multiline_comment|/*&n; *  linux/drivers/ide/ide-probe.c&t;Version 1.11&t;Mar 05, 2003&n; *&n; *  Copyright (C) 1994-1998  Linus Torvalds &amp; authors (see below)&n; */
multiline_comment|/*&n; *  Mostly written by Mark Lord &lt;mlord@pobox.com&gt;&n; *                and Gadi Oxman &lt;gadio@netvision.net.il&gt;&n; *                and Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *&n; *  See linux/MAINTAINERS for address of current maintainer.&n; *&n; * This is the IDE probe module, as evolved from hd.c and ide.c.&n; *&n; * Version 1.00&t;&t;move drive probing code from ide.c to ide-probe.c&n; * Version 1.01&t;&t;fix compilation problem for m68k&n; * Version 1.02&t;&t;increase WAIT_PIDENTIFY to avoid CD-ROM locking at boot&n; *&t;&t;&t; by Andrea Arcangeli&n; * Version 1.03&t;&t;fix for (hwif-&gt;chipset == ide_4drives)&n; * Version 1.04&t;&t;fixed buggy treatments of known flash memory cards&n; *&n; * Version 1.05&t;&t;fix for (hwif-&gt;chipset == ide_pdc4030)&n; *&t;&t;&t;added ide6/7/8/9&n; *&t;&t;&t;allowed for secondary flash card to be detectable&n; *&t;&t;&t; with new flag : drive-&gt;ata_flash : 1;&n; * Version 1.06&t;&t;stream line request queue and prep for cascade project.&n; * Version 1.07&t;&t;max_sect &lt;= 255; slower disks would get behind and&n; * &t;&t;&t;then fall over when they get to 256.&t;Paul G.&n; * Version 1.10&t;&t;Update set for new IDE. drive-&gt;id is now always&n; *&t;&t;&t;valid after probe time even with noprobe&n; */
DECL|macro|REALLY_SLOW_IO
macro_line|#undef REALLY_SLOW_IO&t;&t;/* most systems can safely undef this */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/**&n; *&t;generic_id&t;&t;-&t;add a generic drive id&n; *&t;@drive:&t;drive to make an ID block for&n; *&t;&n; *&t;Add a fake id field to the drive we are passed. This allows&n; *&t;use to skip a ton of NULL checks (which people always miss) &n; *&t;and make drive properties unconditional outside of this file&n; */
DECL|function|generic_id
r_static
r_void
id|generic_id
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|drive-&gt;id-&gt;cyls
op_assign
id|drive-&gt;cyl
suffix:semicolon
id|drive-&gt;id-&gt;heads
op_assign
id|drive-&gt;head
suffix:semicolon
id|drive-&gt;id-&gt;sectors
op_assign
id|drive-&gt;sect
suffix:semicolon
id|drive-&gt;id-&gt;cur_cyls
op_assign
id|drive-&gt;cyl
suffix:semicolon
id|drive-&gt;id-&gt;cur_heads
op_assign
id|drive-&gt;head
suffix:semicolon
id|drive-&gt;id-&gt;cur_sectors
op_assign
id|drive-&gt;sect
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;drive_is_flashcard&t;-&t;check for compact flash&n; *&t;@drive: drive to check&n; *&n; *&t;CompactFlash cards and their brethern pretend to be removable&n; *&t;hard disks, except:&n; * &t;&t;(1) they never have a slave unit, and&n; *&t;&t;(2) they don&squot;t have doorlock mechanisms.&n; *&t;This test catches them, and is invoked elsewhere when setting&n; *&t;appropriate config bits.&n; *&n; *&t;FIXME: This treatment is probably applicable for *all* PCMCIA (PC CARD)&n; *&t;devices, so in linux 2.3.x we should change this to just treat all&n; *&t;PCMCIA  drives this way, and get rid of the model-name tests below&n; *&t;(too big of an interface change for 2.4.x).&n; *&t;At that time, we might also consider parameterizing the timeouts and&n; *&t;retries, since these are MUCH faster than mechanical drives. -M.Lord&n; */
DECL|function|drive_is_flashcard
r_static
r_inline
r_int
id|drive_is_flashcard
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;removable
)paren
(brace
r_if
c_cond
(paren
id|id-&gt;config
op_eq
l_int|0x848a
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* CompactFlash */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;KODAK ATA_FLASH&quot;
comma
l_int|15
)paren
multiline_comment|/* Kodak */
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;Hitachi CV&quot;
comma
l_int|10
)paren
multiline_comment|/* Hitachi */
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;SunDisk SDCFB&quot;
comma
l_int|13
)paren
multiline_comment|/* old SanDisk */
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;SanDisk SDCFB&quot;
comma
l_int|13
)paren
multiline_comment|/* SanDisk */
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;HAGIWARA HPC&quot;
comma
l_int|12
)paren
multiline_comment|/* Hagiwara */
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;LEXAR ATA_FLASH&quot;
comma
l_int|15
)paren
multiline_comment|/* Lexar */
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;ATA_FLASH&quot;
comma
l_int|9
)paren
)paren
multiline_comment|/* Simple Tech */
(brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* yes, it is a flash memory card */
)brace
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no, it is not a flash memory card */
)brace
multiline_comment|/**&n; *&t;do_identify&t;-&t;identify a drive&n; *&t;@drive: drive to identify &n; *&t;@cmd: command used&n; *&n; *&t;Called when we have issued a drive identify command to&n; *&t;read and parse the results. This function is run with&n; *&t;interrupts disabled. &n; */
DECL|function|do_identify
r_static
r_inline
r_void
id|do_identify
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|cmd
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|bswap
op_assign
l_int|1
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
suffix:semicolon
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
multiline_comment|/* read 512 bytes of id info */
id|hwif
op_member_access_from_pointer
id|ata_input_data
c_func
(paren
id|drive
comma
id|id
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|drive-&gt;id_read
op_assign
l_int|1
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|ide_fix_driveid
c_func
(paren
id|id
)paren
suffix:semicolon
macro_line|#if defined (CONFIG_SCSI_EATA_DMA) || defined (CONFIG_SCSI_EATA_PIO) || defined (CONFIG_SCSI_EATA)
multiline_comment|/*&n;&t; * EATA SCSI controllers do a hardware ATA emulation:&n;&t; * Ignore them if there is a driver for them available.&n;&t; */
r_if
c_cond
(paren
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;P&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;M&squot;
)paren
op_logical_or
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;S&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;K&squot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: EATA SCSI HBA %.10s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|id-&gt;model
)paren
suffix:semicolon
r_goto
id|err_misc
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SCSI_EATA_DMA || CONFIG_SCSI_EATA_PIO */
multiline_comment|/*&n;&t; *  WIN_IDENTIFY returns little-endian info,&n;&t; *  WIN_PIDENTIFY *usually* returns little-endian info.&n;&t; */
r_if
c_cond
(paren
id|cmd
op_eq
id|WIN_PIDENTIFY
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;N&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;E&squot;
)paren
multiline_comment|/* NEC */
op_logical_or
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;F&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;X&squot;
)paren
multiline_comment|/* Mitsumi */
op_logical_or
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;P&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;i&squot;
)paren
)paren
multiline_comment|/* Pioneer */
multiline_comment|/* Vertos drives may still be weird */
id|bswap
op_xor_assign
l_int|1
suffix:semicolon
)brace
id|ide_fixstring
c_func
(paren
id|id-&gt;model
comma
r_sizeof
(paren
id|id-&gt;model
)paren
comma
id|bswap
)paren
suffix:semicolon
id|ide_fixstring
c_func
(paren
id|id-&gt;fw_rev
comma
r_sizeof
(paren
id|id-&gt;fw_rev
)paren
comma
id|bswap
)paren
suffix:semicolon
id|ide_fixstring
c_func
(paren
id|id-&gt;serial_no
comma
r_sizeof
(paren
id|id-&gt;serial_no
)paren
comma
id|bswap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;E X A B Y T E N E S T&quot;
)paren
)paren
r_goto
id|err_misc
suffix:semicolon
multiline_comment|/* we depend on this a lot! */
id|id-&gt;model
(braket
r_sizeof
(paren
id|id-&gt;model
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s, &quot;
comma
id|drive-&gt;name
comma
id|id-&gt;model
)paren
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;dead
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Check for an ATAPI device&n;&t; */
r_if
c_cond
(paren
id|cmd
op_eq
id|WIN_PIDENTIFY
)paren
(brace
id|u8
id|type
op_assign
(paren
id|id-&gt;config
op_rshift
l_int|8
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ATAPI &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|ide_floppy
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;CD-ROM&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;oppy&quot;
)paren
op_logical_and
op_logical_neg
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;poyp&quot;
)paren
op_logical_and
op_logical_neg
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;ZIP&quot;
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;cdrom or floppy?, assuming &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_cdrom
)paren
(brace
id|printk
(paren
l_string|&quot;FLOPPY&quot;
)paren
suffix:semicolon
id|drive-&gt;removable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Early cdrom models used zero */
id|type
op_assign
id|ide_cdrom
suffix:semicolon
r_case
id|ide_cdrom
suffix:colon
id|drive-&gt;removable
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_PPC
multiline_comment|/* kludge for Apple PowerBook internal zip */
r_if
c_cond
(paren
op_logical_neg
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;CD-ROM&quot;
)paren
op_logical_and
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;ZIP&quot;
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;FLOPPY&quot;
)paren
suffix:semicolon
id|type
op_assign
id|ide_floppy
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|printk
(paren
l_string|&quot;CD/DVD-ROM&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ide_tape
suffix:colon
id|printk
(paren
l_string|&quot;TAPE&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ide_optical
suffix:colon
id|printk
(paren
l_string|&quot;OPTICAL&quot;
)paren
suffix:semicolon
id|drive-&gt;removable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UNKNOWN (type %d)&quot;
comma
id|type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot; drive&bslash;n&quot;
)paren
suffix:semicolon
id|drive-&gt;media
op_assign
id|type
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Not an ATAPI device: looks like a &quot;regular&quot; hard disk&n;&t; */
r_if
c_cond
(paren
id|id-&gt;config
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
id|drive-&gt;removable
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|drive_is_flashcard
c_func
(paren
id|drive
)paren
)paren
id|drive-&gt;is_flash
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;media
op_assign
id|ide_disk
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s DISK drive&bslash;n&quot;
comma
(paren
id|drive-&gt;is_flash
)paren
ques
c_cond
l_string|&quot;CFA&quot;
suffix:colon
l_string|&quot;ATA&quot;
)paren
suffix:semicolon
id|QUIRK_LIST
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
id|err_misc
suffix:colon
id|kfree
c_func
(paren
id|id
)paren
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;actual_try_to_identify&t;-&t;send ata/atapi identify&n; *&t;@drive: drive to identify&n; *&t;@cmd: command to use&n; *&n; *&t;try_to_identify() sends an ATA(PI) IDENTIFY request to a drive&n; *&t;and waits for a response.  It also monitors irqs while this is&n; *&t;happening, in hope of automatically determining which one is&n; *&t;being used by the interface.&n; *&n; *&t;Returns:&t;0  device was identified&n; *&t;&t;&t;1  device timed-out (no response to identify request)&n; *&t;&t;&t;2  device aborted the command (refused to identify itself)&n; */
DECL|function|actual_try_to_identify
r_static
r_int
id|actual_try_to_identify
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|cmd
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
r_int
id|hd_status
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|u8
id|s
op_assign
l_int|0
comma
id|a
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* take a deep breath */
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
(brace
id|a
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ALTSTATUS_REG
)paren
suffix:semicolon
id|s
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a
op_xor
id|s
)paren
op_amp
op_complement
id|INDEX_STAT
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: probing with STATUS(0x%02x) instead of &quot;
l_string|&quot;ALTSTATUS(0x%02x)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|s
comma
id|a
)paren
suffix:semicolon
multiline_comment|/* ancient Seagate drives, broken interfaces */
id|hd_status
op_assign
id|IDE_STATUS_REG
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* use non-intrusive polling */
id|hd_status
op_assign
id|IDE_ALTSTATUS_REG
suffix:semicolon
)brace
)brace
r_else
id|hd_status
op_assign
id|IDE_STATUS_REG
suffix:semicolon
multiline_comment|/* set features register for atapi&n;&t; * identify command to be sure of reply&n;&t; */
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|WIN_PIDENTIFY
)paren
)paren
multiline_comment|/* disable dma &amp; overlap */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
multiline_comment|/* ask drive for ID */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|cmd
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|timeout
op_assign
(paren
(paren
id|cmd
op_eq
id|WIN_IDENTIFY
)paren
ques
c_cond
id|WAIT_WORSTCASE
suffix:colon
id|WAIT_PIDENTIFY
)paren
op_div
l_int|2
suffix:semicolon
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
multiline_comment|/* drive timed-out */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* give drive a breather */
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hd_status
)paren
)paren
op_amp
id|BUSY_STAT
)paren
suffix:semicolon
multiline_comment|/* wait for IRQ and DRQ_STAT */
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
comma
id|DRQ_STAT
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* local CPU only; some systems need this */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* drive returned ID */
id|do_identify
c_func
(paren
id|drive
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* drive responded with ID */
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear drive IRQ */
(paren
r_void
)paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* drive refused ID */
id|rc
op_assign
l_int|2
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;try_to_identify&t;-&t;try to identify a drive&n; *&t;@drive: drive to probe&n; *&t;@cmd: command to use&n; *&n; *&t;Issue the identify command and then do IRQ probing to&n; *&t;complete the identification when needed by finding the&n; *&t;IRQ the drive is attached to&n; */
DECL|function|try_to_identify
r_static
r_int
id|try_to_identify
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|cmd
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|autoprobe
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|cookie
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Disable device irq unless we need to&n;&t; * probe for it. Otherwise we&squot;ll get spurious&n;&t; * interrupts during the identify-phase that&n;&t; * the irq handler isn&squot;t expecting.&n;&t; */
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
(brace
id|u8
id|ctl
op_assign
id|drive-&gt;ctl
op_or
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;irq
)paren
(brace
id|autoprobe
op_assign
l_int|1
suffix:semicolon
id|cookie
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* enable device irq */
id|ctl
op_and_assign
op_complement
l_int|2
suffix:semicolon
)brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
)brace
id|retval
op_assign
id|actual_try_to_identify
c_func
(paren
id|drive
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|autoprobe
)paren
(brace
r_int
id|irq
suffix:semicolon
multiline_comment|/* mask device irq */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|2
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear drive IRQ */
(paren
r_void
)paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|irq
op_assign
id|probe_irq_off
c_func
(paren
id|cookie
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;irq
)paren
(brace
r_if
c_cond
(paren
id|irq
OG
l_int|0
)paren
(brace
id|hwif-&gt;irq
op_assign
id|irq
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Mmmm.. multiple IRQs..&n;&t;&t;&t;&t; * don&squot;t know which was ours&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: IRQ probe failed (0x%lx)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|cookie
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;do_probe&t;&t;-&t;probe an IDE device&n; *&t;@drive: drive to probe&n; *&t;@cmd: command to use&n; *&n; *&t;do_probe() has the difficult job of finding a drive if it exists,&n; *&t;without getting hung up if it doesn&squot;t exist, without trampling on&n; *&t;ethernet cards, and without leaving any IRQs dangling to haunt us later.&n; *&n; *&t;If a drive is &quot;known&quot; to exist (from CMOS or kernel parameters),&n; *&t;but does not respond right away, the probe will &quot;hang in there&quot;&n; *&t;for the maximum wait time (about 30 seconds), otherwise it will&n; *&t;exit much more quickly.&n; *&n; * Returns:&t;0  device was identified&n; *&t;&t;1  device timed-out (no response to identify request)&n; *&t;&t;2  device aborted the command (refused to identify itself)&n; *&t;&t;3  bad status from device (possible for ATAPI drives)&n; *&t;&t;4  probe was not attempted because failure was obvious&n; */
DECL|function|do_probe
r_static
r_int
id|do_probe
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|cmd
)paren
(brace
r_int
id|rc
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
)paren
(brace
multiline_comment|/* avoid waiting for inappropriate probes */
r_if
c_cond
(paren
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
op_logical_and
(paren
id|cmd
op_eq
id|WIN_IDENTIFY
)paren
)paren
r_return
l_int|4
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;probing for %s: present=%d, media=%d, probetype=%s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;present
comma
id|drive-&gt;media
comma
(paren
id|cmd
op_eq
id|WIN_IDENTIFY
)paren
ques
c_cond
l_string|&quot;ATA&quot;
suffix:colon
l_string|&quot;ATAPI&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* needed for some systems&n;&t; * (e.g. crw9624 as drive0 with disk as slave)&n;&t; */
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|SELECT_DRIVE
c_func
(paren
id|drive
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SELECT_REG
)paren
op_ne
id|drive-&gt;select.all
op_logical_and
op_logical_neg
id|drive-&gt;present
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
op_ne
l_int|0
)paren
(brace
multiline_comment|/* exit with drive0 selected */
id|SELECT_DRIVE
c_func
(paren
op_amp
id|hwif-&gt;drives
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* allow BUSY_STAT to assert &amp; clear */
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
multiline_comment|/* no i/f present: mmm.. this should be a 4 -ml */
r_return
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
comma
id|READY_STAT
comma
id|BUSY_STAT
)paren
op_logical_or
id|drive-&gt;present
op_logical_or
id|cmd
op_eq
id|WIN_PIDENTIFY
)paren
(brace
multiline_comment|/* send cmd and wait */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|try_to_identify
c_func
(paren
id|drive
comma
id|cmd
)paren
)paren
)paren
(brace
multiline_comment|/* failed: try again */
id|rc
op_assign
id|try_to_identify
c_func
(paren
id|drive
comma
id|cmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
op_eq
(paren
id|BUSY_STAT
op_or
id|READY_STAT
)paren
)paren
r_return
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|1
op_logical_and
id|cmd
op_eq
id|WIN_PIDENTIFY
)paren
op_logical_and
(paren
(paren
id|drive-&gt;autotune
op_eq
id|IDE_TUNE_DEFAULT
)paren
op_logical_or
(paren
id|drive-&gt;autotune
op_eq
id|IDE_TUNE_AUTO
)paren
)paren
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: no response (status = 0x%02x), &quot;
l_string|&quot;resetting drive&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|WIN_SRST
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
op_plus
id|WAIT_WORSTCASE
)paren
)paren
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|rc
op_assign
id|try_to_identify
c_func
(paren
id|drive
comma
id|cmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: no response (status = 0x%02x)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
suffix:semicolon
multiline_comment|/* ensure drive irq is clear */
(paren
r_void
)paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* not present or maybe ATAPI */
id|rc
op_assign
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
op_ne
l_int|0
)paren
(brace
multiline_comment|/* exit with drive0 selected */
id|SELECT_DRIVE
c_func
(paren
op_amp
id|hwif-&gt;drives
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* ensure drive irq is clear */
(paren
r_void
)paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; */
DECL|function|enable_nest
r_static
r_void
id|enable_nest
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: enabling %s -- &quot;
comma
id|hwif-&gt;name
comma
id|drive-&gt;id-&gt;model
)paren
suffix:semicolon
id|SELECT_DRIVE
c_func
(paren
id|drive
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|EXABYTE_ENABLE_NEST
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;failed (timeout)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
op_amp
id|BUSY_STAT
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
comma
l_int|0
comma
id|BAD_STAT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;failed (status = 0x%02x)&bslash;n&quot;
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;success&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* if !(success||timed-out) */
r_if
c_cond
(paren
id|do_probe
c_func
(paren
id|drive
comma
id|WIN_IDENTIFY
)paren
op_ge
l_int|2
)paren
(brace
multiline_comment|/* look for ATAPI device */
(paren
r_void
)paren
id|do_probe
c_func
(paren
id|drive
comma
id|WIN_PIDENTIFY
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;probe_for_drives&t;-&t;upper level drive probe&n; *&t;@drive: drive to probe for&n; *&n; *&t;probe_for_drive() tests for existence of a given drive using do_probe()&n; *&t;and presents things to the user as needed.&n; *&n; *&t;Returns:&t;0  no device was found&n; *&t;&t;&t;1  device was found (note: drive-&gt;present might&n; *&t;&t;&t;   still be 0)&n; */
DECL|function|probe_for_drive
r_static
r_inline
id|u8
id|probe_for_drive
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
multiline_comment|/*&n;&t; *&t;In order to keep things simple we have an id&n;&t; *&t;block for all drives at all times. If the device&n;&t; *&t;is pre ATA or refuses ATA/ATAPI identify we&n;&t; *&t;will add faked data to this.&n;&t; *&n;&t; *&t;Also note that 0 everywhere means &quot;can&squot;t do X&quot;&n;&t; */
id|drive-&gt;id
op_assign
id|kmalloc
c_func
(paren
id|SECTOR_WORDS
op_star
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|drive-&gt;id_read
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide: out of memory for id data.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|drive-&gt;id
comma
l_int|0
comma
id|SECTOR_WORDS
op_star
l_int|4
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;UNKNOWN&quot;
)paren
suffix:semicolon
multiline_comment|/* skip probing? */
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;noprobe
)paren
(brace
multiline_comment|/* if !(success||timed-out) */
r_if
c_cond
(paren
id|do_probe
c_func
(paren
id|drive
comma
id|WIN_IDENTIFY
)paren
op_ge
l_int|2
)paren
(brace
multiline_comment|/* look for ATAPI device */
(paren
r_void
)paren
id|do_probe
c_func
(paren
id|drive
comma
id|WIN_PIDENTIFY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;E X A B Y T E N E S T&quot;
)paren
)paren
id|enable_nest
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
multiline_comment|/* drive not found */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* identification failed? */
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;id_read
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: non-IDE drive, CHS=%d/%d/%d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;cyl
comma
id|drive-&gt;head
comma
id|drive-&gt;sect
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_cdrom
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: ATAPI cdrom (?)&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* nuke it */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Unknown device on bus refused identification. Ignoring.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* drive was found */
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The drive wasn&squot;t being helpful. Add generic info only */
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;id_read
)paren
(brace
id|generic_id
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_return
id|drive-&gt;present
suffix:semicolon
)brace
DECL|function|hwif_release_dev
r_static
r_void
id|hwif_release_dev
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|container_of
c_func
(paren
id|dev
comma
id|ide_hwif_t
comma
id|gendev
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|hwif-&gt;gendev_rel_sem
)paren
suffix:semicolon
)brace
DECL|function|hwif_register
r_static
r_void
id|hwif_register
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
multiline_comment|/* register with global device tree */
id|strlcpy
c_func
(paren
id|hwif-&gt;gendev.bus_id
comma
id|hwif-&gt;name
comma
id|BUS_ID_SIZE
)paren
suffix:semicolon
id|hwif-&gt;gendev.driver_data
op_assign
id|hwif
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;gendev.parent
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;pci_dev
)paren
id|hwif-&gt;gendev.parent
op_assign
op_amp
id|hwif-&gt;pci_dev-&gt;dev
suffix:semicolon
r_else
multiline_comment|/* Would like to do = &amp;device_legacy */
id|hwif-&gt;gendev.parent
op_assign
l_int|NULL
suffix:semicolon
)brace
id|hwif-&gt;gendev.release
op_assign
id|hwif_release_dev
suffix:semicolon
id|device_register
c_func
(paren
op_amp
id|hwif-&gt;gendev
)paren
suffix:semicolon
)brace
DECL|function|wait_hwif_ready
r_static
r_int
id|wait_hwif_ready
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_int
id|rc
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Probing IDE interface %s...&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Let HW settle down a bit from whatever init state we&n;&t; * come from */
id|mdelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Wait for BSY bit to go away, spec timeout is 30 seconds,&n;&t; * I know of at least one disk who takes 31 seconds, I use 35&n;&t; * here to be safe&n;&t; */
id|rc
op_assign
id|ide_wait_not_busy
c_func
(paren
id|hwif
comma
l_int|35000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* Now make sure both master &amp; slave are ready */
id|SELECT_DRIVE
c_func
(paren
op_amp
id|hwif-&gt;drives
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|8
comma
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|rc
op_assign
id|ide_wait_not_busy
c_func
(paren
id|hwif
comma
l_int|10000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|SELECT_DRIVE
c_func
(paren
op_amp
id|hwif-&gt;drives
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|8
comma
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|rc
op_assign
id|ide_wait_not_busy
c_func
(paren
id|hwif
comma
l_int|10000
)paren
suffix:semicolon
multiline_comment|/* Exit function with master reselected (let&squot;s be sane) */
id|SELECT_DRIVE
c_func
(paren
op_amp
id|hwif-&gt;drives
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_undecoded_slave&t;-&t;look for bad CF adapters&n; *&t;@hwif: interface&n; *&n; *&t;Analyse the drives on the interface and attempt to decide if we&n; *&t;have the same drive viewed twice. This occurs with crap CF adapters&n; *&t;and PCMCIA sometimes.&n; */
DECL|function|ide_undecoded_slave
r_void
id|ide_undecoded_slave
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
id|ide_drive_t
op_star
id|drive0
op_assign
op_amp
id|hwif-&gt;drives
(braket
l_int|0
)braket
suffix:semicolon
id|ide_drive_t
op_star
id|drive1
op_assign
op_amp
id|hwif-&gt;drives
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive0-&gt;present
op_eq
l_int|0
op_logical_or
id|drive1-&gt;present
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* If the models don&squot;t match they are not the same product */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|drive0-&gt;id-&gt;model
comma
id|drive1-&gt;id-&gt;model
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Serial numbers do not match */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|drive0-&gt;id-&gt;serial_no
comma
id|drive1-&gt;id-&gt;serial_no
comma
l_int|20
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* No serial number, thankfully very rare for CF */
r_if
c_cond
(paren
id|drive0-&gt;id-&gt;serial_no
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Appears to be an IDE flash adapter with decode bugs */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide-probe: ignoring undecoded slave&bslash;n&quot;
)paren
suffix:semicolon
id|drive1-&gt;present
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|ide_undecoded_slave
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_undecoded_slave
)paren
suffix:semicolon
multiline_comment|/*&n; * This routine only knows how to look for drive units 0 and 1&n; * on an interface, so any setting of MAX_DRIVES &gt; 2 won&squot;t work here.&n; */
DECL|function|probe_hwif
r_static
r_void
id|probe_hwif
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_int
r_int
id|unit
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|irqd
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;noprobe
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hwif-&gt;chipset
op_ne
id|ide_4drives
op_logical_or
op_logical_neg
id|hwif-&gt;mate
op_logical_or
op_logical_neg
id|hwif-&gt;mate-&gt;present
)paren
op_logical_and
(paren
id|ide_hwif_request_regions
c_func
(paren
id|hwif
)paren
)paren
)paren
(brace
id|u16
id|msgout
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
)paren
(brace
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ERROR, PORTS ALREADY IN USE&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|msgout
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|msgout
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ports already in use, skipping probe&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must always disable IRQ, as probe_for_drive will assert IRQ, but&n;&t; * we&squot;ll install our IRQ driver much later...&n;&t; */
id|irqd
op_assign
id|hwif-&gt;irq
suffix:semicolon
r_if
c_cond
(paren
id|irqd
)paren
id|disable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
id|local_irq_set
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* This is needed on some PPCs and a bunch of BIOS-less embedded&n;&t; * platforms. Typical cases are:&n;&t; * &n;&t; *  - The firmware hard reset the disk before booting the kernel,&n;&t; *    the drive is still doing it&squot;s poweron-reset sequence, that&n;&t; *    can take up to 30 seconds&n;&t; *  - The firmware does nothing (or no firmware), the device is&n;&t; *    still in POST state (same as above actually).&n;&t; *  - Some CD/DVD/Writer combo drives tend to drive the bus during&n;&t; *    their reset sequence even when they are non-selected slave&n;&t; *    devices, thus preventing discovery of the main HD&n;&t; *    &n;&t; *  Doing this wait-for-busy should not harm any existing configuration&n;&t; *  (at least things won&squot;t be worse than what current code does, that&n;&t; *  is blindly go &amp; talk to the drive) and fix some issues like the&n;&t; *  above.&n;&t; *  &n;&t; *  BenH.&n;&t; */
r_if
c_cond
(paren
id|wait_hwif_ready
c_func
(paren
id|hwif
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Wait for ready failed before probe !&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Second drive should only exist if first drive was found,&n;&t; * but a lot of cdrom drives are configured as single slaves.&n;&t; */
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
id|drive-&gt;dn
op_assign
(paren
id|hwif-&gt;channel
ques
c_cond
l_int|2
suffix:colon
l_int|0
)paren
op_plus
id|unit
suffix:semicolon
(paren
r_void
)paren
id|probe_for_drive
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
op_logical_and
op_logical_neg
id|hwif-&gt;present
)paren
(brace
id|hwif-&gt;present
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_ne
id|ide_4drives
op_logical_or
op_logical_neg
id|hwif-&gt;mate
op_logical_or
op_logical_neg
id|hwif-&gt;mate-&gt;present
)paren
(brace
id|hwif_register
c_func
(paren
id|hwif
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
op_logical_and
id|hwif-&gt;reset
)paren
(brace
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
id|u8
id|stat
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: reset&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|12
comma
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|8
comma
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
suffix:semicolon
r_do
(brace
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|time_after
c_func
(paren
id|timeout
comma
id|jiffies
)paren
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Use cached IRQ number. It might be (and is...) changed by probe&n;&t; * code above&n;&t; */
r_if
c_cond
(paren
id|irqd
)paren
id|enable_irq
c_func
(paren
id|irqd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;present
)paren
(brace
id|ide_hwif_release_regions
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;tuneproc
op_ne
l_int|NULL
op_logical_and
id|drive-&gt;autotune
op_eq
id|IDE_TUNE_AUTO
)paren
multiline_comment|/* auto-tune PIO mode */
id|hwif
op_member_access_from_pointer
id|tuneproc
c_func
(paren
id|drive
comma
l_int|255
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * MAJOR HACK BARF :-/&n;&t;&t;&t; *&n;&t;&t;&t; * FIXME: chipsets own this cruft!&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * Move here to prevent module loading clashing.&n;&t;&t;&t; */
singleline_comment|//&t;&t;drive-&gt;autodma = hwif-&gt;autodma;
r_if
c_cond
(paren
(paren
id|hwif-&gt;ide_dma_check
)paren
op_logical_and
(paren
(paren
id|drive-&gt;autotune
op_eq
id|IDE_TUNE_DEFAULT
)paren
op_logical_or
(paren
id|drive-&gt;autotune
op_eq
id|IDE_TUNE_AUTO
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Force DMAing for the beginning of the check.&n;&t;&t;&t;&t; * Some chipsets appear to do interesting&n;&t;&t;&t;&t; * things, if not checked and cleared.&n;&t;&t;&t;&t; *   PARANOIA!!!&n;&t;&t;&t;&t; */
id|hwif
op_member_access_from_pointer
id|ide_dma_off_quietly
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IDEDMA_ONLYDISK
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
macro_line|#endif
id|hwif
op_member_access_from_pointer
id|ide_dma_check
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_static
r_int
id|hwif_init
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
suffix:semicolon
DECL|function|probe_hwif_init_with_fixup
r_int
id|probe_hwif_init_with_fixup
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_void
(paren
op_star
id|fixup
)paren
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
)paren
(brace
id|probe_hwif
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fixup
)paren
id|fixup
c_func
(paren
id|hwif
)paren
suffix:semicolon
id|hwif_init
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;present
)paren
(brace
id|u16
id|unit
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
multiline_comment|/* For now don&squot;t attach absent drives, we may&n;&t;&t;&t;   want them on default or a new &quot;empty&quot; class&n;&t;&t;&t;   for hotplug reprobing ? */
r_if
c_cond
(paren
id|drive-&gt;present
)paren
(brace
id|ata_attach
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|probe_hwif_init
r_int
id|probe_hwif_init
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_return
id|probe_hwif_init_with_fixup
c_func
(paren
id|hwif
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|variable|probe_hwif_init
id|EXPORT_SYMBOL
c_func
(paren
id|probe_hwif_init
)paren
suffix:semicolon
macro_line|#if MAX_HWIFS &gt; 1
multiline_comment|/*&n; * save_match() is used to simplify logic in init_irq() below.&n; *&n; * A loophole here is that we may not know about a particular&n; * hwif&squot;s irq until after that hwif is actually probed/initialized..&n; * This could be a problem for the case where an hwif is on a&n; * dual interface that requires serialization (eg. cmd640) and another&n; * hwif using one of the same irqs is initialized beforehand.&n; *&n; * This routine detects and reports such situations, but does not fix them.&n; */
DECL|function|save_match
r_static
r_void
id|save_match
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
comma
id|ide_hwif_t
op_star
r_new
comma
id|ide_hwif_t
op_star
op_star
id|match
)paren
(brace
id|ide_hwif_t
op_star
id|m
op_assign
op_star
id|match
suffix:semicolon
r_if
c_cond
(paren
id|m
op_logical_and
id|m-&gt;hwgroup
op_logical_and
id|m-&gt;hwgroup
op_ne
r_new
op_member_access_from_pointer
id|hwgroup
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
r_new
op_member_access_from_pointer
id|hwgroup
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: potential irq problem with %s and %s&bslash;n&quot;
comma
id|hwif-&gt;name
comma
r_new
op_member_access_from_pointer
id|name
comma
id|m-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|m
op_logical_or
id|m-&gt;irq
op_ne
id|hwif-&gt;irq
)paren
multiline_comment|/* don&squot;t undo a prior perfect match */
op_star
id|match
op_assign
r_new
suffix:semicolon
)brace
macro_line|#endif /* MAX_HWIFS &gt; 1 */
multiline_comment|/*&n; * init request queue&n; */
DECL|function|ide_init_queue
r_static
r_int
id|ide_init_queue
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|request_queue_t
op_star
id|q
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|max_sectors
op_assign
l_int|256
suffix:semicolon
r_int
id|max_sg_entries
op_assign
id|PRD_ENTRIES
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Our default set up assumes the normal IDE case,&n;&t; *&t;that is 64K segmenting, standard PRD setup&n;&t; *&t;and LBA28. Some drivers then impose their own&n;&t; *&t;limits and LBA48 we could raise it but as yet&n;&t; *&t;do not.&n;&t; */
id|q
op_assign
id|blk_init_queue
c_func
(paren
id|do_ide_request
comma
op_amp
id|ide_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_return
l_int|1
suffix:semicolon
id|q-&gt;queuedata
op_assign
id|drive
suffix:semicolon
id|blk_queue_segment_boundary
c_func
(paren
id|q
comma
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;rqsize
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;no_lba48
op_logical_or
id|hwif-&gt;no_lba48_dma
)paren
id|hwif-&gt;rqsize
op_assign
l_int|256
suffix:semicolon
r_else
id|hwif-&gt;rqsize
op_assign
l_int|65536
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwif-&gt;rqsize
OL
id|max_sectors
)paren
id|max_sectors
op_assign
id|hwif-&gt;rqsize
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|q
comma
id|max_sectors
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
multiline_comment|/* When we have an IOMMU, we may have a problem where pci_map_sg()&n;&t; * creates segments that don&squot;t completely match our boundary&n;&t; * requirements and thus need to be broken up again. Because it&n;&t; * doesn&squot;t align properly either, we may actually have to break up&n;&t; * to more segments than what was we got in the first place, a max&n;&t; * worst case is twice as many.&n;&t; * This will be fixed once we teach pci_map_sg() about our boundary&n;&t; * requirements, hopefully soon. *FIXME*&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PCI_DMA_BUS_IS_PHYS
)paren
id|max_sg_entries
op_rshift_assign
l_int|1
suffix:semicolon
macro_line|#endif /* CONFIG_PCI */
id|blk_queue_max_hw_segments
c_func
(paren
id|q
comma
id|max_sg_entries
)paren
suffix:semicolon
id|blk_queue_max_phys_segments
c_func
(paren
id|q
comma
id|max_sg_entries
)paren
suffix:semicolon
multiline_comment|/* assign drive and gendisk queue */
id|drive-&gt;queue
op_assign
id|q
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;disk
)paren
id|drive-&gt;disk-&gt;queue
op_assign
id|drive-&gt;queue
suffix:semicolon
multiline_comment|/* needs drive-&gt;queue to be set */
id|ide_toggle_bounce
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* enable led activity for disk drives only */
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
op_logical_and
id|hwif-&gt;led_act
)paren
id|blk_queue_activity_fn
c_func
(paren
id|q
comma
id|hwif-&gt;led_act
comma
id|drive
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine sets up the irq for an ide interface, and creates a new&n; * hwgroup for the irq/hwif if none was previously assigned.&n; *&n; * Much of the code is for correctly detecting/handling irq sharing&n; * and irq serialization situations.  This is somewhat complex because&n; * it handles static as well as dynamic (PCMCIA) IDE interfaces.&n; *&n; * The SA_INTERRUPT in sa_flags means ide_intr() is always entered with&n; * interrupts completely disabled.  This can be bad for interrupt latency,&n; * but anything else has led to problems on some machines.  We re-enable&n; * interrupts as much as we can safely do in most places.&n; */
DECL|function|init_irq
r_static
r_int
id|init_irq
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_int
r_int
id|index
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
suffix:semicolon
id|ide_hwif_t
op_star
id|match
op_assign
l_int|NULL
suffix:semicolon
id|BUG_ON
c_func
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ide_cfg_sem
)paren
suffix:semicolon
id|hwif-&gt;hwgroup
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if MAX_HWIFS &gt; 1
multiline_comment|/*&n;&t; * Group up with any other hwifs that share our irq(s).&n;&t; */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
id|index
op_increment
)paren
(brace
id|ide_hwif_t
op_star
id|h
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;hwgroup
)paren
(brace
multiline_comment|/* scan only initialized hwif&squot;s */
r_if
c_cond
(paren
id|hwif-&gt;irq
op_eq
id|h-&gt;irq
)paren
(brace
id|hwif-&gt;sharing_irq
op_assign
id|h-&gt;sharing_irq
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_ne
id|ide_pci
op_logical_or
id|h-&gt;chipset
op_ne
id|ide_pci
)paren
(brace
id|save_match
c_func
(paren
id|hwif
comma
id|h
comma
op_amp
id|match
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hwif-&gt;serialized
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;mate
op_logical_and
id|hwif-&gt;mate-&gt;irq
op_eq
id|h-&gt;irq
)paren
id|save_match
c_func
(paren
id|hwif
comma
id|h
comma
op_amp
id|match
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|h-&gt;serialized
)paren
(brace
r_if
c_cond
(paren
id|h-&gt;mate
op_logical_and
id|hwif-&gt;irq
op_eq
id|h-&gt;mate-&gt;irq
)paren
id|save_match
c_func
(paren
id|hwif
comma
id|h
comma
op_amp
id|match
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* MAX_HWIFS &gt; 1 */
multiline_comment|/*&n;&t; * If we are still without a hwgroup, then form a new one&n;&t; */
r_if
c_cond
(paren
id|match
)paren
(brace
id|hwgroup
op_assign
id|match-&gt;hwgroup
suffix:semicolon
id|hwif-&gt;hwgroup
op_assign
id|hwgroup
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Link us into the hwgroup.&n;&t;&t; * This must be done early, do ensure that unexpected_intr&n;&t;&t; * can find the hwif and prevent irq storms.&n;&t;&t; * No drives are attached to the new hwif, choose_drive&n;&t;&t; * can&squot;t do anything stupid (yet).&n;&t;&t; * Add ourself as the 2nd entry to the hwgroup-&gt;hwif&n;&t;&t; * linked list, the first entry is the hwif that owns&n;&t;&t; * hwgroup-&gt;handler - do not change that.&n;&t;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|hwif-&gt;next
op_assign
id|hwgroup-&gt;hwif-&gt;next
suffix:semicolon
id|hwgroup-&gt;hwif-&gt;next
op_assign
id|hwif
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|hwgroup
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ide_hwgroup_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwgroup
)paren
r_goto
id|out_up
suffix:semicolon
id|hwif-&gt;hwgroup
op_assign
id|hwgroup
suffix:semicolon
id|memset
c_func
(paren
id|hwgroup
comma
l_int|0
comma
r_sizeof
(paren
id|ide_hwgroup_t
)paren
)paren
suffix:semicolon
id|hwgroup-&gt;hwif
op_assign
id|hwif-&gt;next
op_assign
id|hwif
suffix:semicolon
id|hwgroup-&gt;rq
op_assign
l_int|NULL
suffix:semicolon
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
id|hwgroup-&gt;drive
op_assign
l_int|NULL
suffix:semicolon
id|hwgroup-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|hwgroup-&gt;timer
)paren
suffix:semicolon
id|hwgroup-&gt;timer.function
op_assign
op_amp
id|ide_timer_expiry
suffix:semicolon
id|hwgroup-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|hwgroup
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate the irq, if not already obtained for another hwif&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|match
op_logical_or
id|match-&gt;irq
op_ne
id|hwif-&gt;irq
)paren
(brace
r_int
id|sa
op_assign
id|SA_INTERRUPT
suffix:semicolon
macro_line|#if defined(__mc68000__) || defined(CONFIG_APUS)
id|sa
op_assign
id|SA_SHIRQ
suffix:semicolon
macro_line|#endif /* __mc68000__ || CONFIG_APUS */
r_if
c_cond
(paren
id|IDE_CHIPSET_IS_PCI
c_func
(paren
id|hwif-&gt;chipset
)paren
)paren
(brace
id|sa
op_assign
id|SA_SHIRQ
suffix:semicolon
macro_line|#ifndef CONFIG_IDEPCI_SHARE_IRQ
id|sa
op_or_assign
id|SA_INTERRUPT
suffix:semicolon
macro_line|#endif /* CONFIG_IDEPCI_SHARE_IRQ */
)brace
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
multiline_comment|/* clear nIEN */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0x08
comma
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|hwif-&gt;irq
comma
op_amp
id|ide_intr
comma
id|sa
comma
id|hwif-&gt;name
comma
id|hwgroup
)paren
)paren
r_goto
id|out_unlink
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For any present drive:&n;&t; * - allocate the block device queue&n;&t; * - link drive into the hwgroup&n;&t; */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|index
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ide_init_queue
c_func
(paren
id|drive
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide: failed to init %s&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwgroup-&gt;drive
)paren
(brace
multiline_comment|/* first drive for hwgroup. */
id|drive-&gt;next
op_assign
id|drive
suffix:semicolon
id|hwgroup-&gt;drive
op_assign
id|drive
suffix:semicolon
id|hwgroup-&gt;hwif
op_assign
id|HWIF
c_func
(paren
id|hwgroup-&gt;drive
)paren
suffix:semicolon
)brace
r_else
(brace
id|drive-&gt;next
op_assign
id|hwgroup-&gt;drive-&gt;next
suffix:semicolon
id|hwgroup-&gt;drive-&gt;next
op_assign
id|drive
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
)brace
macro_line|#if !defined(__mc68000__) &amp;&amp; !defined(CONFIG_APUS) &amp;&amp; !defined(__sparc__)
id|printk
c_func
(paren
l_string|&quot;%s at 0x%03lx-0x%03lx,0x%03lx on irq %d&quot;
comma
id|hwif-&gt;name
comma
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_plus
l_int|7
comma
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
comma
id|hwif-&gt;irq
)paren
suffix:semicolon
macro_line|#elif defined(__sparc__)
id|printk
c_func
(paren
l_string|&quot;%s at 0x%03lx-0x%03lx,0x%03lx on irq %s&quot;
comma
id|hwif-&gt;name
comma
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_plus
l_int|7
comma
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
comma
id|__irq_itoa
c_func
(paren
id|hwif-&gt;irq
)paren
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;%s at 0x%08lx on irq %d&quot;
comma
id|hwif-&gt;name
comma
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
id|hwif-&gt;irq
)paren
suffix:semicolon
macro_line|#endif /* __mc68000__ &amp;&amp; CONFIG_APUS */
r_if
c_cond
(paren
id|match
)paren
id|printk
c_func
(paren
l_string|&quot; (%sed with %s)&quot;
comma
id|hwif-&gt;sharing_irq
ques
c_cond
l_string|&quot;shar&quot;
suffix:colon
l_string|&quot;serializ&quot;
comma
id|match-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ide_cfg_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_unlink
suffix:colon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;next
op_eq
id|hwif
)paren
(brace
id|BUG_ON
c_func
(paren
id|match
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|hwgroup-&gt;hwif
op_ne
id|hwif
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hwgroup
)paren
suffix:semicolon
)brace
r_else
(brace
id|ide_hwif_t
op_star
id|g
suffix:semicolon
id|g
op_assign
id|hwgroup-&gt;hwif
suffix:semicolon
r_while
c_loop
(paren
id|g-&gt;next
op_ne
id|hwif
)paren
id|g
op_assign
id|g-&gt;next
suffix:semicolon
id|g-&gt;next
op_assign
id|hwif-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;hwif
op_eq
id|hwif
)paren
(brace
multiline_comment|/* Impossible. */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Duh. Uninitialized hwif listed as active hwif.&bslash;n&quot;
)paren
suffix:semicolon
id|hwgroup-&gt;hwif
op_assign
id|g
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|hwgroup-&gt;hwif
op_eq
id|hwif
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|out_up
suffix:colon
id|up
c_func
(paren
op_amp
id|ide_cfg_sem
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ata_lock
r_static
r_int
id|ata_lock
c_func
(paren
id|dev_t
id|dev
comma
r_void
op_star
id|data
)paren
(brace
multiline_comment|/* FIXME: we want to pin hwif down */
r_return
l_int|0
suffix:semicolon
)brace
r_extern
id|ide_driver_t
id|idedefault_driver
suffix:semicolon
DECL|function|ata_probe
r_static
r_struct
id|kobject
op_star
id|ata_probe
c_func
(paren
id|dev_t
id|dev
comma
r_int
op_star
id|part
comma
r_void
op_star
id|data
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|data
suffix:semicolon
r_int
id|unit
op_assign
op_star
id|part
op_rshift
id|PARTN_BITS
suffix:semicolon
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;driver
op_eq
op_amp
id|idedefault_driver
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
(paren
r_void
)paren
id|request_module
c_func
(paren
l_string|&quot;ide-disk&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;scsi
)paren
(paren
r_void
)paren
id|request_module
c_func
(paren
l_string|&quot;ide-scsi&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_cdrom
op_logical_or
id|drive-&gt;media
op_eq
id|ide_optical
)paren
(paren
r_void
)paren
id|request_module
c_func
(paren
l_string|&quot;ide-cd&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_tape
)paren
(paren
r_void
)paren
id|request_module
c_func
(paren
l_string|&quot;ide-tape&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_floppy
)paren
(paren
r_void
)paren
id|request_module
c_func
(paren
l_string|&quot;ide-floppy&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive-&gt;driver
op_eq
op_amp
id|idedefault_driver
)paren
r_return
l_int|NULL
suffix:semicolon
op_star
id|part
op_and_assign
(paren
l_int|1
op_lshift
id|PARTN_BITS
)paren
op_minus
l_int|1
suffix:semicolon
r_return
id|get_disk
c_func
(paren
id|drive-&gt;disk
)paren
suffix:semicolon
)brace
DECL|function|alloc_disks
r_static
r_int
id|alloc_disks
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_int
r_int
id|unit
suffix:semicolon
r_struct
id|gendisk
op_star
id|disks
(braket
id|MAX_DRIVES
)braket
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
id|unit
op_increment
)paren
(brace
id|disks
(braket
id|unit
)braket
op_assign
id|alloc_disk
c_func
(paren
l_int|1
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disks
(braket
id|unit
)braket
)paren
r_goto
id|Enomem
suffix:semicolon
)brace
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
op_assign
id|disks
(braket
id|unit
)braket
suffix:semicolon
id|disk-&gt;major
op_assign
id|hwif-&gt;major
suffix:semicolon
id|disk-&gt;first_minor
op_assign
id|unit
op_lshift
id|PARTN_BITS
suffix:semicolon
id|sprintf
c_func
(paren
id|disk-&gt;disk_name
comma
l_string|&quot;hd%c&quot;
comma
l_char|&squot;a&squot;
op_plus
id|hwif-&gt;index
op_star
id|MAX_DRIVES
op_plus
id|unit
)paren
suffix:semicolon
id|disk-&gt;fops
op_assign
id|ide_fops
suffix:semicolon
id|disk-&gt;private_data
op_assign
id|drive
suffix:semicolon
id|drive-&gt;disk
op_assign
id|disk
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|Enomem
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(ide::init_gendisk) Out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|unit
op_decrement
)paren
id|put_disk
c_func
(paren
id|disks
(braket
id|unit
)braket
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|drive_release_dev
r_static
r_void
id|drive_release_dev
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|container_of
c_func
(paren
id|dev
comma
id|ide_drive_t
comma
id|gendev
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|drive-&gt;gendev_rel_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * init_gendisk() (as opposed to ide_geninit) is called for each major device,&n; * after probing for drives, to allocate partition tables and other data&n; * structures needed for the routines in genhd.c.  ide_geninit() gets called&n; * somewhat later, during the partition check.&n; */
DECL|function|init_gendisk
r_static
r_void
id|init_gendisk
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_int
r_int
id|unit
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
id|ide_add_generic_settings
c_func
(paren
id|drive
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|drive-&gt;gendev.bus_id
comma
id|BUS_ID_SIZE
comma
l_string|&quot;%u.%u&quot;
comma
id|hwif-&gt;index
comma
id|unit
)paren
suffix:semicolon
id|drive-&gt;gendev.parent
op_assign
op_amp
id|hwif-&gt;gendev
suffix:semicolon
id|drive-&gt;gendev.bus
op_assign
op_amp
id|ide_bus_type
suffix:semicolon
id|drive-&gt;gendev.driver_data
op_assign
id|drive
suffix:semicolon
id|drive-&gt;gendev.release
op_assign
id|drive_release_dev
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
)paren
(brace
id|device_register
c_func
(paren
op_amp
id|drive-&gt;gendev
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|drive-&gt;devfs_name
comma
l_string|&quot;ide/host%d/bus%d/target%d/lun%d&quot;
comma
(paren
id|hwif-&gt;channel
op_logical_and
id|hwif-&gt;mate
)paren
ques
c_cond
id|hwif-&gt;mate-&gt;index
suffix:colon
id|hwif-&gt;index
comma
id|hwif-&gt;channel
comma
id|unit
comma
id|drive-&gt;lun
)paren
suffix:semicolon
)brace
)brace
id|blk_register_region
c_func
(paren
id|MKDEV
c_func
(paren
id|hwif-&gt;major
comma
l_int|0
)paren
comma
id|MAX_DRIVES
op_lshift
id|PARTN_BITS
comma
id|THIS_MODULE
comma
id|ata_probe
comma
id|ata_lock
comma
id|hwif
)paren
suffix:semicolon
)brace
DECL|function|hwif_init
r_static
r_int
id|hwif_init
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_int
id|old_irq
comma
id|unit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;present
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;irq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hwif-&gt;irq
op_assign
id|ide_default_irq
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DISABLED, NO IRQ&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_return
(paren
id|hwif-&gt;present
op_assign
l_int|0
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_BLK_DEV_HD
r_if
c_cond
(paren
id|hwif-&gt;irq
op_eq
id|HD_IRQ
op_logical_and
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_ne
id|HD_DATA
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: CANNOT SHARE IRQ WITH OLD &quot;
l_string|&quot;HARDDISK DRIVER (hd.c)&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_return
(paren
id|hwif-&gt;present
op_assign
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_HD */
multiline_comment|/* we set it back to 1 if all is ok below */
id|hwif-&gt;present
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|hwif-&gt;major
comma
id|hwif-&gt;name
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;sg_max_nents
)paren
id|hwif-&gt;sg_max_nents
op_assign
id|PRD_ENTRIES
suffix:semicolon
id|hwif-&gt;sg_table
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|scatterlist
)paren
op_star
id|hwif-&gt;sg_max_nents
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;sg_table
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unable to allocate SG table.&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alloc_disks
c_func
(paren
id|hwif
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|init_irq
c_func
(paren
id|hwif
)paren
op_eq
l_int|0
)paren
r_goto
id|done
suffix:semicolon
id|old_irq
op_assign
id|hwif-&gt;irq
suffix:semicolon
multiline_comment|/*&n;&t; *&t;It failed to initialise. Find the default IRQ for &n;&t; *&t;this port and try that.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hwif-&gt;irq
op_assign
id|ide_default_irq
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Disabled unable to get IRQ %d.&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|old_irq
)paren
suffix:semicolon
r_goto
id|out_disks
suffix:semicolon
)brace
r_if
c_cond
(paren
id|init_irq
c_func
(paren
id|hwif
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: probed IRQ %d and default IRQ %d failed.&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|old_irq
comma
id|hwif-&gt;irq
)paren
suffix:semicolon
r_goto
id|out_disks
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: probed IRQ %d failed, using default.&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|hwif-&gt;irq
)paren
suffix:semicolon
id|done
suffix:colon
id|init_gendisk
c_func
(paren
id|hwif
)paren
suffix:semicolon
id|hwif-&gt;present
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* success */
r_return
l_int|1
suffix:semicolon
id|out_disks
suffix:colon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
id|unit
op_increment
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|hwif-&gt;drives
(braket
id|unit
)braket
dot
id|disk
suffix:semicolon
id|hwif-&gt;drives
(braket
id|unit
)braket
dot
id|disk
op_assign
l_int|NULL
suffix:semicolon
id|put_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|unregister_blkdev
c_func
(paren
id|hwif-&gt;major
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ideprobe_init
r_int
id|ideprobe_init
(paren
r_void
)paren
(brace
r_int
r_int
id|index
suffix:semicolon
r_int
id|probe
(braket
id|MAX_HWIFS
)braket
suffix:semicolon
id|memset
c_func
(paren
id|probe
comma
l_int|0
comma
id|MAX_HWIFS
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
id|probe
(braket
id|index
)braket
op_assign
op_logical_neg
id|ide_hwifs
(braket
id|index
)braket
dot
id|present
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
r_if
c_cond
(paren
id|probe
(braket
id|index
)braket
)paren
id|probe_hwif
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|index
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
r_if
c_cond
(paren
id|probe
(braket
id|index
)braket
)paren
id|hwif_init
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|index
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
(brace
r_if
c_cond
(paren
id|probe
(braket
id|index
)braket
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;present
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
op_logical_or
id|hwif-&gt;chipset
op_eq
id|ide_forced
)paren
id|hwif-&gt;chipset
op_assign
id|ide_generic
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
r_if
c_cond
(paren
id|hwif-&gt;drives
(braket
id|unit
)braket
dot
id|present
)paren
id|ata_attach
c_func
(paren
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ideprobe_init
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ideprobe_init
)paren
suffix:semicolon
eof
