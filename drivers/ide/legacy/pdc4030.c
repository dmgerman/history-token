multiline_comment|/*  -*- linux-c -*-&n; *  linux/drivers/ide/legacy/pdc4030.c&t;&t;Version 0.90  May 27, 1999&n; *&n; *  Copyright (C) 1995-2002  Linus Torvalds &amp; authors (see below)&n; */
multiline_comment|/*&n; *  Principal Author/Maintainer:  Peter Denison &lt;promise@pnd-pc.demon.co.uk&gt;&n; *&n; *  This file provides support for the second port and cache of Promise&n; *  IDE interfaces, e.g. DC4030VL, DC4030VL-1 and DC4030VL-2.&n; *&n; *  Thanks are due to Mark Lord for advice and patiently answering stupid&n; *  questions, and all those mugs^H^H^H^Hbrave souls who&squot;ve tested this,&n; *  especially Andre Hedrick.&n; *&n; *  Version 0.01&t;Initial version, #include&squot;d in ide.c rather than&n; *                      compiled separately.&n; *                      Reads use Promise commands, writes as before. Drives&n; *                      on second channel are read-only.&n; *  Version 0.02        Writes working on second channel, reads on both&n; *                      channels. Writes fail under high load. Suspect&n; *&t;&t;&t;transfers of &gt;127 sectors don&squot;t work.&n; *  Version 0.03        Brought into line with ide.c version 5.27.&n; *                      Other minor changes.&n; *  Version 0.04        Updated for ide.c version 5.30&n; *                      Changed initialization strategy&n; *  Version 0.05&t;Kernel integration.  -ml&n; *  Version 0.06&t;Ooops. Add hwgroup to direct call of ide_intr() -ml&n; *  Version 0.07&t;Added support for DC4030 variants&n; *&t;&t;&t;Secondary interface autodetection&n; *  Version 0.08&t;Renamed to pdc4030.c&n; *  Version 0.09&t;Obsolete - never released - did manual write request&n; *&t;&t;&t;splitting before max_sectors[major][minor] available.&n; *  Version 0.10&t;Updated for 2.1 series of kernels&n; *  Version 0.11&t;Updated for 2.3 series of kernels&n; *&t;&t;&t;Autodetection code added.&n; *&n; *  Version 0.90&t;Transition to BETA code. No lost/unexpected interrupts&n; */
multiline_comment|/*&n; * Once you&squot;ve compiled it in, you&squot;ll have to also enable the interface&n; * setup routine from the kernel command line, as in &n; *&n; *&t;&squot;linux ide0=dc4030&squot; or &squot;linux ide1=dc4030&squot;&n; *&n; * It should now work as a second controller also (&squot;ide1=dc4030&squot;) but only&n; * if you DON&squot;T have BIOS V4.44, which has a bug. If you have this version&n; * and EPROM programming facilities, you need to fix 4 bytes:&n; * &t;2496:&t;81&t;81&n; *&t;2497:&t;3E&t;3E&n; *&t;2498:&t;22&t;98&t;*&n; *&t;2499:&t;06&t;05&t;*&n; *&t;249A:&t;F0&t;F0&n; *&t;249B:&t;01&t;01&n; *&t;...&n; *&t;24A7:&t;81&t;81&n; *&t;24A8:&t;3E&t;3E&n; *&t;24A9:&t;22&t;98&t;*&n; *&t;24AA:&t;06&t;05&t;*&n; *&t;24AB:&t;70&t;70&n; *&t;24AC:&t;01&t;01&n; *&n; * As of January 1999, Promise Technology Inc. have finally supplied me with&n; * some technical information which has shed a glimmer of light on some of the&n; * problems I was having, especially with writes. &n; *&n; * There are still potential problems with the robustness and efficiency of&n; * this driver because I still don&squot;t understand what the card is doing with&n; * interrupts, however, it has been stable for a while with no reports of ill&n; * effects.&n; */
DECL|macro|DEBUG_READ
mdefine_line|#define DEBUG_READ
DECL|macro|DEBUG_WRITE
mdefine_line|#define DEBUG_WRITE
DECL|macro|__PROMISE_4030
mdefine_line|#define __PROMISE_4030
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;pdc4030.h&quot;
r_static
id|ide_startstop_t
id|promise_rw_disk
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|sector_t
id|block
)paren
suffix:semicolon
multiline_comment|/*&n; * promise_selectproc() is invoked by ide.c&n; * in preparation for access to the specified drive.&n; */
DECL|function|promise_selectproc
r_static
r_void
id|promise_selectproc
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
r_int
id|number
suffix:semicolon
id|number
op_assign
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|channel
op_lshift
l_int|1
)paren
op_plus
id|drive-&gt;select.b.unit
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|number
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pdc4030_cmd handles the set of vendor specific commands that are initiated&n; * by command F0. They all have the same success/failure notification -&n; * &squot;P&squot; (=0x50) on success, &squot;p&squot; (=0x70) on failure.&n; */
DECL|function|pdc4030_cmd
r_int
id|pdc4030_cmd
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|cmd
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
id|u8
id|status_val
suffix:semicolon
id|promise_selectproc
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* redundant? */
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0xF3
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|cmd
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|PROMISE_EXTENDED_COMMAND
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|timeout
op_assign
id|HZ
op_star
l_int|10
suffix:semicolon
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
r_return
l_int|2
suffix:semicolon
multiline_comment|/* device timed out */
)brace
multiline_comment|/* Delays at least 10ms to give interface a chance */
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|status_val
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|status_val
op_ne
l_int|0x50
op_logical_and
id|status_val
op_ne
l_int|0x70
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_val
op_eq
l_int|0x50
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* device returned success */
r_else
r_return
l_int|1
suffix:semicolon
multiline_comment|/* device returned failure */
)brace
multiline_comment|/*&n; * pdc4030_identify sends a vendor-specific IDENTIFY command to the drive&n; */
DECL|function|pdc4030_identify
r_int
id|pdc4030_identify
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
id|pdc4030_cmd
c_func
(paren
id|drive
comma
id|PROMISE_IDENTIFY
)paren
suffix:semicolon
)brace
DECL|variable|enable_promise_support
r_int
id|enable_promise_support
suffix:semicolon
multiline_comment|/*&n; * setup_pdc4030()&n; * Completes the setup of a Promise DC4030 controller card, once found.&n; */
DECL|function|setup_pdc4030
r_int
id|__init
id|setup_pdc4030
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif2
suffix:semicolon
r_struct
id|dc_ident
id|ident
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif
)paren
r_return
l_int|0
suffix:semicolon
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
l_int|0
)braket
suffix:semicolon
id|hwif2
op_assign
op_amp
id|ide_hwifs
(braket
id|hwif-&gt;index
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_pdc4030
)paren
multiline_comment|/* we&squot;ve already been found ! */
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_NSECTOR_REG
)paren
op_eq
l_int|0xFF
op_logical_or
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
op_eq
l_int|0xFF
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0x08
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdc4030_cmd
c_func
(paren
id|drive
comma
id|PROMISE_GET_CONFIG
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|BAD_W_STAT
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Failed Promise read config!&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|hwif
op_member_access_from_pointer
id|ata_input_data
c_func
(paren
id|drive
comma
op_amp
id|ident
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ident.id
(braket
l_int|1
)braket
op_ne
l_char|&squot;P&squot;
op_logical_or
id|ident.id
(braket
l_int|0
)braket
op_ne
l_char|&squot;T&squot;
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Promise caching controller, &quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ident.type
)paren
(brace
r_case
l_int|0x43
suffix:colon
id|printk
c_func
(paren
l_string|&quot;DC4030VL-2, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x41
suffix:colon
id|printk
c_func
(paren
l_string|&quot;DC4030VL-1, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
id|printk
c_func
(paren
l_string|&quot;DC4030VL, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;unknown - type 0x%02x - please report!&bslash;n&quot;
comma
id|ident.type
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Please e-mail the following data to &quot;
l_string|&quot;promise@pnd-pc.demon.co.uk along with&bslash;n&quot;
l_string|&quot;a description of your card and drives:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x90
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|ident
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|0x0f
)paren
op_eq
l_int|0x0f
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%dKB cache, &quot;
comma
(paren
r_int
)paren
id|ident.cache_mem
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ident.irq
)paren
(brace
r_case
l_int|0x00
suffix:colon
id|hwif-&gt;irq
op_assign
l_int|14
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
id|hwif-&gt;irq
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|hwif-&gt;irq
op_assign
l_int|15
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;on IRQ %d&bslash;n&quot;
comma
id|hwif-&gt;irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Once found and identified, we set up the next hwif in the array&n;&t; * (hwif2 = ide_hwifs[hwif-&gt;index+1]) with the same io ports, irq&n;&t; * and other settings as the main hwif. This gives us two &quot;mated&quot;&n;&t; * hwifs pointing to the Promise card.&n;&t; *&n;&t; * We also have to shift the default values for the remaining&n;&t; * interfaces &quot;up by one&quot; to make room for the second interface on the&n;&t; * same set of values.&n;&t; */
id|hwif-&gt;chipset
op_assign
id|hwif2-&gt;chipset
op_assign
id|ide_pdc4030
suffix:semicolon
id|hwif-&gt;mate
op_assign
id|hwif2
suffix:semicolon
id|hwif2-&gt;mate
op_assign
id|hwif
suffix:semicolon
id|hwif2-&gt;channel
op_assign
l_int|1
suffix:semicolon
id|hwif-&gt;rqsize
op_assign
id|hwif2-&gt;rqsize
op_assign
l_int|127
suffix:semicolon
id|hwif-&gt;no_lba48
op_assign
id|hwif2-&gt;no_lba48
op_assign
l_int|1
suffix:semicolon
id|hwif-&gt;selectproc
op_assign
id|hwif2-&gt;selectproc
op_assign
op_amp
id|promise_selectproc
suffix:semicolon
id|hwif-&gt;serialized
op_assign
id|hwif2-&gt;serialized
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* DC4030 hosted drives need their own identify... */
id|hwif-&gt;identify
op_assign
id|hwif2-&gt;identify
op_assign
op_amp
id|pdc4030_identify
suffix:semicolon
multiline_comment|/* Override the normal ide disk read/write. */
id|hwif-&gt;rw_disk
op_assign
id|promise_rw_disk
suffix:semicolon
id|hwif2-&gt;rw_disk
op_assign
id|promise_rw_disk
suffix:semicolon
multiline_comment|/* Shift the remaining interfaces up by one */
r_for
c_loop
(paren
id|i
op_assign
id|MAX_HWIFS
op_minus
l_int|1
suffix:semicolon
id|i
OG
id|hwif-&gt;index
op_plus
l_int|1
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|ide_hwif_t
op_star
id|h
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pdc4030: Shifting i/f %d values to i/f %d&bslash;n&quot;
comma
id|i
op_minus
l_int|1
comma
id|i
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
id|ide_init_hwif_ports
c_func
(paren
op_amp
id|h-&gt;hw
comma
(paren
id|h
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|h-&gt;io_ports
comma
id|h-&gt;hw.io_ports
comma
r_sizeof
(paren
id|h-&gt;io_ports
)paren
)paren
suffix:semicolon
id|h-&gt;noprobe
op_assign
(paren
id|h
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|noprobe
suffix:semicolon
)brace
id|ide_init_hwif_ports
c_func
(paren
op_amp
id|hwif2-&gt;hw
comma
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hwif2-&gt;io_ports
comma
id|hwif-&gt;hw.io_ports
comma
r_sizeof
(paren
id|hwif2-&gt;io_ports
)paren
)paren
suffix:semicolon
id|hwif2-&gt;irq
op_assign
id|hwif-&gt;irq
suffix:semicolon
id|hwif2-&gt;hw.irq
op_assign
id|hwif-&gt;hw.irq
op_assign
id|hwif-&gt;irq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hwif-&gt;drives
(braket
id|i
)braket
dot
id|io_32bit
op_assign
l_int|3
suffix:semicolon
id|hwif2-&gt;drives
(braket
id|i
)braket
dot
id|io_32bit
op_assign
l_int|3
suffix:semicolon
id|hwif-&gt;drives
(braket
id|i
)braket
dot
id|keep_settings
op_assign
l_int|1
suffix:semicolon
id|hwif2-&gt;drives
(braket
id|i
)braket
dot
id|keep_settings
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ident.current_tm
(braket
id|i
)braket
dot
id|cyl
)paren
id|hwif-&gt;drives
(braket
id|i
)braket
dot
id|noprobe
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ident.current_tm
(braket
id|i
op_plus
l_int|2
)braket
dot
id|cyl
)paren
id|hwif2-&gt;drives
(braket
id|i
)braket
dot
id|noprobe
op_assign
l_int|1
suffix:semicolon
)brace
id|probe_hwif_init
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|hwif-&gt;index
)braket
)paren
suffix:semicolon
id|probe_hwif_init
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|hwif2-&gt;index
)braket
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * detect_pdc4030()&n; * Tests for the presence of a DC4030 Promise card on this interface&n; * Returns: 1 if found, 0 if not found&n; */
DECL|function|detect_pdc4030
r_int
id|__init
id|detect_pdc4030
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|IDE_DATA_REG
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Skip test for non-existent interface */
r_return
l_int|0
suffix:semicolon
)brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0xF3
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0x14
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|PROMISE_EXTENDED_COMMAND
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|ide_delay_50ms
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
op_eq
l_char|&squot;P&squot;
op_logical_and
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_NSECTOR_REG
)paren
op_eq
l_char|&squot;T&squot;
op_logical_and
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
op_eq
l_char|&squot;I&squot;
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|ide_probe_for_pdc4030
r_static
r_int
id|__init
id|ide_probe_for_pdc4030
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|index
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
macro_line|#ifndef MODULE
r_if
c_cond
(paren
id|enable_promise_support
op_eq
l_int|0
)paren
r_return
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
id|index
op_increment
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
op_logical_and
id|detect_pdc4030
c_func
(paren
id|hwif
)paren
)paren
(brace
macro_line|#ifndef MODULE
id|setup_pdc4030
c_func
(paren
id|hwif
)paren
suffix:semicolon
macro_line|#else
r_return
id|setup_pdc4030
c_func
(paren
id|hwif
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#ifdef MODULE
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
DECL|function|release_pdc4030
r_static
r_void
id|__exit
id|release_pdc4030
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
comma
id|ide_hwif_t
op_star
id|mate
)paren
(brace
id|hwif-&gt;chipset
op_assign
id|ide_unknown
suffix:semicolon
id|hwif-&gt;selectproc
op_assign
l_int|NULL
suffix:semicolon
id|hwif-&gt;serialized
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|io_32bit
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|io_32bit
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|keep_settings
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|keep_settings
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|noprobe
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|noprobe
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mate
op_ne
l_int|NULL
)paren
(brace
id|mate-&gt;chipset
op_assign
id|ide_unknown
suffix:semicolon
id|mate-&gt;selectproc
op_assign
l_int|NULL
suffix:semicolon
id|mate-&gt;serialized
op_assign
l_int|0
suffix:semicolon
id|mate-&gt;drives
(braket
l_int|0
)braket
dot
id|io_32bit
op_assign
l_int|0
suffix:semicolon
id|mate-&gt;drives
(braket
l_int|1
)braket
dot
id|io_32bit
op_assign
l_int|0
suffix:semicolon
id|mate-&gt;drives
(braket
l_int|0
)braket
dot
id|keep_settings
op_assign
l_int|0
suffix:semicolon
id|mate-&gt;drives
(braket
l_int|1
)braket
dot
id|keep_settings
op_assign
l_int|0
suffix:semicolon
id|mate-&gt;drives
(braket
l_int|0
)braket
dot
id|noprobe
op_assign
l_int|0
suffix:semicolon
id|mate-&gt;drives
(braket
l_int|1
)braket
dot
id|noprobe
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#ifndef MODULE
multiline_comment|/*&n; * init_pdc4030:&n; *&n; * called by ide.c when parsing command line&n; */
DECL|function|init_pdc4030
r_void
id|__init
id|init_pdc4030
c_func
(paren
r_void
)paren
(brace
id|enable_promise_support
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#else
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Peter Denison&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Support of Promise 4030 VLB series IDE chipsets&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|function|pdc4030_mod_init
r_static
r_int
id|__init
id|pdc4030_mod_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|enable_promise_support
op_eq
l_int|0
)paren
id|enable_promise_support
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ide_probe_for_pdc4030
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pdc4030_mod_init
id|module_init
c_func
(paren
id|pdc4030_mod_init
)paren
suffix:semicolon
DECL|function|pdc4030_mod_exit
r_static
r_void
id|__exit
id|pdc4030_mod_exit
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|index
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_if
c_cond
(paren
id|enable_promise_support
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
id|index
op_increment
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_pdc4030
)paren
(brace
id|ide_hwif_t
op_star
id|mate
op_assign
op_amp
id|ide_hwifs
(braket
id|hwif-&gt;index
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|mate-&gt;chipset
op_eq
id|ide_pdc4030
)paren
id|release_pdc4030
c_func
(paren
id|hwif
comma
id|mate
)paren
suffix:semicolon
r_else
id|release_pdc4030
c_func
(paren
id|hwif
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
id|enable_promise_support
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|pdc4030_mod_exit
id|module_exit
c_func
(paren
id|pdc4030_mod_exit
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * promise_read_intr() is the handler for disk read/multread interrupts&n; */
DECL|function|promise_read_intr
r_static
id|ide_startstop_t
id|promise_read_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
r_int
id|sectors_left
comma
id|sectors_avail
comma
id|nsect
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|ata_status_t
id|status
suffix:semicolon
id|status.all
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|status.all
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
id|__FUNCTION__
comma
id|status.all
)paren
suffix:semicolon
id|read_again
suffix:colon
r_do
(brace
id|sectors_left
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_NSECTOR_REG
)paren
op_ne
id|sectors_left
)paren
suffix:semicolon
id|sectors_avail
op_assign
id|rq-&gt;nr_sectors
op_minus
id|sectors_left
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sectors_avail
)paren
r_goto
id|read_again
suffix:semicolon
id|read_next
suffix:colon
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|sectors_avail
)paren
id|nsect
op_assign
id|sectors_avail
suffix:semicolon
id|sectors_avail
op_sub_assign
id|nsect
suffix:semicolon
macro_line|#ifdef DEBUG_READ
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: %s: sectors(%lu-%lu), rem=%lu&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
comma
(paren
r_int
r_int
)paren
id|rq-&gt;sector
comma
(paren
r_int
r_int
)paren
id|rq-&gt;sector
op_plus
id|nsect
op_minus
l_int|1
comma
(paren
r_int
r_int
)paren
id|rq-&gt;nr_sectors
op_minus
id|nsect
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_READ */
macro_line|#ifdef CONFIG_IDE_TASKFILE_IO
id|task_sectors
c_func
(paren
id|drive
comma
id|rq
comma
id|nsect
comma
id|IDE_PIO_IN
)paren
suffix:semicolon
multiline_comment|/* FIXME: can we check status after transfer on pdc4030? */
multiline_comment|/* Complete previously submitted bios. */
r_while
c_loop
(paren
id|rq-&gt;bio
op_ne
id|rq-&gt;cbio
)paren
r_if
c_cond
(paren
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|bio_sectors
c_func
(paren
id|rq-&gt;bio
)paren
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
macro_line|#else /* CONFIG_IDE_TASKFILE_IO */
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ata_input_data
c_func
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|nsect
op_lshift
l_int|9
suffix:semicolon
id|rq-&gt;sector
op_add_assign
id|nsect
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IDE_TASKFILE_IO */
multiline_comment|/*&n; * Now the data has been read in, do the following:&n; * &n; * if there are still sectors left in the request, &n; *   if we know there are still sectors available from the interface,&n; *     go back and read the next bit of the request.&n; *   else if DRQ is asserted, there are more sectors available, so&n; *     go back and find out how many, then read them in.&n; *   else if BUSY is asserted, we are going to get an interrupt, so&n; *     set the handler for the interrupt and just return&n; */
r_if
c_cond
(paren
id|rq-&gt;nr_sectors
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sectors_avail
)paren
r_goto
id|read_next
suffix:semicolon
id|status.all
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status.b.drq
)paren
r_goto
id|read_again
suffix:semicolon
r_if
c_cond
(paren
id|status.b.bsy
)paren
(brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
op_ne
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|promise_read_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_READ
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: promise_read: waiting for&quot;
l_string|&quot;interrupt&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_READ */
r_return
id|ide_started
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Eeek! promise_read_intr: sectors left &quot;
l_string|&quot;!DRQ !BUSY&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;promise read intr&quot;
comma
id|status.all
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * promise_complete_pollfunc()&n; * This is the polling function for waiting (nicely!) until drive stops&n; * being busy. It is invoked at the end of a write, after the previous poll&n; * has finished.&n; *&n; * Once not busy, the end request is called.&n; */
DECL|function|promise_complete_pollfunc
r_static
id|ide_startstop_t
id|promise_complete_pollfunc
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|hwgroup-&gt;rq
suffix:semicolon
r_if
c_cond
(paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
op_amp
id|BUSY_STAT
)paren
(brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|hwgroup-&gt;poll_timeout
)paren
)paren
(brace
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_ne
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|promise_complete_pollfunc
comma
id|HZ
op_div
l_int|100
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
multiline_comment|/* continue polling... */
)brace
id|hwgroup-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: completion timeout - still busy!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;busy timeout&quot;
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
suffix:semicolon
)brace
id|hwgroup-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_WRITE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Write complete - end_request&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_WRITE */
macro_line|#ifdef CONFIG_IDE_TASKFILE_IO
multiline_comment|/* Complete previously submitted bios. */
r_while
c_loop
(paren
id|rq-&gt;bio
op_ne
id|rq-&gt;cbio
)paren
(paren
r_void
)paren
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|bio_sectors
c_func
(paren
id|rq-&gt;bio
)paren
)paren
suffix:semicolon
macro_line|#else
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|rq-&gt;hard_nr_sectors
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * promise_multwrite() transfers a block of up to mcount sectors of data&n; * to a drive as part of a disk multiple-sector write operation.&n; */
macro_line|#ifdef CONFIG_IDE_TASKFILE_IO
DECL|function|promise_multwrite
r_static
r_void
id|promise_multwrite
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|msect
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
r_int
id|nsect
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|task_sectors
c_func
(paren
id|drive
comma
id|rq
comma
id|nsect
comma
id|IDE_PIO_OUT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;nr_sectors
)paren
id|msect
op_assign
l_int|0
suffix:semicolon
r_else
id|msect
op_sub_assign
id|nsect
suffix:semicolon
)brace
r_while
c_loop
(paren
id|msect
)paren
suffix:semicolon
)brace
macro_line|#else /* CONFIG_IDE_TASKFILE_IO */
DECL|function|promise_multwrite
r_static
r_void
id|promise_multwrite
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|mcount
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
op_amp
id|hwgroup-&gt;wrq
suffix:semicolon
r_do
(brace
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|mcount
)paren
id|nsect
op_assign
id|mcount
suffix:semicolon
id|mcount
op_sub_assign
id|nsect
suffix:semicolon
id|buffer
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|rq-&gt;sector
op_add_assign
id|nsect
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|nsect
op_lshift
l_int|9
suffix:semicolon
id|rq-&gt;nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
multiline_comment|/* Do we move to the next bh after this? */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|rq-&gt;bio
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * only move to next bio, when we have processed&n;&t;&t;&t; * all bvecs in this one.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_increment
id|bio-&gt;bi_idx
op_ge
id|bio-&gt;bi_vcnt
)paren
(brace
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio
op_assign
id|bio-&gt;bi_next
suffix:semicolon
)brace
multiline_comment|/* end early early we ran out of requests */
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
id|mcount
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rq-&gt;bio
op_assign
id|bio
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
id|bio_iovec
c_func
(paren
id|bio
)paren
op_member_access_from_pointer
id|bv_len
op_rshift
l_int|9
suffix:semicolon
id|rq-&gt;hard_cur_sectors
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Ok, we&squot;re all setup for the interrupt&n;&t;&t; * re-entering us on the last transfer.&n;&t;&t; */
id|taskfile_output_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|nsect
op_lshift
l_int|7
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mcount
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * promise_write_pollfunc() is the handler for disk write completion polling.&n; */
DECL|function|promise_write_pollfunc
r_static
id|ide_startstop_t
id|promise_write_pollfunc
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASKFILE_IO
r_struct
id|request
op_star
id|rq
op_assign
id|hwgroup-&gt;rq
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_NSECTOR_REG
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|hwgroup-&gt;poll_timeout
)paren
)paren
(brace
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_ne
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|promise_write_pollfunc
comma
id|HZ
op_div
l_int|100
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
multiline_comment|/* continue polling... */
)brace
id|hwgroup-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: write timed-out!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;write timeout&quot;
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IDE_TASKFILE_IO
multiline_comment|/* Complete previously submitted bios. */
r_while
c_loop
(paren
id|rq-&gt;bio
op_ne
id|rq-&gt;cbio
)paren
(paren
r_void
)paren
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|bio_sectors
c_func
(paren
id|rq-&gt;bio
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Now write out last 4 sectors and poll for not BUSY&n;&t; */
id|promise_multwrite
c_func
(paren
id|drive
comma
l_int|4
)paren
suffix:semicolon
id|hwgroup-&gt;poll_timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_ne
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|promise_complete_pollfunc
comma
id|HZ
op_div
l_int|100
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_WRITE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Done last 4 sectors - status = %02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_WRITE */
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * promise_write() transfers a block of one or more sectors of data to a&n; * drive as part of a disk write operation. All but 4 sectors are transferred&n; * in the first attempt, then the interface is polled (nicely!) for completion&n; * before the final 4 sectors are transferred. There is no interrupt generated&n; * on writes (at least on the DC4030VL-2), we just have to poll for NOT BUSY.&n; */
DECL|function|promise_write
r_static
id|ide_startstop_t
id|promise_write
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASKFILE_IO
r_struct
id|request
op_star
id|rq
op_assign
id|hwgroup-&gt;rq
suffix:semicolon
macro_line|#else
r_struct
id|request
op_star
id|rq
op_assign
op_amp
id|hwgroup-&gt;wrq
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_WRITE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: %s: sectors(%lu-%lu)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
comma
(paren
r_int
r_int
)paren
id|rq-&gt;sector
comma
(paren
r_int
r_int
)paren
id|rq-&gt;sector
op_plus
id|rq-&gt;nr_sectors
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_WRITE */
multiline_comment|/*&n;&t; * If there are more than 4 sectors to transfer, do n-4 then go into&n;&t; * the polling strategy as defined above.&n;&t; */
r_if
c_cond
(paren
id|rq-&gt;nr_sectors
OG
l_int|4
)paren
(brace
id|promise_multwrite
c_func
(paren
id|drive
comma
id|rq-&gt;nr_sectors
op_minus
l_int|4
)paren
suffix:semicolon
id|hwgroup-&gt;poll_timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_ne
l_int|NULL
)paren
multiline_comment|/* paranoia check */
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|promise_write_pollfunc
comma
id|HZ
op_div
l_int|100
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t; * There are 4 or fewer sectors to transfer, do them all in one go&n;&t; * and wait for NOT BUSY.&n;&t; */
id|promise_multwrite
c_func
(paren
id|drive
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
id|hwgroup-&gt;poll_timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_ne
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|promise_complete_pollfunc
comma
id|HZ
op_div
l_int|100
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_WRITE
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: promise_write: &lt;= 4 sectors, &quot;
l_string|&quot;status = %02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_WRITE */
r_return
id|ide_started
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * do_pdc4030_io() is called from promise_rw_disk, having had the block number&n; * already set up. It issues a READ or WRITE command to the Promise&n; * controller, assuming LBA has been used to set up the block number.&n; */
macro_line|#ifndef CONFIG_IDE_TASKFILE_IO
DECL|function|do_pdc4030_io
id|ide_startstop_t
id|do_pdc4030_io
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_startstop_t
id|startstop
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|u8
id|stat
op_assign
l_int|0
suffix:semicolon
macro_line|#else
r_static
id|ide_startstop_t
id|do_pdc4030_io
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_task_t
op_star
id|task
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|task_struct_t
op_star
id|taskfile
op_assign
(paren
id|task_struct_t
op_star
)paren
id|task-&gt;tfRegister
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|u8
id|stat
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear nIEN */
id|SELECT_MASK
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;feature
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;sector_count
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to number of sectors to transfer */
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;sector_number
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
multiline_comment|/* refers to sector offset or start sector */
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;low_cylinder
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;high_cylinder
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;device_head
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|taskfile-&gt;command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
(brace
macro_line|#ifndef CONFIG_IDE_TASKFILE_IO
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|PROMISE_READ
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * The card&squot;s behaviour is odd at this point. If the data is&n; * available, DRQ will be true, and no interrupt will be&n; * generated by the card. If this is the case, we need to call the &n; * &quot;interrupt&quot; handler (promise_read_intr) directly. Otherwise, if&n; * an interrupt is going to occur, bit0 of the SELECT register will&n; * be high, so we can set the handler the just return and be interrupted.&n; * If neither of these is the case, we wait for up to 50ms (badly I&squot;m&n; * afraid!) until one of them is.&n; */
id|timeout
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|20
suffix:semicolon
multiline_comment|/* 50ms wait */
r_do
(brace
id|stat
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
id|promise_read_intr
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SELECT_REG
)paren
op_amp
l_int|0x01
)paren
(brace
macro_line|#ifdef DEBUG_READ
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: read: waiting for &quot;
l_string|&quot;interrupt&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_READ */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|promise_read_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: reading: No DRQ and not &quot;
l_string|&quot;waiting - Odd!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifndef CONFIG_IDE_TASKFILE_IO
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|PROMISE_WRITE
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no DRQ after issuing &quot;
l_string|&quot;PROMISE_WRITE&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;unmask
)paren
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_IDE_TASKFILE_IO
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|wrq
op_assign
op_star
id|rq
suffix:semicolon
multiline_comment|/* scratchpad */
macro_line|#endif
r_return
id|promise_write
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
DECL|function|promise_rw_disk
r_static
id|ide_startstop_t
id|promise_rw_disk
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|sector_t
id|block
)paren
(brace
multiline_comment|/* The four drives on the two logical (one physical) interfaces&n;&t;   are distinguished by writing the drive number (0-3) to the&n;&t;   Feature register.&n;&t;   FIXME: Is promise_selectproc now redundant??&n;&t;*/
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|drive_number
op_assign
(paren
id|hwif-&gt;channel
op_lshift
l_int|1
)paren
op_plus
id|drive-&gt;select.b.unit
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASKFILE_IO
r_struct
id|hd_drive_task_hdr
id|taskfile
suffix:semicolon
id|ide_task_t
id|args
suffix:semicolon
macro_line|#endif
id|BUG_ON
c_func
(paren
id|rq-&gt;nr_sectors
OG
l_int|127
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blk_fs_request
c_func
(paren
id|rq
)paren
)paren
(brace
id|blk_dump_rq_flags
c_func
(paren
id|rq
comma
l_string|&quot;promise_rw_disk - bad command&quot;
)paren
suffix:semicolon
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: %sing: LBAsect=%lu, sectors=%lu&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq_data_dir
c_func
(paren
id|rq
)paren
ques
c_cond
l_string|&quot;writ&quot;
suffix:colon
l_string|&quot;read&quot;
comma
id|block
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifndef CONFIG_IDE_TASKFILE_IO
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive_number
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|rq-&gt;nr_sectors
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|block
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|block
op_rshift_assign
l_int|8
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|block
op_rshift_assign
l_int|8
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
(paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
)paren
op_or
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_return
id|do_pdc4030_io
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
macro_line|#else /* !CONFIG_IDE_TASKFILE_IO */
id|memset
c_func
(paren
op_amp
id|taskfile
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hd_drive_task_hdr
)paren
)paren
suffix:semicolon
id|taskfile.feature
op_assign
id|drive_number
suffix:semicolon
id|taskfile.sector_count
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|taskfile.sector_number
op_assign
id|block
suffix:semicolon
id|taskfile.low_cylinder
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
id|taskfile.high_cylinder
op_assign
(paren
id|block
op_rshift_assign
l_int|8
)paren
suffix:semicolon
id|taskfile.device_head
op_assign
(paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
)paren
op_or
id|drive-&gt;select.all
suffix:semicolon
id|taskfile.command
op_assign
(paren
id|rq-&gt;cmd
op_eq
id|READ
)paren
ques
c_cond
id|PROMISE_READ
suffix:colon
id|PROMISE_WRITE
suffix:semicolon
id|memcpy
c_func
(paren
id|args.tfRegister
comma
op_amp
id|taskfile
comma
r_sizeof
(paren
r_struct
id|hd_drive_task_hdr
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|args.hobRegister
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hd_drive_hob_hdr
)paren
)paren
suffix:semicolon
multiline_comment|/* We can&squot;t call ide_cmd_type_parser here, since it won&squot;t understand&n;&t;   our command, but that doesn&squot;t matter, since we don&squot;t use the&n;&t;   generic interrupt handlers either. Setup the bits of args that we&n;&t;   do need.&n;&t;*/
id|args.handler
op_assign
l_int|NULL
suffix:semicolon
id|args.rq
op_assign
(paren
r_struct
id|request
op_star
)paren
id|rq
suffix:semicolon
id|rq-&gt;special
op_assign
(paren
id|ide_task_t
op_star
)paren
op_amp
id|args
suffix:semicolon
r_return
id|do_pdc4030_io
c_func
(paren
id|drive
comma
op_amp
id|args
)paren
suffix:semicolon
macro_line|#endif /* !CONFIG_IDE_TASKFILE_IO */
)brace
eof
