multiline_comment|/* $Id: ide.c,v 1.4 2004/10/12 07:55:48 starvik Exp $&n; *&n; * Etrax specific IDE functions, like init and PIO-mode setting etc.&n; * Almost the entire ide.c is used for the rest of the Etrax ATA driver.&n; * Copyright (c) 2000-2004 Axis Communications AB&n; *&n; * Authors:    Bjorn Wesen        (initial version)&n; *             Mikael Starvik     (pio setup stuff, Linux 2.6 port)&n; */
multiline_comment|/* Regarding DMA:&n; *&n; * There are two forms of DMA - &quot;DMA handshaking&quot; between the interface and the drive,&n; * and DMA between the memory and the interface. We can ALWAYS use the latter, since it&squot;s&n; * something built-in in the Etrax. However only some drives support the DMA-mode handshaking&n; * on the ATA-bus. The normal PC driver and Triton interface disables memory-if DMA when the&n; * device can&squot;t do DMA handshaking for some stupid reason. We don&squot;t need to do that.&n; */
DECL|macro|REALLY_SLOW_IO
macro_line|#undef REALLY_SLOW_IO           /* most systems can safely undef this */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/scatterlist.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/arch/svinto.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
multiline_comment|/* number of Etrax DMA descriptors */
DECL|macro|MAX_DMA_DESCRS
mdefine_line|#define MAX_DMA_DESCRS 64
multiline_comment|/* number of times to retry busy-flags when reading/writing IDE-registers&n; * this can&squot;t be too high because a hung harddisk might cause the watchdog&n; * to trigger (sometimes INB and OUTB are called with irq&squot;s disabled)&n; */
DECL|macro|IDE_REGISTER_TIMEOUT
mdefine_line|#define IDE_REGISTER_TIMEOUT 300
DECL|variable|e100_read_command
r_static
r_int
id|e100_read_command
op_assign
l_int|0
suffix:semicolon
DECL|macro|LOWDB
mdefine_line|#define LOWDB(x)
DECL|macro|D
mdefine_line|#define D(x)
r_static
r_int
id|e100_ide_build_dmatable
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_static
id|ide_startstop_t
id|etrax_dma_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
DECL|function|etrax100_ide_outw
id|etrax100_ide_outw
c_func
(paren
r_int
r_int
id|data
comma
r_int
r_int
id|reg
)paren
(brace
r_int
id|timeleft
suffix:semicolon
id|LOWDB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;ow: data 0x%x, reg 0x%x&bslash;n&quot;
comma
id|data
comma
id|reg
)paren
)paren
suffix:semicolon
multiline_comment|/* note the lack of handling any timeouts. we stop waiting, but we don&squot;t&n;&t; * really notify anybody.&n;&t; */
id|timeleft
op_assign
id|IDE_REGISTER_TIMEOUT
suffix:semicolon
multiline_comment|/* wait for busy flag */
r_while
c_loop
(paren
id|timeleft
op_logical_and
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
)paren
(brace
id|timeleft
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fall through at a timeout, so the ongoing command will be&n;&t; * aborted by the write below, which is expected to be a dummy&n;&t; * command to the command register.  This happens when a faulty&n;&t; * drive times out on a command.  See comment on timeout in&n;&t; * INB.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|timeleft
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ATA timeout reg 0x%lx := 0x%x&bslash;n&quot;
comma
id|reg
comma
id|data
)paren
suffix:semicolon
)brace
op_star
id|R_ATA_CTRL_DATA
op_assign
id|reg
op_or
id|data
suffix:semicolon
multiline_comment|/* write data to the drive&squot;s register */
id|timeleft
op_assign
id|IDE_REGISTER_TIMEOUT
suffix:semicolon
multiline_comment|/* wait for transmitter ready */
r_while
c_loop
(paren
id|timeleft
op_logical_and
op_logical_neg
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|tr_rdy
)paren
)paren
)paren
(brace
id|timeleft
op_decrement
suffix:semicolon
)brace
)brace
r_void
DECL|function|etrax100_ide_outb
id|etrax100_ide_outb
c_func
(paren
r_int
r_char
id|data
comma
r_int
r_int
id|reg
)paren
(brace
id|etrax100_ide_outw
c_func
(paren
id|data
comma
id|reg
)paren
suffix:semicolon
)brace
r_void
DECL|function|etrax100_ide_outbsync
id|etrax100_ide_outbsync
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|addr
comma
r_int
r_int
id|port
)paren
(brace
id|etrax100_ide_outw
c_func
(paren
id|addr
comma
id|port
)paren
suffix:semicolon
)brace
r_int
r_int
DECL|function|etrax100_ide_inw
id|etrax100_ide_inw
c_func
(paren
r_int
r_int
id|reg
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|timeleft
suffix:semicolon
id|timeleft
op_assign
id|IDE_REGISTER_TIMEOUT
suffix:semicolon
multiline_comment|/* wait for busy flag */
r_while
c_loop
(paren
id|timeleft
op_logical_and
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
)paren
(brace
id|timeleft
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|timeleft
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we&squot;re asked to read the status register, like for&n;&t;&t; * example when a command does not complete for an&n;&t;&t; * extended time, but the ATA interface is stuck in a&n;&t;&t; * busy state at the *ETRAX* ATA interface level (as has&n;&t;&t; * happened repeatedly with at least one bad disk), then&n;&t;&t; * the best thing to do is to pretend that we read&n;&t;&t; * &quot;busy&quot; in the status register, so the IDE driver will&n;&t;&t; * time-out, abort the ongoing command and perform a&n;&t;&t; * reset sequence.  Note that the subsequent OUT_BYTE&n;&t;&t; * call will also timeout on busy, but as long as the&n;&t;&t; * write is still performed, everything will be fine.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|reg
op_amp
id|IO_MASK
(paren
id|R_ATA_CTRL_DATA
comma
id|addr
)paren
)paren
op_eq
id|IO_FIELD
(paren
id|R_ATA_CTRL_DATA
comma
id|addr
comma
id|IDE_STATUS_OFFSET
)paren
)paren
r_return
id|BUSY_STAT
suffix:semicolon
r_else
multiline_comment|/* For other rare cases we assume 0 is good enough.  */
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|R_ATA_CTRL_DATA
op_assign
id|reg
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|read
)paren
suffix:semicolon
multiline_comment|/* read data */
id|timeleft
op_assign
id|IDE_REGISTER_TIMEOUT
suffix:semicolon
multiline_comment|/* wait for available */
r_while
c_loop
(paren
id|timeleft
op_logical_and
op_logical_neg
(paren
(paren
id|status
op_assign
op_star
id|R_ATA_STATUS_DATA
)paren
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|dav
)paren
)paren
)paren
(brace
id|timeleft
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|timeleft
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|LOWDB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;inb: 0x%x from reg 0x%x&bslash;n&quot;
comma
id|status
op_amp
l_int|0xff
comma
id|reg
)paren
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|status
suffix:semicolon
)brace
r_int
r_char
DECL|function|etrax100_ide_inb
id|etrax100_ide_inb
c_func
(paren
r_int
r_int
id|reg
)paren
(brace
r_return
(paren
r_int
r_char
)paren
id|etrax100_ide_inw
c_func
(paren
id|reg
)paren
suffix:semicolon
)brace
multiline_comment|/* PIO timing (in R_ATA_CONFIG)&n; *&n; *                        _____________________________&n; * ADDRESS :     ________/&n; *&n; *                            _______________&n; * DIOR    :     ____________/               &bslash;__________&n; *&n; *                               _______________&n; * DATA    :     XXXXXXXXXXXXXXXX_______________XXXXXXXX&n; *&n; *&n; * DIOR is unbuffered while address and data is buffered.&n; * This creates two problems:&n; * 1. The DIOR pulse is to early (because it is unbuffered)&n; * 2. The rise time of DIOR is long&n; *&n; * There are at least three different plausible solutions&n; * 1. Use a pad capable of larger currents in Etrax&n; * 2. Use an external buffer&n; * 3. Make the strobe pulse longer&n; *&n; * Some of the strobe timings below are modified to compensate&n; * for this. This implies a slight performance decrease.&n; *&n; * THIS SHOULD NEVER BE CHANGED!&n; *&n; * TODO: Is this true for the latest LX boards still ?&n; */
DECL|macro|ATA_DMA2_STROBE
mdefine_line|#define ATA_DMA2_STROBE  4
DECL|macro|ATA_DMA2_HOLD
mdefine_line|#define ATA_DMA2_HOLD    0
DECL|macro|ATA_DMA1_STROBE
mdefine_line|#define ATA_DMA1_STROBE  4
DECL|macro|ATA_DMA1_HOLD
mdefine_line|#define ATA_DMA1_HOLD    1
DECL|macro|ATA_DMA0_STROBE
mdefine_line|#define ATA_DMA0_STROBE 12
DECL|macro|ATA_DMA0_HOLD
mdefine_line|#define ATA_DMA0_HOLD    9
DECL|macro|ATA_PIO4_SETUP
mdefine_line|#define ATA_PIO4_SETUP   1
DECL|macro|ATA_PIO4_STROBE
mdefine_line|#define ATA_PIO4_STROBE  5
DECL|macro|ATA_PIO4_HOLD
mdefine_line|#define ATA_PIO4_HOLD    0
DECL|macro|ATA_PIO3_SETUP
mdefine_line|#define ATA_PIO3_SETUP   1
DECL|macro|ATA_PIO3_STROBE
mdefine_line|#define ATA_PIO3_STROBE  5
DECL|macro|ATA_PIO3_HOLD
mdefine_line|#define ATA_PIO3_HOLD    1
DECL|macro|ATA_PIO2_SETUP
mdefine_line|#define ATA_PIO2_SETUP   1
DECL|macro|ATA_PIO2_STROBE
mdefine_line|#define ATA_PIO2_STROBE  6
DECL|macro|ATA_PIO2_HOLD
mdefine_line|#define ATA_PIO2_HOLD    2
DECL|macro|ATA_PIO1_SETUP
mdefine_line|#define ATA_PIO1_SETUP   2
DECL|macro|ATA_PIO1_STROBE
mdefine_line|#define ATA_PIO1_STROBE 11
DECL|macro|ATA_PIO1_HOLD
mdefine_line|#define ATA_PIO1_HOLD    4
DECL|macro|ATA_PIO0_SETUP
mdefine_line|#define ATA_PIO0_SETUP   4
DECL|macro|ATA_PIO0_STROBE
mdefine_line|#define ATA_PIO0_STROBE 19
DECL|macro|ATA_PIO0_HOLD
mdefine_line|#define ATA_PIO0_HOLD    4
r_static
r_int
id|e100_dma_check
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_static
r_void
id|e100_dma_start
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_static
r_int
id|e100_dma_end
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_static
r_void
id|e100_ide_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|e100_ide_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|e100_atapi_input_bytes
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|e100_atapi_output_bytes
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|e100_dma_off
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; * good_dma_drives() lists the model names (from &quot;hdparm -i&quot;)&n; * of drives which do not support mword2 DMA but which are&n; * known to work fine with this interface under Linux.&n; */
DECL|variable|good_dma_drives
r_const
r_char
op_star
id|good_dma_drives
(braket
)braket
op_assign
(brace
l_string|&quot;Micropolis 2112A&quot;
comma
l_string|&quot;CONNER CTMA 4000&quot;
comma
l_string|&quot;CONNER CTT8000-A&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|tune_e100_ide
r_static
r_void
id|tune_e100_ide
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|pio
)paren
(brace
id|pio
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* pio = ide_get_best_pio_mode(drive, pio, 4, NULL); */
multiline_comment|/* set pio mode! */
r_switch
c_cond
(paren
id|pio
)paren
(brace
r_case
l_int|0
suffix:colon
op_star
id|R_ATA_CONFIG
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|enable
comma
l_int|1
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_strobe
comma
id|ATA_DMA2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_hold
comma
id|ATA_DMA2_HOLD
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_setup
comma
id|ATA_PIO0_SETUP
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_strobe
comma
id|ATA_PIO0_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_hold
comma
id|ATA_PIO0_HOLD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
op_star
id|R_ATA_CONFIG
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|enable
comma
l_int|1
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_strobe
comma
id|ATA_DMA2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_hold
comma
id|ATA_DMA2_HOLD
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_setup
comma
id|ATA_PIO1_SETUP
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_strobe
comma
id|ATA_PIO1_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_hold
comma
id|ATA_PIO1_HOLD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|R_ATA_CONFIG
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|enable
comma
l_int|1
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_strobe
comma
id|ATA_DMA2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_hold
comma
id|ATA_DMA2_HOLD
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_setup
comma
id|ATA_PIO2_SETUP
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_strobe
comma
id|ATA_PIO2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_hold
comma
id|ATA_PIO2_HOLD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
id|R_ATA_CONFIG
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|enable
comma
l_int|1
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_strobe
comma
id|ATA_DMA2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_hold
comma
id|ATA_DMA2_HOLD
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_setup
comma
id|ATA_PIO3_SETUP
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_strobe
comma
id|ATA_PIO3_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_hold
comma
id|ATA_PIO3_HOLD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
id|R_ATA_CONFIG
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|enable
comma
l_int|1
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_strobe
comma
id|ATA_DMA2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_hold
comma
id|ATA_DMA2_HOLD
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_setup
comma
id|ATA_PIO4_SETUP
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_strobe
comma
id|ATA_PIO4_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_hold
comma
id|ATA_PIO4_HOLD
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|e100_dma_setup
r_static
r_int
id|e100_dma_setup
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|drive-&gt;hwif-&gt;hwgroup-&gt;rq
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
)paren
(brace
id|e100_read_command
op_assign
l_int|0
suffix:semicolon
id|RESET_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* sometimes the DMA channel get stuck so we need to do this */
id|WAIT_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
)brace
r_else
(brace
id|e100_read_command
op_assign
l_int|1
suffix:semicolon
id|RESET_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* sometimes the DMA channel get stuck so we need to do this */
id|WAIT_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
)brace
multiline_comment|/* set up the Etrax DMA descriptors */
r_if
c_cond
(paren
id|e100_ide_build_dmatable
c_func
(paren
id|drive
)paren
)paren
(brace
id|ide_map_sg
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|e100_dma_exec_cmd
r_static
r_void
id|e100_dma_exec_cmd
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|command
)paren
(brace
multiline_comment|/* set the irq handler which will finish the request when DMA is done */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|etrax_dma_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* issue cmd to drive */
id|etrax100_ide_outb
c_func
(paren
id|command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|init_e100_ide
id|init_e100_ide
(paren
r_void
)paren
(brace
r_volatile
r_int
r_int
id|dummy
suffix:semicolon
r_int
id|h
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ide: ETRAX 100LX built-in ATA DMA controller&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* first fill in some stuff in the ide_hwifs fields */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
id|h
op_increment
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
id|hwif-&gt;mmio
op_assign
l_int|2
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|ide_etrax100
suffix:semicolon
id|hwif-&gt;tuneproc
op_assign
op_amp
id|tune_e100_ide
suffix:semicolon
id|hwif-&gt;ata_input_data
op_assign
op_amp
id|e100_ide_input_data
suffix:semicolon
id|hwif-&gt;ata_output_data
op_assign
op_amp
id|e100_ide_output_data
suffix:semicolon
id|hwif-&gt;atapi_input_bytes
op_assign
op_amp
id|e100_atapi_input_bytes
suffix:semicolon
id|hwif-&gt;atapi_output_bytes
op_assign
op_amp
id|e100_atapi_output_bytes
suffix:semicolon
id|hwif-&gt;ide_dma_check
op_assign
op_amp
id|e100_dma_check
suffix:semicolon
id|hwif-&gt;ide_dma_end
op_assign
op_amp
id|e100_dma_end
suffix:semicolon
id|hwif-&gt;dma_setup
op_assign
op_amp
id|e100_dma_setup
suffix:semicolon
id|hwif-&gt;dma_exec_cmd
op_assign
op_amp
id|e100_dma_exec_cmd
suffix:semicolon
id|hwif-&gt;dma_start
op_assign
op_amp
id|e100_dma_start
suffix:semicolon
id|hwif-&gt;OUTB
op_assign
op_amp
id|etrax100_ide_outb
suffix:semicolon
id|hwif-&gt;OUTW
op_assign
op_amp
id|etrax100_ide_outw
suffix:semicolon
id|hwif-&gt;OUTBSYNC
op_assign
op_amp
id|etrax100_ide_outbsync
suffix:semicolon
id|hwif-&gt;INB
op_assign
op_amp
id|etrax100_ide_inb
suffix:semicolon
id|hwif-&gt;INW
op_assign
op_amp
id|etrax100_ide_inw
suffix:semicolon
id|hwif-&gt;ide_dma_off_quietly
op_assign
op_amp
id|e100_dma_off
suffix:semicolon
)brace
multiline_comment|/* actually reset and configure the etrax100 ide/ata interface */
op_star
id|R_ATA_CTRL_DATA
op_assign
l_int|0
suffix:semicolon
op_star
id|R_ATA_TRANSFER_CNT
op_assign
l_int|0
suffix:semicolon
op_star
id|R_ATA_CONFIG
op_assign
l_int|0
suffix:semicolon
id|genconfig_shadow
op_assign
(paren
id|genconfig_shadow
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_GEN_CONFIG
comma
id|dma2
)paren
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_GEN_CONFIG
comma
id|dma3
)paren
op_amp
op_complement
id|IO_MASK
c_func
(paren
id|R_GEN_CONFIG
comma
id|ata
)paren
)paren
op_or
(paren
id|IO_STATE
c_func
(paren
id|R_GEN_CONFIG
comma
id|dma3
comma
id|ata
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_GEN_CONFIG
comma
id|dma2
comma
id|ata
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_GEN_CONFIG
comma
id|ata
comma
id|select
)paren
)paren
suffix:semicolon
op_star
id|R_GEN_CONFIG
op_assign
id|genconfig_shadow
suffix:semicolon
multiline_comment|/* pull the chosen /reset-line low */
macro_line|#ifdef CONFIG_ETRAX_IDE_G27_RESET
id|REG_SHADOW_SET
c_func
(paren
id|R_PORT_G_DATA
comma
id|port_g_data_shadow
comma
l_int|27
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_IDE_CSE1_16_RESET
id|REG_SHADOW_SET
c_func
(paren
id|port_cse1_addr
comma
id|port_cse1_shadow
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_IDE_CSP0_8_RESET
id|REG_SHADOW_SET
c_func
(paren
id|port_csp0_addr
comma
id|port_csp0_shadow
comma
l_int|8
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_IDE_PB7_RESET
id|port_pb_dir_shadow
op_assign
id|port_pb_dir_shadow
op_or
id|IO_STATE
c_func
(paren
id|R_PORT_PB_DIR
comma
id|dir7
comma
id|output
)paren
suffix:semicolon
op_star
id|R_PORT_PB_DIR
op_assign
id|port_pb_dir_shadow
suffix:semicolon
id|REG_SHADOW_SET
c_func
(paren
id|R_PORT_PB_DATA
comma
id|port_pb_data_shadow
comma
l_int|7
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* wait some */
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
multiline_comment|/* de-assert bus-reset */
macro_line|#ifdef CONFIG_ETRAX_IDE_CSE1_16_RESET
id|REG_SHADOW_SET
c_func
(paren
id|port_cse1_addr
comma
id|port_cse1_shadow
comma
l_int|16
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_IDE_CSP0_8_RESET
id|REG_SHADOW_SET
c_func
(paren
id|port_csp0_addr
comma
id|port_csp0_shadow
comma
l_int|8
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_IDE_G27_RESET
id|REG_SHADOW_SET
c_func
(paren
id|R_PORT_G_DATA
comma
id|port_g_data_shadow
comma
l_int|27
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* make a dummy read to set the ata controller in a proper state */
id|dummy
op_assign
op_star
id|R_ATA_STATUS_DATA
suffix:semicolon
op_star
id|R_ATA_CONFIG
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|enable
comma
l_int|1
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_strobe
comma
id|ATA_DMA2_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|dma_hold
comma
id|ATA_DMA2_HOLD
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_setup
comma
id|ATA_PIO4_SETUP
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_strobe
comma
id|ATA_PIO4_STROBE
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CONFIG
comma
id|pio_hold
comma
id|ATA_PIO4_HOLD
)paren
)paren
suffix:semicolon
op_star
id|R_ATA_CTRL_DATA
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|read
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|addr
comma
l_int|1
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait for busy flag*/
op_star
id|R_IRQ_MASK0_SET
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|ata_irq0
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|ata_irq1
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|ata_irq2
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK0_SET
comma
id|ata_irq3
comma
id|set
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ide: waiting %d seconds for drives to regain consciousness&bslash;n&quot;
comma
id|CONFIG_ETRAX_IDE_DELAY
)paren
suffix:semicolon
id|h
op_assign
id|jiffies
op_plus
(paren
id|CONFIG_ETRAX_IDE_DELAY
op_star
id|HZ
)paren
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|h
)paren
)paren
(brace
multiline_comment|/* nothing */
suffix:semicolon
)brace
multiline_comment|/* reset the dma channels we will use */
id|RESET_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
id|RESET_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
)brace
DECL|function|e100_dma_off
r_static
r_int
id|e100_dma_off
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|mydescr
r_static
id|etrax_dma_descr
id|mydescr
suffix:semicolon
multiline_comment|/*&n; * The following routines are mainly used by the ATAPI drivers.&n; *&n; * These routines will round up any request for an odd number of bytes,&n; * so if an odd bytecount is specified, be sure that there&squot;s at least one&n; * extra byte allocated for the buffer.&n; */
r_static
r_void
DECL|function|e100_atapi_input_bytes
id|e100_atapi_input_bytes
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bytecount
)paren
(brace
r_int
r_int
id|data_reg
op_assign
id|IDE_DATA_REG
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;atapi_input_bytes, dreg 0x%x, buffer 0x%x, count %d&bslash;n&quot;
comma
id|data_reg
comma
id|buffer
comma
id|bytecount
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytecount
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;warning, odd bytecount in cdrom_in_bytes = %d.&bslash;n&quot;
comma
id|bytecount
)paren
suffix:semicolon
id|bytecount
op_increment
suffix:semicolon
multiline_comment|/* to round off */
)brace
multiline_comment|/* make sure the DMA channel is available */
id|RESET_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* setup DMA descriptor */
id|mydescr.sw_len
op_assign
id|bytecount
suffix:semicolon
id|mydescr.ctrl
op_assign
id|d_eol
suffix:semicolon
id|mydescr.buf
op_assign
id|virt_to_phys
c_func
(paren
id|buffer
)paren
suffix:semicolon
multiline_comment|/* start the dma channel */
op_star
id|R_DMA_CH3_FIRST
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|mydescr
)paren
suffix:semicolon
op_star
id|R_DMA_CH3_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH3_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
multiline_comment|/* initiate a multi word dma read using PIO handshaking */
op_star
id|R_ATA_TRANSFER_CNT
op_assign
id|IO_FIELD
c_func
(paren
id|R_ATA_TRANSFER_CNT
comma
id|count
comma
id|bytecount
op_rshift
l_int|1
)paren
suffix:semicolon
op_star
id|R_ATA_CTRL_DATA
op_assign
id|data_reg
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|read
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|src_dst
comma
id|dma
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|handsh
comma
id|pio
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|multi
comma
id|on
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|dma_size
comma
id|word
)paren
suffix:semicolon
multiline_comment|/* wait for completion */
id|LED_DISK_READ
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|ATA_RX_DMA_NBR
)paren
suffix:semicolon
id|LED_DISK_READ
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* old polled transfer code&n;&t; * this should be moved into a new function that can do polled&n;&t; * transfers if DMA is not available&n;&t; */
multiline_comment|/* initiate a multi word read */
op_star
id|R_ATA_TRANSFER_CNT
op_assign
id|wcount
op_lshift
l_int|1
suffix:semicolon
op_star
id|R_ATA_CTRL_DATA
op_assign
id|data_reg
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|read
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|src_dst
comma
r_register
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|handsh
comma
id|pio
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|multi
comma
id|on
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|dma_size
comma
id|word
)paren
suffix:semicolon
multiline_comment|/* svinto has a latency until the busy bit actually is set */
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* unit should be busy during multi transfer */
r_while
c_loop
(paren
(paren
id|status
op_assign
op_star
id|R_ATA_STATUS_DATA
)paren
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|status
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|dav
)paren
)paren
)paren
(brace
id|status
op_assign
op_star
id|R_ATA_STATUS_DATA
suffix:semicolon
)brace
op_star
id|ptr
op_increment
op_assign
(paren
r_int
r_int
)paren
(paren
id|status
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_static
r_void
DECL|function|e100_atapi_output_bytes
id|e100_atapi_output_bytes
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bytecount
)paren
(brace
r_int
r_int
id|data_reg
op_assign
id|IDE_DATA_REG
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;atapi_output_bytes, dreg 0x%x, buffer 0x%x, count %d&bslash;n&quot;
comma
id|data_reg
comma
id|buffer
comma
id|bytecount
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytecount
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;odd bytecount %d in atapi_out_bytes!&bslash;n&quot;
comma
id|bytecount
)paren
suffix:semicolon
id|bytecount
op_increment
suffix:semicolon
)brace
multiline_comment|/* make sure the DMA channel is available */
id|RESET_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
multiline_comment|/* setup DMA descriptor */
id|mydescr.sw_len
op_assign
id|bytecount
suffix:semicolon
id|mydescr.ctrl
op_assign
id|d_eol
suffix:semicolon
id|mydescr.buf
op_assign
id|virt_to_phys
c_func
(paren
id|buffer
)paren
suffix:semicolon
multiline_comment|/* start the dma channel */
op_star
id|R_DMA_CH2_FIRST
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|mydescr
)paren
suffix:semicolon
op_star
id|R_DMA_CH2_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH2_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
multiline_comment|/* initiate a multi word dma write using PIO handshaking */
op_star
id|R_ATA_TRANSFER_CNT
op_assign
id|IO_FIELD
c_func
(paren
id|R_ATA_TRANSFER_CNT
comma
id|count
comma
id|bytecount
op_rshift
l_int|1
)paren
suffix:semicolon
op_star
id|R_ATA_CTRL_DATA
op_assign
id|data_reg
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|write
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|src_dst
comma
id|dma
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|handsh
comma
id|pio
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|multi
comma
id|on
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|dma_size
comma
id|word
)paren
suffix:semicolon
multiline_comment|/* wait for completion */
id|LED_DISK_WRITE
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|WAIT_DMA
c_func
(paren
id|ATA_TX_DMA_NBR
)paren
suffix:semicolon
id|LED_DISK_WRITE
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* old polled write code - see comment in input_bytes */
multiline_comment|/* wait for busy flag */
r_while
c_loop
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* initiate a multi word write */
op_star
id|R_ATA_TRANSFER_CNT
op_assign
id|bytecount
op_rshift
l_int|1
suffix:semicolon
id|ctrl
op_assign
id|data_reg
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|write
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|src_dst
comma
r_register
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|handsh
comma
id|pio
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|multi
comma
id|on
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|dma_size
comma
id|word
)paren
suffix:semicolon
id|LED_DISK_WRITE
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Etrax will set busy = 1 until the multi pio transfer has finished&n;         * and tr_rdy = 1 after each successful word transfer.&n;         * When the last byte has been transferred Etrax will first set tr_tdy = 1&n;         * and then busy = 0 (not in the same cycle). If we read busy before it&n;         * has been set to 0 we will think that we should transfer more bytes&n;         * and then tr_rdy would be 0 forever. This is solved by checking busy&n;         * in the inner loop.&n;         */
r_do
(brace
op_star
id|R_ATA_CTRL_DATA
op_assign
id|ctrl
op_or
op_star
id|ptr
op_increment
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|tr_rdy
)paren
)paren
op_logical_and
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_star
id|R_ATA_STATUS_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_ATA_STATUS_DATA
comma
id|busy
)paren
)paren
(brace
suffix:semicolon
)brace
id|LED_DISK_WRITE
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * This is used for most PIO data transfers *from* the IDE interface&n; */
r_static
r_void
DECL|function|e100_ide_input_data
id|e100_ide_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|e100_atapi_input_bytes
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
op_lshift
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is used for most PIO data transfers *to* the IDE interface&n; */
r_static
r_void
DECL|function|e100_ide_output_data
id|e100_ide_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
id|e100_atapi_output_bytes
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
op_lshift
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* we only have one DMA channel on the chip for ATA, so we can keep these statically */
DECL|variable|ata_descrs
r_static
id|etrax_dma_descr
id|ata_descrs
(braket
id|MAX_DMA_DESCRS
)braket
suffix:semicolon
DECL|variable|ata_tot_size
r_static
r_int
r_int
id|ata_tot_size
suffix:semicolon
multiline_comment|/*&n; * e100_ide_build_dmatable() prepares a dma request.&n; * Returns 0 if all went okay, returns 1 otherwise.&n; */
DECL|function|e100_ide_build_dmatable
r_static
r_int
id|e100_ide_build_dmatable
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
r_int
id|size
comma
id|addr
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|sg
op_assign
id|hwif-&gt;sg_table
suffix:semicolon
id|ata_tot_size
op_assign
l_int|0
suffix:semicolon
id|ide_map_sg
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
id|i
op_assign
id|hwif-&gt;sg_nents
suffix:semicolon
r_while
c_loop
(paren
id|i
)paren
(brace
multiline_comment|/*&n;&t;&t; * Determine addr and size of next buffer area.  We assume that&n;&t;&t; * individual virtual buffers are always composed linearly in&n;&t;&t; * physical memory.  For example, we assume that any 8kB buffer&n;&t;&t; * is always composed of two adjacent physical 4kB pages rather&n;&t;&t; * than two possibly non-adjacent physical 4kB pages.&n;&t;&t; */
multiline_comment|/* group sequential buffers into one large buffer */
id|addr
op_assign
id|page_to_phys
c_func
(paren
id|sg-&gt;page
)paren
op_plus
id|sg-&gt;offset
suffix:semicolon
id|size
op_assign
id|sg_dma_len
c_func
(paren
id|sg
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sg
op_increment
comma
op_decrement
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_plus
id|size
)paren
op_ne
id|page_to_phys
c_func
(paren
id|sg-&gt;page
)paren
op_plus
id|sg-&gt;offset
)paren
r_break
suffix:semicolon
id|size
op_add_assign
id|sg_dma_len
c_func
(paren
id|sg
)paren
suffix:semicolon
)brace
multiline_comment|/* did we run out of descriptors? */
r_if
c_cond
(paren
id|count
op_ge
id|MAX_DMA_DESCRS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: too few DMA descriptors&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* however, this case is more difficult - R_ATA_TRANSFER_CNT cannot be more&n;&t;&t;   than 65536 words per transfer, so in that case we need to either&n;&t;&t;   1) use a DMA interrupt to re-trigger R_ATA_TRANSFER_CNT and continue with&n;&t;&t;      the descriptors, or&n;&t;&t;   2) simply do the request here, and get dma_intr to only ide_end_request on&n;&t;&t;      those blocks that were actually set-up for transfer.&n;&t;&t;*/
r_if
c_cond
(paren
id|ata_tot_size
op_plus
id|size
OG
l_int|131072
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;too large total ATA DMA request, %d + %d!&bslash;n&quot;
comma
id|ata_tot_size
comma
(paren
r_int
)paren
id|size
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If size &gt; 65536 it has to be splitted into new descriptors. Since we don&squot;t handle&n;                   size &gt; 131072 only one split is necessary */
r_if
c_cond
(paren
id|size
OG
l_int|65536
)paren
(brace
multiline_comment|/* ok we want to do IO at addr, size bytes. set up a new descriptor entry */
id|ata_descrs
(braket
id|count
)braket
dot
id|sw_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0 means 65536, this is a 16-bit field */
id|ata_descrs
(braket
id|count
)braket
dot
id|ctrl
op_assign
l_int|0
suffix:semicolon
id|ata_descrs
(braket
id|count
)braket
dot
id|buf
op_assign
id|addr
suffix:semicolon
id|ata_descrs
(braket
id|count
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|ata_descrs
(braket
id|count
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|ata_tot_size
op_add_assign
l_int|65536
suffix:semicolon
multiline_comment|/* size and addr should refere to not handled data */
id|size
op_sub_assign
l_int|65536
suffix:semicolon
id|addr
op_add_assign
l_int|65536
suffix:semicolon
)brace
multiline_comment|/* ok we want to do IO at addr, size bytes. set up a new descriptor entry */
r_if
c_cond
(paren
id|size
op_eq
l_int|65536
)paren
(brace
id|ata_descrs
(braket
id|count
)braket
dot
id|sw_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0 means 65536, this is a 16-bit field */
)brace
r_else
(brace
id|ata_descrs
(braket
id|count
)braket
dot
id|sw_len
op_assign
id|size
suffix:semicolon
)brace
id|ata_descrs
(braket
id|count
)braket
dot
id|ctrl
op_assign
l_int|0
suffix:semicolon
id|ata_descrs
(braket
id|count
)braket
dot
id|buf
op_assign
id|addr
suffix:semicolon
id|ata_descrs
(braket
id|count
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|ata_descrs
(braket
id|count
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|ata_tot_size
op_add_assign
id|size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
multiline_comment|/* set the end-of-list flag on the last descriptor */
id|ata_descrs
(braket
id|count
op_minus
l_int|1
)braket
dot
id|ctrl
op_or_assign
id|d_eol
suffix:semicolon
multiline_comment|/* return and say all is ok */
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: empty DMA table?&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* let the PIO routines handle this weirdness */
)brace
DECL|function|config_drive_for_dma
r_static
r_int
id|config_drive_for_dma
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_const
r_char
op_star
op_star
id|list
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_if
c_cond
(paren
id|id
op_logical_and
(paren
id|id-&gt;capability
op_amp
l_int|1
)paren
)paren
(brace
multiline_comment|/* Enable DMA on any drive that supports mword2 DMA */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
op_logical_and
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
)paren
(brace
id|drive-&gt;using_dma
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* DMA enabled */
)brace
multiline_comment|/* Consult the list of known &quot;good&quot; drives */
id|list
op_assign
id|good_dma_drives
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|list
op_increment
comma
id|id-&gt;model
)paren
)paren
(brace
id|drive-&gt;using_dma
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* DMA enabled */
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* DMA not enabled */
)brace
multiline_comment|/*&n; * etrax_dma_intr() is the handler for disk read/write DMA interrupts&n; */
DECL|function|etrax_dma_intr
r_static
id|ide_startstop_t
id|etrax_dma_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|LED_DISK_READ
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|LED_DISK_WRITE
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
id|ide_dma_intr
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Functions below initiates/aborts DMA read/write operations on a drive.&n; *&n; * The caller is assumed to have selected the drive and programmed the drive&squot;s&n; * sector address using CHS or LBA.  All that remains is to prepare for DMA&n; * and then issue the actual read/write DMA/PIO command to the drive.&n; *&n; * Returns 0 if all went well.&n; * Returns 1 if DMA read/write could not be started, in which case&n; * the caller should revert to PIO for the current request.&n; */
DECL|function|e100_dma_check
r_static
r_int
id|e100_dma_check
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
id|config_drive_for_dma
(paren
id|drive
)paren
suffix:semicolon
)brace
DECL|function|e100_dma_end
r_static
r_int
id|e100_dma_end
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
multiline_comment|/* TODO: check if something went wrong with the DMA */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|e100_dma_start
r_static
r_void
id|e100_dma_start
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
id|e100_read_command
)paren
(brace
multiline_comment|/* begin DMA */
multiline_comment|/* need to do this before RX DMA due to a chip bug&n;&t;&t; * it is enough to just flush the part of the cache that&n;&t;&t; * corresponds to the buffers we start, but since HD transfers&n;&t;&t; * usually are more than 8 kB, it is easier to optimize for the&n;&t;&t; * normal case and just flush the entire cache. its the only&n;&t;&t; * way to be sure! (OB movie quote)&n;&t;&t; */
id|flush_etrax_cache
c_func
(paren
)paren
suffix:semicolon
op_star
id|R_DMA_CH3_FIRST
op_assign
id|virt_to_phys
c_func
(paren
id|ata_descrs
)paren
suffix:semicolon
op_star
id|R_DMA_CH3_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH3_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
multiline_comment|/* initiate a multi word dma read using DMA handshaking */
op_star
id|R_ATA_TRANSFER_CNT
op_assign
id|IO_FIELD
c_func
(paren
id|R_ATA_TRANSFER_CNT
comma
id|count
comma
id|ata_tot_size
op_rshift
l_int|1
)paren
suffix:semicolon
op_star
id|R_ATA_CTRL_DATA
op_assign
id|IO_FIELD
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|data
comma
id|IDE_DATA_REG
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|read
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|src_dst
comma
id|dma
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|handsh
comma
id|dma
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|multi
comma
id|on
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|dma_size
comma
id|word
)paren
suffix:semicolon
id|LED_DISK_READ
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;dma read of %d bytes.&bslash;n&quot;
comma
id|ata_tot_size
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* writing */
multiline_comment|/* begin DMA */
op_star
id|R_DMA_CH2_FIRST
op_assign
id|virt_to_phys
c_func
(paren
id|ata_descrs
)paren
suffix:semicolon
op_star
id|R_DMA_CH2_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH2_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
multiline_comment|/* initiate a multi word dma write using DMA handshaking */
op_star
id|R_ATA_TRANSFER_CNT
op_assign
id|IO_FIELD
c_func
(paren
id|R_ATA_TRANSFER_CNT
comma
id|count
comma
id|ata_tot_size
op_rshift
l_int|1
)paren
suffix:semicolon
op_star
id|R_ATA_CTRL_DATA
op_assign
id|IO_FIELD
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|data
comma
id|IDE_DATA_REG
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|rw
comma
id|write
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|src_dst
comma
id|dma
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|handsh
comma
id|dma
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|multi
comma
id|on
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_ATA_CTRL_DATA
comma
id|dma_size
comma
id|word
)paren
suffix:semicolon
id|LED_DISK_WRITE
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;dma write of %d bytes.&bslash;n&quot;
comma
id|ata_tot_size
)paren
)paren
suffix:semicolon
)brace
)brace
eof
