multiline_comment|/*&n; *&t;IDE I/O functions&n; *&n; *&t;Basic PIO and command management functionality.&n; *&n; * This code was split off from ide.c. See ide.c for history and original&n; * copyrights.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * For the avoidance of doubt the &quot;preferred form&quot; of this code is one which&n; * is in an open non patent encumbered format. Where cryptographic key signing&n; * forms part of the process of creating an executable the information&n; * including keys needed to generate an equivalently functional executable&n; * are deemed to be part of the source code.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
multiline_comment|/**&n; *&t;ide_end_request&t;&t;-&t;complete an IDE I/O&n; *&t;@drive: IDE device for the I/O&n; *&t;@uptodate: &n; *&t;@nr_sectors: number of sectors completed&n; *&n; *&t;This is our end_request wrapper function. We complete the I/O&n; *&t;update random number input and dequeue the request, which if&n; *&t;it was tagged may be out of order.&n; */
DECL|function|ide_end_request
r_int
id|ide_end_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|uptodate
comma
r_int
id|nr_sectors
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
id|REQ_STARTED
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_sectors
)paren
id|nr_sectors
op_assign
id|rq-&gt;hard_cur_sectors
suffix:semicolon
multiline_comment|/*&n;&t; * if failfast is set on a request, override number of sectors and&n;&t; * complete the whole request right now&n;&t; */
r_if
c_cond
(paren
id|blk_noretry_request
c_func
(paren
id|rq
)paren
op_logical_and
op_logical_neg
id|uptodate
)paren
id|nr_sectors
op_assign
id|rq-&gt;hard_nr_sectors
suffix:semicolon
multiline_comment|/*&n;&t; * decide whether to reenable DMA -- 3 is a random magic for now,&n;&t; * if we DMA timeout more than 3 times, just stay in PIO&n;&t; */
r_if
c_cond
(paren
id|drive-&gt;state
op_eq
id|DMA_PIO_RETRY
op_logical_and
id|drive-&gt;retry_pio
op_le
l_int|3
)paren
(brace
id|drive-&gt;state
op_assign
l_int|0
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|hwif
op_member_access_from_pointer
id|ide_dma_on
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|end_that_request_first
c_func
(paren
id|rq
comma
id|uptodate
comma
id|nr_sectors
)paren
)paren
(brace
id|add_disk_randomness
c_func
(paren
id|rq-&gt;rq_disk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
id|blkdev_dequeue_request
c_func
(paren
id|rq
)paren
suffix:semicolon
r_else
id|blk_queue_end_tag
c_func
(paren
id|drive-&gt;queue
comma
id|rq
)paren
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|rq
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|ide_end_request
id|EXPORT_SYMBOL
c_func
(paren
id|ide_end_request
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_complete_pm_request - end the current Power Management request&n; *&t;@drive: target drive&n; *&t;@rq: request&n; *&n; *&t;This function cleans up the current PM request and stops the queue&n; *&t;if necessary.&n; */
DECL|function|ide_complete_pm_request
r_static
r_void
id|ide_complete_pm_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_PM
id|printk
c_func
(paren
l_string|&quot;%s: completing PM request, %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|blk_pm_suspend_request
c_func
(paren
id|rq
)paren
ques
c_cond
l_string|&quot;suspend&quot;
suffix:colon
l_string|&quot;resume&quot;
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_pm_suspend_request
c_func
(paren
id|rq
)paren
)paren
(brace
id|blk_stop_queue
c_func
(paren
id|drive-&gt;queue
)paren
suffix:semicolon
)brace
r_else
(brace
id|drive-&gt;blocked
op_assign
l_int|0
suffix:semicolon
id|blk_start_queue
c_func
(paren
id|drive-&gt;queue
)paren
suffix:semicolon
)brace
id|blkdev_dequeue_request
c_func
(paren
id|rq
)paren
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|rq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_end_drive_cmd&t;-&t;end an explicit drive command&n; *&t;@drive: command &n; *&t;@stat: status bits&n; *&t;@err: error bits&n; *&n; *&t;Clean up after success/failure of an explicit drive command.&n; *&t;These get thrown onto the queue so they are synchronized with&n; *&t;real I/O operations on the drive.&n; *&n; *&t;In LBA48 mode we have to read the register set twice to get&n; *&t;all the extra information out.&n; */
DECL|function|ide_end_drive_cmd
r_void
id|ide_end_drive_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|stat
comma
id|u8
id|err
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_CMD
)paren
(brace
id|u8
op_star
id|args
op_assign
(paren
id|u8
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;errors
op_eq
l_int|0
)paren
id|rq-&gt;errors
op_assign
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
)paren
(brace
id|args
(braket
l_int|0
)braket
op_assign
id|stat
suffix:semicolon
id|args
(braket
l_int|1
)braket
op_assign
id|err
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASK
)paren
(brace
id|u8
op_star
id|args
op_assign
(paren
id|u8
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;errors
op_eq
l_int|0
)paren
id|rq-&gt;errors
op_assign
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
)paren
(brace
id|args
(braket
l_int|0
)braket
op_assign
id|stat
suffix:semicolon
id|args
(braket
l_int|1
)braket
op_assign
id|err
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args
(braket
l_int|3
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args
(braket
l_int|4
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args
(braket
l_int|5
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|args
(braket
l_int|6
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
(brace
id|ide_task_t
op_star
id|args
op_assign
(paren
id|ide_task_t
op_star
)paren
id|rq-&gt;special
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;errors
op_eq
l_int|0
)paren
id|rq-&gt;errors
op_assign
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
)paren
(brace
r_if
c_cond
(paren
id|args-&gt;tf_in_flags.b.data
)paren
(brace
id|u16
id|data
op_assign
id|hwif
op_member_access_from_pointer
id|INW
c_func
(paren
id|IDE_DATA_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_DATA_OFFSET
)braket
op_assign
(paren
id|data
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_DATA_OFFSET_HOB
)braket
op_assign
(paren
id|data
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
)brace
id|args-&gt;tfRegister
(braket
id|IDE_ERROR_OFFSET
)braket
op_assign
id|err
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_NSECTOR_OFFSET
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_SECTOR_OFFSET
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_LCYL_OFFSET
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_HCYL_OFFSET
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_SELECT_OFFSET
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|args-&gt;tfRegister
(braket
id|IDE_STATUS_OFFSET
)braket
op_assign
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
(brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|0x80
comma
id|IDE_CONTROL_REG_HOB
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_FEATURE_OFFSET_HOB
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_NSECTOR_OFFSET_HOB
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_SECTOR_OFFSET_HOB
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_LCYL_OFFSET_HOB
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args-&gt;hobRegister
(braket
id|IDE_HCYL_OFFSET_HOB
)braket
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|blk_pm_request
c_func
(paren
id|rq
)paren
)paren
(brace
macro_line|#ifdef DEBUG_PM
id|printk
c_func
(paren
l_string|&quot;%s: complete_power_step(step: %d, stat: %x, err: %x)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;pm-&gt;pm_step
comma
id|stat
comma
id|err
)paren
suffix:semicolon
macro_line|#endif
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|complete_power_step
c_func
(paren
id|drive
comma
id|rq
comma
id|stat
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;pm-&gt;pm_step
op_eq
id|ide_pm_state_completed
)paren
id|ide_complete_pm_request
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|rq
)paren
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|rq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|ide_end_drive_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ide_end_drive_cmd
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;try_to_flush_leftover_data&t;-&t;flush junk&n; *&t;@drive: drive to flush&n; *&n; *&t;try_to_flush_leftover_data() is invoked in response to a drive&n; *&t;unexpectedly having its DRQ_STAT bit set.  As an alternative to&n; *&t;resetting the drive, this routine tries to clear the condition&n; *&t;by read a sector&squot;s worth of data from the drive.  Of course,&n; *&t;this may not help if the drive is *waiting* for data from *us*.&n; */
DECL|function|try_to_flush_leftover_data
r_void
id|try_to_flush_leftover_data
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|i
op_assign
(paren
id|drive-&gt;mult_count
ques
c_cond
id|drive-&gt;mult_count
suffix:colon
l_int|1
)paren
op_star
id|SECTOR_WORDS
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
(brace
id|u32
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
id|u32
id|wcount
op_assign
(paren
id|i
OG
l_int|16
)paren
ques
c_cond
l_int|16
suffix:colon
id|i
suffix:semicolon
id|i
op_sub_assign
id|wcount
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ata_input_data
c_func
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
)brace
DECL|variable|try_to_flush_leftover_data
id|EXPORT_SYMBOL
c_func
(paren
id|try_to_flush_leftover_data
)paren
suffix:semicolon
multiline_comment|/*&n; * FIXME Add an ATAPI error&n; */
multiline_comment|/**&n; *&t;ide_error&t;-&t;handle an error on the IDE&n; *&t;@drive: drive the error occurred on&n; *&t;@msg: message to report&n; *&t;@stat: status bits&n; *&n; *&t;ide_error() takes action based on the error returned by the drive.&n; *&t;For normal I/O that may well include retries. We deal with&n; *&t;both new-style (taskfile) and old style command handling here.&n; *&t;In the case of taskfile command handling there is work left to&n; *&t;do&n; */
DECL|function|ide_error
id|ide_startstop_t
id|ide_error
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|u8
id|stat
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|u8
id|err
suffix:semicolon
id|err
op_assign
id|ide_dump_status
c_func
(paren
id|drive
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
l_int|NULL
op_logical_or
(paren
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* retry only &quot;normal&quot; I/O: */
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
(paren
id|REQ_DRIVE_CMD
op_or
id|REQ_DRIVE_TASK
)paren
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|err
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|err
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
op_logical_or
(paren
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
op_logical_and
op_logical_neg
id|drive-&gt;nowerr
)paren
)paren
(brace
multiline_comment|/* other bits are useless when BUSY */
id|rq-&gt;errors
op_or_assign
id|ERROR_RESET
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_goto
id|media_out
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
multiline_comment|/* err has different meaning on cdrom and tape */
r_if
c_cond
(paren
id|err
op_eq
id|ABRT_ERR
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;select.b.lba
op_logical_and
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_COMMAND_REG
)paren
op_eq
id|WIN_SPECIFY
)paren
)paren
multiline_comment|/* some newer drives don&squot;t&n;&t;&t;&t;&t;&t; * support WIN_SPECIFY&n;&t;&t;&t;&t;&t; */
r_return
id|ide_stopped
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
id|BAD_CRC
)paren
op_eq
id|BAD_CRC
)paren
(brace
id|drive-&gt;crc_count
op_increment
suffix:semicolon
multiline_comment|/* UDMA crc error -- just retry the operation */
)brace
r_else
r_if
c_cond
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ECC_ERR
)paren
)paren
(brace
multiline_comment|/* retries won&squot;t help these */
id|rq-&gt;errors
op_assign
id|ERROR_MAX
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
(brace
multiline_comment|/* help it find track zero */
id|rq-&gt;errors
op_or_assign
id|ERROR_RECAL
suffix:semicolon
)brace
)brace
id|media_out
suffix:colon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_logical_and
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_ne
id|WRITE
)paren
id|try_to_flush_leftover_data
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
op_amp
(paren
id|BUSY_STAT
op_or
id|DRQ_STAT
)paren
)paren
(brace
multiline_comment|/* force an abort */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|WIN_IDLEIMMEDIATE
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;errors
op_ge
id|ERROR_MAX
)paren
(brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RESET
)paren
op_eq
id|ERROR_RESET
)paren
(brace
op_increment
id|rq-&gt;errors
suffix:semicolon
r_return
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RECAL
)paren
op_eq
id|ERROR_RECAL
)paren
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
op_increment
id|rq-&gt;errors
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|ide_error
id|EXPORT_SYMBOL
c_func
(paren
id|ide_error
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_abort&t;-&t;abort pending IDE operatins&n; *&t;@drive: drive the error occurred on&n; *&t;@msg: message to report&n; *&n; *&t;ide_abort kills and cleans up when we are about to do a &n; *&t;host initiated reset on active commands. Longer term we&n; *&t;want handlers to have sensible abort handling themselves&n; *&n; *&t;This differs fundamentally from ide_error because in &n; *&t;this case the command is doing just fine when we&n; *&t;blow it away.&n; */
DECL|function|ide_abort
id|ide_startstop_t
id|ide_abort
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
l_int|NULL
op_logical_or
(paren
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* retry only &quot;normal&quot; I/O: */
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
(paren
id|REQ_DRIVE_CMD
op_or
id|REQ_DRIVE_TASK
)paren
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|BUSY_STAT
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|BUSY_STAT
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
id|rq-&gt;errors
op_or_assign
id|ERROR_RESET
suffix:semicolon
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|ide_abort
id|EXPORT_SYMBOL
c_func
(paren
id|ide_abort
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_cmd&t;&t;-&t;issue a simple drive command&n; *&t;@drive: drive the command is for&n; *&t;@cmd: command byte&n; *&t;@nsect: sector byte&n; *&t;@handler: handler for the command completion&n; *&n; *&t;Issue a simple drive command with interrupts.&n; *&t;The drive must be selected beforehand.&n; */
DECL|function|ide_cmd
r_void
id|ide_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|cmd
comma
id|u8
id|nsect
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear nIEN */
id|SELECT_MASK
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|nsect
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|ide_execute_command
c_func
(paren
id|drive
comma
id|cmd
comma
id|handler
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|variable|ide_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ide_cmd
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;drive_cmd_intr&t;&t;- &t;drive command completion interrupt&n; *&t;@drive: drive the completion interrupt occurred on&n; *&n; *&t;drive_cmd_intr() is invoked on completion of a special DRIVE_CMD.&n; *&t;We do any necessary daya reading and then wait for the drive to&n; *&t;go non busy. At that point we may read the error data and complete&n; *&t;the request&n; */
DECL|function|drive_cmd_intr
id|ide_startstop_t
id|drive_cmd_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
op_star
id|args
op_assign
(paren
id|u8
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_int
id|retries
op_assign
l_int|10
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_logical_and
id|args
op_logical_and
id|args
(braket
l_int|3
)braket
)paren
(brace
id|u8
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|ata_input_data
c_func
(paren
id|drive
comma
op_amp
id|args
(braket
l_int|4
)braket
comma
id|args
(braket
l_int|3
)braket
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
id|io_32bit
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
op_logical_and
id|DRIVER
c_func
(paren
id|drive
)paren
op_ne
l_int|NULL
)paren
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;drive_cmd&quot;
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/* calls ide_end_drive_cmd */
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|drive_cmd_intr
id|EXPORT_SYMBOL
c_func
(paren
id|drive_cmd_intr
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;do_special&t;&t;-&t;issue some special commands&n; *&t;@drive: drive the command is for&n; *&n; *&t;do_special() is used to issue WIN_SPECIFY, WIN_RESTORE, and WIN_SETMULT&n; *&t;commands to a drive.  It used to do much more, but has been scaled&n; *&t;back.&n; */
DECL|function|do_special
id|ide_startstop_t
id|do_special
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|special_t
op_star
id|s
op_assign
op_amp
id|drive-&gt;special
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: do_special: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|s-&gt;all
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|s-&gt;b.set_tune
)paren
(brace
id|s-&gt;b.set_tune
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|tuneproc
op_ne
l_int|NULL
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|tuneproc
c_func
(paren
id|drive
comma
id|drive-&gt;tune_req
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_else
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|special
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
DECL|variable|do_special
id|EXPORT_SYMBOL
c_func
(paren
id|do_special
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;execute_drive_command&t;-&t;issue special drive command&n; *&t;@drive: the drive to issue th command on&n; *&t;@rq: the request structure holding the command&n; *&n; *&t;execute_drive_cmd() issues a special drive command,  usually &n; *&t;initiated by ioctl() from the external hdparm program. The&n; *&t;command can be a drive command, drive task or taskfile &n; *&t;operation. Weirdly you can call it with NULL to wait for&n; *&t;all commands to finish. Don&squot;t do this as that is due to change&n; */
DECL|function|execute_drive_cmd
id|ide_startstop_t
id|execute_drive_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
(brace
id|ide_task_t
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|args
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;tf_out_flags.all
op_ne
l_int|0
)paren
r_return
id|flagged_taskfile
c_func
(paren
id|drive
comma
id|args
)paren
suffix:semicolon
r_return
id|do_rw_taskfile
c_func
(paren
id|drive
comma
id|args
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASK
)paren
(brace
id|u8
op_star
id|args
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|u8
id|sel
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|args
)paren
r_goto
id|done
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: DRIVE_TASK_CMD &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cmd=0x%02x &quot;
comma
id|args
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fr=0x%02x &quot;
comma
id|args
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ns=0x%02x &quot;
comma
id|args
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sc=0x%02x &quot;
comma
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;lcyl=0x%02x &quot;
comma
id|args
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;hcyl=0x%02x &quot;
comma
id|args
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sel=0x%02x&bslash;n&quot;
comma
id|args
(braket
l_int|6
)braket
)paren
suffix:semicolon
macro_line|#endif
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|args
(braket
l_int|1
)braket
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|args
(braket
l_int|3
)braket
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|args
(braket
l_int|4
)braket
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|args
(braket
l_int|5
)braket
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|sel
op_assign
(paren
id|args
(braket
l_int|6
)braket
op_amp
op_complement
l_int|0x10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
)paren
id|sel
op_or_assign
l_int|0x10
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|sel
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|ide_cmd
c_func
(paren
id|drive
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|2
)braket
comma
op_amp
id|drive_cmd_intr
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_CMD
)paren
(brace
id|u8
op_star
id|args
op_assign
id|rq-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|args
)paren
r_goto
id|done
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: DRIVE_CMD &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cmd=0x%02x &quot;
comma
id|args
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sc=0x%02x &quot;
comma
id|args
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fr=0x%02x &quot;
comma
id|args
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;xx=0x%02x&bslash;n&quot;
comma
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|args
(braket
l_int|0
)braket
op_eq
id|WIN_SMART
)paren
(brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0x4f
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0xc2
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|args
(braket
l_int|2
)braket
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|args
(braket
l_int|1
)braket
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|ide_cmd
c_func
(paren
id|drive
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|3
)braket
comma
op_amp
id|drive_cmd_intr
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|args
(braket
l_int|2
)braket
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|ide_cmd
c_func
(paren
id|drive
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|1
)braket
comma
op_amp
id|drive_cmd_intr
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
id|done
suffix:colon
multiline_comment|/*&n; &t; * NULL is actually a valid way of waiting for&n; &t; * all current requests to be flushed from the queue.&n; &t; */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: DRIVE_CMD (null)&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|execute_drive_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|execute_drive_cmd
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;start_request&t;-&t;start of I/O and command issuing for IDE&n; *&n; *&t;start_request() initiates handling of a new I/O request. It&n; *&t;accepts commands and I/O (read/write) requests. It also does&n; *&t;the final remapping for weird stuff like EZDrive. Once &n; *&t;device mapper can work sector level the EZDrive stuff can go away&n; *&n; *&t;FIXME: this function needs a rename&n; */
DECL|function|start_request
id|ide_startstop_t
id|start_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_startstop_t
id|startstop
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
id|REQ_STARTED
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: start_request: current=0x%08lx&bslash;n&quot;
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|name
comma
(paren
r_int
r_int
)paren
id|rq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* bail early if we&squot;ve exceeded max_failures */
r_if
c_cond
(paren
id|drive-&gt;max_failures
op_logical_and
(paren
id|drive-&gt;failures
OG
id|drive-&gt;max_failures
)paren
)paren
(brace
r_goto
id|kill_rq
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * bail early if we&squot;ve sent a device to sleep, however how to wake&n;&t; * this needs to be a masked flag.  FIXME for proper operations.&n;&t; */
r_if
c_cond
(paren
id|drive-&gt;suspend_reset
)paren
r_goto
id|kill_rq
suffix:semicolon
id|block
op_assign
id|rq-&gt;sector
suffix:semicolon
r_if
c_cond
(paren
id|blk_fs_request
c_func
(paren
id|rq
)paren
op_logical_and
(paren
id|drive-&gt;media
op_eq
id|ide_disk
op_logical_or
id|drive-&gt;media
op_eq
id|ide_floppy
)paren
)paren
(brace
id|block
op_add_assign
id|drive-&gt;sect0
suffix:semicolon
)brace
multiline_comment|/* Yecch - this will shift the entire interval,&n;&t;   possibly killing some innocent following sector */
r_if
c_cond
(paren
id|block
op_eq
l_int|0
op_logical_and
id|drive-&gt;remap_0_to_1
op_eq
l_int|1
)paren
id|block
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* redirect MBR access to EZ-Drive partn table */
r_if
c_cond
(paren
id|blk_pm_suspend_request
c_func
(paren
id|rq
)paren
op_logical_and
id|rq-&gt;pm-&gt;pm_step
op_eq
id|ide_pm_state_start_suspend
)paren
multiline_comment|/* Mark drive blocked when starting the suspend sequence. */
id|drive-&gt;blocked
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|blk_pm_resume_request
c_func
(paren
id|rq
)paren
op_logical_and
id|rq-&gt;pm-&gt;pm_step
op_eq
id|ide_pm_state_start_resume
)paren
(brace
multiline_comment|/* &n;&t;&t; * The first thing we do on wakeup is to wait for BSY bit to&n;&t;&t; * go away (with a looong timeout) as a drive on this hwif may&n;&t;&t; * just be POSTing itself.&n;&t;&t; * We do that before even selecting as the &quot;other&quot; device on&n;&t;&t; * the bus may be broken enough to walk on our toes at this&n;&t;&t; * point.&n;&t;&t; */
r_int
id|rc
suffix:semicolon
macro_line|#ifdef DEBUG_PM
id|printk
c_func
(paren
l_string|&quot;%s: Wakeup request inited, waiting for !BSY...&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|rc
op_assign
id|ide_wait_not_busy
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
l_int|35000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: bus not ready on wakeup&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|SELECT_DRIVE
c_func
(paren
id|drive
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|8
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
suffix:semicolon
id|rc
op_assign
id|ide_wait_not_busy
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
comma
l_int|10000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: drive not ready on wakeup&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
id|SELECT_DRIVE
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|drive-&gt;ready_stat
comma
id|BUSY_STAT
op_or
id|DRQ_STAT
comma
id|WAIT_READY
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: drive not ready for command&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;special.all
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
(paren
id|REQ_DRIVE_CMD
op_or
id|REQ_DRIVE_TASK
)paren
)paren
r_return
id|execute_drive_cmd
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
r_return
id|execute_drive_cmd
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|blk_pm_request
c_func
(paren
id|rq
)paren
)paren
(brace
macro_line|#ifdef DEBUG_PM
id|printk
c_func
(paren
l_string|&quot;%s: start_power_step(step: %d)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;pm-&gt;pm_step
)paren
suffix:semicolon
macro_line|#endif
id|startstop
op_assign
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|start_power_step
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_stopped
op_logical_and
id|rq-&gt;pm-&gt;pm_step
op_eq
id|ide_pm_state_completed
)paren
id|ide_complete_pm_request
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
r_return
(paren
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|do_request
c_func
(paren
id|drive
comma
id|rq
comma
id|block
)paren
)paren
suffix:semicolon
)brace
r_return
id|do_special
c_func
(paren
id|drive
)paren
suffix:semicolon
id|kill_rq
suffix:colon
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|variable|start_request
id|EXPORT_SYMBOL
c_func
(paren
id|start_request
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_stall_queue&t;&t;-&t;pause an IDE device&n; *&t;@drive: drive to stall&n; *&t;@timeout: time to stall for (jiffies)&n; *&n; *&t;ide_stall_queue() can be used by a drive to give excess bandwidth back&n; *&t;to the hwgroup by sleeping for timeout jiffies.&n; */
DECL|function|ide_stall_queue
r_void
id|ide_stall_queue
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|timeout
)paren
(brace
r_if
c_cond
(paren
id|timeout
OG
id|WAIT_WORSTCASE
)paren
id|timeout
op_assign
id|WAIT_WORSTCASE
suffix:semicolon
id|drive-&gt;sleep
op_assign
id|timeout
op_plus
id|jiffies
suffix:semicolon
)brace
DECL|variable|ide_stall_queue
id|EXPORT_SYMBOL
c_func
(paren
id|ide_stall_queue
)paren
suffix:semicolon
DECL|macro|WAKEUP
mdefine_line|#define WAKEUP(drive)&t;((drive)-&gt;service_start + 2 * (drive)-&gt;service_time)
multiline_comment|/**&n; *&t;choose_drive&t;&t;-&t;select a drive to service&n; *&t;@hwgroup: hardware group to select on&n; *&n; *&t;choose_drive() selects the next drive which will be serviced.&n; *&t;This is necessary because the IDE layer can&squot;t issue commands&n; *&t;to both drives on the same cable, unlike SCSI.&n; */
DECL|function|choose_drive
r_static
r_inline
id|ide_drive_t
op_star
id|choose_drive
(paren
id|ide_hwgroup_t
op_star
id|hwgroup
)paren
(brace
id|ide_drive_t
op_star
id|drive
comma
op_star
id|best
suffix:semicolon
id|repeat
suffix:colon
id|best
op_assign
l_int|NULL
suffix:semicolon
id|drive
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|drive-&gt;sleep
op_logical_or
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|drive-&gt;sleep
)paren
)paren
op_logical_and
op_logical_neg
id|elv_queue_empty
c_func
(paren
id|drive-&gt;queue
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|best
op_logical_or
(paren
id|drive-&gt;sleep
op_logical_and
(paren
op_logical_neg
id|best-&gt;sleep
op_logical_or
l_int|0
OL
(paren
r_int
r_int
)paren
(paren
id|best-&gt;sleep
op_minus
id|drive-&gt;sleep
)paren
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|best-&gt;sleep
op_logical_and
l_int|0
OL
(paren
r_int
r_int
)paren
(paren
id|WAKEUP
c_func
(paren
id|best
)paren
op_minus
id|WAKEUP
c_func
(paren
id|drive
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|blk_queue_plugged
c_func
(paren
id|drive-&gt;queue
)paren
)paren
id|best
op_assign
id|drive
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
(paren
id|drive
op_assign
id|drive-&gt;next
)paren
op_ne
id|hwgroup-&gt;drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|best
op_logical_and
id|best-&gt;nice1
op_logical_and
op_logical_neg
id|best-&gt;sleep
op_logical_and
id|best
op_ne
id|hwgroup-&gt;drive
op_logical_and
id|best-&gt;service_time
OG
id|WAIT_MIN_SLEEP
)paren
(brace
r_int
id|t
op_assign
(paren
r_int
r_int
)paren
(paren
id|WAKEUP
c_func
(paren
id|best
)paren
op_minus
id|jiffies
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ge
id|WAIT_MIN_SLEEP
)paren
(brace
multiline_comment|/*&n;&t;&t; * We *may* have some time to spare, but first let&squot;s see if&n;&t;&t; * someone can potentially benefit from our nice mood today..&n;&t;&t; */
id|drive
op_assign
id|best-&gt;next
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;sleep
multiline_comment|/* FIXME: use time_before */
op_logical_and
l_int|0
OL
(paren
r_int
r_int
)paren
(paren
id|WAKEUP
c_func
(paren
id|drive
)paren
op_minus
(paren
id|jiffies
op_minus
id|best-&gt;service_time
)paren
)paren
op_logical_and
l_int|0
OL
(paren
r_int
r_int
)paren
(paren
(paren
id|jiffies
op_plus
id|t
)paren
op_minus
id|WAKEUP
c_func
(paren
id|drive
)paren
)paren
)paren
(brace
id|ide_stall_queue
c_func
(paren
id|best
comma
id|IDE_MIN
c_func
(paren
id|t
comma
l_int|10
op_star
id|WAIT_MIN_SLEEP
)paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|drive
op_assign
id|drive-&gt;next
)paren
op_ne
id|best
)paren
suffix:semicolon
)brace
)brace
r_return
id|best
suffix:semicolon
)brace
multiline_comment|/*&n; * Issue a new request to a drive from hwgroup&n; * Caller must have already done spin_lock_irqsave(&amp;ide_lock, ..);&n; *&n; * A hwgroup is a serialized group of IDE interfaces.  Usually there is&n; * exactly one hwif (interface) per hwgroup, but buggy controllers (eg. CMD640)&n; * may have both interfaces in a single hwgroup to &quot;serialize&quot; access.&n; * Or possibly multiple ISA interfaces can share a common IRQ by being grouped&n; * together into one hwgroup for serialized access.&n; *&n; * Note also that several hwgroups can end up sharing a single IRQ,&n; * possibly along with many other devices.  This is especially common in&n; * PCI-based systems with off-board IDE controller cards.&n; *&n; * The IDE driver uses the single global ide_lock spinlock to protect&n; * access to the request queues, and to protect the hwgroup-&gt;busy flag.&n; *&n; * The first thread into the driver for a particular hwgroup sets the&n; * hwgroup-&gt;busy flag to indicate that this hwgroup is now active,&n; * and then initiates processing of the top request from the request queue.&n; *&n; * Other threads attempting entry notice the busy setting, and will simply&n; * queue their new requests and exit immediately.  Note that hwgroup-&gt;busy&n; * remains set even when the driver is merely awaiting the next interrupt.&n; * Thus, the meaning is &quot;this hwgroup is busy processing a request&quot;.&n; *&n; * When processing of a request completes, the completing thread or IRQ-handler&n; * will start the next request from the queue.  If no more work remains,&n; * the driver will clear the hwgroup-&gt;busy flag and exit.&n; *&n; * The ide_lock (spinlock) is used to protect all access to the&n; * hwgroup-&gt;busy flag, but is otherwise not needed for most processing in&n; * the driver.  This makes the driver much more friendlier to shared IRQs&n; * than previous designs, while remaining 100% (?) SMP safe and capable.&n; */
multiline_comment|/* --BenH: made non-static as ide-pmac.c uses it to kick the hwgroup back&n; *         into life on wakeup from machine sleep.&n; */
DECL|function|ide_do_request
r_void
id|ide_do_request
(paren
id|ide_hwgroup_t
op_star
id|hwgroup
comma
r_int
id|masked_irq
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
multiline_comment|/* for atari only: POSSIBLY BROKEN HERE(?) */
id|ide_get_lock
c_func
(paren
id|ide_intr
comma
id|hwgroup
)paren
suffix:semicolon
multiline_comment|/* caller must own ide_lock */
id|BUG_ON
c_func
(paren
op_logical_neg
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|hwgroup-&gt;busy
)paren
(brace
id|hwgroup-&gt;busy
op_assign
l_int|1
suffix:semicolon
id|drive
op_assign
id|choose_drive
c_func
(paren
id|hwgroup
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
l_int|NULL
)paren
(brace
r_int
r_int
id|sleep
op_assign
l_int|0
suffix:semicolon
id|hwgroup-&gt;rq
op_assign
l_int|NULL
suffix:semicolon
id|drive
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|drive-&gt;sleep
op_logical_and
(paren
op_logical_neg
id|sleep
op_logical_or
l_int|0
OL
(paren
r_int
r_int
)paren
(paren
id|sleep
op_minus
id|drive-&gt;sleep
)paren
)paren
)paren
id|sleep
op_assign
id|drive-&gt;sleep
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|drive
op_assign
id|drive-&gt;next
)paren
op_ne
id|hwgroup-&gt;drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sleep
)paren
(brace
multiline_comment|/*&n;&t;&t; * Take a short snooze, and then wake up this hwgroup again.&n;&t;&t; * This gives other hwgroups on the same a chance to&n;&t;&t; * play fairly with us, just in case there are big differences&n;&t;&t; * in relative throughputs.. don&squot;t want to hog the cpu too much.&n;&t;&t; */
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|sleep
comma
id|jiffies
op_plus
id|WAIT_MIN_SLEEP
)paren
)paren
id|sleep
op_assign
id|jiffies
op_plus
id|WAIT_MIN_SLEEP
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|hwgroup-&gt;timer
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;ide_set_handler: timer already active&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* so that ide_timer_expiry knows what to do */
id|hwgroup-&gt;sleeping
op_assign
l_int|1
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|hwgroup-&gt;timer
comma
id|sleep
)paren
suffix:semicolon
multiline_comment|/* we purposely leave hwgroup-&gt;busy==1&n;&t;&t;&t;&t; * while sleeping */
)brace
r_else
(brace
multiline_comment|/* Ugly, but how can we sleep for the lock&n;&t;&t;&t;&t; * otherwise? perhaps from tq_disk?&n;&t;&t;&t;&t; */
multiline_comment|/* for atari only */
id|ide_release_lock
c_func
(paren
)paren
suffix:semicolon
id|hwgroup-&gt;busy
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* no more work for this hwgroup (for now) */
r_return
suffix:semicolon
)brace
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;hwif-&gt;sharing_irq
op_logical_and
id|hwif
op_ne
id|hwgroup-&gt;hwif
op_logical_and
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
(brace
multiline_comment|/* set nIEN for previous hwif */
id|SELECT_INTERRUPT
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
id|hwgroup-&gt;hwif
op_assign
id|hwif
suffix:semicolon
id|hwgroup-&gt;drive
op_assign
id|drive
suffix:semicolon
id|drive-&gt;sleep
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;service_start
op_assign
id|jiffies
suffix:semicolon
id|queue_next
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|ata_can_queue
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ata_pending_commands
c_func
(paren
id|drive
)paren
)paren
id|hwgroup-&gt;busy
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blk_queue_plugged
c_func
(paren
id|drive-&gt;queue
)paren
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;using_tcq
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide: huh? queue was plugged!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * we know that the queue isn&squot;t empty, but this can happen&n;&t;&t; * if the q-&gt;prep_rq_fn() decides to kill a request&n;&t;&t; */
id|rq
op_assign
id|elv_next_request
c_func
(paren
id|drive-&gt;queue
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq
)paren
(brace
id|hwgroup-&gt;busy
op_assign
op_logical_neg
op_logical_neg
id|ata_pending_commands
c_func
(paren
id|drive
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Sanity: don&squot;t accept a request that isn&squot;t a PM request&n;&t;&t; * if we are currently power managed. This is very important as&n;&t;&t; * blk_stop_queue() doesn&squot;t prevent the elv_next_request()&n;&t;&t; * above to return us whatever is in the queue. Since we call&n;&t;&t; * ide_do_request() ourselves, we end up taking requests while&n;&t;&t; * the queue is blocked...&n;&t;&t; * &n;&t;&t; * We let requests forced at head of queue with ide-preempt&n;&t;&t; * though. I hope that doesn&squot;t happen too much, hopefully not&n;&t;&t; * unless the subdriver triggers such a thing in its own PM&n;&t;&t; * state machine.&n;&t;&t; */
r_if
c_cond
(paren
id|drive-&gt;blocked
op_logical_and
op_logical_neg
id|blk_pm_request
c_func
(paren
id|rq
)paren
op_logical_and
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
id|REQ_PREEMPT
)paren
)paren
(brace
multiline_comment|/* We clear busy, there should be no pending ATA command at this point. */
id|hwgroup-&gt;busy
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;bio
op_logical_and
id|ata_pending_commands
c_func
(paren
id|drive
)paren
)paren
r_break
suffix:semicolon
id|hwgroup-&gt;rq
op_assign
id|rq
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Some systems have trouble with IDE IRQs arriving while&n;&t;&t; * the driver is still setting things up.  So, here we disable&n;&t;&t; * the IRQ used by this interface while the request is being started.&n;&t;&t; * This may look bad at first, but pretty much the same thing&n;&t;&t; * happens anyway when any interrupt comes in, IDE or otherwise&n;&t;&t; *  -- the kernel masks the IRQ while it is being handled.&n;&t;&t; */
r_if
c_cond
(paren
id|hwif-&gt;irq
op_ne
id|masked_irq
)paren
id|disable_irq_nosync
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* allow other IRQs while we start this request */
id|startstop
op_assign
id|start_request
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;irq
op_ne
id|masked_irq
)paren
id|enable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_released
)paren
r_goto
id|queue_next
suffix:semicolon
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_stopped
)paren
id|hwgroup-&gt;busy
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|ide_do_request
id|EXPORT_SYMBOL
c_func
(paren
id|ide_do_request
)paren
suffix:semicolon
multiline_comment|/*&n; * Passes the stuff to ide_do_request&n; */
DECL|function|do_ide_request
r_void
id|do_ide_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
id|ide_do_request
c_func
(paren
id|q-&gt;queuedata
comma
id|IDE_NO_IRQ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * un-busy the hwgroup etc, and clear any pending DMA status. we want to&n; * retry the current request in pio mode instead of risking tossing it&n; * all away&n; */
DECL|function|ide_dma_timeout_retry
r_static
id|ide_startstop_t
id|ide_dma_timeout_retry
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|error
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|ide_startstop_t
id|ret
op_assign
id|ide_stopped
suffix:semicolon
multiline_comment|/*&n;&t; * end current dma transaction&n;&t; */
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: DMA timeout error&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
(paren
r_void
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_end
c_func
(paren
id|drive
)paren
suffix:semicolon
id|ret
op_assign
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;dma timeout error&quot;
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: DMA timeout retry&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
(paren
r_void
)paren
id|hwif
op_member_access_from_pointer
id|ide_dma_timeout
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * disable dma for now, but remember that we did so because of&n;&t; * a timeout -- we&squot;ll reenable after we finish this next request&n;&t; * (or rather the first chunk of it) in pio.&n;&t; */
id|drive-&gt;retry_pio
op_increment
suffix:semicolon
id|drive-&gt;state
op_assign
id|DMA_PIO_RETRY
suffix:semicolon
(paren
r_void
)paren
id|hwif
op_member_access_from_pointer
id|ide_dma_off_quietly
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * un-busy drive etc (hwgroup-&gt;busy is cleared on return) and&n;&t; * make sure request is sane&n;&t; */
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;sector
op_assign
id|rq-&gt;bio-&gt;bi_sector
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
id|bio_iovec
c_func
(paren
id|rq-&gt;bio
)paren
op_member_access_from_pointer
id|bv_len
op_rshift
l_int|9
suffix:semicolon
id|rq-&gt;hard_cur_sectors
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;bio
)paren
id|rq-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_timer_expiry&t;-&t;handle lack of an IDE interrupt&n; *&t;@data: timer callback magic (hwgroup)&n; *&n; *&t;An IDE command has timed out before the expected drive return&n; *&t;occurred. At this point we attempt to clean up the current&n; *&t;mess. If the current handler includes an expiry handler then&n; *&t;we invoke the expiry handler, and providing it is happy the&n; *&t;work is done. If that fails we apply generic recovery rules&n; *&t;invoking the handler and checking the drive DMA status. We&n; *&t;have an excessively incestuous relationship with the DMA&n; *&t;logic that wants cleaning up.&n; */
DECL|function|ide_timer_expiry
r_void
id|ide_timer_expiry
(paren
r_int
r_int
id|data
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
(paren
id|ide_hwgroup_t
op_star
)paren
id|data
suffix:semicolon
id|ide_handler_t
op_star
id|handler
suffix:semicolon
id|ide_expiry_t
op_star
id|expiry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|wait
op_assign
op_minus
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|handler
op_assign
id|hwgroup-&gt;handler
)paren
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Either a marginal timeout occurred&n;&t;&t; * (got the interrupt just as timer expired),&n;&t;&t; * or we were &quot;sleeping&quot; to give other devices a chance.&n;&t;&t; * Either way, we don&squot;t really want to complain about anything.&n;&t;&t; */
r_if
c_cond
(paren
id|hwgroup-&gt;sleeping
)paren
(brace
id|hwgroup-&gt;sleeping
op_assign
l_int|0
suffix:semicolon
id|hwgroup-&gt;busy
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide_timer_expiry: hwgroup-&gt;drive was NULL&bslash;n&quot;
)paren
suffix:semicolon
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
id|ide_startstop_t
id|startstop
op_assign
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwgroup-&gt;busy
)paren
(brace
id|hwgroup-&gt;busy
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* paranoia */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ide_timer_expiry: hwgroup-&gt;busy was 0 ??&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|expiry
op_assign
id|hwgroup-&gt;expiry
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* continue */
r_if
c_cond
(paren
(paren
id|wait
op_assign
id|expiry
c_func
(paren
id|drive
)paren
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* reset timer */
id|hwgroup-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|wait
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|hwgroup-&gt;timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We need to simulate a real interrupt when invoking&n;&t;&t;&t; * the handler() function, which means we need to&n;&t;&t;&t; * globally mask the specific IRQ:&n;&t;&t;&t; */
id|spin_unlock
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#if DISABLE_IRQ_NOSYNC
id|disable_irq_nosync
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* disable_irq_nosync ?? */
id|disable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
macro_line|#endif /* DISABLE_IRQ_NOSYNC */
multiline_comment|/* local CPU only,&n;&t;&t;&t; * as if we were handling an interrupt */
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;poll_timeout
op_ne
l_int|0
)paren
(brace
id|startstop
op_assign
id|handler
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;waiting_for_dma
)paren
(paren
r_void
)paren
id|hwgroup-&gt;hwif
op_member_access_from_pointer
id|ide_dma_lostirq
c_func
(paren
id|drive
)paren
suffix:semicolon
(paren
r_void
)paren
id|ide_ack_intr
c_func
(paren
id|hwif
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: lost interrupt&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|startstop
op_assign
id|handler
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;waiting_for_dma
)paren
(brace
id|startstop
op_assign
id|ide_dma_timeout_retry
c_func
(paren
id|drive
comma
id|wait
)paren
suffix:semicolon
)brace
r_else
id|startstop
op_assign
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|error
c_func
(paren
id|drive
comma
l_string|&quot;irq timeout&quot;
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
suffix:semicolon
)brace
id|drive-&gt;service_time
op_assign
id|jiffies
op_minus
id|drive-&gt;service_start
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_stopped
)paren
id|hwgroup-&gt;busy
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|ide_do_request
c_func
(paren
id|hwgroup
comma
id|IDE_NO_IRQ
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|ide_timer_expiry
id|EXPORT_SYMBOL
c_func
(paren
id|ide_timer_expiry
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;unexpected_intr&t;&t;-&t;handle an unexpected IDE interrupt&n; *&t;@irq: interrupt line&n; *&t;@hwgroup: hwgroup being processed&n; *&n; *&t;There&squot;s nothing really useful we can do with an unexpected interrupt,&n; *&t;other than reading the status register (to clear it), and logging it.&n; *&t;There should be no way that an irq can happen before we&squot;re ready for it,&n; *&t;so we needn&squot;t worry much about losing an &quot;important&quot; interrupt here.&n; *&n; *&t;On laptops (and &quot;green&quot; PCs), an unexpected interrupt occurs whenever&n; *&t;the drive enters &quot;idle&quot;, &quot;standby&quot;, or &quot;sleep&quot; mode, so if the status&n; *&t;looks &quot;good&quot;, we just ignore the interrupt completely.&n; *&n; *&t;This routine assumes __cli() is in effect when called.&n; *&n; *&t;If an unexpected interrupt happens on irq15 while we are handling irq14&n; *&t;and if the two interfaces are &quot;serialized&quot; (CMD640), then it looks like&n; *&t;we could screw up by interfering with a new request being set up for &n; *&t;irq15.&n; *&n; *&t;In reality, this is a non-issue.  The new command is not sent unless &n; *&t;the drive is ready to accept one, in which case we know the drive is&n; *&t;not trying to interrupt us.  And ide_set_handler() is always invoked&n; *&t;before completing the issuance of any new drive command, so we will not&n; *&t;be accidentally invoked as a result of any valid command completion&n; *&t;interrupt.&n; *&n; *&t;Note that we must walk the entire hwgroup here. We know which hwif&n; *&t;is doing the current command, but we don&squot;t know which hwif burped&n; *&t;mysteriously.&n; */
DECL|function|unexpected_intr
r_static
r_void
id|unexpected_intr
(paren
r_int
id|irq
comma
id|ide_hwgroup_t
op_star
id|hwgroup
)paren
(brace
id|u8
id|stat
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|hwgroup-&gt;hwif
suffix:semicolon
multiline_comment|/*&n;&t; * handle the unexpected interrupt&n;&t; */
r_do
(brace
r_if
c_cond
(paren
id|hwif-&gt;irq
op_eq
id|irq
)paren
(brace
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
multiline_comment|/* Try to not flood the console with msgs */
r_static
r_int
r_int
id|last_msgtime
comma
id|count
suffix:semicolon
op_increment
id|count
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|last_msgtime
op_plus
id|HZ
)paren
)paren
(brace
id|last_msgtime
op_assign
id|jiffies
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s%s: unexpected interrupt, &quot;
l_string|&quot;status=0x%02x, count=%ld&bslash;n&quot;
comma
id|hwif-&gt;name
comma
(paren
id|hwif-&gt;next
op_eq
id|hwgroup-&gt;hwif
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;(?)&quot;
comma
id|stat
comma
id|count
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
(paren
id|hwif
op_assign
id|hwif-&gt;next
)paren
op_ne
id|hwgroup-&gt;hwif
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_intr&t;-&t;default IDE interrupt handler&n; *&t;@irq: interrupt number&n; *&t;@dev_id: hwif group&n; *&t;@regs: unused weirdness from the kernel irq layer&n; *&n; *&t;This is the default IRQ handler for the IDE layer. You should&n; *&t;not need to override it. If you do be aware it is subtle in&n; *&t;places&n; *&n; *&t;hwgroup-&gt;hwif is the interface in the group currently performing&n; *&t;a command. hwgroup-&gt;drive is the drive and hwgroup-&gt;handler is&n; *&t;the IRQ handler to call. As we issue a command the handlers&n; *&t;step through multiple states, reassigning the handler to the&n; *&t;next step in the process. Unlike a smart SCSI controller IDE&n; *&t;expects the main processor to sequence the various transfer&n; *&t;stages. We also manage a poll timer to catch up with most&n; *&t;timeout situations. There are still a few where the handlers&n; *&t;don&squot;t ever decide to give up.&n; *&n; *&t;The handler eventually returns ide_stopped to indicate the&n; *&t;request completed. At this point we issue the next request&n; *&t;on the hwgroup and the process begins again.&n; */
DECL|function|ide_intr
id|irqreturn_t
id|ide_intr
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
(paren
id|ide_hwgroup_t
op_star
)paren
id|dev_id
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|ide_handler_t
op_star
id|handler
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|hwif
op_assign
id|hwgroup-&gt;hwif
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ide_ack_intr
c_func
(paren
id|hwif
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|handler
op_assign
id|hwgroup-&gt;handler
)paren
op_eq
l_int|NULL
op_logical_or
id|hwgroup-&gt;poll_timeout
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Not expecting an interrupt from this drive.&n;&t;&t; * That means this could be:&n;&t;&t; *&t;(1) an interrupt from another PCI device&n;&t;&t; *&t;sharing the same PCI INT# as us.&n;&t;&t; * or&t;(2) a drive just entered sleep or standby mode,&n;&t;&t; *&t;and is interrupting to let us know.&n;&t;&t; * or&t;(3) a spurious interrupt of unknown origin.&n;&t;&t; *&n;&t;&t; * For PCI, we cannot tell the difference,&n;&t;&t; * so in that case we just ignore it and hope it goes away.&n;&t;&t; *&n;&t;&t; * FIXME: unexpected_intr should be hwif-&gt; then we can&n;&t;&t; * remove all the ifdef PCI crap&n;&t;&t; */
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
r_if
c_cond
(paren
id|hwif-&gt;pci_dev
op_logical_and
op_logical_neg
id|hwif-&gt;pci_dev-&gt;vendor
)paren
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDEPCI */
(brace
multiline_comment|/*&n;&t;&t;&t; * Probably not a shared PCI interrupt,&n;&t;&t;&t; * so we can safely try to do something about it:&n;&t;&t;&t; */
id|unexpected_intr
c_func
(paren
id|irq
comma
id|hwgroup
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Whack the status register, just in case&n;&t;&t;&t; * we have a leftover pending IRQ.&n;&t;&t;&t; */
(paren
r_void
)paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEPCI */
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_NONE
suffix:semicolon
)brace
id|drive
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive
)paren
(brace
multiline_comment|/*&n;&t;&t; * This should NEVER happen, and there isn&squot;t much&n;&t;&t; * we could do about it here.&n;&t;&t; *&n;&t;&t; * [Note - this can occur if the drive is hot unplugged]&n;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This happens regularly when we share a PCI IRQ with&n;&t;&t; * another device.  Unfortunately, it can also happen&n;&t;&t; * with some buggy drives that trigger the IRQ before&n;&t;&t; * their status register is up to date.  Hopefully we have&n;&t;&t; * enough advance overhead that the latter isn&squot;t a problem.&n;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hwgroup-&gt;busy
)paren
(brace
id|hwgroup-&gt;busy
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* paranoia */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ide_intr: hwgroup-&gt;busy was 0 ??&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|hwgroup-&gt;timer
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;unmask
)paren
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* service this interrupt, may set handler for next interrupt */
id|startstop
op_assign
id|handler
c_func
(paren
id|drive
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note that handler() may have set things up for another&n;&t; * interrupt to occur soon, but it cannot happen until&n;&t; * we exit from this routine, because it will be the&n;&t; * same irq as is currently being serviced here, and Linux&n;&t; * won&squot;t allow another of the same (on any CPU) until we return.&n;&t; */
id|drive-&gt;service_time
op_assign
id|jiffies
op_minus
id|drive-&gt;service_start
suffix:semicolon
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_stopped
)paren
(brace
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* paranoia */
id|hwgroup-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|ide_do_request
c_func
(paren
id|hwgroup
comma
id|hwif-&gt;irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ide_intr: huh? expected NULL handler &quot;
l_string|&quot;on exit&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|variable|ide_intr
id|EXPORT_SYMBOL
c_func
(paren
id|ide_intr
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_init_drive_cmd&t;-&t;initialize a drive command request&n; *&t;@rq: request object&n; *&n; *&t;Initialize a request before we fill it in and send it down to&n; *&t;ide_do_drive_cmd. Commands must be set up by this function. Right&n; *&t;now it doesn&squot;t do a lot, but if that changes abusers will have a&n; *&t;nasty suprise.&n; */
DECL|function|ide_init_drive_cmd
r_void
id|ide_init_drive_cmd
(paren
r_struct
id|request
op_star
id|rq
)paren
(brace
id|memset
c_func
(paren
id|rq
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|rq
)paren
)paren
suffix:semicolon
id|rq-&gt;flags
op_assign
id|REQ_DRIVE_CMD
suffix:semicolon
)brace
DECL|variable|ide_init_drive_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ide_init_drive_cmd
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_do_drive_cmd&t;-&t;issue IDE special command&n; *&t;@drive: device to issue command&n; *&t;@rq: request to issue&n; *&t;@action: action for processing&n; *&n; *&t;This function issues a special IDE device request&n; *&t;onto the request queue.&n; *&n; *&t;If action is ide_wait, then the rq is queued at the end of the&n; *&t;request queue, and the function sleeps until it has been processed.&n; *&t;This is for use when invoked from an ioctl handler.&n; *&n; *&t;If action is ide_preempt, then the rq is queued at the head of&n; *&t;the request queue, displacing the currently-being-processed&n; *&t;request and this function returns immediately without waiting&n; *&t;for the new rq to be completed.  This is VERY DANGEROUS, and is&n; *&t;intended for careful use by the ATAPI tape/cdrom driver code.&n; *&n; *&t;If action is ide_next, then the rq is queued immediately after&n; *&t;the currently-being-processed-request (if any), and the function&n; *&t;returns without waiting for the new rq to be completed.  As above,&n; *&t;This is VERY DANGEROUS, and is intended for careful use by the&n; *&t;ATAPI tape/cdrom driver code.&n; *&n; *&t;If action is ide_end, then the rq is queued at the end of the&n; *&t;request queue, and the function returns immediately without waiting&n; *&t;for the new rq to be completed. This is again intended for careful&n; *&t;use by the ATAPI tape/cdrom driver code.&n; */
DECL|function|ide_do_drive_cmd
r_int
id|ide_do_drive_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|ide_action_t
id|action
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
id|DECLARE_COMPLETION
c_func
(paren
id|wait
)paren
suffix:semicolon
r_int
id|where
op_assign
id|ELEVATOR_INSERT_BACK
comma
id|err
suffix:semicolon
r_int
id|must_wait
op_assign
(paren
id|action
op_eq
id|ide_wait
op_logical_or
id|action
op_eq
id|ide_head_wait
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
multiline_comment|/*&n;&t; *&t;FIXME: there should be a drive or hwif-&gt;special&n;&t; *&t;handler that points here by default, not hacks&n;&t; *&t;in the ide-io.c code&n;&t; *&n;&t; *&t;FIXME2: That code breaks power management if used with&n;&t; *&t;this chipset, that really doesn&squot;t belong here !&n;&t; */
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|chipset
op_eq
id|ide_pdc4030
op_logical_and
id|rq-&gt;buffer
op_ne
l_int|NULL
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* special drive cmds not supported */
macro_line|#endif
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;rq_status
op_assign
id|RQ_ACTIVE
suffix:semicolon
id|rq-&gt;rq_disk
op_assign
id|drive-&gt;disk
suffix:semicolon
multiline_comment|/*&n;&t; * we need to hold an extra reference to request for safe inspection&n;&t; * after completion&n;&t; */
r_if
c_cond
(paren
id|must_wait
)paren
(brace
id|rq-&gt;ref_count
op_increment
suffix:semicolon
id|rq-&gt;waiting
op_assign
op_amp
id|wait
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|ide_preempt
)paren
id|hwgroup-&gt;rq
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|ide_preempt
op_logical_or
id|action
op_eq
id|ide_head_wait
)paren
(brace
id|where
op_assign
id|ELEVATOR_INSERT_FRONT
suffix:semicolon
id|rq-&gt;flags
op_or_assign
id|REQ_PREEMPT
suffix:semicolon
)brace
id|__elv_add_request
c_func
(paren
id|drive-&gt;queue
comma
id|rq
comma
id|where
comma
l_int|0
)paren
suffix:semicolon
id|ide_do_request
c_func
(paren
id|hwgroup
comma
id|IDE_NO_IRQ
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|must_wait
)paren
(brace
id|wait_for_completion
c_func
(paren
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;errors
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|blk_put_request
c_func
(paren
id|rq
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|variable|ide_do_drive_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ide_do_drive_cmd
)paren
suffix:semicolon
eof
