multiline_comment|/*&n; * linux/drivers/ide/ide-pmac.c&n; *&n; * Support for IDE interfaces on PowerMacs.&n; * These IDE interfaces are memory-mapped and have a DBDMA channel&n; * for doing DMA.&n; *&n; *  Copyright (C) 1998-2003 Paul Mackerras &amp; Ben. Herrenschmidt&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; * Some code taken from drivers/ide/ide-dma.c:&n; *&n; *  Copyright (c) 1995-1998  Mark Lord&n; *&n; * TODO: - Use pre-calculated (kauai) timing tables all the time and&n; * get rid of the &quot;rounded&quot; tables used previously, so we have the&n; * same table format for all controllers and can then just have one&n; * big table&n; * &n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/adb.h&gt;
macro_line|#include &lt;linux/pmu.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dbdma.h&gt;
macro_line|#include &lt;asm/ide.h&gt;
macro_line|#include &lt;asm/pci-bridge.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/pmac_feature.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#ifndef CONFIG_PPC64
macro_line|#include &lt;asm/mediabay.h&gt;
macro_line|#endif
macro_line|#include &quot;ide-timing.h&quot;
r_extern
r_void
id|ide_do_request
c_func
(paren
id|ide_hwgroup_t
op_star
id|hwgroup
comma
r_int
id|masked_irq
)paren
suffix:semicolon
DECL|macro|IDE_PMAC_DEBUG
mdefine_line|#define IDE_PMAC_DEBUG
DECL|macro|DMA_WAIT_TIMEOUT
mdefine_line|#define DMA_WAIT_TIMEOUT&t;50
DECL|struct|pmac_ide_hwif
r_typedef
r_struct
id|pmac_ide_hwif
(brace
DECL|member|regbase
r_int
r_int
id|regbase
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|kind
r_int
id|kind
suffix:semicolon
DECL|member|aapl_bus_id
r_int
id|aapl_bus_id
suffix:semicolon
DECL|member|cable_80
r_int
id|cable_80
suffix:colon
l_int|1
suffix:semicolon
DECL|member|mediabay
r_int
id|mediabay
suffix:colon
l_int|1
suffix:semicolon
DECL|member|broken_dma
r_int
id|broken_dma
suffix:colon
l_int|1
suffix:semicolon
DECL|member|broken_dma_warn
r_int
id|broken_dma_warn
suffix:colon
l_int|1
suffix:semicolon
DECL|member|node
r_struct
id|device_node
op_star
id|node
suffix:semicolon
DECL|member|mdev
r_struct
id|macio_dev
op_star
id|mdev
suffix:semicolon
DECL|member|timings
id|u32
id|timings
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
multiline_comment|/* Those fields are duplicating what is in hwif. We currently&n;&t; * can&squot;t use the hwif ones because of some assumptions that are&n;&t; * beeing done by the generic code about the kind of dma controller&n;&t; * and format of the dma table. This will have to be fixed though.&n;&t; */
DECL|member|dma_regs
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma_regs
suffix:semicolon
DECL|member|dma_table_cpu
r_struct
id|dbdma_cmd
op_star
id|dma_table_cpu
suffix:semicolon
DECL|member|dma_table_dma
id|dma_addr_t
id|dma_table_dma
suffix:semicolon
DECL|member|sg_table
r_struct
id|scatterlist
op_star
id|sg_table
suffix:semicolon
DECL|member|sg_nents
r_int
id|sg_nents
suffix:semicolon
DECL|member|sg_dma_direction
r_int
id|sg_dma_direction
suffix:semicolon
macro_line|#endif
DECL|typedef|pmac_ide_hwif_t
)brace
id|pmac_ide_hwif_t
suffix:semicolon
DECL|variable|__pmacdata
r_static
id|pmac_ide_hwif_t
id|pmac_ide
(braket
id|MAX_HWIFS
)braket
id|__pmacdata
suffix:semicolon
DECL|variable|pmac_ide_count
r_static
r_int
id|pmac_ide_count
suffix:semicolon
r_enum
(brace
DECL|enumerator|controller_ohare
id|controller_ohare
comma
multiline_comment|/* OHare based */
DECL|enumerator|controller_heathrow
id|controller_heathrow
comma
multiline_comment|/* Heathrow/Paddington */
DECL|enumerator|controller_kl_ata3
id|controller_kl_ata3
comma
multiline_comment|/* KeyLargo ATA-3 */
DECL|enumerator|controller_kl_ata4
id|controller_kl_ata4
comma
multiline_comment|/* KeyLargo ATA-4 */
DECL|enumerator|controller_un_ata6
id|controller_un_ata6
comma
multiline_comment|/* UniNorth2 ATA-6 */
DECL|enumerator|controller_k2_ata6
id|controller_k2_ata6
multiline_comment|/* K2 ATA-6 */
)brace
suffix:semicolon
DECL|variable|model_name
r_static
r_const
r_char
op_star
id|model_name
(braket
)braket
op_assign
(brace
l_string|&quot;OHare ATA&quot;
comma
multiline_comment|/* OHare based */
l_string|&quot;Heathrow ATA&quot;
comma
multiline_comment|/* Heathrow/Paddington */
l_string|&quot;KeyLargo ATA-3&quot;
comma
multiline_comment|/* KeyLargo ATA-3 (MDMA only) */
l_string|&quot;KeyLargo ATA-4&quot;
comma
multiline_comment|/* KeyLargo ATA-4 (UDMA/66) */
l_string|&quot;UniNorth ATA-6&quot;
comma
multiline_comment|/* UniNorth2 ATA-6 (UDMA/100) */
l_string|&quot;K2 ATA-6&quot;
comma
multiline_comment|/* K2 ATA-6 (UDMA/100) */
)brace
suffix:semicolon
multiline_comment|/*&n; * Extra registers, both 32-bit little-endian&n; */
DECL|macro|IDE_TIMING_CONFIG
mdefine_line|#define IDE_TIMING_CONFIG&t;0x200
DECL|macro|IDE_INTERRUPT
mdefine_line|#define IDE_INTERRUPT&t;&t;0x300
multiline_comment|/* Kauai (U2) ATA has different register setup */
DECL|macro|IDE_KAUAI_PIO_CONFIG
mdefine_line|#define IDE_KAUAI_PIO_CONFIG&t;0x200
DECL|macro|IDE_KAUAI_ULTRA_CONFIG
mdefine_line|#define IDE_KAUAI_ULTRA_CONFIG&t;0x210
DECL|macro|IDE_KAUAI_POLL_CONFIG
mdefine_line|#define IDE_KAUAI_POLL_CONFIG&t;0x220
multiline_comment|/*&n; * Timing configuration register definitions&n; */
multiline_comment|/* Number of IDE_SYSCLK_NS ticks, argument is in nanoseconds */
DECL|macro|SYSCLK_TICKS
mdefine_line|#define SYSCLK_TICKS(t)&t;&t;(((t) + IDE_SYSCLK_NS - 1) / IDE_SYSCLK_NS)
DECL|macro|SYSCLK_TICKS_66
mdefine_line|#define SYSCLK_TICKS_66(t)&t;(((t) + IDE_SYSCLK_66_NS - 1) / IDE_SYSCLK_66_NS)
DECL|macro|IDE_SYSCLK_NS
mdefine_line|#define IDE_SYSCLK_NS&t;&t;30&t;/* 33Mhz cell */
DECL|macro|IDE_SYSCLK_66_NS
mdefine_line|#define IDE_SYSCLK_66_NS&t;15&t;/* 66Mhz cell */
multiline_comment|/* 100Mhz cell, found in Uninorth 2. I don&squot;t have much infos about&n; * this one yet, it appears as a pci device (106b/0033) on uninorth&n; * internal PCI bus and it&squot;s clock is controlled like gem or fw. It&n; * appears to be an evolution of keylargo ATA4 with a timing register&n; * extended to 2 32bits registers and a similar DBDMA channel. Other&n; * registers seem to exist but I can&squot;t tell much about them.&n; * &n; * So far, I&squot;m using pre-calculated tables for this extracted from&n; * the values used by the MacOS X driver.&n; * &n; * The &quot;PIO&quot; register controls PIO and MDMA timings, the &quot;ULTRA&quot;&n; * register controls the UDMA timings. At least, it seems bit 0&n; * of this one enables UDMA vs. MDMA, and bits 4..7 are the&n; * cycle time in units of 10ns. Bits 8..15 are used by I don&squot;t&n; * know their meaning yet&n; */
DECL|macro|TR_100_PIOREG_PIO_MASK
mdefine_line|#define TR_100_PIOREG_PIO_MASK&t;&t;0xff000fff
DECL|macro|TR_100_PIOREG_MDMA_MASK
mdefine_line|#define TR_100_PIOREG_MDMA_MASK&t;&t;0x00fff000
DECL|macro|TR_100_UDMAREG_UDMA_MASK
mdefine_line|#define TR_100_UDMAREG_UDMA_MASK&t;0x0000ffff
DECL|macro|TR_100_UDMAREG_UDMA_EN
mdefine_line|#define TR_100_UDMAREG_UDMA_EN&t;&t;0x00000001
multiline_comment|/* 66Mhz cell, found in KeyLargo. Can do ultra mode 0 to 2 on&n; * 40 connector cable and to 4 on 80 connector one.&n; * Clock unit is 15ns (66Mhz)&n; * &n; * 3 Values can be programmed:&n; *  - Write data setup, which appears to match the cycle time. They&n; *    also call it DIOW setup.&n; *  - Ready to pause time (from spec)&n; *  - Address setup. That one is weird. I don&squot;t see where exactly&n; *    it fits in UDMA cycles, I got it&squot;s name from an obscure piece&n; *    of commented out code in Darwin. They leave it to 0, we do as&n; *    well, despite a comment that would lead to think it has a&n; *    min value of 45ns.&n; * Apple also add 60ns to the write data setup (or cycle time ?) on&n; * reads.&n; */
DECL|macro|TR_66_UDMA_MASK
mdefine_line|#define TR_66_UDMA_MASK&t;&t;&t;0xfff00000
DECL|macro|TR_66_UDMA_EN
mdefine_line|#define TR_66_UDMA_EN&t;&t;&t;0x00100000 /* Enable Ultra mode for DMA */
DECL|macro|TR_66_UDMA_ADDRSETUP_MASK
mdefine_line|#define TR_66_UDMA_ADDRSETUP_MASK&t;0xe0000000 /* Address setup */
DECL|macro|TR_66_UDMA_ADDRSETUP_SHIFT
mdefine_line|#define TR_66_UDMA_ADDRSETUP_SHIFT&t;29
DECL|macro|TR_66_UDMA_RDY2PAUS_MASK
mdefine_line|#define TR_66_UDMA_RDY2PAUS_MASK&t;0x1e000000 /* Ready 2 pause time */
DECL|macro|TR_66_UDMA_RDY2PAUS_SHIFT
mdefine_line|#define TR_66_UDMA_RDY2PAUS_SHIFT&t;25
DECL|macro|TR_66_UDMA_WRDATASETUP_MASK
mdefine_line|#define TR_66_UDMA_WRDATASETUP_MASK&t;0x01e00000 /* Write data setup time */
DECL|macro|TR_66_UDMA_WRDATASETUP_SHIFT
mdefine_line|#define TR_66_UDMA_WRDATASETUP_SHIFT&t;21
DECL|macro|TR_66_MDMA_MASK
mdefine_line|#define TR_66_MDMA_MASK&t;&t;&t;0x000ffc00
DECL|macro|TR_66_MDMA_RECOVERY_MASK
mdefine_line|#define TR_66_MDMA_RECOVERY_MASK&t;0x000f8000
DECL|macro|TR_66_MDMA_RECOVERY_SHIFT
mdefine_line|#define TR_66_MDMA_RECOVERY_SHIFT&t;15
DECL|macro|TR_66_MDMA_ACCESS_MASK
mdefine_line|#define TR_66_MDMA_ACCESS_MASK&t;&t;0x00007c00
DECL|macro|TR_66_MDMA_ACCESS_SHIFT
mdefine_line|#define TR_66_MDMA_ACCESS_SHIFT&t;&t;10
DECL|macro|TR_66_PIO_MASK
mdefine_line|#define TR_66_PIO_MASK&t;&t;&t;0x000003ff
DECL|macro|TR_66_PIO_RECOVERY_MASK
mdefine_line|#define TR_66_PIO_RECOVERY_MASK&t;&t;0x000003e0
DECL|macro|TR_66_PIO_RECOVERY_SHIFT
mdefine_line|#define TR_66_PIO_RECOVERY_SHIFT&t;5
DECL|macro|TR_66_PIO_ACCESS_MASK
mdefine_line|#define TR_66_PIO_ACCESS_MASK&t;&t;0x0000001f
DECL|macro|TR_66_PIO_ACCESS_SHIFT
mdefine_line|#define TR_66_PIO_ACCESS_SHIFT&t;&t;0
multiline_comment|/* 33Mhz cell, found in OHare, Heathrow (&amp; Paddington) and KeyLargo&n; * Can do pio &amp; mdma modes, clock unit is 30ns (33Mhz)&n; * &n; * The access time and recovery time can be programmed. Some older&n; * Darwin code base limit OHare to 150ns cycle time. I decided to do&n; * the same here fore safety against broken old hardware ;)&n; * The HalfTick bit, when set, adds half a clock (15ns) to the access&n; * time and removes one from recovery. It&squot;s not supported on KeyLargo&n; * implementation afaik. The E bit appears to be set for PIO mode 0 and&n; * is used to reach long timings used in this mode.&n; */
DECL|macro|TR_33_MDMA_MASK
mdefine_line|#define TR_33_MDMA_MASK&t;&t;&t;0x003ff800
DECL|macro|TR_33_MDMA_RECOVERY_MASK
mdefine_line|#define TR_33_MDMA_RECOVERY_MASK&t;0x001f0000
DECL|macro|TR_33_MDMA_RECOVERY_SHIFT
mdefine_line|#define TR_33_MDMA_RECOVERY_SHIFT&t;16
DECL|macro|TR_33_MDMA_ACCESS_MASK
mdefine_line|#define TR_33_MDMA_ACCESS_MASK&t;&t;0x0000f800
DECL|macro|TR_33_MDMA_ACCESS_SHIFT
mdefine_line|#define TR_33_MDMA_ACCESS_SHIFT&t;&t;11
DECL|macro|TR_33_MDMA_HALFTICK
mdefine_line|#define TR_33_MDMA_HALFTICK&t;&t;0x00200000
DECL|macro|TR_33_PIO_MASK
mdefine_line|#define TR_33_PIO_MASK&t;&t;&t;0x000007ff
DECL|macro|TR_33_PIO_E
mdefine_line|#define TR_33_PIO_E&t;&t;&t;0x00000400
DECL|macro|TR_33_PIO_RECOVERY_MASK
mdefine_line|#define TR_33_PIO_RECOVERY_MASK&t;&t;0x000003e0
DECL|macro|TR_33_PIO_RECOVERY_SHIFT
mdefine_line|#define TR_33_PIO_RECOVERY_SHIFT&t;5
DECL|macro|TR_33_PIO_ACCESS_MASK
mdefine_line|#define TR_33_PIO_ACCESS_MASK&t;&t;0x0000001f
DECL|macro|TR_33_PIO_ACCESS_SHIFT
mdefine_line|#define TR_33_PIO_ACCESS_SHIFT&t;&t;0
multiline_comment|/*&n; * Interrupt register definitions&n; */
DECL|macro|IDE_INTR_DMA
mdefine_line|#define IDE_INTR_DMA&t;&t;&t;0x80000000
DECL|macro|IDE_INTR_DEVICE
mdefine_line|#define IDE_INTR_DEVICE&t;&t;&t;0x40000000
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
multiline_comment|/* Rounded Multiword DMA timings&n; * &n; * I gave up finding a generic formula for all controller&n; * types and instead, built tables based on timing values&n; * used by Apple in Darwin&squot;s implementation.&n; */
DECL|struct|mdma_timings_t
r_struct
id|mdma_timings_t
(brace
DECL|member|accessTime
r_int
id|accessTime
suffix:semicolon
DECL|member|recoveryTime
r_int
id|recoveryTime
suffix:semicolon
DECL|member|cycleTime
r_int
id|cycleTime
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|__pmacdata
r_struct
id|mdma_timings_t
id|mdma_timings_33
(braket
)braket
id|__pmacdata
op_assign
(brace
(brace
l_int|240
comma
l_int|240
comma
l_int|480
)brace
comma
(brace
l_int|180
comma
l_int|180
comma
l_int|360
)brace
comma
(brace
l_int|135
comma
l_int|135
comma
l_int|270
)brace
comma
(brace
l_int|120
comma
l_int|120
comma
l_int|240
)brace
comma
(brace
l_int|105
comma
l_int|105
comma
l_int|210
)brace
comma
(brace
l_int|90
comma
l_int|90
comma
l_int|180
)brace
comma
(brace
l_int|75
comma
l_int|75
comma
l_int|150
)brace
comma
(brace
l_int|75
comma
l_int|45
comma
l_int|120
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|__pmacdata
r_struct
id|mdma_timings_t
id|mdma_timings_33k
(braket
)braket
id|__pmacdata
op_assign
(brace
(brace
l_int|240
comma
l_int|240
comma
l_int|480
)brace
comma
(brace
l_int|180
comma
l_int|180
comma
l_int|360
)brace
comma
(brace
l_int|150
comma
l_int|150
comma
l_int|300
)brace
comma
(brace
l_int|120
comma
l_int|120
comma
l_int|240
)brace
comma
(brace
l_int|90
comma
l_int|120
comma
l_int|210
)brace
comma
(brace
l_int|90
comma
l_int|90
comma
l_int|180
)brace
comma
(brace
l_int|90
comma
l_int|60
comma
l_int|150
)brace
comma
(brace
l_int|90
comma
l_int|30
comma
l_int|120
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|__pmacdata
r_struct
id|mdma_timings_t
id|mdma_timings_66
(braket
)braket
id|__pmacdata
op_assign
(brace
(brace
l_int|240
comma
l_int|240
comma
l_int|480
)brace
comma
(brace
l_int|180
comma
l_int|180
comma
l_int|360
)brace
comma
(brace
l_int|135
comma
l_int|135
comma
l_int|270
)brace
comma
(brace
l_int|120
comma
l_int|120
comma
l_int|240
)brace
comma
(brace
l_int|105
comma
l_int|105
comma
l_int|210
)brace
comma
(brace
l_int|90
comma
l_int|90
comma
l_int|180
)brace
comma
(brace
l_int|90
comma
l_int|75
comma
l_int|165
)brace
comma
(brace
l_int|75
comma
l_int|45
comma
l_int|120
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* KeyLargo ATA-4 Ultra DMA timings (rounded) */
r_struct
(brace
DECL|member|addrSetup
r_int
id|addrSetup
suffix:semicolon
multiline_comment|/* ??? */
DECL|member|rdy2pause
r_int
id|rdy2pause
suffix:semicolon
DECL|member|wrDataSetup
r_int
id|wrDataSetup
suffix:semicolon
DECL|variable|__pmacdata
)brace
id|kl66_udma_timings
(braket
)braket
id|__pmacdata
op_assign
(brace
(brace
l_int|0
comma
l_int|180
comma
l_int|120
)brace
comma
multiline_comment|/* Mode 0 */
(brace
l_int|0
comma
l_int|150
comma
l_int|90
)brace
comma
multiline_comment|/*      1 */
(brace
l_int|0
comma
l_int|120
comma
l_int|60
)brace
comma
multiline_comment|/*      2 */
(brace
l_int|0
comma
l_int|90
comma
l_int|45
)brace
comma
multiline_comment|/*      3 */
(brace
l_int|0
comma
l_int|90
comma
l_int|30
)brace
multiline_comment|/*      4 */
)brace
suffix:semicolon
multiline_comment|/* UniNorth 2 ATA/100 timings */
DECL|struct|kauai_timing
r_struct
id|kauai_timing
(brace
DECL|member|cycle_time
r_int
id|cycle_time
suffix:semicolon
DECL|member|timing_reg
id|u32
id|timing_reg
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|__pmacdata
r_static
r_struct
id|kauai_timing
id|kauai_pio_timings
(braket
)braket
id|__pmacdata
op_assign
(brace
(brace
l_int|930
comma
l_int|0x08000fff
)brace
comma
(brace
l_int|600
comma
l_int|0x08000a92
)brace
comma
(brace
l_int|383
comma
l_int|0x0800060f
)brace
comma
(brace
l_int|360
comma
l_int|0x08000492
)brace
comma
(brace
l_int|330
comma
l_int|0x0800048f
)brace
comma
(brace
l_int|300
comma
l_int|0x080003cf
)brace
comma
(brace
l_int|270
comma
l_int|0x080003cc
)brace
comma
(brace
l_int|240
comma
l_int|0x0800038b
)brace
comma
(brace
l_int|239
comma
l_int|0x0800030c
)brace
comma
(brace
l_int|180
comma
l_int|0x05000249
)brace
comma
(brace
l_int|120
comma
l_int|0x04000148
)brace
)brace
suffix:semicolon
DECL|variable|__pmacdata
r_static
r_struct
id|kauai_timing
id|kauai_mdma_timings
(braket
)braket
id|__pmacdata
op_assign
(brace
(brace
l_int|1260
comma
l_int|0x00fff000
)brace
comma
(brace
l_int|480
comma
l_int|0x00618000
)brace
comma
(brace
l_int|360
comma
l_int|0x00492000
)brace
comma
(brace
l_int|270
comma
l_int|0x0038e000
)brace
comma
(brace
l_int|240
comma
l_int|0x0030c000
)brace
comma
(brace
l_int|210
comma
l_int|0x002cb000
)brace
comma
(brace
l_int|180
comma
l_int|0x00249000
)brace
comma
(brace
l_int|150
comma
l_int|0x00209000
)brace
comma
(brace
l_int|120
comma
l_int|0x00148000
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
DECL|variable|__pmacdata
r_static
r_struct
id|kauai_timing
id|kauai_udma_timings
(braket
)braket
id|__pmacdata
op_assign
(brace
(brace
l_int|120
comma
l_int|0x000070c0
)brace
comma
(brace
l_int|90
comma
l_int|0x00005d80
)brace
comma
(brace
l_int|60
comma
l_int|0x00004a60
)brace
comma
(brace
l_int|45
comma
l_int|0x00003a50
)brace
comma
(brace
l_int|30
comma
l_int|0x00002a30
)brace
comma
(brace
l_int|20
comma
l_int|0x00002921
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
r_static
r_inline
id|u32
DECL|function|kauai_lookup_timing
id|kauai_lookup_timing
c_func
(paren
r_struct
id|kauai_timing
op_star
id|table
comma
r_int
id|cycle_time
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|table
(braket
id|i
)braket
dot
id|cycle_time
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cycle_time
OG
id|table
(braket
id|i
op_plus
l_int|1
)braket
dot
id|cycle_time
)paren
r_return
id|table
(braket
id|i
)braket
dot
id|timing_reg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* allow up to 256 DBDMA commands per xfer */
DECL|macro|MAX_DCMDS
mdefine_line|#define MAX_DCMDS&t;&t;256
multiline_comment|/* &n; * Wait 1s for disk to answer on IDE bus after a hard reset&n; * of the device (via GPIO/FCR).&n; * &n; * Some devices seem to &quot;pollute&quot; the bus even after dropping&n; * the BSY bit (typically some combo drives slave on the UDMA&n; * bus) after a hard reset. Since we hard reset all drives on&n; * KeyLargo ATA66, we have to keep that delay around. I may end&n; * up not hard resetting anymore on these and keep the delay only&n; * for older interfaces instead (we have to reset when coming&n; * from MacOS...) --BenH. &n; */
DECL|macro|IDE_WAKEUP_DELAY
mdefine_line|#define IDE_WAKEUP_DELAY&t;(1*HZ)
r_static
r_void
id|pmac_ide_setup_dma
c_func
(paren
id|pmac_ide_hwif_t
op_star
id|pmif
comma
id|ide_hwif_t
op_star
id|hwif
)paren
suffix:semicolon
r_static
r_int
id|pmac_ide_build_dmatable
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
suffix:semicolon
r_static
r_int
id|pmac_ide_tune_chipset
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|speed
)paren
suffix:semicolon
r_static
r_void
id|pmac_ide_tuneproc
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|pio
)paren
suffix:semicolon
r_static
r_void
id|pmac_ide_selectproc
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_static
r_void
id|pmac_ide_kauai_selectproc
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_static
r_int
id|pmac_ide_dma_begin
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
multiline_comment|/*&n; * Below is the code for blinking the laptop LED along with hard&n; * disk activity.&n; */
macro_line|#ifdef CONFIG_BLK_DEV_IDE_PMAC_BLINK
multiline_comment|/* Set to 50ms minimum led-on time (also used to limit frequency&n; * of requests sent to the PMU&n; */
DECL|macro|PMU_HD_BLINK_TIME
mdefine_line|#define PMU_HD_BLINK_TIME&t;(HZ/50)
DECL|variable|pmu_blink_on
DECL|variable|pmu_blink_off
r_static
r_struct
id|adb_request
id|pmu_blink_on
comma
id|pmu_blink_off
suffix:semicolon
DECL|variable|pmu_blink_lock
r_static
id|spinlock_t
id|pmu_blink_lock
suffix:semicolon
DECL|variable|pmu_blink_stoptime
r_static
r_int
r_int
id|pmu_blink_stoptime
suffix:semicolon
DECL|variable|pmu_blink_ledstate
r_static
r_int
id|pmu_blink_ledstate
suffix:semicolon
DECL|variable|pmu_blink_timer
r_static
r_struct
id|timer_list
id|pmu_blink_timer
suffix:semicolon
DECL|variable|pmu_ide_blink_enabled
r_static
r_int
id|pmu_ide_blink_enabled
suffix:semicolon
r_static
r_void
DECL|function|pmu_hd_blink_timeout
id|pmu_hd_blink_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pmu_blink_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* We may have been triggered again in a racy way, check&n;&t; * that we really want to switch it off&n;&t; */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|pmu_blink_stoptime
comma
id|jiffies
)paren
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* Previous req. not complete, try 100ms more */
r_if
c_cond
(paren
id|pmu_blink_off.complete
op_eq
l_int|0
)paren
id|mod_timer
c_func
(paren
op_amp
id|pmu_blink_timer
comma
id|jiffies
op_plus
id|PMU_HD_BLINK_TIME
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pmu_blink_ledstate
)paren
(brace
id|pmu_request
c_func
(paren
op_amp
id|pmu_blink_off
comma
l_int|NULL
comma
l_int|4
comma
l_int|0xee
comma
l_int|4
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|pmu_blink_ledstate
op_assign
l_int|0
suffix:semicolon
)brace
id|done
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pmu_blink_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pmu_hd_kick_blink
id|pmu_hd_kick_blink
c_func
(paren
r_void
op_star
id|data
comma
r_int
id|rw
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|pmu_blink_stoptime
op_assign
id|jiffies
op_plus
id|PMU_HD_BLINK_TIME
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|pmu_blink_timer
comma
id|pmu_blink_stoptime
)paren
suffix:semicolon
multiline_comment|/* Fast path when LED is already ON */
r_if
c_cond
(paren
id|pmu_blink_ledstate
op_eq
l_int|1
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pmu_blink_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmu_blink_on.complete
op_logical_and
op_logical_neg
id|pmu_blink_ledstate
)paren
(brace
id|pmu_request
c_func
(paren
op_amp
id|pmu_blink_on
comma
l_int|NULL
comma
l_int|4
comma
l_int|0xee
comma
l_int|4
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|pmu_blink_ledstate
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pmu_blink_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|pmu_hd_blink_init
id|pmu_hd_blink_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|dt
suffix:semicolon
r_const
r_char
op_star
id|model
suffix:semicolon
multiline_comment|/* Currently, I only enable this feature on KeyLargo based laptops,&n;&t; * older laptops may support it (at least heathrow/paddington) but&n;&t; * I don&squot;t feel like loading those venerable old machines with so&n;&t; * much additional interrupt &amp; PMU activity...&n;&t; */
r_if
c_cond
(paren
id|pmu_get_model
c_func
(paren
)paren
op_ne
id|PMU_KEYLARGO_BASED
)paren
r_return
l_int|0
suffix:semicolon
id|dt
op_assign
id|find_devices
c_func
(paren
l_string|&quot;device-tree&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dt
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|model
op_assign
(paren
r_const
r_char
op_star
)paren
id|get_property
c_func
(paren
id|dt
comma
l_string|&quot;model&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|model
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|model
comma
l_string|&quot;PowerBook&quot;
comma
id|strlen
c_func
(paren
l_string|&quot;PowerBook&quot;
)paren
)paren
op_ne
l_int|0
op_logical_and
id|strncmp
c_func
(paren
id|model
comma
l_string|&quot;iBook&quot;
comma
id|strlen
c_func
(paren
l_string|&quot;iBook&quot;
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|pmu_blink_on.complete
op_assign
l_int|1
suffix:semicolon
id|pmu_blink_off.complete
op_assign
l_int|1
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pmu_blink_lock
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|pmu_blink_timer
)paren
suffix:semicolon
id|pmu_blink_timer.function
op_assign
id|pmu_hd_blink_timeout
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDE_PMAC_BLINK */
multiline_comment|/*&n; * N.B. this can&squot;t be an initfunc, because the media-bay task can&n; * call ide_[un]register at any time.&n; */
r_void
id|__pmac
DECL|function|pmac_ide_init_hwif_ports
id|pmac_ide_init_hwif_ports
c_func
(paren
id|hw_regs_t
op_star
id|hw
comma
r_int
r_int
id|data_port
comma
r_int
r_int
id|ctrl_port
comma
r_int
op_star
id|irq
)paren
(brace
r_int
id|i
comma
id|ix
suffix:semicolon
r_if
c_cond
(paren
id|data_port
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|ix
)paren
r_if
c_cond
(paren
id|data_port
op_eq
id|pmac_ide
(braket
id|ix
)braket
dot
id|regbase
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ix
op_ge
id|MAX_HWIFS
)paren
(brace
multiline_comment|/* Probably a PCI interface... */
r_for
c_loop
(paren
id|i
op_assign
id|IDE_DATA_OFFSET
suffix:semicolon
id|i
op_le
id|IDE_STATUS_OFFSET
suffix:semicolon
op_increment
id|i
)paren
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|data_port
op_plus
id|i
op_minus
id|IDE_DATA_OFFSET
suffix:semicolon
id|hw-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
op_assign
id|ctrl_port
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|data_port
op_plus
id|i
op_star
l_int|0x10
suffix:semicolon
id|hw-&gt;io_ports
(braket
l_int|8
)braket
op_assign
id|data_port
op_plus
l_int|0x160
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
l_int|NULL
)paren
op_star
id|irq
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|irq
suffix:semicolon
)brace
multiline_comment|/*&n; * Apply the timings of the proper unit (master/slave) to the shared&n; * timing register when selecting that unit. This version is for&n; * ASICs with a single timing register&n; */
r_static
r_void
id|__pmac
DECL|function|pmac_ide_selectproc
id|pmac_ide_selectproc
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|hwif_data
suffix:semicolon
r_if
c_cond
(paren
id|pmif
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
id|writel
c_func
(paren
id|pmif-&gt;timings
(braket
l_int|1
)braket
comma
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_TIMING_CONFIG
)paren
)paren
suffix:semicolon
r_else
id|writel
c_func
(paren
id|pmif-&gt;timings
(braket
l_int|0
)braket
comma
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_TIMING_CONFIG
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|readl
c_func
(paren
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_TIMING_CONFIG
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Apply the timings of the proper unit (master/slave) to the shared&n; * timing register when selecting that unit. This version is for&n; * ASICs with a dual timing register (Kauai)&n; */
r_static
r_void
id|__pmac
DECL|function|pmac_ide_kauai_selectproc
id|pmac_ide_kauai_selectproc
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|hwif_data
suffix:semicolon
r_if
c_cond
(paren
id|pmif
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
(brace
id|writel
c_func
(paren
id|pmif-&gt;timings
(braket
l_int|1
)braket
comma
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_KAUAI_PIO_CONFIG
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|pmif-&gt;timings
(braket
l_int|3
)braket
comma
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_KAUAI_ULTRA_CONFIG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|writel
c_func
(paren
id|pmif-&gt;timings
(braket
l_int|0
)braket
comma
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_KAUAI_PIO_CONFIG
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|pmif-&gt;timings
(braket
l_int|2
)braket
comma
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_KAUAI_ULTRA_CONFIG
)paren
)paren
suffix:semicolon
)brace
(paren
r_void
)paren
id|readl
c_func
(paren
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_KAUAI_PIO_CONFIG
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Force an update of controller timing values for a given drive&n; */
r_static
r_void
id|__pmac
DECL|function|pmac_ide_do_update_timings
id|pmac_ide_do_update_timings
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|hwif_data
suffix:semicolon
r_if
c_cond
(paren
id|pmif
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;kind
op_eq
id|controller_un_ata6
op_logical_or
id|pmif-&gt;kind
op_eq
id|controller_k2_ata6
)paren
id|pmac_ide_kauai_selectproc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_else
id|pmac_ide_selectproc
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pmac_outbsync
id|pmac_outbsync
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|value
comma
r_int
r_int
id|port
)paren
(brace
id|u32
id|tmp
suffix:semicolon
id|writeb
c_func
(paren
id|value
comma
(paren
r_void
id|__iomem
op_star
)paren
id|port
)paren
suffix:semicolon
id|tmp
op_assign
id|readl
c_func
(paren
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_TIMING_CONFIG
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send the SET_FEATURE IDE command to the drive and update drive-&gt;id with&n; * the new state. We currently don&squot;t use the generic routine as it used to&n; * cause various trouble, especially with older mediabays.&n; * This code is sometimes triggering a spurrious interrupt though, I need&n; * to sort that out sooner or later and see if I can finally get the&n; * common version to work properly in all cases&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_do_setfeature
id|pmac_ide_do_setfeature
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|command
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|1
suffix:semicolon
id|disable_irq_nosync
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|SELECT_DRIVE
c_func
(paren
id|drive
)paren
suffix:semicolon
id|SELECT_MASK
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Get rid of pending error state */
(paren
r_void
)paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* Timeout bumped for some powerbooks */
r_if
c_cond
(paren
id|wait_for_ready
c_func
(paren
id|drive
comma
l_int|2000
)paren
)paren
(brace
multiline_comment|/* Timeout bumped for some powerbooks */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: pmac_ide_do_setfeature disk not ready &quot;
l_string|&quot;before SET_FEATURE!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|2
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|command
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|SETFEATURES_XFER
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTBSYNC
c_func
(paren
id|drive
comma
id|WIN_SETFEATURES
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Timeout bumped for some powerbooks */
id|result
op_assign
id|wait_for_ready
c_func
(paren
id|drive
comma
l_int|2000
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: pmac_ide_do_setfeature disk not ready &quot;
l_string|&quot;after SET_FEATURE !&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|out
suffix:colon
id|SELECT_MASK
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|drive-&gt;id-&gt;dma_ultra
op_and_assign
op_complement
l_int|0xFF00
suffix:semicolon
id|drive-&gt;id-&gt;dma_mword
op_and_assign
op_complement
l_int|0x0F00
suffix:semicolon
id|drive-&gt;id-&gt;dma_1word
op_and_assign
op_complement
l_int|0x0F00
suffix:semicolon
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|XFER_UDMA_7
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x8080
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_6
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x4040
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_5
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x2020
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_4
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x1010
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_3
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0808
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_2
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0404
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_1
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0202
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_0
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0101
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_2
suffix:colon
id|drive-&gt;id-&gt;dma_mword
op_or_assign
l_int|0x0404
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_1
suffix:colon
id|drive-&gt;id-&gt;dma_mword
op_or_assign
l_int|0x0202
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_0
suffix:colon
id|drive-&gt;id-&gt;dma_mword
op_or_assign
l_int|0x0101
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_2
suffix:colon
id|drive-&gt;id-&gt;dma_1word
op_or_assign
l_int|0x0404
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_1
suffix:colon
id|drive-&gt;id-&gt;dma_1word
op_or_assign
l_int|0x0202
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_0
suffix:colon
id|drive-&gt;id-&gt;dma_1word
op_or_assign
l_int|0x0101
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
id|enable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Old tuning functions (called on hdparm -p), sets up drive PIO timings&n; */
r_static
r_void
id|__pmac
DECL|function|pmac_ide_tuneproc
id|pmac_ide_tuneproc
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|pio
)paren
(brace
id|ide_pio_data_t
id|d
suffix:semicolon
id|u32
op_star
id|timings
suffix:semicolon
r_int
id|accessTicks
comma
id|recTicks
suffix:semicolon
r_int
id|accessTime
comma
id|recTime
suffix:semicolon
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|hwif_data
suffix:semicolon
r_if
c_cond
(paren
id|pmif
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* which drive is it ? */
id|timings
op_assign
op_amp
id|pmif-&gt;timings
(braket
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)braket
suffix:semicolon
id|pio
op_assign
id|ide_get_best_pio_mode
c_func
(paren
id|drive
comma
id|pio
comma
l_int|4
comma
op_amp
id|d
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|pmif-&gt;kind
)paren
(brace
r_case
id|controller_un_ata6
suffix:colon
r_case
id|controller_k2_ata6
suffix:colon
(brace
multiline_comment|/* 100Mhz cell */
id|u32
id|tr
op_assign
id|kauai_lookup_timing
c_func
(paren
id|kauai_pio_timings
comma
id|d.cycle_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tr
op_eq
l_int|0
)paren
r_return
suffix:semicolon
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
id|TR_100_PIOREG_PIO_MASK
)paren
op_or
id|tr
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|controller_kl_ata4
suffix:colon
multiline_comment|/* 66Mhz cell */
id|recTime
op_assign
id|d.cycle_time
op_minus
id|ide_pio_timings
(braket
id|pio
)braket
dot
id|active_time
op_minus
id|ide_pio_timings
(braket
id|pio
)braket
dot
id|setup_time
suffix:semicolon
id|recTime
op_assign
id|max
c_func
(paren
id|recTime
comma
l_int|150U
)paren
suffix:semicolon
id|accessTime
op_assign
id|ide_pio_timings
(braket
id|pio
)braket
dot
id|active_time
suffix:semicolon
id|accessTime
op_assign
id|max
c_func
(paren
id|accessTime
comma
l_int|150U
)paren
suffix:semicolon
id|accessTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|accessTime
)paren
suffix:semicolon
id|accessTicks
op_assign
id|min
c_func
(paren
id|accessTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|recTime
)paren
suffix:semicolon
id|recTicks
op_assign
id|min
c_func
(paren
id|recTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
id|TR_66_PIO_MASK
)paren
op_or
(paren
id|accessTicks
op_lshift
id|TR_66_PIO_ACCESS_SHIFT
)paren
op_or
(paren
id|recTicks
op_lshift
id|TR_66_PIO_RECOVERY_SHIFT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
(brace
multiline_comment|/* 33Mhz cell */
r_int
id|ebit
op_assign
l_int|0
suffix:semicolon
id|recTime
op_assign
id|d.cycle_time
op_minus
id|ide_pio_timings
(braket
id|pio
)braket
dot
id|active_time
op_minus
id|ide_pio_timings
(braket
id|pio
)braket
dot
id|setup_time
suffix:semicolon
id|recTime
op_assign
id|max
c_func
(paren
id|recTime
comma
l_int|150U
)paren
suffix:semicolon
id|accessTime
op_assign
id|ide_pio_timings
(braket
id|pio
)braket
dot
id|active_time
suffix:semicolon
id|accessTime
op_assign
id|max
c_func
(paren
id|accessTime
comma
l_int|150U
)paren
suffix:semicolon
id|accessTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|accessTime
)paren
suffix:semicolon
id|accessTicks
op_assign
id|min
c_func
(paren
id|accessTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|accessTicks
op_assign
id|max
c_func
(paren
id|accessTicks
comma
l_int|4U
)paren
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|recTime
)paren
suffix:semicolon
id|recTicks
op_assign
id|min
c_func
(paren
id|recTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|recTicks
op_assign
id|max
c_func
(paren
id|recTicks
comma
l_int|5U
)paren
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|recTicks
OG
l_int|9
)paren
(brace
id|recTicks
op_decrement
suffix:semicolon
multiline_comment|/* guess, but it&squot;s only for PIO0, so... */
id|ebit
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
id|TR_33_PIO_MASK
)paren
op_or
(paren
id|accessTicks
op_lshift
id|TR_33_PIO_ACCESS_SHIFT
)paren
op_or
(paren
id|recTicks
op_lshift
id|TR_33_PIO_RECOVERY_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ebit
)paren
op_star
id|timings
op_or_assign
id|TR_33_PIO_E
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#ifdef IDE_PMAC_DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Set PIO timing for mode %d, reg: 0x%08x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|pio
comma
op_star
id|timings
)paren
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
id|drive-&gt;select.all
op_eq
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SELECT_REG
)paren
)paren
id|pmac_ide_do_update_timings
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
multiline_comment|/*&n; * Calculate KeyLargo ATA/66 UDMA timings&n; */
r_static
r_int
id|__pmac
DECL|function|set_timings_udma_ata4
id|set_timings_udma_ata4
c_func
(paren
id|u32
op_star
id|timings
comma
id|u8
id|speed
)paren
(brace
r_int
id|rdyToPauseTicks
comma
id|wrDataSetupTicks
comma
id|addrTicks
suffix:semicolon
r_if
c_cond
(paren
id|speed
OG
id|XFER_UDMA_4
)paren
r_return
l_int|1
suffix:semicolon
id|rdyToPauseTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|kl66_udma_timings
(braket
id|speed
op_amp
l_int|0xf
)braket
dot
id|rdy2pause
)paren
suffix:semicolon
id|wrDataSetupTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|kl66_udma_timings
(braket
id|speed
op_amp
l_int|0xf
)braket
dot
id|wrDataSetup
)paren
suffix:semicolon
id|addrTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|kl66_udma_timings
(braket
id|speed
op_amp
l_int|0xf
)braket
dot
id|addrSetup
)paren
suffix:semicolon
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
(paren
id|TR_66_UDMA_MASK
op_or
id|TR_66_MDMA_MASK
)paren
)paren
op_or
(paren
id|wrDataSetupTicks
op_lshift
id|TR_66_UDMA_WRDATASETUP_SHIFT
)paren
op_or
(paren
id|rdyToPauseTicks
op_lshift
id|TR_66_UDMA_RDY2PAUS_SHIFT
)paren
op_or
(paren
id|addrTicks
op_lshift
id|TR_66_UDMA_ADDRSETUP_SHIFT
)paren
op_or
id|TR_66_UDMA_EN
suffix:semicolon
macro_line|#ifdef IDE_PMAC_DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide_pmac: Set UDMA timing for mode %d, reg: 0x%08x&bslash;n&quot;
comma
id|speed
op_amp
l_int|0xf
comma
op_star
id|timings
)paren
suffix:semicolon
macro_line|#endif&t;
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Calculate Kauai ATA/100 UDMA timings&n; */
r_static
r_int
id|__pmac
DECL|function|set_timings_udma_ata6
id|set_timings_udma_ata6
c_func
(paren
id|u32
op_star
id|pio_timings
comma
id|u32
op_star
id|ultra_timings
comma
id|u8
id|speed
)paren
(brace
r_struct
id|ide_timing
op_star
id|t
op_assign
id|ide_timing_find_mode
c_func
(paren
id|speed
)paren
suffix:semicolon
id|u32
id|tr
suffix:semicolon
r_if
c_cond
(paren
id|speed
OG
id|XFER_UDMA_5
op_logical_or
id|t
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|tr
op_assign
id|kauai_lookup_timing
c_func
(paren
id|kauai_udma_timings
comma
(paren
r_int
)paren
id|t-&gt;udma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tr
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|ultra_timings
op_assign
(paren
(paren
op_star
id|ultra_timings
)paren
op_amp
op_complement
id|TR_100_UDMAREG_UDMA_MASK
)paren
op_or
id|tr
suffix:semicolon
op_star
id|ultra_timings
op_assign
(paren
op_star
id|ultra_timings
)paren
op_or
id|TR_100_UDMAREG_UDMA_EN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Calculate MDMA timings for all cells&n; */
r_static
r_int
id|__pmac
DECL|function|set_timings_mdma
id|set_timings_mdma
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|intf_type
comma
id|u32
op_star
id|timings
comma
id|u32
op_star
id|timings2
comma
id|u8
id|speed
comma
r_int
id|drive_cycle_time
)paren
(brace
r_int
id|cycleTime
comma
id|accessTime
comma
id|recTime
suffix:semicolon
r_int
id|accessTicks
comma
id|recTicks
suffix:semicolon
r_struct
id|mdma_timings_t
op_star
id|tm
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Get default cycle time for mode */
r_switch
c_cond
(paren
id|speed
op_amp
l_int|0xf
)paren
(brace
r_case
l_int|0
suffix:colon
id|cycleTime
op_assign
l_int|480
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|cycleTime
op_assign
l_int|150
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|cycleTime
op_assign
l_int|120
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Adjust for drive */
r_if
c_cond
(paren
id|drive_cycle_time
op_logical_and
id|drive_cycle_time
OG
id|cycleTime
)paren
id|cycleTime
op_assign
id|drive_cycle_time
suffix:semicolon
multiline_comment|/* OHare limits according to some old Apple sources */
r_if
c_cond
(paren
(paren
id|intf_type
op_eq
id|controller_ohare
)paren
op_logical_and
(paren
id|cycleTime
OL
l_int|150
)paren
)paren
id|cycleTime
op_assign
l_int|150
suffix:semicolon
multiline_comment|/* Get the proper timing array for this controller */
r_switch
c_cond
(paren
id|intf_type
)paren
(brace
r_case
id|controller_un_ata6
suffix:colon
r_case
id|controller_k2_ata6
suffix:colon
r_break
suffix:semicolon
r_case
id|controller_kl_ata4
suffix:colon
id|tm
op_assign
id|mdma_timings_66
suffix:semicolon
r_break
suffix:semicolon
r_case
id|controller_kl_ata3
suffix:colon
id|tm
op_assign
id|mdma_timings_33k
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|tm
op_assign
id|mdma_timings_33
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tm
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Lookup matching access &amp; recovery times */
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|tm
(braket
id|i
op_plus
l_int|1
)braket
dot
id|cycleTime
OL
id|cycleTime
)paren
r_break
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|cycleTime
op_assign
id|tm
(braket
id|i
)braket
dot
id|cycleTime
suffix:semicolon
id|accessTime
op_assign
id|tm
(braket
id|i
)braket
dot
id|accessTime
suffix:semicolon
id|recTime
op_assign
id|tm
(braket
id|i
)braket
dot
id|recoveryTime
suffix:semicolon
macro_line|#ifdef IDE_PMAC_DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: MDMA, cycleTime: %d, accessTime: %d, recTime: %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|cycleTime
comma
id|accessTime
comma
id|recTime
)paren
suffix:semicolon
macro_line|#endif
)brace
r_switch
c_cond
(paren
id|intf_type
)paren
(brace
r_case
id|controller_un_ata6
suffix:colon
r_case
id|controller_k2_ata6
suffix:colon
(brace
multiline_comment|/* 100Mhz cell */
id|u32
id|tr
op_assign
id|kauai_lookup_timing
c_func
(paren
id|kauai_mdma_timings
comma
id|cycleTime
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tr
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
id|TR_100_PIOREG_MDMA_MASK
)paren
op_or
id|tr
suffix:semicolon
op_star
id|timings2
op_assign
(paren
op_star
id|timings2
)paren
op_amp
op_complement
id|TR_100_UDMAREG_UDMA_EN
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|controller_kl_ata4
suffix:colon
multiline_comment|/* 66Mhz cell */
id|accessTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|accessTime
)paren
suffix:semicolon
id|accessTicks
op_assign
id|min
c_func
(paren
id|accessTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|accessTicks
op_assign
id|max
c_func
(paren
id|accessTicks
comma
l_int|0x1U
)paren
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS_66
c_func
(paren
id|recTime
)paren
suffix:semicolon
id|recTicks
op_assign
id|min
c_func
(paren
id|recTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|recTicks
op_assign
id|max
c_func
(paren
id|recTicks
comma
l_int|0x3U
)paren
suffix:semicolon
multiline_comment|/* Clear out mdma bits and disable udma */
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
(paren
id|TR_66_MDMA_MASK
op_or
id|TR_66_UDMA_MASK
)paren
)paren
op_or
(paren
id|accessTicks
op_lshift
id|TR_66_MDMA_ACCESS_SHIFT
)paren
op_or
(paren
id|recTicks
op_lshift
id|TR_66_MDMA_RECOVERY_SHIFT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|controller_kl_ata3
suffix:colon
multiline_comment|/* 33Mhz cell on KeyLargo */
id|accessTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|accessTime
)paren
suffix:semicolon
id|accessTicks
op_assign
id|max
c_func
(paren
id|accessTicks
comma
l_int|1U
)paren
suffix:semicolon
id|accessTicks
op_assign
id|min
c_func
(paren
id|accessTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|accessTime
op_assign
id|accessTicks
op_star
id|IDE_SYSCLK_NS
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|recTime
)paren
suffix:semicolon
id|recTicks
op_assign
id|max
c_func
(paren
id|recTicks
comma
l_int|1U
)paren
suffix:semicolon
id|recTicks
op_assign
id|min
c_func
(paren
id|recTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
id|TR_33_MDMA_MASK
)paren
op_or
(paren
id|accessTicks
op_lshift
id|TR_33_MDMA_ACCESS_SHIFT
)paren
op_or
(paren
id|recTicks
op_lshift
id|TR_33_MDMA_RECOVERY_SHIFT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
(brace
multiline_comment|/* 33Mhz cell on others */
r_int
id|halfTick
op_assign
l_int|0
suffix:semicolon
r_int
id|origAccessTime
op_assign
id|accessTime
suffix:semicolon
r_int
id|origRecTime
op_assign
id|recTime
suffix:semicolon
id|accessTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|accessTime
)paren
suffix:semicolon
id|accessTicks
op_assign
id|max
c_func
(paren
id|accessTicks
comma
l_int|1U
)paren
suffix:semicolon
id|accessTicks
op_assign
id|min
c_func
(paren
id|accessTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|accessTime
op_assign
id|accessTicks
op_star
id|IDE_SYSCLK_NS
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|recTime
)paren
suffix:semicolon
id|recTicks
op_assign
id|max
c_func
(paren
id|recTicks
comma
l_int|2U
)paren
op_minus
l_int|1
suffix:semicolon
id|recTicks
op_assign
id|min
c_func
(paren
id|recTicks
comma
l_int|0x1fU
)paren
suffix:semicolon
id|recTime
op_assign
(paren
id|recTicks
op_plus
l_int|1
)paren
op_star
id|IDE_SYSCLK_NS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|accessTicks
OG
l_int|1
)paren
op_logical_and
(paren
(paren
id|accessTime
op_minus
id|IDE_SYSCLK_NS
op_div
l_int|2
)paren
op_ge
id|origAccessTime
)paren
op_logical_and
(paren
(paren
id|recTime
op_minus
id|IDE_SYSCLK_NS
op_div
l_int|2
)paren
op_ge
id|origRecTime
)paren
)paren
(brace
id|halfTick
op_assign
l_int|1
suffix:semicolon
id|accessTicks
op_decrement
suffix:semicolon
)brace
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
op_complement
id|TR_33_MDMA_MASK
)paren
op_or
(paren
id|accessTicks
op_lshift
id|TR_33_MDMA_ACCESS_SHIFT
)paren
op_or
(paren
id|recTicks
op_lshift
id|TR_33_MDMA_RECOVERY_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|halfTick
)paren
op_star
id|timings
op_or_assign
id|TR_33_MDMA_HALFTICK
suffix:semicolon
)brace
)brace
macro_line|#ifdef IDE_PMAC_DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Set MDMA timing for mode %d, reg: 0x%08x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|speed
op_amp
l_int|0xf
comma
op_star
id|timings
)paren
suffix:semicolon
macro_line|#endif&t;
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC */
multiline_comment|/* &n; * Speedproc. This function is called by the core to set any of the standard&n; * timing (PIO, MDMA or UDMA) to both the drive and the controller.&n; * You may notice we don&squot;t use this function on normal &quot;dma check&quot; operation,&n; * our dedicated function is more precise as it uses the drive provided&n; * cycle time value. We should probably fix this one to deal with that too...&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_tune_chipset
id|pmac_ide_tune_chipset
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|speed
)paren
(brace
r_int
id|unit
op_assign
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|hwif_data
suffix:semicolon
id|u32
op_star
id|timings
comma
op_star
id|timings2
suffix:semicolon
r_if
c_cond
(paren
id|pmif
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|timings
op_assign
op_amp
id|pmif-&gt;timings
(braket
id|unit
)braket
suffix:semicolon
id|timings2
op_assign
op_amp
id|pmif-&gt;timings
(braket
id|unit
op_plus
l_int|2
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|speed
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
r_case
id|XFER_UDMA_5
suffix:colon
r_if
c_cond
(paren
id|pmif-&gt;kind
op_ne
id|controller_un_ata6
op_logical_and
id|pmif-&gt;kind
op_ne
id|controller_k2_ata6
)paren
r_return
l_int|1
suffix:semicolon
r_case
id|XFER_UDMA_4
suffix:colon
r_case
id|XFER_UDMA_3
suffix:colon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|udma_four
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_case
id|XFER_UDMA_2
suffix:colon
r_case
id|XFER_UDMA_1
suffix:colon
r_case
id|XFER_UDMA_0
suffix:colon
r_if
c_cond
(paren
id|pmif-&gt;kind
op_eq
id|controller_kl_ata4
)paren
id|ret
op_assign
id|set_timings_udma_ata4
c_func
(paren
id|timings
comma
id|speed
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pmif-&gt;kind
op_eq
id|controller_un_ata6
op_logical_or
id|pmif-&gt;kind
op_eq
id|controller_k2_ata6
)paren
id|ret
op_assign
id|set_timings_udma_ata6
c_func
(paren
id|timings
comma
id|timings2
comma
id|speed
)paren
suffix:semicolon
r_else
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_2
suffix:colon
r_case
id|XFER_MW_DMA_1
suffix:colon
r_case
id|XFER_MW_DMA_0
suffix:colon
id|ret
op_assign
id|set_timings_mdma
c_func
(paren
id|drive
comma
id|pmif-&gt;kind
comma
id|timings
comma
id|timings2
comma
id|speed
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_2
suffix:colon
r_case
id|XFER_SW_DMA_1
suffix:colon
r_case
id|XFER_SW_DMA_0
suffix:colon
r_return
l_int|1
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
r_case
id|XFER_PIO_4
suffix:colon
r_case
id|XFER_PIO_3
suffix:colon
r_case
id|XFER_PIO_2
suffix:colon
r_case
id|XFER_PIO_1
suffix:colon
r_case
id|XFER_PIO_0
suffix:colon
id|pmac_ide_tuneproc
c_func
(paren
id|drive
comma
id|speed
op_amp
l_int|0x07
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|ret
op_assign
id|pmac_ide_do_setfeature
c_func
(paren
id|drive
comma
id|speed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|pmac_ide_do_update_timings
c_func
(paren
id|drive
)paren
suffix:semicolon
id|drive-&gt;current_speed
op_assign
id|speed
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Blast some well known &quot;safe&quot; values to the timing registers at init or&n; * wakeup from sleep time, before we do real calculation&n; */
r_static
r_void
id|__pmac
DECL|function|sanitize_timings
id|sanitize_timings
c_func
(paren
id|pmac_ide_hwif_t
op_star
id|pmif
)paren
(brace
r_int
r_int
id|value
comma
id|value2
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|pmif-&gt;kind
)paren
(brace
r_case
id|controller_un_ata6
suffix:colon
r_case
id|controller_k2_ata6
suffix:colon
id|value
op_assign
l_int|0x08618a92
suffix:semicolon
id|value2
op_assign
l_int|0x00002921
suffix:semicolon
r_break
suffix:semicolon
r_case
id|controller_kl_ata4
suffix:colon
id|value
op_assign
l_int|0x0008438c
suffix:semicolon
r_break
suffix:semicolon
r_case
id|controller_kl_ata3
suffix:colon
id|value
op_assign
l_int|0x00084526
suffix:semicolon
r_break
suffix:semicolon
r_case
id|controller_heathrow
suffix:colon
r_case
id|controller_ohare
suffix:colon
r_default
suffix:colon
id|value
op_assign
l_int|0x00074526
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pmif-&gt;timings
(braket
l_int|0
)braket
op_assign
id|pmif-&gt;timings
(braket
l_int|1
)braket
op_assign
id|value
suffix:semicolon
id|pmif-&gt;timings
(braket
l_int|2
)braket
op_assign
id|pmif-&gt;timings
(braket
l_int|3
)braket
op_assign
id|value2
suffix:semicolon
)brace
r_int
r_int
id|__pmac
DECL|function|pmac_ide_get_base
id|pmac_ide_get_base
c_func
(paren
r_int
id|index
)paren
(brace
r_return
id|pmac_ide
(braket
id|index
)braket
dot
id|regbase
suffix:semicolon
)brace
r_int
id|__pmac
DECL|function|pmac_ide_check_base
id|pmac_ide_check_base
c_func
(paren
r_int
r_int
id|base
)paren
(brace
r_int
id|ix
suffix:semicolon
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|ix
)paren
r_if
c_cond
(paren
id|base
op_eq
id|pmac_ide
(braket
id|ix
)braket
dot
id|regbase
)paren
r_return
id|ix
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_int
id|__pmac
DECL|function|pmac_ide_get_irq
id|pmac_ide_get_irq
c_func
(paren
r_int
r_int
id|base
)paren
(brace
r_int
id|ix
suffix:semicolon
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|ix
)paren
r_if
c_cond
(paren
id|base
op_eq
id|pmac_ide
(braket
id|ix
)braket
dot
id|regbase
)paren
r_return
id|pmac_ide
(braket
id|ix
)braket
dot
id|irq
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|__pmacdata
r_static
r_int
id|ide_majors
(braket
)braket
id|__pmacdata
op_assign
(brace
l_int|3
comma
l_int|22
comma
l_int|33
comma
l_int|34
comma
l_int|56
comma
l_int|57
)brace
suffix:semicolon
id|dev_t
id|__init
DECL|function|pmac_find_ide_boot
id|pmac_find_ide_boot
c_func
(paren
r_char
op_star
id|bootdevice
comma
r_int
id|n
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Look through the list of IDE interfaces for this one.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmac_ide_count
suffix:semicolon
op_increment
id|i
)paren
(brace
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmac_ide
(braket
id|i
)braket
dot
id|node
op_logical_or
op_logical_neg
id|pmac_ide
(braket
id|i
)braket
dot
id|node-&gt;full_name
)paren
r_continue
suffix:semicolon
id|name
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|node-&gt;full_name
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|name
comma
id|bootdevice
comma
id|n
)paren
op_eq
l_int|0
op_logical_and
id|name
(braket
id|n
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* XXX should cope with the 2nd drive as well... */
r_return
id|MKDEV
c_func
(paren
id|ide_majors
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Suspend call back, should be called after the child devices&n; * have actually been suspended&n; */
r_static
r_int
DECL|function|pmac_ide_do_suspend
id|pmac_ide_do_suspend
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|hwif-&gt;hwif_data
suffix:semicolon
multiline_comment|/* We clear the timings */
id|pmif-&gt;timings
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|pmif-&gt;timings
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE_PMAC_BLINK
multiline_comment|/* Note: This code will be called for every hwif, thus we&squot;ll&n;&t; * try several time to stop the LED blinker timer,  but that&n;&t; * should be harmless&n;&t; */
r_if
c_cond
(paren
id|pmu_ide_blink_enabled
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Make sure we don&squot;t hit the PMU blink */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pmu_blink_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmu_blink_ledstate
)paren
id|del_timer
c_func
(paren
op_amp
id|pmu_blink_timer
)paren
suffix:semicolon
id|pmu_blink_ledstate
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pmu_blink_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDE_PMAC_BLINK */
multiline_comment|/* The media bay will handle itself just fine */
r_if
c_cond
(paren
id|pmif-&gt;mediabay
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Disable the bus */
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_ENABLE
comma
id|pmif-&gt;node
comma
id|pmif-&gt;aapl_bus_id
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Resume call back, should be called before the child devices&n; * are resumed&n; */
r_static
r_int
DECL|function|pmac_ide_do_resume
id|pmac_ide_do_resume
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|hwif-&gt;hwif_data
suffix:semicolon
multiline_comment|/* Hard reset &amp; re-enable controller (do we really need to reset ? -BenH) */
r_if
c_cond
(paren
op_logical_neg
id|pmif-&gt;mediabay
)paren
(brace
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_RESET
comma
id|pmif-&gt;node
comma
id|pmif-&gt;aapl_bus_id
comma
l_int|1
)paren
suffix:semicolon
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_ENABLE
comma
id|pmif-&gt;node
comma
id|pmif-&gt;aapl_bus_id
comma
l_int|1
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_RESET
comma
id|pmif-&gt;node
comma
id|pmif-&gt;aapl_bus_id
comma
l_int|0
)paren
suffix:semicolon
id|msleep
c_func
(paren
id|jiffies_to_msecs
c_func
(paren
id|IDE_WAKEUP_DELAY
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Sanitize drive timings */
id|sanitize_timings
c_func
(paren
id|pmif
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup, register &amp; probe an IDE channel driven by this driver, this is&n; * called by one of the 2 probe functions (macio or PCI). Note that a channel&n; * that ends up beeing free of any device is not kept around by this driver&n; * (it is kept in 2.4). This introduce an interface numbering change on some&n; * rare machines unfortunately, but it&squot;s better this way.&n; */
r_static
r_int
DECL|function|pmac_ide_setup_device
id|pmac_ide_setup_device
c_func
(paren
id|pmac_ide_hwif_t
op_star
id|pmif
comma
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
id|pmif-&gt;node
suffix:semicolon
r_int
op_star
id|bidp
comma
id|i
suffix:semicolon
id|pmif-&gt;cable_80
op_assign
l_int|0
suffix:semicolon
id|pmif-&gt;broken_dma
op_assign
id|pmif-&gt;broken_dma_warn
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
l_string|&quot;kauai-ata&quot;
)paren
)paren
id|pmif-&gt;kind
op_assign
id|controller_un_ata6
suffix:semicolon
r_else
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
l_string|&quot;K2-UATA&quot;
)paren
)paren
id|pmif-&gt;kind
op_assign
id|controller_k2_ata6
suffix:semicolon
r_else
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
l_string|&quot;keylargo-ata&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;ata-4&quot;
)paren
op_eq
l_int|0
)paren
id|pmif-&gt;kind
op_assign
id|controller_kl_ata4
suffix:semicolon
r_else
id|pmif-&gt;kind
op_assign
id|controller_kl_ata3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
l_string|&quot;heathrow-ata&quot;
)paren
)paren
id|pmif-&gt;kind
op_assign
id|controller_heathrow
suffix:semicolon
r_else
(brace
id|pmif-&gt;kind
op_assign
id|controller_ohare
suffix:semicolon
id|pmif-&gt;broken_dma
op_assign
l_int|1
suffix:semicolon
)brace
id|bidp
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,bus-id&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|pmif-&gt;aapl_bus_id
op_assign
id|bidp
ques
c_cond
op_star
id|bidp
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Get cable type from device-tree */
r_if
c_cond
(paren
id|pmif-&gt;kind
op_eq
id|controller_kl_ata4
op_logical_or
id|pmif-&gt;kind
op_eq
id|controller_un_ata6
op_logical_or
id|pmif-&gt;kind
op_eq
id|controller_k2_ata6
)paren
(brace
r_char
op_star
id|cable
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;cable-type&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cable
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|cable
comma
l_string|&quot;80-&quot;
comma
l_int|3
)paren
)paren
id|pmif-&gt;cable_80
op_assign
l_int|1
suffix:semicolon
)brace
id|pmif-&gt;mediabay
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Make sure we have sane timings */
id|sanitize_timings
c_func
(paren
id|pmif
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_PPC64
multiline_comment|/* XXX FIXME: Media bay stuff need re-organizing */
r_if
c_cond
(paren
id|np-&gt;parent
op_logical_and
id|np-&gt;parent-&gt;name
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;parent-&gt;name
comma
l_string|&quot;media-bay&quot;
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_PMAC_PBOOK
id|media_bay_set_ide_infos
c_func
(paren
id|np-&gt;parent
comma
id|pmif-&gt;regbase
comma
id|pmif-&gt;irq
comma
id|hwif-&gt;index
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PMAC_PBOOK */
id|pmif-&gt;mediabay
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bidp
)paren
id|pmif-&gt;aapl_bus_id
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pmif-&gt;kind
op_eq
id|controller_ohare
)paren
(brace
multiline_comment|/* The code below is having trouble on some ohare machines&n;&t;&t; * (timing related ?). Until I can put my hand on one of these&n;&t;&t; * units, I keep the old way&n;&t;&t; */
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_ENABLE
comma
id|np
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
multiline_comment|/* This is necessary to enable IDE when net-booting */
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_RESET
comma
id|np
comma
id|pmif-&gt;aapl_bus_id
comma
l_int|1
)paren
suffix:semicolon
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_ENABLE
comma
id|np
comma
id|pmif-&gt;aapl_bus_id
comma
l_int|1
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ppc_md
dot
id|feature_call
c_func
(paren
id|PMAC_FTR_IDE_RESET
comma
id|np
comma
id|pmif-&gt;aapl_bus_id
comma
l_int|0
)paren
suffix:semicolon
id|msleep
c_func
(paren
id|jiffies_to_msecs
c_func
(paren
id|IDE_WAKEUP_DELAY
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Setup MMIO ops */
id|default_hwif_mmiops
c_func
(paren
id|hwif
)paren
suffix:semicolon
id|hwif-&gt;OUTBSYNC
op_assign
id|pmac_outbsync
suffix:semicolon
multiline_comment|/* Tell common code _not_ to mess with resources */
id|hwif-&gt;mmio
op_assign
l_int|2
suffix:semicolon
id|hwif-&gt;hwif_data
op_assign
id|pmif
suffix:semicolon
id|pmac_ide_init_hwif_ports
c_func
(paren
op_amp
id|hwif-&gt;hw
comma
id|pmif-&gt;regbase
comma
l_int|0
comma
op_amp
id|hwif-&gt;irq
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hwif-&gt;io_ports
comma
id|hwif-&gt;hw.io_ports
comma
r_sizeof
(paren
id|hwif-&gt;io_ports
)paren
)paren
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|ide_pmac
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
op_logical_neg
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_logical_or
id|pmif-&gt;mediabay
suffix:semicolon
id|hwif-&gt;hold
op_assign
id|pmif-&gt;mediabay
suffix:semicolon
id|hwif-&gt;udma_four
op_assign
id|pmif-&gt;cable_80
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|unmask
op_assign
l_int|1
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|unmask
op_assign
l_int|1
suffix:semicolon
id|hwif-&gt;tuneproc
op_assign
id|pmac_ide_tuneproc
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;kind
op_eq
id|controller_un_ata6
op_logical_or
id|pmif-&gt;kind
op_eq
id|controller_k2_ata6
)paren
id|hwif-&gt;selectproc
op_assign
id|pmac_ide_kauai_selectproc
suffix:semicolon
r_else
id|hwif-&gt;selectproc
op_assign
id|pmac_ide_selectproc
suffix:semicolon
id|hwif-&gt;speedproc
op_assign
id|pmac_ide_tune_chipset
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE_PMAC_BLINK
id|pmu_ide_blink_enabled
op_assign
id|pmu_hd_blink_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmu_ide_blink_enabled
)paren
id|hwif-&gt;led_act
op_assign
id|pmu_hd_kick_blink
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide%d: Found Apple %s controller, bus ID %d%s, irq %d&bslash;n&quot;
comma
id|hwif-&gt;index
comma
id|model_name
(braket
id|pmif-&gt;kind
)braket
comma
id|pmif-&gt;aapl_bus_id
comma
id|pmif-&gt;mediabay
ques
c_cond
l_string|&quot; (mediabay)&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|hwif-&gt;irq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PMAC_PBOOK
r_if
c_cond
(paren
id|pmif-&gt;mediabay
op_logical_and
id|check_media_bay_by_base
c_func
(paren
id|pmif-&gt;regbase
comma
id|MB_CD
)paren
op_eq
l_int|0
)paren
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* CONFIG_PMAC_PBOOK */
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
multiline_comment|/* has a DBDMA controller channel */
r_if
c_cond
(paren
id|pmif-&gt;dma_regs
)paren
id|pmac_ide_setup_dma
c_func
(paren
id|pmif
comma
id|hwif
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
multiline_comment|/* We probe the hwif now */
id|probe_hwif_init
c_func
(paren
id|hwif
)paren
suffix:semicolon
multiline_comment|/* The code IDE code will have set hwif-&gt;present if we have devices attached,&n;&t; * if we don&squot;t, the discard the interface except if we are on a media bay slot&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;present
op_logical_and
op_logical_neg
id|pmif-&gt;mediabay
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide%d: Bus empty, interface released.&bslash;n&quot;
comma
id|hwif-&gt;index
)paren
suffix:semicolon
id|default_hwif_iops
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|IDE_DATA_OFFSET
suffix:semicolon
id|i
op_le
id|IDE_CONTROL_OFFSET
suffix:semicolon
op_increment
id|i
)paren
id|hwif-&gt;io_ports
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|ide_unknown
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Attach to a macio probed interface&n; */
r_static
r_int
id|__devinit
DECL|function|pmac_ide_macio_attach
id|pmac_ide_macio_attach
c_func
(paren
r_struct
id|macio_dev
op_star
id|mdev
comma
r_const
r_struct
id|of_match
op_star
id|match
)paren
(brace
r_int
r_int
id|base
comma
id|regbase
suffix:semicolon
r_int
id|irq
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
id|pmac_ide_hwif_t
op_star
id|pmif
suffix:semicolon
r_int
id|i
comma
id|rc
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|MAX_HWIFS
op_logical_and
(paren
id|ide_hwifs
(braket
id|i
)braket
dot
id|io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_ne
l_int|0
op_logical_or
id|pmac_ide
(braket
id|i
)braket
dot
id|node
op_ne
l_int|NULL
)paren
)paren
op_increment
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|MAX_HWIFS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-pmac: MacIO interface attach with no slot&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;          %s&bslash;n&quot;
comma
id|mdev-&gt;ofdev.node-&gt;full_name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|pmif
op_assign
op_amp
id|pmac_ide
(braket
id|i
)braket
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|mdev-&gt;ofdev.node-&gt;n_addrs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide%d: no address for %s&bslash;n&quot;
comma
id|i
comma
id|mdev-&gt;ofdev.node-&gt;full_name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* Request memory resource for IO ports */
r_if
c_cond
(paren
id|macio_request_resource
c_func
(paren
id|mdev
comma
l_int|0
comma
l_string|&quot;ide-pmac (ports)&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide%d: can&squot;t request mmio resource !&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* XXX This is bogus. Should be fixed in the registry by checking&n;&t; * the kind of host interrupt controller, a bit like gatwick&n;&t; * fixes in irq.c. That works well enough for the single case&n;&t; * where that happens though...&n;&t; */
r_if
c_cond
(paren
id|macio_irq_count
c_func
(paren
id|mdev
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide%d: no intrs for device %s, using 13&bslash;n&quot;
comma
id|i
comma
id|mdev-&gt;ofdev.node-&gt;full_name
)paren
suffix:semicolon
id|irq
op_assign
l_int|13
suffix:semicolon
)brace
r_else
id|irq
op_assign
id|macio_irq
c_func
(paren
id|mdev
comma
l_int|0
)paren
suffix:semicolon
id|base
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|macio_resource_start
c_func
(paren
id|mdev
comma
l_int|0
)paren
comma
l_int|0x400
)paren
suffix:semicolon
id|regbase
op_assign
id|base
suffix:semicolon
id|hwif-&gt;pci_dev
op_assign
id|mdev-&gt;bus-&gt;pdev
suffix:semicolon
id|hwif-&gt;gendev.parent
op_assign
op_amp
id|mdev-&gt;ofdev.dev
suffix:semicolon
id|pmif-&gt;mdev
op_assign
id|mdev
suffix:semicolon
id|pmif-&gt;node
op_assign
id|mdev-&gt;ofdev.node
suffix:semicolon
id|pmif-&gt;regbase
op_assign
id|regbase
suffix:semicolon
id|pmif-&gt;irq
op_assign
id|irq
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
r_if
c_cond
(paren
id|macio_resource_count
c_func
(paren
id|mdev
)paren
op_ge
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|macio_request_resource
c_func
(paren
id|mdev
comma
l_int|1
comma
l_string|&quot;ide-pmac (dma)&quot;
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide%d: can&squot;t request DMA resource !&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_else
id|pmif-&gt;dma_regs
op_assign
(paren
r_volatile
r_struct
id|dbdma_regs
op_star
)paren
id|ioremap
c_func
(paren
id|macio_resource_start
c_func
(paren
id|mdev
comma
l_int|1
)paren
comma
l_int|0x1000
)paren
suffix:semicolon
)brace
r_else
id|pmif-&gt;dma_regs
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
id|dev_set_drvdata
c_func
(paren
op_amp
id|mdev-&gt;ofdev.dev
comma
id|hwif
)paren
suffix:semicolon
id|rc
op_assign
id|pmac_ide_setup_device
c_func
(paren
id|pmif
comma
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
multiline_comment|/* The inteface is released to the common IDE layer */
id|dev_set_drvdata
c_func
(paren
op_amp
id|mdev-&gt;ofdev.dev
comma
l_int|NULL
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;dma_regs
)paren
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|pmif-&gt;dma_regs
)paren
suffix:semicolon
id|memset
c_func
(paren
id|pmif
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pmif
)paren
)paren
suffix:semicolon
id|macio_release_resource
c_func
(paren
id|mdev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;dma_regs
)paren
id|macio_release_resource
c_func
(paren
id|mdev
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|pmac_ide_macio_suspend
id|pmac_ide_macio_suspend
c_func
(paren
r_struct
id|macio_dev
op_star
id|mdev
comma
id|u32
id|state
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
(paren
id|ide_hwif_t
op_star
)paren
id|dev_get_drvdata
c_func
(paren
op_amp
id|mdev-&gt;ofdev.dev
)paren
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|state
op_ne
id|mdev-&gt;ofdev.dev.power_state
op_logical_and
id|state
op_ge
l_int|2
)paren
(brace
id|rc
op_assign
id|pmac_ide_do_suspend
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|mdev-&gt;ofdev.dev.power_state
op_assign
id|state
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|pmac_ide_macio_resume
id|pmac_ide_macio_resume
c_func
(paren
r_struct
id|macio_dev
op_star
id|mdev
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
(paren
id|ide_hwif_t
op_star
)paren
id|dev_get_drvdata
c_func
(paren
op_amp
id|mdev-&gt;ofdev.dev
)paren
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mdev-&gt;ofdev.dev.power_state
op_ne
l_int|0
)paren
(brace
id|rc
op_assign
id|pmac_ide_do_resume
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|mdev-&gt;ofdev.dev.power_state
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Attach to a PCI probed interface&n; */
r_static
r_int
id|__devinit
DECL|function|pmac_ide_pci_attach
id|pmac_ide_pci_attach
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|id
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|pmac_ide_hwif_t
op_star
id|pmif
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
r_int
id|rbase
comma
id|rlen
suffix:semicolon
r_int
id|i
comma
id|rc
suffix:semicolon
id|np
op_assign
id|pci_device_to_OF_node
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-pmac: cannot find MacIO node for Kauai ATA interface&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|MAX_HWIFS
op_logical_and
(paren
id|ide_hwifs
(braket
id|i
)braket
dot
id|io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_ne
l_int|0
op_logical_or
id|pmac_ide
(braket
id|i
)braket
dot
id|node
op_ne
l_int|NULL
)paren
)paren
op_increment
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|MAX_HWIFS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-pmac: PCI interface attach with no slot&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;          %s&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|pmif
op_assign
op_amp
id|pmac_ide
(braket
id|i
)braket
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide%i: Can&squot;t enable PCI device for %s&bslash;n&quot;
comma
id|i
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|pci_set_master
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_request_regions
c_func
(paren
id|pdev
comma
l_string|&quot;Kauai ATA&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide%d: Cannot obtain PCI resources for %s&bslash;n&quot;
comma
id|i
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|hwif-&gt;pci_dev
op_assign
id|pdev
suffix:semicolon
id|hwif-&gt;gendev.parent
op_assign
op_amp
id|pdev-&gt;dev
suffix:semicolon
id|pmif-&gt;mdev
op_assign
l_int|NULL
suffix:semicolon
id|pmif-&gt;node
op_assign
id|np
suffix:semicolon
id|rbase
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|rlen
op_assign
id|pci_resource_len
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|base
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|rbase
comma
id|rlen
)paren
suffix:semicolon
id|pmif-&gt;regbase
op_assign
id|base
op_plus
l_int|0x2000
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
id|pmif-&gt;dma_regs
op_assign
(paren
r_volatile
r_struct
id|dbdma_regs
op_star
)paren
(paren
id|base
op_plus
l_int|0x1000
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */&t;
multiline_comment|/* We use the OF node irq mapping */
r_if
c_cond
(paren
id|np-&gt;n_intrs
op_eq
l_int|0
)paren
id|pmif-&gt;irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
r_else
id|pmif-&gt;irq
op_assign
id|np-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
id|hwif
)paren
suffix:semicolon
id|rc
op_assign
id|pmac_ide_setup_device
c_func
(paren
id|pmif
comma
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
multiline_comment|/* The inteface is released to the common IDE layer */
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
l_int|NULL
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|base
)paren
suffix:semicolon
id|memset
c_func
(paren
id|pmif
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pmif
)paren
)paren
suffix:semicolon
id|pci_release_regions
c_func
(paren
id|pdev
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|pmac_ide_pci_suspend
id|pmac_ide_pci_suspend
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
id|u32
id|state
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
(paren
id|ide_hwif_t
op_star
)paren
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|state
op_ne
id|pdev-&gt;dev.power_state
op_logical_and
id|state
op_ge
l_int|2
)paren
(brace
id|rc
op_assign
id|pmac_ide_do_suspend
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|pdev-&gt;dev.power_state
op_assign
id|state
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|pmac_ide_pci_resume
id|pmac_ide_pci_resume
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
(paren
id|ide_hwif_t
op_star
)paren
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;dev.power_state
op_ne
l_int|0
)paren
(brace
id|rc
op_assign
id|pmac_ide_do_resume
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|pdev-&gt;dev.power_state
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|variable|pmac_ide_macio_match
r_static
r_struct
id|of_match
id|pmac_ide_macio_match
(braket
)braket
op_assign
(brace
(brace
dot
id|name
op_assign
l_string|&quot;IDE&quot;
comma
dot
id|type
op_assign
id|OF_ANY_MATCH
comma
dot
id|compatible
op_assign
id|OF_ANY_MATCH
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;ATA&quot;
comma
dot
id|type
op_assign
id|OF_ANY_MATCH
comma
dot
id|compatible
op_assign
id|OF_ANY_MATCH
)brace
comma
(brace
dot
id|name
op_assign
id|OF_ANY_MATCH
comma
dot
id|type
op_assign
l_string|&quot;ide&quot;
comma
dot
id|compatible
op_assign
id|OF_ANY_MATCH
)brace
comma
(brace
dot
id|name
op_assign
id|OF_ANY_MATCH
comma
dot
id|type
op_assign
l_string|&quot;ata&quot;
comma
dot
id|compatible
op_assign
id|OF_ANY_MATCH
)brace
comma
(brace
)brace
comma
)brace
suffix:semicolon
DECL|variable|pmac_ide_macio_driver
r_static
r_struct
id|macio_driver
id|pmac_ide_macio_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ide-pmac&quot;
comma
dot
id|match_table
op_assign
id|pmac_ide_macio_match
comma
dot
id|probe
op_assign
id|pmac_ide_macio_attach
comma
dot
id|suspend
op_assign
id|pmac_ide_macio_suspend
comma
dot
id|resume
op_assign
id|pmac_ide_macio_resume
comma
)brace
suffix:semicolon
DECL|variable|pmac_ide_pci_match
r_static
r_struct
id|pci_device_id
id|pmac_ide_pci_match
(braket
)braket
op_assign
(brace
(brace
id|PCI_VENDOR_ID_APPLE
comma
id|PCI_DEVIEC_ID_APPLE_UNI_N_ATA
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|PCI_VENDOR_ID_APPLE
comma
id|PCI_DEVICE_ID_APPLE_IPID_ATA100
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|PCI_VENDOR_ID_APPLE
comma
id|PCI_DEVICE_ID_APPLE_K2_ATA100
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
DECL|variable|pmac_ide_pci_driver
r_static
r_struct
id|pci_driver
id|pmac_ide_pci_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ide-pmac&quot;
comma
dot
id|id_table
op_assign
id|pmac_ide_pci_match
comma
dot
id|probe
op_assign
id|pmac_ide_pci_attach
comma
dot
id|suspend
op_assign
id|pmac_ide_pci_suspend
comma
dot
id|resume
op_assign
id|pmac_ide_pci_resume
comma
)brace
suffix:semicolon
r_void
id|__init
DECL|function|pmac_ide_probe
id|pmac_ide_probe
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_Pmac
)paren
r_return
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE_PMAC_ATA100FIRST
id|pci_register_driver
c_func
(paren
op_amp
id|pmac_ide_pci_driver
)paren
suffix:semicolon
id|macio_register_driver
c_func
(paren
op_amp
id|pmac_ide_macio_driver
)paren
suffix:semicolon
macro_line|#else
id|macio_register_driver
c_func
(paren
op_amp
id|pmac_ide_macio_driver
)paren
suffix:semicolon
id|pci_register_driver
c_func
(paren
op_amp
id|pmac_ide_pci_driver
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
multiline_comment|/*&n; * This is very close to the generic ide-dma version of the function except&n; * that we don&squot;t use the fields in the hwif but our own copies for sg_table&n; * and friends. We build &amp; map the sglist for a given request&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_build_sglist
id|pmac_ide_build_sglist
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|hwif-&gt;hwif_data
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|pmif-&gt;sg_table
suffix:semicolon
r_int
id|nents
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;sg_dma_active
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|nents
op_assign
id|blk_rq_map_sg
c_func
(paren
id|drive-&gt;queue
comma
id|rq
comma
id|sg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
id|pmif-&gt;sg_dma_direction
op_assign
id|PCI_DMA_FROMDEVICE
suffix:semicolon
r_else
id|pmif-&gt;sg_dma_direction
op_assign
id|PCI_DMA_TODEVICE
suffix:semicolon
r_return
id|pci_map_sg
c_func
(paren
id|hwif-&gt;pci_dev
comma
id|sg
comma
id|nents
comma
id|pmif-&gt;sg_dma_direction
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Same as above but for a &quot;raw&quot; taskfile request&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_raw_build_sglist
id|pmac_ide_raw_build_sglist
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|hwif-&gt;hwif_data
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|pmif-&gt;sg_table
suffix:semicolon
r_int
id|nents
op_assign
l_int|0
suffix:semicolon
id|ide_task_t
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
r_int
r_char
op_star
id|virt_addr
op_assign
id|rq-&gt;buffer
suffix:semicolon
r_int
id|sector_count
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;command_type
op_eq
id|IDE_DRIVE_TASK_RAW_WRITE
)paren
id|pmif-&gt;sg_dma_direction
op_assign
id|PCI_DMA_TODEVICE
suffix:semicolon
r_else
id|pmif-&gt;sg_dma_direction
op_assign
id|PCI_DMA_FROMDEVICE
suffix:semicolon
r_if
c_cond
(paren
id|sector_count
OG
l_int|128
)paren
(brace
id|memset
c_func
(paren
op_amp
id|sg
(braket
id|nents
)braket
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sg
)paren
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|page
op_assign
id|virt_to_page
c_func
(paren
id|virt_addr
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|offset
op_assign
id|offset_in_page
c_func
(paren
id|virt_addr
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|length
op_assign
l_int|128
op_star
id|SECTOR_SIZE
suffix:semicolon
id|nents
op_increment
suffix:semicolon
id|virt_addr
op_assign
id|virt_addr
op_plus
(paren
l_int|128
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|sector_count
op_sub_assign
l_int|128
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|sg
(braket
id|nents
)braket
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sg
)paren
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|page
op_assign
id|virt_to_page
c_func
(paren
id|virt_addr
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|offset
op_assign
id|offset_in_page
c_func
(paren
id|virt_addr
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|length
op_assign
id|sector_count
op_star
id|SECTOR_SIZE
suffix:semicolon
id|nents
op_increment
suffix:semicolon
r_return
id|pci_map_sg
c_func
(paren
id|hwif-&gt;pci_dev
comma
id|sg
comma
id|nents
comma
id|pmif-&gt;sg_dma_direction
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pmac_ide_build_dmatable builds the DBDMA command list&n; * for a transfer and sets the DBDMA channel to point to it.&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_build_dmatable
id|pmac_ide_build_dmatable
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|dbdma_cmd
op_star
id|table
suffix:semicolon
r_int
id|i
comma
id|count
op_assign
l_int|0
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|hwif-&gt;hwif_data
suffix:semicolon
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma
op_assign
id|pmif-&gt;dma_regs
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_int
id|wr
op_assign
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|WRITE
)paren
suffix:semicolon
multiline_comment|/* DMA table is already aligned */
id|table
op_assign
(paren
r_struct
id|dbdma_cmd
op_star
)paren
id|pmif-&gt;dma_table_cpu
suffix:semicolon
multiline_comment|/* Make sure DMA controller is stopped (necessary ?) */
id|writel
c_func
(paren
(paren
id|RUN
op_or
id|PAUSE
op_or
id|FLUSH
op_or
id|WAKE
op_or
id|DEAD
)paren
op_lshift
l_int|16
comma
op_amp
id|dma-&gt;control
)paren
suffix:semicolon
r_while
c_loop
(paren
id|readl
c_func
(paren
op_amp
id|dma-&gt;status
)paren
op_amp
id|RUN
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Build sglist */
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
id|pmif-&gt;sg_nents
op_assign
id|i
op_assign
id|pmac_ide_raw_build_sglist
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_else
id|pmif-&gt;sg_nents
op_assign
id|i
op_assign
id|pmac_ide_build_sglist
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Build DBDMA commands list */
id|sg
op_assign
id|pmif-&gt;sg_table
suffix:semicolon
r_while
c_loop
(paren
id|i
op_logical_and
id|sg_dma_len
c_func
(paren
id|sg
)paren
)paren
(brace
id|u32
id|cur_addr
suffix:semicolon
id|u32
id|cur_len
suffix:semicolon
id|cur_addr
op_assign
id|sg_dma_address
c_func
(paren
id|sg
)paren
suffix:semicolon
id|cur_len
op_assign
id|sg_dma_len
c_func
(paren
id|sg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;broken_dma
op_logical_and
id|cur_addr
op_amp
(paren
id|L1_CACHE_BYTES
op_minus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|pmif-&gt;broken_dma_warn
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: DMA on non aligned address,&quot;
l_string|&quot;switching to PIO on Ohare chipset&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|pmif-&gt;broken_dma_warn
op_assign
l_int|1
suffix:semicolon
)brace
r_goto
id|use_pio_instead
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cur_len
)paren
(brace
r_int
r_int
id|tc
op_assign
(paren
id|cur_len
OL
l_int|0xfe00
)paren
ques
c_cond
id|cur_len
suffix:colon
l_int|0xfe00
suffix:semicolon
r_if
c_cond
(paren
id|count
op_increment
op_ge
id|MAX_DCMDS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: DMA table too small&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_goto
id|use_pio_instead
suffix:semicolon
)brace
id|st_le16
c_func
(paren
op_amp
id|table-&gt;command
comma
id|wr
ques
c_cond
id|OUTPUT_MORE
suffix:colon
id|INPUT_MORE
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|table-&gt;req_count
comma
id|tc
)paren
suffix:semicolon
id|st_le32
c_func
(paren
op_amp
id|table-&gt;phy_addr
comma
id|cur_addr
)paren
suffix:semicolon
id|table-&gt;cmd_dep
op_assign
l_int|0
suffix:semicolon
id|table-&gt;xfer_status
op_assign
l_int|0
suffix:semicolon
id|table-&gt;res_count
op_assign
l_int|0
suffix:semicolon
id|cur_addr
op_add_assign
id|tc
suffix:semicolon
id|cur_len
op_sub_assign
id|tc
suffix:semicolon
op_increment
id|table
suffix:semicolon
)brace
id|sg
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
multiline_comment|/* convert the last command to an input/output last command */
r_if
c_cond
(paren
id|count
)paren
(brace
id|st_le16
c_func
(paren
op_amp
id|table
(braket
op_minus
l_int|1
)braket
dot
id|command
comma
id|wr
ques
c_cond
id|OUTPUT_LAST
suffix:colon
id|INPUT_LAST
)paren
suffix:semicolon
multiline_comment|/* add the stop command to the end of the list */
id|memset
c_func
(paren
id|table
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|table-&gt;command
comma
id|DBDMA_STOP
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|pmif-&gt;dma_table_dma
comma
op_amp
id|dma-&gt;cmdptr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: empty DMA table?&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|use_pio_instead
suffix:colon
id|pci_unmap_sg
c_func
(paren
id|hwif-&gt;pci_dev
comma
id|pmif-&gt;sg_table
comma
id|pmif-&gt;sg_nents
comma
id|pmif-&gt;sg_dma_direction
)paren
suffix:semicolon
id|hwif-&gt;sg_dma_active
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* revert to PIO for this request */
)brace
multiline_comment|/* Teardown mappings after DMA has completed.  */
r_static
r_void
id|__pmac
DECL|function|pmac_ide_destroy_dmatable
id|pmac_ide_destroy_dmatable
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|pci_dev
suffix:semicolon
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|hwif_data
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|pmif-&gt;sg_table
suffix:semicolon
r_int
id|nents
op_assign
id|pmif-&gt;sg_nents
suffix:semicolon
r_if
c_cond
(paren
id|nents
)paren
(brace
id|pci_unmap_sg
c_func
(paren
id|dev
comma
id|sg
comma
id|nents
comma
id|pmif-&gt;sg_dma_direction
)paren
suffix:semicolon
id|pmif-&gt;sg_nents
op_assign
l_int|0
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|sg_dma_active
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Pick up best MDMA timing for the drive and apply it&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_mdma_enable
id|pmac_ide_mdma_enable
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u16
id|mode
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|hwif-&gt;hwif_data
suffix:semicolon
r_int
id|drive_cycle_time
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|u32
op_star
id|timings
comma
op_star
id|timings2
suffix:semicolon
id|u32
id|timing_local
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* which drive is it ? */
id|timings
op_assign
op_amp
id|pmif-&gt;timings
(braket
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)braket
suffix:semicolon
id|timings2
op_assign
op_amp
id|pmif-&gt;timings
(braket
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
op_plus
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Check if drive provide explicit cycle time */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
op_logical_and
(paren
id|id-&gt;eide_dma_time
)paren
)paren
id|drive_cycle_time
op_assign
id|id-&gt;eide_dma_time
suffix:semicolon
r_else
id|drive_cycle_time
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Copy timings to local image */
id|timing_local
(braket
l_int|0
)braket
op_assign
op_star
id|timings
suffix:semicolon
id|timing_local
(braket
l_int|1
)braket
op_assign
op_star
id|timings2
suffix:semicolon
multiline_comment|/* Calculate controller timings */
id|ret
op_assign
id|set_timings_mdma
c_func
(paren
id|drive
comma
id|pmif-&gt;kind
comma
op_amp
id|timing_local
(braket
l_int|0
)braket
comma
op_amp
id|timing_local
(braket
l_int|1
)braket
comma
id|mode
comma
id|drive_cycle_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Set feature on drive */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Enabling MultiWord DMA %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|mode
op_amp
l_int|0xf
)paren
suffix:semicolon
id|ret
op_assign
id|pmac_ide_do_setfeature
c_func
(paren
id|drive
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Failed !&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Apply timings to controller */
op_star
id|timings
op_assign
id|timing_local
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|timings2
op_assign
id|timing_local
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Set speed info in drive */
id|drive-&gt;current_speed
op_assign
id|mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;init_speed
)paren
id|drive-&gt;init_speed
op_assign
id|mode
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Pick up best UDMA timing for the drive and apply it&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_udma_enable
id|pmac_ide_udma_enable
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u16
id|mode
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|hwif-&gt;hwif_data
suffix:semicolon
id|u32
op_star
id|timings
comma
op_star
id|timings2
suffix:semicolon
id|u32
id|timing_local
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* which drive is it ? */
id|timings
op_assign
op_amp
id|pmif-&gt;timings
(braket
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)braket
suffix:semicolon
id|timings2
op_assign
op_amp
id|pmif-&gt;timings
(braket
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
op_plus
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Copy timings to local image */
id|timing_local
(braket
l_int|0
)braket
op_assign
op_star
id|timings
suffix:semicolon
id|timing_local
(braket
l_int|1
)braket
op_assign
op_star
id|timings2
suffix:semicolon
multiline_comment|/* Calculate timings for interface */
r_if
c_cond
(paren
id|pmif-&gt;kind
op_eq
id|controller_un_ata6
op_logical_or
id|pmif-&gt;kind
op_eq
id|controller_k2_ata6
)paren
id|ret
op_assign
id|set_timings_udma_ata6
c_func
(paren
op_amp
id|timing_local
(braket
l_int|0
)braket
comma
op_amp
id|timing_local
(braket
l_int|1
)braket
comma
id|mode
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|set_timings_udma_ata4
c_func
(paren
op_amp
id|timing_local
(braket
l_int|0
)braket
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Set feature on drive */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Enabling Ultra DMA %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|mode
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|ret
op_assign
id|pmac_ide_do_setfeature
c_func
(paren
id|drive
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Failed !&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Apply timings to controller */
op_star
id|timings
op_assign
id|timing_local
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|timings2
op_assign
id|timing_local
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Set speed info in drive */
id|drive-&gt;current_speed
op_assign
id|mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;init_speed
)paren
id|drive-&gt;init_speed
op_assign
id|mode
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Check what is the best DMA timing setting for the drive and&n; * call appropriate functions to apply it.&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_dma_check
id|pmac_ide_dma_check
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|hwif-&gt;hwif_data
suffix:semicolon
r_int
id|enable
op_assign
l_int|1
suffix:semicolon
r_int
id|map
suffix:semicolon
id|drive-&gt;using_dma
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_floppy
)paren
id|enable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|id-&gt;capability
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
id|__ide_dma_good_drive
c_func
(paren
id|drive
)paren
)paren
id|enable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|__ide_dma_bad_drive
c_func
(paren
id|drive
)paren
)paren
id|enable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|enable
)paren
(brace
r_int
id|mode
suffix:semicolon
id|map
op_assign
id|XFER_MWDMA
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;kind
op_eq
id|controller_kl_ata4
op_logical_or
id|pmif-&gt;kind
op_eq
id|controller_un_ata6
op_logical_or
id|pmif-&gt;kind
op_eq
id|controller_k2_ata6
)paren
(brace
id|map
op_or_assign
id|XFER_UDMA
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;cable_80
)paren
(brace
id|map
op_or_assign
id|XFER_UDMA_66
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;kind
op_eq
id|controller_un_ata6
op_logical_or
id|pmif-&gt;kind
op_eq
id|controller_k2_ata6
)paren
id|map
op_or_assign
id|XFER_UDMA_100
suffix:semicolon
)brace
)brace
id|mode
op_assign
id|ide_find_best_mode
c_func
(paren
id|drive
comma
id|map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_amp
id|XFER_UDMA
)paren
id|drive-&gt;using_dma
op_assign
id|pmac_ide_udma_enable
c_func
(paren
id|drive
comma
id|mode
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mode
op_amp
id|XFER_MWDMA
)paren
id|drive-&gt;using_dma
op_assign
id|pmac_ide_mdma_enable
c_func
(paren
id|drive
comma
id|mode
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
l_int|0
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* Apply settings to controller */
id|pmac_ide_do_update_timings
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare a DMA transfer. We build the DMA table, adjust the timings for&n; * a read on KeyLargo ATA/66 and mark us as waiting for DMA completion&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_dma_start
id|pmac_ide_dma_start
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|reading
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|hwif-&gt;hwif_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|u8
id|unit
op_assign
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
suffix:semicolon
id|u8
id|ata4
suffix:semicolon
r_if
c_cond
(paren
id|pmif
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|ata4
op_assign
(paren
id|pmif-&gt;kind
op_eq
id|controller_kl_ata4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmac_ide_build_dmatable
c_func
(paren
id|drive
comma
id|rq
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Apple adds 60ns to wrDataSetup on reads */
r_if
c_cond
(paren
id|ata4
op_logical_and
(paren
id|pmif-&gt;timings
(braket
id|unit
)braket
op_amp
id|TR_66_UDMA_EN
)paren
)paren
(brace
id|writel
c_func
(paren
id|pmif-&gt;timings
(braket
id|unit
)braket
op_plus
(paren
id|reading
ques
c_cond
l_int|0x00800000UL
suffix:colon
l_int|0
)paren
comma
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_TIMING_CONFIG
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|readl
c_func
(paren
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
id|IDE_TIMING_CONFIG
)paren
)paren
suffix:semicolon
)brace
id|drive-&gt;waiting_for_dma
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Start a DMA READ command&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_dma_read
id|pmac_ide_dma_read
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|u8
id|lba48
op_assign
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|task_ioreg_t
id|command
op_assign
id|WIN_NOP
suffix:semicolon
r_if
c_cond
(paren
id|pmac_ide_dma_start
c_func
(paren
id|drive
comma
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
l_int|0
suffix:semicolon
id|command
op_assign
(paren
id|lba48
)paren
ques
c_cond
id|WIN_READDMA_EXT
suffix:colon
id|WIN_READDMA
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;vdma
)paren
id|command
op_assign
(paren
id|lba48
)paren
ques
c_cond
id|WIN_READ_EXT
suffix:colon
id|WIN_READ
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
(brace
id|ide_task_t
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
id|command
op_assign
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
suffix:semicolon
)brace
multiline_comment|/* issue cmd to drive */
id|ide_execute_command
c_func
(paren
id|drive
comma
id|command
comma
op_amp
id|ide_dma_intr
comma
l_int|2
op_star
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|pmac_ide_dma_begin
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start a DMA WRITE command&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_dma_write
id|pmac_ide_dma_write
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|u8
id|lba48
op_assign
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|task_ioreg_t
id|command
op_assign
id|WIN_NOP
suffix:semicolon
r_if
c_cond
(paren
id|pmac_ide_dma_start
c_func
(paren
id|drive
comma
l_int|0
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
l_int|0
suffix:semicolon
id|command
op_assign
(paren
id|lba48
)paren
ques
c_cond
id|WIN_WRITEDMA_EXT
suffix:colon
id|WIN_WRITEDMA
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;vdma
)paren
id|command
op_assign
(paren
id|lba48
)paren
ques
c_cond
id|WIN_WRITE_EXT
suffix:colon
id|WIN_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
(brace
id|ide_task_t
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
id|command
op_assign
id|args-&gt;tfRegister
(braket
id|IDE_COMMAND_OFFSET
)braket
suffix:semicolon
)brace
multiline_comment|/* issue cmd to drive */
id|ide_execute_command
c_func
(paren
id|drive
comma
id|command
comma
op_amp
id|ide_dma_intr
comma
l_int|2
op_star
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|pmac_ide_dma_begin
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Kick the DMA controller into life after the DMA command has been issued&n; * to the drive.&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_dma_begin
id|pmac_ide_dma_begin
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|hwif_data
suffix:semicolon
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma
suffix:semicolon
r_if
c_cond
(paren
id|pmif
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|dma
op_assign
id|pmif-&gt;dma_regs
suffix:semicolon
id|writel
c_func
(paren
(paren
id|RUN
op_lshift
l_int|16
)paren
op_or
id|RUN
comma
op_amp
id|dma-&gt;control
)paren
suffix:semicolon
multiline_comment|/* Make sure it gets to the controller right now */
(paren
r_void
)paren
id|readl
c_func
(paren
op_amp
id|dma-&gt;control
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * After a DMA transfer, make sure the controller is stopped&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_dma_end
id|pmac_ide_dma_end
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|hwif_data
suffix:semicolon
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma
suffix:semicolon
id|u32
id|dstat
suffix:semicolon
r_if
c_cond
(paren
id|pmif
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|dma
op_assign
id|pmif-&gt;dma_regs
suffix:semicolon
id|drive-&gt;waiting_for_dma
op_assign
l_int|0
suffix:semicolon
id|dstat
op_assign
id|readl
c_func
(paren
op_amp
id|dma-&gt;status
)paren
suffix:semicolon
id|writel
c_func
(paren
(paren
(paren
id|RUN
op_or
id|WAKE
op_or
id|DEAD
)paren
op_lshift
l_int|16
)paren
comma
op_amp
id|dma-&gt;control
)paren
suffix:semicolon
id|pmac_ide_destroy_dmatable
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* verify good dma status. we don&squot;t check for ACTIVE beeing 0. We should...&n;&t; * in theory, but with ATAPI decices doing buffer underruns, that would&n;&t; * cause us to disable DMA, which isn&squot;t what we want&n;&t; */
r_return
(paren
id|dstat
op_amp
(paren
id|RUN
op_or
id|DEAD
)paren
)paren
op_ne
id|RUN
suffix:semicolon
)brace
multiline_comment|/*&n; * Check out that the interrupt we got was for us. We can&squot;t always know this&n; * for sure with those Apple interfaces (well, we could on the recent ones but&n; * that&squot;s not implemented yet), on the other hand, we don&squot;t have shared interrupts&n; * so it&squot;s not really a problem&n; */
r_static
r_int
id|__pmac
DECL|function|pmac_ide_dma_test_irq
id|pmac_ide_dma_test_irq
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|hwif_data
suffix:semicolon
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma
suffix:semicolon
r_int
r_int
id|status
comma
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|pmif
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|dma
op_assign
id|pmif-&gt;dma_regs
suffix:semicolon
multiline_comment|/* We have to things to deal with here:&n;&t; * &n;&t; * - The dbdma won&squot;t stop if the command was started&n;&t; * but completed with an error without transferring all&n;&t; * datas. This happens when bad blocks are met during&n;&t; * a multi-block transfer.&n;&t; * &n;&t; * - The dbdma fifo hasn&squot;t yet finished flushing to&n;&t; * to system memory when the disk interrupt occurs.&n;&t; * &n;&t; */
multiline_comment|/* If ACTIVE is cleared, the STOP command have passed and&n;&t; * transfer is complete.&n;&t; */
id|status
op_assign
id|readl
c_func
(paren
op_amp
id|dma-&gt;status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|ACTIVE
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;waiting_for_dma
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide%d, ide_dma_test_irq &bslash;&n;&t;&t;&t;called while not waiting&bslash;n&quot;
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|index
)paren
suffix:semicolon
multiline_comment|/* If dbdma didn&squot;t execute the STOP command yet, the&n;&t; * active bit is still set. We consider that we aren&squot;t&n;&t; * sharing interrupts (which is hopefully the case with&n;&t; * those controllers) and so we just try to flush the&n;&t; * channel for pending data in the fifo&n;&t; */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|writel
c_func
(paren
(paren
id|FLUSH
op_lshift
l_int|16
)paren
op_or
id|FLUSH
comma
op_amp
id|dma-&gt;control
)paren
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|status
op_assign
id|readl
c_func
(paren
op_amp
id|dma-&gt;status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|FLUSH
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|timeout
OG
l_int|100
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide%d, ide_dma_test_irq &bslash;&n;&t;&t;&t;timeout flushing channel&bslash;n&quot;
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|index
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
id|__pmac
DECL|function|pmac_ide_dma_host_off
id|pmac_ide_dma_host_off
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|__pmac
DECL|function|pmac_ide_dma_host_on
id|pmac_ide_dma_host_on
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|__pmac
DECL|function|pmac_ide_dma_lostirq
id|pmac_ide_dma_lostirq
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|pmac_ide_hwif_t
op_star
id|pmif
op_assign
(paren
id|pmac_ide_hwif_t
op_star
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|hwif_data
suffix:semicolon
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|pmif
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|dma
op_assign
id|pmif-&gt;dma_regs
suffix:semicolon
id|status
op_assign
id|readl
c_func
(paren
op_amp
id|dma-&gt;status
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-pmac lost interrupt, dma status: %lx&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate the data structures needed for using DMA with an interface&n; * and fill the proper list of functions pointers&n; */
r_static
r_void
id|__init
DECL|function|pmac_ide_setup_dma
id|pmac_ide_setup_dma
c_func
(paren
id|pmac_ide_hwif_t
op_star
id|pmif
comma
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
multiline_comment|/* We won&squot;t need pci_dev if we switch to generic consistent&n;&t; * DMA routines ...&n;&t; */
r_if
c_cond
(paren
id|hwif-&gt;pci_dev
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate space for the DBDMA commands.&n;&t; * The +2 is +1 for the stop command and +1 to allow for&n;&t; * aligning the start address to a multiple of 16 bytes.&n;&t; */
id|pmif-&gt;dma_table_cpu
op_assign
(paren
r_struct
id|dbdma_cmd
op_star
)paren
id|pci_alloc_consistent
c_func
(paren
id|hwif-&gt;pci_dev
comma
(paren
id|MAX_DCMDS
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
comma
op_amp
id|pmif-&gt;dma_table_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;dma_table_cpu
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unable to allocate DMA command list&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pmif-&gt;sg_table
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|scatterlist
)paren
op_star
id|MAX_DCMDS
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmif-&gt;sg_table
op_eq
l_int|NULL
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hwif-&gt;pci_dev
comma
(paren
id|MAX_DCMDS
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
comma
id|pmif-&gt;dma_table_cpu
comma
id|pmif-&gt;dma_table_dma
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hwif-&gt;ide_dma_off_quietly
op_assign
op_amp
id|__ide_dma_off_quietly
suffix:semicolon
id|hwif-&gt;ide_dma_on
op_assign
op_amp
id|__ide_dma_on
suffix:semicolon
id|hwif-&gt;ide_dma_check
op_assign
op_amp
id|pmac_ide_dma_check
suffix:semicolon
id|hwif-&gt;ide_dma_read
op_assign
op_amp
id|pmac_ide_dma_read
suffix:semicolon
id|hwif-&gt;ide_dma_write
op_assign
op_amp
id|pmac_ide_dma_write
suffix:semicolon
id|hwif-&gt;ide_dma_begin
op_assign
op_amp
id|pmac_ide_dma_begin
suffix:semicolon
id|hwif-&gt;ide_dma_end
op_assign
op_amp
id|pmac_ide_dma_end
suffix:semicolon
id|hwif-&gt;ide_dma_test_irq
op_assign
op_amp
id|pmac_ide_dma_test_irq
suffix:semicolon
id|hwif-&gt;ide_dma_host_off
op_assign
op_amp
id|pmac_ide_dma_host_off
suffix:semicolon
id|hwif-&gt;ide_dma_host_on
op_assign
op_amp
id|pmac_ide_dma_host_on
suffix:semicolon
id|hwif-&gt;ide_dma_verbose
op_assign
op_amp
id|__ide_dma_verbose
suffix:semicolon
id|hwif-&gt;ide_dma_timeout
op_assign
op_amp
id|__ide_dma_timeout
suffix:semicolon
id|hwif-&gt;ide_dma_lostirq
op_assign
op_amp
id|pmac_ide_dma_lostirq
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO
r_if
c_cond
(paren
op_logical_neg
id|noautodma
)paren
id|hwif-&gt;autodma
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|autodma
op_assign
id|hwif-&gt;autodma
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|autodma
op_assign
id|hwif-&gt;autodma
suffix:semicolon
id|hwif-&gt;atapi_dma
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|pmif-&gt;kind
)paren
(brace
r_case
id|controller_un_ata6
suffix:colon
r_case
id|controller_k2_ata6
suffix:colon
id|hwif-&gt;ultra_mask
op_assign
id|pmif-&gt;cable_80
ques
c_cond
l_int|0x3f
suffix:colon
l_int|0x07
suffix:semicolon
id|hwif-&gt;mwdma_mask
op_assign
l_int|0x07
suffix:semicolon
id|hwif-&gt;swdma_mask
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
id|controller_kl_ata4
suffix:colon
id|hwif-&gt;ultra_mask
op_assign
id|pmif-&gt;cable_80
ques
c_cond
l_int|0x1f
suffix:colon
l_int|0x07
suffix:semicolon
id|hwif-&gt;mwdma_mask
op_assign
l_int|0x07
suffix:semicolon
id|hwif-&gt;swdma_mask
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|hwif-&gt;ultra_mask
op_assign
l_int|0x00
suffix:semicolon
id|hwif-&gt;mwdma_mask
op_assign
l_int|0x07
suffix:semicolon
id|hwif-&gt;swdma_mask
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
eof
