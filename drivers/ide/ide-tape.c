multiline_comment|/*&n; * linux/drivers/ide/ide-tape.c&t;&t;Version 1.19&t;Nov, 2003&n; *&n; * Copyright (C) 1995 - 1999 Gadi Oxman &lt;gadio@netvision.net.il&gt;&n; *&n; * $Header$&n; *&n; * This driver was constructed as a student project in the software laboratory&n; * of the faculty of electrical engineering in the Technion - Israel&squot;s&n; * Institute Of Technology, with the guide of Avner Lottem and Dr. Ilana David.&n; *&n; * It is hereby placed under the terms of the GNU general public license.&n; * (See linux/COPYING).&n; */
multiline_comment|/*&n; * IDE ATAPI streaming tape driver.&n; *&n; * This driver is a part of the Linux ide driver and works in co-operation&n; * with linux/drivers/block/ide.c.&n; *&n; * The driver, in co-operation with ide.c, basically traverses the &n; * request-list for the block device interface. The character device&n; * interface, on the other hand, creates new requests, adds them&n; * to the request-list of the block device, and waits for their completion.&n; *&n; * Pipelined operation mode is now supported on both reads and writes.&n; *&n; * The block device major and minor numbers are determined from the&n; * tape&squot;s relative position in the ide interfaces, as explained in ide.c.&n; *&n; * The character device interface consists of the following devices:&n; *&n; * ht0&t;&t;major 37, minor 0&t;first  IDE tape, rewind on close.&n; * ht1&t;&t;major 37, minor 1&t;second IDE tape, rewind on close.&n; * ...&n; * nht0&t;&t;major 37, minor 128&t;first  IDE tape, no rewind on close.&n; * nht1&t;&t;major 37, minor 129&t;second IDE tape, no rewind on close.&n; * ...&n; *&n; * Run linux/scripts/MAKEDEV.ide to create the above entries.&n; *&n; * The general magnetic tape commands compatible interface, as defined by&n; * include/linux/mtio.h, is accessible through the character device.&n; *&n; * General ide driver configuration options, such as the interrupt-unmask&n; * flag, can be configured by issuing an ioctl to the block device interface,&n; * as any other ide device.&n; *&n; * Our own ide-tape ioctl&squot;s can be issued to either the block device or&n; * the character device interface.&n; *&n; * Maximal throughput with minimal bus load will usually be achieved in the&n; * following scenario:&n; *&n; *&t;1.&t;ide-tape is operating in the pipelined operation mode.&n; *&t;2.&t;No buffering is performed by the user backup program.&n; *&n; * Testing was done with a 2 GB CONNER CTMA 4000 IDE ATAPI Streaming Tape Drive.&n; * &n; * Ver 0.1   Nov  1 95   Pre-working code :-)&n; * Ver 0.2   Nov 23 95   A short backup (few megabytes) and restore procedure&n; *                        was successful ! (Using tar cvf ... on the block&n; *                        device interface).&n; *                       A longer backup resulted in major swapping, bad&n; *                        overall Linux performance and eventually failed as&n; *                        we received non serial read-ahead requests from the&n; *                        buffer cache.&n; * Ver 0.3   Nov 28 95   Long backups are now possible, thanks to the&n; *                        character device interface. Linux&squot;s responsiveness&n; *                        and performance doesn&squot;t seem to be much affected&n; *                        from the background backup procedure.&n; *                       Some general mtio.h magnetic tape operations are&n; *                        now supported by our character device. As a result,&n; *                        popular tape utilities are starting to work with&n; *                        ide tapes :-)&n; *                       The following configurations were tested:&n; *                       &t;1. An IDE ATAPI TAPE shares the same interface&n; *                       &t;   and irq with an IDE ATAPI CDROM.&n; *                        &t;2. An IDE ATAPI TAPE shares the same interface&n; *                          &t;   and irq with a normal IDE disk.&n; *                        Both configurations seemed to work just fine !&n; *                        However, to be on the safe side, it is meanwhile&n; *                        recommended to give the IDE TAPE its own interface&n; *                        and irq.&n; *                       The one thing which needs to be done here is to&n; *                        add a &quot;request postpone&quot; feature to ide.c,&n; *                        so that we won&squot;t have to wait for the tape to finish&n; *                        performing a long media access (DSC) request (such&n; *                        as a rewind) before we can access the other device&n; *                        on the same interface. This effect doesn&squot;t disturb&n; *                        normal operation most of the time because read/write&n; *                        requests are relatively fast, and once we are&n; *                        performing one tape r/w request, a lot of requests&n; *                        from the other device can be queued and ide.c will&n; *&t;&t;&t;  service all of them after this single tape request.&n; * Ver 1.0   Dec 11 95   Integrated into Linux 1.3.46 development tree.&n; *                       On each read / write request, we now ask the drive&n; *                        if we can transfer a constant number of bytes&n; *                        (a parameter of the drive) only to its buffers,&n; *                        without causing actual media access. If we can&squot;t,&n; *                        we just wait until we can by polling the DSC bit.&n; *                        This ensures that while we are not transferring&n; *                        more bytes than the constant referred to above, the&n; *                        interrupt latency will not become too high and&n; *                        we won&squot;t cause an interrupt timeout, as happened&n; *                        occasionally in the previous version.&n; *                       While polling for DSC, the current request is&n; *                        postponed and ide.c is free to handle requests from&n; *                        the other device. This is handled transparently to&n; *                        ide.c. The hwgroup locking method which was used&n; *                        in the previous version was removed.&n; *                       Use of new general features which are provided by&n; *                        ide.c for use with atapi devices.&n; *                        (Programming done by Mark Lord)&n; *                       Few potential bug fixes (Again, suggested by Mark)&n; *                       Single character device data transfers are now&n; *                        not limited in size, as they were before.&n; *                       We are asking the tape about its recommended&n; *                        transfer unit and send a larger data transfer&n; *                        as several transfers of the above size.&n; *                        For best results, use an integral number of this&n; *                        basic unit (which is shown during driver&n; *                        initialization). I will soon add an ioctl to get&n; *                        this important parameter.&n; *                       Our data transfer buffer is allocated on startup,&n; *                        rather than before each data transfer. This should&n; *                        ensure that we will indeed have a data buffer.&n; * Ver 1.1   Dec 14 95   Fixed random problems which occurred when the tape&n; *                        shared an interface with another device.&n; *                        (poll_for_dsc was a complete mess).&n; *                       Removed some old (non-active) code which had&n; *                        to do with supporting buffer cache originated&n; *                        requests.&n; *                       The block device interface can now be opened, so&n; *                        that general ide driver features like the unmask&n; *                        interrupts flag can be selected with an ioctl.&n; *                        This is the only use of the block device interface.&n; *                       New fast pipelined operation mode (currently only on&n; *                        writes). When using the pipelined mode, the&n; *                        throughput can potentially reach the maximum&n; *                        tape supported throughput, regardless of the&n; *                        user backup program. On my tape drive, it sometimes&n; *                        boosted performance by a factor of 2. Pipelined&n; *                        mode is enabled by default, but since it has a few&n; *                        downfalls as well, you may want to disable it.&n; *                        A short explanation of the pipelined operation mode&n; *                        is available below.&n; * Ver 1.2   Jan  1 96   Eliminated pipelined mode race condition.&n; *                       Added pipeline read mode. As a result, restores&n; *                        are now as fast as backups.&n; *                       Optimized shared interface behavior. The new behavior&n; *                        typically results in better IDE bus efficiency and&n; *                        higher tape throughput.&n; *                       Pre-calculation of the expected read/write request&n; *                        service time, based on the tape&squot;s parameters. In&n; *                        the pipelined operation mode, this allows us to&n; *                        adjust our polling frequency to a much lower value,&n; *                        and thus to dramatically reduce our load on Linux,&n; *                        without any decrease in performance.&n; *                       Implemented additional mtio.h operations.&n; *                       The recommended user block size is returned by&n; *                        the MTIOCGET ioctl.&n; *                       Additional minor changes.&n; * Ver 1.3   Feb  9 96   Fixed pipelined read mode bug which prevented the&n; *                        use of some block sizes during a restore procedure.&n; *                       The character device interface will now present a&n; *                        continuous view of the media - any mix of block sizes&n; *                        during a backup/restore procedure is supported. The&n; *                        driver will buffer the requests internally and&n; *                        convert them to the tape&squot;s recommended transfer&n; *                        unit, making performance almost independent of the&n; *                        chosen user block size.&n; *                       Some improvements in error recovery.&n; *                       By cooperating with ide-dma.c, bus mastering DMA can&n; *                        now sometimes be used with IDE tape drives as well.&n; *                        Bus mastering DMA has the potential to dramatically&n; *                        reduce the CPU&squot;s overhead when accessing the device,&n; *                        and can be enabled by using hdparm -d1 on the tape&squot;s&n; *                        block device interface. For more info, read the&n; *                        comments in ide-dma.c.&n; * Ver 1.4   Mar 13 96   Fixed serialize support.&n; * Ver 1.5   Apr 12 96   Fixed shared interface operation, broken in 1.3.85.&n; *                       Fixed pipelined read mode inefficiency.&n; *                       Fixed nasty null dereferencing bug.&n; * Ver 1.6   Aug 16 96   Fixed FPU usage in the driver.&n; *                       Fixed end of media bug.&n; * Ver 1.7   Sep 10 96   Minor changes for the CONNER CTT8000-A model.&n; * Ver 1.8   Sep 26 96   Attempt to find a better balance between good&n; *                        interactive response and high system throughput.&n; * Ver 1.9   Nov  5 96   Automatically cross encountered filemarks rather&n; *                        than requiring an explicit FSF command.&n; *                       Abort pending requests at end of media.&n; *                       MTTELL was sometimes returning incorrect results.&n; *                       Return the real block size in the MTIOCGET ioctl.&n; *                       Some error recovery bug fixes.&n; * Ver 1.10  Nov  5 96   Major reorganization.&n; *                       Reduced CPU overhead a bit by eliminating internal&n; *                        bounce buffers.&n; *                       Added module support.&n; *                       Added multiple tape drives support.&n; *                       Added partition support.&n; *                       Rewrote DSC handling.&n; *                       Some portability fixes.&n; *                       Removed ide-tape.h.&n; *                       Additional minor changes.&n; * Ver 1.11  Dec  2 96   Bug fix in previous DSC timeout handling.&n; *                       Use ide_stall_queue() for DSC overlap.&n; *                       Use the maximum speed rather than the current speed&n; *                        to compute the request service time.&n; * Ver 1.12  Dec  7 97   Fix random memory overwriting and/or last block data&n; *                        corruption, which could occur if the total number&n; *                        of bytes written to the tape was not an integral&n; *                        number of tape blocks.&n; *                       Add support for INTERRUPT DRQ devices.&n; * Ver 1.13  Jan  2 98   Add &quot;speed == 0&quot; work-around for HP COLORADO 5GB&n; * Ver 1.14  Dec 30 98   Partial fixes for the Sony/AIWA tape drives.&n; *                       Replace cli()/sti() with hwgroup spinlocks.&n; * Ver 1.15  Mar 25 99   Fix SMP race condition by replacing hwgroup&n; *                        spinlock with private per-tape spinlock.&n; * Ver 1.16  Sep  1 99   Add OnStream tape support.&n; *                       Abort read pipeline on EOD.&n; *                       Wait for the tape to become ready in case it returns&n; *                        &quot;in the process of becoming ready&quot; on open().&n; *                       Fix zero padding of the last written block in&n; *                        case the tape block size is larger than PAGE_SIZE.&n; *                       Decrease the default disconnection time to tn.&n; * Ver 1.16e Oct  3 99   Minor fixes.&n; * Ver 1.16e1 Oct 13 99  Patches by Arnold Niessen,&n; *                          niessen@iae.nl / arnold.niessen@philips.com&n; *                   GO-1)  Undefined code in idetape_read_position&n; *&t;&t;&t;&t;according to Gadi&squot;s email&n; *                   AJN-1) Minor fix asc == 11 should be asc == 0x11&n; *                               in idetape_issue_packet_command (did effect&n; *                               debugging output only)&n; *                   AJN-2) Added more debugging output, and&n; *                              added ide-tape: where missing. I would also&n; *&t;&t;&t;&t;like to add tape-&gt;name where possible&n; *                   AJN-3) Added different debug_level&squot;s &n; *                              via /proc/ide/hdc/settings&n; * &t;&t;&t;&t;&quot;debug_level&quot; determines amount of debugging output;&n; * &t;&t;&t;&t;can be changed using /proc/ide/hdx/settings&n; * &t;&t;&t;&t;0 : almost no debugging output&n; * &t;&t;&t;&t;1 : 0+output errors only&n; * &t;&t;&t;&t;2 : 1+output all sensekey/asc&n; * &t;&t;&t;&t;3 : 2+follow all chrdev related procedures&n; * &t;&t;&t;&t;4 : 3+follow all procedures&n; * &t;&t;&t;&t;5 : 4+include pc_stack rq_stack info&n; * &t;&t;&t;&t;6 : 5+USE_COUNT updates&n; *                   AJN-4) Fixed timeout for retension in idetape_queue_pc_tail&n; *&t;&t;&t;&t;from 5 to 10 minutes&n; *                   AJN-5) Changed maximum number of blocks to skip when&n; *                              reading tapes with multiple consecutive write&n; *                              errors from 100 to 1000 in idetape_get_logical_blk&n; *                   Proposed changes to code:&n; *                   1) output &quot;logical_blk_num&quot; via /proc&n; *                   2) output &quot;current_operation&quot; via /proc&n; *                   3) Either solve or document the fact that `mt rewind&squot; is&n; *                      required after reading from /dev/nhtx to be&n; *&t;&t;&t;able to rmmod the idetape module;&n; *&t;&t;&t;Also, sometimes an application finishes but the&n; *&t;&t;&t;device remains `busy&squot; for some time. Same cause ?&n; *                   Proposed changes to release-notes:&n; *&t;&t;     4) write a simple `quickstart&squot; section in the&n; *                      release notes; I volunteer if you don&squot;t want to&n; * &t;&t;     5) include a pointer to video4linux in the doc&n; *                      to stimulate video applications&n; *                   6) release notes lines 331 and 362: explain what happens&n; *&t;&t;&t;if the application data rate is higher than 1100 KB/s; &n; *&t;&t;&t;similar approach to lower-than-500 kB/s ?&n; *&t;&t;     7) 6.6 Comparison; wouldn&squot;t it be better to allow different &n; *&t;&t;&t;strategies for read and write ?&n; *&t;&t;&t;Wouldn&squot;t it be better to control the tape buffer&n; *&t;&t;&t;contents instead of the bandwidth ?&n; *&t;&t;     8) line 536: replace will by would (if I understand&n; *&t;&t;&t;this section correctly, a hypothetical and unwanted situation&n; *&t;&t;&t; is being described)&n; * Ver 1.16f Dec 15 99   Change place of the secondary OnStream header frames.&n; * Ver 1.17  Nov 2000 / Jan 2001  Marcel Mol, marcel@mesa.nl&n; *&t;&t;&t;- Add idetape_onstream_mode_sense_tape_parameter_page&n; *&t;&t;&t;  function to get tape capacity in frames: tape-&gt;capacity.&n; *&t;&t;&t;- Add support for DI-50 drives( or any DI- drive).&n; *&t;&t;&t;- &squot;workaround&squot; for read error/blank block around block 3000.&n; *&t;&t;&t;- Implement Early warning for end of media for Onstream.&n; *&t;&t;&t;- Cosmetic code changes for readability.&n; *&t;&t;&t;- Idetape_position_tape should not use SKIP bit during&n; *&t;&t;&t;  Onstream read recovery.&n; *&t;&t;&t;- Add capacity, logical_blk_num and first/last_frame_position&n; *&t;&t;&t;  to /proc/ide/hd?/settings.&n; *&t;&t;&t;- Module use count was gone in the Linux 2.4 driver.&n; * Ver 1.17a Apr 2001 Willem Riede osst@riede.org&n; * &t;&t;&t;- Get drive&squot;s actual block size from mode sense block descriptor&n; * &t;&t;&t;- Limit size of pipeline&n; * Ver 1.17b Oct 2002   Alan Stern &lt;stern@rowland.harvard.edu&gt;&n; *&t;&t;&t;Changed IDETAPE_MIN_PIPELINE_STAGES to 1 and actually used&n; *&t;&t;&t; it in the code!&n; *&t;&t;&t;Actually removed aborted stages in idetape_abort_pipeline&n; *&t;&t;&t; instead of just changing the command code.&n; *&t;&t;&t;Made the transfer byte count for Request Sense equal to the&n; *&t;&t;&t; actual length of the data transfer.&n; *&t;&t;&t;Changed handling of partial data transfers: they do not&n; *&t;&t;&t; cause DMA errors.&n; *&t;&t;&t;Moved initiation of DMA transfers to the correct place.&n; *&t;&t;&t;Removed reference to unallocated memory.&n; *&t;&t;&t;Made __idetape_discard_read_pipeline return the number of&n; *&t;&t;&t; sectors skipped, not the number of stages.&n; *&t;&t;&t;Replaced errant kfree() calls with __idetape_kfree_stage().&n; *&t;&t;&t;Fixed off-by-one error in testing the pipeline length.&n; *&t;&t;&t;Fixed handling of filemarks in the read pipeline.&n; *&t;&t;&t;Small code optimization for MTBSF and MTBSFM ioctls.&n; *&t;&t;&t;Don&squot;t try to unlock the door during device close if is&n; *&t;&t;&t; already unlocked!&n; *&t;&t;&t;Cosmetic fixes to miscellaneous debugging output messages.&n; *&t;&t;&t;Set the minimum /proc/ide/hd?/settings values for &quot;pipeline&quot;,&n; *&t;&t;&t; &quot;pipeline_min&quot;, and &quot;pipeline_max&quot; to 1.&n; *&n; * Here are some words from the first releases of hd.c, which are quoted&n; * in ide.c and apply here as well:&n; *&n; * | Special care is recommended.  Have Fun!&n; *&n; */
multiline_comment|/*&n; * An overview of the pipelined operation mode.&n; *&n; * In the pipelined write mode, we will usually just add requests to our&n; * pipeline and return immediately, before we even start to service them. The&n; * user program will then have enough time to prepare the next request while&n; * we are still busy servicing previous requests. In the pipelined read mode,&n; * the situation is similar - we add read-ahead requests into the pipeline,&n; * before the user even requested them.&n; *&n; * The pipeline can be viewed as a &quot;safety net&quot; which will be activated when&n; * the system load is high and prevents the user backup program from keeping up&n; * with the current tape speed. At this point, the pipeline will get&n; * shorter and shorter but the tape will still be streaming at the same speed.&n; * Assuming we have enough pipeline stages, the system load will hopefully&n; * decrease before the pipeline is completely empty, and the backup program&n; * will be able to &quot;catch up&quot; and refill the pipeline again.&n; * &n; * When using the pipelined mode, it would be best to disable any type of&n; * buffering done by the user program, as ide-tape already provides all the&n; * benefits in the kernel, where it can be done in a more efficient way.&n; * As we will usually not block the user program on a request, the most&n; * efficient user code will then be a simple read-write-read-... cycle.&n; * Any additional logic will usually just slow down the backup process.&n; *&n; * Using the pipelined mode, I get a constant over 400 KBps throughput,&n; * which seems to be the maximum throughput supported by my tape.&n; *&n; * However, there are some downfalls:&n; *&n; *&t;1.&t;We use memory (for data buffers) in proportional to the number&n; *&t;&t;of pipeline stages (each stage is about 26 KB with my tape).&n; *&t;2.&t;In the pipelined write mode, we cheat and postpone error codes&n; *&t;&t;to the user task. In read mode, the actual tape position&n; *&t;&t;will be a bit further than the last requested block.&n; *&n; * Concerning (1):&n; *&n; *&t;1.&t;We allocate stages dynamically only when we need them. When&n; *&t;&t;we don&squot;t need them, we don&squot;t consume additional memory. In&n; *&t;&t;case we can&squot;t allocate stages, we just manage without them&n; *&t;&t;(at the expense of decreased throughput) so when Linux is&n; *&t;&t;tight in memory, we will not pose additional difficulties.&n; *&n; *&t;2.&t;The maximum number of stages (which is, in fact, the maximum&n; *&t;&t;amount of memory) which we allocate is limited by the compile&n; *&t;&t;time parameter IDETAPE_MAX_PIPELINE_STAGES.&n; *&n; *&t;3.&t;The maximum number of stages is a controlled parameter - We&n; *&t;&t;don&squot;t start from the user defined maximum number of stages&n; *&t;&t;but from the lower IDETAPE_MIN_PIPELINE_STAGES (again, we&n; *&t;&t;will not even allocate this amount of stages if the user&n; *&t;&t;program can&squot;t handle the speed). We then implement a feedback&n; *&t;&t;loop which checks if the pipeline is empty, and if it is, we&n; *&t;&t;increase the maximum number of stages as necessary until we&n; *&t;&t;reach the optimum value which just manages to keep the tape&n; *&t;&t;busy with minimum allocated memory or until we reach&n; *&t;&t;IDETAPE_MAX_PIPELINE_STAGES.&n; *&n; * Concerning (2):&n; *&n; *&t;In pipelined write mode, ide-tape can not return accurate error codes&n; *&t;to the user program since we usually just add the request to the&n; *      pipeline without waiting for it to be serviced. In case an error&n; *      occurs, I will report it on the next user request.&n; *&n; *&t;In the pipelined read mode, subsequent read requests or forward&n; *&t;filemark spacing will perform correctly, as we preserve all blocks&n; *&t;and filemarks which we encountered during our excess read-ahead.&n; * &n; *&t;For accurate tape positioning and error reporting, disabling&n; *&t;pipelined mode might be the best option.&n; *&n; * You can enable/disable/tune the pipelined operation mode by adjusting&n; * the compile time parameters below.&n; */
multiline_comment|/*&n; *&t;Possible improvements.&n; *&n; *&t;1.&t;Support for the ATAPI overlap protocol.&n; *&n; *&t;&t;In order to maximize bus throughput, we currently use the DSC&n; *&t;&t;overlap method which enables ide.c to service requests from the&n; *&t;&t;other device while the tape is busy executing a command. The&n; *&t;&t;DSC overlap method involves polling the tape&squot;s status register&n; *&t;&t;for the DSC bit, and servicing the other device while the tape&n; *&t;&t;isn&squot;t ready.&n; *&n; *&t;&t;In the current QIC development standard (December 1995),&n; *&t;&t;it is recommended that new tape drives will *in addition* &n; *&t;&t;implement the ATAPI overlap protocol, which is used for the&n; *&t;&t;same purpose - efficient use of the IDE bus, but is interrupt&n; *&t;&t;driven and thus has much less CPU overhead.&n; *&n; *&t;&t;ATAPI overlap is likely to be supported in most new ATAPI&n; *&t;&t;devices, including new ATAPI cdroms, and thus provides us&n; *&t;&t;a method by which we can achieve higher throughput when&n; *&t;&t;sharing a (fast) ATA-2 disk with any (slow) new ATAPI device.&n; */
DECL|macro|IDETAPE_VERSION
mdefine_line|#define IDETAPE_VERSION &quot;1.19&quot;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
multiline_comment|/*&n; * partition&n; */
DECL|struct|os_partition_s
r_typedef
r_struct
id|os_partition_s
(brace
DECL|member|partition_num
id|__u8
id|partition_num
suffix:semicolon
DECL|member|par_desc_ver
id|__u8
id|par_desc_ver
suffix:semicolon
DECL|member|wrt_pass_cntr
id|__u16
id|wrt_pass_cntr
suffix:semicolon
DECL|member|first_frame_addr
id|__u32
id|first_frame_addr
suffix:semicolon
DECL|member|last_frame_addr
id|__u32
id|last_frame_addr
suffix:semicolon
DECL|member|eod_frame_addr
id|__u32
id|eod_frame_addr
suffix:semicolon
DECL|typedef|os_partition_t
)brace
id|os_partition_t
suffix:semicolon
multiline_comment|/*&n; * DAT entry&n; */
DECL|struct|os_dat_entry_s
r_typedef
r_struct
id|os_dat_entry_s
(brace
DECL|member|blk_sz
id|__u32
id|blk_sz
suffix:semicolon
DECL|member|blk_cnt
id|__u16
id|blk_cnt
suffix:semicolon
DECL|member|flags
id|__u8
id|flags
suffix:semicolon
DECL|member|reserved
id|__u8
id|reserved
suffix:semicolon
DECL|typedef|os_dat_entry_t
)brace
id|os_dat_entry_t
suffix:semicolon
multiline_comment|/*&n; * DAT&n; */
DECL|macro|OS_DAT_FLAGS_DATA
mdefine_line|#define OS_DAT_FLAGS_DATA&t;(0xc)
DECL|macro|OS_DAT_FLAGS_MARK
mdefine_line|#define OS_DAT_FLAGS_MARK&t;(0x1)
DECL|struct|os_dat_s
r_typedef
r_struct
id|os_dat_s
(brace
DECL|member|dat_sz
id|__u8
id|dat_sz
suffix:semicolon
DECL|member|reserved1
id|__u8
id|reserved1
suffix:semicolon
DECL|member|entry_cnt
id|__u8
id|entry_cnt
suffix:semicolon
DECL|member|reserved3
id|__u8
id|reserved3
suffix:semicolon
DECL|member|dat_list
id|os_dat_entry_t
id|dat_list
(braket
l_int|16
)braket
suffix:semicolon
DECL|typedef|os_dat_t
)brace
id|os_dat_t
suffix:semicolon
macro_line|#include &lt;linux/mtio.h&gt;
multiline_comment|/**************************** Tunable parameters *****************************/
multiline_comment|/*&n; *&t;Pipelined mode parameters.&n; *&n; *&t;We try to use the minimum number of stages which is enough to&n; *&t;keep the tape constantly streaming. To accomplish that, we implement&n; *&t;a feedback loop around the maximum number of stages:&n; *&n; *&t;We start from MIN maximum stages (we will not even use MIN stages&n; *      if we don&squot;t need them), increment it by RATE*(MAX-MIN)&n; *&t;whenever we sense that the pipeline is empty, until we reach&n; *&t;the optimum value or until we reach MAX.&n; *&n; *&t;Setting the following parameter to 0 is illegal: the pipelined mode&n; *&t;cannot be disabled (calculate_speeds() divides by tape-&gt;max_stages.)&n; */
DECL|macro|IDETAPE_MIN_PIPELINE_STAGES
mdefine_line|#define IDETAPE_MIN_PIPELINE_STAGES&t;  1
DECL|macro|IDETAPE_MAX_PIPELINE_STAGES
mdefine_line|#define IDETAPE_MAX_PIPELINE_STAGES&t;400
DECL|macro|IDETAPE_INCREASE_STAGES_RATE
mdefine_line|#define IDETAPE_INCREASE_STAGES_RATE&t; 20
multiline_comment|/*&n; *&t;The following are used to debug the driver:&n; *&n; *&t;Setting IDETAPE_DEBUG_INFO to 1 will report device capabilities.&n; *&t;Setting IDETAPE_DEBUG_LOG to 1 will log driver flow control.&n; *&t;Setting IDETAPE_DEBUG_BUGS to 1 will enable self-sanity checks in&n; *&t;some places.&n; *&n; *&t;Setting them to 0 will restore normal operation mode:&n; *&n; *&t;&t;1.&t;Disable logging normal successful operations.&n; *&t;&t;2.&t;Disable self-sanity checks.&n; *&t;&t;3.&t;Errors will still be logged, of course.&n; *&n; *&t;All the #if DEBUG code will be removed some day, when the driver&n; *&t;is verified to be stable enough. This will make it much more&n; *&t;esthetic.&n; */
DECL|macro|IDETAPE_DEBUG_INFO
mdefine_line|#define IDETAPE_DEBUG_INFO&t;&t;0
DECL|macro|IDETAPE_DEBUG_LOG
mdefine_line|#define IDETAPE_DEBUG_LOG&t;&t;0
DECL|macro|IDETAPE_DEBUG_BUGS
mdefine_line|#define IDETAPE_DEBUG_BUGS&t;&t;1
multiline_comment|/*&n; *&t;After each failed packet command we issue a request sense command&n; *&t;and retry the packet command IDETAPE_MAX_PC_RETRIES times.&n; *&n; *&t;Setting IDETAPE_MAX_PC_RETRIES to 0 will disable retries.&n; */
DECL|macro|IDETAPE_MAX_PC_RETRIES
mdefine_line|#define IDETAPE_MAX_PC_RETRIES&t;&t;3
multiline_comment|/*&n; *&t;With each packet command, we allocate a buffer of&n; *&t;IDETAPE_PC_BUFFER_SIZE bytes. This is used for several packet&n; *&t;commands (Not for READ/WRITE commands).&n; */
DECL|macro|IDETAPE_PC_BUFFER_SIZE
mdefine_line|#define IDETAPE_PC_BUFFER_SIZE&t;&t;256
multiline_comment|/*&n; *&t;In various places in the driver, we need to allocate storage&n; *&t;for packet commands and requests, which will remain valid while&n; *&t;we leave the driver to wait for an interrupt or a timeout event.&n; */
DECL|macro|IDETAPE_PC_STACK
mdefine_line|#define IDETAPE_PC_STACK&t;&t;(10 + IDETAPE_MAX_PC_RETRIES)
multiline_comment|/*&n; * Some drives (for example, Seagate STT3401A Travan) require a very long&n; * timeout, because they don&squot;t return an interrupt or clear their busy bit&n; * until after the command completes (even retension commands).&n; */
DECL|macro|IDETAPE_WAIT_CMD
mdefine_line|#define IDETAPE_WAIT_CMD&t;&t;(900*HZ)
multiline_comment|/*&n; *&t;The following parameter is used to select the point in the internal&n; *&t;tape fifo in which we will start to refill the buffer. Decreasing&n; *&t;the following parameter will improve the system&squot;s latency and&n; *&t;interactive response, while using a high value might improve sytem&n; *&t;throughput.&n; */
DECL|macro|IDETAPE_FIFO_THRESHOLD
mdefine_line|#define IDETAPE_FIFO_THRESHOLD &t;&t;2
multiline_comment|/*&n; *&t;DSC polling parameters.&n; *&n; *&t;Polling for DSC (a single bit in the status register) is a very&n; *&t;important function in ide-tape. There are two cases in which we&n; *&t;poll for DSC:&n; *&n; *&t;1.&t;Before a read/write packet command, to ensure that we&n; *&t;&t;can transfer data from/to the tape&squot;s data buffers, without&n; *&t;&t;causing an actual media access. In case the tape is not&n; *&t;&t;ready yet, we take out our request from the device&n; *&t;&t;request queue, so that ide.c will service requests from&n; *&t;&t;the other device on the same interface meanwhile.&n; *&n; *&t;2.&t;After the successful initialization of a &quot;media access&n; *&t;&t;packet command&quot;, which is a command which can take a long&n; *&t;&t;time to complete (it can be several seconds or even an hour).&n; *&n; *&t;&t;Again, we postpone our request in the middle to free the bus&n; *&t;&t;for the other device. The polling frequency here should be&n; *&t;&t;lower than the read/write frequency since those media access&n; *&t;&t;commands are slow. We start from a &quot;fast&quot; frequency -&n; *&t;&t;IDETAPE_DSC_MA_FAST (one second), and if we don&squot;t receive DSC&n; *&t;&t;after IDETAPE_DSC_MA_THRESHOLD (5 minutes), we switch it to a&n; *&t;&t;lower frequency - IDETAPE_DSC_MA_SLOW (1 minute).&n; *&n; *&t;We also set a timeout for the timer, in case something goes wrong.&n; *&t;The timeout should be longer then the maximum execution time of a&n; *&t;tape operation.&n; */
multiline_comment|/*&n; *&t;DSC timings.&n; */
DECL|macro|IDETAPE_DSC_RW_MIN
mdefine_line|#define IDETAPE_DSC_RW_MIN&t;&t;5*HZ/100&t;/* 50 msec */
DECL|macro|IDETAPE_DSC_RW_MAX
mdefine_line|#define IDETAPE_DSC_RW_MAX&t;&t;40*HZ/100&t;/* 400 msec */
DECL|macro|IDETAPE_DSC_RW_TIMEOUT
mdefine_line|#define IDETAPE_DSC_RW_TIMEOUT&t;&t;2*60*HZ&t;&t;/* 2 minutes */
DECL|macro|IDETAPE_DSC_MA_FAST
mdefine_line|#define IDETAPE_DSC_MA_FAST&t;&t;2*HZ&t;&t;/* 2 seconds */
DECL|macro|IDETAPE_DSC_MA_THRESHOLD
mdefine_line|#define IDETAPE_DSC_MA_THRESHOLD&t;5*60*HZ&t;&t;/* 5 minutes */
DECL|macro|IDETAPE_DSC_MA_SLOW
mdefine_line|#define IDETAPE_DSC_MA_SLOW&t;&t;30*HZ&t;&t;/* 30 seconds */
DECL|macro|IDETAPE_DSC_MA_TIMEOUT
mdefine_line|#define IDETAPE_DSC_MA_TIMEOUT&t;&t;2*60*60*HZ&t;/* 2 hours */
multiline_comment|/*************************** End of tunable parameters ***********************/
multiline_comment|/*&n; *&t;Debugging/Performance analysis&n; *&n; *&t;I/O trace support&n; */
DECL|macro|USE_IOTRACE
mdefine_line|#define USE_IOTRACE&t;0
macro_line|#if USE_IOTRACE
macro_line|#include &lt;linux/io_trace.h&gt;
DECL|macro|IO_IDETAPE_FIFO
mdefine_line|#define IO_IDETAPE_FIFO&t;500
macro_line|#endif
multiline_comment|/*&n; *&t;Read/Write error simulation&n; */
DECL|macro|SIMULATE_ERRORS
mdefine_line|#define SIMULATE_ERRORS&t;&t;&t;0
multiline_comment|/*&n; *&t;For general magnetic tape device compatibility.&n; */
r_typedef
r_enum
(brace
DECL|enumerator|idetape_direction_none
id|idetape_direction_none
comma
DECL|enumerator|idetape_direction_read
id|idetape_direction_read
comma
DECL|enumerator|idetape_direction_write
id|idetape_direction_write
DECL|typedef|idetape_chrdev_direction_t
)brace
id|idetape_chrdev_direction_t
suffix:semicolon
DECL|struct|idetape_bh
r_struct
id|idetape_bh
(brace
DECL|member|b_size
r_int
r_int
id|b_size
suffix:semicolon
DECL|member|b_count
id|atomic_t
id|b_count
suffix:semicolon
DECL|member|b_reqnext
r_struct
id|idetape_bh
op_star
id|b_reqnext
suffix:semicolon
DECL|member|b_data
r_char
op_star
id|b_data
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Our view of a packet command.&n; */
DECL|struct|idetape_packet_command_s
r_typedef
r_struct
id|idetape_packet_command_s
(brace
DECL|member|c
id|u8
id|c
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* Actual packet bytes */
DECL|member|retries
r_int
id|retries
suffix:semicolon
multiline_comment|/* On each retry, we increment retries */
DECL|member|error
r_int
id|error
suffix:semicolon
multiline_comment|/* Error code */
DECL|member|request_transfer
r_int
id|request_transfer
suffix:semicolon
multiline_comment|/* Bytes to transfer */
DECL|member|actually_transferred
r_int
id|actually_transferred
suffix:semicolon
multiline_comment|/* Bytes actually transferred */
DECL|member|buffer_size
r_int
id|buffer_size
suffix:semicolon
multiline_comment|/* Size of our data buffer */
DECL|member|bh
r_struct
id|idetape_bh
op_star
id|bh
suffix:semicolon
DECL|member|b_data
r_char
op_star
id|b_data
suffix:semicolon
DECL|member|b_count
r_int
id|b_count
suffix:semicolon
DECL|member|buffer
id|u8
op_star
id|buffer
suffix:semicolon
multiline_comment|/* Data buffer */
DECL|member|current_position
id|u8
op_star
id|current_position
suffix:semicolon
multiline_comment|/* Pointer into the above buffer */
DECL|member|callback
id|ide_startstop_t
(paren
op_star
id|callback
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/* Called when this packet command is completed */
DECL|member|pc_buffer
id|u8
id|pc_buffer
(braket
id|IDETAPE_PC_BUFFER_SIZE
)braket
suffix:semicolon
multiline_comment|/* Temporary buffer */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Status/Action bit flags: long for set_bit */
DECL|typedef|idetape_pc_t
)brace
id|idetape_pc_t
suffix:semicolon
multiline_comment|/*&n; *&t;Packet command flag bits.&n; */
multiline_comment|/* Set when an error is considered normal - We won&squot;t retry */
DECL|macro|PC_ABORT
mdefine_line|#define&t;PC_ABORT&t;&t;&t;0
multiline_comment|/* 1 When polling for DSC on a media access command */
DECL|macro|PC_WAIT_FOR_DSC
mdefine_line|#define PC_WAIT_FOR_DSC&t;&t;&t;1
multiline_comment|/* 1 when we prefer to use DMA if possible */
DECL|macro|PC_DMA_RECOMMENDED
mdefine_line|#define PC_DMA_RECOMMENDED&t;&t;2
multiline_comment|/* 1 while DMA in progress */
DECL|macro|PC_DMA_IN_PROGRESS
mdefine_line|#define&t;PC_DMA_IN_PROGRESS&t;&t;3
multiline_comment|/* 1 when encountered problem during DMA */
DECL|macro|PC_DMA_ERROR
mdefine_line|#define&t;PC_DMA_ERROR&t;&t;&t;4
multiline_comment|/* Data direction */
DECL|macro|PC_WRITING
mdefine_line|#define&t;PC_WRITING&t;&t;&t;5
multiline_comment|/*&n; *&t;Capabilities and Mechanical Status Page&n; */
r_typedef
r_struct
(brace
DECL|member|page_code
r_int
id|page_code
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Page code - Should be 0x2a */
DECL|member|reserved0_6
id|__u8
id|reserved0_6
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ps
id|__u8
id|ps
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* parameters saveable */
DECL|member|page_length
id|__u8
id|page_length
suffix:semicolon
multiline_comment|/* Page Length - Should be 0x12 */
DECL|member|reserved2
DECL|member|reserved3
id|__u8
id|reserved2
comma
id|reserved3
suffix:semicolon
DECL|member|ro
r_int
id|ro
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Read Only Mode */
DECL|member|reserved4_1234
r_int
id|reserved4_1234
suffix:colon
l_int|4
suffix:semicolon
DECL|member|sprev
r_int
id|sprev
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Supports SPACE in the reverse direction */
DECL|member|reserved4_67
r_int
id|reserved4_67
suffix:colon
l_int|2
suffix:semicolon
DECL|member|reserved5_012
r_int
id|reserved5_012
suffix:colon
l_int|3
suffix:semicolon
DECL|member|efmt
r_int
id|efmt
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Supports ERASE command initiated formatting */
DECL|member|reserved5_4
r_int
id|reserved5_4
suffix:colon
l_int|1
suffix:semicolon
DECL|member|qfa
r_int
id|qfa
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Supports the QFA two partition formats */
DECL|member|reserved5_67
r_int
id|reserved5_67
suffix:colon
l_int|2
suffix:semicolon
DECL|member|lock
r_int
id|lock
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Supports locking the volume */
DECL|member|locked
r_int
id|locked
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The volume is locked */
DECL|member|prevent
r_int
id|prevent
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The device defaults in the prevent state after power up */
DECL|member|eject
r_int
id|eject
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The device can eject the volume */
DECL|member|disconnect
id|__u8
id|disconnect
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The device can break request &gt; ctl */
DECL|member|reserved6_5
id|__u8
id|reserved6_5
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ecc
r_int
id|ecc
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Supports error correction */
DECL|member|cmprs
r_int
id|cmprs
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Supports data compression */
DECL|member|reserved7_0
r_int
id|reserved7_0
suffix:colon
l_int|1
suffix:semicolon
DECL|member|blk512
r_int
id|blk512
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Supports 512 bytes block size */
DECL|member|blk1024
r_int
id|blk1024
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Supports 1024 bytes block size */
DECL|member|reserved7_3_6
r_int
id|reserved7_3_6
suffix:colon
l_int|4
suffix:semicolon
DECL|member|blk32768
r_int
id|blk32768
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* slowb - the device restricts the byte count for PIO */
multiline_comment|/* transfers for slow buffer memory ??? */
multiline_comment|/* Also 32768 block size in some cases */
DECL|member|max_speed
id|__u16
id|max_speed
suffix:semicolon
multiline_comment|/* Maximum speed supported in KBps */
DECL|member|reserved10
DECL|member|reserved11
id|__u8
id|reserved10
comma
id|reserved11
suffix:semicolon
DECL|member|ctl
id|__u16
id|ctl
suffix:semicolon
multiline_comment|/* Continuous Transfer Limit in blocks */
DECL|member|speed
id|__u16
id|speed
suffix:semicolon
multiline_comment|/* Current Speed, in KBps */
DECL|member|buffer_size
id|__u16
id|buffer_size
suffix:semicolon
multiline_comment|/* Buffer Size, in 512 bytes */
DECL|member|reserved18
DECL|member|reserved19
id|__u8
id|reserved18
comma
id|reserved19
suffix:semicolon
DECL|typedef|idetape_capabilities_page_t
)brace
id|idetape_capabilities_page_t
suffix:semicolon
multiline_comment|/*&n; *&t;Block Size Page&n; */
r_typedef
r_struct
(brace
DECL|member|page_code
r_int
id|page_code
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Page code - Should be 0x30 */
DECL|member|reserved1_6
r_int
id|reserved1_6
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ps
r_int
id|ps
suffix:colon
l_int|1
suffix:semicolon
DECL|member|page_length
id|__u8
id|page_length
suffix:semicolon
multiline_comment|/* Page Length - Should be 2 */
DECL|member|reserved2
id|__u8
id|reserved2
suffix:semicolon
DECL|member|play32
r_int
id|play32
suffix:colon
l_int|1
suffix:semicolon
DECL|member|play32_5
r_int
id|play32_5
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved2_23
r_int
id|reserved2_23
suffix:colon
l_int|2
suffix:semicolon
DECL|member|record32
r_int
id|record32
suffix:colon
l_int|1
suffix:semicolon
DECL|member|record32_5
r_int
id|record32_5
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved2_6
r_int
id|reserved2_6
suffix:colon
l_int|1
suffix:semicolon
DECL|member|one
r_int
id|one
suffix:colon
l_int|1
suffix:semicolon
DECL|typedef|idetape_block_size_page_t
)brace
id|idetape_block_size_page_t
suffix:semicolon
multiline_comment|/*&n; *&t;A pipeline stage.&n; */
DECL|struct|idetape_stage_s
r_typedef
r_struct
id|idetape_stage_s
(brace
DECL|member|rq
r_struct
id|request
id|rq
suffix:semicolon
multiline_comment|/* The corresponding request */
DECL|member|bh
r_struct
id|idetape_bh
op_star
id|bh
suffix:semicolon
multiline_comment|/* The data buffers */
DECL|member|next
r_struct
id|idetape_stage_s
op_star
id|next
suffix:semicolon
multiline_comment|/* Pointer to the next stage */
DECL|typedef|idetape_stage_t
)brace
id|idetape_stage_t
suffix:semicolon
multiline_comment|/*&n; *&t;REQUEST SENSE packet command result - Data Format.&n; */
r_typedef
r_struct
(brace
DECL|member|error_code
r_int
id|error_code
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* Current of deferred errors */
DECL|member|valid
r_int
id|valid
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The information field conforms to QIC-157C */
DECL|member|reserved1
id|__u8
id|reserved1
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* Segment Number - Reserved */
DECL|member|sense_key
r_int
id|sense_key
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Sense Key */
DECL|member|reserved2_4
r_int
id|reserved2_4
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|ili
r_int
id|ili
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Incorrect Length Indicator */
DECL|member|eom
r_int
id|eom
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* End Of Medium */
DECL|member|filemark
r_int
id|filemark
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Filemark */
DECL|member|information
id|__u32
id|information
id|__attribute__
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
DECL|member|asl
id|__u8
id|asl
suffix:semicolon
multiline_comment|/* Additional sense length (n-7) */
DECL|member|command_specific
id|__u32
id|command_specific
suffix:semicolon
multiline_comment|/* Additional command specific information */
DECL|member|asc
id|__u8
id|asc
suffix:semicolon
multiline_comment|/* Additional Sense Code */
DECL|member|ascq
id|__u8
id|ascq
suffix:semicolon
multiline_comment|/* Additional Sense Code Qualifier */
DECL|member|replaceable_unit_code
id|__u8
id|replaceable_unit_code
suffix:semicolon
multiline_comment|/* Field Replaceable Unit Code */
DECL|member|sk_specific1
r_int
id|sk_specific1
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* Sense Key Specific */
DECL|member|sksv
r_int
id|sksv
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Sense Key Specific information is valid */
DECL|member|sk_specific2
id|__u8
id|sk_specific2
suffix:semicolon
multiline_comment|/* Sense Key Specific */
DECL|member|sk_specific3
id|__u8
id|sk_specific3
suffix:semicolon
multiline_comment|/* Sense Key Specific */
DECL|member|pad
id|__u8
id|pad
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Padding to 20 bytes */
DECL|typedef|idetape_request_sense_result_t
)brace
id|idetape_request_sense_result_t
suffix:semicolon
multiline_comment|/*&n; *&t;Most of our global data which we need to save even as we leave the&n; *&t;driver due to an interrupt or a timer event is stored in a variable&n; *&t;of type idetape_tape_t, defined below.&n; */
r_typedef
r_struct
(brace
DECL|member|drive
id|ide_drive_t
op_star
id|drive
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Since a typical character device operation requires more&n;&t; *&t;than one packet command, we provide here enough memory&n;&t; *&t;for the maximum of interconnected packet commands.&n;&t; *&t;The packet commands are stored in the circular array pc_stack.&n;&t; *&t;pc_stack_index points to the last used entry, and warps around&n;&t; *&t;to the start when we get to the last array entry.&n;&t; *&n;&t; *&t;pc points to the current processed packet command.&n;&t; *&n;&t; *&t;failed_pc points to the last failed packet command, or contains&n;&t; *&t;NULL if we do not need to retry any packet command. This is&n;&t; *&t;required since an additional packet command is needed before the&n;&t; *&t;retry, to get detailed information on what went wrong.&n;&t; */
multiline_comment|/* Current packet command */
DECL|member|pc
id|idetape_pc_t
op_star
id|pc
suffix:semicolon
multiline_comment|/* Last failed packet command */
DECL|member|failed_pc
id|idetape_pc_t
op_star
id|failed_pc
suffix:semicolon
multiline_comment|/* Packet command stack */
DECL|member|pc_stack
id|idetape_pc_t
id|pc_stack
(braket
id|IDETAPE_PC_STACK
)braket
suffix:semicolon
multiline_comment|/* Next free packet command storage space */
DECL|member|pc_stack_index
r_int
id|pc_stack_index
suffix:semicolon
DECL|member|rq_stack
r_struct
id|request
id|rq_stack
(braket
id|IDETAPE_PC_STACK
)braket
suffix:semicolon
multiline_comment|/* We implement a circular array */
DECL|member|rq_stack_index
r_int
id|rq_stack_index
suffix:semicolon
multiline_comment|/*&n;&t; *&t;DSC polling variables.&n;&t; *&n;&t; *&t;While polling for DSC we use postponed_rq to postpone the&n;&t; *&t;current request so that ide.c will be able to service&n;&t; *&t;pending requests on the other device. Note that at most&n;&t; *&t;we will have only one DSC (usually data transfer) request&n;&t; *&t;in the device request queue. Additional requests can be&n;&t; *&t;queued in our internal pipeline, but they will be visible&n;&t; *&t;to ide.c only one at a time.&n;&t; */
DECL|member|postponed_rq
r_struct
id|request
op_star
id|postponed_rq
suffix:semicolon
multiline_comment|/* The time in which we started polling for DSC */
DECL|member|dsc_polling_start
r_int
r_int
id|dsc_polling_start
suffix:semicolon
multiline_comment|/* Timer used to poll for dsc */
DECL|member|dsc_timer
r_struct
id|timer_list
id|dsc_timer
suffix:semicolon
multiline_comment|/* Read/Write dsc polling frequency */
DECL|member|best_dsc_rw_frequency
r_int
r_int
id|best_dsc_rw_frequency
suffix:semicolon
multiline_comment|/* The current polling frequency */
DECL|member|dsc_polling_frequency
r_int
r_int
id|dsc_polling_frequency
suffix:semicolon
multiline_comment|/* Maximum waiting time */
DECL|member|dsc_timeout
r_int
r_int
id|dsc_timeout
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Read position information&n;&t; */
DECL|member|partition
id|u8
id|partition
suffix:semicolon
multiline_comment|/* Current block */
DECL|member|first_frame_position
r_int
r_int
id|first_frame_position
suffix:semicolon
DECL|member|last_frame_position
r_int
r_int
id|last_frame_position
suffix:semicolon
DECL|member|blocks_in_buffer
r_int
r_int
id|blocks_in_buffer
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Last error information&n;&t; */
DECL|member|sense_key
DECL|member|asc
DECL|member|ascq
id|u8
id|sense_key
comma
id|asc
comma
id|ascq
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Character device operation&n;&t; */
DECL|member|minor
r_int
r_int
id|minor
suffix:semicolon
multiline_comment|/* device name */
DECL|member|name
r_char
id|name
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Current character device data transfer direction */
DECL|member|chrdev_direction
id|idetape_chrdev_direction_t
id|chrdev_direction
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Device information&n;&t; */
multiline_comment|/* Usually 512 or 1024 bytes */
DECL|member|tape_block_size
r_int
r_int
id|tape_block_size
suffix:semicolon
DECL|member|user_bs_factor
r_int
id|user_bs_factor
suffix:semicolon
multiline_comment|/* Copy of the tape&squot;s Capabilities and Mechanical Page */
DECL|member|capabilities
id|idetape_capabilities_page_t
id|capabilities
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Active data transfer request parameters.&n;&t; *&n;&t; *&t;At most, there is only one ide-tape originated data transfer&n;&t; *&t;request in the device request queue. This allows ide.c to&n;&t; *&t;easily service requests from the other device when we&n;&t; *&t;postpone our active request. In the pipelined operation&n;&t; *&t;mode, we use our internal pipeline structure to hold&n;&t; *&t;more data requests.&n;&t; *&n;&t; *&t;The data buffer size is chosen based on the tape&squot;s&n;&t; *&t;recommendation.&n;&t; */
multiline_comment|/* Pointer to the request which is waiting in the device request queue */
DECL|member|active_data_request
r_struct
id|request
op_star
id|active_data_request
suffix:semicolon
multiline_comment|/* Data buffer size (chosen based on the tape&squot;s recommendation */
DECL|member|stage_size
r_int
id|stage_size
suffix:semicolon
DECL|member|merge_stage
id|idetape_stage_t
op_star
id|merge_stage
suffix:semicolon
DECL|member|merge_stage_size
r_int
id|merge_stage_size
suffix:semicolon
DECL|member|bh
r_struct
id|idetape_bh
op_star
id|bh
suffix:semicolon
DECL|member|b_data
r_char
op_star
id|b_data
suffix:semicolon
DECL|member|b_count
r_int
id|b_count
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Pipeline parameters.&n;&t; *&n;&t; *&t;To accomplish non-pipelined mode, we simply set the following&n;&t; *&t;variables to zero (or NULL, where appropriate).&n;&t; */
multiline_comment|/* Number of currently used stages */
DECL|member|nr_stages
r_int
id|nr_stages
suffix:semicolon
multiline_comment|/* Number of pending stages */
DECL|member|nr_pending_stages
r_int
id|nr_pending_stages
suffix:semicolon
multiline_comment|/* We will not allocate more than this number of stages */
DECL|member|max_stages
DECL|member|min_pipeline
DECL|member|max_pipeline
r_int
id|max_stages
comma
id|min_pipeline
comma
id|max_pipeline
suffix:semicolon
multiline_comment|/* The first stage which will be removed from the pipeline */
DECL|member|first_stage
id|idetape_stage_t
op_star
id|first_stage
suffix:semicolon
multiline_comment|/* The currently active stage */
DECL|member|active_stage
id|idetape_stage_t
op_star
id|active_stage
suffix:semicolon
multiline_comment|/* Will be serviced after the currently active request */
DECL|member|next_stage
id|idetape_stage_t
op_star
id|next_stage
suffix:semicolon
multiline_comment|/* New requests will be added to the pipeline here */
DECL|member|last_stage
id|idetape_stage_t
op_star
id|last_stage
suffix:semicolon
multiline_comment|/* Optional free stage which we can use */
DECL|member|cache_stage
id|idetape_stage_t
op_star
id|cache_stage
suffix:semicolon
DECL|member|pages_per_stage
r_int
id|pages_per_stage
suffix:semicolon
multiline_comment|/* Wasted space in each stage */
DECL|member|excess_bh_size
r_int
id|excess_bh_size
suffix:semicolon
multiline_comment|/* Status/Action flags: long for set_bit */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* protects the ide-tape queue */
DECL|member|spinlock
id|spinlock_t
id|spinlock
suffix:semicolon
multiline_comment|/*&n;&t; * Measures average tape speed&n;&t; */
DECL|member|avg_time
r_int
r_int
id|avg_time
suffix:semicolon
DECL|member|avg_size
r_int
id|avg_size
suffix:semicolon
DECL|member|avg_speed
r_int
id|avg_speed
suffix:semicolon
multiline_comment|/* last sense information */
DECL|member|sense
id|idetape_request_sense_result_t
id|sense
suffix:semicolon
DECL|member|vendor_id
r_char
id|vendor_id
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|product_id
r_char
id|product_id
(braket
l_int|18
)braket
suffix:semicolon
DECL|member|firmware_revision
r_char
id|firmware_revision
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|firmware_revision_num
r_int
id|firmware_revision_num
suffix:semicolon
multiline_comment|/* the door is currently locked */
DECL|member|door_locked
r_int
id|door_locked
suffix:semicolon
multiline_comment|/* the tape hardware is write protected */
DECL|member|drv_write_prot
r_char
id|drv_write_prot
suffix:semicolon
multiline_comment|/* the tape is write protected (hardware or opened as read-only) */
DECL|member|write_prot
r_char
id|write_prot
suffix:semicolon
multiline_comment|/*&n;&t; * Limit the number of times a request can&n;&t; * be postponed, to avoid an infinite postpone&n;&t; * deadlock.&n;&t; */
multiline_comment|/* request postpone count limit */
DECL|member|postpone_cnt
r_int
id|postpone_cnt
suffix:semicolon
multiline_comment|/*&n;&t; * Measures number of frames:&n;&t; *&n;&t; * 1. written/read to/from the driver pipeline (pipeline_head).&n;&t; * 2. written/read to/from the tape buffers (idetape_bh).&n;&t; * 3. written/read by the tape to/from the media (tape_head).&n;&t; */
DECL|member|pipeline_head
r_int
id|pipeline_head
suffix:semicolon
DECL|member|buffer_head
r_int
id|buffer_head
suffix:semicolon
DECL|member|tape_head
r_int
id|tape_head
suffix:semicolon
DECL|member|last_tape_head
r_int
id|last_tape_head
suffix:semicolon
multiline_comment|/*&n;&t; * Speed control at the tape buffers input/output&n;&t; */
DECL|member|insert_time
r_int
r_int
id|insert_time
suffix:semicolon
DECL|member|insert_size
r_int
id|insert_size
suffix:semicolon
DECL|member|insert_speed
r_int
id|insert_speed
suffix:semicolon
DECL|member|max_insert_speed
r_int
id|max_insert_speed
suffix:semicolon
DECL|member|measure_insert_time
r_int
id|measure_insert_time
suffix:semicolon
multiline_comment|/*&n;&t; * Measure tape still time, in milliseconds&n;&t; */
DECL|member|tape_still_time_begin
r_int
r_int
id|tape_still_time_begin
suffix:semicolon
DECL|member|tape_still_time
r_int
id|tape_still_time
suffix:semicolon
multiline_comment|/*&n;&t; * Speed regulation negative feedback loop&n;&t; */
DECL|member|speed_control
r_int
id|speed_control
suffix:semicolon
DECL|member|pipeline_head_speed
r_int
id|pipeline_head_speed
suffix:semicolon
DECL|member|controlled_pipeline_head_speed
r_int
id|controlled_pipeline_head_speed
suffix:semicolon
DECL|member|uncontrolled_pipeline_head_speed
r_int
id|uncontrolled_pipeline_head_speed
suffix:semicolon
DECL|member|controlled_last_pipeline_head
r_int
id|controlled_last_pipeline_head
suffix:semicolon
DECL|member|uncontrolled_last_pipeline_head
r_int
id|uncontrolled_last_pipeline_head
suffix:semicolon
DECL|member|uncontrolled_pipeline_head_time
r_int
r_int
id|uncontrolled_pipeline_head_time
suffix:semicolon
DECL|member|controlled_pipeline_head_time
r_int
r_int
id|controlled_pipeline_head_time
suffix:semicolon
DECL|member|controlled_previous_pipeline_head
r_int
id|controlled_previous_pipeline_head
suffix:semicolon
DECL|member|uncontrolled_previous_pipeline_head
r_int
id|uncontrolled_previous_pipeline_head
suffix:semicolon
DECL|member|controlled_previous_head_time
r_int
r_int
id|controlled_previous_head_time
suffix:semicolon
DECL|member|uncontrolled_previous_head_time
r_int
r_int
id|uncontrolled_previous_head_time
suffix:semicolon
DECL|member|restart_speed_control_req
r_int
id|restart_speed_control_req
suffix:semicolon
multiline_comment|/*&n;         * Debug_level determines amount of debugging output;&n;         * can be changed using /proc/ide/hdx/settings&n;         * 0 : almost no debugging output&n;         * 1 : 0+output errors only&n;         * 2 : 1+output all sensekey/asc&n;         * 3 : 2+follow all chrdev related procedures&n;         * 4 : 3+follow all procedures&n;         * 5 : 4+include pc_stack rq_stack info&n;         * 6 : 5+USE_COUNT updates&n;         */
DECL|member|debug_level
r_int
id|debug_level
suffix:semicolon
DECL|typedef|idetape_tape_t
)brace
id|idetape_tape_t
suffix:semicolon
multiline_comment|/*&n; *&t;Tape door status&n; */
DECL|macro|DOOR_UNLOCKED
mdefine_line|#define DOOR_UNLOCKED&t;&t;&t;0
DECL|macro|DOOR_LOCKED
mdefine_line|#define DOOR_LOCKED&t;&t;&t;1
DECL|macro|DOOR_EXPLICITLY_LOCKED
mdefine_line|#define DOOR_EXPLICITLY_LOCKED&t;&t;2
multiline_comment|/*&n; *&t;Tape flag bits values.&n; */
DECL|macro|IDETAPE_IGNORE_DSC
mdefine_line|#define IDETAPE_IGNORE_DSC&t;&t;0
DECL|macro|IDETAPE_ADDRESS_VALID
mdefine_line|#define IDETAPE_ADDRESS_VALID&t;&t;1&t;/* 0 When the tape position is unknown */
DECL|macro|IDETAPE_BUSY
mdefine_line|#define IDETAPE_BUSY&t;&t;&t;2&t;/* Device already opened */
DECL|macro|IDETAPE_PIPELINE_ERROR
mdefine_line|#define IDETAPE_PIPELINE_ERROR&t;&t;3&t;/* Error detected in a pipeline stage */
DECL|macro|IDETAPE_DETECT_BS
mdefine_line|#define IDETAPE_DETECT_BS&t;&t;4&t;/* Attempt to auto-detect the current user block size */
DECL|macro|IDETAPE_FILEMARK
mdefine_line|#define IDETAPE_FILEMARK&t;&t;5&t;/* Currently on a filemark */
DECL|macro|IDETAPE_DRQ_INTERRUPT
mdefine_line|#define IDETAPE_DRQ_INTERRUPT&t;&t;6&t;/* DRQ interrupt device */
DECL|macro|IDETAPE_READ_ERROR
mdefine_line|#define IDETAPE_READ_ERROR&t;&t;7
DECL|macro|IDETAPE_PIPELINE_ACTIVE
mdefine_line|#define IDETAPE_PIPELINE_ACTIVE&t;&t;8&t;/* pipeline active */
multiline_comment|/* 0 = no tape is loaded, so we don&squot;t rewind after ejecting */
DECL|macro|IDETAPE_MEDIUM_PRESENT
mdefine_line|#define IDETAPE_MEDIUM_PRESENT&t;&t;9
multiline_comment|/*&n; *&t;Supported ATAPI tape drives packet commands&n; */
DECL|macro|IDETAPE_TEST_UNIT_READY_CMD
mdefine_line|#define IDETAPE_TEST_UNIT_READY_CMD&t;0x00
DECL|macro|IDETAPE_REWIND_CMD
mdefine_line|#define IDETAPE_REWIND_CMD&t;&t;0x01
DECL|macro|IDETAPE_REQUEST_SENSE_CMD
mdefine_line|#define IDETAPE_REQUEST_SENSE_CMD&t;0x03
DECL|macro|IDETAPE_READ_CMD
mdefine_line|#define IDETAPE_READ_CMD&t;&t;0x08
DECL|macro|IDETAPE_WRITE_CMD
mdefine_line|#define IDETAPE_WRITE_CMD&t;&t;0x0a
DECL|macro|IDETAPE_WRITE_FILEMARK_CMD
mdefine_line|#define IDETAPE_WRITE_FILEMARK_CMD&t;0x10
DECL|macro|IDETAPE_SPACE_CMD
mdefine_line|#define IDETAPE_SPACE_CMD&t;&t;0x11
DECL|macro|IDETAPE_INQUIRY_CMD
mdefine_line|#define IDETAPE_INQUIRY_CMD&t;&t;0x12
DECL|macro|IDETAPE_ERASE_CMD
mdefine_line|#define IDETAPE_ERASE_CMD&t;&t;0x19
DECL|macro|IDETAPE_MODE_SENSE_CMD
mdefine_line|#define IDETAPE_MODE_SENSE_CMD&t;&t;0x1a
DECL|macro|IDETAPE_MODE_SELECT_CMD
mdefine_line|#define IDETAPE_MODE_SELECT_CMD&t;&t;0x15
DECL|macro|IDETAPE_LOAD_UNLOAD_CMD
mdefine_line|#define IDETAPE_LOAD_UNLOAD_CMD&t;&t;0x1b
DECL|macro|IDETAPE_PREVENT_CMD
mdefine_line|#define IDETAPE_PREVENT_CMD&t;&t;0x1e
DECL|macro|IDETAPE_LOCATE_CMD
mdefine_line|#define IDETAPE_LOCATE_CMD&t;&t;0x2b
DECL|macro|IDETAPE_READ_POSITION_CMD
mdefine_line|#define IDETAPE_READ_POSITION_CMD&t;0x34
DECL|macro|IDETAPE_READ_BUFFER_CMD
mdefine_line|#define IDETAPE_READ_BUFFER_CMD&t;&t;0x3c
DECL|macro|IDETAPE_SET_SPEED_CMD
mdefine_line|#define IDETAPE_SET_SPEED_CMD&t;&t;0xbb
multiline_comment|/*&n; *&t;Some defines for the READ BUFFER command&n; */
DECL|macro|IDETAPE_RETRIEVE_FAULTY_BLOCK
mdefine_line|#define IDETAPE_RETRIEVE_FAULTY_BLOCK&t;6
multiline_comment|/*&n; *&t;Some defines for the SPACE command&n; */
DECL|macro|IDETAPE_SPACE_OVER_FILEMARK
mdefine_line|#define IDETAPE_SPACE_OVER_FILEMARK&t;1
DECL|macro|IDETAPE_SPACE_TO_EOD
mdefine_line|#define IDETAPE_SPACE_TO_EOD&t;&t;3
multiline_comment|/*&n; *&t;Some defines for the LOAD UNLOAD command&n; */
DECL|macro|IDETAPE_LU_LOAD_MASK
mdefine_line|#define IDETAPE_LU_LOAD_MASK&t;&t;1
DECL|macro|IDETAPE_LU_RETENSION_MASK
mdefine_line|#define IDETAPE_LU_RETENSION_MASK&t;2
DECL|macro|IDETAPE_LU_EOT_MASK
mdefine_line|#define IDETAPE_LU_EOT_MASK&t;&t;4
multiline_comment|/*&n; *&t;Special requests for our block device strategy routine.&n; *&n; *&t;In order to service a character device command, we add special&n; *&t;requests to the tail of our block device request queue and wait&n; *&t;for their completion.&n; */
r_enum
(brace
DECL|enumerator|REQ_IDETAPE_PC1
id|REQ_IDETAPE_PC1
op_assign
(paren
l_int|1
op_lshift
l_int|0
)paren
comma
multiline_comment|/* packet command (first stage) */
DECL|enumerator|REQ_IDETAPE_PC2
id|REQ_IDETAPE_PC2
op_assign
(paren
l_int|1
op_lshift
l_int|1
)paren
comma
multiline_comment|/* packet command (second stage) */
DECL|enumerator|REQ_IDETAPE_READ
id|REQ_IDETAPE_READ
op_assign
(paren
l_int|1
op_lshift
l_int|2
)paren
comma
DECL|enumerator|REQ_IDETAPE_WRITE
id|REQ_IDETAPE_WRITE
op_assign
(paren
l_int|1
op_lshift
l_int|3
)paren
comma
DECL|enumerator|REQ_IDETAPE_READ_BUFFER
id|REQ_IDETAPE_READ_BUFFER
op_assign
(paren
l_int|1
op_lshift
l_int|4
)paren
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Error codes which are returned in rq-&gt;errors to the higher part&n; *&t;of the driver.&n; */
DECL|macro|IDETAPE_ERROR_GENERAL
mdefine_line|#define&t;IDETAPE_ERROR_GENERAL&t;&t;101
DECL|macro|IDETAPE_ERROR_FILEMARK
mdefine_line|#define&t;IDETAPE_ERROR_FILEMARK&t;&t;102
DECL|macro|IDETAPE_ERROR_EOD
mdefine_line|#define&t;IDETAPE_ERROR_EOD&t;&t;103
multiline_comment|/*&n; *&t;idetape_chrdev_t provides the link between out character device&n; *&t;interface and our block device interface and the corresponding&n; *&t;ide_drive_t structure.&n; */
r_typedef
r_struct
(brace
DECL|member|drive
id|ide_drive_t
op_star
id|drive
suffix:semicolon
DECL|typedef|idetape_chrdev_t
)brace
id|idetape_chrdev_t
suffix:semicolon
multiline_comment|/*&n; *&t;The following is used to format the general configuration word of&n; *&t;the ATAPI IDENTIFY DEVICE command.&n; */
DECL|struct|idetape_id_gcw
r_struct
id|idetape_id_gcw
(brace
DECL|member|packet_size
r_int
id|packet_size
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Packet Size */
DECL|member|reserved234
r_int
id|reserved234
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|drq_type
r_int
id|drq_type
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Command packet DRQ type */
DECL|member|removable
r_int
id|removable
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Removable media */
DECL|member|device_type
r_int
id|device_type
suffix:colon
l_int|5
suffix:semicolon
multiline_comment|/* Device type */
DECL|member|reserved13
r_int
id|reserved13
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|protocol
r_int
id|protocol
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Protocol type */
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;INQUIRY packet command - Data Format (From Table 6-8 of QIC-157C)&n; */
r_typedef
r_struct
(brace
DECL|member|device_type
r_int
id|device_type
suffix:colon
l_int|5
suffix:semicolon
multiline_comment|/* Peripheral Device Type */
DECL|member|reserved0_765
r_int
id|reserved0_765
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Peripheral Qualifier - Reserved */
DECL|member|reserved1_6t0
r_int
id|reserved1_6t0
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|rmb
r_int
id|rmb
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Removable Medium Bit */
DECL|member|ansi_version
r_int
id|ansi_version
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* ANSI Version */
DECL|member|ecma_version
r_int
id|ecma_version
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* ECMA Version */
DECL|member|iso_version
r_int
id|iso_version
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* ISO Version */
DECL|member|response_format
r_int
id|response_format
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Response Data Format */
DECL|member|reserved3_45
r_int
id|reserved3_45
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved3_6
r_int
id|reserved3_6
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* TrmIOP - Reserved */
DECL|member|reserved3_7
r_int
id|reserved3_7
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* AENC - Reserved */
DECL|member|additional_length
id|__u8
id|additional_length
suffix:semicolon
multiline_comment|/* Additional Length (total_length-4) */
DECL|member|rsv5
DECL|member|rsv6
DECL|member|rsv7
id|__u8
id|rsv5
comma
id|rsv6
comma
id|rsv7
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|vendor_id
id|__u8
id|vendor_id
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Vendor Identification */
DECL|member|product_id
id|__u8
id|product_id
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Product Identification */
DECL|member|revision_level
id|__u8
id|revision_level
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Revision Level */
DECL|member|vendor_specific
id|__u8
id|vendor_specific
(braket
l_int|20
)braket
suffix:semicolon
multiline_comment|/* Vendor Specific - Optional */
DECL|member|reserved56t95
id|__u8
id|reserved56t95
(braket
l_int|40
)braket
suffix:semicolon
multiline_comment|/* Reserved - Optional */
multiline_comment|/* Additional information may be returned */
DECL|typedef|idetape_inquiry_result_t
)brace
id|idetape_inquiry_result_t
suffix:semicolon
multiline_comment|/*&n; *&t;READ POSITION packet command - Data Format (From Table 6-57)&n; */
r_typedef
r_struct
(brace
DECL|member|reserved0_10
r_int
id|reserved0_10
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|bpu
r_int
id|bpu
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Block Position Unknown */
DECL|member|reserved0_543
r_int
id|reserved0_543
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|eop
r_int
id|eop
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* End Of Partition */
DECL|member|bop
r_int
id|bop
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Beginning Of Partition */
DECL|member|partition
id|u8
id|partition
suffix:semicolon
multiline_comment|/* Partition Number */
DECL|member|reserved2
DECL|member|reserved3
id|u8
id|reserved2
comma
id|reserved3
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|first_block
id|u32
id|first_block
suffix:semicolon
multiline_comment|/* First Block Location */
DECL|member|last_block
id|u32
id|last_block
suffix:semicolon
multiline_comment|/* Last Block Location (Optional) */
DECL|member|reserved12
id|u8
id|reserved12
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|blocks_in_buffer
id|u8
id|blocks_in_buffer
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Blocks In Buffer - (Optional) */
DECL|member|bytes_in_buffer
id|u32
id|bytes_in_buffer
suffix:semicolon
multiline_comment|/* Bytes In Buffer (Optional) */
DECL|typedef|idetape_read_position_result_t
)brace
id|idetape_read_position_result_t
suffix:semicolon
multiline_comment|/*&n; *&t;Follows structures which are related to the SELECT SENSE / MODE SENSE&n; *&t;packet commands. Those packet commands are still not supported&n; *&t;by ide-tape.&n; */
DECL|macro|IDETAPE_BLOCK_DESCRIPTOR
mdefine_line|#define IDETAPE_BLOCK_DESCRIPTOR&t;0
DECL|macro|IDETAPE_CAPABILITIES_PAGE
mdefine_line|#define&t;IDETAPE_CAPABILITIES_PAGE&t;0x2a
DECL|macro|IDETAPE_PARAMTR_PAGE
mdefine_line|#define IDETAPE_PARAMTR_PAGE&t;&t;0x2b   /* Onstream DI-x0 only */
DECL|macro|IDETAPE_BLOCK_SIZE_PAGE
mdefine_line|#define IDETAPE_BLOCK_SIZE_PAGE&t;&t;0x30
DECL|macro|IDETAPE_BUFFER_FILLING_PAGE
mdefine_line|#define IDETAPE_BUFFER_FILLING_PAGE&t;0x33
multiline_comment|/*&n; *&t;Mode Parameter Header for the MODE SENSE packet command&n; */
r_typedef
r_struct
(brace
DECL|member|mode_data_length
id|__u8
id|mode_data_length
suffix:semicolon
multiline_comment|/* Length of the following data transfer */
DECL|member|medium_type
id|__u8
id|medium_type
suffix:semicolon
multiline_comment|/* Medium Type */
DECL|member|dsp
id|__u8
id|dsp
suffix:semicolon
multiline_comment|/* Device Specific Parameter */
DECL|member|bdl
id|__u8
id|bdl
suffix:semicolon
multiline_comment|/* Block Descriptor Length */
macro_line|#if 0
multiline_comment|/* data transfer page */
id|__u8
id|page_code
suffix:colon
l_int|6
suffix:semicolon
id|__u8
id|reserved0_6
suffix:colon
l_int|1
suffix:semicolon
id|__u8
id|ps
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* parameters saveable */
id|__u8
id|page_length
suffix:semicolon
multiline_comment|/* page Length == 0x02 */
id|__u8
id|reserved2
suffix:semicolon
id|__u8
id|read32k
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 32k blk size (data only) */
id|__u8
id|read32k5
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 32.5k blk size (data&amp;AUX) */
id|__u8
id|reserved3_23
suffix:colon
l_int|2
suffix:semicolon
id|__u8
id|write32k
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 32k blk size (data only) */
id|__u8
id|write32k5
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 32.5k blk size (data&amp;AUX) */
id|__u8
id|reserved3_6
suffix:colon
l_int|1
suffix:semicolon
id|__u8
id|streaming
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* streaming mode enable */
macro_line|#endif
DECL|typedef|idetape_mode_parameter_header_t
)brace
id|idetape_mode_parameter_header_t
suffix:semicolon
multiline_comment|/*&n; *&t;Mode Parameter Block Descriptor the MODE SENSE packet command&n; *&n; *&t;Support for block descriptors is optional.&n; */
r_typedef
r_struct
(brace
DECL|member|density_code
id|__u8
id|density_code
suffix:semicolon
multiline_comment|/* Medium density code */
DECL|member|blocks
id|__u8
id|blocks
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Number of blocks */
DECL|member|reserved4
id|__u8
id|reserved4
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|length
id|__u8
id|length
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Block Length */
DECL|typedef|idetape_parameter_block_descriptor_t
)brace
id|idetape_parameter_block_descriptor_t
suffix:semicolon
multiline_comment|/*&n; *&t;The Data Compression Page, as returned by the MODE SENSE packet command.&n; */
r_typedef
r_struct
(brace
DECL|member|page_code
r_int
id|page_code
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Page Code - Should be 0xf */
DECL|member|reserved0
r_int
id|reserved0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|ps
r_int
id|ps
suffix:colon
l_int|1
suffix:semicolon
DECL|member|page_length
id|__u8
id|page_length
suffix:semicolon
multiline_comment|/* Page Length - Should be 14 */
DECL|member|reserved2
r_int
id|reserved2
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|dcc
r_int
id|dcc
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data Compression Capable */
DECL|member|dce
r_int
id|dce
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data Compression Enable */
DECL|member|reserved3
r_int
id|reserved3
suffix:colon
l_int|5
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|red
r_int
id|red
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Report Exception on Decompression */
DECL|member|dde
r_int
id|dde
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data Decompression Enable */
DECL|member|ca
id|__u32
id|ca
suffix:semicolon
multiline_comment|/* Compression Algorithm */
DECL|member|da
id|__u32
id|da
suffix:semicolon
multiline_comment|/* Decompression Algorithm */
DECL|member|reserved
id|__u8
id|reserved
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Reserved */
DECL|typedef|idetape_data_compression_page_t
)brace
id|idetape_data_compression_page_t
suffix:semicolon
multiline_comment|/*&n; *&t;The Medium Partition Page, as returned by the MODE SENSE packet command.&n; */
r_typedef
r_struct
(brace
DECL|member|page_code
r_int
id|page_code
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Page Code - Should be 0x11 */
DECL|member|reserved1_6
r_int
id|reserved1_6
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|ps
r_int
id|ps
suffix:colon
l_int|1
suffix:semicolon
DECL|member|page_length
id|__u8
id|page_length
suffix:semicolon
multiline_comment|/* Page Length - Should be 6 */
DECL|member|map
id|__u8
id|map
suffix:semicolon
multiline_comment|/* Maximum Additional Partitions - Should be 0 */
DECL|member|apd
id|__u8
id|apd
suffix:semicolon
multiline_comment|/* Additional Partitions Defined - Should be 0 */
DECL|member|reserved4_012
r_int
id|reserved4_012
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|psum
r_int
id|psum
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Should be 0 */
DECL|member|idp
r_int
id|idp
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be 0 */
DECL|member|sdp
r_int
id|sdp
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be 0 */
DECL|member|fdp
r_int
id|fdp
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Fixed Data Partitions */
DECL|member|mfr
id|__u8
id|mfr
suffix:semicolon
multiline_comment|/* Medium Format Recognition */
DECL|member|reserved
id|__u8
id|reserved
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Reserved */
DECL|typedef|idetape_medium_partition_page_t
)brace
id|idetape_medium_partition_page_t
suffix:semicolon
multiline_comment|/*&n; *&t;Run time configurable parameters.&n; */
r_typedef
r_struct
(brace
DECL|member|dsc_rw_frequency
r_int
id|dsc_rw_frequency
suffix:semicolon
DECL|member|dsc_media_access_frequency
r_int
id|dsc_media_access_frequency
suffix:semicolon
DECL|member|nr_stages
r_int
id|nr_stages
suffix:semicolon
DECL|typedef|idetape_config_t
)brace
id|idetape_config_t
suffix:semicolon
multiline_comment|/*&n; *&t;The variables below are used for the character device interface.&n; *&t;Additional state variables are defined in our ide_drive_t structure.&n; */
DECL|variable|idetape_chrdevs
r_static
id|idetape_chrdev_t
id|idetape_chrdevs
(braket
id|MAX_HWIFS
op_star
id|MAX_DRIVES
)braket
suffix:semicolon
multiline_comment|/*&n; *      Function declarations&n; *&n; */
r_static
r_int
id|idetape_chrdev_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|idetape_write_release
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|minor
)paren
suffix:semicolon
multiline_comment|/*&n; * Too bad. The drive wants to send us data which we are not ready to accept.&n; * Just throw it away.&n; */
DECL|function|idetape_discard_data
r_static
r_void
id|idetape_discard_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|bcount
)paren
(brace
r_while
c_loop
(paren
id|bcount
op_decrement
)paren
(paren
r_void
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_DATA_REG
)paren
suffix:semicolon
)brace
DECL|function|idetape_input_buffers
r_static
r_void
id|idetape_input_buffers
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pc_t
op_star
id|pc
comma
r_int
r_int
id|bcount
)paren
(brace
r_struct
id|idetape_bh
op_star
id|bh
op_assign
id|pc-&gt;bh
suffix:semicolon
r_int
id|count
suffix:semicolon
r_while
c_loop
(paren
id|bcount
)paren
(brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bh == NULL in &quot;
l_string|&quot;idetape_input_buffers&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_discard_data
c_func
(paren
id|drive
comma
id|bcount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|count
op_assign
id|min
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|bh-&gt;b_size
op_minus
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
)paren
comma
id|bcount
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|atapi_input_bytes
c_func
(paren
id|drive
comma
id|bh-&gt;b_data
op_plus
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
comma
id|count
)paren
suffix:semicolon
id|bcount
op_sub_assign
id|count
suffix:semicolon
id|atomic_add
c_func
(paren
id|count
comma
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
op_eq
id|bh-&gt;b_size
)paren
(brace
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|pc-&gt;bh
op_assign
id|bh
suffix:semicolon
)brace
DECL|function|idetape_output_buffers
r_static
r_void
id|idetape_output_buffers
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pc_t
op_star
id|pc
comma
r_int
r_int
id|bcount
)paren
(brace
r_struct
id|idetape_bh
op_star
id|bh
op_assign
id|pc-&gt;bh
suffix:semicolon
r_int
id|count
suffix:semicolon
r_while
c_loop
(paren
id|bcount
)paren
(brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bh == NULL in &quot;
l_string|&quot;idetape_output_buffers&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|count
op_assign
id|min
c_func
(paren
(paren
r_int
r_int
)paren
id|pc-&gt;b_count
comma
(paren
r_int
r_int
)paren
id|bcount
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|atapi_output_bytes
c_func
(paren
id|drive
comma
id|pc-&gt;b_data
comma
id|count
)paren
suffix:semicolon
id|bcount
op_sub_assign
id|count
suffix:semicolon
id|pc-&gt;b_data
op_add_assign
id|count
suffix:semicolon
id|pc-&gt;b_count
op_sub_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pc-&gt;b_count
)paren
(brace
id|pc-&gt;bh
op_assign
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|pc-&gt;b_data
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|pc-&gt;b_count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|idetape_update_buffers
r_static
r_void
id|idetape_update_buffers
(paren
id|idetape_pc_t
op_star
id|pc
)paren
(brace
r_struct
id|idetape_bh
op_star
id|bh
op_assign
id|pc-&gt;bh
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_int
id|bcount
op_assign
id|pc-&gt;actually_transferred
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|PC_WRITING
comma
op_amp
id|pc-&gt;flags
)paren
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|bcount
)paren
(brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bh == NULL in &quot;
l_string|&quot;idetape_update_buffers&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|count
op_assign
id|min
c_func
(paren
(paren
r_int
r_int
)paren
id|bh-&gt;b_size
comma
(paren
r_int
r_int
)paren
id|bcount
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
op_eq
id|bh-&gt;b_size
)paren
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bcount
op_sub_assign
id|count
suffix:semicolon
)brace
id|pc-&gt;bh
op_assign
id|bh
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_next_pc_storage returns a pointer to a place in which we can&n; *&t;safely store a packet command, even though we intend to leave the&n; *&t;driver. A storage space for a maximum of IDETAPE_PC_STACK packet&n; *&t;commands is allocated at initialization time.&n; */
DECL|function|idetape_next_pc_storage
r_static
id|idetape_pc_t
op_star
id|idetape_next_pc_storage
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: pc_stack_index=%d&bslash;n&quot;
comma
id|tape-&gt;pc_stack_index
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;pc_stack_index
op_eq
id|IDETAPE_PC_STACK
)paren
id|tape-&gt;pc_stack_index
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_amp
id|tape-&gt;pc_stack
(braket
id|tape-&gt;pc_stack_index
op_increment
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_next_rq_storage is used along with idetape_next_pc_storage.&n; *&t;Since we queue packet commands in the request queue, we need to&n; *&t;allocate a request, along with the allocation of a packet command.&n; */
multiline_comment|/**************************************************************&n; *                                                            *&n; *  This should get fixed to use kmalloc(.., GFP_ATOMIC)      *&n; *  followed later on by kfree().   -ml                       *&n; *                                                            *&n; **************************************************************/
DECL|function|idetape_next_rq_storage
r_static
r_struct
id|request
op_star
id|idetape_next_rq_storage
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: rq_stack_index=%d&bslash;n&quot;
comma
id|tape-&gt;rq_stack_index
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;rq_stack_index
op_eq
id|IDETAPE_PC_STACK
)paren
id|tape-&gt;rq_stack_index
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_amp
id|tape-&gt;rq_stack
(braket
id|tape-&gt;rq_stack_index
op_increment
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_init_pc initializes a packet command.&n; */
DECL|function|idetape_init_pc
r_static
r_void
id|idetape_init_pc
(paren
id|idetape_pc_t
op_star
id|pc
)paren
(brace
id|memset
c_func
(paren
id|pc-&gt;c
comma
l_int|0
comma
l_int|12
)paren
suffix:semicolon
id|pc-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
id|pc-&gt;pc_buffer
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
id|IDETAPE_PC_BUFFER_SIZE
suffix:semicolon
id|pc-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;b_data
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_analyze_error is called on each failed packet command retry&n; *&t;to analyze the request sense. We currently do not utilize this&n; *&t;information.&n; */
DECL|function|idetape_analyze_error
r_static
r_void
id|idetape_analyze_error
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_request_sense_result_t
op_star
id|result
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_pc_t
op_star
id|pc
op_assign
id|tape-&gt;failed_pc
suffix:semicolon
id|tape-&gt;sense
op_assign
op_star
id|result
suffix:semicolon
id|tape-&gt;sense_key
op_assign
id|result-&gt;sense_key
suffix:semicolon
id|tape-&gt;asc
op_assign
id|result-&gt;asc
suffix:semicolon
id|tape-&gt;ascq
op_assign
id|result-&gt;ascq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
multiline_comment|/*&n;&t; *&t;Without debugging, we only log an error if we decided to&n;&t; *&t;give up retrying.&n;&t; */
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: pc = %x, sense key = %x, &quot;
l_string|&quot;asc = %x, ascq = %x&bslash;n&quot;
comma
id|pc-&gt;c
(braket
l_int|0
)braket
comma
id|result-&gt;sense_key
comma
id|result-&gt;asc
comma
id|result-&gt;ascq
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
multiline_comment|/*&n;&t; *&t;Correct pc-&gt;actually_transferred by asking the tape.&n;&t; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|PC_DMA_ERROR
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
id|pc-&gt;actually_transferred
op_assign
id|pc-&gt;request_transfer
op_minus
id|tape-&gt;tape_block_size
op_star
id|ntohl
c_func
(paren
id|get_unaligned
c_func
(paren
op_amp
id|result-&gt;information
)paren
)paren
suffix:semicolon
id|idetape_update_buffers
c_func
(paren
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If error was the result of a zero-length read or write command,&n;&t; * with sense key=5, asc=0x22, ascq=0, let it slide.  Some drives&n;&t; * (i.e. Seagate STT3401A Travan) don&squot;t support 0-length read/writes.&n;&t; */
r_if
c_cond
(paren
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_READ_CMD
op_logical_or
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_WRITE_CMD
)paren
op_logical_and
id|pc-&gt;c
(braket
l_int|4
)braket
op_eq
l_int|0
op_logical_and
id|pc-&gt;c
(braket
l_int|3
)braket
op_eq
l_int|0
op_logical_and
id|pc-&gt;c
(braket
l_int|2
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* length==0 */
r_if
c_cond
(paren
id|result-&gt;sense_key
op_eq
l_int|5
)paren
(brace
multiline_comment|/* don&squot;t report an error, everything&squot;s ok */
id|pc-&gt;error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t retry read/write */
id|set_bit
c_func
(paren
id|PC_ABORT
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_READ_CMD
op_logical_and
id|result-&gt;filemark
)paren
(brace
id|pc-&gt;error
op_assign
id|IDETAPE_ERROR_FILEMARK
suffix:semicolon
id|set_bit
c_func
(paren
id|PC_ABORT
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_WRITE_CMD
)paren
(brace
r_if
c_cond
(paren
id|result-&gt;eom
op_logical_or
(paren
id|result-&gt;sense_key
op_eq
l_int|0xd
op_logical_and
id|result-&gt;asc
op_eq
l_int|0x0
op_logical_and
id|result-&gt;ascq
op_eq
l_int|0x2
)paren
)paren
(brace
id|pc-&gt;error
op_assign
id|IDETAPE_ERROR_EOD
suffix:semicolon
id|set_bit
c_func
(paren
id|PC_ABORT
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_READ_CMD
op_logical_or
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_WRITE_CMD
)paren
(brace
r_if
c_cond
(paren
id|result-&gt;sense_key
op_eq
l_int|8
)paren
(brace
id|pc-&gt;error
op_assign
id|IDETAPE_ERROR_EOD
suffix:semicolon
id|set_bit
c_func
(paren
id|PC_ABORT
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|PC_ABORT
comma
op_amp
id|pc-&gt;flags
)paren
op_logical_and
id|pc-&gt;actually_transferred
)paren
id|pc-&gt;retries
op_assign
id|IDETAPE_MAX_PC_RETRIES
op_plus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * idetape_active_next_stage will declare the next stage as &quot;active&quot;.&n; */
DECL|function|idetape_active_next_stage
r_static
r_void
id|idetape_active_next_stage
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_stage_t
op_star
id|stage
op_assign
id|tape-&gt;next_stage
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
op_amp
id|stage-&gt;rq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_active_next_stage&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|stage
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bug: Trying to activate a non existing stage&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */&t;
id|rq-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|rq-&gt;special
op_assign
(paren
r_void
op_star
)paren
id|stage-&gt;bh
suffix:semicolon
id|tape-&gt;active_data_request
op_assign
id|rq
suffix:semicolon
id|tape-&gt;active_stage
op_assign
id|stage
suffix:semicolon
id|tape-&gt;next_stage
op_assign
id|stage-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_increase_max_pipeline_stages is a part of the feedback&n; *&t;loop which tries to find the optimum number of stages. In the&n; *&t;feedback loop, we are starting from a minimum maximum number of&n; *&t;stages, and if we sense that the pipeline is empty, we try to&n; *&t;increase it, until we reach the user compile time memory limit.&n; */
DECL|function|idetape_increase_max_pipeline_stages
r_static
r_void
id|idetape_increase_max_pipeline_stages
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|increase
op_assign
(paren
id|tape-&gt;max_pipeline
op_minus
id|tape-&gt;min_pipeline
)paren
op_div
l_int|10
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_increase_max_pipeline_stages&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|tape-&gt;max_stages
op_add_assign
id|max
c_func
(paren
id|increase
comma
l_int|1
)paren
suffix:semicolon
id|tape-&gt;max_stages
op_assign
id|max
c_func
(paren
id|tape-&gt;max_stages
comma
id|tape-&gt;min_pipeline
)paren
suffix:semicolon
id|tape-&gt;max_stages
op_assign
id|min
c_func
(paren
id|tape-&gt;max_stages
comma
id|tape-&gt;max_pipeline
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_kfree_stage calls kfree to completely free a stage, along with&n; *&t;its related buffers.&n; */
DECL|function|__idetape_kfree_stage
r_static
r_void
id|__idetape_kfree_stage
(paren
id|idetape_stage_t
op_star
id|stage
)paren
(brace
r_struct
id|idetape_bh
op_star
id|prev_bh
comma
op_star
id|bh
op_assign
id|stage-&gt;bh
suffix:semicolon
r_int
id|size
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_data
op_ne
l_int|NULL
)paren
(brace
id|size
op_assign
(paren
r_int
)paren
id|bh-&gt;b_size
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|bh-&gt;b_data
)paren
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|bh-&gt;b_data
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
id|prev_bh
op_assign
id|bh
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|kfree
c_func
(paren
id|prev_bh
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|stage
)paren
suffix:semicolon
)brace
DECL|function|idetape_kfree_stage
r_static
r_void
id|idetape_kfree_stage
(paren
id|idetape_tape_t
op_star
id|tape
comma
id|idetape_stage_t
op_star
id|stage
)paren
(brace
id|__idetape_kfree_stage
c_func
(paren
id|stage
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_remove_stage_head removes tape-&gt;first_stage from the pipeline.&n; *&t;The caller should avoid race conditions.&n; */
DECL|function|idetape_remove_stage_head
r_static
r_void
id|idetape_remove_stage_head
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_stage_t
op_star
id|stage
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_remove_stage_head&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bug: tape-&gt;first_stage is NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;active_stage
op_eq
id|tape-&gt;first_stage
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bug: Trying to free our active pipeline stage&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|stage
op_assign
id|tape-&gt;first_stage
suffix:semicolon
id|tape-&gt;first_stage
op_assign
id|stage-&gt;next
suffix:semicolon
id|idetape_kfree_stage
c_func
(paren
id|tape
comma
id|stage
)paren
suffix:semicolon
id|tape-&gt;nr_stages
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
(brace
id|tape-&gt;last_stage
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;next_stage
op_ne
l_int|NULL
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bug: tape-&gt;next_stage != NULL&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;nr_stages
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bug: nr_stages should be 0 now&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
)brace
)brace
multiline_comment|/*&n; * This will free all the pipeline stages starting from new_last_stage-&gt;next&n; * to the end of the list, and point tape-&gt;last_stage to new_last_stage.&n; */
DECL|function|idetape_abort_pipeline
r_static
r_void
id|idetape_abort_pipeline
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_stage_t
op_star
id|new_last_stage
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_stage_t
op_star
id|stage
op_assign
id|new_last_stage-&gt;next
suffix:semicolon
id|idetape_stage_t
op_star
id|nstage
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: %s: idetape_abort_pipeline called&bslash;n&quot;
comma
id|tape-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|stage
)paren
(brace
id|nstage
op_assign
id|stage-&gt;next
suffix:semicolon
id|idetape_kfree_stage
c_func
(paren
id|tape
comma
id|stage
)paren
suffix:semicolon
op_decrement
id|tape-&gt;nr_stages
suffix:semicolon
op_decrement
id|tape-&gt;nr_pending_stages
suffix:semicolon
id|stage
op_assign
id|nstage
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_last_stage
)paren
id|new_last_stage-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;last_stage
op_assign
id|new_last_stage
suffix:semicolon
id|tape-&gt;next_stage
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_end_request is used to finish servicing a request, and to&n; *&t;insert a pending pipeline request into the main device queue.&n; */
DECL|function|idetape_end_request
r_static
r_int
id|idetape_end_request
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|uptodate
comma
r_int
id|nr_sects
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|remove_stage
op_assign
l_int|0
suffix:semicolon
id|idetape_stage_t
op_star
id|active_stage
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_end_request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_switch
c_cond
(paren
id|uptodate
)paren
(brace
r_case
l_int|0
suffix:colon
id|error
op_assign
id|IDETAPE_ERROR_GENERAL
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
id|uptodate
suffix:semicolon
)brace
id|rq-&gt;errors
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* The request was a pipelined data transfer request */
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
id|rq
)paren
(brace
id|active_stage
op_assign
id|tape-&gt;active_stage
suffix:semicolon
id|tape-&gt;active_stage
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;active_data_request
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;nr_pending_stages
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_amp
id|REQ_IDETAPE_WRITE
)paren
(brace
id|remove_stage
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|set_bit
c_func
(paren
id|IDETAPE_PIPELINE_ERROR
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|IDETAPE_ERROR_EOD
)paren
id|idetape_abort_pipeline
c_func
(paren
id|drive
comma
id|active_stage
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_amp
id|REQ_IDETAPE_READ
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
id|IDETAPE_ERROR_EOD
)paren
(brace
id|set_bit
c_func
(paren
id|IDETAPE_PIPELINE_ERROR
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|idetape_abort_pipeline
c_func
(paren
id|drive
comma
id|active_stage
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tape-&gt;next_stage
op_ne
l_int|NULL
)paren
(brace
id|idetape_active_next_stage
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Insert the next request into the request queue.&n;&t;&t;&t; */
(paren
r_void
)paren
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
id|tape-&gt;active_data_request
comma
id|ide_end
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|idetape_increase_max_pipeline_stages
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|//&t;blkdev_dequeue_request(rq);
singleline_comment|//&t;drive-&gt;rq = NULL;
singleline_comment|//&t;end_that_request_last(rq);
r_if
c_cond
(paren
id|remove_stage
)paren
id|idetape_remove_stage_head
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
l_int|NULL
)paren
id|clear_bit
c_func
(paren
id|IDETAPE_PIPELINE_ACTIVE
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|idetape_request_sense_callback
r_static
id|ide_startstop_t
id|idetape_request_sense_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_request_sense_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
(brace
id|idetape_analyze_error
c_func
(paren
id|drive
comma
(paren
id|idetape_request_sense_result_t
op_star
)paren
id|tape-&gt;pc-&gt;buffer
)paren
suffix:semicolon
id|idetape_end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: Error in REQUEST SENSE itself - Aborting request!&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|idetape_create_request_sense_cmd
r_static
r_void
id|idetape_create_request_sense_cmd
(paren
id|idetape_pc_t
op_star
id|pc
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_REQUEST_SENSE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
l_int|20
suffix:semicolon
id|pc-&gt;request_transfer
op_assign
l_int|20
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_request_sense_callback
suffix:semicolon
)brace
DECL|function|idetape_init_rq
r_static
r_void
id|idetape_init_rq
c_func
(paren
r_struct
id|request
op_star
id|rq
comma
id|u8
id|cmd
)paren
(brace
id|memset
c_func
(paren
id|rq
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|rq
)paren
)paren
suffix:semicolon
id|rq-&gt;flags
op_assign
id|REQ_SPECIAL
suffix:semicolon
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_assign
id|cmd
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_queue_pc_head generates a new packet command request in front&n; *&t;of the request queue, before the current request, so that it will be&n; *&t;processed immediately, on the next pass through the driver.&n; *&n; *&t;idetape_queue_pc_head is called from the request handling part of&n; *&t;the driver (the &quot;bottom&quot; part). Safe storage for the request should&n; *&t;be allocated with idetape_next_pc_storage and idetape_next_rq_storage&n; *&t;before calling idetape_queue_pc_head.&n; *&n; *&t;Memory for those requests is pre-allocated at initialization time, and&n; *&t;is limited to IDETAPE_PC_STACK requests. We assume that we have enough&n; *&t;space for the maximum possible number of inter-dependent packet commands.&n; *&n; *&t;The higher level of the driver - The ioctl handler and the character&n; *&t;device handling functions should queue request to the lower level part&n; *&t;and wait for their completion using idetape_queue_pc_tail or&n; *&t;idetape_queue_rw_tail.&n; */
DECL|function|idetape_queue_pc_head
r_static
r_void
id|idetape_queue_pc_head
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pc_t
op_star
id|pc
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|idetape_init_rq
c_func
(paren
id|rq
comma
id|REQ_IDETAPE_PC1
)paren
suffix:semicolon
id|rq-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
id|rq
comma
id|ide_preempt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_retry_pc is called when an error was detected during the&n; *&t;last packet command. We queue a request sense packet command in&n; *&t;the head of the request list.&n; */
DECL|function|idetape_retry_pc
r_static
id|ide_startstop_t
id|idetape_retry_pc
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_pc_t
op_star
id|pc
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|atapi_error_t
id|error
suffix:semicolon
id|error.all
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
suffix:semicolon
id|pc
op_assign
id|idetape_next_pc_storage
c_func
(paren
id|drive
)paren
suffix:semicolon
id|rq
op_assign
id|idetape_next_rq_storage
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_create_request_sense_cmd
c_func
(paren
id|pc
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|IDETAPE_IGNORE_DSC
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|idetape_queue_pc_head
c_func
(paren
id|drive
comma
id|pc
comma
id|rq
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_postpone_request postpones the current request so that&n; *&t;ide.c will be able to service requests from another device on&n; *&t;the same hwgroup while we are polling for DSC.&n; */
DECL|function|idetape_postpone_request
r_static
r_void
id|idetape_postpone_request
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: idetape_postpone_request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|tape-&gt;postponed_rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|ide_stall_queue
c_func
(paren
id|drive
comma
id|tape-&gt;dsc_polling_frequency
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_pc_intr is the usual interrupt handler which will be called&n; *&t;during a packet command. We will transfer some of the data (as&n; *&t;requested by the drive) and will re-point interrupt handler to us.&n; *&t;When data transfer is finished, we will act according to the&n; *&t;algorithm described before idetape_issue_packet_command.&n; *&n; */
DECL|function|idetape_pc_intr
r_static
id|ide_startstop_t
id|idetape_pc_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|drive-&gt;hwif
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|atapi_status_t
id|status
suffix:semicolon
id|atapi_bcount_t
id|bcount
suffix:semicolon
id|atapi_ireason_t
id|ireason
suffix:semicolon
id|idetape_pc_t
op_star
id|pc
op_assign
id|tape-&gt;pc
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
macro_line|#if SIMULATE_ERRORS
r_static
r_int
id|error_sim_count
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_pc_intr &quot;
l_string|&quot;interrupt handler&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */&t;
multiline_comment|/* Clear the interrupt */
id|status.all
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|PC_DMA_IN_PROGRESS
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_end
c_func
(paren
id|drive
)paren
op_logical_or
id|status.b.check
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * A DMA error is sometimes expected. For example,&n;&t;&t;&t; * if the tape is crossing a filemark during a&n;&t;&t;&t; * READ command, it will issue an irq and position&n;&t;&t;&t; * itself before the filemark, so that only a partial&n;&t;&t;&t; * data transfer will occur (which causes the DMA&n;&t;&t;&t; * error). In that case, we will later ask the tape&n;&t;&t;&t; * how much bytes of the original request were&n;&t;&t;&t; * actually transferred (we can&squot;t receive that&n;&t;&t;&t; * information from the DMA engine on most chipsets).&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * On the contrary, a DMA error is never expected;&n;&t;&t;&t; * it usually indicates a hardware error or abort.&n;&t;&t;&t; * If the tape crosses a filemark during a READ&n;&t;&t;&t; * command, it will issue an irq and position itself&n;&t;&t;&t; * after the filemark (not before). Only a partial&n;&t;&t;&t; * data transfer will occur, but no DMA error.&n;&t;&t;&t; * (AS, 19 Apr 2001)&n;&t;&t;&t; */
id|set_bit
c_func
(paren
id|PC_DMA_ERROR
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|pc-&gt;actually_transferred
op_assign
id|pc-&gt;request_transfer
suffix:semicolon
id|idetape_update_buffers
c_func
(paren
id|pc
)paren
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: DMA finished&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
)brace
multiline_comment|/* No more interrupts */
r_if
c_cond
(paren
op_logical_neg
id|status.b.drq
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Packet command completed, %d bytes transferred&bslash;n&quot;
comma
id|pc-&gt;actually_transferred
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|clear_bit
c_func
(paren
id|PC_DMA_IN_PROGRESS
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
macro_line|#if SIMULATE_ERRORS
r_if
c_cond
(paren
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_WRITE_CMD
op_logical_or
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_READ_CMD
)paren
op_logical_and
(paren
op_increment
id|error_sim_count
op_mod
l_int|100
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: %s: simulating error&bslash;n&quot;
comma
id|tape-&gt;name
)paren
suffix:semicolon
id|status.b.check
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|status.b.check
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_REQUEST_SENSE_CMD
)paren
id|status.b.check
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status.b.check
op_logical_or
id|test_bit
c_func
(paren
id|PC_DMA_ERROR
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
multiline_comment|/* Error detected */
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: %s: I/O error&bslash;n&quot;
comma
id|tape-&gt;name
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_REQUEST_SENSE_CMD
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: I/O error in request sense command&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: [cmd %x]: check condition&bslash;n&quot;
comma
id|pc-&gt;c
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Retry operation */
r_return
id|idetape_retry_pc
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
id|pc-&gt;error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|PC_WAIT_FOR_DSC
comma
op_amp
id|pc-&gt;flags
)paren
op_logical_and
op_logical_neg
id|status.b.dsc
)paren
(brace
multiline_comment|/* Media access command */
id|tape-&gt;dsc_polling_start
op_assign
id|jiffies
suffix:semicolon
id|tape-&gt;dsc_polling_frequency
op_assign
id|IDETAPE_DSC_MA_FAST
suffix:semicolon
id|tape-&gt;dsc_timeout
op_assign
id|jiffies
op_plus
id|IDETAPE_DSC_MA_TIMEOUT
suffix:semicolon
multiline_comment|/* Allow ide.c to handle other requests */
id|idetape_postpone_request
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;failed_pc
op_eq
id|pc
)paren
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Command finished - Call the callback function */
r_return
id|pc
op_member_access_from_pointer
id|callback
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|PC_DMA_IN_PROGRESS
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: The tape wants to issue more &quot;
l_string|&quot;interrupts in DMA mode&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: DMA disabled, reverting to PIO&bslash;n&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|__ide_dma_off
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the number of bytes to transfer on this interrupt. */
id|bcount.b.high
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_BCOUNTH_REG
)paren
suffix:semicolon
id|bcount.b.low
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_BCOUNTL_REG
)paren
suffix:semicolon
id|ireason.all
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_IREASON_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ireason.b.cod
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: CoD != 0 in idetape_pc_intr&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ireason.b.io
op_eq
id|test_bit
c_func
(paren
id|PC_WRITING
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
multiline_comment|/* Hopefully, we will never get here */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: We wanted to %s, &quot;
comma
id|ireason.b.io
ques
c_cond
l_string|&quot;Write&quot;
suffix:colon
l_string|&quot;Read&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: but the tape wants us to %s !&bslash;n&quot;
comma
id|ireason.b.io
ques
c_cond
l_string|&quot;Read&quot;
suffix:colon
l_string|&quot;Write&quot;
)paren
suffix:semicolon
r_return
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|PC_WRITING
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
multiline_comment|/* Reading - Check that we have enough space */
id|temp
op_assign
id|pc-&gt;actually_transferred
op_plus
id|bcount.all
suffix:semicolon
r_if
c_cond
(paren
id|temp
OG
id|pc-&gt;request_transfer
)paren
(brace
r_if
c_cond
(paren
id|temp
OG
id|pc-&gt;buffer_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: The tape wants to send us more data than expected - discarding data&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_discard_data
c_func
(paren
id|drive
comma
id|bcount.all
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|idetape_pc_intr
comma
id|IDETAPE_WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ide-tape: The tape wants to send us more data than expected - allowing transfer&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
)brace
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|PC_WRITING
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
r_if
c_cond
(paren
id|pc-&gt;bh
op_ne
l_int|NULL
)paren
id|idetape_output_buffers
c_func
(paren
id|drive
comma
id|pc
comma
id|bcount.all
)paren
suffix:semicolon
r_else
multiline_comment|/* Write the current buffer */
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|atapi_output_bytes
c_func
(paren
id|drive
comma
id|pc-&gt;current_position
comma
id|bcount.all
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pc-&gt;bh
op_ne
l_int|NULL
)paren
id|idetape_input_buffers
c_func
(paren
id|drive
comma
id|pc
comma
id|bcount.all
)paren
suffix:semicolon
r_else
multiline_comment|/* Read the current buffer */
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|atapi_input_bytes
c_func
(paren
id|drive
comma
id|pc-&gt;current_position
comma
id|bcount.all
)paren
suffix:semicolon
)brace
multiline_comment|/* Update the current position */
id|pc-&gt;actually_transferred
op_add_assign
id|bcount.all
suffix:semicolon
id|pc-&gt;current_position
op_add_assign
id|bcount.all
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: [cmd %x] transferred %d bytes on that interrupt&bslash;n&quot;
comma
id|pc-&gt;c
(braket
l_int|0
)braket
comma
id|bcount.all
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* And set the interrupt handler again */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|idetape_pc_intr
comma
id|IDETAPE_WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Packet Command Interface&n; *&n; *&t;The current Packet Command is available in tape-&gt;pc, and will not&n; *&t;change until we finish handling it. Each packet command is associated&n; *&t;with a callback function that will be called when the command is&n; *&t;finished.&n; *&n; *&t;The handling will be done in three stages:&n; *&n; *&t;1.&t;idetape_issue_packet_command will send the packet command to the&n; *&t;&t;drive, and will set the interrupt handler to idetape_pc_intr.&n; *&n; *&t;2.&t;On each interrupt, idetape_pc_intr will be called. This step&n; *&t;&t;will be repeated until the device signals us that no more&n; *&t;&t;interrupts will be issued.&n; *&n; *&t;3.&t;ATAPI Tape media access commands have immediate status with a&n; *&t;&t;delayed process. In case of a successful initiation of a&n; *&t;&t;media access packet command, the DSC bit will be set when the&n; *&t;&t;actual execution of the command is finished. &n; *&t;&t;Since the tape drive will not issue an interrupt, we have to&n; *&t;&t;poll for this event. In this case, we define the request as&n; *&t;&t;&quot;low priority request&quot; by setting rq_status to&n; *&t;&t;IDETAPE_RQ_POSTPONED, &t;set a timer to poll for DSC and exit&n; *&t;&t;the driver.&n; *&n; *&t;&t;ide.c will then give higher priority to requests which&n; *&t;&t;originate from the other device, until will change rq_status&n; *&t;&t;to RQ_ACTIVE.&n; *&n; *&t;4.&t;When the packet command is finished, it will be checked for errors.&n; *&n; *&t;5.&t;In case an error was found, we queue a request sense packet&n; *&t;&t;command in front of the request queue and retry the operation&n; *&t;&t;up to IDETAPE_MAX_PC_RETRIES times.&n; *&n; *&t;6.&t;In case no error was found, or we decided to give up and not&n; *&t;&t;to retry again, the callback function will be called and then&n; *&t;&t;we will handle the next request.&n; *&n; */
DECL|function|idetape_transfer_pc
r_static
id|ide_startstop_t
id|idetape_transfer_pc
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|drive-&gt;hwif
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_pc_t
op_star
id|pc
op_assign
id|tape-&gt;pc
suffix:semicolon
id|atapi_ireason_t
id|ireason
suffix:semicolon
r_int
id|retries
op_assign
l_int|100
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DRQ_STAT
comma
id|BUSY_STAT
comma
id|WAIT_READY
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: Strange, packet command initiated yet DRQ isn&squot;t asserted&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
id|ireason.all
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_IREASON_REG
)paren
suffix:semicolon
r_while
c_loop
(paren
id|retries
op_decrement
op_logical_and
(paren
op_logical_neg
id|ireason.b.cod
op_logical_or
id|ireason.b.io
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: (IO,CoD != (0,1) while issuing &quot;
l_string|&quot;a packet command, retrying&bslash;n&quot;
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|ireason.all
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_IREASON_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retries
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: (IO,CoD != (0,1) while &quot;
l_string|&quot;issuing a packet command, ignoring&bslash;n&quot;
)paren
suffix:semicolon
id|ireason.b.cod
op_assign
l_int|1
suffix:semicolon
id|ireason.b.io
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ireason.b.cod
op_logical_or
id|ireason.b.io
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: (IO,CoD) != (0,1) while issuing &quot;
l_string|&quot;a packet command&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the interrupt routine */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|idetape_pc_intr
comma
id|IDETAPE_WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
multiline_comment|/* Begin DMA, if necessary */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|PC_DMA_IN_PROGRESS
comma
op_amp
id|pc-&gt;flags
)paren
)paren
id|hwif
op_member_access_from_pointer
id|dma_start
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Send the actual packet */
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|atapi_output_bytes
c_func
(paren
id|drive
comma
id|pc-&gt;c
comma
l_int|12
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|idetape_issue_packet_command
r_static
id|ide_startstop_t
id|idetape_issue_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pc_t
op_star
id|pc
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|drive-&gt;hwif
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|atapi_bcount_t
id|bcount
suffix:semicolon
r_int
id|dma_ok
op_assign
l_int|0
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_REQUEST_SENSE_CMD
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_REQUEST_SENSE_CMD
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: possible ide-tape.c bug - &quot;
l_string|&quot;Two request sense in serial were issued&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
r_if
c_cond
(paren
id|tape-&gt;failed_pc
op_eq
l_int|NULL
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|IDETAPE_REQUEST_SENSE_CMD
)paren
id|tape-&gt;failed_pc
op_assign
id|pc
suffix:semicolon
multiline_comment|/* Set the current packet command */
id|tape-&gt;pc
op_assign
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|pc-&gt;retries
OG
id|IDETAPE_MAX_PC_RETRIES
op_logical_or
id|test_bit
c_func
(paren
id|PC_ABORT
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We will &quot;abort&quot; retrying a packet command in case&n;&t;&t; *&t;a legitimate error code was received (crossing a&n;&t;&t; *&t;filemark, or end of the media, for example).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|PC_ABORT
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_TEST_UNIT_READY_CMD
op_logical_and
id|tape-&gt;sense_key
op_eq
l_int|2
op_logical_and
id|tape-&gt;asc
op_eq
l_int|4
op_logical_and
(paren
id|tape-&gt;ascq
op_eq
l_int|1
op_logical_or
id|tape-&gt;ascq
op_eq
l_int|8
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: %s: I/O error, &quot;
l_string|&quot;pc = %2x, key = %2x, &quot;
l_string|&quot;asc = %2x, ascq = %2x&bslash;n&quot;
comma
id|tape-&gt;name
comma
id|pc-&gt;c
(braket
l_int|0
)braket
comma
id|tape-&gt;sense_key
comma
id|tape-&gt;asc
comma
id|tape-&gt;ascq
)paren
suffix:semicolon
)brace
multiline_comment|/* Giving up */
id|pc-&gt;error
op_assign
id|IDETAPE_ERROR_GENERAL
suffix:semicolon
)brace
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
r_return
id|pc
op_member_access_from_pointer
id|callback
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Retry number - %d, cmd = %02X&bslash;n&quot;
comma
id|pc-&gt;retries
comma
id|pc-&gt;c
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|pc-&gt;retries
op_increment
suffix:semicolon
multiline_comment|/* We haven&squot;t transferred any data yet */
id|pc-&gt;actually_transferred
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;current_position
op_assign
id|pc-&gt;buffer
suffix:semicolon
multiline_comment|/* Request to transfer the entire buffer at once */
id|bcount.all
op_assign
id|pc-&gt;request_transfer
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|PC_DMA_ERROR
comma
op_amp
id|pc-&gt;flags
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide-tape: DMA disabled, &quot;
l_string|&quot;reverting to PIO&bslash;n&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|__ide_dma_off
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|PC_DMA_RECOMMENDED
comma
op_amp
id|pc-&gt;flags
)paren
op_logical_and
id|drive-&gt;using_dma
)paren
id|dma_ok
op_assign
op_logical_neg
id|hwif
op_member_access_from_pointer
id|dma_setup
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|dma_ok
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
multiline_comment|/* Use PIO/DMA */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|bcount.b.high
comma
id|IDE_BCOUNTH_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|bcount.b.low
comma
id|IDE_BCOUNTL_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_ok
)paren
multiline_comment|/* Will begin DMA later */
id|set_bit
c_func
(paren
id|PC_DMA_IN_PROGRESS
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDETAPE_DRQ_INTERRUPT
comma
op_amp
id|tape-&gt;flags
)paren
)paren
(brace
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|idetape_transfer_pc
comma
id|IDETAPE_WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_else
(brace
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_return
id|idetape_transfer_pc
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;General packet command callback function.&n; */
DECL|function|idetape_pc_callback
r_static
id|ide_startstop_t
id|idetape_pc_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_pc_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|idetape_end_request
c_func
(paren
id|drive
comma
id|tape-&gt;pc-&gt;error
ques
c_cond
l_int|0
suffix:colon
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A mode sense command is used to &quot;sense&quot; tape parameters.&n; */
DECL|function|idetape_create_mode_sense_cmd
r_static
r_void
id|idetape_create_mode_sense_cmd
(paren
id|idetape_pc_t
op_star
id|pc
comma
id|u8
id|page_code
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_MODE_SENSE_CMD
suffix:semicolon
r_if
c_cond
(paren
id|page_code
op_ne
id|IDETAPE_BLOCK_DESCRIPTOR
)paren
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* DBD = 1 - Don&squot;t return block descriptors */
id|pc-&gt;c
(braket
l_int|2
)braket
op_assign
id|page_code
suffix:semicolon
multiline_comment|/*&n;&t; * Changed pc-&gt;c[3] to 0 (255 will at best return unused info).&n;&t; *&n;&t; * For SCSI this byte is defined as subpage instead of high byte&n;&t; * of length and some IDE drives seem to interpret it this way&n;&t; * and return an error when 255 is used.&n;&t; */
id|pc-&gt;c
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* (We will just discard data in that case) */
r_if
c_cond
(paren
id|page_code
op_eq
id|IDETAPE_BLOCK_DESCRIPTOR
)paren
id|pc-&gt;request_transfer
op_assign
l_int|12
suffix:semicolon
r_else
r_if
c_cond
(paren
id|page_code
op_eq
id|IDETAPE_CAPABILITIES_PAGE
)paren
id|pc-&gt;request_transfer
op_assign
l_int|24
suffix:semicolon
r_else
id|pc-&gt;request_transfer
op_assign
l_int|50
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
)brace
DECL|function|calculate_speeds
r_static
r_void
id|calculate_speeds
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|full
op_assign
l_int|125
comma
id|empty
op_assign
l_int|75
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|tape-&gt;controlled_pipeline_head_time
op_plus
l_int|120
op_star
id|HZ
)paren
)paren
(brace
id|tape-&gt;controlled_previous_pipeline_head
op_assign
id|tape-&gt;controlled_last_pipeline_head
suffix:semicolon
id|tape-&gt;controlled_previous_head_time
op_assign
id|tape-&gt;controlled_pipeline_head_time
suffix:semicolon
id|tape-&gt;controlled_last_pipeline_head
op_assign
id|tape-&gt;pipeline_head
suffix:semicolon
id|tape-&gt;controlled_pipeline_head_time
op_assign
id|jiffies
suffix:semicolon
)brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|tape-&gt;controlled_pipeline_head_time
op_plus
l_int|60
op_star
id|HZ
)paren
)paren
id|tape-&gt;controlled_pipeline_head_speed
op_assign
(paren
id|tape-&gt;pipeline_head
op_minus
id|tape-&gt;controlled_last_pipeline_head
)paren
op_star
l_int|32
op_star
id|HZ
op_div
(paren
id|jiffies
op_minus
id|tape-&gt;controlled_pipeline_head_time
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|tape-&gt;controlled_previous_head_time
)paren
)paren
id|tape-&gt;controlled_pipeline_head_speed
op_assign
(paren
id|tape-&gt;pipeline_head
op_minus
id|tape-&gt;controlled_previous_pipeline_head
)paren
op_star
l_int|32
op_star
id|HZ
op_div
(paren
id|jiffies
op_minus
id|tape-&gt;controlled_previous_head_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;nr_pending_stages
OL
id|tape-&gt;max_stages
multiline_comment|/*- 1 */
)paren
(brace
multiline_comment|/* -1 for read mode error recovery */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|tape-&gt;uncontrolled_previous_head_time
op_plus
l_int|10
op_star
id|HZ
)paren
)paren
(brace
id|tape-&gt;uncontrolled_pipeline_head_time
op_assign
id|jiffies
suffix:semicolon
id|tape-&gt;uncontrolled_pipeline_head_speed
op_assign
(paren
id|tape-&gt;pipeline_head
op_minus
id|tape-&gt;uncontrolled_previous_pipeline_head
)paren
op_star
l_int|32
op_star
id|HZ
op_div
(paren
id|jiffies
op_minus
id|tape-&gt;uncontrolled_previous_head_time
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|tape-&gt;uncontrolled_previous_head_time
op_assign
id|jiffies
suffix:semicolon
id|tape-&gt;uncontrolled_previous_pipeline_head
op_assign
id|tape-&gt;pipeline_head
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|tape-&gt;uncontrolled_pipeline_head_time
op_plus
l_int|30
op_star
id|HZ
)paren
)paren
(brace
id|tape-&gt;uncontrolled_pipeline_head_time
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
id|tape-&gt;pipeline_head_speed
op_assign
id|max
c_func
(paren
id|tape-&gt;uncontrolled_pipeline_head_speed
comma
id|tape-&gt;controlled_pipeline_head_speed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;speed_control
op_eq
l_int|0
)paren
(brace
id|tape-&gt;max_insert_speed
op_assign
l_int|5000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tape-&gt;speed_control
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|tape-&gt;nr_pending_stages
op_ge
id|tape-&gt;max_stages
op_div
l_int|2
)paren
id|tape-&gt;max_insert_speed
op_assign
id|tape-&gt;pipeline_head_speed
op_plus
(paren
l_int|1100
op_minus
id|tape-&gt;pipeline_head_speed
)paren
op_star
l_int|2
op_star
(paren
id|tape-&gt;nr_pending_stages
op_minus
id|tape-&gt;max_stages
op_div
l_int|2
)paren
op_div
id|tape-&gt;max_stages
suffix:semicolon
r_else
id|tape-&gt;max_insert_speed
op_assign
l_int|500
op_plus
(paren
id|tape-&gt;pipeline_head_speed
op_minus
l_int|500
)paren
op_star
l_int|2
op_star
id|tape-&gt;nr_pending_stages
op_div
id|tape-&gt;max_stages
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;nr_pending_stages
op_ge
id|tape-&gt;max_stages
op_star
l_int|99
op_div
l_int|100
)paren
id|tape-&gt;max_insert_speed
op_assign
l_int|5000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tape-&gt;speed_control
op_eq
l_int|2
)paren
(brace
id|tape-&gt;max_insert_speed
op_assign
id|tape-&gt;pipeline_head_speed
op_star
id|empty
op_div
l_int|100
op_plus
(paren
id|tape-&gt;pipeline_head_speed
op_star
id|full
op_div
l_int|100
op_minus
id|tape-&gt;pipeline_head_speed
op_star
id|empty
op_div
l_int|100
)paren
op_star
id|tape-&gt;nr_pending_stages
op_div
id|tape-&gt;max_stages
suffix:semicolon
)brace
r_else
id|tape-&gt;max_insert_speed
op_assign
id|tape-&gt;speed_control
suffix:semicolon
id|tape-&gt;max_insert_speed
op_assign
id|max
c_func
(paren
id|tape-&gt;max_insert_speed
comma
l_int|500
)paren
suffix:semicolon
)brace
DECL|function|idetape_media_access_finished
r_static
id|ide_startstop_t
id|idetape_media_access_finished
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_pc_t
op_star
id|pc
op_assign
id|tape-&gt;pc
suffix:semicolon
id|atapi_status_t
id|status
suffix:semicolon
id|status.all
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status.b.dsc
)paren
(brace
r_if
c_cond
(paren
id|status.b.check
)paren
(brace
multiline_comment|/* Error detected */
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|IDETAPE_TEST_UNIT_READY_CMD
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: %s: I/O error, &quot;
comma
id|tape-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Retry operation */
r_return
id|idetape_retry_pc
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
id|pc-&gt;error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;failed_pc
op_eq
id|pc
)paren
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|pc-&gt;error
op_assign
id|IDETAPE_ERROR_GENERAL
suffix:semicolon
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|pc
op_member_access_from_pointer
id|callback
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
DECL|function|idetape_rw_callback
r_static
id|ide_startstop_t
id|idetape_rw_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|blocks
op_assign
id|tape-&gt;pc-&gt;actually_transferred
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
id|tape-&gt;avg_size
op_add_assign
id|blocks
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
id|tape-&gt;insert_size
op_add_assign
id|blocks
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;insert_size
OG
l_int|1024
op_star
l_int|1024
)paren
id|tape-&gt;measure_insert_time
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;measure_insert_time
)paren
(brace
id|tape-&gt;measure_insert_time
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;insert_time
op_assign
id|jiffies
suffix:semicolon
id|tape-&gt;insert_size
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|tape-&gt;insert_time
)paren
)paren
id|tape-&gt;insert_speed
op_assign
id|tape-&gt;insert_size
op_div
l_int|1024
op_star
id|HZ
op_div
(paren
id|jiffies
op_minus
id|tape-&gt;insert_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_minus
id|tape-&gt;avg_time
op_ge
id|HZ
)paren
(brace
id|tape-&gt;avg_speed
op_assign
id|tape-&gt;avg_size
op_star
id|HZ
op_div
(paren
id|jiffies
op_minus
id|tape-&gt;avg_time
)paren
op_div
l_int|1024
suffix:semicolon
id|tape-&gt;avg_size
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;avg_time
op_assign
id|jiffies
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG_LOG&t;
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_rw_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|tape-&gt;first_frame_position
op_add_assign
id|blocks
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|blocks
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
id|idetape_end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_else
id|idetape_end_request
c_func
(paren
id|drive
comma
id|tape-&gt;pc-&gt;error
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|idetape_create_read_cmd
r_static
r_void
id|idetape_create_read_cmd
c_func
(paren
id|idetape_tape_t
op_star
id|tape
comma
id|idetape_pc_t
op_star
id|pc
comma
r_int
r_int
id|length
comma
r_struct
id|idetape_bh
op_star
id|bh
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_READ_CMD
suffix:semicolon
id|put_unaligned
c_func
(paren
id|htonl
c_func
(paren
id|length
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc-&gt;c
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_rw_callback
suffix:semicolon
id|pc-&gt;bh
op_assign
id|bh
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
l_int|0
)paren
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;request_transfer
op_assign
id|pc-&gt;buffer_size
op_assign
id|length
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
r_if
c_cond
(paren
id|pc-&gt;request_transfer
op_eq
id|tape-&gt;stage_size
)paren
id|set_bit
c_func
(paren
id|PC_DMA_RECOMMENDED
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
)brace
DECL|function|idetape_create_read_buffer_cmd
r_static
r_void
id|idetape_create_read_buffer_cmd
c_func
(paren
id|idetape_tape_t
op_star
id|tape
comma
id|idetape_pc_t
op_star
id|pc
comma
r_int
r_int
id|length
comma
r_struct
id|idetape_bh
op_star
id|bh
)paren
(brace
r_int
id|size
op_assign
l_int|32768
suffix:semicolon
r_struct
id|idetape_bh
op_star
id|p
op_assign
id|bh
suffix:semicolon
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_READ_BUFFER_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
id|IDETAPE_RETRIEVE_FAULTY_BLOCK
suffix:semicolon
id|pc-&gt;c
(braket
l_int|7
)braket
op_assign
id|size
op_rshift
l_int|8
suffix:semicolon
id|pc-&gt;c
(braket
l_int|8
)braket
op_assign
id|size
op_amp
l_int|0xff
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;bh
op_assign
id|bh
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
l_int|0
)paren
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|p-&gt;b_count
comma
l_int|0
)paren
suffix:semicolon
id|p
op_assign
id|p-&gt;b_reqnext
suffix:semicolon
)brace
id|pc-&gt;request_transfer
op_assign
id|pc-&gt;buffer_size
op_assign
id|size
suffix:semicolon
)brace
DECL|function|idetape_create_write_cmd
r_static
r_void
id|idetape_create_write_cmd
c_func
(paren
id|idetape_tape_t
op_star
id|tape
comma
id|idetape_pc_t
op_star
id|pc
comma
r_int
r_int
id|length
comma
r_struct
id|idetape_bh
op_star
id|bh
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_WRITE_CMD
suffix:semicolon
id|put_unaligned
c_func
(paren
id|htonl
c_func
(paren
id|length
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc-&gt;c
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_rw_callback
suffix:semicolon
id|set_bit
c_func
(paren
id|PC_WRITING
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
id|pc-&gt;bh
op_assign
id|bh
suffix:semicolon
id|pc-&gt;b_data
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|pc-&gt;b_count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;request_transfer
op_assign
id|pc-&gt;buffer_size
op_assign
id|length
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
r_if
c_cond
(paren
id|pc-&gt;request_transfer
op_eq
id|tape-&gt;stage_size
)paren
id|set_bit
c_func
(paren
id|PC_DMA_RECOMMENDED
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * idetape_do_request is our request handling function.&t;&n; */
DECL|function|idetape_do_request
r_static
id|ide_startstop_t
id|idetape_do_request
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|sector_t
id|block
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_pc_t
op_star
id|pc
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|request
op_star
id|postponed_rq
op_assign
id|tape-&gt;postponed_rq
suffix:semicolon
id|atapi_status_t
id|status
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
macro_line|#if 0
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: rq_status: %d, &quot;
l_string|&quot;dev: %s, cmd: %ld, errors: %d&bslash;n&quot;
comma
id|rq-&gt;rq_status
comma
id|rq-&gt;rq_disk-&gt;disk_name
comma
id|rq-&gt;cmd
(braket
l_int|0
)braket
comma
id|rq-&gt;errors
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: sector: %ld, &quot;
l_string|&quot;nr_sectors: %ld, current_nr_sectors: %d&bslash;n&quot;
comma
id|rq-&gt;sector
comma
id|rq-&gt;nr_sectors
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
(paren
id|rq-&gt;flags
op_amp
id|REQ_SPECIAL
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We do not support buffer cache originated requests.&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ide-tape: %s: Unsupported request in &quot;
l_string|&quot;request queue (%ld)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;flags
)paren
suffix:semicolon
id|ide_end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Retry a failed packet command&n;&t; */
r_if
c_cond
(paren
id|tape-&gt;failed_pc
op_ne
l_int|NULL
op_logical_and
id|tape-&gt;pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_REQUEST_SENSE_CMD
)paren
(brace
r_return
id|idetape_issue_packet_command
c_func
(paren
id|drive
comma
id|tape-&gt;failed_pc
)paren
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|postponed_rq
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
id|rq
op_ne
id|postponed_rq
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: ide-tape.c bug - &quot;
l_string|&quot;Two DSC requests were queued&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|tape-&gt;postponed_rq
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * If the tape is still busy, postpone our request and service&n;&t; * the other device meanwhile.&n;&t; */
id|status.all
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;dsc_overlap
op_logical_and
op_logical_neg
(paren
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_amp
id|REQ_IDETAPE_PC2
)paren
)paren
id|set_bit
c_func
(paren
id|IDETAPE_IGNORE_DSC
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;tape_still_time
OG
l_int|100
op_logical_and
id|tape-&gt;tape_still_time
OL
l_int|200
)paren
id|tape-&gt;measure_insert_time
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|tape-&gt;insert_time
)paren
)paren
id|tape-&gt;insert_speed
op_assign
id|tape-&gt;insert_size
op_div
l_int|1024
op_star
id|HZ
op_div
(paren
id|jiffies
op_minus
id|tape-&gt;insert_time
)paren
suffix:semicolon
id|calculate_speeds
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
id|IDETAPE_IGNORE_DSC
comma
op_amp
id|tape-&gt;flags
)paren
op_logical_and
op_logical_neg
id|status.b.dsc
)paren
(brace
r_if
c_cond
(paren
id|postponed_rq
op_eq
l_int|NULL
)paren
(brace
id|tape-&gt;dsc_polling_start
op_assign
id|jiffies
suffix:semicolon
id|tape-&gt;dsc_polling_frequency
op_assign
id|tape-&gt;best_dsc_rw_frequency
suffix:semicolon
id|tape-&gt;dsc_timeout
op_assign
id|jiffies
op_plus
id|IDETAPE_DSC_RW_TIMEOUT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|tape-&gt;dsc_timeout
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: %s: DSC timeout&bslash;n&quot;
comma
id|tape-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_amp
id|REQ_IDETAPE_PC2
)paren
(brace
id|idetape_media_access_finished
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_else
(brace
r_return
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|jiffies
op_minus
id|tape-&gt;dsc_polling_start
OG
id|IDETAPE_DSC_MA_THRESHOLD
)paren
id|tape-&gt;dsc_polling_frequency
op_assign
id|IDETAPE_DSC_MA_SLOW
suffix:semicolon
id|idetape_postpone_request
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_amp
id|REQ_IDETAPE_READ
)paren
(brace
id|tape-&gt;buffer_head
op_increment
suffix:semicolon
macro_line|#if USE_IOTRACE
id|IO_trace
c_func
(paren
id|IO_IDETAPE_FIFO
comma
id|tape-&gt;pipeline_head
comma
id|tape-&gt;buffer_head
comma
id|tape-&gt;tape_head
comma
id|tape-&gt;minor
)paren
suffix:semicolon
macro_line|#endif
id|tape-&gt;postpone_cnt
op_assign
l_int|0
suffix:semicolon
id|pc
op_assign
id|idetape_next_pc_storage
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_create_read_cmd
c_func
(paren
id|tape
comma
id|pc
comma
id|rq-&gt;current_nr_sectors
comma
(paren
r_struct
id|idetape_bh
op_star
)paren
id|rq-&gt;special
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_amp
id|REQ_IDETAPE_WRITE
)paren
(brace
id|tape-&gt;buffer_head
op_increment
suffix:semicolon
macro_line|#if USE_IOTRACE
id|IO_trace
c_func
(paren
id|IO_IDETAPE_FIFO
comma
id|tape-&gt;pipeline_head
comma
id|tape-&gt;buffer_head
comma
id|tape-&gt;tape_head
comma
id|tape-&gt;minor
)paren
suffix:semicolon
macro_line|#endif
id|tape-&gt;postpone_cnt
op_assign
l_int|0
suffix:semicolon
id|pc
op_assign
id|idetape_next_pc_storage
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_create_write_cmd
c_func
(paren
id|tape
comma
id|pc
comma
id|rq-&gt;current_nr_sectors
comma
(paren
r_struct
id|idetape_bh
op_star
)paren
id|rq-&gt;special
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_amp
id|REQ_IDETAPE_READ_BUFFER
)paren
(brace
id|tape-&gt;postpone_cnt
op_assign
l_int|0
suffix:semicolon
id|pc
op_assign
id|idetape_next_pc_storage
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_create_read_buffer_cmd
c_func
(paren
id|tape
comma
id|pc
comma
id|rq-&gt;current_nr_sectors
comma
(paren
r_struct
id|idetape_bh
op_star
)paren
id|rq-&gt;special
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_amp
id|REQ_IDETAPE_PC1
)paren
(brace
id|pc
op_assign
(paren
id|idetape_pc_t
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_and_assign
op_complement
(paren
id|REQ_IDETAPE_PC1
)paren
suffix:semicolon
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_or_assign
id|REQ_IDETAPE_PC2
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_amp
id|REQ_IDETAPE_PC2
)paren
(brace
id|idetape_media_access_finished
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|idetape_issue_packet_command
c_func
(paren
id|drive
comma
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Pipeline related functions&n; */
DECL|function|idetape_pipeline_active
r_static
r_inline
r_int
id|idetape_pipeline_active
(paren
id|idetape_tape_t
op_star
id|tape
)paren
(brace
r_int
id|rc1
comma
id|rc2
suffix:semicolon
id|rc1
op_assign
id|test_bit
c_func
(paren
id|IDETAPE_PIPELINE_ACTIVE
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|rc2
op_assign
(paren
id|tape-&gt;active_data_request
op_ne
l_int|NULL
)paren
suffix:semicolon
r_return
id|rc1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_kmalloc_stage uses __get_free_page to allocate a pipeline&n; *&t;stage, along with all the necessary small buffers which together make&n; *&t;a buffer of size tape-&gt;stage_size (or a bit more). We attempt to&n; *&t;combine sequential pages as much as possible.&n; *&n; *&t;Returns a pointer to the new allocated stage, or NULL if we&n; *&t;can&squot;t (or don&squot;t want to) allocate a stage.&n; *&n; *&t;Pipeline stages are optional and are used to increase performance.&n; *&t;If we can&squot;t allocate them, we&squot;ll manage without them.&n; */
DECL|function|__idetape_kmalloc_stage
r_static
id|idetape_stage_t
op_star
id|__idetape_kmalloc_stage
(paren
id|idetape_tape_t
op_star
id|tape
comma
r_int
id|full
comma
r_int
id|clear
)paren
(brace
id|idetape_stage_t
op_star
id|stage
suffix:semicolon
r_struct
id|idetape_bh
op_star
id|prev_bh
comma
op_star
id|bh
suffix:semicolon
r_int
id|pages
op_assign
id|tape-&gt;pages_per_stage
suffix:semicolon
r_char
op_star
id|b_data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stage
op_assign
(paren
id|idetape_stage_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|idetape_stage_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|stage-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_assign
id|stage-&gt;bh
op_assign
(paren
r_struct
id|idetape_bh
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|idetape_bh
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
r_goto
m_abort
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh-&gt;b_data
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
(paren
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
m_abort
suffix:semicolon
r_if
c_cond
(paren
id|clear
)paren
id|memset
c_func
(paren
id|bh-&gt;b_data
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|bh-&gt;b_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
id|full
ques
c_cond
id|bh-&gt;b_size
suffix:colon
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|pages
)paren
(brace
r_if
c_cond
(paren
(paren
id|b_data
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
(paren
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
m_abort
suffix:semicolon
r_if
c_cond
(paren
id|clear
)paren
id|memset
c_func
(paren
id|b_data
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_data
op_eq
id|b_data
op_plus
id|PAGE_SIZE
)paren
(brace
id|bh-&gt;b_size
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|bh-&gt;b_data
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|full
)paren
id|atomic_add
c_func
(paren
id|PAGE_SIZE
comma
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|b_data
op_eq
id|bh-&gt;b_data
op_plus
id|bh-&gt;b_size
)paren
(brace
id|bh-&gt;b_size
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|full
)paren
id|atomic_add
c_func
(paren
id|PAGE_SIZE
comma
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|prev_bh
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
(paren
r_struct
id|idetape_bh
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|idetape_bh
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|b_data
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh-&gt;b_data
op_assign
id|b_data
suffix:semicolon
id|bh-&gt;b_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
id|full
ques
c_cond
id|bh-&gt;b_size
suffix:colon
l_int|0
)paren
suffix:semicolon
id|prev_bh-&gt;b_reqnext
op_assign
id|bh
suffix:semicolon
)brace
id|bh-&gt;b_size
op_sub_assign
id|tape-&gt;excess_bh_size
suffix:semicolon
r_if
c_cond
(paren
id|full
)paren
id|atomic_sub
c_func
(paren
id|tape-&gt;excess_bh_size
comma
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
r_return
id|stage
suffix:semicolon
m_abort
suffix:colon
id|__idetape_kfree_stage
c_func
(paren
id|stage
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|idetape_kmalloc_stage
r_static
id|idetape_stage_t
op_star
id|idetape_kmalloc_stage
(paren
id|idetape_tape_t
op_star
id|tape
)paren
(brace
id|idetape_stage_t
op_star
id|cache_stage
op_assign
id|tape-&gt;cache_stage
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_kmalloc_stage&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;nr_stages
op_ge
id|tape-&gt;max_stages
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cache_stage
op_ne
l_int|NULL
)paren
(brace
id|tape-&gt;cache_stage
op_assign
l_int|NULL
suffix:semicolon
r_return
id|cache_stage
suffix:semicolon
)brace
r_return
id|__idetape_kmalloc_stage
c_func
(paren
id|tape
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|idetape_copy_stage_from_user
r_static
r_void
id|idetape_copy_stage_from_user
(paren
id|idetape_tape_t
op_star
id|tape
comma
id|idetape_stage_t
op_star
id|stage
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|n
)paren
(brace
r_struct
id|idetape_bh
op_star
id|bh
op_assign
id|tape-&gt;bh
suffix:semicolon
r_int
id|count
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bh == NULL in &quot;
l_string|&quot;idetape_copy_stage_from_user&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|count
op_assign
id|min
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|bh-&gt;b_size
op_minus
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
)paren
comma
(paren
r_int
r_int
)paren
id|n
)paren
suffix:semicolon
id|copy_from_user
c_func
(paren
id|bh-&gt;b_data
op_plus
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|n
op_sub_assign
id|count
suffix:semicolon
id|atomic_add
c_func
(paren
id|count
comma
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|buf
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
op_eq
id|bh-&gt;b_size
)paren
(brace
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|tape-&gt;bh
op_assign
id|bh
suffix:semicolon
)brace
DECL|function|idetape_copy_stage_to_user
r_static
r_void
id|idetape_copy_stage_to_user
(paren
id|idetape_tape_t
op_star
id|tape
comma
r_char
id|__user
op_star
id|buf
comma
id|idetape_stage_t
op_star
id|stage
comma
r_int
id|n
)paren
(brace
r_struct
id|idetape_bh
op_star
id|bh
op_assign
id|tape-&gt;bh
suffix:semicolon
r_int
id|count
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bh == NULL in &quot;
l_string|&quot;idetape_copy_stage_to_user&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|count
op_assign
id|min
c_func
(paren
id|tape-&gt;b_count
comma
id|n
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
id|buf
comma
id|tape-&gt;b_data
comma
id|count
)paren
suffix:semicolon
id|n
op_sub_assign
id|count
suffix:semicolon
id|tape-&gt;b_data
op_add_assign
id|count
suffix:semicolon
id|tape-&gt;b_count
op_sub_assign
id|count
suffix:semicolon
id|buf
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;b_count
)paren
(brace
id|tape-&gt;bh
op_assign
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|tape-&gt;b_data
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|tape-&gt;b_count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|idetape_init_merge_stage
r_static
r_void
id|idetape_init_merge_stage
(paren
id|idetape_tape_t
op_star
id|tape
)paren
(brace
r_struct
id|idetape_bh
op_star
id|bh
op_assign
id|tape-&gt;merge_stage-&gt;bh
suffix:semicolon
id|tape-&gt;bh
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_write
)paren
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|tape-&gt;b_data
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|tape-&gt;b_count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
)brace
)brace
DECL|function|idetape_switch_buffers
r_static
r_void
id|idetape_switch_buffers
(paren
id|idetape_tape_t
op_star
id|tape
comma
id|idetape_stage_t
op_star
id|stage
)paren
(brace
r_struct
id|idetape_bh
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|stage-&gt;bh
suffix:semicolon
id|stage-&gt;bh
op_assign
id|tape-&gt;merge_stage-&gt;bh
suffix:semicolon
id|tape-&gt;merge_stage-&gt;bh
op_assign
id|tmp
suffix:semicolon
id|idetape_init_merge_stage
c_func
(paren
id|tape
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_add_stage_tail adds a new stage at the end of the pipeline.&n; */
DECL|function|idetape_add_stage_tail
r_static
r_void
id|idetape_add_stage_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_stage_t
op_star
id|stage
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_add_stage_tail&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
id|stage-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;last_stage
op_ne
l_int|NULL
)paren
id|tape-&gt;last_stage-&gt;next
op_assign
id|stage
suffix:semicolon
r_else
id|tape-&gt;first_stage
op_assign
id|tape-&gt;next_stage
op_assign
id|stage
suffix:semicolon
id|tape-&gt;last_stage
op_assign
id|stage
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;next_stage
op_eq
l_int|NULL
)paren
id|tape-&gt;next_stage
op_assign
id|tape-&gt;last_stage
suffix:semicolon
id|tape-&gt;nr_stages
op_increment
suffix:semicolon
id|tape-&gt;nr_pending_stages
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_wait_for_request installs a completion in a pending request&n; *&t;and sleeps until it is serviced.&n; *&n; *&t;The caller should ensure that the request will not be serviced&n; *&t;before we install the completion (usually by disabling interrupts).&n; */
DECL|function|idetape_wait_for_request
r_static
r_void
id|idetape_wait_for_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|DECLARE_COMPLETION
c_func
(paren
id|wait
)paren
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|rq
op_eq
l_int|NULL
op_logical_or
(paren
id|rq-&gt;flags
op_amp
id|REQ_SPECIAL
)paren
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bug: Trying to sleep on non-valid request&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|rq-&gt;waiting
op_assign
op_amp
id|wait
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|tape-&gt;spinlock
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* The stage and its struct request have been deallocated */
id|spin_lock_irq
c_func
(paren
op_amp
id|tape-&gt;spinlock
)paren
suffix:semicolon
)brace
DECL|function|idetape_read_position_callback
r_static
id|ide_startstop_t
id|idetape_read_position_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_read_position_result_t
op_star
id|result
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_read_position_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
(brace
id|result
op_assign
(paren
id|idetape_read_position_result_t
op_star
)paren
id|tape-&gt;pc-&gt;buffer
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: BOP - %s&bslash;n&quot;
comma
id|result-&gt;bop
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: EOP - %s&bslash;n&quot;
comma
id|result-&gt;eop
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|result-&gt;bpu
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Block location is unknown to the tape&bslash;n&quot;
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|IDETAPE_ADDRESS_VALID
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|idetape_end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Block Location - %u&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|result-&gt;first_block
)paren
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|tape-&gt;partition
op_assign
id|result-&gt;partition
suffix:semicolon
id|tape-&gt;first_frame_position
op_assign
id|ntohl
c_func
(paren
id|result-&gt;first_block
)paren
suffix:semicolon
id|tape-&gt;last_frame_position
op_assign
id|ntohl
c_func
(paren
id|result-&gt;last_block
)paren
suffix:semicolon
id|tape-&gt;blocks_in_buffer
op_assign
id|result-&gt;blocks_in_buffer
(braket
l_int|2
)braket
suffix:semicolon
id|set_bit
c_func
(paren
id|IDETAPE_ADDRESS_VALID
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|idetape_end_request
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|idetape_end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_create_write_filemark_cmd will:&n; *&n; *&t;&t;1.&t;Write a filemark if write_filemark=1.&n; *&t;&t;2.&t;Flush the device buffers without writing a filemark&n; *&t;&t;&t;if write_filemark=0.&n; *&n; */
DECL|function|idetape_create_write_filemark_cmd
r_static
r_void
id|idetape_create_write_filemark_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pc_t
op_star
id|pc
comma
r_int
id|write_filemark
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_WRITE_FILEMARK_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|write_filemark
suffix:semicolon
id|set_bit
c_func
(paren
id|PC_WAIT_FOR_DSC
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
)brace
DECL|function|idetape_create_test_unit_ready_cmd
r_static
r_void
id|idetape_create_test_unit_ready_cmd
c_func
(paren
id|idetape_pc_t
op_star
id|pc
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_TEST_UNIT_READY_CMD
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_queue_pc_tail is based on the following functions:&n; *&n; *&t;ide_do_drive_cmd from ide.c&n; *&t;cdrom_queue_request and cdrom_queue_packet_command from ide-cd.c&n; *&n; *&t;We add a special packet command request to the tail of the request&n; *&t;queue, and wait for it to be serviced.&n; *&n; *&t;This is not to be called from within the request handling part&n; *&t;of the driver ! We allocate here data in the stack, and it is valid&n; *&t;until the request is finished. This is not the case for the bottom&n; *&t;part of the driver, where we are always leaving the functions to wait&n; *&t;for an interrupt or a timer event.&n; *&n; *&t;From the bottom part of the driver, we should allocate safe memory&n; *&t;using idetape_next_pc_storage and idetape_next_rq_storage, and add&n; *&t;the request to the request list without waiting for it to be serviced !&n; *&t;In that case, we usually use idetape_queue_pc_head.&n; */
DECL|function|__idetape_queue_pc_tail
r_static
r_int
id|__idetape_queue_pc_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pc_t
op_star
id|pc
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|idetape_init_rq
c_func
(paren
op_amp
id|rq
comma
id|REQ_IDETAPE_PC1
)paren
suffix:semicolon
id|rq.buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
DECL|function|idetape_create_load_unload_cmd
r_static
r_void
id|idetape_create_load_unload_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pc_t
op_star
id|pc
comma
r_int
id|cmd
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_LOAD_UNLOAD_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|cmd
suffix:semicolon
id|set_bit
c_func
(paren
id|PC_WAIT_FOR_DSC
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
)brace
DECL|function|idetape_wait_ready
r_static
r_int
id|idetape_wait_ready
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|timeout
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_pc_t
id|pc
suffix:semicolon
r_int
id|load_attempted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for the tape to become ready&n;&t; */
id|set_bit
c_func
(paren
id|IDETAPE_MEDIUM_PRESENT
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|idetape_create_test_unit_ready_cmd
c_func
(paren
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tape-&gt;sense_key
op_eq
l_int|2
op_logical_and
id|tape-&gt;asc
op_eq
l_int|4
op_logical_and
id|tape-&gt;ascq
op_eq
l_int|2
)paren
op_logical_or
(paren
id|tape-&gt;asc
op_eq
l_int|0x3A
)paren
)paren
(brace
multiline_comment|/* no media */
r_if
c_cond
(paren
id|load_attempted
)paren
r_return
op_minus
id|ENOMEDIUM
suffix:semicolon
id|idetape_create_load_unload_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
id|IDETAPE_LU_LOAD_MASK
)paren
suffix:semicolon
id|__idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
id|load_attempted
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* not about to be ready */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|tape-&gt;sense_key
op_eq
l_int|2
op_logical_and
id|tape-&gt;asc
op_eq
l_int|4
op_logical_and
(paren
id|tape-&gt;ascq
op_eq
l_int|1
op_logical_or
id|tape-&gt;ascq
op_eq
l_int|8
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|idetape_queue_pc_tail
r_static
r_int
id|idetape_queue_pc_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pc_t
op_star
id|pc
)paren
(brace
r_return
id|__idetape_queue_pc_tail
c_func
(paren
id|drive
comma
id|pc
)paren
suffix:semicolon
)brace
DECL|function|idetape_flush_tape_buffers
r_static
r_int
id|idetape_flush_tape_buffers
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_pc_t
id|pc
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|idetape_create_write_filemark_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|idetape_wait_ready
c_func
(paren
id|drive
comma
l_int|60
op_star
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|idetape_create_read_position_cmd
r_static
r_void
id|idetape_create_read_position_cmd
(paren
id|idetape_pc_t
op_star
id|pc
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_READ_POSITION_CMD
suffix:semicolon
id|pc-&gt;request_transfer
op_assign
l_int|20
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_read_position_callback
suffix:semicolon
)brace
DECL|function|idetape_read_position
r_static
r_int
id|idetape_read_position
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_pc_t
id|pc
suffix:semicolon
r_int
id|position
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_read_position&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|idetape_create_read_position_cmd
c_func
(paren
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|position
op_assign
id|tape-&gt;first_frame_position
suffix:semicolon
r_return
id|position
suffix:semicolon
)brace
DECL|function|idetape_create_locate_cmd
r_static
r_void
id|idetape_create_locate_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pc_t
op_star
id|pc
comma
r_int
r_int
id|block
comma
id|u8
id|partition
comma
r_int
id|skip
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_LOCATE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|put_unaligned
c_func
(paren
id|htonl
c_func
(paren
id|block
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc-&gt;c
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|8
)braket
op_assign
id|partition
suffix:semicolon
id|set_bit
c_func
(paren
id|PC_WAIT_FOR_DSC
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
)brace
DECL|function|idetape_create_prevent_cmd
r_static
r_int
id|idetape_create_prevent_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pc_t
op_star
id|pc
comma
r_int
id|prevent
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;capabilities.lock
)paren
r_return
l_int|0
suffix:semicolon
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_PREVENT_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|prevent
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|__idetape_discard_read_pipeline
r_static
r_int
id|__idetape_discard_read_pipeline
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_ne
id|idetape_direction_read
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Remove merge stage. */
id|cnt
op_assign
id|tape-&gt;merge_stage_size
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|IDETAPE_FILEMARK
comma
op_amp
id|tape-&gt;flags
)paren
)paren
op_increment
id|cnt
suffix:semicolon
multiline_comment|/* Filemarks count as 1 sector */
id|tape-&gt;merge_stage_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_stage
op_ne
l_int|NULL
)paren
(brace
id|__idetape_kfree_stage
c_func
(paren
id|tape-&gt;merge_stage
)paren
suffix:semicolon
id|tape-&gt;merge_stage
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Clear pipeline flags. */
id|clear_bit
c_func
(paren
id|IDETAPE_PIPELINE_ERROR
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|tape-&gt;chrdev_direction
op_assign
id|idetape_direction_none
suffix:semicolon
multiline_comment|/* Remove pipeline stages. */
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
id|tape-&gt;next_stage
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|idetape_pipeline_active
c_func
(paren
id|tape
)paren
)paren
id|idetape_wait_for_request
c_func
(paren
id|drive
comma
id|tape-&gt;active_data_request
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tape-&gt;first_stage
op_ne
l_int|NULL
)paren
(brace
r_struct
id|request
op_star
id|rq_ptr
op_assign
op_amp
id|tape-&gt;first_stage-&gt;rq
suffix:semicolon
id|cnt
op_add_assign
id|rq_ptr-&gt;nr_sectors
op_minus
id|rq_ptr-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|rq_ptr-&gt;errors
op_eq
id|IDETAPE_ERROR_FILEMARK
)paren
op_increment
id|cnt
suffix:semicolon
id|idetape_remove_stage_head
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
id|tape-&gt;nr_pending_stages
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;max_stages
op_assign
id|tape-&gt;min_pipeline
suffix:semicolon
r_return
id|cnt
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_position_tape positions the tape to the requested block&n; *&t;using the LOCATE packet command. A READ POSITION command is then&n; *&t;issued to check where we are positioned.&n; *&n; *&t;Like all higher level operations, we queue the commands at the tail&n; *&t;of the request queue and wait for their completion.&n; *&t;&n; */
DECL|function|idetape_position_tape
r_static
r_int
id|idetape_position_tape
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|block
comma
id|u8
id|partition
comma
r_int
id|skip
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|idetape_pc_t
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_read
)paren
id|__idetape_discard_read_pipeline
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_wait_ready
c_func
(paren
id|drive
comma
l_int|60
op_star
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
id|idetape_create_locate_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
id|block
comma
id|partition
comma
id|skip
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|idetape_create_read_position_cmd
c_func
(paren
op_amp
id|pc
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
)brace
DECL|function|idetape_discard_read_pipeline
r_static
r_void
id|idetape_discard_read_pipeline
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|restore_position
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_int
id|seek
comma
id|position
suffix:semicolon
id|cnt
op_assign
id|__idetape_discard_read_pipeline
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|restore_position
)paren
(brace
id|position
op_assign
id|idetape_read_position
c_func
(paren
id|drive
)paren
suffix:semicolon
id|seek
op_assign
id|position
OG
id|cnt
ques
c_cond
id|position
op_minus
id|cnt
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|idetape_position_tape
c_func
(paren
id|drive
comma
id|seek
comma
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: %s: position_tape failed in discard_pipeline()&bslash;n&quot;
comma
id|tape-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * idetape_queue_rw_tail generates a read/write request for the block&n; * device interface and wait for it to be serviced.&n; */
DECL|function|idetape_queue_rw_tail
r_static
r_int
id|idetape_queue_rw_tail
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|cmd
comma
r_int
id|blocks
comma
r_struct
id|idetape_bh
op_star
id|bh
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|request
id|rq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: idetape_queue_rw_tail: cmd=%d&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|idetape_pipeline_active
c_func
(paren
id|tape
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bug: the pipeline is active in idetape_queue_rw_tail&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */&t;
id|idetape_init_rq
c_func
(paren
op_amp
id|rq
comma
id|cmd
)paren
suffix:semicolon
id|rq.special
op_assign
(paren
r_void
op_star
)paren
id|bh
suffix:semicolon
id|rq.sector
op_assign
id|tape-&gt;first_frame_position
suffix:semicolon
id|rq.nr_sectors
op_assign
id|rq.current_nr_sectors
op_assign
id|blocks
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_amp
(paren
id|REQ_IDETAPE_READ
op_or
id|REQ_IDETAPE_WRITE
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_stage
)paren
id|idetape_init_merge_stage
c_func
(paren
id|tape
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq.errors
op_eq
id|IDETAPE_ERROR_GENERAL
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
(paren
id|tape-&gt;tape_block_size
op_star
(paren
id|blocks
op_minus
id|rq.current_nr_sectors
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_insert_pipeline_into_queue is used to start servicing the&n; *&t;pipeline stages, starting from tape-&gt;next_stage.&n; */
DECL|function|idetape_insert_pipeline_into_queue
r_static
r_void
id|idetape_insert_pipeline_into_queue
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;next_stage
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idetape_pipeline_active
c_func
(paren
id|tape
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|IDETAPE_PIPELINE_ACTIVE
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|idetape_active_next_stage
c_func
(paren
id|drive
)paren
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
id|tape-&gt;active_data_request
comma
id|ide_end
)paren
suffix:semicolon
)brace
)brace
DECL|function|idetape_create_inquiry_cmd
r_static
r_void
id|idetape_create_inquiry_cmd
(paren
id|idetape_pc_t
op_star
id|pc
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_INQUIRY_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|pc-&gt;request_transfer
op_assign
l_int|254
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
)brace
DECL|function|idetape_create_rewind_cmd
r_static
r_void
id|idetape_create_rewind_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pc_t
op_star
id|pc
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_REWIND_CMD
suffix:semicolon
id|set_bit
c_func
(paren
id|PC_WAIT_FOR_DSC
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|idetape_create_mode_select_cmd
(paren
id|idetape_pc_t
op_star
id|pc
comma
r_int
id|length
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PC_WRITING
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_MODE_SELECT_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
id|put_unaligned
c_func
(paren
id|htons
c_func
(paren
id|length
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc-&gt;c
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|pc-&gt;request_transfer
op_assign
l_int|255
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
)brace
macro_line|#endif
DECL|function|idetape_create_erase_cmd
r_static
r_void
id|idetape_create_erase_cmd
(paren
id|idetape_pc_t
op_star
id|pc
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_ERASE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|set_bit
c_func
(paren
id|PC_WAIT_FOR_DSC
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
)brace
DECL|function|idetape_create_space_cmd
r_static
r_void
id|idetape_create_space_cmd
(paren
id|idetape_pc_t
op_star
id|pc
comma
r_int
id|count
comma
id|u8
id|cmd
)paren
(brace
id|idetape_init_pc
c_func
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_SPACE_CMD
suffix:semicolon
id|put_unaligned
c_func
(paren
id|htonl
c_func
(paren
id|count
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc-&gt;c
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
id|cmd
suffix:semicolon
id|set_bit
c_func
(paren
id|PC_WAIT_FOR_DSC
comma
op_amp
id|pc-&gt;flags
)paren
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
)brace
DECL|function|idetape_wait_first_stage
r_static
r_void
id|idetape_wait_first_stage
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_stage
op_eq
id|tape-&gt;first_stage
)paren
id|idetape_wait_for_request
c_func
(paren
id|drive
comma
id|tape-&gt;active_data_request
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_add_chrdev_write_request tries to add a character device&n; *&t;originated write request to our pipeline. In case we don&squot;t succeed,&n; *&t;we revert to non-pipelined operation mode for this request.&n; *&n; *&t;1.&t;Try to allocate a new pipeline stage.&n; *&t;2.&t;If we can&squot;t, wait for more and more requests to be serviced&n; *&t;&t;and try again each time.&n; *&t;3.&t;If we still can&squot;t allocate a stage, fallback to&n; *&t;&t;non-pipelined operation mode for this request.&n; */
DECL|function|idetape_add_chrdev_write_request
r_static
r_int
id|idetape_add_chrdev_write_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|blocks
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_stage_t
op_star
id|new_stage
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_add_chrdev_write_request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
multiline_comment|/*&n;     &t; *&t;Attempt to allocate a new stage.&n;&t; *&t;Pay special attention to possible race conditions.&n;&t; */
r_while
c_loop
(paren
(paren
id|new_stage
op_assign
id|idetape_kmalloc_stage
c_func
(paren
id|tape
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idetape_pipeline_active
c_func
(paren
id|tape
)paren
)paren
(brace
id|idetape_wait_for_request
c_func
(paren
id|drive
comma
id|tape-&gt;active_data_request
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
id|idetape_insert_pipeline_into_queue
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idetape_pipeline_active
c_func
(paren
id|tape
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Linux is short on memory. Fallback to&n;&t;&t;&t; *&t;non-pipelined operation mode for this request.&n;&t;&t;&t; */
r_return
id|idetape_queue_rw_tail
c_func
(paren
id|drive
comma
id|REQ_IDETAPE_WRITE
comma
id|blocks
comma
id|tape-&gt;merge_stage-&gt;bh
)paren
suffix:semicolon
)brace
)brace
id|rq
op_assign
op_amp
id|new_stage-&gt;rq
suffix:semicolon
id|idetape_init_rq
c_func
(paren
id|rq
comma
id|REQ_IDETAPE_WRITE
)paren
suffix:semicolon
multiline_comment|/* Doesn&squot;t actually matter - We always assume sequential access */
id|rq-&gt;sector
op_assign
id|tape-&gt;first_frame_position
suffix:semicolon
id|rq-&gt;nr_sectors
op_assign
id|rq-&gt;current_nr_sectors
op_assign
id|blocks
suffix:semicolon
id|idetape_switch_buffers
c_func
(paren
id|tape
comma
id|new_stage
)paren
suffix:semicolon
id|idetape_add_stage_tail
c_func
(paren
id|drive
comma
id|new_stage
)paren
suffix:semicolon
id|tape-&gt;pipeline_head
op_increment
suffix:semicolon
macro_line|#if USE_IOTRACE
id|IO_trace
c_func
(paren
id|IO_IDETAPE_FIFO
comma
id|tape-&gt;pipeline_head
comma
id|tape-&gt;buffer_head
comma
id|tape-&gt;tape_head
comma
id|tape-&gt;minor
)paren
suffix:semicolon
macro_line|#endif
id|calculate_speeds
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Estimate whether the tape has stopped writing by checking&n;&t; *&t;if our write pipeline is currently empty. If we are not&n;&t; *&t;writing anymore, wait for the pipeline to be full enough&n;&t; *&t;(90%) before starting to service requests, so that we will&n;&t; *&t;be able to keep up with the higher speeds of the tape.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|idetape_pipeline_active
c_func
(paren
id|tape
)paren
)paren
(brace
r_if
c_cond
(paren
id|tape-&gt;nr_stages
op_ge
id|tape-&gt;max_stages
op_star
l_int|9
op_div
l_int|10
op_logical_or
id|tape-&gt;nr_stages
op_ge
id|tape-&gt;max_stages
op_minus
id|tape-&gt;uncontrolled_pipeline_head_speed
op_star
l_int|3
op_star
l_int|1024
op_div
id|tape-&gt;tape_block_size
)paren
(brace
id|tape-&gt;measure_insert_time
op_assign
l_int|1
suffix:semicolon
id|tape-&gt;insert_time
op_assign
id|jiffies
suffix:semicolon
id|tape-&gt;insert_size
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;insert_speed
op_assign
l_int|0
suffix:semicolon
id|idetape_insert_pipeline_into_queue
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|IDETAPE_PIPELINE_ERROR
comma
op_amp
id|tape-&gt;flags
)paren
)paren
multiline_comment|/* Return a deferred error */
r_return
op_minus
id|EIO
suffix:semicolon
r_return
id|blocks
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_wait_for_pipeline will wait until all pending pipeline&n; *&t;requests are serviced. Typically called on device close.&n; */
DECL|function|idetape_wait_for_pipeline
r_static
r_void
id|idetape_wait_for_pipeline
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_while
c_loop
(paren
id|tape-&gt;next_stage
op_logical_or
id|idetape_pipeline_active
c_func
(paren
id|tape
)paren
)paren
(brace
id|idetape_insert_pipeline_into_queue
c_func
(paren
id|drive
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idetape_pipeline_active
c_func
(paren
id|tape
)paren
)paren
id|idetape_wait_for_request
c_func
(paren
id|drive
comma
id|tape-&gt;active_data_request
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|idetape_empty_write_pipeline
r_static
r_void
id|idetape_empty_write_pipeline
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|blocks
comma
id|min
suffix:semicolon
r_struct
id|idetape_bh
op_star
id|bh
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_ne
id|idetape_direction_write
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bug: Trying to empty write pipeline, but we are not writing.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;merge_stage_size
OG
id|tape-&gt;stage_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bug: merge_buffer too big&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;merge_stage_size
op_assign
id|tape-&gt;stage_size
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
r_if
c_cond
(paren
id|tape-&gt;merge_stage_size
)paren
(brace
id|blocks
op_assign
id|tape-&gt;merge_stage_size
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_stage_size
op_mod
id|tape-&gt;tape_block_size
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|blocks
op_increment
suffix:semicolon
id|i
op_assign
id|tape-&gt;tape_block_size
op_minus
id|tape-&gt;merge_stage_size
op_mod
id|tape-&gt;tape_block_size
suffix:semicolon
id|bh
op_assign
id|tape-&gt;bh-&gt;b_reqnext
suffix:semicolon
r_while
c_loop
(paren
id|bh
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
l_int|0
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
id|bh
op_assign
id|tape-&gt;bh
suffix:semicolon
r_while
c_loop
(paren
id|i
)paren
(brace
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: bug, bh NULL&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|min
op_assign
id|min
c_func
(paren
id|i
comma
(paren
r_int
r_int
)paren
(paren
id|bh-&gt;b_size
op_minus
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bh-&gt;b_data
op_plus
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
comma
l_int|0
comma
id|min
)paren
suffix:semicolon
id|atomic_add
c_func
(paren
id|min
comma
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|i
op_sub_assign
id|min
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
)brace
(paren
r_void
)paren
id|idetape_add_chrdev_write_request
c_func
(paren
id|drive
comma
id|blocks
)paren
suffix:semicolon
id|tape-&gt;merge_stage_size
op_assign
l_int|0
suffix:semicolon
)brace
id|idetape_wait_for_pipeline
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_stage
op_ne
l_int|NULL
)paren
(brace
id|__idetape_kfree_stage
c_func
(paren
id|tape-&gt;merge_stage
)paren
suffix:semicolon
id|tape-&gt;merge_stage
op_assign
l_int|NULL
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|IDETAPE_PIPELINE_ERROR
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|tape-&gt;chrdev_direction
op_assign
id|idetape_direction_none
suffix:semicolon
multiline_comment|/*&n;&t; *&t;On the next backup, perform the feedback loop again.&n;&t; *&t;(I don&squot;t want to keep sense information between backups,&n;&t; *&t; as some systems are constantly on, and the system load&n;&t; *&t; can be totally different on the next backup).&n;&t; */
id|tape-&gt;max_stages
op_assign
id|tape-&gt;min_pipeline
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_ne
l_int|NULL
op_logical_or
id|tape-&gt;next_stage
op_ne
l_int|NULL
op_logical_or
id|tape-&gt;last_stage
op_ne
l_int|NULL
op_logical_or
id|tape-&gt;nr_stages
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: ide-tape pipeline bug, &quot;
l_string|&quot;first_stage %p, next_stage %p, &quot;
l_string|&quot;last_stage %p, nr_stages %d&bslash;n&quot;
comma
id|tape-&gt;first_stage
comma
id|tape-&gt;next_stage
comma
id|tape-&gt;last_stage
comma
id|tape-&gt;nr_stages
)paren
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
)brace
DECL|function|idetape_restart_speed_control
r_static
r_void
id|idetape_restart_speed_control
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|tape-&gt;restart_speed_control_req
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;pipeline_head
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;controlled_last_pipeline_head
op_assign
id|tape-&gt;uncontrolled_last_pipeline_head
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;controlled_previous_pipeline_head
op_assign
id|tape-&gt;uncontrolled_previous_pipeline_head
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;pipeline_head_speed
op_assign
id|tape-&gt;controlled_pipeline_head_speed
op_assign
l_int|5000
suffix:semicolon
id|tape-&gt;uncontrolled_pipeline_head_speed
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;controlled_pipeline_head_time
op_assign
id|tape-&gt;uncontrolled_pipeline_head_time
op_assign
id|jiffies
suffix:semicolon
id|tape-&gt;controlled_previous_head_time
op_assign
id|tape-&gt;uncontrolled_previous_head_time
op_assign
id|jiffies
suffix:semicolon
)brace
DECL|function|idetape_initiate_read
r_static
r_int
id|idetape_initiate_read
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|max_stages
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_stage_t
op_star
id|new_stage
suffix:semicolon
r_struct
id|request
id|rq
suffix:semicolon
r_int
id|bytes_read
suffix:semicolon
r_int
id|blocks
op_assign
id|tape-&gt;capabilities.ctl
suffix:semicolon
multiline_comment|/* Initialize read operation */
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_ne
id|idetape_direction_read
)paren
(brace
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_write
)paren
(brace
id|idetape_empty_write_pipeline
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_flush_tape_buffers
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;merge_stage
op_logical_or
id|tape-&gt;merge_stage_size
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;ide-tape: merge_stage_size should be 0 now&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;merge_stage_size
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
r_if
c_cond
(paren
(paren
id|tape-&gt;merge_stage
op_assign
id|__idetape_kmalloc_stage
c_func
(paren
id|tape
comma
l_int|0
comma
l_int|0
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|tape-&gt;chrdev_direction
op_assign
id|idetape_direction_read
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Issue a read 0 command to ensure that DSC handshake&n;&t;&t; *&t;is switched from completion mode to buffer available&n;&t;&t; *&t;mode.&n;&t;&t; *&t;No point in issuing this if DSC overlap isn&squot;t supported,&n;&t;&t; *&t;some drives (Seagate STT3401A) will return an error.&n;&t;&t; */
r_if
c_cond
(paren
id|drive-&gt;dsc_overlap
)paren
(brace
id|bytes_read
op_assign
id|idetape_queue_rw_tail
c_func
(paren
id|drive
comma
id|REQ_IDETAPE_READ
comma
l_int|0
comma
id|tape-&gt;merge_stage-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes_read
OL
l_int|0
)paren
(brace
id|__idetape_kfree_stage
c_func
(paren
id|tape-&gt;merge_stage
)paren
suffix:semicolon
id|tape-&gt;merge_stage
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;chrdev_direction
op_assign
id|idetape_direction_none
suffix:semicolon
r_return
id|bytes_read
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|tape-&gt;restart_speed_control_req
)paren
id|idetape_restart_speed_control
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_init_rq
c_func
(paren
op_amp
id|rq
comma
id|REQ_IDETAPE_READ
)paren
suffix:semicolon
id|rq.sector
op_assign
id|tape-&gt;first_frame_position
suffix:semicolon
id|rq.nr_sectors
op_assign
id|rq.current_nr_sectors
op_assign
id|blocks
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|IDETAPE_PIPELINE_ERROR
comma
op_amp
id|tape-&gt;flags
)paren
op_logical_and
id|tape-&gt;nr_stages
OL
id|max_stages
)paren
(brace
id|new_stage
op_assign
id|idetape_kmalloc_stage
c_func
(paren
id|tape
)paren
suffix:semicolon
r_while
c_loop
(paren
id|new_stage
op_ne
l_int|NULL
)paren
(brace
id|new_stage-&gt;rq
op_assign
id|rq
suffix:semicolon
id|idetape_add_stage_tail
c_func
(paren
id|drive
comma
id|new_stage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;nr_stages
op_ge
id|max_stages
)paren
r_break
suffix:semicolon
id|new_stage
op_assign
id|idetape_kmalloc_stage
c_func
(paren
id|tape
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|idetape_pipeline_active
c_func
(paren
id|tape
)paren
)paren
(brace
r_if
c_cond
(paren
id|tape-&gt;nr_pending_stages
op_ge
l_int|3
op_star
id|max_stages
op_div
l_int|4
)paren
(brace
id|tape-&gt;measure_insert_time
op_assign
l_int|1
suffix:semicolon
id|tape-&gt;insert_time
op_assign
id|jiffies
suffix:semicolon
id|tape-&gt;insert_size
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;insert_speed
op_assign
l_int|0
suffix:semicolon
id|idetape_insert_pipeline_into_queue
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_add_chrdev_read_request is called from idetape_chrdev_read&n; *&t;to service a character device read request and add read-ahead&n; *&t;requests to our pipeline.&n; */
DECL|function|idetape_add_chrdev_read_request
r_static
r_int
id|idetape_add_chrdev_read_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|blocks
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|rq_ptr
suffix:semicolon
r_int
id|bytes_read
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_add_chrdev_read_request, %d blocks&bslash;n&quot;
comma
id|blocks
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
multiline_comment|/*&n;&t; * If we are at a filemark, return a read length of 0&n;&t; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDETAPE_FILEMARK
comma
op_amp
id|tape-&gt;flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for the next block to be available at the head&n;&t; * of the pipeline&n;&t; */
id|idetape_initiate_read
c_func
(paren
id|drive
comma
id|tape-&gt;max_stages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDETAPE_PIPELINE_ERROR
comma
op_amp
id|tape-&gt;flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|idetape_queue_rw_tail
c_func
(paren
id|drive
comma
id|REQ_IDETAPE_READ
comma
id|blocks
comma
id|tape-&gt;merge_stage-&gt;bh
)paren
suffix:semicolon
)brace
id|idetape_wait_first_stage
c_func
(paren
id|drive
)paren
suffix:semicolon
id|rq_ptr
op_assign
op_amp
id|tape-&gt;first_stage-&gt;rq
suffix:semicolon
id|bytes_read
op_assign
id|tape-&gt;tape_block_size
op_star
(paren
id|rq_ptr-&gt;nr_sectors
op_minus
id|rq_ptr-&gt;current_nr_sectors
)paren
suffix:semicolon
id|rq_ptr-&gt;nr_sectors
op_assign
id|rq_ptr-&gt;current_nr_sectors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rq_ptr-&gt;errors
op_eq
id|IDETAPE_ERROR_EOD
)paren
r_return
l_int|0
suffix:semicolon
r_else
(brace
id|idetape_switch_buffers
c_func
(paren
id|tape
comma
id|tape-&gt;first_stage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq_ptr-&gt;errors
op_eq
id|IDETAPE_ERROR_FILEMARK
)paren
id|set_bit
c_func
(paren
id|IDETAPE_FILEMARK
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
id|idetape_remove_stage_head
c_func
(paren
id|drive
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
id|tape-&gt;pipeline_head
op_increment
suffix:semicolon
macro_line|#if USE_IOTRACE
id|IO_trace
c_func
(paren
id|IO_IDETAPE_FIFO
comma
id|tape-&gt;pipeline_head
comma
id|tape-&gt;buffer_head
comma
id|tape-&gt;tape_head
comma
id|tape-&gt;minor
)paren
suffix:semicolon
macro_line|#endif
id|calculate_speeds
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|bytes_read
OG
id|blocks
op_star
id|tape-&gt;tape_block_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bug: trying to return more bytes than requested&bslash;n&quot;
)paren
suffix:semicolon
id|bytes_read
op_assign
id|blocks
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
r_return
(paren
id|bytes_read
)paren
suffix:semicolon
)brace
DECL|function|idetape_pad_zeros
r_static
r_void
id|idetape_pad_zeros
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|bcount
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|idetape_bh
op_star
id|bh
suffix:semicolon
r_int
id|blocks
suffix:semicolon
r_while
c_loop
(paren
id|bcount
)paren
(brace
r_int
r_int
id|count
suffix:semicolon
id|bh
op_assign
id|tape-&gt;merge_stage-&gt;bh
suffix:semicolon
id|count
op_assign
id|min
c_func
(paren
id|tape-&gt;stage_size
comma
id|bcount
)paren
suffix:semicolon
id|bcount
op_sub_assign
id|count
suffix:semicolon
id|blocks
op_assign
id|count
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
id|min
c_func
(paren
id|count
comma
(paren
r_int
r_int
)paren
id|bh-&gt;b_size
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bh-&gt;b_data
comma
l_int|0
comma
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
)paren
suffix:semicolon
id|count
op_sub_assign
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
id|idetape_queue_rw_tail
c_func
(paren
id|drive
comma
id|REQ_IDETAPE_WRITE
comma
id|blocks
comma
id|tape-&gt;merge_stage-&gt;bh
)paren
suffix:semicolon
)brace
)brace
DECL|function|idetape_pipeline_size
r_static
r_int
id|idetape_pipeline_size
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_stage_t
op_star
id|stage
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_int
id|size
op_assign
l_int|0
suffix:semicolon
id|idetape_wait_for_pipeline
c_func
(paren
id|drive
)paren
suffix:semicolon
id|stage
op_assign
id|tape-&gt;first_stage
suffix:semicolon
r_while
c_loop
(paren
id|stage
op_ne
l_int|NULL
)paren
(brace
id|rq
op_assign
op_amp
id|stage-&gt;rq
suffix:semicolon
id|size
op_add_assign
id|tape-&gt;tape_block_size
op_star
(paren
id|rq-&gt;nr_sectors
op_minus
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;errors
op_eq
id|IDETAPE_ERROR_FILEMARK
)paren
id|size
op_add_assign
id|tape-&gt;tape_block_size
suffix:semicolon
id|stage
op_assign
id|stage-&gt;next
suffix:semicolon
)brace
id|size
op_add_assign
id|tape-&gt;merge_stage_size
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Rewinds the tape to the Beginning Of the current Partition (BOP).&n; *&n; *&t;We currently support only one partition.&n; */
DECL|function|idetape_rewind_tape
r_static
r_int
id|idetape_rewind_tape
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|retval
suffix:semicolon
id|idetape_pc_t
id|pc
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_rewind_tape&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */&t;
id|idetape_create_rewind_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|idetape_create_read_position_cmd
c_func
(paren
op_amp
id|pc
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Our special ide-tape ioctl&squot;s.&n; *&n; *&t;Currently there aren&squot;t any ioctl&squot;s.&n; *&t;mtio.h compatible commands should be issued to the character device&n; *&t;interface.&n; */
DECL|function|idetape_blkdev_ioctl
r_static
r_int
id|idetape_blkdev_ioctl
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_config_t
id|config
suffix:semicolon
r_void
id|__user
op_star
id|argp
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG&t;
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_blkdev_ioctl&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_int|0x0340
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|config
comma
id|argp
comma
r_sizeof
(paren
id|idetape_config_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|tape-&gt;best_dsc_rw_frequency
op_assign
id|config.dsc_rw_frequency
suffix:semicolon
id|tape-&gt;max_stages
op_assign
id|config.nr_stages
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0350
suffix:colon
id|config.dsc_rw_frequency
op_assign
(paren
r_int
)paren
id|tape-&gt;best_dsc_rw_frequency
suffix:semicolon
id|config.nr_stages
op_assign
id|tape-&gt;max_stages
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|argp
comma
op_amp
id|config
comma
r_sizeof
(paren
id|idetape_config_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_pre_reset is called before an ATAPI/ATA software reset.&n; */
DECL|function|idetape_pre_reset
r_static
r_void
id|idetape_pre_reset
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|tape
op_ne
l_int|NULL
)paren
id|set_bit
c_func
(paren
id|IDETAPE_IGNORE_DSC
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_space_over_filemarks is now a bit more complicated than just&n; *&t;passing the command to the tape since we may have crossed some&n; *&t;filemarks during our pipelined read-ahead mode.&n; *&n; *&t;As a minor side effect, the pipeline enables us to support MTFSFM when&n; *&t;the filemark is in our internal pipeline even if the tape doesn&squot;t&n; *&t;support spacing over filemarks in the reverse direction.&n; */
DECL|function|idetape_space_over_filemarks
r_static
r_int
id|idetape_space_over_filemarks
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|mt_op
comma
r_int
id|mt_count
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_pc_t
id|pc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mt_count
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|MTBSF
op_eq
id|mt_op
op_logical_or
id|MTBSFM
op_eq
id|mt_op
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;capabilities.sprev
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|mt_count
op_assign
op_minus
id|mt_count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_read
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We have a read-ahead buffer. Scan it for crossed&n;&t;&t; *&t;filemarks.&n;&t;&t; */
id|tape-&gt;merge_stage_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|IDETAPE_FILEMARK
comma
op_amp
id|tape-&gt;flags
)paren
)paren
op_increment
id|count
suffix:semicolon
r_while
c_loop
(paren
id|tape-&gt;first_stage
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|count
op_eq
id|mt_count
)paren
(brace
r_if
c_cond
(paren
id|mt_op
op_eq
id|MTFSFM
)paren
id|set_bit
c_func
(paren
id|IDETAPE_FILEMARK
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
id|tape-&gt;active_stage
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;We have reached the active stage in the read pipeline.&n;&t;&t;&t;&t; *&t;There is no point in allowing the drive to continue&n;&t;&t;&t;&t; *&t;reading any farther, so we stop the pipeline.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; *&t;This section should be moved to a separate subroutine,&n;&t;&t;&t;&t; *&t;because a similar function is performed in&n;&t;&t;&t;&t; *&t;__idetape_discard_read_pipeline(), for example.&n;&t;&t;&t;&t; */
id|tape-&gt;next_stage
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
id|idetape_wait_first_stage
c_func
(paren
id|drive
)paren
suffix:semicolon
id|tape-&gt;next_stage
op_assign
id|tape-&gt;first_stage-&gt;next
suffix:semicolon
)brace
r_else
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tape-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage-&gt;rq.errors
op_eq
id|IDETAPE_ERROR_FILEMARK
)paren
op_increment
id|count
suffix:semicolon
id|idetape_remove_stage_head
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
id|idetape_discard_read_pipeline
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;The filemark was not found in our internal pipeline.&n;&t; *&t;Now we can issue the space command.&n;&t; */
r_switch
c_cond
(paren
id|mt_op
)paren
(brace
r_case
id|MTFSF
suffix:colon
r_case
id|MTBSF
suffix:colon
id|idetape_create_space_cmd
c_func
(paren
op_amp
id|pc
comma
id|mt_count
op_minus
id|count
comma
id|IDETAPE_SPACE_OVER_FILEMARK
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTFSFM
suffix:colon
r_case
id|MTBSFM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;capabilities.sprev
)paren
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_space_over_filemarks
c_func
(paren
id|drive
comma
id|MTFSF
comma
id|mt_count
op_minus
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|count
op_assign
(paren
id|MTBSFM
op_eq
id|mt_op
ques
c_cond
l_int|1
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
r_return
(paren
id|idetape_space_over_filemarks
c_func
(paren
id|drive
comma
id|MTFSF
comma
id|count
)paren
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: MTIO operation %d not supported&bslash;n&quot;
comma
id|mt_op
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Our character device read / write functions.&n; *&n; *&t;The tape is optimized to maximize throughput when it is transferring&n; *&t;an integral number of the &quot;continuous transfer limit&quot;, which is&n; *&t;a parameter of the specific tape (26 KB on my particular tape).&n; *      (32 kB for Onstream)&n; *&n; *&t;As of version 1.3 of the driver, the character device provides an&n; *&t;abstract continuous view of the media - any mix of block sizes (even 1&n; *&t;byte) on the same backup/restore procedure is supported. The driver&n; *&t;will internally convert the requests to the recommended transfer unit,&n; *&t;so that an unmatch between the user&squot;s block size to the recommended&n; *&t;size will only result in a (slightly) increased driver overhead, but&n; *&t;will no longer hit performance.&n; *      This is not applicable to Onstream.&n; */
DECL|function|idetape_chrdev_read
r_static
id|ssize_t
id|idetape_chrdev_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|file-&gt;private_data
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|ssize_t
id|bytes_read
comma
id|temp
comma
id|actually_read
op_assign
l_int|0
comma
id|rc
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_chrdev_read, count %Zd&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_ne
id|idetape_direction_read
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDETAPE_DETECT_BS
comma
op_amp
id|tape-&gt;flags
)paren
)paren
r_if
c_cond
(paren
id|count
OG
id|tape-&gt;tape_block_size
op_logical_and
(paren
id|count
op_mod
id|tape-&gt;tape_block_size
)paren
op_eq
l_int|0
)paren
id|tape-&gt;user_bs_factor
op_assign
id|count
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|idetape_initiate_read
c_func
(paren
id|drive
comma
id|tape-&gt;max_stages
)paren
)paren
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_stage_size
)paren
(brace
id|actually_read
op_assign
id|min
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|tape-&gt;merge_stage_size
)paren
comma
(paren
r_int
r_int
)paren
id|count
)paren
suffix:semicolon
id|idetape_copy_stage_to_user
c_func
(paren
id|tape
comma
id|buf
comma
id|tape-&gt;merge_stage
comma
id|actually_read
)paren
suffix:semicolon
id|buf
op_add_assign
id|actually_read
suffix:semicolon
id|tape-&gt;merge_stage_size
op_sub_assign
id|actually_read
suffix:semicolon
id|count
op_sub_assign
id|actually_read
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_ge
id|tape-&gt;stage_size
)paren
(brace
id|bytes_read
op_assign
id|idetape_add_chrdev_read_request
c_func
(paren
id|drive
comma
id|tape-&gt;capabilities.ctl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes_read
op_le
l_int|0
)paren
r_goto
id|finish
suffix:semicolon
id|idetape_copy_stage_to_user
c_func
(paren
id|tape
comma
id|buf
comma
id|tape-&gt;merge_stage
comma
id|bytes_read
)paren
suffix:semicolon
id|buf
op_add_assign
id|bytes_read
suffix:semicolon
id|count
op_sub_assign
id|bytes_read
suffix:semicolon
id|actually_read
op_add_assign
id|bytes_read
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
id|bytes_read
op_assign
id|idetape_add_chrdev_read_request
c_func
(paren
id|drive
comma
id|tape-&gt;capabilities.ctl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes_read
op_le
l_int|0
)paren
r_goto
id|finish
suffix:semicolon
id|temp
op_assign
id|min
c_func
(paren
(paren
r_int
r_int
)paren
id|count
comma
(paren
r_int
r_int
)paren
id|bytes_read
)paren
suffix:semicolon
id|idetape_copy_stage_to_user
c_func
(paren
id|tape
comma
id|buf
comma
id|tape-&gt;merge_stage
comma
id|temp
)paren
suffix:semicolon
id|actually_read
op_add_assign
id|temp
suffix:semicolon
id|tape-&gt;merge_stage_size
op_assign
id|bytes_read
op_minus
id|temp
suffix:semicolon
)brace
id|finish
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|actually_read
op_logical_and
id|test_bit
c_func
(paren
id|IDETAPE_FILEMARK
comma
op_amp
id|tape-&gt;flags
)paren
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: %s: spacing over filemark&bslash;n&quot;
comma
id|tape-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|idetape_space_over_filemarks
c_func
(paren
id|drive
comma
id|MTFSF
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|actually_read
suffix:semicolon
)brace
DECL|function|idetape_chrdev_write
r_static
id|ssize_t
id|idetape_chrdev_write
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|file-&gt;private_data
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|ssize_t
id|retval
comma
id|actually_written
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The drive is write protected. */
r_if
c_cond
(paren
id|tape-&gt;write_prot
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_chrdev_write, &quot;
l_string|&quot;count %Zd&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
multiline_comment|/* Initialize write operation */
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_ne
id|idetape_direction_write
)paren
(brace
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_read
)paren
id|idetape_discard_read_pipeline
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;merge_stage
op_logical_or
id|tape-&gt;merge_stage_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: merge_stage_size &quot;
l_string|&quot;should be 0 now&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;merge_stage_size
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
r_if
c_cond
(paren
(paren
id|tape-&gt;merge_stage
op_assign
id|__idetape_kmalloc_stage
c_func
(paren
id|tape
comma
l_int|0
comma
l_int|0
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|tape-&gt;chrdev_direction
op_assign
id|idetape_direction_write
suffix:semicolon
id|idetape_init_merge_stage
c_func
(paren
id|tape
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Issue a write 0 command to ensure that DSC handshake&n;&t;&t; *&t;is switched from completion mode to buffer available&n;&t;&t; *&t;mode.&n;&t;&t; *&t;No point in issuing this if DSC overlap isn&squot;t supported,&n;&t;&t; *&t;some drives (Seagate STT3401A) will return an error.&n;&t;&t; */
r_if
c_cond
(paren
id|drive-&gt;dsc_overlap
)paren
(brace
id|retval
op_assign
id|idetape_queue_rw_tail
c_func
(paren
id|drive
comma
id|REQ_IDETAPE_WRITE
comma
l_int|0
comma
id|tape-&gt;merge_stage-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|__idetape_kfree_stage
c_func
(paren
id|tape-&gt;merge_stage
)paren
suffix:semicolon
id|tape-&gt;merge_stage
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;chrdev_direction
op_assign
id|idetape_direction_none
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;restart_speed_control_req
)paren
id|idetape_restart_speed_control
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_stage_size
)paren
(brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;merge_stage_size
op_ge
id|tape-&gt;stage_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: bug: merge buffer too big&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;merge_stage_size
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|actually_written
op_assign
id|min
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|tape-&gt;stage_size
op_minus
id|tape-&gt;merge_stage_size
)paren
comma
(paren
r_int
r_int
)paren
id|count
)paren
suffix:semicolon
id|idetape_copy_stage_from_user
c_func
(paren
id|tape
comma
id|tape-&gt;merge_stage
comma
id|buf
comma
id|actually_written
)paren
suffix:semicolon
id|buf
op_add_assign
id|actually_written
suffix:semicolon
id|tape-&gt;merge_stage_size
op_add_assign
id|actually_written
suffix:semicolon
id|count
op_sub_assign
id|actually_written
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_stage_size
op_eq
id|tape-&gt;stage_size
)paren
(brace
id|tape-&gt;merge_stage_size
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
id|idetape_add_chrdev_write_request
c_func
(paren
id|drive
comma
id|tape-&gt;capabilities.ctl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_le
l_int|0
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|count
op_ge
id|tape-&gt;stage_size
)paren
(brace
id|idetape_copy_stage_from_user
c_func
(paren
id|tape
comma
id|tape-&gt;merge_stage
comma
id|buf
comma
id|tape-&gt;stage_size
)paren
suffix:semicolon
id|buf
op_add_assign
id|tape-&gt;stage_size
suffix:semicolon
id|count
op_sub_assign
id|tape-&gt;stage_size
suffix:semicolon
id|retval
op_assign
id|idetape_add_chrdev_write_request
c_func
(paren
id|drive
comma
id|tape-&gt;capabilities.ctl
)paren
suffix:semicolon
id|actually_written
op_add_assign
id|tape-&gt;stage_size
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_le
l_int|0
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
id|actually_written
op_add_assign
id|count
suffix:semicolon
id|idetape_copy_stage_from_user
c_func
(paren
id|tape
comma
id|tape-&gt;merge_stage
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|tape-&gt;merge_stage_size
op_add_assign
id|count
suffix:semicolon
)brace
r_return
(paren
id|actually_written
)paren
suffix:semicolon
)brace
DECL|function|idetape_write_filemark
r_static
r_int
id|idetape_write_filemark
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_pc_t
id|pc
suffix:semicolon
multiline_comment|/* Write a filemark */
id|idetape_create_write_filemark_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: Couldn&squot;t write a filemark&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_mtioctop is called from idetape_chrdev_ioctl when&n; *&t;the general mtio MTIOCTOP ioctl is requested.&n; *&n; *&t;We currently support the following mtio.h operations:&n; *&n; *&t;MTFSF&t;-&t;Space over mt_count filemarks in the positive direction.&n; *&t;&t;&t;The tape is positioned after the last spaced filemark.&n; *&n; *&t;MTFSFM&t;-&t;Same as MTFSF, but the tape is positioned before the&n; *&t;&t;&t;last filemark.&n; *&n; *&t;MTBSF&t;-&t;Steps background over mt_count filemarks, tape is&n; *&t;&t;&t;positioned before the last filemark.&n; *&n; *&t;MTBSFM&t;-&t;Like MTBSF, only tape is positioned after the last filemark.&n; *&n; *&t;Note:&n; *&n; *&t;&t;MTBSF and MTBSFM are not supported when the tape doesn&squot;t&n; *&t;&t;support spacing over filemarks in the reverse direction.&n; *&t;&t;In this case, MTFSFM is also usually not supported (it is&n; *&t;&t;supported in the rare case in which we crossed the filemark&n; *&t;&t;during our read-ahead pipelined operation mode).&n; *&t;&t;&n; *&t;MTWEOF&t;-&t;Writes mt_count filemarks. Tape is positioned after&n; *&t;&t;&t;the last written filemark.&n; *&n; *&t;MTREW&t;-&t;Rewinds tape.&n; *&n; *&t;MTLOAD&t;-&t;Loads the tape.&n; *&n; *&t;MTOFFL&t;-&t;Puts the tape drive &quot;Offline&quot;: Rewinds the tape and&n; *&t;MTUNLOAD&t;prevents further access until the media is replaced.&n; *&n; *&t;MTNOP&t;-&t;Flushes tape buffers.&n; *&n; *&t;MTRETEN&t;-&t;Retension media. This typically consists of one end&n; *&t;&t;&t;to end pass on the media.&n; *&n; *&t;MTEOM&t;-&t;Moves to the end of recorded data.&n; *&n; *&t;MTERASE&t;-&t;Erases tape.&n; *&n; *&t;MTSETBLK - &t;Sets the user block size to mt_count bytes. If&n; *&t;&t;&t;mt_count is 0, we will attempt to autodetect&n; *&t;&t;&t;the block size.&n; *&n; *&t;MTSEEK&t;-&t;Positions the tape in a specific block number, where&n; *&t;&t;&t;each block is assumed to contain which user_block_size&n; *&t;&t;&t;bytes.&n; *&n; *&t;MTSETPART - &t;Switches to another tape partition.&n; *&n; *&t;MTLOCK - &t;Locks the tape door.&n; *&n; *&t;MTUNLOCK - &t;Unlocks the tape door.&n; *&n; *&t;The following commands are currently not supported:&n; *&n; *&t;MTFSS, MTBSS, MTWSM, MTSETDENSITY,&n; *&t;MTSETDRVBUFFER, MT_ST_BOOLEANS, MT_ST_WRITE_THRESHOLD.&n; */
DECL|function|idetape_mtioctop
r_static
r_int
id|idetape_mtioctop
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|mt_op
comma
r_int
id|mt_count
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_pc_t
id|pc
suffix:semicolon
r_int
id|i
comma
id|retval
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Handling MTIOCTOP ioctl: &quot;
l_string|&quot;mt_op=%d, mt_count=%d&bslash;n&quot;
comma
id|mt_op
comma
id|mt_count
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
multiline_comment|/*&n;&t; *&t;Commands which need our pipelined read-ahead stages.&n;&t; */
r_switch
c_cond
(paren
id|mt_op
)paren
(brace
r_case
id|MTFSF
suffix:colon
r_case
id|MTFSFM
suffix:colon
r_case
id|MTBSF
suffix:colon
r_case
id|MTBSFM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|mt_count
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|idetape_space_over_filemarks
c_func
(paren
id|drive
comma
id|mt_op
comma
id|mt_count
)paren
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|mt_op
)paren
(brace
r_case
id|MTWEOF
suffix:colon
r_if
c_cond
(paren
id|tape-&gt;write_prot
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|idetape_discard_read_pipeline
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mt_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|retval
op_assign
id|idetape_write_filemark
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|MTREW
suffix:colon
id|idetape_discard_read_pipeline
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idetape_rewind_tape
c_func
(paren
id|drive
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|MTLOAD
suffix:colon
id|idetape_discard_read_pipeline
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|idetape_create_load_unload_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
id|IDETAPE_LU_LOAD_MASK
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTUNLOAD
suffix:colon
r_case
id|MTOFFL
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * If door is locked, attempt to unlock before&n;&t;&t;&t; * attempting to eject.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|tape-&gt;door_locked
)paren
(brace
r_if
c_cond
(paren
id|idetape_create_prevent_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
l_int|0
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
id|tape-&gt;door_locked
op_assign
id|DOOR_UNLOCKED
suffix:semicolon
)brace
id|idetape_discard_read_pipeline
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|idetape_create_load_unload_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
op_logical_neg
id|IDETAPE_LU_LOAD_MASK
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|clear_bit
c_func
(paren
id|IDETAPE_MEDIUM_PRESENT
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
r_case
id|MTNOP
suffix:colon
id|idetape_discard_read_pipeline
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|idetape_flush_tape_buffers
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_case
id|MTRETEN
suffix:colon
id|idetape_discard_read_pipeline
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|idetape_create_load_unload_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
id|IDETAPE_LU_RETENSION_MASK
op_or
id|IDETAPE_LU_LOAD_MASK
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTEOM
suffix:colon
id|idetape_create_space_cmd
c_func
(paren
op_amp
id|pc
comma
l_int|0
comma
id|IDETAPE_SPACE_TO_EOD
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTERASE
suffix:colon
(paren
r_void
)paren
id|idetape_rewind_tape
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_create_erase_cmd
c_func
(paren
op_amp
id|pc
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTSETBLK
suffix:colon
r_if
c_cond
(paren
id|mt_count
)paren
(brace
r_if
c_cond
(paren
id|mt_count
OL
id|tape-&gt;tape_block_size
op_logical_or
id|mt_count
op_mod
id|tape-&gt;tape_block_size
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|tape-&gt;user_bs_factor
op_assign
id|mt_count
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
id|clear_bit
c_func
(paren
id|IDETAPE_DETECT_BS
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
)brace
r_else
id|set_bit
c_func
(paren
id|IDETAPE_DETECT_BS
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|MTSEEK
suffix:colon
id|idetape_discard_read_pipeline
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_return
id|idetape_position_tape
c_func
(paren
id|drive
comma
id|mt_count
op_star
id|tape-&gt;user_bs_factor
comma
id|tape-&gt;partition
comma
l_int|0
)paren
suffix:semicolon
r_case
id|MTSETPART
suffix:colon
id|idetape_discard_read_pipeline
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|idetape_position_tape
c_func
(paren
id|drive
comma
l_int|0
comma
id|mt_count
comma
l_int|0
)paren
)paren
suffix:semicolon
r_case
id|MTFSR
suffix:colon
r_case
id|MTBSR
suffix:colon
r_case
id|MTLOCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|idetape_create_prevent_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|tape-&gt;door_locked
op_assign
id|DOOR_EXPLICITLY_LOCKED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|MTUNLOCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|idetape_create_prevent_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|tape-&gt;door_locked
op_assign
id|DOOR_UNLOCKED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: MTIO operation %d not &quot;
l_string|&quot;supported&bslash;n&quot;
comma
id|mt_op
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Our character device ioctls.&n; *&n; *&t;General mtio.h magnetic io commands are supported here, and not in&n; *&t;the corresponding block interface.&n; *&n; *&t;The following ioctls are supported:&n; *&n; *&t;MTIOCTOP -&t;Refer to idetape_mtioctop for detailed description.&n; *&n; *&t;MTIOCGET - &t;The mt_dsreg field in the returned mtget structure&n; *&t;&t;&t;will be set to (user block size in bytes &lt;&lt;&n; *&t;&t;&t;MT_ST_BLKSIZE_SHIFT) &amp; MT_ST_BLKSIZE_MASK.&n; *&n; *&t;&t;&t;The mt_blkno is set to the current user block number.&n; *&t;&t;&t;The other mtget fields are not supported.&n; *&n; *&t;MTIOCPOS -&t;The current tape &quot;block position&quot; is returned. We&n; *&t;&t;&t;assume that each block contains user_block_size&n; *&t;&t;&t;bytes.&n; *&n; *&t;Our own ide-tape ioctls are supported on both interfaces.&n; */
DECL|function|idetape_chrdev_ioctl
r_static
r_int
id|idetape_chrdev_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|file-&gt;private_data
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|mtop
id|mtop
suffix:semicolon
r_struct
id|mtget
id|mtget
suffix:semicolon
r_struct
id|mtpos
id|mtpos
suffix:semicolon
r_int
id|block_offset
op_assign
l_int|0
comma
id|position
op_assign
id|tape-&gt;first_frame_position
suffix:semicolon
r_void
id|__user
op_star
id|argp
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_chrdev_ioctl, &quot;
l_string|&quot;cmd=%u&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|tape-&gt;restart_speed_control_req
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_write
)paren
(brace
id|idetape_empty_write_pipeline
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_flush_tape_buffers
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|MTIOCGET
op_logical_or
id|cmd
op_eq
id|MTIOCPOS
)paren
(brace
id|block_offset
op_assign
id|idetape_pipeline_size
c_func
(paren
id|drive
)paren
op_div
(paren
id|tape-&gt;tape_block_size
op_star
id|tape-&gt;user_bs_factor
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|position
op_assign
id|idetape_read_position
c_func
(paren
id|drive
)paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|MTIOCTOP
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|mtop
comma
id|argp
comma
r_sizeof
(paren
r_struct
id|mtop
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
(paren
id|idetape_mtioctop
c_func
(paren
id|drive
comma
id|mtop.mt_op
comma
id|mtop.mt_count
)paren
)paren
suffix:semicolon
r_case
id|MTIOCGET
suffix:colon
id|memset
c_func
(paren
op_amp
id|mtget
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mtget
)paren
)paren
suffix:semicolon
id|mtget.mt_type
op_assign
id|MT_ISSCSI2
suffix:semicolon
id|mtget.mt_blkno
op_assign
id|position
op_div
id|tape-&gt;user_bs_factor
op_minus
id|block_offset
suffix:semicolon
id|mtget.mt_dsreg
op_assign
(paren
(paren
id|tape-&gt;tape_block_size
op_star
id|tape-&gt;user_bs_factor
)paren
op_lshift
id|MT_ST_BLKSIZE_SHIFT
)paren
op_amp
id|MT_ST_BLKSIZE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;drv_write_prot
)paren
(brace
id|mtget.mt_gstat
op_or_assign
id|GMT_WR_PROT
c_func
(paren
l_int|0xffffffff
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|argp
comma
op_amp
id|mtget
comma
r_sizeof
(paren
r_struct
id|mtget
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|MTIOCPOS
suffix:colon
id|mtpos.mt_blkno
op_assign
id|position
op_div
id|tape-&gt;user_bs_factor
op_minus
id|block_offset
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|argp
comma
op_amp
id|mtpos
comma
r_sizeof
(paren
r_struct
id|mtpos
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_read
)paren
id|idetape_discard_read_pipeline
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_return
id|idetape_blkdev_ioctl
c_func
(paren
id|drive
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
id|idetape_get_blocksize_from_block_descriptor
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Our character device open function.&n; */
DECL|function|idetape_chrdev_open
r_static
r_int
id|idetape_chrdev_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
r_int
id|minor
op_assign
id|iminor
c_func
(paren
id|inode
)paren
comma
id|i
op_assign
id|minor
op_amp
op_complement
l_int|0xc0
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
id|idetape_pc_t
id|pc
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|nonseekable_open
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_chrdev_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|i
op_ge
id|MAX_HWIFS
op_star
id|MAX_DRIVES
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|drive
op_assign
id|idetape_chrdevs
(braket
id|i
)braket
dot
id|drive
suffix:semicolon
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|filp-&gt;private_data
op_assign
id|drive
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|IDETAPE_BUSY
comma
op_amp
id|tape-&gt;flags
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|retval
op_assign
id|idetape_wait_ready
c_func
(paren
id|drive
comma
l_int|60
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|clear_bit
c_func
(paren
id|IDETAPE_BUSY
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: %s: drive not ready&bslash;n&quot;
comma
id|tape-&gt;name
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|idetape_read_position
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|IDETAPE_ADDRESS_VALID
comma
op_amp
id|tape-&gt;flags
)paren
)paren
(paren
r_void
)paren
id|idetape_rewind_tape
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_ne
id|idetape_direction_read
)paren
id|clear_bit
c_func
(paren
id|IDETAPE_PIPELINE_ERROR
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* Read block size and write protect status from drive. */
id|idetape_get_blocksize_from_block_descriptor
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Set write protect flag if device is opened as read-only. */
r_if
c_cond
(paren
(paren
id|filp-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_RDONLY
)paren
id|tape-&gt;write_prot
op_assign
l_int|1
suffix:semicolon
r_else
id|tape-&gt;write_prot
op_assign
id|tape-&gt;drv_write_prot
suffix:semicolon
multiline_comment|/* Make sure drive isn&squot;t write protected if user wants to write. */
r_if
c_cond
(paren
id|tape-&gt;write_prot
)paren
(brace
r_if
c_cond
(paren
(paren
id|filp-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_WRONLY
op_logical_or
(paren
id|filp-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_RDWR
)paren
(brace
id|clear_bit
c_func
(paren
id|IDETAPE_BUSY
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Lock the tape drive door so user can&squot;t eject.&n;&t; */
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_none
)paren
(brace
r_if
c_cond
(paren
id|idetape_create_prevent_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
(brace
r_if
c_cond
(paren
id|tape-&gt;door_locked
op_ne
id|DOOR_EXPLICITLY_LOCKED
)paren
id|tape-&gt;door_locked
op_assign
id|DOOR_LOCKED
suffix:semicolon
)brace
)brace
)brace
id|idetape_restart_speed_control
c_func
(paren
id|drive
)paren
suffix:semicolon
id|tape-&gt;restart_speed_control_req
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|idetape_write_release
r_static
r_void
id|idetape_write_release
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|minor
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_empty_write_pipeline
c_func
(paren
id|drive
)paren
suffix:semicolon
id|tape-&gt;merge_stage
op_assign
id|__idetape_kmalloc_stage
c_func
(paren
id|tape
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_stage
op_ne
l_int|NULL
)paren
(brace
id|idetape_pad_zeros
c_func
(paren
id|drive
comma
id|tape-&gt;tape_block_size
op_star
(paren
id|tape-&gt;user_bs_factor
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|__idetape_kfree_stage
c_func
(paren
id|tape-&gt;merge_stage
)paren
suffix:semicolon
id|tape-&gt;merge_stage
op_assign
l_int|NULL
suffix:semicolon
)brace
id|idetape_write_filemark
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_flush_tape_buffers
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_flush_tape_buffers
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Our character device release function.&n; */
DECL|function|idetape_chrdev_release
r_static
r_int
id|idetape_chrdev_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|filp-&gt;private_data
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
id|idetape_pc_t
id|pc
suffix:semicolon
r_int
r_int
id|minor
op_assign
id|iminor
c_func
(paren
id|inode
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_if
c_cond
(paren
id|tape-&gt;debug_level
op_ge
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Reached idetape_chrdev_release&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_write
)paren
id|idetape_write_release
c_func
(paren
id|drive
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_read
)paren
(brace
r_if
c_cond
(paren
id|minor
OL
l_int|128
)paren
id|idetape_discard_read_pipeline
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_else
id|idetape_wait_for_pipeline
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;cache_stage
op_ne
l_int|NULL
)paren
(brace
id|__idetape_kfree_stage
c_func
(paren
id|tape-&gt;cache_stage
)paren
suffix:semicolon
id|tape-&gt;cache_stage
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|minor
OL
l_int|128
op_logical_and
id|test_bit
c_func
(paren
id|IDETAPE_MEDIUM_PRESENT
comma
op_amp
id|tape-&gt;flags
)paren
)paren
(paren
r_void
)paren
id|idetape_rewind_tape
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_none
)paren
(brace
r_if
c_cond
(paren
id|tape-&gt;door_locked
op_eq
id|DOOR_LOCKED
)paren
(brace
r_if
c_cond
(paren
id|idetape_create_prevent_cmd
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
id|tape-&gt;door_locked
op_assign
id|DOOR_UNLOCKED
suffix:semicolon
)brace
)brace
)brace
id|clear_bit
c_func
(paren
id|IDETAPE_BUSY
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_identify_device is called to check the contents of the&n; *&t;ATAPI IDENTIFY command results. We return:&n; *&n; *&t;1&t;If the tape can be supported by us, based on the information&n; *&t;&t;we have so far.&n; *&n; *&t;0 &t;If this tape driver is not currently supported by us.&n; */
DECL|function|idetape_identify_device
r_static
r_int
id|idetape_identify_device
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|idetape_id_gcw
id|gcw
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_INFO
r_int
r_int
id|mask
comma
id|i
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_INFO */
r_if
c_cond
(paren
id|drive-&gt;id_read
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|gcw
)paren
op_assign
id|id-&gt;config
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_INFO
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Dumping ATAPI Identify Device tape parameters&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Protocol Type: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|gcw.protocol
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ATA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ATAPI&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Reserved (Unknown to ide-tape)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Device Type: %x - &quot;
comma
id|gcw.device_type
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|gcw.device_type
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Direct-access Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Streaming Tape Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;CD-ROM Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Optical memory Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1f
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unknown or no Device type&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Removable: %s&quot;
comma
id|gcw.removable
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Command Packet DRQ Type: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|gcw.drq_type
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Microprocessor DRQ&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Interrupt DRQ&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Accelerated DRQ&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Command Packet Size: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|gcw.packet_size
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
c_func
(paren
l_string|&quot;12 bytes&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;16 bytes&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Model: %.40s&bslash;n&quot;
comma
id|id-&gt;model
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Firmware Revision: %.8s&bslash;n&quot;
comma
id|id-&gt;fw_rev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Serial Number: %.20s&bslash;n&quot;
comma
id|id-&gt;serial_no
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Write buffer size: %d bytes&bslash;n&quot;
comma
id|id-&gt;buf_size
op_star
l_int|512
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: DMA: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x01
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: LBA: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x02
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: IORDY can be disabled: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x04
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: IORDY supported: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x08
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;Unknown&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: ATAPI overlap supported: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x20
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: PIO Cycle Timing Category: %d&bslash;n&quot;
comma
id|id-&gt;tPIO
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: DMA Cycle Timing Category: %d&bslash;n&quot;
comma
id|id-&gt;tDMA
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Single Word DMA supported modes: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
comma
id|mask
op_assign
id|mask
op_lshift
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|id-&gt;dma_1word
op_amp
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;%d &quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;dma_1word
op_amp
(paren
id|mask
op_lshift
l_int|8
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;(active) &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Multi Word DMA supported modes: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
comma
id|mask
op_assign
id|mask
op_lshift
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|id-&gt;dma_mword
op_amp
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;%d &quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;dma_mword
op_amp
(paren
id|mask
op_lshift
l_int|8
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;(active) &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|0x0002
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Enhanced PIO Modes: %s&bslash;n&quot;
comma
id|id-&gt;eide_pio_modes
op_amp
l_int|1
ques
c_cond
l_string|&quot;Mode 3&quot;
suffix:colon
l_string|&quot;None&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Minimum Multi-word DMA cycle per word: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;eide_dma_min
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%d ns&bslash;n&quot;
comma
id|id-&gt;eide_dma_min
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Manufacturer&bslash;&squot;s Recommended Multi-word cycle: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;eide_dma_time
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%d ns&bslash;n&quot;
comma
id|id-&gt;eide_dma_time
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Minimum PIO cycle without IORDY: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;eide_pio
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%d ns&bslash;n&quot;
comma
id|id-&gt;eide_pio
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Minimum PIO cycle with IORDY: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;eide_pio_iordy
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%d ns&bslash;n&quot;
comma
id|id-&gt;eide_pio_iordy
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: According to the device, fields 64-70 are not valid.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_INFO */
multiline_comment|/* Check that we can support this device */
r_if
c_cond
(paren
id|gcw.protocol
op_ne
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: Protocol is not ATAPI&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gcw.device_type
op_ne
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: Device type is not set to tape&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|gcw.removable
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: The removable flag is not set&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gcw.packet_size
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: Packet size is not 12 bytes long&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gcw.packet_size
op_eq
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: Sorry, padding to 16 bytes is still not supported&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Use INQUIRY to get the firmware revision&n; */
DECL|function|idetape_get_inquiry_results
r_static
r_void
id|idetape_get_inquiry_results
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_char
op_star
id|r
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_pc_t
id|pc
suffix:semicolon
id|idetape_inquiry_result_t
op_star
id|inquiry
suffix:semicolon
id|idetape_create_inquiry_cmd
c_func
(paren
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: %s: can&squot;t get INQUIRY results&bslash;n&quot;
comma
id|tape-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|inquiry
op_assign
(paren
id|idetape_inquiry_result_t
op_star
)paren
id|pc.buffer
suffix:semicolon
id|memcpy
c_func
(paren
id|tape-&gt;vendor_id
comma
id|inquiry-&gt;vendor_id
comma
l_int|8
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tape-&gt;product_id
comma
id|inquiry-&gt;product_id
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tape-&gt;firmware_revision
comma
id|inquiry-&gt;revision_level
comma
l_int|4
)paren
suffix:semicolon
id|ide_fixstring
c_func
(paren
id|tape-&gt;vendor_id
comma
l_int|10
comma
l_int|0
)paren
suffix:semicolon
id|ide_fixstring
c_func
(paren
id|tape-&gt;product_id
comma
l_int|18
comma
l_int|0
)paren
suffix:semicolon
id|ide_fixstring
c_func
(paren
id|tape-&gt;firmware_revision
comma
l_int|6
comma
l_int|0
)paren
suffix:semicolon
id|r
op_assign
id|tape-&gt;firmware_revision
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
id|r
op_plus
l_int|1
)paren
op_eq
l_char|&squot;.&squot;
)paren
id|tape-&gt;firmware_revision_num
op_assign
(paren
op_star
id|r
op_minus
l_char|&squot;0&squot;
)paren
op_star
l_int|100
op_plus
(paren
op_star
(paren
id|r
op_plus
l_int|2
)paren
op_minus
l_char|&squot;0&squot;
)paren
op_star
l_int|10
op_plus
op_star
(paren
id|r
op_plus
l_int|3
)paren
op_minus
l_char|&squot;0&squot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: %s &lt;-&gt; %s: %s %s rev %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|tape-&gt;name
comma
id|tape-&gt;vendor_id
comma
id|tape-&gt;product_id
comma
id|tape-&gt;firmware_revision
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_get_mode_sense_results asks the tape about its various&n; *&t;parameters. In particular, we will adjust our data transfer buffer&n; *&t;size to the recommended value as returned by the tape.&n; */
DECL|function|idetape_get_mode_sense_results
r_static
r_void
id|idetape_get_mode_sense_results
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_pc_t
id|pc
suffix:semicolon
id|idetape_mode_parameter_header_t
op_star
id|header
suffix:semicolon
id|idetape_capabilities_page_t
op_star
id|capabilities
suffix:semicolon
id|idetape_create_mode_sense_cmd
c_func
(paren
op_amp
id|pc
comma
id|IDETAPE_CAPABILITIES_PAGE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: Can&squot;t get tape parameters - assuming some default values&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;tape_block_size
op_assign
l_int|512
suffix:semicolon
id|tape-&gt;capabilities.ctl
op_assign
l_int|52
suffix:semicolon
id|tape-&gt;capabilities.speed
op_assign
l_int|450
suffix:semicolon
id|tape-&gt;capabilities.buffer_size
op_assign
l_int|6
op_star
l_int|52
suffix:semicolon
r_return
suffix:semicolon
)brace
id|header
op_assign
(paren
id|idetape_mode_parameter_header_t
op_star
)paren
id|pc.buffer
suffix:semicolon
id|capabilities
op_assign
(paren
id|idetape_capabilities_page_t
op_star
)paren
(paren
id|pc.buffer
op_plus
r_sizeof
(paren
id|idetape_mode_parameter_header_t
)paren
op_plus
id|header-&gt;bdl
)paren
suffix:semicolon
id|capabilities-&gt;max_speed
op_assign
id|ntohs
c_func
(paren
id|capabilities-&gt;max_speed
)paren
suffix:semicolon
id|capabilities-&gt;ctl
op_assign
id|ntohs
c_func
(paren
id|capabilities-&gt;ctl
)paren
suffix:semicolon
id|capabilities-&gt;speed
op_assign
id|ntohs
c_func
(paren
id|capabilities-&gt;speed
)paren
suffix:semicolon
id|capabilities-&gt;buffer_size
op_assign
id|ntohs
c_func
(paren
id|capabilities-&gt;buffer_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capabilities-&gt;speed
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: %s: overriding capabilities-&gt;speed (assuming 650KB/sec)&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|capabilities-&gt;speed
op_assign
l_int|650
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|capabilities-&gt;max_speed
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: %s: overriding capabilities-&gt;max_speed (assuming 650KB/sec)&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|capabilities-&gt;max_speed
op_assign
l_int|650
suffix:semicolon
)brace
id|tape-&gt;capabilities
op_assign
op_star
id|capabilities
suffix:semicolon
multiline_comment|/* Save us a copy */
r_if
c_cond
(paren
id|capabilities-&gt;blk512
)paren
id|tape-&gt;tape_block_size
op_assign
l_int|512
suffix:semicolon
r_else
r_if
c_cond
(paren
id|capabilities-&gt;blk1024
)paren
id|tape-&gt;tape_block_size
op_assign
l_int|1024
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_INFO
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Dumping the results of the MODE SENSE packet command&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Mode Parameter Header:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Mode Data Length - %d&bslash;n&quot;
comma
id|header-&gt;mode_data_length
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Medium Type - %d&bslash;n&quot;
comma
id|header-&gt;medium_type
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Device Specific Parameter - %d&bslash;n&quot;
comma
id|header-&gt;dsp
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Block Descriptor Length - %d&bslash;n&quot;
comma
id|header-&gt;bdl
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Capabilities and Mechanical Status Page:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Page code - %d&bslash;n&quot;
comma
id|capabilities-&gt;page_code
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Page length - %d&bslash;n&quot;
comma
id|capabilities-&gt;page_length
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Read only - %s&bslash;n&quot;
comma
id|capabilities-&gt;ro
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Supports reverse space - %s&bslash;n&quot;
comma
id|capabilities-&gt;sprev
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Supports erase initiated formatting - %s&bslash;n&quot;
comma
id|capabilities-&gt;efmt
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Supports QFA two Partition format - %s&bslash;n&quot;
comma
id|capabilities-&gt;qfa
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Supports locking the medium - %s&bslash;n&quot;
comma
id|capabilities-&gt;lock
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: The volume is currently locked - %s&bslash;n&quot;
comma
id|capabilities-&gt;locked
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: The device defaults in the prevent state - %s&bslash;n&quot;
comma
id|capabilities-&gt;prevent
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Supports ejecting the medium - %s&bslash;n&quot;
comma
id|capabilities-&gt;eject
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Supports error correction - %s&bslash;n&quot;
comma
id|capabilities-&gt;ecc
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Supports data compression - %s&bslash;n&quot;
comma
id|capabilities-&gt;cmprs
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Supports 512 bytes block size - %s&bslash;n&quot;
comma
id|capabilities-&gt;blk512
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Supports 1024 bytes block size - %s&bslash;n&quot;
comma
id|capabilities-&gt;blk1024
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Supports 32768 bytes block size / Restricted byte count for PIO transfers - %s&bslash;n&quot;
comma
id|capabilities-&gt;blk32768
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Maximum supported speed in KBps - %d&bslash;n&quot;
comma
id|capabilities-&gt;max_speed
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Continuous transfer limits in blocks - %d&bslash;n&quot;
comma
id|capabilities-&gt;ctl
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Current speed in KBps - %d&bslash;n&quot;
comma
id|capabilities-&gt;speed
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Buffer size - %d&bslash;n&quot;
comma
id|capabilities-&gt;buffer_size
op_star
l_int|512
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_INFO */
)brace
multiline_comment|/*&n; *&t;ide_get_blocksize_from_block_descriptor does a mode sense page 0 with block descriptor&n; *&t;and if it succeeds sets the tape block size with the reported value&n; */
DECL|function|idetape_get_blocksize_from_block_descriptor
r_static
r_void
id|idetape_get_blocksize_from_block_descriptor
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|idetape_pc_t
id|pc
suffix:semicolon
id|idetape_mode_parameter_header_t
op_star
id|header
suffix:semicolon
id|idetape_parameter_block_descriptor_t
op_star
id|block_descrp
suffix:semicolon
id|idetape_create_mode_sense_cmd
c_func
(paren
op_amp
id|pc
comma
id|IDETAPE_BLOCK_DESCRIPTOR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idetape_queue_pc_tail
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: Can&squot;t get block descriptor&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;tape_block_size
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide-tape: Cannot deal with zero block size, assume 32k&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;tape_block_size
op_assign
l_int|32768
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|header
op_assign
(paren
id|idetape_mode_parameter_header_t
op_star
)paren
id|pc.buffer
suffix:semicolon
id|block_descrp
op_assign
(paren
id|idetape_parameter_block_descriptor_t
op_star
)paren
(paren
id|pc.buffer
op_plus
r_sizeof
(paren
id|idetape_mode_parameter_header_t
)paren
)paren
suffix:semicolon
id|tape-&gt;tape_block_size
op_assign
(paren
id|block_descrp-&gt;length
(braket
l_int|0
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|block_descrp-&gt;length
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_plus
id|block_descrp-&gt;length
(braket
l_int|2
)braket
suffix:semicolon
id|tape-&gt;drv_write_prot
op_assign
(paren
id|header-&gt;dsp
op_amp
l_int|0x80
)paren
op_rshift
l_int|7
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_INFO
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: Adjusted block size - %d&bslash;n&quot;
comma
id|tape-&gt;tape_block_size
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_INFO */
)brace
DECL|function|idetape_add_settings
r_static
r_void
id|idetape_add_settings
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
multiline_comment|/*&n; *&t;&t;&t;drive&t;setting name&t;read/write&t;ioctl&t;ioctl&t;&t;data type&t;min&t;&t;&t;max&t;&t;&t;mul_factor&t;&t;&t;div_factor&t;&t;&t;data pointer&t;&t;&t;&t;set function&n; */
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;buffer&quot;
comma
id|SETTING_READ
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_SHORT
comma
l_int|0
comma
l_int|0xffff
comma
l_int|1
comma
l_int|2
comma
op_amp
id|tape-&gt;capabilities.buffer_size
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;pipeline_min&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|1
comma
l_int|0xffff
comma
id|tape-&gt;stage_size
op_div
l_int|1024
comma
l_int|1
comma
op_amp
id|tape-&gt;min_pipeline
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;pipeline&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|1
comma
l_int|0xffff
comma
id|tape-&gt;stage_size
op_div
l_int|1024
comma
l_int|1
comma
op_amp
id|tape-&gt;max_stages
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;pipeline_max&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|1
comma
l_int|0xffff
comma
id|tape-&gt;stage_size
op_div
l_int|1024
comma
l_int|1
comma
op_amp
id|tape-&gt;max_pipeline
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;pipeline_used&quot;
comma
id|SETTING_READ
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|0
comma
l_int|0xffff
comma
id|tape-&gt;stage_size
op_div
l_int|1024
comma
l_int|1
comma
op_amp
id|tape-&gt;nr_stages
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;pipeline_pending&quot;
comma
id|SETTING_READ
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|0
comma
l_int|0xffff
comma
id|tape-&gt;stage_size
op_div
l_int|1024
comma
l_int|1
comma
op_amp
id|tape-&gt;nr_pending_stages
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;speed&quot;
comma
id|SETTING_READ
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_SHORT
comma
l_int|0
comma
l_int|0xffff
comma
l_int|1
comma
l_int|1
comma
op_amp
id|tape-&gt;capabilities.speed
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;stage&quot;
comma
id|SETTING_READ
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|0
comma
l_int|0xffff
comma
l_int|1
comma
l_int|1024
comma
op_amp
id|tape-&gt;stage_size
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;tdsc&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
id|IDETAPE_DSC_RW_MIN
comma
id|IDETAPE_DSC_RW_MAX
comma
l_int|1000
comma
id|HZ
comma
op_amp
id|tape-&gt;best_dsc_rw_frequency
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;dsc_overlap&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;dsc_overlap
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;pipeline_head_speed_c&quot;
comma
id|SETTING_READ
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|0
comma
l_int|0xffff
comma
l_int|1
comma
l_int|1
comma
op_amp
id|tape-&gt;controlled_pipeline_head_speed
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;pipeline_head_speed_u&quot;
comma
id|SETTING_READ
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|0
comma
l_int|0xffff
comma
l_int|1
comma
l_int|1
comma
op_amp
id|tape-&gt;uncontrolled_pipeline_head_speed
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;avg_speed&quot;
comma
id|SETTING_READ
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|0
comma
l_int|0xffff
comma
l_int|1
comma
l_int|1
comma
op_amp
id|tape-&gt;avg_speed
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;debug_level&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_INT
comma
l_int|0
comma
l_int|0xffff
comma
l_int|1
comma
l_int|1
comma
op_amp
id|tape-&gt;debug_level
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;ide_setup is called to:&n; *&n; *&t;&t;1.&t;Initialize our various state variables.&n; *&t;&t;2.&t;Ask the tape for its capabilities.&n; *&t;&t;3.&t;Allocate a buffer which will be used for data&n; *&t;&t;&t;transfer. The buffer size is chosen based on&n; *&t;&t;&t;the recommendation which we received in step (2).&n; *&n; *&t;Note that at this point ide.c already assigned us an irq, so that&n; *&t;we can queue requests here and wait for their completion.&n; */
DECL|function|idetape_setup
r_static
r_void
id|idetape_setup
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_tape_t
op_star
id|tape
comma
r_int
id|minor
)paren
(brace
r_int
r_int
id|t1
comma
id|tmid
comma
id|tn
comma
id|t
suffix:semicolon
r_int
id|speed
suffix:semicolon
r_struct
id|idetape_id_gcw
id|gcw
suffix:semicolon
r_int
id|stage_size
suffix:semicolon
r_struct
id|sysinfo
id|si
suffix:semicolon
id|memset
c_func
(paren
id|tape
comma
l_int|0
comma
r_sizeof
(paren
id|idetape_tape_t
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|tape-&gt;spinlock
)paren
suffix:semicolon
id|drive-&gt;driver_data
op_assign
id|tape
suffix:semicolon
multiline_comment|/* An ATAPI device ignores DRDY */
id|drive-&gt;ready_stat
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;dsc_overlap
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|pci_dev
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * These two ide-pci host adapters appear to need DSC overlap disabled.&n;&t;&t; * This probably needs further analysis.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|pci_dev-&gt;device
op_eq
id|PCI_DEVICE_ID_ARTOP_ATP850UF
)paren
op_logical_or
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|pci_dev-&gt;device
op_eq
id|PCI_DEVICE_ID_TTI_HPT343
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: %s: disabling DSC overlap&bslash;n&quot;
comma
id|tape-&gt;name
)paren
suffix:semicolon
id|drive-&gt;dsc_overlap
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEPCI */
multiline_comment|/* Seagate Travan drives do not support DSC overlap. */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;Seagate STT3401&quot;
)paren
)paren
id|drive-&gt;dsc_overlap
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;drive
op_assign
id|drive
suffix:semicolon
id|tape-&gt;minor
op_assign
id|minor
suffix:semicolon
id|tape-&gt;name
(braket
l_int|0
)braket
op_assign
l_char|&squot;h&squot;
suffix:semicolon
id|tape-&gt;name
(braket
l_int|1
)braket
op_assign
l_char|&squot;t&squot;
suffix:semicolon
id|tape-&gt;name
(braket
l_int|2
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|minor
suffix:semicolon
id|tape-&gt;chrdev_direction
op_assign
id|idetape_direction_none
suffix:semicolon
id|tape-&gt;pc
op_assign
id|tape-&gt;pc_stack
suffix:semicolon
id|tape-&gt;max_insert_speed
op_assign
l_int|10000
suffix:semicolon
id|tape-&gt;speed_control
op_assign
l_int|1
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|gcw
)paren
op_assign
id|drive-&gt;id-&gt;config
suffix:semicolon
r_if
c_cond
(paren
id|gcw.drq_type
op_eq
l_int|1
)paren
id|set_bit
c_func
(paren
id|IDETAPE_DRQ_INTERRUPT
comma
op_amp
id|tape-&gt;flags
)paren
suffix:semicolon
id|tape-&gt;min_pipeline
op_assign
id|tape-&gt;max_pipeline
op_assign
id|tape-&gt;max_stages
op_assign
l_int|10
suffix:semicolon
id|idetape_get_inquiry_results
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_get_mode_sense_results
c_func
(paren
id|drive
)paren
suffix:semicolon
id|idetape_get_blocksize_from_block_descriptor
c_func
(paren
id|drive
)paren
suffix:semicolon
id|tape-&gt;user_bs_factor
op_assign
l_int|1
suffix:semicolon
id|tape-&gt;stage_size
op_assign
id|tape-&gt;capabilities.ctl
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
r_while
c_loop
(paren
id|tape-&gt;stage_size
OG
l_int|0xffff
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ide-tape: decreasing stage size&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;capabilities.ctl
op_div_assign
l_int|2
suffix:semicolon
id|tape-&gt;stage_size
op_assign
id|tape-&gt;capabilities.ctl
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
)brace
id|stage_size
op_assign
id|tape-&gt;stage_size
suffix:semicolon
id|tape-&gt;pages_per_stage
op_assign
id|stage_size
op_div
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|stage_size
op_mod
id|PAGE_SIZE
)paren
(brace
id|tape-&gt;pages_per_stage
op_increment
suffix:semicolon
id|tape-&gt;excess_bh_size
op_assign
id|PAGE_SIZE
op_minus
id|stage_size
op_mod
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Select the &quot;best&quot; DSC read/write polling frequency&n;&t; *&t;and pipeline size.&n;&t; */
id|speed
op_assign
id|max
c_func
(paren
id|tape-&gt;capabilities.speed
comma
id|tape-&gt;capabilities.max_speed
)paren
suffix:semicolon
id|tape-&gt;max_stages
op_assign
id|speed
op_star
l_int|1000
op_star
l_int|10
op_div
id|tape-&gt;stage_size
suffix:semicolon
multiline_comment|/*&n;&t; * &t;Limit memory use for pipeline to 10% of physical memory&n;&t; */
id|si_meminfo
c_func
(paren
op_amp
id|si
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;max_stages
op_star
id|tape-&gt;stage_size
OG
id|si.totalram
op_star
id|si.mem_unit
op_div
l_int|10
)paren
id|tape-&gt;max_stages
op_assign
id|si.totalram
op_star
id|si.mem_unit
op_div
(paren
l_int|10
op_star
id|tape-&gt;stage_size
)paren
suffix:semicolon
id|tape-&gt;max_stages
op_assign
id|min
c_func
(paren
id|tape-&gt;max_stages
comma
id|IDETAPE_MAX_PIPELINE_STAGES
)paren
suffix:semicolon
id|tape-&gt;min_pipeline
op_assign
id|min
c_func
(paren
id|tape-&gt;max_stages
comma
id|IDETAPE_MIN_PIPELINE_STAGES
)paren
suffix:semicolon
id|tape-&gt;max_pipeline
op_assign
id|min
c_func
(paren
id|tape-&gt;max_stages
op_star
l_int|2
comma
id|IDETAPE_MAX_PIPELINE_STAGES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;max_stages
op_eq
l_int|0
)paren
id|tape-&gt;max_stages
op_assign
id|tape-&gt;min_pipeline
op_assign
id|tape-&gt;max_pipeline
op_assign
l_int|1
suffix:semicolon
id|t1
op_assign
(paren
id|tape-&gt;stage_size
op_star
id|HZ
)paren
op_div
(paren
id|speed
op_star
l_int|1000
)paren
suffix:semicolon
id|tmid
op_assign
(paren
id|tape-&gt;capabilities.buffer_size
op_star
l_int|32
op_star
id|HZ
)paren
op_div
(paren
id|speed
op_star
l_int|125
)paren
suffix:semicolon
id|tn
op_assign
(paren
id|IDETAPE_FIFO_THRESHOLD
op_star
id|tape-&gt;stage_size
op_star
id|HZ
)paren
op_div
(paren
id|speed
op_star
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;max_stages
)paren
id|t
op_assign
id|tn
suffix:semicolon
r_else
id|t
op_assign
id|t1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Ensure that the number we got makes sense; limit&n;&t; *&t;it within IDETAPE_DSC_RW_MIN and IDETAPE_DSC_RW_MAX.&n;&t; */
id|tape-&gt;best_dsc_rw_frequency
op_assign
id|max_t
c_func
(paren
r_int
r_int
comma
id|min_t
c_func
(paren
r_int
r_int
comma
id|t
comma
id|IDETAPE_DSC_RW_MAX
)paren
comma
id|IDETAPE_DSC_RW_MIN
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide-tape: %s &lt;-&gt; %s: %dKBps, %d*%dkB buffer, &quot;
l_string|&quot;%dkB pipeline, %lums tDSC%s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|tape-&gt;name
comma
id|tape-&gt;capabilities.speed
comma
(paren
id|tape-&gt;capabilities.buffer_size
op_star
l_int|512
)paren
op_div
id|tape-&gt;stage_size
comma
id|tape-&gt;stage_size
op_div
l_int|1024
comma
id|tape-&gt;max_stages
op_star
id|tape-&gt;stage_size
op_div
l_int|1024
comma
id|tape-&gt;best_dsc_rw_frequency
op_star
l_int|1000
op_div
id|HZ
comma
id|drive-&gt;using_dma
ques
c_cond
l_string|&quot;, DMA&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|idetape_add_settings
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
DECL|function|idetape_cleanup
r_static
r_int
id|idetape_cleanup
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|minor
op_assign
id|tape-&gt;minor
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDETAPE_BUSY
comma
op_amp
id|tape-&gt;flags
)paren
op_logical_or
id|drive-&gt;usage
op_logical_or
id|tape-&gt;first_stage
op_ne
l_int|NULL
op_logical_or
id|tape-&gt;merge_stage_size
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|idetape_chrdevs
(braket
id|minor
)braket
dot
id|drive
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
op_assign
l_int|0
suffix:semicolon
(paren
r_void
)paren
id|ide_unregister_subdriver
c_func
(paren
id|drive
)paren
suffix:semicolon
id|drive-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
id|devfs_remove
c_func
(paren
l_string|&quot;%s/mt&quot;
comma
id|drive-&gt;devfs_name
)paren
suffix:semicolon
id|devfs_remove
c_func
(paren
l_string|&quot;%s/mtn&quot;
comma
id|drive-&gt;devfs_name
)paren
suffix:semicolon
id|devfs_unregister_tape
c_func
(paren
id|drive-&gt;disk-&gt;number
)paren
suffix:semicolon
id|kfree
(paren
id|tape
)paren
suffix:semicolon
id|drive-&gt;disk-&gt;fops
op_assign
id|ide_fops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|proc_idetape_read_name
r_static
r_int
id|proc_idetape_read_name
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|data
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_char
op_star
id|out
op_assign
id|page
suffix:semicolon
r_int
id|len
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|tape-&gt;name
)paren
suffix:semicolon
id|PROC_IDE_READ_RETURN
c_func
(paren
id|page
comma
id|start
comma
id|off
comma
id|count
comma
id|eof
comma
id|len
)paren
suffix:semicolon
)brace
DECL|variable|idetape_proc
r_static
id|ide_proc_entry_t
id|idetape_proc
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;name&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
id|proc_idetape_read_name
comma
l_int|NULL
)brace
comma
(brace
l_int|NULL
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
macro_line|#else
DECL|macro|idetape_proc
mdefine_line|#define&t;idetape_proc&t;NULL
macro_line|#endif
r_static
r_int
id|idetape_attach
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;IDE subdriver functions, registered with ide.c&n; */
DECL|variable|idetape_driver
r_static
id|ide_driver_t
id|idetape_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;ide-tape&quot;
comma
dot
id|version
op_assign
id|IDETAPE_VERSION
comma
dot
id|media
op_assign
id|ide_tape
comma
dot
id|busy
op_assign
l_int|1
comma
dot
id|supports_dsc_overlap
op_assign
l_int|1
comma
dot
id|cleanup
op_assign
id|idetape_cleanup
comma
dot
id|do_request
op_assign
id|idetape_do_request
comma
dot
id|end_request
op_assign
id|idetape_end_request
comma
dot
id|pre_reset
op_assign
id|idetape_pre_reset
comma
dot
id|proc
op_assign
id|idetape_proc
comma
dot
id|attach
op_assign
id|idetape_attach
comma
dot
id|drives
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|idetape_driver.drives
)paren
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Our character device supporting functions, passed to register_chrdev.&n; */
DECL|variable|idetape_fops
r_static
r_struct
id|file_operations
id|idetape_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|read
op_assign
id|idetape_chrdev_read
comma
dot
id|write
op_assign
id|idetape_chrdev_write
comma
dot
id|ioctl
op_assign
id|idetape_chrdev_ioctl
comma
dot
id|open
op_assign
id|idetape_chrdev_open
comma
dot
id|release
op_assign
id|idetape_chrdev_release
comma
)brace
suffix:semicolon
DECL|function|idetape_open
r_static
r_int
id|idetape_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
id|drive-&gt;usage
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|idetape_release
r_static
r_int
id|idetape_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
id|drive-&gt;usage
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|idetape_ioctl
r_static
r_int
id|idetape_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
op_assign
id|inode-&gt;i_bdev
suffix:semicolon
id|ide_drive_t
op_star
id|drive
op_assign
id|bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
r_int
id|err
op_assign
id|generic_ide_ioctl
c_func
(paren
id|file
comma
id|bdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EINVAL
)paren
id|err
op_assign
id|idetape_blkdev_ioctl
c_func
(paren
id|drive
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|idetape_block_ops
r_static
r_struct
id|block_device_operations
id|idetape_block_ops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|idetape_open
comma
dot
id|release
op_assign
id|idetape_release
comma
dot
id|ioctl
op_assign
id|idetape_ioctl
comma
)brace
suffix:semicolon
DECL|function|idetape_attach
r_static
r_int
id|idetape_attach
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_int
id|minor
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strstr
c_func
(paren
l_string|&quot;ide-tape&quot;
comma
id|drive-&gt;driver_req
)paren
)paren
r_goto
id|failed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_goto
id|failed
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_tape
)paren
r_goto
id|failed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idetape_identify_device
(paren
id|drive
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: %s: not supported by this version of ide-tape&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive-&gt;scsi
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide-tape: passing drive %s to ide-scsi emulation.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;OnStream DI-&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide-tape: Use drive %s with ide-scsi emulation and osst.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide-tape: OnStream support will be removed soon from ide-tape!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|tape
op_assign
(paren
id|idetape_tape_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|idetape_tape_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: %s: Can&squot;t allocate a tape structure&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ide_register_subdriver
c_func
(paren
id|drive
comma
op_amp
id|idetape_driver
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: %s: Failed to register the driver with ide.c&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tape
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
r_for
c_loop
(paren
id|minor
op_assign
l_int|0
suffix:semicolon
id|idetape_chrdevs
(braket
id|minor
)braket
dot
id|drive
op_ne
l_int|NULL
suffix:semicolon
id|minor
op_increment
)paren
suffix:semicolon
id|idetape_setup
c_func
(paren
id|drive
comma
id|tape
comma
id|minor
)paren
suffix:semicolon
id|idetape_chrdevs
(braket
id|minor
)braket
dot
id|drive
op_assign
id|drive
suffix:semicolon
id|devfs_mk_cdev
c_func
(paren
id|MKDEV
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
comma
id|minor
)paren
comma
id|S_IFCHR
op_or
id|S_IRUGO
op_or
id|S_IWUGO
comma
l_string|&quot;%s/mt&quot;
comma
id|drive-&gt;devfs_name
)paren
suffix:semicolon
id|devfs_mk_cdev
c_func
(paren
id|MKDEV
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
comma
id|minor
op_plus
l_int|128
)paren
comma
id|S_IFCHR
op_or
id|S_IRUGO
op_or
id|S_IWUGO
comma
l_string|&quot;%s/mtn&quot;
comma
id|drive-&gt;devfs_name
)paren
suffix:semicolon
id|drive-&gt;disk-&gt;number
op_assign
id|devfs_register_tape
c_func
(paren
id|drive-&gt;devfs_name
)paren
suffix:semicolon
id|drive-&gt;disk-&gt;fops
op_assign
op_amp
id|idetape_block_ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|failed
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;ATAPI Streaming TAPE Driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|function|idetape_exit
r_static
r_void
id|__exit
id|idetape_exit
(paren
r_void
)paren
(brace
id|ide_unregister_driver
c_func
(paren
op_amp
id|idetape_driver
)paren
suffix:semicolon
id|unregister_chrdev
c_func
(paren
id|IDETAPE_MAJOR
comma
l_string|&quot;ht&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_init will register the driver for each tape.&n; */
DECL|function|idetape_init
r_static
r_int
id|idetape_init
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|register_chrdev
c_func
(paren
id|IDETAPE_MAJOR
comma
l_string|&quot;ht&quot;
comma
op_amp
id|idetape_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide-tape: Failed to register character device interface&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|ide_register_driver
c_func
(paren
op_amp
id|idetape_driver
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|idetape_init
id|module_init
c_func
(paren
id|idetape_init
)paren
suffix:semicolon
DECL|variable|idetape_exit
id|module_exit
c_func
(paren
id|idetape_exit
)paren
suffix:semicolon
DECL|variable|IDETAPE_MAJOR
id|MODULE_ALIAS_CHARDEV_MAJOR
c_func
(paren
id|IDETAPE_MAJOR
)paren
suffix:semicolon
eof
