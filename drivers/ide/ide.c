multiline_comment|/*&n; *  linux/drivers/ide/ide.c&t;&t;Version 7.00beta2&t;Mar 05 2003&n; *&n; *  Copyright (C) 1994-1998  Linus Torvalds &amp; authors (see below)&n; */
multiline_comment|/*&n; *  Mostly written by Mark Lord  &lt;mlord@pobox.com&gt;&n; *                and Gadi Oxman &lt;gadio@netvision.net.il&gt;&n; *                and Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *&n; *  See linux/MAINTAINERS for address of current maintainer.&n; *&n; * This is the multiple IDE interface driver, as evolved from hd.c.&n; * It supports up to MAX_HWIFS IDE interfaces, on one or more IRQs&n; *   (usually 14 &amp; 15).&n; * There can be up to two drives per interface, as per the ATA-2 spec.&n; *&n; * Primary:    ide0, port 0x1f0; major=3;  hda is minor=0; hdb is minor=64&n; * Secondary:  ide1, port 0x170; major=22; hdc is minor=0; hdd is minor=64&n; * Tertiary:   ide2, port 0x???; major=33; hde is minor=0; hdf is minor=64&n; * Quaternary: ide3, port 0x???; major=34; hdg is minor=0; hdh is minor=64&n; * ...&n; *&n; *  From hd.c:&n; *  |&n; *  | It traverses the request-list, using interrupts to jump between functions.&n; *  | As nearly all functions can be called within interrupts, we may not sleep.&n; *  | Special care is recommended.  Have Fun!&n; *  |&n; *  | modified by Drew Eckhardt to check nr of hd&squot;s from the CMOS.&n; *  |&n; *  | Thanks to Branko Lankester, lankeste@fwi.uva.nl, who found a bug&n; *  | in the early extended-partition checks and added DM partitions.&n; *  |&n; *  | Early work on error handling by Mika Liljeberg (liljeber@cs.Helsinki.FI).&n; *  |&n; *  | IRQ-unmask, drive-id, multiple-mode, support for &quot;&gt;16 heads&quot;,&n; *  | and general streamlining by Mark Lord (mlord@pobox.com).&n; *&n; *  October, 1994 -- Complete line-by-line overhaul for linux 1.1.x, by:&n; *&n; *&t;Mark Lord&t;(mlord@pobox.com)&t;&t;(IDE Perf.Pkg)&n; *&t;Delman Lee&t;(delman@ieee.org)&t;&t;(&quot;Mr. atdisk2&quot;)&n; *&t;Scott Snyder&t;(snyder@fnald0.fnal.gov)&t;(ATAPI IDE cd-rom)&n; *&n; *  This was a rewrite of just about everything from hd.c, though some original&n; *  code is still sprinkled about.  Think of it as a major evolution, with&n; *  inspiration from lots of linux users, esp.  hamish@zot.apana.org.au&n; *&n; *  Version 1.0 ALPHA&t;initial code, primary i/f working okay&n; *  Version 1.3 BETA&t;dual i/f on shared irq tested &amp; working!&n; *  Version 1.4 BETA&t;added auto probing for irq(s)&n; *  Version 1.5 BETA&t;added ALPHA (untested) support for IDE cd-roms,&n; *  ...&n; * Version 5.50&t;&t;allow values as small as 20 for idebus=&n; * Version 5.51&t;&t;force non io_32bit in drive_cmd_intr()&n; *&t;&t;&t;change delay_10ms() to delay_50ms() to fix problems&n; * Version 5.52&t;&t;fix incorrect invalidation of removable devices&n; *&t;&t;&t;add &quot;hdx=slow&quot; command line option&n; * Version 5.60&t;&t;start to modularize the driver; the disk and ATAPI&n; *&t;&t;&t; drivers can be compiled as loadable modules.&n; *&t;&t;&t;move IDE probe code to ide-probe.c&n; *&t;&t;&t;move IDE disk code to ide-disk.c&n; *&t;&t;&t;add support for generic IDE device subdrivers&n; *&t;&t;&t;add m68k code from Geert Uytterhoeven&n; *&t;&t;&t;probe all interfaces by default&n; *&t;&t;&t;add ioctl to (re)probe an interface&n; * Version 6.00&t;&t;use per device request queues&n; *&t;&t;&t;attempt to optimize shared hwgroup performance&n; *&t;&t;&t;add ioctl to manually adjust bandwidth algorithms&n; *&t;&t;&t;add kerneld support for the probe module&n; *&t;&t;&t;fix bug in ide_error()&n; *&t;&t;&t;fix bug in the first ide_get_lock() call for Atari&n; *&t;&t;&t;don&squot;t flush leftover data for ATAPI devices&n; * Version 6.01&t;&t;clear hwgroup-&gt;active while the hwgroup sleeps&n; *&t;&t;&t;support HDIO_GETGEO for floppies&n; * Version 6.02&t;&t;fix ide_ack_intr() call&n; *&t;&t;&t;check partition table on floppies&n; * Version 6.03&t;&t;handle bad status bit sequencing in ide_wait_stat()&n; * Version 6.10&t;&t;deleted old entries from this list of updates&n; *&t;&t;&t;replaced triton.c with ide-dma.c generic PCI DMA&n; *&t;&t;&t;added support for BIOS-enabled UltraDMA&n; *&t;&t;&t;rename all &quot;promise&quot; things to &quot;pdc4030&quot;&n; *&t;&t;&t;fix EZ-DRIVE handling on small disks&n; * Version 6.11&t;&t;fix probe error in ide_scan_devices()&n; *&t;&t;&t;fix ancient &quot;jiffies&quot; polling bugs&n; *&t;&t;&t;mask all hwgroup interrupts on each irq entry&n; * Version 6.12&t;&t;integrate ioctl and proc interfaces&n; *&t;&t;&t;fix parsing of &quot;idex=&quot; command line parameter&n; * Version 6.13&t;&t;add support for ide4/ide5 courtesy rjones@orchestream.com&n; * Version 6.14&t;&t;fixed IRQ sharing among PCI devices&n; * Version 6.15&t;&t;added SMP awareness to IDE drivers&n; * Version 6.16&t;&t;fixed various bugs; even more SMP friendly&n; * Version 6.17&t;&t;fix for newest EZ-Drive problem&n; * Version 6.18&t;&t;default unpartitioned-disk translation now &quot;BIOS LBA&quot;&n; * Version 6.19&t;&t;Re-design for a UNIFORM driver for all platforms,&n; *&t;&t;&t;  model based on suggestions from Russell King and&n; *&t;&t;&t;  Geert Uytterhoeven&n; *&t;&t;&t;Promise DC4030VL now supported.&n; *&t;&t;&t;add support for ide6/ide7&n; *&t;&t;&t;delay_50ms() changed to ide_delay_50ms() and exported.&n; * Version 6.20&t;&t;Added/Fixed Generic ATA-66 support and hwif detection.&n; *&t;&t;&t;Added hdx=flash to allow for second flash disk&n; *&t;&t;&t;  detection w/o the hang loop.&n; *&t;&t;&t;Added support for ide8/ide9&n; *&t;&t;&t;Added idex=ata66 for the quirky chipsets that are&n; *&t;&t;&t;  ATA-66 compliant, but have yet to determine a method&n; *&t;&t;&t;  of verification of the 80c cable presence.&n; *&t;&t;&t;  Specifically Promise&squot;s PDC20262 chipset.&n; * Version 6.21&t;&t;Fixing/Fixed SMP spinlock issue with insight from an old&n; *&t;&t;&t;  hat that clarified original low level driver design.&n; * Version 6.30&t;&t;Added SMP support; fixed multmode issues.  -ml&n; * Version 6.31&t;&t;Debug Share INTR&squot;s and request queue streaming&n; *&t;&t;&t;Native ATA-100 support&n; *&t;&t;&t;Prep for Cascades Project&n; * Version 7.00alpha&t;First named revision of ide rearrange&n; *&n; *  Some additional driver compile-time options are in ./include/linux/ide.h&n; *&n; *  To do, in likely order of completion:&n; *&t;- modify kernel to obtain BIOS geometry for drives on 2nd/3rd/4th i/f&n; *&n; */
DECL|macro|REVISION
mdefine_line|#define&t;REVISION&t;&quot;Revision: 7.00alpha2&quot;
DECL|macro|VERSION
mdefine_line|#define&t;VERSION&t;&t;&quot;Id: ide.c 7.00a2 20020906&quot;
DECL|macro|REALLY_SLOW_IO
macro_line|#undef REALLY_SLOW_IO&t;&t;/* most systems can safely undef this */
DECL|macro|_IDE_C
mdefine_line|#define _IDE_C&t;&t;&t;/* Tell ide.h it&squot;s really us */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
multiline_comment|/* default maximum number of failures */
DECL|macro|IDE_DEFAULT_MAX_FAILURES
mdefine_line|#define IDE_DEFAULT_MAX_FAILURES &t;1
DECL|variable|ide_hwif_to_major
r_static
r_const
id|u8
id|ide_hwif_to_major
(braket
)braket
op_assign
(brace
id|IDE0_MAJOR
comma
id|IDE1_MAJOR
comma
id|IDE2_MAJOR
comma
id|IDE3_MAJOR
comma
id|IDE4_MAJOR
comma
id|IDE5_MAJOR
comma
id|IDE6_MAJOR
comma
id|IDE7_MAJOR
comma
id|IDE8_MAJOR
comma
id|IDE9_MAJOR
)brace
suffix:semicolon
DECL|variable|idebus_parameter
r_static
r_int
id|idebus_parameter
suffix:semicolon
multiline_comment|/* holds the &quot;idebus=&quot; parameter */
DECL|variable|system_bus_speed
r_static
r_int
id|system_bus_speed
suffix:semicolon
multiline_comment|/* holds what we think is VESA/PCI bus speed */
DECL|variable|initializing
r_static
r_int
id|initializing
suffix:semicolon
multiline_comment|/* set while initializing built-in drivers */
DECL|variable|ide_cfg_sem
id|DECLARE_MUTEX
c_func
(paren
id|ide_cfg_sem
)paren
suffix:semicolon
DECL|variable|__cacheline_aligned_in_smp
id|spinlock_t
id|ide_lock
id|__cacheline_aligned_in_smp
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
DECL|variable|ide_scan_direction
r_static
r_int
id|ide_scan_direction
suffix:semicolon
multiline_comment|/* THIS was formerly 2.2.x pci=reverse */
macro_line|#endif
macro_line|#ifdef CONFIG_IDEDMA_AUTO
DECL|variable|noautodma
r_int
id|noautodma
op_assign
l_int|0
suffix:semicolon
macro_line|#else
DECL|variable|noautodma
r_int
id|noautodma
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
DECL|variable|noautodma
id|EXPORT_SYMBOL
c_func
(paren
id|noautodma
)paren
suffix:semicolon
multiline_comment|/*&n; * This is declared extern in ide.h, for access by other IDE modules:&n; */
DECL|variable|ide_hwifs
id|ide_hwif_t
id|ide_hwifs
(braket
id|MAX_HWIFS
)braket
suffix:semicolon
multiline_comment|/* master data repository */
DECL|variable|ide_hwifs
id|EXPORT_SYMBOL
c_func
(paren
id|ide_hwifs
)paren
suffix:semicolon
r_extern
id|ide_driver_t
id|idedefault_driver
suffix:semicolon
r_static
r_void
id|setup_driver_defaults
c_func
(paren
id|ide_driver_t
op_star
id|driver
)paren
suffix:semicolon
multiline_comment|/*&n; * Do not even *think* about calling this!&n; */
DECL|function|init_hwif_data
r_static
r_void
id|init_hwif_data
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
r_int
id|index
)paren
(brace
r_int
r_int
id|unit
suffix:semicolon
multiline_comment|/* bulk initialize hwif &amp; drive info with zeros */
id|memset
c_func
(paren
id|hwif
comma
l_int|0
comma
r_sizeof
(paren
id|ide_hwif_t
)paren
)paren
suffix:semicolon
multiline_comment|/* fill in any non-zero initial values */
id|hwif-&gt;index
op_assign
id|index
suffix:semicolon
id|hwif-&gt;major
op_assign
id|ide_hwif_to_major
(braket
id|index
)braket
suffix:semicolon
id|hwif-&gt;name
(braket
l_int|0
)braket
op_assign
l_char|&squot;i&squot;
suffix:semicolon
id|hwif-&gt;name
(braket
l_int|1
)braket
op_assign
l_char|&squot;d&squot;
suffix:semicolon
id|hwif-&gt;name
(braket
l_int|2
)braket
op_assign
l_char|&squot;e&squot;
suffix:semicolon
id|hwif-&gt;name
(braket
l_int|3
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|index
suffix:semicolon
id|hwif-&gt;bus_state
op_assign
id|BUSSTATE_ON
suffix:semicolon
id|hwif-&gt;atapi_dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* disable all atapi dma */
id|hwif-&gt;ultra_mask
op_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* disable all ultra */
id|hwif-&gt;mwdma_mask
op_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* disable all mwdma */
id|hwif-&gt;swdma_mask
op_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* disable all swdma */
id|sema_init
c_func
(paren
op_amp
id|hwif-&gt;gendev_rel_sem
comma
l_int|0
)paren
suffix:semicolon
id|default_hwif_iops
c_func
(paren
id|hwif
)paren
suffix:semicolon
id|default_hwif_transport
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
id|drive-&gt;media
op_assign
id|ide_disk
suffix:semicolon
id|drive-&gt;select.all
op_assign
(paren
id|unit
op_lshift
l_int|4
)paren
op_or
l_int|0xa0
suffix:semicolon
id|drive-&gt;hwif
op_assign
id|hwif
suffix:semicolon
id|drive-&gt;ctl
op_assign
l_int|0x08
suffix:semicolon
id|drive-&gt;ready_stat
op_assign
id|READY_STAT
suffix:semicolon
id|drive-&gt;bad_wstat
op_assign
id|BAD_W_STAT
suffix:semicolon
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;special.b.set_geometry
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;name
(braket
l_int|0
)braket
op_assign
l_char|&squot;h&squot;
suffix:semicolon
id|drive-&gt;name
(braket
l_int|1
)braket
op_assign
l_char|&squot;d&squot;
suffix:semicolon
id|drive-&gt;name
(braket
l_int|2
)braket
op_assign
l_char|&squot;a&squot;
op_plus
(paren
id|index
op_star
id|MAX_DRIVES
)paren
op_plus
id|unit
suffix:semicolon
id|drive-&gt;max_failures
op_assign
id|IDE_DEFAULT_MAX_FAILURES
suffix:semicolon
id|drive-&gt;using_dma
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;is_flash
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;driver
op_assign
op_amp
id|idedefault_driver
suffix:semicolon
id|drive-&gt;vdma
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|drive-&gt;list
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|drive-&gt;gendev_rel_sem
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|init_hwif_default
r_static
r_void
id|init_hwif_default
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
r_int
id|index
)paren
(brace
id|hw_regs_t
id|hw
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|hw
comma
l_int|0
comma
r_sizeof
(paren
id|hw_regs_t
)paren
)paren
suffix:semicolon
id|ide_init_hwif_ports
c_func
(paren
op_amp
id|hw
comma
id|ide_default_io_base
c_func
(paren
id|index
)paren
comma
l_int|0
comma
op_amp
id|hwif-&gt;irq
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|hwif-&gt;hw
comma
op_amp
id|hw
comma
r_sizeof
(paren
id|hw
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hwif-&gt;io_ports
comma
id|hw.io_ports
comma
r_sizeof
(paren
id|hw.io_ports
)paren
)paren
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
op_logical_neg
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_HD
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
id|HD_DATA
)paren
id|hwif-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* may be overridden by ide_setup() */
macro_line|#endif
)brace
r_extern
r_void
id|ide_arm_init
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * init_ide_data() sets reasonable default values into all fields&n; * of all instances of the hwifs and drives, but only on the first call.&n; * Subsequent calls have no effect (they don&squot;t wipe out anything).&n; *&n; * This routine is normally called at driver initialization time,&n; * but may also be called MUCH earlier during kernel &quot;command-line&quot;&n; * parameter processing.  As such, we cannot depend on any other parts&n; * of the kernel (such as memory allocation) to be functioning yet.&n; *&n; * This is too bad, as otherwise we could dynamically allocate the&n; * ide_drive_t structs as needed, rather than always consuming memory&n; * for the max possible number (MAX_HWIFS * MAX_DRIVES) of them.&n; *&n; * FIXME: We should stuff the setup data into __init and copy the&n; * relevant hwifs/allocate them properly during boot.&n; */
DECL|macro|MAGIC_COOKIE
mdefine_line|#define MAGIC_COOKIE 0x12345678
DECL|function|init_ide_data
r_static
r_void
id|__init
id|init_ide_data
(paren
r_void
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
r_static
r_int
r_int
id|magic_cookie
op_assign
id|MAGIC_COOKIE
suffix:semicolon
r_if
c_cond
(paren
id|magic_cookie
op_ne
id|MAGIC_COOKIE
)paren
r_return
suffix:semicolon
multiline_comment|/* already initialized */
id|magic_cookie
op_assign
l_int|0
suffix:semicolon
id|setup_driver_defaults
c_func
(paren
op_amp
id|idedefault_driver
)paren
suffix:semicolon
multiline_comment|/* Initialise all interface structures */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
id|init_hwif_data
c_func
(paren
id|hwif
comma
id|index
)paren
suffix:semicolon
id|init_hwif_default
c_func
(paren
id|hwif
comma
id|index
)paren
suffix:semicolon
macro_line|#if !defined(CONFIG_PPC32) || !defined(CONFIG_PCI)
id|hwif-&gt;irq
op_assign
id|hwif-&gt;hw.irq
op_assign
id|ide_init_default_irq
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_IDE_ARM
id|initializing
op_assign
l_int|1
suffix:semicolon
id|ide_arm_init
c_func
(paren
)paren
suffix:semicolon
id|initializing
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * ide_system_bus_speed() returns what we think is the system VESA/PCI&n; * bus speed (in MHz).  This is used for calculating interface PIO timings.&n; * The default is 40 for known PCI systems, 50 otherwise.&n; * The &quot;idebus=xx&quot; parameter can be used to override this value.&n; * The actual value to be used is computed/displayed the first time through.&n; */
DECL|function|ide_system_bus_speed
r_int
id|ide_system_bus_speed
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|system_bus_speed
)paren
(brace
r_if
c_cond
(paren
id|idebus_parameter
)paren
(brace
multiline_comment|/* user supplied value */
id|system_bus_speed
op_assign
id|idebus_parameter
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pci_find_device
c_func
(paren
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|NULL
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* safe default value for PCI */
id|system_bus_speed
op_assign
l_int|33
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* safe default value for VESA and PCI */
id|system_bus_speed
op_assign
l_int|50
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide: Assuming %dMHz system bus speed &quot;
l_string|&quot;for PIO modes%s&bslash;n&quot;
comma
id|system_bus_speed
comma
id|idebus_parameter
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;; override with idebus=xx&quot;
)paren
suffix:semicolon
)brace
r_return
id|system_bus_speed
suffix:semicolon
)brace
multiline_comment|/*&n; * current_capacity() returns the capacity (in sectors) of a drive&n; * according to its current geometry/LBA settings.&n; */
DECL|function|current_capacity
id|sector_t
id|current_capacity
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|capacity
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
DECL|variable|current_capacity
id|EXPORT_SYMBOL
c_func
(paren
id|current_capacity
)paren
suffix:semicolon
multiline_comment|/*&n; * Error reporting, in human readable form (luxurious, but a memory hog).&n; */
DECL|function|ide_dump_status
id|u8
id|ide_dump_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|u8
id|stat
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|err
op_assign
l_int|0
suffix:semicolon
id|local_irq_set
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: %s: status=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Busy &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|READY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DriveReady &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DeviceFault &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|SEEK_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;SeekComplete &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DataRequest &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ECC_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;CorrectedError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|INDEX_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Index &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Error &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
macro_line|#endif&t;/* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
(paren
id|BUSY_STAT
op_or
id|ERR_STAT
)paren
)paren
op_eq
id|ERR_STAT
)paren
(brace
id|err
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_ERROR_REG
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: error=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|err
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ABRT_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;DriveStatusError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ICRC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;Bad%s &quot;
comma
(paren
id|err
op_amp
id|ABRT_ERR
)paren
ques
c_cond
l_string|&quot;CRC&quot;
suffix:colon
l_string|&quot;Sector&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ECC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;UncorrectableError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ID_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;SectorIdNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;TrackZeroNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|MARK_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;AddrMarkNotFound &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ABRT_ERR
)paren
)paren
op_eq
id|BBD_ERR
op_logical_or
(paren
id|err
op_amp
(paren
id|ECC_ERR
op_or
id|ID_ERR
op_or
id|MARK_ERR
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|u64
id|sectors
op_assign
l_int|0
suffix:semicolon
id|u32
id|high
op_assign
l_int|0
suffix:semicolon
id|u32
id|low
op_assign
id|ide_read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|0x80
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|high
op_assign
id|ide_read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|sectors
op_assign
(paren
(paren
id|u64
)paren
id|high
op_lshift
l_int|24
)paren
op_or
id|low
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%llu, high=%d, low=%d&quot;
comma
(paren
r_int
r_int
)paren
id|sectors
comma
id|high
comma
id|low
)paren
suffix:semicolon
)brace
r_else
(brace
id|u8
id|cur
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/* using LBA? */
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%ld&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|cur
op_amp
l_int|0xf
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_LCYL_REG
)paren
op_lshift
l_int|8
)paren
op_or
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, CHS=%d/%d/%d&quot;
comma
(paren
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|8
)paren
op_plus
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_LCYL_REG
)paren
comma
id|cur
op_amp
l_int|0xf
comma
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_logical_and
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
id|printk
c_func
(paren
l_string|&quot;, sector=%llu&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;sector
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|ide_dump_status
id|EXPORT_SYMBOL
c_func
(paren
id|ide_dump_status
)paren
suffix:semicolon
DECL|function|ide_open
r_static
r_int
id|ide_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
DECL|variable|drives_lock
r_static
id|spinlock_t
id|drives_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|drivers_lock
r_static
id|spinlock_t
id|drivers_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|drivers
)paren
suffix:semicolon
multiline_comment|/* Iterator */
DECL|function|m_start
r_static
r_void
op_star
id|m_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|loff_t
id|l
op_assign
op_star
id|pos
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|drivers_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|drivers
)paren
r_if
c_cond
(paren
op_logical_neg
id|l
op_decrement
)paren
r_return
id|list_entry
c_func
(paren
id|p
comma
id|ide_driver_t
comma
id|drivers
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|m_next
r_static
r_void
op_star
id|m_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|list_head
op_star
id|p
op_assign
(paren
(paren
id|ide_driver_t
op_star
)paren
id|v
)paren
op_member_access_from_pointer
id|drivers.next
suffix:semicolon
(paren
op_star
id|pos
)paren
op_increment
suffix:semicolon
r_return
id|p
op_eq
op_amp
id|drivers
ques
c_cond
l_int|NULL
suffix:colon
id|list_entry
c_func
(paren
id|p
comma
id|ide_driver_t
comma
id|drivers
)paren
suffix:semicolon
)brace
DECL|function|m_stop
r_static
r_void
id|m_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|drivers_lock
)paren
suffix:semicolon
)brace
DECL|function|show_driver
r_static
r_int
id|show_driver
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
id|ide_driver_t
op_star
id|driver
op_assign
id|v
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%s version %s&bslash;n&quot;
comma
id|driver-&gt;name
comma
id|driver-&gt;version
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ide_drivers_op
r_struct
id|seq_operations
id|ide_drivers_op
op_assign
(brace
dot
id|start
op_assign
id|m_start
comma
dot
id|next
op_assign
id|m_next
comma
dot
id|stop
op_assign
id|m_stop
comma
dot
id|show
op_assign
id|show_driver
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|variable|proc_ide_root
r_struct
id|proc_dir_entry
op_star
id|proc_ide_root
suffix:semicolon
DECL|variable|generic_subdriver_entries
id|ide_proc_entry_t
id|generic_subdriver_entries
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;capacity&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
id|proc_ide_read_capacity
comma
l_int|NULL
)brace
comma
(brace
l_int|NULL
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
macro_line|#endif
DECL|function|hwif_request_region
r_static
r_struct
id|resource
op_star
id|hwif_request_region
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
r_int
id|addr
comma
r_int
id|num
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
id|request_region
c_func
(paren
id|addr
comma
id|num
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: I/O resource 0x%lX-0x%lX not free.&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|addr
comma
id|addr
op_plus
id|num
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_hwif_request_regions - request resources for IDE&n; *&t;@hwif: interface to use&n; *&n; *&t;Requests all the needed resources for an interface.&n; *&t;Right now core IDE code does this work which is deeply wrong.&n; *&t;MMIO leaves it to the controller driver,&n; *&t;PIO will migrate this way over time.&n; */
DECL|function|ide_hwif_request_regions
r_int
id|ide_hwif_request_regions
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;mmio
op_eq
l_int|2
)paren
r_return
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
id|hwif-&gt;mmio
op_eq
l_int|1
)paren
suffix:semicolon
id|addr
op_assign
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_logical_and
op_logical_neg
id|hwif_request_region
c_func
(paren
id|hwif
comma
id|addr
comma
l_int|1
)paren
)paren
r_goto
id|control_region_busy
suffix:semicolon
id|hwif-&gt;straight8
op_assign
l_int|0
suffix:semicolon
id|addr
op_assign
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_or
l_int|7
)paren
op_eq
id|hwif-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hwif_request_region
c_func
(paren
id|hwif
comma
id|addr
comma
l_int|8
)paren
)paren
r_goto
id|data_region_busy
suffix:semicolon
id|hwif-&gt;straight8
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|IDE_DATA_OFFSET
suffix:semicolon
id|i
op_le
id|IDE_STATUS_OFFSET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|addr
op_assign
id|hwif-&gt;io_ports
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif_request_region
c_func
(paren
id|hwif
comma
id|addr
comma
l_int|1
)paren
)paren
(brace
r_while
c_loop
(paren
op_decrement
id|i
)paren
id|release_region
c_func
(paren
id|addr
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|data_region_busy
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|data_region_busy
suffix:colon
id|addr
op_assign
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
id|release_region
c_func
(paren
id|addr
comma
l_int|1
)paren
suffix:semicolon
id|control_region_busy
suffix:colon
multiline_comment|/* If any errors are return, we drop the hwif interface. */
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_hwif_release_regions - free IDE resources&n; *&n; *&t;Note that we only release the standard ports,&n; *&t;and do not even try to handle any extra ports&n; *&t;allocated for weird IDE interface chipsets.&n; *&n; *&t;Note also that we don&squot;t yet handle mmio resources here. More&n; *&t;importantly our caller should be doing this so we need to &n; *&t;restructure this as a helper function for drivers.&n; */
DECL|function|ide_hwif_release_regions
r_void
id|ide_hwif_release_regions
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
id|u32
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;mmio
op_eq
l_int|2
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
id|release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;straight8
)paren
(brace
id|release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
l_int|8
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|IDE_DATA_OFFSET
suffix:semicolon
id|i
op_le
id|IDE_STATUS_OFFSET
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|i
)braket
)paren
id|release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|i
)braket
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* restore hwif to a sane state */
DECL|function|ide_hwif_restore
r_static
r_void
id|ide_hwif_restore
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
comma
id|ide_hwif_t
op_star
id|tmp_hwif
)paren
(brace
id|hwif-&gt;hwgroup
op_assign
id|tmp_hwif-&gt;hwgroup
suffix:semicolon
id|hwif-&gt;gendev.parent
op_assign
id|tmp_hwif-&gt;gendev.parent
suffix:semicolon
id|hwif-&gt;proc
op_assign
id|tmp_hwif-&gt;proc
suffix:semicolon
id|hwif-&gt;major
op_assign
id|tmp_hwif-&gt;major
suffix:semicolon
id|hwif-&gt;straight8
op_assign
id|tmp_hwif-&gt;straight8
suffix:semicolon
id|hwif-&gt;bus_state
op_assign
id|tmp_hwif-&gt;bus_state
suffix:semicolon
id|hwif-&gt;atapi_dma
op_assign
id|tmp_hwif-&gt;atapi_dma
suffix:semicolon
id|hwif-&gt;ultra_mask
op_assign
id|tmp_hwif-&gt;ultra_mask
suffix:semicolon
id|hwif-&gt;mwdma_mask
op_assign
id|tmp_hwif-&gt;mwdma_mask
suffix:semicolon
id|hwif-&gt;swdma_mask
op_assign
id|tmp_hwif-&gt;swdma_mask
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|tmp_hwif-&gt;chipset
suffix:semicolon
id|hwif-&gt;hold
op_assign
id|tmp_hwif-&gt;hold
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
id|hwif-&gt;pci_dev
op_assign
id|tmp_hwif-&gt;pci_dev
suffix:semicolon
id|hwif-&gt;cds
op_assign
id|tmp_hwif-&gt;cds
suffix:semicolon
macro_line|#endif
id|hwif-&gt;identify
op_assign
id|tmp_hwif-&gt;identify
suffix:semicolon
id|hwif-&gt;tuneproc
op_assign
id|tmp_hwif-&gt;tuneproc
suffix:semicolon
id|hwif-&gt;speedproc
op_assign
id|tmp_hwif-&gt;speedproc
suffix:semicolon
id|hwif-&gt;selectproc
op_assign
id|tmp_hwif-&gt;selectproc
suffix:semicolon
id|hwif-&gt;reset_poll
op_assign
id|tmp_hwif-&gt;reset_poll
suffix:semicolon
id|hwif-&gt;pre_reset
op_assign
id|tmp_hwif-&gt;pre_reset
suffix:semicolon
id|hwif-&gt;resetproc
op_assign
id|tmp_hwif-&gt;resetproc
suffix:semicolon
id|hwif-&gt;intrproc
op_assign
id|tmp_hwif-&gt;intrproc
suffix:semicolon
id|hwif-&gt;maskproc
op_assign
id|tmp_hwif-&gt;maskproc
suffix:semicolon
id|hwif-&gt;quirkproc
op_assign
id|tmp_hwif-&gt;quirkproc
suffix:semicolon
id|hwif-&gt;busproc
op_assign
id|tmp_hwif-&gt;busproc
suffix:semicolon
id|hwif-&gt;ata_input_data
op_assign
id|tmp_hwif-&gt;ata_input_data
suffix:semicolon
id|hwif-&gt;ata_output_data
op_assign
id|tmp_hwif-&gt;ata_output_data
suffix:semicolon
id|hwif-&gt;atapi_input_bytes
op_assign
id|tmp_hwif-&gt;atapi_input_bytes
suffix:semicolon
id|hwif-&gt;atapi_output_bytes
op_assign
id|tmp_hwif-&gt;atapi_output_bytes
suffix:semicolon
id|hwif-&gt;ide_dma_read
op_assign
id|tmp_hwif-&gt;ide_dma_read
suffix:semicolon
id|hwif-&gt;ide_dma_write
op_assign
id|tmp_hwif-&gt;ide_dma_write
suffix:semicolon
id|hwif-&gt;ide_dma_begin
op_assign
id|tmp_hwif-&gt;ide_dma_begin
suffix:semicolon
id|hwif-&gt;ide_dma_end
op_assign
id|tmp_hwif-&gt;ide_dma_end
suffix:semicolon
id|hwif-&gt;ide_dma_check
op_assign
id|tmp_hwif-&gt;ide_dma_check
suffix:semicolon
id|hwif-&gt;ide_dma_on
op_assign
id|tmp_hwif-&gt;ide_dma_on
suffix:semicolon
id|hwif-&gt;ide_dma_off_quietly
op_assign
id|tmp_hwif-&gt;ide_dma_off_quietly
suffix:semicolon
id|hwif-&gt;ide_dma_test_irq
op_assign
id|tmp_hwif-&gt;ide_dma_test_irq
suffix:semicolon
id|hwif-&gt;ide_dma_host_on
op_assign
id|tmp_hwif-&gt;ide_dma_host_on
suffix:semicolon
id|hwif-&gt;ide_dma_host_off
op_assign
id|tmp_hwif-&gt;ide_dma_host_off
suffix:semicolon
id|hwif-&gt;ide_dma_verbose
op_assign
id|tmp_hwif-&gt;ide_dma_verbose
suffix:semicolon
id|hwif-&gt;ide_dma_lostirq
op_assign
id|tmp_hwif-&gt;ide_dma_lostirq
suffix:semicolon
id|hwif-&gt;ide_dma_timeout
op_assign
id|tmp_hwif-&gt;ide_dma_timeout
suffix:semicolon
id|hwif-&gt;OUTB
op_assign
id|tmp_hwif-&gt;OUTB
suffix:semicolon
id|hwif-&gt;OUTBSYNC
op_assign
id|tmp_hwif-&gt;OUTBSYNC
suffix:semicolon
id|hwif-&gt;OUTW
op_assign
id|tmp_hwif-&gt;OUTW
suffix:semicolon
id|hwif-&gt;OUTL
op_assign
id|tmp_hwif-&gt;OUTL
suffix:semicolon
id|hwif-&gt;OUTSW
op_assign
id|tmp_hwif-&gt;OUTSW
suffix:semicolon
id|hwif-&gt;OUTSL
op_assign
id|tmp_hwif-&gt;OUTSL
suffix:semicolon
id|hwif-&gt;INB
op_assign
id|tmp_hwif-&gt;INB
suffix:semicolon
id|hwif-&gt;INW
op_assign
id|tmp_hwif-&gt;INW
suffix:semicolon
id|hwif-&gt;INL
op_assign
id|tmp_hwif-&gt;INL
suffix:semicolon
id|hwif-&gt;INSW
op_assign
id|tmp_hwif-&gt;INSW
suffix:semicolon
id|hwif-&gt;INSL
op_assign
id|tmp_hwif-&gt;INSL
suffix:semicolon
id|hwif-&gt;mmio
op_assign
id|tmp_hwif-&gt;mmio
suffix:semicolon
id|hwif-&gt;rqsize
op_assign
id|tmp_hwif-&gt;rqsize
suffix:semicolon
id|hwif-&gt;no_lba48
op_assign
id|tmp_hwif-&gt;no_lba48
suffix:semicolon
macro_line|#ifndef CONFIG_BLK_DEV_IDECS
id|hwif-&gt;irq
op_assign
id|tmp_hwif-&gt;irq
suffix:semicolon
macro_line|#endif
id|hwif-&gt;dma_base
op_assign
id|tmp_hwif-&gt;dma_base
suffix:semicolon
id|hwif-&gt;dma_master
op_assign
id|tmp_hwif-&gt;dma_master
suffix:semicolon
id|hwif-&gt;dma_command
op_assign
id|tmp_hwif-&gt;dma_command
suffix:semicolon
id|hwif-&gt;dma_vendor1
op_assign
id|tmp_hwif-&gt;dma_vendor1
suffix:semicolon
id|hwif-&gt;dma_status
op_assign
id|tmp_hwif-&gt;dma_status
suffix:semicolon
id|hwif-&gt;dma_vendor3
op_assign
id|tmp_hwif-&gt;dma_vendor3
suffix:semicolon
id|hwif-&gt;dma_prdtable
op_assign
id|tmp_hwif-&gt;dma_prdtable
suffix:semicolon
id|hwif-&gt;dma_extra
op_assign
id|tmp_hwif-&gt;dma_extra
suffix:semicolon
id|hwif-&gt;config_data
op_assign
id|tmp_hwif-&gt;config_data
suffix:semicolon
id|hwif-&gt;select_data
op_assign
id|tmp_hwif-&gt;select_data
suffix:semicolon
id|hwif-&gt;autodma
op_assign
id|tmp_hwif-&gt;autodma
suffix:semicolon
id|hwif-&gt;udma_four
op_assign
id|tmp_hwif-&gt;udma_four
suffix:semicolon
id|hwif-&gt;no_dsc
op_assign
id|tmp_hwif-&gt;no_dsc
suffix:semicolon
id|hwif-&gt;hwif_data
op_assign
id|tmp_hwif-&gt;hwif_data
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_unregister&t;&t;-&t;free an ide interface&n; *&t;@index: index of interface (will change soon to a pointer)&n; *&n; *&t;Perform the final unregister of an IDE interface. At the moment&n; *&t;we don&squot;t refcount interfaces so this will also get split up.&n; *&n; *&t;Locking:&n; *&t;The caller must not hold the IDE locks&n; *&t;The drive present/vanishing is not yet properly locked&n; *&t;Take care with the callbacks. These have been split to avoid&n; *&t;deadlocking the IDE layer. The shutdown callback is called&n; *&t;before we take the lock and free resources. It is up to the&n; *&t;caller to be sure there is no pending I/O here, and that&n; *&t;the interfce will not be reopened (present/vanishing locking&n; *&t;isnt yet done btw). After we commit to the final kill we&n; *&t;call the cleanup callback with the ide locks held.&n; *&n; *&t;Unregister restores the hwif structures to the default state.&n; *&t;This is raving bonkers.&n; */
DECL|function|ide_unregister
r_void
id|ide_unregister
c_func
(paren
r_int
r_int
id|index
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
comma
op_star
id|g
comma
op_star
id|tmp_hwif
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
suffix:semicolon
r_int
id|irq_count
op_assign
l_int|0
comma
id|unit
comma
id|i
suffix:semicolon
id|BUG_ON
c_func
(paren
id|index
op_ge
id|MAX_HWIFS
)paren
suffix:semicolon
id|tmp_hwif
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|tmp_hwif
)paren
comma
id|GFP_KERNEL
op_or
id|__GFP_NOFAIL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_hwif
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unable to allocate memory&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ide_cfg_sem
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;present
)paren
r_goto
m_abort
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;usage
op_logical_or
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
)paren
r_goto
m_abort
suffix:semicolon
id|drive-&gt;dead
op_assign
l_int|1
suffix:semicolon
)brace
id|hwif-&gt;present
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
id|destroy_proc_ide_drives
c_func
(paren
id|hwif
)paren
suffix:semicolon
macro_line|#endif
id|hwgroup
op_assign
id|hwif-&gt;hwgroup
suffix:semicolon
multiline_comment|/*&n;&t; * free the irq if we were the only hwif using it&n;&t; */
id|g
op_assign
id|hwgroup-&gt;hwif
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|g-&gt;irq
op_eq
id|hwif-&gt;irq
)paren
op_increment
id|irq_count
suffix:semicolon
id|g
op_assign
id|g-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|g
op_ne
id|hwgroup-&gt;hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_count
op_eq
l_int|1
)paren
id|free_irq
c_func
(paren
id|hwif-&gt;irq
comma
id|hwgroup
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note that we only release the standard ports,&n;&t; * and do not even try to handle any extra ports&n;&t; * allocated for weird IDE interface chipsets.&n;&t; */
id|ide_hwif_release_regions
c_func
(paren
id|hwif
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove us from the hwgroup, and free&n;&t; * the hwgroup if we were the only member&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|i
)paren
(brace
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;devfs_name
(braket
l_int|0
)braket
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|devfs_remove
c_func
(paren
id|drive-&gt;devfs_name
)paren
suffix:semicolon
id|drive-&gt;devfs_name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
id|drive-&gt;next
)paren
(brace
multiline_comment|/* special case: last drive from hwgroup. */
id|BUG_ON
c_func
(paren
id|hwgroup-&gt;drive
op_ne
id|drive
)paren
suffix:semicolon
id|hwgroup-&gt;drive
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|ide_drive_t
op_star
id|walk
suffix:semicolon
id|walk
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_while
c_loop
(paren
id|walk-&gt;next
op_ne
id|drive
)paren
id|walk
op_assign
id|walk-&gt;next
suffix:semicolon
id|walk-&gt;next
op_assign
id|drive-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;drive
op_eq
id|drive
)paren
(brace
id|hwgroup-&gt;drive
op_assign
id|drive-&gt;next
suffix:semicolon
id|hwgroup-&gt;hwif
op_assign
id|HWIF
c_func
(paren
id|hwgroup-&gt;drive
)paren
suffix:semicolon
)brace
)brace
id|BUG_ON
c_func
(paren
id|hwgroup-&gt;drive
op_eq
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|drive-&gt;id
)paren
suffix:semicolon
id|drive-&gt;id
op_assign
l_int|NULL
suffix:semicolon
)brace
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Messed up locking ... */
id|spin_unlock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|drive-&gt;queue
)paren
suffix:semicolon
id|device_unregister
c_func
(paren
op_amp
id|drive-&gt;gendev
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|drive-&gt;gendev_rel_sem
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|drive-&gt;queue
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwif-&gt;next
op_eq
id|hwif
)paren
(brace
id|BUG_ON
c_func
(paren
id|hwgroup-&gt;hwif
op_ne
id|hwif
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hwgroup
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There is another interface in hwgroup.&n;&t;&t; * Unlink us, and set hwgroup-&gt;drive and -&gt;hwif to&n;&t;&t; * something sane.&n;&t;&t; */
id|g
op_assign
id|hwgroup-&gt;hwif
suffix:semicolon
r_while
c_loop
(paren
id|g-&gt;next
op_ne
id|hwif
)paren
id|g
op_assign
id|g-&gt;next
suffix:semicolon
id|g-&gt;next
op_assign
id|hwif-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;hwif
op_eq
id|hwif
)paren
(brace
multiline_comment|/* Chose a random hwif for hwgroup-&gt;hwif.&n;&t;&t;&t; * It&squot;s guaranteed that there are no drives&n;&t;&t;&t; * left in the hwgroup.&n;&t;&t;&t; */
id|BUG_ON
c_func
(paren
id|hwgroup-&gt;drive
op_ne
l_int|NULL
)paren
suffix:semicolon
id|hwgroup-&gt;hwif
op_assign
id|g
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|hwgroup-&gt;hwif
op_eq
id|hwif
)paren
suffix:semicolon
)brace
multiline_comment|/* More messed up locking ... */
id|spin_unlock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|device_unregister
c_func
(paren
op_amp
id|hwif-&gt;gendev
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|hwif-&gt;gendev_rel_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove us from the kernel&squot;s knowledge&n;&t; */
id|blk_unregister_region
c_func
(paren
id|MKDEV
c_func
(paren
id|hwif-&gt;major
comma
l_int|0
)paren
comma
id|MAX_DRIVES
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DRIVES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|hwif-&gt;drives
(braket
id|i
)braket
dot
id|disk
suffix:semicolon
id|hwif-&gt;drives
(braket
id|i
)braket
dot
id|disk
op_assign
l_int|NULL
suffix:semicolon
id|put_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
)brace
id|unregister_blkdev
c_func
(paren
id|hwif-&gt;major
comma
id|hwif-&gt;name
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;dma_base
)paren
(brace
(paren
r_void
)paren
id|ide_release_dma
c_func
(paren
id|hwif
)paren
suffix:semicolon
id|hwif-&gt;dma_base
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;dma_master
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;dma_command
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;dma_vendor1
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;dma_status
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;dma_vendor3
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;dma_prdtable
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* copy original settings */
op_star
id|tmp_hwif
op_assign
op_star
id|hwif
suffix:semicolon
multiline_comment|/* restore hwif data to pristine status */
id|init_hwif_data
c_func
(paren
id|hwif
comma
id|index
)paren
suffix:semicolon
id|init_hwif_default
c_func
(paren
id|hwif
comma
id|index
)paren
suffix:semicolon
id|ide_hwif_restore
c_func
(paren
id|hwif
comma
id|tmp_hwif
)paren
suffix:semicolon
m_abort
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ide_cfg_sem
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmp_hwif
)paren
suffix:semicolon
)brace
DECL|variable|ide_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|ide_unregister
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_setup_ports &t;-&t;set up IDE interface ports&n; *&t;@hw: register descriptions&n; *&t;@base: base register&n; *&t;@offsets: table of register offsets&n; *&t;@ctrl: control register&n; *&t;@ack_irq: IRQ ack&n; *&t;@irq: interrupt lie&n; *&n; *&t;Setup hw_regs_t structure described by parameters.  You&n; *&t;may set up the hw structure yourself OR use this routine to&n; *&t;do it for you. This is basically a helper&n; *&n; */
DECL|function|ide_setup_ports
r_void
id|ide_setup_ports
(paren
id|hw_regs_t
op_star
id|hw
comma
r_int
r_int
id|base
comma
r_int
op_star
id|offsets
comma
r_int
r_int
id|ctrl
comma
r_int
r_int
id|intr
comma
id|ide_ack_intr_t
op_star
id|ack_intr
comma
multiline_comment|/*&n; *&t;&t;&t;ide_io_ops_t *iops,&n; */
r_int
id|irq
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IDE_NR_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|offsets
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
(brace
r_switch
c_cond
(paren
id|i
)paren
(brace
r_case
id|IDE_CONTROL_OFFSET
suffix:colon
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|ctrl
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if defined(CONFIG_AMIGA) || defined(CONFIG_MAC)
r_case
id|IDE_IRQ_OFFSET
suffix:colon
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|intr
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* (CONFIG_AMIGA) || (CONFIG_MAC) */
r_default
suffix:colon
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|base
op_plus
id|offsets
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|hw-&gt;irq
op_assign
id|irq
suffix:semicolon
id|hw-&gt;dma
op_assign
id|NO_DMA
suffix:semicolon
id|hw-&gt;ack_intr
op_assign
id|ack_intr
suffix:semicolon
multiline_comment|/*&n; *&t;hw-&gt;iops = iops;&n; */
)brace
multiline_comment|/*&n; * Register an IDE interface, specifying exactly the registers etc&n; * Set init=1 iff calling before probes have taken place.&n; */
DECL|function|ide_register_hw
r_int
id|ide_register_hw
(paren
id|hw_regs_t
op_star
id|hw
comma
id|ide_hwif_t
op_star
op_star
id|hwifp
)paren
(brace
r_int
id|index
comma
id|retry
op_assign
l_int|1
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_do
(brace
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;hw.io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
id|hw-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
r_goto
id|found
suffix:semicolon
)brace
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;hold
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|hwif-&gt;present
op_logical_and
op_logical_neg
id|hwif-&gt;mate
op_logical_and
op_logical_neg
id|initializing
)paren
op_logical_or
(paren
op_logical_neg
id|hwif-&gt;hw.io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_logical_and
id|initializing
)paren
)paren
r_goto
id|found
suffix:semicolon
)brace
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
id|index
op_increment
)paren
id|ide_unregister
c_func
(paren
id|index
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retry
op_decrement
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
id|found
suffix:colon
r_if
c_cond
(paren
id|hwif-&gt;present
)paren
id|ide_unregister
c_func
(paren
id|index
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;hold
)paren
(brace
id|init_hwif_data
c_func
(paren
id|hwif
comma
id|index
)paren
suffix:semicolon
id|init_hwif_default
c_func
(paren
id|hwif
comma
id|index
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwif-&gt;present
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|hwif-&gt;hw
comma
id|hw
comma
r_sizeof
(paren
op_star
id|hw
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hwif-&gt;io_ports
comma
id|hwif-&gt;hw.io_ports
comma
r_sizeof
(paren
id|hwif-&gt;hw.io_ports
)paren
)paren
suffix:semicolon
id|hwif-&gt;irq
op_assign
id|hw-&gt;irq
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|hw-&gt;chipset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initializing
)paren
(brace
id|probe_hwif_init
c_func
(paren
id|hwif
)paren
suffix:semicolon
id|create_proc_ide_interfaces
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwifp
)paren
op_star
id|hwifp
op_assign
id|hwif
suffix:semicolon
r_return
(paren
id|initializing
op_logical_or
id|hwif-&gt;present
)paren
ques
c_cond
id|index
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
DECL|variable|ide_register_hw
id|EXPORT_SYMBOL
c_func
(paren
id|ide_register_hw
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Locks for IDE setting functionality&n; */
DECL|variable|ide_setting_sem
id|DECLARE_MUTEX
c_func
(paren
id|ide_setting_sem
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_add_setting&t;-&t;add an ide setting option&n; *&t;@drive: drive to use&n; *&t;@name: setting name&n; *&t;@rw: true if the function is read write&n; *&t;@read_ioctl: function to call on read&n; *&t;@write_ioctl: function to call on write&n; *&t;@data_type: type of data&n; *&t;@min: range minimum&n; *&t;@max: range maximum&n; *&t;@mul_factor: multiplication scale&n; *&t;@div_factor: divison scale&n; *&t;@data: private data field&n; *&t;@set: setting&n; *&n; *&t;Removes the setting named from the device if it is present.&n; *&t;The function takes the settings_lock to protect against &n; *&t;parallel changes. This function must not be called from IRQ&n; *&t;context. Returns 0 on success or -1 on failure.&n; *&n; *&t;BUGS: This code is seriously over-engineered. There is also&n; *&t;magic about how the driver specific features are setup. If&n; *&t;a driver is attached we assume the driver settings are auto&n; *&t;remove.&n; */
DECL|function|ide_add_setting
r_int
id|ide_add_setting
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|name
comma
r_int
id|rw
comma
r_int
id|read_ioctl
comma
r_int
id|write_ioctl
comma
r_int
id|data_type
comma
r_int
id|min
comma
r_int
id|max
comma
r_int
id|mul_factor
comma
r_int
id|div_factor
comma
r_void
op_star
id|data
comma
id|ide_procset_t
op_star
id|set
)paren
(brace
id|ide_settings_t
op_star
op_star
id|p
op_assign
(paren
id|ide_settings_t
op_star
op_star
)paren
op_amp
id|drive-&gt;settings
comma
op_star
id|setting
op_assign
l_int|NULL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ide_setting_sem
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|p
)paren
op_logical_and
id|strcmp
c_func
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|name
comma
id|name
)paren
OL
l_int|0
)paren
id|p
op_assign
op_amp
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|setting
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|setting
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
m_abort
suffix:semicolon
id|memset
c_func
(paren
id|setting
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|setting
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|setting-&gt;name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
m_abort
suffix:semicolon
id|strcpy
c_func
(paren
id|setting-&gt;name
comma
id|name
)paren
suffix:semicolon
id|setting-&gt;rw
op_assign
id|rw
suffix:semicolon
id|setting-&gt;read_ioctl
op_assign
id|read_ioctl
suffix:semicolon
id|setting-&gt;write_ioctl
op_assign
id|write_ioctl
suffix:semicolon
id|setting-&gt;data_type
op_assign
id|data_type
suffix:semicolon
id|setting-&gt;min
op_assign
id|min
suffix:semicolon
id|setting-&gt;max
op_assign
id|max
suffix:semicolon
id|setting-&gt;mul_factor
op_assign
id|mul_factor
suffix:semicolon
id|setting-&gt;div_factor
op_assign
id|div_factor
suffix:semicolon
id|setting-&gt;data
op_assign
id|data
suffix:semicolon
id|setting-&gt;set
op_assign
id|set
suffix:semicolon
id|setting-&gt;next
op_assign
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;driver
op_ne
op_amp
id|idedefault_driver
)paren
id|setting-&gt;auto_remove
op_assign
l_int|1
suffix:semicolon
op_star
id|p
op_assign
id|setting
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ide_setting_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
m_abort
suffix:colon
id|up
c_func
(paren
op_amp
id|ide_setting_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setting
)paren
id|kfree
c_func
(paren
id|setting
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|variable|ide_add_setting
id|EXPORT_SYMBOL
c_func
(paren
id|ide_add_setting
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;__ide_remove_setting&t;-&t;remove an ide setting option&n; *&t;@drive: drive to use&n; *&t;@name: setting name&n; *&n; *&t;Removes the setting named from the device if it is present.&n; *&t;The caller must hold the setting semaphore.&n; */
DECL|function|__ide_remove_setting
r_static
r_void
id|__ide_remove_setting
(paren
id|ide_drive_t
op_star
id|drive
comma
r_char
op_star
id|name
)paren
(brace
id|ide_settings_t
op_star
op_star
id|p
comma
op_star
id|setting
suffix:semicolon
id|p
op_assign
(paren
id|ide_settings_t
op_star
op_star
)paren
op_amp
id|drive-&gt;settings
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|p
)paren
op_logical_and
id|strcmp
c_func
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|name
comma
id|name
)paren
)paren
id|p
op_assign
op_amp
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|setting
op_assign
(paren
op_star
id|p
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
(paren
op_star
id|p
)paren
op_assign
id|setting-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|setting-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|setting
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_find_setting_by_ioctl&t;-&t;find a drive specific ioctl&n; *&t;@drive: drive to scan&n; *&t;@cmd: ioctl command to handle&n; *&n; *&t;Scan&squot;s the device setting table for a matching entry and returns&n; *&t;this or NULL if no entry is found. The caller must hold the&n; *&t;setting semaphore&n; */
DECL|function|ide_find_setting_by_ioctl
r_static
id|ide_settings_t
op_star
id|ide_find_setting_by_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|cmd
)paren
(brace
id|ide_settings_t
op_star
id|setting
op_assign
id|drive-&gt;settings
suffix:semicolon
r_while
c_loop
(paren
id|setting
)paren
(brace
r_if
c_cond
(paren
id|setting-&gt;read_ioctl
op_eq
id|cmd
op_logical_or
id|setting-&gt;write_ioctl
op_eq
id|cmd
)paren
r_break
suffix:semicolon
id|setting
op_assign
id|setting-&gt;next
suffix:semicolon
)brace
r_return
id|setting
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_find_setting_by_name&t;-&t;find a drive specific setting&n; *&t;@drive: drive to scan&n; *&t;@name: setting name&n; *&n; *&t;Scan&squot;s the device setting table for a matching entry and returns&n; *&t;this or NULL if no entry is found. The caller must hold the&n; *&t;setting semaphore&n; */
DECL|function|ide_find_setting_by_name
id|ide_settings_t
op_star
id|ide_find_setting_by_name
(paren
id|ide_drive_t
op_star
id|drive
comma
r_char
op_star
id|name
)paren
(brace
id|ide_settings_t
op_star
id|setting
op_assign
id|drive-&gt;settings
suffix:semicolon
r_while
c_loop
(paren
id|setting
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|setting-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|setting
op_assign
id|setting-&gt;next
suffix:semicolon
)brace
r_return
id|setting
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;auto_remove_settings&t;-&t;remove driver specific settings&n; *&t;@drive: drive&n; *&n; *&t;Automatically remove all the driver specific settings for this&n; *&t;drive. This function may sleep and must not be called from IRQ&n; *&t;context. The caller must hold ide_setting_sem.&n; */
DECL|function|auto_remove_settings
r_static
r_void
id|auto_remove_settings
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_settings_t
op_star
id|setting
suffix:semicolon
id|repeat
suffix:colon
id|setting
op_assign
id|drive-&gt;settings
suffix:semicolon
r_while
c_loop
(paren
id|setting
)paren
(brace
r_if
c_cond
(paren
id|setting-&gt;auto_remove
)paren
(brace
id|__ide_remove_setting
c_func
(paren
id|drive
comma
id|setting-&gt;name
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|setting
op_assign
id|setting-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;ide_read_setting&t;-&t;read an IDE setting&n; *&t;@drive: drive to read from&n; *&t;@setting: drive setting&n; *&n; *&t;Read a drive setting and return the value. The caller&n; *&t;must hold the ide_setting_sem when making this call.&n; *&n; *&t;BUGS: the data return and error are the same return value&n; *&t;so an error -EINVAL and true return of the same value cannot&n; *&t;be told apart&n; */
DECL|function|ide_read_setting
r_int
id|ide_read_setting
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_settings_t
op_star
id|setting
)paren
(brace
r_int
id|val
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|setting-&gt;rw
op_amp
id|SETTING_READ
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|setting-&gt;data_type
)paren
(brace
r_case
id|TYPE_BYTE
suffix:colon
id|val
op_assign
op_star
(paren
(paren
id|u8
op_star
)paren
id|setting-&gt;data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_SHORT
suffix:colon
id|val
op_assign
op_star
(paren
(paren
id|u16
op_star
)paren
id|setting-&gt;data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_INT
suffix:colon
r_case
id|TYPE_INTA
suffix:colon
id|val
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
id|setting-&gt;data
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|val
suffix:semicolon
)brace
DECL|function|ide_spin_wait_hwgroup
r_int
id|ide_spin_wait_hwgroup
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
(paren
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|hwgroup-&gt;busy
)paren
(brace
r_int
r_int
id|lflags
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|local_irq_set
c_func
(paren
id|lflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|local_irq_restore
c_func
(paren
id|lflags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: channel busy&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|lflags
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ide_spin_wait_hwgroup
id|EXPORT_SYMBOL
c_func
(paren
id|ide_spin_wait_hwgroup
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_write_setting&t;-&t;read an IDE setting&n; *&t;@drive: drive to read from&n; *&t;@setting: drive setting&n; *&t;@val: value&n; *&n; *&t;Write a drive setting if it is possible. The caller&n; *&t;must hold the ide_setting_sem when making this call.&n; *&n; *&t;BUGS: the data return and error are the same return value&n; *&t;so an error -EINVAL and true return of the same value cannot&n; *&t;be told apart&n; *&n; *&t;FIXME:  This should be changed to enqueue a special request&n; *&t;to the driver to change settings, and then wait on a sema for completion.&n; *&t;The current scheme of polling is kludgy, though safe enough.&n; */
DECL|function|ide_write_setting
r_int
id|ide_write_setting
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_settings_t
op_star
id|setting
comma
r_int
id|val
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|setting-&gt;rw
op_amp
id|SETTING_WRITE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|val
template_param
id|setting-&gt;max
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|setting-&gt;set
)paren
r_return
id|setting
op_member_access_from_pointer
id|set
c_func
(paren
id|drive
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_spin_wait_hwgroup
c_func
(paren
id|drive
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_switch
c_cond
(paren
id|setting-&gt;data_type
)paren
(brace
r_case
id|TYPE_BYTE
suffix:colon
op_star
(paren
(paren
id|u8
op_star
)paren
id|setting-&gt;data
)paren
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_SHORT
suffix:colon
op_star
(paren
(paren
id|u16
op_star
)paren
id|setting-&gt;data
)paren
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_INT
suffix:colon
op_star
(paren
(paren
id|u32
op_star
)paren
id|setting-&gt;data
)paren
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_INTA
suffix:colon
id|p
op_assign
(paren
id|u32
op_star
)paren
id|setting-&gt;data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_lshift
id|PARTN_BITS
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
op_star
id|p
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_io_32bit
r_static
r_int
id|set_io_32bit
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
id|drive-&gt;io_32bit
op_assign
id|arg
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_DTC2278
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|chipset
op_eq
id|ide_dtc2278
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|drives
(braket
op_logical_neg
id|drive-&gt;select.b.unit
)braket
dot
id|io_32bit
op_assign
id|arg
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_DTC2278 */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_using_dma
r_static
r_int
id|set_using_dma
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;id
op_logical_or
op_logical_neg
(paren
id|drive-&gt;id-&gt;capability
op_amp
l_int|1
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_check
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
(brace
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_check
c_func
(paren
id|drive
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_on
c_func
(paren
id|drive
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|__ide_dma_off
c_func
(paren
id|drive
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
macro_line|#else
r_return
op_minus
id|EPERM
suffix:semicolon
macro_line|#endif
)brace
DECL|function|set_pio_mode
r_static
r_int
id|set_pio_mode
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|tuneproc
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;special.b.set_tune
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|drive-&gt;tune_req
op_assign
(paren
id|u8
)paren
id|arg
suffix:semicolon
id|drive-&gt;special.b.set_tune
op_assign
l_int|1
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_xfer_rate
r_static
r_int
id|set_xfer_rate
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_int
id|err
op_assign
id|ide_wait_cmd
c_func
(paren
id|drive
comma
id|WIN_SETFEATURES
comma
(paren
id|u8
)paren
id|arg
comma
id|SETFEATURES_XFER
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|arg
)paren
(brace
id|ide_set_xfer_rate
c_func
(paren
id|drive
comma
(paren
id|u8
)paren
id|arg
)paren
suffix:semicolon
id|ide_driveid_update
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|ide_atapi_to_scsi
r_int
id|ide_atapi_to_scsi
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
(brace
id|drive-&gt;scsi
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
c_func
(paren
id|drive
)paren
)paren
(brace
id|drive-&gt;scsi
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|drive-&gt;scsi
op_assign
(paren
id|u8
)paren
id|arg
suffix:semicolon
id|ata_attach
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_add_generic_settings
r_void
id|ide_add_generic_settings
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
multiline_comment|/*&n; *&t;&t;&t;drive&t;setting name&t;&t;read/write access&t;&t;&t;&t;read ioctl&t;&t;write ioctl&t;&t;data type&t;min&t;max&t;&t;&t;&t;mul_factor&t;div_factor&t;data pointer&t;&t;&t;set function&n; */
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;io_32bit&quot;
comma
id|drive-&gt;no_io_32bit
ques
c_cond
id|SETTING_READ
suffix:colon
id|SETTING_RW
comma
id|HDIO_GET_32BIT
comma
id|HDIO_SET_32BIT
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
op_plus
(paren
id|SUPPORT_VLB_SYNC
op_lshift
l_int|1
)paren
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;io_32bit
comma
id|set_io_32bit
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;keepsettings&quot;
comma
id|SETTING_RW
comma
id|HDIO_GET_KEEPSETTINGS
comma
id|HDIO_SET_KEEPSETTINGS
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;keep_settings
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;nice1&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;nice1
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;pio_mode&quot;
comma
id|SETTING_WRITE
comma
op_minus
l_int|1
comma
id|HDIO_SET_PIO_MODE
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|255
comma
l_int|1
comma
l_int|1
comma
l_int|NULL
comma
id|set_pio_mode
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;unmaskirq&quot;
comma
id|drive-&gt;no_unmask
ques
c_cond
id|SETTING_READ
suffix:colon
id|SETTING_RW
comma
id|HDIO_GET_UNMASKINTR
comma
id|HDIO_SET_UNMASKINTR
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;unmask
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;using_dma&quot;
comma
id|SETTING_RW
comma
id|HDIO_GET_DMA
comma
id|HDIO_SET_DMA
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;using_dma
comma
id|set_using_dma
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;init_speed&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|70
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;init_speed
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;current_speed&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|70
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;current_speed
comma
id|set_xfer_rate
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;number&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|3
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;dn
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;ide-scsi&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
id|HDIO_SET_IDE_SCSI
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;scsi
comma
id|ide_atapi_to_scsi
)paren
suffix:semicolon
)brace
DECL|function|system_bus_clock
r_int
id|system_bus_clock
(paren
r_void
)paren
(brace
r_return
(paren
r_int
)paren
(paren
(paren
op_logical_neg
id|system_bus_speed
)paren
ques
c_cond
id|ide_system_bus_speed
c_func
(paren
)paren
suffix:colon
id|system_bus_speed
)paren
suffix:semicolon
)brace
DECL|variable|system_bus_clock
id|EXPORT_SYMBOL
c_func
(paren
id|system_bus_clock
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Locking is badly broken here - since way back.  That sucker is&n; * root-only, but that&squot;s not an excuse...  The real question is what&n; * exclusion rules do we want here.&n; */
DECL|function|ide_replace_subdriver
r_int
id|ide_replace_subdriver
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|driver
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
op_logical_or
id|drive-&gt;usage
op_logical_or
id|drive-&gt;dead
)paren
r_goto
m_abort
suffix:semicolon
r_if
c_cond
(paren
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
c_func
(paren
id|drive
)paren
)paren
r_goto
m_abort
suffix:semicolon
id|strlcpy
c_func
(paren
id|drive-&gt;driver_req
comma
id|driver
comma
r_sizeof
(paren
id|drive-&gt;driver_req
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_attach
c_func
(paren
id|drive
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|drives_lock
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|drive-&gt;list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|drives_lock
)paren
suffix:semicolon
id|drive-&gt;driver_req
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|ata_attach
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
(brace
id|drive-&gt;driver_req
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DRIVER
c_func
(paren
id|drive
)paren
op_ne
op_amp
id|idedefault_driver
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|name
comma
id|driver
)paren
)paren
r_return
l_int|0
suffix:semicolon
m_abort
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ata_attach
r_int
id|ata_attach
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|drivers_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|drivers
)paren
(brace
id|ide_driver_t
op_star
id|driver
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|ide_driver_t
comma
id|drivers
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|driver-&gt;owner
)paren
)paren
r_continue
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|drivers_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver
op_member_access_from_pointer
id|attach
c_func
(paren
id|drive
)paren
op_eq
l_int|0
)paren
(brace
id|module_put
c_func
(paren
id|driver-&gt;owner
)paren
suffix:semicolon
id|drive-&gt;gendev.driver
op_assign
op_amp
id|driver-&gt;gen_driver
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|drivers_lock
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|driver-&gt;owner
)paren
suffix:semicolon
)brace
id|drive-&gt;gendev.driver
op_assign
op_amp
id|idedefault_driver.gen_driver
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|drivers_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idedefault_driver
dot
id|attach
c_func
(paren
id|drive
)paren
op_ne
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;ide: default attach failed&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|generic_ide_suspend
r_static
r_int
id|generic_ide_suspend
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|state
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|dev-&gt;driver_data
suffix:semicolon
r_struct
id|request
id|rq
suffix:semicolon
r_struct
id|request_pm_state
id|rqpm
suffix:semicolon
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|rq
comma
l_int|0
comma
r_sizeof
(paren
id|rq
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|rqpm
comma
l_int|0
comma
r_sizeof
(paren
id|rqpm
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|rq.flags
op_assign
id|REQ_PM_SUSPEND
suffix:semicolon
id|rq.special
op_assign
op_amp
id|args
suffix:semicolon
id|rq.pm
op_assign
op_amp
id|rqpm
suffix:semicolon
id|rqpm.pm_step
op_assign
id|ide_pm_state_start_suspend
suffix:semicolon
id|rqpm.pm_state
op_assign
id|state
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
DECL|function|generic_ide_resume
r_static
r_int
id|generic_ide_resume
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|dev-&gt;driver_data
suffix:semicolon
r_struct
id|request
id|rq
suffix:semicolon
r_struct
id|request_pm_state
id|rqpm
suffix:semicolon
id|ide_task_t
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|rq
comma
l_int|0
comma
r_sizeof
(paren
id|rq
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|rqpm
comma
l_int|0
comma
r_sizeof
(paren
id|rqpm
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|rq.flags
op_assign
id|REQ_PM_RESUME
suffix:semicolon
id|rq.special
op_assign
op_amp
id|args
suffix:semicolon
id|rq.pm
op_assign
op_amp
id|rqpm
suffix:semicolon
id|rqpm.pm_step
op_assign
id|ide_pm_state_start_resume
suffix:semicolon
id|rqpm.pm_state
op_assign
l_int|0
suffix:semicolon
r_return
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_head_wait
)paren
suffix:semicolon
)brace
DECL|function|generic_ide_ioctl
r_int
id|generic_ide_ioctl
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
id|ide_settings_t
op_star
id|setting
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_void
id|__user
op_star
id|p
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ide_setting_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|setting
op_assign
id|ide_find_setting_by_ioctl
c_func
(paren
id|drive
comma
id|cmd
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
id|setting-&gt;read_ioctl
)paren
(brace
id|err
op_assign
id|ide_read_setting
c_func
(paren
id|drive
comma
id|setting
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ide_setting_sem
)paren
suffix:semicolon
r_return
id|err
op_ge
l_int|0
ques
c_cond
id|put_user
c_func
(paren
id|err
comma
(paren
r_int
id|__user
op_star
)paren
id|arg
)paren
suffix:colon
id|err
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|bdev
op_ne
id|bdev-&gt;bd_contains
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
id|err
op_assign
id|ide_write_setting
c_func
(paren
id|drive
comma
id|setting
comma
id|arg
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ide_setting_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|ide_setting_sem
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
(brace
r_struct
id|hd_geometry
id|geom
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
op_logical_or
(paren
id|drive-&gt;media
op_ne
id|ide_disk
op_logical_and
id|drive-&gt;media
op_ne
id|ide_floppy
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|geom.heads
op_assign
id|drive-&gt;bios_head
suffix:semicolon
id|geom.sectors
op_assign
id|drive-&gt;bios_sect
suffix:semicolon
id|geom.cylinders
op_assign
(paren
id|u16
)paren
id|drive-&gt;bios_cyl
suffix:semicolon
multiline_comment|/* truncate */
id|geom.start
op_assign
id|get_start_sect
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|p
comma
op_amp
id|geom
comma
r_sizeof
(paren
r_struct
id|hd_geometry
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|HDIO_OBSOLETE_IDENTITY
suffix:colon
r_case
id|HDIO_GET_IDENTITY
suffix:colon
r_if
c_cond
(paren
id|bdev
op_ne
id|bdev-&gt;bd_contains
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id_read
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOMSG
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|p
comma
id|drive-&gt;id
comma
(paren
id|cmd
op_eq
id|HDIO_GET_IDENTITY
)paren
ques
c_cond
r_sizeof
(paren
op_star
id|drive-&gt;id
)paren
suffix:colon
l_int|142
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_GET_NICE
suffix:colon
r_return
id|put_user
c_func
(paren
id|drive-&gt;dsc_overlap
op_lshift
id|IDE_NICE_DSC_OVERLAP
op_or
id|drive-&gt;atapi_overlap
op_lshift
id|IDE_NICE_ATAPI_OVERLAP
op_or
id|drive-&gt;nice0
op_lshift
id|IDE_NICE_0
op_or
id|drive-&gt;nice1
op_lshift
id|IDE_NICE_1
op_or
id|drive-&gt;nice2
op_lshift
id|IDE_NICE_2
comma
(paren
r_int
id|__user
op_star
)paren
id|arg
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IDE_TASK_IOCTL
r_case
id|HDIO_DRIVE_TASKFILE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
op_logical_or
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_switch
c_cond
(paren
id|drive-&gt;media
)paren
(brace
r_case
id|ide_disk
suffix:colon
r_return
id|ide_taskfile_ioctl
c_func
(paren
id|drive
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOMSG
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IDE_TASK_IOCTL */
r_case
id|HDIO_DRIVE_CMD
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
id|ide_cmd_ioctl
c_func
(paren
id|drive
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_case
id|HDIO_DRIVE_TASK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
id|ide_task_ioctl
c_func
(paren
id|drive
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_case
id|HDIO_SCAN_HWIF
suffix:colon
(brace
id|hw_regs_t
id|hw
suffix:semicolon
r_int
id|args
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
id|p
comma
l_int|3
op_star
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|hw
comma
l_int|0
comma
r_sizeof
(paren
id|hw
)paren
)paren
suffix:semicolon
id|ide_init_hwif_ports
c_func
(paren
op_amp
id|hw
comma
(paren
r_int
r_int
)paren
id|args
(braket
l_int|0
)braket
comma
(paren
r_int
r_int
)paren
id|args
(braket
l_int|1
)braket
comma
l_int|NULL
)paren
suffix:semicolon
id|hw.irq
op_assign
id|args
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ide_register_hw
c_func
(paren
op_amp
id|hw
comma
l_int|NULL
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|HDIO_UNREGISTER_HWIF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* (arg &gt; MAX_HWIFS) checked in function */
id|ide_unregister
c_func
(paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_SET_NICE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_ne
(paren
id|arg
op_amp
(paren
(paren
l_int|1
op_lshift
id|IDE_NICE_DSC_OVERLAP
)paren
op_or
(paren
l_int|1
op_lshift
id|IDE_NICE_1
)paren
)paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|drive-&gt;dsc_overlap
op_assign
(paren
id|arg
op_rshift
id|IDE_NICE_DSC_OVERLAP
)paren
op_amp
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;dsc_overlap
op_logical_and
op_logical_neg
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|supports_dsc_overlap
)paren
(brace
id|drive-&gt;dsc_overlap
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|drive-&gt;nice1
op_assign
(paren
id|arg
op_rshift
id|IDE_NICE_1
)paren
op_amp
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_DRIVE_RESET
suffix:colon
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Abort the current command on the&n;&t;&t;&t; *&t;group if there is one, taking&n;&t;&t;&t; *&t;care not to allow anything else&n;&t;&t;&t; *&t;to be queued and to die on the&n;&t;&t;&t; *&t;spot if we miss one somehow&n;&t;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
m_abort
(paren
id|drive
comma
l_string|&quot;drive reset&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Ensure nothing gets queued after we&n;&t;&t;&t;   drop the lock. Reset will clear the busy */
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
op_assign
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
(paren
r_void
)paren
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;suspend_reset
)paren
(brace
multiline_comment|/*&n; *&t;&t;&t;&t;APM WAKE UP todo !!&n; *&t;&t;&t;&t;int nogoodpower = 1;&n; *&t;&t;&t;&t;while(nogoodpower) {&n; *&t;&t;&t;&t;&t;check_power1() or check_power2()&n; *&t;&t;&t;&t;&t;nogoodpower = 0;&n; *&t;&t;&t;&t;} &n; *&t;&t;&t;&t;HWIF(drive)-&gt;multiproc(drive);&n; */
r_return
id|ioctl_by_bdev
c_func
(paren
id|bdev
comma
id|BLKRRPART
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMEJECT
suffix:colon
r_case
id|CDROMCLOSETRAY
suffix:colon
r_return
id|scsi_cmd_ioctl
c_func
(paren
id|bdev-&gt;bd_disk
comma
id|cmd
comma
id|p
)paren
suffix:semicolon
r_case
id|HDIO_GET_BUSSTATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|bus_state
comma
(paren
r_int
id|__user
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_SET_BUSSTATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busproc
)paren
r_return
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busproc
c_func
(paren
id|drive
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|variable|generic_ide_ioctl
id|EXPORT_SYMBOL
c_func
(paren
id|generic_ide_ioctl
)paren
suffix:semicolon
multiline_comment|/*&n; * stridx() returns the offset of c within s,&n; * or -1 if c is &squot;&bslash;0&squot; or not found within s.&n; */
DECL|function|stridx
r_static
r_int
id|__init
id|stridx
(paren
r_const
r_char
op_star
id|s
comma
r_char
id|c
)paren
(brace
r_char
op_star
id|i
op_assign
id|strchr
c_func
(paren
id|s
comma
id|c
)paren
suffix:semicolon
r_return
(paren
id|i
op_logical_and
id|c
)paren
ques
c_cond
id|i
op_minus
id|s
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * match_parm() does parsing for ide_setup():&n; *&n; * 1. the first char of s must be &squot;=&squot;.&n; * 2. if the remainder matches one of the supplied keywords,&n; *     the index (1 based) of the keyword is negated and returned.&n; * 3. if the remainder is a series of no more than max_vals numbers&n; *     separated by commas, the numbers are saved in vals[] and a&n; *     count of how many were saved is returned.  Base10 is assumed,&n; *     and base16 is allowed when prefixed with &quot;0x&quot;.&n; * 4. otherwise, zero is returned.&n; */
DECL|function|match_parm
r_static
r_int
id|__init
id|match_parm
(paren
r_char
op_star
id|s
comma
r_const
r_char
op_star
id|keywords
(braket
)braket
comma
r_int
id|vals
(braket
)braket
comma
r_int
id|max_vals
)paren
(brace
r_static
r_const
r_char
op_star
id|decimal
op_assign
l_string|&quot;0123456789&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|hex
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_increment
op_eq
l_char|&squot;=&squot;
)paren
(brace
multiline_comment|/*&n;&t;&t; * Try matching against the supplied keywords,&n;&t;&t; * and return -(index+1) if we match one&n;&t;&t; */
r_if
c_cond
(paren
id|keywords
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|keywords
op_ne
l_int|NULL
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
op_star
id|keywords
op_increment
)paren
)paren
r_return
op_minus
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Look for a series of no more than &quot;max_vals&quot;&n;&t;&t; * numeric values separated by commas, in base10,&n;&t;&t; * or base16 when prefixed with &quot;0x&quot;.&n;&t;&t; * Return a count of how many were found.&n;&t;&t; */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
(paren
id|i
op_assign
id|stridx
c_func
(paren
id|decimal
comma
op_star
id|s
)paren
)paren
op_ge
l_int|0
suffix:semicolon
)paren
(brace
id|vals
(braket
id|n
)braket
op_assign
id|i
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
op_assign
id|stridx
c_func
(paren
id|decimal
comma
op_star
op_increment
id|s
)paren
)paren
op_ge
l_int|0
)paren
id|vals
(braket
id|n
)braket
op_assign
(paren
id|vals
(braket
id|n
)braket
op_star
l_int|10
)paren
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;x&squot;
op_logical_and
op_logical_neg
id|vals
(braket
id|n
)braket
)paren
(brace
r_while
c_loop
(paren
(paren
id|i
op_assign
id|stridx
c_func
(paren
id|hex
comma
op_star
op_increment
id|s
)paren
)paren
op_ge
l_int|0
)paren
id|vals
(braket
id|n
)braket
op_assign
(paren
id|vals
(braket
id|n
)braket
op_star
l_int|0x10
)paren
op_plus
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|n
op_eq
id|max_vals
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;,&squot;
op_logical_or
op_star
id|s
op_eq
l_char|&squot;;&squot;
)paren
op_increment
id|s
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|s
)paren
r_return
id|n
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* zero = nothing matched */
)brace
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
DECL|variable|probe_pdc4030
r_static
r_int
id|__initdata
id|probe_pdc4030
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_ALI14XX
DECL|variable|probe_ali14xx
r_static
r_int
id|__initdata
id|probe_ali14xx
suffix:semicolon
r_extern
r_int
id|ali14xx_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_UMC8672
DECL|variable|probe_umc8672
r_static
r_int
id|__initdata
id|probe_umc8672
suffix:semicolon
r_extern
r_int
id|umc8672_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_DTC2278
DECL|variable|probe_dtc2278
r_static
r_int
id|__initdata
id|probe_dtc2278
suffix:semicolon
r_extern
r_int
id|dtc2278_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_HT6560B
DECL|variable|probe_ht6560b
r_static
r_int
id|__initdata
id|probe_ht6560b
suffix:semicolon
r_extern
r_int
id|ht6560b_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_QD65XX
DECL|variable|probe_qd65xx
r_static
r_int
id|__initdata
id|probe_qd65xx
suffix:semicolon
r_extern
r_int
id|qd65xx_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|is_chipset_set
r_static
r_int
id|__initdata
id|is_chipset_set
(braket
id|MAX_HWIFS
)braket
suffix:semicolon
multiline_comment|/*&n; * ide_setup() gets called VERY EARLY during initialization,&n; * to handle kernel &quot;command line&quot; strings beginning with &quot;hdx=&quot; or &quot;ide&quot;.&n; *&n; * Remember to update Documentation/ide.txt if you change something here.&n; */
DECL|function|ide_setup
r_int
id|__init
id|ide_setup
(paren
r_char
op_star
id|s
)paren
(brace
r_int
id|i
comma
id|vals
(braket
l_int|3
)braket
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
r_int
id|hw
comma
id|unit
suffix:semicolon
r_const
r_char
id|max_drive
op_assign
l_char|&squot;a&squot;
op_plus
(paren
(paren
id|MAX_HWIFS
op_star
id|MAX_DRIVES
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_const
r_char
id|max_hwif
op_assign
l_char|&squot;0&squot;
op_plus
(paren
id|MAX_HWIFS
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;hd&quot;
comma
l_int|2
)paren
op_eq
l_int|0
op_logical_and
id|s
(braket
l_int|2
)braket
op_eq
l_char|&squot;=&squot;
)paren
multiline_comment|/* hd= is for hd.c   */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* driver and not us */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;ide&quot;
comma
l_int|3
)paren
op_logical_and
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;idebus&quot;
comma
l_int|6
)paren
op_logical_and
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;hd&quot;
comma
l_int|2
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide_setup: %s&quot;
comma
id|s
)paren
suffix:semicolon
id|init_ide_data
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDOUBLER
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ide=doubler&quot;
)paren
)paren
(brace
r_extern
r_int
id|ide_doubler
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; : Enabled support for IDE doublers&bslash;n&quot;
)paren
suffix:semicolon
id|ide_doubler
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEDOUBLER */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ide=nodma&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IDE: Prevented DMA&bslash;n&quot;
)paren
suffix:semicolon
id|noautodma
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ide=reverse&quot;
)paren
)paren
(brace
id|ide_scan_direction
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; : Enabled support for IDE inverse scan order.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEPCI */
multiline_comment|/*&n;&t; * Look for drive options:  &quot;hdx=&quot;&n;&t; */
r_if
c_cond
(paren
id|s
(braket
l_int|0
)braket
op_eq
l_char|&squot;h&squot;
op_logical_and
id|s
(braket
l_int|1
)braket
op_eq
l_char|&squot;d&squot;
op_logical_and
id|s
(braket
l_int|2
)braket
op_ge
l_char|&squot;a&squot;
op_logical_and
id|s
(braket
l_int|2
)braket
op_le
id|max_drive
)paren
(brace
r_const
r_char
op_star
id|hd_words
(braket
)braket
op_assign
(brace
l_string|&quot;none&quot;
comma
l_string|&quot;noprobe&quot;
comma
l_string|&quot;nowerr&quot;
comma
l_string|&quot;cdrom&quot;
comma
l_string|&quot;serialize&quot;
comma
l_string|&quot;autotune&quot;
comma
l_string|&quot;noautotune&quot;
comma
l_string|&quot;stroke&quot;
comma
l_string|&quot;swapdata&quot;
comma
l_string|&quot;bswap&quot;
comma
l_string|&quot;minus11&quot;
comma
l_string|&quot;remap&quot;
comma
l_string|&quot;remap63&quot;
comma
l_string|&quot;scsi&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|unit
op_assign
id|s
(braket
l_int|2
)braket
op_minus
l_char|&squot;a&squot;
suffix:semicolon
id|hw
op_assign
id|unit
op_div
id|MAX_DRIVES
suffix:semicolon
id|unit
op_assign
id|unit
op_mod
id|MAX_DRIVES
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|hw
)braket
suffix:semicolon
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|s
op_plus
l_int|4
comma
l_string|&quot;ide-&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|strlcpy
c_func
(paren
id|drive-&gt;driver_req
comma
id|s
op_plus
l_int|4
comma
r_sizeof
(paren
id|drive-&gt;driver_req
)paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|3
)braket
comma
id|hd_words
comma
id|vals
comma
l_int|3
)paren
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
multiline_comment|/* &quot;none&quot; */
r_case
op_minus
l_int|2
suffix:colon
multiline_comment|/* &quot;noprobe&quot; */
id|drive-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|3
suffix:colon
multiline_comment|/* &quot;nowerr&quot; */
id|drive-&gt;bad_wstat
op_assign
id|BAD_R_STAT
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|4
suffix:colon
multiline_comment|/* &quot;cdrom&quot; */
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;media
op_assign
id|ide_cdrom
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|5
suffix:colon
multiline_comment|/* &quot;serialize&quot; */
id|printk
c_func
(paren
l_string|&quot; -- USE &bslash;&quot;ide%d=serialize&bslash;&quot; INSTEAD&quot;
comma
id|hw
)paren
suffix:semicolon
r_goto
id|do_serialize
suffix:semicolon
r_case
op_minus
l_int|6
suffix:colon
multiline_comment|/* &quot;autotune&quot; */
id|drive-&gt;autotune
op_assign
id|IDE_TUNE_AUTO
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|7
suffix:colon
multiline_comment|/* &quot;noautotune&quot; */
id|drive-&gt;autotune
op_assign
id|IDE_TUNE_NOAUTO
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|8
suffix:colon
multiline_comment|/* stroke */
id|drive-&gt;stroke
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|9
suffix:colon
multiline_comment|/* &quot;swapdata&quot; */
r_case
op_minus
l_int|10
suffix:colon
multiline_comment|/* &quot;bswap&quot; */
id|drive-&gt;bswap
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|12
suffix:colon
multiline_comment|/* &quot;remap&quot; */
id|drive-&gt;remap_0_to_1
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|13
suffix:colon
multiline_comment|/* &quot;remap63&quot; */
id|drive-&gt;sect0
op_assign
l_int|63
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|14
suffix:colon
multiline_comment|/* &quot;scsi&quot; */
id|drive-&gt;scsi
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* cyl,head,sect */
id|drive-&gt;media
op_assign
id|ide_disk
suffix:semicolon
id|drive-&gt;cyl
op_assign
id|drive-&gt;bios_cyl
op_assign
id|vals
(braket
l_int|0
)braket
suffix:semicolon
id|drive-&gt;head
op_assign
id|drive-&gt;bios_head
op_assign
id|vals
(braket
l_int|1
)braket
suffix:semicolon
id|drive-&gt;sect
op_assign
id|drive-&gt;bios_sect
op_assign
id|vals
(braket
l_int|2
)braket
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;forced_geom
op_assign
l_int|1
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_default
suffix:colon
r_goto
id|bad_option
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|s
(braket
l_int|0
)braket
op_ne
l_char|&squot;i&squot;
op_logical_or
id|s
(braket
l_int|1
)braket
op_ne
l_char|&squot;d&squot;
op_logical_or
id|s
(braket
l_int|2
)braket
op_ne
l_char|&squot;e&squot;
)paren
r_goto
id|bad_option
suffix:semicolon
multiline_comment|/*&n;&t; * Look for bus speed option:  &quot;idebus=&quot;&n;&t; */
r_if
c_cond
(paren
id|s
(braket
l_int|3
)braket
op_eq
l_char|&squot;b&squot;
op_logical_and
id|s
(braket
l_int|4
)braket
op_eq
l_char|&squot;u&squot;
op_logical_and
id|s
(braket
l_int|5
)braket
op_eq
l_char|&squot;s&squot;
)paren
(brace
r_if
c_cond
(paren
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|6
)braket
comma
l_int|NULL
comma
id|vals
comma
l_int|1
)paren
op_ne
l_int|1
)paren
r_goto
id|bad_option
suffix:semicolon
r_if
c_cond
(paren
id|vals
(braket
l_int|0
)braket
op_ge
l_int|20
op_logical_and
id|vals
(braket
l_int|0
)braket
op_le
l_int|66
)paren
(brace
id|idebus_parameter
op_assign
id|vals
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; -- BAD BUS SPEED! Expected value from 20 to 66&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Look for interface options:  &quot;idex=&quot;&n;&t; */
r_if
c_cond
(paren
id|s
(braket
l_int|3
)braket
op_ge
l_char|&squot;0&squot;
op_logical_and
id|s
(braket
l_int|3
)braket
op_le
id|max_hwif
)paren
(brace
multiline_comment|/*&n;&t;&t; * Be VERY CAREFUL changing this: note hardcoded indexes below&n;&t;&t; * (-8, -9, -10) are reserved to ease the hardcoding.&n;&t;&t; */
r_static
r_const
r_char
op_star
id|ide_words
(braket
)braket
op_assign
(brace
l_string|&quot;noprobe&quot;
comma
l_string|&quot;serialize&quot;
comma
l_string|&quot;autotune&quot;
comma
l_string|&quot;noautotune&quot;
comma
l_string|&quot;reset&quot;
comma
l_string|&quot;dma&quot;
comma
l_string|&quot;ata66&quot;
comma
l_string|&quot;minus8&quot;
comma
l_string|&quot;minus9&quot;
comma
l_string|&quot;minus10&quot;
comma
l_string|&quot;four&quot;
comma
l_string|&quot;qd65xx&quot;
comma
l_string|&quot;ht6560b&quot;
comma
l_string|&quot;cmd640_vlb&quot;
comma
l_string|&quot;dtc2278&quot;
comma
l_string|&quot;umc8672&quot;
comma
l_string|&quot;ali14xx&quot;
comma
l_string|&quot;dc4030&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|hw
op_assign
id|s
(braket
l_int|3
)braket
op_minus
l_char|&squot;0&squot;
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|hw
)braket
suffix:semicolon
id|i
op_assign
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|4
)braket
comma
id|ide_words
comma
id|vals
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Cryptic check to ensure chipset not already set for hwif.&n;&t;&t; * Note: we can&squot;t depend on hwif-&gt;chipset here.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|i
op_ge
op_minus
l_int|18
op_logical_and
id|i
op_le
op_minus
l_int|11
)paren
op_logical_or
(paren
id|i
OG
l_int|0
op_logical_and
id|i
op_le
l_int|3
)paren
)paren
(brace
multiline_comment|/* chipset already specified */
r_if
c_cond
(paren
id|is_chipset_set
(braket
id|hw
)braket
)paren
r_goto
id|bad_option
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
op_minus
l_int|18
op_logical_and
id|i
op_le
op_minus
l_int|11
)paren
(brace
multiline_comment|/* these drivers are for &quot;ide0=&quot; only */
r_if
c_cond
(paren
id|hw
op_ne
l_int|0
)paren
r_goto
id|bad_hwif
suffix:semicolon
multiline_comment|/* chipset already specified for 2nd port */
r_if
c_cond
(paren
id|is_chipset_set
(braket
id|hw
op_plus
l_int|1
)braket
)paren
r_goto
id|bad_option
suffix:semicolon
)brace
id|is_chipset_set
(braket
id|hw
)braket
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|i
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
r_case
op_minus
l_int|18
suffix:colon
multiline_comment|/* &quot;dc4030&quot; */
id|probe_pdc4030
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_ALI14XX
r_case
op_minus
l_int|17
suffix:colon
multiline_comment|/* &quot;ali14xx&quot; */
id|probe_ali14xx
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_UMC8672
r_case
op_minus
l_int|16
suffix:colon
multiline_comment|/* &quot;umc8672&quot; */
id|probe_umc8672
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_DTC2278
r_case
op_minus
l_int|15
suffix:colon
multiline_comment|/* &quot;dtc2278&quot; */
id|probe_dtc2278
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_CMD640
r_case
op_minus
l_int|14
suffix:colon
multiline_comment|/* &quot;cmd640_vlb&quot; */
(brace
r_extern
r_int
id|cmd640_vlb
suffix:semicolon
multiline_comment|/* flag for cmd640.c */
id|cmd640_vlb
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_HT6560B
r_case
op_minus
l_int|13
suffix:colon
multiline_comment|/* &quot;ht6560b&quot; */
id|probe_ht6560b
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_QD65XX
r_case
op_minus
l_int|12
suffix:colon
multiline_comment|/* &quot;qd65xx&quot; */
id|probe_qd65xx
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_4DRIVES
r_case
op_minus
l_int|11
suffix:colon
multiline_comment|/* &quot;four&quot; drives on one set of ports */
(brace
id|ide_hwif_t
op_star
id|mate
op_assign
op_amp
id|ide_hwifs
(braket
id|hw
op_xor
l_int|1
)braket
suffix:semicolon
id|mate-&gt;drives
(braket
l_int|0
)braket
dot
id|select.all
op_xor_assign
l_int|0x20
suffix:semicolon
id|mate-&gt;drives
(braket
l_int|1
)braket
dot
id|select.all
op_xor_assign
l_int|0x20
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|mate-&gt;chipset
op_assign
id|ide_4drives
suffix:semicolon
id|mate-&gt;irq
op_assign
id|hwif-&gt;irq
suffix:semicolon
id|memcpy
c_func
(paren
id|mate-&gt;io_ports
comma
id|hwif-&gt;io_ports
comma
r_sizeof
(paren
id|hwif-&gt;io_ports
)paren
)paren
suffix:semicolon
r_goto
id|do_serialize
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_4DRIVES */
r_case
op_minus
l_int|10
suffix:colon
multiline_comment|/* minus10 */
r_case
op_minus
l_int|9
suffix:colon
multiline_comment|/* minus9 */
r_case
op_minus
l_int|8
suffix:colon
multiline_comment|/* minus8 */
r_goto
id|bad_option
suffix:semicolon
r_case
op_minus
l_int|7
suffix:colon
multiline_comment|/* ata66 */
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
id|hwif-&gt;udma_four
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#else
r_goto
id|bad_hwif
suffix:semicolon
macro_line|#endif
r_case
op_minus
l_int|6
suffix:colon
multiline_comment|/* dma */
id|hwif-&gt;autodma
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|5
suffix:colon
multiline_comment|/* &quot;reset&quot; */
id|hwif-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|4
suffix:colon
multiline_comment|/* &quot;noautotune&quot; */
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|autotune
op_assign
id|IDE_TUNE_NOAUTO
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|autotune
op_assign
id|IDE_TUNE_NOAUTO
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|3
suffix:colon
multiline_comment|/* &quot;autotune&quot; */
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|autotune
op_assign
id|IDE_TUNE_AUTO
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|autotune
op_assign
id|IDE_TUNE_AUTO
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|2
suffix:colon
multiline_comment|/* &quot;serialize&quot; */
id|do_serialize
suffix:colon
id|hwif-&gt;mate
op_assign
op_amp
id|ide_hwifs
(braket
id|hw
op_xor
l_int|1
)braket
suffix:semicolon
id|hwif-&gt;mate-&gt;mate
op_assign
id|hwif
suffix:semicolon
id|hwif-&gt;serialized
op_assign
id|hwif-&gt;mate-&gt;serialized
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|1
suffix:colon
multiline_comment|/* &quot;noprobe&quot; */
id|hwif-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* base */
id|vals
(braket
l_int|1
)braket
op_assign
id|vals
(braket
l_int|0
)braket
op_plus
l_int|0x206
suffix:semicolon
multiline_comment|/* default ctl */
r_case
l_int|2
suffix:colon
multiline_comment|/* base,ctl */
id|vals
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default irq = probe for it */
r_case
l_int|3
suffix:colon
multiline_comment|/* base,ctl,irq */
id|hwif-&gt;hw.irq
op_assign
id|vals
(braket
l_int|2
)braket
suffix:semicolon
id|ide_init_hwif_ports
c_func
(paren
op_amp
id|hwif-&gt;hw
comma
(paren
r_int
r_int
)paren
id|vals
(braket
l_int|0
)braket
comma
(paren
r_int
r_int
)paren
id|vals
(braket
l_int|1
)braket
comma
op_amp
id|hwif-&gt;irq
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hwif-&gt;io_ports
comma
id|hwif-&gt;hw.io_ports
comma
r_sizeof
(paren
id|hwif-&gt;io_ports
)paren
)paren
suffix:semicolon
id|hwif-&gt;irq
op_assign
id|vals
(braket
l_int|2
)braket
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|ide_forced
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
l_int|0
suffix:colon
r_goto
id|bad_option
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot; -- SUPPORT NOT CONFIGURED IN THIS KERNEL&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|bad_option
suffix:colon
id|printk
c_func
(paren
l_string|&quot; -- BAD OPTION&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|bad_hwif
suffix:colon
id|printk
c_func
(paren
l_string|&quot;-- NOT SUPPORTED ON ide%d&quot;
comma
id|hw
)paren
suffix:semicolon
id|done
suffix:colon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_extern
r_void
id|pnpide_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|h8300_ide_init
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * probe_for_hwifs() finds/initializes &quot;known&quot; IDE interfaces&n; */
DECL|function|probe_for_hwifs
r_static
r_void
id|__init
id|probe_for_hwifs
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
id|ide_scan_pcibus
c_func
(paren
id|ide_scan_direction
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEPCI */
macro_line|#ifdef CONFIG_ETRAX_IDE
(brace
r_extern
r_void
id|init_e100_ide
c_func
(paren
r_void
)paren
suffix:semicolon
id|init_e100_ide
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ETRAX_IDE */
macro_line|#ifdef CONFIG_BLK_DEV_CMD640
(brace
r_extern
r_void
id|ide_probe_for_cmd640x
c_func
(paren
r_void
)paren
suffix:semicolon
id|ide_probe_for_cmd640x
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_CMD640 */
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
(brace
r_extern
r_int
id|pdc4030_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
id|probe_pdc4030
)paren
(paren
r_void
)paren
id|pdc4030_init
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_PDC4030 */
macro_line|#ifdef CONFIG_BLK_DEV_IDE_PMAC
(brace
r_extern
r_void
id|pmac_ide_probe
c_func
(paren
r_void
)paren
suffix:semicolon
id|pmac_ide_probe
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDE_PMAC */
macro_line|#ifdef CONFIG_BLK_DEV_GAYLE
(brace
r_extern
r_void
id|gayle_init
c_func
(paren
r_void
)paren
suffix:semicolon
id|gayle_init
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_GAYLE */
macro_line|#ifdef CONFIG_BLK_DEV_FALCON_IDE
(brace
r_extern
r_void
id|falconide_init
c_func
(paren
r_void
)paren
suffix:semicolon
id|falconide_init
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_FALCON_IDE */
macro_line|#ifdef CONFIG_BLK_DEV_MAC_IDE
(brace
r_extern
r_void
id|macide_init
c_func
(paren
r_void
)paren
suffix:semicolon
id|macide_init
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_MAC_IDE */
macro_line|#ifdef CONFIG_BLK_DEV_Q40IDE
(brace
r_extern
r_void
id|q40ide_init
c_func
(paren
r_void
)paren
suffix:semicolon
id|q40ide_init
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_Q40IDE */
macro_line|#ifdef CONFIG_BLK_DEV_BUDDHA
(brace
r_extern
r_void
id|buddha_init
c_func
(paren
r_void
)paren
suffix:semicolon
id|buddha_init
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_BUDDHA */
macro_line|#ifdef CONFIG_BLK_DEV_IDEPNP
id|pnpide_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_H8300
id|h8300_ide_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;Actually unregister the subdriver. Called with the&n; *&t;request lock dropped.&n; */
DECL|function|default_cleanup
r_static
r_int
id|default_cleanup
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
id|ide_unregister_subdriver
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
DECL|function|default_do_request
r_static
id|ide_startstop_t
id|default_do_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|sector_t
id|block
)paren
(brace
id|ide_end_request
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|default_end_request
r_static
r_int
id|default_end_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|uptodate
comma
r_int
id|nr_sects
)paren
(brace
r_return
id|ide_end_request
c_func
(paren
id|drive
comma
id|uptodate
comma
id|nr_sects
)paren
suffix:semicolon
)brace
DECL|function|default_sense
r_static
id|u8
id|default_sense
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|u8
id|stat
)paren
(brace
r_return
id|ide_dump_status
c_func
(paren
id|drive
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
)brace
DECL|function|default_error
r_static
id|ide_startstop_t
id|default_error
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|u8
id|stat
)paren
(brace
r_return
id|ide_error
c_func
(paren
id|drive
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
)brace
DECL|function|default_pre_reset
r_static
r_void
id|default_pre_reset
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
)brace
DECL|function|default_capacity
r_static
id|sector_t
id|default_capacity
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
l_int|0x7fffffff
suffix:semicolon
)brace
DECL|function|default_special
r_static
id|ide_startstop_t
id|default_special
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|special_t
op_star
id|s
op_assign
op_amp
id|drive-&gt;special
suffix:semicolon
id|s-&gt;all
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;mult_req
op_assign
l_int|0
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|default_attach
r_static
r_int
id|default_attach
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: does not support hotswap of device class !&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|default_abort
r_static
id|ide_startstop_t
id|default_abort
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_return
id|ide_abort
c_func
(paren
id|drive
comma
id|msg
)paren
suffix:semicolon
)brace
DECL|function|default_start_power_step
r_static
id|ide_startstop_t
id|default_start_power_step
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|rq-&gt;pm-&gt;pm_step
op_assign
id|ide_pm_state_completed
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|setup_driver_defaults
r_static
r_void
id|setup_driver_defaults
(paren
id|ide_driver_t
op_star
id|d
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;cleanup
op_eq
l_int|NULL
)paren
id|d-&gt;cleanup
op_assign
id|default_cleanup
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;do_request
op_eq
l_int|NULL
)paren
id|d-&gt;do_request
op_assign
id|default_do_request
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;end_request
op_eq
l_int|NULL
)paren
id|d-&gt;end_request
op_assign
id|default_end_request
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;sense
op_eq
l_int|NULL
)paren
id|d-&gt;sense
op_assign
id|default_sense
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;error
op_eq
l_int|NULL
)paren
id|d-&gt;error
op_assign
id|default_error
suffix:semicolon
r_if
c_cond
(paren
id|d
op_member_access_from_pointer
m_abort
op_eq
l_int|NULL
)paren
id|d
op_member_access_from_pointer
m_abort
op_assign
id|default_abort
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;pre_reset
op_eq
l_int|NULL
)paren
id|d-&gt;pre_reset
op_assign
id|default_pre_reset
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;capacity
op_eq
l_int|NULL
)paren
id|d-&gt;capacity
op_assign
id|default_capacity
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;special
op_eq
l_int|NULL
)paren
id|d-&gt;special
op_assign
id|default_special
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;attach
op_eq
l_int|NULL
)paren
id|d-&gt;attach
op_assign
id|default_attach
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;start_power_step
op_eq
l_int|NULL
)paren
id|d-&gt;start_power_step
op_assign
id|default_start_power_step
suffix:semicolon
)brace
DECL|function|ide_register_subdriver
r_int
id|ide_register_subdriver
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_driver_t
op_star
id|driver
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|drive-&gt;driver
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
op_logical_or
id|drive-&gt;driver
op_ne
op_amp
id|idedefault_driver
op_logical_or
id|drive-&gt;usage
op_logical_or
id|drive-&gt;dead
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|drive-&gt;driver
op_assign
id|driver
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|drives_lock
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|drive-&gt;list
comma
op_amp
id|driver-&gt;drives
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|drives_lock
)paren
suffix:semicolon
singleline_comment|//&t;printk(KERN_INFO &quot;%s: attached %s driver.&bslash;n&quot;, drive-&gt;name, driver-&gt;name);
r_if
c_cond
(paren
(paren
id|drive-&gt;autotune
op_eq
id|IDE_TUNE_DEFAULT
)paren
op_logical_or
(paren
id|drive-&gt;autotune
op_eq
id|IDE_TUNE_AUTO
)paren
)paren
(brace
multiline_comment|/* DMA timings and setup moved to ide-probe.c */
id|drive-&gt;dsc_overlap
op_assign
(paren
id|drive-&gt;next
op_ne
id|drive
op_logical_and
id|driver-&gt;supports_dsc_overlap
)paren
suffix:semicolon
id|drive-&gt;nice1
op_assign
l_int|1
suffix:semicolon
)brace
id|drive-&gt;suspend_reset
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_if
c_cond
(paren
id|drive-&gt;driver
op_ne
op_amp
id|idedefault_driver
)paren
(brace
id|ide_add_proc_entries
c_func
(paren
id|drive-&gt;proc
comma
id|generic_subdriver_entries
comma
id|drive
)paren
suffix:semicolon
id|ide_add_proc_entries
c_func
(paren
id|drive-&gt;proc
comma
id|driver-&gt;proc
comma
id|drive
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ide_register_subdriver
id|EXPORT_SYMBOL
c_func
(paren
id|ide_register_subdriver
)paren
suffix:semicolon
DECL|function|ide_unregister_subdriver
r_int
id|ide_unregister_subdriver
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ide_setting_sem
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;usage
op_logical_or
id|drive-&gt;driver
op_eq
op_amp
id|idedefault_driver
op_logical_or
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ide_setting_sem
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
id|ide_remove_proc_entries
c_func
(paren
id|drive-&gt;proc
comma
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|proc
)paren
suffix:semicolon
id|ide_remove_proc_entries
c_func
(paren
id|drive-&gt;proc
comma
id|generic_subdriver_entries
)paren
suffix:semicolon
macro_line|#endif
id|auto_remove_settings
c_func
(paren
id|drive
)paren
suffix:semicolon
id|drive-&gt;driver
op_assign
op_amp
id|idedefault_driver
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ide_setting_sem
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|drives_lock
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|drive-&gt;list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|drives_lock
)paren
suffix:semicolon
multiline_comment|/* drive will be added to &amp;idedefault_driver-&gt;drives in ata_attach() */
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ide_unregister_subdriver
id|EXPORT_SYMBOL
c_func
(paren
id|ide_unregister_subdriver
)paren
suffix:semicolon
DECL|function|ide_drive_remove
r_static
r_int
id|ide_drive_remove
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|container_of
c_func
(paren
id|dev
comma
id|ide_drive_t
comma
id|gendev
)paren
suffix:semicolon
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_register_driver
r_int
id|ide_register_driver
c_func
(paren
id|ide_driver_t
op_star
id|driver
)paren
(brace
r_struct
id|list_head
id|list
suffix:semicolon
r_struct
id|list_head
op_star
id|list_loop
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp_storage
suffix:semicolon
id|setup_driver_defaults
c_func
(paren
id|driver
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|drivers_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|driver-&gt;drivers
comma
op_amp
id|drivers
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|drivers_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|list
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|drives_lock
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|idedefault_driver.drives
comma
op_amp
id|list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|drives_lock
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|list_loop
comma
id|tmp_storage
comma
op_amp
id|list
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|container_of
c_func
(paren
id|list_loop
comma
id|ide_drive_t
comma
id|list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|drive-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
)paren
id|ata_attach
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
id|driver-&gt;gen_driver.name
op_assign
(paren
r_char
op_star
)paren
id|driver-&gt;name
suffix:semicolon
id|driver-&gt;gen_driver.bus
op_assign
op_amp
id|ide_bus_type
suffix:semicolon
id|driver-&gt;gen_driver.remove
op_assign
id|ide_drive_remove
suffix:semicolon
r_return
id|driver_register
c_func
(paren
op_amp
id|driver-&gt;gen_driver
)paren
suffix:semicolon
)brace
DECL|variable|ide_register_driver
id|EXPORT_SYMBOL
c_func
(paren
id|ide_register_driver
)paren
suffix:semicolon
DECL|function|ide_unregister_driver
r_void
id|ide_unregister_driver
c_func
(paren
id|ide_driver_t
op_star
id|driver
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|drivers_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|driver-&gt;drivers
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|drivers_lock
)paren
suffix:semicolon
id|driver_unregister
c_func
(paren
op_amp
id|driver-&gt;gen_driver
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|driver-&gt;drives
)paren
)paren
(brace
id|drive
op_assign
id|list_entry
c_func
(paren
id|driver-&gt;drives.next
comma
id|ide_drive_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver
op_member_access_from_pointer
id|cleanup
c_func
(paren
id|drive
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: cleanup_module() called while still busy&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|ata_attach
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
DECL|variable|ide_unregister_driver
id|EXPORT_SYMBOL
c_func
(paren
id|ide_unregister_driver
)paren
suffix:semicolon
DECL|variable|ide_fops
r_struct
id|block_device_operations
id|ide_fops
(braket
)braket
op_assign
(brace
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|ide_open
comma
)brace
)brace
suffix:semicolon
DECL|variable|ide_fops
id|EXPORT_SYMBOL
c_func
(paren
id|ide_fops
)paren
suffix:semicolon
multiline_comment|/*&n; * Probe module&n; */
DECL|variable|ide_lock
id|EXPORT_SYMBOL
c_func
(paren
id|ide_lock
)paren
suffix:semicolon
DECL|variable|ide_bus_type
r_struct
id|bus_type
id|ide_bus_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ide&quot;
comma
dot
id|suspend
op_assign
id|generic_ide_suspend
comma
dot
id|resume
op_assign
id|generic_ide_resume
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * This is gets invoked once during initialization, to set *everything* up&n; */
DECL|function|ide_init
r_int
id|__init
id|ide_init
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Uniform Multi-Platform E-IDE driver &quot;
id|REVISION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|devfs_mk_dir
c_func
(paren
l_string|&quot;ide&quot;
)paren
suffix:semicolon
id|system_bus_speed
op_assign
id|ide_system_bus_speed
c_func
(paren
)paren
suffix:semicolon
id|bus_register
c_func
(paren
op_amp
id|ide_bus_type
)paren
suffix:semicolon
id|init_ide_data
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|proc_ide_root
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;ide&quot;
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_ALI14XX
r_if
c_cond
(paren
id|probe_ali14xx
)paren
(paren
r_void
)paren
id|ali14xx_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_UMC8672
r_if
c_cond
(paren
id|probe_umc8672
)paren
(paren
r_void
)paren
id|umc8672_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_DTC2278
r_if
c_cond
(paren
id|probe_dtc2278
)paren
(paren
r_void
)paren
id|dtc2278_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_HT6560B
r_if
c_cond
(paren
id|probe_ht6560b
)paren
(paren
r_void
)paren
id|ht6560b_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_QD65XX
r_if
c_cond
(paren
id|probe_qd65xx
)paren
(paren
r_void
)paren
id|qd65xx_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|initializing
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Probe for special PCI and other &quot;known&quot; interface chipsets. */
id|probe_for_hwifs
c_func
(paren
)paren
suffix:semicolon
id|initializing
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|proc_ide_create
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|options
r_char
op_star
id|options
op_assign
l_int|NULL
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|options
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|function|parse_options
r_static
r_void
id|__init
id|parse_options
(paren
r_char
op_star
id|line
)paren
(brace
r_char
op_star
id|next
op_assign
id|line
suffix:semicolon
r_if
c_cond
(paren
id|line
op_eq
l_int|NULL
op_logical_or
op_logical_neg
op_star
id|line
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
(paren
id|line
op_assign
id|next
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|next
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot; &squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_star
id|next
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ide_setup
c_func
(paren
id|line
)paren
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;Unknown option &squot;%s&squot;&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
)brace
)brace
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
(brace
id|parse_options
c_func
(paren
id|options
)paren
suffix:semicolon
r_return
id|ide_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
r_int
id|index
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
(brace
id|ide_unregister
c_func
(paren
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_hwifs
(braket
id|index
)braket
dot
id|dma_base
)paren
(paren
r_void
)paren
id|ide_release_dma
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|index
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
id|proc_ide_destroy
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|devfs_remove
c_func
(paren
l_string|&quot;ide&quot;
)paren
suffix:semicolon
id|bus_unregister
c_func
(paren
op_amp
id|ide_bus_type
)paren
suffix:semicolon
)brace
macro_line|#else /* !MODULE */
id|__setup
c_func
(paren
l_string|&quot;&quot;
comma
id|ide_setup
)paren
suffix:semicolon
DECL|variable|ide_init
id|module_init
c_func
(paren
id|ide_init
)paren
suffix:semicolon
macro_line|#endif /* MODULE */
eof
