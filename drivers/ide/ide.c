multiline_comment|/**** vi:set ts=8 sts=8 sw=8:************************************************&n; *&n; *  Copyright (C) 1994-1998,2002  Linus Torvalds and authors:&n; *&n; *&t;Mark Lord&t;&lt;mlord@pobox.com&gt;&n; *      Gadi Oxman&t;&lt;gadio@netvision.net.il&gt;&n; *      Andre Hedrick&t;&lt;andre@linux-ide.org&gt;&n; *&t;Jens Axboe&t;&lt;axboe@suse.de&gt;&n; *      Marcin Dalecki&t;&lt;martin@dalecki.de&gt;&n; *&n; *  See linux/MAINTAINERS for address of current maintainer.&n; *&n; * This is the basic common code of the ATA interface drivers.&n; *&n; * It supports up to MAX_HWIFS IDE interfaces, on one or more IRQs (usually 14&n; * &amp; 15).  There can be up to two drives per interface, as per the ATA-7 spec.&n; *&n; * Primary:    ide0, port 0x1f0; major=3;  hda is minor=0; hdb is minor=64&n; * Secondary:  ide1, port 0x170; major=22; hdc is minor=0; hdd is minor=64&n; * Tertiary:   ide2, port 0x???; major=33; hde is minor=0; hdf is minor=64&n; * Quaternary: ide3, port 0x???; major=34; hdg is minor=0; hdh is minor=64&n; * ...&n; *&n; *  Contributors:&n; *&n; *&t;Drew Eckhardt&n; *&t;Branko Lankester&t;&lt;lankeste@fwi.uva.nl&gt;&n; *&t;Mika Liljeberg&n; *&t;Delman Lee&t;&t;&lt;delman@ieee.org&gt;&n; *&t;Scott Snyder&t;&t;&lt;snyder@fnald0.fnal.gov&gt;&n; *&n; *  Some additional driver compile-time options are in &lt;linux/ide.h&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#ifndef MODULE
macro_line|# include &lt;linux/init.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &quot;ata-timing.h&quot;
macro_line|#include &quot;pcihost.h&quot;
macro_line|#include &quot;ioctl.h&quot;
multiline_comment|/* default maximum number of failures */
DECL|macro|IDE_DEFAULT_MAX_FAILURES
mdefine_line|#define IDE_DEFAULT_MAX_FAILURES&t;1
multiline_comment|/*&n; * CompactFlash cards and their relatives pretend to be removable hard disks, except:&n; *&t;(1) they never have a slave unit, and&n; *&t;(2) they don&squot;t have a door lock mechanisms.&n; * This test catches them, and is invoked elsewhere when setting appropriate config bits.&n; *&n; * FIXME FIXME: Yes this is for certain applicable for all of them as time has shown.&n; *&n; * FIXME: This treatment is probably applicable for *all* PCMCIA (PC CARD) devices,&n; * so in linux 2.3.x we should change this to just treat all PCMCIA drives this way,&n; * and get rid of the model-name tests below (too big of an interface change for 2.2.x).&n; * At that time, we might also consider parameterizing the timeouts and retries,&n; * since these are MUCH faster than mechanical drives.&t;-M.Lord&n; */
DECL|function|drive_is_flashcard
r_int
id|drive_is_flashcard
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|flashcards
(braket
)braket
op_assign
(brace
l_string|&quot;KODAK ATA_FLASH&quot;
comma
l_string|&quot;Hitachi CV&quot;
comma
l_string|&quot;SunDisk SDCFB&quot;
comma
l_string|&quot;HAGIWARA HPC&quot;
comma
l_string|&quot;LEXAR ATA_FLASH&quot;
comma
l_string|&quot;ATA_FLASH&quot;
multiline_comment|/* Simple Tech */
)brace
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;removable
op_logical_and
id|id
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|id-&gt;config
op_eq
l_int|0x848a
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* CompactFlash */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|flashcards
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
id|flashcards
(braket
id|i
)braket
comma
id|strlen
c_func
(paren
id|flashcards
(braket
id|i
)braket
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__ide_end_request
r_int
id|__ide_end_request
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
id|uptodate
comma
r_int
r_int
id|nr_secs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|drive-&gt;channel-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
id|REQ_STARTED
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * small hack to eliminate locking from ide_end_request to grab&n;&t; * the first segment number of sectors&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|nr_secs
)paren
id|nr_secs
op_assign
id|rq-&gt;hard_cur_sectors
suffix:semicolon
multiline_comment|/*&n;&t; * Decide whether to reenable DMA -- 3 is a random magic for now,&n;&t; * if we DMA timeout more than 3 times, just stay in PIO.&n;&t; */
r_if
c_cond
(paren
id|drive-&gt;state
op_eq
id|DMA_PIO_RETRY
op_logical_and
id|drive-&gt;retry_pio
op_le
l_int|3
)paren
(brace
id|drive-&gt;state
op_assign
l_int|0
suffix:semicolon
id|udma_enable
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|end_that_request_first
c_func
(paren
id|rq
comma
id|uptodate
comma
id|nr_secs
)paren
)paren
(brace
id|add_blkdev_randomness
c_func
(paren
id|major
c_func
(paren
id|rq-&gt;rq_dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blk_rq_tagged
c_func
(paren
id|rq
)paren
)paren
id|blkdev_dequeue_request
c_func
(paren
id|rq
)paren
suffix:semicolon
r_else
id|blk_queue_end_tag
c_func
(paren
op_amp
id|drive-&gt;queue
comma
id|rq
)paren
suffix:semicolon
id|drive-&gt;rq
op_assign
l_int|NULL
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|rq
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|drive-&gt;channel-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* This is the default end request function as well */
DECL|function|ide_end_request
r_int
id|ide_end_request
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
id|uptodate
)paren
(brace
r_return
id|__ide_end_request
c_func
(paren
id|drive
comma
id|rq
comma
id|uptodate
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This should get invoked any time we exit the driver to&n; * wait for an interrupt response from a drive.  handler() points&n; * at the appropriate code to handle the next interrupt, and a&n; * timer is started to prevent us from waiting forever in case&n; * something goes wrong (see the ide_timer_expiry() handler later on).&n; */
DECL|function|ide_set_handler
r_void
id|ide_set_handler
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
id|ata_handler_t
id|handler
comma
r_int
r_int
id|timeout
comma
id|ata_expiry_t
id|expiry
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ata_channel
op_star
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|ch-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;handler
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ide_set_handler: handler not null; old=%p, new=%p, from %p&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ch-&gt;handler
comma
id|handler
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
id|ch-&gt;handler
op_assign
id|handler
suffix:semicolon
id|ch-&gt;expiry
op_assign
id|expiry
suffix:semicolon
id|ch-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|ch-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|auto_reduce_xfer
r_static
id|u8
id|auto_reduce_xfer
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;crc_count
)paren
r_return
id|drive-&gt;current_speed
suffix:semicolon
id|drive-&gt;crc_count
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|drive-&gt;current_speed
)paren
(brace
r_case
id|XFER_UDMA_7
suffix:colon
r_return
id|XFER_UDMA_6
suffix:semicolon
r_case
id|XFER_UDMA_6
suffix:colon
r_return
id|XFER_UDMA_5
suffix:semicolon
r_case
id|XFER_UDMA_5
suffix:colon
r_return
id|XFER_UDMA_4
suffix:semicolon
r_case
id|XFER_UDMA_4
suffix:colon
r_return
id|XFER_UDMA_3
suffix:semicolon
r_case
id|XFER_UDMA_3
suffix:colon
r_return
id|XFER_UDMA_2
suffix:semicolon
r_case
id|XFER_UDMA_2
suffix:colon
r_return
id|XFER_UDMA_1
suffix:semicolon
r_case
id|XFER_UDMA_1
suffix:colon
r_return
id|XFER_UDMA_0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * OOPS we do not goto non Ultra DMA modes&n;&t;&t;&t; * without iCRC&squot;s available we force&n;&t;&t;&t; * the system to PIO and make the user&n;&t;&t;&t; * invoke the ATA-1 ATA-2 DMA modes.&n;&t;&t;&t; */
r_case
id|XFER_UDMA_0
suffix:colon
r_default
suffix:colon
r_return
id|XFER_PIO_4
suffix:semicolon
)brace
)brace
DECL|function|check_crc_errors
r_static
r_void
id|check_crc_errors
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;using_dma
)paren
r_return
suffix:semicolon
multiline_comment|/* check the DMA crc count */
r_if
c_cond
(paren
id|drive-&gt;crc_count
)paren
(brace
id|udma_enable
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;speedproc
)paren
(brace
id|u8
id|pio
op_assign
id|auto_reduce_xfer
c_func
(paren
id|drive
)paren
suffix:semicolon
id|drive-&gt;channel
op_member_access_from_pointer
id|speedproc
c_func
(paren
id|drive
comma
id|pio
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive-&gt;current_speed
op_ge
id|XFER_SW_DMA_0
)paren
id|udma_enable
c_func
(paren
id|drive
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|udma_enable
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The capacity of a drive according to its current geometry/LBA settings in&n; * sectors.&n; */
DECL|function|ata_capacity
id|sector_t
id|ata_capacity
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
op_logical_or
op_logical_neg
id|drive-&gt;driver
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|capacity
)paren
r_return
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|capacity
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* This used to be 0x7fffffff, but since now we use the maximal drive&n;&t; * capacity value used by other kernel subsystems as well.&n;&t; */
r_return
op_complement
l_int|0UL
suffix:semicolon
)brace
r_extern
r_struct
id|block_device_operations
id|ide_fops
(braket
)braket
suffix:semicolon
r_static
id|ide_startstop_t
id|do_reset1
c_func
(paren
r_struct
id|ata_device
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* needed below */
multiline_comment|/*&n; * Poll the interface for completion every 50ms during an ATAPI drive reset&n; * operation. If the drive has not yet responded, and we have not yet hit our&n; * maximum waiting time, then the timer is restarted for another 50ms.&n; */
DECL|function|atapi_reset_pollfunc
r_static
id|ide_startstop_t
id|atapi_reset_pollfunc
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|__rq
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
id|ata_select
c_func
(paren
id|drive
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
id|BUSY_STAT
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ATAPI reset complete&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|ch-&gt;poll_timeout
)paren
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
id|atapi_reset_pollfunc
comma
id|HZ
op_div
l_int|20
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
multiline_comment|/* continue polling */
)brace
id|ch-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* end of polling */
id|printk
c_func
(paren
l_string|&quot;%s: ATAPI reset timed out, status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;status
)paren
suffix:semicolon
r_return
id|do_reset1
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* do it the old fashioned way */
)brace
id|ch-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* done polling */
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Poll the interface for completion every 50ms during an ata reset operation.&n; * If the drives have not yet responded, and we have not yet hit our maximum&n; * waiting time, then the timer is restarted for another 50ms.&n; */
DECL|function|reset_pollfunc
r_static
id|ide_startstop_t
id|reset_pollfunc
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|__rq
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
id|BUSY_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|ch-&gt;poll_timeout
)paren
)paren
(brace
id|ide_set_handler
c_func
(paren
id|drive
comma
id|reset_pollfunc
comma
id|HZ
op_div
l_int|20
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
multiline_comment|/* continue polling */
)brace
id|printk
c_func
(paren
l_string|&quot;%s: reset timed out, status=0x%02x&bslash;n&quot;
comma
id|ch-&gt;name
comma
id|drive-&gt;status
)paren
suffix:semicolon
id|drive-&gt;failures
op_increment
suffix:semicolon
)brace
r_else
(brace
id|u8
id|stat
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reset: &quot;
comma
id|ch-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_assign
id|GET_ERR
c_func
(paren
)paren
)paren
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;success&bslash;n&quot;
)paren
suffix:semicolon
id|drive-&gt;failures
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_char
op_star
id|msg
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
id|u8
id|val
suffix:semicolon
r_static
r_char
op_star
id|messages
(braket
l_int|5
)braket
op_assign
(brace
l_string|&quot; passed&quot;
comma
l_string|&quot; formatter device&quot;
comma
l_string|&quot; sector buffer&quot;
comma
l_string|&quot; ECC circuitry&quot;
comma
l_string|&quot; controlling MPU error&quot;
)brace
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;master:&quot;
)paren
suffix:semicolon
id|val
op_assign
id|stat
op_amp
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|1
op_logical_and
id|val
op_le
l_int|5
)paren
id|msg
op_assign
id|messages
(braket
id|val
op_minus
l_int|1
)braket
suffix:semicolon
r_else
id|msg
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x80
)paren
id|printk
c_func
(paren
l_string|&quot;; slave:&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%s error [%02x]&bslash;n&quot;
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
id|drive-&gt;failures
op_increment
suffix:semicolon
)brace
)brace
id|ch-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* done polling */
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempt to recover a confused drive by resetting it.  Unfortunately,&n; * resetting a disk drive actually resets all devices on the same interface, so&n; * it can really be thought of as resetting the interface rather than resetting&n; * the drive.&n; *&n; * ATAPI devices have their own reset mechanism which allows them to be&n; * individually reset without clobbering other devices on the same interface.&n; *&n; * Unfortunately, the IDE interface does not generate an interrupt to let us&n; * know when the reset operation has finished, so we must poll for this.&n; * Equally poor, though, is the fact that this may a very long time to&n; * complete, (up to 30 seconds worst case).  So, instead of busy-waiting here&n; * for it, we set a timer to poll at 50ms intervals.&n; */
DECL|function|do_reset1
r_static
id|ide_startstop_t
id|do_reset1
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
id|do_not_try_atapi
)paren
(brace
r_int
r_int
id|unit
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ata_channel
op_star
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
multiline_comment|/* For an ATAPI device, first try an ATAPI SRST. */
r_if
c_cond
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
op_logical_and
op_logical_neg
id|do_not_try_atapi
)paren
(brace
id|check_crc_errors
c_func
(paren
id|drive
)paren
suffix:semicolon
id|ata_select
c_func
(paren
id|drive
comma
l_int|20
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|WIN_SRST
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|ch-&gt;poll_timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
id|atapi_reset_pollfunc
comma
id|HZ
op_div
l_int|20
comma
l_int|NULL
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * First, reset any device state data we were maintaining&n;&t; * for any of the drives on this interface.&n;&t; */
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
id|check_crc_errors
c_func
(paren
op_amp
id|ch-&gt;drives
(braket
id|unit
)braket
)paren
suffix:semicolon
id|__restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|read_24
r_static
r_inline
id|u32
id|read_24
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_return
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
op_lshift
l_int|8
)paren
op_or
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Clean up after success/failure of an explicit drive cmd&n; *&n; * Should be called under lock held.&n; */
DECL|function|ide_end_drive_cmd
r_void
id|ide_end_drive_cmd
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|u8
id|err
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_CMD
)paren
(brace
id|u8
op_star
id|args
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|rq-&gt;errors
op_assign
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
)paren
(brace
id|args
(braket
l_int|0
)braket
op_assign
id|drive-&gt;status
suffix:semicolon
id|args
(braket
l_int|1
)braket
op_assign
id|err
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_ACB
)paren
(brace
r_struct
id|ata_taskfile
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
id|rq-&gt;errors
op_assign
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
)paren
(brace
id|args-&gt;taskfile.feature
op_assign
id|err
suffix:semicolon
id|args-&gt;taskfile.sector_count
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args-&gt;taskfile.sector_number
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args-&gt;taskfile.low_cylinder
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args-&gt;taskfile.high_cylinder
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|args-&gt;taskfile.device_head
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|args-&gt;taskfile.command
op_assign
id|drive-&gt;status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
multiline_comment|/* The following command goes to the hob file! */
id|OUT_BYTE
c_func
(paren
l_int|0x80
comma
id|drive-&gt;channel-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
suffix:semicolon
id|args-&gt;hobfile.feature
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|args-&gt;hobfile.sector_count
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args-&gt;hobfile.sector_number
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args-&gt;hobfile.low_cylinder
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args-&gt;hobfile.high_cylinder
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
)brace
)brace
)brace
id|blkdev_dequeue_request
c_func
(paren
id|rq
)paren
suffix:semicolon
id|drive-&gt;rq
op_assign
l_int|NULL
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|rq
)paren
suffix:semicolon
)brace
macro_line|#if FANCY_STATUS_DUMPS
DECL|struct|ata_bit_messages
r_struct
id|ata_bit_messages
(brace
DECL|member|mask
id|u8
id|mask
suffix:semicolon
DECL|member|match
id|u8
id|match
suffix:semicolon
DECL|member|msg
r_const
r_char
op_star
id|msg
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|ata_status_msgs
r_static
r_struct
id|ata_bit_messages
id|ata_status_msgs
(braket
)braket
op_assign
(brace
(brace
id|BUSY_STAT
comma
id|BUSY_STAT
comma
l_string|&quot;Busy&quot;
)brace
comma
(brace
id|READY_STAT
comma
id|READY_STAT
comma
l_string|&quot;DriveReady&quot;
)brace
comma
(brace
id|WRERR_STAT
comma
id|WRERR_STAT
comma
l_string|&quot;DeviceFault&quot;
)brace
comma
(brace
id|SEEK_STAT
comma
id|SEEK_STAT
comma
l_string|&quot;SeekComplete&quot;
)brace
comma
(brace
id|DRQ_STAT
comma
id|DRQ_STAT
comma
l_string|&quot;DataRequest&quot;
)brace
comma
(brace
id|ECC_STAT
comma
id|ECC_STAT
comma
l_string|&quot;CorrectedError&quot;
)brace
comma
(brace
id|INDEX_STAT
comma
id|INDEX_STAT
comma
l_string|&quot;Index&quot;
)brace
comma
(brace
id|ERR_STAT
comma
id|ERR_STAT
comma
l_string|&quot;Error&quot;
)brace
)brace
suffix:semicolon
DECL|variable|ata_error_msgs
r_static
r_struct
id|ata_bit_messages
id|ata_error_msgs
(braket
)braket
op_assign
(brace
(brace
id|ICRC_ERR
op_or
id|ABRT_ERR
comma
id|ABRT_ERR
comma
l_string|&quot;DriveStatusError&quot;
)brace
comma
(brace
id|ICRC_ERR
op_or
id|ABRT_ERR
comma
id|ICRC_ERR
comma
l_string|&quot;BadSector&quot;
)brace
comma
(brace
id|ICRC_ERR
op_or
id|ABRT_ERR
comma
id|ICRC_ERR
op_or
id|ABRT_ERR
comma
l_string|&quot;BadCRC&quot;
)brace
comma
(brace
id|ECC_ERR
comma
id|ECC_ERR
comma
l_string|&quot;UncorrectableError&quot;
)brace
comma
(brace
id|ID_ERR
comma
id|ID_ERR
comma
l_string|&quot;SectorIdNotFound&quot;
)brace
comma
(brace
id|TRK0_ERR
comma
id|TRK0_ERR
comma
l_string|&quot;TrackZeroNotFound&quot;
)brace
comma
(brace
id|MARK_ERR
comma
id|MARK_ERR
comma
l_string|&quot;AddrMarkNotFound&quot;
)brace
)brace
suffix:semicolon
DECL|function|ata_dump_bits
r_static
r_void
id|ata_dump_bits
c_func
(paren
r_struct
id|ata_bit_messages
op_star
id|msgs
comma
r_int
id|nr
comma
id|byte
id|bits
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
comma
id|msgs
op_increment
)paren
r_if
c_cond
(paren
(paren
id|bits
op_amp
id|msgs-&gt;mask
)paren
op_eq
id|msgs-&gt;match
)paren
id|printk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|msgs-&gt;msg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;} &quot;
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|ata_dump_bits
macro_line|# define ata_dump_bits(msgs,nr,bits) do { } while (0)
macro_line|#endif
multiline_comment|/*&n; * Error reporting, in human readable form (luxurious, but a memory hog).&n; */
DECL|function|ide_dump_status
id|u8
id|ide_dump_status
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_const
r_char
op_star
id|msg
comma
id|u8
id|stat
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|err
op_assign
l_int|0
suffix:semicolon
id|__save_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|printk
c_func
(paren
l_string|&quot;%s: %s: status=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
id|ata_dump_bits
c_func
(paren
id|ata_status_msgs
comma
id|ARRAY_SIZE
c_func
(paren
id|ata_status_msgs
)paren
comma
id|stat
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
(paren
id|BUSY_STAT
op_or
id|ERR_STAT
)paren
)paren
op_eq
id|ERR_STAT
)paren
(brace
id|err
op_assign
id|GET_ERR
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: error=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|err
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
r_if
c_cond
(paren
id|drive-&gt;type
op_eq
id|ATA_DISK
)paren
(brace
id|ata_dump_bits
c_func
(paren
id|ata_error_msgs
comma
id|ARRAY_SIZE
c_func
(paren
id|ata_error_msgs
)paren
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ABRT_ERR
)paren
)paren
op_eq
id|BBD_ERR
op_logical_or
(paren
id|err
op_amp
(paren
id|ECC_ERR
op_or
id|ID_ERR
op_or
id|MARK_ERR
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|__u64
id|sectors
op_assign
l_int|0
suffix:semicolon
id|u32
id|low
op_assign
l_int|0
comma
id|high
op_assign
l_int|0
suffix:semicolon
id|low
op_assign
id|read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
l_int|0x80
comma
id|drive-&gt;channel-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
suffix:semicolon
id|high
op_assign
id|read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|sectors
op_assign
(paren
(paren
id|__u64
)paren
id|high
op_lshift
l_int|24
)paren
op_or
id|low
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%lld, high=%d, low=%d&quot;
comma
(paren
r_int
r_int
)paren
id|sectors
comma
id|high
comma
id|low
)paren
suffix:semicolon
)brace
r_else
(brace
id|u8
id|cur
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/* using LBA? */
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%ld&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|cur
op_amp
l_int|0xf
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
op_lshift
l_int|8
)paren
op_or
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, CHS=%d/%d/%d&quot;
comma
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|8
)paren
op_plus
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
comma
id|cur
op_amp
l_int|0xf
comma
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rq
)paren
id|printk
c_func
(paren
l_string|&quot;, sector=%ld&quot;
comma
id|rq-&gt;sector
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|__restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * This gets invoked in response to a drive unexpectedly having its DRQ_STAT&n; * bit set.  As an alternative to resetting the drive, it tries to clear the&n; * condition by reading a sector&squot;s worth of data from the drive.  Of course,&n; * this may not help if the drive is *waiting* for data from *us*.&n; */
DECL|function|try_to_flush_leftover_data
r_static
r_void
id|try_to_flush_leftover_data
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
(paren
id|drive-&gt;mult_count
ques
c_cond
id|drive-&gt;mult_count
suffix:colon
l_int|1
)paren
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|u32
id|buffer
(braket
id|SECTOR_WORDS
)braket
suffix:semicolon
id|ata_read
c_func
(paren
id|drive
comma
id|buffer
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
DECL|macro|IS_PDC4030_DRIVE
macro_line|# define IS_PDC4030_DRIVE (drive-&gt;channel-&gt;chipset == ide_pdc4030)
macro_line|#else
DECL|macro|IS_PDC4030_DRIVE
macro_line|# define IS_PDC4030_DRIVE (0)&t;/* auto-NULLs out pdc4030 code */
macro_line|#endif
multiline_comment|/*&n; * We are still on the old request path here so issuing the recalibrate command&n; * directly should just work.&n; */
DECL|function|do_recalibrate
r_static
r_int
id|do_recalibrate
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: recalibrating!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
)paren
r_return
id|ide_stopped
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_PDC4030_DRIVE
)paren
(brace
r_struct
id|ata_taskfile
id|args
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.taskfile.sector_count
op_assign
id|drive-&gt;sect
suffix:semicolon
id|args.taskfile.command
op_assign
id|WIN_RESTORE
suffix:semicolon
id|args.handler
op_assign
id|recal_intr
suffix:semicolon
id|ata_taskfile
c_func
(paren
id|drive
comma
op_amp
id|args
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
id|IS_PDC4030_DRIVE
ques
c_cond
id|ide_stopped
suffix:colon
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * Take action based on the error returned by the drive.&n; */
DECL|function|ata_error
id|ide_startstop_t
id|ata_error
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_const
r_char
op_star
id|msg
)paren
(brace
id|u8
id|err
suffix:semicolon
id|u8
id|stat
op_assign
id|drive-&gt;status
suffix:semicolon
id|err
op_assign
id|ide_dump_status
c_func
(paren
id|drive
comma
id|rq
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive
op_logical_or
op_logical_neg
id|rq
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* retry only &quot;normal&quot; I/O: */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
id|REQ_CMD
)paren
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|rq
comma
id|err
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/* other bits are useless when BUSY */
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
op_logical_or
(paren
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
op_logical_and
op_logical_neg
id|drive-&gt;nowerr
)paren
)paren
id|rq-&gt;errors
op_or_assign
id|ERROR_RESET
suffix:semicolon
multiline_comment|/* FIXME: What&squot;s that?! */
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;type
op_eq
id|ATA_DISK
op_logical_and
(paren
id|stat
op_amp
id|ERR_STAT
)paren
)paren
(brace
multiline_comment|/* err has different meaning on cdrom and tape */
r_if
c_cond
(paren
id|err
op_eq
id|ABRT_ERR
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;select.b.lba
op_logical_and
id|IN_BYTE
c_func
(paren
id|IDE_COMMAND_REG
)paren
op_eq
id|WIN_SPECIFY
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* some newer drives don&squot;t support WIN_SPECIFY */
)brace
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
(paren
id|ABRT_ERR
op_or
id|ICRC_ERR
)paren
)paren
op_eq
(paren
id|ABRT_ERR
op_or
id|ICRC_ERR
)paren
)paren
id|drive-&gt;crc_count
op_increment
suffix:semicolon
multiline_comment|/* UDMA crc error -- just retry the operation */
r_else
r_if
c_cond
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ECC_ERR
)paren
)paren
multiline_comment|/* retries won&squot;t help these */
id|rq-&gt;errors
op_assign
id|ERROR_MAX
suffix:semicolon
r_else
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
multiline_comment|/* help it find track zero */
id|rq-&gt;errors
op_or_assign
id|ERROR_RECAL
suffix:semicolon
)brace
multiline_comment|/* pre bio (rq-&gt;cmd != WRITE) */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_logical_and
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
id|try_to_flush_leftover_data
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
id|BUSY_STAT
op_or
id|DRQ_STAT
)paren
)paren
id|OUT_BYTE
c_func
(paren
id|WIN_IDLEIMMEDIATE
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* force an abort */
r_if
c_cond
(paren
id|rq-&gt;errors
op_ge
id|ERROR_MAX
)paren
(brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
)paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|0
)paren
suffix:semicolon
r_else
id|ide_end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
op_increment
id|rq-&gt;errors
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RESET
)paren
op_eq
id|ERROR_RESET
)paren
r_return
id|do_reset1
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RECAL
)paren
op_eq
id|ERROR_RECAL
)paren
r_return
id|do_recalibrate
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Invoked on completion of a special DRIVE_CMD.&n; */
DECL|function|drive_cmd_intr
r_static
id|ide_startstop_t
id|drive_cmd_intr
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|u8
op_star
id|args
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
r_if
c_cond
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
id|DRQ_STAT
)paren
op_logical_and
id|args
op_logical_and
id|args
(braket
l_int|3
)braket
)paren
(brace
r_int
id|retries
op_assign
l_int|10
suffix:semicolon
id|ata_read
c_func
(paren
id|drive
comma
op_amp
id|args
(braket
l_int|4
)braket
comma
id|args
(braket
l_int|3
)braket
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|ata_error
c_func
(paren
id|drive
comma
id|rq
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* already calls ide_end_drive_cmd */
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|rq
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Busy-wait for the drive status to be not &quot;busy&quot;.  Check then the status for&n; * all of the &quot;good&quot; bits and none of the &quot;bad&quot; bits, and if all is okay it&n; * returns 0.  All other cases return 1 after invoking error handler -- caller&n; * should just return.&n; *&n; * This routine should get fixed to not hog the cpu during extra long waits..&n; * That could be done by busy-waiting for the first jiffy or two, and then&n; * setting a timer to wake up at half second intervals thereafter, until&n; * timeout is achieved, before timing out.&n; */
DECL|function|ide_wait_stat
r_int
id|ide_wait_stat
c_func
(paren
id|ide_startstop_t
op_star
id|startstop
comma
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|byte
id|good
comma
id|byte
id|bad
comma
r_int
r_int
id|timeout
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* bail early if we&squot;ve exceeded max_failures */
r_if
c_cond
(paren
id|drive-&gt;max_failures
op_logical_and
(paren
id|drive-&gt;failures
OG
id|drive-&gt;max_failures
)paren
)paren
(brace
op_star
id|startstop
op_assign
id|ide_stopped
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* spec allows drive 400ns to assert &quot;BUSY&quot; */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
id|BUSY_STAT
)paren
)paren
(brace
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
id|BUSY_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
op_star
id|startstop
op_assign
id|ata_error
c_func
(paren
id|drive
comma
id|rq
comma
l_string|&quot;status timeout&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Allow status to settle, then read it again.  A few rare drives&n;&t; * vastly violate the 400ns spec here, so we&squot;ll wait up to 10usec for a&n;&t; * &quot;good&quot; status rather than expensively fail things immediately.  This&n;&t; * fix courtesy of Matthew Faupel &amp; Niccolo Rigacci.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_status
c_func
(paren
id|drive
comma
id|good
comma
id|bad
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|startstop
op_assign
id|ata_error
c_func
(paren
id|drive
comma
id|rq
comma
l_string|&quot;status error&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This initiates handling of a new I/O request.&n; */
DECL|function|start_request
r_static
id|ide_startstop_t
id|start_request
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|sector_t
id|block
suffix:semicolon
r_int
r_int
id|minor
op_assign
id|minor
c_func
(paren
id|rq-&gt;rq_dev
)paren
suffix:semicolon
r_int
r_int
id|unit
op_assign
id|minor
op_rshift
id|PARTN_BITS
suffix:semicolon
r_struct
id|ata_channel
op_star
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
id|REQ_STARTED
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: start_request: current=0x%08lx&bslash;n&quot;
comma
id|ch-&gt;name
comma
(paren
r_int
r_int
)paren
id|rq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* bail early if we&squot;ve exceeded max_failures */
r_if
c_cond
(paren
id|drive-&gt;max_failures
op_logical_and
(paren
id|drive-&gt;failures
OG
id|drive-&gt;max_failures
)paren
)paren
r_goto
id|kill_rq
suffix:semicolon
r_if
c_cond
(paren
id|unit
op_ge
id|MAX_DRIVES
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: bad device number: %s&bslash;n&quot;
comma
id|ch-&gt;name
comma
id|kdevname
c_func
(paren
id|rq-&gt;rq_dev
)paren
)paren
suffix:semicolon
r_goto
id|kill_rq
suffix:semicolon
)brace
id|block
op_assign
id|rq-&gt;sector
suffix:semicolon
multiline_comment|/* Strange disk manager remap.&n;&t; */
r_if
c_cond
(paren
(paren
id|rq-&gt;flags
op_amp
id|REQ_CMD
)paren
op_logical_and
(paren
id|drive-&gt;type
op_eq
id|ATA_DISK
op_logical_or
id|drive-&gt;type
op_eq
id|ATA_FLOPPY
)paren
)paren
(brace
id|block
op_add_assign
id|drive-&gt;sect0
suffix:semicolon
)brace
multiline_comment|/* Yecch - this will shift the entire interval, possibly killing some&n;&t; * innocent following sector.&n;&t; */
r_if
c_cond
(paren
id|block
op_eq
l_int|0
op_logical_and
id|drive-&gt;remap_0_to_1
op_eq
l_int|1
)paren
id|block
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* redirect MBR access to EZ-Drive partn table */
(brace
id|ide_startstop_t
id|res
suffix:semicolon
id|ata_select
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|res
comma
id|drive
comma
id|rq
comma
id|drive-&gt;ready_stat
comma
id|BUSY_STAT
op_or
id|DRQ_STAT
comma
id|WAIT_READY
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: drive not ready for command&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
)brace
multiline_comment|/* This issues a special drive command, usually initiated by ioctl()&n;&t; * from the external hdparm program.&n;&t; */
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_ACB
)paren
(brace
r_struct
id|ata_taskfile
op_star
id|args
op_assign
id|rq-&gt;special
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|args
)paren
)paren
r_goto
id|args_error
suffix:semicolon
id|ata_taskfile
c_func
(paren
id|drive
comma
id|args
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|args-&gt;command_type
op_eq
id|IDE_DRIVE_TASK_RAW_WRITE
)paren
op_logical_or
(paren
id|args-&gt;command_type
op_eq
id|IDE_DRIVE_TASK_OUT
)paren
)paren
op_logical_and
id|args-&gt;prehandler
op_logical_and
id|args-&gt;handler
)paren
r_return
id|args
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_CMD
)paren
(brace
id|u8
op_star
id|args
op_assign
id|rq-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|args
)paren
)paren
r_goto
id|args_error
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: DRIVE_CMD &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cmd=0x%02x &quot;
comma
id|args
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; sc=0x%02x &quot;
comma
id|args
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; fr=0x%02x &quot;
comma
id|args
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; xx=0x%02x&bslash;n&quot;
comma
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
macro_line|#endif
id|ide_set_handler
c_func
(paren
id|drive
comma
id|drive_cmd_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|ata_irq_enable
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|ata_mask
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
(braket
l_int|0
)braket
op_eq
id|WIN_SMART
)paren
(brace
r_struct
id|hd_drive_task_hdr
id|regfile
suffix:semicolon
id|regfile.feature
op_assign
id|args
(braket
l_int|2
)braket
suffix:semicolon
id|regfile.sector_count
op_assign
id|args
(braket
l_int|3
)braket
suffix:semicolon
id|regfile.sector_number
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
id|regfile.low_cylinder
op_assign
l_int|0x4f
suffix:semicolon
id|regfile.high_cylinder
op_assign
l_int|0xc2
suffix:semicolon
id|ata_out_regfile
c_func
(paren
id|drive
comma
op_amp
id|regfile
)paren
suffix:semicolon
)brace
r_else
(brace
id|OUT_BYTE
c_func
(paren
id|args
(braket
l_int|2
)braket
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args
(braket
l_int|1
)braket
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
)brace
id|OUT_BYTE
c_func
(paren
id|args
(braket
l_int|0
)braket
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/* The normal way of execution is to pass and execute the request&n;&t; * handler down to the device type driver.&n;&t; */
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|do_request
)paren
r_return
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|do_request
c_func
(paren
id|drive
comma
id|rq
comma
id|block
)paren
suffix:semicolon
r_else
(brace
id|ide_end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Error handling:&n;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: device type %d not supported&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;type
)paren
suffix:semicolon
id|kill_rq
suffix:colon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
)paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|0
)paren
suffix:semicolon
r_else
id|ide_end_request
c_func
(paren
id|drive
comma
id|rq
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
id|args_error
suffix:colon
multiline_comment|/* NULL as arguemnt is used by ioctls as a way of waiting for all&n;&t; * current requests to be flushed from the queue.&n;&t; */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: DRIVE_CMD (null)&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|rq
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|restart_request
id|ide_startstop_t
id|restart_request
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|ch-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ch-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|ch-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|start_request
c_func
(paren
id|drive
comma
id|drive-&gt;rq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is used by a drive to give excess bandwidth back by sleeping for&n; * timeout jiffies.&n; */
DECL|function|ide_stall_queue
r_void
id|ide_stall_queue
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_int
r_int
id|timeout
)paren
(brace
r_if
c_cond
(paren
id|timeout
OG
id|WAIT_WORSTCASE
)paren
id|timeout
op_assign
id|WAIT_WORSTCASE
suffix:semicolon
id|drive-&gt;sleep
op_assign
id|timeout
op_plus
id|jiffies
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine the longest sleep time for the devices at this channel.&n; */
DECL|function|longest_sleep
r_static
r_int
r_int
id|longest_sleep
c_func
(paren
r_struct
id|ata_channel
op_star
id|channel
)paren
(brace
r_int
r_int
id|sleep
op_assign
l_int|0
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|channel-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
multiline_comment|/* This device is sleeping and waiting to be serviced&n;&t;&t; * later than any other device we checked thus far.&n;&t;&t; */
r_if
c_cond
(paren
id|drive-&gt;sleep
op_logical_and
(paren
op_logical_neg
id|sleep
op_logical_or
id|time_after
c_func
(paren
id|sleep
comma
id|drive-&gt;sleep
)paren
)paren
)paren
id|sleep
op_assign
id|drive-&gt;sleep
suffix:semicolon
)brace
r_return
id|sleep
suffix:semicolon
)brace
multiline_comment|/*&n; * Select the next device which will be serviced.  This selects only between&n; * devices on the same channel, since everything else will be scheduled on the&n; * queue level.&n; */
DECL|function|choose_urgent_device
r_static
r_struct
id|ata_device
op_star
id|choose_urgent_device
c_func
(paren
r_struct
id|ata_channel
op_star
id|channel
)paren
(brace
r_struct
id|ata_device
op_star
id|choice
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|sleep
op_assign
l_int|0
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|channel-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
multiline_comment|/* There are no request pending for this device.&n;&t;&t; */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|drive-&gt;queue.queue_head
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* This device still wants to remain idle.&n;&t;&t; */
r_if
c_cond
(paren
id|drive-&gt;sleep
op_logical_and
id|time_after
c_func
(paren
id|drive-&gt;sleep
comma
id|jiffies
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Take this device, if there is no device choosen thus far or&n;&t;&t; * it&squot;s more urgent.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|choice
op_logical_or
(paren
id|drive-&gt;sleep
op_logical_and
(paren
op_logical_neg
id|choice-&gt;sleep
op_logical_or
id|time_after
c_func
(paren
id|choice-&gt;sleep
comma
id|drive-&gt;sleep
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|blk_queue_plugged
c_func
(paren
op_amp
id|drive-&gt;queue
)paren
)paren
id|choice
op_assign
id|drive
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|choice
)paren
r_return
id|choice
suffix:semicolon
id|sleep
op_assign
id|longest_sleep
c_func
(paren
id|channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sleep
)paren
(brace
multiline_comment|/*&n;&t;&t; * Take a short snooze, and then wake up again.  Just in case&n;&t;&t; * there are big differences in relative throughputs.. don&squot;t&n;&t;&t; * want to hog the cpu too much.&n;&t;&t; */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|sleep
op_minus
id|WAIT_MIN_SLEEP
)paren
)paren
id|sleep
op_assign
id|jiffies
op_plus
id|WAIT_MIN_SLEEP
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|channel-&gt;timer
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide_set_handler: timer already active&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|set_bit
c_func
(paren
id|IDE_SLEEP
comma
id|channel-&gt;active
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|channel-&gt;timer
comma
id|sleep
)paren
suffix:semicolon
multiline_comment|/* we purposely leave hwgroup busy while sleeping */
)brace
r_else
(brace
multiline_comment|/* Ugly, but how can we sleep for the lock otherwise? perhaps&n;&t;&t; * from tq_disk? */
id|ide_release_lock
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
multiline_comment|/* for atari only */
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
id|channel-&gt;active
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Feed commands to a drive until it barfs.  Called with queue lock held and&n; * busy channel.&n; */
DECL|function|queue_commands
r_static
r_void
id|queue_commands
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
id|ide_startstop_t
id|startstop
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|IDE_BUSY
comma
id|ch-&gt;active
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: error: not busy while queueing!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Abort early if we can&squot;t queue another command. for non&n;&t;&t; * tcq, ata_can_queue is always 1 since we never get here&n;&t;&t; * unless the drive is idle.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ata_can_queue
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ata_pending_commands
c_func
(paren
id|drive
)paren
)paren
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
id|ch-&gt;active
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|drive-&gt;sleep
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDE_DMA
comma
id|ch-&gt;active
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: error: DMA in progress...&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* There&squot;s a small window between where the queue could be&n;&t;&t; * replugged while we are in here when using tcq (in which&n;&t;&t; * case the queue is probably empty anyways...), so check&n;&t;&t; * and leave if appropriate. When not using tcq, this is&n;&t;&t; * still a severe BUG!&n;&t;&t; */
r_if
c_cond
(paren
id|blk_queue_plugged
c_func
(paren
op_amp
id|drive-&gt;queue
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|drive-&gt;using_tcq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|rq
op_assign
id|elv_next_request
c_func
(paren
op_amp
id|drive-&gt;queue
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ata_pending_commands
c_func
(paren
id|drive
)paren
)paren
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
id|ch-&gt;active
)paren
suffix:semicolon
id|drive-&gt;rq
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* If there are queued commands, we can&squot;t start a non-fs&n;&t;&t; * request (really, a non-queuable command) until the&n;&t;&t; * queue is empty.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
id|REQ_CMD
)paren
op_logical_and
id|ata_pending_commands
c_func
(paren
id|drive
)paren
)paren
r_break
suffix:semicolon
id|drive-&gt;rq
op_assign
id|rq
suffix:semicolon
id|spin_unlock
c_func
(paren
id|drive-&gt;channel-&gt;lock
)paren
suffix:semicolon
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* allow other IRQs while we start this request */
id|startstop
op_assign
id|start_request
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|drive-&gt;channel-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* command started, we are busy */
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_started
)paren
r_break
suffix:semicolon
multiline_comment|/* start_request() can return either ide_stopped (no command&n;&t;&t; * was started), ide_started (command started, don&squot;t queue&n;&t;&t; * more), or ide_released (command started, try and queue&n;&t;&t; * more).&n;&t;&t; */
macro_line|#if 0
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_stopped
)paren
id|set_bit
c_func
(paren
id|IDE_BUSY
comma
op_amp
id|hwgroup-&gt;flags
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n; * Issue a new request.&n; * Caller must have already done spin_lock_irqsave(channel-&gt;lock, ...)&n; */
DECL|function|do_request
r_static
r_void
id|do_request
c_func
(paren
r_struct
id|ata_channel
op_star
id|channel
)paren
(brace
id|ide_get_lock
c_func
(paren
op_amp
id|irq_lock
comma
id|ata_irq_request
comma
id|hwgroup
)paren
suffix:semicolon
multiline_comment|/* for atari only: POSSIBLY BROKEN HERE(?) */
singleline_comment|//&t;__cli();&t;/* necessary paranoia: ensure IRQs are masked on local CPU */
r_while
c_loop
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|IDE_BUSY
comma
id|channel-&gt;active
)paren
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
suffix:semicolon
r_struct
id|ata_device
op_star
id|drive
suffix:semicolon
multiline_comment|/* this will clear IDE_BUSY, if appropriate */
id|drive
op_assign
id|choose_urgent_device
c_func
(paren
id|channel
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive
)paren
r_break
suffix:semicolon
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
multiline_comment|/* Disable intrerrupts from the drive on the previous channel.&n;&t;&t; *&n;&t;&t; * FIXME: This should be only done if we are indeed sharing the same&n;&t;&t; * interrupt line with it.&n;&t;&t; *&n;&t;&t; * FIXME: check this! It appears to act on the current channel!&n;&t;&t; */
r_if
c_cond
(paren
id|ch
op_ne
id|channel
op_logical_and
id|channel-&gt;sharing_irq
op_logical_and
id|ch-&gt;irq
op_eq
id|channel-&gt;irq
)paren
id|ata_irq_enable
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Remember the last drive we where acting on.&n;&t;&t; */
id|ch-&gt;drive
op_assign
id|drive
suffix:semicolon
id|queue_commands
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_ide_request
r_void
id|do_ide_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
id|do_request
c_func
(paren
id|q-&gt;queuedata
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Un-busy the hwgroup etc, and clear any pending DMA status. we want to&n; * retry the current request in PIO mode instead of risking tossing it&n; * all away&n; */
DECL|function|dma_timeout_retry
r_static
r_void
id|dma_timeout_retry
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
multiline_comment|/*&n;&t; * end current dma transaction&n;&t; */
id|udma_stop
c_func
(paren
id|drive
)paren
suffix:semicolon
id|udma_timeout
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable dma for now, but remember that we did so because of&n;&t; * a timeout -- we&squot;ll reenable after we finish this next request&n;&t; * (or rather the first chunk of it) in pio.&n;&t; */
id|drive-&gt;retry_pio
op_increment
suffix:semicolon
id|drive-&gt;state
op_assign
id|DMA_PIO_RETRY
suffix:semicolon
id|udma_enable
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * un-busy drive etc (hwgroup-&gt;busy is cleared on return) and&n;&t; * make sure request is sane&n;&t; */
id|drive-&gt;rq
op_assign
l_int|NULL
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;bio
)paren
(brace
id|rq-&gt;sector
op_assign
id|rq-&gt;bio-&gt;bi_sector
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
id|bio_iovec
c_func
(paren
id|rq-&gt;bio
)paren
op_member_access_from_pointer
id|bv_len
op_rshift
l_int|9
suffix:semicolon
id|rq-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is our timeout function for all drive operations.  But note that it can&n; * also be invoked as a result of a &quot;sleep&quot; operation triggered by the&n; * mod_timer() call in do_request.&n; */
DECL|function|ide_timer_expiry
r_void
id|ide_timer_expiry
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
op_assign
(paren
r_struct
id|ata_channel
op_star
)paren
id|data
suffix:semicolon
id|ata_handler_t
op_star
id|handler
suffix:semicolon
id|ata_expiry_t
op_star
id|expiry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|wait
suffix:semicolon
multiline_comment|/*&n;&t; * A global lock protects timers etc -- shouldn&squot;t get contention&n;&t; * worth mentioning.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
id|ch-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|handler
op_assign
id|ch-&gt;handler
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
multiline_comment|/*&n;&t;&t; * Either a marginal timeout occurred (got the interrupt just&n;&t;&t; * as timer expired), or we were &quot;sleeping&quot; to give other&n;&t;&t; * devices a chance.  Either way, we don&squot;t really want to&n;&t;&t; * complain about anything.&n;&t;&t; */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|IDE_SLEEP
comma
id|ch-&gt;active
)paren
)paren
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
id|ch-&gt;active
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
id|ch-&gt;drive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ide_timer_expiry: IRQ handler was NULL&bslash;n&quot;
)paren
suffix:semicolon
id|ch-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|ide_startstop_t
id|startstop
suffix:semicolon
multiline_comment|/* paranoia */
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|IDE_BUSY
comma
id|ch-&gt;active
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ide_timer_expiry: IRQ handler was not busy??&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|expiry
op_assign
id|ch-&gt;expiry
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* continue */
r_if
c_cond
(paren
(paren
id|wait
op_assign
id|expiry
c_func
(paren
id|drive
comma
id|drive-&gt;rq
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* reengage timer */
id|ch-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|wait
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|ch-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|ch-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We need to simulate a real interrupt when invoking&n;&t;&t;&t; * the handler() function, which means we need to globally&n;&t;&t;&t; * mask the specific IRQ:&n;&t;&t;&t; */
id|spin_unlock
c_func
(paren
id|ch-&gt;lock
)paren
suffix:semicolon
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
macro_line|#if DISABLE_IRQ_NOSYNC
id|disable_irq_nosync
c_func
(paren
id|ch-&gt;irq
)paren
suffix:semicolon
macro_line|#else
id|disable_irq
c_func
(paren
id|ch-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* disable_irq_nosync ?? */
macro_line|#endif
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only, as if we were handling an interrupt */
r_if
c_cond
(paren
id|ch-&gt;poll_timeout
op_ne
l_int|0
)paren
(brace
id|startstop
op_assign
id|handler
c_func
(paren
id|drive
comma
id|drive-&gt;rq
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;waiting_for_dma
)paren
id|udma_irq_lost
c_func
(paren
id|drive
)paren
suffix:semicolon
(paren
r_void
)paren
id|ide_ack_intr
c_func
(paren
id|ch
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: lost interrupt&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|startstop
op_assign
id|handler
c_func
(paren
id|drive
comma
id|drive-&gt;rq
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;waiting_for_dma
)paren
(brace
id|startstop
op_assign
id|ide_stopped
suffix:semicolon
id|dma_timeout_retry
c_func
(paren
id|drive
comma
id|drive-&gt;rq
)paren
suffix:semicolon
)brace
r_else
id|startstop
op_assign
id|ata_error
c_func
(paren
id|drive
comma
id|drive-&gt;rq
comma
l_string|&quot;irq timeout&quot;
)paren
suffix:semicolon
)brace
id|enable_irq
c_func
(paren
id|ch-&gt;irq
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|ch-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_stopped
)paren
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
id|ch-&gt;active
)paren
suffix:semicolon
)brace
)brace
id|do_request
c_func
(paren
id|ch-&gt;drive-&gt;channel
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|ch-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * There&squot;s nothing really useful we can do with an unexpected interrupt,&n; * other than reading the status register (to clear it), and logging it.&n; * There should be no way that an irq can happen before we&squot;re ready for it,&n; * so we needn&squot;t worry much about losing an &quot;important&quot; interrupt here.&n; *&n; * On laptops (and &quot;green&quot; PCs), an unexpected interrupt occurs whenever the&n; * drive enters &quot;idle&quot;, &quot;standby&quot;, or &quot;sleep&quot; mode, so if the status looks&n; * &quot;good&quot;, we just ignore the interrupt completely.&n; *&n; * This routine assumes __cli() is in effect when called.&n; *&n; * If an unexpected interrupt happens on irq15 while we are handling irq14&n; * and if the two interfaces are &quot;serialized&quot; (CMD640), then it looks like&n; * we could screw up by interfering with a new request being set up for irq15.&n; *&n; * In reality, this is a non-issue.  The new command is not sent unless the&n; * drive is ready to accept one, in which case we know the drive is not&n; * trying to interrupt us.  And ide_set_handler() is always invoked before&n; * completing the issuance of any new drive command, so we will not be&n; * accidentally invoked as a result of any valid command completion interrupt.&n; *&n; */
DECL|function|unexpected_irq
r_static
r_void
id|unexpected_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
r_struct
id|ata_device
op_star
id|drive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch-&gt;present
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;irq
op_ne
id|irq
)paren
r_continue
suffix:semicolon
multiline_comment|/* FIXME: this is a bit weak */
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
multiline_comment|/* Try to not flood the console with msgs */
r_static
r_int
r_int
id|last_msgtime
suffix:semicolon
r_static
r_int
id|count
suffix:semicolon
op_increment
id|count
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|last_msgtime
op_plus
id|HZ
)paren
)paren
(brace
id|last_msgtime
op_assign
id|jiffies
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: unexpected interrupt, status=0x%02x, count=%d&bslash;n&quot;
comma
id|ch-&gt;name
comma
id|drive-&gt;status
comma
id|count
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * Entry point for all interrupts, caller does __cli() for us.&n; */
DECL|function|ata_irq_request
r_void
id|ata_irq_request
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|data
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
op_assign
id|data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ata_device
op_star
id|drive
suffix:semicolon
id|ata_handler_t
op_star
id|handler
op_assign
id|ch-&gt;handler
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|ch-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ide_ack_intr
c_func
(paren
id|ch
)paren
)paren
r_goto
id|out_lock
suffix:semicolon
r_if
c_cond
(paren
id|handler
op_eq
l_int|NULL
op_logical_or
id|ch-&gt;poll_timeout
op_ne
l_int|0
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide: unexpected interrupt %d %d&bslash;n&quot;
comma
id|ch-&gt;unit
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Not expecting an interrupt from this drive.&n;&t;&t; * That means this could be:&n;&t;&t; *&t;(1) an interrupt from another PCI device&n;&t;&t; *&t;sharing the same PCI INT# as us.&n;&t;&t; * or&t;(2) a drive just entered sleep or standby mode,&n;&t;&t; *&t;and is interrupting to let us know.&n;&t;&t; * or&t;(3) a spurious interrupt of unknown origin.&n;&t;&t; *&n;&t;&t; * For PCI, we cannot tell the difference,&n;&t;&t; * so in that case we just ignore it and hope it goes away.&n;&t;&t; */
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
id|ch-&gt;pci_dev
op_logical_and
op_logical_neg
id|ch-&gt;pci_dev-&gt;vendor
)paren
macro_line|#endif
(brace
multiline_comment|/* Probably not a shared PCI interrupt, so we can&n;&t;&t;&t; * safely try to do something about it:&n;&t;&t;&t; */
id|unexpected_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Whack the status register, just in case we have a leftover pending IRQ.&n;&t;&t;&t; */
id|IN_BYTE
c_func
(paren
id|ch-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
r_goto
id|out_lock
suffix:semicolon
)brace
id|drive
op_assign
id|ch-&gt;drive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This happens regularly when we share a PCI IRQ with another device.&n;&t;&t; * Unfortunately, it can also happen with some buggy drives that trigger&n;&t;&t; * the IRQ before their status register is up to date.  Hopefully we have&n;&t;&t; * enough advance overhead that the latter isn&squot;t a problem.&n;&t;&t; */
r_goto
id|out_lock
suffix:semicolon
)brace
multiline_comment|/* paranoia */
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|IDE_BUSY
comma
id|ch-&gt;active
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: %s: hwgroup was not busy!?&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ch-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|ch-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;unmask
)paren
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
multiline_comment|/* service this interrupt, may set handler for next interrupt */
id|startstop
op_assign
id|handler
c_func
(paren
id|drive
comma
id|drive-&gt;rq
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|ch-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note that handler() may have set things up for another&n;&t; * interrupt to occur soon, but it cannot happen until&n;&t; * we exit from this routine, because it will be the&n;&t; * same irq as is currently being serviced here, and Linux&n;&t; * won&squot;t allow another of the same (on any CPU) until we return.&n;&t; */
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_stopped
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ch-&gt;handler
)paren
(brace
multiline_comment|/* paranoia */
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
id|ch-&gt;active
)paren
suffix:semicolon
id|do_request
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s: huh? expected NULL handler on exit&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_released
)paren
id|queue_commands
c_func
(paren
id|drive
)paren
suffix:semicolon
id|out_lock
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
id|ch-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|ide_open
r_static
r_int
id|ide_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* Request a particular device type module.&n;&t; *&n;&t; * FIXME: The function which should rather requests the drivers is&n;&t; * ide_driver_module(), since it seems illogical and even a bit&n;&t; * dangerous to postpone this until open time!&n;&t; */
macro_line|#ifdef CONFIG_KMOD
r_if
c_cond
(paren
id|drive-&gt;driver
op_eq
l_int|NULL
)paren
(brace
r_char
op_star
id|module
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|drive-&gt;type
)paren
(brace
r_case
id|ATA_DISK
suffix:colon
id|module
op_assign
l_string|&quot;ide-disk&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_ROM
suffix:colon
id|module
op_assign
l_string|&quot;ide-cd&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_TAPE
suffix:colon
id|module
op_assign
l_string|&quot;ide-tape&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_FLOPPY
suffix:colon
id|module
op_assign
l_string|&quot;ide-floppy&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_SCSI
suffix:colon
id|module
op_assign
l_string|&quot;ide-scsi&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* nothing we can do about it */
suffix:semicolon
)brace
r_if
c_cond
(paren
id|module
)paren
id|request_module
c_func
(paren
id|module
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|drive-&gt;driver
op_eq
l_int|NULL
)paren
id|ide_driver_module
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|drive-&gt;busy
)paren
id|sleep_on
c_func
(paren
op_amp
id|drive-&gt;wqueue
)paren
suffix:semicolon
op_increment
id|drive-&gt;usage
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|open
)paren
r_return
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|open
c_func
(paren
id|inode
comma
id|filp
comma
id|drive
)paren
suffix:semicolon
r_else
(brace
op_decrement
id|drive-&gt;usage
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: driver not present&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
op_decrement
id|drive-&gt;usage
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n; * Releasing a block device means we sync() it, so that it can safely&n; * be forgotten about...&n; */
DECL|function|ide_release
r_static
r_int
id|ide_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|drive-&gt;usage
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|release
)paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|release
c_func
(paren
id|inode
comma
id|file
comma
id|drive
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_spin_wait_hwgroup
r_int
id|ide_spin_wait_hwgroup
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
multiline_comment|/* FIXME: Wait on a proper timer. Instead of playing games on the&n;&t; * spin_lock().&n;&t; */
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
(paren
l_int|10
op_star
id|HZ
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|drive-&gt;channel-&gt;lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|IDE_BUSY
comma
id|drive-&gt;channel-&gt;active
)paren
)paren
(brace
id|spin_unlock_irq
c_func
(paren
id|drive-&gt;channel-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: channel busy&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
id|drive-&gt;channel-&gt;lock
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_check_media_change
r_static
r_int
id|ide_check_media_change
c_func
(paren
id|kdev_t
id|i_rdev
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not changed */
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
(brace
id|ata_get
c_func
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|check_media_change
)paren
id|res
op_assign
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|check_media_change
c_func
(paren
id|drive
)paren
suffix:semicolon
r_else
id|res
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* assume it was changed */
id|ata_put
c_func
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|variable|ide_fops
r_struct
id|block_device_operations
id|ide_fops
(braket
)braket
op_assign
(brace
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|open
suffix:colon
id|ide_open
comma
id|release
suffix:colon
id|ide_release
comma
id|ioctl
suffix:colon
id|ata_ioctl
comma
id|check_media_change
suffix:colon
id|ide_check_media_change
comma
id|revalidate
suffix:colon
id|ata_revalidate
)brace
)brace
suffix:semicolon
DECL|variable|ide_fops
id|EXPORT_SYMBOL
c_func
(paren
id|ide_fops
)paren
suffix:semicolon
DECL|variable|ide_spin_wait_hwgroup
id|EXPORT_SYMBOL
c_func
(paren
id|ide_spin_wait_hwgroup
)paren
suffix:semicolon
DECL|variable|drive_is_flashcard
id|EXPORT_SYMBOL
c_func
(paren
id|drive_is_flashcard
)paren
suffix:semicolon
DECL|variable|ide_timer_expiry
id|EXPORT_SYMBOL
c_func
(paren
id|ide_timer_expiry
)paren
suffix:semicolon
DECL|variable|do_ide_request
id|EXPORT_SYMBOL
c_func
(paren
id|do_ide_request
)paren
suffix:semicolon
DECL|variable|ide_set_handler
id|EXPORT_SYMBOL
c_func
(paren
id|ide_set_handler
)paren
suffix:semicolon
DECL|variable|ide_dump_status
id|EXPORT_SYMBOL
c_func
(paren
id|ide_dump_status
)paren
suffix:semicolon
DECL|variable|ata_error
id|EXPORT_SYMBOL
c_func
(paren
id|ata_error
)paren
suffix:semicolon
DECL|variable|ide_wait_stat
id|EXPORT_SYMBOL
c_func
(paren
id|ide_wait_stat
)paren
suffix:semicolon
DECL|variable|restart_request
id|EXPORT_SYMBOL
c_func
(paren
id|restart_request
)paren
suffix:semicolon
DECL|variable|ide_end_drive_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ide_end_drive_cmd
)paren
suffix:semicolon
DECL|variable|__ide_end_request
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_end_request
)paren
suffix:semicolon
DECL|variable|ide_end_request
id|EXPORT_SYMBOL
c_func
(paren
id|ide_end_request
)paren
suffix:semicolon
DECL|variable|ide_stall_queue
id|EXPORT_SYMBOL
c_func
(paren
id|ide_stall_queue
)paren
suffix:semicolon
DECL|variable|ide_setup_ports
id|EXPORT_SYMBOL
c_func
(paren
id|ide_setup_ports
)paren
suffix:semicolon
eof
