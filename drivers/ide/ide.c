multiline_comment|/*&n; *  Copyright (C) 1994-1998  Linus Torvalds &amp; authors (see below)&n; *&n; *  Mostly written by Mark Lord  &lt;mlord@pobox.com&gt;&n; *                and Gadi Oxman &lt;gadio@netvision.net.il&gt;&n; *                and Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *&n; *  See linux/MAINTAINERS for address of current maintainer.&n; *&n; * This is the multiple IDE interface driver, as evolved from hd.c.&n; * It supports up to MAX_HWIFS IDE interfaces, on one or more IRQs (usually 14 &amp; 15).&n; * There can be up to two drives per interface, as per the ATA-2 spec.&n; *&n; * Primary:    ide0, port 0x1f0; major=3;  hda is minor=0; hdb is minor=64&n; * Secondary:  ide1, port 0x170; major=22; hdc is minor=0; hdd is minor=64&n; * Tertiary:   ide2, port 0x???; major=33; hde is minor=0; hdf is minor=64&n; * Quaternary: ide3, port 0x???; major=34; hdg is minor=0; hdh is minor=64&n; * ...&n; *&n; *  From hd.c:&n; *  |&n; *  | It traverses the request-list, using interrupts to jump between functions.&n; *  | As nearly all functions can be called within interrupts, we may not sleep.&n; *  | Special care is recommended.  Have Fun!&n; *  |&n; *  | modified by Drew Eckhardt to check nr of hd&squot;s from the CMOS.&n; *  |&n; *  | Thanks to Branko Lankester, lankeste@fwi.uva.nl, who found a bug&n; *  | in the early extended-partition checks and added DM partitions.&n; *  |&n; *  | Early work on error handling by Mika Liljeberg (liljeber@cs.Helsinki.FI).&n; *  |&n; *  | IRQ-unmask, drive-id, multiple-mode, support for &quot;&gt;16 heads&quot;,&n; *  | and general streamlining by Mark Lord (mlord@pobox.com).&n; *&n; *  October, 1994 -- Complete line-by-line overhaul for linux 1.1.x, by:&n; *&n; *&t;Mark Lord&t;(mlord@pobox.com)&t;&t;(IDE Perf.Pkg)&n; *&t;Delman Lee&t;(delman@ieee.org)&t;&t;(&quot;Mr. atdisk2&quot;)&n; *&t;Scott Snyder&t;(snyder@fnald0.fnal.gov)&t;(ATAPI IDE cd-rom)&n; *&n; *  This was a rewrite of just about everything from hd.c, though some original&n; *  code is still sprinkled about.  Think of it as a major evolution, with&n; *  inspiration from lots of linux users, esp.  hamish@zot.apana.org.au&n; *&n; *  Version 1.0 ALPHA&t;initial code, primary i/f working okay&n; *  Version 1.3 BETA&t;dual i/f on shared irq tested &amp; working!&n; *  Version 1.4 BETA&t;added auto probing for irq(s)&n; *  Version 1.5 BETA&t;added ALPHA (untested) support for IDE cd-roms,&n; *  ...&n; * Version 5.50&t;&t;allow values as small as 20 for idebus=&n; * Version 5.51&t;&t;force non io_32bit in drive_cmd_intr()&n; *&t;&t;&t;change delay_10ms() to delay_50ms() to fix problems&n; * Version 5.52&t;&t;fix incorrect invalidation of removable devices&n; *&t;&t;&t;add &quot;hdx=slow&quot; command line option&n; * Version 5.60&t;&t;start to modularize the driver; the disk and ATAPI&n; *&t;&t;&t; drivers can be compiled as loadable modules.&n; *&t;&t;&t;move IDE probe code to ide-probe.c&n; *&t;&t;&t;move IDE disk code to ide-disk.c&n; *&t;&t;&t;add support for generic IDE device subdrivers&n; *&t;&t;&t;add m68k code from Geert Uytterhoeven&n; *&t;&t;&t;probe all interfaces by default&n; *&t;&t;&t;add ioctl to (re)probe an interface&n; * Version 6.00&t;&t;use per device request queues&n; *&t;&t;&t;attempt to optimize shared hwgroup performance&n; *&t;&t;&t;add ioctl to manually adjust bandwidth algorithms&n; *&t;&t;&t;add kerneld support for the probe module&n; *&t;&t;&t;fix bug in ide_error()&n; *&t;&t;&t;fix bug in the first ide_get_lock() call for Atari&n; *&t;&t;&t;don&squot;t flush leftover data for ATAPI devices&n; * Version 6.01&t;&t;clear hwgroup-&gt;active while the hwgroup sleeps&n; *&t;&t;&t;support HDIO_GETGEO for floppies&n; * Version 6.02&t;&t;fix ide_ack_intr() call&n; *&t;&t;&t;check partition table on floppies&n; * Version 6.03&t;&t;handle bad status bit sequencing in ide_wait_stat()&n; * Version 6.10&t;&t;deleted old entries from this list of updates&n; *&t;&t;&t;replaced triton.c with ide-dma.c generic PCI DMA&n; *&t;&t;&t;added support for BIOS-enabled UltraDMA&n; *&t;&t;&t;rename all &quot;promise&quot; things to &quot;pdc4030&quot;&n; *&t;&t;&t;fix EZ-DRIVE handling on small disks&n; * Version 6.11&t;&t;fix probe error in ide_scan_devices()&n; *&t;&t;&t;fix ancient &quot;jiffies&quot; polling bugs&n; *&t;&t;&t;mask all hwgroup interrupts on each irq entry&n; * Version 6.12&t;&t;integrate ioctl and proc interfaces&n; *&t;&t;&t;fix parsing of &quot;idex=&quot; command line parameter&n; * Version 6.13&t;&t;add support for ide4/ide5 courtesy rjones@orchestream.com&n; * Version 6.14&t;&t;fixed IRQ sharing among PCI devices&n; * Version 6.15&t;&t;added SMP awareness to IDE drivers&n; * Version 6.16&t;&t;fixed various bugs; even more SMP friendly&n; * Version 6.17&t;&t;fix for newest EZ-Drive problem&n; * Version 6.18&t;&t;default unpartitioned-disk translation now &quot;BIOS LBA&quot;&n; * Version 6.19&t;&t;Re-design for a UNIFORM driver for all platforms,&n; *&t;&t;&t;  model based on suggestions from Russell King and&n; *&t;&t;&t;  Geert Uytterhoeven&n; *&t;&t;&t;Promise DC4030VL now supported.&n; *&t;&t;&t;add support for ide6/ide7&n; *&t;&t;&t;delay_50ms() changed to ide_delay_50ms() and exported.&n; * Version 6.20&t;&t;Added/Fixed Generic ATA-66 support and hwif detection.&n; *&t;&t;&t;Added hdx=flash to allow for second flash disk&n; *&t;&t;&t;  detection w/o the hang loop.&n; *&t;&t;&t;Added support for ide8/ide9&n; *&t;&t;&t;Added idex=ata66 for the quirky chipsets that are&n; *&t;&t;&t;  ATA-66 compliant, but have yet to determine a method&n; *&t;&t;&t;  of verification of the 80c cable presence.&n; *&t;&t;&t;  Specifically Promise&squot;s PDC20262 chipset.&n; * Version 6.21&t;&t;Fixing/Fixed SMP spinlock issue with insight from an old&n; *&t;&t;&t;  hat that clarified original low level driver design.&n; * Version 6.30&t;&t;Added SMP support; fixed multmode issues.  -ml&n; * Version 6.31&t;&t;Debug Share INTR&squot;s and request queue streaming&n; *&t;&t;&t;Native ATA-100 support&n; *&t;&t;&t;Prep for Cascades Project&n; * Version 6.32&t;&t;4GB highmem support for DMA, and mapping of those for&n; *&t;&t;&t;PIO transfer (Jens Axboe)&n; *&n; *  Some additional driver compile-time options are in ./include/linux/ide.h&n; */
DECL|macro|VERSION
mdefine_line|#define&t;VERSION&t;&quot;7.0.0&quot;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#ifndef MODULE
macro_line|# include &lt;linux/init.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &quot;ata-timing.h&quot;
multiline_comment|/*&n; * Those will be moved into separate header files eventually.&n; */
macro_line|#ifdef CONFIG_BLK_DEV_RZ1000
r_extern
r_void
id|ide_probe_for_rz100x
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_IDE
r_extern
r_void
id|init_e100_ide
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_CMD640
r_extern
r_void
id|ide_probe_for_cmd640x
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
r_extern
r_int
id|ide_probe_for_pdc4030
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDE_PMAC
r_extern
r_void
id|pmac_ide_probe
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDE_ICSIDE
r_extern
r_void
id|icside_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDE_RAPIDE
r_extern
r_void
id|rapide_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_GAYLE
r_extern
r_void
id|gayle_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_FALCON_IDE
r_extern
r_void
id|falconide_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_MAC_IDE
r_extern
r_void
id|macide_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_Q40IDE
r_extern
r_void
id|q40ide_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_BUDDHA
r_extern
r_void
id|buddha_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_BLK_DEV_ISAPNP) &amp;&amp; defined(CONFIG_ISAPNP)
r_extern
r_void
id|pnpide_init
c_func
(paren
r_int
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* default maximum number of failures */
DECL|macro|IDE_DEFAULT_MAX_FAILURES
mdefine_line|#define IDE_DEFAULT_MAX_FAILURES&t;1
DECL|variable|idebus_parameter
r_static
r_int
id|idebus_parameter
suffix:semicolon
multiline_comment|/* holds the &quot;idebus=&quot; parameter */
DECL|variable|system_bus_speed
r_int
id|system_bus_speed
suffix:semicolon
multiline_comment|/* holds what we think is VESA/PCI bus speed */
DECL|variable|initializing
r_static
r_int
id|initializing
suffix:semicolon
multiline_comment|/* set while initializing built-in drivers */
multiline_comment|/*&n; * Protects access to global structures etc.&n; */
DECL|variable|__cacheline_aligned
id|spinlock_t
id|ide_lock
id|__cacheline_aligned
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
DECL|variable|ide_scan_direction
r_static
r_int
id|ide_scan_direction
suffix:semicolon
multiline_comment|/* THIS was formerly 2.2.x pci=reverse */
macro_line|#endif
macro_line|#if defined(__mc68000__) || defined(CONFIG_APUS)
multiline_comment|/*&n; * This is used by the Atari code to obtain access to the IDE interrupt,&n; * which is shared between several drivers.&n; */
DECL|variable|ide_intr_lock
r_static
r_int
id|ide_intr_lock
suffix:semicolon
macro_line|#endif
DECL|variable|noautodma
r_int
id|noautodma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * This is declared extern in ide.h, for access by other IDE modules:&n; */
DECL|variable|ide_hwifs
r_struct
id|ata_channel
id|ide_hwifs
(braket
id|MAX_HWIFS
)braket
suffix:semicolon
multiline_comment|/* master data repository */
macro_line|#if (DISK_RECOVERY_TIME &gt; 0)
multiline_comment|/*&n; * For really screwed hardware (hey, at least it *can* be used with Linux)&n; * we can enforce a minimum delay time between successive operations.&n; */
DECL|function|read_timer
r_static
r_int
r_int
id|read_timer
(paren
r_void
)paren
(brace
r_int
r_int
id|t
comma
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|t
op_assign
id|jiffies
op_star
l_int|11932
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
l_int|0x43
)paren
suffix:semicolon
id|i
op_assign
id|inb_p
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
id|i
op_or_assign
id|inb
c_func
(paren
l_int|0x40
)paren
op_lshift
l_int|8
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
r_return
(paren
id|t
op_minus
id|i
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|set_recovery_timer
r_static
r_inline
r_void
id|set_recovery_timer
c_func
(paren
r_struct
id|ata_channel
op_star
id|channel
)paren
(brace
macro_line|#if (DISK_RECOVERY_TIME &gt; 0)
id|channel-&gt;last_time
op_assign
id|read_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Do not even *think* about calling this!&n; */
DECL|function|init_hwif_data
r_static
r_void
id|init_hwif_data
c_func
(paren
r_struct
id|ata_channel
op_star
id|hwif
comma
r_int
r_int
id|index
)paren
(brace
r_static
r_const
id|byte
id|ide_major
(braket
)braket
op_assign
(brace
id|IDE0_MAJOR
comma
id|IDE1_MAJOR
comma
id|IDE2_MAJOR
comma
id|IDE3_MAJOR
comma
id|IDE4_MAJOR
comma
id|IDE5_MAJOR
comma
id|IDE6_MAJOR
comma
id|IDE7_MAJOR
comma
id|IDE8_MAJOR
comma
id|IDE9_MAJOR
)brace
suffix:semicolon
r_int
r_int
id|unit
suffix:semicolon
id|hw_regs_t
id|hw
suffix:semicolon
multiline_comment|/* bulk initialize hwif &amp; drive info with zeros */
id|memset
c_func
(paren
id|hwif
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ata_channel
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|hw
comma
l_int|0
comma
r_sizeof
(paren
id|hw_regs_t
)paren
)paren
suffix:semicolon
multiline_comment|/* fill in any non-zero initial values */
id|hwif-&gt;index
op_assign
id|index
suffix:semicolon
id|ide_init_hwif_ports
c_func
(paren
op_amp
id|hw
comma
id|ide_default_io_base
c_func
(paren
id|index
)paren
comma
l_int|0
comma
op_amp
id|hwif-&gt;irq
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|hwif-&gt;hw
comma
op_amp
id|hw
comma
r_sizeof
(paren
id|hw
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hwif-&gt;io_ports
comma
id|hw.io_ports
comma
r_sizeof
(paren
id|hw.io_ports
)paren
)paren
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
op_logical_neg
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_HD
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
id|HD_DATA
)paren
id|hwif-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* may be overridden by ide_setup() */
macro_line|#endif /* CONFIG_BLK_DEV_HD */
id|hwif-&gt;major
op_assign
id|ide_major
(braket
id|index
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|hwif-&gt;name
comma
l_string|&quot;ide%d&quot;
comma
id|index
)paren
suffix:semicolon
id|hwif-&gt;bus_state
op_assign
id|BUSSTATE_ON
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
id|drive-&gt;type
op_assign
id|ATA_DISK
suffix:semicolon
id|drive-&gt;select.all
op_assign
(paren
id|unit
op_lshift
l_int|4
)paren
op_or
l_int|0xa0
suffix:semicolon
id|drive-&gt;channel
op_assign
id|hwif
suffix:semicolon
id|drive-&gt;ctl
op_assign
l_int|0x08
suffix:semicolon
id|drive-&gt;ready_stat
op_assign
id|READY_STAT
suffix:semicolon
id|drive-&gt;bad_wstat
op_assign
id|BAD_W_STAT
suffix:semicolon
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;special.b.set_geometry
op_assign
l_int|1
suffix:semicolon
id|sprintf
c_func
(paren
id|drive-&gt;name
comma
l_string|&quot;hd%c&quot;
comma
l_char|&squot;a&squot;
op_plus
(paren
id|index
op_star
id|MAX_DRIVES
)paren
op_plus
id|unit
)paren
suffix:semicolon
id|drive-&gt;max_failures
op_assign
id|IDE_DEFAULT_MAX_FAILURES
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|drive-&gt;wqueue
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * init_ide_data() sets reasonable default values into all fields&n; * of all instances of the hwifs and drives, but only on the first call.&n; * Subsequent calls have no effect (they don&squot;t wipe out anything).&n; *&n; * This routine is normally called at driver initialization time,&n; * but may also be called MUCH earlier during kernel &quot;command-line&quot;&n; * parameter processing.  As such, we cannot depend on any other parts&n; * of the kernel (such as memory allocation) to be functioning yet.&n; *&n; * This is too bad, as otherwise we could dynamically allocate the&n; * ide_drive_t structs as needed, rather than always consuming memory&n; * for the max possible number (MAX_HWIFS * MAX_DRIVES) of them.&n; */
DECL|macro|MAGIC_COOKIE
mdefine_line|#define MAGIC_COOKIE 0x12345678
DECL|function|init_ide_data
r_static
r_void
id|__init
id|init_ide_data
(paren
r_void
)paren
(brace
r_int
r_int
id|h
suffix:semicolon
r_static
r_int
r_int
id|magic_cookie
op_assign
id|MAGIC_COOKIE
suffix:semicolon
r_if
c_cond
(paren
id|magic_cookie
op_ne
id|MAGIC_COOKIE
)paren
r_return
suffix:semicolon
multiline_comment|/* already initialized */
id|magic_cookie
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize all interface structures */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
id|init_hwif_data
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|h
)braket
comma
id|h
)paren
suffix:semicolon
multiline_comment|/* Add default hw interfaces */
id|ide_init_default_hwifs
c_func
(paren
)paren
suffix:semicolon
id|idebus_parameter
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * CompactFlash cards and their relatives pretend to be removable hard disks, except:&n; *&t;(1) they never have a slave unit, and&n; *&t;(2) they don&squot;t have a door lock mechanisms.&n; * This test catches them, and is invoked elsewhere when setting appropriate config bits.&n; *&n; * FIXME FIXME: Yes this is for certain applicable for all of them as time has shown.&n; *&n; * FIXME: This treatment is probably applicable for *all* PCMCIA (PC CARD) devices,&n; * so in linux 2.3.x we should change this to just treat all PCMCIA drives this way,&n; * and get rid of the model-name tests below (too big of an interface change for 2.2.x).&n; * At that time, we might also consider parameterizing the timeouts and retries,&n; * since these are MUCH faster than mechanical drives.&t;-M.Lord&n; */
DECL|function|drive_is_flashcard
r_int
id|drive_is_flashcard
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;removable
op_logical_and
id|id
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|id-&gt;config
op_eq
l_int|0x848a
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* CompactFlash */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;KODAK ATA_FLASH&quot;
comma
l_int|15
)paren
multiline_comment|/* Kodak */
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;Hitachi CV&quot;
comma
l_int|10
)paren
multiline_comment|/* Hitachi */
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;SunDisk SDCFB&quot;
comma
l_int|13
)paren
multiline_comment|/* SunDisk */
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;HAGIWARA HPC&quot;
comma
l_int|12
)paren
multiline_comment|/* Hagiwara */
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;LEXAR ATA_FLASH&quot;
comma
l_int|15
)paren
multiline_comment|/* Lexar */
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;ATA_FLASH&quot;
comma
l_int|9
)paren
)paren
multiline_comment|/* Simple Tech */
(brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* yes, it is a flash memory card */
)brace
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no, it is not a flash memory card */
)brace
DECL|function|ide_end_queued_request
r_void
id|ide_end_queued_request
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|uptodate
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
id|REQ_STARTED
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|rq-&gt;special
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|end_that_request_first
c_func
(paren
id|rq
comma
id|uptodate
comma
id|rq-&gt;hard_nr_sectors
)paren
)paren
(brace
r_struct
id|ata_request
op_star
id|ar
op_assign
id|rq-&gt;special
suffix:semicolon
id|add_blkdev_randomness
c_func
(paren
id|major
c_func
(paren
id|rq-&gt;rq_dev
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|ata_ar_put
c_func
(paren
id|drive
comma
id|ar
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|rq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|__ide_end_request
r_int
id|__ide_end_request
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|uptodate
comma
r_int
id|nr_secs
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
id|REQ_STARTED
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * small hack to eliminate locking from ide_end_request to grab&n;&t; * the first segment number of sectors&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|nr_secs
)paren
id|nr_secs
op_assign
id|rq-&gt;hard_cur_sectors
suffix:semicolon
multiline_comment|/*&n;&t; * decide whether to reenable DMA -- 3 is a random magic for now,&n;&t; * if we DMA timeout more than 3 times, just stay in PIO&n;&t; */
r_if
c_cond
(paren
id|drive-&gt;state
op_eq
id|DMA_PIO_RETRY
op_logical_and
id|drive-&gt;retry_pio
op_le
l_int|3
)paren
(brace
id|drive-&gt;state
op_assign
l_int|0
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|end_that_request_first
c_func
(paren
id|rq
comma
id|uptodate
comma
id|nr_secs
)paren
)paren
(brace
r_struct
id|ata_request
op_star
id|ar
op_assign
id|rq-&gt;special
suffix:semicolon
id|add_blkdev_randomness
c_func
(paren
id|major
c_func
(paren
id|rq-&gt;rq_dev
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * request with ATA_AR_QUEUED set have already been&n;&t;&t; * dequeued, but doing it twice is ok&n;&t;&t; */
id|blkdev_dequeue_request
c_func
(paren
id|rq
)paren
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ar
)paren
id|ata_ar_put
c_func
(paren
id|drive
comma
id|ar
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|rq
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This should get invoked any time we exit the driver to&n; * wait for an interrupt response from a drive.  handler() points&n; * at the appropriate code to handle the next interrupt, and a&n; * timer is started to prevent us from waiting forever in case&n; * something goes wrong (see the ide_timer_expiry() handler later on).&n; */
DECL|function|ide_set_handler
r_void
id|ide_set_handler
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_handler_t
op_star
id|handler
comma
r_int
r_int
id|timeout
comma
id|ide_expiry_t
op_star
id|expiry
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ide_set_handler: handler not null; old=%p, new=%p, from %p&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|hwgroup-&gt;handler
comma
id|handler
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
id|hwgroup-&gt;handler
op_assign
id|handler
suffix:semicolon
id|hwgroup-&gt;expiry
op_assign
id|expiry
suffix:semicolon
id|hwgroup-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|hwgroup-&gt;timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|ata_pre_reset
r_static
r_void
id|ata_pre_reset
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|pre_reset
)paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|pre_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;keep_settings
op_logical_and
op_logical_neg
id|drive-&gt;using_dma
)paren
(brace
id|drive-&gt;unmask
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive-&gt;using_dma
)paren
(brace
multiline_comment|/* check the DMA crc count */
r_if
c_cond
(paren
id|drive-&gt;crc_count
)paren
(brace
id|drive-&gt;channel
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off_quietly
comma
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive-&gt;channel-&gt;speedproc
)paren
op_ne
l_int|NULL
)paren
id|drive-&gt;channel
op_member_access_from_pointer
id|speedproc
c_func
(paren
id|drive
comma
id|ide_auto_reduce_xfer
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;current_speed
op_ge
id|XFER_SW_DMA_0
)paren
id|drive-&gt;channel
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
id|drive-&gt;channel
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off
comma
id|drive
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The capacity of a drive according to its current geometry/LBA settings in&n; * sectors.&n; */
DECL|function|ata_capacity
r_int
r_int
id|ata_capacity
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
op_logical_or
op_logical_neg
id|drive-&gt;driver
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|capacity
)paren
r_return
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|capacity
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* This used to be 0x7fffffff, but since now we use the maximal drive&n;&t; * capacity value used by other kernel subsystems as well.&n;&t; */
r_return
op_complement
l_int|0UL
suffix:semicolon
)brace
multiline_comment|/*&n; * This is used to issue WIN_SPECIFY, WIN_RESTORE, and WIN_SETMULT commands to&n; * a drive.  It used to do much more, but has been scaled back.&n; */
DECL|function|ata_special
r_static
id|ide_startstop_t
id|ata_special
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|special_t
op_star
id|s
op_assign
op_amp
id|drive-&gt;special
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: ata_special: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|s-&gt;all
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|s-&gt;b.set_tune
)paren
(brace
id|ide_tuneproc_t
op_star
id|tuneproc
op_assign
id|drive-&gt;channel-&gt;tuneproc
suffix:semicolon
id|s-&gt;b.set_tune
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tuneproc
op_ne
l_int|NULL
)paren
id|tuneproc
c_func
(paren
id|drive
comma
id|drive-&gt;tune_req
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;driver
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|special
)paren
r_return
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|special
c_func
(paren
id|drive
)paren
suffix:semicolon
r_else
(brace
id|drive-&gt;special.all
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;mult_req
op_assign
l_int|0
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;all
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: bad special flag: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|s-&gt;all
)paren
suffix:semicolon
id|s-&gt;all
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
r_extern
r_struct
id|block_device_operations
id|ide_fops
(braket
)braket
suffix:semicolon
multiline_comment|/*&n; * This is called exactly *once* for each channel.&n; */
DECL|function|ide_geninit
r_void
id|ide_geninit
c_func
(paren
r_struct
id|ata_channel
op_star
id|hwif
)paren
(brace
r_int
r_int
id|unit
suffix:semicolon
r_struct
id|gendisk
op_star
id|gd
op_assign
id|hwif-&gt;gd
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
op_logical_and
id|drive-&gt;type
op_ne
id|ATA_FLOPPY
)paren
r_continue
suffix:semicolon
id|register_disk
c_func
(paren
id|gd
comma
id|mk_kdev
c_func
(paren
id|hwif-&gt;major
comma
id|unit
op_lshift
id|PARTN_BITS
)paren
comma
macro_line|#ifdef CONFIG_BLK_DEV_ISAPNP
(paren
id|drive-&gt;forced_geom
op_logical_and
id|drive-&gt;noprobe
)paren
ques
c_cond
l_int|1
suffix:colon
macro_line|#endif
l_int|1
op_lshift
id|PARTN_BITS
comma
id|ide_fops
comma
id|ata_capacity
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
id|ide_startstop_t
id|do_reset1
c_func
(paren
id|ide_drive_t
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* needed below */
multiline_comment|/*&n; * Poll the interface for completion every 50ms during an ATAPI drive reset&n; * operation. If the drive has not yet responded, and we have not yet hit our&n; * maximum waiting time, then the timer is restarted for another 50ms.&n; */
DECL|function|atapi_reset_pollfunc
r_static
id|ide_startstop_t
id|atapi_reset_pollfunc
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
id|byte
id|stat
suffix:semicolon
id|SELECT_DRIVE
c_func
(paren
id|drive-&gt;channel
comma
id|drive
)paren
suffix:semicolon
id|udelay
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
l_int|0
comma
id|BUSY_STAT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ATAPI reset complete&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|hwgroup-&gt;poll_timeout
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|atapi_reset_pollfunc
comma
id|HZ
op_div
l_int|20
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
multiline_comment|/* continue polling */
)brace
id|hwgroup-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* end of polling */
id|printk
c_func
(paren
l_string|&quot;%s: ATAPI reset timed-out, status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
r_return
id|do_reset1
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* do it the old fashioned way */
)brace
id|hwgroup-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* done polling */
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Poll the interface for completion every 50ms during an ata reset operation.&n; * If the drives have not yet responded, and we have not yet hit our maximum&n; * waiting time, then the timer is restarted for another 50ms.&n; */
DECL|function|reset_pollfunc
r_static
id|ide_startstop_t
id|reset_pollfunc
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|ata_channel
op_star
id|hwif
op_assign
id|drive-&gt;channel
suffix:semicolon
id|byte
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|tmp
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
l_int|0
comma
id|BUSY_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|hwgroup-&gt;poll_timeout
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|reset_pollfunc
comma
id|HZ
op_div
l_int|20
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
multiline_comment|/* continue polling */
)brace
id|printk
c_func
(paren
l_string|&quot;%s: reset timed-out, status=0x%02x&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|tmp
)paren
suffix:semicolon
id|drive-&gt;failures
op_increment
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset: &quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_assign
id|GET_ERR
c_func
(paren
)paren
)paren
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;success&bslash;n&quot;
)paren
suffix:semicolon
id|drive-&gt;failures
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|drive-&gt;failures
op_increment
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
id|printk
c_func
(paren
l_string|&quot;master: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|tmp
op_amp
l_int|0x7f
)paren
(brace
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;passed&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;formatter device error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;sector buffer error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ECC circuitry error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;controlling MPU error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;error (0x%02x?)&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp
op_amp
l_int|0x80
)paren
id|printk
c_func
(paren
l_string|&quot;; slave: failed&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|hwgroup-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* done polling */
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * do_reset1() attempts to recover a confused drive by resetting it.&n; * Unfortunately, resetting a disk drive actually resets all devices on&n; * the same interface, so it can really be thought of as resetting the&n; * interface rather than resetting the drive.&n; *&n; * ATAPI devices have their own reset mechanism which allows them to be&n; * individually reset without clobbering other devices on the same interface.&n; *&n; * Unfortunately, the IDE interface does not generate an interrupt to let&n; * us know when the reset operation has finished, so we must poll for this.&n; * Equally poor, though, is the fact that this may a very long time to complete,&n; * (up to 30 seconds worst case).  So, instead of busy-waiting here for it,&n; * we set a timer to poll at 50ms intervals.&n; */
DECL|function|do_reset1
r_static
id|ide_startstop_t
id|do_reset1
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|do_not_try_atapi
)paren
(brace
r_int
r_int
id|unit
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ata_channel
op_star
id|hwif
op_assign
id|drive-&gt;channel
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
multiline_comment|/* For an ATAPI device, first try an ATAPI SRST. */
r_if
c_cond
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
op_logical_and
op_logical_neg
id|do_not_try_atapi
)paren
(brace
id|ata_pre_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
id|SELECT_DRIVE
c_func
(paren
id|hwif
comma
id|drive
)paren
suffix:semicolon
id|udelay
(paren
l_int|20
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|WIN_SRST
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|hwgroup-&gt;poll_timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
id|BUG_ON
c_func
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|atapi_reset_pollfunc
comma
id|HZ
op_div
l_int|20
comma
l_int|NULL
)paren
suffix:semicolon
id|__restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * First, reset any device state data we were maintaining&n;&t; * for any of the drives on this interface.&n;&t; */
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
id|ata_pre_reset
c_func
(paren
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
)paren
suffix:semicolon
macro_line|#if OK_TO_RESET_CONTROLLER
r_if
c_cond
(paren
op_logical_neg
id|IDE_CONTROL_REG
)paren
(brace
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Note that we also set nIEN while resetting the device,&n;&t; * to mask unwanted interrupts from the interface during the reset.&n;&t; * However, due to the design of PC hardware, this will cause an&n;&t; * immediate interrupt due to the edge transition it produces.&n;&t; * This single interrupt gives us a &quot;fast poll&quot; for drives that&n;&t; * recover from reset very quickly, saving us the first 50ms wait time.&n;&t; */
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|6
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* set SRST and nIEN */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* more than enough time */
r_if
c_cond
(paren
id|drive-&gt;quirk_list
op_eq
l_int|2
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear SRST and nIEN */
)brace
r_else
(brace
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|2
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear SRST, leave nIEN */
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* more than enough time */
id|hwgroup-&gt;poll_timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
id|BUG_ON
c_func
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|reset_pollfunc
comma
id|HZ
op_div
l_int|20
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Some weird controller like resetting themselves to a strange&n;&t; * state when the disks are reset this way. At least, the Winbond&n;&t; * 553 documentation says that&n;&t; */
r_if
c_cond
(paren
id|hwif-&gt;resetproc
op_ne
l_int|NULL
)paren
id|hwif
op_member_access_from_pointer
id|resetproc
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#endif
id|__restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|read_24
r_static
r_inline
id|u32
id|read_24
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
op_lshift
l_int|8
)paren
op_or
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Clean up after success/failure of an explicit drive cmd&n; */
DECL|function|ide_end_drive_cmd
r_void
id|ide_end_drive_cmd
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|stat
comma
id|byte
id|err
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_CMD
)paren
(brace
id|byte
op_star
id|args
op_assign
(paren
id|byte
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|rq-&gt;errors
op_assign
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
)paren
(brace
id|args
(braket
l_int|0
)braket
op_assign
id|stat
suffix:semicolon
id|args
(braket
l_int|1
)braket
op_assign
id|err
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASK
)paren
(brace
id|byte
op_star
id|args
op_assign
(paren
id|byte
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|rq-&gt;errors
op_assign
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
)paren
(brace
id|args
(braket
l_int|0
)braket
op_assign
id|stat
suffix:semicolon
id|args
(braket
l_int|1
)braket
op_assign
id|err
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args
(braket
l_int|3
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args
(braket
l_int|4
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args
(braket
l_int|5
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|args
(braket
l_int|6
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
(brace
r_struct
id|ata_request
op_star
id|ar
op_assign
id|rq-&gt;special
suffix:semicolon
r_struct
id|ata_taskfile
op_star
id|args
op_assign
op_amp
id|ar-&gt;ar_task
suffix:semicolon
id|rq-&gt;errors
op_assign
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
op_logical_and
id|args-&gt;taskfile.command
op_eq
id|WIN_NOP
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: NOP completed&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
)paren
(brace
id|args-&gt;taskfile.feature
op_assign
id|err
suffix:semicolon
id|args-&gt;taskfile.sector_count
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args-&gt;taskfile.sector_number
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args-&gt;taskfile.low_cylinder
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args-&gt;taskfile.high_cylinder
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|args-&gt;taskfile.device_head
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|args-&gt;taskfile.command
op_assign
id|stat
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
multiline_comment|/* The following command goes to the hob file! */
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|0x80
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|args-&gt;hobfile.feature
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|args-&gt;hobfile.sector_count
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|args-&gt;hobfile.sector_number
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|args-&gt;hobfile.low_cylinder
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|args-&gt;hobfile.high_cylinder
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ar-&gt;ar_flags
op_amp
id|ATA_AR_RETURN
)paren
id|ata_ar_put
c_func
(paren
id|drive
comma
id|ar
)paren
suffix:semicolon
)brace
id|blkdev_dequeue_request
c_func
(paren
id|rq
)paren
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|rq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Error reporting, in human readable form (luxurious, but a memory hog).&n; */
DECL|function|ide_dump_status
id|byte
id|ide_dump_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|byte
id|stat
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|byte
id|err
op_assign
l_int|0
suffix:semicolon
id|__save_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|printk
c_func
(paren
l_string|&quot;%s: %s: status=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Busy &quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|READY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DriveReady &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DeviceFault &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|SEEK_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;SeekComplete &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DataRequest &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ECC_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;CorrectedError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|INDEX_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Index &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Error &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
macro_line|#endif&t;/* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
(paren
id|BUSY_STAT
op_or
id|ERR_STAT
)paren
)paren
op_eq
id|ERR_STAT
)paren
(brace
id|err
op_assign
id|GET_ERR
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: error=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|err
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
r_if
c_cond
(paren
id|drive-&gt;type
op_eq
id|ATA_DISK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ABRT_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;DriveStatusError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ICRC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
(paren
id|err
op_amp
id|ABRT_ERR
)paren
ques
c_cond
l_string|&quot;BadCRC &quot;
suffix:colon
l_string|&quot;BadSector &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ECC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;UncorrectableError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ID_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;SectorIdNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;TrackZeroNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|MARK_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;AddrMarkNotFound &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ABRT_ERR
)paren
)paren
op_eq
id|BBD_ERR
op_logical_or
(paren
id|err
op_amp
(paren
id|ECC_ERR
op_or
id|ID_ERR
op_or
id|MARK_ERR
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|drive-&gt;id-&gt;command_set_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;id-&gt;cfs_enable_2
op_amp
l_int|0x0400
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
id|__u64
id|sectors
op_assign
l_int|0
suffix:semicolon
id|u32
id|low
op_assign
l_int|0
comma
id|high
op_assign
l_int|0
suffix:semicolon
id|low
op_assign
id|read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|0x80
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|high
op_assign
id|read_24
c_func
(paren
id|drive
)paren
suffix:semicolon
id|sectors
op_assign
(paren
(paren
id|__u64
)paren
id|high
op_lshift
l_int|24
)paren
op_or
id|low
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%lld, high=%d, low=%d&quot;
comma
(paren
r_int
r_int
)paren
id|sectors
comma
id|high
comma
id|low
)paren
suffix:semicolon
)brace
r_else
(brace
id|byte
id|cur
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/* using LBA? */
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%ld&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|cur
op_amp
l_int|0xf
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
op_lshift
l_int|8
)paren
op_or
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, CHS=%d/%d/%d&quot;
comma
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|8
)paren
op_plus
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
comma
id|cur
op_amp
l_int|0xf
comma
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_logical_and
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
id|printk
c_func
(paren
l_string|&quot;, sector=%ld&quot;
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;sector
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|__restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * try_to_flush_leftover_data() is invoked in response to a drive&n; * unexpectedly having its DRQ_STAT bit set.  As an alternative to&n; * resetting the drive, this routine tries to clear the condition&n; * by read a sector&squot;s worth of data from the drive.  Of course,&n; * this may not help if the drive is *waiting* for data from *us*.&n; */
DECL|function|try_to_flush_leftover_data
r_static
r_void
id|try_to_flush_leftover_data
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|i
op_assign
(paren
id|drive-&gt;mult_count
ques
c_cond
id|drive-&gt;mult_count
suffix:colon
l_int|1
)paren
op_star
id|SECTOR_WORDS
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
(brace
id|u32
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|wcount
op_assign
(paren
id|i
OG
l_int|16
)paren
ques
c_cond
l_int|16
suffix:colon
id|i
suffix:semicolon
id|i
op_sub_assign
id|wcount
suffix:semicolon
id|ata_input_data
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Take action based on the error returned by the drive.&n; */
DECL|function|ide_error
id|ide_startstop_t
id|ide_error
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|byte
id|stat
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|byte
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: remember to invalidate tcq queue when drive-&gt;using_tcq&n;&t; * and atomic_read(&amp;drive-&gt;tcq-&gt;queued) /jens&n;&t; */
id|err
op_assign
id|ide_dump_status
c_func
(paren
id|drive
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
l_int|NULL
op_logical_or
(paren
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
op_eq
l_int|NULL
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* retry only &quot;normal&quot; I/O: */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
id|REQ_CMD
)paren
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|err
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
op_logical_or
(paren
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
op_logical_and
op_logical_neg
id|drive-&gt;nowerr
)paren
)paren
(brace
multiline_comment|/* other bits are useless when BUSY */
id|rq-&gt;errors
op_or_assign
id|ERROR_RESET
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;type
op_eq
id|ATA_DISK
op_logical_and
(paren
id|stat
op_amp
id|ERR_STAT
)paren
)paren
(brace
multiline_comment|/* err has different meaning on cdrom and tape */
r_if
c_cond
(paren
id|err
op_eq
id|ABRT_ERR
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;select.b.lba
op_logical_and
id|IN_BYTE
c_func
(paren
id|IDE_COMMAND_REG
)paren
op_eq
id|WIN_SPECIFY
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* some newer drives don&squot;t support WIN_SPECIFY */
)brace
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
(paren
id|ABRT_ERR
op_or
id|ICRC_ERR
)paren
)paren
op_eq
(paren
id|ABRT_ERR
op_or
id|ICRC_ERR
)paren
)paren
(brace
id|drive-&gt;crc_count
op_increment
suffix:semicolon
multiline_comment|/* UDMA crc error -- just retry the operation */
)brace
r_else
r_if
c_cond
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ECC_ERR
)paren
)paren
multiline_comment|/* retries won&squot;t help these */
id|rq-&gt;errors
op_assign
id|ERROR_MAX
suffix:semicolon
r_else
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
multiline_comment|/* help it find track zero */
id|rq-&gt;errors
op_or_assign
id|ERROR_RECAL
suffix:semicolon
)brace
multiline_comment|/* pre bio (rq-&gt;cmd != WRITE) */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_logical_and
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
id|try_to_flush_leftover_data
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GET_STAT
c_func
(paren
)paren
op_amp
(paren
id|BUSY_STAT
op_or
id|DRQ_STAT
)paren
)paren
id|OUT_BYTE
c_func
(paren
id|WIN_IDLEIMMEDIATE
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* force an abort */
r_if
c_cond
(paren
id|rq-&gt;errors
op_ge
id|ERROR_MAX
)paren
(brace
multiline_comment|/* ATA-PATTERN */
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
)paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_else
id|ide_end_request
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RESET
)paren
op_eq
id|ERROR_RESET
)paren
(brace
op_increment
id|rq-&gt;errors
suffix:semicolon
r_return
id|do_reset1
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RECAL
)paren
op_eq
id|ERROR_RECAL
)paren
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
op_increment
id|rq-&gt;errors
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Issue a simple drive command.  The drive must be selected beforehand.&n; */
DECL|function|ide_cmd
r_void
id|ide_cmd
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|cmd
comma
id|byte
id|nsect
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
id|BUG_ON
c_func
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear nIEN */
id|SELECT_MASK
c_func
(paren
id|drive-&gt;channel
comma
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|nsect
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|cmd
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Invoked on completion of a special DRIVE_CMD.&n; */
DECL|function|drive_cmd_intr
r_static
id|ide_startstop_t
id|drive_cmd_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|byte
op_star
id|args
op_assign
(paren
id|byte
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_int
id|retries
op_assign
l_int|10
suffix:semicolon
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_logical_and
id|args
op_logical_and
id|args
(braket
l_int|3
)braket
)paren
(brace
id|byte
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
id|ata_input_data
c_func
(paren
id|drive
comma
op_amp
id|args
(braket
l_int|4
)braket
comma
id|args
(braket
l_int|3
)braket
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
id|io_32bit
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|retries
op_decrement
)paren
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;drive_cmd&quot;
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/* calls ide_end_drive_cmd */
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/*&n; * Busy-wait for the drive status to be not &quot;busy&quot;.  Check then the status for&n; * all of the &quot;good&quot; bits and none of the &quot;bad&quot; bits, and if all is okay it&n; * returns 0.  All other cases return 1 after invoking ide_error() -- caller&n; * should just return.&n; *&n; * This routine should get fixed to not hog the cpu during extra long waits..&n; * That could be done by busy-waiting for the first jiffy or two, and then&n; * setting a timer to wake up at half second intervals thereafter, until&n; * timeout is achieved, before timing out.&n; */
DECL|function|ide_wait_stat
r_int
id|ide_wait_stat
c_func
(paren
id|ide_startstop_t
op_star
id|startstop
comma
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|good
comma
id|byte
id|bad
comma
r_int
r_int
id|timeout
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* bail early if we&squot;ve exceeded max_failures */
r_if
c_cond
(paren
id|drive-&gt;max_failures
op_logical_and
(paren
id|drive-&gt;failures
OG
id|drive-&gt;max_failures
)paren
)paren
(brace
op_star
id|startstop
op_assign
id|ide_stopped
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* spec allows drive 400ns to assert &quot;BUSY&quot; */
r_if
c_cond
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
op_amp
id|BUSY_STAT
)paren
(brace
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
op_amp
id|BUSY_STAT
)paren
(brace
r_if
c_cond
(paren
l_int|0
OL
(paren
r_int
r_int
)paren
(paren
id|jiffies
op_minus
id|timeout
)paren
)paren
(brace
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
op_star
id|startstop
op_assign
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;status timeout&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
)brace
multiline_comment|/*&n;&t; * Allow status to settle, then read it again.&n;&t; * A few rare drives vastly violate the 400ns spec here,&n;&t; * so we&squot;ll wait up to 10usec for a &quot;good&quot; status&n;&t; * rather than expensively fail things immediately.&n;&t; * This fix courtesy of Matthew Faupel &amp; Niccolo Rigacci.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
comma
id|good
comma
id|bad
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|startstop
op_assign
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;status error&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This initiates handling of a new I/O request.&n; */
DECL|function|start_request
r_static
id|ide_startstop_t
id|start_request
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_startstop_t
id|startstop
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
r_int
r_int
id|minor
op_assign
id|minor
c_func
(paren
id|rq-&gt;rq_dev
)paren
comma
id|unit
op_assign
id|minor
op_rshift
id|PARTN_BITS
suffix:semicolon
r_struct
id|ata_channel
op_star
id|hwif
op_assign
id|drive-&gt;channel
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
id|REQ_STARTED
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: start_request: current=0x%08lx&bslash;n&quot;
comma
id|hwif-&gt;name
comma
(paren
r_int
r_int
)paren
id|rq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* bail early if we&squot;ve exceeded max_failures */
r_if
c_cond
(paren
id|drive-&gt;max_failures
op_logical_and
(paren
id|drive-&gt;failures
OG
id|drive-&gt;max_failures
)paren
)paren
(brace
r_goto
id|kill_rq
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unit
op_ge
id|MAX_DRIVES
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: bad device number: %s&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|kdevname
c_func
(paren
id|rq-&gt;rq_dev
)paren
)paren
suffix:semicolon
r_goto
id|kill_rq
suffix:semicolon
)brace
id|block
op_assign
id|rq-&gt;sector
suffix:semicolon
multiline_comment|/* Strange disk manager remap */
r_if
c_cond
(paren
(paren
id|rq-&gt;flags
op_amp
id|REQ_CMD
)paren
op_logical_and
(paren
id|drive-&gt;type
op_eq
id|ATA_DISK
op_logical_or
id|drive-&gt;type
op_eq
id|ATA_FLOPPY
)paren
)paren
(brace
id|block
op_add_assign
id|drive-&gt;sect0
suffix:semicolon
)brace
multiline_comment|/* Yecch - this will shift the entire interval,&n;&t;   possibly killing some innocent following sector */
r_if
c_cond
(paren
id|block
op_eq
l_int|0
op_logical_and
id|drive-&gt;remap_0_to_1
op_eq
l_int|1
)paren
id|block
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* redirect MBR access to EZ-Drive partn table */
macro_line|#if (DISK_RECOVERY_TIME &gt; 0)
r_while
c_loop
(paren
(paren
id|read_timer
c_func
(paren
)paren
op_minus
id|hwif-&gt;last_time
)paren
OL
id|DISK_RECOVERY_TIME
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDE_DMA
comma
op_amp
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|flags
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;start_request: auch, DMA in progress 1&bslash;n&quot;
)paren
suffix:semicolon
id|SELECT_DRIVE
c_func
(paren
id|hwif
comma
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDE_DMA
comma
op_amp
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|flags
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;start_request: auch, DMA in progress 2&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
id|drive-&gt;ready_stat
comma
id|BUSY_STAT
op_or
id|DRQ_STAT
comma
id|WAIT_READY
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: drive not ready for command&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
multiline_comment|/* FIXME: We can see nicely here that all commands should be submitted&n;&t; * through the request queue and that the special field in drive should&n;&t; * go as soon as possible!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;special.all
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
(paren
id|REQ_DRIVE_CMD
op_or
id|REQ_DRIVE_TASK
op_or
id|REQ_DRIVE_TASKFILE
)paren
)paren
(brace
multiline_comment|/* This issues a special drive command, usually&n;&t;&t;&t; * initiated by ioctl() from the external hdparm&n;&t;&t;&t; * program.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
(brace
r_struct
id|ata_request
op_star
id|ar
op_assign
id|rq-&gt;special
suffix:semicolon
r_struct
id|ata_taskfile
op_star
id|args
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ar
)paren
r_goto
id|args_error
suffix:semicolon
id|args
op_assign
op_amp
id|ar-&gt;ar_task
suffix:semicolon
id|ata_taskfile
c_func
(paren
id|drive
comma
id|args
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|args-&gt;command_type
op_eq
id|IDE_DRIVE_TASK_RAW_WRITE
)paren
op_logical_or
(paren
id|args-&gt;command_type
op_eq
id|IDE_DRIVE_TASK_OUT
)paren
)paren
op_logical_and
id|args-&gt;prehandler
op_logical_and
id|args-&gt;handler
)paren
r_return
id|args
op_member_access_from_pointer
id|prehandler
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASK
)paren
(brace
id|byte
op_star
id|args
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|byte
id|sel
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|args
)paren
)paren
r_goto
id|args_error
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: DRIVE_TASK_CMD &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cmd=0x%02x &quot;
comma
id|args
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fr=0x%02x &quot;
comma
id|args
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ns=0x%02x &quot;
comma
id|args
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sc=0x%02x &quot;
comma
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;lcyl=0x%02x &quot;
comma
id|args
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;hcyl=0x%02x &quot;
comma
id|args
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sel=0x%02x&bslash;n&quot;
comma
id|args
(braket
l_int|6
)braket
)paren
suffix:semicolon
macro_line|#endif
id|OUT_BYTE
c_func
(paren
id|args
(braket
l_int|1
)braket
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args
(braket
l_int|3
)braket
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args
(braket
l_int|4
)braket
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args
(braket
l_int|5
)braket
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|sel
op_assign
(paren
id|args
(braket
l_int|6
)braket
op_amp
op_complement
l_int|0x10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
)paren
id|sel
op_or_assign
l_int|0x10
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|sel
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|ide_cmd
c_func
(paren
id|drive
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|2
)braket
comma
op_amp
id|drive_cmd_intr
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_CMD
)paren
(brace
id|byte
op_star
id|args
op_assign
id|rq-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|args
)paren
)paren
r_goto
id|args_error
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: DRIVE_CMD &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cmd=0x%02x &quot;
comma
id|args
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sc=0x%02x &quot;
comma
id|args
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fr=0x%02x &quot;
comma
id|args
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;xx=0x%02x&bslash;n&quot;
comma
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|args
(braket
l_int|0
)braket
op_eq
id|WIN_SMART
)paren
(brace
id|OUT_BYTE
c_func
(paren
l_int|0x4f
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
l_int|0xc2
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args
(braket
l_int|2
)braket
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args
(braket
l_int|1
)braket
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|ide_cmd
c_func
(paren
id|drive
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|3
)braket
comma
op_amp
id|drive_cmd_intr
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
id|OUT_BYTE
c_func
(paren
id|args
(braket
l_int|2
)braket
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|ide_cmd
c_func
(paren
id|drive
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|1
)braket
comma
op_amp
id|drive_cmd_intr
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
id|args_error
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * NULL is actually a valid way of waiting for all&n;&t;&t;&t; * current requests to be flushed from the queue.&n;&t;&t;&t; */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: DRIVE_CMD (null)&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|GET_STAT
c_func
(paren
)paren
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/* The normal way of execution is to pass execute the request&n;&t;&t; * handler.&n;&t;&t; */
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|do_request
)paren
r_return
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|do_request
c_func
(paren
id|drive
comma
id|rq
comma
id|block
)paren
suffix:semicolon
r_else
(brace
id|ide_end_request
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: device type %d not supported&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;type
)paren
suffix:semicolon
r_goto
id|kill_rq
suffix:semicolon
)brace
r_return
id|ata_special
c_func
(paren
id|drive
)paren
suffix:semicolon
id|kill_rq
suffix:colon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
)paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_else
id|ide_end_request
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|restart_request
id|ide_startstop_t
id|restart_request
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|hwgroup-&gt;timer
)paren
suffix:semicolon
id|rq
op_assign
id|hwgroup-&gt;rq
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|start_request
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is used by a drive to give excess bandwidth back to the hwgroup by&n; * sleeping for timeout jiffies.&n; */
DECL|function|ide_stall_queue
r_void
id|ide_stall_queue
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|timeout
)paren
(brace
r_if
c_cond
(paren
id|timeout
OG
id|WAIT_WORSTCASE
)paren
id|timeout
op_assign
id|WAIT_WORSTCASE
suffix:semicolon
id|drive-&gt;PADAM_sleep
op_assign
id|timeout
op_plus
id|jiffies
suffix:semicolon
)brace
multiline_comment|/*&n; * Select the next drive which will be serviced.&n; */
DECL|function|choose_drive
r_static
r_inline
id|ide_drive_t
op_star
id|choose_drive
c_func
(paren
id|ide_hwgroup_t
op_star
id|hwgroup
)paren
(brace
id|ide_drive_t
op_star
id|drive
comma
op_star
id|best
suffix:semicolon
id|best
op_assign
l_int|NULL
suffix:semicolon
id|drive
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|drive-&gt;queue.queue_head
)paren
op_logical_and
(paren
op_logical_neg
id|drive-&gt;PADAM_sleep
op_logical_or
id|time_after_eq
c_func
(paren
id|drive-&gt;PADAM_sleep
comma
id|jiffies
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|best
op_logical_or
(paren
id|drive-&gt;PADAM_sleep
op_logical_and
(paren
op_logical_neg
id|best-&gt;PADAM_sleep
op_logical_or
id|time_after
c_func
(paren
id|best-&gt;PADAM_sleep
comma
id|drive-&gt;PADAM_sleep
)paren
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|best-&gt;PADAM_sleep
op_logical_and
id|time_after
c_func
(paren
id|best-&gt;PADAM_service_start
op_plus
l_int|2
op_star
id|best-&gt;PADAM_service_time
comma
id|drive-&gt;PADAM_service_start
op_plus
l_int|2
op_star
id|drive-&gt;PADAM_service_time
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|blk_queue_plugged
c_func
(paren
op_amp
id|drive-&gt;queue
)paren
)paren
id|best
op_assign
id|drive
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
(paren
id|drive
op_assign
id|drive-&gt;next
)paren
op_ne
id|hwgroup-&gt;drive
)paren
suffix:semicolon
r_return
id|best
suffix:semicolon
)brace
multiline_comment|/*&n; * Issue a new request to a drive from hwgroup&n; * Caller must have already done spin_lock_irqsave(&amp;ide_lock, ...)&n; *&n; * A hwgroup is a serialized group of IDE interfaces.  Usually there is&n; * exactly one hwif (interface) per hwgroup, but buggy controllers (eg. CMD640)&n; * may have both interfaces in a single hwgroup to &quot;serialize&quot; access.&n; * Or possibly multiple ISA interfaces can share a common IRQ by being grouped&n; * together into one hwgroup for serialized access.&n; *&n; * Note also that several hwgroups can end up sharing a single IRQ,&n; * possibly along with many other devices.  This is especially common in&n; * PCI-based systems with off-board IDE controller cards.&n; *&n; * The IDE driver uses the queue spinlock to protect access to the request&n; * queues.&n; *&n; * The first thread into the driver for a particular hwgroup sets the&n; * hwgroup-&gt;flags IDE_BUSY flag to indicate that this hwgroup is now active,&n; * and then initiates processing of the top request from the request queue.&n; *&n; * Other threads attempting entry notice the busy setting, and will simply&n; * queue their new requests and exit immediately.  Note that hwgroup-&gt;flags&n; * remains busy even when the driver is merely awaiting the next interrupt.&n; * Thus, the meaning is &quot;this hwgroup is busy processing a request&quot;.&n; *&n; * When processing of a request completes, the completing thread or IRQ-handler&n; * will start the next request from the queue.  If no more work remains,&n; * the driver will clear the hwgroup-&gt;flags IDE_BUSY flag and exit.&n; */
DECL|function|ide_do_request
r_static
r_void
id|ide_do_request
c_func
(paren
id|ide_hwgroup_t
op_star
id|hwgroup
comma
r_int
id|masked_irq
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_struct
id|ata_channel
op_star
id|hwif
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|ide_get_lock
c_func
(paren
op_amp
id|ide_intr_lock
comma
id|ide_intr
comma
id|hwgroup
)paren
suffix:semicolon
multiline_comment|/* for atari only: POSSIBLY BROKEN HERE(?) */
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* necessary paranoia: ensure IRQs are masked on local CPU */
r_while
c_loop
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|IDE_BUSY
comma
op_amp
id|hwgroup-&gt;flags
)paren
)paren
(brace
id|drive
op_assign
id|choose_drive
c_func
(paren
id|hwgroup
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
l_int|NULL
)paren
(brace
r_int
r_int
id|sleep
op_assign
l_int|0
suffix:semicolon
id|hwgroup-&gt;rq
op_assign
l_int|NULL
suffix:semicolon
id|drive
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|drive-&gt;PADAM_sleep
op_logical_and
(paren
op_logical_neg
id|sleep
op_logical_or
id|time_after
c_func
(paren
id|sleep
comma
id|drive-&gt;PADAM_sleep
)paren
)paren
)paren
id|sleep
op_assign
id|drive-&gt;PADAM_sleep
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|drive
op_assign
id|drive-&gt;next
)paren
op_ne
id|hwgroup-&gt;drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sleep
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Take a short snooze, and then wake up this hwgroup again.&n;&t;&t;&t;&t; * This gives other hwgroups on the same a chance to&n;&t;&t;&t;&t; * play fairly with us, just in case there are big differences&n;&t;&t;&t;&t; * in relative throughputs.. don&squot;t want to hog the cpu too much.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
l_int|0
OL
(paren
r_int
r_int
)paren
(paren
id|jiffies
op_plus
id|WAIT_MIN_SLEEP
op_minus
id|sleep
)paren
)paren
id|sleep
op_assign
id|jiffies
op_plus
id|WAIT_MIN_SLEEP
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|hwgroup-&gt;timer
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;ide_set_handler: timer already active&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|set_bit
c_func
(paren
id|IDE_SLEEP
comma
op_amp
id|hwgroup-&gt;flags
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|hwgroup-&gt;timer
comma
id|sleep
)paren
suffix:semicolon
multiline_comment|/* we purposely leave hwgroup busy while sleeping */
)brace
r_else
(brace
multiline_comment|/* Ugly, but how can we sleep for the lock otherwise? perhaps from tq_disk? */
id|ide_release_lock
c_func
(paren
op_amp
id|ide_intr_lock
)paren
suffix:semicolon
multiline_comment|/* for atari only */
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
op_amp
id|hwgroup-&gt;flags
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
multiline_comment|/* no more work for this hwgroup (for now) */
)brace
id|hwif
op_assign
id|drive-&gt;channel
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;hwif-&gt;sharing_irq
op_logical_and
id|hwif
op_ne
id|hwgroup-&gt;hwif
op_logical_and
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
(brace
multiline_comment|/* set nIEN for previous hwif */
r_if
c_cond
(paren
id|hwif-&gt;intrproc
)paren
id|hwif
op_member_access_from_pointer
id|intrproc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_else
id|OUT_BYTE
c_func
(paren
(paren
id|drive
)paren
op_member_access_from_pointer
id|ctl
op_or
l_int|2
comma
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
suffix:semicolon
)brace
id|hwgroup-&gt;hwif
op_assign
id|hwif
suffix:semicolon
id|hwgroup-&gt;drive
op_assign
id|drive
suffix:semicolon
id|drive-&gt;PADAM_sleep
op_assign
l_int|0
suffix:semicolon
id|queue_next
suffix:colon
id|drive-&gt;PADAM_service_start
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDE_DMA
comma
op_amp
id|hwgroup-&gt;flags
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide_do_request: DMA in progress...&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * there&squot;s a small window between where the queue could be&n;&t;&t; * replugged while we are in here when using tcq (in which&n;&t;&t; * case the queue is probably empty anyways...), so check&n;&t;&t; * and leave if appropriate. When not using tcq, this is&n;&t;&t; * still a severe BUG!&n;&t;&t; */
r_if
c_cond
(paren
id|blk_queue_plugged
c_func
(paren
op_amp
id|drive-&gt;queue
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|drive-&gt;using_tcq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * just continuing an interrupted request maybe&n;&t;&t; */
id|rq
op_assign
id|hwgroup-&gt;rq
op_assign
id|elv_next_request
c_func
(paren
op_amp
id|drive-&gt;queue
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ide_pending_commands
c_func
(paren
id|drive
)paren
)paren
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
op_amp
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Some systems have trouble with IDE IRQs arriving while&n;&t;&t; * the driver is still setting things up.  So, here we disable&n;&t;&t; * the IRQ used by this interface while the request is being started.&n;&t;&t; * This may look bad at first, but pretty much the same thing&n;&t;&t; * happens anyway when any interrupt comes in, IDE or otherwise&n;&t;&t; *  -- the kernel masks the IRQ while it is being handled.&n;&t;&t; */
r_if
c_cond
(paren
id|masked_irq
op_logical_and
id|hwif-&gt;irq
op_ne
id|masked_irq
)paren
id|disable_irq_nosync
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* allow other IRQs while we start this request */
id|startstop
op_assign
id|start_request
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|masked_irq
op_logical_and
id|hwif-&gt;irq
op_ne
id|masked_irq
)paren
id|enable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_released
)paren
r_goto
id|queue_next
suffix:semicolon
r_else
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_stopped
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDE_DMA
comma
op_amp
id|hwgroup-&gt;flags
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;2nd illegal clear&bslash;n&quot;
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
op_amp
id|hwgroup-&gt;flags
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Returns the queue which corresponds to a given device.&n; */
DECL|function|ide_get_queue
id|request_queue_t
op_star
id|ide_get_queue
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|ata_channel
op_star
id|channel
op_assign
(paren
r_struct
id|ata_channel
op_star
)paren
id|blk_dev
(braket
id|major
c_func
(paren
id|dev
)paren
)braket
dot
id|data
suffix:semicolon
multiline_comment|/* FIXME: ALLERT: This discriminates between master and slave! */
r_return
op_amp
id|channel-&gt;drives
(braket
id|DEVICE_NR
c_func
(paren
id|dev
)paren
op_amp
l_int|1
)braket
dot
id|queue
suffix:semicolon
)brace
multiline_comment|/*&n; * Passes the stuff to ide_do_request&n; */
DECL|function|do_ide_request
r_void
id|do_ide_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
id|ide_do_request
c_func
(paren
id|q-&gt;queuedata
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * un-busy the hwgroup etc, and clear any pending DMA status. we want to&n; * retry the current request in PIO mode instead of risking tossing it&n; * all away&n; *&n; * FIXME: needs a bit of tcq work&n; */
DECL|function|ide_dma_timeout_retry
r_void
id|ide_dma_timeout_retry
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
op_assign
id|drive-&gt;channel
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ata_request
op_star
id|ar
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;using_tcq
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;tcq-&gt;active_tag
op_ne
op_minus
l_int|1
)paren
(brace
id|ar
op_assign
id|IDE_CUR_AR
c_func
(paren
id|drive
)paren
suffix:semicolon
id|rq
op_assign
id|ar-&gt;ar_rq
suffix:semicolon
)brace
)brace
r_else
(brace
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|ar
op_assign
id|rq-&gt;special
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * end current dma transaction&n;&t; */
r_if
c_cond
(paren
id|rq
)paren
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_end
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * complain a little, later we might remove some of this verbosity&n;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: timeout waiting for DMA&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;using_tcq
)paren
id|printk
c_func
(paren
l_string|&quot; queued, active tag %d&quot;
comma
id|drive-&gt;tcq-&gt;active_tag
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_timeout
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable dma for now, but remember that we did so because of&n;&t; * a timeout -- we&squot;ll reenable after we finish this next request&n;&t; * (or rather the first chunk of it) in pio.&n;&t; */
id|drive-&gt;retry_pio
op_increment
suffix:semicolon
id|drive-&gt;state
op_assign
id|DMA_PIO_RETRY
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off_quietly
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * un-busy drive etc (hwgroup-&gt;busy is cleared on return) and&n;&t; * make sure request is sane&n;&t; */
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq
)paren
r_return
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;bio
)paren
(brace
id|rq-&gt;sector
op_assign
id|rq-&gt;bio-&gt;bi_sector
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
id|bio_iovec
c_func
(paren
id|rq-&gt;bio
)paren
op_member_access_from_pointer
id|bv_len
op_rshift
l_int|9
suffix:semicolon
id|rq-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  this request was not on the queue any more&n;&t; */
r_if
c_cond
(paren
id|ar-&gt;ar_flags
op_amp
id|ATA_AR_QUEUED
)paren
(brace
id|ata_ar_put
c_func
(paren
id|drive
comma
id|ar
)paren
suffix:semicolon
id|_elv_add_request
c_func
(paren
op_amp
id|drive-&gt;queue
comma
id|rq
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is our timeout function for all drive operations.  But note that it can&n; * also be invoked as a result of a &quot;sleep&quot; operation triggered by the&n; * mod_timer() call in ide_do_request.&n; */
DECL|function|ide_timer_expiry
r_void
id|ide_timer_expiry
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
(paren
id|ide_hwgroup_t
op_star
)paren
id|data
suffix:semicolon
id|ide_handler_t
op_star
id|handler
suffix:semicolon
id|ide_expiry_t
op_star
id|expiry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|wait
suffix:semicolon
multiline_comment|/*&n;&t; * a global lock protects timers etc -- shouldn&squot;t get contention&n;&t; * worth mentioning&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|hwgroup-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|handler
op_assign
id|hwgroup-&gt;handler
)paren
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Either a marginal timeout occurred&n;&t;&t; * (got the interrupt just as timer expired),&n;&t;&t; * or we were &quot;sleeping&quot; to give other devices a chance.&n;&t;&t; * Either way, we don&squot;t really want to complain about anything.&n;&t;&t; */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|IDE_SLEEP
comma
op_amp
id|hwgroup-&gt;flags
)paren
)paren
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
op_amp
id|hwgroup-&gt;flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide_timer_expiry: hwgroup-&gt;drive was NULL&bslash;n&quot;
)paren
suffix:semicolon
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_struct
id|ata_channel
op_star
id|hwif
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
multiline_comment|/* paranoia */
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|IDE_BUSY
comma
op_amp
id|hwgroup-&gt;flags
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ide_timer_expiry: hwgroup was not busy??&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|expiry
op_assign
id|hwgroup-&gt;expiry
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* continue */
r_if
c_cond
(paren
(paren
id|wait
op_assign
id|expiry
c_func
(paren
id|drive
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* reengage timer */
id|hwgroup-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|wait
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|hwgroup-&gt;timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We need to simulate a real interrupt when invoking&n;&t;&t;&t; * the handler() function, which means we need to globally&n;&t;&t;&t; * mask the specific IRQ:&n;&t;&t;&t; */
id|spin_unlock
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|hwif
op_assign
id|drive-&gt;channel
suffix:semicolon
macro_line|#if DISABLE_IRQ_NOSYNC
id|disable_irq_nosync
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
macro_line|#else
id|disable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* disable_irq_nosync ?? */
macro_line|#endif
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only, as if we were handling an interrupt */
r_if
c_cond
(paren
id|hwgroup-&gt;poll_timeout
op_ne
l_int|0
)paren
(brace
id|startstop
op_assign
id|handler
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;waiting_for_dma
)paren
(paren
r_void
)paren
id|hwgroup-&gt;hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_lostirq
comma
id|drive
)paren
suffix:semicolon
(paren
r_void
)paren
id|ide_ack_intr
c_func
(paren
id|hwif
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: lost interrupt&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|startstop
op_assign
id|handler
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;waiting_for_dma
)paren
(brace
id|startstop
op_assign
id|ide_stopped
suffix:semicolon
id|ide_dma_timeout_retry
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
id|startstop
op_assign
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;irq timeout&quot;
comma
id|GET_STAT
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
id|set_recovery_timer
c_func
(paren
id|hwif
)paren
suffix:semicolon
id|drive-&gt;PADAM_service_time
op_assign
id|jiffies
op_minus
id|drive-&gt;PADAM_service_start
suffix:semicolon
id|enable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_stopped
)paren
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
op_amp
id|hwgroup-&gt;flags
)paren
suffix:semicolon
)brace
)brace
id|ide_do_request
c_func
(paren
id|hwgroup
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * There&squot;s nothing really useful we can do with an unexpected interrupt,&n; * other than reading the status register (to clear it), and logging it.&n; * There should be no way that an irq can happen before we&squot;re ready for it,&n; * so we needn&squot;t worry much about losing an &quot;important&quot; interrupt here.&n; *&n; * On laptops (and &quot;green&quot; PCs), an unexpected interrupt occurs whenever the&n; * drive enters &quot;idle&quot;, &quot;standby&quot;, or &quot;sleep&quot; mode, so if the status looks&n; * &quot;good&quot;, we just ignore the interrupt completely.&n; *&n; * This routine assumes __cli() is in effect when called.&n; *&n; * If an unexpected interrupt happens on irq15 while we are handling irq14&n; * and if the two interfaces are &quot;serialized&quot; (CMD640), then it looks like&n; * we could screw up by interfering with a new request being set up for irq15.&n; *&n; * In reality, this is a non-issue.  The new command is not sent unless the&n; * drive is ready to accept one, in which case we know the drive is not&n; * trying to interrupt us.  And ide_set_handler() is always invoked before&n; * completing the issuance of any new drive command, so we will not be&n; * accidentally invoked as a result of any valid command completion interrupt.&n; *&n; */
DECL|function|unexpected_intr
r_static
r_void
id|unexpected_intr
c_func
(paren
r_int
id|irq
comma
id|ide_hwgroup_t
op_star
id|hwgroup
)paren
(brace
id|u8
id|stat
suffix:semicolon
r_struct
id|ata_channel
op_star
id|hwif
op_assign
id|hwgroup-&gt;hwif
suffix:semicolon
multiline_comment|/*&n;&t; * handle the unexpected interrupt&n;&t; */
r_do
(brace
r_if
c_cond
(paren
id|hwif-&gt;irq
op_eq
id|irq
)paren
(brace
id|stat
op_assign
id|IN_BYTE
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
multiline_comment|/* Try to not flood the console with msgs */
r_static
r_int
r_int
id|last_msgtime
comma
id|count
suffix:semicolon
op_increment
id|count
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
(paren
r_int
r_int
)paren
(paren
id|jiffies
op_minus
(paren
id|last_msgtime
op_plus
id|HZ
)paren
)paren
)paren
(brace
id|last_msgtime
op_assign
id|jiffies
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s%s: unexpected interrupt, status=0x%02x, count=%ld&bslash;n&quot;
comma
id|hwif-&gt;name
comma
(paren
id|hwif-&gt;next
op_eq
id|hwgroup-&gt;hwif
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;(?)&quot;
comma
id|stat
comma
id|count
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
(paren
id|hwif
op_assign
id|hwif-&gt;next
)paren
op_ne
id|hwgroup-&gt;hwif
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * entry point for all interrupts, caller does __cli() for us&n; */
DECL|function|ide_intr
r_void
id|ide_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
(paren
id|ide_hwgroup_t
op_star
)paren
id|dev_id
suffix:semicolon
r_struct
id|ata_channel
op_star
id|hwif
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|ide_handler_t
op_star
id|handler
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|hwif
op_assign
id|hwgroup-&gt;hwif
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ide_ack_intr
c_func
(paren
id|hwif
)paren
)paren
r_goto
id|out_lock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|handler
op_assign
id|hwgroup-&gt;handler
)paren
op_eq
l_int|NULL
op_logical_or
id|hwgroup-&gt;poll_timeout
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Not expecting an interrupt from this drive.&n;&t;&t; * That means this could be:&n;&t;&t; *&t;(1) an interrupt from another PCI device&n;&t;&t; *&t;sharing the same PCI INT# as us.&n;&t;&t; * or&t;(2) a drive just entered sleep or standby mode,&n;&t;&t; *&t;and is interrupting to let us know.&n;&t;&t; * or&t;(3) a spurious interrupt of unknown origin.&n;&t;&t; *&n;&t;&t; * For PCI, we cannot tell the difference,&n;&t;&t; * so in that case we just ignore it and hope it goes away.&n;&t;&t; */
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
r_if
c_cond
(paren
id|hwif-&gt;pci_dev
op_logical_and
op_logical_neg
id|hwif-&gt;pci_dev-&gt;vendor
)paren
macro_line|#endif
(brace
multiline_comment|/*&n;&t;&t;&t; * Probably not a shared PCI interrupt,&n;&t;&t;&t; * so we can safely try to do something about it:&n;&t;&t;&t; */
id|unexpected_intr
c_func
(paren
id|irq
comma
id|hwgroup
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Whack the status register, just in case we have a leftover pending IRQ.&n;&t;&t;&t; */
id|IN_BYTE
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
r_goto
id|out_lock
suffix:semicolon
)brace
id|drive
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive
)paren
(brace
multiline_comment|/*&n;&t;&t; * This should NEVER happen, and there isn&squot;t much we could do&n;&t;&t; * about it here.&n;&t;&t; */
r_goto
id|out_lock
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive_is_ready
c_func
(paren
id|drive
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This happens regularly when we share a PCI IRQ with another device.&n;&t;&t; * Unfortunately, it can also happen with some buggy drives that trigger&n;&t;&t; * the IRQ before their status register is up to date.  Hopefully we have&n;&t;&t; * enough advance overhead that the latter isn&squot;t a problem.&n;&t;&t; */
r_goto
id|out_lock
suffix:semicolon
)brace
multiline_comment|/* paranoia */
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|IDE_BUSY
comma
op_amp
id|hwgroup-&gt;flags
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ide_intr: hwgroup was not busy??&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|hwgroup-&gt;timer
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;unmask
)paren
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|startstop
op_assign
id|handler
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* service this interrupt, may set handler for next interrupt */
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note that handler() may have set things up for another&n;&t; * interrupt to occur soon, but it cannot happen until&n;&t; * we exit from this routine, because it will be the&n;&t; * same irq as is currently being serviced here, and Linux&n;&t; * won&squot;t allow another of the same (on any CPU) until we return.&n;&t; */
id|set_recovery_timer
c_func
(paren
id|drive-&gt;channel
)paren
suffix:semicolon
id|drive-&gt;PADAM_service_time
op_assign
id|jiffies
op_minus
id|drive-&gt;PADAM_service_start
suffix:semicolon
r_if
c_cond
(paren
id|startstop
op_eq
id|ide_stopped
)paren
(brace
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* paranoia */
id|clear_bit
c_func
(paren
id|IDE_BUSY
comma
op_amp
id|hwgroup-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|IDE_DMA
comma
op_amp
id|hwgroup-&gt;flags
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;ide_intr: illegal clear&bslash;n&quot;
)paren
suffix:semicolon
id|ide_do_request
c_func
(paren
id|hwgroup
comma
id|hwif-&gt;irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ide_intr: huh? expected NULL handler on exit&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|out_lock
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * get_info_ptr() returns the (ide_drive_t *) for a given device number.&n; * It returns NULL if the given device number does not match any present drives.&n; */
DECL|function|get_info_ptr
id|ide_drive_t
op_star
id|get_info_ptr
c_func
(paren
id|kdev_t
id|i_rdev
)paren
(brace
r_int
r_int
id|major
op_assign
id|major
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
r_int
id|h
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;present
op_logical_and
id|major
op_eq
id|hwif-&gt;major
)paren
(brace
r_int
id|unit
op_assign
id|DEVICE_NR
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
OL
id|MAX_DRIVES
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
)paren
r_return
id|drive
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is intended to be used prior to invoking ide_do_drive_cmd().&n; */
DECL|function|ide_init_drive_cmd
r_void
id|ide_init_drive_cmd
(paren
r_struct
id|request
op_star
id|rq
)paren
(brace
id|memset
c_func
(paren
id|rq
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|rq
)paren
)paren
suffix:semicolon
id|rq-&gt;flags
op_assign
id|REQ_DRIVE_CMD
suffix:semicolon
)brace
multiline_comment|/*&n; * This function issues a special IDE device request onto the request queue.&n; *&n; * If action is ide_wait, then the rq is queued at the end of the request&n; * queue, and the function sleeps until it has been processed.  This is for use&n; * when invoked from an ioctl handler.&n; *&n; * If action is ide_preempt, then the rq is queued at the head of the request&n; * queue, displacing the currently-being-processed request and this function&n; * returns immediately without waiting for the new rq to be completed.  This is&n; * VERY DANGEROUS, and is intended for careful use by the ATAPI tape/cdrom&n; * driver code.&n; *&n; * If action is ide_next, then the rq is queued immediately after the&n; * currently-being-processed-request (if any), and the function returns without&n; * waiting for the new rq to be completed.  As above, This is VERY DANGEROUS,&n; * and is intended for careful use by the ATAPI tape/cdrom driver code.&n; *&n; * If action is ide_end, then the rq is queued at the end of the request queue,&n; * and the function returns immediately without waiting for the new rq to be&n; * completed. This is again intended for careful use by the ATAPI tape/cdrom&n; * driver code.&n; */
DECL|function|ide_do_drive_cmd
r_int
id|ide_do_drive_cmd
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|ide_action_t
id|action
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|major
op_assign
id|drive-&gt;channel-&gt;major
suffix:semicolon
id|request_queue_t
op_star
id|q
op_assign
op_amp
id|drive-&gt;queue
suffix:semicolon
r_struct
id|list_head
op_star
id|queue_head
op_assign
op_amp
id|q-&gt;queue_head
suffix:semicolon
id|DECLARE_COMPLETION
c_func
(paren
id|wait
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;chipset
op_eq
id|ide_pdc4030
op_logical_and
id|rq-&gt;buffer
op_ne
l_int|NULL
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* special drive cmds not supported */
macro_line|#endif
id|rq-&gt;flags
op_or_assign
id|REQ_STARTED
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;rq_status
op_assign
id|RQ_ACTIVE
suffix:semicolon
id|rq-&gt;rq_dev
op_assign
id|mk_kdev
c_func
(paren
id|major
comma
(paren
id|drive-&gt;select.b.unit
)paren
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|ide_wait
)paren
id|rq-&gt;waiting
op_assign
op_amp
id|wait
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_queue_empty
c_func
(paren
op_amp
id|drive-&gt;queue
)paren
op_logical_or
id|action
op_eq
id|ide_preempt
)paren
(brace
r_if
c_cond
(paren
id|action
op_eq
id|ide_preempt
)paren
id|hwgroup-&gt;rq
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|action
op_eq
id|ide_wait
op_logical_or
id|action
op_eq
id|ide_end
)paren
id|queue_head
op_assign
id|queue_head-&gt;prev
suffix:semicolon
r_else
id|queue_head
op_assign
id|queue_head-&gt;next
suffix:semicolon
)brace
id|q-&gt;elevator
dot
id|elevator_add_req_fn
c_func
(paren
id|q
comma
id|rq
comma
id|queue_head
)paren
suffix:semicolon
id|ide_do_request
c_func
(paren
id|hwgroup
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|ide_wait
)paren
(brace
id|wait_for_completion
c_func
(paren
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* wait for it to be serviced */
r_return
id|rq-&gt;errors
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* return -EIO if errors */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called to flush all partitions and partition tables&n; * for a changed disk, and then re-read the new partition table.&n; * If we are revalidating a disk because of a media change, then we&n; * enter with usage == 0.  If we are using an ioctl, we automatically have&n; * usage == 1 (we need an open channel to use an ioctl :-), so this&n; * is our limit.&n; */
DECL|function|ide_revalidate_disk
r_int
id|ide_revalidate_disk
(paren
id|kdev_t
id|i_rdev
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|i_rdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;busy
op_logical_or
(paren
id|drive-&gt;usage
OG
l_int|1
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|drive-&gt;busy
op_assign
l_int|1
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|res
op_assign
id|wipe_partitions
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|revalidate
)paren
(brace
id|ata_get
c_func
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
multiline_comment|/* this is a no-op for tapes and SCSI based access */
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|revalidate
c_func
(paren
id|drive
)paren
suffix:semicolon
id|ata_put
c_func
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
id|grok_partitions
c_func
(paren
id|i_rdev
comma
id|ata_capacity
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
id|drive-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|drive-&gt;wqueue
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * Look again for all drives in the system on all interfaces.  This is used&n; * after a new driver category has been loaded as module.&n; */
DECL|function|revalidate_drives
r_void
id|revalidate_drives
c_func
(paren
r_void
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
id|h
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
r_int
id|unit
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|drive
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
dot
id|drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;revalidate
)paren
(brace
id|drive-&gt;revalidate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initializing
)paren
id|ide_revalidate_disk
c_func
(paren
id|mk_kdev
c_func
(paren
id|hwif-&gt;major
comma
id|unit
op_lshift
id|PARTN_BITS
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|ide_probe_module
r_static
r_void
id|ide_probe_module
c_func
(paren
r_void
)paren
(brace
id|ideprobe_init
c_func
(paren
)paren
suffix:semicolon
id|revalidate_drives
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|ide_driver_module
r_static
r_void
id|ide_driver_module
(paren
r_void
)paren
(brace
r_int
id|index
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
r_if
c_cond
(paren
id|ide_hwifs
(braket
id|index
)braket
dot
id|present
)paren
r_goto
id|search
suffix:semicolon
id|ide_probe_module
c_func
(paren
)paren
suffix:semicolon
id|search
suffix:colon
id|revalidate_drives
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|ide_open
r_static
r_int
id|ide_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;driver
op_eq
l_int|NULL
)paren
id|ide_driver_module
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Request a particular device type module.&n;&t; *&n;&t; * FIXME: The function which should rather requests the drivers in&n;&t; * ide_driver_module(), since it seems illogical and even a bit&n;&t; * dangerous to delay this until open time!&n;&t; */
macro_line|#ifdef CONFIG_KMOD
r_if
c_cond
(paren
id|drive-&gt;driver
op_eq
l_int|NULL
)paren
(brace
r_char
op_star
id|module
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|drive-&gt;type
)paren
(brace
r_case
id|ATA_DISK
suffix:colon
id|module
op_assign
l_string|&quot;ide-disk&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_ROM
suffix:colon
id|module
op_assign
l_string|&quot;ide-cd&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_TAPE
suffix:colon
id|module
op_assign
l_string|&quot;ide-tape&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_FLOPPY
suffix:colon
id|module
op_assign
l_string|&quot;ide-floppy&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_SCSI
suffix:colon
id|module
op_assign
l_string|&quot;ide-scsi&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* nothing we can do about it */
suffix:semicolon
)brace
r_if
c_cond
(paren
id|module
)paren
id|request_module
c_func
(paren
id|module
)paren
suffix:semicolon
)brace
macro_line|#endif
r_while
c_loop
(paren
id|drive-&gt;busy
)paren
id|sleep_on
c_func
(paren
op_amp
id|drive-&gt;wqueue
)paren
suffix:semicolon
op_increment
id|drive-&gt;usage
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|open
)paren
r_return
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|open
c_func
(paren
id|inode
comma
id|filp
comma
id|drive
)paren
suffix:semicolon
r_else
(brace
op_decrement
id|drive-&gt;usage
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: driver not present&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|drive-&gt;usage
op_decrement
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n; * Releasing a block device means we sync() it, so that it can safely&n; * be forgotten about...&n; */
DECL|function|ide_release
r_static
r_int
id|ide_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|drive-&gt;usage
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|release
)paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|release
c_func
(paren
id|inode
comma
id|file
comma
id|drive
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|variable|generic_subdriver_entries
id|ide_proc_entry_t
id|generic_subdriver_entries
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;capacity&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
id|proc_ide_read_capacity
comma
l_int|NULL
)brace
comma
(brace
l_int|NULL
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Note that we only release the standard ports, and do not even try to handle&n; * any extra ports allocated for weird IDE interface chipsets.&n; */
DECL|function|hwif_unregister
r_static
r_void
id|hwif_unregister
c_func
(paren
r_struct
id|ata_channel
op_star
id|hwif
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;straight8
)paren
(brace
id|ide_release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
id|ide_release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_ERROR_OFFSET
)braket
)paren
id|ide_release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_ERROR_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_NSECTOR_OFFSET
)braket
)paren
id|ide_release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_NSECTOR_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_SECTOR_OFFSET
)braket
)paren
id|ide_release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_SECTOR_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_LCYL_OFFSET
)braket
)paren
id|ide_release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_LCYL_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_HCYL_OFFSET
)braket
)paren
id|ide_release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_HCYL_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_SELECT_OFFSET
)braket
)paren
id|ide_release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_SELECT_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
)paren
id|ide_release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
id|ide_release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_AMIGA) || defined(CONFIG_MAC)
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_IRQ_OFFSET
)braket
)paren
id|ide_release_region
c_func
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_IRQ_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|ide_unregister
r_void
id|ide_unregister
c_func
(paren
r_struct
id|ata_channel
op_star
id|channel
)paren
(brace
r_struct
id|gendisk
op_star
id|gd
suffix:semicolon
id|ide_drive_t
op_star
id|drive
comma
op_star
id|d
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
suffix:semicolon
r_int
id|unit
comma
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|p
comma
id|minor
suffix:semicolon
r_struct
id|ata_channel
id|old_hwif
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|channel-&gt;present
)paren
r_goto
m_abort
suffix:semicolon
id|put_device
c_func
(paren
op_amp
id|channel-&gt;dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|drive
op_assign
op_amp
id|channel-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;busy
op_logical_or
id|drive-&gt;usage
)paren
r_goto
m_abort
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
)paren
(brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
c_func
(paren
id|drive
)paren
)paren
r_goto
m_abort
suffix:semicolon
)brace
r_else
id|ide_unregister_subdriver
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
id|channel-&gt;present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * All clear?  Then blow away the buffer cache&n;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|drive
op_assign
op_amp
id|channel-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
id|minor
op_assign
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
(paren
l_int|1
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
op_increment
id|p
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;part
(braket
id|p
)braket
dot
id|nr_sects
OG
l_int|0
)paren
(brace
id|kdev_t
id|devp
op_assign
id|mk_kdev
c_func
(paren
id|channel-&gt;major
comma
id|minor
op_plus
id|p
)paren
suffix:semicolon
id|invalidate_device
c_func
(paren
id|devp
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef CONFIG_PROC_FS
id|destroy_proc_ide_drives
c_func
(paren
id|channel
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|hwgroup
op_assign
id|channel-&gt;hwgroup
suffix:semicolon
multiline_comment|/*&n;&t; * free the irq if we were the only hwif using it&n;&t; */
(brace
r_struct
id|ata_channel
op_star
id|g
suffix:semicolon
r_int
id|irq_count
op_assign
l_int|0
suffix:semicolon
id|g
op_assign
id|hwgroup-&gt;hwif
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|g-&gt;irq
op_eq
id|channel-&gt;irq
)paren
op_increment
id|irq_count
suffix:semicolon
id|g
op_assign
id|g-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|g
op_ne
id|hwgroup-&gt;hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_count
op_eq
l_int|1
)paren
id|free_irq
c_func
(paren
id|channel-&gt;irq
comma
id|hwgroup
)paren
suffix:semicolon
)brace
id|hwif_unregister
c_func
(paren
id|channel
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove us from the hwgroup, and free&n;&t; * the hwgroup if we were the only member&n;&t; */
id|d
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|i
)paren
(brace
id|drive
op_assign
op_amp
id|channel-&gt;drives
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;de
)paren
(brace
id|devfs_unregister
(paren
id|drive-&gt;de
)paren
suffix:semicolon
id|drive-&gt;de
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|hwgroup-&gt;drive-&gt;next
op_ne
id|drive
)paren
id|hwgroup-&gt;drive
op_assign
id|hwgroup-&gt;drive-&gt;next
suffix:semicolon
id|hwgroup-&gt;drive-&gt;next
op_assign
id|drive-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;drive
op_eq
id|drive
)paren
id|hwgroup-&gt;drive
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|drive-&gt;id
)paren
suffix:semicolon
id|drive-&gt;id
op_assign
l_int|NULL
suffix:semicolon
)brace
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
op_amp
id|drive-&gt;queue
)paren
suffix:semicolon
id|ide_teardown_commandlist
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;present
)paren
id|hwgroup-&gt;drive
op_assign
id|d
suffix:semicolon
r_while
c_loop
(paren
id|hwgroup-&gt;hwif-&gt;next
op_ne
id|channel
)paren
id|hwgroup-&gt;hwif
op_assign
id|hwgroup-&gt;hwif-&gt;next
suffix:semicolon
id|hwgroup-&gt;hwif-&gt;next
op_assign
id|channel-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;hwif
op_eq
id|channel
)paren
id|kfree
c_func
(paren
id|hwgroup
)paren
suffix:semicolon
r_else
id|hwgroup-&gt;hwif
op_assign
id|hwgroup-&gt;drive-&gt;channel
suffix:semicolon
macro_line|#if defined(CONFIG_BLK_DEV_IDEDMA) &amp;&amp; !defined(CONFIG_DMA_NONPCI)
id|ide_release_dma
c_func
(paren
id|channel
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Remove us from the kernel&squot;s knowledge.&n;&t; */
id|unregister_blkdev
c_func
(paren
id|channel-&gt;major
comma
id|channel-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|blksize_size
(braket
id|channel-&gt;major
)braket
)paren
suffix:semicolon
id|blk_dev
(braket
id|channel-&gt;major
)braket
dot
id|data
op_assign
l_int|NULL
suffix:semicolon
id|blk_dev
(braket
id|channel-&gt;major
)braket
dot
id|queue
op_assign
l_int|NULL
suffix:semicolon
id|blk_clear
c_func
(paren
id|channel-&gt;major
)paren
suffix:semicolon
id|gd
op_assign
id|channel-&gt;gd
suffix:semicolon
r_if
c_cond
(paren
id|gd
)paren
(brace
id|del_gendisk
c_func
(paren
id|gd
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|gd-&gt;sizes
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|gd-&gt;part
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gd-&gt;de_arr
)paren
id|kfree
(paren
id|gd-&gt;de_arr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gd-&gt;flags
)paren
id|kfree
(paren
id|gd-&gt;flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|gd
)paren
suffix:semicolon
id|channel-&gt;gd
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reinitialize the channel handler, but preserve any special methods for&n;&t; * it.&n;&t; */
id|old_hwif
op_assign
op_star
id|channel
suffix:semicolon
id|init_hwif_data
c_func
(paren
id|channel
comma
id|channel-&gt;index
)paren
suffix:semicolon
id|channel-&gt;hwgroup
op_assign
id|old_hwif.hwgroup
suffix:semicolon
id|channel-&gt;tuneproc
op_assign
id|old_hwif.tuneproc
suffix:semicolon
id|channel-&gt;speedproc
op_assign
id|old_hwif.speedproc
suffix:semicolon
id|channel-&gt;selectproc
op_assign
id|old_hwif.selectproc
suffix:semicolon
id|channel-&gt;resetproc
op_assign
id|old_hwif.resetproc
suffix:semicolon
id|channel-&gt;intrproc
op_assign
id|old_hwif.intrproc
suffix:semicolon
id|channel-&gt;maskproc
op_assign
id|old_hwif.maskproc
suffix:semicolon
id|channel-&gt;quirkproc
op_assign
id|old_hwif.quirkproc
suffix:semicolon
id|channel-&gt;rwproc
op_assign
id|old_hwif.rwproc
suffix:semicolon
id|channel-&gt;ideproc
op_assign
id|old_hwif.ideproc
suffix:semicolon
id|channel-&gt;dmaproc
op_assign
id|old_hwif.dmaproc
suffix:semicolon
id|channel-&gt;busproc
op_assign
id|old_hwif.busproc
suffix:semicolon
id|channel-&gt;bus_state
op_assign
id|old_hwif.bus_state
suffix:semicolon
id|channel-&gt;dma_base
op_assign
id|old_hwif.dma_base
suffix:semicolon
id|channel-&gt;dma_extra
op_assign
id|old_hwif.dma_extra
suffix:semicolon
id|channel-&gt;config_data
op_assign
id|old_hwif.config_data
suffix:semicolon
id|channel-&gt;select_data
op_assign
id|old_hwif.select_data
suffix:semicolon
id|channel-&gt;proc
op_assign
id|old_hwif.proc
suffix:semicolon
macro_line|#ifndef CONFIG_BLK_DEV_IDECS
id|channel-&gt;irq
op_assign
id|old_hwif.irq
suffix:semicolon
macro_line|#endif
id|channel-&gt;major
op_assign
id|old_hwif.major
suffix:semicolon
id|channel-&gt;chipset
op_assign
id|old_hwif.chipset
suffix:semicolon
id|channel-&gt;autodma
op_assign
id|old_hwif.autodma
suffix:semicolon
id|channel-&gt;udma_four
op_assign
id|old_hwif.udma_four
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
id|channel-&gt;pci_dev
op_assign
id|old_hwif.pci_dev
suffix:semicolon
macro_line|#endif
id|channel-&gt;straight8
op_assign
id|old_hwif.straight8
suffix:semicolon
m_abort
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup hw_regs_t structure described by parameters.  You&n; * may set up the hw structure yourself OR use this routine to&n; * do it for you.&n; */
DECL|function|ide_setup_ports
r_void
id|ide_setup_ports
(paren
id|hw_regs_t
op_star
id|hw
comma
id|ide_ioreg_t
id|base
comma
r_int
op_star
id|offsets
comma
id|ide_ioreg_t
id|ctrl
comma
id|ide_ioreg_t
id|intr
comma
id|ide_ack_intr_t
op_star
id|ack_intr
comma
r_int
id|irq
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IDE_NR_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|offsets
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
(brace
r_switch
c_cond
(paren
id|i
)paren
(brace
r_case
id|IDE_CONTROL_OFFSET
suffix:colon
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|ctrl
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if defined(CONFIG_AMIGA) || defined(CONFIG_MAC)
r_case
id|IDE_IRQ_OFFSET
suffix:colon
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|intr
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|base
op_plus
id|offsets
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|hw-&gt;irq
op_assign
id|irq
suffix:semicolon
id|hw-&gt;dma
op_assign
id|NO_DMA
suffix:semicolon
id|hw-&gt;ack_intr
op_assign
id|ack_intr
suffix:semicolon
)brace
multiline_comment|/*&n; * Register an IDE interface, specifing exactly the registers etc&n; * Set init=1 iff calling before probes have taken place.&n; */
DECL|function|ide_register_hw
r_int
id|ide_register_hw
c_func
(paren
id|hw_regs_t
op_star
id|hw
comma
r_struct
id|ata_channel
op_star
op_star
id|hwifp
)paren
(brace
r_int
id|h
suffix:semicolon
r_int
id|retry
op_assign
l_int|1
suffix:semicolon
r_struct
id|ata_channel
op_star
id|hwif
suffix:semicolon
r_do
(brace
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;hw.io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
id|hw-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
r_goto
id|found
suffix:semicolon
)brace
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|hwif-&gt;present
op_logical_and
(paren
id|hwif-&gt;unit
op_eq
id|ATA_PRIMARY
)paren
op_logical_and
op_logical_neg
id|initializing
)paren
op_logical_or
(paren
op_logical_neg
id|hwif-&gt;hw.io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_logical_and
id|initializing
)paren
)paren
r_goto
id|found
suffix:semicolon
)brace
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
id|ide_unregister
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|h
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retry
op_decrement
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
id|found
suffix:colon
id|ide_unregister
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;present
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|hwif-&gt;hw
comma
id|hw
comma
r_sizeof
(paren
op_star
id|hw
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hwif-&gt;io_ports
comma
id|hwif-&gt;hw.io_ports
comma
r_sizeof
(paren
id|hwif-&gt;hw.io_ports
)paren
)paren
suffix:semicolon
id|hwif-&gt;irq
op_assign
id|hw-&gt;irq
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|hw-&gt;chipset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initializing
)paren
(brace
id|ide_probe_module
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|create_proc_ide_interfaces
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|ide_driver_module
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwifp
)paren
op_star
id|hwifp
op_assign
id|hwif
suffix:semicolon
r_return
(paren
id|initializing
op_logical_or
id|hwif-&gt;present
)paren
ques
c_cond
id|h
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Compatability function for existing drivers.  If you want&n; * something different, use the function above.&n; */
DECL|function|ide_register
r_int
id|ide_register
c_func
(paren
r_int
id|arg1
comma
r_int
id|arg2
comma
r_int
id|irq
)paren
(brace
id|hw_regs_t
id|hw
suffix:semicolon
id|ide_init_hwif_ports
c_func
(paren
op_amp
id|hw
comma
(paren
id|ide_ioreg_t
)paren
id|arg1
comma
(paren
id|ide_ioreg_t
)paren
id|arg2
comma
l_int|NULL
)paren
suffix:semicolon
id|hw.irq
op_assign
id|irq
suffix:semicolon
r_return
id|ide_register_hw
c_func
(paren
op_amp
id|hw
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|ide_add_setting
r_void
id|ide_add_setting
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|name
comma
r_int
id|rw
comma
r_int
id|read_ioctl
comma
r_int
id|write_ioctl
comma
r_int
id|data_type
comma
r_int
id|min
comma
r_int
id|max
comma
r_int
id|mul_factor
comma
r_int
id|div_factor
comma
r_void
op_star
id|data
comma
id|ide_procset_t
op_star
id|set
)paren
(brace
id|ide_settings_t
op_star
op_star
id|p
op_assign
op_amp
id|drive-&gt;settings
suffix:semicolon
id|ide_settings_t
op_star
id|setting
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|p
)paren
op_logical_and
id|strcmp
c_func
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|name
comma
id|name
)paren
OL
l_int|0
)paren
id|p
op_assign
op_amp
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|setting
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|setting
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
m_abort
suffix:semicolon
id|memset
c_func
(paren
id|setting
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|setting
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|setting-&gt;name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
m_abort
suffix:semicolon
id|strcpy
c_func
(paren
id|setting-&gt;name
comma
id|name
)paren
suffix:semicolon
id|setting-&gt;rw
op_assign
id|rw
suffix:semicolon
id|setting-&gt;read_ioctl
op_assign
id|read_ioctl
suffix:semicolon
id|setting-&gt;write_ioctl
op_assign
id|write_ioctl
suffix:semicolon
id|setting-&gt;data_type
op_assign
id|data_type
suffix:semicolon
id|setting-&gt;min
op_assign
id|min
suffix:semicolon
id|setting-&gt;max
op_assign
id|max
suffix:semicolon
id|setting-&gt;mul_factor
op_assign
id|mul_factor
suffix:semicolon
id|setting-&gt;div_factor
op_assign
id|div_factor
suffix:semicolon
id|setting-&gt;data
op_assign
id|data
suffix:semicolon
id|setting-&gt;set
op_assign
id|set
suffix:semicolon
id|setting-&gt;next
op_assign
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;driver
)paren
id|setting-&gt;auto_remove
op_assign
l_int|1
suffix:semicolon
op_star
id|p
op_assign
id|setting
suffix:semicolon
r_return
suffix:semicolon
m_abort
suffix:colon
r_if
c_cond
(paren
id|setting
)paren
id|kfree
c_func
(paren
id|setting
)paren
suffix:semicolon
)brace
DECL|function|ide_remove_setting
r_void
id|ide_remove_setting
(paren
id|ide_drive_t
op_star
id|drive
comma
r_char
op_star
id|name
)paren
(brace
id|ide_settings_t
op_star
op_star
id|p
op_assign
op_amp
id|drive-&gt;settings
comma
op_star
id|setting
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|p
)paren
op_logical_and
id|strcmp
c_func
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|name
comma
id|name
)paren
)paren
id|p
op_assign
op_amp
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|setting
op_assign
(paren
op_star
id|p
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
(paren
op_star
id|p
)paren
op_assign
id|setting-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|setting-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|setting
)paren
suffix:semicolon
)brace
DECL|function|auto_remove_settings
r_static
r_void
id|auto_remove_settings
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_settings_t
op_star
id|setting
suffix:semicolon
id|repeat
suffix:colon
id|setting
op_assign
id|drive-&gt;settings
suffix:semicolon
r_while
c_loop
(paren
id|setting
)paren
(brace
r_if
c_cond
(paren
id|setting-&gt;auto_remove
)paren
(brace
id|ide_remove_setting
c_func
(paren
id|drive
comma
id|setting-&gt;name
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|setting
op_assign
id|setting-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|ide_read_setting
r_int
id|ide_read_setting
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_settings_t
op_star
id|setting
)paren
(brace
r_int
id|val
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|setting-&gt;rw
op_amp
id|SETTING_READ
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|setting-&gt;data_type
)paren
(brace
r_case
id|TYPE_BYTE
suffix:colon
id|val
op_assign
op_star
(paren
(paren
id|u8
op_star
)paren
id|setting-&gt;data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_SHORT
suffix:colon
id|val
op_assign
op_star
(paren
(paren
id|u16
op_star
)paren
id|setting-&gt;data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_INT
suffix:colon
r_case
id|TYPE_INTA
suffix:colon
id|val
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
id|setting-&gt;data
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|val
suffix:semicolon
)brace
DECL|function|ide_spin_wait_hwgroup
r_int
id|ide_spin_wait_hwgroup
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
(paren
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|IDE_BUSY
comma
op_amp
id|hwgroup-&gt;flags
)paren
)paren
(brace
r_int
r_int
id|lflags
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
id|__save_flags
c_func
(paren
id|lflags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only; needed for jiffies */
r_if
c_cond
(paren
l_int|0
OL
(paren
r_int
r_int
)paren
(paren
id|jiffies
op_minus
id|timeout
)paren
)paren
(brace
id|__restore_flags
c_func
(paren
id|lflags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|printk
c_func
(paren
l_string|&quot;%s: channel busy&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|__restore_flags
c_func
(paren
id|lflags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|spin_lock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME:  This should be changed to enqueue a special request&n; * to the driver to change settings, and then wait on a semaphore for completion.&n; * The current scheme of polling is kludgey, though safe enough.&n; */
DECL|function|ide_write_setting
r_int
id|ide_write_setting
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_settings_t
op_star
id|setting
comma
r_int
id|val
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|setting-&gt;rw
op_amp
id|SETTING_WRITE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|val
template_param
id|setting-&gt;max
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|setting-&gt;set
)paren
r_return
id|setting
op_member_access_from_pointer
id|set
c_func
(paren
id|drive
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_spin_wait_hwgroup
c_func
(paren
id|drive
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_switch
c_cond
(paren
id|setting-&gt;data_type
)paren
(brace
r_case
id|TYPE_BYTE
suffix:colon
op_star
(paren
(paren
id|u8
op_star
)paren
id|setting-&gt;data
)paren
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_SHORT
suffix:colon
op_star
(paren
(paren
id|u16
op_star
)paren
id|setting-&gt;data
)paren
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_INT
suffix:colon
op_star
(paren
(paren
id|u32
op_star
)paren
id|setting-&gt;data
)paren
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_INTA
suffix:colon
id|p
op_assign
(paren
id|u32
op_star
)paren
id|setting-&gt;data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_lshift
id|PARTN_BITS
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
op_star
id|p
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|ide_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_io_32bit
r_static
r_int
id|set_io_32bit
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
id|drive-&gt;io_32bit
op_assign
id|arg
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_DTC2278
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;chipset
op_eq
id|ide_dtc2278
)paren
id|drive-&gt;channel-&gt;drives
(braket
op_logical_neg
id|drive-&gt;select.b.unit
)braket
dot
id|io_32bit
op_assign
id|arg
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_DTC2278 */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_using_dma
r_static
r_int
id|set_using_dma
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;driver
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;id
op_logical_or
op_logical_neg
(paren
id|drive-&gt;id-&gt;capability
op_amp
l_int|1
)paren
op_logical_or
op_logical_neg
id|drive-&gt;channel-&gt;dmaproc
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;channel
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|arg
ques
c_cond
id|ide_dma_on
suffix:colon
id|ide_dma_off
comma
id|drive
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_pio_mode
r_static
r_int
id|set_pio_mode
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|arg
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;channel-&gt;tuneproc
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;special.b.set_tune
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|drive-&gt;tune_req
op_assign
(paren
id|byte
)paren
id|arg
suffix:semicolon
id|drive-&gt;special.b.set_tune
op_assign
l_int|1
suffix:semicolon
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_add_generic_settings
r_void
id|ide_add_generic_settings
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
multiline_comment|/*&t;&t;&t;drive&t;setting name&t;&t;read/write access&t;&t;&t;&t;read ioctl&t;&t;write ioctl&t;&t;data type&t;min&t;max&t;&t;&t;&t;mul_factor&t;div_factor&t;data pointer&t;&t;&t;set function */
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;io_32bit&quot;
comma
id|drive-&gt;no_io_32bit
ques
c_cond
id|SETTING_READ
suffix:colon
id|SETTING_RW
comma
id|HDIO_GET_32BIT
comma
id|HDIO_SET_32BIT
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
op_plus
(paren
id|SUPPORT_VLB_SYNC
op_lshift
l_int|1
)paren
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;io_32bit
comma
id|set_io_32bit
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;keepsettings&quot;
comma
id|SETTING_RW
comma
id|HDIO_GET_KEEPSETTINGS
comma
id|HDIO_SET_KEEPSETTINGS
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;keep_settings
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;pio_mode&quot;
comma
id|SETTING_WRITE
comma
op_minus
l_int|1
comma
id|HDIO_SET_PIO_MODE
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|255
comma
l_int|1
comma
l_int|1
comma
l_int|NULL
comma
id|set_pio_mode
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;slow&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;slow
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;unmaskirq&quot;
comma
id|drive-&gt;no_unmask
ques
c_cond
id|SETTING_READ
suffix:colon
id|SETTING_RW
comma
id|HDIO_GET_UNMASKINTR
comma
id|HDIO_SET_UNMASKINTR
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;unmask
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;using_dma&quot;
comma
id|SETTING_RW
comma
id|HDIO_GET_DMA
comma
id|HDIO_SET_DMA
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;using_dma
comma
id|set_using_dma
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;ide_scsi&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;scsi
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;init_speed&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|69
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;init_speed
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;current_speed&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|69
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;current_speed
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;number&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|3
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;dn
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Delay for *at least* 50ms.  As we don&squot;t know how much time is left&n; * until the next tick occurs, we wait an extra tick to be safe.&n; * This is used only during the probing/polling for drives at boot time.&n; *&n; * However, its usefullness may be needed in other places, thus we export it now.&n; * The future may change this to a millisecond setable delay.&n; */
DECL|function|ide_delay_50ms
r_void
id|ide_delay_50ms
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_BLK_DEV_IDECS
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
macro_line|#else
id|__set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDECS */
)brace
DECL|function|ide_ioctl
r_static
r_int
id|ide_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
op_assign
l_int|0
comma
id|major
comma
id|minor
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_struct
id|request
id|rq
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|ide_settings_t
op_star
id|setting
suffix:semicolon
id|dev
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
id|major
op_assign
id|major
c_func
(paren
id|dev
)paren
suffix:semicolon
id|minor
op_assign
id|minor
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Find setting by ioctl */
id|setting
op_assign
id|drive-&gt;settings
suffix:semicolon
r_while
c_loop
(paren
id|setting
)paren
(brace
r_if
c_cond
(paren
id|setting-&gt;read_ioctl
op_eq
id|cmd
op_logical_or
id|setting-&gt;write_ioctl
op_eq
id|cmd
)paren
r_break
suffix:semicolon
id|setting
op_assign
id|setting-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|setting
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
id|setting-&gt;read_ioctl
)paren
(brace
id|err
op_assign
id|ide_read_setting
c_func
(paren
id|drive
comma
id|setting
)paren
suffix:semicolon
r_return
id|err
op_ge
l_int|0
ques
c_cond
id|put_user
c_func
(paren
id|err
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:colon
id|err
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|ide_write_setting
c_func
(paren
id|drive
comma
id|setting
comma
id|arg
)paren
suffix:semicolon
)brace
)brace
id|ide_init_drive_cmd
(paren
op_amp
id|rq
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
(brace
r_struct
id|hd_geometry
op_star
id|loc
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|bios_cyl
op_assign
id|drive-&gt;bios_cyl
suffix:semicolon
multiline_comment|/* truncate */
r_if
c_cond
(paren
op_logical_neg
id|loc
op_logical_or
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
op_logical_and
id|drive-&gt;type
op_ne
id|ATA_FLOPPY
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|drive-&gt;bios_head
comma
(paren
id|byte
op_star
)paren
op_amp
id|loc-&gt;heads
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|drive-&gt;bios_sect
comma
(paren
id|byte
op_star
)paren
op_amp
id|loc-&gt;sectors
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|bios_cyl
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|loc-&gt;cylinders
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
(paren
r_int
)paren
id|drive-&gt;part
(braket
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)braket
dot
id|start_sect
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|loc-&gt;start
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|HDIO_GETGEO_BIG
suffix:colon
(brace
r_struct
id|hd_big_geometry
op_star
id|loc
op_assign
(paren
r_struct
id|hd_big_geometry
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|loc
op_logical_or
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
op_logical_and
id|drive-&gt;type
op_ne
id|ATA_FLOPPY
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|drive-&gt;bios_head
comma
(paren
id|byte
op_star
)paren
op_amp
id|loc-&gt;heads
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|drive-&gt;bios_sect
comma
(paren
id|byte
op_star
)paren
op_amp
id|loc-&gt;sectors
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|drive-&gt;bios_cyl
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|loc-&gt;cylinders
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
(paren
r_int
)paren
id|drive-&gt;part
(braket
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)braket
dot
id|start_sect
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|loc-&gt;start
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|HDIO_GETGEO_BIG_RAW
suffix:colon
(brace
r_struct
id|hd_big_geometry
op_star
id|loc
op_assign
(paren
r_struct
id|hd_big_geometry
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|loc
op_logical_or
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
op_logical_and
id|drive-&gt;type
op_ne
id|ATA_FLOPPY
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|drive-&gt;head
comma
(paren
id|byte
op_star
)paren
op_amp
id|loc-&gt;heads
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|drive-&gt;sect
comma
(paren
id|byte
op_star
)paren
op_amp
id|loc-&gt;sectors
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|drive-&gt;cyl
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|loc-&gt;cylinders
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
(paren
r_int
)paren
id|drive-&gt;part
(braket
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)braket
dot
id|start_sect
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|loc-&gt;start
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|BLKRRPART
suffix:colon
multiline_comment|/* Re-read partition tables */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
id|ide_revalidate_disk
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_case
id|HDIO_OBSOLETE_IDENTITY
suffix:colon
r_case
id|HDIO_GET_IDENTITY
suffix:colon
r_if
c_cond
(paren
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMSG
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
(paren
r_char
op_star
)paren
id|drive-&gt;id
comma
(paren
id|cmd
op_eq
id|HDIO_GET_IDENTITY
)paren
ques
c_cond
r_sizeof
(paren
op_star
id|drive-&gt;id
)paren
suffix:colon
l_int|142
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_GET_NICE
suffix:colon
r_return
id|put_user
c_func
(paren
id|drive-&gt;dsc_overlap
op_lshift
id|IDE_NICE_DSC_OVERLAP
op_or
id|drive-&gt;atapi_overlap
op_lshift
id|IDE_NICE_ATAPI_OVERLAP
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|HDIO_DRIVE_CMD
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
op_logical_or
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
id|ide_cmd_ioctl
c_func
(paren
id|drive
comma
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_case
id|HDIO_DRIVE_TASK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
op_logical_or
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
id|ide_task_ioctl
c_func
(paren
id|drive
comma
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_case
id|HDIO_SET_NICE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_ne
(paren
id|arg
op_amp
(paren
(paren
l_int|1
op_lshift
id|IDE_NICE_DSC_OVERLAP
)paren
)paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|drive-&gt;dsc_overlap
op_assign
(paren
id|arg
op_rshift
id|IDE_NICE_DSC_OVERLAP
)paren
op_amp
l_int|1
suffix:semicolon
multiline_comment|/* Only CD-ROM&squot;s and tapes support DSC overlap. */
r_if
c_cond
(paren
id|drive-&gt;dsc_overlap
op_logical_and
op_logical_neg
(paren
id|drive-&gt;type
op_eq
id|ATA_ROM
op_logical_or
id|drive-&gt;type
op_eq
id|ATA_TAPE
)paren
)paren
(brace
id|drive-&gt;dsc_overlap
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
r_case
id|BLKGETSIZE64
suffix:colon
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKFLSBUF
suffix:colon
r_case
id|BLKSSZGET
suffix:colon
r_case
id|BLKPG
suffix:colon
r_case
id|BLKELVGET
suffix:colon
r_case
id|BLKELVSET
suffix:colon
r_case
id|BLKBSZGET
suffix:colon
r_case
id|BLKBSZSET
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|inode-&gt;i_bdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * uniform packet command handling&n;&t;&t; */
r_case
id|CDROMEJECT
suffix:colon
r_case
id|CDROMCLOSETRAY
suffix:colon
r_return
id|block_ioctl
c_func
(paren
id|inode-&gt;i_rdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_case
id|HDIO_GET_BUSSTATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|drive-&gt;channel-&gt;bus_state
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_SET_BUSSTATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;busproc
)paren
id|drive-&gt;channel
op_member_access_from_pointer
id|busproc
c_func
(paren
id|drive
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ioctl
)paren
r_return
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|drive
comma
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|ide_teardown_commandlist
r_void
id|ide_teardown_commandlist
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|pci_dev
op_star
id|pdev
op_assign
id|drive-&gt;channel-&gt;pci_dev
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|drive-&gt;free_req
)paren
(brace
r_struct
id|ata_request
op_star
id|ar
op_assign
id|list_ata_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|ar-&gt;ar_queue
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ar-&gt;ar_sg_table
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|pdev
comma
id|PRD_SEGMENTS
op_star
id|PRD_BYTES
comma
id|ar-&gt;ar_dmatable_cpu
comma
id|ar-&gt;ar_dmatable
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ar
)paren
suffix:semicolon
)brace
)brace
DECL|function|ide_build_commandlist
r_int
id|ide_build_commandlist
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|pci_dev
op_star
id|pdev
op_assign
id|drive-&gt;channel-&gt;pci_dev
suffix:semicolon
r_struct
id|ata_request
op_star
id|ar
suffix:semicolon
id|ide_tag_info_t
op_star
id|tcq
suffix:semicolon
r_int
id|i
comma
id|err
suffix:semicolon
id|tcq
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ide_tag_info_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcq
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|drive-&gt;tcq
op_assign
id|tcq
suffix:semicolon
id|memset
c_func
(paren
id|drive-&gt;tcq
comma
l_int|0
comma
r_sizeof
(paren
id|ide_tag_info_t
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|drive-&gt;free_req
)paren
suffix:semicolon
id|drive-&gt;using_tcq
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|drive-&gt;queue_depth
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Having kzmalloc would help reduce code size at quite&n;&t;&t; * many places in kernel. */
id|ar
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ar
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ar
)paren
r_break
suffix:semicolon
id|memset
c_func
(paren
id|ar
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ar
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ar-&gt;ar_queue
)paren
suffix:semicolon
id|ar-&gt;ar_sg_table
op_assign
id|kmalloc
c_func
(paren
id|PRD_SEGMENTS
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ar-&gt;ar_sg_table
)paren
(brace
id|kfree
c_func
(paren
id|ar
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ar-&gt;ar_dmatable_cpu
op_assign
id|pci_alloc_consistent
c_func
(paren
id|pdev
comma
id|PRD_SEGMENTS
op_star
id|PRD_BYTES
comma
op_amp
id|ar-&gt;ar_dmatable
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ar-&gt;ar_dmatable_cpu
)paren
(brace
id|kfree
c_func
(paren
id|ar-&gt;ar_sg_table
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ar
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * pheew, all done, add to list&n;&t;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|ar-&gt;ar_queue
comma
op_amp
id|drive-&gt;free_req
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
)paren
(brace
id|drive-&gt;queue_depth
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
l_int|1
)paren
(brace
id|drive-&gt;using_tcq
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;tcq-&gt;queued
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;tcq-&gt;active_tag
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|drive-&gt;tcq
)paren
suffix:semicolon
id|drive-&gt;tcq
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|drive-&gt;tcq
)paren
suffix:semicolon
id|drive-&gt;tcq
op_assign
l_int|NULL
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|ide_check_media_change
r_static
r_int
id|ide_check_media_change
(paren
id|kdev_t
id|i_rdev
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not changed */
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
(brace
id|ata_get
c_func
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|check_media_change
)paren
id|res
op_assign
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|check_media_change
c_func
(paren
id|drive
)paren
suffix:semicolon
r_else
id|res
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* assume it was changed */
id|ata_put
c_func
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|ide_fixstring
r_void
id|ide_fixstring
(paren
id|byte
op_star
id|s
comma
r_const
r_int
id|bytecount
comma
r_const
r_int
id|byteswap
)paren
(brace
id|byte
op_star
id|p
op_assign
id|s
comma
op_star
id|end
op_assign
op_amp
id|s
(braket
id|bytecount
op_amp
op_complement
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bytecount must be even */
r_if
c_cond
(paren
id|byteswap
)paren
(brace
multiline_comment|/* convert from big-endian to host byte order */
r_for
c_loop
(paren
id|p
op_assign
id|end
suffix:semicolon
id|p
op_ne
id|s
suffix:semicolon
)paren
(brace
r_int
r_int
op_star
id|pp
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|p
op_sub_assign
l_int|2
)paren
suffix:semicolon
op_star
id|pp
op_assign
id|ntohs
c_func
(paren
op_star
id|pp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* strip leading blanks */
r_while
c_loop
(paren
id|s
op_ne
id|end
op_logical_and
op_star
id|s
op_eq
l_char|&squot; &squot;
)paren
op_increment
id|s
suffix:semicolon
multiline_comment|/* compress internal blanks and strip trailing blanks */
r_while
c_loop
(paren
id|s
op_ne
id|end
op_logical_and
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
op_star
id|s
op_increment
op_ne
l_char|&squot; &squot;
op_logical_or
(paren
id|s
op_ne
id|end
op_logical_and
op_star
id|s
op_logical_and
op_star
id|s
op_ne
l_char|&squot; &squot;
)paren
)paren
op_star
id|p
op_increment
op_assign
op_star
(paren
id|s
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* wipe out trailing garbage */
r_while
c_loop
(paren
id|p
op_ne
id|end
)paren
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * FIXME: rewrite the following crap:&n; */
multiline_comment|/*&n; * stridx() returns the offset of c within s,&n; * or -1 if c is &squot;&bslash;0&squot; or not found within s.&n; */
DECL|function|stridx
r_static
r_int
id|__init
id|stridx
(paren
r_const
r_char
op_star
id|s
comma
r_char
id|c
)paren
(brace
r_char
op_star
id|i
op_assign
id|strchr
c_func
(paren
id|s
comma
id|c
)paren
suffix:semicolon
r_return
(paren
id|i
op_logical_and
id|c
)paren
ques
c_cond
id|i
op_minus
id|s
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Parsing for ide_setup():&n; *&n; * 1. the first char of s must be &squot;=&squot;.&n; * 2. if the remainder matches one of the supplied keywords,&n; *     the index (1 based) of the keyword is negated and returned.&n; * 3. if the remainder is a series of no more than max_vals numbers&n; *     separated by commas, the numbers are saved in vals[] and a&n; *     count of how many were saved is returned.  Base10 is assumed,&n; *     and base16 is allowed when prefixed with &quot;0x&quot;.&n; * 4. otherwise, zero is returned.&n; */
DECL|function|match_parm
r_static
r_int
id|__init
id|match_parm
(paren
r_char
op_star
id|s
comma
r_const
r_char
op_star
id|keywords
(braket
)braket
comma
r_int
id|vals
(braket
)braket
comma
r_int
id|max_vals
)paren
(brace
r_static
r_const
r_char
op_star
id|decimal
op_assign
l_string|&quot;0123456789&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|hex
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_increment
op_eq
l_char|&squot;=&squot;
)paren
(brace
multiline_comment|/*&n;&t;&t; * Try matching against the supplied keywords,&n;&t;&t; * and return -(index+1) if we match one&n;&t;&t; */
r_if
c_cond
(paren
id|keywords
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|keywords
op_ne
l_int|NULL
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
op_star
id|keywords
op_increment
)paren
)paren
r_return
op_minus
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Look for a series of no more than &quot;max_vals&quot;&n;&t;&t; * numeric values separated by commas, in base10,&n;&t;&t; * or base16 when prefixed with &quot;0x&quot;.&n;&t;&t; * Return a count of how many were found.&n;&t;&t; */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
(paren
id|i
op_assign
id|stridx
c_func
(paren
id|decimal
comma
op_star
id|s
)paren
)paren
op_ge
l_int|0
suffix:semicolon
)paren
(brace
id|vals
(braket
id|n
)braket
op_assign
id|i
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
op_assign
id|stridx
c_func
(paren
id|decimal
comma
op_star
op_increment
id|s
)paren
)paren
op_ge
l_int|0
)paren
id|vals
(braket
id|n
)braket
op_assign
(paren
id|vals
(braket
id|n
)braket
op_star
l_int|10
)paren
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;x&squot;
op_logical_and
op_logical_neg
id|vals
(braket
id|n
)braket
)paren
(brace
r_while
c_loop
(paren
(paren
id|i
op_assign
id|stridx
c_func
(paren
id|hex
comma
op_star
op_increment
id|s
)paren
)paren
op_ge
l_int|0
)paren
id|vals
(braket
id|n
)braket
op_assign
(paren
id|vals
(braket
id|n
)braket
op_star
l_int|0x10
)paren
op_plus
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|n
op_eq
id|max_vals
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;,&squot;
op_logical_or
op_star
id|s
op_eq
l_char|&squot;;&squot;
)paren
op_increment
id|s
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|s
)paren
r_return
id|n
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* zero = nothing matched */
)brace
multiline_comment|/*&n; * This gets called VERY EARLY during initialization, to handle kernel &quot;command&n; * line&quot; strings beginning with &quot;hdx=&quot; or &quot;ide&quot;.It gets called even before the&n; * actual module gets initialized.&n; *&n; * Here is the complete set currently supported comand line options:&n; *&n; * &quot;hdx=&quot;  is recognized for all &quot;x&quot; from &quot;a&quot; to &quot;h&quot;, such as &quot;hdc&quot;.&n; * &quot;idex=&quot; is recognized for all &quot;x&quot; from &quot;0&quot; to &quot;3&quot;, such as &quot;ide1&quot;.&n; *&n; * &quot;hdx=noprobe&quot;&t;: drive may be present, but do not probe for it&n; * &quot;hdx=none&quot;&t;&t;: drive is NOT present, ignore cmos and do not probe&n; * &quot;hdx=nowerr&quot;&t;&t;: ignore the WRERR_STAT bit on this drive&n; * &quot;hdx=cdrom&quot;&t;&t;: drive is present, and is a cdrom drive&n; * &quot;hdx=cyl,head,sect&quot;&t;: disk drive is present, with specified geometry&n; * &quot;hdx=noremap&quot;&t;: do not remap 0-&gt;1 even though EZD was detected&n; * &quot;hdx=autotune&quot;&t;: driver will attempt to tune interface speed&n; *&t;&t;&t;&t;to the fastest PIO mode supported,&n; *&t;&t;&t;&t;if possible for this drive only.&n; *&t;&t;&t;&t;Not fully supported by all chipset types,&n; *&t;&t;&t;&t;and quite likely to cause trouble with&n; *&t;&t;&t;&t;older/odd IDE drives.&n; *&n; * &quot;hdx=slow&quot;&t;&t;: insert a huge pause after each access to the data&n; *&t;&t;&t;&t;port. Should be used only as a last resort.&n; *&n; * &quot;hdx=swapdata&quot;&t;: when the drive is a disk, byte swap all data&n; * &quot;hdx=bswap&quot;&t;&t;: same as above..........&n; * &quot;hdxlun=xx&quot;          : set the drive last logical unit.&n; * &quot;hdx=flash&quot;&t;&t;: allows for more than one ata_flash disk to be&n; *&t;&t;&t;&t;registered. In most cases, only one device&n; *&t;&t;&t;&t;will be present.&n; * &quot;hdx=scsi&quot;&t;&t;: the return of the ide-scsi flag, this is useful for&n; *&t;&t;&t;&t;allowwing ide-floppy, ide-tape, and ide-cdrom|writers&n; *&t;&t;&t;&t;to use ide-scsi emulation on a device specific option.&n; * &quot;idebus=xx&quot;&t;&t;: inform IDE driver of VESA/PCI bus speed in MHz,&n; *&t;&t;&t;&t;where &quot;xx&quot; is between 20 and 66 inclusive,&n; *&t;&t;&t;&t;used when tuning chipset PIO modes.&n; *&t;&t;&t;&t;For PCI bus, 25 is correct for a P75 system,&n; *&t;&t;&t;&t;30 is correct for P90,P120,P180 systems,&n; *&t;&t;&t;&t;and 33 is used for P100,P133,P166 systems.&n; *&t;&t;&t;&t;If in doubt, use idebus=33 for PCI.&n; *&t;&t;&t;&t;As for VLB, it is safest to not specify it.&n; *&n; * &quot;idex=noprobe&quot;&t;: do not attempt to access/use this interface&n; * &quot;idex=base&quot;&t;&t;: probe for an interface at the address specified,&n; *&t;&t;&t;&t;where &quot;base&quot; is usually 0x1f0 or 0x170&n; *&t;&t;&t;&t;and &quot;ctl&quot; is assumed to be &quot;base&quot;+0x206&n; * &quot;idex=base,ctl&quot;&t;: specify both base and ctl&n; * &quot;idex=base,ctl,irq&quot;&t;: specify base, ctl, and irq number&n; * &quot;idex=autotune&quot;&t;: driver will attempt to tune interface speed&n; *&t;&t;&t;&t;to the fastest PIO mode supported,&n; *&t;&t;&t;&t;for all drives on this interface.&n; *&t;&t;&t;&t;Not fully supported by all chipset types,&n; *&t;&t;&t;&t;and quite likely to cause trouble with&n; *&t;&t;&t;&t;older/odd IDE drives.&n; * &quot;idex=noautotune&quot;&t;: driver will NOT attempt to tune interface speed&n; *&t;&t;&t;&t;This is the default for most chipsets,&n; *&t;&t;&t;&t;except the cmd640.&n; * &quot;idex=serialize&quot;&t;: do not overlap operations on idex and ide(x^1)&n; * &quot;idex=four&quot;&t;&t;: four drives on idex and ide(x^1) share same ports&n; * &quot;idex=reset&quot;&t;&t;: reset interface before first use&n; * &quot;idex=dma&quot;&t;&t;: enable DMA by default on both drives if possible&n; * &quot;idex=ata66&quot;&t;&t;: informs the interface that it has an 80c cable&n; *&t;&t;&t;&t;for chipsets that are ATA-66 capable, but&n; *&t;&t;&t;&t;the ablity to bit test for detection is&n; *&t;&t;&t;&t;currently unknown.&n; * &quot;ide=reverse&quot;&t;: Formerly called to pci sub-system, but now local.&n; *&n; * The following are valid ONLY on ide0, (except dc4030)&n; * and the defaults for the base,ctl ports must not be altered.&n; *&n; * &quot;ide0=dtc2278&quot;&t;: probe/support DTC2278 interface&n; * &quot;ide0=ht6560b&quot;&t;: probe/support HT6560B interface&n; * &quot;ide0=cmd640_vlb&quot;&t;: *REQUIRED* for VLB cards with the CMD640 chip&n; *&t;&t;&t;  (not for PCI -- automatically detected)&n; * &quot;ide0=qd65xx&quot;&t;: probe/support qd65xx interface&n; * &quot;ide0=ali14xx&quot;&t;: probe/support ali14xx chipsets (ALI M1439, M1443, M1445)&n; * &quot;ide0=umc8672&quot;&t;: probe/support umc8672 chipsets&n; * &quot;idex=dc4030&quot;&t;: probe/support Promise DC4030VL interface&n; * &quot;ide=doubler&quot;&t;: probe/support IDE doublers on Amiga&n; */
DECL|function|ide_setup
r_int
id|__init
id|ide_setup
(paren
r_char
op_star
id|s
)paren
(brace
r_int
id|i
comma
id|vals
(braket
l_int|3
)braket
suffix:semicolon
r_struct
id|ata_channel
op_star
id|hwif
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
r_int
id|hw
comma
id|unit
suffix:semicolon
r_const
r_char
id|max_drive
op_assign
l_char|&squot;a&squot;
op_plus
(paren
(paren
id|MAX_HWIFS
op_star
id|MAX_DRIVES
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_const
r_char
id|max_hwif
op_assign
l_char|&squot;0&squot;
op_plus
(paren
id|MAX_HWIFS
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;hd=&quot;
comma
l_int|3
)paren
)paren
multiline_comment|/* hd= is for hd.c driver and not us */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;ide&quot;
comma
l_int|3
)paren
op_logical_and
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;idebus&quot;
comma
l_int|6
)paren
op_logical_and
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;hd&quot;
comma
l_int|2
)paren
)paren
multiline_comment|/* hdx= &amp; hdxlun= */
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ide_setup: %s&quot;
comma
id|s
)paren
suffix:semicolon
id|init_ide_data
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDOUBLER
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ide=doubler&quot;
)paren
)paren
(brace
r_extern
r_int
id|ide_doubler
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; : Enabled support for IDE doublers&bslash;n&quot;
)paren
suffix:semicolon
id|ide_doubler
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ide=nodma&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IDE: Prevented DMA&bslash;n&quot;
)paren
suffix:semicolon
id|noautodma
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ide=reverse&quot;
)paren
)paren
(brace
id|ide_scan_direction
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; : Enabled support for IDE inverse scan order.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Look for drive options:  &quot;hdx=&quot;&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;hd&quot;
comma
l_int|2
)paren
op_logical_and
id|s
(braket
l_int|2
)braket
op_ge
l_char|&squot;a&squot;
op_logical_and
id|s
(braket
l_int|2
)braket
op_le
id|max_drive
)paren
(brace
r_const
r_char
op_star
id|hd_words
(braket
)braket
op_assign
(brace
l_string|&quot;none&quot;
comma
l_string|&quot;noprobe&quot;
comma
l_string|&quot;nowerr&quot;
comma
l_string|&quot;cdrom&quot;
comma
l_string|&quot;serialize&quot;
comma
l_string|&quot;autotune&quot;
comma
l_string|&quot;noautotune&quot;
comma
l_string|&quot;slow&quot;
comma
l_string|&quot;swapdata&quot;
comma
l_string|&quot;bswap&quot;
comma
l_string|&quot;flash&quot;
comma
l_string|&quot;remap&quot;
comma
l_string|&quot;noremap&quot;
comma
l_string|&quot;scsi&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|unit
op_assign
id|s
(braket
l_int|2
)braket
op_minus
l_char|&squot;a&squot;
suffix:semicolon
id|hw
op_assign
id|unit
op_div
id|MAX_DRIVES
suffix:semicolon
id|unit
op_assign
id|unit
op_mod
id|MAX_DRIVES
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|hw
)braket
suffix:semicolon
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|s
op_plus
l_int|4
comma
l_string|&quot;ide-&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|strncpy
c_func
(paren
id|drive-&gt;driver_req
comma
id|s
op_plus
l_int|4
comma
l_int|9
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Look for last lun option:  &quot;hdxlun=&quot;&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
op_amp
id|s
(braket
l_int|3
)braket
comma
l_string|&quot;lun&quot;
comma
l_int|3
)paren
)paren
(brace
r_if
c_cond
(paren
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|6
)braket
comma
l_int|NULL
comma
id|vals
comma
l_int|1
)paren
op_ne
l_int|1
)paren
r_goto
id|bad_option
suffix:semicolon
r_if
c_cond
(paren
id|vals
(braket
l_int|0
)braket
op_ge
l_int|0
op_logical_and
id|vals
(braket
l_int|0
)braket
op_le
l_int|7
)paren
(brace
id|drive-&gt;last_lun
op_assign
id|vals
(braket
l_int|0
)braket
suffix:semicolon
id|drive-&gt;forced_lun
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; -- BAD LAST LUN! Expected value from 0 to 7&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|3
)braket
comma
id|hd_words
comma
id|vals
comma
l_int|3
)paren
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
multiline_comment|/* &quot;none&quot; */
id|drive-&gt;nobios
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* drop into &quot;noprobe&quot; */
r_case
op_minus
l_int|2
suffix:colon
multiline_comment|/* &quot;noprobe&quot; */
id|drive-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|3
suffix:colon
multiline_comment|/* &quot;nowerr&quot; */
id|drive-&gt;bad_wstat
op_assign
id|BAD_R_STAT
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|4
suffix:colon
multiline_comment|/* &quot;cdrom&quot; */
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;type
op_assign
id|ATA_ROM
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|5
suffix:colon
multiline_comment|/* &quot;serialize&quot; */
id|printk
c_func
(paren
l_string|&quot; -- USE &bslash;&quot;ide%d=serialize&bslash;&quot; INSTEAD&quot;
comma
id|hw
)paren
suffix:semicolon
r_goto
id|do_serialize
suffix:semicolon
r_case
op_minus
l_int|6
suffix:colon
multiline_comment|/* &quot;autotune&quot; */
id|drive-&gt;autotune
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|7
suffix:colon
multiline_comment|/* &quot;noautotune&quot; */
id|drive-&gt;autotune
op_assign
l_int|2
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|8
suffix:colon
multiline_comment|/* &quot;slow&quot; */
id|drive-&gt;slow
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|9
suffix:colon
multiline_comment|/* &quot;swapdata&quot; or &quot;bswap&quot; */
r_case
op_minus
l_int|10
suffix:colon
id|drive-&gt;bswap
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|11
suffix:colon
multiline_comment|/* &quot;flash&quot; */
id|drive-&gt;ata_flash
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|12
suffix:colon
multiline_comment|/* &quot;remap&quot; */
id|drive-&gt;remap_0_to_1
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|13
suffix:colon
multiline_comment|/* &quot;noremap&quot; */
id|drive-&gt;remap_0_to_1
op_assign
l_int|2
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|14
suffix:colon
multiline_comment|/* &quot;scsi&quot; */
macro_line|#if defined(CONFIG_BLK_DEV_IDESCSI) &amp;&amp; defined(CONFIG_SCSI)
id|drive-&gt;scsi
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#else
id|drive-&gt;scsi
op_assign
l_int|0
suffix:semicolon
r_goto
id|bad_option
suffix:semicolon
macro_line|#endif
r_case
l_int|3
suffix:colon
multiline_comment|/* cyl,head,sect */
id|drive-&gt;type
op_assign
id|ATA_DISK
suffix:semicolon
id|drive-&gt;cyl
op_assign
id|drive-&gt;bios_cyl
op_assign
id|vals
(braket
l_int|0
)braket
suffix:semicolon
id|drive-&gt;head
op_assign
id|drive-&gt;bios_head
op_assign
id|vals
(braket
l_int|1
)braket
suffix:semicolon
id|drive-&gt;sect
op_assign
id|drive-&gt;bios_sect
op_assign
id|vals
(braket
l_int|2
)braket
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;forced_geom
op_assign
l_int|1
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_default
suffix:colon
r_goto
id|bad_option
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Look for bus speed option:  &quot;idebus=&quot;&n;&t; */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;idebus&quot;
comma
l_int|6
)paren
)paren
(brace
r_if
c_cond
(paren
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|6
)braket
comma
l_int|NULL
comma
id|vals
comma
l_int|1
)paren
op_ne
l_int|1
)paren
r_goto
id|bad_option
suffix:semicolon
r_if
c_cond
(paren
id|vals
(braket
l_int|0
)braket
op_ge
l_int|20
op_logical_and
id|vals
(braket
l_int|0
)braket
op_le
l_int|66
)paren
(brace
id|idebus_parameter
op_assign
id|vals
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; -- BAD BUS SPEED! Expected value from 20 to 66&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Look for interface options:  &quot;idex=&quot;&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;ide&quot;
comma
l_int|3
)paren
op_logical_and
id|s
(braket
l_int|3
)braket
op_ge
l_char|&squot;0&squot;
op_logical_and
id|s
(braket
l_int|3
)braket
op_le
id|max_hwif
)paren
(brace
multiline_comment|/*&n;&t;&t; * Be VERY CAREFUL changing this: note hardcoded indexes below&n;&t;&t; * -8,-9,-10. -11 : are reserved for future idex calls to ease the hardcoding.&n;&t;&t; */
r_const
r_char
op_star
id|ide_words
(braket
)braket
op_assign
(brace
l_string|&quot;noprobe&quot;
comma
l_string|&quot;serialize&quot;
comma
l_string|&quot;autotune&quot;
comma
l_string|&quot;noautotune&quot;
comma
l_string|&quot;reset&quot;
comma
l_string|&quot;dma&quot;
comma
l_string|&quot;ata66&quot;
comma
l_string|&quot;minus8&quot;
comma
l_string|&quot;minus9&quot;
comma
l_string|&quot;minus10&quot;
comma
l_string|&quot;minus11&quot;
comma
l_string|&quot;qd65xx&quot;
comma
l_string|&quot;ht6560b&quot;
comma
l_string|&quot;cmd640_vlb&quot;
comma
l_string|&quot;dtc2278&quot;
comma
l_string|&quot;umc8672&quot;
comma
l_string|&quot;ali14xx&quot;
comma
l_string|&quot;dc4030&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|hw
op_assign
id|s
(braket
l_int|3
)braket
op_minus
l_char|&squot;0&squot;
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|hw
)braket
suffix:semicolon
id|i
op_assign
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|4
)braket
comma
id|ide_words
comma
id|vals
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Cryptic check to ensure chipset not already set for hwif:&n;&t;&t; */
r_if
c_cond
(paren
id|i
OG
l_int|0
op_logical_or
id|i
op_le
op_minus
l_int|11
)paren
(brace
multiline_comment|/* is parameter a chipset name? */
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_ne
id|ide_unknown
)paren
r_goto
id|bad_option
suffix:semicolon
multiline_comment|/* chipset already specified */
r_if
c_cond
(paren
id|i
op_le
op_minus
l_int|11
op_logical_and
id|i
op_ne
op_minus
l_int|18
op_logical_and
id|hw
op_ne
l_int|0
)paren
r_goto
id|bad_hwif
suffix:semicolon
multiline_comment|/* chipset drivers are for &quot;ide0=&quot; only */
r_if
c_cond
(paren
id|i
op_le
op_minus
l_int|11
op_logical_and
id|i
op_ne
op_minus
l_int|18
op_logical_and
id|ide_hwifs
(braket
id|hw
op_plus
l_int|1
)braket
dot
id|chipset
op_ne
id|ide_unknown
)paren
r_goto
id|bad_option
suffix:semicolon
multiline_comment|/* chipset for 2nd port already specified */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|i
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
r_case
op_minus
l_int|18
suffix:colon
multiline_comment|/* &quot;dc4030&quot; */
(brace
r_extern
r_void
id|init_pdc4030
c_func
(paren
r_void
)paren
suffix:semicolon
id|init_pdc4030
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_PDC4030 */
macro_line|#ifdef CONFIG_BLK_DEV_ALI14XX
r_case
op_minus
l_int|17
suffix:colon
multiline_comment|/* &quot;ali14xx&quot; */
(brace
r_extern
r_void
id|init_ali14xx
(paren
r_void
)paren
suffix:semicolon
id|init_ali14xx
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_UMC8672
r_case
op_minus
l_int|16
suffix:colon
multiline_comment|/* &quot;umc8672&quot; */
(brace
r_extern
r_void
id|init_umc8672
(paren
r_void
)paren
suffix:semicolon
id|init_umc8672
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_DTC2278
r_case
op_minus
l_int|15
suffix:colon
multiline_comment|/* &quot;dtc2278&quot; */
(brace
r_extern
r_void
id|init_dtc2278
(paren
r_void
)paren
suffix:semicolon
id|init_dtc2278
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_CMD640
r_case
op_minus
l_int|14
suffix:colon
multiline_comment|/* &quot;cmd640_vlb&quot; */
(brace
r_extern
r_int
id|cmd640_vlb
suffix:semicolon
multiline_comment|/* flag for cmd640.c */
id|cmd640_vlb
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_HT6560B
r_case
op_minus
l_int|13
suffix:colon
multiline_comment|/* &quot;ht6560b&quot; */
(brace
r_extern
r_void
id|init_ht6560b
(paren
r_void
)paren
suffix:semicolon
id|init_ht6560b
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if CONFIG_BLK_DEV_QD65XX
r_case
op_minus
l_int|12
suffix:colon
multiline_comment|/* &quot;qd65xx&quot; */
(brace
r_extern
r_void
id|init_qd65xx
(paren
r_void
)paren
suffix:semicolon
id|init_qd65xx
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
r_case
op_minus
l_int|11
suffix:colon
multiline_comment|/* minus11 */
r_case
op_minus
l_int|10
suffix:colon
multiline_comment|/* minus10 */
r_case
op_minus
l_int|9
suffix:colon
multiline_comment|/* minus9 */
r_case
op_minus
l_int|8
suffix:colon
multiline_comment|/* minus8 */
r_goto
id|bad_option
suffix:semicolon
r_case
op_minus
l_int|7
suffix:colon
multiline_comment|/* ata66 */
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
id|hwif-&gt;udma_four
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#else
id|hwif-&gt;udma_four
op_assign
l_int|0
suffix:semicolon
r_goto
id|bad_hwif
suffix:semicolon
macro_line|#endif
r_case
op_minus
l_int|6
suffix:colon
multiline_comment|/* dma */
id|hwif-&gt;autodma
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|5
suffix:colon
multiline_comment|/* &quot;reset&quot; */
id|hwif-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|4
suffix:colon
multiline_comment|/* &quot;noautotune&quot; */
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|autotune
op_assign
l_int|2
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|autotune
op_assign
l_int|2
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|3
suffix:colon
multiline_comment|/* &quot;autotune&quot; */
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|autotune
op_assign
l_int|1
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|autotune
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|2
suffix:colon
multiline_comment|/* &quot;serialize&quot; */
id|do_serialize
suffix:colon
(brace
r_struct
id|ata_channel
op_star
id|mate
suffix:semicolon
id|mate
op_assign
op_amp
id|ide_hwifs
(braket
id|hw
op_xor
l_int|1
)braket
suffix:semicolon
id|hwif-&gt;serialized
op_assign
l_int|1
suffix:semicolon
id|mate-&gt;serialized
op_assign
l_int|1
suffix:semicolon
)brace
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|1
suffix:colon
multiline_comment|/* &quot;noprobe&quot; */
id|hwif-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* base */
id|vals
(braket
l_int|1
)braket
op_assign
id|vals
(braket
l_int|0
)braket
op_plus
l_int|0x206
suffix:semicolon
multiline_comment|/* default ctl */
r_case
l_int|2
suffix:colon
multiline_comment|/* base,ctl */
id|vals
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default irq = probe for it */
r_case
l_int|3
suffix:colon
multiline_comment|/* base,ctl,irq */
id|hwif-&gt;hw.irq
op_assign
id|vals
(braket
l_int|2
)braket
suffix:semicolon
id|ide_init_hwif_ports
c_func
(paren
op_amp
id|hwif-&gt;hw
comma
(paren
id|ide_ioreg_t
)paren
id|vals
(braket
l_int|0
)braket
comma
(paren
id|ide_ioreg_t
)paren
id|vals
(braket
l_int|1
)braket
comma
op_amp
id|hwif-&gt;irq
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hwif-&gt;io_ports
comma
id|hwif-&gt;hw.io_ports
comma
r_sizeof
(paren
id|hwif-&gt;io_ports
)paren
)paren
suffix:semicolon
id|hwif-&gt;irq
op_assign
id|vals
(braket
l_int|2
)braket
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|ide_generic
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
l_int|0
suffix:colon
r_goto
id|bad_option
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot; -- SUPPORT NOT CONFIGURED IN THIS KERNEL&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|bad_option
suffix:colon
id|printk
c_func
(paren
l_string|&quot; -- BAD OPTION&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|bad_hwif
suffix:colon
id|printk
c_func
(paren
l_string|&quot;-- NOT SUPPORTED ON ide%d&quot;
comma
id|hw
)paren
suffix:semicolon
id|done
suffix:colon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/****************************************************************************/
multiline_comment|/* This is the default end request function as well */
DECL|function|ide_end_request
r_int
id|ide_end_request
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|uptodate
)paren
(brace
r_return
id|__ide_end_request
c_func
(paren
id|drive
comma
id|uptodate
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup IDE devices, which requested a particular driver&n; */
DECL|function|ide_scan_devices
id|ide_drive_t
op_star
id|ide_scan_devices
c_func
(paren
id|byte
id|type
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|ata_operations
op_star
id|driver
comma
r_int
id|n
)paren
(brace
r_int
r_int
id|unit
comma
id|index
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;present
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_char
op_star
id|req
op_assign
id|drive-&gt;driver_req
suffix:semicolon
r_if
c_cond
(paren
op_star
id|req
op_logical_and
op_logical_neg
id|strstr
c_func
(paren
id|name
comma
id|req
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
op_logical_and
id|drive-&gt;type
op_eq
id|type
op_logical_and
id|drive-&gt;driver
op_eq
id|driver
op_logical_and
op_increment
id|i
OG
id|n
)paren
r_return
id|drive
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This is in fact registering a drive not a driver.&n; */
DECL|function|ide_register_subdriver
r_int
id|ide_register_subdriver
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|ata_operations
op_star
id|driver
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* all CPUs */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* all CPUs */
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
op_logical_or
id|drive-&gt;driver
op_ne
l_int|NULL
op_logical_or
id|drive-&gt;busy
op_logical_or
id|drive-&gt;usage
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* all CPUs */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* FIXME: This will be pushed to the drivers! Thus allowing us to&n;&t; * save one parameter here separate this out.&n;&t; */
id|drive-&gt;driver
op_assign
id|driver
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* all CPUs */
multiline_comment|/* FIXME: Check what this magic number is supposed to be about? */
r_if
c_cond
(paren
id|drive-&gt;autotune
op_ne
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;dmaproc
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Force DMAing for the beginning of the check.  Some&n;&t;&t;&t; * chipsets appear to do interesting things, if not&n;&t;&t;&t; * checked and cleared.&n;&t;&t;&t; *&n;&t;&t;&t; *   PARANOIA!!!&n;&t;&t;&t; */
id|drive-&gt;channel
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off_quietly
comma
id|drive
)paren
suffix:semicolon
id|drive-&gt;channel
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_check
comma
id|drive
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE_TCQ_DEFAULT
id|drive-&gt;channel
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_queued_on
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDE_TCQ_DEFAULT */
)brace
multiline_comment|/* Only CD-ROMs and tape drives support DSC overlap. */
id|drive-&gt;dsc_overlap
op_assign
(paren
id|drive-&gt;next
op_ne
id|drive
op_logical_and
(paren
id|drive-&gt;type
op_eq
id|ATA_ROM
op_logical_or
id|drive-&gt;type
op_eq
id|ATA_TAPE
)paren
)paren
suffix:semicolon
)brace
id|drive-&gt;revalidate
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;suspend_reset
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|ide_add_proc_entries
c_func
(paren
id|drive-&gt;proc
comma
id|generic_subdriver_entries
comma
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
id|ide_add_proc_entries
c_func
(paren
id|drive-&gt;proc
comma
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|proc
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is in fact the default cleanup routine.&n; *&n; * FIXME: Check whatever we maybe don&squot;t call it twice!.&n; */
DECL|function|ide_unregister_subdriver
r_int
id|ide_unregister_subdriver
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* all CPUs */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* all CPUs */
macro_line|#if 0
r_if
c_cond
(paren
id|__MOD_IN_USE
c_func
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|owner
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|drive-&gt;usage
op_logical_or
id|drive-&gt;busy
op_logical_or
op_logical_neg
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* all CPUs */
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_BLK_DEV_ISAPNP) &amp;&amp; defined(CONFIG_ISAPNP) &amp;&amp; defined(MODULE)
id|pnpide_init
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
id|ide_remove_proc_entries
c_func
(paren
id|drive-&gt;proc
comma
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|proc
)paren
suffix:semicolon
id|ide_remove_proc_entries
c_func
(paren
id|drive-&gt;proc
comma
id|generic_subdriver_entries
)paren
suffix:semicolon
macro_line|#endif
id|auto_remove_settings
c_func
(paren
id|drive
)paren
suffix:semicolon
id|drive-&gt;driver
op_assign
l_int|NULL
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* all CPUs */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Register an ATA driver for a particular device type.&n; */
DECL|function|register_ata_driver
r_int
id|register_ata_driver
c_func
(paren
r_int
r_int
id|type
comma
r_struct
id|ata_operations
op_star
id|driver
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|register_ata_driver
id|EXPORT_SYMBOL
c_func
(paren
id|register_ata_driver
)paren
suffix:semicolon
multiline_comment|/*&n; * Unregister an ATA driver for a particular device type.&n; */
DECL|function|unregister_ata_driver
r_int
id|unregister_ata_driver
c_func
(paren
r_int
r_int
id|type
comma
r_struct
id|ata_operations
op_star
id|driver
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|unregister_ata_driver
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_ata_driver
)paren
suffix:semicolon
DECL|variable|ide_fops
r_struct
id|block_device_operations
id|ide_fops
(braket
)braket
op_assign
(brace
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|open
suffix:colon
id|ide_open
comma
id|release
suffix:colon
id|ide_release
comma
id|ioctl
suffix:colon
id|ide_ioctl
comma
id|check_media_change
suffix:colon
id|ide_check_media_change
comma
id|revalidate
suffix:colon
id|ide_revalidate_disk
)brace
)brace
suffix:semicolon
DECL|variable|ide_fops
id|EXPORT_SYMBOL
c_func
(paren
id|ide_fops
)paren
suffix:semicolon
DECL|variable|ide_hwifs
id|EXPORT_SYMBOL
c_func
(paren
id|ide_hwifs
)paren
suffix:semicolon
DECL|variable|ide_spin_wait_hwgroup
id|EXPORT_SYMBOL
c_func
(paren
id|ide_spin_wait_hwgroup
)paren
suffix:semicolon
DECL|variable|revalidate_drives
id|EXPORT_SYMBOL
c_func
(paren
id|revalidate_drives
)paren
suffix:semicolon
multiline_comment|/*&n; * Probe module&n; */
DECL|variable|ide_devfs_handle
id|devfs_handle_t
id|ide_devfs_handle
suffix:semicolon
DECL|variable|ide_lock
id|EXPORT_SYMBOL
c_func
(paren
id|ide_lock
)paren
suffix:semicolon
DECL|variable|drive_is_flashcard
id|EXPORT_SYMBOL
c_func
(paren
id|drive_is_flashcard
)paren
suffix:semicolon
DECL|variable|ide_timer_expiry
id|EXPORT_SYMBOL
c_func
(paren
id|ide_timer_expiry
)paren
suffix:semicolon
DECL|variable|ide_intr
id|EXPORT_SYMBOL
c_func
(paren
id|ide_intr
)paren
suffix:semicolon
DECL|variable|ide_get_queue
id|EXPORT_SYMBOL
c_func
(paren
id|ide_get_queue
)paren
suffix:semicolon
DECL|variable|ide_add_generic_settings
id|EXPORT_SYMBOL
c_func
(paren
id|ide_add_generic_settings
)paren
suffix:semicolon
DECL|variable|do_ide_request
id|EXPORT_SYMBOL
c_func
(paren
id|do_ide_request
)paren
suffix:semicolon
multiline_comment|/*&n; * Driver module&n; */
DECL|variable|ide_scan_devices
id|EXPORT_SYMBOL
c_func
(paren
id|ide_scan_devices
)paren
suffix:semicolon
DECL|variable|ide_register_subdriver
id|EXPORT_SYMBOL
c_func
(paren
id|ide_register_subdriver
)paren
suffix:semicolon
DECL|variable|ide_unregister_subdriver
id|EXPORT_SYMBOL
c_func
(paren
id|ide_unregister_subdriver
)paren
suffix:semicolon
DECL|variable|ide_set_handler
id|EXPORT_SYMBOL
c_func
(paren
id|ide_set_handler
)paren
suffix:semicolon
DECL|variable|ide_dump_status
id|EXPORT_SYMBOL
c_func
(paren
id|ide_dump_status
)paren
suffix:semicolon
DECL|variable|ide_error
id|EXPORT_SYMBOL
c_func
(paren
id|ide_error
)paren
suffix:semicolon
DECL|variable|ide_fixstring
id|EXPORT_SYMBOL
c_func
(paren
id|ide_fixstring
)paren
suffix:semicolon
DECL|variable|ide_wait_stat
id|EXPORT_SYMBOL
c_func
(paren
id|ide_wait_stat
)paren
suffix:semicolon
DECL|variable|restart_request
id|EXPORT_SYMBOL
c_func
(paren
id|restart_request
)paren
suffix:semicolon
DECL|variable|ide_init_drive_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ide_init_drive_cmd
)paren
suffix:semicolon
DECL|variable|ide_do_drive_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ide_do_drive_cmd
)paren
suffix:semicolon
DECL|variable|ide_end_drive_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ide_end_drive_cmd
)paren
suffix:semicolon
DECL|variable|__ide_end_request
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_end_request
)paren
suffix:semicolon
DECL|variable|ide_end_request
id|EXPORT_SYMBOL
c_func
(paren
id|ide_end_request
)paren
suffix:semicolon
DECL|variable|ide_revalidate_disk
id|EXPORT_SYMBOL
c_func
(paren
id|ide_revalidate_disk
)paren
suffix:semicolon
DECL|variable|ide_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ide_cmd
)paren
suffix:semicolon
DECL|variable|ide_delay_50ms
id|EXPORT_SYMBOL
c_func
(paren
id|ide_delay_50ms
)paren
suffix:semicolon
DECL|variable|ide_stall_queue
id|EXPORT_SYMBOL
c_func
(paren
id|ide_stall_queue
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|variable|ide_add_proc_entries
id|EXPORT_SYMBOL
c_func
(paren
id|ide_add_proc_entries
)paren
suffix:semicolon
DECL|variable|ide_remove_proc_entries
id|EXPORT_SYMBOL
c_func
(paren
id|ide_remove_proc_entries
)paren
suffix:semicolon
DECL|variable|proc_ide_read_geometry
id|EXPORT_SYMBOL
c_func
(paren
id|proc_ide_read_geometry
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|ide_add_setting
id|EXPORT_SYMBOL
c_func
(paren
id|ide_add_setting
)paren
suffix:semicolon
DECL|variable|ide_remove_setting
id|EXPORT_SYMBOL
c_func
(paren
id|ide_remove_setting
)paren
suffix:semicolon
DECL|variable|ide_register_hw
id|EXPORT_SYMBOL
c_func
(paren
id|ide_register_hw
)paren
suffix:semicolon
DECL|variable|ide_register
id|EXPORT_SYMBOL
c_func
(paren
id|ide_register
)paren
suffix:semicolon
DECL|variable|ide_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|ide_unregister
)paren
suffix:semicolon
DECL|variable|ide_setup_ports
id|EXPORT_SYMBOL
c_func
(paren
id|ide_setup_ports
)paren
suffix:semicolon
DECL|variable|get_info_ptr
id|EXPORT_SYMBOL
c_func
(paren
id|get_info_ptr
)paren
suffix:semicolon
DECL|function|ide_notify_reboot
r_static
r_int
id|ide_notify_reboot
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|x
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
id|i
comma
id|unit
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|SYS_HALT
suffix:colon
r_case
id|SYS_POWER_OFF
suffix:colon
r_case
id|SYS_RESTART
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;flushing ide devices: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HWIFS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;present
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
multiline_comment|/* set the drive to standby */
id|printk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
id|event
op_ne
id|SYS_RESTART
)paren
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|standby
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|standby
c_func
(paren
id|drive
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
)paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|ide_notifier
r_static
r_struct
id|notifier_block
id|ide_notifier
op_assign
(brace
id|ide_notify_reboot
comma
l_int|NULL
comma
l_int|5
)brace
suffix:semicolon
multiline_comment|/*&n; * This is the global initialization entry point.&n; */
DECL|function|ata_module_init
r_static
r_int
id|__init
id|ata_module_init
c_func
(paren
r_void
)paren
(brace
r_int
id|h
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Uniform Multi-Platform E-IDE driver ver.:&quot;
id|VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ide_devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;ide&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Initialize system bus speed.&n;&t; *&n;&t; * This can be changed by a particular chipse initialization module.&n;&t; * Otherwise we assume 33MHz as a safe value for PCI bus based systems.&n;&t; * 50MHz will be assumed for abolitions like VESA, since higher values&n;&t; * result in more conservative timing setups.&n;&t; *&n;&t; * The kernel parameter idebus=XX overrides the default settings.&n;&t; */
id|system_bus_speed
op_assign
l_int|50
suffix:semicolon
r_if
c_cond
(paren
id|idebus_parameter
)paren
id|system_bus_speed
op_assign
id|idebus_parameter
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
r_else
r_if
c_cond
(paren
id|pci_present
c_func
(paren
)paren
)paren
id|system_bus_speed
op_assign
l_int|33
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;ide: system bus speed %dMHz&bslash;n&quot;
comma
id|system_bus_speed
)paren
suffix:semicolon
id|init_ide_data
(paren
)paren
suffix:semicolon
id|initializing
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Detect and initialize &quot;known&quot; IDE host chip types.&n;&t; */
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
id|pci_present
c_func
(paren
)paren
)paren
(brace
macro_line|# ifdef CONFIG_BLK_DEV_IDEPCI
id|ide_scan_pcibus
c_func
(paren
id|ide_scan_direction
)paren
suffix:semicolon
macro_line|# else
macro_line|#  ifdef CONFIG_BLK_DEV_RZ1000
id|ide_probe_for_rz100x
c_func
(paren
)paren
suffix:semicolon
macro_line|#  endif
macro_line|# endif
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_IDE
id|init_e100_ide
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_CMD640
id|ide_probe_for_cmd640x
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
id|ide_probe_for_pdc4030
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDE_PMAC
id|pmac_ide_probe
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDE_ICSIDE
id|icside_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDE_RAPIDE
id|rapide_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_GAYLE
id|gayle_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_FALCON_IDE
id|falconide_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_MAC_IDE
id|macide_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_Q40IDE
id|q40ide_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_BUDDHA
id|buddha_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_BLK_DEV_ISAPNP) &amp;&amp; defined(CONFIG_ISAPNP)
id|pnpide_init
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
macro_line|# if defined(__mc68000__) || defined(CONFIG_APUS)
r_if
c_cond
(paren
id|ide_hwifs
(braket
l_int|0
)braket
dot
id|io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
(brace
id|ide_get_lock
c_func
(paren
op_amp
id|ide_intr_lock
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* for atari only */
id|disable_irq
c_func
(paren
id|ide_hwifs
(braket
l_int|0
)braket
dot
id|irq
)paren
suffix:semicolon
multiline_comment|/* disable_irq_nosync ?? */
singleline_comment|//&t;&t;disable_irq_nosync(ide_hwifs[0].irq);
)brace
macro_line|# endif
id|ideprobe_init
c_func
(paren
)paren
suffix:semicolon
macro_line|# if defined(__mc68000__) || defined(CONFIG_APUS)
r_if
c_cond
(paren
id|ide_hwifs
(braket
l_int|0
)braket
dot
id|io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
(brace
id|enable_irq
c_func
(paren
id|ide_hwifs
(braket
l_int|0
)braket
dot
id|irq
)paren
suffix:semicolon
id|ide_release_lock
c_func
(paren
op_amp
id|ide_intr_lock
)paren
suffix:semicolon
multiline_comment|/* for atari only */
)brace
macro_line|# endif
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
id|proc_ide_create
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Initialize all device type driver modules.&n;&t; */
macro_line|#ifdef CONFIG_BLK_DEV_IDEDISK
id|idedisk_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
id|ide_cdrom_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
id|idetape_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDEFLOPPY
id|idefloppy_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDESCSI
macro_line|# ifdef CONFIG_SCSI
id|idescsi_init
c_func
(paren
)paren
suffix:semicolon
macro_line|# else
macro_line|#warning ATA SCSI emulation selected but no SCSI-subsystem in kernel
macro_line|# endif
macro_line|#endif
id|initializing
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
r_struct
id|ata_channel
op_star
id|channel
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|channel-&gt;present
)paren
id|ide_geninit
c_func
(paren
id|channel
)paren
suffix:semicolon
)brace
id|register_reboot_notifier
c_func
(paren
op_amp
id|ide_notifier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|options
r_static
r_char
op_star
id|options
op_assign
l_int|NULL
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|options
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|function|parse_options
r_static
r_void
id|__init
id|parse_options
(paren
r_char
op_star
id|line
)paren
(brace
r_char
op_star
id|next
op_assign
id|line
suffix:semicolon
r_if
c_cond
(paren
id|line
op_eq
l_int|NULL
op_logical_or
op_logical_neg
op_star
id|line
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
(paren
id|line
op_assign
id|next
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|next
op_assign
id|strchr
c_func
(paren
id|line
comma
l_char|&squot; &squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_star
id|next
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ide_setup
c_func
(paren
id|line
)paren
)paren
id|printk
(paren
l_string|&quot;Unknown option &squot;%s&squot;&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
)brace
)brace
DECL|function|init_ata
r_static
r_int
id|__init
id|init_ata
(paren
r_void
)paren
(brace
id|parse_options
c_func
(paren
id|options
)paren
suffix:semicolon
r_return
id|ata_module_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_ata
r_static
r_void
id|__exit
id|cleanup_ata
(paren
r_void
)paren
(brace
r_int
id|h
suffix:semicolon
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|ide_notifier
)paren
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|ide_unregister
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|h
)braket
)paren
suffix:semicolon
)brace
macro_line|# ifdef CONFIG_PROC_FS
id|proc_ide_destroy
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
id|devfs_unregister
c_func
(paren
id|ide_devfs_handle
)paren
suffix:semicolon
)brace
DECL|variable|init_ata
id|module_init
c_func
(paren
id|init_ata
)paren
suffix:semicolon
DECL|variable|cleanup_ata
id|module_exit
c_func
(paren
id|cleanup_ata
)paren
suffix:semicolon
macro_line|#ifndef MODULE
multiline_comment|/* command line option parser */
id|__setup
c_func
(paren
l_string|&quot;&quot;
comma
id|ide_setup
)paren
suffix:semicolon
macro_line|#endif
eof
