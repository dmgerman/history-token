multiline_comment|/**** vi:set ts=8 sts=8 sw=8:************************************************&n; *&n; *  Copyright (C) 2002&t;     Marcin Dalecki &lt;martin@dalecki.de&gt;&n; *  Copyright (C) 1998-2000  Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *  Copyright (C) 1995-1998  Mark Lord&n; *&n; *  May be copied or modified under the terms of the GNU General Public License&n; */
multiline_comment|/*&n; *  This module provides support for automatic detection and configuration of&n; *  all PCI ATA host chip chanells interfaces present in a system.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;pcihost.h&quot;
multiline_comment|/*&n; * This is the list of registered PCI chipset driver data structures.&n; */
DECL|variable|ata_pci_device_list
r_static
r_struct
id|ata_pci_device
op_star
id|ata_pci_device_list
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * This function supplies the data necessary to detect the particular chipset.&n; *&n; * Please note that we don&squot;t copy data over. We are just linking it in to the&n; * list.&n; */
DECL|function|ata_register_chipset
r_void
id|ata_register_chipset
c_func
(paren
r_struct
id|ata_pci_device
op_star
id|d
)paren
(brace
r_struct
id|ata_pci_device
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d
)paren
r_return
suffix:semicolon
id|d-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ata_pci_device_list
)paren
(brace
id|ata_pci_device_list
op_assign
id|d
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tmp
op_assign
id|ata_pci_device_list
suffix:semicolon
r_while
c_loop
(paren
id|tmp-&gt;next
)paren
(brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
id|tmp-&gt;next
op_assign
id|d
suffix:semicolon
)brace
multiline_comment|/*&n; * This allows off board ide-pci cards the enable a BIOS, verify interrupt&n; * settings of split-mirror pci-config space, place chipset into init-mode,&n; * and/or preserve an interrupt if the card is not native ide support.&n; */
DECL|function|trust_pci_irq
r_static
r_int
r_int
id|__init
id|trust_pci_irq
c_func
(paren
r_struct
id|ata_pci_device
op_star
id|d
comma
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;flags
op_amp
id|ATA_F_IRQ
)paren
r_return
id|dev-&gt;irq
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Match a PCI IDE port against an entry in ide_hwifs[],&n; * based on io_base port if possible.&n; */
DECL|function|lookup_channel
r_static
r_struct
id|ata_channel
id|__init
op_star
id|lookup_channel
c_func
(paren
r_int
r_int
id|io_base
comma
r_int
id|bootable
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|h
suffix:semicolon
r_struct
id|ata_channel
op_star
id|hwif
suffix:semicolon
multiline_comment|/*&n;&t; * Look for a hwif with matching io_base specified using&n;&t; * parameters to ide_setup().&n;&t; */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
id|io_base
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_generic
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* a perfect match */
)brace
)brace
multiline_comment|/*&n;&t; * Look for a hwif with matching io_base default value.&n;&t; * If chipset is &quot;ide_unknown&quot;, then claim that hwif slot.&n;&t; * Otherwise, some other chipset has already claimed it..  :(&n;&t; */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
id|io_base
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* match */
id|printk
c_func
(paren
l_string|&quot;%s: port 0x%04lx already claimed by %s&bslash;n&quot;
comma
id|name
comma
id|io_base
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* already claimed */
)brace
)brace
multiline_comment|/*&n;&t; * Okay, there is no hwif matching our io_base,&n;&t; * so we&squot;ll just claim an unassigned slot.&n;&t; * Give preference to claiming other slots before claiming ide0/ide1,&n;&t; * just in case there&squot;s another interface yet-to-be-scanned&n;&t; * which uses ports 1f0/170 (the ide0/ide1 defaults).&n;&t; *&n;&t; * Unless there is a bootable card that does not use the standard&n;&t; * ports 1f0/170 (the ide0/ide1 defaults). The (bootable) flag.&n;&t; */
r_if
c_cond
(paren
id|bootable
op_eq
id|ON_BOARD
)paren
(brace
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* pick an unused entry */
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|h
op_assign
l_int|2
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
id|ide_hwifs
op_plus
id|h
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* pick an unused entry */
)brace
)brace
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
l_int|2
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
id|ide_hwifs
op_plus
id|h
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* pick an unused entry */
)brace
id|printk
c_func
(paren
l_string|&quot;%s: too many IDE interfaces, no room in table&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|setup_pci_baseregs
r_static
r_int
id|__init
id|setup_pci_baseregs
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|u8
id|reg
suffix:semicolon
id|u8
id|progif
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Place both IDE interfaces into PCI &quot;native&quot; mode:&n;&t; */
r_if
c_cond
(paren
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_CLASS_PROG
comma
op_amp
id|progif
)paren
op_logical_or
(paren
id|progif
op_amp
l_int|5
)paren
op_ne
l_int|5
)paren
(brace
r_if
c_cond
(paren
(paren
id|progif
op_amp
l_int|0xa
)paren
op_ne
l_int|0xa
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: device not capable of full native PCI mode&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: placing both ports into native PCI mode&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev
comma
id|PCI_CLASS_PROG
comma
id|progif
op_or
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_CLASS_PROG
comma
op_amp
id|progif
)paren
op_logical_or
(paren
id|progif
op_amp
l_int|5
)paren
op_ne
l_int|5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: rewrite of PROGIF failed, wanted 0x%04x, got 0x%04x&bslash;n&quot;
comma
id|name
comma
id|progif
op_or
l_int|5
comma
id|progif
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Setup base registers for IDE command/control spaces for each interface:&n;&t; */
r_for
c_loop
(paren
id|reg
op_assign
l_int|0
suffix:semicolon
id|reg
OL
l_int|4
suffix:semicolon
id|reg
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
id|dev-&gt;resource
op_plus
id|reg
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res-&gt;start
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Missing I/O address #%d&bslash;n&quot;
comma
id|name
comma
id|reg
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
multiline_comment|/*&n; * Fetch the DMA Bus-Master-I/O-Base-Address (BMIBA) from PCI space:&n; */
DECL|function|get_dma_base
r_static
r_int
r_int
id|__init
id|get_dma_base
c_func
(paren
r_struct
id|ata_channel
op_star
id|hwif
comma
r_int
id|extra
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|dma_base
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
op_assign
id|hwif-&gt;pci_dev
suffix:semicolon
id|dma_base
op_assign
id|pci_resource_start
c_func
(paren
id|dev
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_base
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* PDC20246, PDC20262, HPT343, &amp; HPT366 */
r_if
c_cond
(paren
id|extra
)paren
(brace
id|request_region
c_func
(paren
id|dma_base
op_plus
l_int|16
comma
id|extra
comma
id|name
)paren
suffix:semicolon
id|hwif-&gt;dma_extra
op_assign
id|extra
suffix:semicolon
)brace
multiline_comment|/* If we are on the second channel, the dma base address will be one&n;&t; * entry away from the primary interface.&n;&t; */
r_if
c_cond
(paren
id|hwif-&gt;unit
op_eq
id|ATA_SECONDARY
)paren
id|dma_base
op_add_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_AL
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_AL_M5219
)paren
op_logical_or
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_AMD
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_AMD_VIPER_7409
)paren
op_logical_or
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_CMD
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_CMD_643
)paren
op_logical_or
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_SERVERWORKS
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_SERVERWORKS_CSB5IDE
)paren
)paren
(brace
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_amp
l_int|0x60
comma
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_amp
l_int|0x80
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: simplex device: DMA forced&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If the device claims &quot;simplex&quot; DMA, this means only one of&n;&t;&t; * the two interfaces can be trusted with DMA at any point in&n;&t;&t; * time.  So we should enable DMA only on one of the two&n;&t;&t; * interfaces.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|present
op_logical_and
op_logical_neg
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|present
)paren
op_logical_or
id|hwif-&gt;unit
op_eq
id|ATA_SECONDARY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: simplex device:  DMA disabled&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|dma_base
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
id|dma_base
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup DMA transfers on a channel.&n; */
DECL|function|setup_channel_dma
r_static
r_void
id|__init
id|setup_channel_dma
c_func
(paren
r_struct
id|ata_channel
op_star
id|ch
comma
r_struct
id|pci_dev
op_star
id|dev
comma
r_struct
id|ata_pci_device
op_star
id|d
comma
r_int
id|port
comma
id|u8
id|class_rev
comma
r_int
id|pciirq
comma
r_int
id|autodma
comma
r_int
r_int
op_star
id|pcicmd
)paren
(brace
r_int
r_int
id|dma_base
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;flags
op_amp
id|ATA_F_NOADMA
)paren
id|autodma
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|autodma
)paren
id|ch-&gt;autodma
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|d-&gt;flags
op_amp
id|ATA_F_DMA
)paren
op_logical_or
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_STORAGE_IDE
op_logical_and
(paren
id|dev
op_member_access_from_pointer
r_class
op_amp
l_int|0x80
)paren
)paren
)paren
)paren
r_return
suffix:semicolon
id|dma_base
op_assign
id|get_dma_base
c_func
(paren
id|ch
comma
(paren
(paren
id|port
op_eq
id|ATA_PRIMARY
)paren
op_logical_and
id|d-&gt;extra
)paren
ques
c_cond
id|d-&gt;extra
suffix:colon
l_int|0
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_base
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s Bus-Master DMA was disabled by BIOS&bslash;n&quot;
comma
id|ch-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|pcicmd
op_amp
id|PCI_COMMAND_MASTER
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set up BM-DMA capability (PnP BIOS should have done this already)&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|d-&gt;vendor
op_eq
id|PCI_VENDOR_ID_CYRIX
op_logical_and
id|d-&gt;device
op_eq
id|PCI_DEVICE_ID_CYRIX_5530_IDE
)paren
)paren
id|ch-&gt;autodma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default DMA off if we had to configure it here */
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_star
id|pcicmd
op_or
id|PCI_COMMAND_MASTER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|pcicmd
)paren
op_logical_or
op_logical_neg
(paren
op_star
id|pcicmd
op_amp
id|PCI_COMMAND_MASTER
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s error updating PCICMD&bslash;n&quot;
comma
id|ch-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dma_base
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|d-&gt;init_dma
)paren
id|d
op_member_access_from_pointer
id|init_dma
c_func
(paren
id|ch
comma
id|dma_base
)paren
suffix:semicolon
r_else
id|ata_init_dma
c_func
(paren
id|ch
comma
id|dma_base
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Setup a particular port on an ATA host controller.&n; *&n; * This gets called once for the master and for the slave interface.&n; */
DECL|function|setup_host_channel
r_static
r_int
id|__init
id|setup_host_channel
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_struct
id|ata_pci_device
op_star
id|d
comma
r_int
id|port
comma
id|u8
id|class_rev
comma
r_int
id|pciirq
comma
r_int
id|autodma
comma
r_int
r_int
op_star
id|pcicmd
)paren
(brace
r_int
r_int
id|base
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|ctl
op_assign
l_int|0
suffix:semicolon
id|ide_pci_enablebit_t
op_star
id|e
op_assign
op_amp
(paren
id|d-&gt;enablebits
(braket
id|port
)braket
)paren
suffix:semicolon
r_struct
id|ata_channel
op_star
id|ch
suffix:semicolon
id|u8
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|port
op_eq
id|ATA_SECONDARY
)paren
(brace
multiline_comment|/* If this is a Promise FakeRaid controller, the 2nd controller&n;&t;&t; * will be marked as disabled while it is actually there and&n;&t;&t; * enabled by the bios for raid purposes.  Skip the normal &quot;is&n;&t;&t; * it enabled&quot; test for those.&n;&t;&t; */
r_if
c_cond
(paren
id|d-&gt;flags
op_amp
id|ATA_F_PHACK
)paren
r_goto
id|controller_ok
suffix:semicolon
)brace
multiline_comment|/* Test whatever the port is enabled.&n;&t; */
r_if
c_cond
(paren
id|e-&gt;reg
)paren
(brace
r_if
c_cond
(paren
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|e-&gt;reg
comma
op_amp
id|tmp
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* error! */
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|e-&gt;mask
)paren
op_ne
id|e-&gt;val
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Nothing to be done for the second port.&n;&t; */
r_if
c_cond
(paren
id|port
op_eq
id|ATA_SECONDARY
)paren
(brace
r_if
c_cond
(paren
(paren
id|d-&gt;flags
op_amp
id|ATA_F_HPTHACK
)paren
op_logical_and
(paren
id|class_rev
OL
l_int|0x03
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|controller_ok
suffix:colon
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_ne
id|PCI_CLASS_STORAGE_IDE
op_logical_or
(paren
id|dev
op_member_access_from_pointer
r_class
op_amp
(paren
id|port
ques
c_cond
l_int|4
suffix:colon
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ctl
op_assign
id|dev-&gt;resource
(braket
(paren
l_int|2
op_star
id|port
)paren
op_plus
l_int|1
)braket
dot
id|start
suffix:semicolon
id|base
op_assign
id|dev-&gt;resource
(braket
l_int|2
op_star
id|port
)braket
dot
id|start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctl
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
)paren
op_logical_or
op_logical_neg
(paren
id|base
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: error: IO reported as MEM by BIOS!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* try it with the default values */
id|ctl
op_assign
l_int|0
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ctl
op_logical_and
op_logical_neg
id|base
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: error: missing MEM base info from BIOS!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* we will still try to get along with the default */
)brace
r_if
c_cond
(paren
id|base
op_logical_and
op_logical_neg
id|ctl
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: error: missing IO base info from BIOS!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* we will still try to get along with the default */
)brace
multiline_comment|/* Fill in the default values: */
r_if
c_cond
(paren
op_logical_neg
id|ctl
)paren
id|ctl
op_assign
id|port
ques
c_cond
l_int|0x374
suffix:colon
l_int|0x3f4
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
id|base
op_assign
id|port
ques
c_cond
l_int|0x170
suffix:colon
l_int|0x1f0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|lookup_channel
c_func
(paren
id|base
comma
id|d-&gt;bootable
comma
id|dev-&gt;name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* no room */
r_if
c_cond
(paren
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_ne
id|base
)paren
(brace
id|ide_init_hwif_ports
c_func
(paren
op_amp
id|ch-&gt;hw
comma
id|base
comma
(paren
id|ctl
op_or
l_int|2
)paren
comma
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ch-&gt;io_ports
comma
id|ch-&gt;hw.io_ports
comma
r_sizeof
(paren
id|ch-&gt;io_ports
)paren
)paren
suffix:semicolon
id|ch-&gt;noprobe
op_assign
op_logical_neg
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
suffix:semicolon
)brace
id|ch-&gt;chipset
op_assign
id|ide_pci
suffix:semicolon
id|ch-&gt;pci_dev
op_assign
id|dev
suffix:semicolon
id|ch-&gt;unit
op_assign
id|port
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch-&gt;irq
)paren
id|ch-&gt;irq
op_assign
id|pciirq
suffix:semicolon
multiline_comment|/* Serialize the interfaces if requested by configuration information.&n;&t; */
r_if
c_cond
(paren
id|d-&gt;flags
op_amp
id|ATA_F_SER
)paren
id|ch-&gt;serialized
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Cross wired IRQ lines on UMC chips and no DMA transfers.*/
r_if
c_cond
(paren
id|d-&gt;flags
op_amp
id|ATA_F_FIXIRQ
)paren
(brace
id|ch-&gt;irq
op_assign
id|port
ques
c_cond
l_int|15
suffix:colon
l_int|14
suffix:semicolon
r_goto
id|no_dma
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;flags
op_amp
id|ATA_F_NODMA
)paren
r_goto
id|no_dma
suffix:semicolon
multiline_comment|/* Check whatever this interface is UDMA4 mode capable. */
r_if
c_cond
(paren
id|ch-&gt;udma_four
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: warning: ATA-66/100 forced bit set!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|d-&gt;ata66_check
)paren
id|ch-&gt;udma_four
op_assign
id|d
op_member_access_from_pointer
id|ata66_check
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
id|setup_channel_dma
c_func
(paren
id|ch
comma
id|dev
comma
id|d
comma
id|port
comma
id|class_rev
comma
id|pciirq
comma
id|autodma
comma
id|pcicmd
)paren
suffix:semicolon
macro_line|#endif
id|no_dma
suffix:colon
multiline_comment|/* Call chipset-specific routine for each enabled channel. */
r_if
c_cond
(paren
id|d-&gt;init_channel
)paren
id|d
op_member_access_from_pointer
id|init_channel
c_func
(paren
id|ch
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Looks at the primary/secondary channels on a PCI IDE device and, if they are&n; * enabled, prepares the IDE driver for use with them.  This generic code works&n; * for most PCI chipsets.&n; *&n; * One thing that is not standardized is the location of the primary/secondary&n; * interface &quot;enable/disable&quot; bits.  For chipsets that we &quot;know&quot; about, this&n; * information is in the struct ata_pci_device struct; for all other chipsets,&n; * we just assume both interfaces are enabled.&n; */
DECL|function|setup_pci_device
r_static
r_void
id|__init
id|setup_pci_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_struct
id|ata_pci_device
op_star
id|d
)paren
(brace
r_int
id|autodma
op_assign
l_int|0
suffix:semicolon
r_int
id|pciirq
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|pcicmd
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|tried_config
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|class_rev
suffix:semicolon
macro_line|#ifdef CONFIG_IDEDMA_AUTO
r_if
c_cond
(paren
op_logical_neg
id|noautodma
)paren
id|autodma
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Could not enable PCI device.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|check_if_enabled
suffix:colon
r_if
c_cond
(paren
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|pcicmd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: error accessing PCI regs&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pcicmd
op_amp
id|PCI_COMMAND_IO
)paren
)paren
(brace
multiline_comment|/* is device disabled? */
multiline_comment|/*&n;&t;&t; * PnP BIOS was *supposed* to have set this device up for us,&n;&t;&t; * but we can do it ourselves, so long as the BIOS has assigned&n;&t;&t; * an IRQ (or possibly the device is using a &quot;legacy header&quot;&n;&t;&t; * for IRQs).  Maybe the user deliberately *disabled* the&n;&t;&t; * device, but we&squot;ll eventually ignore it again if no drives&n;&t;&t; * respond.&n;&t;&t; */
r_if
c_cond
(paren
id|tried_config
op_increment
op_logical_or
id|setup_pci_baseregs
c_func
(paren
id|dev
comma
id|dev-&gt;name
)paren
op_logical_or
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|pcicmd
op_or
id|PCI_COMMAND_IO
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: device disabled (BIOS)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|autodma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default DMA off if we had to configure it here */
r_goto
id|check_if_enabled
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tried_config
)paren
id|printk
c_func
(paren
l_string|&quot;%s: device enabled (Linux)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|class_rev
)paren
suffix:semicolon
id|class_rev
op_and_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;vendor
op_eq
id|PCI_VENDOR_ID_TTI
op_logical_and
id|PCI_DEVICE_ID_TTI_HPT343
)paren
(brace
multiline_comment|/* see comments in hpt34x.c to see why... */
id|d-&gt;bootable
op_assign
(paren
id|pcicmd
op_amp
id|PCI_COMMAND_MEMORY
)paren
ques
c_cond
id|OFF_BOARD
suffix:colon
id|NEVER_BOARD
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: chipset rev.: %d&bslash;n&quot;
comma
id|class_rev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Can we trust the reported IRQ?&n;&t; */
id|pciirq
op_assign
id|dev-&gt;irq
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_STORAGE_RAID
)paren
(brace
multiline_comment|/* By rights we want to ignore these, but the Promise Fastrak&n;&t;&t;   people have some strange ideas about proprietary so we have&n;&t;&t;   to act otherwise on those. The Supertrak however we need&n;&t;&t;   to skip */
r_if
c_cond
(paren
id|d-&gt;vendor
op_eq
id|PCI_VENDOR_ID_PROMISE
op_logical_and
id|d-&gt;device
op_eq
id|PCI_DEVICE_ID_PROMISE_20265
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: Found promise 20265 in RAID mode.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;bus-&gt;self
op_logical_and
id|dev-&gt;bus-&gt;self-&gt;vendor
op_eq
id|PCI_VENDOR_ID_INTEL
op_logical_and
id|dev-&gt;bus-&gt;self-&gt;device
op_eq
id|PCI_DEVICE_ID_INTEL_I960
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: Skipping Promise PDC20265 attached to I2O RAID controller.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Its attached to something else, just a random bridge.&n;&t;&t;   Suspect a fastrak and fall through */
)brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_amp
op_complement
(paren
l_int|0xfa
)paren
)paren
op_ne
(paren
(paren
id|PCI_CLASS_STORAGE_IDE
op_lshift
l_int|8
)paren
op_or
l_int|5
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: non-legacy mode: IRQ probe delayed&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This allows off board ide-pci cards to enable a BIOS,&n;&t;&t; * verify interrupt settings of split-mirror pci-config&n;&t;&t; * space, place chipset into init-mode, and/or preserve&n;&t;&t; * an interrupt if the card is not native ide support.&n;&t;&t; */
r_if
c_cond
(paren
id|d-&gt;init_chipset
)paren
id|pciirq
op_assign
id|d
op_member_access_from_pointer
id|init_chipset
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
id|pciirq
op_assign
id|trust_pci_irq
c_func
(paren
id|d
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tried_config
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: will probe IRQs later&bslash;n&quot;
)paren
suffix:semicolon
id|pciirq
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|pciirq
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: invalid IRQ (%d): will probe later&bslash;n&quot;
comma
id|pciirq
)paren
suffix:semicolon
id|pciirq
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|d-&gt;init_chipset
)paren
id|d
op_member_access_from_pointer
id|init_chipset
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef __sparc__
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: 100%% native mode on irq&bslash;n&quot;
comma
id|__irq_itoa
c_func
(paren
id|pciirq
)paren
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: 100%% native mode on irq %d&bslash;n&quot;
comma
id|pciirq
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * Set up IDE chanells. First the primary, then the secondary.&n;&t; */
id|setup_host_channel
c_func
(paren
id|dev
comma
id|d
comma
id|ATA_PRIMARY
comma
id|class_rev
comma
id|pciirq
comma
id|autodma
comma
op_amp
id|pcicmd
)paren
suffix:semicolon
id|setup_host_channel
c_func
(paren
id|dev
comma
id|d
comma
id|ATA_SECONDARY
comma
id|class_rev
comma
id|pciirq
comma
id|autodma
comma
op_amp
id|pcicmd
)paren
suffix:semicolon
)brace
DECL|function|pdc20270_device_order_fixup
r_static
r_void
id|__init
id|pdc20270_device_order_fixup
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_struct
id|ata_pci_device
op_star
id|d
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev2
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_dev
op_star
id|findev
suffix:semicolon
r_struct
id|ata_pci_device
op_star
id|d2
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;bus-&gt;self
op_logical_and
id|dev-&gt;bus-&gt;self-&gt;vendor
op_eq
id|PCI_VENDOR_ID_DEC
op_logical_and
id|dev-&gt;bus-&gt;self-&gt;device
op_eq
id|PCI_DEVICE_ID_DEC_21150
)paren
(brace
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
op_amp
l_int|2
)paren
(brace
r_return
suffix:semicolon
)brace
id|d-&gt;extra
op_assign
l_int|0
suffix:semicolon
id|pci_for_each_dev
c_func
(paren
id|findev
)paren
(brace
r_if
c_cond
(paren
(paren
id|findev-&gt;vendor
op_eq
id|dev-&gt;vendor
)paren
op_logical_and
(paren
id|findev-&gt;device
op_eq
id|dev-&gt;device
)paren
op_logical_and
(paren
id|PCI_SLOT
c_func
(paren
id|findev-&gt;devfn
)paren
op_amp
l_int|2
)paren
)paren
(brace
id|u8
id|irq
op_assign
l_int|0
suffix:semicolon
id|u8
id|irq2
op_assign
l_int|0
suffix:semicolon
id|dev2
op_assign
id|findev
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev2
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
id|irq2
)paren
(brace
id|dev2-&gt;irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev2
comma
id|PCI_INTERRUPT_LINE
comma
id|irq
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: %s: controller, PCI slot %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;slot_name
)paren
suffix:semicolon
id|setup_pci_device
c_func
(paren
id|dev
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev2
)paren
r_return
suffix:semicolon
id|d2
op_assign
id|d
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: %s: controller, PCI slot %s&bslash;n&quot;
comma
id|dev2-&gt;name
comma
id|dev2-&gt;slot_name
)paren
suffix:semicolon
id|setup_pci_device
c_func
(paren
id|dev2
comma
id|d2
)paren
suffix:semicolon
)brace
DECL|function|hpt374_device_order_fixup
r_static
r_void
id|__init
id|hpt374_device_order_fixup
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_struct
id|ata_pci_device
op_star
id|d
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev2
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_dev
op_star
id|findev
suffix:semicolon
r_struct
id|ata_pci_device
op_star
id|d2
suffix:semicolon
r_if
c_cond
(paren
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
op_amp
l_int|1
)paren
r_return
suffix:semicolon
id|pci_for_each_dev
c_func
(paren
id|findev
)paren
(brace
r_if
c_cond
(paren
(paren
id|findev-&gt;vendor
op_eq
id|dev-&gt;vendor
)paren
op_logical_and
(paren
id|findev-&gt;device
op_eq
id|dev-&gt;device
)paren
op_logical_and
(paren
(paren
id|findev-&gt;devfn
op_minus
id|dev-&gt;devfn
)paren
op_eq
l_int|1
)paren
op_logical_and
(paren
id|PCI_FUNC
c_func
(paren
id|findev-&gt;devfn
)paren
op_amp
l_int|1
)paren
)paren
(brace
id|dev2
op_assign
id|findev
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: %s: controller, PCI slot %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;slot_name
)paren
suffix:semicolon
id|setup_pci_device
c_func
(paren
id|dev
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev2
)paren
(brace
r_return
suffix:semicolon
)brace
r_else
(brace
id|byte
id|irq
op_assign
l_int|0
comma
id|irq2
op_assign
l_int|0
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev2
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
id|irq2
)paren
(brace
id|pci_write_config_byte
c_func
(paren
id|dev2
comma
id|PCI_INTERRUPT_LINE
comma
id|irq
)paren
suffix:semicolon
id|dev2-&gt;irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: pci-config space interrupt fixed.&bslash;n&quot;
comma
id|dev2-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|d2
op_assign
id|d
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: %s: controller, PCI slot %s&bslash;n&quot;
comma
id|dev2-&gt;name
comma
id|dev2-&gt;slot_name
)paren
suffix:semicolon
id|setup_pci_device
c_func
(paren
id|dev2
comma
id|d2
)paren
suffix:semicolon
)brace
DECL|function|hpt366_device_order_fixup
r_static
r_void
id|__init
id|hpt366_device_order_fixup
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_struct
id|ata_pci_device
op_star
id|d
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev2
op_assign
l_int|NULL
comma
op_star
id|findev
suffix:semicolon
r_struct
id|ata_pci_device
op_star
id|d2
suffix:semicolon
r_int
r_char
id|pin1
op_assign
l_int|0
comma
id|pin2
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|class_rev
suffix:semicolon
r_if
c_cond
(paren
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
op_amp
l_int|1
)paren
r_return
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|class_rev
)paren
suffix:semicolon
id|class_rev
op_and_assign
l_int|0xff
suffix:semicolon
r_switch
c_cond
(paren
id|class_rev
)paren
(brace
r_case
l_int|5
suffix:colon
r_case
l_int|4
suffix:colon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: %s: controller, PCI slot %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;slot_name
)paren
suffix:semicolon
id|setup_pci_device
c_func
(paren
id|dev
comma
id|d
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|pin1
)paren
suffix:semicolon
id|pci_for_each_dev
c_func
(paren
id|findev
)paren
(brace
r_if
c_cond
(paren
id|findev-&gt;vendor
op_eq
id|dev-&gt;vendor
op_logical_and
id|findev-&gt;device
op_eq
id|dev-&gt;device
op_logical_and
(paren
(paren
id|findev-&gt;devfn
op_minus
id|dev-&gt;devfn
)paren
op_eq
l_int|1
)paren
op_logical_and
(paren
id|PCI_FUNC
c_func
(paren
id|findev-&gt;devfn
)paren
op_amp
l_int|1
)paren
)paren
(brace
id|dev2
op_assign
id|findev
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev2
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|pin2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pin1
op_ne
id|pin2
)paren
op_logical_and
(paren
id|dev-&gt;irq
op_eq
id|dev2-&gt;irq
)paren
)paren
(brace
id|d-&gt;bootable
op_assign
id|ON_BOARD
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATAL: %s: onboard version of chipset, pin1=%d pin2=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pin1
comma
id|pin2
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: %s: controller, PCI slot %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;slot_name
)paren
suffix:semicolon
id|setup_pci_device
c_func
(paren
id|dev
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev2
)paren
r_return
suffix:semicolon
id|d2
op_assign
id|d
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: %s: controller, PCI slot %s&bslash;n&quot;
comma
id|dev2-&gt;name
comma
id|dev2-&gt;slot_name
)paren
suffix:semicolon
id|setup_pci_device
c_func
(paren
id|dev2
comma
id|d2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This finds all PCI IDE controllers and calls appropriate initialization&n; * functions for them.&n; */
DECL|function|scan_pcidev
r_static
r_void
id|__init
id|scan_pcidev
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_int
r_int
id|vendor
suffix:semicolon
r_int
r_int
id|device
suffix:semicolon
r_struct
id|ata_pci_device
op_star
id|d
suffix:semicolon
id|vendor
op_assign
id|dev-&gt;vendor
suffix:semicolon
id|device
op_assign
id|dev-&gt;device
suffix:semicolon
multiline_comment|/* Look up the chipset information.&n;&t; * We expect only one match.&n;&t; */
r_for
c_loop
(paren
id|d
op_assign
id|ata_pci_device_list
suffix:semicolon
id|d
suffix:semicolon
id|d
op_assign
id|d-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;vendor
op_eq
id|vendor
op_logical_and
id|d-&gt;device
op_eq
id|device
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|d
)paren
(brace
multiline_comment|/* Only check the device calls, if it wasn&squot;t listed, since&n;&t;&t; * there are in esp. some pdc202xx chips which &quot;work around&quot;&n;&t;&t; * beeing grabbed by generic drivers.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_STORAGE_IDE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: unknown interface: %s, PCI slot %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;slot_name
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;init_channel
op_eq
id|ATA_PCI_IGNORE
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: %s: ignored by PCI bus scan&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|d-&gt;vendor
op_eq
id|PCI_VENDOR_ID_OPTI
op_logical_and
id|d-&gt;device
op_eq
id|PCI_DEVICE_ID_OPTI_82C558
)paren
op_logical_and
op_logical_neg
(paren
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
op_amp
l_int|1
)paren
)paren
r_return
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|d-&gt;vendor
op_eq
id|PCI_VENDOR_ID_CONTAQ
op_logical_and
id|d-&gt;device
op_eq
id|PCI_DEVICE_ID_CONTAQ_82C693
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
op_amp
l_int|1
)paren
op_logical_or
op_logical_neg
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_STORAGE_IDE
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* CY82C693 is more than only a IDE controller */
r_else
r_if
c_cond
(paren
(paren
id|d-&gt;vendor
op_eq
id|PCI_VENDOR_ID_ITE
op_logical_and
id|d-&gt;device
op_eq
id|PCI_DEVICE_ID_ITE_IT8172G
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
op_amp
l_int|1
)paren
op_logical_or
op_logical_neg
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_STORAGE_IDE
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* IT8172G is also more than only an IDE controller */
r_else
r_if
c_cond
(paren
(paren
id|d-&gt;vendor
op_eq
id|PCI_VENDOR_ID_UMC
op_logical_and
id|d-&gt;device
op_eq
id|PCI_DEVICE_ID_UMC_UM8886A
)paren
op_logical_and
op_logical_neg
(paren
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
op_amp
l_int|1
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* UM8886A/BF pair */
r_else
r_if
c_cond
(paren
id|d-&gt;flags
op_amp
id|ATA_F_HPTHACK
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;device
op_eq
id|PCI_DEVICE_ID_TTI_HPT366
)paren
id|hpt366_device_order_fixup
c_func
(paren
id|dev
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;device
op_eq
id|PCI_DEVICE_ID_TTI_HPT374
)paren
id|hpt374_device_order_fixup
c_func
(paren
id|dev
comma
id|d
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|d-&gt;vendor
op_eq
id|PCI_VENDOR_ID_PROMISE
op_logical_and
id|d-&gt;device
op_eq
id|PCI_DEVICE_ID_PROMISE_20268R
)paren
id|pdc20270_device_order_fixup
c_func
(paren
id|dev
comma
id|d
)paren
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: %s, PCI slot %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;slot_name
)paren
suffix:semicolon
id|setup_pci_device
c_func
(paren
id|dev
comma
id|d
)paren
suffix:semicolon
)brace
)brace
DECL|function|ide_scan_pcibus
r_void
id|__init
id|ide_scan_pcibus
c_func
(paren
r_int
id|scan_direction
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scan_direction
)paren
(brace
id|pci_for_each_dev
c_func
(paren
id|dev
)paren
(brace
id|scan_pcidev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|pci_for_each_dev_reverse
c_func
(paren
id|dev
)paren
(brace
id|scan_pcidev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* known chips without particular chipset driver module data table */
multiline_comment|/* Those are id&squot;s of chips we don&squot;t deal currently with, but which still need&n; * some generic quirk handling.&n; */
DECL|variable|__initdata
r_static
r_struct
id|ata_pci_device
id|chipsets
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|vendor
suffix:colon
id|PCI_VENDOR_ID_PCTECH
comma
id|device
suffix:colon
id|PCI_DEVICE_ID_PCTECH_SAMURAI_IDE
comma
id|bootable
suffix:colon
id|ON_BOARD
)brace
comma
(brace
id|vendor
suffix:colon
id|PCI_VENDOR_ID_CMD
comma
id|device
suffix:colon
id|PCI_DEVICE_ID_CMD_640
comma
id|init_channel
suffix:colon
id|ATA_PCI_IGNORE
comma
id|bootable
suffix:colon
id|ON_BOARD
)brace
comma
(brace
id|vendor
suffix:colon
id|PCI_VENDOR_ID_NS
comma
id|device
suffix:colon
id|PCI_DEVICE_ID_NS_87410
comma
id|enablebits
suffix:colon
(brace
(brace
l_int|0x43
comma
l_int|0x08
comma
l_int|0x08
)brace
comma
(brace
l_int|0x47
comma
l_int|0x08
comma
l_int|0x08
)brace
)brace
comma
id|bootable
suffix:colon
id|ON_BOARD
)brace
comma
(brace
id|vendor
suffix:colon
id|PCI_VENDOR_ID_HINT
comma
id|device
suffix:colon
id|PCI_DEVICE_ID_HINT_VXPROII_IDE
comma
id|bootable
suffix:colon
id|ON_BOARD
)brace
comma
(brace
id|vendor
suffix:colon
id|PCI_VENDOR_ID_HOLTEK
comma
id|device
suffix:colon
id|PCI_DEVICE_ID_HOLTEK_6565
comma
id|bootable
suffix:colon
id|ON_BOARD
)brace
comma
(brace
id|vendor
suffix:colon
id|PCI_VENDOR_ID_INTEL
comma
id|device
suffix:colon
id|PCI_DEVICE_ID_INTEL_82371MX
comma
id|enablebits
suffix:colon
(brace
(brace
l_int|0x6D
comma
l_int|0x80
comma
l_int|0x80
)brace
comma
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
)brace
comma
id|bootable
suffix:colon
id|ON_BOARD
comma
id|flags
suffix:colon
id|ATA_F_NODMA
)brace
comma
(brace
id|vendor
suffix:colon
id|PCI_VENDOR_ID_UMC
comma
id|device
suffix:colon
id|PCI_DEVICE_ID_UMC_UM8673F
comma
id|bootable
suffix:colon
id|ON_BOARD
comma
id|flags
suffix:colon
id|ATA_F_FIXIRQ
)brace
comma
(brace
id|vendor
suffix:colon
id|PCI_VENDOR_ID_UMC
comma
id|device
suffix:colon
id|PCI_DEVICE_ID_UMC_UM8886A
comma
id|bootable
suffix:colon
id|ON_BOARD
comma
id|flags
suffix:colon
id|ATA_F_FIXIRQ
)brace
comma
(brace
id|vendor
suffix:colon
id|PCI_VENDOR_ID_UMC
comma
id|device
suffix:colon
id|PCI_DEVICE_ID_UMC_UM8886BF
comma
id|bootable
suffix:colon
id|ON_BOARD
comma
id|flags
suffix:colon
id|ATA_F_FIXIRQ
)brace
comma
(brace
id|vendor
suffix:colon
id|PCI_VENDOR_ID_VIA
comma
id|device
suffix:colon
id|PCI_DEVICE_ID_VIA_82C561
comma
id|bootable
suffix:colon
id|ON_BOARD
comma
id|flags
suffix:colon
id|ATA_F_NOADMA
)brace
comma
(brace
id|vendor
suffix:colon
id|PCI_VENDOR_ID_VIA
comma
id|device
suffix:colon
id|PCI_DEVICE_ID_VIA_82C586_1
comma
id|bootable
suffix:colon
id|ON_BOARD
comma
id|flags
suffix:colon
id|ATA_F_NOADMA
)brace
comma
(brace
id|vendor
suffix:colon
id|PCI_VENDOR_ID_TTI
comma
id|device
suffix:colon
id|PCI_DEVICE_ID_TTI_HPT366
comma
id|bootable
suffix:colon
id|OFF_BOARD
comma
id|extra
suffix:colon
l_int|240
comma
id|flags
suffix:colon
id|ATA_F_IRQ
op_or
id|ATA_F_HPTHACK
)brace
)brace
suffix:semicolon
DECL|function|init_ata_pci_misc
r_int
id|__init
id|init_ata_pci_misc
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|chipsets
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ata_register_chipset
c_func
(paren
op_amp
id|chipsets
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
