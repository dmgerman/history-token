multiline_comment|/*&n; *  Copyright (c) 1999-2000  Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *  Copyright (c) 1995-1998  Mark Lord&n; *&n; *  May be copied or modified under the terms of the GNU General Public License&n; *&n; *  Special Thanks to Mark for his Six years of work.&n; */
multiline_comment|/*&n; * This module provides support for the bus-master IDE DMA functions&n; * of various PCI chipsets, including the Intel PIIX (i82371FB for&n; * the 430 FX chipset), the PIIX3 (i82371SB for the 430 HX/VX and&n; * 440 chipsets), and the PIIX4 (i82371AB for the 430 TX chipset)&n; * (&quot;PIIX&quot; stands for &quot;PCI ISA IDE Xcellerator&quot;).&n; *&n; * Pretty much the same code works for other IDE PCI bus-mastering chipsets.&n; *&n; * DMA is supported for all IDE devices (disk drives, cdroms, tapes, floppies).&n; *&n; * By default, DMA support is prepared for use, but is currently enabled only&n; * for drives which already have DMA enabled (UltraDMA or mode 2 multi/single),&n; * or which are recognized as &quot;good&quot; (see table below).  Drives with only mode0&n; * or mode1 (multi/single) DMA should also work with this chipset/driver&n; * (eg. MC2112A) but are not enabled by default.&n; *&n; * Use &quot;hdparm -i&quot; to view modes supported by a given drive.&n; *&n; * The hdparm-3.5 (or later) utility can be used for manually enabling/disabling&n; * DMA support, but must be (re-)compiled against this kernel version or later.&n; *&n; * To enable DMA, use &quot;hdparm -d1 /dev/hd?&quot; on a per-drive basis after booting.&n; * If problems arise, ide.c will disable DMA operation after a few retries.&n; * This error recovery mechanism works and has been extremely well exercised.&n; *&n; * IDE drives, depending on their vintage, may support several different modes&n; * of DMA operation.  The boot-time modes are indicated with a &quot;*&quot; in&n; * the &quot;hdparm -i&quot; listing, and can be changed with *knowledgeable* use of&n; * the &quot;hdparm -X&quot; feature.  There is seldom a need to do this, as drives&n; * normally power-up with their &quot;best&quot; PIO/DMA modes enabled.&n; *&n; * Testing has been done with a rather extensive number of drives,&n; * with Quantum &amp; Western Digital models generally outperforming the pack,&n; * and Fujitsu &amp; Conner (and some Seagate which are really Conner) drives&n; * showing more lackluster throughput.&n; *&n; * Keep an eye on /var/adm/messages for &quot;DMA disabled&quot; messages.&n; *&n; * Some people have reported trouble with Intel Zappa motherboards.&n; * This can be fixed by upgrading the AMI BIOS to version 1.00.04.BS0,&n; * available from ftp://ftp.intel.com/pub/bios/10004bs0.exe&n; * (thanks to Glen Morrell &lt;glen@spin.Stanford.edu&gt; for researching this).&n; *&n; * Thanks to &quot;Christopher J. Reimer&quot; &lt;reimer@doe.carleton.ca&gt; for&n; * fixing the problem with the BIOS on some Acer motherboards.&n; *&n; * Thanks to &quot;Benoit Poulot-Cazajous&quot; &lt;poulot@chorus.fr&gt; for testing&n; * &quot;TX&quot; chipset compatibility and for providing patches for the &quot;TX&quot; chipset.&n; *&n; * Thanks to Christian Brunner &lt;chb@muc.de&gt; for taking a good first crack&n; * at generic DMA -- his patches were referred to when preparing this code.&n; *&n; * Most importantly, thanks to Robert Bringman &lt;rob@mars.trion.com&gt;&n; * for supplying a Promise UDMA board &amp; WD UDMA drive for this work!&n; *&n; * And, yes, Intel Zappa boards really *do* use both PIIX IDE ports.&n; *&n; * check_drive_lists(ide_drive_t *drive, int good_bad)&n; *&n; * ATA-66/100 and recovery functions, I forgot the rest......&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
multiline_comment|/*&n; * Long lost data from 2.0.34 that is now in 2.0.39&n; *&n; * This was used in ./drivers/block/triton.c to do DMA Base address setup&n; * when PnP failed.  Oh the things we forget.  I believe this was part&n; * of SFF-8038i that has been withdrawn from public access... :-((&n; */
DECL|macro|DEFAULT_BMIBA
mdefine_line|#define DEFAULT_BMIBA&t;0xe800&t;/* in case BIOS did not init it */
DECL|macro|DEFAULT_BMCRBA
mdefine_line|#define DEFAULT_BMCRBA&t;0xcc00&t;/* VIA&squot;s default value */
DECL|macro|DEFAULT_BMALIBA
mdefine_line|#define DEFAULT_BMALIBA&t;0xd400&t;/* ALI&squot;s default value */
macro_line|#ifdef CONFIG_IDEDMA_NEW_DRIVE_LISTINGS
DECL|struct|drive_list_entry
r_struct
id|drive_list_entry
(brace
DECL|member|id_model
r_char
op_star
id|id_model
suffix:semicolon
DECL|member|id_firmware
r_char
op_star
id|id_firmware
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|drive_whitelist
r_struct
id|drive_list_entry
id|drive_whitelist
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;Micropolis 2112A&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;CONNER CTMA 4000&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;CONNER CTT8000-A&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;ST34342A&quot;
comma
l_int|NULL
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|variable|drive_blacklist
r_struct
id|drive_list_entry
id|drive_blacklist
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;WDC AC11000H&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;WDC AC22100H&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;WDC AC32500H&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;WDC AC33100H&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;WDC AC31600H&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;WDC AC32100H&quot;
comma
l_string|&quot;24.09P07&quot;
)brace
comma
(brace
l_string|&quot;WDC AC23200L&quot;
comma
l_string|&quot;21.10N21&quot;
)brace
comma
(brace
l_string|&quot;Compaq CRD-8241B&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;CRD-8400B&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;CRD-8480B&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;CRD-8480C&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;CRD-8482B&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;CRD-84&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;SanDisk SDP3B&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;SanDisk SDP3B-64&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;SANYO CD-ROM CRD&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;HITACHI CDR-8&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;HITACHI CDR-8335&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;HITACHI CDR-8435&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;Toshiba CD-ROM XM-6202B&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;CD-532E-A&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;E-IDE CD-ROM CR-840&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;CD-ROM Drive/F5A&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;RICOH CD-R/RW MP7083A&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;WPI CDD-820&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;SAMSUNG CD-ROM SC-148C&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;SAMSUNG CD-ROM SC-148F&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;SAMSUNG CD-ROM SC&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;SanDisk SDP3B-64&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;SAMSUNG CD-ROM SN-124&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;PLEXTOR CD-R PX-W8432T&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;ATAPI CD-ROM DRIVE 40X MAXIMUM&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;_NEC DV5800A&quot;
comma
l_int|NULL
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|function|in_drive_list
r_static
r_int
id|in_drive_list
c_func
(paren
r_struct
id|hd_driveid
op_star
id|id
comma
r_struct
id|drive_list_entry
op_star
id|drive_table
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|drive_table-&gt;id_model
suffix:semicolon
id|drive_table
op_increment
)paren
r_if
c_cond
(paren
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|drive_table-&gt;id_model
comma
id|id-&gt;model
)paren
)paren
op_logical_and
(paren
(paren
id|drive_table-&gt;id_firmware
op_logical_and
op_logical_neg
id|strstr
c_func
(paren
id|drive_table-&gt;id_firmware
comma
id|id-&gt;fw_rev
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|drive_table-&gt;id_firmware
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n; * good_dma_drives() lists the model names (from &quot;hdparm -i&quot;)&n; * of drives which do not support mode2 DMA but which are&n; * known to work fine with this interface under Linux.&n; */
DECL|variable|good_dma_drives
r_const
r_char
op_star
id|good_dma_drives
(braket
)braket
op_assign
(brace
l_string|&quot;Micropolis 2112A&quot;
comma
l_string|&quot;CONNER CTMA 4000&quot;
comma
l_string|&quot;CONNER CTT8000-A&quot;
comma
l_string|&quot;ST34342A&quot;
comma
multiline_comment|/* for Sun Ultra */
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * bad_dma_drives() lists the model names (from &quot;hdparm -i&quot;)&n; * of drives which supposedly support (U)DMA but which are&n; * known to corrupt data with this interface under Linux.&n; *&n; * This is an empirical list. Its generated from bug reports. That means&n; * while it reflects actual problem distributions it doesn&squot;t answer whether&n; * the drive or the controller, or cabling, or software, or some combination&n; * thereof is the fault. If you don&squot;t happen to agree with the kernel&squot;s&n; * opinion of your drive - use hdparm to turn DMA on.&n; */
DECL|variable|bad_dma_drives
r_const
r_char
op_star
id|bad_dma_drives
(braket
)braket
op_assign
(brace
l_string|&quot;WDC AC11000H&quot;
comma
l_string|&quot;WDC AC22100H&quot;
comma
l_string|&quot;WDC AC32100H&quot;
comma
l_string|&quot;WDC AC32500H&quot;
comma
l_string|&quot;WDC AC33100H&quot;
comma
l_string|&quot;WDC AC31600H&quot;
comma
l_int|NULL
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * dma_intr() is the handler for disk read/write DMA interrupts&n; */
DECL|function|ide_dma_intr
id|ide_startstop_t
id|ide_dma_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
comma
id|dma_stat
suffix:semicolon
id|dma_stat
op_assign
id|drive-&gt;channel
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_end
comma
id|drive
)paren
suffix:semicolon
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* get drive status */
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dma_stat
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|__ide_end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: dma_intr: bad DMA status (dma_stat=%x)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|dma_stat
)paren
suffix:semicolon
)brace
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;dma_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
DECL|function|ide_build_sglist
r_int
id|ide_build_sglist
c_func
(paren
r_struct
id|ata_channel
op_star
id|hwif
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|DEVICE_NR
c_func
(paren
id|rq-&gt;rq_dev
)paren
op_amp
l_int|1
)braket
dot
id|queue
suffix:semicolon
r_struct
id|ata_request
op_star
id|ar
op_assign
id|rq-&gt;special
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ar-&gt;ar_flags
op_amp
id|ATA_AR_SETUP
)paren
)paren
(brace
id|ar-&gt;ar_flags
op_or_assign
id|ATA_AR_SETUP
suffix:semicolon
id|ar-&gt;ar_sg_nents
op_assign
id|blk_rq_map_sg
c_func
(paren
id|q
comma
id|rq
comma
id|ar-&gt;ar_sg_table
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;q
op_logical_and
id|ar-&gt;ar_sg_nents
OG
id|rq-&gt;nr_phys_segments
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: received %d phys segments, build %d&bslash;n&quot;
comma
id|__FILE__
comma
id|rq-&gt;nr_phys_segments
comma
id|ar-&gt;ar_sg_nents
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ar-&gt;ar_sg_nents
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: zero segments in request&bslash;n&quot;
comma
id|__FILE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
id|ar-&gt;ar_sg_ddir
op_assign
id|PCI_DMA_FROMDEVICE
suffix:semicolon
r_else
id|ar-&gt;ar_sg_ddir
op_assign
id|PCI_DMA_TODEVICE
suffix:semicolon
r_return
id|pci_map_sg
c_func
(paren
id|hwif-&gt;pci_dev
comma
id|ar-&gt;ar_sg_table
comma
id|ar-&gt;ar_sg_nents
comma
id|ar-&gt;ar_sg_ddir
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME: taskfiles should be a map of pages, not a long virt address... /jens&n; * FIXME: I agree with Jens --mdcki!&n; */
DECL|function|raw_build_sglist
r_static
r_int
id|raw_build_sglist
c_func
(paren
r_struct
id|ata_channel
op_star
id|ch
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|ata_request
op_star
id|ar
op_assign
id|rq-&gt;special
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|ar-&gt;ar_sg_table
suffix:semicolon
r_struct
id|ata_taskfile
op_star
id|args
op_assign
op_amp
id|ar-&gt;ar_task
suffix:semicolon
r_int
r_char
op_star
id|virt_addr
op_assign
id|rq-&gt;buffer
suffix:semicolon
r_int
id|sector_count
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
r_int
id|nents
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;command_type
op_eq
id|IDE_DRIVE_TASK_RAW_WRITE
)paren
id|ar-&gt;ar_sg_ddir
op_assign
id|PCI_DMA_TODEVICE
suffix:semicolon
r_else
id|ar-&gt;ar_sg_ddir
op_assign
id|PCI_DMA_FROMDEVICE
suffix:semicolon
r_if
c_cond
(paren
id|sector_count
OG
l_int|128
)paren
(brace
id|memset
c_func
(paren
op_amp
id|sg
(braket
id|nents
)braket
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sg
)paren
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|page
op_assign
id|virt_to_page
c_func
(paren
id|virt_addr
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|offset
op_assign
(paren
r_int
r_int
)paren
id|virt_addr
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|length
op_assign
l_int|128
op_star
id|SECTOR_SIZE
suffix:semicolon
id|nents
op_increment
suffix:semicolon
id|virt_addr
op_assign
id|virt_addr
op_plus
(paren
l_int|128
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|sector_count
op_sub_assign
l_int|128
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|sg
(braket
id|nents
)braket
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sg
)paren
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|page
op_assign
id|virt_to_page
c_func
(paren
id|virt_addr
)paren
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|offset
op_assign
(paren
r_int
r_int
)paren
id|virt_addr
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|sg
(braket
id|nents
)braket
dot
id|length
op_assign
id|sector_count
op_star
id|SECTOR_SIZE
suffix:semicolon
id|nents
op_increment
suffix:semicolon
r_return
id|pci_map_sg
c_func
(paren
id|ch-&gt;pci_dev
comma
id|sg
comma
id|nents
comma
id|ar-&gt;ar_sg_ddir
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare a dma request.&n; * Returns 0 if all went okay, returns 1 otherwise.&n; * This may also be invoked from trm290.c&n; */
DECL|function|ide_build_dmatable
r_int
id|ide_build_dmatable
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|ide_dma_action_t
id|func
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
op_assign
id|drive-&gt;channel
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_TRM290
r_int
r_int
id|is_trm290_chipset
op_assign
(paren
id|hwif-&gt;chipset
op_eq
id|ide_trm290
)paren
suffix:semicolon
macro_line|#else
r_const
r_int
id|is_trm290_chipset
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_struct
id|ata_request
op_star
id|ar
op_assign
id|rq-&gt;special
suffix:semicolon
r_int
r_int
op_star
id|table
op_assign
id|ar-&gt;ar_dmatable_cpu
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
id|ar-&gt;ar_sg_nents
op_assign
id|raw_build_sglist
c_func
(paren
id|hwif
comma
id|rq
)paren
suffix:semicolon
r_else
id|ar-&gt;ar_sg_nents
op_assign
id|ide_build_sglist
c_func
(paren
id|hwif
comma
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ar-&gt;ar_sg_nents
)paren
r_return
l_int|0
suffix:semicolon
id|sg
op_assign
id|ar-&gt;ar_sg_table
suffix:semicolon
id|i
op_assign
id|ar-&gt;ar_sg_nents
suffix:semicolon
r_while
c_loop
(paren
id|i
)paren
(brace
id|u32
id|cur_addr
suffix:semicolon
id|u32
id|cur_len
suffix:semicolon
id|cur_addr
op_assign
id|sg_dma_address
c_func
(paren
id|sg
)paren
suffix:semicolon
id|cur_len
op_assign
id|sg_dma_len
c_func
(paren
id|sg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fill in the dma table, without crossing any 64kB boundaries.&n;&t;&t; * Most hardware requires 16-bit alignment of all blocks,&n;&t;&t; * but the trm290 requires 32-bit alignment.&n;&t;&t; */
r_while
c_loop
(paren
id|cur_len
)paren
(brace
id|u32
id|xcount
comma
id|bcount
op_assign
l_int|0x10000
op_minus
(paren
id|cur_addr
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_increment
op_ge
id|PRD_ENTRIES
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide-dma: req %p&bslash;n&quot;
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;count %d, sg_nents %d, cur_len %d, cur_addr %u&bslash;n&quot;
comma
id|count
comma
id|ar-&gt;ar_sg_nents
comma
id|cur_len
comma
id|cur_addr
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bcount
OG
id|cur_len
)paren
id|bcount
op_assign
id|cur_len
suffix:semicolon
op_star
id|table
op_increment
op_assign
id|cpu_to_le32
c_func
(paren
id|cur_addr
)paren
suffix:semicolon
id|xcount
op_assign
id|bcount
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|is_trm290_chipset
)paren
id|xcount
op_assign
(paren
(paren
id|xcount
op_rshift
l_int|2
)paren
op_minus
l_int|1
)paren
op_lshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|xcount
op_eq
l_int|0x0000
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Most chipsets correctly interpret a length of&n;&t;&t;&t; * 0x0000 as 64KB, but at least one (e.g. CS5530)&n;&t;&t;&t; * misinterprets it as zero (!). So here we break&n;&t;&t;&t; * the 64KB entry into two 32KB entries instead.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|count
op_increment
op_ge
id|PRD_ENTRIES
)paren
(brace
id|pci_unmap_sg
c_func
(paren
id|hwif-&gt;pci_dev
comma
id|sg
comma
id|ar-&gt;ar_sg_nents
comma
id|ar-&gt;ar_sg_ddir
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|table
op_increment
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0x8000
)paren
suffix:semicolon
op_star
id|table
op_increment
op_assign
id|cpu_to_le32
c_func
(paren
id|cur_addr
op_plus
l_int|0x8000
)paren
suffix:semicolon
id|xcount
op_assign
l_int|0x8000
suffix:semicolon
)brace
op_star
id|table
op_increment
op_assign
id|cpu_to_le32
c_func
(paren
id|xcount
)paren
suffix:semicolon
id|cur_addr
op_add_assign
id|bcount
suffix:semicolon
id|cur_len
op_sub_assign
id|bcount
suffix:semicolon
)brace
id|sg
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
id|printk
c_func
(paren
l_string|&quot;%s: empty DMA table?&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|is_trm290_chipset
)paren
op_star
op_decrement
id|table
op_or_assign
id|cpu_to_le32
c_func
(paren
l_int|0x80000000
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* Teardown mappings after DMA has completed.  */
DECL|function|ide_destroy_dmatable
r_void
id|ide_destroy_dmatable
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
id|drive-&gt;channel-&gt;pci_dev
suffix:semicolon
r_struct
id|ata_request
op_star
id|ar
op_assign
id|IDE_CUR_AR
c_func
(paren
id|drive
)paren
suffix:semicolon
id|pci_unmap_sg
c_func
(paren
id|dev
comma
id|ar-&gt;ar_sg_table
comma
id|ar-&gt;ar_sg_nents
comma
id|ar-&gt;ar_sg_ddir
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  For both Blacklisted and Whitelisted drives.&n; *  This is setup to be called as an extern for future support&n; *  to other special driver code.&n; */
DECL|function|check_drive_lists
r_int
id|check_drive_lists
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|good_bad
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
macro_line|#ifdef CONFIG_IDEDMA_NEW_DRIVE_LISTINGS
r_if
c_cond
(paren
id|good_bad
)paren
(brace
r_return
id|in_drive_list
c_func
(paren
id|id
comma
id|drive_whitelist
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|blacklist
op_assign
id|in_drive_list
c_func
(paren
id|id
comma
id|drive_blacklist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blacklist
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Disabling (U)DMA for %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|id-&gt;model
)paren
suffix:semicolon
r_return
id|blacklist
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_IDEDMA_NEW_DRIVE_LISTINGS */
r_const
r_char
op_star
op_star
id|list
suffix:semicolon
r_if
c_cond
(paren
id|good_bad
)paren
(brace
multiline_comment|/* Consult the list of known &quot;good&quot; drives */
id|list
op_assign
id|good_dma_drives
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|list
op_increment
comma
id|id-&gt;model
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Consult the list of known &quot;bad&quot; drives */
id|list
op_assign
id|bad_dma_drives
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|list
op_increment
comma
id|id-&gt;model
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Disabling (U)DMA for %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|id-&gt;model
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* CONFIG_IDEDMA_NEW_DRIVE_LISTINGS */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|report_drive_dmaing
r_int
id|report_drive_dmaing
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
op_logical_and
(paren
id|eighty_ninty_three
c_func
(paren
id|drive
)paren
)paren
op_logical_and
(paren
id|id-&gt;dma_ultra
op_amp
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|14
)paren
op_amp
l_int|3
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|15
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(mode 7)&quot;
)paren
suffix:semicolon
multiline_comment|/* UDMA BIOS-enabled! */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(133)&quot;
)paren
suffix:semicolon
multiline_comment|/* UDMA BIOS-enabled! */
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
op_logical_and
(paren
id|eighty_ninty_three
c_func
(paren
id|drive
)paren
)paren
op_logical_and
(paren
id|id-&gt;dma_ultra
op_amp
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|11
)paren
op_amp
l_int|7
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|13
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(100)&quot;
)paren
suffix:semicolon
multiline_comment|/* UDMA BIOS-enabled! */
)brace
r_else
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|12
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(66)&quot;
)paren
suffix:semicolon
multiline_comment|/* UDMA BIOS-enabled! */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(44)&quot;
)paren
suffix:semicolon
multiline_comment|/* UDMA BIOS-enabled! */
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
op_logical_and
(paren
id|id-&gt;dma_ultra
op_amp
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|8
)paren
op_amp
l_int|7
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|10
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(33)&quot;
)paren
suffix:semicolon
multiline_comment|/* UDMA BIOS-enabled! */
)brace
r_else
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|9
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(25)&quot;
)paren
suffix:semicolon
multiline_comment|/* UDMA BIOS-enabled! */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(16)&quot;
)paren
suffix:semicolon
multiline_comment|/* UDMA BIOS-enabled! */
)brace
)brace
r_else
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, (U)DMA&quot;
)paren
suffix:semicolon
multiline_comment|/* Can be BIOS-enabled! */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, DMA&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|config_drive_for_dma
r_static
r_int
id|config_drive_for_dma
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|config_allows_dma
op_assign
l_int|1
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_struct
id|ata_channel
op_star
id|hwif
op_assign
id|drive-&gt;channel
suffix:semicolon
macro_line|#ifdef CONFIG_IDEDMA_ONLYDISK
r_if
c_cond
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
)paren
id|config_allows_dma
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|id
op_logical_and
(paren
id|id-&gt;capability
op_amp
l_int|1
)paren
op_logical_and
id|hwif-&gt;autodma
op_logical_and
id|config_allows_dma
)paren
(brace
multiline_comment|/* Consult the list of known &quot;bad&quot; drives */
r_if
c_cond
(paren
id|ide_dmaproc
c_func
(paren
id|ide_dma_bad_drive
comma
id|drive
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Enable DMA on any drive that has UltraDMA (mode 6/7/?) enabled */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
op_logical_and
(paren
id|eighty_ninty_three
c_func
(paren
id|drive
)paren
)paren
)paren
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_amp
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|14
)paren
op_amp
l_int|2
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Enable DMA on any drive that has UltraDMA (mode 3/4/5) enabled */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
op_logical_and
(paren
id|eighty_ninty_three
c_func
(paren
id|drive
)paren
)paren
)paren
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_amp
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|11
)paren
op_amp
l_int|7
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Enable DMA on any drive that has UltraDMA (mode 0/1/2) enabled */
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
multiline_comment|/* UltraDMA */
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_amp
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|8
)paren
op_amp
l_int|7
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Enable DMA on any drive that has mode2 DMA (multi or single) enabled */
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
multiline_comment|/* regular DMA */
r_if
c_cond
(paren
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
op_logical_or
(paren
id|id-&gt;dma_1word
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Consult the list of known &quot;good&quot; drives */
r_if
c_cond
(paren
id|ide_dmaproc
c_func
(paren
id|ide_dma_good_drive
comma
id|drive
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
)brace
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off_quietly
comma
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * 1 dma-ing, 2 error, 4 intr&n; */
DECL|function|dma_timer_expiry
r_static
r_int
id|dma_timer_expiry
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|dma_stat
op_assign
id|inb
c_func
(paren
id|drive-&gt;channel-&gt;dma_base
op_plus
l_int|2
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: dma_timer_expiry: dma status == 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|dma_stat
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
macro_line|#if 0
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|expiry
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* one free ride for now */
macro_line|#endif
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|2
)paren
(brace
multiline_comment|/* ERROR */
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;dma_timer_expiry&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|1
)paren
multiline_comment|/* DMAing */
r_return
id|WAIT_CMD
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_toggle_bounce
r_static
r_void
id|ide_toggle_bounce
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|on
)paren
(brace
id|u64
id|addr
op_assign
id|BLK_BOUNCE_HIGH
suffix:semicolon
r_if
c_cond
(paren
id|on
op_logical_and
id|drive-&gt;type
op_eq
id|ATA_DISK
op_logical_and
id|drive-&gt;channel-&gt;highmem
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PCI_DMA_BUS_IS_PHYS
)paren
id|addr
op_assign
id|BLK_BOUNCE_ANY
suffix:semicolon
r_else
id|addr
op_assign
id|drive-&gt;channel-&gt;pci_dev-&gt;dma_mask
suffix:semicolon
)brace
id|blk_queue_bounce_limit
c_func
(paren
op_amp
id|drive-&gt;queue
comma
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start DMA engine.&n; */
DECL|function|ide_start_dma
r_int
id|ide_start_dma
c_func
(paren
r_struct
id|ata_channel
op_star
id|hwif
comma
id|ide_drive_t
op_star
id|drive
comma
id|ide_dma_action_t
id|func
)paren
(brace
r_int
r_int
id|reading
op_assign
l_int|0
comma
id|count
suffix:semicolon
r_int
r_int
id|dma_base
op_assign
id|hwif-&gt;dma_base
suffix:semicolon
r_struct
id|ata_request
op_star
id|ar
op_assign
id|IDE_CUR_AR
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|ar-&gt;ar_rq
)paren
op_eq
id|READ
)paren
id|reading
op_assign
l_int|1
op_lshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;rwproc
)paren
id|hwif
op_member_access_from_pointer
id|rwproc
c_func
(paren
id|drive
comma
id|func
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|count
op_assign
id|ide_build_dmatable
c_func
(paren
id|drive
comma
id|ar-&gt;ar_rq
comma
id|func
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* try PIO instead of DMA */
id|ar-&gt;ar_flags
op_or_assign
id|ATA_AR_SETUP
suffix:semicolon
id|outl
c_func
(paren
id|ar-&gt;ar_dmatable
comma
id|dma_base
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* PRD table */
id|outb
c_func
(paren
id|reading
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* specify r/w */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_or
l_int|6
comma
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* clear INTR &amp; ERROR flags */
id|drive-&gt;waiting_for_dma
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_dmaproc() initiates/aborts DMA read/write operations on a drive.&n; *&n; * The caller is assumed to have selected the drive and programmed the drive&squot;s&n; * sector address using CHS or LBA.  All that remains is to prepare for DMA&n; * and then issue the actual read/write DMA/PIO command to the drive.&n; *&n; * For ATAPI devices, we just prepare for DMA and return. The caller should&n; * then issue the packet command to the drive and call us again with&n; * ide_dma_begin afterwards.&n; *&n; * Returns 0 if all went well.&n; * Returns 1 if DMA read/write could not be started, in which case&n; * the caller should revert to PIO for the current request.&n; * May also be invoked from trm290.c&n; */
DECL|function|ide_dmaproc
r_int
id|ide_dmaproc
(paren
id|ide_dma_action_t
id|func
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|ata_channel
op_star
id|hwif
op_assign
id|drive-&gt;channel
suffix:semicolon
r_int
r_int
id|dma_base
op_assign
id|hwif-&gt;dma_base
suffix:semicolon
id|u8
id|unit
op_assign
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
suffix:semicolon
r_int
r_int
id|reading
op_assign
l_int|0
comma
id|set_high
op_assign
l_int|1
suffix:semicolon
r_struct
id|ata_request
op_star
id|ar
suffix:semicolon
id|u8
id|dma_stat
suffix:semicolon
r_switch
c_cond
(paren
id|func
)paren
(brace
r_case
id|ide_dma_off
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: DMA disabled&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_case
id|ide_dma_off_quietly
suffix:colon
id|set_high
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;using_tcq
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
(paren
l_int|5
op_plus
id|unit
)paren
)paren
comma
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
r_case
id|ide_dma_on
suffix:colon
id|ide_toggle_bounce
c_func
(paren
id|drive
comma
id|set_high
)paren
suffix:semicolon
id|drive-&gt;using_dma
op_assign
(paren
id|func
op_eq
id|ide_dma_on
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;using_dma
)paren
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_or
(paren
l_int|1
op_lshift
(paren
l_int|5
op_plus
id|unit
)paren
)paren
comma
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|ide_dma_check
suffix:colon
r_return
id|config_drive_for_dma
(paren
id|drive
)paren
suffix:semicolon
r_case
id|ide_dma_begin
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ide_dma_begin: from %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|IDE_DMA
comma
op_amp
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|flags
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Note that this is done *after* the cmd has&n;&t;&t;&t; * been issued to the drive, as per the BM-IDE spec.&n;&t;&t;&t; * The Promise Ultra33 doesn&squot;t work correctly when&n;&t;&t;&t; * we do this part before issuing the drive cmd.&n;&t;&t;&t; */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_or
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* start DMA */
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE_TCQ
r_case
id|ide_dma_queued_on
suffix:colon
r_case
id|ide_dma_queued_off
suffix:colon
r_case
id|ide_dma_read_queued
suffix:colon
r_case
id|ide_dma_write_queued
suffix:colon
r_case
id|ide_dma_queued_start
suffix:colon
r_return
id|ide_tcq_dmaproc
c_func
(paren
id|func
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif
r_case
id|ide_dma_read
suffix:colon
id|reading
op_assign
l_int|1
op_lshift
l_int|3
suffix:semicolon
r_case
id|ide_dma_write
suffix:colon
id|ar
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;special
suffix:semicolon
r_if
c_cond
(paren
id|ide_start_dma
c_func
(paren
id|hwif
comma
id|drive
comma
id|func
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
)paren
r_return
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|handler
)paren
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|ide_dma_intr
comma
id|WAIT_CMD
comma
id|dma_timer_expiry
)paren
suffix:semicolon
multiline_comment|/* issue cmd to drive */
r_if
c_cond
(paren
(paren
id|ar-&gt;ar_rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
op_logical_and
(paren
id|drive-&gt;addressing
op_eq
l_int|1
)paren
)paren
(brace
r_struct
id|ata_taskfile
op_star
id|args
op_assign
op_amp
id|ar-&gt;ar_task
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|args-&gt;taskfile.command
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive-&gt;addressing
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|reading
ques
c_cond
id|WIN_READDMA_EXT
suffix:colon
id|WIN_WRITEDMA_EXT
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
r_else
(brace
id|OUT_BYTE
c_func
(paren
id|reading
ques
c_cond
id|WIN_READDMA
suffix:colon
id|WIN_WRITEDMA
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_begin
comma
id|drive
)paren
suffix:semicolon
r_case
id|ide_dma_end
suffix:colon
multiline_comment|/* returns 1 on error, 0 otherwise */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ide_dma_end: from %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
id|IDE_DMA
comma
op_amp
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|flags
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide_dma_end: dma not going? %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|drive-&gt;waiting_for_dma
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_amp
op_complement
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* stop DMA */
id|dma_stat
op_assign
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* get DMA status */
id|outb
c_func
(paren
id|dma_stat
op_or
l_int|6
comma
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* clear the INTR &amp; ERROR bits */
id|ide_destroy_dmatable
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* purge DMA mappings */
r_if
c_cond
(paren
id|drive-&gt;tcq
)paren
id|IDE_SET_CUR_TAG
c_func
(paren
id|drive
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
(paren
id|dma_stat
op_amp
l_int|7
)paren
op_ne
l_int|4
ques
c_cond
(paren
l_int|0x10
op_or
id|dma_stat
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* verify good DMA status */
r_case
id|ide_dma_test_irq
suffix:colon
multiline_comment|/* returns 1 if dma irq issued, 0 otherwise */
id|dma_stat
op_assign
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
macro_line|#if 0  /* do not set unless you know what you are doing */
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|4
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|dma_base
op_plus
l_int|2
comma
id|dma_stat
op_amp
l_int|0xE4
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
(paren
id|dma_stat
op_amp
l_int|4
)paren
op_eq
l_int|4
suffix:semicolon
multiline_comment|/* return 1 if INTR asserted */
r_case
id|ide_dma_bad_drive
suffix:colon
r_case
id|ide_dma_good_drive
suffix:colon
r_return
id|check_drive_lists
c_func
(paren
id|drive
comma
(paren
id|func
op_eq
id|ide_dma_good_drive
)paren
)paren
suffix:semicolon
r_case
id|ide_dma_verbose
suffix:colon
r_return
id|report_drive_dmaing
c_func
(paren
id|drive
)paren
suffix:semicolon
r_case
id|ide_dma_timeout
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: DMA timeout occured!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
id|ide_dma_retune
suffix:colon
r_case
id|ide_dma_lostirq
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: chipset supported func only: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|func
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unsupported func: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|func
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Needed for allowing full modular support of ide-driver&n; */
DECL|function|ide_release_dma
r_void
id|ide_release_dma
c_func
(paren
r_struct
id|ata_channel
op_star
id|hwif
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;dma_base
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hwif-&gt;dma_extra
)paren
op_logical_and
(paren
id|hwif-&gt;unit
op_eq
l_int|0
)paren
)paren
id|release_region
c_func
(paren
(paren
id|hwif-&gt;dma_base
op_plus
l_int|16
)paren
comma
id|hwif-&gt;dma_extra
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|hwif-&gt;dma_base
comma
l_int|8
)paren
suffix:semicolon
id|hwif-&gt;dma_base
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This can be called for a dynamically installed interface. Don&squot;t __init it&n; */
DECL|function|ide_setup_dma
r_void
id|ide_setup_dma
c_func
(paren
r_struct
id|ata_channel
op_star
id|hwif
comma
r_int
r_int
id|dma_base
comma
r_int
r_int
id|num_ports
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    %s: BM-DMA at 0x%04lx-0x%04lx&quot;
comma
id|hwif-&gt;name
comma
id|dma_base
comma
id|dma_base
op_plus
id|num_ports
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|dma_base
comma
id|num_ports
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; -- ERROR, PORT ADDRESSES ALREADY IN USE&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|request_region
c_func
(paren
id|dma_base
comma
id|num_ports
comma
id|hwif-&gt;name
)paren
suffix:semicolon
id|hwif-&gt;dma_base
op_assign
id|dma_base
suffix:semicolon
id|hwif-&gt;dmaproc
op_assign
op_amp
id|ide_dmaproc
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_ne
id|ide_trm290
)paren
(brace
id|byte
id|dma_stat
op_assign
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, BIOS settings: %s:%s, %s:%s&quot;
comma
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|name
comma
(paren
id|dma_stat
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;DMA&quot;
suffix:colon
l_string|&quot;pio&quot;
comma
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|name
comma
(paren
id|dma_stat
op_amp
l_int|0x40
)paren
ques
c_cond
l_string|&quot;DMA&quot;
suffix:colon
l_string|&quot;pio&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
