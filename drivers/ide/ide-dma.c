multiline_comment|/*&n; *  linux/drivers/ide/ide-dma.c&t;&t;Version 4.10&t;June 9, 2000&n; *&n; *  Copyright (c) 1999-2000&t;Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *  May be copied or modified under the terms of the GNU General Public License&n; */
multiline_comment|/*&n; *  Special Thanks to Mark for his Six years of work.&n; *&n; *  Copyright (c) 1995-1998  Mark Lord&n; *  May be copied or modified under the terms of the GNU General Public License&n; */
multiline_comment|/*&n; * This module provides support for the bus-master IDE DMA functions&n; * of various PCI chipsets, including the Intel PIIX (i82371FB for&n; * the 430 FX chipset), the PIIX3 (i82371SB for the 430 HX/VX and &n; * 440 chipsets), and the PIIX4 (i82371AB for the 430 TX chipset)&n; * (&quot;PIIX&quot; stands for &quot;PCI ISA IDE Xcellerator&quot;).&n; *&n; * Pretty much the same code works for other IDE PCI bus-mastering chipsets.&n; *&n; * DMA is supported for all IDE devices (disk drives, cdroms, tapes, floppies).&n; *&n; * By default, DMA support is prepared for use, but is currently enabled only&n; * for drives which already have DMA enabled (UltraDMA or mode 2 multi/single),&n; * or which are recognized as &quot;good&quot; (see table below).  Drives with only mode0&n; * or mode1 (multi/single) DMA should also work with this chipset/driver&n; * (eg. MC2112A) but are not enabled by default.&n; *&n; * Use &quot;hdparm -i&quot; to view modes supported by a given drive.&n; *&n; * The hdparm-3.5 (or later) utility can be used for manually enabling/disabling&n; * DMA support, but must be (re-)compiled against this kernel version or later.&n; *&n; * To enable DMA, use &quot;hdparm -d1 /dev/hd?&quot; on a per-drive basis after booting.&n; * If problems arise, ide.c will disable DMA operation after a few retries.&n; * This error recovery mechanism works and has been extremely well exercised.&n; *&n; * IDE drives, depending on their vintage, may support several different modes&n; * of DMA operation.  The boot-time modes are indicated with a &quot;*&quot; in&n; * the &quot;hdparm -i&quot; listing, and can be changed with *knowledgeable* use of&n; * the &quot;hdparm -X&quot; feature.  There is seldom a need to do this, as drives&n; * normally power-up with their &quot;best&quot; PIO/DMA modes enabled.&n; *&n; * Testing has been done with a rather extensive number of drives,&n; * with Quantum &amp; Western Digital models generally outperforming the pack,&n; * and Fujitsu &amp; Conner (and some Seagate which are really Conner) drives&n; * showing more lackluster throughput.&n; *&n; * Keep an eye on /var/adm/messages for &quot;DMA disabled&quot; messages.&n; *&n; * Some people have reported trouble with Intel Zappa motherboards.&n; * This can be fixed by upgrading the AMI BIOS to version 1.00.04.BS0,&n; * available from ftp://ftp.intel.com/pub/bios/10004bs0.exe&n; * (thanks to Glen Morrell &lt;glen@spin.Stanford.edu&gt; for researching this).&n; *&n; * Thanks to &quot;Christopher J. Reimer&quot; &lt;reimer@doe.carleton.ca&gt; for&n; * fixing the problem with the BIOS on some Acer motherboards.&n; *&n; * Thanks to &quot;Benoit Poulot-Cazajous&quot; &lt;poulot@chorus.fr&gt; for testing&n; * &quot;TX&quot; chipset compatibility and for providing patches for the &quot;TX&quot; chipset.&n; *&n; * Thanks to Christian Brunner &lt;chb@muc.de&gt; for taking a good first crack&n; * at generic DMA -- his patches were referred to when preparing this code.&n; *&n; * Most importantly, thanks to Robert Bringman &lt;rob@mars.trion.com&gt;&n; * for supplying a Promise UDMA board &amp; WD UDMA drive for this work!&n; *&n; * And, yes, Intel Zappa boards really *do* use both PIIX IDE ports.&n; *&n; * ATA-66/100 and recovery functions, I forgot the rest......&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/scatterlist.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
DECL|struct|drive_list_entry
r_struct
id|drive_list_entry
(brace
DECL|member|id_model
r_const
r_char
op_star
id|id_model
suffix:semicolon
DECL|member|id_firmware
r_const
r_char
op_star
id|id_firmware
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|drive_whitelist
r_static
r_const
r_struct
id|drive_list_entry
id|drive_whitelist
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;Micropolis 2112A&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;CONNER CTMA 4000&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;CONNER CTT8000-A&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;ST34342A&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|variable|drive_blacklist
r_static
r_const
r_struct
id|drive_list_entry
id|drive_blacklist
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;WDC AC11000H&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;WDC AC22100H&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;WDC AC32500H&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;WDC AC33100H&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;WDC AC31600H&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;WDC AC32100H&quot;
comma
l_string|&quot;24.09P07&quot;
)brace
comma
(brace
l_string|&quot;WDC AC23200L&quot;
comma
l_string|&quot;21.10N21&quot;
)brace
comma
(brace
l_string|&quot;Compaq CRD-8241B&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;CRD-8400B&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;CRD-8480B&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;CRD-8482B&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;CRD-84&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;SanDisk SDP3B&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;SanDisk SDP3B-64&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;SANYO CD-ROM CRD&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;HITACHI CDR-8&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;HITACHI CDR-8335&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;HITACHI CDR-8435&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;Toshiba CD-ROM XM-6202B&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;CD-532E-A&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;E-IDE CD-ROM CR-840&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;CD-ROM Drive/F5A&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;WPI CDD-820&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;SAMSUNG CD-ROM SC-148C&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;SAMSUNG CD-ROM SC&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;SanDisk SDP3B-64&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;SAMSUNG CD-ROM SN-124&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;ATAPI CD-ROM DRIVE 40X MAXIMUM&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;_NEC DV5800A&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;in_drive_list&t;-&t;look for drive in black/white list&n; *&t;@id: drive identifier&n; *&t;@drive_table: list to inspect&n; *&n; *&t;Look for a drive in the blacklist and the whitelist tables&n; *&t;Returns 1 if the drive is found in the table.&n; */
DECL|function|in_drive_list
r_static
r_int
id|in_drive_list
c_func
(paren
r_struct
id|hd_driveid
op_star
id|id
comma
r_const
r_struct
id|drive_list_entry
op_star
id|drive_table
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|drive_table-&gt;id_model
suffix:semicolon
id|drive_table
op_increment
)paren
r_if
c_cond
(paren
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|drive_table-&gt;id_model
comma
id|id-&gt;model
)paren
)paren
op_logical_and
(paren
(paren
id|strstr
c_func
(paren
id|drive_table-&gt;id_firmware
comma
id|id-&gt;fw_rev
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|drive_table-&gt;id_firmware
comma
l_string|&quot;ALL&quot;
)paren
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ide_dma_intr&t;-&t;IDE DMA interrupt handler&n; *&t;@drive: the drive the interrupt is for&n; *&n; *&t;Handle an interrupt completing a read/write DMA transfer on an &n; *&t;IDE device&n; */
DECL|function|ide_dma_intr
id|ide_startstop_t
id|ide_dma_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|u8
id|stat
op_assign
l_int|0
comma
id|dma_stat
op_assign
l_int|0
suffix:semicolon
id|dma_stat
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_end
c_func
(paren
id|drive
)paren
suffix:semicolon
id|stat
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* get drive status */
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dma_stat
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|end_request
c_func
(paren
id|drive
comma
l_int|1
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: dma_intr: bad DMA status (dma_stat=%x)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|dma_stat
)paren
suffix:semicolon
)brace
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;dma_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
DECL|variable|ide_dma_intr
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_dma_intr
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
multiline_comment|/**&n; *&t;ide_build_sglist&t;-&t;map IDE scatter gather for DMA I/O&n; *&t;@drive: the drive to build the DMA table for&n; *&t;@rq: the request holding the sg list&n; *&n; *&t;Perform the PCI mapping magic necessary to access the source or&n; *&t;target buffers of a request via PCI DMA. The lower layers of the&n; *&t;kernel provide the necessary cache management so that we can&n; *&t;operate in a portable fashion&n; */
DECL|function|ide_build_sglist
r_int
id|ide_build_sglist
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|hwif-&gt;sg_table
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;flags
op_amp
id|REQ_DRIVE_TASKFILE
)paren
op_logical_and
id|rq-&gt;nr_sectors
OG
l_int|256
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ide_map_sg
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|READ
)paren
id|hwif-&gt;sg_dma_direction
op_assign
id|PCI_DMA_FROMDEVICE
suffix:semicolon
r_else
id|hwif-&gt;sg_dma_direction
op_assign
id|PCI_DMA_TODEVICE
suffix:semicolon
r_return
id|pci_map_sg
c_func
(paren
id|hwif-&gt;pci_dev
comma
id|sg
comma
id|hwif-&gt;sg_nents
comma
id|hwif-&gt;sg_dma_direction
)paren
suffix:semicolon
)brace
DECL|variable|ide_build_sglist
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_build_sglist
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_build_dmatable&t;-&t;build IDE DMA table&n; *&n; *&t;ide_build_dmatable() prepares a dma request. We map the command&n; *&t;to get the pci bus addresses of the buffers and then build up&n; *&t;the PRD table that the IDE layer wants to be fed. The code&n; *&t;knows about the 64K wrap bug in the CS5530.&n; *&n; *&t;Returns 0 if all went okay, returns 1 otherwise.&n; *&t;May also be invoked from trm290.c&n; */
DECL|function|ide_build_dmatable
r_int
id|ide_build_dmatable
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
op_star
id|table
op_assign
id|hwif-&gt;dmatable_cpu
suffix:semicolon
r_int
r_int
id|is_trm290
op_assign
(paren
id|hwif-&gt;chipset
op_eq
id|ide_trm290
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
id|hwif-&gt;sg_nents
op_assign
id|i
op_assign
id|ide_build_sglist
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_return
l_int|0
suffix:semicolon
id|sg
op_assign
id|hwif-&gt;sg_table
suffix:semicolon
r_while
c_loop
(paren
id|i
)paren
(brace
id|u32
id|cur_addr
suffix:semicolon
id|u32
id|cur_len
suffix:semicolon
id|cur_addr
op_assign
id|sg_dma_address
c_func
(paren
id|sg
)paren
suffix:semicolon
id|cur_len
op_assign
id|sg_dma_len
c_func
(paren
id|sg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fill in the dma table, without crossing any 64kB boundaries.&n;&t;&t; * Most hardware requires 16-bit alignment of all blocks,&n;&t;&t; * but the trm290 requires 32-bit alignment.&n;&t;&t; */
r_while
c_loop
(paren
id|cur_len
)paren
(brace
r_if
c_cond
(paren
id|count
op_increment
op_ge
id|PRD_ENTRIES
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: DMA table too small&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_goto
id|use_pio_instead
suffix:semicolon
)brace
r_else
(brace
id|u32
id|xcount
comma
id|bcount
op_assign
l_int|0x10000
op_minus
(paren
id|cur_addr
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcount
OG
id|cur_len
)paren
id|bcount
op_assign
id|cur_len
suffix:semicolon
op_star
id|table
op_increment
op_assign
id|cpu_to_le32
c_func
(paren
id|cur_addr
)paren
suffix:semicolon
id|xcount
op_assign
id|bcount
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|is_trm290
)paren
id|xcount
op_assign
(paren
(paren
id|xcount
op_rshift
l_int|2
)paren
op_minus
l_int|1
)paren
op_lshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|xcount
op_eq
l_int|0x0000
)paren
(brace
multiline_comment|/* &n;&t; * Most chipsets correctly interpret a length of 0x0000 as 64KB,&n;&t; * but at least one (e.g. CS5530) misinterprets it as zero (!).&n;&t; * So here we break the 64KB entry into two 32KB entries instead.&n;&t; */
r_if
c_cond
(paren
id|count
op_increment
op_ge
id|PRD_ENTRIES
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: DMA table too small&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_goto
id|use_pio_instead
suffix:semicolon
)brace
op_star
id|table
op_increment
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0x8000
)paren
suffix:semicolon
op_star
id|table
op_increment
op_assign
id|cpu_to_le32
c_func
(paren
id|cur_addr
op_plus
l_int|0x8000
)paren
suffix:semicolon
id|xcount
op_assign
l_int|0x8000
suffix:semicolon
)brace
op_star
id|table
op_increment
op_assign
id|cpu_to_le32
c_func
(paren
id|xcount
)paren
suffix:semicolon
id|cur_addr
op_add_assign
id|bcount
suffix:semicolon
id|cur_len
op_sub_assign
id|bcount
suffix:semicolon
)brace
)brace
id|sg
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_trm290
)paren
op_star
op_decrement
id|table
op_or_assign
id|cpu_to_le32
c_func
(paren
l_int|0x80000000
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: empty DMA table?&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|use_pio_instead
suffix:colon
id|pci_unmap_sg
c_func
(paren
id|hwif-&gt;pci_dev
comma
id|hwif-&gt;sg_table
comma
id|hwif-&gt;sg_nents
comma
id|hwif-&gt;sg_dma_direction
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* revert to PIO for this request */
)brace
DECL|variable|ide_build_dmatable
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_build_dmatable
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_destroy_dmatable&t;-&t;clean up DMA mapping&n; *&t;@drive: The drive to unmap&n; *&n; *&t;Teardown mappings after DMA has completed. This must be called&n; *&t;after the completion of each use of ide_build_dmatable and before&n; *&t;the next use of ide_build_dmatable. Failure to do so will cause&n; *&t;an oops as only one mapping can be live for each target at a given&n; *&t;time.&n; */
DECL|function|ide_destroy_dmatable
r_void
id|ide_destroy_dmatable
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|pci_dev
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|sg_table
suffix:semicolon
r_int
id|nents
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|sg_nents
suffix:semicolon
id|pci_unmap_sg
c_func
(paren
id|dev
comma
id|sg
comma
id|nents
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|sg_dma_direction
)paren
suffix:semicolon
)brace
DECL|variable|ide_destroy_dmatable
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_destroy_dmatable
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;config_drive_for_dma&t;-&t;attempt to activate IDE DMA&n; *&t;@drive: the drive to place in DMA mode&n; *&n; *&t;If the drive supports at least mode 2 DMA or UDMA of any kind&n; *&t;then attempt to place it into DMA mode. Drives that are known to&n; *&t;support DMA but predate the DMA properties or that are known&n; *&t;to have DMA handling bugs are also set up appropriately based&n; *&t;on the good/bad drive lists.&n; */
DECL|function|config_drive_for_dma
r_static
r_int
id|config_drive_for_dma
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;capability
op_amp
l_int|1
)paren
op_logical_and
id|hwif-&gt;autodma
)paren
(brace
multiline_comment|/*&n;&t;&t; * Enable DMA on any drive that has&n;&t;&t; * UltraDMA (mode 0/1/2/3/4/5/6) enabled&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
op_logical_and
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|8
)paren
op_amp
l_int|0x7f
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|ide_dma_on
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Enable DMA on any drive that has mode2 DMA&n;&t;&t; * (multi or single) enabled&n;&t;&t; */
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
multiline_comment|/* regular DMA */
r_if
c_cond
(paren
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
op_logical_or
(paren
id|id-&gt;dma_1word
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
)paren
r_return
id|hwif
op_member_access_from_pointer
id|ide_dma_on
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Consult the list of known &quot;good&quot; drives */
r_if
c_cond
(paren
id|__ide_dma_good_drive
c_func
(paren
id|drive
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|ide_dma_on
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
singleline_comment|//&t;if (hwif-&gt;tuneproc != NULL) hwif-&gt;tuneproc(drive, 255);
r_return
id|hwif
op_member_access_from_pointer
id|ide_dma_off_quietly
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dma_timer_expiry&t;-&t;handle a DMA timeout&n; *&t;@drive: Drive that timed out&n; *&n; *&t;An IDE DMA transfer timed out. In the event of an error we ask&n; *&t;the driver to resolve the problem, if a DMA transfer is still&n; *&t;in progress we continue to wait (arguably we need to add a &n; *&t;secondary &squot;I don&squot;t care what the drive thinks&squot; timeout here)&n; *&t;Finally if we have an interrupt we let it complete the I/O.&n; *&t;But only one time - we clear expiry and if it&squot;s still not&n; *&t;completed after WAIT_CMD, we error and retry in PIO.&n; *&t;This can occur if an interrupt is lost or due to hang or bugs.&n; */
DECL|function|dma_timer_expiry
r_static
r_int
id|dma_timer_expiry
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|dma_stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hwif-&gt;dma_status
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: dma_timer_expiry: dma status == 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|dma_stat
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_stat
op_amp
l_int|0x18
)paren
op_eq
l_int|0x18
)paren
multiline_comment|/* BUSY Stupid Early Timer !! */
r_return
id|WAIT_CMD
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|expiry
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* one free ride for now */
multiline_comment|/* 1 dmaing, 2 error, 4 intr */
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|2
)paren
multiline_comment|/* ERROR */
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|1
)paren
multiline_comment|/* DMAing */
r_return
id|WAIT_CMD
suffix:semicolon
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|4
)paren
multiline_comment|/* Got an Interrupt */
r_return
id|WAIT_CMD
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Status is unknown -- reset the bus */
)brace
multiline_comment|/**&n; *&t;__ide_dma_host_off&t;-&t;Generic DMA kill&n; *&t;@drive: drive to control&n; *&n; *&t;Perform the generic IDE controller DMA off operation. This&n; *&t;works for most IDE bus mastering controllers&n; */
DECL|function|__ide_dma_host_off
r_int
id|__ide_dma_host_off
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|unit
op_assign
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
suffix:semicolon
id|u8
id|dma_stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hwif-&gt;dma_status
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
(paren
id|dma_stat
op_amp
op_complement
(paren
l_int|1
op_lshift
(paren
l_int|5
op_plus
id|unit
)paren
)paren
)paren
comma
id|hwif-&gt;dma_status
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|__ide_dma_host_off
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_dma_host_off
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;__ide_dma_host_off_quietly&t;-&t;Generic DMA kill&n; *&t;@drive: drive to control&n; *&n; *&t;Turn off the current DMA on this IDE controller. &n; */
DECL|function|__ide_dma_off_quietly
r_int
id|__ide_dma_off_quietly
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|drive-&gt;using_dma
op_assign
l_int|0
suffix:semicolon
id|ide_toggle_bounce
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_host_off
c_func
(paren
id|drive
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|__ide_dma_off_quietly
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_dma_off_quietly
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
multiline_comment|/**&n; *&t;__ide_dma_off&t;-&t;disable DMA on a device&n; *&t;@drive: drive to disable DMA on&n; *&n; *&t;Disable IDE DMA for a device on this IDE controller.&n; *&t;Inform the user that DMA has been disabled.&n; */
DECL|function|__ide_dma_off
r_int
id|__ide_dma_off
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: DMA disabled&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_off_quietly
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
DECL|variable|__ide_dma_off
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_dma_off
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
multiline_comment|/**&n; *&t;__ide_dma_host_on&t;-&t;Enable DMA on a host&n; *&t;@drive: drive to enable for DMA&n; *&n; *&t;Enable DMA on an IDE controller following generic bus mastering&n; *&t;IDE controller behaviour&n; */
DECL|function|__ide_dma_host_on
r_int
id|__ide_dma_host_on
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;using_dma
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|unit
op_assign
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
suffix:semicolon
id|u8
id|dma_stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hwif-&gt;dma_status
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
(paren
id|dma_stat
op_or
(paren
l_int|1
op_lshift
(paren
l_int|5
op_plus
id|unit
)paren
)paren
)paren
comma
id|hwif-&gt;dma_status
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|__ide_dma_host_on
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_dma_host_on
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;__ide_dma_on&t;&t;-&t;Enable DMA on a device&n; *&t;@drive: drive to enable DMA on&n; *&n; *&t;Enable IDE DMA for a device on this IDE controller.&n; */
DECL|function|__ide_dma_on
r_int
id|__ide_dma_on
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
multiline_comment|/* consult the list of known &quot;bad&quot; drives */
r_if
c_cond
(paren
id|__ide_dma_bad_drive
c_func
(paren
id|drive
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|drive-&gt;using_dma
op_assign
l_int|1
suffix:semicolon
id|ide_toggle_bounce
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_host_on
c_func
(paren
id|drive
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|__ide_dma_on
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_dma_on
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;__ide_dma_check&t;&t;-&t;check DMA setup&n; *&t;@drive: drive to check&n; *&n; *&t;Don&squot;t use - due for extermination&n; */
DECL|function|__ide_dma_check
r_int
id|__ide_dma_check
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
id|config_drive_for_dma
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
DECL|variable|__ide_dma_check
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_dma_check
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ide_dma_setup&t;-&t;begin a DMA phase&n; *&t;@drive: target device&n; *&n; *&t;Build an IDE DMA PRD (IDE speak for scatter gather table)&n; *&t;and then set up the DMA transfer registers for a device&n; *&t;that follows generic IDE PCI DMA behaviour. Controllers can&n; *&t;override this function if they need to&n; *&n; *&t;Returns 0 on success. If a PIO fallback is required then 1&n; *&t;is returned. &n; */
DECL|function|ide_dma_setup
r_int
id|ide_dma_setup
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|drive-&gt;hwif
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
r_int
id|reading
suffix:semicolon
id|u8
id|dma_stat
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
)paren
id|reading
op_assign
l_int|0
suffix:semicolon
r_else
id|reading
op_assign
l_int|1
op_lshift
l_int|3
suffix:semicolon
multiline_comment|/* fall back to pio! */
r_if
c_cond
(paren
op_logical_neg
id|ide_build_dmatable
c_func
(paren
id|drive
comma
id|rq
)paren
)paren
(brace
id|ide_map_sg
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* PRD table */
id|hwif
op_member_access_from_pointer
id|OUTL
c_func
(paren
id|hwif-&gt;dmatable_dma
comma
id|hwif-&gt;dma_prdtable
)paren
suffix:semicolon
multiline_comment|/* specify r/w */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|reading
comma
id|hwif-&gt;dma_command
)paren
suffix:semicolon
multiline_comment|/* read dma_status for INTR &amp; ERROR flags */
id|dma_stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hwif-&gt;dma_status
)paren
suffix:semicolon
multiline_comment|/* clear INTR &amp; ERROR flags */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|dma_stat
op_or
l_int|6
comma
id|hwif-&gt;dma_status
)paren
suffix:semicolon
id|drive-&gt;waiting_for_dma
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ide_dma_setup
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_dma_setup
)paren
suffix:semicolon
DECL|function|ide_dma_exec_cmd
r_static
r_void
id|ide_dma_exec_cmd
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|command
)paren
(brace
multiline_comment|/* issue cmd to drive */
id|ide_execute_command
c_func
(paren
id|drive
comma
id|command
comma
op_amp
id|ide_dma_intr
comma
l_int|2
op_star
id|WAIT_CMD
comma
id|dma_timer_expiry
)paren
suffix:semicolon
)brace
DECL|function|ide_dma_start
r_void
id|ide_dma_start
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|dma_cmd
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hwif-&gt;dma_command
)paren
suffix:semicolon
multiline_comment|/* Note that this is done *after* the cmd has&n;&t; * been issued to the drive, as per the BM-IDE spec.&n;&t; * The Promise Ultra33 doesn&squot;t work correctly when&n;&t; * we do this part before issuing the drive cmd.&n;&t; */
multiline_comment|/* start DMA */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|dma_cmd
op_or
l_int|1
comma
id|hwif-&gt;dma_command
)paren
suffix:semicolon
id|hwif-&gt;dma
op_assign
l_int|1
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|ide_dma_start
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_dma_start
)paren
suffix:semicolon
multiline_comment|/* returns 1 on error, 0 otherwise */
DECL|function|__ide_dma_end
r_int
id|__ide_dma_end
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|dma_stat
op_assign
l_int|0
comma
id|dma_cmd
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;waiting_for_dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get dma_command mode */
id|dma_cmd
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hwif-&gt;dma_command
)paren
suffix:semicolon
multiline_comment|/* stop DMA */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|dma_cmd
op_amp
op_complement
l_int|1
comma
id|hwif-&gt;dma_command
)paren
suffix:semicolon
multiline_comment|/* get DMA status */
id|dma_stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hwif-&gt;dma_status
)paren
suffix:semicolon
multiline_comment|/* clear the INTR &amp; ERROR bits */
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|dma_stat
op_or
l_int|6
comma
id|hwif-&gt;dma_status
)paren
suffix:semicolon
multiline_comment|/* purge DMA mappings */
id|ide_destroy_dmatable
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* verify good DMA status */
id|hwif-&gt;dma
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|dma_stat
op_amp
l_int|7
)paren
op_ne
l_int|4
ques
c_cond
(paren
l_int|0x10
op_or
id|dma_stat
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|variable|__ide_dma_end
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_dma_end
)paren
suffix:semicolon
multiline_comment|/* returns 1 if dma irq issued, 0 otherwise */
DECL|function|__ide_dma_test_irq
r_static
r_int
id|__ide_dma_test_irq
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|u8
id|dma_stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hwif-&gt;dma_status
)paren
suffix:semicolon
macro_line|#if 0  /* do not set unless you know what you are doing */
r_if
c_cond
(paren
id|dma_stat
op_amp
l_int|4
)paren
(brace
id|u8
id|stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|IDE_STATUS_REG
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|OUTB
c_func
(paren
id|hwif-&gt;dma_status
comma
id|dma_stat
op_amp
l_int|0xE4
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* return 1 if INTR asserted */
r_if
c_cond
(paren
(paren
id|dma_stat
op_amp
l_int|4
)paren
op_eq
l_int|4
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;waiting_for_dma
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: (%s) called while not waiting&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
DECL|function|__ide_dma_bad_drive
r_int
id|__ide_dma_bad_drive
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_int
id|blacklist
op_assign
id|in_drive_list
c_func
(paren
id|id
comma
id|drive_blacklist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blacklist
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Disabling (U)DMA for %s (blacklisted)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|id-&gt;model
)paren
suffix:semicolon
r_return
id|blacklist
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|__ide_dma_bad_drive
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_dma_bad_drive
)paren
suffix:semicolon
DECL|function|__ide_dma_good_drive
r_int
id|__ide_dma_good_drive
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_return
id|in_drive_list
c_func
(paren
id|id
comma
id|drive_whitelist
)paren
suffix:semicolon
)brace
DECL|variable|__ide_dma_good_drive
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_dma_good_drive
)paren
suffix:semicolon
DECL|function|ide_use_dma
r_int
id|ide_use_dma
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|drive-&gt;hwif
suffix:semicolon
multiline_comment|/* consult the list of known &quot;bad&quot; drives */
r_if
c_cond
(paren
id|__ide_dma_bad_drive
c_func
(paren
id|drive
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* capable of UltraDMA modes */
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;ultra_mask
op_amp
id|id-&gt;dma_ultra
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* capable of regular DMA modes */
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;mwdma_mask
op_amp
id|id-&gt;dma_mword
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;swdma_mask
op_amp
id|id-&gt;dma_1word
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* consult the list of known &quot;good&quot; drives */
r_if
c_cond
(paren
id|__ide_dma_good_drive
c_func
(paren
id|drive
)paren
op_logical_and
id|id-&gt;eide_dma_time
OL
l_int|150
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ide_use_dma
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_use_dma
)paren
suffix:semicolon
DECL|function|ide_dma_verbose
r_void
id|ide_dma_verbose
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|8
)paren
op_logical_and
(paren
id|id-&gt;dma_mword
op_rshift
l_int|8
)paren
)paren
r_goto
id|bug_dma_off
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;dma_ultra
op_amp
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|8
)paren
op_amp
id|hwif-&gt;ultra_mask
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|11
)paren
op_amp
l_int|0x1F
)paren
op_logical_and
id|eighty_ninty_three
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|15
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(mode 7)&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|14
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(133)&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|13
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(100)&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|12
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(66)&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|11
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(44)&quot;
)paren
suffix:semicolon
)brace
r_else
r_goto
id|mode_two
suffix:semicolon
)brace
r_else
(brace
id|mode_two
suffix:colon
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|10
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(33)&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|9
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(25)&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|8
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, UDMA(16)&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, (U)DMA&quot;
)paren
suffix:semicolon
multiline_comment|/* Can be BIOS-enabled! */
)brace
)brace
r_else
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;dma_mword
op_rshift
l_int|8
)paren
op_logical_and
(paren
id|id-&gt;dma_1word
op_rshift
l_int|8
)paren
)paren
r_goto
id|bug_dma_off
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, DMA&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, BUG&quot;
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|bug_dma_off
suffix:colon
id|printk
c_func
(paren
l_string|&quot;, BUG DMA OFF&quot;
)paren
suffix:semicolon
id|hwif
op_member_access_from_pointer
id|ide_dma_off_quietly
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|ide_dma_verbose
id|EXPORT_SYMBOL
c_func
(paren
id|ide_dma_verbose
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
DECL|function|__ide_dma_lostirq
r_int
id|__ide_dma_lostirq
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DMA interrupt recovery&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|__ide_dma_lostirq
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_dma_lostirq
)paren
suffix:semicolon
DECL|function|__ide_dma_timeout
r_int
id|__ide_dma_timeout
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: timeout waiting for DMA&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_test_irq
c_func
(paren
id|drive
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|ide_dma_end
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
DECL|variable|__ide_dma_timeout
id|EXPORT_SYMBOL
c_func
(paren
id|__ide_dma_timeout
)paren
suffix:semicolon
multiline_comment|/*&n; * Needed for allowing full modular support of ide-driver&n; */
DECL|function|ide_release_dma_engine
r_static
r_int
id|ide_release_dma_engine
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;dmatable_cpu
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hwif-&gt;pci_dev
comma
id|PRD_ENTRIES
op_star
id|PRD_BYTES
comma
id|hwif-&gt;dmatable_cpu
comma
id|hwif-&gt;dmatable_dma
)paren
suffix:semicolon
id|hwif-&gt;dmatable_cpu
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ide_release_iomio_dma
r_static
r_int
id|ide_release_iomio_dma
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_if
c_cond
(paren
(paren
id|hwif-&gt;dma_extra
)paren
op_logical_and
(paren
id|hwif-&gt;channel
op_eq
l_int|0
)paren
)paren
id|release_region
c_func
(paren
(paren
id|hwif-&gt;dma_base
op_plus
l_int|16
)paren
comma
id|hwif-&gt;dma_extra
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|hwif-&gt;dma_base
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;dma_base2
)paren
id|release_region
c_func
(paren
id|hwif-&gt;dma_base
comma
l_int|8
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Needed for allowing full modular support of ide-driver&n; */
DECL|function|ide_release_dma
r_int
id|ide_release_dma
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;mmio
op_eq
l_int|2
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_etrax100
)paren
r_return
l_int|1
suffix:semicolon
id|ide_release_dma_engine
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_return
id|ide_release_iomio_dma
c_func
(paren
id|hwif
)paren
suffix:semicolon
)brace
DECL|function|ide_allocate_dma_engine
r_static
r_int
id|ide_allocate_dma_engine
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
id|hwif-&gt;dmatable_cpu
op_assign
id|pci_alloc_consistent
c_func
(paren
id|hwif-&gt;pci_dev
comma
id|PRD_ENTRIES
op_star
id|PRD_BYTES
comma
op_amp
id|hwif-&gt;dmatable_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;dmatable_cpu
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: -- Error, unable to allocate%s DMA table(s).&bslash;n&quot;
comma
(paren
id|hwif-&gt;dmatable_cpu
op_eq
l_int|NULL
)paren
ques
c_cond
l_string|&quot; CPU&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|hwif-&gt;cds-&gt;name
)paren
suffix:semicolon
id|ide_release_dma_engine
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ide_mapped_mmio_dma
r_static
r_int
id|ide_mapped_mmio_dma
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
r_int
id|base
comma
r_int
r_int
id|ports
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    %s: MMIO-DMA &quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
id|hwif-&gt;dma_base
op_assign
id|base
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;cds-&gt;extra
op_logical_and
id|hwif-&gt;channel
op_eq
l_int|0
)paren
id|hwif-&gt;dma_extra
op_assign
id|hwif-&gt;cds-&gt;extra
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;mate
)paren
(brace
id|hwif-&gt;dma_master
op_assign
(paren
id|hwif-&gt;channel
)paren
ques
c_cond
id|hwif-&gt;mate-&gt;dma_base
suffix:colon
id|base
suffix:semicolon
)brace
r_else
id|hwif-&gt;dma_master
op_assign
id|base
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_iomio_dma
r_static
r_int
id|ide_iomio_dma
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
r_int
id|base
comma
r_int
r_int
id|ports
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    %s: BM-DMA at 0x%04lx-0x%04lx&quot;
comma
id|hwif-&gt;name
comma
id|base
comma
id|base
op_plus
id|ports
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|base
comma
id|ports
comma
id|hwif-&gt;name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; -- Error, ports in use.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|hwif-&gt;dma_base
op_assign
id|base
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hwif-&gt;cds-&gt;extra
)paren
op_logical_and
(paren
id|hwif-&gt;channel
op_eq
l_int|0
)paren
)paren
(brace
id|request_region
c_func
(paren
id|base
op_plus
l_int|16
comma
id|hwif-&gt;cds-&gt;extra
comma
id|hwif-&gt;cds-&gt;name
)paren
suffix:semicolon
id|hwif-&gt;dma_extra
op_assign
id|hwif-&gt;cds-&gt;extra
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwif-&gt;mate
)paren
(brace
id|hwif-&gt;dma_master
op_assign
(paren
id|hwif-&gt;channel
)paren
ques
c_cond
id|hwif-&gt;mate-&gt;dma_base
suffix:colon
id|base
suffix:semicolon
)brace
r_else
id|hwif-&gt;dma_master
op_assign
id|base
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;dma_base2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|hwif-&gt;dma_base2
comma
id|ports
comma
id|hwif-&gt;name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; -- Error, secondary ports in use.&bslash;n&quot;
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|base
comma
id|ports
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_dma_iobase
r_static
r_int
id|ide_dma_iobase
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
r_int
id|base
comma
r_int
r_int
id|ports
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;mmio
op_eq
l_int|2
)paren
r_return
id|ide_mapped_mmio_dma
c_func
(paren
id|hwif
comma
id|base
comma
id|ports
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|hwif-&gt;mmio
op_eq
l_int|1
)paren
suffix:semicolon
r_return
id|ide_iomio_dma
c_func
(paren
id|hwif
comma
id|base
comma
id|ports
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This can be called for a dynamically installed interface. Don&squot;t __init it&n; */
DECL|function|ide_setup_dma
r_void
id|ide_setup_dma
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
r_int
id|dma_base
comma
r_int
r_int
id|num_ports
)paren
(brace
r_if
c_cond
(paren
id|ide_dma_iobase
c_func
(paren
id|hwif
comma
id|dma_base
comma
id|num_ports
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ide_allocate_dma_engine
c_func
(paren
id|hwif
)paren
)paren
(brace
id|ide_release_dma
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hwif-&gt;dma_command
)paren
)paren
id|hwif-&gt;dma_command
op_assign
id|hwif-&gt;dma_base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hwif-&gt;dma_vendor1
)paren
)paren
id|hwif-&gt;dma_vendor1
op_assign
(paren
id|hwif-&gt;dma_base
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hwif-&gt;dma_status
)paren
)paren
id|hwif-&gt;dma_status
op_assign
(paren
id|hwif-&gt;dma_base
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hwif-&gt;dma_vendor3
)paren
)paren
id|hwif-&gt;dma_vendor3
op_assign
(paren
id|hwif-&gt;dma_base
op_plus
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hwif-&gt;dma_prdtable
)paren
)paren
id|hwif-&gt;dma_prdtable
op_assign
(paren
id|hwif-&gt;dma_base
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;ide_dma_off_quietly
)paren
id|hwif-&gt;ide_dma_off_quietly
op_assign
op_amp
id|__ide_dma_off_quietly
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;ide_dma_host_off
)paren
id|hwif-&gt;ide_dma_host_off
op_assign
op_amp
id|__ide_dma_host_off
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;ide_dma_on
)paren
id|hwif-&gt;ide_dma_on
op_assign
op_amp
id|__ide_dma_on
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;ide_dma_host_on
)paren
id|hwif-&gt;ide_dma_host_on
op_assign
op_amp
id|__ide_dma_host_on
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;ide_dma_check
)paren
id|hwif-&gt;ide_dma_check
op_assign
op_amp
id|__ide_dma_check
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;dma_setup
)paren
id|hwif-&gt;dma_setup
op_assign
op_amp
id|ide_dma_setup
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;dma_exec_cmd
)paren
id|hwif-&gt;dma_exec_cmd
op_assign
op_amp
id|ide_dma_exec_cmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;dma_start
)paren
id|hwif-&gt;dma_start
op_assign
op_amp
id|ide_dma_start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;ide_dma_end
)paren
id|hwif-&gt;ide_dma_end
op_assign
op_amp
id|__ide_dma_end
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;ide_dma_test_irq
)paren
id|hwif-&gt;ide_dma_test_irq
op_assign
op_amp
id|__ide_dma_test_irq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;ide_dma_timeout
)paren
id|hwif-&gt;ide_dma_timeout
op_assign
op_amp
id|__ide_dma_timeout
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;ide_dma_lostirq
)paren
id|hwif-&gt;ide_dma_lostirq
op_assign
op_amp
id|__ide_dma_lostirq
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_ne
id|ide_trm290
)paren
(brace
id|u8
id|dma_stat
op_assign
id|hwif
op_member_access_from_pointer
id|INB
c_func
(paren
id|hwif-&gt;dma_status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, BIOS settings: %s:%s, %s:%s&quot;
comma
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|name
comma
(paren
id|dma_stat
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;DMA&quot;
suffix:colon
l_string|&quot;pio&quot;
comma
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|name
comma
(paren
id|dma_stat
op_amp
l_int|0x40
)paren
ques
c_cond
l_string|&quot;DMA&quot;
suffix:colon
l_string|&quot;pio&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hwif-&gt;dma_master
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|ide_setup_dma
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ide_setup_dma
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
eof
