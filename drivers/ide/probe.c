multiline_comment|/**** vi:set ts=8 sts=8 sw=8:************************************************&n; *&n; *  Copyright (C) 1994-1998  Linus Torvalds &amp; authors (see below)&n; *&n; *  Mostly written by Mark Lord &lt;mlord@pobox.com&gt;&n; *                and Gadi Oxman &lt;gadio@netvision.net.il&gt;&n; *                and Andre Hedrick &lt;andre@linux-ide.org&gt;&n; *&n; *  See linux/MAINTAINERS for address of current maintainer.&n; *&n; */
multiline_comment|/*&n; * This is roughly the code related to device detection and&n; * device id handling.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
r_extern
r_struct
id|ata_device
op_star
id|get_info_ptr
c_func
(paren
id|kdev_t
)paren
suffix:semicolon
multiline_comment|/*&n; * This is called from the partition-table code in pt/msdos.c.&n; *&n; * It has two tasks:&n; *&n; * (I) to handle Ontrack DiskManager by offsetting everything by 63 sectors,&n; *  or to handle EZdrive by remapping sector 0 to sector 1.&n; *&n; * (II) to invent a translated geometry.&n; *&n; * Part (I) is suppressed if the user specifies the &quot;noremap&quot; option&n; * on the command line.&n; *&n; * Part (II) is suppressed if the user specifies an explicit geometry.&n; *&n; * The ptheads parameter is either 0 or tells about the number of&n; * heads shown by the end of the first nonempty partition.&n; * If this is either 16, 32, 64, 128, 240 or 255 we&squot;ll believe it.&n; *&n; * The xparm parameter has the following meaning:&n; *&t; 0 = convert to CHS with fewer than 1024 cyls&n; *&t;     using the same method as Ontrack DiskManager.&n; *&t; 1 = same as &quot;0&quot;, plus offset everything by 63 sectors.&n; *&t;-1 = similar to &quot;0&quot;, plus redirect sector 0 to sector 1.&n; *&t; 2 = convert to a CHS geometry with &quot;ptheads&quot; heads.&n; *&n; * Returns 0 if the translation was not possible, if the device was not&n; * an IDE disk drive, or if a geometry was &quot;forced&quot; on the commandline.&n; * Returns 1 if the geometry translation was successful.&n; */
DECL|function|ide_xlate_1024
r_int
id|ide_xlate_1024
c_func
(paren
id|kdev_t
id|i_rdev
comma
r_int
id|xparm
comma
r_int
id|ptheads
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
suffix:semicolon
r_const
r_char
op_star
id|msg1
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_int
id|heads
op_assign
l_int|0
suffix:semicolon
r_int
id|c
comma
id|h
comma
id|s
suffix:semicolon
r_int
id|transl
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* try translation */
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* remap? */
r_if
c_cond
(paren
id|drive-&gt;remap_0_to_1
op_ne
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|xparm
op_eq
l_int|1
)paren
(brace
multiline_comment|/* DM */
id|drive-&gt;sect0
op_assign
l_int|63
suffix:semicolon
id|msg1
op_assign
l_string|&quot; [remap +63]&quot;
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xparm
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* EZ-Drive */
r_if
c_cond
(paren
id|drive-&gt;remap_0_to_1
op_eq
l_int|0
)paren
(brace
id|drive-&gt;remap_0_to_1
op_assign
l_int|1
suffix:semicolon
id|msg1
op_assign
l_string|&quot; [remap 0-&gt;1]&quot;
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* There used to be code here that assigned drive-&gt;id-&gt;CHS&n;&t;   to drive-&gt;CHS and that to drive-&gt;bios_CHS. However, some disks have&n;&t;   id-&gt;C/H/S = 4092/16/63 but are larger than 2.1 GB.  In such cases&n;&t;   that code was wrong.  Moreover, there seems to be no reason to do&n;&t;   any of these things. */
multiline_comment|/* translate? */
r_if
c_cond
(paren
id|drive-&gt;forced_geom
)paren
id|transl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* does ptheads look reasonable? */
r_if
c_cond
(paren
id|ptheads
op_eq
l_int|32
op_logical_or
id|ptheads
op_eq
l_int|64
op_logical_or
id|ptheads
op_eq
l_int|128
op_logical_or
id|ptheads
op_eq
l_int|240
op_logical_or
id|ptheads
op_eq
l_int|255
)paren
id|heads
op_assign
id|ptheads
suffix:semicolon
r_if
c_cond
(paren
id|xparm
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|heads
op_logical_or
(paren
id|drive-&gt;bios_head
op_ge
id|heads
op_logical_and
id|drive-&gt;bios_sect
op_eq
l_int|63
)paren
)paren
id|transl
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xparm
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;bios_head
OG
l_int|16
)paren
id|transl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we already have a translation */
)brace
r_if
c_cond
(paren
id|transl
)paren
(brace
r_static
r_const
id|u8
id|dm_head_vals
(braket
)braket
op_assign
(brace
l_int|4
comma
l_int|8
comma
l_int|16
comma
l_int|32
comma
l_int|64
comma
l_int|128
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
r_const
id|u8
op_star
id|headp
op_assign
id|dm_head_vals
suffix:semicolon
r_int
r_int
id|total
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If heads is nonzero: find a translation with this many heads&n;&t;&t; * and S=63.  Otherwise: find out how OnTrack Disk Manager&n;&t;&t; * would translate the disk.&n;&t;&t; *&n;&t;&t; * The specs say: take geometry as obtained from Identify,&n;&t;&t; * compute total capacity C*H*S from that, and truncate to&n;&t;&t; * 1024*255*63. Now take S=63, H the first in the sequence 4,&n;&t;&t; * 8, 16, 32, 64, 128, 255 such that 63*H*1024 &gt;= total.&n;&t;&t; * [Please tell aeb@cwi.nl in case this computes a geometry&n;&t;&t; * different from what OnTrack uses.]&n;&t;&t; */
id|total
op_assign
id|ata_capacity
c_func
(paren
id|drive
)paren
suffix:semicolon
id|s
op_assign
l_int|63
suffix:semicolon
r_if
c_cond
(paren
id|heads
)paren
(brace
id|h
op_assign
id|heads
suffix:semicolon
id|c
op_assign
id|total
op_div
(paren
l_int|63
op_star
id|heads
)paren
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
l_int|63
op_star
id|headp
(braket
l_int|0
)braket
op_star
l_int|1024
OL
id|total
op_logical_and
id|headp
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
id|headp
op_increment
suffix:semicolon
id|h
op_assign
id|headp
(braket
l_int|0
)braket
suffix:semicolon
id|c
op_assign
id|total
op_div
(paren
l_int|63
op_star
id|headp
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
id|drive-&gt;bios_cyl
op_assign
id|c
suffix:semicolon
id|drive-&gt;bios_head
op_assign
id|h
suffix:semicolon
id|drive-&gt;bios_sect
op_assign
id|s
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|drive-&gt;part
(braket
l_int|0
)braket
dot
id|nr_sects
op_assign
id|ata_capacity
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|printk
c_func
(paren
l_string|&quot;%s%s [%d/%d/%d]&quot;
comma
id|msg
comma
id|msg1
comma
id|drive-&gt;bios_cyl
comma
id|drive-&gt;bios_head
comma
id|drive-&gt;bios_sect
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * hd_driveid data come as little endian, it needs to be converted on big&n; * endian machines.&n; */
DECL|function|ata_fix_driveid
r_void
id|ata_fix_driveid
c_func
(paren
r_struct
id|hd_driveid
op_star
id|id
)paren
(brace
macro_line|#ifndef __LITTLE_ENDIAN
macro_line|# ifdef __BIG_ENDIAN
r_int
id|i
suffix:semicolon
id|u16
op_star
id|stringcast
suffix:semicolon
id|id-&gt;config
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;config
)paren
suffix:semicolon
id|id-&gt;cyls
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;cyls
)paren
suffix:semicolon
id|id-&gt;reserved2
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;reserved2
)paren
suffix:semicolon
id|id-&gt;heads
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;heads
)paren
suffix:semicolon
id|id-&gt;track_bytes
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;track_bytes
)paren
suffix:semicolon
id|id-&gt;sector_bytes
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;sector_bytes
)paren
suffix:semicolon
id|id-&gt;sectors
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;sectors
)paren
suffix:semicolon
id|id-&gt;vendor0
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;vendor0
)paren
suffix:semicolon
id|id-&gt;vendor1
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;vendor1
)paren
suffix:semicolon
id|id-&gt;vendor2
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;vendor2
)paren
suffix:semicolon
id|stringcast
op_assign
(paren
id|u16
op_star
)paren
op_amp
id|id-&gt;serial_no
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|20
op_div
l_int|2
)paren
suffix:semicolon
id|i
op_increment
)paren
id|stringcast
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|stringcast
(braket
id|i
)braket
)paren
suffix:semicolon
id|id-&gt;buf_type
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;buf_type
)paren
suffix:semicolon
id|id-&gt;buf_size
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;buf_size
)paren
suffix:semicolon
id|id-&gt;ecc_bytes
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;ecc_bytes
)paren
suffix:semicolon
id|stringcast
op_assign
(paren
id|u16
op_star
)paren
op_amp
id|id-&gt;fw_rev
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|8
op_div
l_int|2
)paren
suffix:semicolon
id|i
op_increment
)paren
id|stringcast
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|stringcast
(braket
id|i
)braket
)paren
suffix:semicolon
id|stringcast
op_assign
(paren
id|u16
op_star
)paren
op_amp
id|id-&gt;model
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|40
op_div
l_int|2
)paren
suffix:semicolon
id|i
op_increment
)paren
id|stringcast
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|stringcast
(braket
id|i
)braket
)paren
suffix:semicolon
id|id-&gt;dword_io
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;dword_io
)paren
suffix:semicolon
id|id-&gt;reserved50
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;reserved50
)paren
suffix:semicolon
id|id-&gt;field_valid
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;field_valid
)paren
suffix:semicolon
id|id-&gt;cur_cyls
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;cur_cyls
)paren
suffix:semicolon
id|id-&gt;cur_heads
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;cur_heads
)paren
suffix:semicolon
id|id-&gt;cur_sectors
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;cur_sectors
)paren
suffix:semicolon
id|id-&gt;cur_capacity0
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;cur_capacity0
)paren
suffix:semicolon
id|id-&gt;cur_capacity1
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;cur_capacity1
)paren
suffix:semicolon
id|id-&gt;lba_capacity
op_assign
id|__le32_to_cpu
c_func
(paren
id|id-&gt;lba_capacity
)paren
suffix:semicolon
id|id-&gt;dma_1word
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;dma_1word
)paren
suffix:semicolon
id|id-&gt;dma_mword
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;dma_mword
)paren
suffix:semicolon
id|id-&gt;eide_pio_modes
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;eide_pio_modes
)paren
suffix:semicolon
id|id-&gt;eide_dma_min
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;eide_dma_min
)paren
suffix:semicolon
id|id-&gt;eide_dma_time
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;eide_dma_time
)paren
suffix:semicolon
id|id-&gt;eide_pio
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;eide_pio
)paren
suffix:semicolon
id|id-&gt;eide_pio_iordy
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;eide_pio_iordy
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
op_increment
id|i
)paren
id|id-&gt;words69_70
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;words69_70
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
id|id-&gt;words71_74
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;words71_74
(braket
id|i
)braket
)paren
suffix:semicolon
id|id-&gt;queue_depth
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;queue_depth
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
id|id-&gt;words76_79
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;words76_79
(braket
id|i
)braket
)paren
suffix:semicolon
id|id-&gt;major_rev_num
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;major_rev_num
)paren
suffix:semicolon
id|id-&gt;minor_rev_num
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;minor_rev_num
)paren
suffix:semicolon
id|id-&gt;command_set_1
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;command_set_1
)paren
suffix:semicolon
id|id-&gt;command_set_2
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;command_set_2
)paren
suffix:semicolon
id|id-&gt;cfsse
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;cfsse
)paren
suffix:semicolon
id|id-&gt;cfs_enable_1
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;cfs_enable_1
)paren
suffix:semicolon
id|id-&gt;cfs_enable_2
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;cfs_enable_2
)paren
suffix:semicolon
id|id-&gt;csf_default
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;csf_default
)paren
suffix:semicolon
id|id-&gt;dma_ultra
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;dma_ultra
)paren
suffix:semicolon
id|id-&gt;word89
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;word89
)paren
suffix:semicolon
id|id-&gt;word90
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;word90
)paren
suffix:semicolon
id|id-&gt;CurAPMvalues
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;CurAPMvalues
)paren
suffix:semicolon
id|id-&gt;word92
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;word92
)paren
suffix:semicolon
id|id-&gt;hw_config
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;hw_config
)paren
suffix:semicolon
id|id-&gt;acoustic
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;acoustic
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|id-&gt;words95_99
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;words95_99
(braket
id|i
)braket
)paren
suffix:semicolon
id|id-&gt;lba_capacity_2
op_assign
id|__le64_to_cpu
c_func
(paren
id|id-&gt;lba_capacity_2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|22
suffix:semicolon
id|i
op_increment
)paren
id|id-&gt;words104_125
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;words104_125
(braket
id|i
)braket
)paren
suffix:semicolon
id|id-&gt;last_lun
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;last_lun
)paren
suffix:semicolon
id|id-&gt;word127
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;word127
)paren
suffix:semicolon
id|id-&gt;dlf
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;dlf
)paren
suffix:semicolon
id|id-&gt;csfo
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;csfo
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|26
suffix:semicolon
id|i
op_increment
)paren
id|id-&gt;words130_155
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;words130_155
(braket
id|i
)braket
)paren
suffix:semicolon
id|id-&gt;word156
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;word156
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|id-&gt;words157_159
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;words157_159
(braket
id|i
)braket
)paren
suffix:semicolon
id|id-&gt;cfa_power
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;cfa_power
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|14
suffix:semicolon
id|i
op_increment
)paren
id|id-&gt;words161_175
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;words161_175
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|31
suffix:semicolon
id|i
op_increment
)paren
id|id-&gt;words176_205
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;words176_205
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|48
suffix:semicolon
id|i
op_increment
)paren
id|id-&gt;words206_254
(braket
id|i
)braket
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;words206_254
(braket
id|i
)braket
)paren
suffix:semicolon
id|id-&gt;integrity_word
op_assign
id|__le16_to_cpu
c_func
(paren
id|id-&gt;integrity_word
)paren
suffix:semicolon
macro_line|# else
macro_line|#  error &quot;Please fix &lt;asm/byteorder.h&gt;&quot;
macro_line|# endif
macro_line|#endif
)brace
DECL|function|ide_fixstring
r_void
id|ide_fixstring
c_func
(paren
r_char
op_star
id|s
comma
r_const
r_int
id|bytecount
comma
r_const
r_int
id|byteswap
)paren
(brace
r_char
op_star
id|p
op_assign
id|s
suffix:semicolon
r_char
op_star
id|end
op_assign
op_amp
id|s
(braket
id|bytecount
op_amp
op_complement
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bytecount must be even */
r_if
c_cond
(paren
id|byteswap
)paren
(brace
multiline_comment|/* convert from big-endian to host byte order */
r_for
c_loop
(paren
id|p
op_assign
id|end
suffix:semicolon
id|p
op_ne
id|s
suffix:semicolon
)paren
(brace
r_int
r_int
op_star
id|pp
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|p
op_sub_assign
l_int|2
)paren
suffix:semicolon
op_star
id|pp
op_assign
id|ntohs
c_func
(paren
op_star
id|pp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* strip leading blanks */
r_while
c_loop
(paren
id|s
op_ne
id|end
op_logical_and
op_star
id|s
op_eq
l_char|&squot; &squot;
)paren
op_increment
id|s
suffix:semicolon
multiline_comment|/* compress internal blanks and strip trailing blanks */
r_while
c_loop
(paren
id|s
op_ne
id|end
op_logical_and
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
op_star
id|s
op_increment
op_ne
l_char|&squot; &squot;
op_logical_or
(paren
id|s
op_ne
id|end
op_logical_and
op_star
id|s
op_logical_and
op_star
id|s
op_ne
l_char|&squot; &squot;
)paren
)paren
op_star
id|p
op_increment
op_assign
op_star
(paren
id|s
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* wipe out trailing garbage */
r_while
c_loop
(paren
id|p
op_ne
id|end
)paren
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
multiline_comment|/*&n; *  All hosts that use the 80c ribbon must use this!&n; */
DECL|function|eighty_ninty_three
id|byte
id|eighty_ninty_three
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_return
(paren
(paren
id|u8
)paren
(paren
(paren
id|drive-&gt;channel-&gt;udma_four
)paren
op_logical_and
macro_line|#ifndef CONFIG_IDEDMA_IVB
(paren
id|drive-&gt;id-&gt;hw_config
op_amp
l_int|0x4000
)paren
op_logical_and
macro_line|#endif
(paren
id|drive-&gt;id-&gt;hw_config
op_amp
l_int|0x6000
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: Channel lock should be held.&n; */
DECL|function|ide_config_drive_speed
r_int
id|ide_config_drive_speed
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
id|byte
id|speed
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|error
op_assign
l_int|1
suffix:semicolon
macro_line|#if defined(CONFIG_BLK_DEV_IDEDMA) &amp;&amp; !defined(__CRIS__)
id|u8
id|unit
op_assign
(paren
id|drive-&gt;select.b.unit
op_amp
l_int|0x01
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|ch-&gt;dma_base
op_plus
l_int|2
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
(paren
l_int|5
op_plus
id|unit
)paren
)paren
comma
id|ch-&gt;dma_base
op_plus
l_int|2
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Don&squot;t use ide_wait_cmd here - it will attempt to set_geometry and&n;&t; * recalibrate, but for some reason these don&squot;t work at this point&n;&t; * (lost interrupt).&n;         *&n;         * Select the drive, and issue the SETFEATURES command&n;         */
id|disable_irq
c_func
(paren
id|ch-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* disable_irq_nosync ?? */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|ata_select
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|ata_mask
c_func
(paren
id|drive
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|ata_irq_enable
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|speed
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|SETFEATURES_XFER
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|WIN_SETFEATURES
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;quirk_list
op_eq
l_int|2
)paren
id|ata_irq_enable
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|ata_busy_poll
c_func
(paren
id|drive
comma
id|WAIT_CMD
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allow status to settle, then read it again.&n;&t; * A few rare drives vastly violate the 400ns spec here,&n;&t; * so we&squot;ll wait up to 10usec for a &quot;good&quot; status&n;&t; * rather than expensively fail things immediately.&n;&t; * This fix courtesy of Matthew Faupel &amp; Niccolo Rigacci.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_status
c_func
(paren
id|drive
comma
id|DRIVE_READY
comma
id|BUSY_STAT
op_or
id|DRQ_STAT
op_or
id|ERR_STAT
)paren
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|ata_mask
c_func
(paren
id|drive
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|ch-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ata_dump
c_func
(paren
id|drive
comma
l_int|NULL
comma
l_string|&quot;set drive speed&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|drive-&gt;id-&gt;dma_ultra
op_and_assign
op_complement
l_int|0xFF00
suffix:semicolon
id|drive-&gt;id-&gt;dma_mword
op_and_assign
op_complement
l_int|0x0F00
suffix:semicolon
id|drive-&gt;id-&gt;dma_1word
op_and_assign
op_complement
l_int|0x0F00
suffix:semicolon
macro_line|#if defined(CONFIG_BLK_DEV_IDEDMA) &amp;&amp; !defined(__CRIS__)
r_if
c_cond
(paren
id|speed
OG
id|XFER_PIO_4
)paren
(brace
id|outb
c_func
(paren
id|inb
c_func
(paren
id|ch-&gt;dma_base
op_plus
l_int|2
)paren
op_or
(paren
l_int|1
op_lshift
(paren
l_int|5
op_plus
id|unit
)paren
)paren
comma
id|ch-&gt;dma_base
op_plus
l_int|2
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|inb
c_func
(paren
id|ch-&gt;dma_base
op_plus
l_int|2
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
(paren
l_int|5
op_plus
id|unit
)paren
)paren
comma
id|ch-&gt;dma_base
op_plus
l_int|2
)paren
suffix:semicolon
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|speed
)paren
(brace
r_case
id|XFER_UDMA_7
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x8080
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_6
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x4040
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_5
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x2020
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_4
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x1010
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_3
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0808
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_2
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0404
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_1
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0202
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_UDMA_0
suffix:colon
id|drive-&gt;id-&gt;dma_ultra
op_or_assign
l_int|0x0101
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_2
suffix:colon
id|drive-&gt;id-&gt;dma_mword
op_or_assign
l_int|0x0404
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_1
suffix:colon
id|drive-&gt;id-&gt;dma_mword
op_or_assign
l_int|0x0202
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_MW_DMA_0
suffix:colon
id|drive-&gt;id-&gt;dma_mword
op_or_assign
l_int|0x0101
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_2
suffix:colon
id|drive-&gt;id-&gt;dma_1word
op_or_assign
l_int|0x0404
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_1
suffix:colon
id|drive-&gt;id-&gt;dma_1word
op_or_assign
l_int|0x0202
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFER_SW_DMA_0
suffix:colon
id|drive-&gt;id-&gt;dma_1word
op_or_assign
l_int|0x0101
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_identify
r_static
r_inline
r_void
id|do_identify
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
id|u8
id|cmd
)paren
(brace
r_int
id|bswap
op_assign
l_int|1
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
suffix:semicolon
id|id
op_assign
id|drive-&gt;id
op_assign
id|kmalloc
(paren
id|SECTOR_WORDS
op_star
l_int|4
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* called with interrupts disabled! */
r_if
c_cond
(paren
op_logical_neg
id|id
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(ide-probe::do_identify) Out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_kmalloc
suffix:semicolon
)brace
multiline_comment|/* Read 512 bytes of id info.&n;&t; *&n;&t; * Please note that it is well known that some *very* old drives are&n;&t; * able to provide only 256 of them, since this was the amount read by&n;&t; * DOS.&n;&t; *&n;&t; * However let&squot;s try to get away with this...&n;&t; */
id|ata_read
c_func
(paren
id|drive
comma
id|id
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|ata_fix_driveid
c_func
(paren
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;word156
op_eq
l_int|0x4d42
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: drive-&gt;id-&gt;word156 == 0x%04x &bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;id-&gt;word156
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;forced_lun
)paren
id|drive-&gt;last_lun
op_assign
id|id-&gt;last_lun
op_amp
l_int|0x7
suffix:semicolon
macro_line|#if defined (CONFIG_SCSI_EATA_DMA) || defined (CONFIG_SCSI_EATA_PIO) || defined (CONFIG_SCSI_EATA)
multiline_comment|/*&n;&t; * EATA SCSI controllers do a hardware ATA emulation:&n;&t; * Ignore them if there is a driver for them available.&n;&t; */
r_if
c_cond
(paren
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;P&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;M&squot;
)paren
op_logical_or
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;S&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;K&squot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: EATA SCSI HBA %.10s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|id-&gt;model
)paren
suffix:semicolon
r_goto
id|err_misc
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *  WIN_IDENTIFY returns little-endian info,&n;&t; *  WIN_PIDENTIFY *usually* returns little-endian info.&n;&t; */
r_if
c_cond
(paren
id|cmd
op_eq
id|WIN_PIDENTIFY
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;N&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;E&squot;
)paren
multiline_comment|/* NEC */
op_logical_or
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;F&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;X&squot;
)paren
multiline_comment|/* Mitsumi */
op_logical_or
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;P&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;i&squot;
)paren
)paren
multiline_comment|/* Pioneer */
id|bswap
op_xor_assign
l_int|1
suffix:semicolon
multiline_comment|/* Vertos drives may still be weird */
)brace
id|ide_fixstring
c_func
(paren
id|id-&gt;model
comma
r_sizeof
(paren
id|id-&gt;model
)paren
comma
id|bswap
)paren
suffix:semicolon
id|ide_fixstring
c_func
(paren
id|id-&gt;fw_rev
comma
r_sizeof
(paren
id|id-&gt;fw_rev
)paren
comma
id|bswap
)paren
suffix:semicolon
id|ide_fixstring
c_func
(paren
id|id-&gt;serial_no
comma
r_sizeof
(paren
id|id-&gt;serial_no
)paren
comma
id|bswap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;E X A B Y T E N E S T&quot;
)paren
)paren
r_goto
id|err_misc
suffix:semicolon
id|id-&gt;model
(braket
r_sizeof
(paren
id|id-&gt;model
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* we depend on this a lot! */
id|printk
c_func
(paren
l_string|&quot;%s: %s, &quot;
comma
id|drive-&gt;name
comma
id|id-&gt;model
)paren
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Check for an ATAPI device:&n;&t; */
r_if
c_cond
(paren
id|cmd
op_eq
id|WIN_PIDENTIFY
)paren
(brace
id|u8
id|type
op_assign
(paren
id|id-&gt;config
op_rshift
l_int|8
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ATAPI &quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;unit
op_eq
l_int|1
op_logical_and
id|drive-&gt;channel-&gt;chipset
op_eq
id|ide_pdc4030
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; -- not supported on 2nd Promise port&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_misc
suffix:semicolon
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|ATA_FLOPPY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;CD-ROM&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;oppy&quot;
)paren
op_logical_and
op_logical_neg
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;poyp&quot;
)paren
op_logical_and
op_logical_neg
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;ZIP&quot;
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;cdrom or floppy?, assuming &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;type
op_ne
id|ATA_ROM
)paren
(brace
id|printk
(paren
l_string|&quot;FLOPPY&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|type
op_assign
id|ATA_ROM
suffix:semicolon
multiline_comment|/* Early cdrom models used zero */
r_case
id|ATA_ROM
suffix:colon
id|drive-&gt;removable
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_PPC
multiline_comment|/* kludge for Apple PowerBook internal zip */
r_if
c_cond
(paren
op_logical_neg
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;CD-ROM&quot;
)paren
op_logical_and
id|strstr
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;ZIP&quot;
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;FLOPPY&quot;
)paren
suffix:semicolon
id|type
op_assign
id|ATA_FLOPPY
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|printk
(paren
l_string|&quot;CD/DVD-ROM&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_TAPE
suffix:colon
id|printk
(paren
l_string|&quot;TAPE&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_MOD
suffix:colon
id|printk
(paren
l_string|&quot;OPTICAL&quot;
)paren
suffix:semicolon
id|drive-&gt;removable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UNKNOWN (type %d)&quot;
comma
id|type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot; drive&bslash;n&quot;
)paren
suffix:semicolon
id|drive-&gt;type
op_assign
id|type
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Not an ATAPI device: looks like a &quot;regular&quot; hard disk:&n;&t; */
r_if
c_cond
(paren
id|id-&gt;config
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
id|drive-&gt;removable
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: This is just plain ugly or plain unnecessary.&n;&t; *&n;&t; * Prevent long system lockup probing later for non-existant slave&n;&t; * drive if the hwif is actually a flash memory card of some variety:&n;&t; */
r_if
c_cond
(paren
id|drive_is_flashcard
c_func
(paren
id|drive
)paren
)paren
(brace
r_struct
id|ata_device
op_star
id|mate
op_assign
op_amp
id|drive-&gt;channel-&gt;drives
(braket
l_int|1
op_xor
id|drive-&gt;select.b.unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mate-&gt;ata_flash
)paren
(brace
id|mate-&gt;present
op_assign
l_int|0
suffix:semicolon
id|mate-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|drive-&gt;type
op_assign
id|ATA_DISK
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;DISK drive&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize our quirk list. */
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;quirkproc
)paren
id|drive-&gt;quirk_list
op_assign
id|drive-&gt;channel
op_member_access_from_pointer
id|quirkproc
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Initialize queue depth settings */
id|drive-&gt;queue_depth
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE_TCQ_DEPTH
id|drive-&gt;queue_depth
op_assign
id|CONFIG_BLK_DEV_IDE_TCQ_DEPTH
suffix:semicolon
macro_line|#else
id|drive-&gt;queue_depth
op_assign
id|drive-&gt;id-&gt;queue_depth
op_plus
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|drive-&gt;queue_depth
template_param
id|IDE_MAX_TAG
)paren
id|drive-&gt;queue_depth
op_assign
id|IDE_MAX_TAG
suffix:semicolon
r_return
suffix:semicolon
id|err_misc
suffix:colon
id|kfree
c_func
(paren
id|id
)paren
suffix:semicolon
id|err_kmalloc
suffix:colon
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Sends an ATA(PI) IDENTIFY request to a drive and wait for a response.  It&n; * also monitor irqs while this is happening, in hope of automatically&n; * determining which one is being used by the interface.&n; *&n; * Returns:&t;0  device was identified&n; *&t;&t;1  device timed-out (no response to identify request)&n; *&t;&t;2  device aborted the command (refused to identify itself)&n; */
DECL|function|identify
r_static
r_int
id|identify
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
id|u8
id|cmd
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
r_int
id|rc
op_assign
l_int|1
suffix:semicolon
r_int
id|autoprobe
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|cookie
op_assign
l_int|0
suffix:semicolon
id|ide_ioreg_t
id|hd_status
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/* FIXME: perhaps we should be just using allways the status register,&n;&t; * since it should simplify the code significantly.&n;&t; */
r_if
c_cond
(paren
id|ch-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
(brace
id|u8
id|s
suffix:semicolon
id|u8
id|a
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;channel-&gt;irq
)paren
(brace
id|autoprobe
op_assign
l_int|1
suffix:semicolon
id|cookie
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
id|ata_irq_enable
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* enable device irq */
)brace
multiline_comment|/* take a deep breath */
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|a
op_assign
id|IN_BYTE
c_func
(paren
id|ch-&gt;io_ports
(braket
id|IDE_ALTSTATUS_OFFSET
)braket
)paren
suffix:semicolon
id|s
op_assign
id|IN_BYTE
c_func
(paren
id|ch-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a
op_xor
id|s
)paren
op_amp
op_complement
id|INDEX_STAT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: probing with STATUS(0x%02x) instead of ALTSTATUS(0x%02x)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|s
comma
id|a
)paren
suffix:semicolon
id|hd_status
op_assign
id|ch-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
suffix:semicolon
multiline_comment|/* ancient Seagate drives, broken interfaces */
)brace
r_else
(brace
id|hd_status
op_assign
id|ch-&gt;io_ports
(braket
id|IDE_ALTSTATUS_OFFSET
)braket
suffix:semicolon
multiline_comment|/* use non-intrusive polling */
)brace
)brace
r_else
(brace
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|hd_status
op_assign
id|ch-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
suffix:semicolon
)brace
multiline_comment|/* set features register for atapi identify command to be sure of reply */
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|WIN_PIDENTIFY
)paren
)paren
id|OUT_BYTE
c_func
(paren
l_int|0
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
multiline_comment|/* disable dma &amp; overlap */
macro_line|#if CONFIG_BLK_DEV_PDC4030
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;chipset
op_eq
id|ide_pdc4030
)paren
(brace
multiline_comment|/* DC4030 hosted drives need their own identify... */
r_extern
r_int
id|pdc4030_identify
c_func
(paren
r_struct
id|ata_device
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdc4030_identify
c_func
(paren
id|drive
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
macro_line|#endif
id|OUT_BYTE
c_func
(paren
id|cmd
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* ask drive for ID */
id|timeout
op_assign
(paren
(paren
id|cmd
op_eq
id|WIN_IDENTIFY
)paren
ques
c_cond
id|WAIT_WORSTCASE
suffix:colon
id|WAIT_PIDENTIFY
)paren
op_div
l_int|2
suffix:semicolon
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* drive timed-out */
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* give drive a breather */
)brace
r_while
c_loop
(paren
id|IN_BYTE
c_func
(paren
id|hd_status
)paren
op_amp
id|BUSY_STAT
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* wait for IRQ and DRQ_STAT */
r_if
c_cond
(paren
id|ata_status
c_func
(paren
id|drive
comma
id|DRQ_STAT
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only; some systems need this */
id|do_identify
c_func
(paren
id|drive
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* drive returned ID */
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* drive responded with ID */
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* clear drive IRQ */
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
)brace
r_else
id|rc
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* drive refused ID */
id|out
suffix:colon
r_if
c_cond
(paren
id|autoprobe
)paren
(brace
r_int
id|irq
suffix:semicolon
id|ata_irq_enable
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mask device irq */
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* clear drive IRQ */
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|irq
op_assign
id|probe_irq_off
c_func
(paren
id|cookie
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;channel-&gt;irq
)paren
(brace
r_if
c_cond
(paren
id|irq
OG
l_int|0
)paren
id|drive-&gt;channel-&gt;irq
op_assign
id|irq
suffix:semicolon
r_else
multiline_comment|/* Mmmm.. multiple IRQs.. don&squot;t know which was ours */
id|printk
c_func
(paren
l_string|&quot;%s: IRQ probe failed (0x%lx)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|cookie
)paren
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * This has the difficult job of finding a drive if it exists, without getting&n; * hung up if it doesn&squot;t exist, without trampling on ethernet cards, and&n; * without leaving any IRQs dangling to haunt us later.&n; *&n; * If a drive is &quot;known&quot; to exist (from CMOS or kernel parameters), but does&n; * not respond right away, the probe will &quot;hang in there&quot; for the maximum wait&n; * time (about 30 seconds), otherwise it will exit much more quickly.&n; *&n; * Returns:&t;0  device was identified&n; *&t;&t;1  device timed-out (no response to identify request)&n; *&t;&t;2  device aborted the command (refused to identify itself)&n; *&t;&t;3  bad status from device (possible for ATAPI drives)&n; *&t;&t;4  probe was not attempted because failure was obvious&n; */
DECL|function|do_probe
r_static
r_int
id|do_probe
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
id|u8
id|cmd
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|ata_channel
op_star
id|ch
op_assign
id|drive-&gt;channel
suffix:semicolon
id|u8
id|select
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
)paren
(brace
multiline_comment|/* avoid waiting for inappropriate probes */
r_if
c_cond
(paren
(paren
id|drive-&gt;type
op_ne
id|ATA_DISK
)paren
op_logical_and
(paren
id|cmd
op_eq
id|WIN_IDENTIFY
)paren
)paren
r_return
l_int|4
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;probing for %s: present=%d, type=%02x, probetype=%s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;present
comma
id|drive-&gt;type
comma
(paren
id|cmd
op_eq
id|WIN_IDENTIFY
)paren
ques
c_cond
l_string|&quot;ATA&quot;
suffix:colon
l_string|&quot;ATAPI&quot;
)paren
suffix:semicolon
macro_line|#endif
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* needed for some systems (e.g. crw9624 as drive0 with disk as slave) */
id|ata_select
c_func
(paren
id|drive
comma
l_int|50000
)paren
suffix:semicolon
id|select
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|select
op_ne
id|drive-&gt;select.all
op_logical_and
op_logical_neg
id|drive-&gt;present
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
op_ne
l_int|0
)paren
(brace
id|ata_select
c_func
(paren
op_amp
id|ch-&gt;drives
(braket
l_int|0
)braket
comma
l_int|50000
)paren
suffix:semicolon
multiline_comment|/* exit with drive0 selected */
)brace
r_return
l_int|3
suffix:semicolon
multiline_comment|/* no i/f present: mmm.. this should be a 4 -ml */
)brace
r_if
c_cond
(paren
id|ata_status
c_func
(paren
id|drive
comma
id|READY_STAT
comma
id|BUSY_STAT
)paren
op_logical_or
id|drive-&gt;present
op_logical_or
id|cmd
op_eq
id|WIN_PIDENTIFY
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|identify
c_func
(paren
id|drive
comma
id|cmd
)paren
)paren
)paren
multiline_comment|/* send cmd and wait */
id|rc
op_assign
id|identify
c_func
(paren
id|drive
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* failed: try again */
r_if
c_cond
(paren
id|rc
op_eq
l_int|1
op_logical_and
id|cmd
op_eq
id|WIN_PIDENTIFY
op_logical_and
id|drive-&gt;autotune
op_ne
l_int|2
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: no response (status = 0x%02x), resetting drive&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;status
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|WIN_SRST
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
id|BUSY_STAT
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
op_plus
id|WAIT_WORSTCASE
)paren
)paren
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|rc
op_assign
id|identify
c_func
(paren
id|drive
comma
id|cmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: no response (status = 0x%02x)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;status
)paren
suffix:semicolon
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* ensure drive irq is clear */
)brace
r_else
id|rc
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* not present or maybe ATAPI */
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
op_ne
l_int|0
)paren
(brace
id|ata_select
c_func
(paren
op_amp
id|ch-&gt;drives
(braket
l_int|0
)braket
comma
l_int|50000
)paren
suffix:semicolon
multiline_comment|/* exit with drive0 selected */
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* ensure drive irq is clear */
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Probe for drivers on a channel.&n; *&n; * This routine only knows how to look for drive units 0 and 1 on an interface,&n; * so any setting of MAX_DRIVES &gt; 2 won&squot;t work here.&n; */
DECL|function|channel_probe
r_static
r_void
id|channel_probe
c_func
(paren
r_struct
id|ata_channel
op_star
id|ch
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;noprobe
)paren
r_return
suffix:semicolon
id|ch-&gt;straight8
op_assign
l_int|0
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only; needed for jiffies and irq probing */
multiline_comment|/*&n;&t; * Check for the presence of a channel by probing for drives on it.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;noprobe
)paren
multiline_comment|/* don&squot;t look for this one */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|do_probe
c_func
(paren
id|drive
comma
id|WIN_IDENTIFY
)paren
op_ge
l_int|2
)paren
(brace
multiline_comment|/* if !(success||timed-out) */
id|do_probe
c_func
(paren
id|drive
comma
id|WIN_PIDENTIFY
)paren
suffix:semicolon
multiline_comment|/* look for ATAPI device */
)brace
multiline_comment|/* Special handling of EXABYTE controller cards. */
r_if
c_cond
(paren
id|drive-&gt;id
op_logical_and
id|strstr
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;E X A B Y T E N E S T&quot;
)paren
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: enabling %s -- &quot;
comma
id|drive-&gt;channel-&gt;name
comma
id|drive-&gt;id-&gt;model
)paren
suffix:semicolon
id|ata_select
c_func
(paren
id|drive
comma
l_int|50000
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|EXABYTE_ENABLE_NEST
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;failed (timeout)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
id|BUSY_STAT
)paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ata_status
c_func
(paren
id|drive
comma
l_int|0
comma
id|BAD_STAT
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;failed (status = 0x%02x)&bslash;n&quot;
comma
id|drive-&gt;status
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;success&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_probe
c_func
(paren
id|drive
comma
id|WIN_IDENTIFY
)paren
op_ge
l_int|2
)paren
(brace
multiline_comment|/* if !(success||timed-out) */
id|do_probe
c_func
(paren
id|drive
comma
id|WIN_PIDENTIFY
)paren
suffix:semicolon
multiline_comment|/* look for ATAPI device */
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
multiline_comment|/* drive not found */
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;id
)paren
(brace
multiline_comment|/* identification failed? */
r_if
c_cond
(paren
id|drive-&gt;type
op_eq
id|ATA_DISK
)paren
id|printk
(paren
l_string|&quot;%s: pre-ATA drive, CHS=%d/%d/%d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;cyl
comma
id|drive-&gt;head
comma
id|drive-&gt;sect
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|drive-&gt;type
op_eq
id|ATA_ROM
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ATAPI cdrom (?)&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_else
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* nuke it */
)brace
multiline_comment|/* drive found, there is a channel it is attached too. */
r_if
c_cond
(paren
id|drive-&gt;present
)paren
id|ch-&gt;present
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ch-&gt;present
)paren
r_goto
id|not_found
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_or
l_int|7
)paren
op_eq
(paren
(paren
r_int
r_int
)paren
id|ch-&gt;io_ports
(braket
id|IDE_STATUS_OFFSET
)braket
)paren
)paren
(brace
id|error
op_add_assign
op_logical_neg
id|request_region
c_func
(paren
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
l_int|8
comma
id|ch-&gt;name
)paren
suffix:semicolon
id|ch-&gt;straight8
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|error
op_add_assign
op_logical_neg
id|request_region
c_func
(paren
id|ch-&gt;io_ports
(braket
id|i
)braket
comma
l_int|1
comma
id|ch-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
id|error
op_add_assign
op_logical_neg
id|request_region
c_func
(paren
id|ch-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
comma
l_int|1
comma
id|ch-&gt;name
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_AMIGA) || defined(CONFIG_MAC)
r_if
c_cond
(paren
id|ch-&gt;io_ports
(braket
id|IDE_IRQ_OFFSET
)braket
)paren
id|error
op_add_assign
op_logical_neg
id|request_region
c_func
(paren
id|ch-&gt;io_ports
(braket
id|IDE_IRQ_OFFSET
)braket
comma
l_int|1
comma
id|ch-&gt;name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Some neccessary register area was already used. Skip this device.&n;&t; */
r_if
c_cond
(paren
macro_line|#if CONFIG_BLK_DEV_PDC4030
(paren
id|ch-&gt;chipset
op_ne
id|ide_pdc4030
op_logical_or
id|ch-&gt;unit
op_eq
l_int|0
)paren
op_logical_and
macro_line|#endif
id|error
)paren
(brace
multiline_comment|/* FIXME: We should be dealing properly with partial IO region&n;&t;&t; * allocations here.&n;&t;&t; */
id|ch-&gt;present
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: error: ports already in use!&bslash;n&quot;
comma
id|ch-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ch-&gt;present
)paren
r_goto
id|not_found
suffix:semicolon
multiline_comment|/* Register this hardware interface within the global device tree.&n;&t; *&n;&t; * FIXME: This should be handled as a pci subdevice in a generic way.&n;&t; */
id|sprintf
c_func
(paren
id|ch-&gt;dev.bus_id
comma
l_string|&quot;ata@%02x&quot;
comma
id|ch-&gt;unit
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ch-&gt;dev.name
comma
l_string|&quot;ATA/ATAPI Host-Channel&quot;
)paren
suffix:semicolon
id|ch-&gt;dev.driver_data
op_assign
id|ch
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
id|ch-&gt;pci_dev
)paren
id|ch-&gt;dev.parent
op_assign
op_amp
id|ch-&gt;pci_dev-&gt;dev
suffix:semicolon
r_else
macro_line|#endif
id|ch-&gt;dev.parent
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Would like to do = &amp;device_legacy */
id|device_register
c_func
(paren
op_amp
id|ch-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;reset
)paren
id|ata_reset
c_func
(paren
id|ch
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
multiline_comment|/*&n;&t; * Now setup the PIO transfer modes of the drives on this channel.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
op_logical_and
(paren
id|drive-&gt;autotune
op_eq
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;tuneproc
)paren
id|drive-&gt;channel
op_member_access_from_pointer
id|tuneproc
c_func
(paren
id|drive
comma
l_int|255
)paren
suffix:semicolon
multiline_comment|/* auto-tune PIO mode */
)brace
)brace
r_return
suffix:semicolon
id|not_found
suffix:colon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine sets up the irq for an ide interface, and creates a new hwgroup&n; * for the irq/channel if none was previously assigned.&n; *&n; * Much of the code is for correctly detecting/handling irq sharing and irq&n; * serialization situations.  This is somewhat complex because it handles&n; * static as well as dynamic (PCMCIA) IDE interfaces.&n; *&n; * The SA_INTERRUPT in sa_flags means ata_irq_request() is always entered with&n; * interrupts completely disabled.  This can be bad for interrupt latency, but&n; * anything else has led to problems on some machines.  We re-enable interrupts&n; * as much as we can safely do in most places.&n; */
DECL|function|init_irq
r_static
r_int
id|init_irq
c_func
(paren
r_struct
id|ata_channel
op_star
id|ch
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spinlock_t
op_star
id|lock
suffix:semicolon
id|spinlock_t
op_star
id|new_lock
suffix:semicolon
r_int
r_int
op_star
id|active
suffix:semicolon
r_int
r_int
op_star
id|new_active
suffix:semicolon
r_struct
id|ata_channel
op_star
id|match
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Spare allocation before sleep. */
id|new_lock
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|lock
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|new_active
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|active
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
op_star
id|new_active
op_assign
l_int|0L
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|ch-&gt;lock
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if MAX_HWIFS &gt; 1
multiline_comment|/*&n;&t; * Group up with any other channels that share our irq(s).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|ata_channel
op_star
id|h
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* scan only initialized channels */
r_if
c_cond
(paren
op_logical_neg
id|h-&gt;lock
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;irq
op_ne
id|h-&gt;irq
)paren
r_continue
suffix:semicolon
id|ch-&gt;sharing_irq
op_assign
id|h-&gt;sharing_irq
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;chipset
op_ne
id|ide_pci
op_logical_or
id|h-&gt;chipset
op_ne
id|ide_pci
op_logical_or
id|ch-&gt;serialized
op_logical_or
id|h-&gt;serialized
)paren
(brace
r_if
c_cond
(paren
id|match
op_logical_and
id|match-&gt;lock
op_logical_and
id|match-&gt;lock
op_ne
id|h-&gt;lock
)paren
id|printk
c_func
(paren
l_string|&quot;%s: potential irq problem with %s and %s&bslash;n&quot;
comma
id|ch-&gt;name
comma
id|h-&gt;name
comma
id|match-&gt;name
)paren
suffix:semicolon
multiline_comment|/* don&squot;t undo a prior perfect match */
r_if
c_cond
(paren
op_logical_neg
id|match
op_logical_or
id|match-&gt;irq
op_ne
id|ch-&gt;irq
)paren
id|match
op_assign
id|h
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * If we are still without a lock group, then form a new one&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
(brace
id|lock
op_assign
id|new_lock
suffix:semicolon
id|active
op_assign
id|new_active
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lock
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|spin_lock_init
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|lock
op_assign
id|match-&gt;lock
suffix:semicolon
id|active
op_assign
id|match-&gt;active
suffix:semicolon
r_if
c_cond
(paren
id|new_lock
)paren
(brace
id|kfree
c_func
(paren
id|new_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Allocate the irq, if not already obtained for another channel&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|match
op_logical_or
id|match-&gt;irq
op_ne
id|ch-&gt;irq
)paren
(brace
r_struct
id|ata_device
id|tmp
suffix:semicolon
macro_line|#ifdef CONFIG_IDEPCI_SHARE_IRQ
r_int
id|sa
op_assign
id|IDE_CHIPSET_IS_PCI
c_func
(paren
id|ch-&gt;chipset
)paren
ques
c_cond
id|SA_SHIRQ
suffix:colon
id|SA_INTERRUPT
suffix:semicolon
macro_line|#else
r_int
id|sa
op_assign
id|IDE_CHIPSET_IS_PCI
c_func
(paren
id|ch-&gt;chipset
)paren
ques
c_cond
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
suffix:colon
id|SA_INTERRUPT
suffix:semicolon
macro_line|#endif
multiline_comment|/* Enable interrupts triggered by the drive.  We use a shallow&n;&t;&t; * device structure, just to use the generic function very&n;&t;&t; * early.&n;&t;&t; */
id|tmp.channel
op_assign
id|ch
suffix:semicolon
id|ata_irq_enable
c_func
(paren
op_amp
id|tmp
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|ch-&gt;irq
comma
op_amp
id|ata_irq_request
comma
id|sa
comma
id|ch-&gt;name
comma
id|ch
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
(brace
id|kfree
c_func
(paren
id|lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|active
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Everything is okay. Tag us as member of this lock group.&n;&t; */
id|ch-&gt;lock
op_assign
id|lock
suffix:semicolon
id|ch-&gt;active
op_assign
id|active
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|ch-&gt;timer.function
op_assign
op_amp
id|ide_timer_expiry
suffix:semicolon
id|ch-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|ch
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
id|i
)braket
suffix:semicolon
id|request_queue_t
op_star
id|q
suffix:semicolon
r_int
id|max_sectors
op_assign
l_int|255
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch-&gt;drive
)paren
id|ch-&gt;drive
op_assign
id|drive
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Init the per device request queue&n;&t;&t; */
id|q
op_assign
op_amp
id|drive-&gt;queue
suffix:semicolon
id|q-&gt;queuedata
op_assign
id|drive-&gt;channel
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|q
comma
id|do_ide_request
comma
id|drive-&gt;channel-&gt;lock
)paren
suffix:semicolon
id|blk_queue_segment_boundary
c_func
(paren
id|q
comma
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/* ATA can do up to 128K per request, pdc4030 needs smaller limit */
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;chipset
op_eq
id|ide_pdc4030
)paren
id|max_sectors
op_assign
l_int|127
suffix:semicolon
macro_line|#endif
id|blk_queue_max_sectors
c_func
(paren
id|q
comma
id|max_sectors
)paren
suffix:semicolon
multiline_comment|/* IDE DMA can do PRD_ENTRIES number of segments. */
id|blk_queue_max_hw_segments
c_func
(paren
id|q
comma
id|PRD_ENTRIES
)paren
suffix:semicolon
multiline_comment|/* FIXME: This is a driver limit and could be eliminated. */
id|blk_queue_max_phys_segments
c_func
(paren
id|q
comma
id|PRD_ENTRIES
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#if !defined(__mc68000__) &amp;&amp; !defined(CONFIG_APUS) &amp;&amp; !defined(__sparc__)
id|printk
c_func
(paren
l_string|&quot;%s at 0x%03x-0x%03x,0x%03x on irq %d&quot;
comma
id|ch-&gt;name
comma
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_plus
l_int|7
comma
id|ch-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
comma
id|ch-&gt;irq
)paren
suffix:semicolon
macro_line|#elif defined(__sparc__)
id|printk
c_func
(paren
l_string|&quot;%s at 0x%03lx-0x%03lx,0x%03lx on irq %s&quot;
comma
id|ch-&gt;name
comma
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_plus
l_int|7
comma
id|ch-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
comma
id|__irq_itoa
c_func
(paren
id|ch-&gt;irq
)paren
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;%s at %p on irq 0x%08x&quot;
comma
id|ch-&gt;name
comma
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
id|ch-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|match
)paren
id|printk
c_func
(paren
l_string|&quot; (%sed with %s)&quot;
comma
id|ch-&gt;sharing_irq
ques
c_cond
l_string|&quot;shar&quot;
suffix:colon
l_string|&quot;serializ&quot;
comma
id|match-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the queue which corresponds to a given device.&n; *&n; * FIXME: this should take struct block_device * as argument in future.&n; */
DECL|function|ata_get_queue
r_static
id|request_queue_t
op_star
id|ata_get_queue
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
op_assign
(paren
r_struct
id|ata_channel
op_star
)paren
id|blk_dev
(braket
id|major
c_func
(paren
id|dev
)paren
)braket
dot
id|data
suffix:semicolon
multiline_comment|/* FIXME: ALLERT: This discriminates between master and slave! */
r_return
op_amp
id|ch-&gt;drives
(braket
id|DEVICE_NR
c_func
(paren
id|dev
)paren
op_amp
l_int|1
)braket
dot
id|queue
suffix:semicolon
)brace
multiline_comment|/* Number of minor numbers we consume par channel. */
DECL|macro|ATA_MINORS
mdefine_line|#define ATA_MINORS&t;(MAX_DRIVES * (1 &lt;&lt; PARTN_BITS))
DECL|function|channel_init
r_static
r_void
id|channel_init
c_func
(paren
r_struct
id|ata_channel
op_star
id|ch
)paren
(brace
r_struct
id|gendisk
op_star
id|gd
suffix:semicolon
r_int
r_int
id|unit
suffix:semicolon
r_extern
id|devfs_handle_t
id|ide_devfs_handle
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch-&gt;present
)paren
r_return
suffix:semicolon
multiline_comment|/* we set it back to 1 if all is ok below */
id|ch-&gt;present
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch-&gt;irq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch-&gt;irq
op_assign
id|ide_default_irq
c_func
(paren
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DISABLED, NO IRQ&bslash;n&quot;
comma
id|ch-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_BLK_DEV_HD
r_if
c_cond
(paren
id|ch-&gt;irq
op_eq
id|HD_IRQ
op_logical_and
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_ne
id|HD_DATA
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: CANNOT SHARE IRQ WITH OLD HARDDISK DRIVER (hd.c)&bslash;n&quot;
comma
id|ch-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|devfs_register_blkdev
c_func
(paren
id|ch-&gt;major
comma
id|ch-&gt;name
comma
id|ide_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: UNABLE TO GET MAJOR NUMBER %d&bslash;n&quot;
comma
id|ch-&gt;name
comma
id|ch-&gt;major
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|init_irq
c_func
(paren
id|ch
)paren
)paren
(brace
r_int
id|irq
op_assign
id|ch-&gt;irq
suffix:semicolon
multiline_comment|/*&n;&t;&t; * It failed to initialise. Find the default IRQ for&n;&t;&t; * this port and try that.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch-&gt;irq
op_assign
id|ide_default_irq
c_func
(paren
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: disabled; unable to get IRQ %d.&bslash;n&quot;
comma
id|ch-&gt;name
comma
id|irq
)paren
suffix:semicolon
(paren
r_void
)paren
id|unregister_blkdev
(paren
id|ch-&gt;major
comma
id|ch-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|init_irq
c_func
(paren
id|ch
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: probed IRQ %d and default IRQ %d failed.&bslash;n&quot;
comma
id|ch-&gt;name
comma
id|irq
comma
id|ch-&gt;irq
)paren
suffix:semicolon
(paren
r_void
)paren
id|unregister_blkdev
c_func
(paren
id|ch-&gt;major
comma
id|ch-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: probed IRQ %d failed, using default.&bslash;n&quot;
comma
id|ch-&gt;name
comma
id|ch-&gt;irq
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize partition and global device data.&n;&t; */
id|gd
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|gendisk
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gd
)paren
r_goto
id|err_kmalloc_gd
suffix:semicolon
id|gd-&gt;sizes
op_assign
id|kmalloc
c_func
(paren
id|ATA_MINORS
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gd-&gt;sizes
)paren
r_goto
id|err_kmalloc_gd_sizes
suffix:semicolon
id|gd-&gt;part
op_assign
id|kmalloc
c_func
(paren
id|ATA_MINORS
op_star
r_sizeof
(paren
r_struct
id|hd_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gd-&gt;part
)paren
r_goto
id|err_kmalloc_gd_part
suffix:semicolon
id|memset
c_func
(paren
id|gd-&gt;part
comma
l_int|0
comma
id|ATA_MINORS
op_star
r_sizeof
(paren
r_struct
id|hd_struct
)paren
)paren
suffix:semicolon
id|gd-&gt;de_arr
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|gd-&gt;de_arr
)paren
op_star
id|MAX_DRIVES
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gd-&gt;de_arr
)paren
r_goto
id|err_kmalloc_gd_de_arr
suffix:semicolon
id|memset
c_func
(paren
id|gd-&gt;de_arr
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|gd-&gt;de_arr
)paren
op_star
id|MAX_DRIVES
)paren
suffix:semicolon
id|gd-&gt;flags
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|gd-&gt;flags
)paren
op_star
id|MAX_DRIVES
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gd-&gt;flags
)paren
r_goto
id|err_kmalloc_gd_flags
suffix:semicolon
id|memset
c_func
(paren
id|gd-&gt;flags
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|gd-&gt;flags
)paren
op_star
id|MAX_DRIVES
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
id|ch-&gt;drives
(braket
id|unit
)braket
dot
id|part
op_assign
op_amp
id|gd-&gt;part
(braket
id|unit
op_lshift
id|PARTN_BITS
)braket
suffix:semicolon
id|gd-&gt;major
op_assign
id|ch-&gt;major
suffix:semicolon
multiline_comment|/* our major device number */
id|gd-&gt;major_name
op_assign
id|IDE_MAJOR_NAME
suffix:semicolon
multiline_comment|/* treated special in genhd.c */
id|gd-&gt;minor_shift
op_assign
id|PARTN_BITS
suffix:semicolon
multiline_comment|/* num bits for partitions */
id|gd-&gt;nr_real
op_assign
id|MAX_DRIVES
suffix:semicolon
multiline_comment|/* current num real drives */
id|gd-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* linked list of major devs */
id|gd-&gt;fops
op_assign
id|ide_fops
suffix:semicolon
multiline_comment|/* file operations */
id|gd-&gt;de_arr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|gd-&gt;de_arr
)paren
op_star
id|MAX_DRIVES
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gd-&gt;de_arr
)paren
id|memset
c_func
(paren
id|gd-&gt;de_arr
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|gd-&gt;de_arr
)paren
op_star
id|MAX_DRIVES
)paren
suffix:semicolon
r_else
r_goto
id|err_kmalloc_gd_de_arr
suffix:semicolon
id|gd-&gt;flags
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|gd-&gt;flags
)paren
op_star
id|MAX_DRIVES
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gd-&gt;flags
)paren
id|memset
c_func
(paren
id|gd-&gt;flags
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|gd-&gt;flags
)paren
op_star
id|MAX_DRIVES
)paren
suffix:semicolon
r_else
r_goto
id|err_kmalloc_gd_flags
suffix:semicolon
id|ch-&gt;gd
op_assign
id|gd
suffix:semicolon
id|add_gendisk
c_func
(paren
id|gd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
r_char
id|name
(braket
l_int|80
)braket
suffix:semicolon
id|ch-&gt;drives
(braket
id|unit
)braket
dot
id|dn
op_assign
(paren
(paren
id|ch-&gt;unit
ques
c_cond
l_int|2
suffix:colon
l_int|0
)paren
op_plus
id|unit
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;host%d/bus%d/target%d/lun%d&quot;
comma
id|ch-&gt;index
comma
id|ch-&gt;unit
comma
id|unit
comma
id|ch-&gt;drives
(braket
id|unit
)braket
dot
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;drives
(braket
id|unit
)braket
dot
id|present
)paren
id|ch-&gt;drives
(braket
id|unit
)braket
dot
id|de
op_assign
id|devfs_mk_dir
c_func
(paren
id|ide_devfs_handle
comma
id|name
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|blk_dev
(braket
id|ch-&gt;major
)braket
dot
id|data
op_assign
id|ch
suffix:semicolon
id|blk_dev
(braket
id|ch-&gt;major
)braket
dot
id|queue
op_assign
id|ata_get_queue
suffix:semicolon
multiline_comment|/* All went well, flag this channel entry as valid again. */
id|ch-&gt;present
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
id|err_kmalloc_gd_flags
suffix:colon
id|kfree
c_func
(paren
id|gd-&gt;de_arr
)paren
suffix:semicolon
id|err_kmalloc_gd_de_arr
suffix:colon
id|kfree
c_func
(paren
id|gd-&gt;part
)paren
suffix:semicolon
id|err_kmalloc_gd_part
suffix:colon
id|kfree
c_func
(paren
id|gd-&gt;sizes
)paren
suffix:semicolon
id|err_kmalloc_gd_sizes
suffix:colon
id|kfree
c_func
(paren
id|gd
)paren
suffix:semicolon
id|err_kmalloc_gd
suffix:colon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;(%s) Out of memory&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME: consider moving this to main.c, since this is the only place where&n; * it&squot;s used.&n; *&n; * Probe only for drives on channes which are not already present.&n; */
DECL|function|ideprobe_init
r_int
id|ideprobe_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
id|probe
(braket
id|MAX_HWIFS
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|i
)paren
id|probe
(braket
id|i
)braket
op_assign
op_logical_neg
id|ide_hwifs
(braket
id|i
)braket
dot
id|present
suffix:semicolon
multiline_comment|/*&n;&t; * Probe for drives in the usual way.. CMOS/BIOS, then poke at ports&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|probe
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|channel_probe
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|probe
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|channel_init
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ata_fix_driveid
id|EXPORT_SYMBOL
c_func
(paren
id|ata_fix_driveid
)paren
suffix:semicolon
DECL|variable|ide_fixstring
id|EXPORT_SYMBOL
c_func
(paren
id|ide_fixstring
)paren
suffix:semicolon
DECL|variable|eighty_ninty_three
id|EXPORT_SYMBOL
c_func
(paren
id|eighty_ninty_three
)paren
suffix:semicolon
DECL|variable|ide_config_drive_speed
id|EXPORT_SYMBOL
c_func
(paren
id|ide_config_drive_speed
)paren
suffix:semicolon
eof
