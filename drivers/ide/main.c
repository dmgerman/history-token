multiline_comment|/**** vi:set ts=8 sts=8 sw=8:************************************************&n; *&n; *  Copyright (C) 1994-1998,2002  Linus Torvalds and authors:&n; *&n; *&t;Mark Lord&t;&lt;mlord@pobox.com&gt;&n; *      Gadi Oxman&t;&lt;gadio@netvision.net.il&gt;&n; *      Andre Hedrick&t;&lt;andre@linux-ide.org&gt;&n; *&t;Jens Axboe&t;&lt;axboe@suse.de&gt;&n; *      Marcin Dalecki&t;&lt;martin@dalecki.de&gt;&n; *&n; *  See linux/MAINTAINERS for address of current maintainer.&n; */
multiline_comment|/*&n; * Handle overall infrastructure of the driver&n; */
DECL|macro|VERSION
mdefine_line|#define&t;VERSION&t;&quot;7.0.0&quot;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#ifndef MODULE
macro_line|# include &lt;linux/init.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &quot;ata-timing.h&quot;
macro_line|#include &quot;pcihost.h&quot;
macro_line|#include &quot;ioctl.h&quot;
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;ATA/ATAPI driver infrastructure&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|options
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Those will be moved into separate header files eventually.&n; */
macro_line|#ifdef CONFIG_ETRAX_IDE
r_extern
r_void
id|init_e100_ide
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_CMD640
r_extern
r_void
id|ide_probe_for_cmd640x
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
r_extern
r_int
id|ide_probe_for_pdc4030
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDE_PMAC
r_extern
r_void
id|pmac_ide_probe
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDE_ICSIDE
r_extern
r_void
id|icside_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDE_RAPIDE
r_extern
r_void
id|rapide_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_GAYLE
r_extern
r_void
id|gayle_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_FALCON_IDE
r_extern
r_void
id|falconide_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_MAC_IDE
r_extern
r_void
id|macide_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_Q40IDE
r_extern
r_void
id|q40ide_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_BUDDHA
r_extern
r_void
id|buddha_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_BLK_DEV_ISAPNP) &amp;&amp; defined(CONFIG_ISAPNP)
r_extern
r_void
id|pnpide_init
c_func
(paren
r_int
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* default maximum number of failures */
DECL|macro|IDE_DEFAULT_MAX_FAILURES
mdefine_line|#define IDE_DEFAULT_MAX_FAILURES&t;1
DECL|variable|system_bus_speed
r_int
id|system_bus_speed
suffix:semicolon
multiline_comment|/* holds what we think is VESA/PCI bus speed */
DECL|variable|initializing
r_static
r_int
id|initializing
suffix:semicolon
multiline_comment|/* set while initializing built-in drivers */
DECL|variable|idebus_parameter
r_static
r_int
id|idebus_parameter
suffix:semicolon
multiline_comment|/* the &quot;idebus=&quot; parameter */
multiline_comment|/*&n; * Protects access to global structures etc.&n; */
DECL|variable|__cacheline_aligned
id|spinlock_t
id|ide_lock
id|__cacheline_aligned
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
DECL|variable|ide_scan_direction
r_static
r_int
id|ide_scan_direction
suffix:semicolon
multiline_comment|/* THIS was formerly 2.2.x pci=reverse */
macro_line|#endif
macro_line|#if defined(__mc68000__) || defined(CONFIG_APUS)
multiline_comment|/*&n; * This is used by the Atari code to obtain access to the IDE interrupt,&n; * which is shared between several drivers.&n; */
DECL|variable|irq_lock
r_static
r_int
id|irq_lock
suffix:semicolon
macro_line|#endif
DECL|variable|noautodma
r_int
id|noautodma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Single linked list of sub device type drivers */
DECL|variable|ata_drivers
r_static
r_struct
id|ata_operations
op_star
id|ata_drivers
suffix:semicolon
multiline_comment|/* = NULL */
DECL|variable|ata_drivers_lock
r_static
id|spinlock_t
id|ata_drivers_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * This is declared extern in ide.h, for access by other IDE modules:&n; */
DECL|variable|ide_hwifs
r_struct
id|ata_channel
id|ide_hwifs
(braket
id|MAX_HWIFS
)braket
suffix:semicolon
multiline_comment|/* master data repository */
multiline_comment|/*&n; * FIXME: This function should be unrolled in the palces where it get&squot;s used,&n; * since in reality it&squot;s simple architecture specific initialization.&n; *&n; * Setup hw_regs_t structure described by parameters.  You may set up the hw&n; * structure yourself OR use this routine to do it for you.&n; */
DECL|function|ide_setup_ports
r_void
id|ide_setup_ports
c_func
(paren
id|hw_regs_t
op_star
id|hw
comma
id|ide_ioreg_t
id|base
comma
r_int
op_star
id|offsets
comma
id|ide_ioreg_t
id|ctrl
comma
id|ide_ioreg_t
id|intr
comma
id|ide_ack_intr_t
op_star
id|ack_intr
comma
r_int
id|irq
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IDE_NR_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|offsets
(braket
id|i
)braket
op_ne
op_minus
l_int|1
)paren
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|base
op_plus
id|offsets
(braket
id|i
)braket
suffix:semicolon
r_else
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offsets
(braket
id|IDE_CONTROL_OFFSET
)braket
op_eq
op_minus
l_int|1
)paren
id|hw-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
op_assign
id|ctrl
suffix:semicolon
multiline_comment|/* FIMXE: check if we can remove this ifdef */
macro_line|#if defined(CONFIG_AMIGA) || defined(CONFIG_MAC)
r_if
c_cond
(paren
id|offsets
(braket
id|IDE_IRQ_OFFSET
)braket
op_eq
op_minus
l_int|1
)paren
id|hw-&gt;io_ports
(braket
id|IDE_IRQ_OFFSET
)braket
op_assign
id|intr
suffix:semicolon
macro_line|#endif
id|hw-&gt;irq
op_assign
id|irq
suffix:semicolon
id|hw-&gt;dma
op_assign
id|NO_DMA
suffix:semicolon
id|hw-&gt;ack_intr
op_assign
id|ack_intr
suffix:semicolon
)brace
DECL|function|init_hwif_data
r_static
r_void
id|init_hwif_data
c_func
(paren
r_struct
id|ata_channel
op_star
id|ch
comma
r_int
r_int
id|index
)paren
(brace
r_static
r_const
r_int
r_int
id|majors
(braket
)braket
op_assign
(brace
id|IDE0_MAJOR
comma
id|IDE1_MAJOR
comma
id|IDE2_MAJOR
comma
id|IDE3_MAJOR
comma
id|IDE4_MAJOR
comma
id|IDE5_MAJOR
comma
id|IDE6_MAJOR
comma
id|IDE7_MAJOR
comma
id|IDE8_MAJOR
comma
id|IDE9_MAJOR
)brace
suffix:semicolon
r_int
r_int
id|unit
suffix:semicolon
id|hw_regs_t
id|hw
suffix:semicolon
multiline_comment|/* bulk initialize channel &amp; drive info with zeros */
id|memset
c_func
(paren
id|ch
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ata_channel
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|hw
comma
l_int|0
comma
r_sizeof
(paren
id|hw_regs_t
)paren
)paren
suffix:semicolon
multiline_comment|/* fill in any non-zero initial values */
id|ch-&gt;index
op_assign
id|index
suffix:semicolon
id|ide_init_hwif_ports
c_func
(paren
op_amp
id|hw
comma
id|ide_default_io_base
c_func
(paren
id|index
)paren
comma
l_int|0
comma
op_amp
id|ch-&gt;irq
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ch-&gt;hw
comma
op_amp
id|hw
comma
r_sizeof
(paren
id|hw
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ch-&gt;io_ports
comma
id|hw.io_ports
comma
r_sizeof
(paren
id|hw.io_ports
)paren
)paren
suffix:semicolon
id|ch-&gt;noprobe
op_assign
op_logical_neg
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_HD
r_if
c_cond
(paren
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
id|HD_DATA
)paren
id|ch-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* may be overridden by ide_setup() */
macro_line|#endif
id|ch-&gt;major
op_assign
id|majors
(braket
id|index
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|ch-&gt;name
comma
l_string|&quot;ide%d&quot;
comma
id|index
)paren
suffix:semicolon
id|ch-&gt;bus_state
op_assign
id|BUSSTATE_ON
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
id|drive-&gt;type
op_assign
id|ATA_DISK
suffix:semicolon
id|drive-&gt;select.all
op_assign
(paren
id|unit
op_lshift
l_int|4
)paren
op_or
l_int|0xa0
suffix:semicolon
id|drive-&gt;channel
op_assign
id|ch
suffix:semicolon
id|drive-&gt;ready_stat
op_assign
id|READY_STAT
suffix:semicolon
id|drive-&gt;bad_wstat
op_assign
id|BAD_W_STAT
suffix:semicolon
id|sprintf
c_func
(paren
id|drive-&gt;name
comma
l_string|&quot;hd%c&quot;
comma
l_char|&squot;a&squot;
op_plus
(paren
id|index
op_star
id|MAX_DRIVES
)paren
op_plus
id|unit
)paren
suffix:semicolon
id|drive-&gt;max_failures
op_assign
id|IDE_DEFAULT_MAX_FAILURES
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|drive-&gt;wqueue
)paren
suffix:semicolon
)brace
)brace
r_extern
r_struct
id|block_device_operations
id|ide_fops
(braket
)braket
suffix:semicolon
multiline_comment|/*&n; * Returns the (struct ata_device *) for a given device number.  Return&n; * NULL if the given device number does not match any present drives.&n; */
DECL|function|get_info_ptr
r_struct
id|ata_device
op_star
id|get_info_ptr
c_func
(paren
id|kdev_t
id|i_rdev
)paren
(brace
r_int
r_int
id|major
op_assign
id|major
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
r_int
id|h
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;present
op_logical_and
id|major
op_eq
id|ch-&gt;major
)paren
(brace
r_int
id|unit
op_assign
id|DEVICE_NR
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
OL
id|MAX_DRIVES
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
)paren
r_return
id|drive
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called to flush all partitions and partition tables&n; * for a changed disk, and then re-read the new partition table.&n; * If we are revalidating a disk because of a media change, then we&n; * enter with usage == 0.  If we are using an ioctl, we automatically have&n; * usage == 1 (we need an open channel to use an ioctl :-), so this&n; * is our limit.&n; */
DECL|function|ata_revalidate
r_int
id|ata_revalidate
c_func
(paren
id|kdev_t
id|i_rdev
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|i_rdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* FIXME: The locking here doesn&squot;t make the slightest sense! */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;busy
op_logical_or
(paren
id|drive-&gt;usage
OG
l_int|1
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|drive-&gt;busy
op_assign
l_int|1
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
id|res
op_assign
id|wipe_partitions
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|revalidate
)paren
(brace
id|ata_get
c_func
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
multiline_comment|/* This is expected to be a no-op for tapes and SCSI&n;&t;&t;&t; * based access.&n;&t;&t;&t; */
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|revalidate
c_func
(paren
id|drive
)paren
suffix:semicolon
id|ata_put
c_func
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
id|grok_partitions
c_func
(paren
id|i_rdev
comma
id|ata_capacity
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
id|drive-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|drive-&gt;wqueue
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME: this is most propably just totally unnecessary.&n; *&n; * Look again for all drives in the system on all interfaces.&n; */
DECL|function|revalidate_drives
r_static
r_void
id|revalidate_drives
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
id|unit
suffix:semicolon
r_struct
id|ata_channel
op_star
id|ch
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;revalidate
)paren
(brace
id|drive-&gt;revalidate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initializing
)paren
id|ata_revalidate
c_func
(paren
id|mk_kdev
c_func
(paren
id|ch-&gt;major
comma
id|unit
op_lshift
id|PARTN_BITS
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|ide_driver_module
r_void
id|ide_driver_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Don&squot;t reinit the probe if there is already one channel detected. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|ide_hwifs
(braket
id|i
)braket
dot
id|present
)paren
r_goto
id|revalidate
suffix:semicolon
)brace
id|ideprobe_init
c_func
(paren
)paren
suffix:semicolon
id|revalidate
suffix:colon
id|revalidate_drives
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the data associated with a channel.&n; */
DECL|function|ide_unregister
r_void
id|ide_unregister
c_func
(paren
r_struct
id|ata_channel
op_star
id|ch
)paren
(brace
r_struct
id|gendisk
op_star
id|gd
suffix:semicolon
r_struct
id|ata_device
op_star
id|d
suffix:semicolon
id|spinlock_t
op_star
id|lock
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|p
comma
id|minor
suffix:semicolon
r_struct
id|ata_channel
id|old
suffix:semicolon
r_int
id|n_irq
suffix:semicolon
r_int
id|n_ch
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch-&gt;present
)paren
r_goto
m_abort
suffix:semicolon
id|put_device
c_func
(paren
op_amp
id|ch-&gt;dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;busy
op_logical_or
id|drive-&gt;usage
)paren
r_goto
m_abort
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
)paren
(brace
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
c_func
(paren
id|drive
)paren
)paren
r_goto
m_abort
suffix:semicolon
)brace
r_else
id|ide_unregister_subdriver
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
id|ch-&gt;present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * All clear?  Then blow away the buffer cache&n;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
id|minor
op_assign
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
(paren
l_int|1
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
op_increment
id|p
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;part
(braket
id|p
)braket
dot
id|nr_sects
OG
l_int|0
)paren
(brace
id|kdev_t
id|devp
op_assign
id|mk_kdev
c_func
(paren
id|ch-&gt;major
comma
id|minor
op_plus
id|p
)paren
suffix:semicolon
id|invalidate_device
c_func
(paren
id|devp
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note that we only release the standard ports, and do not even try to&n;&t; * handle any extra ports allocated for weird IDE interface chipsets.&n;&t; */
r_if
c_cond
(paren
id|ch-&gt;straight8
)paren
(brace
id|release_region
c_func
(paren
id|ch-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ch-&gt;io_ports
(braket
id|i
)braket
)paren
id|release_region
c_func
(paren
id|ch-&gt;io_ports
(braket
id|i
)braket
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
)paren
id|release_region
c_func
(paren
id|ch-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* FIXME: check if we can remove this ifdef */
macro_line|#if defined(CONFIG_AMIGA) || defined(CONFIG_MAC)
r_if
c_cond
(paren
id|ch-&gt;io_ports
(braket
id|IDE_IRQ_OFFSET
)braket
)paren
id|release_region
c_func
(paren
id|ch-&gt;io_ports
(braket
id|IDE_IRQ_OFFSET
)braket
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Remove us from the lock group.&n;&t; */
id|lock
op_assign
id|ch-&gt;lock
suffix:semicolon
id|d
op_assign
id|ch-&gt;drive
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;de
)paren
(brace
id|devfs_unregister
(paren
id|drive-&gt;de
)paren
suffix:semicolon
id|drive-&gt;de
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
multiline_comment|/* FIXME: possibly unneccessary */
r_if
c_cond
(paren
id|ch-&gt;drive
op_eq
id|drive
)paren
id|ch-&gt;drive
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|drive-&gt;id
)paren
suffix:semicolon
id|drive-&gt;id
op_assign
l_int|NULL
suffix:semicolon
)brace
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
op_amp
id|drive-&gt;queue
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;present
)paren
id|ch-&gt;drive
op_assign
id|d
suffix:semicolon
multiline_comment|/*&n;&t; * Free the irq if we were the only channel using it.&n;&t; *&n;&t; * Free the lock group if we were the only member.&n;&t; */
id|n_irq
op_assign
id|n_ch
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|ata_channel
op_star
id|tmp
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;present
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;irq
op_eq
id|ch-&gt;irq
)paren
op_increment
id|n_irq
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;lock
op_eq
id|ch-&gt;lock
)paren
op_increment
id|n_ch
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n_irq
op_eq
l_int|1
)paren
id|free_irq
c_func
(paren
id|ch-&gt;irq
comma
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_ch
op_eq
l_int|1
)paren
(brace
id|kfree
c_func
(paren
id|ch-&gt;lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ch-&gt;active
)paren
suffix:semicolon
id|ch-&gt;lock
op_assign
l_int|NULL
suffix:semicolon
id|ch-&gt;active
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
id|ide_release_dma
c_func
(paren
id|ch
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Remove us from the kernel&squot;s knowledge.&n;&t; */
id|unregister_blkdev
c_func
(paren
id|ch-&gt;major
comma
id|ch-&gt;name
)paren
suffix:semicolon
id|blk_dev
(braket
id|ch-&gt;major
)braket
dot
id|data
op_assign
l_int|NULL
suffix:semicolon
id|blk_dev
(braket
id|ch-&gt;major
)braket
dot
id|queue
op_assign
l_int|NULL
suffix:semicolon
id|blk_clear
c_func
(paren
id|ch-&gt;major
)paren
suffix:semicolon
id|gd
op_assign
id|ch-&gt;gd
suffix:semicolon
r_if
c_cond
(paren
id|gd
)paren
(brace
id|del_gendisk
c_func
(paren
id|gd
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|gd-&gt;sizes
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|gd-&gt;part
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gd-&gt;de_arr
)paren
id|kfree
(paren
id|gd-&gt;de_arr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gd-&gt;flags
)paren
id|kfree
(paren
id|gd-&gt;flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|gd
)paren
suffix:semicolon
id|ch-&gt;gd
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reinitialize the channel handler, but preserve any special methods for&n;&t; * it.&n;&t; */
id|old
op_assign
op_star
id|ch
suffix:semicolon
id|init_hwif_data
c_func
(paren
id|ch
comma
id|ch-&gt;index
)paren
suffix:semicolon
id|ch-&gt;lock
op_assign
id|old.lock
suffix:semicolon
id|ch-&gt;tuneproc
op_assign
id|old.tuneproc
suffix:semicolon
id|ch-&gt;speedproc
op_assign
id|old.speedproc
suffix:semicolon
id|ch-&gt;selectproc
op_assign
id|old.selectproc
suffix:semicolon
id|ch-&gt;resetproc
op_assign
id|old.resetproc
suffix:semicolon
id|ch-&gt;intrproc
op_assign
id|old.intrproc
suffix:semicolon
id|ch-&gt;maskproc
op_assign
id|old.maskproc
suffix:semicolon
id|ch-&gt;quirkproc
op_assign
id|old.quirkproc
suffix:semicolon
id|ch-&gt;ata_read
op_assign
id|old.ata_read
suffix:semicolon
id|ch-&gt;ata_write
op_assign
id|old.ata_write
suffix:semicolon
id|ch-&gt;atapi_read
op_assign
id|old.atapi_read
suffix:semicolon
id|ch-&gt;atapi_write
op_assign
id|old.atapi_write
suffix:semicolon
id|ch-&gt;udma_setup
op_assign
id|old.udma_setup
suffix:semicolon
id|ch-&gt;udma_enable
op_assign
id|old.udma_enable
suffix:semicolon
id|ch-&gt;udma_start
op_assign
id|old.udma_start
suffix:semicolon
id|ch-&gt;udma_stop
op_assign
id|old.udma_stop
suffix:semicolon
id|ch-&gt;udma_init
op_assign
id|old.udma_init
suffix:semicolon
id|ch-&gt;udma_irq_status
op_assign
id|old.udma_irq_status
suffix:semicolon
id|ch-&gt;udma_timeout
op_assign
id|old.udma_timeout
suffix:semicolon
id|ch-&gt;udma_irq_lost
op_assign
id|old.udma_irq_lost
suffix:semicolon
id|ch-&gt;busproc
op_assign
id|old.busproc
suffix:semicolon
id|ch-&gt;bus_state
op_assign
id|old.bus_state
suffix:semicolon
id|ch-&gt;dma_base
op_assign
id|old.dma_base
suffix:semicolon
id|ch-&gt;dma_extra
op_assign
id|old.dma_extra
suffix:semicolon
id|ch-&gt;config_data
op_assign
id|old.config_data
suffix:semicolon
id|ch-&gt;select_data
op_assign
id|old.select_data
suffix:semicolon
id|ch-&gt;proc
op_assign
id|old.proc
suffix:semicolon
multiline_comment|/* FIXME: most propably this is always right:! */
macro_line|#ifndef CONFIG_BLK_DEV_IDECS
id|ch-&gt;irq
op_assign
id|old.irq
suffix:semicolon
macro_line|#endif
id|ch-&gt;major
op_assign
id|old.major
suffix:semicolon
id|ch-&gt;chipset
op_assign
id|old.chipset
suffix:semicolon
id|ch-&gt;autodma
op_assign
id|old.autodma
suffix:semicolon
id|ch-&gt;udma_four
op_assign
id|old.udma_four
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
id|ch-&gt;pci_dev
op_assign
id|old.pci_dev
suffix:semicolon
macro_line|#endif
id|ch-&gt;straight8
op_assign
id|old.straight8
suffix:semicolon
m_abort
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|subdriver_match
r_static
r_int
id|subdriver_match
c_func
(paren
r_struct
id|ata_channel
op_star
id|channel
comma
r_struct
id|ata_operations
op_star
id|ops
)paren
(brace
r_int
id|count
comma
id|unit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|channel-&gt;present
)paren
r_return
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|channel-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
op_logical_and
op_logical_neg
id|drive-&gt;driver
)paren
(brace
(paren
op_star
id|ops-&gt;attach
)paren
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;driver
op_ne
l_int|NULL
)paren
id|count
op_increment
suffix:semicolon
)brace
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|subdriver_iterator
r_static
r_struct
id|ata_operations
op_star
id|subdriver_iterator
c_func
(paren
r_struct
id|ata_operations
op_star
id|prev
)paren
(brace
r_struct
id|ata_operations
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ata_drivers_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Restart from beginning if current ata_operations was deallocated,&n;&t;   or if prev is NULL. */
r_for
c_loop
(paren
id|tmp
op_assign
id|ata_drivers
suffix:semicolon
id|tmp
op_ne
id|prev
op_logical_and
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
id|tmp
op_assign
id|ata_drivers
suffix:semicolon
r_else
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ata_drivers_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/*&n; * Register an IDE interface, specifing exactly the registers etc&n; * Set initializing=1 iff calling before probes have taken place.&n; */
DECL|function|ide_register_hw
r_int
id|ide_register_hw
c_func
(paren
id|hw_regs_t
op_star
id|hw
)paren
(brace
r_int
id|h
suffix:semicolon
r_int
id|retry
op_assign
l_int|1
suffix:semicolon
r_struct
id|ata_channel
op_star
id|ch
suffix:semicolon
r_struct
id|ata_operations
op_star
id|subdriver
suffix:semicolon
r_do
(brace
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|ch
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;hw.io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
id|hw-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
r_goto
id|found
suffix:semicolon
)brace
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|ch
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|ch-&gt;present
op_logical_and
(paren
id|ch-&gt;unit
op_eq
id|ATA_PRIMARY
)paren
op_logical_and
op_logical_neg
id|initializing
)paren
op_logical_or
(paren
op_logical_neg
id|ch-&gt;hw.io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_logical_and
id|initializing
)paren
)paren
r_goto
id|found
suffix:semicolon
)brace
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
id|ide_unregister
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|h
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retry
op_decrement
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
id|found
suffix:colon
id|ide_unregister
c_func
(paren
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;present
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ch-&gt;hw
comma
id|hw
comma
r_sizeof
(paren
op_star
id|hw
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ch-&gt;io_ports
comma
id|ch-&gt;hw.io_ports
comma
r_sizeof
(paren
id|ch-&gt;hw.io_ports
)paren
)paren
suffix:semicolon
id|ch-&gt;irq
op_assign
id|hw-&gt;irq
suffix:semicolon
id|ch-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;chipset
op_assign
id|hw-&gt;chipset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initializing
)paren
(brace
id|ideprobe_init
c_func
(paren
)paren
suffix:semicolon
id|revalidate_drives
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: Do we really have to call it second time here?! */
id|ide_driver_module
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Look up whatever there is a subdriver, which will serve this&n;&t; * device.&n;&t; */
id|subdriver
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|subdriver
op_assign
id|subdriver_iterator
c_func
(paren
id|subdriver
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|subdriver_match
c_func
(paren
id|ch
comma
id|subdriver
)paren
OG
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_return
(paren
id|initializing
op_logical_or
id|ch-&gt;present
)paren
ques
c_cond
id|h
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * FIXME: rewrite the following crap:&n; */
multiline_comment|/*&n; * stridx() returns the offset of c within s,&n; * or -1 if c is &squot;&bslash;0&squot; or not found within s.&n; */
DECL|function|stridx
r_static
r_int
id|__init
id|stridx
(paren
r_const
r_char
op_star
id|s
comma
r_char
id|c
)paren
(brace
r_char
op_star
id|i
op_assign
id|strchr
c_func
(paren
id|s
comma
id|c
)paren
suffix:semicolon
r_return
(paren
id|i
op_logical_and
id|c
)paren
ques
c_cond
id|i
op_minus
id|s
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Parsing for ide_setup():&n; *&n; * 1. the first char of s must be &squot;=&squot;.&n; * 2. if the remainder matches one of the supplied keywords,&n; *     the index (1 based) of the keyword is negated and returned.&n; * 3. if the remainder is a series of no more than max_vals numbers&n; *     separated by commas, the numbers are saved in vals[] and a&n; *     count of how many were saved is returned.  Base10 is assumed,&n; *     and base16 is allowed when prefixed with &quot;0x&quot;.&n; * 4. otherwise, zero is returned.&n; */
DECL|function|match_parm
r_static
r_int
id|__init
id|match_parm
(paren
r_char
op_star
id|s
comma
r_const
r_char
op_star
id|keywords
(braket
)braket
comma
r_int
id|vals
(braket
)braket
comma
r_int
id|max_vals
)paren
(brace
r_static
r_const
r_char
op_star
id|decimal
op_assign
l_string|&quot;0123456789&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|hex
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_increment
op_eq
l_char|&squot;=&squot;
)paren
(brace
multiline_comment|/*&n;&t;&t; * Try matching against the supplied keywords,&n;&t;&t; * and return -(index+1) if we match one&n;&t;&t; */
r_if
c_cond
(paren
id|keywords
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|keywords
op_ne
l_int|NULL
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
op_star
id|keywords
op_increment
)paren
)paren
r_return
op_minus
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Look for a series of no more than &quot;max_vals&quot;&n;&t;&t; * numeric values separated by commas, in base10,&n;&t;&t; * or base16 when prefixed with &quot;0x&quot;.&n;&t;&t; * Return a count of how many were found.&n;&t;&t; */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
(paren
id|i
op_assign
id|stridx
c_func
(paren
id|decimal
comma
op_star
id|s
)paren
)paren
op_ge
l_int|0
suffix:semicolon
)paren
(brace
id|vals
(braket
id|n
)braket
op_assign
id|i
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
op_assign
id|stridx
c_func
(paren
id|decimal
comma
op_star
op_increment
id|s
)paren
)paren
op_ge
l_int|0
)paren
id|vals
(braket
id|n
)braket
op_assign
(paren
id|vals
(braket
id|n
)braket
op_star
l_int|10
)paren
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;x&squot;
op_logical_and
op_logical_neg
id|vals
(braket
id|n
)braket
)paren
(brace
r_while
c_loop
(paren
(paren
id|i
op_assign
id|stridx
c_func
(paren
id|hex
comma
op_star
op_increment
id|s
)paren
)paren
op_ge
l_int|0
)paren
id|vals
(braket
id|n
)braket
op_assign
(paren
id|vals
(braket
id|n
)braket
op_star
l_int|0x10
)paren
op_plus
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|n
op_eq
id|max_vals
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;,&squot;
op_logical_or
op_star
id|s
op_eq
l_char|&squot;;&squot;
)paren
op_increment
id|s
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|s
)paren
r_return
id|n
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* zero = nothing matched */
)brace
multiline_comment|/*&n; * This sets reasonable default values into all fields of all instances of the&n; * channles and drives, but only on the first call.  Subsequent calls have no&n; * effect (they don&squot;t wipe out anything).&n; *&n; * This routine is normally called at driver initialization time, but may also&n; * be called MUCH earlier during kernel &quot;command-line&quot; parameter processing.&n; * As such, we cannot depend on any other parts of the kernel (such as memory&n; * allocation) to be functioning yet.&n; *&n; * This is too bad, as otherwise we could dynamically allocate the ata_device&n; * structs as needed, rather than always consuming memory for the max possible&n; * number (MAX_HWIFS * MAX_DRIVES) of them.&n; */
DECL|macro|MAGIC_COOKIE
mdefine_line|#define MAGIC_COOKIE 0x12345678
DECL|function|init_global_data
r_static
r_void
id|__init
id|init_global_data
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|h
suffix:semicolon
r_static
r_int
r_int
id|magic_cookie
op_assign
id|MAGIC_COOKIE
suffix:semicolon
r_if
c_cond
(paren
id|magic_cookie
op_ne
id|MAGIC_COOKIE
)paren
r_return
suffix:semicolon
multiline_comment|/* already initialized */
id|magic_cookie
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize all interface structures */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
id|init_hwif_data
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|h
)braket
comma
id|h
)paren
suffix:semicolon
multiline_comment|/* Add default hw interfaces */
id|ide_init_default_hwifs
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This gets called VERY EARLY during initialization, to handle kernel &quot;command&n; * line&quot; strings beginning with &quot;hdx=&quot; or &quot;ide&quot;.It gets called even before the&n; * actual module gets initialized.&n; *&n; * Please look at Documentation/ide.txt to see the complete list of supported&n; * options.&n; */
DECL|function|ide_setup
r_int
id|__init
id|ide_setup
c_func
(paren
r_char
op_star
id|s
)paren
(brace
r_int
id|i
comma
id|vals
(braket
l_int|3
)braket
suffix:semicolon
r_struct
id|ata_channel
op_star
id|ch
suffix:semicolon
r_struct
id|ata_device
op_star
id|drive
suffix:semicolon
r_int
r_int
id|hw
comma
id|unit
suffix:semicolon
r_const
r_char
id|max_drive
op_assign
l_char|&squot;a&squot;
op_plus
(paren
(paren
id|MAX_HWIFS
op_star
id|MAX_DRIVES
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_const
r_char
id|max_ch
op_assign
l_char|&squot;0&squot;
op_plus
(paren
id|MAX_HWIFS
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;hd=&quot;
comma
l_int|3
)paren
)paren
multiline_comment|/* hd= is for hd.c driver and not us */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;ide&quot;
comma
l_int|3
)paren
op_logical_and
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;idebus&quot;
comma
l_int|6
)paren
op_logical_and
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;hd&quot;
comma
l_int|2
)paren
)paren
multiline_comment|/* hdx= &amp; hdxlun= */
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ide_setup: %s&quot;
comma
id|s
)paren
suffix:semicolon
id|init_global_data
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDOUBLER
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ide=doubler&quot;
)paren
)paren
(brace
r_extern
r_int
id|ide_doubler
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; : Enabled support for IDE doublers&bslash;n&quot;
)paren
suffix:semicolon
id|ide_doubler
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ide=nodma&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: Prevented DMA&bslash;n&quot;
)paren
suffix:semicolon
id|noautodma
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;ide=reverse&quot;
)paren
)paren
(brace
id|ide_scan_direction
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; : Enabled support for IDE inverse scan order.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Look for drive options:  &quot;hdx=&quot;&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;hd&quot;
comma
l_int|2
)paren
op_logical_and
id|s
(braket
l_int|2
)braket
op_ge
l_char|&squot;a&squot;
op_logical_and
id|s
(braket
l_int|2
)braket
op_le
id|max_drive
)paren
(brace
r_const
r_char
op_star
id|hd_words
(braket
)braket
op_assign
(brace
l_string|&quot;none&quot;
comma
l_string|&quot;noprobe&quot;
comma
l_string|&quot;nowerr&quot;
comma
l_string|&quot;cdrom&quot;
comma
l_string|&quot;serialize&quot;
comma
l_string|&quot;autotune&quot;
comma
l_string|&quot;noautotune&quot;
comma
l_string|&quot;slow&quot;
comma
l_string|&quot;flash&quot;
comma
l_string|&quot;remap&quot;
comma
l_string|&quot;noremap&quot;
comma
l_string|&quot;scsi&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|unit
op_assign
id|s
(braket
l_int|2
)braket
op_minus
l_char|&squot;a&squot;
suffix:semicolon
id|hw
op_assign
id|unit
op_div
id|MAX_DRIVES
suffix:semicolon
id|unit
op_assign
id|unit
op_mod
id|MAX_DRIVES
suffix:semicolon
id|ch
op_assign
op_amp
id|ide_hwifs
(braket
id|hw
)braket
suffix:semicolon
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|s
op_plus
l_int|4
comma
l_string|&quot;ide-&quot;
comma
l_int|4
)paren
)paren
(brace
id|strncpy
c_func
(paren
id|drive-&gt;driver_req
comma
id|s
op_plus
l_int|4
comma
l_int|9
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Look for last lun option:  &quot;hdxlun=&quot;&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
op_amp
id|s
(braket
l_int|3
)braket
comma
l_string|&quot;lun&quot;
comma
l_int|3
)paren
)paren
(brace
r_if
c_cond
(paren
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|6
)braket
comma
l_int|NULL
comma
id|vals
comma
l_int|1
)paren
op_ne
l_int|1
)paren
r_goto
id|bad_option
suffix:semicolon
r_if
c_cond
(paren
id|vals
(braket
l_int|0
)braket
op_ge
l_int|0
op_logical_and
id|vals
(braket
l_int|0
)braket
op_le
l_int|7
)paren
(brace
id|drive-&gt;last_lun
op_assign
id|vals
(braket
l_int|0
)braket
suffix:semicolon
id|drive-&gt;forced_lun
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; -- BAD LAST LUN! Expected value from 0 to 7&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|3
)braket
comma
id|hd_words
comma
id|vals
comma
l_int|3
)paren
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
multiline_comment|/* &quot;none&quot; */
id|drive-&gt;nobios
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* drop into &quot;noprobe&quot; */
r_case
op_minus
l_int|2
suffix:colon
multiline_comment|/* &quot;noprobe&quot; */
id|drive-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|3
suffix:colon
multiline_comment|/* &quot;nowerr&quot; */
id|drive-&gt;bad_wstat
op_assign
id|BAD_R_STAT
suffix:semicolon
id|ch-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|4
suffix:colon
multiline_comment|/* &quot;cdrom&quot; */
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;type
op_assign
id|ATA_ROM
suffix:semicolon
id|ch-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|5
suffix:colon
multiline_comment|/* &quot;serialize&quot; */
id|printk
c_func
(paren
l_string|&quot; -- USE &bslash;&quot;ide%d=serialize&bslash;&quot; INSTEAD&quot;
comma
id|hw
)paren
suffix:semicolon
r_goto
id|do_serialize
suffix:semicolon
r_case
op_minus
l_int|6
suffix:colon
multiline_comment|/* &quot;autotune&quot; */
id|drive-&gt;autotune
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|7
suffix:colon
multiline_comment|/* &quot;noautotune&quot; */
id|drive-&gt;autotune
op_assign
l_int|2
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|8
suffix:colon
multiline_comment|/* &quot;slow&quot; */
id|ch-&gt;slow
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|9
suffix:colon
multiline_comment|/* &quot;flash&quot; */
id|drive-&gt;ata_flash
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|10
suffix:colon
multiline_comment|/* &quot;remap&quot; */
id|drive-&gt;remap_0_to_1
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|11
suffix:colon
multiline_comment|/* &quot;noremap&quot; */
id|drive-&gt;remap_0_to_1
op_assign
l_int|2
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|12
suffix:colon
multiline_comment|/* &quot;scsi&quot; */
macro_line|#if defined(CONFIG_BLK_DEV_IDESCSI) &amp;&amp; defined(CONFIG_SCSI)
id|drive-&gt;scsi
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#else
id|drive-&gt;scsi
op_assign
l_int|0
suffix:semicolon
r_goto
id|bad_option
suffix:semicolon
macro_line|#endif
r_case
l_int|3
suffix:colon
multiline_comment|/* cyl,head,sect */
id|drive-&gt;type
op_assign
id|ATA_DISK
suffix:semicolon
id|drive-&gt;cyl
op_assign
id|drive-&gt;bios_cyl
op_assign
id|vals
(braket
l_int|0
)braket
suffix:semicolon
id|drive-&gt;head
op_assign
id|drive-&gt;bios_head
op_assign
id|vals
(braket
l_int|1
)braket
suffix:semicolon
id|drive-&gt;sect
op_assign
id|drive-&gt;bios_sect
op_assign
id|vals
(braket
l_int|2
)braket
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;forced_geom
op_assign
l_int|1
suffix:semicolon
id|ch-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_default
suffix:colon
r_goto
id|bad_option
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Look for bus speed option:  &quot;idebus=&quot;&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;idebus&quot;
comma
l_int|6
)paren
)paren
(brace
r_if
c_cond
(paren
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|6
)braket
comma
l_int|NULL
comma
id|vals
comma
l_int|1
)paren
op_ne
l_int|1
)paren
r_goto
id|bad_option
suffix:semicolon
id|idebus_parameter
op_assign
id|vals
(braket
l_int|0
)braket
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Look for interface options:  &quot;idex=&quot;&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;ide&quot;
comma
l_int|3
)paren
op_logical_and
id|s
(braket
l_int|3
)braket
op_ge
l_char|&squot;0&squot;
op_logical_and
id|s
(braket
l_int|3
)braket
op_le
id|max_ch
)paren
(brace
multiline_comment|/*&n;&t;&t; * Be VERY CAREFUL changing this: note hardcoded indexes below&n;&t;&t; * -8,-9,-10. -11 : are reserved for future idex calls to ease the hardcoding.&n;&t;&t; */
r_const
r_char
op_star
id|ide_words
(braket
)braket
op_assign
(brace
l_string|&quot;noprobe&quot;
comma
l_string|&quot;serialize&quot;
comma
l_string|&quot;autotune&quot;
comma
l_string|&quot;noautotune&quot;
comma
l_string|&quot;reset&quot;
comma
l_string|&quot;dma&quot;
comma
l_string|&quot;ata66&quot;
comma
l_string|&quot;minus8&quot;
comma
l_string|&quot;minus9&quot;
comma
l_string|&quot;minus10&quot;
comma
l_string|&quot;minus11&quot;
comma
l_string|&quot;qd65xx&quot;
comma
l_string|&quot;ht6560b&quot;
comma
l_string|&quot;cmd640_vlb&quot;
comma
l_string|&quot;dtc2278&quot;
comma
l_string|&quot;umc8672&quot;
comma
l_string|&quot;ali14xx&quot;
comma
l_string|&quot;dc4030&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|hw
op_assign
id|s
(braket
l_int|3
)braket
op_minus
l_char|&squot;0&squot;
suffix:semicolon
id|ch
op_assign
op_amp
id|ide_hwifs
(braket
id|hw
)braket
suffix:semicolon
id|i
op_assign
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|4
)braket
comma
id|ide_words
comma
id|vals
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Cryptic check to ensure chipset not already set for a channel:&n;&t;&t; */
r_if
c_cond
(paren
id|i
OG
l_int|0
op_logical_or
id|i
op_le
op_minus
l_int|11
)paren
(brace
multiline_comment|/* is parameter a chipset name? */
r_if
c_cond
(paren
id|ch-&gt;chipset
op_ne
id|ide_unknown
)paren
r_goto
id|bad_option
suffix:semicolon
multiline_comment|/* chipset already specified */
r_if
c_cond
(paren
id|i
op_le
op_minus
l_int|11
op_logical_and
id|i
op_ne
op_minus
l_int|18
op_logical_and
id|hw
op_ne
l_int|0
)paren
r_goto
id|bad_channel
suffix:semicolon
multiline_comment|/* chipset drivers are for &quot;ide0=&quot; only */
r_if
c_cond
(paren
id|i
op_le
op_minus
l_int|11
op_logical_and
id|i
op_ne
op_minus
l_int|18
op_logical_and
id|ide_hwifs
(braket
id|hw
op_plus
l_int|1
)braket
dot
id|chipset
op_ne
id|ide_unknown
)paren
r_goto
id|bad_option
suffix:semicolon
multiline_comment|/* chipset for 2nd port already specified */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|i
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
r_case
op_minus
l_int|18
suffix:colon
multiline_comment|/* &quot;dc4030&quot; */
(brace
r_extern
r_void
id|init_pdc4030
c_func
(paren
r_void
)paren
suffix:semicolon
id|init_pdc4030
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_ALI14XX
r_case
op_minus
l_int|17
suffix:colon
multiline_comment|/* &quot;ali14xx&quot; */
(brace
r_extern
r_void
id|init_ali14xx
(paren
r_void
)paren
suffix:semicolon
id|init_ali14xx
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_UMC8672
r_case
op_minus
l_int|16
suffix:colon
multiline_comment|/* &quot;umc8672&quot; */
(brace
r_extern
r_void
id|init_umc8672
(paren
r_void
)paren
suffix:semicolon
id|init_umc8672
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_DTC2278
r_case
op_minus
l_int|15
suffix:colon
multiline_comment|/* &quot;dtc2278&quot; */
(brace
r_extern
r_void
id|init_dtc2278
(paren
r_void
)paren
suffix:semicolon
id|init_dtc2278
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_CMD640
r_case
op_minus
l_int|14
suffix:colon
multiline_comment|/* &quot;cmd640_vlb&quot; */
(brace
r_extern
r_int
id|cmd640_vlb
suffix:semicolon
multiline_comment|/* flag for cmd640.c */
id|cmd640_vlb
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_HT6560B
r_case
op_minus
l_int|13
suffix:colon
multiline_comment|/* &quot;ht6560b&quot; */
(brace
r_extern
r_void
id|init_ht6560b
(paren
r_void
)paren
suffix:semicolon
id|init_ht6560b
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if CONFIG_BLK_DEV_QD65XX
r_case
op_minus
l_int|12
suffix:colon
multiline_comment|/* &quot;qd65xx&quot; */
(brace
r_extern
r_void
id|init_qd65xx
(paren
r_void
)paren
suffix:semicolon
id|init_qd65xx
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif
r_case
op_minus
l_int|11
suffix:colon
multiline_comment|/* minus11 */
r_case
op_minus
l_int|10
suffix:colon
multiline_comment|/* minus10 */
r_case
op_minus
l_int|9
suffix:colon
multiline_comment|/* minus9 */
r_case
op_minus
l_int|8
suffix:colon
multiline_comment|/* minus8 */
r_goto
id|bad_option
suffix:semicolon
r_case
op_minus
l_int|7
suffix:colon
multiline_comment|/* ata66 */
macro_line|#ifdef CONFIG_PCI
id|ch-&gt;udma_four
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#else
id|ch-&gt;udma_four
op_assign
l_int|0
suffix:semicolon
r_goto
id|bad_channel
suffix:semicolon
macro_line|#endif
r_case
op_minus
l_int|6
suffix:colon
multiline_comment|/* dma */
id|ch-&gt;autodma
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|5
suffix:colon
multiline_comment|/* reset */
id|ch-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|4
suffix:colon
multiline_comment|/* noautotune */
id|ch-&gt;drives
(braket
l_int|0
)braket
dot
id|autotune
op_assign
l_int|2
suffix:semicolon
id|ch-&gt;drives
(braket
l_int|1
)braket
dot
id|autotune
op_assign
l_int|2
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|3
suffix:colon
multiline_comment|/* autotune */
id|ch-&gt;drives
(braket
l_int|0
)braket
dot
id|autotune
op_assign
l_int|1
suffix:semicolon
id|ch-&gt;drives
(braket
l_int|1
)braket
dot
id|autotune
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|2
suffix:colon
multiline_comment|/* &quot;serialize&quot; */
id|do_serialize
suffix:colon
(brace
r_struct
id|ata_channel
op_star
id|mate
suffix:semicolon
id|mate
op_assign
op_amp
id|ide_hwifs
(braket
id|hw
op_xor
l_int|1
)braket
suffix:semicolon
id|ch-&gt;serialized
op_assign
l_int|1
suffix:semicolon
id|mate-&gt;serialized
op_assign
l_int|1
suffix:semicolon
)brace
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|1
suffix:colon
multiline_comment|/* &quot;noprobe&quot; */
id|ch-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* base */
id|vals
(braket
l_int|1
)braket
op_assign
id|vals
(braket
l_int|0
)braket
op_plus
l_int|0x206
suffix:semicolon
multiline_comment|/* default ctl */
r_case
l_int|2
suffix:colon
multiline_comment|/* base,ctl */
id|vals
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default irq = probe for it */
r_case
l_int|3
suffix:colon
multiline_comment|/* base,ctl,irq */
id|ch-&gt;hw.irq
op_assign
id|vals
(braket
l_int|2
)braket
suffix:semicolon
id|ide_init_hwif_ports
c_func
(paren
op_amp
id|ch-&gt;hw
comma
(paren
id|ide_ioreg_t
)paren
id|vals
(braket
l_int|0
)braket
comma
(paren
id|ide_ioreg_t
)paren
id|vals
(braket
l_int|1
)braket
comma
op_amp
id|ch-&gt;irq
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ch-&gt;io_ports
comma
id|ch-&gt;hw.io_ports
comma
r_sizeof
(paren
id|ch-&gt;io_ports
)paren
)paren
suffix:semicolon
id|ch-&gt;irq
op_assign
id|vals
(braket
l_int|2
)braket
suffix:semicolon
id|ch-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;chipset
op_assign
id|ide_generic
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
l_int|0
suffix:colon
r_goto
id|bad_option
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot; -- SUPPORT NOT CONFIGURED IN THIS KERNEL&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|bad_option
suffix:colon
id|printk
c_func
(paren
l_string|&quot; -- BAD OPTION&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|bad_channel
suffix:colon
id|printk
c_func
(paren
l_string|&quot;-- NOT SUPPORTED ON ide%d&quot;
comma
id|hw
)paren
suffix:semicolon
id|done
suffix:colon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/****************************************************************************/
multiline_comment|/*&n; * This is in fact registering a device not a driver.&n; */
DECL|function|ide_register_subdriver
r_int
id|ide_register_subdriver
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
comma
r_struct
id|ata_operations
op_star
id|driver
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* FIXME: The locking here doesn&squot;t make the slightest sense! */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
op_logical_or
id|drive-&gt;driver
op_ne
l_int|NULL
op_logical_or
id|drive-&gt;busy
op_logical_or
id|drive-&gt;usage
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* FIXME: This will be pushed to the drivers! Thus allowing us to&n;&t; * save one parameter here and to separate this out.&n;&t; */
id|drive-&gt;driver
op_assign
id|driver
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ide_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Default autotune or requested autotune */
r_if
c_cond
(paren
id|drive-&gt;autotune
op_ne
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;udma_setup
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Force DMAing for the beginning of the check.  Some&n;&t;&t;&t; * chipsets appear to do interesting things, if not&n;&t;&t;&t; * checked and cleared.&n;&t;&t;&t; *&n;&t;&t;&t; *   PARANOIA!!!&n;&t;&t;&t; */
id|udma_enable
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|drive-&gt;channel
op_member_access_from_pointer
id|udma_setup
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE_TCQ_DEFAULT
id|udma_tcq_enable
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Only CD-ROMs and tape drives support DSC overlap.  But only&n;&t;&t; * if they are alone on a channel. */
r_if
c_cond
(paren
id|drive-&gt;type
op_eq
id|ATA_ROM
op_logical_or
id|drive-&gt;type
op_eq
id|ATA_TAPE
)paren
(brace
r_int
id|single
op_assign
l_int|0
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
r_if
c_cond
(paren
id|drive-&gt;channel-&gt;drives
(braket
id|unit
)braket
dot
id|present
)paren
op_increment
id|single
suffix:semicolon
id|drive-&gt;dsc_overlap
op_assign
(paren
id|single
op_eq
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|drive-&gt;dsc_overlap
op_assign
l_int|0
suffix:semicolon
)brace
id|drive-&gt;revalidate
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;suspend_reset
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is in fact the default cleanup routine.&n; *&n; * FIXME: Check whatever we maybe don&squot;t call it twice!.&n; */
DECL|function|ide_unregister_subdriver
r_int
id|ide_unregister_subdriver
c_func
(paren
r_struct
id|ata_device
op_star
id|drive
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* all CPUs */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* all CPUs */
macro_line|#if 0
r_if
c_cond
(paren
id|__MOD_IN_USE
c_func
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|owner
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|drive-&gt;usage
op_logical_or
id|drive-&gt;busy
op_logical_or
op_logical_neg
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* all CPUs */
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_BLK_DEV_ISAPNP) &amp;&amp; defined(CONFIG_ISAPNP) &amp;&amp; defined(MODULE)
id|pnpide_init
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|drive-&gt;driver
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* all CPUs */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Register an ATA subdriver for a particular device type.&n; */
DECL|function|register_ata_driver
r_int
id|register_ata_driver
c_func
(paren
r_struct
id|ata_operations
op_star
id|driver
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ata_drivers_lock
comma
id|flags
)paren
suffix:semicolon
id|driver-&gt;next
op_assign
id|ata_drivers
suffix:semicolon
id|ata_drivers
op_assign
id|driver
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ata_drivers_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
id|count
op_add_assign
id|subdriver_match
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|index
)braket
comma
id|driver
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|variable|register_ata_driver
id|EXPORT_SYMBOL
c_func
(paren
id|register_ata_driver
)paren
suffix:semicolon
multiline_comment|/*&n; * Unregister an ATA subdriver for a particular device type.&n; */
DECL|function|unregister_ata_driver
r_void
id|unregister_ata_driver
c_func
(paren
r_struct
id|ata_operations
op_star
id|driver
)paren
(brace
r_struct
id|ata_operations
op_star
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|unit
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ata_drivers_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
op_amp
id|ata_drivers
suffix:semicolon
op_star
id|tmp
op_ne
l_int|NULL
suffix:semicolon
id|tmp
op_assign
op_amp
(paren
op_star
id|tmp
)paren
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
op_star
id|tmp
op_eq
id|driver
)paren
(brace
op_star
id|tmp
op_assign
id|driver-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ata_drivers_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
(brace
r_struct
id|ata_channel
op_star
id|ch
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;driver
op_eq
id|driver
)paren
(paren
op_star
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
)paren
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|unregister_ata_driver
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_ata_driver
)paren
suffix:semicolon
DECL|variable|ide_hwifs
id|EXPORT_SYMBOL
c_func
(paren
id|ide_hwifs
)paren
suffix:semicolon
DECL|variable|ide_lock
id|EXPORT_SYMBOL
c_func
(paren
id|ide_lock
)paren
suffix:semicolon
DECL|variable|ide_devfs_handle
id|devfs_handle_t
id|ide_devfs_handle
suffix:semicolon
DECL|variable|ide_register_subdriver
id|EXPORT_SYMBOL
c_func
(paren
id|ide_register_subdriver
)paren
suffix:semicolon
DECL|variable|ide_unregister_subdriver
id|EXPORT_SYMBOL
c_func
(paren
id|ide_unregister_subdriver
)paren
suffix:semicolon
DECL|variable|ata_revalidate
id|EXPORT_SYMBOL
c_func
(paren
id|ata_revalidate
)paren
suffix:semicolon
DECL|variable|ide_register_hw
id|EXPORT_SYMBOL
c_func
(paren
id|ide_register_hw
)paren
suffix:semicolon
DECL|variable|ide_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|ide_unregister
)paren
suffix:semicolon
DECL|variable|get_info_ptr
id|EXPORT_SYMBOL
c_func
(paren
id|get_info_ptr
)paren
suffix:semicolon
multiline_comment|/*&n; * Handle power handling related events ths system informs us about.&n; */
DECL|function|ata_sys_notify
r_static
r_int
id|ata_sys_notify
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|x
)paren
(brace
r_int
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|SYS_HALT
suffix:colon
r_case
id|SYS_POWER_OFF
suffix:colon
r_case
id|SYS_RESTART
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;flushing ide devices: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HWIFS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|unit
suffix:semicolon
r_struct
id|ata_channel
op_star
id|ch
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch-&gt;present
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
r_struct
id|ata_device
op_star
id|drive
op_assign
op_amp
id|ch-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
multiline_comment|/* set the drive to standby */
id|printk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
)paren
(brace
r_if
c_cond
(paren
id|event
op_ne
id|SYS_RESTART
)paren
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|standby
op_logical_and
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|standby
c_func
(paren
id|drive
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
)paren
id|ata_ops
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cleanup
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|ata_notifier
r_static
r_struct
id|notifier_block
id|ata_notifier
op_assign
(brace
id|ata_sys_notify
comma
l_int|NULL
comma
l_int|5
)brace
suffix:semicolon
multiline_comment|/*&n; * This is the global initialization entry point.&n; */
DECL|function|ata_module_init
r_static
r_int
id|__init
id|ata_module_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA/ATAPI device driver v&quot;
id|VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ide_devfs_handle
op_assign
id|devfs_mk_dir
c_func
(paren
l_int|NULL
comma
l_string|&quot;ata&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_mk_symlink
c_func
(paren
l_int|NULL
comma
l_string|&quot;ide&quot;
comma
id|DEVFS_FL_DEFAULT
comma
l_string|&quot;ata&quot;
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Because most of the ATA adapters represent the timings in unit of&n;&t; * bus clocks, and there is no known reliable way to detect the bus&n;&t; * clock frequency, we assume 50 MHz for non-PCI (VLB, EISA) and 33 MHz&n;&t; * for PCI based systems. Since assuming only hurts performance and not&n;&t; * stability, this is OK. The user can change this on the command line&n;&t; * by using the &quot;idebus=XX&quot; parameter. While the system_bus_speed&n;&t; * variable is in kHz units, we accept both MHz and kHz entry on the&n;&t; * command line for backward compatibility.&n;&t; */
id|system_bus_speed
op_assign
l_int|50000
suffix:semicolon
r_if
c_cond
(paren
id|pci_present
c_func
(paren
)paren
)paren
id|system_bus_speed
op_assign
l_int|33333
suffix:semicolon
r_if
c_cond
(paren
id|idebus_parameter
op_ge
l_int|20
op_logical_and
id|idebus_parameter
op_le
l_int|80
)paren
(brace
id|system_bus_speed
op_assign
id|idebus_parameter
op_star
l_int|1000
suffix:semicolon
r_switch
c_cond
(paren
id|system_bus_speed
)paren
(brace
r_case
l_int|33000
suffix:colon
id|system_bus_speed
op_assign
l_int|33333
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|37000
suffix:colon
id|system_bus_speed
op_assign
l_int|37500
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|41000
suffix:colon
id|system_bus_speed
op_assign
l_int|41666
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|66000
suffix:colon
id|system_bus_speed
op_assign
l_int|66666
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|idebus_parameter
op_ge
l_int|20000
op_logical_and
id|idebus_parameter
op_le
l_int|80000
)paren
id|system_bus_speed
op_assign
id|idebus_parameter
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ATA: %s bus speed %d.%dMHz&bslash;n&quot;
comma
id|pci_present
c_func
(paren
)paren
ques
c_cond
l_string|&quot;PCI&quot;
suffix:colon
l_string|&quot;System&quot;
comma
id|system_bus_speed
op_div
l_int|1000
comma
id|system_bus_speed
op_div
l_int|100
op_mod
l_int|10
)paren
suffix:semicolon
id|init_global_data
c_func
(paren
)paren
suffix:semicolon
id|initializing
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
multiline_comment|/*&n;&t; * Register the host chip drivers.&n;&t; */
macro_line|# ifdef CONFIG_BLK_DEV_PIIX
id|init_piix
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_VIA82CXXX
id|init_via82cxxx
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_PDC202XX
id|init_pdc202xx
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_RZ1000
id|init_rz1000
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_SIS5513
id|init_sis5513
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_CMD64X
id|init_cmd64x
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_OPTI621
id|init_opti621
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_TRM290
id|init_trm290
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_NS87415
id|init_ns87415
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_AEC62XX
id|init_aec62xx
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_SL82C105
id|init_sl82c105
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_HPT34X
id|init_hpt34x
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_HPT366
id|init_hpt366
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_ALI15X3
id|init_ali15x3
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_CY82C693
id|init_cy82c693
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_CS5530
id|init_cs5530
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_AMD74XX
id|init_amd74xx
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_SVWKS
id|init_svwks
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
macro_line|# ifdef CONFIG_BLK_DEV_IT8172
id|init_it8172
c_func
(paren
)paren
suffix:semicolon
macro_line|# endif
id|init_ata_pci_misc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Detect and initialize &quot;known&quot; IDE host chip types.&n;&t; */
r_if
c_cond
(paren
id|pci_present
c_func
(paren
)paren
)paren
(brace
macro_line|# ifdef CONFIG_PCI
id|ide_scan_pcibus
c_func
(paren
id|ide_scan_direction
)paren
suffix:semicolon
macro_line|# else
macro_line|#  ifdef CONFIG_BLK_DEV_RZ1000
id|ide_probe_for_rz100x
c_func
(paren
)paren
suffix:semicolon
macro_line|#  endif
macro_line|# endif
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_IDE
id|init_e100_ide
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_CMD640
id|ide_probe_for_cmd640x
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_PDC4030
id|ide_probe_for_pdc4030
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDE_PMAC
id|pmac_ide_probe
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDE_ICSIDE
id|icside_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDE_RAPIDE
id|rapide_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_GAYLE
id|gayle_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_FALCON_IDE
id|falconide_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_MAC_IDE
id|macide_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_Q40IDE
id|q40ide_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_BUDDHA
id|buddha_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_BLK_DEV_ISAPNP) &amp;&amp; defined(CONFIG_ISAPNP)
id|pnpide_init
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
macro_line|# if defined(__mc68000__) || defined(CONFIG_APUS)
r_if
c_cond
(paren
id|ide_hwifs
(braket
l_int|0
)braket
dot
id|io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
(brace
singleline_comment|// ide_get_lock(&amp;irq_lock, NULL, NULL);/* for atari only */
id|disable_irq
c_func
(paren
id|ide_hwifs
(braket
l_int|0
)braket
dot
id|irq
)paren
suffix:semicolon
multiline_comment|/* disable_irq_nosync ?? */
singleline_comment|//&t;&t;disable_irq_nosync(ide_hwifs[0].irq);
)brace
macro_line|# endif
id|ideprobe_init
c_func
(paren
)paren
suffix:semicolon
macro_line|# if defined(__mc68000__) || defined(CONFIG_APUS)
r_if
c_cond
(paren
id|ide_hwifs
(braket
l_int|0
)braket
dot
id|io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
(brace
id|enable_irq
c_func
(paren
id|ide_hwifs
(braket
l_int|0
)braket
dot
id|irq
)paren
suffix:semicolon
id|ide_release_lock
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
multiline_comment|/* for atari only */
)brace
macro_line|# endif
macro_line|#endif
multiline_comment|/*&n;&t; * Initialize all device type driver modules.&n;&t; */
macro_line|#ifdef CONFIG_BLK_DEV_IDEDISK
id|idedisk_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
id|ide_cdrom_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
id|idetape_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDEFLOPPY
id|idefloppy_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|initializing
op_assign
l_int|0
suffix:semicolon
id|register_reboot_notifier
c_func
(paren
op_amp
id|ata_notifier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|options
r_static
r_char
op_star
id|options
op_assign
l_int|NULL
suffix:semicolon
DECL|function|init_ata
r_static
r_int
id|__init
id|init_ata
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|options
op_ne
l_int|NULL
op_logical_and
op_star
id|options
)paren
(brace
r_char
op_star
id|next
op_assign
id|options
suffix:semicolon
r_while
c_loop
(paren
(paren
id|options
op_assign
id|next
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|next
op_assign
id|strchr
c_func
(paren
id|options
comma
l_char|&squot; &squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_star
id|next
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ide_setup
c_func
(paren
id|options
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unknown option &squot;%s&squot;&bslash;n&quot;
comma
id|options
)paren
suffix:semicolon
)brace
)brace
r_return
id|ata_module_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_ata
r_static
r_void
id|__exit
id|cleanup_ata
c_func
(paren
r_void
)paren
(brace
r_int
id|h
suffix:semicolon
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|ata_notifier
)paren
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|ide_unregister
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|h
)braket
)paren
suffix:semicolon
)brace
id|devfs_unregister
c_func
(paren
id|ide_devfs_handle
)paren
suffix:semicolon
)brace
DECL|variable|init_ata
id|module_init
c_func
(paren
id|init_ata
)paren
suffix:semicolon
DECL|variable|cleanup_ata
id|module_exit
c_func
(paren
id|cleanup_ata
)paren
suffix:semicolon
macro_line|#ifndef MODULE
multiline_comment|/* command line option parser */
id|__setup
c_func
(paren
l_string|&quot;&quot;
comma
id|ide_setup
)paren
suffix:semicolon
macro_line|#endif
eof
