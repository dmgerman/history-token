multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2003-2005 Silicon Graphics, Inc.  All Rights Reserved.&n; */
multiline_comment|/*&n; * This file contains a module version of the ioc4 serial driver. This&n; * includes all the support functions needed (support functions, etc.)&n; * and the serial driver itself.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/serialP.h&gt;
macro_line|#include &lt;linux/circ_buf.h&gt;
macro_line|#include &lt;linux/serial_reg.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/ioc4_common.h&gt;
macro_line|#include &lt;linux/serial_core.h&gt;
multiline_comment|/*&n; * interesting things about the ioc4&n; */
DECL|macro|IOC4_NUM_SERIAL_PORTS
mdefine_line|#define IOC4_NUM_SERIAL_PORTS&t;4&t;/* max ports per card */
DECL|macro|IOC4_NUM_CARDS
mdefine_line|#define IOC4_NUM_CARDS&t;&t;8&t;/* max cards per partition */
DECL|macro|GET_SIO_IR
mdefine_line|#define&t;GET_SIO_IR(_n)&t;(_n == 0) ? (IOC4_SIO_IR_S0) : &bslash;&n;&t;&t;&t;&t;(_n == 1) ? (IOC4_SIO_IR_S1) : &bslash;&n;&t;&t;&t;&t;(_n == 2) ? (IOC4_SIO_IR_S2) : &bslash;&n;&t;&t;&t;&t;(IOC4_SIO_IR_S3)
DECL|macro|GET_OTHER_IR
mdefine_line|#define&t;GET_OTHER_IR(_n)  (_n == 0) ? (IOC4_OTHER_IR_S0_MEMERR) : &bslash;&n;&t;&t;&t;&t;(_n == 1) ? (IOC4_OTHER_IR_S1_MEMERR) : &bslash;&n;&t;&t;&t;&t;(_n == 2) ? (IOC4_OTHER_IR_S2_MEMERR) : &bslash;&n;&t;&t;&t;&t;(IOC4_OTHER_IR_S3_MEMERR)
multiline_comment|/*&n; * All IOC4 registers are 32 bits wide.&n; */
multiline_comment|/*&n; * PCI Memory Space Map&n; */
DECL|macro|IOC4_PCI_ERR_ADDR_L
mdefine_line|#define IOC4_PCI_ERR_ADDR_L     0x000&t;/* Low Error Address */
DECL|macro|IOC4_PCI_ERR_ADDR_VLD
mdefine_line|#define IOC4_PCI_ERR_ADDR_VLD&t;        (0x1 &lt;&lt; 0)
DECL|macro|IOC4_PCI_ERR_ADDR_MST_ID_MSK
mdefine_line|#define IOC4_PCI_ERR_ADDR_MST_ID_MSK    (0xf &lt;&lt; 1)
DECL|macro|IOC4_PCI_ERR_ADDR_MST_NUM_MSK
mdefine_line|#define IOC4_PCI_ERR_ADDR_MST_NUM_MSK   (0xe &lt;&lt; 1)
DECL|macro|IOC4_PCI_ERR_ADDR_MST_TYP_MSK
mdefine_line|#define IOC4_PCI_ERR_ADDR_MST_TYP_MSK   (0x1 &lt;&lt; 1)
DECL|macro|IOC4_PCI_ERR_ADDR_MUL_ERR
mdefine_line|#define IOC4_PCI_ERR_ADDR_MUL_ERR       (0x1 &lt;&lt; 5)
DECL|macro|IOC4_PCI_ERR_ADDR_ADDR_MSK
mdefine_line|#define IOC4_PCI_ERR_ADDR_ADDR_MSK      (0x3ffffff &lt;&lt; 6)
multiline_comment|/* Interrupt types */
DECL|macro|IOC4_SIO_INTR_TYPE
mdefine_line|#define&t;IOC4_SIO_INTR_TYPE&t;0
DECL|macro|IOC4_OTHER_INTR_TYPE
mdefine_line|#define&t;IOC4_OTHER_INTR_TYPE&t;1
DECL|macro|IOC4_NUM_INTR_TYPES
mdefine_line|#define&t;IOC4_NUM_INTR_TYPES&t;2
multiline_comment|/* Bitmasks for IOC4_SIO_IR, IOC4_SIO_IEC, and IOC4_SIO_IES  */
DECL|macro|IOC4_SIO_IR_S0_TX_MT
mdefine_line|#define IOC4_SIO_IR_S0_TX_MT&t;   0x00000001&t;/* Serial port 0 TX empty */
DECL|macro|IOC4_SIO_IR_S0_RX_FULL
mdefine_line|#define IOC4_SIO_IR_S0_RX_FULL&t;   0x00000002&t;/* Port 0 RX buf full */
DECL|macro|IOC4_SIO_IR_S0_RX_HIGH
mdefine_line|#define IOC4_SIO_IR_S0_RX_HIGH&t;   0x00000004&t;/* Port 0 RX hiwat */
DECL|macro|IOC4_SIO_IR_S0_RX_TIMER
mdefine_line|#define IOC4_SIO_IR_S0_RX_TIMER&t;   0x00000008&t;/* Port 0 RX timeout */
DECL|macro|IOC4_SIO_IR_S0_DELTA_DCD
mdefine_line|#define IOC4_SIO_IR_S0_DELTA_DCD   0x00000010&t;/* Port 0 delta DCD */
DECL|macro|IOC4_SIO_IR_S0_DELTA_CTS
mdefine_line|#define IOC4_SIO_IR_S0_DELTA_CTS   0x00000020&t;/* Port 0 delta CTS */
DECL|macro|IOC4_SIO_IR_S0_INT
mdefine_line|#define IOC4_SIO_IR_S0_INT&t;   0x00000040&t;/* Port 0 pass-thru intr */
DECL|macro|IOC4_SIO_IR_S0_TX_EXPLICIT
mdefine_line|#define IOC4_SIO_IR_S0_TX_EXPLICIT 0x00000080&t;/* Port 0 explicit TX thru */
DECL|macro|IOC4_SIO_IR_S1_TX_MT
mdefine_line|#define IOC4_SIO_IR_S1_TX_MT&t;   0x00000100&t;/* Serial port 1 */
DECL|macro|IOC4_SIO_IR_S1_RX_FULL
mdefine_line|#define IOC4_SIO_IR_S1_RX_FULL&t;   0x00000200&t;/* */
DECL|macro|IOC4_SIO_IR_S1_RX_HIGH
mdefine_line|#define IOC4_SIO_IR_S1_RX_HIGH&t;   0x00000400&t;/* */
DECL|macro|IOC4_SIO_IR_S1_RX_TIMER
mdefine_line|#define IOC4_SIO_IR_S1_RX_TIMER&t;   0x00000800&t;/* */
DECL|macro|IOC4_SIO_IR_S1_DELTA_DCD
mdefine_line|#define IOC4_SIO_IR_S1_DELTA_DCD   0x00001000&t;/* */
DECL|macro|IOC4_SIO_IR_S1_DELTA_CTS
mdefine_line|#define IOC4_SIO_IR_S1_DELTA_CTS   0x00002000&t;/* */
DECL|macro|IOC4_SIO_IR_S1_INT
mdefine_line|#define IOC4_SIO_IR_S1_INT&t;   0x00004000&t;/* */
DECL|macro|IOC4_SIO_IR_S1_TX_EXPLICIT
mdefine_line|#define IOC4_SIO_IR_S1_TX_EXPLICIT 0x00008000&t;/* */
DECL|macro|IOC4_SIO_IR_S2_TX_MT
mdefine_line|#define IOC4_SIO_IR_S2_TX_MT&t;   0x00010000&t;/* Serial port 2 */
DECL|macro|IOC4_SIO_IR_S2_RX_FULL
mdefine_line|#define IOC4_SIO_IR_S2_RX_FULL&t;   0x00020000&t;/* */
DECL|macro|IOC4_SIO_IR_S2_RX_HIGH
mdefine_line|#define IOC4_SIO_IR_S2_RX_HIGH&t;   0x00040000&t;/* */
DECL|macro|IOC4_SIO_IR_S2_RX_TIMER
mdefine_line|#define IOC4_SIO_IR_S2_RX_TIMER&t;   0x00080000&t;/* */
DECL|macro|IOC4_SIO_IR_S2_DELTA_DCD
mdefine_line|#define IOC4_SIO_IR_S2_DELTA_DCD   0x00100000&t;/* */
DECL|macro|IOC4_SIO_IR_S2_DELTA_CTS
mdefine_line|#define IOC4_SIO_IR_S2_DELTA_CTS   0x00200000&t;/* */
DECL|macro|IOC4_SIO_IR_S2_INT
mdefine_line|#define IOC4_SIO_IR_S2_INT&t;   0x00400000&t;/* */
DECL|macro|IOC4_SIO_IR_S2_TX_EXPLICIT
mdefine_line|#define IOC4_SIO_IR_S2_TX_EXPLICIT 0x00800000&t;/* */
DECL|macro|IOC4_SIO_IR_S3_TX_MT
mdefine_line|#define IOC4_SIO_IR_S3_TX_MT&t;   0x01000000&t;/* Serial port 3 */
DECL|macro|IOC4_SIO_IR_S3_RX_FULL
mdefine_line|#define IOC4_SIO_IR_S3_RX_FULL&t;   0x02000000&t;/* */
DECL|macro|IOC4_SIO_IR_S3_RX_HIGH
mdefine_line|#define IOC4_SIO_IR_S3_RX_HIGH&t;   0x04000000&t;/* */
DECL|macro|IOC4_SIO_IR_S3_RX_TIMER
mdefine_line|#define IOC4_SIO_IR_S3_RX_TIMER&t;   0x08000000&t;/* */
DECL|macro|IOC4_SIO_IR_S3_DELTA_DCD
mdefine_line|#define IOC4_SIO_IR_S3_DELTA_DCD   0x10000000&t;/* */
DECL|macro|IOC4_SIO_IR_S3_DELTA_CTS
mdefine_line|#define IOC4_SIO_IR_S3_DELTA_CTS   0x20000000&t;/* */
DECL|macro|IOC4_SIO_IR_S3_INT
mdefine_line|#define IOC4_SIO_IR_S3_INT&t;   0x40000000&t;/* */
DECL|macro|IOC4_SIO_IR_S3_TX_EXPLICIT
mdefine_line|#define IOC4_SIO_IR_S3_TX_EXPLICIT 0x80000000&t;/* */
multiline_comment|/* Per device interrupt masks */
DECL|macro|IOC4_SIO_IR_S0
mdefine_line|#define IOC4_SIO_IR_S0&t;&t;(IOC4_SIO_IR_S0_TX_MT | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S0_RX_FULL | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S0_RX_HIGH | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S0_RX_TIMER | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S0_DELTA_DCD | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S0_DELTA_CTS | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S0_INT | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S0_TX_EXPLICIT)
DECL|macro|IOC4_SIO_IR_S1
mdefine_line|#define IOC4_SIO_IR_S1&t;&t;(IOC4_SIO_IR_S1_TX_MT | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S1_RX_FULL | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S1_RX_HIGH | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S1_RX_TIMER | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S1_DELTA_DCD | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S1_DELTA_CTS | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S1_INT | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S1_TX_EXPLICIT)
DECL|macro|IOC4_SIO_IR_S2
mdefine_line|#define IOC4_SIO_IR_S2&t;&t;(IOC4_SIO_IR_S2_TX_MT | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S2_RX_FULL | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S2_RX_HIGH | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S2_RX_TIMER | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S2_DELTA_DCD | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S2_DELTA_CTS | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S2_INT | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S2_TX_EXPLICIT)
DECL|macro|IOC4_SIO_IR_S3
mdefine_line|#define IOC4_SIO_IR_S3&t;&t;(IOC4_SIO_IR_S3_TX_MT | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S3_RX_FULL | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S3_RX_HIGH | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S3_RX_TIMER | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S3_DELTA_DCD | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S3_DELTA_CTS | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S3_INT | &bslash;&n;&t;&t;&t;&t; IOC4_SIO_IR_S3_TX_EXPLICIT)
multiline_comment|/* Bitmasks for IOC4_OTHER_IR, IOC4_OTHER_IEC, and IOC4_OTHER_IES  */
DECL|macro|IOC4_OTHER_IR_ATA_INT
mdefine_line|#define IOC4_OTHER_IR_ATA_INT           0x00000001  /* ATAPI intr pass-thru */
DECL|macro|IOC4_OTHER_IR_ATA_MEMERR
mdefine_line|#define IOC4_OTHER_IR_ATA_MEMERR        0x00000002  /* ATAPI DMA PCI error */
DECL|macro|IOC4_OTHER_IR_S0_MEMERR
mdefine_line|#define IOC4_OTHER_IR_S0_MEMERR         0x00000004  /* Port 0 PCI error */
DECL|macro|IOC4_OTHER_IR_S1_MEMERR
mdefine_line|#define IOC4_OTHER_IR_S1_MEMERR         0x00000008  /* Port 1 PCI error */
DECL|macro|IOC4_OTHER_IR_S2_MEMERR
mdefine_line|#define IOC4_OTHER_IR_S2_MEMERR         0x00000010  /* Port 2 PCI error */
DECL|macro|IOC4_OTHER_IR_S3_MEMERR
mdefine_line|#define IOC4_OTHER_IR_S3_MEMERR         0x00000020  /* Port 3 PCI error */
multiline_comment|/* Bitmasks for IOC4_SIO_CR */
DECL|macro|IOC4_SIO_CR_CMD_PULSE_SHIFT
mdefine_line|#define IOC4_SIO_CR_CMD_PULSE_SHIFT              0  /* byte bus strobe shift */
DECL|macro|IOC4_SIO_CR_ARB_DIAG_TX0
mdefine_line|#define IOC4_SIO_CR_ARB_DIAG_TX0&t;0x00000000
DECL|macro|IOC4_SIO_CR_ARB_DIAG_RX0
mdefine_line|#define IOC4_SIO_CR_ARB_DIAG_RX0&t;0x00000010
DECL|macro|IOC4_SIO_CR_ARB_DIAG_TX1
mdefine_line|#define IOC4_SIO_CR_ARB_DIAG_TX1&t;0x00000020
DECL|macro|IOC4_SIO_CR_ARB_DIAG_RX1
mdefine_line|#define IOC4_SIO_CR_ARB_DIAG_RX1&t;0x00000030
DECL|macro|IOC4_SIO_CR_ARB_DIAG_TX2
mdefine_line|#define IOC4_SIO_CR_ARB_DIAG_TX2&t;0x00000040
DECL|macro|IOC4_SIO_CR_ARB_DIAG_RX2
mdefine_line|#define IOC4_SIO_CR_ARB_DIAG_RX2&t;0x00000050
DECL|macro|IOC4_SIO_CR_ARB_DIAG_TX3
mdefine_line|#define IOC4_SIO_CR_ARB_DIAG_TX3&t;0x00000060
DECL|macro|IOC4_SIO_CR_ARB_DIAG_RX3
mdefine_line|#define IOC4_SIO_CR_ARB_DIAG_RX3&t;0x00000070
DECL|macro|IOC4_SIO_CR_SIO_DIAG_IDLE
mdefine_line|#define IOC4_SIO_CR_SIO_DIAG_IDLE&t;0x00000080  /* 0 -&gt; active request among&n;&t;&t;&t;&t;&t;&t;&t;   serial ports (ro) */
multiline_comment|/* Defs for some of the generic I/O pins */
DECL|macro|IOC4_GPCR_UART0_MODESEL
mdefine_line|#define IOC4_GPCR_UART0_MODESEL&t;   0x10&t;/* Pin is output to port 0&n;&t;&t;&t;&t;&t;&t;   mode sel */
DECL|macro|IOC4_GPCR_UART1_MODESEL
mdefine_line|#define IOC4_GPCR_UART1_MODESEL&t;   0x20&t;/* Pin is output to port 1&n;&t;&t;&t;&t;&t;&t;   mode sel */
DECL|macro|IOC4_GPCR_UART2_MODESEL
mdefine_line|#define IOC4_GPCR_UART2_MODESEL&t;   0x40&t;/* Pin is output to port 2&n;&t;&t;&t;&t;&t;&t;   mode sel */
DECL|macro|IOC4_GPCR_UART3_MODESEL
mdefine_line|#define IOC4_GPCR_UART3_MODESEL&t;   0x80&t;/* Pin is output to port 3&n;&t;&t;&t;&t;&t;&t;   mode sel */
DECL|macro|IOC4_GPPR_UART0_MODESEL_PIN
mdefine_line|#define IOC4_GPPR_UART0_MODESEL_PIN   4&t;/* GIO pin controlling&n;&t;&t;&t;&t;&t;   uart 0 mode select */
DECL|macro|IOC4_GPPR_UART1_MODESEL_PIN
mdefine_line|#define IOC4_GPPR_UART1_MODESEL_PIN   5&t;/* GIO pin controlling&n;&t;&t;&t;&t;&t;   uart 1 mode select */
DECL|macro|IOC4_GPPR_UART2_MODESEL_PIN
mdefine_line|#define IOC4_GPPR_UART2_MODESEL_PIN   6&t;/* GIO pin controlling&n;&t;&t;&t;&t;&t;   uart 2 mode select */
DECL|macro|IOC4_GPPR_UART3_MODESEL_PIN
mdefine_line|#define IOC4_GPPR_UART3_MODESEL_PIN   7&t;/* GIO pin controlling&n;&t;&t;&t;&t;&t;   uart 3 mode select */
multiline_comment|/* Bitmasks for serial RX status byte */
DECL|macro|IOC4_RXSB_OVERRUN
mdefine_line|#define IOC4_RXSB_OVERRUN       0x01&t;/* Char(s) lost */
DECL|macro|IOC4_RXSB_PAR_ERR
mdefine_line|#define IOC4_RXSB_PAR_ERR&t;0x02&t;/* Parity error */
DECL|macro|IOC4_RXSB_FRAME_ERR
mdefine_line|#define IOC4_RXSB_FRAME_ERR&t;0x04&t;/* Framing error */
DECL|macro|IOC4_RXSB_BREAK
mdefine_line|#define IOC4_RXSB_BREAK&t;        0x08&t;/* Break character */
DECL|macro|IOC4_RXSB_CTS
mdefine_line|#define IOC4_RXSB_CTS&t;        0x10&t;/* State of CTS */
DECL|macro|IOC4_RXSB_DCD
mdefine_line|#define IOC4_RXSB_DCD&t;        0x20&t;/* State of DCD */
DECL|macro|IOC4_RXSB_MODEM_VALID
mdefine_line|#define IOC4_RXSB_MODEM_VALID   0x40&t;/* DCD, CTS, and OVERRUN are valid */
DECL|macro|IOC4_RXSB_DATA_VALID
mdefine_line|#define IOC4_RXSB_DATA_VALID    0x80&t;/* Data byte, FRAME_ERR PAR_ERR&n;&t;&t;&t;&t;&t; * &amp; BREAK valid */
multiline_comment|/* Bitmasks for serial TX control byte */
DECL|macro|IOC4_TXCB_INT_WHEN_DONE
mdefine_line|#define IOC4_TXCB_INT_WHEN_DONE 0x20&t;/* Interrupt after this byte is sent */
DECL|macro|IOC4_TXCB_INVALID
mdefine_line|#define IOC4_TXCB_INVALID&t;0x00&t;/* Byte is invalid */
DECL|macro|IOC4_TXCB_VALID
mdefine_line|#define IOC4_TXCB_VALID&t;        0x40&t;/* Byte is valid */
DECL|macro|IOC4_TXCB_MCR
mdefine_line|#define IOC4_TXCB_MCR&t;        0x80&t;/* Data&lt;7:0&gt; to modem control reg */
DECL|macro|IOC4_TXCB_DELAY
mdefine_line|#define IOC4_TXCB_DELAY&t;        0xc0&t;/* Delay data&lt;7:0&gt; mSec */
multiline_comment|/* Bitmasks for IOC4_SBBR_L */
DECL|macro|IOC4_SBBR_L_SIZE
mdefine_line|#define IOC4_SBBR_L_SIZE&t;0x00000001  /* 0 == 1KB rings, 1 == 4KB rings */
multiline_comment|/* Bitmasks for IOC4_SSCR_&lt;3:0&gt; */
DECL|macro|IOC4_SSCR_RX_THRESHOLD
mdefine_line|#define IOC4_SSCR_RX_THRESHOLD  0x000001ff  /* Hiwater mark */
DECL|macro|IOC4_SSCR_TX_TIMER_BUSY
mdefine_line|#define IOC4_SSCR_TX_TIMER_BUSY 0x00010000  /* TX timer in progress */
DECL|macro|IOC4_SSCR_HFC_EN
mdefine_line|#define IOC4_SSCR_HFC_EN&t;0x00020000  /* Hardware flow control enabled */
DECL|macro|IOC4_SSCR_RX_RING_DCD
mdefine_line|#define IOC4_SSCR_RX_RING_DCD   0x00040000  /* Post RX record on delta-DCD */
DECL|macro|IOC4_SSCR_RX_RING_CTS
mdefine_line|#define IOC4_SSCR_RX_RING_CTS   0x00080000  /* Post RX record on delta-CTS */
DECL|macro|IOC4_SSCR_DIAG
mdefine_line|#define IOC4_SSCR_DIAG&t;        0x00200000  /* Bypass clock divider for sim */
DECL|macro|IOC4_SSCR_RX_DRAIN
mdefine_line|#define IOC4_SSCR_RX_DRAIN&t;0x08000000  /* Drain RX buffer to memory */
DECL|macro|IOC4_SSCR_DMA_EN
mdefine_line|#define IOC4_SSCR_DMA_EN&t;0x10000000  /* Enable ring buffer DMA */
DECL|macro|IOC4_SSCR_DMA_PAUSE
mdefine_line|#define IOC4_SSCR_DMA_PAUSE&t;0x20000000  /* Pause DMA */
DECL|macro|IOC4_SSCR_PAUSE_STATE
mdefine_line|#define IOC4_SSCR_PAUSE_STATE   0x40000000  /* Sets when PAUSE takes effect */
DECL|macro|IOC4_SSCR_RESET
mdefine_line|#define IOC4_SSCR_RESET&t;        0x80000000  /* Reset DMA channels */
multiline_comment|/* All producer/comsumer pointers are the same bitfield */
DECL|macro|IOC4_PROD_CONS_PTR_4K
mdefine_line|#define IOC4_PROD_CONS_PTR_4K   0x00000ff8&t;/* For 4K buffers */
DECL|macro|IOC4_PROD_CONS_PTR_1K
mdefine_line|#define IOC4_PROD_CONS_PTR_1K   0x000003f8&t;/* For 1K buffers */
DECL|macro|IOC4_PROD_CONS_PTR_OFF
mdefine_line|#define IOC4_PROD_CONS_PTR_OFF           3
multiline_comment|/* Bitmasks for IOC4_SRCIR_&lt;3:0&gt; */
DECL|macro|IOC4_SRCIR_ARM
mdefine_line|#define IOC4_SRCIR_ARM&t;        0x80000000&t;/* Arm RX timer */
multiline_comment|/* Bitmasks for IOC4_SHADOW_&lt;3:0&gt; */
DECL|macro|IOC4_SHADOW_DR
mdefine_line|#define IOC4_SHADOW_DR&t; 0x00000001&t;/* Data ready */
DECL|macro|IOC4_SHADOW_OE
mdefine_line|#define IOC4_SHADOW_OE&t; 0x00000002&t;/* Overrun error */
DECL|macro|IOC4_SHADOW_PE
mdefine_line|#define IOC4_SHADOW_PE&t; 0x00000004&t;/* Parity error */
DECL|macro|IOC4_SHADOW_FE
mdefine_line|#define IOC4_SHADOW_FE&t; 0x00000008&t;/* Framing error */
DECL|macro|IOC4_SHADOW_BI
mdefine_line|#define IOC4_SHADOW_BI&t; 0x00000010&t;/* Break interrupt */
DECL|macro|IOC4_SHADOW_THRE
mdefine_line|#define IOC4_SHADOW_THRE 0x00000020&t;/* Xmit holding register empty */
DECL|macro|IOC4_SHADOW_TEMT
mdefine_line|#define IOC4_SHADOW_TEMT 0x00000040&t;/* Xmit shift register empty */
DECL|macro|IOC4_SHADOW_RFCE
mdefine_line|#define IOC4_SHADOW_RFCE 0x00000080&t;/* Char in RX fifo has an error */
DECL|macro|IOC4_SHADOW_DCTS
mdefine_line|#define IOC4_SHADOW_DCTS 0x00010000&t;/* Delta clear to send */
DECL|macro|IOC4_SHADOW_DDCD
mdefine_line|#define IOC4_SHADOW_DDCD 0x00080000&t;/* Delta data carrier detect */
DECL|macro|IOC4_SHADOW_CTS
mdefine_line|#define IOC4_SHADOW_CTS&t; 0x00100000&t;/* Clear to send */
DECL|macro|IOC4_SHADOW_DCD
mdefine_line|#define IOC4_SHADOW_DCD&t; 0x00800000&t;/* Data carrier detect */
DECL|macro|IOC4_SHADOW_DTR
mdefine_line|#define IOC4_SHADOW_DTR&t; 0x01000000&t;/* Data terminal ready */
DECL|macro|IOC4_SHADOW_RTS
mdefine_line|#define IOC4_SHADOW_RTS&t; 0x02000000&t;/* Request to send */
DECL|macro|IOC4_SHADOW_OUT1
mdefine_line|#define IOC4_SHADOW_OUT1 0x04000000&t;/* 16550 OUT1 bit */
DECL|macro|IOC4_SHADOW_OUT2
mdefine_line|#define IOC4_SHADOW_OUT2 0x08000000&t;/* 16550 OUT2 bit */
DECL|macro|IOC4_SHADOW_LOOP
mdefine_line|#define IOC4_SHADOW_LOOP 0x10000000&t;/* Loopback enabled */
multiline_comment|/* Bitmasks for IOC4_SRTR_&lt;3:0&gt; */
DECL|macro|IOC4_SRTR_CNT
mdefine_line|#define IOC4_SRTR_CNT&t;        0x00000fff&t;/* Reload value for RX timer */
DECL|macro|IOC4_SRTR_CNT_VAL
mdefine_line|#define IOC4_SRTR_CNT_VAL&t;0x0fff0000&t;/* Current value of RX timer */
DECL|macro|IOC4_SRTR_CNT_VAL_SHIFT
mdefine_line|#define IOC4_SRTR_CNT_VAL_SHIFT         16
DECL|macro|IOC4_SRTR_HZ
mdefine_line|#define IOC4_SRTR_HZ                 16000&t;/* SRTR clock frequency */
multiline_comment|/* Serial port register map used for DMA and PIO serial I/O */
DECL|struct|ioc4_serialregs
r_struct
id|ioc4_serialregs
(brace
DECL|member|sscr
r_uint32
id|sscr
suffix:semicolon
DECL|member|stpir
r_uint32
id|stpir
suffix:semicolon
DECL|member|stcir
r_uint32
id|stcir
suffix:semicolon
DECL|member|srpir
r_uint32
id|srpir
suffix:semicolon
DECL|member|srcir
r_uint32
id|srcir
suffix:semicolon
DECL|member|srtr
r_uint32
id|srtr
suffix:semicolon
DECL|member|shadow
r_uint32
id|shadow
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* IOC4 UART register map */
DECL|struct|ioc4_uartregs
r_struct
id|ioc4_uartregs
(brace
DECL|member|i4u_lcr
r_char
id|i4u_lcr
suffix:semicolon
r_union
(brace
DECL|member|iir
r_char
id|iir
suffix:semicolon
multiline_comment|/* read only */
DECL|member|fcr
r_char
id|fcr
suffix:semicolon
multiline_comment|/* write only */
DECL|member|u3
)brace
id|u3
suffix:semicolon
r_union
(brace
DECL|member|ier
r_char
id|ier
suffix:semicolon
multiline_comment|/* DLAB == 0 */
DECL|member|dlm
r_char
id|dlm
suffix:semicolon
multiline_comment|/* DLAB == 1 */
DECL|member|u2
)brace
id|u2
suffix:semicolon
r_union
(brace
DECL|member|rbr
r_char
id|rbr
suffix:semicolon
multiline_comment|/* read only, DLAB == 0 */
DECL|member|thr
r_char
id|thr
suffix:semicolon
multiline_comment|/* write only, DLAB == 0 */
DECL|member|dll
r_char
id|dll
suffix:semicolon
multiline_comment|/* DLAB == 1 */
DECL|member|u1
)brace
id|u1
suffix:semicolon
DECL|member|i4u_scr
r_char
id|i4u_scr
suffix:semicolon
DECL|member|i4u_msr
r_char
id|i4u_msr
suffix:semicolon
DECL|member|i4u_lsr
r_char
id|i4u_lsr
suffix:semicolon
DECL|member|i4u_mcr
r_char
id|i4u_mcr
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* short names */
DECL|macro|i4u_dll
mdefine_line|#define i4u_dll u1.dll
DECL|macro|i4u_ier
mdefine_line|#define i4u_ier u2.ier
DECL|macro|i4u_dlm
mdefine_line|#define i4u_dlm u2.dlm
DECL|macro|i4u_fcr
mdefine_line|#define i4u_fcr u3.fcr
multiline_comment|/* PCI memory space register map addressed using pci_bar0 */
DECL|struct|ioc4_memregs
r_struct
id|ioc4_memregs
(brace
DECL|struct|ioc4_mem
r_struct
id|ioc4_mem
(brace
multiline_comment|/* Miscellaneous IOC4  registers */
DECL|member|pci_err_addr_l
r_uint32
id|pci_err_addr_l
suffix:semicolon
DECL|member|pci_err_addr_h
r_uint32
id|pci_err_addr_h
suffix:semicolon
DECL|member|sio_ir
r_uint32
id|sio_ir
suffix:semicolon
DECL|member|other_ir
r_uint32
id|other_ir
suffix:semicolon
multiline_comment|/* These registers are read-only for general kernel code.  */
DECL|member|sio_ies_ro
r_uint32
id|sio_ies_ro
suffix:semicolon
DECL|member|other_ies_ro
r_uint32
id|other_ies_ro
suffix:semicolon
DECL|member|sio_iec_ro
r_uint32
id|sio_iec_ro
suffix:semicolon
DECL|member|other_iec_ro
r_uint32
id|other_iec_ro
suffix:semicolon
DECL|member|sio_cr
r_uint32
id|sio_cr
suffix:semicolon
DECL|member|misc_fill1
r_uint32
id|misc_fill1
suffix:semicolon
DECL|member|int_out
r_uint32
id|int_out
suffix:semicolon
DECL|member|misc_fill2
r_uint32
id|misc_fill2
suffix:semicolon
DECL|member|gpcr_s
r_uint32
id|gpcr_s
suffix:semicolon
DECL|member|gpcr_c
r_uint32
id|gpcr_c
suffix:semicolon
DECL|member|gpdr
r_uint32
id|gpdr
suffix:semicolon
DECL|member|misc_fill3
r_uint32
id|misc_fill3
suffix:semicolon
DECL|member|gppr_0
r_uint32
id|gppr_0
suffix:semicolon
DECL|member|gppr_1
r_uint32
id|gppr_1
suffix:semicolon
DECL|member|gppr_2
r_uint32
id|gppr_2
suffix:semicolon
DECL|member|gppr_3
r_uint32
id|gppr_3
suffix:semicolon
DECL|member|gppr_4
r_uint32
id|gppr_4
suffix:semicolon
DECL|member|gppr_5
r_uint32
id|gppr_5
suffix:semicolon
DECL|member|gppr_6
r_uint32
id|gppr_6
suffix:semicolon
DECL|member|gppr_7
r_uint32
id|gppr_7
suffix:semicolon
DECL|member|ioc4_mem
)brace
id|ioc4_mem
suffix:semicolon
DECL|member|misc_fill4
r_char
id|misc_fill4
(braket
l_int|0x100
op_minus
l_int|0x5C
op_minus
l_int|4
)braket
suffix:semicolon
multiline_comment|/* ATA/ATAP registers */
DECL|member|ata_notused
r_uint32
id|ata_notused
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|ata_fill1
r_char
id|ata_fill1
(braket
l_int|0x140
op_minus
l_int|0x120
op_minus
l_int|4
)braket
suffix:semicolon
DECL|member|ata_notused1
r_uint32
id|ata_notused1
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|ata_fill2
r_char
id|ata_fill2
(braket
l_int|0x200
op_minus
l_int|0x15C
op_minus
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Keyboard and mouse registers */
DECL|member|km_notused
r_uint32
id|km_notused
(braket
l_int|5
)braket
suffix:semicolon
suffix:semicolon
DECL|member|km_fill1
r_char
id|km_fill1
(braket
l_int|0x300
op_minus
l_int|0x210
op_minus
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Serial port registers used for DMA serial I/O */
DECL|struct|ioc4_serial
r_struct
id|ioc4_serial
(brace
DECL|member|sbbr01_l
r_uint32
id|sbbr01_l
suffix:semicolon
DECL|member|sbbr01_h
r_uint32
id|sbbr01_h
suffix:semicolon
DECL|member|sbbr23_l
r_uint32
id|sbbr23_l
suffix:semicolon
DECL|member|sbbr23_h
r_uint32
id|sbbr23_h
suffix:semicolon
DECL|member|port_0
r_struct
id|ioc4_serialregs
id|port_0
suffix:semicolon
DECL|member|port_1
r_struct
id|ioc4_serialregs
id|port_1
suffix:semicolon
DECL|member|port_2
r_struct
id|ioc4_serialregs
id|port_2
suffix:semicolon
DECL|member|port_3
r_struct
id|ioc4_serialregs
id|port_3
suffix:semicolon
DECL|member|uart_0
r_struct
id|ioc4_uartregs
id|uart_0
suffix:semicolon
DECL|member|uart_1
r_struct
id|ioc4_uartregs
id|uart_1
suffix:semicolon
DECL|member|uart_2
r_struct
id|ioc4_uartregs
id|uart_2
suffix:semicolon
DECL|member|uart_3
r_struct
id|ioc4_uartregs
id|uart_3
suffix:semicolon
DECL|member|ioc4_serial
)brace
id|ioc4_serial
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* UART clock speed */
DECL|macro|IOC4_SER_XIN_CLK
mdefine_line|#define IOC4_SER_XIN_CLK        IOC4_SER_XIN_CLK_66
DECL|macro|IOC4_SER_XIN_CLK_66
mdefine_line|#define IOC4_SER_XIN_CLK_66     66666667
DECL|macro|IOC4_SER_XIN_CLK_33
mdefine_line|#define IOC4_SER_XIN_CLK_33     33333333
DECL|macro|IOC4_W_IES
mdefine_line|#define IOC4_W_IES&t;&t;0
DECL|macro|IOC4_W_IEC
mdefine_line|#define IOC4_W_IEC&t;&t;1
DECL|typedef|ioc4_intr_func_f
r_typedef
r_void
id|ioc4_intr_func_f
c_func
(paren
r_void
op_star
comma
r_uint32
)paren
suffix:semicolon
DECL|typedef|ioc4_intr_func_t
r_typedef
id|ioc4_intr_func_f
op_star
id|ioc4_intr_func_t
suffix:semicolon
multiline_comment|/* defining this will get you LOTS of great debug info */
singleline_comment|//#define DEBUG_INTERRUPTS
DECL|macro|DPRINT_CONFIG
mdefine_line|#define DPRINT_CONFIG(_x...)&t;;
singleline_comment|//#define DPRINT_CONFIG(_x...)&t;printk _x
multiline_comment|/* number of characters left in xmit buffer before we ask for more */
DECL|macro|WAKEUP_CHARS
mdefine_line|#define WAKEUP_CHARS&t;256
multiline_comment|/* number of characters we want to transmit to the lower level at a time */
DECL|macro|IOC4_MAX_CHARS
mdefine_line|#define IOC4_MAX_CHARS&t;128
multiline_comment|/* Device name we&squot;re using */
DECL|macro|DEVICE_NAME
mdefine_line|#define DEVICE_NAME&t;&quot;ttyIOC&quot;
DECL|macro|DEVICE_MAJOR
mdefine_line|#define DEVICE_MAJOR 204
DECL|macro|DEVICE_MINOR
mdefine_line|#define DEVICE_MINOR 50
multiline_comment|/* register offsets */
DECL|macro|IOC4_SERIAL_OFFSET
mdefine_line|#define IOC4_SERIAL_OFFSET&t;0x300
multiline_comment|/* flags for next_char_state */
DECL|macro|NCS_BREAK
mdefine_line|#define NCS_BREAK&t;0x1
DECL|macro|NCS_PARITY
mdefine_line|#define NCS_PARITY&t;0x2
DECL|macro|NCS_FRAMING
mdefine_line|#define NCS_FRAMING&t;0x4
DECL|macro|NCS_OVERRUN
mdefine_line|#define NCS_OVERRUN&t;0x8
multiline_comment|/* cause we need SOME parameters ... */
DECL|macro|MIN_BAUD_SUPPORTED
mdefine_line|#define MIN_BAUD_SUPPORTED&t;1200
DECL|macro|MAX_BAUD_SUPPORTED
mdefine_line|#define MAX_BAUD_SUPPORTED&t;115200
multiline_comment|/* protocol types supported */
DECL|enum|sio_proto
r_enum
id|sio_proto
(brace
DECL|enumerator|PROTO_RS232
id|PROTO_RS232
comma
DECL|enumerator|PROTO_RS422
id|PROTO_RS422
)brace
suffix:semicolon
multiline_comment|/* Notification types */
DECL|macro|N_DATA_READY
mdefine_line|#define N_DATA_READY&t;0x01
DECL|macro|N_OUTPUT_LOWAT
mdefine_line|#define N_OUTPUT_LOWAT&t;0x02
DECL|macro|N_BREAK
mdefine_line|#define N_BREAK&t;&t;0x04
DECL|macro|N_PARITY_ERROR
mdefine_line|#define N_PARITY_ERROR&t;0x08
DECL|macro|N_FRAMING_ERROR
mdefine_line|#define N_FRAMING_ERROR&t;0x10
DECL|macro|N_OVERRUN_ERROR
mdefine_line|#define N_OVERRUN_ERROR&t;0x20
DECL|macro|N_DDCD
mdefine_line|#define N_DDCD&t;&t;0x40
DECL|macro|N_DCTS
mdefine_line|#define N_DCTS&t;&t;0x80
DECL|macro|N_ALL_INPUT
mdefine_line|#define N_ALL_INPUT&t;(N_DATA_READY | N_BREAK |&t;&t;&t;&bslash;&n;&t;&t;&t; N_PARITY_ERROR | N_FRAMING_ERROR |&t;&t;&bslash;&n;&t;&t;&t; N_OVERRUN_ERROR | N_DDCD | N_DCTS)
DECL|macro|N_ALL_OUTPUT
mdefine_line|#define N_ALL_OUTPUT&t;N_OUTPUT_LOWAT
DECL|macro|N_ALL_ERRORS
mdefine_line|#define N_ALL_ERRORS&t;(N_PARITY_ERROR | N_FRAMING_ERROR | N_OVERRUN_ERROR)
DECL|macro|N_ALL
mdefine_line|#define N_ALL&t;&t;(N_DATA_READY | N_OUTPUT_LOWAT | N_BREAK |&t;&bslash;&n;&t;&t;&t; N_PARITY_ERROR | N_FRAMING_ERROR |&t;&t;&bslash;&n;&t;&t;&t; N_OVERRUN_ERROR | N_DDCD | N_DCTS)
DECL|macro|SER_DIVISOR
mdefine_line|#define SER_DIVISOR(_x, clk)&t;&t;(((clk) + (_x) * 8) / ((_x) * 16))
DECL|macro|DIVISOR_TO_BAUD
mdefine_line|#define DIVISOR_TO_BAUD(div, clk)&t;((clk) / 16 / (div))
multiline_comment|/* Some masks */
DECL|macro|LCR_MASK_BITS_CHAR
mdefine_line|#define LCR_MASK_BITS_CHAR&t;(UART_LCR_WLEN5 | UART_LCR_WLEN6 &bslash;&n;&t;&t;&t;&t;&t;| UART_LCR_WLEN7 | UART_LCR_WLEN8)
DECL|macro|LCR_MASK_STOP_BITS
mdefine_line|#define LCR_MASK_STOP_BITS&t;(UART_LCR_STOP)
DECL|macro|PENDING
mdefine_line|#define PENDING(_p)&t;(readl(&amp;(_p)-&gt;ip_mem-&gt;sio_ir) &amp; _p-&gt;ip_ienb)
DECL|macro|READ_SIO_IR
mdefine_line|#define READ_SIO_IR(_p) readl(&amp;(_p)-&gt;ip_mem-&gt;sio_ir)
multiline_comment|/* Default to 4k buffers */
macro_line|#ifdef IOC4_1K_BUFFERS
DECL|macro|RING_BUF_SIZE
mdefine_line|#define RING_BUF_SIZE 1024
DECL|macro|IOC4_BUF_SIZE_BIT
mdefine_line|#define IOC4_BUF_SIZE_BIT 0
DECL|macro|PROD_CONS_MASK
mdefine_line|#define PROD_CONS_MASK IOC4_PROD_CONS_PTR_1K
macro_line|#else
DECL|macro|RING_BUF_SIZE
mdefine_line|#define RING_BUF_SIZE 4096
DECL|macro|IOC4_BUF_SIZE_BIT
mdefine_line|#define IOC4_BUF_SIZE_BIT IOC4_SBBR_L_SIZE
DECL|macro|PROD_CONS_MASK
mdefine_line|#define PROD_CONS_MASK IOC4_PROD_CONS_PTR_4K
macro_line|#endif
DECL|macro|TOTAL_RING_BUF_SIZE
mdefine_line|#define TOTAL_RING_BUF_SIZE (RING_BUF_SIZE * 4)
multiline_comment|/*&n; * This is the entry saved by the driver - one per card&n; */
DECL|struct|ioc4_control
r_struct
id|ioc4_control
(brace
DECL|member|ic_irq
r_int
id|ic_irq
suffix:semicolon
r_struct
(brace
multiline_comment|/* uart ports are allocated here */
DECL|member|icp_uart_port
r_struct
id|uart_port
id|icp_uart_port
suffix:semicolon
multiline_comment|/* Handy reference material */
DECL|member|icp_port
r_struct
id|ioc4_port
op_star
id|icp_port
suffix:semicolon
DECL|member|ic_port
)brace
id|ic_port
(braket
id|IOC4_NUM_SERIAL_PORTS
)braket
suffix:semicolon
DECL|member|ic_soft
r_struct
id|ioc4_soft
op_star
id|ic_soft
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * per-IOC4 data structure&n; */
DECL|macro|MAX_IOC4_INTR_ENTS
mdefine_line|#define MAX_IOC4_INTR_ENTS&t;(8 * sizeof(uint32_t))
DECL|struct|ioc4_soft
r_struct
id|ioc4_soft
(brace
DECL|member|is_ioc4_mem_addr
r_struct
id|ioc4_mem
id|__iomem
op_star
id|is_ioc4_mem_addr
suffix:semicolon
DECL|member|is_ioc4_serial_addr
r_struct
id|ioc4_serial
id|__iomem
op_star
id|is_ioc4_serial_addr
suffix:semicolon
multiline_comment|/* Each interrupt type has an entry in the array */
DECL|struct|ioc4_intr_type
r_struct
id|ioc4_intr_type
(brace
multiline_comment|/*&n;&t;&t; * Each in-use entry in this array contains at least&n;&t;&t; * one nonzero bit in sd_bits; no two entries in this&n;&t;&t; * array have overlapping sd_bits values.&n;&t;&t; */
DECL|struct|ioc4_intr_info
r_struct
id|ioc4_intr_info
(brace
DECL|member|sd_bits
r_uint32
id|sd_bits
suffix:semicolon
DECL|member|sd_intr
id|ioc4_intr_func_f
op_star
id|sd_intr
suffix:semicolon
DECL|member|sd_info
r_void
op_star
id|sd_info
suffix:semicolon
DECL|member|is_intr_info
)brace
id|is_intr_info
(braket
id|MAX_IOC4_INTR_ENTS
)braket
suffix:semicolon
multiline_comment|/* Number of entries active in the above array */
DECL|member|is_num_intrs
id|atomic_t
id|is_num_intrs
suffix:semicolon
DECL|member|is_intr_type
)brace
id|is_intr_type
(braket
id|IOC4_NUM_INTR_TYPES
)braket
suffix:semicolon
multiline_comment|/* is_ir_lock must be held while&n;&t; * modifying sio_ie values, so&n;&t; * we can be sure that sio_ie is&n;&t; * not changing when we read it&n;&t; * along with sio_ir.&n;&t; */
DECL|member|is_ir_lock
id|spinlock_t
id|is_ir_lock
suffix:semicolon
multiline_comment|/* SIO_IE[SC] mod lock */
)brace
suffix:semicolon
multiline_comment|/* Local port info for each IOC4 serial ports */
DECL|struct|ioc4_port
r_struct
id|ioc4_port
(brace
DECL|member|ip_port
r_struct
id|uart_port
op_star
id|ip_port
suffix:semicolon
multiline_comment|/* Back ptrs for this port */
DECL|member|ip_control
r_struct
id|ioc4_control
op_star
id|ip_control
suffix:semicolon
DECL|member|ip_pdev
r_struct
id|pci_dev
op_star
id|ip_pdev
suffix:semicolon
DECL|member|ip_ioc4_soft
r_struct
id|ioc4_soft
op_star
id|ip_ioc4_soft
suffix:semicolon
multiline_comment|/* pci mem addresses */
DECL|member|ip_mem
r_struct
id|ioc4_mem
id|__iomem
op_star
id|ip_mem
suffix:semicolon
DECL|member|ip_serial
r_struct
id|ioc4_serial
id|__iomem
op_star
id|ip_serial
suffix:semicolon
DECL|member|ip_serial_regs
r_struct
id|ioc4_serialregs
id|__iomem
op_star
id|ip_serial_regs
suffix:semicolon
DECL|member|ip_uart_regs
r_struct
id|ioc4_uartregs
id|__iomem
op_star
id|ip_uart_regs
suffix:semicolon
multiline_comment|/* Ring buffer page for this port */
DECL|member|ip_dma_ringbuf
id|dma_addr_t
id|ip_dma_ringbuf
suffix:semicolon
multiline_comment|/* vaddr of ring buffer */
DECL|member|ip_cpu_ringbuf
r_struct
id|ring_buffer
op_star
id|ip_cpu_ringbuf
suffix:semicolon
multiline_comment|/* Rings for this port */
DECL|member|ip_inring
r_struct
id|ring
op_star
id|ip_inring
suffix:semicolon
DECL|member|ip_outring
r_struct
id|ring
op_star
id|ip_outring
suffix:semicolon
multiline_comment|/* Hook to port specific values */
DECL|member|ip_hooks
r_struct
id|hooks
op_star
id|ip_hooks
suffix:semicolon
DECL|member|ip_lock
id|spinlock_t
id|ip_lock
suffix:semicolon
multiline_comment|/* Various rx/tx parameters */
DECL|member|ip_baud
r_int
id|ip_baud
suffix:semicolon
DECL|member|ip_tx_lowat
r_int
id|ip_tx_lowat
suffix:semicolon
DECL|member|ip_rx_timeout
r_int
id|ip_rx_timeout
suffix:semicolon
multiline_comment|/* Copy of notification bits */
DECL|member|ip_notify
r_int
id|ip_notify
suffix:semicolon
multiline_comment|/* Shadow copies of various registers so we don&squot;t need to PIO&n;&t; * read them constantly&n;&t; */
DECL|member|ip_ienb
r_uint32
id|ip_ienb
suffix:semicolon
multiline_comment|/* Enabled interrupts */
DECL|member|ip_sscr
r_uint32
id|ip_sscr
suffix:semicolon
DECL|member|ip_tx_prod
r_uint32
id|ip_tx_prod
suffix:semicolon
DECL|member|ip_rx_cons
r_uint32
id|ip_rx_cons
suffix:semicolon
DECL|member|ip_pci_bus_speed
r_int
id|ip_pci_bus_speed
suffix:semicolon
DECL|member|ip_flags
r_int
r_char
id|ip_flags
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* tx low water mark.  We need to notify the driver whenever tx is getting&n; * close to empty so it can refill the tx buffer and keep things going.&n; * Let&squot;s assume that if we interrupt 1 ms before the tx goes idle, we&squot;ll&n; * have no trouble getting in more chars in time (I certainly hope so).&n; */
DECL|macro|TX_LOWAT_LATENCY
mdefine_line|#define TX_LOWAT_LATENCY      1000
DECL|macro|TX_LOWAT_HZ
mdefine_line|#define TX_LOWAT_HZ          (1000000 / TX_LOWAT_LATENCY)
DECL|macro|TX_LOWAT_CHARS
mdefine_line|#define TX_LOWAT_CHARS(baud) (baud / 10 / TX_LOWAT_HZ)
multiline_comment|/* Flags per port */
DECL|macro|INPUT_HIGH
mdefine_line|#define INPUT_HIGH&t;0x01
DECL|macro|DCD_ON
mdefine_line|#define DCD_ON&t;&t;0x02
DECL|macro|LOWAT_WRITTEN
mdefine_line|#define LOWAT_WRITTEN&t;0x04
DECL|macro|READ_ABORTED
mdefine_line|#define READ_ABORTED&t;0x08
multiline_comment|/* Since each port has different register offsets and bitmasks&n; * for everything, we&squot;ll store those that we need in tables so we&n; * don&squot;t have to be constantly checking the port we are dealing with.&n; */
DECL|struct|hooks
r_struct
id|hooks
(brace
DECL|member|intr_delta_dcd
r_uint32
id|intr_delta_dcd
suffix:semicolon
DECL|member|intr_delta_cts
r_uint32
id|intr_delta_cts
suffix:semicolon
DECL|member|intr_tx_mt
r_uint32
id|intr_tx_mt
suffix:semicolon
DECL|member|intr_rx_timer
r_uint32
id|intr_rx_timer
suffix:semicolon
DECL|member|intr_rx_high
r_uint32
id|intr_rx_high
suffix:semicolon
DECL|member|intr_tx_explicit
r_uint32
id|intr_tx_explicit
suffix:semicolon
DECL|member|intr_dma_error
r_uint32
id|intr_dma_error
suffix:semicolon
DECL|member|intr_clear
r_uint32
id|intr_clear
suffix:semicolon
DECL|member|intr_all
r_uint32
id|intr_all
suffix:semicolon
DECL|member|rs422_select_pin
r_char
id|rs422_select_pin
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|hooks_array
r_static
r_struct
id|hooks
id|hooks_array
(braket
id|IOC4_NUM_SERIAL_PORTS
)braket
op_assign
(brace
multiline_comment|/* Values for port 0 */
(brace
id|IOC4_SIO_IR_S0_DELTA_DCD
comma
id|IOC4_SIO_IR_S0_DELTA_CTS
comma
id|IOC4_SIO_IR_S0_TX_MT
comma
id|IOC4_SIO_IR_S0_RX_TIMER
comma
id|IOC4_SIO_IR_S0_RX_HIGH
comma
id|IOC4_SIO_IR_S0_TX_EXPLICIT
comma
id|IOC4_OTHER_IR_S0_MEMERR
comma
(paren
id|IOC4_SIO_IR_S0_TX_MT
op_or
id|IOC4_SIO_IR_S0_RX_FULL
op_or
id|IOC4_SIO_IR_S0_RX_HIGH
op_or
id|IOC4_SIO_IR_S0_RX_TIMER
op_or
id|IOC4_SIO_IR_S0_DELTA_DCD
op_or
id|IOC4_SIO_IR_S0_DELTA_CTS
op_or
id|IOC4_SIO_IR_S0_INT
op_or
id|IOC4_SIO_IR_S0_TX_EXPLICIT
)paren
comma
id|IOC4_SIO_IR_S0
comma
id|IOC4_GPPR_UART0_MODESEL_PIN
comma
)brace
comma
multiline_comment|/* Values for port 1 */
(brace
id|IOC4_SIO_IR_S1_DELTA_DCD
comma
id|IOC4_SIO_IR_S1_DELTA_CTS
comma
id|IOC4_SIO_IR_S1_TX_MT
comma
id|IOC4_SIO_IR_S1_RX_TIMER
comma
id|IOC4_SIO_IR_S1_RX_HIGH
comma
id|IOC4_SIO_IR_S1_TX_EXPLICIT
comma
id|IOC4_OTHER_IR_S1_MEMERR
comma
(paren
id|IOC4_SIO_IR_S1_TX_MT
op_or
id|IOC4_SIO_IR_S1_RX_FULL
op_or
id|IOC4_SIO_IR_S1_RX_HIGH
op_or
id|IOC4_SIO_IR_S1_RX_TIMER
op_or
id|IOC4_SIO_IR_S1_DELTA_DCD
op_or
id|IOC4_SIO_IR_S1_DELTA_CTS
op_or
id|IOC4_SIO_IR_S1_INT
op_or
id|IOC4_SIO_IR_S1_TX_EXPLICIT
)paren
comma
id|IOC4_SIO_IR_S1
comma
id|IOC4_GPPR_UART1_MODESEL_PIN
comma
)brace
comma
multiline_comment|/* Values for port 2 */
(brace
id|IOC4_SIO_IR_S2_DELTA_DCD
comma
id|IOC4_SIO_IR_S2_DELTA_CTS
comma
id|IOC4_SIO_IR_S2_TX_MT
comma
id|IOC4_SIO_IR_S2_RX_TIMER
comma
id|IOC4_SIO_IR_S2_RX_HIGH
comma
id|IOC4_SIO_IR_S2_TX_EXPLICIT
comma
id|IOC4_OTHER_IR_S2_MEMERR
comma
(paren
id|IOC4_SIO_IR_S2_TX_MT
op_or
id|IOC4_SIO_IR_S2_RX_FULL
op_or
id|IOC4_SIO_IR_S2_RX_HIGH
op_or
id|IOC4_SIO_IR_S2_RX_TIMER
op_or
id|IOC4_SIO_IR_S2_DELTA_DCD
op_or
id|IOC4_SIO_IR_S2_DELTA_CTS
op_or
id|IOC4_SIO_IR_S2_INT
op_or
id|IOC4_SIO_IR_S2_TX_EXPLICIT
)paren
comma
id|IOC4_SIO_IR_S2
comma
id|IOC4_GPPR_UART2_MODESEL_PIN
comma
)brace
comma
multiline_comment|/* Values for port 3 */
(brace
id|IOC4_SIO_IR_S3_DELTA_DCD
comma
id|IOC4_SIO_IR_S3_DELTA_CTS
comma
id|IOC4_SIO_IR_S3_TX_MT
comma
id|IOC4_SIO_IR_S3_RX_TIMER
comma
id|IOC4_SIO_IR_S3_RX_HIGH
comma
id|IOC4_SIO_IR_S3_TX_EXPLICIT
comma
id|IOC4_OTHER_IR_S3_MEMERR
comma
(paren
id|IOC4_SIO_IR_S3_TX_MT
op_or
id|IOC4_SIO_IR_S3_RX_FULL
op_or
id|IOC4_SIO_IR_S3_RX_HIGH
op_or
id|IOC4_SIO_IR_S3_RX_TIMER
op_or
id|IOC4_SIO_IR_S3_DELTA_DCD
op_or
id|IOC4_SIO_IR_S3_DELTA_CTS
op_or
id|IOC4_SIO_IR_S3_INT
op_or
id|IOC4_SIO_IR_S3_TX_EXPLICIT
)paren
comma
id|IOC4_SIO_IR_S3
comma
id|IOC4_GPPR_UART3_MODESEL_PIN
comma
)brace
)brace
suffix:semicolon
multiline_comment|/* A ring buffer entry */
DECL|struct|ring_entry
r_struct
id|ring_entry
(brace
r_union
(brace
r_struct
(brace
DECL|member|alldata
r_uint32
id|alldata
suffix:semicolon
DECL|member|allsc
r_uint32
id|allsc
suffix:semicolon
DECL|member|all
)brace
id|all
suffix:semicolon
r_struct
(brace
DECL|member|data
r_char
id|data
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* data bytes */
DECL|member|sc
r_char
id|sc
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* status/control */
DECL|member|s
)brace
id|s
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Test the valid bits in any of the 4 sc chars using &quot;allsc&quot; member */
DECL|macro|RING_ANY_VALID
mdefine_line|#define RING_ANY_VALID &bslash;&n;&t;((uint32_t)(IOC4_RXSB_MODEM_VALID | IOC4_RXSB_DATA_VALID) * 0x01010101)
DECL|macro|ring_sc
mdefine_line|#define ring_sc     u.s.sc
DECL|macro|ring_data
mdefine_line|#define ring_data   u.s.data
DECL|macro|ring_allsc
mdefine_line|#define ring_allsc  u.all.allsc
multiline_comment|/* Number of entries per ring buffer. */
DECL|macro|ENTRIES_PER_RING
mdefine_line|#define ENTRIES_PER_RING (RING_BUF_SIZE / (int) sizeof(struct ring_entry))
multiline_comment|/* An individual ring */
DECL|struct|ring
r_struct
id|ring
(brace
DECL|member|entries
r_struct
id|ring_entry
id|entries
(braket
id|ENTRIES_PER_RING
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* The whole enchilada */
DECL|struct|ring_buffer
r_struct
id|ring_buffer
(brace
DECL|member|TX_0_OR_2
r_struct
id|ring
id|TX_0_OR_2
suffix:semicolon
DECL|member|RX_0_OR_2
r_struct
id|ring
id|RX_0_OR_2
suffix:semicolon
DECL|member|TX_1_OR_3
r_struct
id|ring
id|TX_1_OR_3
suffix:semicolon
DECL|member|RX_1_OR_3
r_struct
id|ring
id|RX_1_OR_3
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Get a ring from a port struct */
DECL|macro|RING
mdefine_line|#define RING(_p, _wh)&t;&amp;(((struct ring_buffer *)((_p)-&gt;ip_cpu_ringbuf))-&gt;_wh)
multiline_comment|/* Infinite loop detection.&n; */
DECL|macro|MAXITER
mdefine_line|#define MAXITER 10000000
multiline_comment|/* Prototypes */
r_static
r_void
id|receive_chars
c_func
(paren
r_struct
id|uart_port
op_star
)paren
suffix:semicolon
r_static
r_void
id|handle_intr
c_func
(paren
r_void
op_star
id|arg
comma
r_uint32
id|sio_ir
)paren
suffix:semicolon
multiline_comment|/**&n; * write_ireg - write the interrupt regs&n; * @ioc4_soft: ptr to soft struct for this port&n; * @val: value to write&n; * @which: which register&n; * @type: which ireg set&n; */
r_static
r_inline
r_void
DECL|function|write_ireg
id|write_ireg
c_func
(paren
r_struct
id|ioc4_soft
op_star
id|ioc4_soft
comma
r_uint32
id|val
comma
r_int
id|which
comma
r_int
id|type
)paren
(brace
r_struct
id|ioc4_mem
id|__iomem
op_star
id|mem
op_assign
id|ioc4_soft-&gt;is_ioc4_mem_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc4_soft-&gt;is_ir_lock
comma
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|IOC4_SIO_INTR_TYPE
suffix:colon
r_switch
c_cond
(paren
id|which
)paren
(brace
r_case
id|IOC4_W_IES
suffix:colon
id|writel
c_func
(paren
id|val
comma
op_amp
id|mem-&gt;sio_ies_ro
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IOC4_W_IEC
suffix:colon
id|writel
c_func
(paren
id|val
comma
op_amp
id|mem-&gt;sio_iec_ro
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IOC4_OTHER_INTR_TYPE
suffix:colon
r_switch
c_cond
(paren
id|which
)paren
(brace
r_case
id|IOC4_W_IES
suffix:colon
id|writel
c_func
(paren
id|val
comma
op_amp
id|mem-&gt;other_ies_ro
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IOC4_W_IEC
suffix:colon
id|writel
c_func
(paren
id|val
comma
op_amp
id|mem-&gt;other_iec_ro
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc4_soft-&gt;is_ir_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * set_baud - Baud rate setting code&n; * @port: port to set&n; * @baud: baud rate to use&n; */
DECL|function|set_baud
r_static
r_int
id|set_baud
c_func
(paren
r_struct
id|ioc4_port
op_star
id|port
comma
r_int
id|baud
)paren
(brace
r_int
id|actual_baud
suffix:semicolon
r_int
id|diff
suffix:semicolon
r_int
id|lcr
suffix:semicolon
r_int
r_int
id|divisor
suffix:semicolon
r_struct
id|ioc4_uartregs
id|__iomem
op_star
id|uart
suffix:semicolon
id|divisor
op_assign
id|SER_DIVISOR
c_func
(paren
id|baud
comma
id|port-&gt;ip_pci_bus_speed
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|divisor
)paren
r_return
l_int|1
suffix:semicolon
id|actual_baud
op_assign
id|DIVISOR_TO_BAUD
c_func
(paren
id|divisor
comma
id|port-&gt;ip_pci_bus_speed
)paren
suffix:semicolon
id|diff
op_assign
id|actual_baud
op_minus
id|baud
suffix:semicolon
r_if
c_cond
(paren
id|diff
OL
l_int|0
)paren
id|diff
op_assign
op_minus
id|diff
suffix:semicolon
multiline_comment|/* If we&squot;re within 1%, we&squot;ve found a match */
r_if
c_cond
(paren
id|diff
op_star
l_int|100
OG
id|actual_baud
)paren
r_return
l_int|1
suffix:semicolon
id|uart
op_assign
id|port-&gt;ip_uart_regs
suffix:semicolon
id|lcr
op_assign
id|readb
c_func
(paren
op_amp
id|uart-&gt;i4u_lcr
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|lcr
op_or
id|UART_LCR_DLAB
comma
op_amp
id|uart-&gt;i4u_lcr
)paren
suffix:semicolon
id|writeb
c_func
(paren
(paren
r_int
r_char
)paren
id|divisor
comma
op_amp
id|uart-&gt;i4u_dll
)paren
suffix:semicolon
id|writeb
c_func
(paren
(paren
r_int
r_char
)paren
(paren
id|divisor
op_rshift
l_int|8
)paren
comma
op_amp
id|uart-&gt;i4u_dlm
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|lcr
comma
op_amp
id|uart-&gt;i4u_lcr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * get_ioc4_port - given a uart port, return the control structure&n; * @port: uart port&n; */
DECL|function|get_ioc4_port
r_static
r_struct
id|ioc4_port
op_star
id|get_ioc4_port
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
)paren
(brace
r_struct
id|ioc4_control
op_star
id|control
op_assign
id|dev_get_drvdata
c_func
(paren
id|the_port-&gt;dev
)paren
suffix:semicolon
r_int
id|ii
suffix:semicolon
r_if
c_cond
(paren
id|control
)paren
(brace
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
OL
id|IOC4_NUM_SERIAL_PORTS
suffix:semicolon
id|ii
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|control-&gt;ic_port
(braket
id|ii
)braket
dot
id|icp_port
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|the_port
op_eq
id|control-&gt;ic_port
(braket
id|ii
)braket
dot
id|icp_port-&gt;ip_port
)paren
r_return
id|control-&gt;ic_port
(braket
id|ii
)braket
dot
id|icp_port
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* The IOC4 hardware provides no atomic way to determine if interrupts&n; * are pending since two reads are required to do so.  The handler must&n; * read the SIO_IR and the SIO_IES, and take the logical and of the&n; * two.  When this value is zero, all interrupts have been serviced and&n; * the handler may return.&n; *&n; * This has the unfortunate &quot;hole&quot; that, if some other CPU or&n; * some other thread or some higher level interrupt manages to&n; * modify SIO_IE between our reads of SIO_IR and SIO_IE, we may&n; * think we have observed SIO_IR&amp;SIO_IE==0 when in fact this&n; * condition never really occurred.&n; *&n; * To solve this, we use a simple spinlock that must be held&n; * whenever modifying SIO_IE; holding this lock while observing&n; * both SIO_IR and SIO_IE guarantees that we do not falsely&n; * conclude that no enabled interrupts are pending.&n; */
r_static
r_inline
r_uint32
DECL|function|pending_intrs
id|pending_intrs
c_func
(paren
r_struct
id|ioc4_soft
op_star
id|soft
comma
r_int
id|type
)paren
(brace
r_struct
id|ioc4_mem
id|__iomem
op_star
id|mem
op_assign
id|soft-&gt;is_ioc4_mem_addr
suffix:semicolon
r_int
r_int
id|flag
suffix:semicolon
r_uint32
id|intrs
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
(paren
id|type
op_eq
id|IOC4_SIO_INTR_TYPE
)paren
op_logical_or
(paren
id|type
op_eq
id|IOC4_OTHER_INTR_TYPE
)paren
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|soft-&gt;is_ir_lock
comma
id|flag
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|IOC4_SIO_INTR_TYPE
suffix:colon
id|intrs
op_assign
id|readl
c_func
(paren
op_amp
id|mem-&gt;sio_ir
)paren
op_amp
id|readl
c_func
(paren
op_amp
id|mem-&gt;sio_ies_ro
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IOC4_OTHER_INTR_TYPE
suffix:colon
id|intrs
op_assign
id|readl
c_func
(paren
op_amp
id|mem-&gt;other_ir
)paren
op_amp
id|readl
c_func
(paren
op_amp
id|mem-&gt;other_ies_ro
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t process any ATA interrupte */
id|intrs
op_and_assign
op_complement
(paren
id|IOC4_OTHER_IR_ATA_INT
op_or
id|IOC4_OTHER_IR_ATA_MEMERR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|soft-&gt;is_ir_lock
comma
id|flag
)paren
suffix:semicolon
r_return
id|intrs
suffix:semicolon
)brace
multiline_comment|/**&n; * port_init - Initialize the sio and ioc4 hardware for a given port&n; *&t;&t;&t;called per port from attach...&n; * @port: port to initialize&n; */
DECL|function|port_init
r_static
r_int
r_inline
id|port_init
c_func
(paren
r_struct
id|ioc4_port
op_star
id|port
)paren
(brace
r_uint32
id|sio_cr
suffix:semicolon
r_struct
id|hooks
op_star
id|hooks
op_assign
id|port-&gt;ip_hooks
suffix:semicolon
r_struct
id|ioc4_uartregs
id|__iomem
op_star
id|uart
suffix:semicolon
multiline_comment|/* Idle the IOC4 serial interface */
id|writel
c_func
(paren
id|IOC4_SSCR_RESET
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
multiline_comment|/* Wait until any pending bus activity for this port has ceased */
r_do
id|sio_cr
op_assign
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_mem-&gt;sio_cr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|sio_cr
op_amp
id|IOC4_SIO_CR_SIO_DIAG_IDLE
)paren
)paren
suffix:semicolon
multiline_comment|/* Finish reset sequence */
id|writel
c_func
(paren
l_int|0
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
multiline_comment|/* Once RESET is done, reload cached tx_prod and rx_cons values&n;&t; * and set rings to empty by making prod == cons&n;&t; */
id|port-&gt;ip_tx_prod
op_assign
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;stcir
)paren
op_amp
id|PROD_CONS_MASK
suffix:semicolon
id|writel
c_func
(paren
id|port-&gt;ip_tx_prod
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;stpir
)paren
suffix:semicolon
id|port-&gt;ip_rx_cons
op_assign
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;srpir
)paren
op_amp
id|PROD_CONS_MASK
suffix:semicolon
id|writel
c_func
(paren
id|port-&gt;ip_rx_cons
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;srcir
)paren
suffix:semicolon
multiline_comment|/* Disable interrupts for this 16550 */
id|uart
op_assign
id|port-&gt;ip_uart_regs
suffix:semicolon
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|uart-&gt;i4u_lcr
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|uart-&gt;i4u_ier
)paren
suffix:semicolon
multiline_comment|/* Set the default baud */
id|set_baud
c_func
(paren
id|port
comma
id|port-&gt;ip_baud
)paren
suffix:semicolon
multiline_comment|/* Set line control to 8 bits no parity */
id|writeb
c_func
(paren
id|UART_LCR_WLEN8
op_or
l_int|0
comma
op_amp
id|uart-&gt;i4u_lcr
)paren
suffix:semicolon
multiline_comment|/* UART_LCR_STOP == 1 stop */
multiline_comment|/* Enable the FIFOs */
id|writeb
c_func
(paren
id|UART_FCR_ENABLE_FIFO
comma
op_amp
id|uart-&gt;i4u_fcr
)paren
suffix:semicolon
multiline_comment|/* then reset 16550 FIFOs */
id|writeb
c_func
(paren
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
comma
op_amp
id|uart-&gt;i4u_fcr
)paren
suffix:semicolon
multiline_comment|/* Clear modem control register */
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|uart-&gt;i4u_mcr
)paren
suffix:semicolon
multiline_comment|/* Clear deltas in modem status register */
id|readb
c_func
(paren
op_amp
id|uart-&gt;i4u_msr
)paren
suffix:semicolon
multiline_comment|/* Only do this once per port pair */
r_if
c_cond
(paren
id|port-&gt;ip_hooks
op_eq
op_amp
id|hooks_array
(braket
l_int|0
)braket
op_logical_or
id|port-&gt;ip_hooks
op_eq
op_amp
id|hooks_array
(braket
l_int|2
)braket
)paren
(brace
r_int
r_int
id|ring_pci_addr
suffix:semicolon
r_uint32
id|__iomem
op_star
id|sbbr_l
suffix:semicolon
r_uint32
id|__iomem
op_star
id|sbbr_h
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;ip_hooks
op_eq
op_amp
id|hooks_array
(braket
l_int|0
)braket
)paren
(brace
id|sbbr_l
op_assign
op_amp
id|port-&gt;ip_serial-&gt;sbbr01_l
suffix:semicolon
id|sbbr_h
op_assign
op_amp
id|port-&gt;ip_serial-&gt;sbbr01_h
suffix:semicolon
)brace
r_else
(brace
id|sbbr_l
op_assign
op_amp
id|port-&gt;ip_serial-&gt;sbbr23_l
suffix:semicolon
id|sbbr_h
op_assign
op_amp
id|port-&gt;ip_serial-&gt;sbbr23_h
suffix:semicolon
)brace
id|ring_pci_addr
op_assign
(paren
r_int
r_int
id|__iomem
)paren
id|port-&gt;ip_dma_ringbuf
suffix:semicolon
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot;%s: ring_pci_addr 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ring_pci_addr
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
(paren
r_int
r_int
)paren
(paren
(paren
r_uint64
)paren
id|ring_pci_addr
op_rshift
l_int|32
)paren
comma
id|sbbr_h
)paren
suffix:semicolon
id|writel
c_func
(paren
(paren
r_int
r_int
)paren
id|ring_pci_addr
op_or
id|IOC4_BUF_SIZE_BIT
comma
id|sbbr_l
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the receive timeout value to 10 msec */
id|writel
c_func
(paren
id|IOC4_SRTR_HZ
op_div
l_int|100
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;srtr
)paren
suffix:semicolon
multiline_comment|/* Set rx threshold, enable DMA */
multiline_comment|/* Set high water mark at 3/4 of full ring */
id|port-&gt;ip_sscr
op_assign
(paren
id|ENTRIES_PER_RING
op_star
l_int|3
op_div
l_int|4
)paren
suffix:semicolon
id|writel
c_func
(paren
id|port-&gt;ip_sscr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
multiline_comment|/* Disable and clear all serial related interrupt bits */
id|write_ireg
c_func
(paren
id|port-&gt;ip_ioc4_soft
comma
id|hooks-&gt;intr_clear
comma
id|IOC4_W_IEC
comma
id|IOC4_SIO_INTR_TYPE
)paren
suffix:semicolon
id|port-&gt;ip_ienb
op_and_assign
op_complement
id|hooks-&gt;intr_clear
suffix:semicolon
id|writel
c_func
(paren
id|hooks-&gt;intr_clear
comma
op_amp
id|port-&gt;ip_mem-&gt;sio_ir
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * handle_dma_error_intr - service any pending DMA error interrupts for the&n; *&t;&t;&t;given port - 2nd level called via sd_intr&n; * @arg: handler arg&n; * @other_ir: ioc4regs&n; */
DECL|function|handle_dma_error_intr
r_static
r_void
id|handle_dma_error_intr
c_func
(paren
r_void
op_star
id|arg
comma
r_uint32
id|other_ir
)paren
(brace
r_struct
id|ioc4_port
op_star
id|port
op_assign
(paren
r_struct
id|ioc4_port
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|hooks
op_star
id|hooks
op_assign
id|port-&gt;ip_hooks
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;ip_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* ACK the interrupt */
id|writel
c_func
(paren
id|hooks-&gt;intr_dma_error
comma
op_amp
id|port-&gt;ip_mem-&gt;other_ir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_mem-&gt;pci_err_addr_l
)paren
op_amp
id|IOC4_PCI_ERR_ADDR_VLD
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PCI error address is 0x%lx, &quot;
l_string|&quot;master is serial port %c %s&bslash;n&quot;
comma
(paren
(paren
(paren
r_uint64
)paren
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_mem-&gt;pci_err_addr_h
)paren
op_lshift
l_int|32
)paren
op_or
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_mem-&gt;pci_err_addr_l
)paren
)paren
op_amp
id|IOC4_PCI_ERR_ADDR_ADDR_MSK
comma
l_char|&squot;1&squot;
op_plus
(paren
(paren
r_char
)paren
(paren
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_mem
op_member_access_from_pointer
id|pci_err_addr_l
)paren
op_amp
id|IOC4_PCI_ERR_ADDR_MST_NUM_MSK
)paren
op_rshift
l_int|1
)paren
comma
(paren
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_mem-&gt;pci_err_addr_l
)paren
op_amp
id|IOC4_PCI_ERR_ADDR_MST_TYP_MSK
)paren
ques
c_cond
l_string|&quot;RX&quot;
suffix:colon
l_string|&quot;TX&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_mem-&gt;pci_err_addr_l
)paren
op_amp
id|IOC4_PCI_ERR_ADDR_MUL_ERR
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Multiple errors occurred&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;ip_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Re-enable DMA error interrupts */
id|write_ireg
c_func
(paren
id|port-&gt;ip_ioc4_soft
comma
id|hooks-&gt;intr_dma_error
comma
id|IOC4_W_IES
comma
id|IOC4_OTHER_INTR_TYPE
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * intr_connect - interrupt connect function&n; * @soft: soft struct for this card&n; * @type: interrupt type&n; * @intrbits: bit pattern to set&n; * @intr: handler function&n; * @info: handler arg&n; */
r_static
r_void
DECL|function|intr_connect
id|intr_connect
c_func
(paren
r_struct
id|ioc4_soft
op_star
id|soft
comma
r_int
id|type
comma
r_uint32
id|intrbits
comma
id|ioc4_intr_func_f
op_star
id|intr
comma
r_void
op_star
id|info
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|ioc4_intr_info
op_star
id|intr_ptr
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
(paren
id|type
op_eq
id|IOC4_SIO_INTR_TYPE
)paren
op_logical_or
(paren
id|type
op_eq
id|IOC4_OTHER_INTR_TYPE
)paren
)paren
)paren
suffix:semicolon
id|i
op_assign
id|atomic_inc
c_func
(paren
op_amp
id|soft
op_member_access_from_pointer
id|is_intr_type
(braket
id|type
)braket
dot
id|is_num_intrs
)paren
op_minus
l_int|1
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|i
OL
id|MAX_IOC4_INTR_ENTS
op_logical_or
(paren
id|printk
c_func
(paren
l_string|&quot;i %d&bslash;n&quot;
comma
id|i
)paren
comma
l_int|0
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Save off the lower level interrupt handler */
id|intr_ptr
op_assign
op_amp
id|soft-&gt;is_intr_type
(braket
id|type
)braket
dot
id|is_intr_info
(braket
id|i
)braket
suffix:semicolon
id|intr_ptr-&gt;sd_bits
op_assign
id|intrbits
suffix:semicolon
id|intr_ptr-&gt;sd_intr
op_assign
id|intr
suffix:semicolon
id|intr_ptr-&gt;sd_info
op_assign
id|info
suffix:semicolon
)brace
multiline_comment|/**&n; * ioc4_intr - Top level IOC4 interrupt handler.&n; * @irq: irq value&n; * @arg: handler arg&n; * @regs: registers&n; */
DECL|function|ioc4_intr
r_static
id|irqreturn_t
id|ioc4_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ioc4_soft
op_star
id|soft
suffix:semicolon
r_uint32
id|this_ir
comma
id|this_mir
suffix:semicolon
r_int
id|xx
comma
id|num_intrs
op_assign
l_int|0
suffix:semicolon
r_int
id|intr_type
suffix:semicolon
r_int
id|handled
op_assign
l_int|0
suffix:semicolon
r_struct
id|ioc4_intr_info
op_star
id|ii
suffix:semicolon
id|soft
op_assign
id|arg
suffix:semicolon
r_for
c_loop
(paren
id|intr_type
op_assign
l_int|0
suffix:semicolon
id|intr_type
OL
id|IOC4_NUM_INTR_TYPES
suffix:semicolon
id|intr_type
op_increment
)paren
(brace
id|num_intrs
op_assign
(paren
r_int
)paren
id|atomic_read
c_func
(paren
op_amp
id|soft-&gt;is_intr_type
(braket
id|intr_type
)braket
dot
id|is_num_intrs
)paren
suffix:semicolon
id|this_mir
op_assign
id|this_ir
op_assign
id|pending_intrs
c_func
(paren
id|soft
comma
id|intr_type
)paren
suffix:semicolon
multiline_comment|/* Farm out the interrupt to the various drivers depending on&n;&t;&t; * which interrupt bits are set.&n;&t;&t; */
r_for
c_loop
(paren
id|xx
op_assign
l_int|0
suffix:semicolon
id|xx
OL
id|num_intrs
suffix:semicolon
id|xx
op_increment
)paren
(brace
id|ii
op_assign
op_amp
id|soft-&gt;is_intr_type
(braket
id|intr_type
)braket
dot
id|is_intr_info
(braket
id|xx
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|this_mir
op_assign
id|this_ir
op_amp
id|ii-&gt;sd_bits
)paren
)paren
(brace
multiline_comment|/* Disable owned interrupts, call handler */
id|handled
op_increment
suffix:semicolon
id|write_ireg
c_func
(paren
id|soft
comma
id|ii-&gt;sd_bits
comma
id|IOC4_W_IEC
comma
id|intr_type
)paren
suffix:semicolon
id|ii
op_member_access_from_pointer
id|sd_intr
c_func
(paren
id|ii-&gt;sd_info
comma
id|this_mir
)paren
suffix:semicolon
id|this_ir
op_and_assign
op_complement
id|this_mir
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|this_ir
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;unknown IOC4 %s interrupt 0x%x, sio_ir = 0x%x,&quot;
l_string|&quot; sio_ies = 0x%x, other_ir = 0x%x :&quot;
l_string|&quot;other_ies = 0x%x&bslash;n&quot;
comma
(paren
id|intr_type
op_eq
id|IOC4_SIO_INTR_TYPE
)paren
ques
c_cond
l_string|&quot;sio&quot;
suffix:colon
l_string|&quot;other&quot;
comma
id|this_ir
comma
id|readl
c_func
(paren
op_amp
id|soft-&gt;is_ioc4_mem_addr-&gt;sio_ir
)paren
comma
id|readl
c_func
(paren
op_amp
id|soft-&gt;is_ioc4_mem_addr-&gt;sio_ies_ro
)paren
comma
id|readl
c_func
(paren
op_amp
id|soft-&gt;is_ioc4_mem_addr-&gt;other_ir
)paren
comma
id|readl
c_func
(paren
op_amp
id|soft-&gt;is_ioc4_mem_addr-&gt;other_ies_ro
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_INTERRUPTS
(brace
r_struct
id|ioc4_mem
id|__iomem
op_star
id|mem
op_assign
id|soft-&gt;is_ioc4_mem_addr
suffix:semicolon
id|spinlock_t
op_star
id|lp
op_assign
op_amp
id|soft-&gt;is_ir_lock
suffix:semicolon
r_int
r_int
id|flag
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|soft-&gt;is_ir_lock
comma
id|flag
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%s : %d : mem 0x%p sio_ir 0x%x sio_ies_ro 0x%x &quot;
l_string|&quot;other_ir 0x%x other_ies_ro 0x%x mask 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
comma
(paren
r_void
op_star
)paren
id|mem
comma
id|readl
c_func
(paren
op_amp
id|mem-&gt;sio_ir
)paren
comma
id|readl
c_func
(paren
op_amp
id|mem-&gt;sio_ies_ro
)paren
comma
id|readl
c_func
(paren
op_amp
id|mem-&gt;other_ir
)paren
comma
id|readl
c_func
(paren
op_amp
id|mem-&gt;other_ies_ro
)paren
comma
id|IOC4_OTHER_IR_ATA_INT
op_or
id|IOC4_OTHER_IR_ATA_MEMERR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|soft-&gt;is_ir_lock
comma
id|flag
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|handled
ques
c_cond
id|IRQ_HANDLED
suffix:colon
id|IRQ_NONE
suffix:semicolon
)brace
multiline_comment|/**&n; * ioc4_attach_local - Device initialization.&n; *&t;&t;&t;Called at *_attach() time for each&n; *&t;&t;&t;IOC4 with serial ports in the system.&n; * @control: ioc4_control ptr&n; * @pdev: PCI handle for this device&n; * @soft: soft struct for this device&n; * @ioc4: ioc4 mem space&n; */
DECL|function|ioc4_attach_local
r_static
r_int
r_inline
id|ioc4_attach_local
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|ioc4_control
op_star
id|control
comma
r_struct
id|ioc4_soft
op_star
id|soft
comma
r_void
id|__iomem
op_star
id|ioc4_mem
comma
r_void
id|__iomem
op_star
id|ioc4_serial
)paren
(brace
r_struct
id|ioc4_port
op_star
id|port
suffix:semicolon
r_struct
id|ioc4_port
op_star
id|ports
(braket
id|IOC4_NUM_SERIAL_PORTS
)braket
suffix:semicolon
r_int
id|port_number
suffix:semicolon
r_uint16
id|ioc4_revid_min
op_assign
l_int|62
suffix:semicolon
r_uint16
id|ioc4_revid
suffix:semicolon
multiline_comment|/* IOC4 firmware must be at least rev 62 */
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND_SPECIAL
comma
op_amp
id|ioc4_revid
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IOC4 firmware revision %d&bslash;n&quot;
comma
id|ioc4_revid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioc4_revid
OL
id|ioc4_revid_min
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;IOC4 serial not supported on firmware rev %d, &quot;
l_string|&quot;please upgrade to rev %d or higher&bslash;n&quot;
comma
id|ioc4_revid
comma
id|ioc4_revid_min
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|ioc4_mem
op_eq
l_int|NULL
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ioc4_serial
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Create port structures for each port */
r_for
c_loop
(paren
id|port_number
op_assign
l_int|0
suffix:semicolon
id|port_number
OL
id|IOC4_NUM_SERIAL_PORTS
suffix:semicolon
id|port_number
op_increment
)paren
(brace
id|port
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ioc4_port
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;IOC4 serial memory not available for port&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|port
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ioc4_port
)paren
)paren
suffix:semicolon
multiline_comment|/* we need to remember the previous ones, to point back to&n;&t;&t; * them farther down - setting up the ring buffers.&n;&t;&t; */
id|ports
(braket
id|port_number
)braket
op_assign
id|port
suffix:semicolon
multiline_comment|/* Allocate buffers and jumpstart the hardware.  */
id|control-&gt;ic_port
(braket
id|port_number
)braket
dot
id|icp_port
op_assign
id|port
suffix:semicolon
id|port-&gt;ip_ioc4_soft
op_assign
id|soft
suffix:semicolon
id|port-&gt;ip_pdev
op_assign
id|pdev
suffix:semicolon
id|port-&gt;ip_ienb
op_assign
l_int|0
suffix:semicolon
id|port-&gt;ip_pci_bus_speed
op_assign
id|IOC4_SER_XIN_CLK
suffix:semicolon
id|port-&gt;ip_baud
op_assign
l_int|9600
suffix:semicolon
id|port-&gt;ip_control
op_assign
id|control
suffix:semicolon
id|port-&gt;ip_mem
op_assign
id|ioc4_mem
suffix:semicolon
id|port-&gt;ip_serial
op_assign
id|ioc4_serial
suffix:semicolon
multiline_comment|/* point to the right hook */
id|port-&gt;ip_hooks
op_assign
op_amp
id|hooks_array
(braket
id|port_number
)braket
suffix:semicolon
multiline_comment|/* Get direct hooks to the serial regs and uart regs&n;&t;&t; * for this port&n;&t;&t; */
r_switch
c_cond
(paren
id|port_number
)paren
(brace
r_case
l_int|0
suffix:colon
id|port-&gt;ip_serial_regs
op_assign
op_amp
(paren
id|port-&gt;ip_serial-&gt;port_0
)paren
suffix:semicolon
id|port-&gt;ip_uart_regs
op_assign
op_amp
(paren
id|port-&gt;ip_serial-&gt;uart_0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|port-&gt;ip_serial_regs
op_assign
op_amp
(paren
id|port-&gt;ip_serial-&gt;port_1
)paren
suffix:semicolon
id|port-&gt;ip_uart_regs
op_assign
op_amp
(paren
id|port-&gt;ip_serial-&gt;uart_1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|port-&gt;ip_serial_regs
op_assign
op_amp
(paren
id|port-&gt;ip_serial-&gt;port_2
)paren
suffix:semicolon
id|port-&gt;ip_uart_regs
op_assign
op_amp
(paren
id|port-&gt;ip_serial-&gt;uart_2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
l_int|3
suffix:colon
id|port-&gt;ip_serial_regs
op_assign
op_amp
(paren
id|port-&gt;ip_serial-&gt;port_3
)paren
suffix:semicolon
id|port-&gt;ip_uart_regs
op_assign
op_amp
(paren
id|port-&gt;ip_serial-&gt;uart_3
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* ring buffers are 1 to a pair of ports */
r_if
c_cond
(paren
id|port_number
op_logical_and
(paren
id|port_number
op_amp
l_int|1
)paren
)paren
(brace
multiline_comment|/* odd use the evens buffer */
id|port-&gt;ip_dma_ringbuf
op_assign
id|ports
(braket
id|port_number
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|ip_dma_ringbuf
suffix:semicolon
id|port-&gt;ip_cpu_ringbuf
op_assign
id|ports
(braket
id|port_number
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|ip_cpu_ringbuf
suffix:semicolon
id|port-&gt;ip_inring
op_assign
id|RING
c_func
(paren
id|port
comma
id|RX_1_OR_3
)paren
suffix:semicolon
id|port-&gt;ip_outring
op_assign
id|RING
c_func
(paren
id|port
comma
id|TX_1_OR_3
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|port-&gt;ip_dma_ringbuf
op_eq
l_int|0
)paren
(brace
id|port-&gt;ip_cpu_ringbuf
op_assign
id|pci_alloc_consistent
(paren
id|pdev
comma
id|TOTAL_RING_BUF_SIZE
comma
op_amp
id|port-&gt;ip_dma_ringbuf
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
(paren
(paren
(paren
r_int64
)paren
id|port-&gt;ip_dma_ringbuf
)paren
op_amp
(paren
id|TOTAL_RING_BUF_SIZE
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
)paren
suffix:semicolon
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot;%s : ip_cpu_ringbuf 0x%p &quot;
l_string|&quot;ip_dma_ringbuf 0x%p&bslash;n&quot;
comma
id|__FUNCTION__
comma
(paren
r_void
op_star
)paren
id|port-&gt;ip_cpu_ringbuf
comma
(paren
r_void
op_star
)paren
id|port-&gt;ip_dma_ringbuf
)paren
)paren
suffix:semicolon
id|port-&gt;ip_inring
op_assign
id|RING
c_func
(paren
id|port
comma
id|RX_0_OR_2
)paren
suffix:semicolon
id|port-&gt;ip_outring
op_assign
id|RING
c_func
(paren
id|port
comma
id|TX_0_OR_2
)paren
suffix:semicolon
)brace
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot;%s : port %d [addr 0x%p] control 0x%p&quot;
comma
id|__FUNCTION__
comma
id|port_number
comma
(paren
r_void
op_star
)paren
id|port
comma
(paren
r_void
op_star
)paren
id|control
)paren
)paren
suffix:semicolon
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot; ip_serial_regs 0x%p ip_uart_regs 0x%p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|port-&gt;ip_serial_regs
comma
(paren
r_void
op_star
)paren
id|port-&gt;ip_uart_regs
)paren
)paren
suffix:semicolon
multiline_comment|/* Initialize the hardware for IOC4 */
id|port_init
c_func
(paren
id|port
)paren
suffix:semicolon
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot;%s: port_number %d port 0x%p inring 0x%p &quot;
l_string|&quot;outring 0x%p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|port_number
comma
(paren
r_void
op_star
)paren
id|port
comma
(paren
r_void
op_star
)paren
id|port-&gt;ip_inring
comma
(paren
r_void
op_star
)paren
id|port-&gt;ip_outring
)paren
)paren
suffix:semicolon
multiline_comment|/* Attach interrupt handlers */
id|intr_connect
c_func
(paren
id|soft
comma
id|IOC4_SIO_INTR_TYPE
comma
id|GET_SIO_IR
c_func
(paren
id|port_number
)paren
comma
id|handle_intr
comma
id|port
)paren
suffix:semicolon
id|intr_connect
c_func
(paren
id|soft
comma
id|IOC4_OTHER_INTR_TYPE
comma
id|GET_OTHER_IR
c_func
(paren
id|port_number
)paren
comma
id|handle_dma_error_intr
comma
id|port
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * enable_intrs - enable interrupts&n; * @port: port to enable&n; * @mask: mask to use&n; */
DECL|function|enable_intrs
r_static
r_void
id|enable_intrs
c_func
(paren
r_struct
id|ioc4_port
op_star
id|port
comma
r_uint32
id|mask
)paren
(brace
r_struct
id|hooks
op_star
id|hooks
op_assign
id|port-&gt;ip_hooks
suffix:semicolon
r_if
c_cond
(paren
(paren
id|port-&gt;ip_ienb
op_amp
id|mask
)paren
op_ne
id|mask
)paren
(brace
id|write_ireg
c_func
(paren
id|port-&gt;ip_ioc4_soft
comma
id|mask
comma
id|IOC4_W_IES
comma
id|IOC4_SIO_INTR_TYPE
)paren
suffix:semicolon
id|port-&gt;ip_ienb
op_or_assign
id|mask
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;ip_ienb
)paren
id|write_ireg
c_func
(paren
id|port-&gt;ip_ioc4_soft
comma
id|hooks-&gt;intr_dma_error
comma
id|IOC4_W_IES
comma
id|IOC4_OTHER_INTR_TYPE
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * local_open - local open a port&n; * @port: port to open&n; */
DECL|function|local_open
r_static
r_inline
r_int
id|local_open
c_func
(paren
r_struct
id|ioc4_port
op_star
id|port
)paren
(brace
r_int
id|spiniter
op_assign
l_int|0
suffix:semicolon
id|port-&gt;ip_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Pause the DMA interface if necessary */
r_if
c_cond
(paren
id|port-&gt;ip_sscr
op_amp
id|IOC4_SSCR_DMA_EN
)paren
(brace
id|writel
c_func
(paren
id|port-&gt;ip_sscr
op_or
id|IOC4_SSCR_DMA_PAUSE
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs
op_member_access_from_pointer
id|sscr
)paren
op_amp
id|IOC4_SSCR_PAUSE_STATE
)paren
op_eq
l_int|0
)paren
(brace
id|spiniter
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|spiniter
OG
id|MAXITER
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Reset the input fifo.  If the uart received chars while the port&n;&t; * was closed and DMA is not enabled, the uart may have a bunch of&n;&t; * chars hanging around in its rx fifo which will not be discarded&n;&t; * by rclr in the upper layer. We must get rid of them here.&n;&t; */
id|writeb
c_func
(paren
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
comma
op_amp
id|port-&gt;ip_uart_regs-&gt;i4u_fcr
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|UART_LCR_WLEN8
comma
op_amp
id|port-&gt;ip_uart_regs-&gt;i4u_lcr
)paren
suffix:semicolon
multiline_comment|/* UART_LCR_STOP == 1 stop */
multiline_comment|/* Re-enable DMA, set default threshold to intr whenever there is&n;&t; * data available.&n;&t; */
id|port-&gt;ip_sscr
op_and_assign
op_complement
id|IOC4_SSCR_RX_THRESHOLD
suffix:semicolon
id|port-&gt;ip_sscr
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* default threshold */
multiline_comment|/* Plug in the new sscr.  This implicitly clears the DMA_PAUSE&n;&t; * flag if it was set above&n;&t; */
id|writel
c_func
(paren
id|port-&gt;ip_sscr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
id|port-&gt;ip_tx_lowat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * set_rx_timeout - Set rx timeout and threshold values.&n; * @port: port to use&n; * @timeout: timeout value in ticks&n; */
DECL|function|set_rx_timeout
r_static
r_inline
r_int
id|set_rx_timeout
c_func
(paren
r_struct
id|ioc4_port
op_star
id|port
comma
r_int
id|timeout
)paren
(brace
r_int
id|threshold
suffix:semicolon
id|port-&gt;ip_rx_timeout
op_assign
id|timeout
suffix:semicolon
multiline_comment|/* Timeout is in ticks.  Let&squot;s figure out how many chars we&n;&t; * can receive at the current baud rate in that interval&n;&t; * and set the rx threshold to that amount.  There are 4 chars&n;&t; * per ring entry, so we&squot;ll divide the number of chars that will&n;&t; * arrive in timeout by 4.&n;&t; */
id|threshold
op_assign
id|timeout
op_star
id|port-&gt;ip_baud
op_div
l_int|10
op_div
id|HZ
op_div
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|threshold
op_eq
l_int|0
)paren
id|threshold
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* otherwise we&squot;ll intr all the time! */
r_if
c_cond
(paren
(paren
r_int
)paren
id|threshold
OG
(paren
r_int
)paren
id|IOC4_SSCR_RX_THRESHOLD
)paren
r_return
l_int|1
suffix:semicolon
id|port-&gt;ip_sscr
op_and_assign
op_complement
id|IOC4_SSCR_RX_THRESHOLD
suffix:semicolon
id|port-&gt;ip_sscr
op_or_assign
id|threshold
suffix:semicolon
id|writel
c_func
(paren
id|port-&gt;ip_sscr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
multiline_comment|/* Now set the rx timeout to the given value */
id|timeout
op_assign
id|timeout
op_star
id|IOC4_SRTR_HZ
op_div
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OG
id|IOC4_SRTR_CNT
)paren
id|timeout
op_assign
id|IOC4_SRTR_CNT
suffix:semicolon
id|writel
c_func
(paren
id|timeout
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;srtr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * config_port - config the hardware&n; * @port: port to config&n; * @baud: baud rate for the port&n; * @byte_size: data size&n; * @stop_bits: number of stop bits&n; * @parenb: parity enable ?&n; * @parodd: odd parity ?&n; */
r_static
r_inline
r_int
DECL|function|config_port
id|config_port
c_func
(paren
r_struct
id|ioc4_port
op_star
id|port
comma
r_int
id|baud
comma
r_int
id|byte_size
comma
r_int
id|stop_bits
comma
r_int
id|parenb
comma
r_int
id|parodd
)paren
(brace
r_char
id|lcr
comma
id|sizebits
suffix:semicolon
r_int
id|spiniter
op_assign
l_int|0
suffix:semicolon
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot;%s: baud %d byte_size %d stop %d parenb %d parodd %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|baud
comma
id|byte_size
comma
id|stop_bits
comma
id|parenb
comma
id|parodd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set_baud
c_func
(paren
id|port
comma
id|baud
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|byte_size
)paren
(brace
r_case
l_int|5
suffix:colon
id|sizebits
op_assign
id|UART_LCR_WLEN5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|sizebits
op_assign
id|UART_LCR_WLEN6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|sizebits
op_assign
id|UART_LCR_WLEN7
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|sizebits
op_assign
id|UART_LCR_WLEN8
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Pause the DMA interface if necessary */
r_if
c_cond
(paren
id|port-&gt;ip_sscr
op_amp
id|IOC4_SSCR_DMA_EN
)paren
(brace
id|writel
c_func
(paren
id|port-&gt;ip_sscr
op_or
id|IOC4_SSCR_DMA_PAUSE
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
op_amp
id|IOC4_SSCR_PAUSE_STATE
)paren
op_eq
l_int|0
)paren
(brace
id|spiniter
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|spiniter
OG
id|MAXITER
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Clear relevant fields in lcr */
id|lcr
op_assign
id|readb
c_func
(paren
op_amp
id|port-&gt;ip_uart_regs-&gt;i4u_lcr
)paren
suffix:semicolon
id|lcr
op_and_assign
op_complement
(paren
id|LCR_MASK_BITS_CHAR
op_or
id|UART_LCR_EPAR
op_or
id|UART_LCR_PARITY
op_or
id|LCR_MASK_STOP_BITS
)paren
suffix:semicolon
multiline_comment|/* Set byte size in lcr */
id|lcr
op_or_assign
id|sizebits
suffix:semicolon
multiline_comment|/* Set parity */
r_if
c_cond
(paren
id|parenb
)paren
(brace
id|lcr
op_or_assign
id|UART_LCR_PARITY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parodd
)paren
id|lcr
op_or_assign
id|UART_LCR_EPAR
suffix:semicolon
)brace
multiline_comment|/* Set stop bits */
r_if
c_cond
(paren
id|stop_bits
)paren
id|lcr
op_or_assign
id|UART_LCR_STOP
multiline_comment|/* 2 stop bits */
suffix:semicolon
id|writeb
c_func
(paren
id|lcr
comma
op_amp
id|port-&gt;ip_uart_regs-&gt;i4u_lcr
)paren
suffix:semicolon
multiline_comment|/* Re-enable the DMA interface if necessary */
r_if
c_cond
(paren
id|port-&gt;ip_sscr
op_amp
id|IOC4_SSCR_DMA_EN
)paren
(brace
id|writel
c_func
(paren
id|port-&gt;ip_sscr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
)brace
id|port-&gt;ip_baud
op_assign
id|baud
suffix:semicolon
multiline_comment|/* When we get within this number of ring entries of filling the&n;&t; * entire ring on tx, place an EXPLICIT intr to generate a lowat&n;&t; * notification when output has drained.&n;&t; */
id|port-&gt;ip_tx_lowat
op_assign
(paren
id|TX_LOWAT_CHARS
c_func
(paren
id|baud
)paren
op_plus
l_int|3
)paren
op_div
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;ip_tx_lowat
op_eq
l_int|0
)paren
id|port-&gt;ip_tx_lowat
op_assign
l_int|1
suffix:semicolon
id|set_rx_timeout
c_func
(paren
id|port
comma
id|port-&gt;ip_rx_timeout
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * do_write - Write bytes to the port.  Returns the number of bytes&n; *&t;&t;&t;actually written. Called from transmit_chars&n; * @port: port to use&n; * @buf: the stuff to write&n; * @len: how many bytes in &squot;buf&squot;&n; */
DECL|function|do_write
r_static
r_inline
r_int
id|do_write
c_func
(paren
r_struct
id|ioc4_port
op_star
id|port
comma
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|prod_ptr
comma
id|cons_ptr
comma
id|total
op_assign
l_int|0
suffix:semicolon
r_struct
id|ring
op_star
id|outring
suffix:semicolon
r_struct
id|ring_entry
op_star
id|entry
suffix:semicolon
r_struct
id|hooks
op_star
id|hooks
op_assign
id|port-&gt;ip_hooks
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|len
op_ge
l_int|0
)paren
)paren
suffix:semicolon
id|prod_ptr
op_assign
id|port-&gt;ip_tx_prod
suffix:semicolon
id|cons_ptr
op_assign
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;stcir
)paren
op_amp
id|PROD_CONS_MASK
suffix:semicolon
id|outring
op_assign
id|port-&gt;ip_outring
suffix:semicolon
multiline_comment|/* Maintain a 1-entry red-zone.  The ring buffer is full when&n;&t; * (cons - prod) % ring_size is 1.  Rather than do this subtraction&n;&t; * in the body of the loop, I&squot;ll do it now.&n;&t; */
id|cons_ptr
op_assign
(paren
id|cons_ptr
op_minus
(paren
r_int
)paren
r_sizeof
(paren
r_struct
id|ring_entry
)paren
)paren
op_amp
id|PROD_CONS_MASK
suffix:semicolon
multiline_comment|/* Stuff the bytes into the output */
r_while
c_loop
(paren
(paren
id|prod_ptr
op_ne
id|cons_ptr
)paren
op_logical_and
(paren
id|len
OG
l_int|0
)paren
)paren
(brace
r_int
id|xx
suffix:semicolon
multiline_comment|/* Get 4 bytes (one ring entry) at a time */
id|entry
op_assign
(paren
r_struct
id|ring_entry
op_star
)paren
(paren
(paren
id|caddr_t
)paren
id|outring
op_plus
id|prod_ptr
)paren
suffix:semicolon
multiline_comment|/* Invalidate all entries */
id|entry-&gt;ring_allsc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Copy in some bytes */
r_for
c_loop
(paren
id|xx
op_assign
l_int|0
suffix:semicolon
(paren
id|xx
OL
l_int|4
)paren
op_logical_and
(paren
id|len
OG
l_int|0
)paren
suffix:semicolon
id|xx
op_increment
)paren
(brace
id|entry-&gt;ring_data
(braket
id|xx
)braket
op_assign
op_star
id|buf
op_increment
suffix:semicolon
id|entry-&gt;ring_sc
(braket
id|xx
)braket
op_assign
id|IOC4_TXCB_VALID
suffix:semicolon
id|len
op_decrement
suffix:semicolon
id|total
op_increment
suffix:semicolon
)brace
multiline_comment|/* If we are within some small threshold of filling up the&n;&t;&t; * entire ring buffer, we must place an EXPLICIT intr here&n;&t;&t; * to generate a lowat interrupt in case we subsequently&n;&t;&t; * really do fill up the ring and the caller goes to sleep.&n;&t;&t; * No need to place more than one though.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|port-&gt;ip_flags
op_amp
id|LOWAT_WRITTEN
)paren
op_logical_and
(paren
(paren
id|cons_ptr
op_minus
id|prod_ptr
)paren
op_amp
id|PROD_CONS_MASK
)paren
op_le
id|port-&gt;ip_tx_lowat
op_star
(paren
r_int
)paren
r_sizeof
(paren
r_struct
id|ring_entry
)paren
)paren
(brace
id|port-&gt;ip_flags
op_or_assign
id|LOWAT_WRITTEN
suffix:semicolon
id|entry-&gt;ring_sc
(braket
l_int|0
)braket
op_or_assign
id|IOC4_TXCB_INT_WHEN_DONE
suffix:semicolon
)brace
multiline_comment|/* Go on to next entry */
id|prod_ptr
op_add_assign
r_sizeof
(paren
r_struct
id|ring_entry
)paren
suffix:semicolon
id|prod_ptr
op_and_assign
id|PROD_CONS_MASK
suffix:semicolon
)brace
multiline_comment|/* If we sent something, start DMA if necessary */
r_if
c_cond
(paren
id|total
OG
l_int|0
op_logical_and
op_logical_neg
(paren
id|port-&gt;ip_sscr
op_amp
id|IOC4_SSCR_DMA_EN
)paren
)paren
(brace
id|port-&gt;ip_sscr
op_or_assign
id|IOC4_SSCR_DMA_EN
suffix:semicolon
id|writel
c_func
(paren
id|port-&gt;ip_sscr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
)brace
multiline_comment|/* Store the new producer pointer.  If tx is disabled, we stuff the&n;&t; * data into the ring buffer, but we don&squot;t actually start tx.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uart_tx_stopped
c_func
(paren
id|port-&gt;ip_port
)paren
)paren
(brace
id|writel
c_func
(paren
id|prod_ptr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;stpir
)paren
suffix:semicolon
multiline_comment|/* If we are now transmitting, enable tx_mt interrupt so we&n;&t;&t; * can disable DMA if necessary when the tx finishes.&n;&t;&t; */
r_if
c_cond
(paren
id|total
OG
l_int|0
)paren
id|enable_intrs
c_func
(paren
id|port
comma
id|hooks-&gt;intr_tx_mt
)paren
suffix:semicolon
)brace
id|port-&gt;ip_tx_prod
op_assign
id|prod_ptr
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
multiline_comment|/**&n; * disable_intrs - disable interrupts&n; * @port: port to enable&n; * @mask: mask to use&n; */
DECL|function|disable_intrs
r_static
r_void
id|disable_intrs
c_func
(paren
r_struct
id|ioc4_port
op_star
id|port
comma
r_uint32
id|mask
)paren
(brace
r_struct
id|hooks
op_star
id|hooks
op_assign
id|port-&gt;ip_hooks
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;ip_ienb
op_amp
id|mask
)paren
(brace
id|write_ireg
c_func
(paren
id|port-&gt;ip_ioc4_soft
comma
id|mask
comma
id|IOC4_W_IEC
comma
id|IOC4_SIO_INTR_TYPE
)paren
suffix:semicolon
id|port-&gt;ip_ienb
op_and_assign
op_complement
id|mask
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;ip_ienb
)paren
id|write_ireg
c_func
(paren
id|port-&gt;ip_ioc4_soft
comma
id|hooks-&gt;intr_dma_error
comma
id|IOC4_W_IEC
comma
id|IOC4_OTHER_INTR_TYPE
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * set_notification - Modify event notification&n; * @port: port to use&n; * @mask: events mask&n; * @set_on: set ?&n; */
DECL|function|set_notification
r_static
r_int
id|set_notification
c_func
(paren
r_struct
id|ioc4_port
op_star
id|port
comma
r_int
id|mask
comma
r_int
id|set_on
)paren
(brace
r_struct
id|hooks
op_star
id|hooks
op_assign
id|port-&gt;ip_hooks
suffix:semicolon
r_uint32
id|intrbits
comma
id|sscrbits
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|mask
)paren
suffix:semicolon
id|intrbits
op_assign
id|sscrbits
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|N_DATA_READY
)paren
id|intrbits
op_or_assign
(paren
id|hooks-&gt;intr_rx_timer
op_or
id|hooks-&gt;intr_rx_high
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|N_OUTPUT_LOWAT
)paren
id|intrbits
op_or_assign
id|hooks-&gt;intr_tx_explicit
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|N_DDCD
)paren
(brace
id|intrbits
op_or_assign
id|hooks-&gt;intr_delta_dcd
suffix:semicolon
id|sscrbits
op_or_assign
id|IOC4_SSCR_RX_RING_DCD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mask
op_amp
id|N_DCTS
)paren
id|intrbits
op_or_assign
id|hooks-&gt;intr_delta_cts
suffix:semicolon
r_if
c_cond
(paren
id|set_on
)paren
(brace
id|enable_intrs
c_func
(paren
id|port
comma
id|intrbits
)paren
suffix:semicolon
id|port-&gt;ip_notify
op_or_assign
id|mask
suffix:semicolon
id|port-&gt;ip_sscr
op_or_assign
id|sscrbits
suffix:semicolon
)brace
r_else
(brace
id|disable_intrs
c_func
(paren
id|port
comma
id|intrbits
)paren
suffix:semicolon
id|port-&gt;ip_notify
op_and_assign
op_complement
id|mask
suffix:semicolon
id|port-&gt;ip_sscr
op_and_assign
op_complement
id|sscrbits
suffix:semicolon
)brace
multiline_comment|/* We require DMA if either DATA_READY or DDCD notification is&n;&t; * currently requested. If neither of these is requested and&n;&t; * there is currently no tx in progress, DMA may be disabled.&n;&t; */
r_if
c_cond
(paren
id|port-&gt;ip_notify
op_amp
(paren
id|N_DATA_READY
op_or
id|N_DDCD
)paren
)paren
id|port-&gt;ip_sscr
op_or_assign
id|IOC4_SSCR_DMA_EN
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|port-&gt;ip_ienb
op_amp
id|hooks-&gt;intr_tx_mt
)paren
)paren
id|port-&gt;ip_sscr
op_and_assign
op_complement
id|IOC4_SSCR_DMA_EN
suffix:semicolon
id|writel
c_func
(paren
id|port-&gt;ip_sscr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * set_mcr - set the master control reg&n; * @the_port: port to use&n; * @set: set ?&n; * @mask1: mcr mask&n; * @mask2: shadow mask&n; */
DECL|function|set_mcr
r_static
r_inline
r_int
id|set_mcr
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
comma
r_int
id|set
comma
r_int
id|mask1
comma
r_int
id|mask2
)paren
(brace
r_struct
id|ioc4_port
op_star
id|port
op_assign
id|get_ioc4_port
c_func
(paren
id|the_port
)paren
suffix:semicolon
r_uint32
id|shadow
suffix:semicolon
r_int
id|spiniter
op_assign
l_int|0
suffix:semicolon
r_char
id|mcr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Pause the DMA interface if necessary */
r_if
c_cond
(paren
id|port-&gt;ip_sscr
op_amp
id|IOC4_SSCR_DMA_EN
)paren
(brace
id|writel
c_func
(paren
id|port-&gt;ip_sscr
op_or
id|IOC4_SSCR_DMA_PAUSE
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
op_amp
id|IOC4_SSCR_PAUSE_STATE
)paren
op_eq
l_int|0
)paren
(brace
id|spiniter
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|spiniter
OG
id|MAXITER
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|shadow
op_assign
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;shadow
)paren
suffix:semicolon
id|mcr
op_assign
(paren
id|shadow
op_amp
l_int|0xff000000
)paren
op_rshift
l_int|24
suffix:semicolon
multiline_comment|/* Set new value */
r_if
c_cond
(paren
id|set
)paren
(brace
id|mcr
op_or_assign
id|mask1
suffix:semicolon
id|shadow
op_or_assign
id|mask2
suffix:semicolon
)brace
r_else
(brace
id|mcr
op_and_assign
op_complement
id|mask1
suffix:semicolon
id|shadow
op_and_assign
op_complement
id|mask2
suffix:semicolon
)brace
id|writeb
c_func
(paren
id|mcr
comma
op_amp
id|port-&gt;ip_uart_regs-&gt;i4u_mcr
)paren
suffix:semicolon
id|writel
c_func
(paren
id|shadow
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;shadow
)paren
suffix:semicolon
multiline_comment|/* Re-enable the DMA interface if necessary */
r_if
c_cond
(paren
id|port-&gt;ip_sscr
op_amp
id|IOC4_SSCR_DMA_EN
)paren
(brace
id|writel
c_func
(paren
id|port-&gt;ip_sscr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ioc4_set_proto - set the protocol for the port&n; * @port: port to use&n; * @proto: protocol to use&n; */
DECL|function|ioc4_set_proto
r_static
r_int
id|ioc4_set_proto
c_func
(paren
r_struct
id|ioc4_port
op_star
id|port
comma
r_enum
id|sio_proto
id|proto
)paren
(brace
r_struct
id|hooks
op_star
id|hooks
op_assign
id|port-&gt;ip_hooks
suffix:semicolon
r_switch
c_cond
(paren
id|proto
)paren
(brace
r_case
id|PROTO_RS232
suffix:colon
multiline_comment|/* Clear the appropriate GIO pin */
id|writel
c_func
(paren
l_int|0
comma
(paren
op_amp
id|port-&gt;ip_mem-&gt;gppr_0
op_plus
id|hooks-&gt;rs422_select_pin
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PROTO_RS422
suffix:colon
multiline_comment|/* Set the appropriate GIO pin */
id|writel
c_func
(paren
l_int|1
comma
(paren
op_amp
id|port-&gt;ip_mem-&gt;gppr_0
op_plus
id|hooks-&gt;rs422_select_pin
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * transmit_chars - upper level write, called with ip_lock&n; * @the_port: port to write&n; */
DECL|function|transmit_chars
r_static
r_void
id|transmit_chars
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
)paren
(brace
r_int
id|xmit_count
comma
id|tail
comma
id|head
suffix:semicolon
r_int
id|result
suffix:semicolon
r_char
op_star
id|start
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_struct
id|ioc4_port
op_star
id|port
op_assign
id|get_ioc4_port
c_func
(paren
id|the_port
)paren
suffix:semicolon
r_struct
id|uart_info
op_star
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|the_port
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
id|info
op_assign
id|the_port-&gt;info
suffix:semicolon
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
op_amp
id|info-&gt;xmit
)paren
op_logical_or
id|uart_tx_stopped
c_func
(paren
id|the_port
)paren
)paren
(brace
multiline_comment|/* Nothing to do or hw stopped */
id|set_notification
c_func
(paren
id|port
comma
id|N_ALL_OUTPUT
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|head
op_assign
id|info-&gt;xmit.head
suffix:semicolon
id|tail
op_assign
id|info-&gt;xmit.tail
suffix:semicolon
id|start
op_assign
(paren
r_char
op_star
)paren
op_amp
id|info-&gt;xmit.buf
(braket
id|tail
)braket
suffix:semicolon
multiline_comment|/* write out all the data or until the end of the buffer */
id|xmit_count
op_assign
(paren
id|head
OL
id|tail
)paren
ques
c_cond
(paren
id|UART_XMIT_SIZE
op_minus
id|tail
)paren
suffix:colon
(paren
id|head
op_minus
id|tail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmit_count
OG
l_int|0
)paren
(brace
id|result
op_assign
id|do_write
c_func
(paren
id|port
comma
id|start
comma
id|xmit_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
(brace
multiline_comment|/* booking */
id|xmit_count
op_sub_assign
id|result
suffix:semicolon
id|the_port-&gt;icount.tx
op_add_assign
id|result
suffix:semicolon
multiline_comment|/* advance the pointers */
id|tail
op_add_assign
id|result
suffix:semicolon
id|tail
op_and_assign
id|UART_XMIT_SIZE
op_minus
l_int|1
suffix:semicolon
id|info-&gt;xmit.tail
op_assign
id|tail
suffix:semicolon
id|start
op_assign
(paren
r_char
op_star
)paren
op_amp
id|info-&gt;xmit.buf
(braket
id|tail
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|uart_circ_chars_pending
c_func
(paren
op_amp
id|info-&gt;xmit
)paren
OL
id|WAKEUP_CHARS
)paren
id|uart_write_wakeup
c_func
(paren
id|the_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
op_amp
id|info-&gt;xmit
)paren
)paren
(brace
id|set_notification
c_func
(paren
id|port
comma
id|N_OUTPUT_LOWAT
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_notification
c_func
(paren
id|port
comma
id|N_OUTPUT_LOWAT
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * ioc4_change_speed - change the speed of the port&n; * @the_port: port to change&n; * @new_termios: new termios settings&n; * @old_termios: old termios settings&n; */
r_static
r_void
DECL|function|ioc4_change_speed
id|ioc4_change_speed
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
comma
r_struct
id|termios
op_star
id|new_termios
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|ioc4_port
op_star
id|port
op_assign
id|get_ioc4_port
c_func
(paren
id|the_port
)paren
suffix:semicolon
r_int
id|baud
comma
id|bits
suffix:semicolon
r_int
id|cflag
comma
id|cval
suffix:semicolon
r_int
id|new_parity
op_assign
l_int|0
comma
id|new_parity_enable
op_assign
l_int|0
comma
id|new_stop
op_assign
l_int|1
comma
id|new_data
op_assign
l_int|8
suffix:semicolon
r_struct
id|uart_info
op_star
id|info
op_assign
id|the_port-&gt;info
suffix:semicolon
id|cflag
op_assign
id|new_termios-&gt;c_cflag
suffix:semicolon
r_switch
c_cond
(paren
id|cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|new_data
op_assign
l_int|5
suffix:semicolon
id|cval
op_assign
l_int|0x00
suffix:semicolon
id|bits
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|new_data
op_assign
l_int|6
suffix:semicolon
id|cval
op_assign
l_int|0x01
suffix:semicolon
id|bits
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|new_data
op_assign
l_int|7
suffix:semicolon
id|cval
op_assign
l_int|0x02
suffix:semicolon
id|bits
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS8
suffix:colon
id|new_data
op_assign
l_int|8
suffix:semicolon
id|cval
op_assign
l_int|0x03
suffix:semicolon
id|bits
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* cuz we always need a default ... */
id|new_data
op_assign
l_int|5
suffix:semicolon
id|cval
op_assign
l_int|0x00
suffix:semicolon
id|bits
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|CSTOPB
)paren
(brace
id|cval
op_or_assign
l_int|0x04
suffix:semicolon
id|bits
op_increment
suffix:semicolon
id|new_stop
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|PARENB
)paren
(brace
id|cval
op_or_assign
id|UART_LCR_PARITY
suffix:semicolon
id|bits
op_increment
suffix:semicolon
id|new_parity_enable
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|PARODD
)paren
(brace
id|cval
op_or_assign
id|UART_LCR_EPAR
suffix:semicolon
id|new_parity
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|IGNPAR
)paren
(brace
id|cval
op_and_assign
op_complement
id|UART_LCR_PARITY
suffix:semicolon
id|new_parity_enable
op_assign
l_int|0
suffix:semicolon
)brace
id|baud
op_assign
id|uart_get_baud_rate
c_func
(paren
id|the_port
comma
id|new_termios
comma
id|old_termios
comma
id|MIN_BAUD_SUPPORTED
comma
id|MAX_BAUD_SUPPORTED
)paren
suffix:semicolon
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot;%s: returned baud %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|baud
)paren
)paren
suffix:semicolon
multiline_comment|/* default is 9600 */
r_if
c_cond
(paren
op_logical_neg
id|baud
)paren
id|baud
op_assign
l_int|9600
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|the_port-&gt;fifosize
)paren
id|the_port-&gt;fifosize
op_assign
id|IOC4_MAX_CHARS
suffix:semicolon
id|the_port-&gt;timeout
op_assign
(paren
(paren
id|the_port-&gt;fifosize
op_star
id|HZ
op_star
id|bits
)paren
op_div
(paren
id|baud
op_div
l_int|10
)paren
)paren
suffix:semicolon
id|the_port-&gt;timeout
op_add_assign
id|HZ
op_div
l_int|50
suffix:semicolon
multiline_comment|/* Add .02 seconds of slop */
id|the_port-&gt;ignore_status_mask
op_assign
id|N_ALL_INPUT
suffix:semicolon
r_if
c_cond
(paren
id|I_IGNPAR
c_func
(paren
id|info-&gt;tty
)paren
)paren
id|the_port-&gt;ignore_status_mask
op_and_assign
op_complement
(paren
id|N_PARITY_ERROR
op_or
id|N_FRAMING_ERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I_IGNBRK
c_func
(paren
id|info-&gt;tty
)paren
)paren
(brace
id|the_port-&gt;ignore_status_mask
op_and_assign
op_complement
id|N_BREAK
suffix:semicolon
r_if
c_cond
(paren
id|I_IGNPAR
c_func
(paren
id|info-&gt;tty
)paren
)paren
id|the_port-&gt;ignore_status_mask
op_and_assign
op_complement
id|N_OVERRUN_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|cflag
op_amp
id|CREAD
)paren
)paren
(brace
multiline_comment|/* ignore everything */
id|the_port-&gt;ignore_status_mask
op_and_assign
op_complement
id|N_DATA_READY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
id|info-&gt;flags
op_or_assign
id|ASYNC_CTS_FLOW
suffix:semicolon
r_else
id|info-&gt;flags
op_and_assign
op_complement
id|ASYNC_CTS_FLOW
suffix:semicolon
multiline_comment|/* Set the configuration and proper notification call */
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot;%s : port 0x%p cflag 0%o &quot;
l_string|&quot;config_port(baud %d data %d stop %d p enable %d parity %d),&quot;
l_string|&quot; notification 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
(paren
r_void
op_star
)paren
id|port
comma
id|cflag
comma
id|baud
comma
id|new_data
comma
id|new_stop
comma
id|new_parity_enable
comma
id|new_parity
comma
id|the_port-&gt;ignore_status_mask
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|config_port
c_func
(paren
id|port
comma
id|baud
comma
multiline_comment|/* baud */
id|new_data
comma
multiline_comment|/* byte size */
id|new_stop
comma
multiline_comment|/* stop bits */
id|new_parity_enable
comma
multiline_comment|/* set parity */
id|new_parity
)paren
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/* parity 1==odd */
id|set_notification
c_func
(paren
id|port
comma
id|the_port-&gt;ignore_status_mask
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * ic4_startup_local - Start up the serial port - returns &gt;= 0 if no errors&n; * @the_port: Port to operate on&n; */
DECL|function|ic4_startup_local
r_static
r_inline
r_int
id|ic4_startup_local
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|ioc4_port
op_star
id|port
suffix:semicolon
r_struct
id|uart_info
op_star
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|the_port
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|port
op_assign
id|get_ioc4_port
c_func
(paren
id|the_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|info
op_assign
id|the_port-&gt;info
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|UIF_INITIALIZED
)paren
(brace
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;tty
)paren
(brace
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_HI
)paren
id|info-&gt;tty-&gt;alt_speed
op_assign
l_int|57600
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_VHI
)paren
id|info-&gt;tty-&gt;alt_speed
op_assign
l_int|115200
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_SHI
)paren
id|info-&gt;tty-&gt;alt_speed
op_assign
l_int|230400
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_WARP
)paren
id|info-&gt;tty-&gt;alt_speed
op_assign
l_int|460800
suffix:semicolon
)brace
id|local_open
c_func
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* set the speed of the serial port */
id|ioc4_change_speed
c_func
(paren
id|the_port
comma
id|info-&gt;tty-&gt;termios
comma
(paren
r_struct
id|termios
op_star
)paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* enable hardware flow control - after ioc4_change_speed because&n;&t; * ASYNC_CTS_FLOW is set there */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CTS_FLOW
)paren
(brace
id|port-&gt;ip_sscr
op_or_assign
id|IOC4_SSCR_HFC_EN
suffix:semicolon
id|writel
c_func
(paren
id|port-&gt;ip_sscr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
)brace
id|info-&gt;flags
op_or_assign
id|UIF_INITIALIZED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ioc4_cb_output_lowat - called when the output low water mark is hit&n; * @port: port to output&n; */
DECL|function|ioc4_cb_output_lowat
r_static
r_void
id|ioc4_cb_output_lowat
c_func
(paren
r_struct
id|ioc4_port
op_star
id|port
)paren
(brace
multiline_comment|/* ip_lock is set on the call here */
r_if
c_cond
(paren
id|port-&gt;ip_port
)paren
(brace
id|transmit_chars
c_func
(paren
id|port-&gt;ip_port
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * handle_intr - service any interrupts for the given port - 2nd level&n; *&t;&t;&t;called via sd_intr&n; * @arg: handler arg&n; * @sio_ir: ioc4regs&n; */
DECL|function|handle_intr
r_static
r_void
id|handle_intr
c_func
(paren
r_void
op_star
id|arg
comma
r_uint32
id|sio_ir
)paren
(brace
r_struct
id|ioc4_port
op_star
id|port
op_assign
(paren
r_struct
id|ioc4_port
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|hooks
op_star
id|hooks
op_assign
id|port-&gt;ip_hooks
suffix:semicolon
r_int
r_int
id|rx_high_rd_aborted
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|uart_port
op_star
id|the_port
suffix:semicolon
r_int
id|loop_counter
suffix:semicolon
multiline_comment|/* Possible race condition here: The tx_mt interrupt bit may be&n;&t; * cleared without the intervention of the interrupt handler,&n;&t; * e.g. by a write.  If the top level interrupt handler reads a&n;&t; * tx_mt, then some other processor does a write, starting up&n;&t; * output, then we come in here, see the tx_mt and stop DMA, the&n;&t; * output started by the other processor will hang.  Thus we can&n;&t; * only rely on tx_mt being legitimate if it is read while the&n;&t; * port lock is held.  Therefore this bit must be ignored in the&n;&t; * passed in interrupt mask which was read by the top level&n;&t; * interrupt handler since the port lock was not held at the time&n;&t; * it was read.  We can only rely on this bit being accurate if it&n;&t; * is read while the port lock is held.  So we&squot;ll clear it for now,&n;&t; * and reload it later once we have the port lock.&n;&t; */
id|sio_ir
op_and_assign
op_complement
(paren
id|hooks-&gt;intr_tx_mt
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;ip_lock
comma
id|flags
)paren
suffix:semicolon
id|loop_counter
op_assign
id|MAXITER
suffix:semicolon
multiline_comment|/* to avoid hangs */
r_do
(brace
r_uint32
id|shadow
suffix:semicolon
r_if
c_cond
(paren
id|loop_counter
op_decrement
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;IOC4 serial: &quot;
l_string|&quot;possible hang condition/&quot;
l_string|&quot;port stuck on interrupt.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Handle a DCD change */
r_if
c_cond
(paren
id|sio_ir
op_amp
id|hooks-&gt;intr_delta_dcd
)paren
(brace
multiline_comment|/* ACK the interrupt */
id|writel
c_func
(paren
id|hooks-&gt;intr_delta_dcd
comma
op_amp
id|port-&gt;ip_mem-&gt;sio_ir
)paren
suffix:semicolon
id|shadow
op_assign
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;shadow
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|port-&gt;ip_notify
op_amp
id|N_DDCD
)paren
op_logical_and
(paren
id|shadow
op_amp
id|IOC4_SHADOW_DCD
)paren
op_logical_and
(paren
id|port-&gt;ip_port
)paren
)paren
(brace
id|the_port
op_assign
id|port-&gt;ip_port
suffix:semicolon
id|the_port-&gt;icount.dcd
op_assign
l_int|1
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|the_port
op_member_access_from_pointer
id|info-&gt;delta_msr_wait
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|port-&gt;ip_notify
op_amp
id|N_DDCD
)paren
op_logical_and
op_logical_neg
(paren
id|shadow
op_amp
id|IOC4_SHADOW_DCD
)paren
)paren
(brace
multiline_comment|/* Flag delta DCD/no DCD */
id|port-&gt;ip_flags
op_or_assign
id|DCD_ON
suffix:semicolon
)brace
)brace
multiline_comment|/* Handle a CTS change */
r_if
c_cond
(paren
id|sio_ir
op_amp
id|hooks-&gt;intr_delta_cts
)paren
(brace
multiline_comment|/* ACK the interrupt */
id|writel
c_func
(paren
id|hooks-&gt;intr_delta_cts
comma
op_amp
id|port-&gt;ip_mem-&gt;sio_ir
)paren
suffix:semicolon
id|shadow
op_assign
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;shadow
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|port-&gt;ip_notify
op_amp
id|N_DCTS
)paren
op_logical_and
(paren
id|port-&gt;ip_port
)paren
)paren
(brace
id|the_port
op_assign
id|port-&gt;ip_port
suffix:semicolon
id|the_port-&gt;icount.cts
op_assign
(paren
id|shadow
op_amp
id|IOC4_SHADOW_CTS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|the_port-&gt;info-&gt;delta_msr_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* rx timeout interrupt.  Must be some data available.  Put this&n;&t;&t; * before the check for rx_high since servicing this condition&n;&t;&t; * may cause that condition to clear.&n;&t;&t; */
r_if
c_cond
(paren
id|sio_ir
op_amp
id|hooks-&gt;intr_rx_timer
)paren
(brace
multiline_comment|/* ACK the interrupt */
id|writel
c_func
(paren
id|hooks-&gt;intr_rx_timer
comma
op_amp
id|port-&gt;ip_mem-&gt;sio_ir
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|port-&gt;ip_notify
op_amp
id|N_DATA_READY
)paren
op_logical_and
(paren
id|port-&gt;ip_port
)paren
)paren
(brace
multiline_comment|/* ip_lock is set on call here */
id|receive_chars
c_func
(paren
id|port-&gt;ip_port
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* rx high interrupt. Must be after rx_timer.  */
r_else
r_if
c_cond
(paren
id|sio_ir
op_amp
id|hooks-&gt;intr_rx_high
)paren
(brace
multiline_comment|/* Data available, notify upper layer */
r_if
c_cond
(paren
(paren
id|port-&gt;ip_notify
op_amp
id|N_DATA_READY
)paren
op_logical_and
id|port-&gt;ip_port
)paren
(brace
multiline_comment|/* ip_lock is set on call here */
id|receive_chars
c_func
(paren
id|port-&gt;ip_port
)paren
suffix:semicolon
)brace
multiline_comment|/* We can&squot;t ACK this interrupt.  If receive_chars didn&squot;t&n;&t;&t;&t; * cause the condition to clear, we&squot;ll have to disable&n;&t;&t;&t; * the interrupt until the data is drained.&n;&t;&t;&t; * If the read was aborted, don&squot;t disable the interrupt&n;&t;&t;&t; * as this may cause us to hang indefinitely.  An&n;&t;&t;&t; * aborted read generally means that this interrupt&n;&t;&t;&t; * hasn&squot;t been delivered to the cpu yet anyway, even&n;&t;&t;&t; * though we see it as asserted when we read the sio_ir.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|sio_ir
op_assign
id|PENDING
c_func
(paren
id|port
)paren
)paren
op_amp
id|hooks-&gt;intr_rx_high
)paren
(brace
r_if
c_cond
(paren
(paren
id|port-&gt;ip_flags
op_amp
id|READ_ABORTED
)paren
op_eq
l_int|0
)paren
(brace
id|port-&gt;ip_ienb
op_and_assign
op_complement
id|hooks-&gt;intr_rx_high
suffix:semicolon
id|port-&gt;ip_flags
op_or_assign
id|INPUT_HIGH
suffix:semicolon
)brace
r_else
(brace
id|rx_high_rd_aborted
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* We got a low water interrupt: notify upper layer to&n;&t;&t; * send more data.  Must come before tx_mt since servicing&n;&t;&t; * this condition may cause that condition to clear.&n;&t;&t; */
r_if
c_cond
(paren
id|sio_ir
op_amp
id|hooks-&gt;intr_tx_explicit
)paren
(brace
id|port-&gt;ip_flags
op_and_assign
op_complement
id|LOWAT_WRITTEN
suffix:semicolon
multiline_comment|/* ACK the interrupt */
id|writel
c_func
(paren
id|hooks-&gt;intr_tx_explicit
comma
op_amp
id|port-&gt;ip_mem-&gt;sio_ir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;ip_notify
op_amp
id|N_OUTPUT_LOWAT
)paren
id|ioc4_cb_output_lowat
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle tx_mt.  Must come after tx_explicit.  */
r_else
r_if
c_cond
(paren
id|sio_ir
op_amp
id|hooks-&gt;intr_tx_mt
)paren
(brace
multiline_comment|/* If we are expecting a lowat notification&n;&t;&t;&t; * and we get to this point it probably means that for&n;&t;&t;&t; * some reason the tx_explicit didn&squot;t work as expected&n;&t;&t;&t; * (that can legitimately happen if the output buffer is&n;&t;&t;&t; * filled up in just the right way).&n;&t;&t;&t; * So send the notification now.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|port-&gt;ip_notify
op_amp
id|N_OUTPUT_LOWAT
)paren
(brace
id|ioc4_cb_output_lowat
c_func
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* We need to reload the sio_ir since the lowat&n;&t;&t;&t;&t; * call may have caused another write to occur,&n;&t;&t;&t;&t; * clearing the tx_mt condition.&n;&t;&t;&t;&t; */
id|sio_ir
op_assign
id|PENDING
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
multiline_comment|/* If the tx_mt condition still persists even after the&n;&t;&t;&t; * lowat call, we&squot;ve got some work to do.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sio_ir
op_amp
id|hooks-&gt;intr_tx_mt
)paren
(brace
multiline_comment|/* If we are not currently expecting DMA input,&n;&t;&t;&t;&t; * and the transmitter has just gone idle,&n;&t;&t;&t;&t; * there is no longer any reason for DMA, so&n;&t;&t;&t;&t; * disable it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|port-&gt;ip_notify
op_amp
(paren
id|N_DATA_READY
op_or
id|N_DDCD
)paren
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|port-&gt;ip_sscr
op_amp
id|IOC4_SSCR_DMA_EN
)paren
)paren
suffix:semicolon
id|port-&gt;ip_sscr
op_and_assign
op_complement
id|IOC4_SSCR_DMA_EN
suffix:semicolon
id|writel
c_func
(paren
id|port-&gt;ip_sscr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
)brace
multiline_comment|/* Prevent infinite tx_mt interrupt */
id|port-&gt;ip_ienb
op_and_assign
op_complement
id|hooks-&gt;intr_tx_mt
suffix:semicolon
)brace
)brace
id|sio_ir
op_assign
id|PENDING
c_func
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* if the read was aborted and only hooks-&gt;intr_rx_high,&n;&t;&t; * clear hooks-&gt;intr_rx_high, so we do not loop forever.&n;&t;&t; */
r_if
c_cond
(paren
id|rx_high_rd_aborted
op_logical_and
(paren
id|sio_ir
op_eq
id|hooks-&gt;intr_rx_high
)paren
)paren
(brace
id|sio_ir
op_and_assign
op_complement
id|hooks-&gt;intr_rx_high
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|sio_ir
op_amp
id|hooks-&gt;intr_all
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;ip_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Re-enable interrupts before returning from interrupt handler.&n;&t; * Getting interrupted here is okay.  It&squot;ll just v() our semaphore, and&n;&t; * we&squot;ll come through the loop again.&n;&t; */
id|write_ireg
c_func
(paren
id|port-&gt;ip_ioc4_soft
comma
id|port-&gt;ip_ienb
comma
id|IOC4_W_IES
comma
id|IOC4_SIO_INTR_TYPE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ioc4_cb_post_ncs - called for some basic errors&n; * @port: port to use&n; * @ncs: event&n; */
DECL|function|ioc4_cb_post_ncs
r_static
r_void
id|ioc4_cb_post_ncs
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
comma
r_int
id|ncs
)paren
(brace
r_struct
id|uart_icount
op_star
id|icount
suffix:semicolon
id|icount
op_assign
op_amp
id|the_port-&gt;icount
suffix:semicolon
r_if
c_cond
(paren
id|ncs
op_amp
id|NCS_BREAK
)paren
id|icount-&gt;brk
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ncs
op_amp
id|NCS_FRAMING
)paren
id|icount-&gt;frame
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ncs
op_amp
id|NCS_OVERRUN
)paren
id|icount-&gt;overrun
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ncs
op_amp
id|NCS_PARITY
)paren
id|icount-&gt;parity
op_increment
suffix:semicolon
)brace
multiline_comment|/**&n; * do_read - Read in bytes from the port.  Return the number of bytes&n; *&t;&t;&t;actually read.&n; * @the_port: port to use&n; * @buf: place to put the stuff we read&n; * @len: how big &squot;buf&squot; is&n; */
DECL|function|do_read
r_static
r_inline
r_int
id|do_read
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|prod_ptr
comma
id|cons_ptr
comma
id|total
suffix:semicolon
r_struct
id|ioc4_port
op_star
id|port
op_assign
id|get_ioc4_port
c_func
(paren
id|the_port
)paren
suffix:semicolon
r_struct
id|ring
op_star
id|inring
suffix:semicolon
r_struct
id|ring_entry
op_star
id|entry
suffix:semicolon
r_struct
id|hooks
op_star
id|hooks
op_assign
id|port-&gt;ip_hooks
suffix:semicolon
r_int
id|byte_num
suffix:semicolon
r_char
op_star
id|sc
suffix:semicolon
r_int
id|loop_counter
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|len
op_ge
l_int|0
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|port
)paren
suffix:semicolon
multiline_comment|/* There is a nasty timing issue in the IOC4. When the rx_timer&n;&t; * expires or the rx_high condition arises, we take an interrupt.&n;&t; * At some point while servicing the interrupt, we read bytes from&n;&t; * the ring buffer and re-arm the rx_timer.  However the rx_timer is&n;&t; * not started until the first byte is received *after* it is armed,&n;&t; * and any bytes pending in the rx construction buffers are not drained&n;&t; * to memory until either there are 4 bytes available or the rx_timer&n;&t; * expires.  This leads to a potential situation where data is left&n;&t; * in the construction buffers forever - 1 to 3 bytes were received&n;&t; * after the interrupt was generated but before the rx_timer was&n;&t; * re-armed. At that point as long as no subsequent bytes are received&n;&t; * the timer will never be started and the bytes will remain in the&n;&t; * construction buffer forever.  The solution is to execute a DRAIN&n;&t; * command after rearming the timer.  This way any bytes received before&n;&t; * the DRAIN will be drained to memory, and any bytes received after&n;&t; * the DRAIN will start the TIMER and be drained when it expires.&n;&t; * Luckily, this only needs to be done when the DMA buffer is empty&n;&t; * since there is no requirement that this function return all&n;&t; * available data as long as it returns some.&n;&t; */
multiline_comment|/* Re-arm the timer */
id|writel
c_func
(paren
id|port-&gt;ip_rx_cons
op_or
id|IOC4_SRCIR_ARM
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;srcir
)paren
suffix:semicolon
id|prod_ptr
op_assign
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;srpir
)paren
op_amp
id|PROD_CONS_MASK
suffix:semicolon
id|cons_ptr
op_assign
id|port-&gt;ip_rx_cons
suffix:semicolon
r_if
c_cond
(paren
id|prod_ptr
op_eq
id|cons_ptr
)paren
(brace
r_int
id|reset_dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Input buffer appears empty, do a flush. */
multiline_comment|/* DMA must be enabled for this to work. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|port-&gt;ip_sscr
op_amp
id|IOC4_SSCR_DMA_EN
)paren
)paren
(brace
id|port-&gt;ip_sscr
op_or_assign
id|IOC4_SSCR_DMA_EN
suffix:semicolon
id|reset_dma
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Potential race condition: we must reload the srpir after&n;&t;&t; * issuing the drain command, otherwise we could think the rx&n;&t;&t; * buffer is empty, then take a very long interrupt, and when&n;&t;&t; * we come back it&squot;s full and we wait forever for the drain to&n;&t;&t; * complete.&n;&t;&t; */
id|writel
c_func
(paren
id|port-&gt;ip_sscr
op_or
id|IOC4_SSCR_RX_DRAIN
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
id|prod_ptr
op_assign
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;srpir
)paren
op_amp
id|PROD_CONS_MASK
suffix:semicolon
multiline_comment|/* We must not wait for the DRAIN to complete unless there are&n;&t;&t; * at least 8 bytes (2 ring entries) available to receive the&n;&t;&t; * data otherwise the DRAIN will never complete and we&squot;ll&n;&t;&t; * deadlock here.&n;&t;&t; * In fact, to make things easier, I&squot;ll just ignore the flush if&n;&t;&t; * there is any data at all now available.&n;&t;&t; */
r_if
c_cond
(paren
id|prod_ptr
op_eq
id|cons_ptr
)paren
(brace
id|loop_counter
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
op_amp
id|IOC4_SSCR_RX_DRAIN
)paren
(brace
id|loop_counter
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|loop_counter
OG
id|MAXITER
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* SIGH. We have to reload the prod_ptr *again* since&n;&t;&t;&t; * the drain may have caused it to change&n;&t;&t;&t; */
id|prod_ptr
op_assign
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;srpir
)paren
op_amp
id|PROD_CONS_MASK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reset_dma
)paren
(brace
id|port-&gt;ip_sscr
op_and_assign
op_complement
id|IOC4_SSCR_DMA_EN
suffix:semicolon
id|writel
c_func
(paren
id|port-&gt;ip_sscr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;sscr
)paren
suffix:semicolon
)brace
)brace
id|inring
op_assign
id|port-&gt;ip_inring
suffix:semicolon
id|port-&gt;ip_flags
op_and_assign
op_complement
id|READ_ABORTED
suffix:semicolon
id|total
op_assign
l_int|0
suffix:semicolon
id|loop_counter
op_assign
l_int|0xfffff
suffix:semicolon
multiline_comment|/* to avoid hangs */
multiline_comment|/* Grab bytes from the hardware */
r_while
c_loop
(paren
(paren
id|prod_ptr
op_ne
id|cons_ptr
)paren
op_logical_and
(paren
id|len
OG
l_int|0
)paren
)paren
(brace
id|entry
op_assign
(paren
r_struct
id|ring_entry
op_star
)paren
(paren
(paren
id|caddr_t
)paren
id|inring
op_plus
id|cons_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|loop_counter
op_decrement
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;IOC4 serial: &quot;
l_string|&quot;possible hang condition/&quot;
l_string|&quot;port stuck on read.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* According to the producer pointer, this ring entry&n;&t;&t; * must contain some data.  But if the PIO happened faster&n;&t;&t; * than the DMA, the data may not be available yet, so let&squot;s&n;&t;&t; * wait until it arrives.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|entry-&gt;ring_allsc
op_amp
id|RING_ANY_VALID
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Indicate the read is aborted so we don&squot;t disable&n;&t;&t;&t; * the interrupt thinking that the consumer is&n;&t;&t;&t; * congested.&n;&t;&t;&t; */
id|port-&gt;ip_flags
op_or_assign
id|READ_ABORTED
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Load the bytes/status out of the ring entry */
r_for
c_loop
(paren
id|byte_num
op_assign
l_int|0
suffix:semicolon
id|byte_num
template_param
l_int|0
suffix:semicolon
id|byte_num
op_increment
)paren
(brace
id|sc
op_assign
op_amp
(paren
id|entry-&gt;ring_sc
(braket
id|byte_num
)braket
)paren
suffix:semicolon
multiline_comment|/* Check for change in modem state or overrun */
r_if
c_cond
(paren
(paren
op_star
id|sc
op_amp
id|IOC4_RXSB_MODEM_VALID
)paren
op_logical_and
(paren
id|port-&gt;ip_notify
op_amp
id|N_DDCD
)paren
)paren
(brace
multiline_comment|/* Notify upper layer if DCD dropped */
r_if
c_cond
(paren
(paren
id|port-&gt;ip_flags
op_amp
id|DCD_ON
)paren
op_logical_and
op_logical_neg
(paren
op_star
id|sc
op_amp
id|IOC4_RXSB_DCD
)paren
)paren
(brace
multiline_comment|/* If we have already copied some data,&n;&t;&t;&t;&t;&t; * return it.  We&squot;ll pick up the carrier&n;&t;&t;&t;&t;&t; * drop on the next pass.  That way we&n;&t;&t;&t;&t;&t; * don&squot;t throw away the data that has&n;&t;&t;&t;&t;&t; * already been copied back to&n;&t;&t;&t;&t;&t; * the caller&squot;s buffer.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|total
OG
l_int|0
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|port-&gt;ip_flags
op_and_assign
op_complement
id|DCD_ON
suffix:semicolon
multiline_comment|/* Turn off this notification so the&n;&t;&t;&t;&t;&t; * carrier drop protocol won&squot;t see it&n;&t;&t;&t;&t;&t; * again when it does a read.&n;&t;&t;&t;&t;&t; */
op_star
id|sc
op_and_assign
op_complement
id|IOC4_RXSB_MODEM_VALID
suffix:semicolon
multiline_comment|/* To keep things consistent, we need&n;&t;&t;&t;&t;&t; * to update the consumer pointer so&n;&t;&t;&t;&t;&t; * the next reader won&squot;t come in and&n;&t;&t;&t;&t;&t; * try to read the same ring entries&n;&t;&t;&t;&t;&t; * again. This must be done here before&n;&t;&t;&t;&t;&t; * the dcd change.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|entry-&gt;ring_allsc
op_amp
id|RING_ANY_VALID
)paren
op_eq
l_int|0
)paren
(brace
id|cons_ptr
op_add_assign
(paren
r_int
)paren
r_sizeof
(paren
r_struct
id|ring_entry
)paren
suffix:semicolon
id|cons_ptr
op_and_assign
id|PROD_CONS_MASK
suffix:semicolon
)brace
id|writel
c_func
(paren
id|cons_ptr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;srcir
)paren
suffix:semicolon
id|port-&gt;ip_rx_cons
op_assign
id|cons_ptr
suffix:semicolon
multiline_comment|/* Notify upper layer of carrier drop */
r_if
c_cond
(paren
(paren
id|port-&gt;ip_notify
op_amp
id|N_DDCD
)paren
op_logical_and
id|port-&gt;ip_port
)paren
(brace
id|the_port-&gt;icount.dcd
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|the_port-&gt;info
op_member_access_from_pointer
id|delta_msr_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* If we had any data to return, we&n;&t;&t;&t;&t;&t; * would have returned it above.&n;&t;&t;&t;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_star
id|sc
op_amp
id|IOC4_RXSB_MODEM_VALID
)paren
(brace
multiline_comment|/* Notify that an input overrun occurred */
r_if
c_cond
(paren
(paren
op_star
id|sc
op_amp
id|IOC4_RXSB_OVERRUN
)paren
op_logical_and
(paren
id|port-&gt;ip_notify
op_amp
id|N_OVERRUN_ERROR
)paren
)paren
(brace
id|ioc4_cb_post_ncs
c_func
(paren
id|the_port
comma
id|NCS_OVERRUN
)paren
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t look at this byte again */
op_star
id|sc
op_and_assign
op_complement
id|IOC4_RXSB_MODEM_VALID
suffix:semicolon
)brace
multiline_comment|/* Check for valid data or RX errors */
r_if
c_cond
(paren
(paren
op_star
id|sc
op_amp
id|IOC4_RXSB_DATA_VALID
)paren
op_logical_and
(paren
(paren
op_star
id|sc
op_amp
(paren
id|IOC4_RXSB_PAR_ERR
op_or
id|IOC4_RXSB_FRAME_ERR
op_or
id|IOC4_RXSB_BREAK
)paren
)paren
op_logical_and
(paren
id|port-&gt;ip_notify
op_amp
(paren
id|N_PARITY_ERROR
op_or
id|N_FRAMING_ERROR
op_or
id|N_BREAK
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* There is an error condition on the next byte.&n;&t;&t;&t;&t; * If we have already transferred some bytes,&n;&t;&t;&t;&t; * we&squot;ll stop here. Otherwise if this is the&n;&t;&t;&t;&t; * first byte to be read, we&squot;ll just transfer&n;&t;&t;&t;&t; * it alone after notifying the&n;&t;&t;&t;&t; * upper layer of its status.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|total
OG
l_int|0
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
op_star
id|sc
op_amp
id|IOC4_RXSB_PAR_ERR
)paren
op_logical_and
(paren
id|port-&gt;ip_notify
op_amp
id|N_PARITY_ERROR
)paren
)paren
(brace
id|ioc4_cb_post_ncs
c_func
(paren
id|the_port
comma
id|NCS_PARITY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|sc
op_amp
id|IOC4_RXSB_FRAME_ERR
)paren
op_logical_and
(paren
id|port-&gt;ip_notify
op_amp
id|N_FRAMING_ERROR
)paren
)paren
(brace
id|ioc4_cb_post_ncs
c_func
(paren
id|the_port
comma
id|NCS_FRAMING
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|sc
op_amp
id|IOC4_RXSB_BREAK
)paren
op_logical_and
(paren
id|port-&gt;ip_notify
op_amp
id|N_BREAK
)paren
)paren
(brace
id|ioc4_cb_post_ncs
(paren
id|the_port
comma
id|NCS_BREAK
)paren
suffix:semicolon
)brace
id|len
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_star
id|sc
op_amp
id|IOC4_RXSB_DATA_VALID
)paren
(brace
op_star
id|sc
op_and_assign
op_complement
id|IOC4_RXSB_DATA_VALID
suffix:semicolon
op_star
id|buf
op_assign
id|entry-&gt;ring_data
(braket
id|byte_num
)braket
suffix:semicolon
id|buf
op_increment
suffix:semicolon
id|len
op_decrement
suffix:semicolon
id|total
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* If we used up this entry entirely, go on to the next one,&n;&t;&t; * otherwise we must have run out of buffer space, so&n;&t;&t; * leave the consumer pointer here for the next read in case&n;&t;&t; * there are still unread bytes in this entry.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|entry-&gt;ring_allsc
op_amp
id|RING_ANY_VALID
)paren
op_eq
l_int|0
)paren
(brace
id|cons_ptr
op_add_assign
(paren
r_int
)paren
r_sizeof
(paren
r_struct
id|ring_entry
)paren
suffix:semicolon
id|cons_ptr
op_and_assign
id|PROD_CONS_MASK
suffix:semicolon
)brace
)brace
multiline_comment|/* Update consumer pointer and re-arm rx timer interrupt */
id|writel
c_func
(paren
id|cons_ptr
comma
op_amp
id|port-&gt;ip_serial_regs-&gt;srcir
)paren
suffix:semicolon
id|port-&gt;ip_rx_cons
op_assign
id|cons_ptr
suffix:semicolon
multiline_comment|/* If we have now dipped below the rx high water mark and we have&n;&t; * rx_high interrupt turned off, we can now turn it back on again.&n;&t; */
r_if
c_cond
(paren
(paren
id|port-&gt;ip_flags
op_amp
id|INPUT_HIGH
)paren
op_logical_and
(paren
(paren
(paren
id|prod_ptr
op_minus
id|cons_ptr
)paren
op_amp
id|PROD_CONS_MASK
)paren
OL
(paren
(paren
id|port-&gt;ip_sscr
op_amp
id|IOC4_SSCR_RX_THRESHOLD
)paren
op_lshift
id|IOC4_PROD_CONS_PTR_OFF
)paren
)paren
)paren
(brace
id|port-&gt;ip_flags
op_and_assign
op_complement
id|INPUT_HIGH
suffix:semicolon
id|enable_intrs
c_func
(paren
id|port
comma
id|hooks-&gt;intr_rx_high
)paren
suffix:semicolon
)brace
r_return
id|total
suffix:semicolon
)brace
multiline_comment|/**&n; * receive_chars - upper level read. Called with ip_lock.&n; * @the_port: port to read from&n; */
DECL|function|receive_chars
r_static
r_void
id|receive_chars
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
r_char
id|ch
(braket
id|IOC4_MAX_CHARS
)braket
suffix:semicolon
r_int
id|read_count
comma
id|request_count
suffix:semicolon
r_struct
id|uart_icount
op_star
id|icount
suffix:semicolon
r_struct
id|uart_info
op_star
id|info
op_assign
id|the_port-&gt;info
suffix:semicolon
multiline_comment|/* Make sure all the pointers are &quot;good&quot; ones */
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
)paren
r_return
suffix:semicolon
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
id|request_count
op_assign
id|TTY_FLIPBUF_SIZE
op_minus
id|tty-&gt;flip.count
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|request_count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|request_count
OG
id|IOC4_MAX_CHARS
op_minus
l_int|2
)paren
id|request_count
op_assign
id|IOC4_MAX_CHARS
op_minus
l_int|2
suffix:semicolon
id|icount
op_assign
op_amp
id|the_port-&gt;icount
suffix:semicolon
id|read_count
op_assign
id|do_read
c_func
(paren
id|the_port
comma
id|ch
comma
id|request_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_count
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|tty-&gt;flip.char_buf_ptr
comma
id|ch
comma
id|read_count
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tty-&gt;flip.flag_buf_ptr
comma
id|TTY_NORMAL
comma
id|read_count
)paren
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_add_assign
id|read_count
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_add_assign
id|read_count
suffix:semicolon
id|tty-&gt;flip.count
op_add_assign
id|read_count
suffix:semicolon
id|icount-&gt;rx
op_add_assign
id|read_count
suffix:semicolon
)brace
)brace
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ic4_type - What type of console are we?&n; * @port: Port to operate with (we ignore since we only have one port)&n; *&n; */
DECL|function|ic4_type
r_static
r_const
r_char
op_star
id|ic4_type
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
)paren
(brace
r_return
l_string|&quot;SGI IOC4 Serial&quot;
suffix:semicolon
)brace
multiline_comment|/**&n; * ic4_tx_empty - Is the transmitter empty?  We pretend we&squot;re always empty&n; * @port: Port to operate on (we ignore since we always return 1)&n; *&n; */
DECL|function|ic4_tx_empty
r_static
r_int
r_int
id|ic4_tx_empty
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * ic4_stop_tx - stop the transmitter&n; * @port: Port to operate on&n; * @tty_stop: Set to 1 if called via uart_stop&n; *&n; */
DECL|function|ic4_stop_tx
r_static
r_void
id|ic4_stop_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
comma
r_int
r_int
id|tty_stop
)paren
(brace
)brace
multiline_comment|/**&n; * null_void_function -&n; * @port: Port to operate on&n; *&n; */
DECL|function|null_void_function
r_static
r_void
id|null_void_function
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
)paren
(brace
)brace
multiline_comment|/**&n; * ic4_shutdown - shut down the port - free irq and disable&n; * @port: Port to shut down&n; *&n; */
DECL|function|ic4_shutdown
r_static
r_void
id|ic4_shutdown
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
)paren
(brace
r_int
r_int
id|port_flags
suffix:semicolon
r_struct
id|ioc4_port
op_star
id|port
suffix:semicolon
r_struct
id|uart_info
op_star
id|info
suffix:semicolon
id|port
op_assign
id|get_ioc4_port
c_func
(paren
id|the_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
id|info
op_assign
id|the_port-&gt;info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|UIF_INITIALIZED
)paren
)paren
r_return
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;delta_msr_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;ip_lock
comma
id|port_flags
)paren
suffix:semicolon
id|set_notification
c_func
(paren
id|port
comma
id|N_ALL
comma
l_int|0
)paren
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
id|UIF_INITIALIZED
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;ip_lock
comma
id|port_flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ic4_set_mctrl - set control lines (dtr, rts, etc)&n; * @port: Port to operate on&n; * @mctrl: Lines to set/unset&n; *&n; */
DECL|function|ic4_set_mctrl
r_static
r_void
id|ic4_set_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
comma
r_int
r_int
id|mctrl
)paren
(brace
r_int
r_char
id|mcr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_RTS
)paren
id|mcr
op_or_assign
id|UART_MCR_RTS
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_DTR
)paren
id|mcr
op_or_assign
id|UART_MCR_DTR
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_OUT1
)paren
id|mcr
op_or_assign
id|UART_MCR_OUT1
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_OUT2
)paren
id|mcr
op_or_assign
id|UART_MCR_OUT2
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_LOOP
)paren
id|mcr
op_or_assign
id|UART_MCR_LOOP
suffix:semicolon
id|set_mcr
c_func
(paren
id|the_port
comma
l_int|1
comma
id|mcr
comma
id|IOC4_SHADOW_DTR
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ic4_get_mctrl - get control line info&n; * @port: port to operate on&n; *&n; */
DECL|function|ic4_get_mctrl
r_static
r_int
r_int
id|ic4_get_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
)paren
(brace
r_struct
id|ioc4_port
op_star
id|port
op_assign
id|get_ioc4_port
c_func
(paren
id|the_port
)paren
suffix:semicolon
r_uint32
id|shadow
suffix:semicolon
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
l_int|0
suffix:semicolon
id|shadow
op_assign
id|readl
c_func
(paren
op_amp
id|port-&gt;ip_serial_regs-&gt;shadow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shadow
op_amp
id|IOC4_SHADOW_DCD
)paren
id|ret
op_or_assign
id|TIOCM_CAR
suffix:semicolon
r_if
c_cond
(paren
id|shadow
op_amp
id|IOC4_SHADOW_DR
)paren
id|ret
op_or_assign
id|TIOCM_DSR
suffix:semicolon
r_if
c_cond
(paren
id|shadow
op_amp
id|IOC4_SHADOW_CTS
)paren
id|ret
op_or_assign
id|TIOCM_CTS
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * ic4_start_tx - Start transmitter, flush any output&n; * @port: Port to operate on&n; * @tty_stop: Set to 1 if called via uart_start&n; *&n; */
DECL|function|ic4_start_tx
r_static
r_void
id|ic4_start_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
comma
r_int
r_int
id|tty_stop
)paren
(brace
r_struct
id|ioc4_port
op_star
id|port
op_assign
id|get_ioc4_port
c_func
(paren
id|the_port
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|port
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;ip_lock
comma
id|flags
)paren
suffix:semicolon
id|transmit_chars
c_func
(paren
id|the_port
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;ip_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * ic4_break_ctl - handle breaks&n; * @port: Port to operate on&n; * @break_state: Break state&n; *&n; */
DECL|function|ic4_break_ctl
r_static
r_void
id|ic4_break_ctl
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
comma
r_int
id|break_state
)paren
(brace
)brace
multiline_comment|/**&n; * ic4_startup - Start up the serial port - always return 0 (We&squot;re always on)&n; * @port: Port to operate on&n; *&n; */
DECL|function|ic4_startup
r_static
r_int
id|ic4_startup
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|ioc4_port
op_star
id|port
suffix:semicolon
r_struct
id|ioc4_control
op_star
id|control
suffix:semicolon
r_struct
id|uart_info
op_star
id|info
suffix:semicolon
r_int
r_int
id|port_flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|the_port
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|port
op_assign
id|get_ioc4_port
c_func
(paren
id|the_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|info
op_assign
id|the_port-&gt;info
suffix:semicolon
id|control
op_assign
id|port-&gt;ip_control
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|control
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Start up the serial port */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;ip_lock
comma
id|port_flags
)paren
suffix:semicolon
id|retval
op_assign
id|ic4_startup_local
c_func
(paren
id|the_port
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;ip_lock
comma
id|port_flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * ic4_set_termios - set termios stuff&n; * @port: port to operate on&n; * @termios: New settings&n; * @termios: Old&n; *&n; */
r_static
r_void
DECL|function|ic4_set_termios
id|ic4_set_termios
c_func
(paren
r_struct
id|uart_port
op_star
id|the_port
comma
r_struct
id|termios
op_star
id|termios
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|ioc4_port
op_star
id|port
op_assign
id|get_ioc4_port
c_func
(paren
id|the_port
)paren
suffix:semicolon
r_int
r_int
id|port_flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;ip_lock
comma
id|port_flags
)paren
suffix:semicolon
id|ioc4_change_speed
c_func
(paren
id|the_port
comma
id|termios
comma
id|old_termios
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;ip_lock
comma
id|port_flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ic4_request_port - allocate resources for port - no op....&n; * @port: port to operate on&n; *&n; */
DECL|function|ic4_request_port
r_static
r_int
id|ic4_request_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Associate the uart functions above - given to serial core */
DECL|variable|ioc4_ops
r_static
r_struct
id|uart_ops
id|ioc4_ops
op_assign
(brace
dot
id|tx_empty
op_assign
id|ic4_tx_empty
comma
dot
id|set_mctrl
op_assign
id|ic4_set_mctrl
comma
dot
id|get_mctrl
op_assign
id|ic4_get_mctrl
comma
dot
id|stop_tx
op_assign
id|ic4_stop_tx
comma
dot
id|start_tx
op_assign
id|ic4_start_tx
comma
dot
id|stop_rx
op_assign
id|null_void_function
comma
dot
id|enable_ms
op_assign
id|null_void_function
comma
dot
id|break_ctl
op_assign
id|ic4_break_ctl
comma
dot
id|startup
op_assign
id|ic4_startup
comma
dot
id|shutdown
op_assign
id|ic4_shutdown
comma
dot
id|set_termios
op_assign
id|ic4_set_termios
comma
dot
id|type
op_assign
id|ic4_type
comma
dot
id|release_port
op_assign
id|null_void_function
comma
dot
id|request_port
op_assign
id|ic4_request_port
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Boot-time initialization code&n; */
DECL|variable|ioc4_uart
r_static
r_struct
id|uart_driver
id|ioc4_uart
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|driver_name
op_assign
l_string|&quot;ioc4_serial&quot;
comma
dot
id|dev_name
op_assign
id|DEVICE_NAME
comma
dot
id|major
op_assign
id|DEVICE_MAJOR
comma
dot
id|minor
op_assign
id|DEVICE_MINOR
comma
dot
id|nr
op_assign
id|IOC4_NUM_CARDS
op_star
id|IOC4_NUM_SERIAL_PORTS
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * ioc4_serial_core_attach - register with serial core&n; *&t;&t;This is done during pci probing&n; * @pdev: handle for this card&n; */
r_static
r_inline
r_int
DECL|function|ioc4_serial_core_attach
id|ioc4_serial_core_attach
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|ioc4_port
op_star
id|port
suffix:semicolon
r_struct
id|uart_port
op_star
id|the_port
suffix:semicolon
r_struct
id|ioc4_control
op_star
id|control
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_int
id|ii
suffix:semicolon
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot;%s: attach pdev 0x%p - control 0x%p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|pdev
comma
(paren
r_void
op_star
)paren
id|control
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|control
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* once around for each port on this card */
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
OL
id|IOC4_NUM_SERIAL_PORTS
suffix:semicolon
id|ii
op_increment
)paren
(brace
id|the_port
op_assign
op_amp
id|control-&gt;ic_port
(braket
id|ii
)braket
dot
id|icp_uart_port
suffix:semicolon
id|port
op_assign
id|control-&gt;ic_port
(braket
id|ii
)braket
dot
id|icp_port
suffix:semicolon
id|port-&gt;ip_port
op_assign
id|the_port
suffix:semicolon
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot;%s: attach the_port 0x%p / port 0x%p&bslash;n&quot;
comma
id|__FUNCTION__
comma
(paren
r_void
op_star
)paren
id|the_port
comma
(paren
r_void
op_star
)paren
id|port
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|the_port-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* membase, iobase and mapbase just need to be non-0 */
id|the_port-&gt;membase
op_assign
(paren
r_int
r_char
id|__iomem
op_star
)paren
l_int|1
suffix:semicolon
id|the_port-&gt;line
op_assign
id|the_port-&gt;iobase
op_assign
id|ii
suffix:semicolon
id|the_port-&gt;mapbase
op_assign
l_int|1
suffix:semicolon
id|the_port-&gt;type
op_assign
id|PORT_16550A
suffix:semicolon
id|the_port-&gt;fifosize
op_assign
id|IOC4_MAX_CHARS
suffix:semicolon
id|the_port-&gt;ops
op_assign
op_amp
id|ioc4_ops
suffix:semicolon
id|the_port-&gt;irq
op_assign
id|control-&gt;ic_irq
suffix:semicolon
id|the_port-&gt;dev
op_assign
op_amp
id|pdev-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|uart_add_one_port
c_func
(paren
op_amp
id|ioc4_uart
comma
id|the_port
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: unable to add port %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|the_port-&gt;line
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot;IOC4 serial driver port %d irq = %d&bslash;n&quot;
comma
id|the_port-&gt;line
comma
id|the_port-&gt;irq
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* all ports are rs232 for now */
id|ioc4_set_proto
c_func
(paren
id|port
comma
id|PROTO_RS232
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ioc4_serial_attach_one - register attach function&n; *&t;&t;called per card found from ioc4_serial_detect as part&n; *&t;&t;of module_init().&n; * @pdev: handle for this card&n; * @pci_id: pci id for this card&n; */
r_int
DECL|function|ioc4_serial_attach_one
id|ioc4_serial_attach_one
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|pci_id
)paren
(brace
r_struct
id|ioc4_mem
id|__iomem
op_star
id|mem
suffix:semicolon
r_int
r_int
id|tmp_addr
comma
id|tmp_addr1
suffix:semicolon
r_struct
id|ioc4_serial
id|__iomem
op_star
id|serial
suffix:semicolon
r_struct
id|ioc4_soft
op_star
id|soft
suffix:semicolon
r_struct
id|ioc4_control
op_star
id|control
suffix:semicolon
r_int
id|tmp
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot;%s (0x%p, 0x%p)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|pdev
comma
id|pci_id
)paren
)paren
suffix:semicolon
multiline_comment|/* Map in the ioc4 memory */
id|tmp_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_addr
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ioc4 (%p) : unable to get PIO mapping for &quot;
l_string|&quot;MEM space&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|pdev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|tmp_addr
comma
r_sizeof
(paren
r_struct
id|ioc4_mem
)paren
comma
l_string|&quot;sioc4_mem&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;ioc4 (%p): unable to get request region for &quot;
l_string|&quot;MEM space&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|pdev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|mem
op_assign
id|ioremap
c_func
(paren
id|tmp_addr
comma
r_sizeof
(paren
r_struct
id|ioc4_mem
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ioc4 (%p) : unable to remap ioc4 memory&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|pdev
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out1
suffix:semicolon
)brace
multiline_comment|/* request serial registers */
id|tmp_addr1
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
op_plus
id|IOC4_SERIAL_OFFSET
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|tmp_addr1
comma
r_sizeof
(paren
r_struct
id|ioc4_serial
)paren
comma
l_string|&quot;sioc4_uart&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ioc4 (%p): unable to get request region for &quot;
l_string|&quot;uart space&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|pdev
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out1
suffix:semicolon
)brace
id|serial
op_assign
id|ioremap
c_func
(paren
id|tmp_addr1
comma
r_sizeof
(paren
r_struct
id|ioc4_serial
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ioc4 (%p) : unable to remap ioc4 serial register&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|pdev
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out2
suffix:semicolon
)brace
id|DPRINT_CONFIG
c_func
(paren
(paren
l_string|&quot;%s : mem 0x%p, serial 0x%p&bslash;n&quot;
comma
id|__FUNCTION__
comma
(paren
r_void
op_star
)paren
id|mem
comma
(paren
r_void
op_star
)paren
id|serial
)paren
)paren
suffix:semicolon
multiline_comment|/* Get memory for the new card */
id|control
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ioc4_control
)paren
op_star
id|IOC4_NUM_SERIAL_PORTS
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|control
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ioc4_attach_one&quot;
l_string|&quot;: unable to get memory for the IOC4&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out2
suffix:semicolon
)brace
id|memset
c_func
(paren
id|control
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ioc4_control
)paren
)paren
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
id|control
)paren
suffix:semicolon
multiline_comment|/* Allocate the soft structure */
id|soft
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ioc4_soft
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|soft
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ioc4 (%p): unable to get memory for the soft struct&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|pdev
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out3
suffix:semicolon
)brace
id|memset
c_func
(paren
id|soft
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ioc4_soft
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|soft-&gt;is_ir_lock
)paren
suffix:semicolon
id|soft-&gt;is_ioc4_mem_addr
op_assign
id|mem
suffix:semicolon
id|soft-&gt;is_ioc4_serial_addr
op_assign
id|serial
suffix:semicolon
multiline_comment|/* Init the IOC4 */
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|tmp
op_or
id|PCI_COMMAND_PARITY
op_or
id|PCI_COMMAND_SERR
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0xf
op_lshift
id|IOC4_SIO_CR_CMD_PULSE_SHIFT
comma
op_amp
id|mem-&gt;sio_cr
)paren
suffix:semicolon
multiline_comment|/* Enable serial port mode select generic PIO pins as outputs */
id|writel
c_func
(paren
id|IOC4_GPCR_UART0_MODESEL
op_or
id|IOC4_GPCR_UART1_MODESEL
op_or
id|IOC4_GPCR_UART2_MODESEL
op_or
id|IOC4_GPCR_UART3_MODESEL
comma
op_amp
id|mem-&gt;gpcr_s
)paren
suffix:semicolon
multiline_comment|/* Clear and disable all interrupts */
id|write_ireg
c_func
(paren
id|soft
comma
op_complement
l_int|0
comma
id|IOC4_W_IEC
comma
id|IOC4_SIO_INTR_TYPE
)paren
suffix:semicolon
id|writel
c_func
(paren
op_complement
l_int|0
comma
op_amp
id|mem-&gt;sio_ir
)paren
suffix:semicolon
id|write_ireg
c_func
(paren
id|soft
comma
op_complement
(paren
id|IOC4_OTHER_IR_ATA_INT
op_or
id|IOC4_OTHER_IR_ATA_MEMERR
)paren
comma
id|IOC4_W_IEC
comma
id|IOC4_OTHER_INTR_TYPE
)paren
suffix:semicolon
id|writel
c_func
(paren
op_complement
(paren
id|IOC4_OTHER_IR_ATA_MEMERR
op_or
id|IOC4_OTHER_IR_ATA_MEMERR
)paren
comma
op_amp
id|mem-&gt;other_ir
)paren
suffix:semicolon
id|control-&gt;ic_soft
op_assign
id|soft
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_irq
c_func
(paren
id|pdev-&gt;irq
comma
id|ioc4_intr
comma
id|SA_SHIRQ
comma
l_string|&quot;sgi-ioc4serial&quot;
comma
(paren
r_void
op_star
)paren
id|soft
)paren
)paren
(brace
id|control-&gt;ic_irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s : request_irq fails for IRQ 0x%x&bslash;n &quot;
comma
id|__FUNCTION__
comma
id|pdev-&gt;irq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|ioc4_attach_local
c_func
(paren
id|pdev
comma
id|control
comma
id|soft
comma
id|soft-&gt;is_ioc4_mem_addr
comma
id|soft-&gt;is_ioc4_serial_addr
)paren
)paren
)paren
r_goto
id|out4
suffix:semicolon
multiline_comment|/* register port with the serial core */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|ioc4_serial_core_attach
c_func
(paren
id|pdev
)paren
)paren
)paren
r_goto
id|out4
suffix:semicolon
r_return
id|ret
suffix:semicolon
multiline_comment|/* error exits that give back resources */
id|out4
suffix:colon
id|kfree
c_func
(paren
id|soft
)paren
suffix:semicolon
id|out3
suffix:colon
id|kfree
c_func
(paren
id|control
)paren
suffix:semicolon
id|out2
suffix:colon
id|release_region
c_func
(paren
id|tmp_addr1
comma
r_sizeof
(paren
r_struct
id|ioc4_serial
)paren
)paren
suffix:semicolon
id|out1
suffix:colon
id|release_region
c_func
(paren
id|tmp_addr
comma
r_sizeof
(paren
r_struct
id|ioc4_mem
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * ioc4_serial_remove_one - detach function&n; *&n; * @pdev: handle for this card&n; */
macro_line|#if 0
r_void
id|ioc4_serial_remove_one
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_int
id|ii
suffix:semicolon
r_struct
id|ioc4_control
op_star
id|control
suffix:semicolon
r_struct
id|uart_port
op_star
id|the_port
suffix:semicolon
r_struct
id|ioc4_port
op_star
id|port
suffix:semicolon
r_struct
id|ioc4_soft
op_star
id|soft
suffix:semicolon
id|control
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
OL
id|IOC4_NUM_SERIAL_PORTS
suffix:semicolon
id|ii
op_increment
)paren
(brace
id|the_port
op_assign
op_amp
id|control-&gt;ic_port
(braket
id|ii
)braket
dot
id|icp_uart_port
suffix:semicolon
r_if
c_cond
(paren
id|the_port
)paren
(brace
id|uart_remove_one_port
c_func
(paren
op_amp
id|ioc4_uart
comma
id|the_port
)paren
suffix:semicolon
)brace
id|port
op_assign
id|control-&gt;ic_port
(braket
id|ii
)braket
dot
id|icp_port
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ii
op_amp
l_int|1
)paren
op_logical_and
id|port
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|port-&gt;ip_pdev
comma
id|TOTAL_RING_BUF_SIZE
comma
(paren
r_void
op_star
)paren
id|port-&gt;ip_cpu_ringbuf
comma
id|port-&gt;ip_dma_ringbuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
)brace
id|soft
op_assign
id|control-&gt;ic_soft
suffix:semicolon
r_if
c_cond
(paren
id|soft
)paren
(brace
id|free_irq
c_func
(paren
id|control-&gt;ic_irq
comma
(paren
r_void
op_star
)paren
id|soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|soft-&gt;is_ioc4_serial_addr
)paren
(brace
id|release_region
c_func
(paren
(paren
r_int
r_int
)paren
id|soft-&gt;is_ioc4_serial_addr
comma
r_sizeof
(paren
r_struct
id|ioc4_serial
)paren
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|soft
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|control
)paren
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
l_int|NULL
)paren
suffix:semicolon
id|uart_unregister_driver
c_func
(paren
op_amp
id|ioc4_uart
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * ioc4_serial_init - module init&n; */
DECL|function|ioc4_serial_init
r_int
id|ioc4_serial_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* register with serial core */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|uart_register_driver
c_func
(paren
op_amp
id|ioc4_uart
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Couldn&squot;t register IOC4 serial driver&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Pat Gefre - Silicon Graphics Inc. (SGI) &lt;pfg@sgi.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Serial PCI driver module for SGI IOC4 Base-IO Card&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|ioc4_serial_init
id|EXPORT_SYMBOL
c_func
(paren
id|ioc4_serial_init
)paren
suffix:semicolon
DECL|variable|ioc4_serial_attach_one
id|EXPORT_SYMBOL
c_func
(paren
id|ioc4_serial_attach_one
)paren
suffix:semicolon
eof
