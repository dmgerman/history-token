multiline_comment|/*&n; * C-Brick Serial Port (and console) driver for SGI Altix machines.&n; *&n; * This driver is NOT suitable for talking to the l1-controller for&n; * anything other than &squot;console activities&squot; --- please use the l1&n; * driver for that.&n; *&n; *&n; * Copyright (c) 2004 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License&n; * as published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public&n; * License along with this program; if not, write the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information:  Silicon Graphics, Inc., 1500 Crittenden Lane,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/NoticeExplan&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sysrq.h&gt;
macro_line|#include &lt;linux/circ_buf.h&gt;
macro_line|#include &lt;linux/serial_reg.h&gt;
macro_line|#include &lt;linux/delay.h&gt; /* for mdelay */
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/serial_core.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
multiline_comment|/* number of characters we can transmit to the SAL console at a time */
DECL|macro|SN_SAL_MAX_CHARS
mdefine_line|#define SN_SAL_MAX_CHARS 120
multiline_comment|/* 64K, when we&squot;re asynch, it must be at least printk&squot;s LOG_BUF_LEN to&n; * avoid losing chars, (always has to be a power of 2) */
DECL|macro|SN_SAL_BUFFER_SIZE
mdefine_line|#define SN_SAL_BUFFER_SIZE (64 * (1 &lt;&lt; 10))
DECL|macro|SN_SAL_UART_FIFO_DEPTH
mdefine_line|#define SN_SAL_UART_FIFO_DEPTH 16
DECL|macro|SN_SAL_UART_FIFO_SPEED_CPS
mdefine_line|#define SN_SAL_UART_FIFO_SPEED_CPS 9600/10
multiline_comment|/* sn_transmit_chars() calling args */
DECL|macro|TRANSMIT_BUFFERED
mdefine_line|#define TRANSMIT_BUFFERED&t;0
DECL|macro|TRANSMIT_RAW
mdefine_line|#define TRANSMIT_RAW&t;&t;1
multiline_comment|/* To use dynamic numbers only and not use the assigned major and minor,&n; * define the following.. */
multiline_comment|/* #define USE_DYNAMIC_MINOR 1 */
multiline_comment|/* use dynamic minor number */
DECL|macro|USE_DYNAMIC_MINOR
mdefine_line|#define USE_DYNAMIC_MINOR 0&t;/* Don&squot;t rely on misc_register dynamic minor */
multiline_comment|/* Device name we&squot;re using */
DECL|macro|DEVICE_NAME
mdefine_line|#define DEVICE_NAME &quot;ttySG&quot;
DECL|macro|DEVICE_NAME_DYNAMIC
mdefine_line|#define DEVICE_NAME_DYNAMIC &quot;ttySG0&quot;&t;/* need full name for misc_register */
multiline_comment|/* The major/minor we are using, ignored for USE_DYNAMIC_MINOR */
DECL|macro|DEVICE_MAJOR
mdefine_line|#define DEVICE_MAJOR 204
DECL|macro|DEVICE_MINOR
mdefine_line|#define DEVICE_MINOR 40
macro_line|#ifdef CONFIG_MAGIC_SYSRQ
DECL|variable|sysrq_serial_str
r_static
r_char
id|sysrq_serial_str
(braket
)braket
op_assign
l_string|&quot;&bslash;eSYS&quot;
suffix:semicolon
DECL|variable|sysrq_serial_ptr
r_static
r_char
op_star
id|sysrq_serial_ptr
op_assign
id|sysrq_serial_str
suffix:semicolon
DECL|variable|sysrq_requested
r_static
r_int
r_int
id|sysrq_requested
suffix:semicolon
macro_line|#endif /* CONFIG_MAGIC_SYSRQ */
multiline_comment|/*&n; * Port definition - this kinda drives it all&n; */
DECL|struct|sn_cons_port
r_struct
id|sn_cons_port
(brace
DECL|member|sc_timer
r_struct
id|timer_list
id|sc_timer
suffix:semicolon
DECL|member|sc_port
r_struct
id|uart_port
id|sc_port
suffix:semicolon
DECL|struct|sn_sal_ops
r_struct
id|sn_sal_ops
(brace
DECL|member|sal_puts_raw
r_int
(paren
op_star
id|sal_puts_raw
)paren
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|len
)paren
suffix:semicolon
DECL|member|sal_puts
r_int
(paren
op_star
id|sal_puts
)paren
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|len
)paren
suffix:semicolon
DECL|member|sal_getc
r_int
(paren
op_star
id|sal_getc
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|member|sal_input_pending
r_int
(paren
op_star
id|sal_input_pending
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|member|sal_wakeup_transmit
r_void
(paren
op_star
id|sal_wakeup_transmit
)paren
(paren
r_struct
id|sn_cons_port
op_star
comma
r_int
)paren
suffix:semicolon
DECL|member|sc_ops
)brace
op_star
id|sc_ops
suffix:semicolon
DECL|member|sc_interrupt_timeout
r_int
r_int
id|sc_interrupt_timeout
suffix:semicolon
DECL|member|sc_is_asynch
r_int
id|sc_is_asynch
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|sal_console_port
r_static
r_struct
id|sn_cons_port
id|sal_console_port
suffix:semicolon
multiline_comment|/* Only used if USE_DYNAMIC_MINOR is set to 1 */
DECL|variable|misc
r_static
r_struct
id|miscdevice
id|misc
suffix:semicolon
multiline_comment|/* used with misc_register for dynamic */
r_extern
r_void
id|early_sn_setup
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#ifdef DEBUG
r_static
r_int
id|sn_debug_printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
suffix:semicolon
DECL|macro|DPRINTF
mdefine_line|#define DPRINTF(x...) sn_debug_printf(x)
macro_line|#else
DECL|macro|DPRINTF
mdefine_line|#define DPRINTF(x...) do { } while (0)
macro_line|#endif
multiline_comment|/* Prototypes */
r_static
r_int
id|snt_hw_puts_raw
c_func
(paren
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|snt_hw_puts_buffered
c_func
(paren
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|snt_poll_getc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|snt_poll_input_pending
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|snt_intr_getc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|snt_intr_input_pending
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|sn_transmit_chars
c_func
(paren
r_struct
id|sn_cons_port
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* A table for polling:&n; */
DECL|variable|poll_ops
r_static
r_struct
id|sn_sal_ops
id|poll_ops
op_assign
(brace
dot
id|sal_puts_raw
op_assign
id|snt_hw_puts_raw
comma
dot
id|sal_puts
op_assign
id|snt_hw_puts_raw
comma
dot
id|sal_getc
op_assign
id|snt_poll_getc
comma
dot
id|sal_input_pending
op_assign
id|snt_poll_input_pending
)brace
suffix:semicolon
multiline_comment|/* A table for interrupts enabled */
DECL|variable|intr_ops
r_static
r_struct
id|sn_sal_ops
id|intr_ops
op_assign
(brace
dot
id|sal_puts_raw
op_assign
id|snt_hw_puts_raw
comma
dot
id|sal_puts
op_assign
id|snt_hw_puts_buffered
comma
dot
id|sal_getc
op_assign
id|snt_intr_getc
comma
dot
id|sal_input_pending
op_assign
id|snt_intr_input_pending
comma
dot
id|sal_wakeup_transmit
op_assign
id|sn_transmit_chars
)brace
suffix:semicolon
multiline_comment|/* the console does output in two distinctly different ways:&n; * synchronous (raw) and asynchronous (buffered).  initally, early_printk&n; * does synchronous output.  any data written goes directly to the SAL&n; * to be output (incidentally, it is internally buffered by the SAL)&n; * after interrupts and timers are initialized and available for use,&n; * the console init code switches to asynchronous output.  this is&n; * also the earliest opportunity to begin polling for console input.&n; * after console initialization, console output and tty (serial port)&n; * output is buffered and sent to the SAL asynchronously (either by&n; * timer callback or by UART interrupt) */
multiline_comment|/* routines for running the console in polling mode */
multiline_comment|/**&n; * snt_poll_getc - Get a character from the console in polling mode&n; *&n; */
DECL|function|snt_poll_getc
r_static
r_int
id|snt_poll_getc
c_func
(paren
r_void
)paren
(brace
r_int
id|ch
suffix:semicolon
id|ia64_sn_console_getc
c_func
(paren
op_amp
id|ch
)paren
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
multiline_comment|/**&n; * snt_poll_input_pending - Check if any input is waiting - polling mode.&n; *&n; */
DECL|function|snt_poll_input_pending
r_static
r_int
id|snt_poll_input_pending
c_func
(paren
r_void
)paren
(brace
r_int
id|status
comma
id|input
suffix:semicolon
id|status
op_assign
id|ia64_sn_console_check
c_func
(paren
op_amp
id|input
)paren
suffix:semicolon
r_return
op_logical_neg
id|status
op_logical_and
id|input
suffix:semicolon
)brace
multiline_comment|/* routines for an interrupt driven console (normal) */
multiline_comment|/**&n; * snt_intr_getc - Get a character from the console, interrupt mode&n; *&n; */
DECL|function|snt_intr_getc
r_static
r_int
id|snt_intr_getc
c_func
(paren
r_void
)paren
(brace
r_return
id|ia64_sn_console_readc
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * snt_intr_input_pending - Check if input is pending, interrupt mode&n; *&n; */
DECL|function|snt_intr_input_pending
r_static
r_int
id|snt_intr_input_pending
c_func
(paren
r_void
)paren
(brace
r_return
id|ia64_sn_console_intr_status
c_func
(paren
)paren
op_amp
id|SAL_CONSOLE_INTR_RECV
suffix:semicolon
)brace
multiline_comment|/* these functions are polled and interrupt */
multiline_comment|/**&n; * snt_hw_puts_raw - Send raw string to the console, polled or interrupt mode&n; * @s: String&n; * @len: Length&n; *&n; */
DECL|function|snt_hw_puts_raw
r_static
r_int
id|snt_hw_puts_raw
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|len
)paren
(brace
multiline_comment|/* this will call the PROM and not return until this is done */
r_return
id|ia64_sn_console_putb
c_func
(paren
id|s
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * snt_hw_puts_buffered - Send string to console, polled or interrupt mode&n; * @s: String&n; * @len: Length&n; *&n; */
DECL|function|snt_hw_puts_buffered
r_static
r_int
id|snt_hw_puts_buffered
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|len
)paren
(brace
multiline_comment|/* queue data to the PROM */
r_return
id|ia64_sn_console_xmit_chars
c_func
(paren
(paren
r_char
op_star
)paren
id|s
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/* uart interface structs&n; * These functions are associated with the uart_port that the serial core&n; * infrastructure calls.&n; *&n; * Note: Due to how the console works, many routines are no-ops.&n; */
multiline_comment|/**&n; * snp_type - What type of console are we?&n; * @port: Port to operate with (we ignore since we only have one port)&n; *&n; */
DECL|function|snp_type
r_static
r_const
r_char
op_star
id|snp_type
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_return
(paren
l_string|&quot;SGI SN L1&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * snp_tx_empty - Is the transmitter empty?  We pretend we&squot;re always empty&n; * @port: Port to operate on (we ignore since we only have one port)&n; *&n; */
DECL|function|snp_tx_empty
r_static
r_int
r_int
id|snp_tx_empty
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * snp_stop_tx - stop the transmitter - no-op for us&n; * @port: Port to operat eon - we ignore - no-op function&n; * @tty_stop: Set to 1 if called via uart_stop&n; *&n; */
DECL|function|snp_stop_tx
r_static
r_void
id|snp_stop_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|tty_stop
)paren
(brace
)brace
multiline_comment|/**&n; * snp_release_port - Free i/o and resources for port - no-op for us&n; * @port: Port to operate on - we ignore - no-op function&n; *&n; */
DECL|function|snp_release_port
r_static
r_void
id|snp_release_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
)brace
multiline_comment|/**&n; * snp_enable_ms - Force modem status interrupts on - no-op for us&n; * @port: Port to operate on - we ignore - no-op function&n; *&n; */
DECL|function|snp_enable_ms
r_static
r_void
id|snp_enable_ms
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
)brace
multiline_comment|/**&n; * snp_shutdown - shut down the port - free irq and disable - no-op for us&n; * @port: Port to shut down - we ignore&n; *&n; */
DECL|function|snp_shutdown
r_static
r_void
id|snp_shutdown
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
)brace
multiline_comment|/**&n; * snp_set_mctrl - set control lines (dtr, rts, etc) - no-op for our console&n; * @port: Port to operate on - we ignore&n; * @mctrl: Lines to set/unset - we ignore&n; *&n; */
DECL|function|snp_set_mctrl
r_static
r_void
id|snp_set_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|mctrl
)paren
(brace
)brace
multiline_comment|/**&n; * snp_get_mctrl - get contorl line info, we just return a static value&n; * @port: port to operate on - we only have one port so we ignore this&n; *&n; */
DECL|function|snp_get_mctrl
r_static
r_int
r_int
id|snp_get_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_return
id|TIOCM_CAR
op_or
id|TIOCM_RNG
op_or
id|TIOCM_DSR
op_or
id|TIOCM_CTS
suffix:semicolon
)brace
multiline_comment|/**&n; * snp_stop_rx - Stop the receiver - we ignor ethis&n; * @port: Port to operate on - we ignore&n; *&n; */
DECL|function|snp_stop_rx
r_static
r_void
id|snp_stop_rx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
)brace
multiline_comment|/**&n; * snp_start_tx - Start transmitter&n; * @port: Port to operate on&n; * @tty_stop: Set to 1 if called via uart_start&n; *&n; */
DECL|function|snp_start_tx
r_static
r_void
id|snp_start_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|tty_stop
)paren
(brace
r_if
c_cond
(paren
id|sal_console_port.sc_ops-&gt;sal_wakeup_transmit
)paren
id|sal_console_port.sc_ops
op_member_access_from_pointer
id|sal_wakeup_transmit
c_func
(paren
op_amp
id|sal_console_port
comma
id|TRANSMIT_BUFFERED
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * snp_break_ctl - handle breaks - ignored by us&n; * @port: Port to operate on&n; * @break_state: Break state&n; *&n; */
DECL|function|snp_break_ctl
r_static
r_void
id|snp_break_ctl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
id|break_state
)paren
(brace
)brace
multiline_comment|/**&n; * snp_startup - Start up the serial port - always return 0 (We&squot;re always on)&n; * @port: Port to operate on&n; *&n; */
DECL|function|snp_startup
r_static
r_int
id|snp_startup
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * snp_set_termios - set termios stuff - we ignore these&n; * @port: port to operate on&n; * @termios: New settings&n; * @termios: Old&n; *&n; */
r_static
r_void
DECL|function|snp_set_termios
id|snp_set_termios
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|termios
op_star
id|termios
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
)brace
multiline_comment|/**&n; * snp_request_port - allocate resources for port - ignored by us&n; * @port: port to operate on&n; *&n; */
DECL|function|snp_request_port
r_static
r_int
id|snp_request_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * snp_config_port - allocate resources, set up - we ignore,  we&squot;re always on&n; * @port: Port to operate on&n; * @flags: flags used for port setup&n; *&n; */
DECL|function|snp_config_port
r_static
r_void
id|snp_config_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
id|flags
)paren
(brace
)brace
multiline_comment|/* Associate the uart functions above - given to serial core */
DECL|variable|sn_console_ops
r_static
r_struct
id|uart_ops
id|sn_console_ops
op_assign
(brace
dot
id|tx_empty
op_assign
id|snp_tx_empty
comma
dot
id|set_mctrl
op_assign
id|snp_set_mctrl
comma
dot
id|get_mctrl
op_assign
id|snp_get_mctrl
comma
dot
id|stop_tx
op_assign
id|snp_stop_tx
comma
dot
id|start_tx
op_assign
id|snp_start_tx
comma
dot
id|stop_rx
op_assign
id|snp_stop_rx
comma
dot
id|enable_ms
op_assign
id|snp_enable_ms
comma
dot
id|break_ctl
op_assign
id|snp_break_ctl
comma
dot
id|startup
op_assign
id|snp_startup
comma
dot
id|shutdown
op_assign
id|snp_shutdown
comma
dot
id|set_termios
op_assign
id|snp_set_termios
comma
dot
id|pm
op_assign
l_int|NULL
comma
dot
id|type
op_assign
id|snp_type
comma
dot
id|release_port
op_assign
id|snp_release_port
comma
dot
id|request_port
op_assign
id|snp_request_port
comma
dot
id|config_port
op_assign
id|snp_config_port
comma
dot
id|verify_port
op_assign
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/* End of uart struct functions and defines */
macro_line|#ifdef DEBUG
multiline_comment|/**&n; * sn_debug_printf - close to hardware debugging printf&n; * @fmt: printf format&n; *&n; * This is as &quot;close to the metal&quot; as we can get, used when the driver&n; * itself may be broken.&n; *&n; */
DECL|function|sn_debug_printf
r_static
r_int
id|sn_debug_printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_static
r_char
id|printk_buf
(braket
l_int|1024
)braket
suffix:semicolon
r_int
id|printed_len
suffix:semicolon
id|va_list
id|args
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|printed_len
op_assign
id|vsnprintf
c_func
(paren
id|printk_buf
comma
r_sizeof
(paren
id|printk_buf
)paren
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sal_console_port.sc_ops
)paren
(brace
id|sal_console_port.sc_ops
op_assign
op_amp
id|poll_ops
suffix:semicolon
id|early_sn_setup
c_func
(paren
)paren
suffix:semicolon
)brace
id|sal_console_port.sc_ops
op_member_access_from_pointer
id|sal_puts_raw
c_func
(paren
id|printk_buf
comma
id|printed_len
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_return
id|printed_len
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* DEBUG */
multiline_comment|/*&n; * Interrupt handling routines.&n; */
multiline_comment|/**&n; * sn_receive_chars - Grab characters, pass them to tty layer&n; * @port: Port to operate on&n; * @regs: Saved registers (needed by uart_handle_sysrq_char)&n; * @flags: irq flags&n; *&n; * Note: If we&squot;re not registered with the serial core infrastructure yet,&n; * we don&squot;t try to send characters to it...&n; *&n; */
r_static
r_void
DECL|function|sn_receive_chars
id|sn_receive_chars
c_func
(paren
r_struct
id|sn_cons_port
op_star
id|port
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|flags
)paren
(brace
r_int
id|ch
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sn_receive_chars - port NULL so can&squot;t receieve&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;sc_ops
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sn_receive_chars - port-&gt;sc_ops  NULL so can&squot;t receieve&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;sc_port.info
)paren
(brace
multiline_comment|/* The serial_core stuffs are initilized, use them */
id|tty
op_assign
id|port-&gt;sc_port.info-&gt;tty
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Not registered yet - can&squot;t pass to tty layer.  */
id|tty
op_assign
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|port-&gt;sc_ops
op_member_access_from_pointer
id|sal_input_pending
c_func
(paren
)paren
)paren
(brace
id|ch
op_assign
id|port-&gt;sc_ops
op_member_access_from_pointer
id|sal_getc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sn_console: An error occured while &quot;
l_string|&quot;obtaining data from the console (0x%0x)&bslash;n&quot;
comma
id|ch
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MAGIC_SYSRQ
r_if
c_cond
(paren
id|sysrq_requested
)paren
(brace
r_int
r_int
id|sysrq_timeout
op_assign
id|sysrq_requested
op_plus
id|HZ
op_star
l_int|5
suffix:semicolon
id|sysrq_requested
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|sysrq_timeout
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
id|handle_sysrq
c_func
(paren
id|ch
comma
id|regs
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* ignore actual sysrq command char */
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ch
op_eq
op_star
id|sysrq_serial_ptr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
op_increment
id|sysrq_serial_ptr
)paren
)paren
(brace
id|sysrq_requested
op_assign
id|jiffies
suffix:semicolon
id|sysrq_serial_ptr
op_assign
id|sysrq_serial_str
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * ignore the whole sysrq string except for the&n;&t;&t;&t; * leading escape&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ch
op_ne
l_char|&squot;&bslash;e&squot;
)paren
r_continue
suffix:semicolon
)brace
r_else
id|sysrq_serial_ptr
op_assign
id|sysrq_serial_str
suffix:semicolon
macro_line|#endif /* CONFIG_MAGIC_SYSRQ */
multiline_comment|/* record the character to pass up to the tty layer */
r_if
c_cond
(paren
id|tty
)paren
(brace
op_star
id|tty-&gt;flip.char_buf_ptr
op_assign
id|ch
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_NORMAL
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_eq
id|TTY_FLIPBUF_SIZE
)paren
r_break
suffix:semicolon
)brace
id|port-&gt;sc_port.icount.rx
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty
)paren
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_transmit_chars - grab characters from serial core, send off&n; * @port: Port to operate on&n; * @raw: Transmit raw or buffered&n; *&n; * Note: If we&squot;re early, before we&squot;re registered with serial core, the&n; * writes are going through sn_sal_console_write because that&squot;s how&n; * register_console has been set up.  We currently could have asynch&n; * polls calling this function due to sn_sal_switch_to_asynch but we can&n; * ignore them until we register with the serial core stuffs.&n; *&n; */
DECL|function|sn_transmit_chars
r_static
r_void
id|sn_transmit_chars
c_func
(paren
r_struct
id|sn_cons_port
op_star
id|port
comma
r_int
id|raw
)paren
(brace
r_int
id|xmit_count
comma
id|tail
comma
id|head
comma
id|loops
comma
id|ii
suffix:semicolon
r_int
id|result
suffix:semicolon
r_char
op_star
id|start
suffix:semicolon
r_struct
id|circ_buf
op_star
id|xmit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|port-&gt;sc_is_asynch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;sc_port.info
)paren
(brace
multiline_comment|/* We&squot;re initilized, using serial core infrastructure */
id|xmit
op_assign
op_amp
id|port-&gt;sc_port.info-&gt;xmit
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Probably sn_sal_switch_to_asynch has been run but serial core isn&squot;t&n;&t;&t; * initilized yet.  Just return.  Writes are going through&n;&t;&t; * sn_sal_console_write (due to register_console) at this time.&n;&t;&t; */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
id|xmit
)paren
op_logical_or
id|uart_tx_stopped
c_func
(paren
op_amp
id|port-&gt;sc_port
)paren
)paren
(brace
multiline_comment|/* Nothing to do. */
r_return
suffix:semicolon
)brace
id|head
op_assign
id|xmit-&gt;head
suffix:semicolon
id|tail
op_assign
id|xmit-&gt;tail
suffix:semicolon
id|start
op_assign
op_amp
id|xmit-&gt;buf
(braket
id|tail
)braket
suffix:semicolon
multiline_comment|/* twice around gets the tail to the end of the buffer and&n;&t; * then to the head, if needed */
id|loops
op_assign
(paren
id|head
OL
id|tail
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
OL
id|loops
suffix:semicolon
id|ii
op_increment
)paren
(brace
id|xmit_count
op_assign
(paren
id|head
OL
id|tail
)paren
ques
c_cond
(paren
id|UART_XMIT_SIZE
op_minus
id|tail
)paren
suffix:colon
(paren
id|head
op_minus
id|tail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmit_count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|raw
op_eq
id|TRANSMIT_RAW
)paren
id|result
op_assign
id|port-&gt;sc_ops
op_member_access_from_pointer
id|sal_puts_raw
c_func
(paren
id|start
comma
id|xmit_count
)paren
suffix:semicolon
r_else
id|result
op_assign
id|port-&gt;sc_ops
op_member_access_from_pointer
id|sal_puts
c_func
(paren
id|start
comma
id|xmit_count
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
id|DPRINTF
c_func
(paren
l_string|&quot;`&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
(brace
id|xmit_count
op_sub_assign
id|result
suffix:semicolon
id|port-&gt;sc_port.icount.tx
op_add_assign
id|result
suffix:semicolon
id|tail
op_add_assign
id|result
suffix:semicolon
id|tail
op_and_assign
id|UART_XMIT_SIZE
op_minus
l_int|1
suffix:semicolon
id|xmit-&gt;tail
op_assign
id|tail
suffix:semicolon
id|start
op_assign
op_amp
id|xmit-&gt;buf
(braket
id|tail
)braket
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|uart_circ_chars_pending
c_func
(paren
id|xmit
)paren
OL
id|WAKEUP_CHARS
)paren
id|uart_write_wakeup
c_func
(paren
op_amp
id|port-&gt;sc_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
id|xmit
)paren
)paren
id|snp_stop_tx
c_func
(paren
op_amp
id|port-&gt;sc_port
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* no-op for us */
)brace
multiline_comment|/**&n; * sn_sal_interrupt - Handle console interrupts&n; * @irq: irq #, useful for debug statements&n; * @dev_id: our pointer to our port (sn_cons_port which contains the uart port)&n; * @regs: Saved registers, used by sn_receive_chars for uart_handle_sysrq_char&n; *&n; */
DECL|function|sn_sal_interrupt
r_static
id|irqreturn_t
id|sn_sal_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|sn_cons_port
op_star
id|port
op_assign
(paren
r_struct
id|sn_cons_port
op_star
)paren
id|dev_id
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|status
op_assign
id|ia64_sn_console_intr_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
id|IRQ_NONE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|SAL_CONSOLE_INTR_RECV
)paren
(brace
id|sn_receive_chars
c_func
(paren
id|port
comma
id|regs
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|SAL_CONSOLE_INTR_XMIT
)paren
(brace
id|sn_transmit_chars
c_func
(paren
id|port
comma
id|TRANSMIT_BUFFERED
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_sal_connect_interrupt - Request interrupt, handled by sn_sal_interrupt&n; * @port: Our sn_cons_port (which contains the uart port)&n; *&n; * returns the console irq if interrupt is successfully registered, else 0&n; *&n; */
DECL|function|sn_sal_connect_interrupt
r_static
r_int
id|sn_sal_connect_interrupt
c_func
(paren
r_struct
id|sn_cons_port
op_star
id|port
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|SGI_UART_VECTOR
comma
id|sn_sal_interrupt
comma
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
comma
l_string|&quot;SAL console driver&quot;
comma
id|port
)paren
op_ge
l_int|0
)paren
(brace
r_return
id|SGI_UART_VECTOR
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;sn_console: console proceeding in polled mode&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_sal_timer_poll - this function handles polled console mode&n; * @data: A pointer to our sn_cons_port (which contains the uart port)&n; *&n; * data is the pointer that init_timer will store for us.  This function is&n; * associated with init_timer to see if there is any console traffic.&n; * Obviously not used in interrupt mode&n; *&n; */
DECL|function|sn_sal_timer_poll
r_static
r_void
id|sn_sal_timer_poll
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sn_cons_port
op_star
id|port
op_assign
(paren
r_struct
id|sn_cons_port
op_star
)paren
id|data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;sc_port.irq
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
id|sn_receive_chars
c_func
(paren
id|port
comma
l_int|NULL
comma
id|flags
)paren
suffix:semicolon
id|sn_transmit_chars
c_func
(paren
id|port
comma
id|TRANSMIT_RAW
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|port-&gt;sc_timer
comma
id|jiffies
op_plus
id|port-&gt;sc_interrupt_timeout
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Boot-time initialization code&n; */
multiline_comment|/**&n; * sn_sal_switch_to_asynch - Switch to async mode (as opposed to synch)&n; * @port: Our sn_cons_port (which contains the uart port)&n; *&n; * So this is used by sn_sal_serial_console_init (early on, before we&squot;re&n; * registered with serial core).  It&squot;s also used by sn_sal_module_init&n; * right after we&squot;ve registered with serial core.  The later only happens&n; * if we didn&squot;t already come through here via sn_sal_serial_console_init.&n; *&n; */
DECL|function|sn_sal_switch_to_asynch
r_static
r_void
id|__init
id|sn_sal_switch_to_asynch
c_func
(paren
r_struct
id|sn_cons_port
op_star
id|port
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;sn_console: about to switch to asynchronous console&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* without early_printk, we may be invoked late enough to race&n;&t; * with other cpus doing console IO at this point, however&n;&t; * console interrupts will never be enabled */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* early_printk invocation may have done this for us */
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;sc_ops
)paren
id|port-&gt;sc_ops
op_assign
op_amp
id|poll_ops
suffix:semicolon
multiline_comment|/* we can&squot;t turn on the console interrupt (as request_irq&n;&t; * calls kmalloc, which isn&squot;t set up yet), so we rely on a&n;&t; * timer to poll for input and push data from the console&n;&t; * buffer.&n;&t; */
id|init_timer
c_func
(paren
op_amp
id|port-&gt;sc_timer
)paren
suffix:semicolon
id|port-&gt;sc_timer.function
op_assign
id|sn_sal_timer_poll
suffix:semicolon
id|port-&gt;sc_timer.data
op_assign
(paren
r_int
r_int
)paren
id|port
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
id|port-&gt;sc_interrupt_timeout
op_assign
l_int|6
suffix:semicolon
r_else
(brace
multiline_comment|/* 960cps / 16 char FIFO = 60HZ&n;&t;&t; * HZ / (SN_SAL_FIFO_SPEED_CPS / SN_SAL_FIFO_DEPTH) */
id|port-&gt;sc_interrupt_timeout
op_assign
id|HZ
op_star
id|SN_SAL_UART_FIFO_DEPTH
op_div
id|SN_SAL_UART_FIFO_SPEED_CPS
suffix:semicolon
)brace
id|mod_timer
c_func
(paren
op_amp
id|port-&gt;sc_timer
comma
id|jiffies
op_plus
id|port-&gt;sc_interrupt_timeout
)paren
suffix:semicolon
id|port-&gt;sc_is_asynch
op_assign
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_sal_switch_to_interrupts - Switch to interrupt driven mode&n; * @port: Our sn_cons_port (which contains the uart port)&n; *&n; * In sn_sal_module_init, after we&squot;re registered with serial core and&n; * the port is added, this function is called to switch us to interrupt&n; * mode.  We were previously in asynch/polling mode (using init_timer).&n; *&n; * We attempt to switch to interrupt mode here by calling&n; * sn_sal_connect_interrupt.  If that works out, we enable receive interrupts.&n; */
DECL|function|sn_sal_switch_to_interrupts
r_static
r_void
id|__init
id|sn_sal_switch_to_interrupts
c_func
(paren
r_struct
id|sn_cons_port
op_star
id|port
)paren
(brace
r_int
id|irq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;sn_console: switching to interrupt driven console&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
id|irq
op_assign
id|sn_sal_connect_interrupt
c_func
(paren
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
)paren
(brace
id|port-&gt;sc_port.irq
op_assign
id|irq
suffix:semicolon
id|port-&gt;sc_ops
op_assign
op_amp
id|intr_ops
suffix:semicolon
multiline_comment|/* turn on receive interrupts */
id|ia64_sn_console_intr_enable
c_func
(paren
id|SAL_CONSOLE_INTR_RECV
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Kernel console definitions&n; */
r_static
r_void
id|sn_sal_console_write
c_func
(paren
r_struct
id|console
op_star
comma
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|__init
id|sn_sal_console_setup
c_func
(paren
r_struct
id|console
op_star
comma
r_char
op_star
)paren
suffix:semicolon
r_extern
r_struct
id|uart_driver
id|sal_console_uart
suffix:semicolon
r_extern
r_struct
id|tty_driver
op_star
id|uart_console_device
c_func
(paren
r_struct
id|console
op_star
comma
r_int
op_star
)paren
suffix:semicolon
DECL|variable|sal_console
r_static
r_struct
id|console
id|sal_console
op_assign
(brace
dot
id|name
op_assign
id|DEVICE_NAME
comma
dot
id|write
op_assign
id|sn_sal_console_write
comma
dot
id|device
op_assign
id|uart_console_device
comma
dot
id|setup
op_assign
id|sn_sal_console_setup
comma
dot
id|index
op_assign
op_minus
l_int|1
comma
multiline_comment|/* unspecified */
dot
id|data
op_assign
op_amp
id|sal_console_uart
comma
)brace
suffix:semicolon
DECL|macro|SAL_CONSOLE
mdefine_line|#define SAL_CONSOLE&t;&amp;sal_console
DECL|variable|sal_console_uart
r_static
r_struct
id|uart_driver
id|sal_console_uart
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|driver_name
op_assign
l_string|&quot;sn_console&quot;
comma
dot
id|dev_name
op_assign
id|DEVICE_NAME
comma
dot
id|major
op_assign
l_int|0
comma
multiline_comment|/* major/minor set at registration time per USE_DYNAMIC_MINOR */
dot
id|minor
op_assign
l_int|0
comma
dot
id|nr
op_assign
l_int|1
comma
multiline_comment|/* one port */
dot
id|cons
op_assign
id|SAL_CONSOLE
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * sn_sal_module_init - When the kernel loads us, get us rolling w/ serial core&n; *&n; * Before this is called, we&squot;ve been printing kernel messages in a special&n; * early mode not making use of the serial core infrastructure.  When our&n; * driver is loaded for real, we register the driver and port with serial&n; * core and try to enable interrupt driven mode.&n; *&n; */
DECL|function|sn_sal_module_init
r_static
r_int
id|__init
id|sn_sal_module_init
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ia64_platform_is
c_func
(paren
l_string|&quot;sn2&quot;
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;sn_console: Console driver init&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|USE_DYNAMIC_MINOR
op_eq
l_int|1
)paren
(brace
id|misc.minor
op_assign
id|MISC_DYNAMIC_MINOR
suffix:semicolon
id|misc.name
op_assign
id|DEVICE_NAME_DYNAMIC
suffix:semicolon
id|retval
op_assign
id|misc_register
c_func
(paren
op_amp
id|misc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;Failed to register console device using misc_register.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|sal_console_uart.major
op_assign
id|MISC_MAJOR
suffix:semicolon
id|sal_console_uart.minor
op_assign
id|misc.minor
suffix:semicolon
)brace
r_else
(brace
id|sal_console_uart.major
op_assign
id|DEVICE_MAJOR
suffix:semicolon
id|sal_console_uart.minor
op_assign
id|DEVICE_MINOR
suffix:semicolon
)brace
multiline_comment|/* We register the driver and the port before switching to interrupts&n;&t; * or async above so the proper uart structures are populated */
r_if
c_cond
(paren
id|uart_register_driver
c_func
(paren
op_amp
id|sal_console_uart
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;ERROR sn_sal_module_init failed uart_register_driver, line %d&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|spin_lock_init
c_func
(paren
op_amp
id|sal_console_port.sc_port.lock
)paren
suffix:semicolon
multiline_comment|/* Setup the port struct with the minimum needed */
id|sal_console_port.sc_port.membase
op_assign
(paren
r_char
op_star
)paren
l_int|1
suffix:semicolon
multiline_comment|/* just needs to be non-zero */
id|sal_console_port.sc_port.type
op_assign
id|PORT_16550A
suffix:semicolon
id|sal_console_port.sc_port.fifosize
op_assign
id|SN_SAL_MAX_CHARS
suffix:semicolon
id|sal_console_port.sc_port.ops
op_assign
op_amp
id|sn_console_ops
suffix:semicolon
id|sal_console_port.sc_port.line
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|uart_add_one_port
c_func
(paren
op_amp
id|sal_console_uart
comma
op_amp
id|sal_console_port.sc_port
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* error - not sure what I&squot;d do - so I&squot;ll do nothing */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unable to add port&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
multiline_comment|/* when this driver is compiled in, the console initialization&n;&t; * will have already switched us into asynchronous operation&n;&t; * before we get here through the module initcalls */
r_if
c_cond
(paren
op_logical_neg
id|sal_console_port.sc_is_asynch
)paren
(brace
id|sn_sal_switch_to_asynch
c_func
(paren
op_amp
id|sal_console_port
)paren
suffix:semicolon
)brace
multiline_comment|/* at this point (module_init) we can try to turn on interrupts */
r_if
c_cond
(paren
op_logical_neg
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
(brace
id|sn_sal_switch_to_interrupts
c_func
(paren
op_amp
id|sal_console_port
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_sal_module_exit - When we&squot;re unloaded, remove the driver/port&n; *&n; */
DECL|function|sn_sal_module_exit
r_static
r_void
id|__exit
id|sn_sal_module_exit
c_func
(paren
r_void
)paren
(brace
id|del_timer_sync
c_func
(paren
op_amp
id|sal_console_port.sc_timer
)paren
suffix:semicolon
id|uart_remove_one_port
c_func
(paren
op_amp
id|sal_console_uart
comma
op_amp
id|sal_console_port.sc_port
)paren
suffix:semicolon
id|uart_unregister_driver
c_func
(paren
op_amp
id|sal_console_uart
)paren
suffix:semicolon
id|misc_deregister
c_func
(paren
op_amp
id|misc
)paren
suffix:semicolon
)brace
DECL|variable|sn_sal_module_init
id|module_init
c_func
(paren
id|sn_sal_module_init
)paren
suffix:semicolon
DECL|variable|sn_sal_module_exit
id|module_exit
c_func
(paren
id|sn_sal_module_exit
)paren
suffix:semicolon
multiline_comment|/**&n; * puts_raw_fixed - sn_sal_console_write helper for adding &bslash;r&squot;s as required&n; * @puts_raw : puts function to do the writing&n; * @s: input string&n; * @count: length&n; *&n; * We need a &bslash;r ahead of every &bslash;n for direct writes through&n; * ia64_sn_console_putb (what sal_puts_raw below actually does).&n; *&n; */
DECL|function|puts_raw_fixed
r_static
r_void
id|puts_raw_fixed
c_func
(paren
r_int
(paren
op_star
id|puts_raw
)paren
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|len
)paren
comma
r_const
r_char
op_star
id|s
comma
r_int
id|count
)paren
(brace
r_const
r_char
op_star
id|s1
suffix:semicolon
multiline_comment|/* Output &squot;&bslash;r&squot; before each &squot;&bslash;n&squot; */
r_while
c_loop
(paren
(paren
id|s1
op_assign
id|memchr
c_func
(paren
id|s
comma
l_char|&squot;&bslash;n&squot;
comma
id|count
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|puts_raw
c_func
(paren
id|s
comma
id|s1
op_minus
id|s
)paren
suffix:semicolon
id|puts_raw
c_func
(paren
l_string|&quot;&bslash;r&bslash;n&quot;
comma
l_int|2
)paren
suffix:semicolon
id|count
op_sub_assign
id|s1
op_plus
l_int|1
op_minus
id|s
suffix:semicolon
id|s
op_assign
id|s1
op_plus
l_int|1
suffix:semicolon
)brace
id|puts_raw
c_func
(paren
id|s
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_sal_console_write - Print statements before serial core available&n; * @console: Console to operate on - we ignore since we have just one&n; * @s: String to send&n; * @count: length&n; *&n; * This is referenced in the console struct.  It is used for early&n; * console printing before we register with serial core and for things&n; * such as kdb.  The console_lock must be held when we get here.&n; *&n; * This function has some code for trying to print output even if the lock&n; * is held.  We try to cover the case where a lock holder could have died.&n; * We don&squot;t use this special case code if we&squot;re not registered with serial&n; * core yet.  After we&squot;re registered with serial core, the only time this&n; * function would be used is for high level kernel output like magic sys req,&n; * kdb, and printk&squot;s.&n; */
r_static
r_void
DECL|function|sn_sal_console_write
id|sn_sal_console_write
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_const
r_char
op_star
id|s
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_struct
id|sn_cons_port
op_star
id|port
op_assign
op_amp
id|sal_console_port
suffix:semicolon
macro_line|#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT)
r_static
r_int
id|stole_lock
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|BUG_ON
c_func
(paren
op_logical_neg
id|port-&gt;sc_is_asynch
)paren
suffix:semicolon
multiline_comment|/* We can&squot;t look at the xmit buffer if we&squot;re not registered with serial core&n;&t; *  yet.  So only do the fancy recovery after registering&n;&t; */
r_if
c_cond
(paren
id|port-&gt;sc_port.info
)paren
(brace
multiline_comment|/* somebody really wants this output, might be an&n;&t;&t; * oops, kdb, panic, etc.  make sure they get it. */
macro_line|#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT)
r_if
c_cond
(paren
id|spin_is_locked
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
)paren
)paren
(brace
r_int
id|lhead
op_assign
id|port-&gt;sc_port.info-&gt;xmit.head
suffix:semicolon
r_int
id|ltail
op_assign
id|port-&gt;sc_port.info-&gt;xmit.tail
suffix:semicolon
r_int
id|counter
comma
id|got_lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We attempt to determine if someone has died with the&n;&t;&t;&t; * lock. We wait ~20 secs after the head and tail ptrs&n;&t;&t;&t; * stop moving and assume the lock holder is not functional&n;&t;&t;&t; * and plow ahead. If the lock is freed within the time out&n;&t;&t;&t; * period we re-get the lock and go ahead normally. We also&n;&t;&t;&t; * remember if we have plowed ahead so that we don&squot;t have&n;&t;&t;&t; * to wait out the time out period again - the asumption&n;&t;&t;&t; * is that we will time out again.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|150
suffix:semicolon
id|mdelay
c_func
(paren
l_int|125
)paren
comma
id|counter
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|spin_is_locked
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
)paren
op_logical_or
id|stole_lock
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|stole_lock
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port
op_member_access_from_pointer
id|sc_port.lock
comma
id|flags
)paren
suffix:semicolon
id|got_lock
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* still locked */
r_if
c_cond
(paren
(paren
id|lhead
op_ne
id|port-&gt;sc_port.info-&gt;xmit.head
)paren
op_logical_or
(paren
id|ltail
op_ne
id|port-&gt;sc_port.info-&gt;xmit
dot
id|tail
)paren
)paren
(brace
id|lhead
op_assign
id|port-&gt;sc_port.info-&gt;xmit
dot
id|head
suffix:semicolon
id|ltail
op_assign
id|port-&gt;sc_port.info-&gt;xmit
dot
id|tail
suffix:semicolon
id|counter
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* flush anything in the serial core xmit buffer, raw */
id|sn_transmit_chars
c_func
(paren
id|port
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|got_lock
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
id|stole_lock
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* fell thru */
id|stole_lock
op_assign
l_int|1
suffix:semicolon
)brace
id|puts_raw_fixed
c_func
(paren
id|port-&gt;sc_ops-&gt;sal_puts_raw
comma
id|s
comma
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
id|stole_lock
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
id|sn_transmit_chars
c_func
(paren
id|port
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;sc_port.lock
comma
id|flags
)paren
suffix:semicolon
id|puts_raw_fixed
c_func
(paren
id|port-&gt;sc_ops-&gt;sal_puts_raw
comma
id|s
comma
id|count
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_SMP) || defined(CONFIG_PREEMPT)
)brace
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* Not yet registered with serial core - simple case */
id|puts_raw_fixed
c_func
(paren
id|port-&gt;sc_ops-&gt;sal_puts_raw
comma
id|s
comma
id|count
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * sn_sal_console_setup - Set up console for early printing&n; * @co: Console to work with&n; * @options: Options to set&n; *&n; * Altix console doesn&squot;t do anything with baud rates, etc, anyway.&n; *&n; * This isn&squot;t required since not providing the setup function in the&n; * console struct is ok.  However, other patches like KDB plop something&n; * here so providing it is easier.&n; *&n; */
DECL|function|sn_sal_console_setup
r_static
r_int
id|__init
id|sn_sal_console_setup
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_char
op_star
id|options
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_sal_console_write_early - simple early output routine&n; * @co - console struct&n; * @s - string to print&n; * @count - count&n; *&n; * Simple function to provide early output, before even&n; * sn_sal_serial_console_init is called.  Referenced in the&n; * console struct registerd in sn_serial_console_early_setup.&n; *&n; */
r_static
r_void
id|__init
DECL|function|sn_sal_console_write_early
id|sn_sal_console_write_early
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_const
r_char
op_star
id|s
comma
r_int
id|count
)paren
(brace
id|puts_raw_fixed
c_func
(paren
id|sal_console_port.sc_ops-&gt;sal_puts_raw
comma
id|s
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* Used for very early console printing - again, before&n; * sn_sal_serial_console_init is run */
DECL|variable|__initdata
r_static
r_struct
id|console
id|sal_console_early
id|__initdata
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;sn_sal&quot;
comma
dot
id|write
op_assign
id|sn_sal_console_write_early
comma
dot
id|flags
op_assign
id|CON_PRINTBUFFER
comma
dot
id|index
op_assign
op_minus
l_int|1
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * sn_serial_console_early_setup - Sets up early console output support&n; *&n; * Register a console early on...  This is for output before even&n; * sn_sal_serial_cosnole_init is called.  This function is called from&n; * setup.c.  This allows us to do really early polled writes. When&n; * sn_sal_serial_console_init is called, this console is unregistered&n; * and a new one registered.&n; */
DECL|function|sn_serial_console_early_setup
r_int
id|__init
id|sn_serial_console_early_setup
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ia64_platform_is
c_func
(paren
l_string|&quot;sn2&quot;
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|sal_console_port.sc_ops
op_assign
op_amp
id|poll_ops
suffix:semicolon
id|early_sn_setup
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Find SAL entry points */
id|register_console
c_func
(paren
op_amp
id|sal_console_early
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * sn_sal_serial_console_init - Early console output - set up for register&n; *&n; * This function is called when regular console init happens.  Because we&n; * support even earlier console output with sn_serial_console_early_setup&n; * (called from setup.c directly), this function unregisters the really&n; * early console.&n; *&n; * Note: Even if setup.c doesn&squot;t register sal_console_early, unregistering&n; * it here doesn&squot;t hurt anything.&n; *&n; */
DECL|function|sn_sal_serial_console_init
r_static
r_int
id|__init
id|sn_sal_serial_console_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ia64_platform_is
c_func
(paren
l_string|&quot;sn2&quot;
)paren
)paren
(brace
id|sn_sal_switch_to_asynch
c_func
(paren
op_amp
id|sal_console_port
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;sn_sal_serial_console_init : register console&bslash;n&quot;
)paren
suffix:semicolon
id|register_console
c_func
(paren
op_amp
id|sal_console
)paren
suffix:semicolon
id|unregister_console
c_func
(paren
op_amp
id|sal_console_early
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sn_sal_serial_console_init
id|console_initcall
c_func
(paren
id|sn_sal_serial_console_init
)paren
suffix:semicolon
eof
