multiline_comment|/* $Id: su.c,v 1.55 2002/01/08 16:00:16 davem Exp $&n; * su.c: Small serial driver for keyboard/mouse interface on sparc32/PCI&n; *&n; * Copyright (C) 1997  Eddie C. Dost  (ecd@skynet.be)&n; * Copyright (C) 1998-1999  Pete Zaitcev   (zaitcev@yahoo.com)&n; *&n; * This is mainly a variation of 8250.c, credits go to authors mentioned&n; * therein.  In fact this driver should be merged into the generic 8250.c&n; * infrastructure perhaps using a 8250_sparc.c module.&n; *&n; * Fixed to use tty_get_baud_rate().&n; *   Theodore Ts&squot;o &lt;tytso@mit.edu&gt;, 2001-Oct-12&n; *&n; * Converted to new 2.5.x UART layer.&n; *   David S. Miller (davem@redhat.com), 2002-Jul-29&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/circ_buf.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/sysrq.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#ifdef CONFIG_SERIO
macro_line|#include &lt;linux/serio.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/serial_reg.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/ebus.h&gt;
macro_line|#ifdef CONFIG_SPARC64
macro_line|#include &lt;asm/isa.h&gt;
macro_line|#endif
macro_line|#if defined(CONFIG_SERIAL_SUNSU_CONSOLE) &amp;&amp; defined(CONFIG_MAGIC_SYSRQ)
DECL|macro|SUPPORT_SYSRQ
mdefine_line|#define SUPPORT_SYSRQ
macro_line|#endif
macro_line|#include &lt;linux/serial_core.h&gt;
macro_line|#include &quot;suncore.h&quot;
multiline_comment|/* We are on a NS PC87303 clocked with 24.0 MHz, which results&n; * in a UART clock of 1.8462 MHz.&n; */
DECL|macro|SU_BASE_BAUD
mdefine_line|#define SU_BASE_BAUD&t;(1846200 / 16)
DECL|enum|su_type
DECL|enumerator|SU_PORT_NONE
DECL|enumerator|SU_PORT_MS
DECL|enumerator|SU_PORT_KBD
DECL|enumerator|SU_PORT_PORT
r_enum
id|su_type
(brace
id|SU_PORT_NONE
comma
id|SU_PORT_MS
comma
id|SU_PORT_KBD
comma
id|SU_PORT_PORT
)brace
suffix:semicolon
DECL|variable|su_typev
r_static
r_char
op_star
id|su_typev
(braket
)braket
op_assign
(brace
l_string|&quot;su(???)&quot;
comma
l_string|&quot;su(mouse)&quot;
comma
l_string|&quot;su(kbd)&quot;
comma
l_string|&quot;su(serial)&quot;
)brace
suffix:semicolon
multiline_comment|/*&n; * Here we define the default xmit fifo size used for each type of UART.&n; */
DECL|variable|uart_config
r_static
r_const
r_struct
id|serial_uart_config
id|uart_config
(braket
id|PORT_MAX_8250
op_plus
l_int|1
)braket
op_assign
(brace
(brace
l_string|&quot;unknown&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;8250&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;16450&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;16550&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;16550A&quot;
comma
l_int|16
comma
id|UART_CLEAR_FIFO
op_or
id|UART_USE_FIFO
)brace
comma
(brace
l_string|&quot;Cirrus&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;ST16650&quot;
comma
l_int|1
comma
id|UART_CLEAR_FIFO
op_or
id|UART_STARTECH
)brace
comma
(brace
l_string|&quot;ST16650V2&quot;
comma
l_int|32
comma
id|UART_CLEAR_FIFO
op_or
id|UART_USE_FIFO
op_or
id|UART_STARTECH
)brace
comma
(brace
l_string|&quot;TI16750&quot;
comma
l_int|64
comma
id|UART_CLEAR_FIFO
op_or
id|UART_USE_FIFO
)brace
comma
(brace
l_string|&quot;Startech&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;16C950/954&quot;
comma
l_int|128
comma
id|UART_CLEAR_FIFO
op_or
id|UART_USE_FIFO
)brace
comma
(brace
l_string|&quot;ST16654&quot;
comma
l_int|64
comma
id|UART_CLEAR_FIFO
op_or
id|UART_USE_FIFO
op_or
id|UART_STARTECH
)brace
comma
(brace
l_string|&quot;XR16850&quot;
comma
l_int|128
comma
id|UART_CLEAR_FIFO
op_or
id|UART_USE_FIFO
op_or
id|UART_STARTECH
)brace
comma
(brace
l_string|&quot;RSA&quot;
comma
l_int|2048
comma
id|UART_CLEAR_FIFO
op_or
id|UART_USE_FIFO
)brace
)brace
suffix:semicolon
DECL|struct|uart_sunsu_port
r_struct
id|uart_sunsu_port
(brace
DECL|member|port
r_struct
id|uart_port
id|port
suffix:semicolon
DECL|member|acr
r_int
r_char
id|acr
suffix:semicolon
DECL|member|ier
r_int
r_char
id|ier
suffix:semicolon
DECL|member|rev
r_int
r_int
id|rev
suffix:semicolon
DECL|member|lcr
r_int
r_char
id|lcr
suffix:semicolon
DECL|member|lsr_break_flag
r_int
r_int
id|lsr_break_flag
suffix:semicolon
DECL|member|cflag
r_int
r_int
id|cflag
suffix:semicolon
multiline_comment|/* Probing information.  */
DECL|member|su_type
r_enum
id|su_type
id|su_type
suffix:semicolon
DECL|member|type_probed
r_int
r_int
id|type_probed
suffix:semicolon
multiline_comment|/* XXX Stupid */
DECL|member|port_node
r_int
id|port_node
suffix:semicolon
DECL|member|irq
r_int
r_int
id|irq
suffix:semicolon
macro_line|#ifdef CONFIG_SERIO
DECL|member|serio
r_struct
id|serio
id|serio
suffix:semicolon
DECL|member|serio_open
r_int
id|serio_open
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|_INLINE_
mdefine_line|#define _INLINE_
DECL|function|serial_in
r_static
id|_INLINE_
r_int
r_int
id|serial_in
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
comma
r_int
id|offset
)paren
(brace
id|offset
op_lshift_assign
id|up-&gt;port.regshift
suffix:semicolon
r_switch
c_cond
(paren
id|up-&gt;port.iotype
)paren
(brace
r_case
id|SERIAL_IO_HUB6
suffix:colon
id|outb
c_func
(paren
id|up-&gt;port.hub6
op_minus
l_int|1
op_plus
id|offset
comma
id|up-&gt;port.iobase
)paren
suffix:semicolon
r_return
id|inb
c_func
(paren
id|up-&gt;port.iobase
op_plus
l_int|1
)paren
suffix:semicolon
r_case
id|SERIAL_IO_MEM
suffix:colon
r_return
id|readb
c_func
(paren
id|up-&gt;port.membase
op_plus
id|offset
)paren
suffix:semicolon
r_default
suffix:colon
r_return
id|inb
c_func
(paren
id|up-&gt;port.iobase
op_plus
id|offset
)paren
suffix:semicolon
)brace
)brace
r_static
id|_INLINE_
r_void
DECL|function|serial_out
id|serial_out
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
comma
r_int
id|offset
comma
r_int
id|value
)paren
(brace
macro_line|#ifndef CONFIG_SPARC64
multiline_comment|/*&n;&t; * MrCoffee has weird schematics: IRQ4 &amp; P10(?) pins of SuperIO are&n;&t; * connected with a gate then go to SlavIO. When IRQ4 goes tristated&n;&t; * gate outputs a logical one. Since we use level triggered interrupts&n;&t; * we have lockup and watchdog reset. We cannot mask IRQ because&n;&t; * keyboard shares IRQ with us (Word has it as Bob Smelik&squot;s design).&n;&t; * This problem is similar to what Alpha people suffer, see serial.c.&n;&t; */
r_if
c_cond
(paren
id|offset
op_eq
id|UART_MCR
)paren
id|value
op_or_assign
id|UART_MCR_OUT2
suffix:semicolon
macro_line|#endif
id|offset
op_lshift_assign
id|up-&gt;port.regshift
suffix:semicolon
r_switch
c_cond
(paren
id|up-&gt;port.iotype
)paren
(brace
r_case
id|SERIAL_IO_HUB6
suffix:colon
id|outb
c_func
(paren
id|up-&gt;port.hub6
op_minus
l_int|1
op_plus
id|offset
comma
id|up-&gt;port.iobase
)paren
suffix:semicolon
id|outb
c_func
(paren
id|value
comma
id|up-&gt;port.iobase
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SERIAL_IO_MEM
suffix:colon
id|writeb
c_func
(paren
id|value
comma
id|up-&gt;port.membase
op_plus
id|offset
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|outb
c_func
(paren
id|value
comma
id|up-&gt;port.iobase
op_plus
id|offset
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * We used to support using pause I/O for certain machines.  We&n; * haven&squot;t supported this for a while, but just in case it&squot;s badly&n; * needed for certain old 386 machines, I&squot;ve left these #define&squot;s&n; * in....&n; */
DECL|macro|serial_inp
mdefine_line|#define serial_inp(up, offset)&t;&t;serial_in(up, offset)
DECL|macro|serial_outp
mdefine_line|#define serial_outp(up, offset, value)&t;serial_out(up, offset, value)
multiline_comment|/*&n; * For the 16C950&n; */
DECL|function|serial_icr_write
r_static
r_void
id|serial_icr_write
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
comma
r_int
id|offset
comma
r_int
id|value
)paren
(brace
id|serial_out
c_func
(paren
id|up
comma
id|UART_SCR
comma
id|offset
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_ICR
comma
id|value
)paren
suffix:semicolon
)brace
macro_line|#if 0 /* Unused currently */
r_static
r_int
r_int
id|serial_icr_read
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
comma
r_int
id|offset
)paren
(brace
r_int
r_int
id|value
suffix:semicolon
id|serial_icr_write
c_func
(paren
id|up
comma
id|UART_ACR
comma
id|up-&gt;acr
op_or
id|UART_ACR_ICRRD
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_SCR
comma
id|offset
)paren
suffix:semicolon
id|value
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_ICR
)paren
suffix:semicolon
id|serial_icr_write
c_func
(paren
id|up
comma
id|UART_ACR
comma
id|up-&gt;acr
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_SERIAL_8250_RSA
multiline_comment|/*&n; * Attempts to turn on the RSA FIFO.  Returns zero on failure.&n; * We set the port uart clock rate if we succeed.&n; */
DECL|function|__enable_rsa
r_static
r_int
id|__enable_rsa
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
)paren
(brace
r_int
r_char
id|mode
suffix:semicolon
r_int
id|result
suffix:semicolon
id|mode
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RSA_MSR
)paren
suffix:semicolon
id|result
op_assign
id|mode
op_amp
id|UART_RSA_MSR_FIFO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_RSA_MSR
comma
id|mode
op_or
id|UART_RSA_MSR_FIFO
)paren
suffix:semicolon
id|mode
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RSA_MSR
)paren
suffix:semicolon
id|result
op_assign
id|mode
op_amp
id|UART_RSA_MSR_FIFO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
id|up-&gt;port.uartclk
op_assign
id|SERIAL_RSA_BAUD_BASE
op_star
l_int|16
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|enable_rsa
r_static
r_void
id|enable_rsa
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
)paren
(brace
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_RSA
)paren
(brace
r_if
c_cond
(paren
id|up-&gt;port.uartclk
op_ne
id|SERIAL_RSA_BAUD_BASE
op_star
l_int|16
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
id|__enable_rsa
c_func
(paren
id|up
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up-&gt;port.uartclk
op_eq
id|SERIAL_RSA_BAUD_BASE
op_star
l_int|16
)paren
id|serial_outp
c_func
(paren
id|up
comma
id|UART_RSA_FRR
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Attempts to turn off the RSA FIFO.  Returns zero on failure.&n; * It is unknown why interrupts were disabled in here.  However,&n; * the caller is expected to preserve this behaviour by grabbing&n; * the spinlock before calling this function.&n; */
DECL|function|disable_rsa
r_static
r_void
id|disable_rsa
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
)paren
(brace
r_int
r_char
id|mode
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_RSA
op_logical_and
id|up-&gt;port.uartclk
op_eq
id|SERIAL_RSA_BAUD_BASE
op_star
l_int|16
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
id|mode
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RSA_MSR
)paren
suffix:semicolon
id|result
op_assign
op_logical_neg
(paren
id|mode
op_amp
id|UART_RSA_MSR_FIFO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_RSA_MSR
comma
id|mode
op_amp
op_complement
id|UART_RSA_MSR_FIFO
)paren
suffix:semicolon
id|mode
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RSA_MSR
)paren
suffix:semicolon
id|result
op_assign
op_logical_neg
(paren
id|mode
op_amp
id|UART_RSA_MSR_FIFO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
id|up-&gt;port.uartclk
op_assign
id|SERIAL_RSA_BAUD_BASE_LO
op_star
l_int|16
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_SERIAL_8250_RSA */
DECL|function|sunsu_stop_tx
r_static
r_void
id|sunsu_stop_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|tty_stop
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_sunsu_port
op_star
)paren
id|port
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;ier
op_amp
id|UART_IER_THRI
)paren
(brace
id|up-&gt;ier
op_and_assign
op_complement
id|UART_IER_THRI
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_16C950
op_logical_and
id|tty_stop
)paren
(brace
id|up-&gt;acr
op_or_assign
id|UART_ACR_TXDIS
suffix:semicolon
id|serial_icr_write
c_func
(paren
id|up
comma
id|UART_ACR
comma
id|up-&gt;acr
)paren
suffix:semicolon
)brace
)brace
DECL|function|sunsu_start_tx
r_static
r_void
id|sunsu_start_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|tty_start
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_sunsu_port
op_star
)paren
id|port
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|up-&gt;ier
op_amp
id|UART_IER_THRI
)paren
)paren
(brace
id|up-&gt;ier
op_or_assign
id|UART_IER_THRI
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We only do this from uart_start&n;&t; */
r_if
c_cond
(paren
id|tty_start
op_logical_and
id|up-&gt;port.type
op_eq
id|PORT_16C950
)paren
(brace
id|up-&gt;acr
op_and_assign
op_complement
id|UART_ACR_TXDIS
suffix:semicolon
id|serial_icr_write
c_func
(paren
id|up
comma
id|UART_ACR
comma
id|up-&gt;acr
)paren
suffix:semicolon
)brace
)brace
DECL|function|sunsu_stop_rx
r_static
r_void
id|sunsu_stop_rx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_sunsu_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|up-&gt;ier
op_and_assign
op_complement
id|UART_IER_RLSI
suffix:semicolon
id|up-&gt;port.read_status_mask
op_and_assign
op_complement
id|UART_LSR_DR
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|sunsu_enable_ms
r_static
r_void
id|sunsu_enable_ms
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_sunsu_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|up-&gt;ier
op_or_assign
id|UART_IER_MSI
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
id|_INLINE_
r_struct
id|tty_struct
op_star
DECL|function|receive_chars
id|receive_chars
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
comma
r_int
r_char
op_star
id|status
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|up-&gt;port.info-&gt;tty
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_int
id|max_count
op_assign
l_int|256
suffix:semicolon
r_int
id|saw_console_brk
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
)paren
(brace
id|tty-&gt;flip.work
dot
id|func
c_func
(paren
(paren
r_void
op_star
)paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
r_return
id|tty
suffix:semicolon
singleline_comment|// if TTY_DONT_FLIP is set
)brace
id|ch
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_assign
id|ch
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_NORMAL
suffix:semicolon
id|up-&gt;port.icount.rx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_star
id|status
op_amp
(paren
id|UART_LSR_BI
op_or
id|UART_LSR_PE
op_or
id|UART_LSR_FE
op_or
id|UART_LSR_OE
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * For statistics only&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_BI
)paren
(brace
op_star
id|status
op_and_assign
op_complement
(paren
id|UART_LSR_FE
op_or
id|UART_LSR_PE
)paren
suffix:semicolon
id|up-&gt;port.icount.brk
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.cons
op_ne
l_int|NULL
op_logical_and
id|up-&gt;port.line
op_eq
id|up-&gt;port.cons-&gt;index
)paren
id|saw_console_brk
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * We do the SysRQ and SAK checking&n;&t;&t;&t;&t; * here because otherwise the break&n;&t;&t;&t;&t; * may get masked by ignore_status_mask&n;&t;&t;&t;&t; * or read_status_mask.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|uart_handle_break
c_func
(paren
op_amp
id|up-&gt;port
)paren
)paren
r_goto
id|ignore_char
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_PE
)paren
id|up-&gt;port.icount.parity
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_FE
)paren
id|up-&gt;port.icount.frame
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_OE
)paren
id|up-&gt;port.icount.overrun
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Mask off conditions which should be ingored.&n;&t;&t;&t; */
op_star
id|status
op_and_assign
id|up-&gt;port.read_status_mask
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.cons
op_ne
l_int|NULL
op_logical_and
id|up-&gt;port.line
op_eq
id|up-&gt;port.cons-&gt;index
)paren
(brace
multiline_comment|/* Recover the break flag from console xmit */
op_star
id|status
op_or_assign
id|up-&gt;lsr_break_flag
suffix:semicolon
id|up-&gt;lsr_break_flag
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_BI
)paren
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_BREAK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_PE
)paren
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_PARITY
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_FE
)paren
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_FRAME
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uart_handle_sysrq_char
c_func
(paren
op_amp
id|up-&gt;port
comma
id|ch
comma
id|regs
)paren
)paren
r_goto
id|ignore_char
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|status
op_amp
id|up-&gt;port.ignore_status_mask
)paren
op_eq
l_int|0
)paren
(brace
id|tty-&gt;flip.flag_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|status
op_amp
id|UART_LSR_OE
)paren
op_logical_and
id|tty-&gt;flip.count
OL
id|TTY_FLIPBUF_SIZE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Overrun is special, since it&squot;s reported&n;&t;&t;&t; * immediately, and doesn&squot;t affect the current&n;&t;&t;&t; * character.&n;&t;&t;&t; */
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_OVERRUN
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.count
op_increment
suffix:semicolon
)brace
id|ignore_char
suffix:colon
op_star
id|status
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
op_star
id|status
op_amp
id|UART_LSR_DR
)paren
op_logical_and
(paren
id|max_count
op_decrement
OG
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|saw_console_brk
)paren
id|sun_do_break
c_func
(paren
)paren
suffix:semicolon
r_return
id|tty
suffix:semicolon
)brace
DECL|function|transmit_chars
r_static
id|_INLINE_
r_void
id|transmit_chars
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
)paren
(brace
r_struct
id|circ_buf
op_star
id|xmit
op_assign
op_amp
id|up-&gt;port.info-&gt;xmit
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.x_char
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_TX
comma
id|up-&gt;port.x_char
)paren
suffix:semicolon
id|up-&gt;port.icount.tx
op_increment
suffix:semicolon
id|up-&gt;port.x_char
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
id|xmit
)paren
op_logical_or
id|uart_tx_stopped
c_func
(paren
op_amp
id|up-&gt;port
)paren
)paren
(brace
id|sunsu_stop_tx
c_func
(paren
op_amp
id|up-&gt;port
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|count
op_assign
id|up-&gt;port.fifosize
suffix:semicolon
r_do
(brace
id|serial_out
c_func
(paren
id|up
comma
id|UART_TX
comma
id|xmit-&gt;buf
(braket
id|xmit-&gt;tail
)braket
)paren
suffix:semicolon
id|xmit-&gt;tail
op_assign
(paren
id|xmit-&gt;tail
op_plus
l_int|1
)paren
op_amp
(paren
id|UART_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|up-&gt;port.icount.tx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
id|xmit
)paren
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_chars_pending
c_func
(paren
id|xmit
)paren
OL
id|WAKEUP_CHARS
)paren
id|uart_write_wakeup
c_func
(paren
op_amp
id|up-&gt;port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
id|xmit
)paren
)paren
id|sunsu_stop_tx
c_func
(paren
op_amp
id|up-&gt;port
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|check_modem_status
r_static
id|_INLINE_
r_void
id|check_modem_status
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|UART_MSR_ANY_DELTA
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_TERI
)paren
id|up-&gt;port.icount.rng
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DDSR
)paren
id|up-&gt;port.icount.dsr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DDCD
)paren
id|uart_handle_dcd_change
c_func
(paren
op_amp
id|up-&gt;port
comma
id|status
op_amp
id|UART_MSR_DCD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DCTS
)paren
id|uart_handle_cts_change
c_func
(paren
op_amp
id|up-&gt;port
comma
id|status
op_amp
id|UART_MSR_CTS
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|up-&gt;port.info-&gt;delta_msr_wait
)paren
suffix:semicolon
)brace
DECL|function|sunsu_serial_interrupt
r_static
id|irqreturn_t
id|sunsu_serial_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
id|dev_id
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_do
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|status
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
id|tty
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_LSR_DR
)paren
id|tty
op_assign
id|receive_chars
c_func
(paren
id|up
comma
op_amp
id|status
comma
id|regs
)paren
suffix:semicolon
id|check_modem_status
c_func
(paren
id|up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_LSR_THRE
)paren
id|transmit_chars
c_func
(paren
id|up
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
)paren
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_IIR
)paren
op_amp
id|UART_IIR_NO_INT
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* Separate interrupt handling path for keyboard/mouse ports.  */
r_static
r_void
id|sunsu_change_speed
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|cflag
comma
r_int
r_int
id|iflag
comma
r_int
r_int
id|quot
)paren
suffix:semicolon
DECL|function|sunsu_change_mouse_baud
r_static
r_void
id|sunsu_change_mouse_baud
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
)paren
(brace
r_int
r_int
id|cur_cflag
op_assign
id|up-&gt;cflag
suffix:semicolon
r_int
id|quot
comma
id|new_baud
suffix:semicolon
id|up-&gt;cflag
op_and_assign
op_complement
id|CBAUD
suffix:semicolon
id|up-&gt;cflag
op_or_assign
id|suncore_mouse_baud_cflag_next
c_func
(paren
id|cur_cflag
comma
op_amp
id|new_baud
)paren
suffix:semicolon
id|quot
op_assign
id|up-&gt;port.uartclk
op_div
(paren
l_int|16
op_star
id|new_baud
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
id|sunsu_change_speed
c_func
(paren
op_amp
id|up-&gt;port
comma
id|up-&gt;cflag
comma
l_int|0
comma
id|quot
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
)brace
DECL|function|receive_kbd_ms_chars
r_static
r_void
id|receive_kbd_ms_chars
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|is_break
)paren
(brace
r_do
(brace
r_int
r_char
id|ch
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
multiline_comment|/* Stop-A is handled by drivers/char/keyboard.c now. */
r_if
c_cond
(paren
id|up-&gt;su_type
op_eq
id|SU_PORT_KBD
)paren
(brace
macro_line|#ifdef CONFIG_SERIO
id|serio_interrupt
c_func
(paren
op_amp
id|up-&gt;serio
comma
id|ch
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|up-&gt;su_type
op_eq
id|SU_PORT_MS
)paren
(brace
r_int
id|ret
op_assign
id|suncore_mouse_baud_detection
c_func
(paren
id|ch
comma
id|is_break
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|2
suffix:colon
id|sunsu_change_mouse_baud
c_func
(paren
id|up
)paren
suffix:semicolon
multiline_comment|/* fallthru */
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
macro_line|#ifdef CONFIG_SERIO
id|serio_interrupt
c_func
(paren
op_amp
id|up-&gt;serio
comma
id|ch
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_LSR
)paren
op_amp
id|UART_LSR_DR
)paren
suffix:semicolon
)brace
DECL|function|sunsu_kbd_ms_interrupt
r_static
id|irqreturn_t
id|sunsu_kbd_ms_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_IIR
)paren
op_amp
id|UART_IIR_NO_INT
)paren
)paren
(brace
r_int
r_char
id|status
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|UART_LSR_DR
)paren
op_logical_or
(paren
id|status
op_amp
id|UART_LSR_BI
)paren
)paren
id|receive_kbd_ms_chars
c_func
(paren
id|up
comma
id|regs
comma
(paren
id|status
op_amp
id|UART_LSR_BI
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|function|sunsu_tx_empty
r_static
r_int
r_int
id|sunsu_tx_empty
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_sunsu_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_LSR
)paren
op_amp
id|UART_LSR_TEMT
ques
c_cond
id|TIOCSER_TEMT
suffix:colon
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sunsu_get_mctrl
r_static
r_int
r_int
id|sunsu_get_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_sunsu_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DCD
)paren
id|ret
op_or_assign
id|TIOCM_CAR
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_RI
)paren
id|ret
op_or_assign
id|TIOCM_RNG
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DSR
)paren
id|ret
op_or_assign
id|TIOCM_DSR
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_CTS
)paren
id|ret
op_or_assign
id|TIOCM_CTS
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sunsu_set_mctrl
r_static
r_void
id|sunsu_set_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|mctrl
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_sunsu_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_char
id|mcr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_RTS
)paren
id|mcr
op_or_assign
id|UART_MCR_RTS
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_DTR
)paren
id|mcr
op_or_assign
id|UART_MCR_DTR
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_OUT1
)paren
id|mcr
op_or_assign
id|UART_MCR_OUT1
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_OUT2
)paren
id|mcr
op_or_assign
id|UART_MCR_OUT2
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_LOOP
)paren
id|mcr
op_or_assign
id|UART_MCR_LOOP
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|mcr
)paren
suffix:semicolon
)brace
DECL|function|sunsu_break_ctl
r_static
r_void
id|sunsu_break_ctl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
id|break_state
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_sunsu_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|break_state
op_eq
op_minus
l_int|1
)paren
id|up-&gt;lcr
op_or_assign
id|UART_LCR_SBC
suffix:semicolon
r_else
id|up-&gt;lcr
op_and_assign
op_complement
id|UART_LCR_SBC
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|up-&gt;lcr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|sunsu_startup
r_static
r_int
id|sunsu_startup
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_sunsu_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_16C950
)paren
(brace
multiline_comment|/* Wake up and initialize UART */
id|up-&gt;acr
op_assign
l_int|0
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_EFR
comma
id|UART_EFR_ECB
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
id|serial_icr_write
c_func
(paren
id|up
comma
id|UART_CSR
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Reset the UART */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_EFR
comma
id|UART_EFR_ECB
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SERIAL_8250_RSA
multiline_comment|/*&n;&t; * If this is an RSA port, see if we can kick it up to the&n;&t; * higher speed clock.&n;&t; */
id|enable_rsa
c_func
(paren
id|up
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Clear the FIFO buffers and disable them.&n;&t; * (they will be reeanbled in set_termios())&n;&t; */
r_if
c_cond
(paren
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|flags
op_amp
id|UART_CLEAR_FIFO
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear the interrupt registers.&n;&t; */
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IIR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, there&squot;s no way the LSR could still be 0xff;&n;&t; * if it is, then bail out, because there&squot;s likely no UART&n;&t; * here.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|up-&gt;port.flags
op_amp
id|ASYNC_BUGGY_UART
)paren
op_logical_and
(paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
op_eq
l_int|0xff
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ttyS%d: LSR safety check engaged!&bslash;n&quot;
comma
id|up-&gt;port.line
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up-&gt;su_type
op_ne
id|SU_PORT_PORT
)paren
(brace
id|retval
op_assign
id|request_irq
c_func
(paren
id|up-&gt;irq
comma
id|sunsu_kbd_ms_interrupt
comma
id|SA_SHIRQ
comma
id|su_typev
(braket
id|up-&gt;su_type
)braket
comma
id|up
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|request_irq
c_func
(paren
id|up-&gt;irq
comma
id|sunsu_serial_interrupt
comma
id|SA_SHIRQ
comma
id|su_typev
(braket
id|up-&gt;su_type
)braket
comma
id|up
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;su: Cannot register IRQ %d&bslash;n&quot;
comma
id|up-&gt;irq
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now, initialize the UART&n;&t; */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|UART_LCR_WLEN8
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|up-&gt;port.mctrl
op_or_assign
id|TIOCM_OUT2
suffix:semicolon
id|sunsu_set_mctrl
c_func
(paren
op_amp
id|up-&gt;port
comma
id|up-&gt;port.mctrl
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Finally, enable interrupts.  Note: Modem status interrupts&n;&t; * are set via set_termios(), which will be occurring imminently&n;&t; * anyway, so we don&squot;t enable them here.&n;&t; */
id|up-&gt;ier
op_assign
id|UART_IER_RLSI
op_or
id|UART_IER_RDI
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|ASYNC_FOURPORT
)paren
(brace
r_int
r_int
id|icp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Enable interrupts on the AST Fourport board&n;&t;&t; */
id|icp
op_assign
(paren
id|up-&gt;port.iobase
op_amp
l_int|0xfe0
)paren
op_or
l_int|0x01f
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x80
comma
id|icp
)paren
suffix:semicolon
(paren
r_void
)paren
id|inb_p
c_func
(paren
id|icp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * And clear the interrupt registers again for luck.&n;&t; */
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IIR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sunsu_shutdown
r_static
r_void
id|sunsu_shutdown
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_sunsu_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Disable interrupts from this port&n;&t; */
id|up-&gt;ier
op_assign
l_int|0
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|ASYNC_FOURPORT
)paren
(brace
multiline_comment|/* reset interrupts on the AST Fourport board */
id|inb
c_func
(paren
(paren
id|up-&gt;port.iobase
op_amp
l_int|0xfe0
)paren
op_or
l_int|0x1f
)paren
suffix:semicolon
id|up-&gt;port.mctrl
op_or_assign
id|TIOCM_OUT1
suffix:semicolon
)brace
r_else
id|up-&gt;port.mctrl
op_and_assign
op_complement
id|TIOCM_OUT2
suffix:semicolon
id|sunsu_set_mctrl
c_func
(paren
op_amp
id|up-&gt;port
comma
id|up-&gt;port.mctrl
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable break condition and FIFOs&n;&t; */
id|serial_out
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LCR
)paren
op_amp
op_complement
id|UART_LCR_SBC
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SERIAL_8250_RSA
multiline_comment|/*&n;&t; * Reset the RSA board back to 115kbps compat mode.&n;&t; */
id|disable_rsa
c_func
(paren
id|up
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Read data port to reset things.&n;&t; */
(paren
r_void
)paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|up-&gt;irq
comma
id|up
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|sunsu_change_speed
id|sunsu_change_speed
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|cflag
comma
r_int
r_int
id|iflag
comma
r_int
r_int
id|quot
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_sunsu_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_char
id|cval
comma
id|fcr
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_switch
c_cond
(paren
id|cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|cval
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|cval
op_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|cval
op_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
id|CS8
suffix:colon
id|cval
op_assign
l_int|0x03
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|CSTOPB
)paren
id|cval
op_or_assign
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_amp
id|PARENB
)paren
id|cval
op_or_assign
id|UART_LCR_PARITY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cflag
op_amp
id|PARODD
)paren
)paren
id|cval
op_or_assign
id|UART_LCR_EPAR
suffix:semicolon
macro_line|#ifdef CMSPAR
r_if
c_cond
(paren
id|cflag
op_amp
id|CMSPAR
)paren
id|cval
op_or_assign
id|UART_LCR_SPAR
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Work around a bug in the Oxford Semiconductor 952 rev B&n;&t; * chip which causes it to seriously miscalculate baud rates&n;&t; * when DLL is 0.&n;&t; */
r_if
c_cond
(paren
(paren
id|quot
op_amp
l_int|0xff
)paren
op_eq
l_int|0
op_logical_and
id|up-&gt;port.type
op_eq
id|PORT_16C950
op_logical_and
id|up-&gt;rev
op_eq
l_int|0x5201
)paren
id|quot
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|flags
op_amp
id|UART_USE_FIFO
)paren
(brace
r_if
c_cond
(paren
(paren
id|up-&gt;port.uartclk
op_div
id|quot
)paren
OL
(paren
l_int|2400
op_star
l_int|16
)paren
)paren
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_TRIGGER_1
suffix:semicolon
macro_line|#ifdef CONFIG_SERIAL_8250_RSA
r_else
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_RSA
)paren
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_TRIGGER_14
suffix:semicolon
macro_line|#endif
r_else
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_TRIGGER_8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_16750
)paren
id|fcr
op_or_assign
id|UART_FCR7_64BYTE
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, we&squot;re now changing the port state.  Do it with&n;&t; * interrupts disabled.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update the per-port timeout.&n;&t; */
id|uart_update_timeout
c_func
(paren
id|port
comma
id|cflag
comma
(paren
id|port-&gt;uartclk
op_div
(paren
l_int|16
op_star
id|quot
)paren
)paren
)paren
suffix:semicolon
id|up-&gt;port.read_status_mask
op_assign
id|UART_LSR_OE
op_or
id|UART_LSR_THRE
op_or
id|UART_LSR_DR
suffix:semicolon
r_if
c_cond
(paren
id|iflag
op_amp
id|INPCK
)paren
id|up-&gt;port.read_status_mask
op_or_assign
id|UART_LSR_FE
op_or
id|UART_LSR_PE
suffix:semicolon
r_if
c_cond
(paren
id|iflag
op_amp
(paren
id|BRKINT
op_or
id|PARMRK
)paren
)paren
id|up-&gt;port.read_status_mask
op_or_assign
id|UART_LSR_BI
suffix:semicolon
multiline_comment|/*&n;&t; * Characteres to ignore&n;&t; */
id|up-&gt;port.ignore_status_mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iflag
op_amp
id|IGNPAR
)paren
id|up-&gt;port.ignore_status_mask
op_or_assign
id|UART_LSR_PE
op_or
id|UART_LSR_FE
suffix:semicolon
r_if
c_cond
(paren
id|iflag
op_amp
id|IGNBRK
)paren
(brace
id|up-&gt;port.ignore_status_mask
op_or_assign
id|UART_LSR_BI
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;re ignoring parity and break indicators,&n;&t;&t; * ignore overruns too (for real raw support).&n;&t;&t; */
r_if
c_cond
(paren
id|iflag
op_amp
id|IGNPAR
)paren
id|up-&gt;port.ignore_status_mask
op_or_assign
id|UART_LSR_OE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ignore all characters if CREAD is not set&n;&t; */
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CREAD
)paren
op_eq
l_int|0
)paren
id|up-&gt;port.ignore_status_mask
op_or_assign
id|UART_LSR_DR
suffix:semicolon
multiline_comment|/*&n;&t; * CTS flow control flag and modem status interrupts&n;&t; */
id|up-&gt;ier
op_and_assign
op_complement
id|UART_IER_MSI
suffix:semicolon
r_if
c_cond
(paren
id|UART_ENABLE_MS
c_func
(paren
op_amp
id|up-&gt;port
comma
id|cflag
)paren
)paren
id|up-&gt;ier
op_or_assign
id|UART_IER_MSI
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|flags
op_amp
id|UART_STARTECH
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_EFR
comma
id|cflag
op_amp
id|CRTSCTS
ques
c_cond
id|UART_EFR_CTS
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|cval
op_or
id|UART_LCR_DLAB
)paren
suffix:semicolon
multiline_comment|/* set DLAB */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_DLL
comma
id|quot
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* LS of divisor */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_DLM
comma
id|quot
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* MS of divisor */
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_16750
)paren
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|fcr
)paren
suffix:semicolon
multiline_comment|/* set fcr */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|cval
)paren
suffix:semicolon
multiline_comment|/* reset DLAB */
id|up-&gt;lcr
op_assign
id|cval
suffix:semicolon
multiline_comment|/* Save LCR */
r_if
c_cond
(paren
id|up-&gt;port.type
op_ne
id|PORT_16750
)paren
(brace
r_if
c_cond
(paren
id|fcr
op_amp
id|UART_FCR_ENABLE_FIFO
)paren
(brace
multiline_comment|/* emulated UARTs (Lucent Venus 167x) need two steps */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
)brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|fcr
)paren
suffix:semicolon
multiline_comment|/* set fcr */
)brace
id|up-&gt;cflag
op_assign
id|cflag
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|sunsu_set_termios
id|sunsu_set_termios
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|termios
op_star
id|termios
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
r_int
r_int
id|baud
comma
id|quot
suffix:semicolon
multiline_comment|/*&n;&t; * Ask the core to calculate the divisor for us.&n;&t; */
id|baud
op_assign
id|uart_get_baud_rate
c_func
(paren
id|port
comma
id|termios
comma
id|old
comma
l_int|0
comma
id|port-&gt;uartclk
op_div
l_int|16
)paren
suffix:semicolon
id|quot
op_assign
id|uart_get_divisor
c_func
(paren
id|port
comma
id|baud
)paren
suffix:semicolon
id|sunsu_change_speed
c_func
(paren
id|port
comma
id|termios-&gt;c_cflag
comma
id|termios-&gt;c_iflag
comma
id|quot
)paren
suffix:semicolon
)brace
DECL|function|sunsu_release_port
r_static
r_void
id|sunsu_release_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
)brace
DECL|function|sunsu_request_port
r_static
r_int
id|sunsu_request_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sunsu_config_port
r_static
r_void
id|sunsu_config_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
id|flags
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_sunsu_port
op_star
)paren
id|port
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UART_CONFIG_TYPE
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are supposed to call autoconfig here, but this requires&n;&t;&t; * splitting all the OBP probing crap from the UART probing.&n;&t;&t; * We&squot;ll do it when we kill sunsu.c altogether.&n;&t;&t; */
id|port-&gt;type
op_assign
id|up-&gt;type_probed
suffix:semicolon
multiline_comment|/* XXX */
)brace
)brace
r_static
r_int
DECL|function|sunsu_verify_port
id|sunsu_verify_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|serial_struct
op_star
id|ser
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_static
r_const
r_char
op_star
DECL|function|sunsu_type
id|sunsu_type
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_int
id|type
op_assign
id|port-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|ARRAY_SIZE
c_func
(paren
id|uart_config
)paren
)paren
id|type
op_assign
l_int|0
suffix:semicolon
r_return
id|uart_config
(braket
id|type
)braket
dot
id|name
suffix:semicolon
)brace
DECL|variable|sunsu_pops
r_static
r_struct
id|uart_ops
id|sunsu_pops
op_assign
(brace
dot
id|tx_empty
op_assign
id|sunsu_tx_empty
comma
dot
id|set_mctrl
op_assign
id|sunsu_set_mctrl
comma
dot
id|get_mctrl
op_assign
id|sunsu_get_mctrl
comma
dot
id|stop_tx
op_assign
id|sunsu_stop_tx
comma
dot
id|start_tx
op_assign
id|sunsu_start_tx
comma
dot
id|stop_rx
op_assign
id|sunsu_stop_rx
comma
dot
id|enable_ms
op_assign
id|sunsu_enable_ms
comma
dot
id|break_ctl
op_assign
id|sunsu_break_ctl
comma
dot
id|startup
op_assign
id|sunsu_startup
comma
dot
id|shutdown
op_assign
id|sunsu_shutdown
comma
dot
id|set_termios
op_assign
id|sunsu_set_termios
comma
dot
id|type
op_assign
id|sunsu_type
comma
dot
id|release_port
op_assign
id|sunsu_release_port
comma
dot
id|request_port
op_assign
id|sunsu_request_port
comma
dot
id|config_port
op_assign
id|sunsu_config_port
comma
dot
id|verify_port
op_assign
id|sunsu_verify_port
comma
)brace
suffix:semicolon
DECL|macro|UART_NR
mdefine_line|#define UART_NR&t;4
DECL|variable|sunsu_ports
r_static
r_struct
id|uart_sunsu_port
id|sunsu_ports
(braket
id|UART_NR
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_SERIO
DECL|variable|sunsu_serio_lock
r_static
id|spinlock_t
id|sunsu_serio_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|sunsu_serio_write
r_static
r_int
id|sunsu_serio_write
c_func
(paren
r_struct
id|serio
op_star
id|serio
comma
r_int
r_char
id|ch
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
id|serio-&gt;port_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|lsr
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sunsu_serio_lock
comma
id|flags
)paren
suffix:semicolon
r_do
(brace
id|lsr
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|lsr
op_amp
id|UART_LSR_THRE
)paren
)paren
suffix:semicolon
multiline_comment|/* Send the character out. */
id|serial_out
c_func
(paren
id|up
comma
id|UART_TX
comma
id|ch
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sunsu_serio_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sunsu_serio_open
r_static
r_int
id|sunsu_serio_open
c_func
(paren
r_struct
id|serio
op_star
id|serio
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
id|serio-&gt;port_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sunsu_serio_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|up-&gt;serio_open
)paren
(brace
id|up-&gt;serio_open
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sunsu_serio_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sunsu_serio_close
r_static
r_void
id|sunsu_serio_close
c_func
(paren
r_struct
id|serio
op_star
id|serio
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
id|serio-&gt;port_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sunsu_serio_lock
comma
id|flags
)paren
suffix:semicolon
id|up-&gt;serio_open
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sunsu_serio_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SERIO */
DECL|function|sunsu_autoconfig
r_static
r_void
id|sunsu_autoconfig
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
)paren
(brace
r_int
r_char
id|status1
comma
id|status2
comma
id|scratch
comma
id|scratch2
comma
id|scratch3
suffix:semicolon
r_int
r_char
id|save_lcr
comma
id|save_mcr
suffix:semicolon
r_struct
id|linux_ebus_device
op_star
id|dev
op_assign
l_int|0
suffix:semicolon
r_struct
id|linux_ebus
op_star
id|ebus
suffix:semicolon
macro_line|#ifdef CONFIG_SPARC64
r_struct
id|sparc_isa_bridge
op_star
id|isa_br
suffix:semicolon
r_struct
id|sparc_isa_device
op_star
id|isa_dev
suffix:semicolon
macro_line|#endif
macro_line|#ifndef CONFIG_SPARC64
r_struct
id|linux_prom_registers
id|reg0
suffix:semicolon
macro_line|#endif
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|up-&gt;port_node
op_logical_or
op_logical_neg
id|up-&gt;su_type
)paren
r_return
suffix:semicolon
id|up-&gt;type_probed
op_assign
id|PORT_UNKNOWN
suffix:semicolon
id|up-&gt;port.iotype
op_assign
id|SERIAL_IO_MEM
suffix:semicolon
multiline_comment|/*&n;&t; * First we look for Ebus-bases su&squot;s&n;&t; */
id|for_each_ebus
c_func
(paren
id|ebus
)paren
(brace
id|for_each_ebusdev
c_func
(paren
id|dev
comma
id|ebus
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;prom_node
op_eq
id|up-&gt;port_node
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The EBus is broken on sparc; it delivers&n;&t;&t;&t;&t; * virtual addresses in resources. Oh well...&n;&t;&t;&t;&t; * This is correct on sparc64, though.&n;&t;&t;&t;&t; */
id|up-&gt;port.membase
op_assign
(paren
r_char
op_star
)paren
id|dev-&gt;resource
(braket
l_int|0
)braket
dot
id|start
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * This is correct on both architectures.&n;&t;&t;&t;&t; */
id|up-&gt;port.mapbase
op_assign
id|dev-&gt;resource
(braket
l_int|0
)braket
dot
id|start
suffix:semicolon
id|up-&gt;irq
op_assign
id|dev-&gt;irqs
(braket
l_int|0
)braket
suffix:semicolon
r_goto
id|ebus_done
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef CONFIG_SPARC64
id|for_each_isa
c_func
(paren
id|isa_br
)paren
(brace
id|for_each_isadev
c_func
(paren
id|isa_dev
comma
id|isa_br
)paren
(brace
r_if
c_cond
(paren
id|isa_dev-&gt;prom_node
op_eq
id|up-&gt;port_node
)paren
(brace
multiline_comment|/* Same on sparc64. Cool architecure... */
id|up-&gt;port.membase
op_assign
(paren
r_char
op_star
)paren
id|isa_dev-&gt;resource.start
suffix:semicolon
id|up-&gt;port.mapbase
op_assign
id|isa_dev-&gt;resource.start
suffix:semicolon
id|up-&gt;irq
op_assign
id|isa_dev-&gt;irq
suffix:semicolon
r_goto
id|ebus_done
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_SPARC64
multiline_comment|/*&n;&t; * Not on Ebus, bailing.&n;&t; */
r_return
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;&t; * Not on Ebus, must be OBIO.&n;&t; */
r_if
c_cond
(paren
id|prom_getproperty
c_func
(paren
id|up-&gt;port_node
comma
l_string|&quot;reg&quot;
comma
(paren
r_char
op_star
)paren
op_amp
id|reg0
comma
r_sizeof
(paren
id|reg0
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;sunsu: no &bslash;&quot;reg&bslash;&quot; property&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prom_apply_obio_ranges
c_func
(paren
op_amp
id|reg0
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg0.which_io
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Just in case... */
id|prom_printf
c_func
(paren
l_string|&quot;sunsu: bus number nonzero: 0x%x:%x&bslash;n&quot;
comma
id|reg0.which_io
comma
id|reg0.phys_addr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|up-&gt;port.mapbase
op_assign
id|reg0.phys_addr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|up-&gt;port.membase
op_assign
id|ioremap
c_func
(paren
id|reg0.phys_addr
comma
id|reg0.reg_size
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;sunsu: Cannot map registers.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * 0x20 is sun4m thing, Dave Redman heritage.&n;&t; * See arch/sparc/kernel/irq.c.&n;&t; */
mdefine_line|#define IRQ_4M(n)&t;((n)|0x20)
multiline_comment|/*&n;&t; * There is no intr property on MrCoffee, so hardwire it.&n;&t; */
id|up-&gt;irq
op_assign
id|IRQ_4M
c_func
(paren
l_int|13
)paren
suffix:semicolon
macro_line|#endif
id|ebus_done
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|up-&gt;port.flags
op_amp
id|ASYNC_BUGGY_UART
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Do a simple existence test first; if we fail this, there&squot;s&n;&t;&t; * no point trying anything else.&n;&t;&t; *&n;&t;&t; * 0x80 is used as a nonsense port to prevent against false&n;&t;&t; * positives due to ISA bus float.  The assumption is that&n;&t;&t; * 0x80 is a non-existent port; which should be safe since&n;&t;&t; * include/asm/io.h also makes this assumption.&n;&t;&t; */
id|scratch
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IER
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef __i386__
id|outb
c_func
(paren
l_int|0xff
comma
l_int|0x080
)paren
suffix:semicolon
macro_line|#endif
id|scratch2
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IER
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0x0f
)paren
suffix:semicolon
macro_line|#ifdef __i386__
id|outb
c_func
(paren
l_int|0
comma
l_int|0x080
)paren
suffix:semicolon
macro_line|#endif
id|scratch3
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IER
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
id|scratch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scratch2
op_ne
l_int|0
op_logical_or
id|scratch3
op_ne
l_int|0x0F
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* We failed; there&squot;s nothing here */
)brace
id|save_mcr
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_MCR
)paren
suffix:semicolon
id|save_lcr
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Check to see if a UART is really there.  Certain broken&n;&t; * internal modems based on the Rockwell chipset fail this&n;&t; * test, because they apparently don&squot;t implement the loopback&n;&t; * test mode.  So this test is skipped on the COM 1 through&n;&t; * COM 4 ports.  This *should* be safe, since no board&n;&t; * manufacturer would be stupid enough to design a board&n;&t; * that conflicts with COM 1-4 --- we hope!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|up-&gt;port.flags
op_amp
id|ASYNC_SKIP_TEST
)paren
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|UART_MCR_LOOP
op_or
l_int|0x0A
)paren
suffix:semicolon
id|status1
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_MSR
)paren
op_amp
l_int|0xF0
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|save_mcr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status1
op_ne
l_int|0x90
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* We failed loopback test */
)brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
multiline_comment|/* set up for StarTech test */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_EFR
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* EFR is the same as FCR */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
id|scratch
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IIR
)paren
op_rshift
l_int|6
suffix:semicolon
r_switch
c_cond
(paren
id|scratch
)paren
(brace
r_case
l_int|0
suffix:colon
id|up-&gt;port.type
op_assign
id|PORT_16450
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|up-&gt;port.type
op_assign
id|PORT_UNKNOWN
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|up-&gt;port.type
op_assign
id|PORT_16550
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|up-&gt;port.type
op_assign
id|PORT_16550A
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_16550A
)paren
(brace
multiline_comment|/* Check for Startech UART&squot;s */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|UART_LCR_DLAB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_EFR
)paren
op_eq
l_int|0
)paren
(brace
id|up-&gt;port.type
op_assign
id|PORT_16650
suffix:semicolon
)brace
r_else
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_EFR
)paren
op_eq
l_int|0
)paren
id|up-&gt;port.type
op_assign
id|PORT_16650V2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_16550A
)paren
(brace
multiline_comment|/* Check for TI 16750 */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|save_lcr
op_or
id|UART_LCR_DLAB
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR7_64BYTE
)paren
suffix:semicolon
id|scratch
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IIR
)paren
op_rshift
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|scratch
op_eq
l_int|7
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If this is a 16750, and not a cheap UART&n;&t;&t;&t; * clone, then it should only go into 64 byte&n;&t;&t;&t; * mode if the UART_FCR7_64BYTE bit was set&n;&t;&t;&t; * while UART_LCR_DLAB was latched.&n;&t;&t;&t; */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR7_64BYTE
)paren
suffix:semicolon
id|scratch
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IIR
)paren
op_rshift
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|scratch
op_eq
l_int|6
)paren
id|up-&gt;port.type
op_assign
id|PORT_16750
suffix:semicolon
)brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
)brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|save_lcr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_16450
)paren
(brace
id|scratch
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_SCR
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_SCR
comma
l_int|0xa5
)paren
suffix:semicolon
id|status1
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_SCR
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_SCR
comma
l_int|0x5a
)paren
suffix:semicolon
id|status2
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_SCR
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_SCR
comma
id|scratch
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status1
op_ne
l_int|0xa5
)paren
op_logical_or
(paren
id|status2
op_ne
l_int|0x5a
)paren
)paren
id|up-&gt;port.type
op_assign
id|PORT_8250
suffix:semicolon
)brace
id|up-&gt;port.fifosize
op_assign
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|dfl_xmit_fifo_size
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_UNKNOWN
)paren
r_goto
id|out
suffix:semicolon
id|up-&gt;type_probed
op_assign
id|up-&gt;port.type
suffix:semicolon
multiline_comment|/* XXX */
multiline_comment|/*&n;&t; * Reset the UART.&n;&t; */
macro_line|#ifdef CONFIG_SERIAL_8250_RSA
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_RSA
)paren
id|serial_outp
c_func
(paren
id|up
comma
id|UART_RSA_FRR
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|save_mcr
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
(paren
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
)paren
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|sunsu_reg
r_static
r_struct
id|uart_driver
id|sunsu_reg
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|driver_name
op_assign
l_string|&quot;serial&quot;
comma
dot
id|devfs_name
op_assign
l_string|&quot;tts/&quot;
comma
dot
id|dev_name
op_assign
l_string|&quot;ttyS&quot;
comma
dot
id|major
op_assign
id|TTY_MAJOR
comma
)brace
suffix:semicolon
DECL|function|sunsu_kbd_ms_init
r_static
r_int
id|__init
id|sunsu_kbd_ms_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|up
op_assign
id|sunsu_ports
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
comma
id|up
op_increment
)paren
(brace
id|up-&gt;port.line
op_assign
id|i
suffix:semicolon
id|up-&gt;port.type
op_assign
id|PORT_UNKNOWN
suffix:semicolon
id|up-&gt;port.uartclk
op_assign
(paren
id|SU_BASE_BAUD
op_star
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;su_type
op_eq
id|SU_PORT_KBD
)paren
id|up-&gt;cflag
op_assign
id|B1200
op_or
id|CS8
op_or
id|CLOCAL
op_or
id|CREAD
suffix:semicolon
r_else
id|up-&gt;cflag
op_assign
id|B4800
op_or
id|CS8
op_or
id|CLOCAL
op_or
id|CREAD
suffix:semicolon
id|sunsu_autoconfig
c_func
(paren
id|up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_UNKNOWN
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;su%d at 0x%p (irq = %s) is a %s&bslash;n&quot;
comma
id|i
comma
id|up-&gt;port.membase
comma
id|__irq_itoa
c_func
(paren
id|up-&gt;irq
)paren
comma
id|sunsu_type
c_func
(paren
op_amp
id|up-&gt;port
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SERIO
id|memset
c_func
(paren
op_amp
id|up-&gt;serio
comma
l_int|0
comma
r_sizeof
(paren
id|up-&gt;serio
)paren
)paren
suffix:semicolon
id|up-&gt;serio.port_data
op_assign
id|up
suffix:semicolon
id|up-&gt;serio.type
op_assign
id|SERIO_RS232
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;su_type
op_eq
id|SU_PORT_KBD
)paren
(brace
id|up-&gt;serio.type
op_or_assign
id|SERIO_SUNKBD
suffix:semicolon
id|up-&gt;serio.name
op_assign
l_string|&quot;sukbd&quot;
suffix:semicolon
)brace
r_else
(brace
id|up-&gt;serio.type
op_or_assign
(paren
id|SERIO_SUN
op_or
(paren
l_int|1
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
id|up-&gt;serio.name
op_assign
l_string|&quot;sums&quot;
suffix:semicolon
)brace
id|up-&gt;serio.phys
op_assign
(paren
id|i
op_eq
l_int|0
ques
c_cond
l_string|&quot;su/serio0&quot;
suffix:colon
l_string|&quot;su/serio1&quot;
)paren
suffix:semicolon
id|up-&gt;serio.write
op_assign
id|sunsu_serio_write
suffix:semicolon
id|up-&gt;serio.open
op_assign
id|sunsu_serio_open
suffix:semicolon
id|up-&gt;serio.close
op_assign
id|sunsu_serio_close
suffix:semicolon
id|serio_register_port
c_func
(paren
op_amp
id|up-&gt;serio
)paren
suffix:semicolon
macro_line|#endif
id|sunsu_startup
c_func
(paren
op_amp
id|up-&gt;port
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ------------------------------------------------------------&n; * Serial console driver&n; * ------------------------------------------------------------&n; */
macro_line|#ifdef CONFIG_SERIAL_SUNSU_CONSOLE
DECL|macro|BOTH_EMPTY
mdefine_line|#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
multiline_comment|/*&n; *&t;Wait for transmitter &amp; holding register to empty&n; */
DECL|function|wait_for_xmitr
r_static
id|__inline__
r_void
id|wait_for_xmitr
c_func
(paren
r_struct
id|uart_sunsu_port
op_star
id|up
)paren
(brace
r_int
r_int
id|status
comma
id|tmout
op_assign
l_int|10000
suffix:semicolon
multiline_comment|/* Wait up to 10ms for the character(s) to be sent. */
r_do
(brace
id|status
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_LSR_BI
)paren
id|up-&gt;lsr_break_flag
op_assign
id|UART_LSR_BI
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|tmout
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|status
op_amp
id|BOTH_EMPTY
)paren
op_ne
id|BOTH_EMPTY
)paren
suffix:semicolon
multiline_comment|/* Wait up to 1s for flow control if necessary */
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|ASYNC_CONS_FLOW
)paren
(brace
id|tmout
op_assign
l_int|1000000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|tmout
op_logical_and
(paren
(paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_MSR
)paren
op_amp
id|UART_MSR_CTS
)paren
op_eq
l_int|0
)paren
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Print a string to the serial port trying not to disturb&n; *&t;any possible real use of the port...&n; */
DECL|function|sunsu_console_write
r_static
r_void
id|sunsu_console_write
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_const
r_char
op_star
id|s
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
op_amp
id|sunsu_ports
(braket
id|co-&gt;index
)braket
suffix:semicolon
r_int
r_int
id|ier
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;First save the UER then disable the interrupts&n;&t; */
id|ier
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IER
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now, do each character&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|s
op_increment
)paren
(brace
id|wait_for_xmitr
c_func
(paren
id|up
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Send the character out.&n;&t;&t; *&t;If a LF, also do CR...&n;&t;&t; */
id|serial_out
c_func
(paren
id|up
comma
id|UART_TX
comma
op_star
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_eq
l_int|10
)paren
(brace
id|wait_for_xmitr
c_func
(paren
id|up
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_TX
comma
l_int|13
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Finally, wait for transmitter to become empty&n;&t; *&t;and restore the IER&n;&t; */
id|wait_for_xmitr
c_func
(paren
id|up
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|ier
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Setup initial baud/bits/parity. We do two things here:&n; *&t;- construct a cflag setting for the first su_open()&n; *&t;- initialize the serial port&n; *&t;Return non-zero if we didn&squot;t find a serial port.&n; */
DECL|function|sunsu_console_setup
r_static
r_int
id|__init
id|sunsu_console_setup
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_char
op_star
id|options
)paren
(brace
r_struct
id|uart_port
op_star
id|port
suffix:semicolon
r_int
id|baud
op_assign
l_int|9600
suffix:semicolon
r_int
id|bits
op_assign
l_int|8
suffix:semicolon
r_int
id|parity
op_assign
l_char|&squot;n&squot;
suffix:semicolon
r_int
id|flow
op_assign
l_char|&squot;n&squot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Console: ttyS%d (SU)&bslash;n&quot;
comma
(paren
id|sunsu_reg.minor
op_minus
l_int|64
)paren
op_plus
id|co-&gt;index
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check whether an invalid uart number has been specified, and&n;&t; * if so, search for the first available port that does have&n;&t; * console support.&n;&t; */
r_if
c_cond
(paren
id|co-&gt;index
op_ge
id|UART_NR
)paren
id|co-&gt;index
op_assign
l_int|0
suffix:semicolon
id|port
op_assign
op_amp
id|sunsu_ports
(braket
id|co-&gt;index
)braket
dot
id|port
suffix:semicolon
multiline_comment|/*&n;&t; * Temporary fix.&n;&t; */
id|spin_lock_init
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options
)paren
id|uart_parse_options
c_func
(paren
id|options
comma
op_amp
id|baud
comma
op_amp
id|parity
comma
op_amp
id|bits
comma
op_amp
id|flow
)paren
suffix:semicolon
r_return
id|uart_set_options
c_func
(paren
id|port
comma
id|co
comma
id|baud
comma
id|parity
comma
id|bits
comma
id|flow
)paren
suffix:semicolon
)brace
DECL|variable|sunsu_cons
r_static
r_struct
id|console
id|sunsu_cons
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ttyS&quot;
comma
dot
id|write
op_assign
id|sunsu_console_write
comma
dot
id|device
op_assign
id|uart_console_device
comma
dot
id|setup
op_assign
id|sunsu_console_setup
comma
dot
id|flags
op_assign
id|CON_PRINTBUFFER
comma
dot
id|index
op_assign
op_minus
l_int|1
comma
dot
id|data
op_assign
op_amp
id|sunsu_reg
comma
)brace
suffix:semicolon
DECL|macro|SUNSU_CONSOLE
mdefine_line|#define SUNSU_CONSOLE&t;(&amp;sunsu_cons)
multiline_comment|/*&n; *&t;Register console.&n; */
DECL|function|sunsu_serial_console_init
r_static
r_int
id|__init
id|sunsu_serial_console_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|con_is_present
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UART_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|this_minor
op_assign
id|sunsu_reg.minor
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|this_minor
op_minus
l_int|64
)paren
op_eq
(paren
id|serial_console
op_minus
l_int|1
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|UART_NR
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sunsu_ports
(braket
id|i
)braket
dot
id|port_node
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|sunsu_cons.index
op_assign
id|i
suffix:semicolon
id|register_console
c_func
(paren
op_amp
id|sunsu_cons
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|macro|SUNSU_CONSOLE
mdefine_line|#define SUNSU_CONSOLE&t;&t;&t;(NULL)
DECL|macro|sunsu_serial_console_init
mdefine_line|#define sunsu_serial_console_init()&t;do { } while (0)
macro_line|#endif
DECL|function|sunsu_serial_init
r_static
r_int
id|__init
id|sunsu_serial_init
c_func
(paren
r_void
)paren
(brace
r_int
id|instance
comma
id|ret
comma
id|i
suffix:semicolon
multiline_comment|/* How many instances do we need?  */
id|instance
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UART_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
op_amp
id|sunsu_ports
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;su_type
op_eq
id|SU_PORT_MS
op_logical_or
id|up-&gt;su_type
op_eq
id|SU_PORT_KBD
)paren
r_continue
suffix:semicolon
id|up-&gt;port.flags
op_or_assign
id|ASYNC_BOOT_AUTOCONF
suffix:semicolon
id|up-&gt;port.type
op_assign
id|PORT_UNKNOWN
suffix:semicolon
id|up-&gt;port.uartclk
op_assign
(paren
id|SU_BASE_BAUD
op_star
l_int|16
)paren
suffix:semicolon
id|sunsu_autoconfig
c_func
(paren
id|up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_UNKNOWN
)paren
r_continue
suffix:semicolon
id|up-&gt;port.line
op_assign
id|instance
op_increment
suffix:semicolon
id|up-&gt;port.ops
op_assign
op_amp
id|sunsu_pops
suffix:semicolon
)brace
id|sunsu_reg.minor
op_assign
id|sunserial_current_minor
suffix:semicolon
id|sunserial_current_minor
op_add_assign
id|instance
suffix:semicolon
id|sunsu_reg.nr
op_assign
id|instance
suffix:semicolon
id|sunsu_reg.cons
op_assign
id|SUNSU_CONSOLE
suffix:semicolon
id|ret
op_assign
id|uart_register_driver
c_func
(paren
op_amp
id|sunsu_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UART_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
op_amp
id|sunsu_ports
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Do not register Keyboard/Mouse lines with UART&n;&t;&t; * layer.&n;&t;&t; */
r_if
c_cond
(paren
id|up-&gt;su_type
op_eq
id|SU_PORT_MS
op_logical_or
id|up-&gt;su_type
op_eq
id|SU_PORT_KBD
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_UNKNOWN
)paren
r_continue
suffix:semicolon
id|uart_add_one_port
c_func
(paren
op_amp
id|sunsu_reg
comma
op_amp
id|up-&gt;port
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|su_node_ok
r_static
r_int
id|su_node_ok
c_func
(paren
r_int
id|node
comma
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|name
comma
l_string|&quot;su&quot;
comma
id|namelen
)paren
op_eq
l_int|0
op_logical_or
id|strncmp
c_func
(paren
id|name
comma
l_string|&quot;su_pnp&quot;
comma
id|namelen
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|name
comma
l_string|&quot;serial&quot;
comma
id|namelen
)paren
op_eq
l_int|0
)paren
(brace
r_char
id|compat
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|clen
suffix:semicolon
multiline_comment|/* Is it _really_ a &squot;su&squot; device? */
id|clen
op_assign
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;compatible&quot;
comma
id|compat
comma
r_sizeof
(paren
id|compat
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clen
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|compat
comma
l_string|&quot;sab82532&quot;
comma
l_int|8
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Nope, Siemens serial, not for us. */
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SU_PROPSIZE
mdefine_line|#define SU_PROPSIZE&t;128
multiline_comment|/*&n; * Scan status structure.&n; * &quot;prop&quot; is a local variable but it eats stack to keep it in each&n; * stack frame of a recursive procedure.&n; */
DECL|struct|su_probe_scan
r_struct
id|su_probe_scan
(brace
DECL|member|msnode
DECL|member|kbnode
r_int
id|msnode
comma
id|kbnode
suffix:semicolon
multiline_comment|/* PROM nodes for mouse and keyboard */
DECL|member|msx
DECL|member|kbx
r_int
id|msx
comma
id|kbx
suffix:semicolon
multiline_comment|/* minors for mouse and keyboard */
DECL|member|devices
r_int
id|devices
suffix:semicolon
multiline_comment|/* scan index */
DECL|member|prop
r_char
id|prop
(braket
id|SU_PROPSIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * We have several platforms which present &squot;su&squot; in different parts&n; * of the device tree. &squot;su&squot; may be found under obio, ebus, isa and pci.&n; * We walk over the tree and find them wherever PROM hides them.&n; */
DECL|function|su_probe_any
r_static
r_void
id|__init
id|su_probe_any
c_func
(paren
r_struct
id|su_probe_scan
op_star
id|t
comma
r_int
id|sunode
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;devices
op_ge
id|UART_NR
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|sunode
op_ne
l_int|0
suffix:semicolon
id|sunode
op_assign
id|prom_getsibling
c_func
(paren
id|sunode
)paren
)paren
(brace
id|len
op_assign
id|prom_getproperty
c_func
(paren
id|sunode
comma
l_string|&quot;name&quot;
comma
id|t-&gt;prop
comma
id|SU_PROPSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|1
)paren
r_continue
suffix:semicolon
multiline_comment|/* Broken PROM node */
r_if
c_cond
(paren
id|su_node_ok
c_func
(paren
id|sunode
comma
id|t-&gt;prop
comma
id|len
)paren
)paren
(brace
id|up
op_assign
op_amp
id|sunsu_ports
(braket
id|t-&gt;devices
)braket
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;kbnode
op_ne
l_int|0
op_logical_and
id|sunode
op_eq
id|t-&gt;kbnode
)paren
(brace
id|t-&gt;kbx
op_assign
id|t-&gt;devices
suffix:semicolon
id|up-&gt;su_type
op_assign
id|SU_PORT_KBD
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|t-&gt;msnode
op_ne
l_int|0
op_logical_and
id|sunode
op_eq
id|t-&gt;msnode
)paren
(brace
id|t-&gt;msx
op_assign
id|t-&gt;devices
suffix:semicolon
id|up-&gt;su_type
op_assign
id|SU_PORT_MS
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_SPARC64
multiline_comment|/*&n;&t;&t;&t;&t; * Do not attempt to use the truncated&n;&t;&t;&t;&t; * keyboard/mouse ports as serial ports&n;&t;&t;&t;&t; * on Ultras with PC keyboard attached.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|prom_getbool
c_func
(paren
id|sunode
comma
l_string|&quot;mouse&quot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|prom_getbool
c_func
(paren
id|sunode
comma
l_string|&quot;keyboard&quot;
)paren
)paren
r_continue
suffix:semicolon
macro_line|#endif
id|up-&gt;su_type
op_assign
id|SU_PORT_PORT
suffix:semicolon
)brace
id|up-&gt;port_node
op_assign
id|sunode
suffix:semicolon
op_increment
id|t-&gt;devices
suffix:semicolon
)brace
r_else
(brace
id|su_probe_any
c_func
(paren
id|t
comma
id|prom_getchild
c_func
(paren
id|sunode
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|sunsu_probe
r_static
r_int
id|__init
id|sunsu_probe
c_func
(paren
r_void
)paren
(brace
r_int
id|node
suffix:semicolon
r_int
id|len
suffix:semicolon
r_struct
id|su_probe_scan
id|scan
suffix:semicolon
multiline_comment|/*&n;&t; * First, we scan the tree.&n;&t; */
id|scan.devices
op_assign
l_int|0
suffix:semicolon
id|scan.msx
op_assign
op_minus
l_int|1
suffix:semicolon
id|scan.kbx
op_assign
op_minus
l_int|1
suffix:semicolon
id|scan.kbnode
op_assign
l_int|0
suffix:semicolon
id|scan.msnode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Get the nodes for keyboard and mouse from &squot;aliases&squot;...&n;&t; */
id|node
op_assign
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
suffix:semicolon
id|node
op_assign
id|prom_searchsiblings
c_func
(paren
id|node
comma
l_string|&quot;aliases&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node
op_ne
l_int|0
)paren
(brace
id|len
op_assign
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;keyboard&quot;
comma
id|scan.prop
comma
id|SU_PROPSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|scan.prop
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|scan.kbnode
op_assign
id|prom_finddevice
c_func
(paren
id|scan.prop
)paren
suffix:semicolon
)brace
id|len
op_assign
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;mouse&quot;
comma
id|scan.prop
comma
id|SU_PROPSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|scan.prop
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|scan.msnode
op_assign
id|prom_finddevice
c_func
(paren
id|scan.prop
)paren
suffix:semicolon
)brace
)brace
id|su_probe_any
c_func
(paren
op_amp
id|scan
comma
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Second, we process the special case of keyboard and mouse.&n;&t; *&n;&t; * Currently if we got keyboard and mouse hooked to &quot;su&quot; ports&n;&t; * we do not use any possible remaining &quot;su&quot; as a serial port.&n;&t; * Thus, we ignore values of .msx and .kbx, then compact ports.&n;&t; */
r_if
c_cond
(paren
id|scan.msx
op_ne
op_minus
l_int|1
op_logical_and
id|scan.kbx
op_ne
op_minus
l_int|1
)paren
(brace
id|sunsu_ports
(braket
l_int|0
)braket
dot
id|su_type
op_assign
id|SU_PORT_MS
suffix:semicolon
id|sunsu_ports
(braket
l_int|0
)braket
dot
id|port_node
op_assign
id|scan.msnode
suffix:semicolon
id|sunsu_ports
(braket
l_int|1
)braket
dot
id|su_type
op_assign
id|SU_PORT_KBD
suffix:semicolon
id|sunsu_ports
(braket
l_int|1
)braket
dot
id|port_node
op_assign
id|scan.kbnode
suffix:semicolon
id|sunsu_kbd_ms_init
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scan.msx
op_ne
op_minus
l_int|1
op_logical_or
id|scan.kbx
op_ne
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sunsu_probe: cannot match keyboard and mouse, confused&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scan.devices
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * Console must be initiated after the generic initialization.&n;&t; */
id|sunsu_serial_init
c_func
(paren
)paren
suffix:semicolon
id|sunsu_serial_console_init
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sunsu_exit
r_static
r_void
id|__exit
id|sunsu_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|saw_uart
suffix:semicolon
id|saw_uart
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UART_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|uart_sunsu_port
op_star
id|up
op_assign
op_amp
id|sunsu_ports
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;su_type
op_eq
id|SU_PORT_MS
op_logical_or
id|up-&gt;su_type
op_eq
id|SU_PORT_KBD
)paren
(brace
macro_line|#ifdef CONFIG_SERIO
id|serio_unregister_port
c_func
(paren
op_amp
id|up-&gt;serio
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|up-&gt;port.type
op_ne
id|PORT_UNKNOWN
)paren
(brace
id|uart_remove_one_port
c_func
(paren
op_amp
id|sunsu_reg
comma
op_amp
id|up-&gt;port
)paren
suffix:semicolon
id|saw_uart
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|saw_uart
)paren
id|uart_unregister_driver
c_func
(paren
op_amp
id|sunsu_reg
)paren
suffix:semicolon
)brace
DECL|variable|sunsu_probe
id|module_init
c_func
(paren
id|sunsu_probe
)paren
suffix:semicolon
DECL|variable|sunsu_exit
id|module_exit
c_func
(paren
id|sunsu_exit
)paren
suffix:semicolon
eof
