multiline_comment|/*&n; * linux/drivers/serial/pmac_zilog.c&n; * &n; * Driver for PowerMac Z85c30 based ESCC cell found in the&n; * &quot;macio&quot; ASICs of various PowerMac models&n; * &n; * Copyright (C) 2003 Ben. Herrenschmidt (benh@kernel.crashing.org)&n; *&n; * Derived from drivers/macintosh/macserial.c by Paul Mackerras&n; * and drivers/serial/sunzilog.c by David S. Miller&n; *&n; * Hrm... actually, I ripped most of sunzilog (Thanks David !) and&n; * adapted special tweaks needed for us. I don&squot;t think it&squot;s worth&n; * merging back those though. The DMA code still has to get in&n; * and once done, I expect that driver to remain fairly stable in&n; * the long term, unless we change the driver model again...&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; * TODO:   - Add DMA support&n; *         - Defer port shutdown to a few seconds after close&n; *         - maybe put something right into up-&gt;clk_divisor&n; */
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/adb.h&gt;
macro_line|#include &lt;linux/pmu.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/pmac_feature.h&gt;
macro_line|#include &lt;asm/kgdb.h&gt;
macro_line|#include &lt;asm/dbdma.h&gt;
macro_line|#include &lt;asm/macio.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/serial_core.h&gt;
macro_line|#include &quot;pmac_zilog.h&quot;
macro_line|#if defined(CONFIG_SERIAL_PMACZILOG_CONSOLE) &amp;&amp; defined(CONFIG_PPC64)
DECL|macro|HAS_SCCDBG
mdefine_line|#define HAS_SCCDBG
r_extern
r_int
id|sccdbg
suffix:semicolon
macro_line|#endif
multiline_comment|/* Not yet implemented */
DECL|macro|HAS_DBDMA
macro_line|#undef HAS_DBDMA
DECL|variable|__initdata
r_static
r_char
id|version
(braket
)braket
id|__initdata
op_assign
l_string|&quot;pmac_zilog.c 0.5a (Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;)&quot;
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Driver for the PowerMac serial ports.&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|macro|PWRDBG
mdefine_line|#define PWRDBG(fmt, arg...)&t;printk(KERN_DEBUG fmt , ## arg)
multiline_comment|/*&n; * For the sake of early serial console, we can do a pre-probe&n; * (optional) of the ports at rather early boot time.&n; */
DECL|variable|pmz_ports
r_static
r_struct
id|uart_pmac_port
id|pmz_ports
(braket
id|MAX_ZS_PORTS
)braket
suffix:semicolon
DECL|variable|pmz_ports_count
r_static
r_int
id|pmz_ports_count
suffix:semicolon
multiline_comment|/* &n; * Load all registers to reprogram the port&n; * This function must only be called when the TX is not busy.  The UART&n; * port lock must be held and local interrupts disabled.&n; */
DECL|function|pmz_load_zsregs
r_static
r_void
id|pmz_load_zsregs
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
comma
id|u8
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Let pending transmits finish.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|stat
op_assign
id|read_zsreg
c_func
(paren
id|up
comma
id|R1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ALL_SNT
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
id|ZS_CLEARERR
c_func
(paren
id|up
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|ZS_CLEARFIFO
c_func
(paren
id|up
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|ZS_CLEARERR
c_func
(paren
id|up
)paren
suffix:semicolon
multiline_comment|/* Disable all interrupts.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R1
comma
id|regs
(braket
id|R1
)braket
op_amp
op_complement
(paren
id|RxINT_MASK
op_or
id|TxINT_ENAB
op_or
id|EXT_INT_ENAB
)paren
)paren
suffix:semicolon
multiline_comment|/* Set parity, sync config, stop bits, and clock divisor.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R4
comma
id|regs
(braket
id|R4
)braket
)paren
suffix:semicolon
multiline_comment|/* Set misc. TX/RX control bits.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R10
comma
id|regs
(braket
id|R10
)braket
)paren
suffix:semicolon
multiline_comment|/* Set TX/RX controls sans the enable bits.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R3
comma
id|regs
(braket
id|R3
)braket
op_amp
op_complement
id|RxENABLE
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R5
comma
id|regs
(braket
id|R5
)braket
op_amp
op_complement
id|TxENABLE
)paren
suffix:semicolon
multiline_comment|/* Synchronous mode config.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R6
comma
id|regs
(braket
id|R6
)braket
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R7
comma
id|regs
(braket
id|R7
)braket
)paren
suffix:semicolon
multiline_comment|/* Disable baud generator.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R14
comma
id|regs
(braket
id|R14
)braket
op_amp
op_complement
id|BRENAB
)paren
suffix:semicolon
multiline_comment|/* Clock mode control.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R11
comma
id|regs
(braket
id|R11
)braket
)paren
suffix:semicolon
multiline_comment|/* Lower and upper byte of baud rate generator divisor.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R12
comma
id|regs
(braket
id|R12
)braket
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R13
comma
id|regs
(braket
id|R13
)braket
)paren
suffix:semicolon
multiline_comment|/* Now rewrite R14, with BRENAB (if set).  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R14
comma
id|regs
(braket
id|R14
)braket
)paren
suffix:semicolon
multiline_comment|/* External status interrupt control.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R15
comma
id|regs
(braket
id|R15
)braket
)paren
suffix:semicolon
multiline_comment|/* Reset external status interrupts.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R0
comma
id|RES_EXT_INT
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R0
comma
id|RES_EXT_INT
)paren
suffix:semicolon
multiline_comment|/* Rewrite R3/R5, this time without enables masked.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R3
comma
id|regs
(braket
id|R3
)braket
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R5
comma
id|regs
(braket
id|R5
)braket
)paren
suffix:semicolon
multiline_comment|/* Rewrite R1, this time without IRQ enabled masked.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R1
comma
id|regs
(braket
id|R1
)braket
)paren
suffix:semicolon
multiline_comment|/* Enable interrupts */
id|write_zsreg
c_func
(paren
id|up
comma
id|R9
comma
id|regs
(braket
id|R9
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * We do like sunzilog to avoid disrupting pending Tx&n; * Reprogram the Zilog channel HW registers with the copies found in the&n; * software state struct.  If the transmitter is busy, we defer this update&n; * until the next TX complete interrupt.  Else, we do it right now.&n; *&n; * The UART port lock must be held and local interrupts disabled.&n; */
DECL|function|pmz_maybe_update_regs
r_static
r_void
id|pmz_maybe_update_regs
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ZS_REGS_HELD
c_func
(paren
id|up
)paren
)paren
(brace
r_if
c_cond
(paren
id|ZS_TX_ACTIVE
c_func
(paren
id|up
)paren
)paren
(brace
id|up-&gt;flags
op_or_assign
id|PMACZILOG_FLAG_REGS_HELD
suffix:semicolon
)brace
r_else
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmz: maybe_update_regs: updating&bslash;n&quot;
)paren
suffix:semicolon
id|pmz_load_zsregs
c_func
(paren
id|up
comma
id|up-&gt;curregs
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|pmz_receive_chars
r_static
r_void
id|pmz_receive_chars
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|up-&gt;port.info-&gt;tty
suffix:semicolon
multiline_comment|/* XXX info==NULL? */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
r_char
id|ch
comma
id|r1
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
)paren
(brace
id|tty-&gt;flip.work
dot
id|func
c_func
(paren
(paren
r_void
op_star
)paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
multiline_comment|/* XXX Ignores SysRq when we need it most. Fix. */
r_return
suffix:semicolon
)brace
id|r1
op_assign
id|read_zsreg
c_func
(paren
id|up
comma
id|R1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r1
op_amp
(paren
id|PAR_ERR
op_or
id|Rx_OVR
op_or
id|CRC_ERR
)paren
)paren
(brace
id|write_zsreg
c_func
(paren
id|up
comma
id|R0
comma
id|ERR_RES
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
)brace
id|ch
op_assign
id|read_zsdata
c_func
(paren
id|up
)paren
suffix:semicolon
id|ch
op_and_assign
id|up-&gt;parity_mask
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_int|0
op_logical_and
id|up-&gt;prev_status
op_amp
id|BRK_ABRT
)paren
(brace
id|r1
op_or_assign
id|BRK_ABRT
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rx break&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* A real serial line, record the character and status.  */
op_star
id|tty-&gt;flip.char_buf_ptr
op_assign
id|ch
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_NORMAL
suffix:semicolon
id|up-&gt;port.icount.rx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|r1
op_amp
(paren
id|PAR_ERR
op_or
id|Rx_OVR
op_or
id|CRC_ERR
op_or
id|BRK_ABRT
)paren
)paren
(brace
r_if
c_cond
(paren
id|r1
op_amp
id|BRK_ABRT
)paren
(brace
id|r1
op_and_assign
op_complement
(paren
id|PAR_ERR
op_or
id|CRC_ERR
)paren
suffix:semicolon
id|up-&gt;port.icount.brk
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|uart_handle_break
c_func
(paren
op_amp
id|up-&gt;port
)paren
)paren
r_goto
id|next_char
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|r1
op_amp
id|PAR_ERR
)paren
id|up-&gt;port.icount.parity
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r1
op_amp
id|CRC_ERR
)paren
id|up-&gt;port.icount.frame
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|r1
op_amp
id|Rx_OVR
)paren
id|up-&gt;port.icount.overrun
op_increment
suffix:semicolon
id|r1
op_and_assign
id|up-&gt;port.read_status_mask
suffix:semicolon
r_if
c_cond
(paren
id|r1
op_amp
id|BRK_ABRT
)paren
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_BREAK
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r1
op_amp
id|PAR_ERR
)paren
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_PARITY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r1
op_amp
id|CRC_ERR
)paren
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_FRAME
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uart_handle_sysrq_char
c_func
(paren
op_amp
id|up-&gt;port
comma
id|ch
comma
id|regs
)paren
)paren
r_goto
id|next_char
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.ignore_status_mask
op_eq
l_int|0xff
op_logical_or
(paren
id|r1
op_amp
id|up-&gt;port.ignore_status_mask
)paren
op_eq
l_int|0
)paren
(brace
id|tty-&gt;flip.flag_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|r1
op_amp
id|Rx_OVR
)paren
op_logical_and
id|tty-&gt;flip.count
OL
id|TTY_FLIPBUF_SIZE
)paren
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_OVERRUN
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.count
op_increment
suffix:semicolon
)brace
id|next_char
suffix:colon
id|ch
op_assign
id|read_zsreg
c_func
(paren
id|up
comma
id|R0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch
op_amp
id|Rx_CH_AV
)paren
)paren
r_break
suffix:semicolon
)brace
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|pmz_status_handle
r_static
r_void
id|pmz_status_handle
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
id|status
op_assign
id|read_zsreg
c_func
(paren
id|up
comma
id|R0
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R0
comma
id|RES_EXT_INT
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
macro_line|#ifdef HAS_SCCDBG
r_if
c_cond
(paren
id|sccdbg
op_logical_and
(paren
id|status
op_amp
id|BRK_ABRT
)paren
op_logical_and
op_logical_neg
(paren
id|up-&gt;prev_status
op_amp
id|BRK_ABRT
)paren
)paren
(brace
macro_line|#ifdef CONFIG_XMON
r_extern
r_void
id|xmon
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif /* HAS_SCCDBG */
r_if
c_cond
(paren
id|ZS_WANTS_MODEM_STATUS
c_func
(paren
id|up
)paren
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|SYNC_HUNT
)paren
id|up-&gt;port.icount.dsr
op_increment
suffix:semicolon
multiline_comment|/* The Zilog just gives us an interrupt when DCD/CTS/etc. change.&n;&t;&t; * But it does not tell us which bit has changed, we have to keep&n;&t;&t; * track of this ourselves.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|DCD
)paren
op_xor
id|up-&gt;prev_status
)paren
id|uart_handle_dcd_change
c_func
(paren
op_amp
id|up-&gt;port
comma
(paren
id|status
op_amp
id|DCD
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|CTS
)paren
op_xor
id|up-&gt;prev_status
)paren
id|uart_handle_cts_change
c_func
(paren
op_amp
id|up-&gt;port
comma
(paren
id|status
op_amp
id|CTS
)paren
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|up-&gt;port.info-&gt;delta_msr_wait
)paren
suffix:semicolon
)brace
id|up-&gt;prev_status
op_assign
id|status
suffix:semicolon
)brace
DECL|function|pmz_transmit_chars
r_static
r_void
id|pmz_transmit_chars
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
)paren
(brace
r_struct
id|circ_buf
op_star
id|xmit
suffix:semicolon
r_if
c_cond
(paren
id|ZS_IS_CONS
c_func
(paren
id|up
)paren
)paren
(brace
r_int
r_char
id|status
op_assign
id|read_zsreg
c_func
(paren
id|up
comma
id|R0
)paren
suffix:semicolon
multiline_comment|/* TX still busy?  Just wait for the next TX done interrupt.&n;&t;&t; *&n;&t;&t; * It can occur because of how we do serial console writes.  It would&n;&t;&t; * be nice to transmit console writes just like we normally would for&n;&t;&t; * a TTY line. (ie. buffered and TX interrupt driven).  That is not&n;&t;&t; * easy because console writes cannot sleep.  One solution might be&n;&t;&t; * to poll on enough port-&gt;xmit space becomming free.  -DaveM&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|Tx_BUF_EMP
)paren
)paren
r_return
suffix:semicolon
)brace
id|up-&gt;flags
op_and_assign
op_complement
id|PMACZILOG_FLAG_TX_ACTIVE
suffix:semicolon
r_if
c_cond
(paren
id|ZS_REGS_HELD
c_func
(paren
id|up
)paren
)paren
(brace
id|pmz_load_zsregs
c_func
(paren
id|up
comma
id|up-&gt;curregs
)paren
suffix:semicolon
id|up-&gt;flags
op_and_assign
op_complement
id|PMACZILOG_FLAG_REGS_HELD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ZS_TX_STOPPED
c_func
(paren
id|up
)paren
)paren
(brace
id|up-&gt;flags
op_and_assign
op_complement
id|PMACZILOG_FLAG_TX_STOPPED
suffix:semicolon
r_goto
id|ack_tx_int
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up-&gt;port.x_char
)paren
(brace
id|up-&gt;flags
op_or_assign
id|PMACZILOG_FLAG_TX_ACTIVE
suffix:semicolon
id|write_zsdata
c_func
(paren
id|up
comma
id|up-&gt;port.x_char
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|up-&gt;port.icount.tx
op_increment
suffix:semicolon
id|up-&gt;port.x_char
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up-&gt;port.info
op_eq
l_int|NULL
)paren
r_goto
id|ack_tx_int
suffix:semicolon
id|xmit
op_assign
op_amp
id|up-&gt;port.info-&gt;xmit
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
id|xmit
)paren
)paren
(brace
id|uart_write_wakeup
c_func
(paren
op_amp
id|up-&gt;port
)paren
suffix:semicolon
r_goto
id|ack_tx_int
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uart_tx_stopped
c_func
(paren
op_amp
id|up-&gt;port
)paren
)paren
r_goto
id|ack_tx_int
suffix:semicolon
id|up-&gt;flags
op_or_assign
id|PMACZILOG_FLAG_TX_ACTIVE
suffix:semicolon
id|write_zsdata
c_func
(paren
id|up
comma
id|xmit-&gt;buf
(braket
id|xmit-&gt;tail
)braket
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|xmit-&gt;tail
op_assign
(paren
id|xmit-&gt;tail
op_plus
l_int|1
)paren
op_amp
(paren
id|UART_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|up-&gt;port.icount.tx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_chars_pending
c_func
(paren
id|xmit
)paren
OL
id|WAKEUP_CHARS
)paren
id|uart_write_wakeup
c_func
(paren
op_amp
id|up-&gt;port
)paren
suffix:semicolon
r_return
suffix:semicolon
id|ack_tx_int
suffix:colon
id|write_zsreg
c_func
(paren
id|up
comma
id|R0
comma
id|RES_Tx_P
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
)brace
multiline_comment|/* Hrm... we register that twice, fixme later.... */
DECL|function|pmz_interrupt
r_static
id|irqreturn_t
id|pmz_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|up
op_assign
id|dev_id
suffix:semicolon
r_struct
id|uart_pmac_port
op_star
id|up_a
suffix:semicolon
r_struct
id|uart_pmac_port
op_star
id|up_b
suffix:semicolon
r_int
id|rc
op_assign
id|IRQ_NONE
suffix:semicolon
id|u8
id|r3
suffix:semicolon
id|up_a
op_assign
id|ZS_IS_CHANNEL_A
c_func
(paren
id|up
)paren
ques
c_cond
id|up
suffix:colon
id|up-&gt;mate
suffix:semicolon
id|up_b
op_assign
id|up_a-&gt;mate
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|up_a-&gt;port.lock
)paren
suffix:semicolon
id|r3
op_assign
id|read_zsreg
c_func
(paren
id|up
comma
id|R3
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmz_irq: %x&bslash;n&quot;
comma
id|r3
)paren
suffix:semicolon
multiline_comment|/* Channel A */
r_if
c_cond
(paren
id|r3
op_amp
(paren
id|CHAEXT
op_or
id|CHATxIP
op_or
id|CHARxIP
)paren
)paren
(brace
id|write_zsreg
c_func
(paren
id|up_a
comma
id|R0
comma
id|RES_H_IUS
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up_a
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmz: irq channel A: %x&bslash;n&quot;
comma
id|r3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r3
op_amp
id|CHAEXT
)paren
id|pmz_status_handle
c_func
(paren
id|up_a
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r3
op_amp
id|CHARxIP
)paren
id|pmz_receive_chars
c_func
(paren
id|up_a
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r3
op_amp
id|CHATxIP
)paren
id|pmz_transmit_chars
c_func
(paren
id|up_a
)paren
suffix:semicolon
id|rc
op_assign
id|IRQ_HANDLED
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|up_a-&gt;port.lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|up_b-&gt;port.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r3
op_amp
(paren
id|CHBEXT
op_or
id|CHBTxIP
op_or
id|CHBRxIP
)paren
)paren
(brace
id|write_zsreg
c_func
(paren
id|up_b
comma
id|R0
comma
id|RES_H_IUS
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up_b
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmz: irq channel B: %x&bslash;n&quot;
comma
id|r3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r3
op_amp
id|CHBEXT
)paren
id|pmz_status_handle
c_func
(paren
id|up_b
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r3
op_amp
id|CHBRxIP
)paren
id|pmz_receive_chars
c_func
(paren
id|up_b
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r3
op_amp
id|CHBTxIP
)paren
id|pmz_transmit_chars
c_func
(paren
id|up_b
)paren
suffix:semicolon
id|rc
op_assign
id|IRQ_HANDLED
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|up_b-&gt;port.lock
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Peek the status register, lock not held by caller&n; */
DECL|function|pmz_peek_status
r_static
r_inline
id|u8
id|pmz_peek_status
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|status
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|read_zsreg
c_func
(paren
id|up
comma
id|R0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* &n; * Check if transmitter is empty&n; * The port lock is not held.&n; */
DECL|function|pmz_tx_empty
r_static
r_int
r_int
id|pmz_tx_empty
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
id|status
op_assign
id|pmz_peek_status
c_func
(paren
id|to_pmz
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|Tx_BUF_EMP
)paren
r_return
id|TIOCSER_TEMT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Set Modem Control (RTS &amp; DTR) bits&n; * The port lock is held and interrupts are disabled.&n; * Note: Shall we really filter out RTS on external ports or&n; * should that be dealt at higher level only ?&n; */
DECL|function|pmz_set_mctrl
r_static
r_void
id|pmz_set_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|mctrl
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|up
op_assign
id|to_pmz
c_func
(paren
id|port
)paren
suffix:semicolon
r_int
r_char
id|set_bits
comma
id|clear_bits
suffix:semicolon
multiline_comment|/* Do nothing for irda for now... */
r_if
c_cond
(paren
id|ZS_IS_IRDA
c_func
(paren
id|up
)paren
)paren
r_return
suffix:semicolon
id|set_bits
op_assign
id|clear_bits
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ZS_IS_INTMODEM
c_func
(paren
id|up
)paren
)paren
(brace
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_RTS
)paren
id|set_bits
op_or_assign
id|RTS
suffix:semicolon
r_else
id|clear_bits
op_or_assign
id|RTS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_DTR
)paren
id|set_bits
op_or_assign
id|DTR
suffix:semicolon
r_else
id|clear_bits
op_or_assign
id|DTR
suffix:semicolon
multiline_comment|/* NOTE: Not subject to &squot;transmitter active&squot; rule.  */
id|up-&gt;curregs
(braket
id|R5
)braket
op_or_assign
id|set_bits
suffix:semicolon
id|up-&gt;curregs
(braket
id|R5
)braket
op_and_assign
op_complement
id|clear_bits
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R5
comma
id|up-&gt;curregs
(braket
id|R5
)braket
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Get Modem Control bits (only the input ones, the core will&n; * or that with a cached value of the control ones)&n; * The port lock is not held.&n; */
DECL|function|pmz_get_mctrl
r_static
r_int
r_int
id|pmz_get_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|status
op_assign
id|pmz_peek_status
c_func
(paren
id|to_pmz
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|DCD
)paren
id|ret
op_or_assign
id|TIOCM_CAR
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|SYNC_HUNT
)paren
id|ret
op_or_assign
id|TIOCM_DSR
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|CTS
)paren
id|ret
op_or_assign
id|TIOCM_CTS
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* &n; * Stop TX side. Dealt like sunzilog at next Tx interrupt,&n; * though for DMA, we will have to do a bit more. What is&n; * the meaning of the tty_stop bit ? XXX&n; * The port lock is held and interrupts are disabled.&n; */
DECL|function|pmz_stop_tx
r_static
r_void
id|pmz_stop_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|tty_stop
)paren
(brace
id|to_pmz
c_func
(paren
id|port
)paren
op_member_access_from_pointer
id|flags
op_or_assign
id|PMACZILOG_FLAG_TX_STOPPED
suffix:semicolon
)brace
multiline_comment|/* &n; * Kick the Tx side.&n; * The port lock is held and interrupts are disabled.&n; */
DECL|function|pmz_start_tx
r_static
r_void
id|pmz_start_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|tty_start
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|up
op_assign
id|to_pmz
c_func
(paren
id|port
)paren
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmz: start_tx()&bslash;n&quot;
)paren
suffix:semicolon
id|up-&gt;flags
op_or_assign
id|PMACZILOG_FLAG_TX_ACTIVE
suffix:semicolon
id|up-&gt;flags
op_and_assign
op_complement
id|PMACZILOG_FLAG_TX_STOPPED
suffix:semicolon
id|status
op_assign
id|read_zsreg
c_func
(paren
id|up
comma
id|R0
)paren
suffix:semicolon
multiline_comment|/* TX busy?  Just wait for the TX done interrupt.  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|Tx_BUF_EMP
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Send the first character to jump-start the TX done&n;&t; * IRQ sending engine.&n;&t; */
r_if
c_cond
(paren
id|port-&gt;x_char
)paren
(brace
id|write_zsdata
c_func
(paren
id|up
comma
id|port-&gt;x_char
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|port-&gt;icount.tx
op_increment
suffix:semicolon
id|port-&gt;x_char
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|circ_buf
op_star
id|xmit
op_assign
op_amp
id|port-&gt;info-&gt;xmit
suffix:semicolon
id|write_zsdata
c_func
(paren
id|up
comma
id|xmit-&gt;buf
(braket
id|xmit-&gt;tail
)braket
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|xmit-&gt;tail
op_assign
(paren
id|xmit-&gt;tail
op_plus
l_int|1
)paren
op_amp
(paren
id|UART_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|port-&gt;icount.tx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_chars_pending
c_func
(paren
id|xmit
)paren
OL
id|WAKEUP_CHARS
)paren
id|uart_write_wakeup
c_func
(paren
op_amp
id|up-&gt;port
)paren
suffix:semicolon
)brace
id|pr_debug
c_func
(paren
l_string|&quot;pmz: start_tx() done.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Stop Rx side, basically disable emitting of&n; * Rx interrupts on the port&n; * The port lock is held.&n; */
DECL|function|pmz_stop_rx
r_static
r_void
id|pmz_stop_rx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|up
op_assign
id|to_pmz
c_func
(paren
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ZS_IS_CONS
c_func
(paren
id|up
)paren
)paren
r_return
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmz: stop_rx()()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Disable all RX interrupts.  */
id|up-&gt;curregs
(braket
id|R1
)braket
op_and_assign
op_complement
id|RxINT_MASK
suffix:semicolon
id|pmz_maybe_update_regs
c_func
(paren
id|up
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmz: stop_rx() done.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Enable modem status change interrupts&n; * The port lock is held.&n; */
DECL|function|pmz_enable_ms
r_static
r_void
id|pmz_enable_ms
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|up
op_assign
id|to_pmz
c_func
(paren
id|port
)paren
suffix:semicolon
r_int
r_char
id|new_reg
suffix:semicolon
id|new_reg
op_assign
id|up-&gt;curregs
(braket
id|R15
)braket
op_or
(paren
id|DCDIE
op_or
id|SYNCIE
op_or
id|CTSIE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_reg
op_ne
id|up-&gt;curregs
(braket
id|R15
)braket
)paren
(brace
id|up-&gt;curregs
(braket
id|R15
)braket
op_assign
id|new_reg
suffix:semicolon
multiline_comment|/* NOTE: Not subject to &squot;transmitter active&squot; rule.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R15
comma
id|up-&gt;curregs
(braket
id|R15
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Control break state emission&n; * The port lock is not held.&n; */
DECL|function|pmz_break_ctl
r_static
r_void
id|pmz_break_ctl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
id|break_state
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|up
op_assign
id|to_pmz
c_func
(paren
id|port
)paren
suffix:semicolon
r_int
r_char
id|set_bits
comma
id|clear_bits
comma
id|new_reg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|set_bits
op_assign
id|clear_bits
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|break_state
)paren
id|set_bits
op_or_assign
id|SND_BRK
suffix:semicolon
r_else
id|clear_bits
op_or_assign
id|SND_BRK
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|new_reg
op_assign
(paren
id|up-&gt;curregs
(braket
id|R5
)braket
op_or
id|set_bits
)paren
op_amp
op_complement
id|clear_bits
suffix:semicolon
r_if
c_cond
(paren
id|new_reg
op_ne
id|up-&gt;curregs
(braket
id|R5
)braket
)paren
(brace
id|up-&gt;curregs
(braket
id|R5
)braket
op_assign
id|new_reg
suffix:semicolon
multiline_comment|/* NOTE: Not subject to &squot;transmitter active&squot; rule.  */
id|write_zsreg
c_func
(paren
id|up
comma
id|R5
comma
id|up-&gt;curregs
(braket
id|R5
)braket
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Turn power on or off to the SCC and associated stuff&n; * (port drivers, modem, IR port, etc.)&n; * Returns the number of milliseconds we should wait before&n; * trying to use the port.&n; */
DECL|function|pmz_set_scc_power
r_static
r_int
id|pmz_set_scc_power
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
comma
r_int
id|state
)paren
(brace
r_int
id|delay
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_SCC_ENABLE
comma
id|up-&gt;node
comma
id|up-&gt;port_type
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ZS_IS_INTMODEM
c_func
(paren
id|up
)paren
)paren
(brace
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_MODEM_ENABLE
comma
id|up-&gt;node
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|delay
op_assign
l_int|2500
suffix:semicolon
multiline_comment|/* wait for 2.5s before using */
)brace
r_else
r_if
c_cond
(paren
id|ZS_IS_IRDA
c_func
(paren
id|up
)paren
)paren
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* Do better here once the problems&n;&t;&t;&t;                 * with blocking have been ironed out&n;&t;&t;&t;                 */
)brace
r_else
(brace
multiline_comment|/* TODO: Make that depend on a timer, don&squot;t power down&n;&t;&t; * immediately&n;&t;&t; */
r_if
c_cond
(paren
id|ZS_IS_INTMODEM
c_func
(paren
id|up
)paren
)paren
(brace
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_MODEM_ENABLE
comma
id|up-&gt;node
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_SCC_ENABLE
comma
id|up-&gt;node
comma
id|up-&gt;port_type
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|delay
suffix:semicolon
)brace
multiline_comment|/*&n; * FixZeroBug....Works around a bug in the SCC receving channel.&n; * Taken from Darwin code, 15 Sept. 2000  -DanM&n; *&n; * The following sequence prevents a problem that is seen with O&squot;Hare ASICs&n; * (most versions -- also with some Heathrow and Hydra ASICs) where a zero&n; * at the input to the receiver becomes &squot;stuck&squot; and locks up the receiver.&n; * This problem can occur as a result of a zero bit at the receiver input&n; * coincident with any of the following events:&n; *&n; *&t;The SCC is initialized (hardware or software).&n; *&t;A framing error is detected.&n; *&t;The clocking option changes from synchronous or X1 asynchronous&n; *&t;&t;clocking to X16, X32, or X64 asynchronous clocking.&n; *&t;The decoding mode is changed among NRZ, NRZI, FM0, or FM1.&n; *&n; * This workaround attempts to recover from the lockup condition by placing&n; * the SCC in synchronous loopback mode with a fast clock before programming&n; * any of the asynchronous modes.&n; */
DECL|function|pmz_fix_zero_bug_scc
r_static
r_void
id|pmz_fix_zero_bug_scc
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
)paren
(brace
id|write_zsreg
c_func
(paren
id|up
comma
l_int|9
comma
id|ZS_IS_CHANNEL_A
c_func
(paren
id|up
)paren
ques
c_cond
id|CHRA
suffix:colon
id|CHRB
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|9
comma
(paren
id|ZS_IS_CHANNEL_A
c_func
(paren
id|up
)paren
ques
c_cond
id|CHRA
suffix:colon
id|CHRB
)paren
op_or
id|NV
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|4
comma
(paren
id|X1CLK
op_or
id|EXTSYNC
)paren
)paren
suffix:semicolon
multiline_comment|/* I think this is wrong....but, I just copying code....&n;&t;*/
id|write_zsreg
c_func
(paren
id|up
comma
l_int|3
comma
(paren
l_int|8
op_amp
op_complement
id|RxENABLE
)paren
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|5
comma
(paren
l_int|8
op_amp
op_complement
id|TxENABLE
)paren
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|9
comma
id|NV
)paren
suffix:semicolon
multiline_comment|/* Didn&squot;t we already do this? */
id|write_zsreg
c_func
(paren
id|up
comma
l_int|11
comma
(paren
id|RCBR
op_or
id|TCBR
)paren
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|12
comma
l_int|0
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|13
comma
l_int|0
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|14
comma
(paren
id|LOOPBAK
op_or
id|SSBR
)paren
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|14
comma
(paren
id|LOOPBAK
op_or
id|SSBR
op_or
id|BRENAB
)paren
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|3
comma
(paren
l_int|8
op_or
id|RxENABLE
)paren
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|0
comma
id|RES_EXT_INT
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|0
comma
id|RES_EXT_INT
)paren
suffix:semicolon
multiline_comment|/* to kill some time */
multiline_comment|/* The channel should be OK now, but it is probably receiving&n;&t; * loopback garbage.&n;&t; * Switch to asynchronous mode, disable the receiver,&n;&t; * and discard everything in the receive buffer.&n;&t; */
id|write_zsreg
c_func
(paren
id|up
comma
l_int|9
comma
id|NV
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|4
comma
id|PAR_ENAB
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|3
comma
(paren
l_int|8
op_amp
op_complement
id|RxENABLE
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|read_zsreg
c_func
(paren
id|up
comma
l_int|0
)paren
op_amp
id|Rx_CH_AV
)paren
(brace
(paren
r_void
)paren
id|read_zsreg
c_func
(paren
id|up
comma
l_int|8
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|0
comma
id|RES_EXT_INT
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|0
comma
id|ERR_RES
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Real startup routine, powers up the hardware and sets up&n; * the SCC. Returns a delay in ms where you need to wait before&n; * actually using the port, this is typically the internal modem&n; * powerup delay. This routine expect the lock to be taken.&n; */
DECL|function|__pmz_startup
r_static
r_int
id|__pmz_startup
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
)paren
(brace
r_int
id|pwr_delay
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|up-&gt;curregs
comma
l_int|0
comma
r_sizeof
(paren
id|up-&gt;curregs
)paren
)paren
suffix:semicolon
multiline_comment|/* Power up the SCC &amp; underlying hardware (modem/irda) */
id|pwr_delay
op_assign
id|pmz_set_scc_power
c_func
(paren
id|up
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Nice buggy HW ... */
id|pmz_fix_zero_bug_scc
c_func
(paren
id|up
)paren
suffix:semicolon
multiline_comment|/* Reset the chip */
id|write_zsreg
c_func
(paren
id|up
comma
l_int|9
comma
id|ZS_IS_CHANNEL_A
c_func
(paren
id|up
)paren
ques
c_cond
id|CHRA
suffix:colon
id|CHRB
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|9
comma
l_int|0
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
multiline_comment|/* Clear the interrupt registers */
id|write_zsreg
c_func
(paren
id|up
comma
id|R1
comma
l_int|0
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R0
comma
id|ERR_RES
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R0
comma
id|ERR_RES
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R0
comma
id|RES_H_IUS
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R0
comma
id|RES_H_IUS
)paren
suffix:semicolon
multiline_comment|/* Remember status for DCD/CTS changes */
id|up-&gt;prev_status
op_assign
id|read_zsreg
c_func
(paren
id|up
comma
id|R0
)paren
suffix:semicolon
multiline_comment|/* Enable receiver and transmitter.  */
id|up-&gt;curregs
(braket
id|R3
)braket
op_or_assign
id|RxENABLE
suffix:semicolon
id|up-&gt;curregs
(braket
id|R5
)braket
op_or_assign
id|TxENABLE
op_or
id|RTS
op_or
id|DTR
suffix:semicolon
multiline_comment|/* Master interrupt enable */
id|up-&gt;curregs
(braket
id|R9
)braket
op_or_assign
id|NV
op_or
id|MIE
suffix:semicolon
id|up-&gt;curregs
(braket
id|R1
)braket
op_or_assign
id|EXT_INT_ENAB
op_or
id|INT_ALL_Rx
op_or
id|TxINT_ENAB
suffix:semicolon
id|pmz_maybe_update_regs
c_func
(paren
id|up
)paren
suffix:semicolon
r_return
id|pwr_delay
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the &quot;normal&quot; startup routine, using the above one&n; * wrapped with the lock and doing a schedule delay&n; */
DECL|function|pmz_startup
r_static
r_int
id|pmz_startup
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|up
op_assign
id|to_pmz
c_func
(paren
id|port
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|pwr_delay
op_assign
l_int|0
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmz: startup()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* A console is never powered down */
r_if
c_cond
(paren
op_logical_neg
id|ZS_IS_CONS
c_func
(paren
id|up
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|pwr_delay
op_assign
id|__pmz_startup
c_func
(paren
id|up
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|up-&gt;port.irq
comma
id|pmz_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;PowerMac Zilog&quot;
comma
id|up
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to register zs interrupt handler.&bslash;n&quot;
)paren
suffix:semicolon
id|pmz_set_scc_power
c_func
(paren
id|up
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* Right now, we deal with delay by blocking here, I&squot;ll be&n;&t; * smarter later on&n;&t; */
r_if
c_cond
(paren
id|pwr_delay
op_ne
l_int|0
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmz: delaying %d ms&bslash;n&quot;
comma
id|pwr_delay
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
(paren
id|pwr_delay
op_star
id|HZ
)paren
op_div
l_int|1000
)paren
suffix:semicolon
)brace
id|pr_debug
c_func
(paren
l_string|&quot;pmz: startup() done.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pmz_shutdown
r_static
r_void
id|pmz_shutdown
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|up
op_assign
id|to_pmz
c_func
(paren
id|port
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmz: shutdown()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Release interrupt handler */
id|free_irq
c_func
(paren
id|up-&gt;port.irq
comma
id|up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ZS_IS_CONS
c_func
(paren
id|up
)paren
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Disable receiver and transmitter.  */
id|up-&gt;curregs
(braket
id|R3
)braket
op_and_assign
op_complement
id|RxENABLE
suffix:semicolon
id|up-&gt;curregs
(braket
id|R5
)braket
op_and_assign
op_complement
id|TxENABLE
suffix:semicolon
multiline_comment|/* Disable all interrupts and BRK assertion.  */
id|up-&gt;curregs
(braket
id|R1
)braket
op_and_assign
op_complement
(paren
id|EXT_INT_ENAB
op_or
id|TxINT_ENAB
op_or
id|RxINT_MASK
)paren
suffix:semicolon
id|up-&gt;curregs
(braket
id|R5
)braket
op_and_assign
op_complement
id|SND_BRK
suffix:semicolon
id|pmz_maybe_update_regs
c_func
(paren
id|up
)paren
suffix:semicolon
multiline_comment|/* Shut the chip down */
id|pmz_set_scc_power
c_func
(paren
id|up
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmz: shutdown() done.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Shared by TTY driver and serial console setup.  The port lock is held&n; * and local interrupts are disabled.&n; */
r_static
r_void
DECL|function|pmz_convert_to_zs
id|pmz_convert_to_zs
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
comma
r_int
r_int
id|cflag
comma
r_int
r_int
id|iflag
comma
r_int
id|baud
)paren
(brace
r_int
id|brg
suffix:semicolon
r_switch
c_cond
(paren
id|baud
)paren
(brace
r_case
id|ZS_CLOCK
op_div
l_int|16
suffix:colon
multiline_comment|/* 230400 */
id|up-&gt;curregs
(braket
id|R4
)braket
op_assign
id|X16CLK
suffix:semicolon
id|up-&gt;curregs
(braket
id|R11
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ZS_CLOCK
op_div
l_int|32
suffix:colon
multiline_comment|/* 115200 */
id|up-&gt;curregs
(braket
id|R4
)braket
op_assign
id|X32CLK
suffix:semicolon
id|up-&gt;curregs
(braket
id|R11
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|up-&gt;curregs
(braket
id|R4
)braket
op_assign
id|X16CLK
suffix:semicolon
id|up-&gt;curregs
(braket
id|R11
)braket
op_assign
id|TCBR
op_or
id|RCBR
suffix:semicolon
id|brg
op_assign
id|BPS_TO_BRG
c_func
(paren
id|baud
comma
id|ZS_CLOCK
op_div
l_int|16
)paren
suffix:semicolon
id|up-&gt;curregs
(braket
id|R12
)braket
op_assign
(paren
id|brg
op_amp
l_int|255
)paren
suffix:semicolon
id|up-&gt;curregs
(braket
id|R13
)braket
op_assign
(paren
(paren
id|brg
op_rshift
l_int|8
)paren
op_amp
l_int|255
)paren
suffix:semicolon
id|up-&gt;curregs
(braket
id|R14
)braket
op_assign
id|BRENAB
suffix:semicolon
)brace
multiline_comment|/* Character size, stop bits, and parity. */
id|up-&gt;curregs
(braket
l_int|3
)braket
op_and_assign
op_complement
id|RxN_MASK
suffix:semicolon
id|up-&gt;curregs
(braket
l_int|5
)braket
op_and_assign
op_complement
id|TxN_MASK
suffix:semicolon
r_switch
c_cond
(paren
id|cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|up-&gt;curregs
(braket
l_int|3
)braket
op_or_assign
id|Rx5
suffix:semicolon
id|up-&gt;curregs
(braket
l_int|5
)braket
op_or_assign
id|Tx5
suffix:semicolon
id|up-&gt;parity_mask
op_assign
l_int|0x1f
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|up-&gt;curregs
(braket
l_int|3
)braket
op_or_assign
id|Rx6
suffix:semicolon
id|up-&gt;curregs
(braket
l_int|5
)braket
op_or_assign
id|Tx6
suffix:semicolon
id|up-&gt;parity_mask
op_assign
l_int|0x3f
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|up-&gt;curregs
(braket
l_int|3
)braket
op_or_assign
id|Rx7
suffix:semicolon
id|up-&gt;curregs
(braket
l_int|5
)braket
op_or_assign
id|Tx7
suffix:semicolon
id|up-&gt;parity_mask
op_assign
l_int|0x7f
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS8
suffix:colon
r_default
suffix:colon
id|up-&gt;curregs
(braket
l_int|3
)braket
op_or_assign
id|Rx8
suffix:semicolon
id|up-&gt;curregs
(braket
l_int|5
)braket
op_or_assign
id|Tx8
suffix:semicolon
id|up-&gt;parity_mask
op_assign
l_int|0xff
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|up-&gt;curregs
(braket
l_int|4
)braket
op_and_assign
op_complement
(paren
id|SB_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_amp
id|CSTOPB
)paren
id|up-&gt;curregs
(braket
l_int|4
)braket
op_or_assign
id|SB2
suffix:semicolon
r_else
id|up-&gt;curregs
(braket
l_int|4
)braket
op_or_assign
id|SB1
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_amp
id|PARENB
)paren
id|up-&gt;curregs
(braket
l_int|4
)braket
op_or_assign
id|PAR_ENAB
suffix:semicolon
r_else
id|up-&gt;curregs
(braket
l_int|4
)braket
op_and_assign
op_complement
id|PAR_ENAB
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cflag
op_amp
id|PARODD
)paren
)paren
id|up-&gt;curregs
(braket
l_int|4
)braket
op_or_assign
id|PAR_EVEN
suffix:semicolon
r_else
id|up-&gt;curregs
(braket
l_int|4
)braket
op_and_assign
op_complement
id|PAR_EVEN
suffix:semicolon
id|up-&gt;port.read_status_mask
op_assign
id|Rx_OVR
suffix:semicolon
r_if
c_cond
(paren
id|iflag
op_amp
id|INPCK
)paren
id|up-&gt;port.read_status_mask
op_or_assign
id|CRC_ERR
op_or
id|PAR_ERR
suffix:semicolon
r_if
c_cond
(paren
id|iflag
op_amp
(paren
id|BRKINT
op_or
id|PARMRK
)paren
)paren
id|up-&gt;port.read_status_mask
op_or_assign
id|BRK_ABRT
suffix:semicolon
id|up-&gt;port.ignore_status_mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iflag
op_amp
id|IGNPAR
)paren
id|up-&gt;port.ignore_status_mask
op_or_assign
id|CRC_ERR
op_or
id|PAR_ERR
suffix:semicolon
r_if
c_cond
(paren
id|iflag
op_amp
id|IGNBRK
)paren
(brace
id|up-&gt;port.ignore_status_mask
op_or_assign
id|BRK_ABRT
suffix:semicolon
r_if
c_cond
(paren
id|iflag
op_amp
id|IGNPAR
)paren
id|up-&gt;port.ignore_status_mask
op_or_assign
id|Rx_OVR
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CREAD
)paren
op_eq
l_int|0
)paren
id|up-&gt;port.ignore_status_mask
op_assign
l_int|0xff
suffix:semicolon
)brace
DECL|function|pmz_irda_rts_pulses
r_static
r_void
id|pmz_irda_rts_pulses
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
comma
r_int
id|w
)paren
(brace
id|udelay
c_func
(paren
id|w
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|5
comma
id|Tx8
op_or
id|TxENABLE
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|5
comma
id|Tx8
op_or
id|TxENABLE
op_or
id|RTS
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|5
comma
id|Tx8
op_or
id|TxENABLE
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
l_int|5
comma
id|Tx8
op_or
id|TxENABLE
op_or
id|RTS
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the irda codec on the imac to the specified baud rate.&n; */
DECL|function|pmz_irda_setup
r_static
r_void
id|pmz_irda_setup
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
comma
r_int
id|cflags
)paren
(brace
r_int
id|code
comma
id|speed
comma
id|t
suffix:semicolon
id|speed
op_assign
id|cflags
op_amp
id|CBAUD
suffix:semicolon
r_if
c_cond
(paren
id|speed
template_param
id|B115200
)paren
r_return
suffix:semicolon
id|code
op_assign
l_int|0x4d
op_plus
id|B115200
op_minus
id|speed
suffix:semicolon
multiline_comment|/* disable serial interrupts and receive DMA */
id|write_zsreg
c_func
(paren
id|up
comma
l_int|1
comma
id|up-&gt;curregs
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x9f
)paren
suffix:semicolon
multiline_comment|/* wait for transmitter to drain */
id|t
op_assign
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
(paren
id|read_zsreg
c_func
(paren
id|up
comma
id|R0
)paren
op_amp
id|Tx_BUF_EMP
)paren
op_eq
l_int|0
op_logical_or
(paren
id|read_zsreg
c_func
(paren
id|up
comma
id|R1
)paren
op_amp
id|ALL_SNT
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|t
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;transmitter didn&squot;t drain&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* set to 8 bits, no parity, 19200 baud, RTS on, DTR off */
id|write_zsreg
c_func
(paren
id|up
comma
id|R4
comma
id|X16CLK
op_or
id|SB1
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R11
comma
id|TCBR
op_or
id|RCBR
)paren
suffix:semicolon
id|t
op_assign
id|BPS_TO_BRG
c_func
(paren
l_int|19200
comma
id|ZS_CLOCK
op_div
l_int|16
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R12
comma
id|t
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R13
comma
id|t
op_rshift
l_int|8
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R14
comma
id|BRENAB
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R3
comma
id|Rx8
op_or
id|RxENABLE
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R5
comma
id|Tx8
op_or
id|TxENABLE
op_or
id|RTS
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
multiline_comment|/* set TxD low for ~104us and pulse RTS */
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|write_zsdata
c_func
(paren
id|up
comma
l_int|0xfe
)paren
suffix:semicolon
id|pmz_irda_rts_pulses
c_func
(paren
id|up
comma
l_int|150
)paren
suffix:semicolon
id|pmz_irda_rts_pulses
c_func
(paren
id|up
comma
l_int|180
)paren
suffix:semicolon
id|pmz_irda_rts_pulses
c_func
(paren
id|up
comma
l_int|50
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* assert DTR, wait 30ms, talk to the chip */
id|write_zsreg
c_func
(paren
id|up
comma
id|R5
comma
id|Tx8
op_or
id|TxENABLE
op_or
id|RTS
op_or
id|DTR
)paren
suffix:semicolon
id|zssync
c_func
(paren
id|up
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
r_while
c_loop
(paren
id|read_zsreg
c_func
(paren
id|up
comma
id|R0
)paren
op_amp
id|Rx_CH_AV
)paren
id|read_zsdata
c_func
(paren
id|up
)paren
suffix:semicolon
id|write_zsdata
c_func
(paren
id|up
comma
l_int|1
)paren
suffix:semicolon
id|t
op_assign
l_int|1000
suffix:semicolon
r_while
c_loop
(paren
(paren
id|read_zsreg
c_func
(paren
id|up
comma
id|R0
)paren
op_amp
id|Rx_CH_AV
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|t
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;irda_setup timed out on 1st byte&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
id|t
op_assign
id|read_zsdata
c_func
(paren
id|up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ne
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;irda_setup 1st byte = %x&bslash;n&quot;
comma
id|t
)paren
suffix:semicolon
id|write_zsdata
c_func
(paren
id|up
comma
id|code
)paren
suffix:semicolon
id|t
op_assign
l_int|1000
suffix:semicolon
r_while
c_loop
(paren
(paren
id|read_zsreg
c_func
(paren
id|up
comma
id|R0
)paren
op_amp
id|Rx_CH_AV
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|t
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;irda_setup timed out on 2nd byte&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
id|t
op_assign
id|read_zsdata
c_func
(paren
id|up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ne
id|code
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;irda_setup 2nd byte = %x (%x)&bslash;n&quot;
comma
id|t
comma
id|code
)paren
suffix:semicolon
multiline_comment|/* Drop DTR again and do some more RTS pulses */
id|out
suffix:colon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R5
comma
id|Tx8
op_or
id|TxENABLE
op_or
id|RTS
)paren
suffix:semicolon
id|pmz_irda_rts_pulses
c_func
(paren
id|up
comma
l_int|80
)paren
suffix:semicolon
multiline_comment|/* We should be right to go now.  We assume that load_zsregs&n;&t;   will get called soon to load up the correct baud rate etc. */
id|up-&gt;curregs
(braket
id|R5
)braket
op_assign
(paren
id|up-&gt;curregs
(braket
id|R5
)braket
op_or
id|RTS
)paren
op_amp
op_complement
id|DTR
suffix:semicolon
)brace
multiline_comment|/* The port lock is not held.  */
r_static
r_void
DECL|function|pmz_set_termios
id|pmz_set_termios
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|termios
op_star
id|termios
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|up
op_assign
id|to_pmz
c_func
(paren
id|port
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|baud
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmz: set_termios()&bslash;n&quot;
)paren
suffix:semicolon
id|baud
op_assign
id|uart_get_baud_rate
c_func
(paren
id|port
comma
id|termios
comma
id|old
comma
l_int|1200
comma
l_int|230400
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|pmz_convert_to_zs
c_func
(paren
id|up
comma
id|termios-&gt;c_cflag
comma
id|termios-&gt;c_iflag
comma
id|baud
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UART_ENABLE_MS
c_func
(paren
op_amp
id|up-&gt;port
comma
id|termios-&gt;c_cflag
)paren
)paren
(brace
id|up-&gt;curregs
(braket
id|R15
)braket
op_or_assign
id|DCDIE
op_or
id|SYNCIE
op_or
id|CTSIE
suffix:semicolon
id|up-&gt;flags
op_or_assign
id|PMACZILOG_FLAG_MODEM_STATUS
suffix:semicolon
)brace
r_else
(brace
id|up-&gt;curregs
(braket
id|R15
)braket
op_and_assign
op_complement
(paren
id|DCDIE
op_or
id|SYNCIE
op_or
id|CTSIE
)paren
suffix:semicolon
id|up-&gt;flags
op_and_assign
op_complement
id|PMACZILOG_FLAG_MODEM_STATUS
suffix:semicolon
)brace
multiline_comment|/* set the irda codec to the right rate */
r_if
c_cond
(paren
id|ZS_IS_IRDA
c_func
(paren
id|up
)paren
)paren
id|pmz_irda_setup
c_func
(paren
id|up
comma
id|termios-&gt;c_cflag
)paren
suffix:semicolon
multiline_comment|/* Load registers to the chip */
id|pmz_maybe_update_regs
c_func
(paren
id|up
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmz: set_termios() done.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|pmz_type
r_static
r_const
r_char
op_star
id|pmz_type
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_return
l_string|&quot;PowerMac Zilog&quot;
suffix:semicolon
)brace
multiline_comment|/* We do not request/release mappings of the registers here, this&n; * happens at early serial probe time.&n; */
DECL|function|pmz_release_port
r_static
r_void
id|pmz_release_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
)brace
DECL|function|pmz_request_port
r_static
r_int
id|pmz_request_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* These do not need to do anything interesting either.  */
DECL|function|pmz_config_port
r_static
r_void
id|pmz_config_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
id|flags
)paren
(brace
)brace
multiline_comment|/* We do not support letting the user mess with the divisor, IRQ, etc. */
DECL|function|pmz_verify_port
r_static
r_int
id|pmz_verify_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|serial_struct
op_star
id|ser
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|variable|pmz_pops
r_static
r_struct
id|uart_ops
id|pmz_pops
op_assign
(brace
dot
id|tx_empty
op_assign
id|pmz_tx_empty
comma
dot
id|set_mctrl
op_assign
id|pmz_set_mctrl
comma
dot
id|get_mctrl
op_assign
id|pmz_get_mctrl
comma
dot
id|stop_tx
op_assign
id|pmz_stop_tx
comma
dot
id|start_tx
op_assign
id|pmz_start_tx
comma
dot
id|stop_rx
op_assign
id|pmz_stop_rx
comma
dot
id|enable_ms
op_assign
id|pmz_enable_ms
comma
dot
id|break_ctl
op_assign
id|pmz_break_ctl
comma
dot
id|startup
op_assign
id|pmz_startup
comma
dot
id|shutdown
op_assign
id|pmz_shutdown
comma
dot
id|set_termios
op_assign
id|pmz_set_termios
comma
dot
id|type
op_assign
id|pmz_type
comma
dot
id|release_port
op_assign
id|pmz_release_port
comma
dot
id|request_port
op_assign
id|pmz_request_port
comma
dot
id|config_port
op_assign
id|pmz_config_port
comma
dot
id|verify_port
op_assign
id|pmz_verify_port
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Setup one port structure after probing, HW is down at this point,&n; * Unlike sunzilog, we don&squot;t need to pre-init the spinlock as we don&squot;t&n; * register our console before uart_add_one_port() is called&n; */
DECL|function|pmz_init_port
r_static
r_int
id|__init
id|pmz_init_port
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
id|up-&gt;node
suffix:semicolon
r_char
op_star
id|conn
suffix:semicolon
r_struct
id|slot_names_prop
(brace
r_int
id|count
suffix:semicolon
r_char
id|name
(braket
l_int|1
)braket
suffix:semicolon
)brace
op_star
id|slots
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/*&n;&t; * Request &amp; map chip registers&n;&t; */
id|up-&gt;port.mapbase
op_assign
id|np-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
id|up-&gt;port.membase
op_assign
id|ioremap
c_func
(paren
id|up-&gt;port.mapbase
comma
l_int|0x1000
)paren
suffix:semicolon
id|up-&gt;control_reg
op_assign
(paren
r_volatile
id|u8
op_star
)paren
id|up-&gt;port.membase
suffix:semicolon
id|up-&gt;data_reg
op_assign
id|up-&gt;control_reg
op_plus
l_int|0x10
suffix:semicolon
multiline_comment|/*&n;&t; * Request &amp; map DBDMA registers&n;&t; */
macro_line|#ifdef HAS_DBDMA
r_if
c_cond
(paren
id|np-&gt;n_addrs
op_ge
l_int|3
op_logical_and
id|np-&gt;n_intrs
op_ge
l_int|3
)paren
id|up-&gt;flags
op_or_assign
id|PMACZILOG_FLAG_HAS_DMA
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
id|ZS_HAS_DMA
c_func
(paren
id|up
)paren
)paren
(brace
id|up-&gt;tx_dma_regs
op_assign
(paren
r_volatile
r_struct
id|dbdma_regs
op_star
)paren
id|ioremap
c_func
(paren
id|np-&gt;addrs
(braket
id|np-&gt;n_addrs
op_minus
l_int|2
)braket
dot
id|address
comma
l_int|0x1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;tx_dma_regs
op_eq
l_int|NULL
)paren
(brace
id|up-&gt;flags
op_and_assign
op_complement
id|PMACZILOG_FLAG_HAS_DMA
suffix:semicolon
r_goto
id|no_dma
suffix:semicolon
)brace
id|up-&gt;rx_dma_regs
op_assign
(paren
r_volatile
r_struct
id|dbdma_regs
op_star
)paren
id|ioremap
c_func
(paren
id|np-&gt;addrs
(braket
id|np-&gt;n_addrs
op_minus
l_int|1
)braket
dot
id|address
comma
l_int|0x1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;rx_dma_regs
op_eq
l_int|NULL
)paren
(brace
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|up-&gt;tx_dma_regs
)paren
suffix:semicolon
id|up-&gt;flags
op_and_assign
op_complement
id|PMACZILOG_FLAG_HAS_DMA
suffix:semicolon
r_goto
id|no_dma
suffix:semicolon
)brace
id|up-&gt;tx_dma_irq
op_assign
id|np-&gt;intrs
(braket
l_int|1
)braket
dot
id|line
suffix:semicolon
id|up-&gt;rx_dma_irq
op_assign
id|np-&gt;intrs
(braket
l_int|2
)braket
dot
id|line
suffix:semicolon
)brace
id|no_dma
suffix:colon
multiline_comment|/*&n;&t; * Detect port type&n;&t; */
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
l_string|&quot;cobalt&quot;
)paren
)paren
id|up-&gt;flags
op_or_assign
id|PMACZILOG_FLAG_IS_INTMODEM
suffix:semicolon
id|conn
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,connector&quot;
comma
op_amp
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conn
op_logical_and
(paren
id|strcmp
c_func
(paren
id|conn
comma
l_string|&quot;infrared&quot;
)paren
op_eq
l_int|0
)paren
)paren
id|up-&gt;flags
op_or_assign
id|PMACZILOG_FLAG_IS_IRDA
suffix:semicolon
id|up-&gt;port_type
op_assign
id|PMAC_SCC_ASYNC
suffix:semicolon
multiline_comment|/* 1999 Powerbook G3 has slot-names property instead */
id|slots
op_assign
(paren
r_struct
id|slot_names_prop
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;slot-names&quot;
comma
op_amp
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slots
op_logical_and
id|slots-&gt;count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|slots-&gt;name
comma
l_string|&quot;IrDA&quot;
)paren
op_eq
l_int|0
)paren
id|up-&gt;flags
op_or_assign
id|PMACZILOG_FLAG_IS_IRDA
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|slots-&gt;name
comma
l_string|&quot;Modem&quot;
)paren
op_eq
l_int|0
)paren
id|up-&gt;flags
op_or_assign
id|PMACZILOG_FLAG_IS_INTMODEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ZS_IS_IRDA
c_func
(paren
id|up
)paren
)paren
id|up-&gt;port_type
op_assign
id|PMAC_SCC_IRDA
suffix:semicolon
r_if
c_cond
(paren
id|ZS_IS_INTMODEM
c_func
(paren
id|up
)paren
)paren
(brace
r_struct
id|device_node
op_star
id|i2c_modem
op_assign
id|find_devices
c_func
(paren
l_string|&quot;i2c-modem&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2c_modem
)paren
(brace
r_char
op_star
id|mid
op_assign
id|get_property
c_func
(paren
id|i2c_modem
comma
l_string|&quot;modem-id&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mid
)paren
r_switch
c_cond
(paren
op_star
id|mid
)paren
(brace
r_case
l_int|0x04
suffix:colon
r_case
l_int|0x05
suffix:colon
r_case
l_int|0x07
suffix:colon
r_case
l_int|0x08
suffix:colon
r_case
l_int|0x0b
suffix:colon
r_case
l_int|0x0c
suffix:colon
id|up-&gt;port_type
op_assign
id|PMAC_SCC_I2S1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;pmac_zilog: i2c-modem detected, id: %d&bslash;n&quot;
comma
id|mid
ques
c_cond
(paren
op_star
id|mid
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;pmac_zilog: serial modem detected&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Init remaining bits of &quot;port&quot; structure&n;&t; */
id|up-&gt;port.iotype
op_assign
id|SERIAL_IO_MEM
suffix:semicolon
id|up-&gt;port.irq
op_assign
id|np-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
suffix:semicolon
id|up-&gt;port.uartclk
op_assign
id|ZS_CLOCK
suffix:semicolon
id|up-&gt;port.fifosize
op_assign
l_int|1
suffix:semicolon
id|up-&gt;port.ops
op_assign
op_amp
id|pmz_pops
suffix:semicolon
id|up-&gt;port.type
op_assign
id|PORT_PMAC_ZILOG
suffix:semicolon
id|up-&gt;port.flags
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get rid of a port on module removal&n; */
DECL|function|pmz_dispose_port
r_static
r_void
id|pmz_dispose_port
c_func
(paren
r_struct
id|uart_pmac_port
op_star
id|up
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|up-&gt;control_reg
)paren
suffix:semicolon
id|np
op_assign
id|up-&gt;node
suffix:semicolon
id|up-&gt;node
op_assign
l_int|NULL
suffix:semicolon
id|of_node_put
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called upon match with an escc node in the devive-tree.&n; */
DECL|function|pmz_attach
r_static
r_int
id|pmz_attach
c_func
(paren
r_struct
id|macio_dev
op_star
id|mdev
comma
r_const
r_struct
id|of_match
op_star
id|match
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Iterate the pmz_ports array to find a matching entry&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ZS_PORTS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|pmz_ports
(braket
id|i
)braket
dot
id|node
op_eq
id|mdev-&gt;ofdev.node
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|up
op_assign
op_amp
id|pmz_ports
(braket
id|i
)braket
suffix:semicolon
id|up-&gt;dev
op_assign
id|mdev
suffix:semicolon
id|dev_set_drvdata
c_func
(paren
op_amp
id|mdev-&gt;ofdev.dev
comma
id|up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|macio_request_resources
c_func
(paren
id|up-&gt;dev
comma
l_string|&quot;pmac_zilog&quot;
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Failed to request resource, port still active&bslash;n&quot;
comma
id|up-&gt;node-&gt;name
)paren
suffix:semicolon
r_else
id|up-&gt;flags
op_or_assign
id|PMACZILOG_FLAG_RSRC_REQUESTED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n; * That one should not be called, macio isn&squot;t really a hotswap device,&n; * we don&squot;t expect one of those serial ports to go away...&n; */
DECL|function|pmz_detach
r_static
r_int
id|pmz_detach
c_func
(paren
r_struct
id|macio_dev
op_star
id|mdev
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|up
op_assign
id|dev_get_drvdata
c_func
(paren
op_amp
id|mdev-&gt;ofdev.dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|up
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;flags
op_amp
id|PMACZILOG_FLAG_RSRC_REQUESTED
)paren
(brace
id|macio_release_resources
c_func
(paren
id|up-&gt;dev
)paren
suffix:semicolon
id|up-&gt;flags
op_and_assign
op_complement
id|PMACZILOG_FLAG_RSRC_REQUESTED
suffix:semicolon
)brace
id|dev_set_drvdata
c_func
(paren
op_amp
id|mdev-&gt;ofdev.dev
comma
l_int|NULL
)paren
suffix:semicolon
id|up-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Probe all ports in the system and build the ports array, we register&n; * with the serial layer at this point, the macio-type probing is only&n; * used later to &quot;attach&quot; to the sysfs tree so we get power management&n; * events&n; */
DECL|function|pmz_probe
r_static
r_int
id|__init
id|pmz_probe
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|node_p
comma
op_star
id|node_a
comma
op_star
id|node_b
comma
op_star
id|np
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/*&n;&t; * Find all escc chips in the system&n;&t; */
id|node_p
op_assign
id|of_find_node_by_name
c_func
(paren
l_int|NULL
comma
l_string|&quot;escc&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|node_p
)paren
(brace
multiline_comment|/*&n;&t;&t; * First get channel A/B node pointers&n;&t;&t; * &n;&t;&t; * TODO: Add routines with proper locking to do that...&n;&t;&t; */
id|node_a
op_assign
id|node_b
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
l_int|NULL
suffix:semicolon
(paren
id|np
op_assign
id|of_get_next_child
c_func
(paren
id|node_p
comma
id|np
)paren
)paren
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;ch-a&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
id|node_a
op_assign
id|of_node_get
c_func
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;ch-b&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
id|node_b
op_assign
id|of_node_get
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|node_a
op_logical_or
op_logical_neg
id|node_b
)paren
(brace
id|of_node_put
c_func
(paren
id|node_a
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|node_b
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;pmac_zilog: missing node %c for escc %s&bslash;n&quot;
comma
(paren
op_logical_neg
id|node_a
)paren
ques
c_cond
l_char|&squot;a&squot;
suffix:colon
l_char|&squot;b&squot;
comma
id|node_p-&gt;full_name
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Fill basic fields in the port structures&n;&t;&t; */
id|pmz_ports
(braket
id|count
)braket
dot
id|mate
op_assign
op_amp
id|pmz_ports
(braket
id|count
op_plus
l_int|1
)braket
suffix:semicolon
id|pmz_ports
(braket
id|count
op_plus
l_int|1
)braket
dot
id|mate
op_assign
op_amp
id|pmz_ports
(braket
id|count
)braket
suffix:semicolon
id|pmz_ports
(braket
id|count
)braket
dot
id|flags
op_assign
id|PMACZILOG_FLAG_IS_CHANNEL_A
suffix:semicolon
id|pmz_ports
(braket
id|count
)braket
dot
id|node
op_assign
id|node_a
suffix:semicolon
id|pmz_ports
(braket
id|count
op_plus
l_int|1
)braket
dot
id|node
op_assign
id|node_b
suffix:semicolon
id|pmz_ports
(braket
id|count
)braket
dot
id|port.line
op_assign
id|count
suffix:semicolon
id|pmz_ports
(braket
id|count
op_plus
l_int|1
)braket
dot
id|port.line
op_assign
id|count
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Setup the ports for real&n;&t;&t; */
id|rc
op_assign
id|pmz_init_port
c_func
(paren
op_amp
id|pmz_ports
(braket
id|count
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|rc
op_assign
id|pmz_init_port
c_func
(paren
op_amp
id|pmz_ports
(braket
id|count
op_plus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|of_node_put
c_func
(paren
id|node_a
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|node_b
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pmz_ports
(braket
id|count
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|uart_pmac_port
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pmz_ports
(braket
id|count
op_plus
l_int|1
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|uart_pmac_port
)paren
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
id|count
op_add_assign
l_int|2
suffix:semicolon
id|next
suffix:colon
id|node_p
op_assign
id|of_find_node_by_name
c_func
(paren
id|node_p
comma
l_string|&quot;escc&quot;
)paren
suffix:semicolon
)brace
id|pmz_ports_count
op_assign
id|count
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pmz_uart_reg
r_static
r_struct
id|uart_driver
id|pmz_uart_reg
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|driver_name
op_assign
l_string|&quot;ttyS&quot;
comma
dot
id|devfs_name
op_assign
l_string|&quot;tts/&quot;
comma
dot
id|dev_name
op_assign
l_string|&quot;ttyS&quot;
comma
dot
id|major
op_assign
id|TTY_MAJOR
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_SERIAL_PMACZILOG_CONSOLE
r_static
r_void
id|pmz_console_write
c_func
(paren
r_struct
id|console
op_star
id|con
comma
r_const
r_char
op_star
id|s
comma
r_int
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|__init
id|pmz_console_setup
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_char
op_star
id|options
)paren
suffix:semicolon
DECL|variable|pmz_console
r_static
r_struct
id|console
id|pmz_console
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ttyS&quot;
comma
dot
id|write
op_assign
id|pmz_console_write
comma
dot
id|device
op_assign
id|uart_console_device
comma
dot
id|setup
op_assign
id|pmz_console_setup
comma
dot
id|flags
op_assign
id|CON_PRINTBUFFER
comma
dot
id|index
op_assign
op_minus
l_int|1
comma
dot
id|data
op_assign
op_amp
id|pmz_uart_reg
comma
)brace
suffix:semicolon
DECL|macro|PMACZILOG_CONSOLE
mdefine_line|#define PMACZILOG_CONSOLE&t;&amp;pmz_console
macro_line|#else /* CONFIG_SERIAL_PMACZILOG_CONSOLE */
DECL|macro|PMACZILOG_CONSOLE
mdefine_line|#define PMACZILOG_CONSOLE&t;(NULL)
macro_line|#endif /* CONFIG_SERIAL_PMACZILOG_CONSOLE */
multiline_comment|/*&n; * Register the driver, console driver and ports with the serial&n; * core&n; */
DECL|function|pmz_register
r_static
r_int
id|__init
id|pmz_register
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|rc
suffix:semicolon
id|pmz_uart_reg.nr
op_assign
id|pmz_ports_count
suffix:semicolon
id|pmz_uart_reg.cons
op_assign
id|PMACZILOG_CONSOLE
suffix:semicolon
id|pmz_uart_reg.minor
op_assign
l_int|64
suffix:semicolon
multiline_comment|/*&n;&t; * Register this driver with the serial core&n;&t; */
id|rc
op_assign
id|uart_register_driver
c_func
(paren
op_amp
id|pmz_uart_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t; * Register each port with the serial core&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmz_ports_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|uport
op_assign
op_amp
id|pmz_ports
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|uport-&gt;node
op_ne
l_int|NULL
)paren
id|uart_add_one_port
c_func
(paren
op_amp
id|pmz_uart_reg
comma
op_amp
id|uport-&gt;port
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pmz_match
r_static
r_struct
id|of_match
id|pmz_match
(braket
)braket
op_assign
(brace
(brace
dot
id|name
op_assign
l_string|&quot;ch-a&quot;
comma
dot
id|type
op_assign
id|OF_ANY_MATCH
comma
dot
id|compatible
op_assign
id|OF_ANY_MATCH
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;ch-b&quot;
comma
dot
id|type
op_assign
id|OF_ANY_MATCH
comma
dot
id|compatible
op_assign
id|OF_ANY_MATCH
)brace
comma
(brace
)brace
comma
)brace
suffix:semicolon
DECL|variable|pmz_driver
r_static
r_struct
id|macio_driver
id|pmz_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;pmac_zilog&quot;
comma
dot
id|match_table
op_assign
id|pmz_match
comma
dot
id|probe
op_assign
id|pmz_attach
comma
dot
id|remove
op_assign
id|pmz_detach
comma
singleline_comment|//&t;.suspend&t;= pmz_suspend, *** NYI
singleline_comment|//&t;.resume&t;&t;= pmz_resume,  *** NYI
)brace
suffix:semicolon
DECL|function|init_pmz
r_static
r_int
id|__init
id|init_pmz
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s&bslash;n&quot;
comma
id|version
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * First, we need to do a direct OF-based probe pass. We&n;&t; * do that because we want serial console up before the&n;&t; * macio stuffs calls us back, and since that makes it&n;&t; * easier to pass the proper number of channels to&n;&t; * uart_register_driver()&n;&t; */
r_if
c_cond
(paren
id|pmz_ports_count
op_eq
l_int|0
)paren
id|pmz_probe
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Bail early if no port found&n;&t; */
r_if
c_cond
(paren
id|pmz_ports_count
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * Now we register with the serial layer&n;&t; */
id|pmz_register
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Then we register the macio driver itself&n;&t; */
r_return
id|macio_register_driver
c_func
(paren
op_amp
id|pmz_driver
)paren
suffix:semicolon
)brace
DECL|function|exit_pmz
r_static
r_void
id|__exit
id|exit_pmz
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Get rid of macio-driver (detach from macio) */
id|macio_unregister_driver
c_func
(paren
op_amp
id|pmz_driver
)paren
suffix:semicolon
multiline_comment|/* Unregister UART driver */
id|uart_unregister_driver
c_func
(paren
op_amp
id|pmz_uart_reg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmz_ports_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|uport
op_assign
op_amp
id|pmz_ports
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|uport-&gt;node
op_ne
l_int|NULL
)paren
(brace
id|uart_remove_one_port
c_func
(paren
op_amp
id|pmz_uart_reg
comma
op_amp
id|uport-&gt;port
)paren
suffix:semicolon
id|pmz_dispose_port
c_func
(paren
id|uport
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef CONFIG_SERIAL_PMACZILOG_CONSOLE
multiline_comment|/*&n; * Print a string to the serial port trying not to disturb&n; * any possible real use of the port...&n; */
DECL|function|pmz_console_write
r_static
r_void
id|pmz_console_write
c_func
(paren
r_struct
id|console
op_star
id|con
comma
r_const
r_char
op_star
id|s
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|uart_pmac_port
op_star
id|up
op_assign
op_amp
id|pmz_ports
(braket
id|con-&gt;index
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Turn of interrupts and enable the transmitter. */
id|write_zsreg
c_func
(paren
id|up
comma
id|R1
comma
id|up-&gt;curregs
(braket
l_int|1
)braket
op_amp
op_complement
id|TxINT_ENAB
)paren
suffix:semicolon
id|write_zsreg
c_func
(paren
id|up
comma
id|R5
comma
id|up-&gt;curregs
(braket
l_int|5
)braket
op_or
id|TxENABLE
op_or
id|RTS
op_or
id|DTR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Wait for the transmit buffer to empty. */
r_while
c_loop
(paren
(paren
id|read_zsreg
c_func
(paren
id|up
comma
id|R0
)paren
op_amp
id|Tx_BUF_EMP
)paren
op_eq
l_int|0
)paren
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|write_zsdata
c_func
(paren
id|up
comma
id|s
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
(braket
id|i
)braket
op_eq
l_int|10
)paren
(brace
r_while
c_loop
(paren
(paren
id|read_zsreg
c_func
(paren
id|up
comma
id|R0
)paren
op_amp
id|Tx_BUF_EMP
)paren
op_eq
l_int|0
)paren
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|write_zsdata
c_func
(paren
id|up
comma
id|R13
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Restore the values in the registers. */
id|write_zsreg
c_func
(paren
id|up
comma
id|R1
comma
id|up-&gt;curregs
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t disable the transmitter. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup the serial console&n; */
DECL|function|pmz_console_setup
r_static
r_int
id|__init
id|pmz_console_setup
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_char
op_star
id|options
)paren
(brace
r_struct
id|uart_port
op_star
id|port
suffix:semicolon
r_int
id|baud
op_assign
l_int|38400
suffix:semicolon
r_int
id|bits
op_assign
l_int|8
suffix:semicolon
r_int
id|parity
op_assign
l_char|&squot;n&squot;
suffix:semicolon
r_int
id|flow
op_assign
l_char|&squot;n&squot;
suffix:semicolon
r_int
r_int
id|pwr_delay
suffix:semicolon
multiline_comment|/*&n;&t; * XServe&squot;s default to 57600 bps&n;&t; */
r_if
c_cond
(paren
id|machine_is_compatible
c_func
(paren
l_string|&quot;RackMac1,1&quot;
)paren
op_logical_or
id|machine_is_compatible
c_func
(paren
l_string|&quot;RackMac1,2&quot;
)paren
)paren
id|baud
op_assign
l_int|57600
suffix:semicolon
multiline_comment|/*&n;&t; * Check whether an invalid uart number has been specified, and&n;&t; * if so, search for the first available port that does have&n;&t; * console support.&n;&t; */
r_if
c_cond
(paren
id|co-&gt;index
op_ge
id|pmz_ports_count
)paren
id|co-&gt;index
op_assign
l_int|0
suffix:semicolon
id|port
op_assign
op_amp
id|pmz_ports
(braket
id|co-&gt;index
)braket
dot
id|port
suffix:semicolon
multiline_comment|/*&n;&t; * Mark port as beeing a console&n;&t; */
id|port-&gt;flags
op_or_assign
id|PMACZILOG_FLAG_IS_CONS
suffix:semicolon
multiline_comment|/*&n;&t; * Temporary fix for uart layer who didn&squot;t setup the spinlock yet&n;&t; */
id|spin_lock_init
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enable the hardware&n;&t; */
id|pwr_delay
op_assign
id|__pmz_startup
c_func
(paren
op_amp
id|pmz_ports
(braket
id|co-&gt;index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pwr_delay
)paren
id|mdelay
c_func
(paren
id|pwr_delay
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options
)paren
id|uart_parse_options
c_func
(paren
id|options
comma
op_amp
id|baud
comma
op_amp
id|parity
comma
op_amp
id|bits
comma
op_amp
id|flow
)paren
suffix:semicolon
r_return
id|uart_set_options
c_func
(paren
id|port
comma
id|co
comma
id|baud
comma
id|parity
comma
id|bits
comma
id|flow
)paren
suffix:semicolon
)brace
DECL|function|pmz_console_init
r_static
r_int
id|__init
id|pmz_console_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Probe ports */
id|pmz_probe
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SERIAL_PMACZILOG_CONSOLE
macro_line|#endif
multiline_comment|/* TODO: Autoprobe console based on OF */
multiline_comment|/* pmz_console.index = i; */
id|register_console
c_func
(paren
op_amp
id|pmz_console
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pmz_console_init
id|console_initcall
c_func
(paren
id|pmz_console_init
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_PMACZILOG_CONSOLE */
DECL|variable|init_pmz
id|module_init
c_func
(paren
id|init_pmz
)paren
suffix:semicolon
DECL|variable|exit_pmz
id|module_exit
c_func
(paren
id|exit_pmz
)paren
suffix:semicolon
eof
