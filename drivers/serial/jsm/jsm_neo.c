multiline_comment|/************************************************************************&n; * Copyright 2003 Digi International (www.digi.com)&n; *&n; * Copyright (C) 2004 IBM Corporation. All rights reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED; without even the&n; * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR&n; * PURPOSE.  See the GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 * Temple Place - Suite 330, Boston,&n; * MA  02111-1307, USA.&n; *&n; * Contact Information:&n; * Scott H Kilau &lt;Scott_Kilau@digi.com&gt;&n; * Wendy Xiong   &lt;wendyx@us.ltcfwd.linux.ibm.com&gt;&n; *&n; ***********************************************************************/
macro_line|#include &lt;linux/delay.h&gt;&t;/* For udelay */
macro_line|#include &lt;linux/serial_reg.h&gt;&t;/* For the various UART offsets */
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;jsm.h&quot;&t;&t;/* Driver main header file */
DECL|variable|jsm_offset_table
r_static
id|u32
id|jsm_offset_table
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x01
comma
l_int|0x02
comma
l_int|0x04
comma
l_int|0x08
comma
l_int|0x10
comma
l_int|0x20
comma
l_int|0x40
comma
l_int|0x80
)brace
suffix:semicolon
multiline_comment|/*&n; * This function allows calls to ensure that all outstanding&n; * PCI writes have been completed, by doing a PCI read against&n; * a non-destructive, read-only location on the Neo card.&n; *&n; * In this case, we are reading the DVID (Read-only Device Identification)&n; * value of the Neo card.&n; */
DECL|function|neo_pci_posting_flush
r_static
r_inline
r_void
id|neo_pci_posting_flush
c_func
(paren
r_struct
id|jsm_board
op_star
id|bd
)paren
(brace
id|readb
c_func
(paren
id|bd-&gt;re_map_membase
op_plus
l_int|0x8D
)paren
suffix:semicolon
)brace
DECL|function|neo_set_cts_flow_control
r_static
r_void
id|neo_set_cts_flow_control
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|ier
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
id|u8
id|efr
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|PARAM
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Setting CTSFLOW&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Turn on auto CTS flow control */
id|ier
op_or_assign
(paren
id|UART_17158_IER_CTSDSR
)paren
suffix:semicolon
id|efr
op_or_assign
(paren
id|UART_17158_EFR_ECB
op_or
id|UART_17158_EFR_CTSDSR
)paren
suffix:semicolon
multiline_comment|/* Turn off auto Xon flow control */
id|efr
op_and_assign
op_complement
(paren
id|UART_17158_EFR_IXON
)paren
suffix:semicolon
multiline_comment|/* Why? Becuz Exar&squot;s spec says we have to zero it out before setting it */
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
multiline_comment|/* Turn on UART enhanced bits */
id|writeb
c_func
(paren
id|efr
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
multiline_comment|/* Turn on table D, with 8 char hi/low watermarks */
id|writeb
c_func
(paren
(paren
id|UART_17158_FCTR_TRGD
op_or
id|UART_17158_FCTR_RTS_4DELAY
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;fctr
)paren
suffix:semicolon
multiline_comment|/* Feed the UART our trigger levels */
id|writeb
c_func
(paren
l_int|8
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;tfifo
)paren
suffix:semicolon
id|ch-&gt;ch_t_tlevel
op_assign
l_int|8
suffix:semicolon
id|writeb
c_func
(paren
id|ier
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
)brace
DECL|function|neo_set_rts_flow_control
r_static
r_void
id|neo_set_rts_flow_control
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|ier
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
id|u8
id|efr
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|PARAM
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Setting RTSFLOW&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Turn on auto RTS flow control */
id|ier
op_or_assign
(paren
id|UART_17158_IER_RTSDTR
)paren
suffix:semicolon
id|efr
op_or_assign
(paren
id|UART_17158_EFR_ECB
op_or
id|UART_17158_EFR_RTSDTR
)paren
suffix:semicolon
multiline_comment|/* Turn off auto Xoff flow control */
id|ier
op_and_assign
op_complement
(paren
id|UART_17158_IER_XOFF
)paren
suffix:semicolon
id|efr
op_and_assign
op_complement
(paren
id|UART_17158_EFR_IXOFF
)paren
suffix:semicolon
multiline_comment|/* Why? Becuz Exar&squot;s spec says we have to zero it out before setting it */
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
multiline_comment|/* Turn on UART enhanced bits */
id|writeb
c_func
(paren
id|efr
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
id|writeb
c_func
(paren
(paren
id|UART_17158_FCTR_TRGD
op_or
id|UART_17158_FCTR_RTS_4DELAY
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;fctr
)paren
suffix:semicolon
id|ch-&gt;ch_r_watermark
op_assign
l_int|4
suffix:semicolon
id|writeb
c_func
(paren
l_int|56
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;rfifo
)paren
suffix:semicolon
id|ch-&gt;ch_r_tlevel
op_assign
l_int|56
suffix:semicolon
id|writeb
c_func
(paren
id|ier
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * From the Neo UART spec sheet:&n;&t; * The auto RTS/DTR function must be started by asserting&n;&t; * RTS/DTR# output pin (MCR bit-0 or 1 to logic 1 after&n;&t; * it is enabled.&n;&t; */
id|ch-&gt;ch_mostat
op_or_assign
(paren
id|UART_MCR_RTS
)paren
suffix:semicolon
)brace
DECL|function|neo_set_ixon_flow_control
r_static
r_void
id|neo_set_ixon_flow_control
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|ier
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
id|u8
id|efr
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|PARAM
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Setting IXON FLOW&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Turn off auto CTS flow control */
id|ier
op_and_assign
op_complement
(paren
id|UART_17158_IER_CTSDSR
)paren
suffix:semicolon
id|efr
op_and_assign
op_complement
(paren
id|UART_17158_EFR_CTSDSR
)paren
suffix:semicolon
multiline_comment|/* Turn on auto Xon flow control */
id|efr
op_or_assign
(paren
id|UART_17158_EFR_ECB
op_or
id|UART_17158_EFR_IXON
)paren
suffix:semicolon
multiline_comment|/* Why? Becuz Exar&squot;s spec says we have to zero it out before setting it */
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
multiline_comment|/* Turn on UART enhanced bits */
id|writeb
c_func
(paren
id|efr
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
id|writeb
c_func
(paren
(paren
id|UART_17158_FCTR_TRGD
op_or
id|UART_17158_FCTR_RTS_8DELAY
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;fctr
)paren
suffix:semicolon
id|ch-&gt;ch_r_watermark
op_assign
l_int|4
suffix:semicolon
id|writeb
c_func
(paren
l_int|32
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;rfifo
)paren
suffix:semicolon
id|ch-&gt;ch_r_tlevel
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* Tell UART what start/stop chars it should be looking for */
id|writeb
c_func
(paren
id|ch-&gt;ch_startc
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;xonchar1
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;xonchar2
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|ch-&gt;ch_stopc
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;xoffchar1
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;xoffchar2
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|ier
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
)brace
DECL|function|neo_set_ixoff_flow_control
r_static
r_void
id|neo_set_ixoff_flow_control
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|ier
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
id|u8
id|efr
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|PARAM
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Setting IXOFF FLOW&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Turn off auto RTS flow control */
id|ier
op_and_assign
op_complement
(paren
id|UART_17158_IER_RTSDTR
)paren
suffix:semicolon
id|efr
op_and_assign
op_complement
(paren
id|UART_17158_EFR_RTSDTR
)paren
suffix:semicolon
multiline_comment|/* Turn on auto Xoff flow control */
id|ier
op_or_assign
(paren
id|UART_17158_IER_XOFF
)paren
suffix:semicolon
id|efr
op_or_assign
(paren
id|UART_17158_EFR_ECB
op_or
id|UART_17158_EFR_IXOFF
)paren
suffix:semicolon
multiline_comment|/* Why? Becuz Exar&squot;s spec says we have to zero it out before setting it */
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
multiline_comment|/* Turn on UART enhanced bits */
id|writeb
c_func
(paren
id|efr
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
multiline_comment|/* Turn on table D, with 8 char hi/low watermarks */
id|writeb
c_func
(paren
(paren
id|UART_17158_FCTR_TRGD
op_or
id|UART_17158_FCTR_RTS_8DELAY
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;fctr
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|8
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;tfifo
)paren
suffix:semicolon
id|ch-&gt;ch_t_tlevel
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* Tell UART what start/stop chars it should be looking for */
id|writeb
c_func
(paren
id|ch-&gt;ch_startc
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;xonchar1
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;xonchar2
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|ch-&gt;ch_stopc
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;xoffchar1
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;xoffchar2
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|ier
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
)brace
DECL|function|neo_set_no_input_flow_control
r_static
r_void
id|neo_set_no_input_flow_control
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|ier
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
id|u8
id|efr
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|PARAM
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Unsetting Input FLOW&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Turn off auto RTS flow control */
id|ier
op_and_assign
op_complement
(paren
id|UART_17158_IER_RTSDTR
)paren
suffix:semicolon
id|efr
op_and_assign
op_complement
(paren
id|UART_17158_EFR_RTSDTR
)paren
suffix:semicolon
multiline_comment|/* Turn off auto Xoff flow control */
id|ier
op_and_assign
op_complement
(paren
id|UART_17158_IER_XOFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;ch_c_iflag
op_amp
id|IXON
)paren
id|efr
op_and_assign
op_complement
(paren
id|UART_17158_EFR_IXOFF
)paren
suffix:semicolon
r_else
id|efr
op_and_assign
op_complement
(paren
id|UART_17158_EFR_ECB
op_or
id|UART_17158_EFR_IXOFF
)paren
suffix:semicolon
multiline_comment|/* Why? Becuz Exar&squot;s spec says we have to zero it out before setting it */
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
multiline_comment|/* Turn on UART enhanced bits */
id|writeb
c_func
(paren
id|efr
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
multiline_comment|/* Turn on table D, with 8 char hi/low watermarks */
id|writeb
c_func
(paren
(paren
id|UART_17158_FCTR_TRGD
op_or
id|UART_17158_FCTR_RTS_8DELAY
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;fctr
)paren
suffix:semicolon
id|ch-&gt;ch_r_watermark
op_assign
l_int|0
suffix:semicolon
id|writeb
c_func
(paren
l_int|16
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;tfifo
)paren
suffix:semicolon
id|ch-&gt;ch_t_tlevel
op_assign
l_int|16
suffix:semicolon
id|writeb
c_func
(paren
l_int|16
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;rfifo
)paren
suffix:semicolon
id|ch-&gt;ch_r_tlevel
op_assign
l_int|16
suffix:semicolon
id|writeb
c_func
(paren
id|ier
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
)brace
DECL|function|neo_set_no_output_flow_control
r_static
r_void
id|neo_set_no_output_flow_control
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|ier
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
id|u8
id|efr
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|PARAM
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Unsetting Output FLOW&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Turn off auto CTS flow control */
id|ier
op_and_assign
op_complement
(paren
id|UART_17158_IER_CTSDSR
)paren
suffix:semicolon
id|efr
op_and_assign
op_complement
(paren
id|UART_17158_EFR_CTSDSR
)paren
suffix:semicolon
multiline_comment|/* Turn off auto Xon flow control */
r_if
c_cond
(paren
id|ch-&gt;ch_c_iflag
op_amp
id|IXOFF
)paren
id|efr
op_and_assign
op_complement
(paren
id|UART_17158_EFR_IXON
)paren
suffix:semicolon
r_else
id|efr
op_and_assign
op_complement
(paren
id|UART_17158_EFR_ECB
op_or
id|UART_17158_EFR_IXON
)paren
suffix:semicolon
multiline_comment|/* Why? Becuz Exar&squot;s spec says we have to zero it out before setting it */
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
multiline_comment|/* Turn on UART enhanced bits */
id|writeb
c_func
(paren
id|efr
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
multiline_comment|/* Turn on table D, with 8 char hi/low watermarks */
id|writeb
c_func
(paren
(paren
id|UART_17158_FCTR_TRGD
op_or
id|UART_17158_FCTR_RTS_8DELAY
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;fctr
)paren
suffix:semicolon
id|ch-&gt;ch_r_watermark
op_assign
l_int|0
suffix:semicolon
id|writeb
c_func
(paren
l_int|16
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;tfifo
)paren
suffix:semicolon
id|ch-&gt;ch_t_tlevel
op_assign
l_int|16
suffix:semicolon
id|writeb
c_func
(paren
l_int|16
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;rfifo
)paren
suffix:semicolon
id|ch-&gt;ch_r_tlevel
op_assign
l_int|16
suffix:semicolon
id|writeb
c_func
(paren
id|ier
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
)brace
DECL|function|neo_set_new_start_stop_chars
r_static
r_inline
r_void
id|neo_set_new_start_stop_chars
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
multiline_comment|/* if hardware flow control is set, then skip this whole thing */
r_if
c_cond
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|CRTSCTS
)paren
r_return
suffix:semicolon
id|jsm_printk
c_func
(paren
id|PARAM
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Tell UART what start/stop chars it should be looking for */
id|writeb
c_func
(paren
id|ch-&gt;ch_startc
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;xonchar1
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;xonchar2
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|ch-&gt;ch_stopc
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;xoffchar1
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;xoffchar2
)paren
suffix:semicolon
)brace
DECL|function|neo_copy_data_from_uart_to_queue
r_static
r_void
id|neo_copy_data_from_uart_to_queue
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
r_int
id|qleft
op_assign
l_int|0
suffix:semicolon
id|u8
id|linestatus
op_assign
l_int|0
suffix:semicolon
id|u8
id|error_mask
op_assign
l_int|0
suffix:semicolon
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_int
id|total
op_assign
l_int|0
suffix:semicolon
id|u16
id|head
suffix:semicolon
id|u16
id|tail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
multiline_comment|/* cache head and tail of queue */
id|head
op_assign
id|ch-&gt;ch_r_head
op_amp
id|RQUEUEMASK
suffix:semicolon
id|tail
op_assign
id|ch-&gt;ch_r_tail
op_amp
id|RQUEUEMASK
suffix:semicolon
multiline_comment|/* Get our cached LSR */
id|linestatus
op_assign
id|ch-&gt;ch_cached_lsr
suffix:semicolon
id|ch-&gt;ch_cached_lsr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Store how much space we have left in the queue */
r_if
c_cond
(paren
(paren
id|qleft
op_assign
id|tail
op_minus
id|head
op_minus
l_int|1
)paren
OL
l_int|0
)paren
id|qleft
op_add_assign
id|RQUEUEMASK
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If the UART is not in FIFO mode, force the FIFO copy to&n;&t; * NOT be run, by setting total to 0.&n;&t; *&n;&t; * On the other hand, if the UART IS in FIFO mode, then ask&n;&t; * the UART to give us an approximation of data it has RX&squot;ed.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_FIFO_ENABLED
)paren
)paren
id|total
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|total
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;rfifo
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * EXAR chip bug - RX FIFO COUNT - Fudge factor.&n;&t;&t; *&n;&t;&t; * This resolves a problem/bug with the Exar chip that sometimes&n;&t;&t; * returns a bogus value in the rfifo register.&n;&t;&t; * The count can be any where from 0-3 bytes &quot;off&quot;.&n;&t;&t; * Bizarre, but true.&n;&t;&t; */
id|total
op_sub_assign
l_int|3
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Finally, bound the copy to make sure we don&squot;t overflow&n;&t; * our own queue...&n;&t; * The byte by byte copy loop below this loop this will&n;&t; * deal with the queue overflow possibility.&n;&t; */
id|total
op_assign
id|min
c_func
(paren
id|total
comma
id|qleft
)paren
suffix:semicolon
r_while
c_loop
(paren
id|total
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Grab the linestatus register, we need to check&n;&t;&t; * to see if there are any errors in the FIFO.&n;&t;&t; */
id|linestatus
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;lsr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Break out if there is a FIFO error somewhere.&n;&t;&t; * This will allow us to go byte by byte down below,&n;&t;&t; * finding the exact location of the error.&n;&t;&t; */
r_if
c_cond
(paren
id|linestatus
op_amp
id|UART_17158_RX_FIFO_DATA_ERROR
)paren
r_break
suffix:semicolon
multiline_comment|/* Make sure we don&squot;t go over the end of our queue */
id|n
op_assign
id|min
c_func
(paren
(paren
(paren
id|u32
)paren
id|total
)paren
comma
(paren
id|RQUEUESIZE
op_minus
(paren
id|u32
)paren
id|head
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Cut down n even further if needed, this is to fix&n;&t;&t; * a problem with memcpy_fromio() with the Neo on the&n;&t;&t; * IBM pSeries platform.&n;&t;&t; * 15 bytes max appears to be the magic number.&n;&t;&t; */
id|n
op_assign
id|min
c_func
(paren
(paren
id|u32
)paren
id|n
comma
(paren
id|u32
)paren
l_int|12
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Since we are grabbing the linestatus register, which&n;&t;&t; * will reset some bits after our read, we need to ensure&n;&t;&t; * we don&squot;t miss our TX FIFO emptys.&n;&t;&t; */
r_if
c_cond
(paren
id|linestatus
op_amp
(paren
id|UART_LSR_THRE
op_or
id|UART_17158_TX_AND_FIFO_CLR
)paren
)paren
id|ch-&gt;ch_flags
op_or_assign
(paren
id|CH_TX_FIFO_EMPTY
op_or
id|CH_TX_FIFO_LWM
)paren
suffix:semicolon
id|linestatus
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Copy data from uart to the queue */
id|memcpy_fromio
c_func
(paren
id|ch-&gt;ch_rqueue
op_plus
id|head
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;txrxburst
comma
id|n
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Since RX_FIFO_DATA_ERROR was 0, we are guarenteed&n;&t;&t; * that all the data currently in the FIFO is free of&n;&t;&t; * breaks and parity/frame/orun errors.&n;&t;&t; */
id|memset
c_func
(paren
id|ch-&gt;ch_equeue
op_plus
id|head
comma
l_int|0
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* Add to and flip head if needed */
id|head
op_assign
(paren
id|head
op_plus
id|n
)paren
op_amp
id|RQUEUEMASK
suffix:semicolon
id|total
op_sub_assign
id|n
suffix:semicolon
id|qleft
op_sub_assign
id|n
suffix:semicolon
id|ch-&gt;ch_rxcount
op_add_assign
id|n
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Create a mask to determine whether we should&n;&t; * insert the character (if any) into our queue.&n;&t; */
r_if
c_cond
(paren
id|ch-&gt;ch_c_iflag
op_amp
id|IGNBRK
)paren
id|error_mask
op_or_assign
id|UART_LSR_BI
suffix:semicolon
multiline_comment|/*&n;&t; * Now cleanup any leftover bytes still in the UART.&n;&t; * Also deal with any possible queue overflow here as well.&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Its possible we have a linestatus from the loop above&n;&t;&t; * this, so we &quot;OR&quot; on any extra bits.&n;&t;&t; */
id|linestatus
op_or_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;lsr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the chip tells us there is no more data pending to&n;&t;&t; * be read, we can then leave.&n;&t;&t; * But before we do, cache the linestatus, just in case.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|linestatus
op_amp
id|UART_LSR_DR
)paren
)paren
(brace
id|ch-&gt;ch_cached_lsr
op_assign
id|linestatus
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* No need to store this bit */
id|linestatus
op_and_assign
op_complement
id|UART_LSR_DR
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Since we are grabbing the linestatus register, which&n;&t;&t; * will reset some bits after our read, we need to ensure&n;&t;&t; * we don&squot;t miss our TX FIFO emptys.&n;&t;&t; */
r_if
c_cond
(paren
id|linestatus
op_amp
(paren
id|UART_LSR_THRE
op_or
id|UART_17158_TX_AND_FIFO_CLR
)paren
)paren
(brace
id|linestatus
op_and_assign
op_complement
(paren
id|UART_LSR_THRE
op_or
id|UART_17158_TX_AND_FIFO_CLR
)paren
suffix:semicolon
id|ch-&gt;ch_flags
op_or_assign
(paren
id|CH_TX_FIFO_EMPTY
op_or
id|CH_TX_FIFO_LWM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Discard character if we are ignoring the error mask.&n;&t;&t; */
r_if
c_cond
(paren
id|linestatus
op_amp
id|error_mask
)paren
(brace
id|u8
id|discard
suffix:semicolon
id|linestatus
op_assign
l_int|0
suffix:semicolon
id|memcpy_fromio
c_func
(paren
op_amp
id|discard
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;txrxburst
comma
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If our queue is full, we have no choice but to drop some data.&n;&t;&t; * The assumption is that HWFLOW or SWFLOW should have stopped&n;&t;&t; * things way way before we got to this point.&n;&t;&t; *&n;&t;&t; * I decided that I wanted to ditch the oldest data first,&n;&t;&t; * I hope thats okay with everyone? Yes? Good.&n;&t;&t; */
r_while
c_loop
(paren
id|qleft
OL
l_int|1
)paren
(brace
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Queue full, dropping DATA:%x LSR:%x&bslash;n&quot;
comma
id|ch-&gt;ch_rqueue
(braket
id|tail
)braket
comma
id|ch-&gt;ch_equeue
(braket
id|tail
)braket
)paren
suffix:semicolon
id|ch-&gt;ch_r_tail
op_assign
id|tail
op_assign
(paren
id|tail
op_plus
l_int|1
)paren
op_amp
id|RQUEUEMASK
suffix:semicolon
id|ch-&gt;ch_err_overrun
op_increment
suffix:semicolon
id|qleft
op_increment
suffix:semicolon
)brace
id|memcpy_fromio
c_func
(paren
id|ch-&gt;ch_rqueue
op_plus
id|head
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;txrxburst
comma
l_int|1
)paren
suffix:semicolon
id|ch-&gt;ch_equeue
(braket
id|head
)braket
op_assign
(paren
id|u8
)paren
id|linestatus
suffix:semicolon
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;DATA/LSR pair: %x %x&bslash;n&quot;
comma
id|ch-&gt;ch_rqueue
(braket
id|head
)braket
comma
id|ch-&gt;ch_equeue
(braket
id|head
)braket
)paren
suffix:semicolon
multiline_comment|/* Ditch any remaining linestatus value. */
id|linestatus
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Add to and flip head if needed */
id|head
op_assign
(paren
id|head
op_plus
l_int|1
)paren
op_amp
id|RQUEUEMASK
suffix:semicolon
id|qleft
op_decrement
suffix:semicolon
id|ch-&gt;ch_rxcount
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Write new final heads to channel structure.&n;&t; */
id|ch-&gt;ch_r_head
op_assign
id|head
op_amp
id|RQUEUEMASK
suffix:semicolon
id|ch-&gt;ch_e_head
op_assign
id|head
op_amp
id|EQUEUEMASK
suffix:semicolon
id|jsm_input
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
DECL|function|neo_copy_data_from_queue_to_uart
r_static
r_void
id|neo_copy_data_from_queue_to_uart
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u16
id|head
suffix:semicolon
id|u16
id|tail
suffix:semicolon
r_int
id|n
suffix:semicolon
r_int
id|s
suffix:semicolon
r_int
id|qlen
suffix:semicolon
id|u32
id|len_written
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
multiline_comment|/* No data to write to the UART */
r_if
c_cond
(paren
id|ch-&gt;ch_w_tail
op_eq
id|ch-&gt;ch_w_head
)paren
r_return
suffix:semicolon
multiline_comment|/* If port is &quot;stopped&quot;, don&squot;t send any data to the UART */
r_if
c_cond
(paren
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_STOP
)paren
op_logical_or
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_BREAK_SENDING
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If FIFOs are disabled. Send data directly to txrx register&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_FIFO_ENABLED
)paren
)paren
(brace
id|u8
id|lsrbits
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;lsr
)paren
suffix:semicolon
id|ch-&gt;ch_cached_lsr
op_or_assign
id|lsrbits
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;ch_cached_lsr
op_amp
id|UART_LSR_THRE
)paren
(brace
id|ch-&gt;ch_cached_lsr
op_and_assign
op_complement
(paren
id|UART_LSR_THRE
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|ch-&gt;ch_wqueue
(braket
id|ch-&gt;ch_w_tail
)braket
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;txrx
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|WRITE
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Tx data: %x&bslash;n&quot;
comma
id|ch-&gt;ch_wqueue
(braket
id|ch-&gt;ch_w_head
)braket
)paren
suffix:semicolon
id|ch-&gt;ch_w_tail
op_increment
suffix:semicolon
id|ch-&gt;ch_w_tail
op_and_assign
id|WQUEUEMASK
suffix:semicolon
id|ch-&gt;ch_txcount
op_increment
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have to do it this way, because of the EXAR TXFIFO count bug.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch-&gt;ch_flags
op_amp
(paren
id|CH_TX_FIFO_EMPTY
op_or
id|CH_TX_FIFO_LWM
)paren
)paren
)paren
r_return
suffix:semicolon
id|len_written
op_assign
l_int|0
suffix:semicolon
id|n
op_assign
id|UART_17158_TX_FIFOSIZE
op_minus
id|ch-&gt;ch_t_tlevel
suffix:semicolon
multiline_comment|/* cache head and tail of queue */
id|head
op_assign
id|ch-&gt;ch_w_head
op_amp
id|WQUEUEMASK
suffix:semicolon
id|tail
op_assign
id|ch-&gt;ch_w_tail
op_amp
id|WQUEUEMASK
suffix:semicolon
id|qlen
op_assign
(paren
id|head
op_minus
id|tail
)paren
op_amp
id|WQUEUEMASK
suffix:semicolon
multiline_comment|/* Find minimum of the FIFO space, versus queue length */
id|n
op_assign
id|min
c_func
(paren
id|n
comma
id|qlen
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
OG
l_int|0
)paren
(brace
id|s
op_assign
(paren
(paren
id|head
op_ge
id|tail
)paren
ques
c_cond
id|head
suffix:colon
id|WQUEUESIZE
)paren
op_minus
id|tail
suffix:semicolon
id|s
op_assign
id|min
c_func
(paren
id|s
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|memcpy_toio
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;txrxburst
comma
id|ch-&gt;ch_wqueue
op_plus
id|tail
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* Add and flip queue if needed */
id|tail
op_assign
(paren
id|tail
op_plus
id|s
)paren
op_amp
id|WQUEUEMASK
suffix:semicolon
id|n
op_sub_assign
id|s
suffix:semicolon
id|ch-&gt;ch_txcount
op_add_assign
id|s
suffix:semicolon
id|len_written
op_add_assign
id|s
suffix:semicolon
)brace
multiline_comment|/* Update the final tail */
id|ch-&gt;ch_w_tail
op_assign
id|tail
op_amp
id|WQUEUEMASK
suffix:semicolon
r_if
c_cond
(paren
id|len_written
op_ge
id|ch-&gt;ch_t_tlevel
)paren
id|ch-&gt;ch_flags
op_and_assign
op_complement
(paren
id|CH_TX_FIFO_EMPTY
op_or
id|CH_TX_FIFO_LWM
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jsm_tty_write
c_func
(paren
op_amp
id|ch-&gt;uart_port
)paren
)paren
id|uart_write_wakeup
c_func
(paren
op_amp
id|ch-&gt;uart_port
)paren
suffix:semicolon
)brace
DECL|function|neo_parse_modem
r_static
r_void
id|neo_parse_modem
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
comma
id|u8
id|signals
)paren
(brace
id|u8
id|msignals
op_assign
id|signals
suffix:semicolon
id|jsm_printk
c_func
(paren
id|MSIGS
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;neo_parse_modem: port: %d msignals: %x&bslash;n&quot;
comma
id|ch-&gt;ch_portnum
comma
id|msignals
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
multiline_comment|/* Scrub off lower bits. They signify delta&squot;s, which I don&squot;t care about */
id|msignals
op_and_assign
l_int|0xf0
suffix:semicolon
r_if
c_cond
(paren
id|msignals
op_amp
id|UART_MSR_DCD
)paren
id|ch-&gt;ch_mistat
op_or_assign
id|UART_MSR_DCD
suffix:semicolon
r_else
id|ch-&gt;ch_mistat
op_and_assign
op_complement
id|UART_MSR_DCD
suffix:semicolon
r_if
c_cond
(paren
id|msignals
op_amp
id|UART_MSR_DSR
)paren
id|ch-&gt;ch_mistat
op_or_assign
id|UART_MSR_DSR
suffix:semicolon
r_else
id|ch-&gt;ch_mistat
op_and_assign
op_complement
id|UART_MSR_DSR
suffix:semicolon
r_if
c_cond
(paren
id|msignals
op_amp
id|UART_MSR_RI
)paren
id|ch-&gt;ch_mistat
op_or_assign
id|UART_MSR_RI
suffix:semicolon
r_else
id|ch-&gt;ch_mistat
op_and_assign
op_complement
id|UART_MSR_RI
suffix:semicolon
r_if
c_cond
(paren
id|msignals
op_amp
id|UART_MSR_CTS
)paren
id|ch-&gt;ch_mistat
op_or_assign
id|UART_MSR_CTS
suffix:semicolon
r_else
id|ch-&gt;ch_mistat
op_and_assign
op_complement
id|UART_MSR_CTS
suffix:semicolon
id|jsm_printk
c_func
(paren
id|MSIGS
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Port: %d DTR: %d RTS: %d CTS: %d DSR: %d &quot;
l_string|&quot;RI: %d CD: %d&bslash;n&quot;
comma
id|ch-&gt;ch_portnum
comma
op_logical_neg
op_logical_neg
(paren
(paren
id|ch-&gt;ch_mistat
op_or
id|ch-&gt;ch_mostat
)paren
op_amp
id|UART_MCR_DTR
)paren
comma
op_logical_neg
op_logical_neg
(paren
(paren
id|ch-&gt;ch_mistat
op_or
id|ch-&gt;ch_mostat
)paren
op_amp
id|UART_MCR_RTS
)paren
comma
op_logical_neg
op_logical_neg
(paren
(paren
id|ch-&gt;ch_mistat
op_or
id|ch-&gt;ch_mostat
)paren
op_amp
id|UART_MSR_CTS
)paren
comma
op_logical_neg
op_logical_neg
(paren
(paren
id|ch-&gt;ch_mistat
op_or
id|ch-&gt;ch_mostat
)paren
op_amp
id|UART_MSR_DSR
)paren
comma
op_logical_neg
op_logical_neg
(paren
(paren
id|ch-&gt;ch_mistat
op_or
id|ch-&gt;ch_mostat
)paren
op_amp
id|UART_MSR_RI
)paren
comma
op_logical_neg
op_logical_neg
(paren
(paren
id|ch-&gt;ch_mistat
op_or
id|ch-&gt;ch_mostat
)paren
op_amp
id|UART_MSR_DCD
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Make the UART raise any of the output signals we want up */
DECL|function|neo_assert_modem_signals
r_static
r_void
id|neo_assert_modem_signals
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
id|out
op_assign
id|ch-&gt;ch_mostat
suffix:semicolon
id|writeb
c_func
(paren
id|out
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;mcr
)paren
suffix:semicolon
multiline_comment|/* flush write operation */
id|neo_pci_posting_flush
c_func
(paren
id|ch-&gt;ch_bd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush the WRITE FIFO on the Neo.&n; *&n; * NOTE: Channel lock MUST be held before calling this function!&n; */
DECL|function|neo_flush_uart_write
r_static
r_void
id|neo_flush_uart_write
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|tmp
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
id|writeb
c_func
(paren
(paren
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_XMIT
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;isr_fcr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Check to see if the UART feels it completely flushed the FIFO. */
id|tmp
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;isr_fcr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
l_int|4
)paren
(brace
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Still flushing TX UART... i: %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
id|ch-&gt;ch_flags
op_or_assign
(paren
id|CH_TX_FIFO_EMPTY
op_or
id|CH_TX_FIFO_LWM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush the READ FIFO on the Neo.&n; *&n; * NOTE: Channel lock MUST be held before calling this function!&n; */
DECL|function|neo_flush_uart_read
r_static
r_void
id|neo_flush_uart_read
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|tmp
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
id|writeb
c_func
(paren
(paren
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;isr_fcr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Check to see if the UART feels it completely flushed the FIFO. */
id|tmp
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;isr_fcr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
l_int|2
)paren
(brace
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Still flushing RX UART... i: %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * No locks are assumed to be held when calling this function.&n; */
DECL|function|neo_clear_break
r_void
id|neo_clear_break
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
comma
r_int
id|force
)paren
(brace
r_int
r_int
id|lock_flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
multiline_comment|/* Turn break off, and unset some variables */
r_if
c_cond
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_BREAK_SENDING
)paren
(brace
id|u8
id|temp
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;lcr
)paren
suffix:semicolon
id|writeb
c_func
(paren
(paren
id|temp
op_amp
op_complement
id|UART_LCR_SBC
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;lcr
)paren
suffix:semicolon
id|ch-&gt;ch_flags
op_and_assign
op_complement
(paren
id|CH_BREAK_SENDING
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;clear break Finishing UART_LCR_SBC! finished: %lx&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
multiline_comment|/* flush write operation */
id|neo_pci_posting_flush
c_func
(paren
id|ch-&gt;ch_bd
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse the ISR register.&n; */
DECL|function|neo_parse_isr
r_static
r_inline
r_void
id|neo_parse_isr
c_func
(paren
r_struct
id|jsm_board
op_star
id|brd
comma
id|u32
id|port
)paren
(brace
r_struct
id|jsm_channel
op_star
id|ch
suffix:semicolon
id|u8
id|isr
suffix:semicolon
id|u8
id|cause
suffix:semicolon
r_int
r_int
id|lock_flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brd
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|port
OG
id|brd-&gt;maxports
)paren
r_return
suffix:semicolon
id|ch
op_assign
id|brd-&gt;channels
(braket
id|port
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
multiline_comment|/* Here we try to figure out what caused the interrupt to happen */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|isr
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;isr_fcr
)paren
suffix:semicolon
multiline_comment|/* Bail if no pending interrupt */
r_if
c_cond
(paren
id|isr
op_amp
id|UART_IIR_NO_INT
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Yank off the upper 2 bits, which just show that the FIFO&squot;s are enabled.&n;&t;&t; */
id|isr
op_and_assign
op_complement
(paren
id|UART_17158_IIR_FIFO_ENABLED
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INTR
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;%s:%d isr: %x&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|isr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isr
op_amp
(paren
id|UART_17158_IIR_RDI_TIMEOUT
op_or
id|UART_IIR_RDI
)paren
)paren
(brace
multiline_comment|/* Read data from uart -&gt; queue */
id|neo_copy_data_from_uart_to_queue
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* Call our tty layer to enforce queue flow control if needed. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|jsm_check_queue_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|isr
op_amp
id|UART_IIR_THRI
)paren
(brace
multiline_comment|/* Transfer data (if any) from Write Queue -&gt; UART. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|ch-&gt;ch_flags
op_or_assign
(paren
id|CH_TX_FIFO_EMPTY
op_or
id|CH_TX_FIFO_LWM
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|neo_copy_data_from_queue_to_uart
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|isr
op_amp
id|UART_17158_IIR_XONXOFF
)paren
(brace
id|cause
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;xoffchar1
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INTR
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Port %d. Got ISR_XONXOFF: cause:%x&bslash;n&quot;
comma
id|port
comma
id|cause
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Since the UART detected either an XON or&n;&t;&t;&t; * XOFF match, we need to figure out which&n;&t;&t;&t; * one it was, so we can suspend or resume data flow.&n;&t;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cause
op_eq
id|UART_17158_XON_DETECT
)paren
(brace
multiline_comment|/* Is output stopped right now, if so, resume it */
r_if
c_cond
(paren
id|brd-&gt;channels
(braket
id|port
)braket
op_member_access_from_pointer
id|ch_flags
op_amp
id|CH_STOP
)paren
(brace
id|ch-&gt;ch_flags
op_and_assign
op_complement
(paren
id|CH_STOP
)paren
suffix:semicolon
)brace
id|jsm_printk
c_func
(paren
id|INTR
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Port %d. XON detected in incoming data&bslash;n&quot;
comma
id|port
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cause
op_eq
id|UART_17158_XOFF_DETECT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|brd-&gt;channels
(braket
id|port
)braket
op_member_access_from_pointer
id|ch_flags
op_amp
id|CH_STOP
)paren
)paren
(brace
id|ch-&gt;ch_flags
op_or_assign
id|CH_STOP
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INTR
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Setting CH_STOP&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|jsm_printk
c_func
(paren
id|INTR
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Port: %d. XOFF detected in incoming data&bslash;n&quot;
comma
id|port
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|isr
op_amp
id|UART_17158_IIR_HWFLOW_STATE_CHANGE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we get here, this means the hardware is doing auto flow control.&n;&t;&t;&t; * Check to see whether RTS/DTR or CTS/DSR caused this interrupt.&n;&t;&t;&t; */
id|cause
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;mcr
)paren
suffix:semicolon
multiline_comment|/* Which pin is doing auto flow? RTS or DTR? */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cause
op_amp
l_int|0x4
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cause
op_amp
id|UART_MCR_RTS
)paren
id|ch-&gt;ch_mostat
op_or_assign
id|UART_MCR_RTS
suffix:semicolon
r_else
id|ch-&gt;ch_mostat
op_and_assign
op_complement
(paren
id|UART_MCR_RTS
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cause
op_amp
id|UART_MCR_DTR
)paren
id|ch-&gt;ch_mostat
op_or_assign
id|UART_MCR_DTR
suffix:semicolon
r_else
id|ch-&gt;ch_mostat
op_and_assign
op_complement
(paren
id|UART_MCR_DTR
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Parse any modem signal changes */
id|jsm_printk
c_func
(paren
id|INTR
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;MOD_STAT: sending to parse_modem_sigs&bslash;n&quot;
)paren
suffix:semicolon
id|neo_parse_modem
c_func
(paren
id|ch
comma
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;msr
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|neo_parse_lsr
r_static
r_inline
r_void
id|neo_parse_lsr
c_func
(paren
r_struct
id|jsm_board
op_star
id|brd
comma
id|u32
id|port
)paren
(brace
r_struct
id|jsm_channel
op_star
id|ch
suffix:semicolon
r_int
id|linestatus
suffix:semicolon
r_int
r_int
id|lock_flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brd
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|port
OG
id|brd-&gt;maxports
)paren
r_return
suffix:semicolon
id|ch
op_assign
id|brd-&gt;channels
(braket
id|port
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
id|linestatus
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;lsr
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INTR
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;%s:%d port: %d linestatus: %x&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|port
comma
id|linestatus
)paren
suffix:semicolon
id|ch-&gt;ch_cached_lsr
op_or_assign
id|linestatus
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;ch_cached_lsr
op_amp
id|UART_LSR_DR
)paren
(brace
multiline_comment|/* Read data from uart -&gt; queue */
id|neo_copy_data_from_uart_to_queue
c_func
(paren
id|ch
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|jsm_check_queue_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is a special flag. It indicates that at least 1&n;&t; * RX error (parity, framing, or break) has happened.&n;&t; * Mark this in our struct, which will tell me that I have&n;&t; *to do the special RX+LSR read for this FIFO load.&n;&t; */
r_if
c_cond
(paren
id|linestatus
op_amp
id|UART_17158_RX_FIFO_DATA_ERROR
)paren
id|jsm_printk
c_func
(paren
id|INTR
comma
id|DEBUG
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;%s:%d Port: %d Got an RX error, need to parse LSR&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|port
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The next 3 tests should *NOT* happen, as the above test&n;&t; * should encapsulate all 3... At least, thats what Exar says.&n;&t; */
r_if
c_cond
(paren
id|linestatus
op_amp
id|UART_LSR_PE
)paren
(brace
id|ch-&gt;ch_err_parity
op_increment
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INTR
comma
id|DEBUG
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;%s:%d Port: %d. PAR ERR!&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|linestatus
op_amp
id|UART_LSR_FE
)paren
(brace
id|ch-&gt;ch_err_frame
op_increment
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INTR
comma
id|DEBUG
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;%s:%d Port: %d. FRM ERR!&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|linestatus
op_amp
id|UART_LSR_BI
)paren
(brace
id|ch-&gt;ch_err_break
op_increment
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INTR
comma
id|DEBUG
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;%s:%d Port: %d. BRK INTR!&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|linestatus
op_amp
id|UART_LSR_OE
)paren
(brace
multiline_comment|/*&n;&t;&t; * Rx Oruns. Exar says that an orun will NOT corrupt&n;&t;&t; * the FIFO. It will just replace the holding register&n;&t;&t; * with this new data byte. So basically just ignore this.&n;&t;&t; * Probably we should eventually have an orun stat in our driver...&n;&t;&t; */
id|ch-&gt;ch_err_overrun
op_increment
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INTR
comma
id|DEBUG
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;%s:%d Port: %d. Rx Overrun!&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|linestatus
op_amp
id|UART_LSR_THRE
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|ch-&gt;ch_flags
op_or_assign
(paren
id|CH_TX_FIFO_EMPTY
op_or
id|CH_TX_FIFO_LWM
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
multiline_comment|/* Transfer data (if any) from Write Queue -&gt; UART. */
id|neo_copy_data_from_queue_to_uart
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|linestatus
op_amp
id|UART_17158_TX_AND_FIFO_CLR
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|ch-&gt;ch_flags
op_or_assign
(paren
id|CH_TX_FIFO_EMPTY
op_or
id|CH_TX_FIFO_LWM
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
multiline_comment|/* Transfer data (if any) from Write Queue -&gt; UART. */
id|neo_copy_data_from_queue_to_uart
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * neo_param()&n; * Send any/all changes to the line to the UART.&n; */
DECL|function|neo_param
r_static
r_void
id|neo_param
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|lcr
op_assign
l_int|0
suffix:semicolon
id|u8
id|uart_lcr
op_assign
l_int|0
suffix:semicolon
id|u8
id|ier
op_assign
l_int|0
suffix:semicolon
id|u32
id|baud
op_assign
l_int|9600
suffix:semicolon
r_int
id|quot
op_assign
l_int|0
suffix:semicolon
r_struct
id|jsm_board
op_star
id|bd
suffix:semicolon
id|bd
op_assign
id|ch-&gt;ch_bd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bd
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If baud rate is zero, flush queues, and set mval to drop DTR.&n;&t; */
r_if
c_cond
(paren
(paren
id|ch-&gt;ch_c_cflag
op_amp
(paren
id|CBAUD
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|ch-&gt;ch_r_head
op_assign
id|ch-&gt;ch_r_tail
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;ch_e_head
op_assign
id|ch-&gt;ch_e_tail
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;ch_w_head
op_assign
id|ch-&gt;ch_w_tail
op_assign
l_int|0
suffix:semicolon
id|neo_flush_uart_write
c_func
(paren
id|ch
)paren
suffix:semicolon
id|neo_flush_uart_read
c_func
(paren
id|ch
)paren
suffix:semicolon
id|ch-&gt;ch_flags
op_or_assign
(paren
id|CH_BAUD0
)paren
suffix:semicolon
id|ch-&gt;ch_mostat
op_and_assign
op_complement
(paren
id|UART_MCR_RTS
op_or
id|UART_MCR_DTR
)paren
suffix:semicolon
id|neo_assert_modem_signals
c_func
(paren
id|ch
)paren
suffix:semicolon
id|ch-&gt;ch_old_baud
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ch-&gt;ch_custom_speed
)paren
(brace
id|baud
op_assign
id|ch-&gt;ch_custom_speed
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_BAUD0
)paren
id|ch-&gt;ch_flags
op_and_assign
op_complement
(paren
id|CH_BAUD0
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|iindex
op_assign
l_int|0
suffix:semicolon
r_int
id|jindex
op_assign
l_int|0
suffix:semicolon
r_const
id|u64
id|bauds
(braket
l_int|4
)braket
(braket
l_int|16
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|50
comma
l_int|75
comma
l_int|110
comma
l_int|134
comma
l_int|150
comma
l_int|200
comma
l_int|300
comma
l_int|600
comma
l_int|1200
comma
l_int|1800
comma
l_int|2400
comma
l_int|4800
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
)brace
comma
(brace
l_int|0
comma
l_int|57600
comma
l_int|115200
comma
l_int|230400
comma
l_int|460800
comma
l_int|150
comma
l_int|200
comma
l_int|921600
comma
l_int|600
comma
l_int|1200
comma
l_int|1800
comma
l_int|2400
comma
l_int|4800
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
)brace
comma
(brace
l_int|0
comma
l_int|57600
comma
l_int|76800
comma
l_int|115200
comma
l_int|131657
comma
l_int|153600
comma
l_int|230400
comma
l_int|460800
comma
l_int|921600
comma
l_int|1200
comma
l_int|1800
comma
l_int|2400
comma
l_int|4800
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
)brace
comma
(brace
l_int|0
comma
l_int|57600
comma
l_int|115200
comma
l_int|230400
comma
l_int|460800
comma
l_int|150
comma
l_int|200
comma
l_int|921600
comma
l_int|600
comma
l_int|1200
comma
l_int|1800
comma
l_int|2400
comma
l_int|4800
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
)brace
)brace
suffix:semicolon
id|baud
op_assign
id|C_BAUD
c_func
(paren
id|ch-&gt;uart_port.info-&gt;tty
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|CBAUDEX
)paren
id|iindex
op_assign
l_int|1
suffix:semicolon
id|jindex
op_assign
id|baud
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iindex
op_ge
l_int|0
)paren
op_logical_and
(paren
id|iindex
OL
l_int|4
)paren
op_logical_and
(paren
id|jindex
op_ge
l_int|0
)paren
op_logical_and
(paren
id|jindex
OL
l_int|16
)paren
)paren
id|baud
op_assign
id|bauds
(braket
id|iindex
)braket
(braket
id|jindex
)braket
suffix:semicolon
r_else
(brace
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|DEBUG
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;baud indices were out of range (%d)(%d)&quot;
comma
id|iindex
comma
id|jindex
)paren
suffix:semicolon
id|baud
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|baud
op_eq
l_int|0
)paren
id|baud
op_assign
l_int|9600
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_BAUD0
)paren
id|ch-&gt;ch_flags
op_and_assign
op_complement
(paren
id|CH_BAUD0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|PARENB
)paren
id|lcr
op_or_assign
id|UART_LCR_PARITY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|PARODD
)paren
)paren
id|lcr
op_or_assign
id|UART_LCR_EPAR
suffix:semicolon
multiline_comment|/*&n;&t; * Not all platforms support mark/space parity,&n;&t; * so this will hide behind an ifdef.&n;&t; */
macro_line|#ifdef CMSPAR
r_if
c_cond
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|CMSPAR
)paren
id|lcr
op_or_assign
id|UART_LCR_SPAR
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|CSTOPB
)paren
id|lcr
op_or_assign
id|UART_LCR_STOP
suffix:semicolon
r_switch
c_cond
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|lcr
op_or_assign
id|UART_LCR_WLEN5
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|lcr
op_or_assign
id|UART_LCR_WLEN6
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|lcr
op_or_assign
id|UART_LCR_WLEN7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS8
suffix:colon
r_default
suffix:colon
id|lcr
op_or_assign
id|UART_LCR_WLEN8
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ier
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
id|uart_lcr
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;lcr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|baud
op_eq
l_int|0
)paren
id|baud
op_assign
l_int|9600
suffix:semicolon
id|quot
op_assign
id|ch-&gt;ch_bd-&gt;bd_dividend
op_div
id|baud
suffix:semicolon
r_if
c_cond
(paren
id|quot
op_ne
l_int|0
)paren
(brace
id|ch-&gt;ch_old_baud
op_assign
id|baud
suffix:semicolon
id|writeb
c_func
(paren
id|UART_LCR_DLAB
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;lcr
)paren
suffix:semicolon
id|writeb
c_func
(paren
(paren
id|quot
op_amp
l_int|0xff
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;txrx
)paren
suffix:semicolon
id|writeb
c_func
(paren
(paren
id|quot
op_rshift
l_int|8
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|lcr
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;lcr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uart_lcr
op_ne
id|lcr
)paren
id|writeb
c_func
(paren
id|lcr
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;lcr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|CREAD
)paren
id|ier
op_or_assign
(paren
id|UART_IER_RDI
op_or
id|UART_IER_RLSI
)paren
suffix:semicolon
id|ier
op_or_assign
(paren
id|UART_IER_THRI
op_or
id|UART_IER_MSI
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|ier
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
multiline_comment|/* Set new start/stop chars */
id|neo_set_new_start_stop_chars
c_func
(paren
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|CRTSCTS
)paren
id|neo_set_cts_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ch-&gt;ch_c_iflag
op_amp
id|IXON
)paren
(brace
multiline_comment|/* If start/stop is set to disable, then we should disable flow control */
r_if
c_cond
(paren
(paren
id|ch-&gt;ch_startc
op_eq
id|__DISABLED_CHAR
)paren
op_logical_or
(paren
id|ch-&gt;ch_stopc
op_eq
id|__DISABLED_CHAR
)paren
)paren
id|neo_set_no_output_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
r_else
id|neo_set_ixon_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
r_else
id|neo_set_no_output_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|CRTSCTS
)paren
id|neo_set_rts_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ch-&gt;ch_c_iflag
op_amp
id|IXOFF
)paren
(brace
multiline_comment|/* If start/stop is set to disable, then we should disable flow control */
r_if
c_cond
(paren
(paren
id|ch-&gt;ch_startc
op_eq
id|__DISABLED_CHAR
)paren
op_logical_or
(paren
id|ch-&gt;ch_stopc
op_eq
id|__DISABLED_CHAR
)paren
)paren
id|neo_set_no_input_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
r_else
id|neo_set_ixoff_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
r_else
id|neo_set_no_input_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust the RX FIFO Trigger level if baud is less than 9600.&n;&t; * Not exactly elegant, but this is needed because of the Exar chip&squot;s&n;&t; * delay on firing off the RX FIFO interrupt on slower baud rates.&n;&t; */
r_if
c_cond
(paren
id|baud
OL
l_int|9600
)paren
(brace
id|writeb
c_func
(paren
l_int|1
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;rfifo
)paren
suffix:semicolon
id|ch-&gt;ch_r_tlevel
op_assign
l_int|1
suffix:semicolon
)brace
id|neo_assert_modem_signals
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* Get current status of the modem signals now */
id|neo_parse_modem
c_func
(paren
id|ch
comma
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;msr
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * jsm_neo_intr()&n; *&n; * Neo specific interrupt handler.&n; */
DECL|function|neo_intr
r_static
id|irqreturn_t
id|neo_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|voidbrd
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|jsm_board
op_star
id|brd
op_assign
(paren
r_struct
id|jsm_board
op_star
)paren
id|voidbrd
suffix:semicolon
r_struct
id|jsm_channel
op_star
id|ch
suffix:semicolon
r_int
id|port
op_assign
l_int|0
suffix:semicolon
r_int
id|type
op_assign
l_int|0
suffix:semicolon
r_int
id|current_port
suffix:semicolon
id|u32
id|tmp
suffix:semicolon
id|u32
id|uart_poll
suffix:semicolon
r_int
r_int
id|lock_flags
suffix:semicolon
r_int
r_int
id|lock_flags2
suffix:semicolon
r_int
id|outofloop_count
op_assign
l_int|0
suffix:semicolon
id|brd-&gt;intr_count
op_increment
suffix:semicolon
multiline_comment|/* Lock out the slow poller from running on this board. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|brd-&gt;bd_intr_lock
comma
id|lock_flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read in &quot;extended&quot; IRQ information from the 32bit Neo register.&n;&t; * Bits 0-7: What port triggered the interrupt.&n;&t; * Bits 8-31: Each 3bits indicate what type of interrupt occurred.&n;&t; */
id|uart_poll
op_assign
id|readl
c_func
(paren
id|brd-&gt;re_map_membase
op_plus
id|UART_17158_POLL_ADDR_OFFSET
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INTR
comma
id|INFO
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;%s:%d uart_poll: %x&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|uart_poll
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uart_poll
)paren
(brace
id|jsm_printk
c_func
(paren
id|INTR
comma
id|INFO
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;Kernel interrupted to me, but no pending interrupts...&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|brd-&gt;bd_intr_lock
comma
id|lock_flags
)paren
suffix:semicolon
r_return
id|IRQ_NONE
suffix:semicolon
)brace
multiline_comment|/* At this point, we have at least SOMETHING to service, dig further... */
id|current_port
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Loop on each port */
r_while
c_loop
(paren
(paren
(paren
id|uart_poll
op_amp
l_int|0xff
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|outofloop_count
OL
l_int|0xff
)paren
)paren
(brace
id|tmp
op_assign
id|uart_poll
suffix:semicolon
id|outofloop_count
op_increment
suffix:semicolon
multiline_comment|/* Check current port to see if it has interrupt pending */
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|jsm_offset_table
(braket
id|current_port
)braket
)paren
op_ne
l_int|0
)paren
(brace
id|port
op_assign
id|current_port
suffix:semicolon
id|type
op_assign
id|tmp
op_rshift
(paren
l_int|8
op_plus
(paren
id|port
op_star
l_int|3
)paren
)paren
suffix:semicolon
id|type
op_and_assign
l_int|0x7
suffix:semicolon
)brace
r_else
(brace
id|current_port
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|jsm_printk
c_func
(paren
id|INTR
comma
id|INFO
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;%s:%d port: %x type: %x&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|port
comma
id|type
)paren
suffix:semicolon
multiline_comment|/* Remove this port + type from uart_poll */
id|uart_poll
op_and_assign
op_complement
(paren
id|jsm_offset_table
(braket
id|port
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|type
)paren
(brace
multiline_comment|/* If no type, just ignore it, and move onto next port */
id|jsm_printk
c_func
(paren
id|INTR
comma
id|ERR
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;Interrupt with no type! port: %d&bslash;n&quot;
comma
id|port
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Switch on type of interrupt we have */
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|UART_17158_RXRDY_TIMEOUT
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * RXRDY Time-out is cleared by reading data in the&n;&t;&t;&t;* RX FIFO until it falls below the trigger level.&n;&t;&t;&t; */
multiline_comment|/* Verify the port is in range. */
r_if
c_cond
(paren
id|port
OG
id|brd-&gt;nasync
)paren
r_continue
suffix:semicolon
id|ch
op_assign
id|brd-&gt;channels
(braket
id|port
)braket
suffix:semicolon
id|neo_copy_data_from_uart_to_queue
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* Call our tty layer to enforce queue flow control if needed. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags2
)paren
suffix:semicolon
id|jsm_check_queue_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags2
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|UART_17158_RX_LINE_STATUS
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * RXRDY and RX LINE Status (logic OR of LSR[4:1])&n;&t;&t;&t; */
id|neo_parse_lsr
c_func
(paren
id|brd
comma
id|port
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|UART_17158_TXRDY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * TXRDY interrupt clears after reading ISR register for the UART channel.&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * Yes, this is odd...&n;&t;&t;&t; * Why would I check EVERY possibility of type of&n;&t;&t;&t; * interrupt, when we know its TXRDY???&n;&t;&t;&t; * Becuz for some reason, even tho we got triggered for TXRDY,&n;&t;&t;&t; * it seems to be occassionally wrong. Instead of TX, which&n;&t;&t;&t; * it should be, I was getting things like RXDY too. Weird.&n;&t;&t;&t; */
id|neo_parse_isr
c_func
(paren
id|brd
comma
id|port
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|UART_17158_MSR
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * MSR or flow control was seen.&n;&t;&t;&t; */
id|neo_parse_isr
c_func
(paren
id|brd
comma
id|port
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * The UART triggered us with a bogus interrupt type.&n;&t;&t;&t; * It appears the Exar chip, when REALLY bogged down, will throw&n;&t;&t;&t; * these once and awhile.&n;&t;&t;&t; * Its harmless, just ignore it and move on.&n;&t;&t;&t; */
id|jsm_printk
c_func
(paren
id|INTR
comma
id|ERR
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;%s:%d Unknown Interrupt type: %x&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|type
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|brd-&gt;bd_intr_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INTR
comma
id|INFO
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;finish.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; * Neo specific way of turning off the receiver.&n; * Used as a way to enforce queue flow control when in&n; * hardware flow control mode.&n; */
DECL|function|neo_disable_receiver
r_static
r_void
id|neo_disable_receiver
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|tmp
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
(paren
id|UART_IER_RDI
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|tmp
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
multiline_comment|/* flush write operation */
id|neo_pci_posting_flush
c_func
(paren
id|ch-&gt;ch_bd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Neo specific way of turning on the receiver.&n; * Used as a way to un-enforce queue flow control when in&n; * hardware flow control mode.&n; */
DECL|function|neo_enable_receiver
r_static
r_void
id|neo_enable_receiver
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|tmp
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
id|tmp
op_or_assign
(paren
id|UART_IER_RDI
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|tmp
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
multiline_comment|/* flush write operation */
id|neo_pci_posting_flush
c_func
(paren
id|ch-&gt;ch_bd
)paren
suffix:semicolon
)brace
DECL|function|neo_send_start_character
r_static
r_void
id|neo_send_start_character
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;ch_startc
op_ne
id|__DISABLED_CHAR
)paren
(brace
id|ch-&gt;ch_xon_sends
op_increment
suffix:semicolon
id|writeb
c_func
(paren
id|ch-&gt;ch_startc
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;txrx
)paren
suffix:semicolon
multiline_comment|/* flush write operation */
id|neo_pci_posting_flush
c_func
(paren
id|ch-&gt;ch_bd
)paren
suffix:semicolon
)brace
)brace
DECL|function|neo_send_stop_character
r_static
r_void
id|neo_send_stop_character
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;ch_stopc
op_ne
id|__DISABLED_CHAR
)paren
(brace
id|ch-&gt;ch_xoff_sends
op_increment
suffix:semicolon
id|writeb
c_func
(paren
id|ch-&gt;ch_stopc
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;txrx
)paren
suffix:semicolon
multiline_comment|/* flush write operation */
id|neo_pci_posting_flush
c_func
(paren
id|ch-&gt;ch_bd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * neo_uart_init&n; */
DECL|function|neo_uart_init
r_static
r_void
id|neo_uart_init
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|UART_EFR_ECB
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
multiline_comment|/* Clear out UART and FIFO */
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;txrx
)paren
suffix:semicolon
id|writeb
c_func
(paren
(paren
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;isr_fcr
)paren
suffix:semicolon
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;lsr
)paren
suffix:semicolon
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;msr
)paren
suffix:semicolon
id|ch-&gt;ch_flags
op_or_assign
id|CH_FIFO_ENABLED
suffix:semicolon
multiline_comment|/* Assert any signals we want up */
id|writeb
c_func
(paren
id|ch-&gt;ch_mostat
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;mcr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Make the UART completely turn off.&n; */
DECL|function|neo_uart_off
r_static
r_void
id|neo_uart_off
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
multiline_comment|/* Turn off UART enhanced bits */
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;efr
)paren
suffix:semicolon
multiline_comment|/* Stop all interrupts from occurring. */
id|writeb
c_func
(paren
l_int|0
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;ier
)paren
suffix:semicolon
)brace
DECL|function|neo_get_uart_bytes_left
r_static
id|u32
id|neo_get_uart_bytes_left
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
id|u8
id|left
op_assign
l_int|0
suffix:semicolon
id|u8
id|lsr
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;lsr
)paren
suffix:semicolon
multiline_comment|/* We must cache the LSR as some of the bits get reset once read... */
id|ch-&gt;ch_cached_lsr
op_or_assign
id|lsr
suffix:semicolon
multiline_comment|/* Determine whether the Transmitter is empty or not */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lsr
op_amp
id|UART_LSR_TEMT
)paren
)paren
id|left
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|ch-&gt;ch_flags
op_or_assign
(paren
id|CH_TX_FIFO_EMPTY
op_or
id|CH_TX_FIFO_LWM
)paren
suffix:semicolon
id|left
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|left
suffix:semicolon
)brace
multiline_comment|/* Channel lock MUST be held by the calling function! */
DECL|function|neo_send_break
r_static
r_void
id|neo_send_break
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
multiline_comment|/*&n;&t; * Set the time we should stop sending the break.&n;&t; * If we are already sending a break, toss away the existing&n;&t; * time to stop, and use this new value instead.&n;&t; */
multiline_comment|/* Tell the UART to start sending the break */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_BREAK_SENDING
)paren
)paren
(brace
id|u8
id|temp
op_assign
id|readb
c_func
(paren
op_amp
id|ch-&gt;ch_neo_uart-&gt;lcr
)paren
suffix:semicolon
id|writeb
c_func
(paren
(paren
id|temp
op_or
id|UART_LCR_SBC
)paren
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;lcr
)paren
suffix:semicolon
id|ch-&gt;ch_flags
op_or_assign
(paren
id|CH_BREAK_SENDING
)paren
suffix:semicolon
multiline_comment|/* flush write operation */
id|neo_pci_posting_flush
c_func
(paren
id|ch-&gt;ch_bd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * neo_send_immediate_char.&n; *&n; * Sends a specific character as soon as possible to the UART,&n; * jumping over any bytes that might be in the write queue.&n; *&n; * The channel lock MUST be held by the calling function.&n; */
DECL|function|neo_send_immediate_char
r_static
r_void
id|neo_send_immediate_char
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
comma
r_int
r_char
id|c
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
id|writeb
c_func
(paren
id|c
comma
op_amp
id|ch-&gt;ch_neo_uart-&gt;txrx
)paren
suffix:semicolon
multiline_comment|/* flush write operation */
id|neo_pci_posting_flush
c_func
(paren
id|ch-&gt;ch_bd
)paren
suffix:semicolon
)brace
DECL|variable|jsm_neo_ops
r_struct
id|board_ops
id|jsm_neo_ops
op_assign
(brace
dot
id|intr
op_assign
id|neo_intr
comma
dot
id|uart_init
op_assign
id|neo_uart_init
comma
dot
id|uart_off
op_assign
id|neo_uart_off
comma
dot
id|param
op_assign
id|neo_param
comma
dot
id|assert_modem_signals
op_assign
id|neo_assert_modem_signals
comma
dot
id|flush_uart_write
op_assign
id|neo_flush_uart_write
comma
dot
id|flush_uart_read
op_assign
id|neo_flush_uart_read
comma
dot
id|disable_receiver
op_assign
id|neo_disable_receiver
comma
dot
id|enable_receiver
op_assign
id|neo_enable_receiver
comma
dot
id|send_break
op_assign
id|neo_send_break
comma
dot
id|clear_break
op_assign
id|neo_clear_break
comma
dot
id|send_start_character
op_assign
id|neo_send_start_character
comma
dot
id|send_stop_character
op_assign
id|neo_send_stop_character
comma
dot
id|copy_data_from_queue_to_uart
op_assign
id|neo_copy_data_from_queue_to_uart
comma
dot
id|get_uart_bytes_left
op_assign
id|neo_get_uart_bytes_left
comma
dot
id|send_immediate_char
op_assign
id|neo_send_immediate_char
)brace
suffix:semicolon
eof
