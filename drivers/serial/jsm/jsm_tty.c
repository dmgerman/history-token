multiline_comment|/************************************************************************&n; * Copyright 2003 Digi International (www.digi.com)&n; *&n; * Copyright (C) 2004 IBM Corporation. All rights reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED; without even the&n; * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR&n; * PURPOSE.  See the GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 * Temple Place - Suite 330, Boston,&n; * MA  02111-1307, USA.&n; *&n; * Contact Information:&n; * Scott H Kilau &lt;Scott_Kilau@digi.com&gt;&n; * Wendy Xiong   &lt;wendyx@us.ltcfwd.linux.ibm.com&gt;&n; *&n; ***********************************************************************/
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/serial_reg.h&gt;
macro_line|#include &lt;linux/delay.h&gt;&t;/* For udelay */
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &quot;jsm.h&quot;
DECL|function|jsm_get_mstat
r_static
r_inline
r_int
id|jsm_get_mstat
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
r_int
r_char
id|mstat
suffix:semicolon
r_int
r_char
id|result
suffix:semicolon
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
id|mstat
op_assign
(paren
id|ch-&gt;ch_mostat
op_or
id|ch-&gt;ch_mistat
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|UART_MCR_DTR
)paren
id|result
op_or_assign
id|TIOCM_DTR
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|UART_MCR_RTS
)paren
id|result
op_or_assign
id|TIOCM_RTS
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|UART_MSR_CTS
)paren
id|result
op_or_assign
id|TIOCM_CTS
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|UART_MSR_DSR
)paren
id|result
op_or_assign
id|TIOCM_DSR
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|UART_MSR_RI
)paren
id|result
op_or_assign
id|TIOCM_RI
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|UART_MSR_DCD
)paren
id|result
op_or_assign
id|TIOCM_CD
suffix:semicolon
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;finish&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|jsm_tty_tx_empty
r_static
r_int
r_int
id|jsm_tty_tx_empty
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_return
id|TIOCSER_TEMT
suffix:semicolon
)brace
multiline_comment|/*&n; * Return modem signals to ld.&n; */
DECL|function|jsm_tty_get_mctrl
r_static
r_int
r_int
id|jsm_tty_get_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_int
id|result
suffix:semicolon
r_struct
id|jsm_channel
op_star
id|channel
op_assign
(paren
r_struct
id|jsm_channel
op_star
)paren
id|port
suffix:semicolon
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|jsm_get_mstat
c_func
(paren
id|channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;finish&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * jsm_set_modem_info()&n; *&n; * Set modem signals, called by ld.&n; */
DECL|function|jsm_tty_set_mctrl
r_static
r_void
id|jsm_tty_set_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|mctrl
)paren
(brace
r_struct
id|jsm_channel
op_star
id|channel
op_assign
(paren
r_struct
id|jsm_channel
op_star
)paren
id|port
suffix:semicolon
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_RTS
)paren
id|channel-&gt;ch_mostat
op_or_assign
id|UART_MCR_RTS
suffix:semicolon
r_else
id|channel-&gt;ch_mostat
op_and_assign
op_complement
id|UART_MCR_RTS
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_DTR
)paren
id|channel-&gt;ch_mostat
op_or_assign
id|UART_MCR_DTR
suffix:semicolon
r_else
id|channel-&gt;ch_mostat
op_and_assign
op_complement
id|UART_MCR_DTR
suffix:semicolon
id|channel-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|assert_modem_signals
c_func
(paren
id|channel
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;finish&bslash;n&quot;
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|jsm_tty_start_tx
r_static
r_void
id|jsm_tty_start_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|tty_start
)paren
(brace
r_struct
id|jsm_channel
op_star
id|channel
op_assign
(paren
r_struct
id|jsm_channel
op_star
)paren
id|port
suffix:semicolon
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
id|channel-&gt;ch_flags
op_and_assign
op_complement
(paren
id|CH_STOP
)paren
suffix:semicolon
id|jsm_tty_write
c_func
(paren
id|port
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;finish&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|jsm_tty_stop_tx
r_static
r_void
id|jsm_tty_stop_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|tty_stop
)paren
(brace
r_struct
id|jsm_channel
op_star
id|channel
op_assign
(paren
r_struct
id|jsm_channel
op_star
)paren
id|port
suffix:semicolon
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
id|channel-&gt;ch_flags
op_or_assign
(paren
id|CH_STOP
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;finish&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|jsm_tty_send_xchar
r_static
r_void
id|jsm_tty_send_xchar
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_char
id|ch
)paren
(brace
r_int
r_int
id|lock_flags
suffix:semicolon
r_struct
id|jsm_channel
op_star
id|channel
op_assign
(paren
r_struct
id|jsm_channel
op_star
)paren
id|port
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|lock_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
id|port-&gt;info-&gt;tty-&gt;termios-&gt;c_cc
(braket
id|VSTART
)braket
)paren
id|channel-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|send_start_character
c_func
(paren
id|channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
id|port-&gt;info-&gt;tty-&gt;termios-&gt;c_cc
(braket
id|VSTOP
)braket
)paren
id|channel-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|send_stop_character
c_func
(paren
id|channel
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|lock_flags
)paren
suffix:semicolon
)brace
DECL|function|jsm_tty_stop_rx
r_static
r_void
id|jsm_tty_stop_rx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|jsm_channel
op_star
id|channel
op_assign
(paren
r_struct
id|jsm_channel
op_star
)paren
id|port
suffix:semicolon
id|channel-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|disable_receiver
c_func
(paren
id|channel
)paren
suffix:semicolon
)brace
DECL|function|jsm_tty_break
r_static
r_void
id|jsm_tty_break
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
id|break_state
)paren
(brace
r_int
r_int
id|lock_flags
suffix:semicolon
r_struct
id|jsm_channel
op_star
id|channel
op_assign
(paren
r_struct
id|jsm_channel
op_star
)paren
id|port
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|lock_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|break_state
op_eq
op_minus
l_int|1
)paren
id|channel-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|send_break
c_func
(paren
id|channel
)paren
suffix:semicolon
r_else
id|channel-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|clear_break
c_func
(paren
id|channel
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|lock_flags
)paren
suffix:semicolon
)brace
DECL|function|jsm_tty_open
r_static
r_int
id|jsm_tty_open
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|jsm_board
op_star
id|brd
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|jsm_channel
op_star
id|channel
op_assign
(paren
r_struct
id|jsm_channel
op_star
)paren
id|port
suffix:semicolon
multiline_comment|/* Get board pointer from our array of majors we have allocated */
id|brd
op_assign
id|channel-&gt;ch_bd
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate channel buffers for read/write/error.&n;&t; * Set flag, so we don&squot;t get trounced on.&n;&t; */
id|channel-&gt;ch_flags
op_or_assign
(paren
id|CH_OPENING
)paren
suffix:semicolon
multiline_comment|/* Drop locks, as malloc with GFP_KERNEL can sleep */
r_if
c_cond
(paren
op_logical_neg
id|channel-&gt;ch_rqueue
)paren
(brace
id|channel-&gt;ch_rqueue
op_assign
(paren
id|u8
op_star
)paren
id|kmalloc
c_func
(paren
id|RQUEUESIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|channel-&gt;ch_rqueue
)paren
(brace
id|jsm_printk
c_func
(paren
id|INIT
comma
id|ERR
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;unable to allocate read queue buf&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|channel-&gt;ch_rqueue
comma
l_int|0
comma
id|RQUEUESIZE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|channel-&gt;ch_equeue
)paren
(brace
id|channel-&gt;ch_equeue
op_assign
(paren
id|u8
op_star
)paren
id|kmalloc
c_func
(paren
id|EQUEUESIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|channel-&gt;ch_equeue
)paren
(brace
id|jsm_printk
c_func
(paren
id|INIT
comma
id|ERR
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;unable to allocate error queue buf&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|channel-&gt;ch_equeue
comma
l_int|0
comma
id|EQUEUESIZE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|channel-&gt;ch_wqueue
)paren
(brace
id|channel-&gt;ch_wqueue
op_assign
(paren
id|u8
op_star
)paren
id|kmalloc
c_func
(paren
id|WQUEUESIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|channel-&gt;ch_wqueue
)paren
(brace
id|jsm_printk
c_func
(paren
id|INIT
comma
id|ERR
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;unable to allocate write queue buf&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|channel-&gt;ch_wqueue
comma
l_int|0
comma
id|WQUEUESIZE
)paren
suffix:semicolon
)brace
id|channel-&gt;ch_flags
op_and_assign
op_complement
(paren
id|CH_OPENING
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize if neither terminal is open.&n;&t; */
id|jsm_printk
c_func
(paren
id|OPEN
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;jsm_open: initializing channel in open...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Flush input queues.&n;&t; */
id|channel-&gt;ch_r_head
op_assign
id|channel-&gt;ch_r_tail
op_assign
l_int|0
suffix:semicolon
id|channel-&gt;ch_e_head
op_assign
id|channel-&gt;ch_e_tail
op_assign
l_int|0
suffix:semicolon
id|channel-&gt;ch_w_head
op_assign
id|channel-&gt;ch_w_tail
op_assign
l_int|0
suffix:semicolon
id|brd-&gt;bd_ops
op_member_access_from_pointer
id|flush_uart_write
c_func
(paren
id|channel
)paren
suffix:semicolon
id|brd-&gt;bd_ops
op_member_access_from_pointer
id|flush_uart_read
c_func
(paren
id|channel
)paren
suffix:semicolon
id|channel-&gt;ch_flags
op_assign
l_int|0
suffix:semicolon
id|channel-&gt;ch_cached_lsr
op_assign
l_int|0
suffix:semicolon
id|channel-&gt;ch_stops_sent
op_assign
l_int|0
suffix:semicolon
id|channel-&gt;ch_c_cflag
op_assign
id|port-&gt;info-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
id|channel-&gt;ch_c_iflag
op_assign
id|port-&gt;info-&gt;tty-&gt;termios-&gt;c_iflag
suffix:semicolon
id|channel-&gt;ch_c_oflag
op_assign
id|port-&gt;info-&gt;tty-&gt;termios-&gt;c_oflag
suffix:semicolon
id|channel-&gt;ch_c_lflag
op_assign
id|port-&gt;info-&gt;tty-&gt;termios-&gt;c_lflag
suffix:semicolon
id|channel-&gt;ch_startc
op_assign
id|port-&gt;info-&gt;tty-&gt;termios-&gt;c_cc
(braket
id|VSTART
)braket
suffix:semicolon
id|channel-&gt;ch_stopc
op_assign
id|port-&gt;info-&gt;tty-&gt;termios-&gt;c_cc
(braket
id|VSTOP
)braket
suffix:semicolon
multiline_comment|/* Tell UART to init itself */
id|brd-&gt;bd_ops
op_member_access_from_pointer
id|uart_init
c_func
(paren
id|channel
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Run param in case we changed anything&n;&t; */
id|brd-&gt;bd_ops
op_member_access_from_pointer
id|param
c_func
(paren
id|channel
)paren
suffix:semicolon
id|jsm_carrier
c_func
(paren
id|channel
)paren
suffix:semicolon
id|channel-&gt;ch_open_count
op_increment
suffix:semicolon
id|jsm_printk
c_func
(paren
id|OPEN
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;finish&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|jsm_tty_close
r_static
r_void
id|jsm_tty_close
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|jsm_board
op_star
id|bd
suffix:semicolon
r_struct
id|termios
op_star
id|ts
suffix:semicolon
r_struct
id|jsm_channel
op_star
id|channel
op_assign
(paren
r_struct
id|jsm_channel
op_star
)paren
id|port
suffix:semicolon
id|jsm_printk
c_func
(paren
id|CLOSE
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
id|bd
op_assign
id|channel-&gt;ch_bd
suffix:semicolon
id|ts
op_assign
id|channel-&gt;uart_port.info-&gt;tty-&gt;termios
suffix:semicolon
id|channel-&gt;ch_flags
op_and_assign
op_complement
(paren
id|CH_STOPI
)paren
suffix:semicolon
id|channel-&gt;ch_open_count
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; * If we have HUPCL set, lower DTR and RTS&n;&t; */
r_if
c_cond
(paren
id|channel-&gt;ch_c_cflag
op_amp
id|HUPCL
)paren
(brace
id|jsm_printk
c_func
(paren
id|CLOSE
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Close. HUPCL set, dropping DTR/RTS&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Drop RTS/DTR */
id|channel-&gt;ch_mostat
op_and_assign
op_complement
(paren
id|UART_MCR_DTR
op_or
id|UART_MCR_RTS
)paren
suffix:semicolon
id|bd-&gt;bd_ops
op_member_access_from_pointer
id|assert_modem_signals
c_func
(paren
id|channel
)paren
suffix:semicolon
)brace
id|channel-&gt;ch_old_baud
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Turn off UART interrupts for this port */
id|channel-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|uart_off
c_func
(paren
id|channel
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|CLOSE
comma
id|INFO
comma
op_amp
id|channel-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;finish&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|jsm_tty_set_termios
r_static
r_void
id|jsm_tty_set_termios
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|termios
op_star
id|termios
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_int
r_int
id|lock_flags
suffix:semicolon
r_struct
id|jsm_channel
op_star
id|channel
op_assign
(paren
r_struct
id|jsm_channel
op_star
)paren
id|port
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|lock_flags
)paren
suffix:semicolon
id|channel-&gt;ch_c_cflag
op_assign
id|termios-&gt;c_cflag
suffix:semicolon
id|channel-&gt;ch_c_iflag
op_assign
id|termios-&gt;c_iflag
suffix:semicolon
id|channel-&gt;ch_c_oflag
op_assign
id|termios-&gt;c_oflag
suffix:semicolon
id|channel-&gt;ch_c_lflag
op_assign
id|termios-&gt;c_lflag
suffix:semicolon
id|channel-&gt;ch_startc
op_assign
id|termios-&gt;c_cc
(braket
id|VSTART
)braket
suffix:semicolon
id|channel-&gt;ch_stopc
op_assign
id|termios-&gt;c_cc
(braket
id|VSTOP
)braket
suffix:semicolon
id|channel-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|param
c_func
(paren
id|channel
)paren
suffix:semicolon
id|jsm_carrier
c_func
(paren
id|channel
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|lock_flags
)paren
suffix:semicolon
)brace
DECL|function|jsm_tty_type
r_static
r_const
r_char
op_star
id|jsm_tty_type
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_return
l_string|&quot;jsm&quot;
suffix:semicolon
)brace
DECL|function|jsm_tty_release_port
r_static
r_void
id|jsm_tty_release_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
)brace
DECL|function|jsm_tty_request_port
r_static
r_int
id|jsm_tty_request_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jsm_config_port
r_static
r_void
id|jsm_config_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
id|flags
)paren
(brace
id|port-&gt;type
op_assign
id|PORT_JSM
suffix:semicolon
)brace
DECL|variable|jsm_ops
r_static
r_struct
id|uart_ops
id|jsm_ops
op_assign
(brace
dot
id|tx_empty
op_assign
id|jsm_tty_tx_empty
comma
dot
id|set_mctrl
op_assign
id|jsm_tty_set_mctrl
comma
dot
id|get_mctrl
op_assign
id|jsm_tty_get_mctrl
comma
dot
id|stop_tx
op_assign
id|jsm_tty_stop_tx
comma
dot
id|start_tx
op_assign
id|jsm_tty_start_tx
comma
dot
id|send_xchar
op_assign
id|jsm_tty_send_xchar
comma
dot
id|stop_rx
op_assign
id|jsm_tty_stop_rx
comma
dot
id|break_ctl
op_assign
id|jsm_tty_break
comma
dot
id|startup
op_assign
id|jsm_tty_open
comma
dot
id|shutdown
op_assign
id|jsm_tty_close
comma
dot
id|set_termios
op_assign
id|jsm_tty_set_termios
comma
dot
id|type
op_assign
id|jsm_tty_type
comma
dot
id|release_port
op_assign
id|jsm_tty_release_port
comma
dot
id|request_port
op_assign
id|jsm_tty_request_port
comma
dot
id|config_port
op_assign
id|jsm_config_port
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * jsm_tty_init()&n; *&n; * Init the tty subsystem.  Called once per board after board has been&n; * downloaded and init&squot;ed.&n; */
DECL|function|jsm_tty_init
r_int
id|jsm_tty_init
c_func
(paren
r_struct
id|jsm_board
op_star
id|brd
)paren
(brace
r_int
id|i
suffix:semicolon
id|u8
op_star
id|vaddr
suffix:semicolon
r_struct
id|jsm_channel
op_star
id|ch
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brd
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INIT
comma
id|INFO
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize board structure elements.&n;&t; */
id|vaddr
op_assign
id|brd-&gt;re_map_membase
suffix:semicolon
id|brd-&gt;nasync
op_assign
id|brd-&gt;maxports
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate channel memory that might not have been allocated&n;&t; * when the driver was first loaded.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|brd-&gt;nasync
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|brd-&gt;channels
(braket
id|i
)braket
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Okay to malloc with GFP_KERNEL, we are not at&n;&t;&t;&t; * interrupt context, and there are no locks held.&n;&t;&t;&t; */
id|brd-&gt;channels
(braket
id|i
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jsm_channel
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brd-&gt;channels
(braket
id|i
)braket
)paren
(brace
id|jsm_printk
c_func
(paren
id|CORE
comma
id|ERR
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;%s:%d Unable to allocate memory for channel struct&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|brd-&gt;channels
(braket
id|i
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|jsm_channel
)paren
)paren
suffix:semicolon
)brace
)brace
id|ch
op_assign
id|brd-&gt;channels
(braket
l_int|0
)braket
suffix:semicolon
id|vaddr
op_assign
id|brd-&gt;re_map_membase
suffix:semicolon
multiline_comment|/* Set up channel variables */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|brd-&gt;nasync
suffix:semicolon
id|i
op_increment
comma
id|ch
op_assign
id|brd-&gt;channels
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|brd-&gt;channels
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ch-&gt;ch_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brd-&gt;bd_uart_offset
op_eq
l_int|0x200
)paren
id|ch-&gt;ch_neo_uart
op_assign
(paren
r_struct
id|neo_uart_struct
op_star
)paren
(paren
(paren
id|u64
)paren
id|vaddr
op_plus
(paren
id|brd-&gt;bd_uart_offset
op_star
id|i
)paren
)paren
suffix:semicolon
id|ch-&gt;ch_bd
op_assign
id|brd
suffix:semicolon
id|ch-&gt;ch_portnum
op_assign
id|i
suffix:semicolon
multiline_comment|/* .25 second delay */
id|ch-&gt;ch_close_delay
op_assign
l_int|250
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ch-&gt;ch_flags_wait
)paren
suffix:semicolon
)brace
id|jsm_printk
c_func
(paren
id|INIT
comma
id|INFO
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;finish&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jsm_uart_port_init
r_int
id|jsm_uart_port_init
c_func
(paren
r_struct
id|jsm_board
op_star
id|brd
)paren
(brace
r_int
id|i
suffix:semicolon
id|u8
op_star
id|vaddr
suffix:semicolon
r_struct
id|jsm_channel
op_star
id|ch
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brd
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INIT
comma
id|INFO
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize board structure elements.&n;&t; */
id|vaddr
op_assign
id|brd-&gt;re_map_membase
suffix:semicolon
id|brd-&gt;nasync
op_assign
id|brd-&gt;maxports
suffix:semicolon
multiline_comment|/* Set up channel variables */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|brd-&gt;nasync
suffix:semicolon
id|i
op_increment
comma
id|ch
op_assign
id|brd-&gt;channels
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|brd-&gt;channels
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|brd-&gt;channels
(braket
id|i
)braket
op_member_access_from_pointer
id|uart_port.irq
op_assign
id|brd-&gt;irq
suffix:semicolon
id|brd-&gt;channels
(braket
id|i
)braket
op_member_access_from_pointer
id|uart_port.type
op_assign
id|PORT_JSM
suffix:semicolon
id|brd-&gt;channels
(braket
id|i
)braket
op_member_access_from_pointer
id|uart_port.iotype
op_assign
id|UPIO_MEM
suffix:semicolon
id|brd-&gt;channels
(braket
id|i
)braket
op_member_access_from_pointer
id|uart_port.membase
op_assign
id|brd-&gt;re_map_membase
suffix:semicolon
id|brd-&gt;channels
(braket
id|i
)braket
op_member_access_from_pointer
id|uart_port.fifosize
op_assign
l_int|16
suffix:semicolon
id|brd-&gt;channels
(braket
id|i
)braket
op_member_access_from_pointer
id|uart_port.ops
op_assign
op_amp
id|jsm_ops
suffix:semicolon
id|brd-&gt;channels
(braket
id|i
)braket
op_member_access_from_pointer
id|uart_port.line
op_assign
id|brd-&gt;channels
(braket
id|i
)braket
op_member_access_from_pointer
id|ch_portnum
op_plus
id|brd-&gt;boardnum
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|uart_add_one_port
(paren
op_amp
id|jsm_uart_driver
comma
op_amp
id|brd-&gt;channels
(braket
id|i
)braket
op_member_access_from_pointer
id|uart_port
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Added device failed&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Added device &bslash;n&quot;
)paren
suffix:semicolon
)brace
id|jsm_printk
c_func
(paren
id|INIT
comma
id|INFO
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;finish&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jsm_remove_uart_port
r_int
id|jsm_remove_uart_port
c_func
(paren
r_struct
id|jsm_board
op_star
id|brd
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|jsm_channel
op_star
id|ch
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brd
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|jsm_printk
c_func
(paren
id|INIT
comma
id|INFO
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize board structure elements.&n;&t; */
id|brd-&gt;nasync
op_assign
id|brd-&gt;maxports
suffix:semicolon
multiline_comment|/* Set up channel variables */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|brd-&gt;nasync
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|brd-&gt;channels
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|ch
op_assign
id|brd-&gt;channels
(braket
id|i
)braket
suffix:semicolon
id|uart_remove_one_port
c_func
(paren
op_amp
id|jsm_uart_driver
comma
op_amp
id|brd-&gt;channels
(braket
id|i
)braket
op_member_access_from_pointer
id|uart_port
)paren
suffix:semicolon
)brace
id|jsm_printk
c_func
(paren
id|INIT
comma
id|INFO
comma
op_amp
id|brd-&gt;pci_dev
comma
l_string|&quot;finish&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jsm_input
r_void
id|jsm_input
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
r_struct
id|jsm_board
op_star
id|bd
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tp
suffix:semicolon
id|u32
id|rmask
suffix:semicolon
id|u16
id|head
suffix:semicolon
id|u16
id|tail
suffix:semicolon
r_int
id|data_len
suffix:semicolon
id|u64
id|lock_flags
suffix:semicolon
r_int
id|flip_len
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buf
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|buf2
op_assign
l_int|NULL
suffix:semicolon
r_int
id|s
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
id|tp
op_assign
id|ch-&gt;uart_port.info-&gt;tty
suffix:semicolon
id|bd
op_assign
id|ch-&gt;ch_bd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bd
)paren
(brace
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *Figure the number of characters in the buffer.&n;&t; *Exit immediately if none.&n;&t; */
id|rmask
op_assign
id|RQUEUEMASK
suffix:semicolon
id|head
op_assign
id|ch-&gt;ch_r_head
op_amp
id|rmask
suffix:semicolon
id|tail
op_assign
id|ch-&gt;ch_r_tail
op_amp
id|rmask
suffix:semicolon
id|data_len
op_assign
(paren
id|head
op_minus
id|tail
)paren
op_amp
id|rmask
suffix:semicolon
r_if
c_cond
(paren
id|data_len
op_eq
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *If the device is not open, or CREAD is off, flush&n;&t; *input data and return immediately.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tp
op_logical_or
op_logical_neg
(paren
id|tp-&gt;termios-&gt;c_cflag
op_amp
id|CREAD
)paren
)paren
(brace
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;input. dropping %d bytes on port %d...&bslash;n&quot;
comma
id|data_len
comma
id|ch-&gt;ch_portnum
)paren
suffix:semicolon
id|ch-&gt;ch_r_head
op_assign
id|tail
suffix:semicolon
multiline_comment|/* Force queue flow control to be released, if needed */
id|jsm_check_queue_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we are throttled, simply don&squot;t read any data.&n;&t; */
r_if
c_cond
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_STOPI
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Port %d throttled, not reading any data. head: %x tail: %x&bslash;n&quot;
comma
id|ch-&gt;ch_portnum
comma
id|head
comma
id|tail
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;start 2&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the rxbuf is empty and we are not throttled, put as much&n;&t; * as we can directly into the linux TTY flip buffer.&n;&t; * The jsm_rawreadok case takes advantage of carnal knowledge that&n;&t; * the char_buf and the flag_buf are next to each other and&n;&t; * are each of (2 * TTY_FLIPBUF_SIZE) size.&n;&t; *&n;&t; * NOTE: if(!tty-&gt;real_raw), the call to ldisc.receive_buf&n;&t; *actually still uses the flag buffer, so you can&squot;t&n;&t; *use it for input data&n;&t; */
r_if
c_cond
(paren
id|jsm_rawreadok
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;real_raw
)paren
id|flip_len
op_assign
id|MYFLIPLEN
suffix:semicolon
r_else
id|flip_len
op_assign
l_int|2
op_star
id|TTY_FLIPBUF_SIZE
suffix:semicolon
)brace
r_else
id|flip_len
op_assign
id|TTY_FLIPBUF_SIZE
op_minus
id|tp-&gt;flip.count
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|data_len
comma
id|flip_len
)paren
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|len
comma
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
op_minus
id|tp-&gt;read_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;jsm_input 1&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we&squot;re bypassing flip buffers on rx, we can blast it&n;&t; * right into the beginning of the buffer.&n;&t; */
r_if
c_cond
(paren
id|jsm_rawreadok
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;real_raw
)paren
(brace
r_if
c_cond
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_FLIPBUF_IN_USE
)paren
(brace
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;JSM - FLIPBUF in use. delaying input&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ch-&gt;ch_flags
op_or_assign
id|CH_FLIPBUF_IN_USE
suffix:semicolon
id|buf
op_assign
id|ch-&gt;ch_bd-&gt;flipbuf
suffix:semicolon
id|buf2
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|buf
op_assign
id|tp-&gt;flip.char_buf
suffix:semicolon
id|buf2
op_assign
id|tp-&gt;flip.flag_buf
suffix:semicolon
)brace
)brace
r_else
(brace
id|buf
op_assign
id|tp-&gt;flip.char_buf_ptr
suffix:semicolon
id|buf2
op_assign
id|tp-&gt;flip.flag_buf_ptr
suffix:semicolon
)brace
id|n
op_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t; * n now contains the most amount of data we can copy,&n;&t; * bounded either by the flip buffer size or the amount&n;&t; * of data the card actually has pending...&n;&t; */
r_while
c_loop
(paren
id|n
)paren
(brace
id|s
op_assign
(paren
(paren
id|head
op_ge
id|tail
)paren
ques
c_cond
id|head
suffix:colon
id|RQUEUESIZE
)paren
op_minus
id|tail
suffix:semicolon
id|s
op_assign
id|min
c_func
(paren
id|s
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|ch-&gt;ch_rqueue
op_plus
id|tail
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* buf2 is only set when port isn&squot;t raw */
r_if
c_cond
(paren
id|buf2
)paren
id|memcpy
c_func
(paren
id|buf2
comma
id|ch-&gt;ch_equeue
op_plus
id|tail
comma
id|s
)paren
suffix:semicolon
id|tail
op_add_assign
id|s
suffix:semicolon
id|buf
op_add_assign
id|s
suffix:semicolon
r_if
c_cond
(paren
id|buf2
)paren
id|buf2
op_add_assign
id|s
suffix:semicolon
id|n
op_sub_assign
id|s
suffix:semicolon
multiline_comment|/* Flip queue if needed */
id|tail
op_and_assign
id|rmask
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * In high performance mode, we don&squot;t have to update&n;&t; * flag_buf or any of the counts or pointers into flip buf.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|jsm_rawreadok
)paren
(brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tp
)paren
op_logical_or
id|I_BRKINT
c_func
(paren
id|tp
)paren
op_logical_or
id|I_INPCK
c_func
(paren
id|tp
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Give the Linux ld the flags in the&n;&t;&t;&t;&t; * format it likes.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_amp
id|UART_LSR_BI
)paren
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_assign
id|TTY_BREAK
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_amp
id|UART_LSR_PE
)paren
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_assign
id|TTY_PARITY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_amp
id|UART_LSR_FE
)paren
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_assign
id|TTY_FRAME
suffix:semicolon
r_else
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_assign
id|TTY_NORMAL
suffix:semicolon
)brace
)brace
r_else
(brace
id|memset
c_func
(paren
id|tp-&gt;flip.flag_buf_ptr
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
)brace
id|tp-&gt;flip.char_buf_ptr
op_add_assign
id|len
suffix:semicolon
id|tp-&gt;flip.flag_buf_ptr
op_add_assign
id|len
suffix:semicolon
id|tp-&gt;flip.count
op_add_assign
id|len
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;real_raw
)paren
(brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tp
)paren
op_logical_or
id|I_BRKINT
c_func
(paren
id|tp
)paren
op_logical_or
id|I_INPCK
c_func
(paren
id|tp
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Give the Linux ld the flags in the&n;&t;&t;&t;&t; * format it likes.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_amp
id|UART_LSR_BI
)paren
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_assign
id|TTY_BREAK
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_amp
id|UART_LSR_PE
)paren
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_assign
id|TTY_PARITY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_amp
id|UART_LSR_FE
)paren
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_assign
id|TTY_FRAME
suffix:semicolon
r_else
id|tp-&gt;flip.flag_buf_ptr
(braket
id|i
)braket
op_assign
id|TTY_NORMAL
suffix:semicolon
)brace
)brace
r_else
id|memset
c_func
(paren
id|tp-&gt;flip.flag_buf
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we&squot;re doing raw reads, jam it right into the&n;&t; * line disc bypassing the flip buffers.&n;&t; */
r_if
c_cond
(paren
id|jsm_rawreadok
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;real_raw
)paren
(brace
id|ch-&gt;ch_r_tail
op_assign
id|tail
op_amp
id|rmask
suffix:semicolon
id|ch-&gt;ch_e_tail
op_assign
id|tail
op_amp
id|rmask
suffix:semicolon
id|jsm_check_queue_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* !!! WE *MUST* LET GO OF ALL LOCKS BEFORE CALLING RECEIVE BUF !!! */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;jsm_input. %d real_raw len:%d calling receive_buf for board %d&bslash;n&quot;
comma
id|__LINE__
comma
id|len
comma
id|ch-&gt;ch_bd-&gt;boardnum
)paren
suffix:semicolon
id|tp-&gt;ldisc
dot
id|receive_buf
c_func
(paren
id|tp
comma
id|ch-&gt;ch_bd-&gt;flipbuf
comma
l_int|NULL
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Allow use of channel flip buffer again */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|ch-&gt;ch_flags
op_and_assign
op_complement
id|CH_FLIPBUF_IN_USE
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|ch-&gt;ch_r_tail
op_assign
id|tail
op_amp
id|rmask
suffix:semicolon
id|ch-&gt;ch_e_tail
op_assign
id|tail
op_amp
id|rmask
suffix:semicolon
id|jsm_check_queue_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* !!! WE *MUST* LET GO OF ALL LOCKS BEFORE CALLING RECEIVE BUF !!! */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;jsm_input. %d not real_raw len:%d calling receive_buf for board %d&bslash;n&quot;
comma
id|__LINE__
comma
id|len
comma
id|ch-&gt;ch_bd-&gt;boardnum
)paren
suffix:semicolon
id|tp-&gt;ldisc
dot
id|receive_buf
c_func
(paren
id|tp
comma
id|tp-&gt;flip.char_buf
comma
id|tp-&gt;flip.flag_buf
comma
id|len
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|ch-&gt;ch_r_tail
op_assign
id|tail
op_amp
id|rmask
suffix:semicolon
id|ch-&gt;ch_e_tail
op_assign
id|tail
op_amp
id|rmask
suffix:semicolon
id|jsm_check_queue_flow_control
c_func
(paren
id|ch
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|lock_flags
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;jsm_input. %d not jsm_read raw okay scheduling flip&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|tty_schedule_flip
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|jsm_printk
c_func
(paren
id|IOCTL
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;finish&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|jsm_carrier
r_void
id|jsm_carrier
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
r_struct
id|jsm_board
op_star
id|bd
suffix:semicolon
r_int
id|virt_carrier
op_assign
l_int|0
suffix:semicolon
r_int
id|phys_carrier
op_assign
l_int|0
suffix:semicolon
id|jsm_printk
c_func
(paren
id|CARR
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;start&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_return
suffix:semicolon
id|bd
op_assign
id|ch-&gt;ch_bd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bd
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;ch_mistat
op_amp
id|UART_MSR_DCD
)paren
(brace
id|jsm_printk
c_func
(paren
id|CARR
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;mistat: %x D_CD: %x&bslash;n&quot;
comma
id|ch-&gt;ch_mistat
comma
id|ch-&gt;ch_mistat
op_amp
id|UART_MSR_DCD
)paren
suffix:semicolon
id|phys_carrier
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|CLOCAL
)paren
id|virt_carrier
op_assign
l_int|1
suffix:semicolon
id|jsm_printk
c_func
(paren
id|CARR
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;DCD: physical: %d virt: %d&bslash;n&quot;
comma
id|phys_carrier
comma
id|virt_carrier
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Test for a VIRTUAL carrier transition to HIGH.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_FCAR
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|virt_carrier
op_eq
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * When carrier rises, wake any threads waiting&n;&t;&t; * for carrier in the open routine.&n;&t;&t; */
id|jsm_printk
c_func
(paren
id|CARR
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;carrier: virt DCD rose&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
(paren
id|ch-&gt;ch_flags_wait
)paren
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|ch-&gt;ch_flags_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Test for a PHYSICAL carrier transition to HIGH.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_CD
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|phys_carrier
op_eq
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * When carrier rises, wake any threads waiting&n;&t;&t; * for carrier in the open routine.&n;&t;&t; */
id|jsm_printk
c_func
(paren
id|CARR
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;carrier: physical DCD rose&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
(paren
id|ch-&gt;ch_flags_wait
)paren
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|ch-&gt;ch_flags_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Test for a PHYSICAL transition to low, so long as we aren&squot;t&n;&t; *  currently ignoring physical transitions (which is what &quot;virtual&n;&t; *  carrier&quot; indicates).&n;&t; *&n;&t; *  The transition of the virtual carrier to low really doesn&squot;t&n;&t; *  matter... it really only means &quot;ignore carrier state&quot;, not&n;&t; *  &quot;make pretend that carrier is there&quot;.&n;&t; */
r_if
c_cond
(paren
(paren
id|virt_carrier
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_CD
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|phys_carrier
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;When carrier drops:&n;&t;&t; *&n;&t;&t; *&t;Drop carrier on all open units.&n;&t;&t; *&n;&t;&t; *&t;Flush queues, waking up any task waiting in the&n;&t;&t; *&t;line discipline.&n;&t;&t; *&n;&t;&t; *&t;Send a hangup to the control terminal.&n;&t;&t; *&n;&t;&t; *&t;Enable all select calls.&n;&t;&t; */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
(paren
id|ch-&gt;ch_flags_wait
)paren
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|ch-&gt;ch_flags_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Make sure that our cached values reflect the current reality.&n;&t; */
r_if
c_cond
(paren
id|virt_carrier
op_eq
l_int|1
)paren
id|ch-&gt;ch_flags
op_or_assign
id|CH_FCAR
suffix:semicolon
r_else
id|ch-&gt;ch_flags
op_and_assign
op_complement
id|CH_FCAR
suffix:semicolon
r_if
c_cond
(paren
id|phys_carrier
op_eq
l_int|1
)paren
id|ch-&gt;ch_flags
op_or_assign
id|CH_CD
suffix:semicolon
r_else
id|ch-&gt;ch_flags
op_and_assign
op_complement
id|CH_CD
suffix:semicolon
)brace
DECL|function|jsm_check_queue_flow_control
r_void
id|jsm_check_queue_flow_control
c_func
(paren
r_struct
id|jsm_channel
op_star
id|ch
)paren
(brace
r_int
id|qleft
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Store how much space we have left in the queue */
r_if
c_cond
(paren
(paren
id|qleft
op_assign
id|ch-&gt;ch_r_tail
op_minus
id|ch-&gt;ch_r_head
op_minus
l_int|1
)paren
OL
l_int|0
)paren
id|qleft
op_add_assign
id|RQUEUEMASK
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if we should enforce flow control on our queue because&n;&t; * the ld (or user) isn&squot;t reading data out of our queue fast enuf.&n;&t; *&n;&t; * NOTE: This is done based on what the current flow control of the&n;&t; * port is set for.&n;&t; *&n;&t; * 1) HWFLOW (RTS) - Turn off the UART&squot;s Receive interrupt.&n;&t; *&t;This will cause the UART&squot;s FIFO to back up, and force&n;&t; *&t;the RTS signal to be dropped.&n;&t; * 2) SWFLOW (IXOFF) - Keep trying to send a stop character to&n;&t; *&t;the other side, in hopes it will stop sending data to us.&n;&t; * 3) NONE - Nothing we can do.  We will simply drop any extra data&n;&t; *&t;that gets sent into us when the queue fills up.&n;&t; */
r_if
c_cond
(paren
id|qleft
OL
l_int|256
)paren
(brace
multiline_comment|/* HWFLOW */
r_if
c_cond
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|CRTSCTS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_RECEIVER_OFF
)paren
)paren
(brace
id|ch-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|disable_receiver
c_func
(paren
id|ch
)paren
suffix:semicolon
id|ch-&gt;ch_flags
op_or_assign
(paren
id|CH_RECEIVER_OFF
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Internal queue hit hilevel mark (%d)! Turning off interrupts.&bslash;n&quot;
comma
id|qleft
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* SWFLOW */
r_else
r_if
c_cond
(paren
id|ch-&gt;ch_c_iflag
op_amp
id|IXOFF
)paren
(brace
r_if
c_cond
(paren
id|ch-&gt;ch_stops_sent
op_le
id|MAX_STOPS_SENT
)paren
(brace
id|ch-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|send_stop_character
c_func
(paren
id|ch
)paren
suffix:semicolon
id|ch-&gt;ch_stops_sent
op_increment
suffix:semicolon
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Sending stop char! Times sent: %x&bslash;n&quot;
comma
id|ch-&gt;ch_stops_sent
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Check to see if we should unenforce flow control because&n;&t; * ld (or user) finally read enuf data out of our queue.&n;&t; *&n;&t; * NOTE: This is done based on what the current flow control of the&n;&t; * port is set for.&n;&t; *&n;&t; * 1) HWFLOW (RTS) - Turn back on the UART&squot;s Receive interrupt.&n;&t; *&t;This will cause the UART&squot;s FIFO to raise RTS back up,&n;&t; *&t;which will allow the other side to start sending data again.&n;&t; * 2) SWFLOW (IXOFF) - Send a start character to&n;&t; *&t;the other side, so it will start sending data to us again.&n;&t; * 3) NONE - Do nothing. Since we didn&squot;t do anything to turn off the&n;&t; *&t;other side, we don&squot;t need to do anything now.&n;&t; */
r_if
c_cond
(paren
id|qleft
OG
(paren
id|RQUEUESIZE
op_div
l_int|2
)paren
)paren
(brace
multiline_comment|/* HWFLOW */
r_if
c_cond
(paren
id|ch-&gt;ch_c_cflag
op_amp
id|CRTSCTS
)paren
(brace
r_if
c_cond
(paren
id|ch-&gt;ch_flags
op_amp
id|CH_RECEIVER_OFF
)paren
(brace
id|ch-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|enable_receiver
c_func
(paren
id|ch
)paren
suffix:semicolon
id|ch-&gt;ch_flags
op_and_assign
op_complement
(paren
id|CH_RECEIVER_OFF
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Internal queue hit lowlevel mark (%d)! Turning on interrupts.&bslash;n&quot;
comma
id|qleft
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* SWFLOW */
r_else
r_if
c_cond
(paren
id|ch-&gt;ch_c_iflag
op_amp
id|IXOFF
op_logical_and
id|ch-&gt;ch_stops_sent
)paren
(brace
id|ch-&gt;ch_stops_sent
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|send_start_character
c_func
(paren
id|ch
)paren
suffix:semicolon
id|jsm_printk
c_func
(paren
id|READ
comma
id|INFO
comma
op_amp
id|ch-&gt;ch_bd-&gt;pci_dev
comma
l_string|&quot;Sending start char!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * jsm_tty_write()&n; *&n; * Take data from the user or kernel and send it out to the FEP.&n; * In here exists all the Transparent Print magic as well.&n; */
DECL|function|jsm_tty_write
r_int
id|jsm_tty_write
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_int
id|bufcount
op_assign
l_int|0
comma
id|n
op_assign
l_int|0
suffix:semicolon
r_int
id|data_count
op_assign
l_int|0
comma
id|data_count1
op_assign
l_int|0
suffix:semicolon
id|u16
id|head
suffix:semicolon
id|u16
id|tail
suffix:semicolon
id|u16
id|tmask
suffix:semicolon
id|u32
id|remain
suffix:semicolon
r_int
id|temp_tail
op_assign
id|port-&gt;info-&gt;xmit.tail
suffix:semicolon
r_struct
id|jsm_channel
op_star
id|channel
op_assign
(paren
r_struct
id|jsm_channel
op_star
)paren
id|port
suffix:semicolon
id|tmask
op_assign
id|WQUEUEMASK
suffix:semicolon
id|head
op_assign
(paren
id|channel-&gt;ch_w_head
)paren
op_amp
id|tmask
suffix:semicolon
id|tail
op_assign
(paren
id|channel-&gt;ch_w_tail
)paren
op_amp
id|tmask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bufcount
op_assign
id|tail
op_minus
id|head
op_minus
l_int|1
)paren
OL
l_int|0
)paren
id|bufcount
op_add_assign
id|WQUEUESIZE
suffix:semicolon
id|n
op_assign
id|bufcount
suffix:semicolon
id|n
op_assign
id|min
c_func
(paren
id|n
comma
l_int|56
)paren
suffix:semicolon
id|remain
op_assign
id|WQUEUESIZE
op_minus
id|head
suffix:semicolon
id|data_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
id|remain
)paren
(brace
id|n
op_sub_assign
id|remain
suffix:semicolon
r_while
c_loop
(paren
(paren
id|port-&gt;info-&gt;xmit.head
op_ne
id|temp_tail
)paren
op_logical_and
(paren
id|data_count
OL
id|remain
)paren
)paren
(brace
id|channel-&gt;ch_wqueue
(braket
id|head
op_increment
)braket
op_assign
id|port-&gt;info-&gt;xmit.buf
(braket
id|temp_tail
)braket
suffix:semicolon
id|temp_tail
op_increment
suffix:semicolon
id|temp_tail
op_and_assign
(paren
id|UART_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|data_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data_count
op_eq
id|remain
)paren
id|head
op_assign
l_int|0
suffix:semicolon
)brace
id|data_count1
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|0
)paren
(brace
id|remain
op_assign
id|n
suffix:semicolon
r_while
c_loop
(paren
(paren
id|port-&gt;info-&gt;xmit.head
op_ne
id|temp_tail
)paren
op_logical_and
(paren
id|data_count1
OL
id|remain
)paren
)paren
(brace
id|channel-&gt;ch_wqueue
(braket
id|head
op_increment
)braket
op_assign
id|port-&gt;info-&gt;xmit.buf
(braket
id|temp_tail
)braket
suffix:semicolon
id|temp_tail
op_increment
suffix:semicolon
id|temp_tail
op_and_assign
(paren
id|UART_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|data_count1
op_increment
suffix:semicolon
)brace
)brace
id|port-&gt;info-&gt;xmit.tail
op_assign
id|temp_tail
suffix:semicolon
id|data_count
op_add_assign
id|data_count1
suffix:semicolon
r_if
c_cond
(paren
id|data_count
)paren
(brace
id|head
op_and_assign
id|tmask
suffix:semicolon
id|channel-&gt;ch_w_head
op_assign
id|head
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data_count
)paren
(brace
id|channel-&gt;ch_bd-&gt;bd_ops
op_member_access_from_pointer
id|copy_data_from_queue_to_uart
c_func
(paren
id|channel
)paren
suffix:semicolon
)brace
r_return
id|data_count
suffix:semicolon
)brace
DECL|function|jsm_driver_version_show
r_static
id|ssize_t
id|jsm_driver_version_show
c_func
(paren
r_struct
id|device_driver
op_star
id|ddp
comma
r_char
op_star
id|buf
)paren
(brace
r_return
id|snprintf
c_func
(paren
id|buf
comma
id|PAGE_SIZE
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|JSM_VERSION
)paren
suffix:semicolon
)brace
r_static
id|DRIVER_ATTR
c_func
(paren
id|version
comma
id|S_IRUSR
comma
id|jsm_driver_version_show
comma
l_int|NULL
)paren
suffix:semicolon
DECL|function|jsm_driver_state_show
r_static
id|ssize_t
id|jsm_driver_state_show
c_func
(paren
r_struct
id|device_driver
op_star
id|ddp
comma
r_char
op_star
id|buf
)paren
(brace
r_return
id|snprintf
c_func
(paren
id|buf
comma
id|PAGE_SIZE
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|jsm_driver_state_text
(braket
id|jsm_driver_state
)braket
)paren
suffix:semicolon
)brace
r_static
id|DRIVER_ATTR
c_func
(paren
id|state
comma
id|S_IRUSR
comma
id|jsm_driver_state_show
comma
l_int|NULL
)paren
suffix:semicolon
DECL|function|jsm_create_driver_sysfiles
r_void
id|jsm_create_driver_sysfiles
c_func
(paren
r_struct
id|device_driver
op_star
id|driverfs
)paren
(brace
id|driver_create_file
c_func
(paren
id|driverfs
comma
op_amp
id|driver_attr_version
)paren
suffix:semicolon
id|driver_create_file
c_func
(paren
id|driverfs
comma
op_amp
id|driver_attr_state
)paren
suffix:semicolon
)brace
DECL|function|jsm_remove_driver_sysfiles
r_void
id|jsm_remove_driver_sysfiles
c_func
(paren
r_struct
id|device_driver
op_star
id|driverfs
)paren
(brace
id|driver_remove_file
c_func
(paren
id|driverfs
comma
op_amp
id|driver_attr_version
)paren
suffix:semicolon
id|driver_remove_file
c_func
(paren
id|driverfs
comma
op_amp
id|driver_attr_state
)paren
suffix:semicolon
)brace
eof
