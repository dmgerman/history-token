multiline_comment|/*&n; *  linux/drivers/char/core.c&n; *&n; *  Driver core for serial ports&n; *&n; *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts&squot;o.&n; *&n; *  Copyright 1999 ARM Limited&n; *  Copyright (C) 2000-2001 Deep Blue Solutions Ltd.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/serial_core.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/serial.h&gt; /* for serial_state and serial_icounter_struct */
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|DEBUG
macro_line|#undef&t;DEBUG
macro_line|#ifdef DEBUG
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(x...)&t;printk(x)
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(x...)&t;do { } while (0)
macro_line|#endif
multiline_comment|/*&n; * This is used to lock changes in serial line configuration.&n; */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|port_sem
)paren
suffix:semicolon
DECL|macro|HIGH_BITS_OFFSET
mdefine_line|#define HIGH_BITS_OFFSET&t;((sizeof(long)-sizeof(int))*8)
DECL|macro|uart_users
mdefine_line|#define uart_users(state)&t;((state)-&gt;count + ((state)-&gt;info ? (state)-&gt;info-&gt;blocked_open : 0))
macro_line|#ifdef CONFIG_SERIAL_CORE_CONSOLE
DECL|macro|uart_console
mdefine_line|#define uart_console(port)&t;((port)-&gt;cons &amp;&amp; (port)-&gt;cons-&gt;index == (port)-&gt;line)
macro_line|#else
DECL|macro|uart_console
mdefine_line|#define uart_console(port)&t;(0)
macro_line|#endif
r_static
r_void
id|uart_change_speed
c_func
(paren
r_struct
id|uart_state
op_star
id|state
comma
r_struct
id|termios
op_star
id|old_termios
)paren
suffix:semicolon
r_static
r_void
id|uart_wait_until_sent
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|timeout
)paren
suffix:semicolon
r_static
r_void
id|uart_change_pm
c_func
(paren
r_struct
id|uart_state
op_star
id|state
comma
r_int
id|pm_state
)paren
suffix:semicolon
multiline_comment|/*&n; * This routine is used by the interrupt handler to schedule processing in&n; * the software interrupt portion of the driver.&n; */
DECL|function|uart_write_wakeup
r_void
id|uart_write_wakeup
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_info
op_star
id|info
op_assign
id|port-&gt;info
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|info-&gt;tlet
)paren
suffix:semicolon
)brace
DECL|function|uart_stop
r_static
r_void
id|uart_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|stop_tx
c_func
(paren
id|port
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__uart_start
r_static
r_void
id|__uart_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uart_circ_empty
c_func
(paren
op_amp
id|state-&gt;info-&gt;xmit
)paren
op_logical_and
id|state-&gt;info-&gt;xmit.buf
op_logical_and
op_logical_neg
id|tty-&gt;stopped
op_logical_and
op_logical_neg
id|tty-&gt;hw_stopped
)paren
id|port-&gt;ops
op_member_access_from_pointer
id|start_tx
c_func
(paren
id|port
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|uart_start
r_static
r_void
id|uart_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__uart_start
c_func
(paren
id|tty
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|uart_tasklet_action
r_static
r_void
id|uart_tasklet_action
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
(paren
r_struct
id|uart_state
op_star
)paren
id|data
suffix:semicolon
id|tty_wakeup
c_func
(paren
id|state-&gt;info-&gt;tty
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|uart_update_mctrl
id|uart_update_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|set
comma
r_int
r_int
id|clear
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|old
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|old
op_assign
id|port-&gt;mctrl
suffix:semicolon
id|port-&gt;mctrl
op_assign
(paren
id|old
op_amp
op_complement
id|clear
)paren
op_or
id|set
suffix:semicolon
r_if
c_cond
(paren
id|old
op_ne
id|port-&gt;mctrl
)paren
id|port-&gt;ops
op_member_access_from_pointer
id|set_mctrl
c_func
(paren
id|port
comma
id|port-&gt;mctrl
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|macro|uart_set_mctrl
mdefine_line|#define uart_set_mctrl(port,set)&t;uart_update_mctrl(port,set,0)
DECL|macro|uart_clear_mctrl
mdefine_line|#define uart_clear_mctrl(port,clear)&t;uart_update_mctrl(port,0,clear)
multiline_comment|/*&n; * Startup the port.  This will be called once per open.  All calls&n; * will be serialised by the per-port semaphore.&n; */
DECL|function|uart_startup
r_static
r_int
id|uart_startup
c_func
(paren
r_struct
id|uart_state
op_star
id|state
comma
r_int
id|init_hw
)paren
(brace
r_struct
id|uart_info
op_star
id|info
op_assign
id|state-&gt;info
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|UIF_INITIALIZED
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Set the TTY IO error marker - we will only clear this&n;&t; * once we have successfully opened the port.  Also set&n;&t; * up the tty-&gt;alt_speed kludge&n;&t; */
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;type
op_eq
id|PORT_UNKNOWN
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Initialise and allocate the transmit and temporary&n;&t; * buffer.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;xmit.buf
)paren
(brace
id|page
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|info-&gt;xmit.buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|page
suffix:semicolon
id|uart_circ_clear
c_func
(paren
op_amp
id|info-&gt;xmit
)paren
suffix:semicolon
)brace
id|retval
op_assign
id|port-&gt;ops
op_member_access_from_pointer
id|startup
c_func
(paren
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|init_hw
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Initialise the hardware port settings.&n;&t;&t;&t; */
id|uart_change_speed
c_func
(paren
id|state
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Setup the RTS and DTR signals once the&n;&t;&t;&t; * port is open and ready to respond.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
id|uart_set_mctrl
c_func
(paren
id|port
comma
id|TIOCM_RTS
op_or
id|TIOCM_DTR
)paren
suffix:semicolon
)brace
id|info-&gt;flags
op_or_assign
id|UIF_INITIALIZED
suffix:semicolon
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_logical_and
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
id|retval
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine will shutdown a serial port; interrupts are disabled, and&n; * DTR is dropped if the hangup on close termio flag is on.  Calls to&n; * uart_shutdown are serialised by the per-port semaphore.&n; */
DECL|function|uart_shutdown
r_static
r_void
id|uart_shutdown
c_func
(paren
r_struct
id|uart_state
op_star
id|state
)paren
(brace
r_struct
id|uart_info
op_star
id|info
op_assign
id|state-&gt;info
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|UIF_INITIALIZED
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Turn off DTR and RTS early.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
op_logical_or
(paren
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
)paren
id|uart_clear_mctrl
c_func
(paren
id|port
comma
id|TIOCM_DTR
op_or
id|TIOCM_RTS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * clear delta_msr_wait queue to avoid mem leaks: we may free&n;&t; * the irq here so the queue might never be woken up.  Note&n;&t; * that we won&squot;t end up waiting on delta_msr_wait again since&n;&t; * any outstanding file descriptors should be pointing at&n;&t; * hung_up_tty_fops now.&n;&t; */
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;delta_msr_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Free the IRQ and disable the port.&n;&t; */
id|port-&gt;ops
op_member_access_from_pointer
id|shutdown
c_func
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the IRQ handler isn&squot;t running on another CPU.&n;&t; */
id|synchronize_irq
c_func
(paren
id|port-&gt;irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Free the transmit buffer page.&n;&t; */
r_if
c_cond
(paren
id|info-&gt;xmit.buf
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|info-&gt;xmit.buf
)paren
suffix:semicolon
id|info-&gt;xmit.buf
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * kill off our tasklet&n;&t; */
id|tasklet_kill
c_func
(paren
op_amp
id|info-&gt;tlet
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
id|UIF_INITIALIZED
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;uart_update_timeout - update per-port FIFO timeout.&n; *&t;@port:  uart_port structure describing the port&n; *&t;@cflag: termios cflag value&n; *&t;@baud:  speed of the port&n; *&n; *&t;Set the port FIFO timeout value.  The @cflag value should&n; *&t;reflect the actual hardware settings.&n; */
r_void
DECL|function|uart_update_timeout
id|uart_update_timeout
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|cflag
comma
r_int
r_int
id|baud
)paren
(brace
r_int
r_int
id|bits
suffix:semicolon
multiline_comment|/* byte size and parity */
r_switch
c_cond
(paren
id|cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|bits
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|bits
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|bits
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|bits
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// CS8
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|CSTOPB
)paren
id|bits
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_amp
id|PARENB
)paren
id|bits
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * The total number of bits to be transmitted in the fifo.&n;&t; */
id|bits
op_assign
id|bits
op_star
id|port-&gt;fifosize
suffix:semicolon
multiline_comment|/*&n;&t; * Figure the timeout to send the above number of bits.&n;&t; * Add .02 seconds of slop&n;&t; */
id|port-&gt;timeout
op_assign
(paren
id|HZ
op_star
id|bits
)paren
op_div
id|baud
op_plus
id|HZ
op_div
l_int|50
suffix:semicolon
)brace
DECL|variable|uart_update_timeout
id|EXPORT_SYMBOL
c_func
(paren
id|uart_update_timeout
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;uart_get_baud_rate - return baud rate for a particular port&n; *&t;@port: uart_port structure describing the port in question.&n; *&t;@termios: desired termios settings.&n; *&t;@old: old termios (or NULL)&n; *&t;@min: minimum acceptable baud rate&n; *&t;@max: maximum acceptable baud rate&n; *&n; *&t;Decode the termios structure into a numeric baud rate,&n; *&t;taking account of the magic 38400 baud rate (with spd_*&n; *&t;flags), and mapping the %B0 rate to 9600 baud.&n; *&n; *&t;If the new baud rate is invalid, try the old termios setting.&n; *&t;If it&squot;s still invalid, we try 9600 baud.&n; *&n; *&t;Update the @termios structure to reflect the baud rate&n; *&t;we&squot;re actually going to be using.&n; */
r_int
r_int
DECL|function|uart_get_baud_rate
id|uart_get_baud_rate
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|termios
op_star
id|termios
comma
r_struct
id|termios
op_star
id|old
comma
r_int
r_int
id|min
comma
r_int
r_int
id|max
)paren
(brace
r_int
r_int
r_try
comma
id|baud
comma
id|altbaud
op_assign
l_int|38400
suffix:semicolon
r_int
r_int
id|flags
op_assign
id|port-&gt;flags
op_amp
id|UPF_SPD_MASK
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
id|UPF_SPD_HI
)paren
id|altbaud
op_assign
l_int|57600
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
id|UPF_SPD_VHI
)paren
id|altbaud
op_assign
l_int|115200
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
id|UPF_SPD_SHI
)paren
id|altbaud
op_assign
l_int|230400
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
id|UPF_SPD_WARP
)paren
id|altbaud
op_assign
l_int|460800
suffix:semicolon
r_for
c_loop
(paren
r_try
op_assign
l_int|0
suffix:semicolon
r_try
OL
l_int|2
suffix:semicolon
r_try
op_increment
)paren
(brace
id|baud
op_assign
id|tty_termios_baud_rate
c_func
(paren
id|termios
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The spd_hi, spd_vhi, spd_shi, spd_warp kludge...&n;&t;&t; * Die! Die! Die!&n;&t;&t; */
r_if
c_cond
(paren
id|baud
op_eq
l_int|38400
)paren
id|baud
op_assign
id|altbaud
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Special case: B0 rate.&n;&t;&t; */
r_if
c_cond
(paren
id|baud
op_eq
l_int|0
)paren
id|baud
op_assign
l_int|9600
suffix:semicolon
r_if
c_cond
(paren
id|baud
op_ge
id|min
op_logical_and
id|baud
op_le
id|max
)paren
r_return
id|baud
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Oops, the quotient was zero.  Try again with&n;&t;&t; * the old baud rate if possible.&n;&t;&t; */
id|termios-&gt;c_cflag
op_and_assign
op_complement
id|CBAUD
suffix:semicolon
r_if
c_cond
(paren
id|old
)paren
(brace
id|termios-&gt;c_cflag
op_or_assign
id|old-&gt;c_cflag
op_amp
id|CBAUD
suffix:semicolon
id|old
op_assign
l_int|NULL
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * As a last resort, if the quotient is zero,&n;&t;&t; * default to 9600 bps&n;&t;&t; */
id|termios-&gt;c_cflag
op_or_assign
id|B9600
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|uart_get_baud_rate
id|EXPORT_SYMBOL
c_func
(paren
id|uart_get_baud_rate
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;uart_get_divisor - return uart clock divisor&n; *&t;@port: uart_port structure describing the port.&n; *&t;@baud: desired baud rate&n; *&n; *&t;Calculate the uart clock divisor for the port.&n; */
r_int
r_int
DECL|function|uart_get_divisor
id|uart_get_divisor
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|baud
)paren
(brace
r_int
r_int
id|quot
suffix:semicolon
multiline_comment|/*&n;&t; * Old custom speed handling.&n;&t; */
r_if
c_cond
(paren
id|baud
op_eq
l_int|38400
op_logical_and
(paren
id|port-&gt;flags
op_amp
id|UPF_SPD_MASK
)paren
op_eq
id|UPF_SPD_CUST
)paren
id|quot
op_assign
id|port-&gt;custom_divisor
suffix:semicolon
r_else
id|quot
op_assign
(paren
id|port-&gt;uartclk
op_plus
(paren
l_int|8
op_star
id|baud
)paren
)paren
op_div
(paren
l_int|16
op_star
id|baud
)paren
suffix:semicolon
r_return
id|quot
suffix:semicolon
)brace
DECL|variable|uart_get_divisor
id|EXPORT_SYMBOL
c_func
(paren
id|uart_get_divisor
)paren
suffix:semicolon
r_static
r_void
DECL|function|uart_change_speed
id|uart_change_speed
c_func
(paren
r_struct
id|uart_state
op_star
id|state
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|state-&gt;info-&gt;tty
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_struct
id|termios
op_star
id|termios
suffix:semicolon
multiline_comment|/*&n;&t; * If we have no tty, termios, or the port does not exist,&n;&t; * then we can&squot;t set the parameters for this port.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|tty-&gt;termios
op_logical_or
id|port-&gt;type
op_eq
id|PORT_UNKNOWN
)paren
r_return
suffix:semicolon
id|termios
op_assign
id|tty-&gt;termios
suffix:semicolon
multiline_comment|/*&n;&t; * Set flags based on termios cflag&n;&t; */
r_if
c_cond
(paren
id|termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
id|state-&gt;info-&gt;flags
op_or_assign
id|UIF_CTS_FLOW
suffix:semicolon
r_else
id|state-&gt;info-&gt;flags
op_and_assign
op_complement
id|UIF_CTS_FLOW
suffix:semicolon
r_if
c_cond
(paren
id|termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
id|state-&gt;info-&gt;flags
op_and_assign
op_complement
id|UIF_CHECK_CD
suffix:semicolon
r_else
id|state-&gt;info-&gt;flags
op_or_assign
id|UIF_CHECK_CD
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|set_termios
c_func
(paren
id|port
comma
id|termios
comma
id|old_termios
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__uart_put_char
id|__uart_put_char
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|circ_buf
op_star
id|circ
comma
r_int
r_char
id|c
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|circ-&gt;buf
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_chars_free
c_func
(paren
id|circ
)paren
op_ne
l_int|0
)paren
(brace
id|circ-&gt;buf
(braket
id|circ-&gt;head
)braket
op_assign
id|c
suffix:semicolon
id|circ-&gt;head
op_assign
(paren
id|circ-&gt;head
op_plus
l_int|1
)paren
op_amp
(paren
id|UART_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|uart_put_char
r_static
r_void
id|uart_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
id|__uart_put_char
c_func
(paren
id|state-&gt;port
comma
op_amp
id|state-&gt;info-&gt;xmit
comma
id|ch
)paren
suffix:semicolon
)brace
DECL|function|uart_flush_chars
r_static
r_void
id|uart_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|uart_start
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|uart_write
id|uart_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_struct
id|circ_buf
op_star
id|circ
op_assign
op_amp
id|state-&gt;info-&gt;xmit
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|c
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|circ-&gt;buf
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|c
op_assign
id|CIRC_SPACE_TO_END
c_func
(paren
id|circ-&gt;head
comma
id|circ-&gt;tail
comma
id|UART_XMIT_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
id|c
)paren
id|c
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|memcpy
c_func
(paren
id|circ-&gt;buf
op_plus
id|circ-&gt;head
comma
id|buf
comma
id|c
)paren
suffix:semicolon
id|circ-&gt;head
op_assign
(paren
id|circ-&gt;head
op_plus
id|c
)paren
op_amp
(paren
id|UART_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
id|ret
op_add_assign
id|c
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|uart_start
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|uart_write_room
r_static
r_int
id|uart_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_return
id|uart_circ_chars_free
c_func
(paren
op_amp
id|state-&gt;info-&gt;xmit
)paren
suffix:semicolon
)brace
DECL|function|uart_chars_in_buffer
r_static
r_int
id|uart_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_return
id|uart_circ_chars_pending
c_func
(paren
op_amp
id|state-&gt;info-&gt;xmit
)paren
suffix:semicolon
)brace
DECL|function|uart_flush_buffer
r_static
r_void
id|uart_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;uart_flush_buffer(%d) called&bslash;n&quot;
comma
id|tty-&gt;index
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|uart_circ_clear
c_func
(paren
op_amp
id|state-&gt;info-&gt;xmit
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|tty_wakeup
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is used to send a high-priority XON/XOFF character to&n; * the device&n; */
DECL|function|uart_send_xchar
r_static
r_void
id|uart_send_xchar
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
id|ch
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;ops-&gt;send_xchar
)paren
id|port-&gt;ops
op_member_access_from_pointer
id|send_xchar
c_func
(paren
id|port
comma
id|ch
)paren
suffix:semicolon
r_else
(brace
id|port-&gt;x_char
op_assign
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|ch
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|start_tx
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|uart_throttle
r_static
r_void
id|uart_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
id|uart_send_xchar
c_func
(paren
id|tty
comma
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
id|uart_clear_mctrl
c_func
(paren
id|state-&gt;port
comma
id|TIOCM_RTS
)paren
suffix:semicolon
)brace
DECL|function|uart_unthrottle
r_static
r_void
id|uart_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;x_char
)paren
id|port-&gt;x_char
op_assign
l_int|0
suffix:semicolon
r_else
id|uart_send_xchar
c_func
(paren
id|tty
comma
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
id|uart_set_mctrl
c_func
(paren
id|port
comma
id|TIOCM_RTS
)paren
suffix:semicolon
)brace
DECL|function|uart_get_info
r_static
r_int
id|uart_get_info
c_func
(paren
r_struct
id|uart_state
op_star
id|state
comma
r_struct
id|serial_struct
id|__user
op_star
id|retinfo
)paren
(brace
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_struct
id|serial_struct
id|tmp
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|tmp.type
op_assign
id|port-&gt;type
suffix:semicolon
id|tmp.line
op_assign
id|port-&gt;line
suffix:semicolon
id|tmp.port
op_assign
id|port-&gt;iobase
suffix:semicolon
r_if
c_cond
(paren
id|HIGH_BITS_OFFSET
)paren
id|tmp.port_high
op_assign
(paren
r_int
)paren
id|port-&gt;iobase
op_rshift
id|HIGH_BITS_OFFSET
suffix:semicolon
id|tmp.irq
op_assign
id|port-&gt;irq
suffix:semicolon
id|tmp.flags
op_assign
id|port-&gt;flags
suffix:semicolon
id|tmp.xmit_fifo_size
op_assign
id|port-&gt;fifosize
suffix:semicolon
id|tmp.baud_base
op_assign
id|port-&gt;uartclk
op_div
l_int|16
suffix:semicolon
id|tmp.close_delay
op_assign
id|state-&gt;close_delay
op_div
l_int|10
suffix:semicolon
id|tmp.closing_wait
op_assign
id|state-&gt;closing_wait
op_eq
id|USF_CLOSING_WAIT_NONE
ques
c_cond
id|ASYNC_CLOSING_WAIT_NONE
suffix:colon
id|state-&gt;closing_wait
op_div
l_int|10
suffix:semicolon
id|tmp.custom_divisor
op_assign
id|port-&gt;custom_divisor
suffix:semicolon
id|tmp.hub6
op_assign
id|port-&gt;hub6
suffix:semicolon
id|tmp.io_type
op_assign
id|port-&gt;iotype
suffix:semicolon
id|tmp.iomem_reg_shift
op_assign
id|port-&gt;regshift
suffix:semicolon
id|tmp.iomem_base
op_assign
(paren
r_void
op_star
)paren
id|port-&gt;mapbase
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|retinfo
comma
op_amp
id|tmp
comma
r_sizeof
(paren
op_star
id|retinfo
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|uart_set_info
r_static
r_int
id|uart_set_info
c_func
(paren
r_struct
id|uart_state
op_star
id|state
comma
r_struct
id|serial_struct
id|__user
op_star
id|newinfo
)paren
(brace
r_struct
id|serial_struct
id|new_serial
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_int
r_int
id|new_port
suffix:semicolon
r_int
r_int
id|change_irq
comma
id|change_port
comma
id|old_flags
comma
id|closing_wait
suffix:semicolon
r_int
r_int
id|old_custom_divisor
comma
id|close_delay
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_serial
comma
id|newinfo
comma
r_sizeof
(paren
id|new_serial
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|new_port
op_assign
id|new_serial.port
suffix:semicolon
r_if
c_cond
(paren
id|HIGH_BITS_OFFSET
)paren
id|new_port
op_add_assign
(paren
r_int
r_int
)paren
id|new_serial.port_high
op_lshift
id|HIGH_BITS_OFFSET
suffix:semicolon
id|new_serial.irq
op_assign
id|irq_canonicalize
c_func
(paren
id|new_serial.irq
)paren
suffix:semicolon
id|close_delay
op_assign
id|new_serial.close_delay
op_star
l_int|10
suffix:semicolon
id|closing_wait
op_assign
id|new_serial.closing_wait
op_eq
id|ASYNC_CLOSING_WAIT_NONE
ques
c_cond
id|USF_CLOSING_WAIT_NONE
suffix:colon
id|new_serial.closing_wait
op_star
l_int|10
suffix:semicolon
multiline_comment|/*&n;&t; * This semaphore protects state-&gt;count.  It is also&n;&t; * very useful to prevent opens.  Also, take the&n;&t; * port configuration semaphore to make sure that a&n;&t; * module insertion/removal doesn&squot;t change anything&n;&t; * under us.&n;&t; */
id|down
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
id|change_irq
op_assign
id|new_serial.irq
op_ne
id|port-&gt;irq
suffix:semicolon
multiline_comment|/*&n;&t; * Since changing the &squot;type&squot; of the port changes its resource&n;&t; * allocations, we should treat type changes the same as&n;&t; * IO port changes.&n;&t; */
id|change_port
op_assign
id|new_port
op_ne
id|port-&gt;iobase
op_logical_or
(paren
r_int
r_int
)paren
id|new_serial.iomem_base
op_ne
id|port-&gt;mapbase
op_logical_or
id|new_serial.hub6
op_ne
id|port-&gt;hub6
op_logical_or
id|new_serial.io_type
op_ne
id|port-&gt;iotype
op_logical_or
id|new_serial.iomem_reg_shift
op_ne
id|port-&gt;regshift
op_logical_or
id|new_serial.type
op_ne
id|port-&gt;type
suffix:semicolon
id|old_flags
op_assign
id|port-&gt;flags
suffix:semicolon
id|old_custom_divisor
op_assign
id|port-&gt;custom_divisor
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|change_irq
op_logical_or
id|change_port
op_logical_or
(paren
id|new_serial.baud_base
op_ne
id|port-&gt;uartclk
op_div
l_int|16
)paren
op_logical_or
(paren
id|close_delay
op_ne
id|state-&gt;close_delay
)paren
op_logical_or
(paren
id|closing_wait
op_ne
id|state-&gt;closing_wait
)paren
op_logical_or
(paren
id|new_serial.xmit_fifo_size
op_ne
id|port-&gt;fifosize
)paren
op_logical_or
(paren
(paren
(paren
id|new_serial.flags
op_xor
id|old_flags
)paren
op_amp
op_complement
id|UPF_USR_MASK
)paren
op_ne
l_int|0
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|port-&gt;flags
op_assign
(paren
(paren
id|port-&gt;flags
op_amp
op_complement
id|UPF_USR_MASK
)paren
op_or
(paren
id|new_serial.flags
op_amp
id|UPF_USR_MASK
)paren
)paren
suffix:semicolon
id|port-&gt;custom_divisor
op_assign
id|new_serial.custom_divisor
suffix:semicolon
r_goto
id|check_and_exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ask the low level driver to verify the settings.&n;&t; */
r_if
c_cond
(paren
id|port-&gt;ops-&gt;verify_port
)paren
id|retval
op_assign
id|port-&gt;ops
op_member_access_from_pointer
id|verify_port
c_func
(paren
id|port
comma
op_amp
id|new_serial
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_serial.irq
op_ge
id|NR_IRQS
)paren
op_logical_or
(paren
id|new_serial.irq
OL
l_int|0
)paren
op_logical_or
(paren
id|new_serial.baud_base
OL
l_int|9600
)paren
)paren
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
id|change_port
op_logical_or
id|change_irq
)paren
(brace
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure that we are the sole user of this port.&n;&t;&t; */
r_if
c_cond
(paren
id|uart_users
c_func
(paren
id|state
)paren
OG
l_int|1
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We need to shutdown the serial port at the old&n;&t;&t; * port/type/irq combination.&n;&t;&t; */
id|uart_shutdown
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|change_port
)paren
(brace
r_int
r_int
id|old_iobase
comma
id|old_mapbase
suffix:semicolon
r_int
r_int
id|old_type
comma
id|old_iotype
comma
id|old_hub6
comma
id|old_shift
suffix:semicolon
id|old_iobase
op_assign
id|port-&gt;iobase
suffix:semicolon
id|old_mapbase
op_assign
id|port-&gt;mapbase
suffix:semicolon
id|old_type
op_assign
id|port-&gt;type
suffix:semicolon
id|old_hub6
op_assign
id|port-&gt;hub6
suffix:semicolon
id|old_iotype
op_assign
id|port-&gt;iotype
suffix:semicolon
id|old_shift
op_assign
id|port-&gt;regshift
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Free and release old regions&n;&t;&t; */
r_if
c_cond
(paren
id|old_type
op_ne
id|PORT_UNKNOWN
)paren
id|port-&gt;ops
op_member_access_from_pointer
id|release_port
c_func
(paren
id|port
)paren
suffix:semicolon
id|port-&gt;iobase
op_assign
id|new_port
suffix:semicolon
id|port-&gt;type
op_assign
id|new_serial.type
suffix:semicolon
id|port-&gt;hub6
op_assign
id|new_serial.hub6
suffix:semicolon
id|port-&gt;iotype
op_assign
id|new_serial.io_type
suffix:semicolon
id|port-&gt;regshift
op_assign
id|new_serial.iomem_reg_shift
suffix:semicolon
id|port-&gt;mapbase
op_assign
(paren
r_int
r_int
)paren
id|new_serial.iomem_base
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Claim and map the new regions&n;&t;&t; */
r_if
c_cond
(paren
id|port-&gt;type
op_ne
id|PORT_UNKNOWN
)paren
(brace
id|retval
op_assign
id|port-&gt;ops
op_member_access_from_pointer
id|request_port
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Always success - Jean II */
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we fail to request resources for the&n;&t;&t; * new port, try to restore the old settings.&n;&t;&t; */
r_if
c_cond
(paren
id|retval
op_logical_and
id|old_type
op_ne
id|PORT_UNKNOWN
)paren
(brace
id|port-&gt;iobase
op_assign
id|old_iobase
suffix:semicolon
id|port-&gt;type
op_assign
id|old_type
suffix:semicolon
id|port-&gt;hub6
op_assign
id|old_hub6
suffix:semicolon
id|port-&gt;iotype
op_assign
id|old_iotype
suffix:semicolon
id|port-&gt;regshift
op_assign
id|old_shift
suffix:semicolon
id|port-&gt;mapbase
op_assign
id|old_mapbase
suffix:semicolon
id|retval
op_assign
id|port-&gt;ops
op_member_access_from_pointer
id|request_port
c_func
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we failed to restore the old settings,&n;&t;&t;&t; * we fail like this.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|retval
)paren
id|port-&gt;type
op_assign
id|PORT_UNKNOWN
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We failed anyway.&n;&t;&t;&t; */
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
id|port-&gt;irq
op_assign
id|new_serial.irq
suffix:semicolon
id|port-&gt;uartclk
op_assign
id|new_serial.baud_base
op_star
l_int|16
suffix:semicolon
id|port-&gt;flags
op_assign
(paren
id|port-&gt;flags
op_amp
op_complement
id|UPF_CHANGE_MASK
)paren
op_or
(paren
id|new_serial.flags
op_amp
id|UPF_CHANGE_MASK
)paren
suffix:semicolon
id|port-&gt;custom_divisor
op_assign
id|new_serial.custom_divisor
suffix:semicolon
id|state-&gt;close_delay
op_assign
id|close_delay
suffix:semicolon
id|state-&gt;closing_wait
op_assign
id|closing_wait
suffix:semicolon
id|port-&gt;fifosize
op_assign
id|new_serial.xmit_fifo_size
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;info-&gt;tty
)paren
id|state-&gt;info-&gt;tty-&gt;low_latency
op_assign
(paren
id|port-&gt;flags
op_amp
id|UPF_LOW_LATENCY
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|check_and_exit
suffix:colon
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;type
op_eq
id|PORT_UNKNOWN
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;info-&gt;flags
op_amp
id|UIF_INITIALIZED
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|old_flags
op_xor
id|port-&gt;flags
)paren
op_amp
id|UPF_SPD_MASK
)paren
op_logical_or
id|old_custom_divisor
op_ne
id|port-&gt;custom_divisor
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If they&squot;re setting up a custom divisor or speed,&n;&t;&t;&t; * instead of clearing it, then bitch about it. No&n;&t;&t;&t; * need to rate-limit; it&squot;s CAP_SYS_ADMIN only.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|UPF_SPD_MASK
)paren
(brace
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s sets custom speed on %s. This &quot;
l_string|&quot;is deprecated.&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|tty_name
c_func
(paren
id|state-&gt;info-&gt;tty
comma
id|buf
)paren
)paren
suffix:semicolon
)brace
id|uart_change_speed
c_func
(paren
id|state
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
r_else
id|retval
op_assign
id|uart_startup
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
m_exit
suffix:colon
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * uart_get_lsr_info - get line status register info.&n; * Note: uart_ioctl protects us against hangups.&n; */
DECL|function|uart_get_lsr_info
r_static
r_int
id|uart_get_lsr_info
c_func
(paren
r_struct
id|uart_state
op_star
id|state
comma
r_int
r_int
id|__user
op_star
id|value
)paren
(brace
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_int
r_int
id|result
suffix:semicolon
id|result
op_assign
id|port-&gt;ops
op_member_access_from_pointer
id|tx_empty
c_func
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re about to load something into the transmit&n;&t; * register, we&squot;ll pretend the transmitter isn&squot;t empty to&n;&t; * avoid a race condition (depending on when the transmit&n;&t; * interrupt happens).&n;&t; */
r_if
c_cond
(paren
id|port-&gt;x_char
op_logical_or
(paren
(paren
id|uart_circ_chars_pending
c_func
(paren
op_amp
id|state-&gt;info-&gt;xmit
)paren
OG
l_int|0
)paren
op_logical_and
op_logical_neg
id|state-&gt;info-&gt;tty-&gt;stopped
op_logical_and
op_logical_neg
id|state-&gt;info-&gt;tty-&gt;hw_stopped
)paren
)paren
id|result
op_and_assign
op_complement
id|TIOCSER_TEMT
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|result
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|uart_tiocmget
r_static
r_int
id|uart_tiocmget
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_int
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|file
op_logical_or
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|file
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
)paren
(brace
id|result
op_assign
id|port-&gt;mctrl
suffix:semicolon
id|result
op_or_assign
id|port-&gt;ops
op_member_access_from_pointer
id|get_mctrl
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_int
DECL|function|uart_tiocmset
id|uart_tiocmset
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|set
comma
r_int
r_int
id|clear
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|file
op_logical_or
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|file
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
)paren
(brace
id|uart_update_mctrl
c_func
(paren
id|port
comma
id|set
comma
id|clear
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|uart_break_ctl
r_static
r_void
id|uart_break_ctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|break_state
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|kernel_locked
c_func
(paren
)paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;type
op_ne
id|PORT_UNKNOWN
)paren
id|port-&gt;ops
op_member_access_from_pointer
id|break_ctl
c_func
(paren
id|port
comma
id|break_state
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
)brace
DECL|function|uart_do_autoconfig
r_static
r_int
id|uart_do_autoconfig
c_func
(paren
r_struct
id|uart_state
op_star
id|state
)paren
(brace
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_int
id|flags
comma
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*&n;&t; * Take the per-port semaphore.  This prevents count from&n;&t; * changing, and hence any extra opens of the port while&n;&t; * we&squot;re auto-configuring.&n;&t; */
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|state-&gt;sem
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|uart_users
c_func
(paren
id|state
)paren
op_eq
l_int|1
)paren
(brace
id|uart_shutdown
c_func
(paren
id|state
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we already have a port type configured,&n;&t;&t; * we must release its resources.&n;&t;&t; */
r_if
c_cond
(paren
id|port-&gt;type
op_ne
id|PORT_UNKNOWN
)paren
id|port-&gt;ops
op_member_access_from_pointer
id|release_port
c_func
(paren
id|port
)paren
suffix:semicolon
id|flags
op_assign
id|UART_CONFIG_TYPE
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|UPF_AUTO_IRQ
)paren
id|flags
op_or_assign
id|UART_CONFIG_IRQ
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This will claim the ports resources if&n;&t;&t; * a port is found.&n;&t;&t; */
id|port-&gt;ops
op_member_access_from_pointer
id|config_port
c_func
(paren
id|port
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|uart_startup
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change&n; * - mask passed in arg for lines of interest&n; *   (use |&squot;ed TIOCM_RNG/DSR/CD/CTS for masking)&n; * Caller should use TIOCGICOUNT to see which one it was&n; */
r_static
r_int
DECL|function|uart_wait_modem_status
id|uart_wait_modem_status
c_func
(paren
r_struct
id|uart_state
op_star
id|state
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|uart_icount
id|cprev
comma
id|cnow
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * note the counters on entry&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|cprev
comma
op_amp
id|port-&gt;icount
comma
r_sizeof
(paren
r_struct
id|uart_icount
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Force modem status interrupts on&n;&t; */
id|port-&gt;ops
op_member_access_from_pointer
id|enable_ms
c_func
(paren
id|port
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|state-&gt;info-&gt;delta_msr_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|cnow
comma
op_amp
id|port-&gt;icount
comma
r_sizeof
(paren
r_struct
id|uart_icount
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|arg
op_amp
id|TIOCM_RNG
)paren
op_logical_and
(paren
id|cnow.rng
op_ne
id|cprev.rng
)paren
)paren
op_logical_or
(paren
(paren
id|arg
op_amp
id|TIOCM_DSR
)paren
op_logical_and
(paren
id|cnow.dsr
op_ne
id|cprev.dsr
)paren
)paren
op_logical_or
(paren
(paren
id|arg
op_amp
id|TIOCM_CD
)paren
op_logical_and
(paren
id|cnow.dcd
op_ne
id|cprev.dcd
)paren
)paren
op_logical_or
(paren
(paren
id|arg
op_amp
id|TIOCM_CTS
)paren
op_logical_and
(paren
id|cnow.cts
op_ne
id|cprev.cts
)paren
)paren
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* see if a signal did it */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cprev
op_assign
id|cnow
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|state-&gt;info-&gt;delta_msr_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)&n; * Return: write counters to the user passed counter struct&n; * NB: both 1-&gt;0 and 0-&gt;1 transitions are counted except for&n; *     RI where only 0-&gt;1 is counted.&n; */
DECL|function|uart_get_count
r_static
r_int
id|uart_get_count
c_func
(paren
r_struct
id|uart_state
op_star
id|state
comma
r_struct
id|serial_icounter_struct
id|__user
op_star
id|icnt
)paren
(brace
r_struct
id|serial_icounter_struct
id|icount
suffix:semicolon
r_struct
id|uart_icount
id|cnow
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|cnow
comma
op_amp
id|port-&gt;icount
comma
r_sizeof
(paren
r_struct
id|uart_icount
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
id|icount.cts
op_assign
id|cnow.cts
suffix:semicolon
id|icount.dsr
op_assign
id|cnow.dsr
suffix:semicolon
id|icount.rng
op_assign
id|cnow.rng
suffix:semicolon
id|icount.dcd
op_assign
id|cnow.dcd
suffix:semicolon
id|icount.rx
op_assign
id|cnow.rx
suffix:semicolon
id|icount.tx
op_assign
id|cnow.tx
suffix:semicolon
id|icount.frame
op_assign
id|cnow.frame
suffix:semicolon
id|icount.overrun
op_assign
id|cnow.overrun
suffix:semicolon
id|icount.parity
op_assign
id|cnow.parity
suffix:semicolon
id|icount.brk
op_assign
id|cnow.brk
suffix:semicolon
id|icount.buf_overrun
op_assign
id|cnow.buf_overrun
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
id|icnt
comma
op_amp
id|icount
comma
r_sizeof
(paren
id|icount
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Called via sys_ioctl under the BKL.  We can use spin_lock_irq() here.&n; */
r_static
r_int
DECL|function|uart_ioctl
id|uart_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_void
id|__user
op_star
id|uarg
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|kernel_locked
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * These ioctls don&squot;t rely on the hardware to be present.&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCGSERIAL
suffix:colon
id|ret
op_assign
id|uart_get_info
c_func
(paren
id|state
comma
id|uarg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSSERIAL
suffix:colon
id|ret
op_assign
id|uart_set_info
c_func
(paren
id|state
comma
id|uarg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSERCONFIG
suffix:colon
id|ret
op_assign
id|uart_do_autoconfig
c_func
(paren
id|state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSERGWILD
suffix:colon
multiline_comment|/* obsolete */
r_case
id|TIOCSERSWILD
suffix:colon
multiline_comment|/* obsolete */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|ENOIOCTLCMD
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The following should only be used when hardware is present.&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMIWAIT
suffix:colon
id|ret
op_assign
id|uart_wait_modem_status
c_func
(paren
id|state
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCGICOUNT
suffix:colon
id|ret
op_assign
id|uart_get_count
c_func
(paren
id|state
comma
id|uarg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|ENOIOCTLCMD
)paren
r_goto
id|out
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out_up
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * All these rely on hardware being present and need to be&n;&t; * protected against the tty being hung up.&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCSERGETLSR
suffix:colon
multiline_comment|/* Get line status register */
id|ret
op_assign
id|uart_get_lsr_info
c_func
(paren
id|state
comma
id|uarg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
(brace
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;ops-&gt;ioctl
)paren
id|ret
op_assign
id|port-&gt;ops
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|port
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|out_up
suffix:colon
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|uart_set_termios
r_static
r_void
id|uart_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|cflag
op_assign
id|tty-&gt;termios-&gt;c_cflag
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|kernel_locked
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * These are the bits that are used to setup various&n;&t; * flags in the low level driver.&n;&t; */
DECL|macro|RELEVANT_IFLAG
mdefine_line|#define RELEVANT_IFLAG(iflag)&t;((iflag) &amp; (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
r_if
c_cond
(paren
(paren
id|cflag
op_xor
id|old_termios-&gt;c_cflag
)paren
op_eq
l_int|0
op_logical_and
id|RELEVANT_IFLAG
c_func
(paren
id|tty-&gt;termios-&gt;c_iflag
op_xor
id|old_termios-&gt;c_iflag
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|uart_change_speed
c_func
(paren
id|state
comma
id|old_termios
)paren
suffix:semicolon
multiline_comment|/* Handle transition to B0 status */
r_if
c_cond
(paren
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
op_logical_and
op_logical_neg
(paren
id|cflag
op_amp
id|CBAUD
)paren
)paren
id|uart_clear_mctrl
c_func
(paren
id|state-&gt;port
comma
id|TIOCM_RTS
op_or
id|TIOCM_DTR
)paren
suffix:semicolon
multiline_comment|/* Handle transition away from B0 status */
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
op_logical_and
(paren
id|cflag
op_amp
id|CBAUD
)paren
)paren
(brace
r_int
r_int
id|mask
op_assign
id|TIOCM_DTR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
op_logical_or
op_logical_neg
id|test_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
id|mask
op_or_assign
id|TIOCM_RTS
suffix:semicolon
id|uart_set_mctrl
c_func
(paren
id|state-&gt;port
comma
id|mask
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle turning off CRTSCTS */
r_if
c_cond
(paren
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_logical_and
op_logical_neg
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;hw_stopped
op_assign
l_int|0
suffix:semicolon
id|__uart_start
c_func
(paren
id|tty
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n;&t; * No need to wake up processes in open wait, since they&n;&t; * sample the CLOCAL flag once, and don&squot;t recheck it.&n;&t; * XXX  It&squot;s not clear whether the current behavior is correct&n;&t; * or not.  Hence, this may change.....&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
op_logical_and
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|state-&gt;info-&gt;open_wait
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * In 2.4.5, calls to this will be serialized via the BKL in&n; *  linux/drivers/char/tty_io.c:tty_release()&n; *  linux/drivers/char/tty_io.c:do_tty_handup()&n; */
DECL|function|uart_close
r_static
r_void
id|uart_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|kernel_locked
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state
op_logical_or
op_logical_neg
id|state-&gt;port
)paren
r_return
suffix:semicolon
id|port
op_assign
id|state-&gt;port
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;uart_close(%d) called&bslash;n&quot;
comma
id|port-&gt;line
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|state-&gt;count
op_ne
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Uh, oh.  tty-&gt;count is 1, which means that the tty&n;&t;&t; * structure will be freed.  state-&gt;count should always&n;&t;&t; * be one in these conditions.  If it&squot;s greater than&n;&t;&t; * one, we&squot;ve got real problems, since it means the&n;&t;&t; * serial port won&squot;t be shutdown.&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;uart_close: bad serial port count; tty-&gt;count is 1, &quot;
l_string|&quot;state-&gt;count is %d&bslash;n&quot;
comma
id|state-&gt;count
)paren
suffix:semicolon
id|state-&gt;count
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|state-&gt;count
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;uart_close: bad serial port count for %s: %d&bslash;n&quot;
comma
id|tty-&gt;name
comma
id|state-&gt;count
)paren
suffix:semicolon
id|state-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|state-&gt;count
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/*&n;&t; * Now we wait for the transmit buffer to clear; and we notify&n;&t; * the line discipline to only process XON/XOFF characters by&n;&t; * setting tty-&gt;closing.&n;&t; */
id|tty-&gt;closing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;closing_wait
op_ne
id|USF_CLOSING_WAIT_NONE
)paren
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
id|msecs_to_jiffies
c_func
(paren
id|state-&gt;closing_wait
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, we stop accepting input.  To do this, we&n;&t; * disable the receive line status interrupts.&n;&t; */
r_if
c_cond
(paren
id|state-&gt;info-&gt;flags
op_amp
id|UIF_INITIALIZED
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|stop_rx
c_func
(paren
id|port
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Before we drop DTR, make sure the UART transmitter&n;&t;&t; * has completely drained; this is especially&n;&t;&t; * important if there is a transmit FIFO!&n;&t;&t; */
id|uart_wait_until_sent
c_func
(paren
id|tty
comma
id|port-&gt;timeout
)paren
suffix:semicolon
)brace
id|uart_shutdown
c_func
(paren
id|state
)paren
suffix:semicolon
id|uart_flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty_ldisc_flush
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
id|state-&gt;info-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;info-&gt;blocked_open
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;close_delay
)paren
id|msleep_interruptible
c_func
(paren
id|state-&gt;close_delay
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|uart_console
c_func
(paren
id|port
)paren
)paren
(brace
id|uart_change_pm
c_func
(paren
id|state
comma
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Wake up anyone trying to open this port.&n;&t; */
id|state-&gt;info-&gt;flags
op_and_assign
op_complement
id|UIF_NORMAL_ACTIVE
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|state-&gt;info-&gt;open_wait
)paren
suffix:semicolon
id|done
suffix:colon
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
)brace
DECL|function|uart_wait_until_sent
r_static
r_void
id|uart_wait_until_sent
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|timeout
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_int
r_int
id|char_time
comma
id|expire
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|kernel_locked
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;type
op_eq
id|PORT_UNKNOWN
op_logical_or
id|port-&gt;fifosize
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Set the check interval to be 1/5 of the estimated time to&n;&t; * send a single character, and make it at least 1.  The check&n;&t; * interval should also be less than the timeout.&n;&t; *&n;&t; * Note: we have to use pretty tight timings here to satisfy&n;&t; * the NIST-PCTS.&n;&t; */
id|char_time
op_assign
(paren
id|port-&gt;timeout
op_minus
id|HZ
op_div
l_int|50
)paren
op_div
id|port-&gt;fifosize
suffix:semicolon
id|char_time
op_assign
id|char_time
op_div
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|char_time
op_eq
l_int|0
)paren
id|char_time
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_logical_and
id|timeout
OL
id|char_time
)paren
id|char_time
op_assign
id|timeout
suffix:semicolon
multiline_comment|/*&n;&t; * If the transmitter hasn&squot;t cleared in twice the approximate&n;&t; * amount of time to send the entire FIFO, it probably won&squot;t&n;&t; * ever clear.  This assumes the UART isn&squot;t doing flow&n;&t; * control, which is currently the case.  Hence, if it ever&n;&t; * takes longer than port-&gt;timeout, this is probably due to a&n;&t; * UART bug of some kind.  So, we clamp the timeout parameter at&n;&t; * 2*port-&gt;timeout.&n;&t; */
r_if
c_cond
(paren
id|timeout
op_eq
l_int|0
op_logical_or
id|timeout
OG
l_int|2
op_star
id|port-&gt;timeout
)paren
id|timeout
op_assign
l_int|2
op_star
id|port-&gt;timeout
suffix:semicolon
id|expire
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;uart_wait_until_sent(%d), jiffies=%lu, expire=%lu...&bslash;n&quot;
comma
id|port-&gt;line
comma
id|jiffies
comma
id|expire
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check whether the transmitter is empty every &squot;char_time&squot;.&n;&t; * &squot;timeout&squot; / &squot;expire&squot; give us the maximum amount of time&n;&t; * we wait.&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|port-&gt;ops
op_member_access_from_pointer
id|tx_empty
c_func
(paren
id|port
)paren
)paren
(brace
id|msleep_interruptible
c_func
(paren
id|jiffies_to_msecs
c_func
(paren
id|char_time
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|expire
)paren
)paren
r_break
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
multiline_comment|/* might not be needed */
)brace
multiline_comment|/*&n; * This is called with the BKL held in&n; *  linux/drivers/char/tty_io.c:do_tty_hangup()&n; * We&squot;re called from the eventd thread, so we can sleep for&n; * a _short_ time only.&n; */
DECL|function|uart_hangup
r_static
r_void
id|uart_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|tty-&gt;driver_data
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|kernel_locked
c_func
(paren
)paren
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;uart_hangup(%d)&bslash;n&quot;
comma
id|state-&gt;port-&gt;line
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;info
op_logical_and
id|state-&gt;info-&gt;flags
op_amp
id|UIF_NORMAL_ACTIVE
)paren
(brace
id|uart_flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|uart_shutdown
c_func
(paren
id|state
)paren
suffix:semicolon
id|state-&gt;count
op_assign
l_int|0
suffix:semicolon
id|state-&gt;info-&gt;flags
op_and_assign
op_complement
id|UIF_NORMAL_ACTIVE
suffix:semicolon
id|state-&gt;info-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|state-&gt;info-&gt;open_wait
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|state-&gt;info-&gt;delta_msr_wait
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy across the serial console cflag setting into the termios settings&n; * for the initial open of the port.  This allows continuity between the&n; * kernel settings, and the settings init adopts when it opens the port&n; * for the first time.&n; */
DECL|function|uart_update_termios
r_static
r_void
id|uart_update_termios
c_func
(paren
r_struct
id|uart_state
op_star
id|state
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|state-&gt;info-&gt;tty
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_if
c_cond
(paren
id|uart_console
c_func
(paren
id|port
)paren
op_logical_and
id|port-&gt;cons-&gt;cflag
)paren
(brace
id|tty-&gt;termios-&gt;c_cflag
op_assign
id|port-&gt;cons-&gt;cflag
suffix:semicolon
id|port-&gt;cons-&gt;cflag
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the device failed to grab its irq resources,&n;&t; * or some other error occurred, don&squot;t try to talk&n;&t; * to the port hardware.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Make termios settings take effect.&n;&t;&t; */
id|uart_change_speed
c_func
(paren
id|state
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * And finally enable the RTS and DTR signals.&n;&t;&t; */
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
id|uart_set_mctrl
c_func
(paren
id|port
comma
id|TIOCM_DTR
op_or
id|TIOCM_RTS
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Block the open until the port is ready.  We must be called with&n; * the per-port semaphore held.&n; */
r_static
r_int
DECL|function|uart_block_til_ready
id|uart_block_til_ready
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|uart_state
op_star
id|state
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|uart_info
op_star
id|info
op_assign
id|state-&gt;info
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
id|info-&gt;blocked_open
op_increment
suffix:semicolon
id|state-&gt;count
op_decrement
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|info-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we have been hung up, tell userspace/restart open.&n;&t;&t; */
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
id|info-&gt;tty
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the port has been closed, tell userspace/restart open.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|UIF_INITIALIZED
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If non-blocking mode is set, or CLOCAL mode is set,&n;&t;&t; * we don&squot;t want to wait for the modem status lines to&n;&t;&t; * indicate that the port is ready.&n;&t;&t; *&n;&t;&t; * Also, if the port is not enabled/configured, we want&n;&t;&t; * to allow the open to succeed here.  Note that we will&n;&t;&t; * have set TTY_IO_ERROR for a non-existant port.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
op_logical_or
(paren
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
op_logical_or
(paren
id|info-&gt;tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set DTR to allow modem to know we&squot;re waiting.  Do&n;&t;&t; * not set RTS here - we want to make sure we catch&n;&t;&t; * the data from the modem.&n;&t;&t; */
r_if
c_cond
(paren
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
id|uart_set_mctrl
c_func
(paren
id|port
comma
id|TIOCM_DTR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * and wait for the carrier to indicate that the&n;&t;&t; * modem is ready for us.&n;&t;&t; */
r_if
c_cond
(paren
id|port-&gt;ops
op_member_access_from_pointer
id|get_mctrl
c_func
(paren
id|port
)paren
op_amp
id|TIOCM_CAR
)paren
r_break
suffix:semicolon
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|info-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|state-&gt;count
op_increment
suffix:semicolon
id|info-&gt;blocked_open
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
op_logical_or
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|uart_get
r_static
r_struct
id|uart_state
op_star
id|uart_get
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
comma
r_int
id|line
)paren
(brace
r_struct
id|uart_state
op_star
id|state
suffix:semicolon
id|down
c_func
(paren
op_amp
id|port_sem
)paren
suffix:semicolon
id|state
op_assign
id|drv-&gt;state
op_plus
id|line
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|state-&gt;sem
)paren
)paren
(brace
id|state
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|state-&gt;count
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;port
)paren
(brace
id|state-&gt;count
op_decrement
suffix:semicolon
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
id|state
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;info
)paren
(brace
id|state-&gt;info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|uart_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;info
)paren
(brace
id|memset
c_func
(paren
id|state-&gt;info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|uart_info
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|state-&gt;info-&gt;open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|state-&gt;info-&gt;delta_msr_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Link the info into the other structures.&n;&t;&t;&t; */
id|state-&gt;port-&gt;info
op_assign
id|state-&gt;info
suffix:semicolon
id|tasklet_init
c_func
(paren
op_amp
id|state-&gt;info-&gt;tlet
comma
id|uart_tasklet_action
comma
(paren
r_int
r_int
)paren
id|state
)paren
suffix:semicolon
)brace
r_else
(brace
id|state-&gt;count
op_decrement
suffix:semicolon
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
id|state
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|port_sem
)paren
suffix:semicolon
r_return
id|state
suffix:semicolon
)brace
multiline_comment|/*&n; * In 2.4.5, calls to uart_open are serialised by the BKL in&n; *   linux/fs/devices.c:chrdev_open()&n; * Note that if this fails, then uart_close() _will_ be called.&n; *&n; * In time, we want to scrap the &quot;opening nonpresent ports&quot;&n; * behaviour and implement an alternative way for setserial&n; * to set base addresses/ports/types.  This will allow us to&n; * get rid of a certain amount of extra tests.&n; */
DECL|function|uart_open
r_static
r_int
id|uart_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|uart_driver
op_star
id|drv
op_assign
(paren
r_struct
id|uart_driver
op_star
)paren
id|tty-&gt;driver-&gt;driver_state
suffix:semicolon
r_struct
id|uart_state
op_star
id|state
suffix:semicolon
r_int
id|retval
comma
id|line
op_assign
id|tty-&gt;index
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|kernel_locked
c_func
(paren
)paren
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;uart_open(%d) called&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * tty-&gt;driver-&gt;num won&squot;t change, so we won&squot;t fail here with&n;&t; * tty-&gt;driver_data set to something non-NULL (and therefore&n;&t; * we won&squot;t get caught by uart_close()).&n;&t; */
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|line
op_ge
id|tty-&gt;driver-&gt;num
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/*&n;&t; * We take the semaphore inside uart_get to guarantee that we won&squot;t&n;&t; * be re-entered while allocating the info structure, or while we&n;&t; * request any IRQs that the driver may need.  This also has the nice&n;&t; * side-effect that it delays the action of uart_hangup, so we can&n;&t; * guarantee that info-&gt;tty will always contain something reasonable.&n;&t; */
id|state
op_assign
id|uart_get
c_func
(paren
id|drv
comma
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|state
)paren
)paren
(brace
id|retval
op_assign
id|PTR_ERR
c_func
(paren
id|state
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Once we set tty-&gt;driver_data here, we are guaranteed that&n;&t; * uart_close() will decrement the driver module use count.&n;&t; * Any failures from here onwards should not touch the count.&n;&t; */
id|tty-&gt;driver_data
op_assign
id|state
suffix:semicolon
id|tty-&gt;low_latency
op_assign
(paren
id|state-&gt;port-&gt;flags
op_amp
id|UPF_LOW_LATENCY
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|tty-&gt;alt_speed
op_assign
l_int|0
suffix:semicolon
id|state-&gt;info-&gt;tty
op_assign
id|tty
suffix:semicolon
multiline_comment|/*&n;&t; * If the port is in the middle of closing, bail out now.&n;&t; */
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|state-&gt;count
op_decrement
suffix:semicolon
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make sure the device is in D0 state.&n;&t; */
r_if
c_cond
(paren
id|state-&gt;count
op_eq
l_int|1
)paren
id|uart_change_pm
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Start up the serial port.&n;&t; */
id|retval
op_assign
id|uart_startup
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we succeeded, wait until the port is ready.&n;&t; */
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
id|retval
op_assign
id|uart_block_til_ready
c_func
(paren
id|filp
comma
id|state
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is the first open to succeed, adjust things to suit.&n;&t; */
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
op_logical_and
op_logical_neg
(paren
id|state-&gt;info-&gt;flags
op_amp
id|UIF_NORMAL_ACTIVE
)paren
)paren
(brace
id|state-&gt;info-&gt;flags
op_or_assign
id|UIF_NORMAL_ACTIVE
suffix:semicolon
id|uart_update_termios
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|fail
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|uart_type
r_static
r_const
r_char
op_star
id|uart_type
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_const
r_char
op_star
id|str
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;ops-&gt;type
)paren
id|str
op_assign
id|port-&gt;ops
op_member_access_from_pointer
id|type
c_func
(paren
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|str
)paren
id|str
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_return
id|str
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|uart_line_info
r_static
r_int
id|uart_line_info
c_func
(paren
r_char
op_star
id|buf
comma
r_struct
id|uart_driver
op_star
id|drv
comma
r_int
id|i
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|drv-&gt;state
op_plus
id|i
suffix:semicolon
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_char
id|stat_buf
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
l_int|0
suffix:semicolon
id|ret
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d: uart:%s %s%08lX irq:%d&quot;
comma
id|port-&gt;line
comma
id|uart_type
c_func
(paren
id|port
)paren
comma
id|port-&gt;iotype
op_eq
id|UPIO_MEM
ques
c_cond
l_string|&quot;mmio:0x&quot;
suffix:colon
l_string|&quot;port:&quot;
comma
id|port-&gt;iotype
op_eq
id|UPIO_MEM
ques
c_cond
id|port-&gt;mapbase
suffix:colon
(paren
r_int
r_int
)paren
id|port-&gt;iobase
comma
id|port-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;type
op_eq
id|PORT_UNKNOWN
)paren
(brace
id|strcat
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
id|status
op_assign
id|port-&gt;ops
op_member_access_from_pointer
id|get_mctrl
c_func
(paren
id|port
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; tx:%d rx:%d&quot;
comma
id|port-&gt;icount.tx
comma
id|port-&gt;icount.rx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;icount.frame
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; fe:%d&quot;
comma
id|port-&gt;icount.frame
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;icount.parity
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; pe:%d&quot;
comma
id|port-&gt;icount.parity
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;icount.brk
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; brk:%d&quot;
comma
id|port-&gt;icount.brk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;icount.overrun
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; oe:%d&quot;
comma
id|port-&gt;icount.overrun
)paren
suffix:semicolon
DECL|macro|INFOBIT
mdefine_line|#define INFOBIT(bit,str) &bslash;&n;&t;if (port-&gt;mctrl &amp; (bit)) &bslash;&n;&t;&t;strncat(stat_buf, (str), sizeof(stat_buf) - &bslash;&n;&t;&t;&t;strlen(stat_buf) - 2)
DECL|macro|STATBIT
mdefine_line|#define STATBIT(bit,str) &bslash;&n;&t;if (status &amp; (bit)) &bslash;&n;&t;&t;strncat(stat_buf, (str), sizeof(stat_buf) - &bslash;&n;&t;&t;       strlen(stat_buf) - 2)
id|stat_buf
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|stat_buf
(braket
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|INFOBIT
c_func
(paren
id|TIOCM_RTS
comma
l_string|&quot;|RTS&quot;
)paren
suffix:semicolon
id|STATBIT
c_func
(paren
id|TIOCM_CTS
comma
l_string|&quot;|CTS&quot;
)paren
suffix:semicolon
id|INFOBIT
c_func
(paren
id|TIOCM_DTR
comma
l_string|&quot;|DTR&quot;
)paren
suffix:semicolon
id|STATBIT
c_func
(paren
id|TIOCM_DSR
comma
l_string|&quot;|DSR&quot;
)paren
suffix:semicolon
id|STATBIT
c_func
(paren
id|TIOCM_CAR
comma
l_string|&quot;|CD&quot;
)paren
suffix:semicolon
id|STATBIT
c_func
(paren
id|TIOCM_RNG
comma
l_string|&quot;|RI&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat_buf
(braket
l_int|0
)braket
)paren
id|stat_buf
(braket
l_int|0
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
id|stat_buf
)paren
suffix:semicolon
)brace
r_else
(brace
id|strcat
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
DECL|macro|STATBIT
macro_line|#undef STATBIT
DECL|macro|INFOBIT
macro_line|#undef INFOBIT
r_return
id|ret
suffix:semicolon
)brace
DECL|function|uart_read_proc
r_static
r_int
id|uart_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|tty_driver
op_star
id|ttydrv
op_assign
id|data
suffix:semicolon
r_struct
id|uart_driver
op_star
id|drv
op_assign
id|ttydrv-&gt;driver_state
suffix:semicolon
r_int
id|i
comma
id|len
op_assign
l_int|0
comma
id|l
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;serinfo:1.0 driver%s%s revision:%s&bslash;n&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|drv-&gt;nr
op_logical_and
id|len
OL
id|PAGE_SIZE
op_minus
l_int|96
suffix:semicolon
id|i
op_increment
)paren
(brace
id|l
op_assign
id|uart_line_info
c_func
(paren
id|page
op_plus
id|len
comma
id|drv
comma
id|i
)paren
suffix:semicolon
id|len
op_add_assign
id|l
suffix:semicolon
r_if
c_cond
(paren
id|len
op_plus
id|begin
OG
id|off
op_plus
id|count
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|len
op_plus
id|begin
OL
id|off
)paren
(brace
id|begin
op_add_assign
id|len
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
)brace
)brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|off
op_ge
id|len
op_plus
id|begin
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
(paren
id|off
op_minus
id|begin
)paren
suffix:semicolon
r_return
(paren
id|count
OL
id|begin
op_plus
id|len
op_minus
id|off
)paren
ques
c_cond
id|count
suffix:colon
(paren
id|begin
op_plus
id|len
op_minus
id|off
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_SERIAL_CORE_CONSOLE
multiline_comment|/*&n; *&t;Check whether an invalid uart number has been specified, and&n; *&t;if so, search for the first available port that does have&n; *&t;console support.&n; */
r_struct
id|uart_port
op_star
id|__init
DECL|function|uart_get_console
id|uart_get_console
c_func
(paren
r_struct
id|uart_port
op_star
id|ports
comma
r_int
id|nr
comma
r_struct
id|console
op_star
id|co
)paren
(brace
r_int
id|idx
op_assign
id|co-&gt;index
suffix:semicolon
r_if
c_cond
(paren
id|idx
OL
l_int|0
op_logical_or
id|idx
op_ge
id|nr
op_logical_or
(paren
id|ports
(braket
id|idx
)braket
dot
id|iobase
op_eq
l_int|0
op_logical_and
id|ports
(braket
id|idx
)braket
dot
id|membase
op_eq
l_int|NULL
)paren
)paren
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|nr
suffix:semicolon
id|idx
op_increment
)paren
r_if
c_cond
(paren
id|ports
(braket
id|idx
)braket
dot
id|iobase
op_ne
l_int|0
op_logical_or
id|ports
(braket
id|idx
)braket
dot
id|membase
op_ne
l_int|NULL
)paren
r_break
suffix:semicolon
id|co-&gt;index
op_assign
id|idx
suffix:semicolon
r_return
id|ports
op_plus
id|idx
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;uart_parse_options - Parse serial port baud/parity/bits/flow contro.&n; *&t;@options: pointer to option string&n; *&t;@baud: pointer to an &squot;int&squot; variable for the baud rate.&n; *&t;@parity: pointer to an &squot;int&squot; variable for the parity.&n; *&t;@bits: pointer to an &squot;int&squot; variable for the number of data bits.&n; *&t;@flow: pointer to an &squot;int&squot; variable for the flow control character.&n; *&n; *&t;uart_parse_options decodes a string containing the serial console&n; *&t;options.  The format of the string is &lt;baud&gt;&lt;parity&gt;&lt;bits&gt;&lt;flow&gt;,&n; *&t;eg: 115200n8r&n; */
r_void
id|__init
DECL|function|uart_parse_options
id|uart_parse_options
c_func
(paren
r_char
op_star
id|options
comma
r_int
op_star
id|baud
comma
r_int
op_star
id|parity
comma
r_int
op_star
id|bits
comma
r_int
op_star
id|flow
)paren
(brace
r_char
op_star
id|s
op_assign
id|options
suffix:semicolon
op_star
id|baud
op_assign
id|simple_strtoul
c_func
(paren
id|s
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|s
op_ge
l_char|&squot;0&squot;
op_logical_and
op_star
id|s
op_le
l_char|&squot;9&squot;
)paren
id|s
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
)paren
op_star
id|parity
op_assign
op_star
id|s
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
)paren
op_star
id|bits
op_assign
op_star
id|s
op_increment
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
)paren
op_star
id|flow
op_assign
op_star
id|s
suffix:semicolon
)brace
DECL|struct|baud_rates
r_struct
id|baud_rates
(brace
DECL|member|rate
r_int
r_int
id|rate
suffix:semicolon
DECL|member|cflag
r_int
r_int
id|cflag
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|baud_rates
r_static
r_struct
id|baud_rates
id|baud_rates
(braket
)braket
op_assign
(brace
(brace
l_int|921600
comma
id|B921600
)brace
comma
(brace
l_int|460800
comma
id|B460800
)brace
comma
(brace
l_int|230400
comma
id|B230400
)brace
comma
(brace
l_int|115200
comma
id|B115200
)brace
comma
(brace
l_int|57600
comma
id|B57600
)brace
comma
(brace
l_int|38400
comma
id|B38400
)brace
comma
(brace
l_int|19200
comma
id|B19200
)brace
comma
(brace
l_int|9600
comma
id|B9600
)brace
comma
(brace
l_int|4800
comma
id|B4800
)brace
comma
(brace
l_int|2400
comma
id|B2400
)brace
comma
(brace
l_int|1200
comma
id|B1200
)brace
comma
(brace
l_int|0
comma
id|B38400
)brace
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;uart_set_options - setup the serial console parameters&n; *&t;@port: pointer to the serial ports uart_port structure&n; *&t;@co: console pointer&n; *&t;@baud: baud rate&n; *&t;@parity: parity character - &squot;n&squot; (none), &squot;o&squot; (odd), &squot;e&squot; (even)&n; *&t;@bits: number of data bits&n; *&t;@flow: flow control character - &squot;r&squot; (rts)&n; */
r_int
id|__init
DECL|function|uart_set_options
id|uart_set_options
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|console
op_star
id|co
comma
r_int
id|baud
comma
r_int
id|parity
comma
r_int
id|bits
comma
r_int
id|flow
)paren
(brace
r_struct
id|termios
id|termios
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|termios
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
id|termios.c_cflag
op_assign
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
multiline_comment|/*&n;&t; * Construct a cflag setting.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|baud_rates
(braket
id|i
)braket
dot
id|rate
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|baud_rates
(braket
id|i
)braket
dot
id|rate
op_le
id|baud
)paren
r_break
suffix:semicolon
id|termios.c_cflag
op_or_assign
id|baud_rates
(braket
id|i
)braket
dot
id|cflag
suffix:semicolon
r_if
c_cond
(paren
id|bits
op_eq
l_int|7
)paren
id|termios.c_cflag
op_or_assign
id|CS7
suffix:semicolon
r_else
id|termios.c_cflag
op_or_assign
id|CS8
suffix:semicolon
r_switch
c_cond
(paren
id|parity
)paren
(brace
r_case
l_char|&squot;o&squot;
suffix:colon
r_case
l_char|&squot;O&squot;
suffix:colon
id|termios.c_cflag
op_or_assign
id|PARODD
suffix:semicolon
multiline_comment|/*fall through*/
r_case
l_char|&squot;e&squot;
suffix:colon
r_case
l_char|&squot;E&squot;
suffix:colon
id|termios.c_cflag
op_or_assign
id|PARENB
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flow
op_eq
l_char|&squot;r&squot;
)paren
id|termios.c_cflag
op_or_assign
id|CRTSCTS
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|set_termios
c_func
(paren
id|port
comma
op_amp
id|termios
comma
l_int|NULL
)paren
suffix:semicolon
id|co-&gt;cflag
op_assign
id|termios.c_cflag
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SERIAL_CORE_CONSOLE */
DECL|function|uart_change_pm
r_static
r_void
id|uart_change_pm
c_func
(paren
r_struct
id|uart_state
op_star
id|state
comma
r_int
id|pm_state
)paren
(brace
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;ops-&gt;pm
)paren
id|port-&gt;ops
op_member_access_from_pointer
id|pm
c_func
(paren
id|port
comma
id|pm_state
comma
id|state-&gt;pm_state
)paren
suffix:semicolon
id|state-&gt;pm_state
op_assign
id|pm_state
suffix:semicolon
)brace
DECL|function|uart_suspend_port
r_int
id|uart_suspend_port
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
comma
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|drv-&gt;state
op_plus
id|port-&gt;line
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;info
op_logical_and
id|state-&gt;info-&gt;flags
op_amp
id|UIF_INITIALIZED
)paren
(brace
r_struct
id|uart_ops
op_star
id|ops
op_assign
id|port-&gt;ops
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
id|ops
op_member_access_from_pointer
id|stop_tx
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
id|ops
op_member_access_from_pointer
id|set_mctrl
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
id|ops
op_member_access_from_pointer
id|stop_rx
c_func
(paren
id|port
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait for the transmitter to empty.&n;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
id|ops
op_member_access_from_pointer
id|tx_empty
c_func
(paren
id|port
)paren
)paren
(brace
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
id|ops
op_member_access_from_pointer
id|shutdown
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Disable the console device before suspending.&n;&t; */
r_if
c_cond
(paren
id|uart_console
c_func
(paren
id|port
)paren
)paren
id|console_stop
c_func
(paren
id|port-&gt;cons
)paren
suffix:semicolon
id|uart_change_pm
c_func
(paren
id|state
comma
l_int|3
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|uart_resume_port
r_int
id|uart_resume_port
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
comma
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|drv-&gt;state
op_plus
id|port-&gt;line
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
id|uart_change_pm
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Re-enable the console device after suspending.&n;&t; */
r_if
c_cond
(paren
id|uart_console
c_func
(paren
id|port
)paren
)paren
(brace
id|uart_change_speed
c_func
(paren
id|state
comma
l_int|NULL
)paren
suffix:semicolon
id|console_start
c_func
(paren
id|port-&gt;cons
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|state-&gt;info
op_logical_and
id|state-&gt;info-&gt;flags
op_amp
id|UIF_INITIALIZED
)paren
(brace
r_struct
id|uart_ops
op_star
id|ops
op_assign
id|port-&gt;ops
suffix:semicolon
id|ops
op_member_access_from_pointer
id|set_mctrl
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
id|ops
op_member_access_from_pointer
id|startup
c_func
(paren
id|port
)paren
suffix:semicolon
id|uart_change_speed
c_func
(paren
id|state
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
id|ops
op_member_access_from_pointer
id|set_mctrl
c_func
(paren
id|port
comma
id|port-&gt;mctrl
)paren
suffix:semicolon
id|ops
op_member_access_from_pointer
id|start_tx
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|uart_report_port
id|uart_report_port
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
comma
r_struct
id|uart_port
op_star
id|port
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s%d&quot;
comma
id|drv-&gt;dev_name
comma
id|port-&gt;line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; at &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|port-&gt;iotype
)paren
(brace
r_case
id|UPIO_PORT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;I/O 0x%x&quot;
comma
id|port-&gt;iobase
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UPIO_HUB6
suffix:colon
id|printk
c_func
(paren
l_string|&quot;I/O 0x%x offset 0x%x&quot;
comma
id|port-&gt;iobase
comma
id|port-&gt;hub6
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UPIO_MEM
suffix:colon
r_case
id|UPIO_MEM32
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MMIO 0x%lx&quot;
comma
id|port-&gt;mapbase
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; (irq = %d) is a %s&bslash;n&quot;
comma
id|port-&gt;irq
comma
id|uart_type
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|uart_configure_port
id|uart_configure_port
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
comma
r_struct
id|uart_state
op_star
id|state
comma
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * If there isn&squot;t a port here, don&squot;t do anything further.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;iobase
op_logical_and
op_logical_neg
id|port-&gt;mapbase
op_logical_and
op_logical_neg
id|port-&gt;membase
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Now do the auto configuration stuff.  Note that config_port&n;&t; * is expected to claim the resources and map the port for us.&n;&t; */
id|flags
op_assign
id|UART_CONFIG_TYPE
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|UPF_AUTO_IRQ
)paren
id|flags
op_or_assign
id|UART_CONFIG_IRQ
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|UPF_BOOT_AUTOCONF
)paren
(brace
id|port-&gt;type
op_assign
id|PORT_UNKNOWN
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|config_port
c_func
(paren
id|port
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;type
op_ne
id|PORT_UNKNOWN
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|uart_report_port
c_func
(paren
id|drv
comma
id|port
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ensure that the modem control lines are de-activated.&n;&t;&t; * We probably don&squot;t need a spinlock around this, but&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|port-&gt;ops
op_member_access_from_pointer
id|set_mctrl
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Power down all ports by default, except the&n;&t;&t; * console if we have one.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uart_console
c_func
(paren
id|port
)paren
)paren
id|uart_change_pm
c_func
(paren
id|state
comma
l_int|3
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This reverses the effects of uart_configure_port, hanging up the&n; * port before removal.&n; */
r_static
r_void
DECL|function|uart_unconfigure_port
id|uart_unconfigure_port
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
comma
r_struct
id|uart_state
op_star
id|state
)paren
(brace
r_struct
id|uart_port
op_star
id|port
op_assign
id|state-&gt;port
suffix:semicolon
r_struct
id|uart_info
op_star
id|info
op_assign
id|state-&gt;info
suffix:semicolon
r_if
c_cond
(paren
id|info
op_logical_and
id|info-&gt;tty
)paren
id|tty_vhangup
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
id|state-&gt;info
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Free the port IO and memory resources, if any.&n;&t; */
r_if
c_cond
(paren
id|port-&gt;type
op_ne
id|PORT_UNKNOWN
)paren
id|port-&gt;ops
op_member_access_from_pointer
id|release_port
c_func
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Indicate that there isn&squot;t a port here anymore.&n;&t; */
id|port-&gt;type
op_assign
id|PORT_UNKNOWN
suffix:semicolon
multiline_comment|/*&n;&t; * Kill the tasklet, and free resources.&n;&t; */
r_if
c_cond
(paren
id|info
)paren
(brace
id|tasklet_kill
c_func
(paren
op_amp
id|info-&gt;tlet
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
)brace
DECL|variable|uart_ops
r_static
r_struct
id|tty_operations
id|uart_ops
op_assign
(brace
dot
id|open
op_assign
id|uart_open
comma
dot
id|close
op_assign
id|uart_close
comma
dot
id|write
op_assign
id|uart_write
comma
dot
id|put_char
op_assign
id|uart_put_char
comma
dot
id|flush_chars
op_assign
id|uart_flush_chars
comma
dot
id|write_room
op_assign
id|uart_write_room
comma
dot
id|chars_in_buffer
op_assign
id|uart_chars_in_buffer
comma
dot
id|flush_buffer
op_assign
id|uart_flush_buffer
comma
dot
id|ioctl
op_assign
id|uart_ioctl
comma
dot
id|throttle
op_assign
id|uart_throttle
comma
dot
id|unthrottle
op_assign
id|uart_unthrottle
comma
dot
id|send_xchar
op_assign
id|uart_send_xchar
comma
dot
id|set_termios
op_assign
id|uart_set_termios
comma
dot
id|stop
op_assign
id|uart_stop
comma
dot
id|start
op_assign
id|uart_start
comma
dot
id|hangup
op_assign
id|uart_hangup
comma
dot
id|break_ctl
op_assign
id|uart_break_ctl
comma
dot
id|wait_until_sent
op_assign
id|uart_wait_until_sent
comma
macro_line|#ifdef CONFIG_PROC_FS
dot
id|read_proc
op_assign
id|uart_read_proc
comma
macro_line|#endif
dot
id|tiocmget
op_assign
id|uart_tiocmget
comma
dot
id|tiocmset
op_assign
id|uart_tiocmset
comma
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;uart_register_driver - register a driver with the uart core layer&n; *&t;@drv: low level driver structure&n; *&n; *&t;Register a uart driver with the core driver.  We in turn register&n; *&t;with the tty layer, and initialise the core driver per-port state.&n; *&n; *&t;We have a proc file in /proc/tty/driver which is named after the&n; *&t;normal driver.&n; *&n; *&t;drv-&gt;port should be NULL, and the per-port structures should be&n; *&t;registered using uart_add_one_port after this call has succeeded.&n; */
DECL|function|uart_register_driver
r_int
id|uart_register_driver
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
)paren
(brace
r_struct
id|tty_driver
op_star
id|normal
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|retval
suffix:semicolon
id|BUG_ON
c_func
(paren
id|drv-&gt;state
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Maybe we should be using a slab cache for this, especially if&n;&t; * we have a large number of ports to handle.&n;&t; */
id|drv-&gt;state
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|uart_state
)paren
op_star
id|drv-&gt;nr
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;state
)paren
r_goto
id|out
suffix:semicolon
id|memset
c_func
(paren
id|drv-&gt;state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|uart_state
)paren
op_star
id|drv-&gt;nr
)paren
suffix:semicolon
id|normal
op_assign
id|alloc_tty_driver
c_func
(paren
id|drv-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|normal
)paren
r_goto
id|out
suffix:semicolon
id|drv-&gt;tty_driver
op_assign
id|normal
suffix:semicolon
id|normal-&gt;owner
op_assign
id|drv-&gt;owner
suffix:semicolon
id|normal-&gt;driver_name
op_assign
id|drv-&gt;driver_name
suffix:semicolon
id|normal-&gt;devfs_name
op_assign
id|drv-&gt;devfs_name
suffix:semicolon
id|normal-&gt;name
op_assign
id|drv-&gt;dev_name
suffix:semicolon
id|normal-&gt;major
op_assign
id|drv-&gt;major
suffix:semicolon
id|normal-&gt;minor_start
op_assign
id|drv-&gt;minor
suffix:semicolon
id|normal-&gt;type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|normal-&gt;subtype
op_assign
id|SERIAL_TYPE_NORMAL
suffix:semicolon
id|normal-&gt;init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|normal-&gt;init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
id|normal-&gt;flags
op_assign
id|TTY_DRIVER_REAL_RAW
op_or
id|TTY_DRIVER_NO_DEVFS
suffix:semicolon
id|normal-&gt;driver_state
op_assign
id|drv
suffix:semicolon
id|tty_set_operations
c_func
(paren
id|normal
comma
op_amp
id|uart_ops
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialise the UART state(s).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|drv-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|drv-&gt;state
op_plus
id|i
suffix:semicolon
id|state-&gt;close_delay
op_assign
l_int|500
suffix:semicolon
multiline_comment|/* .5 seconds */
id|state-&gt;closing_wait
op_assign
l_int|30000
suffix:semicolon
multiline_comment|/* 30 seconds */
id|init_MUTEX
c_func
(paren
op_amp
id|state-&gt;sem
)paren
suffix:semicolon
)brace
id|retval
op_assign
id|tty_register_driver
c_func
(paren
id|normal
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|put_tty_driver
c_func
(paren
id|normal
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|drv-&gt;state
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;uart_unregister_driver - remove a driver from the uart core layer&n; *&t;@drv: low level driver structure&n; *&n; *&t;Remove all references to a driver from the core driver.  The low&n; *&t;level driver must have removed all its ports via the&n; *&t;uart_remove_one_port() if it registered them with uart_add_one_port().&n; *&t;(ie, drv-&gt;port == NULL)&n; */
DECL|function|uart_unregister_driver
r_void
id|uart_unregister_driver
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
)paren
(brace
r_struct
id|tty_driver
op_star
id|p
op_assign
id|drv-&gt;tty_driver
suffix:semicolon
id|tty_unregister_driver
c_func
(paren
id|p
)paren
suffix:semicolon
id|put_tty_driver
c_func
(paren
id|p
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|drv-&gt;state
)paren
suffix:semicolon
id|drv-&gt;tty_driver
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|uart_console_device
r_struct
id|tty_driver
op_star
id|uart_console_device
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_int
op_star
id|index
)paren
(brace
r_struct
id|uart_driver
op_star
id|p
op_assign
id|co-&gt;data
suffix:semicolon
op_star
id|index
op_assign
id|co-&gt;index
suffix:semicolon
r_return
id|p-&gt;tty_driver
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;uart_add_one_port - attach a driver-defined port structure&n; *&t;@drv: pointer to the uart low level driver structure for this port&n; *&t;@port: uart port structure to use for this port.&n; *&n; *&t;This allows the driver to register its own uart_port structure&n; *&t;with the core driver.  The main purpose is to allow the low&n; *&t;level uart drivers to expand uart_port, rather than having yet&n; *&t;more levels of structures.&n; */
DECL|function|uart_add_one_port
r_int
id|uart_add_one_port
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
comma
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_state
op_star
id|state
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;line
op_ge
id|drv-&gt;nr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|state
op_assign
id|drv-&gt;state
op_plus
id|port-&gt;line
suffix:semicolon
id|down
c_func
(paren
op_amp
id|port_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;port
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|state-&gt;port
op_assign
id|port
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
id|port-&gt;cons
op_assign
id|drv-&gt;cons
suffix:semicolon
id|port-&gt;info
op_assign
id|state-&gt;info
suffix:semicolon
id|uart_configure_port
c_func
(paren
id|drv
comma
id|state
comma
id|port
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Register the port whether it&squot;s detected or not.  This allows&n;&t; * setserial to be used to alter this ports parameters.&n;&t; */
id|tty_register_device
c_func
(paren
id|drv-&gt;tty_driver
comma
id|port-&gt;line
comma
id|port-&gt;dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this driver supports console, and it hasn&squot;t been&n;&t; * successfully registered yet, try to re-register it.&n;&t; * It may be that the port was not available.&n;&t; */
r_if
c_cond
(paren
id|port-&gt;type
op_ne
id|PORT_UNKNOWN
op_logical_and
id|port-&gt;cons
op_logical_and
op_logical_neg
(paren
id|port-&gt;cons-&gt;flags
op_amp
id|CON_ENABLED
)paren
)paren
id|register_console
c_func
(paren
id|port-&gt;cons
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|port_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;uart_remove_one_port - detach a driver defined port structure&n; *&t;@drv: pointer to the uart low level driver structure for this port&n; *&t;@port: uart port structure for this port&n; *&n; *&t;This unhooks (and hangs up) the specified port structure from the&n; *&t;core driver.  No further calls will be made to the low-level code&n; *&t;for this port.&n; */
DECL|function|uart_remove_one_port
r_int
id|uart_remove_one_port
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
comma
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_state
op_star
id|state
op_assign
id|drv-&gt;state
op_plus
id|port-&gt;line
suffix:semicolon
id|BUG_ON
c_func
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;port
op_ne
id|port
)paren
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;Removing wrong port: %p != %p&bslash;n&quot;
comma
id|state-&gt;port
comma
id|port
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|port_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove the devices from devfs&n;&t; */
id|tty_unregister_device
c_func
(paren
id|drv-&gt;tty_driver
comma
id|port-&gt;line
)paren
suffix:semicolon
id|uart_unconfigure_port
c_func
(paren
id|drv
comma
id|state
)paren
suffix:semicolon
id|state-&gt;port
op_assign
l_int|NULL
suffix:semicolon
id|up
c_func
(paren
op_amp
id|port_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Are the two ports equivalent?&n; */
DECL|function|uart_match_port
r_static
r_int
id|uart_match_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port1
comma
r_struct
id|uart_port
op_star
id|port2
)paren
(brace
r_if
c_cond
(paren
id|port1-&gt;iotype
op_ne
id|port2-&gt;iotype
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|port1-&gt;iotype
)paren
(brace
r_case
id|UPIO_PORT
suffix:colon
r_return
(paren
id|port1-&gt;iobase
op_eq
id|port2-&gt;iobase
)paren
suffix:semicolon
r_case
id|UPIO_HUB6
suffix:colon
r_return
(paren
id|port1-&gt;iobase
op_eq
id|port2-&gt;iobase
)paren
op_logical_and
(paren
id|port1-&gt;hub6
op_eq
id|port2-&gt;hub6
)paren
suffix:semicolon
r_case
id|UPIO_MEM
suffix:colon
r_return
(paren
id|port1-&gt;membase
op_eq
id|port2-&gt;membase
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Try to find an unused uart_state slot for a port.&n; */
r_static
r_struct
id|uart_state
op_star
DECL|function|uart_find_match_or_unused
id|uart_find_match_or_unused
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
comma
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * First, find a port entry which matches.  Note: if we do&n;&t; * find a matching entry, and it has a non-zero use count,&n;&t; * then we can&squot;t register the port.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|drv-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|uart_match_port
c_func
(paren
id|drv-&gt;state
(braket
id|i
)braket
dot
id|port
comma
id|port
)paren
)paren
r_return
op_amp
id|drv-&gt;state
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * We didn&squot;t find a matching entry, so look for the first&n;&t; * free entry.  We look for one which hasn&squot;t been previously&n;&t; * used (indicated by zero iobase).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|drv-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|drv-&gt;state
(braket
id|i
)braket
dot
id|port-&gt;type
op_eq
id|PORT_UNKNOWN
op_logical_and
id|drv-&gt;state
(braket
id|i
)braket
dot
id|port-&gt;iobase
op_eq
l_int|0
op_logical_and
id|drv-&gt;state
(braket
id|i
)braket
dot
id|count
op_eq
l_int|0
)paren
r_return
op_amp
id|drv-&gt;state
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * That also failed.  Last resort is to find any currently&n;&t; * entry which doesn&squot;t have a real port associated with it.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|drv-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|drv-&gt;state
(braket
id|i
)braket
dot
id|port-&gt;type
op_eq
id|PORT_UNKNOWN
op_logical_and
id|drv-&gt;state
(braket
id|i
)braket
dot
id|count
op_eq
l_int|0
)paren
r_return
op_amp
id|drv-&gt;state
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;uart_register_port: register uart settings with a port&n; *&t;@drv: pointer to the uart low level driver structure for this port&n; *&t;@port: uart port structure describing the port&n; *&n; *&t;Register UART settings with the specified low level driver.  Detect&n; *&t;the type of the port if UPF_BOOT_AUTOCONF is set, and detect the&n; *&t;IRQ if UPF_AUTO_IRQ is set.&n; *&n; *&t;We try to pick the same port for the same IO base address, so that&n; *&t;when a modem is plugged in, unplugged and plugged back in, it gets&n; *&t;allocated the same port.&n; *&n; *&t;Returns negative error, or positive line number.&n; */
DECL|function|uart_register_port
r_int
id|uart_register_port
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
comma
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_state
op_star
id|state
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|down
c_func
(paren
op_amp
id|port_sem
)paren
suffix:semicolon
id|state
op_assign
id|uart_find_match_or_unused
c_func
(paren
id|drv
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ok, we&squot;ve found a line that we can use.&n;&t;&t; *&n;&t;&t; * If we find a port that matches this one, and it appears&n;&t;&t; * to be in-use (even if it doesn&squot;t have a type) we shouldn&squot;t&n;&t;&t; * alter it underneath itself - the port may be open and&n;&t;&t; * trying to do useful work.&n;&t;&t; */
r_if
c_cond
(paren
id|uart_users
c_func
(paren
id|state
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the port is already initialised, don&squot;t touch it.&n;&t;&t; */
r_if
c_cond
(paren
id|state-&gt;port-&gt;type
op_eq
id|PORT_UNKNOWN
)paren
(brace
id|state-&gt;port-&gt;iobase
op_assign
id|port-&gt;iobase
suffix:semicolon
id|state-&gt;port-&gt;membase
op_assign
id|port-&gt;membase
suffix:semicolon
id|state-&gt;port-&gt;irq
op_assign
id|port-&gt;irq
suffix:semicolon
id|state-&gt;port-&gt;uartclk
op_assign
id|port-&gt;uartclk
suffix:semicolon
id|state-&gt;port-&gt;fifosize
op_assign
id|port-&gt;fifosize
suffix:semicolon
id|state-&gt;port-&gt;regshift
op_assign
id|port-&gt;regshift
suffix:semicolon
id|state-&gt;port-&gt;iotype
op_assign
id|port-&gt;iotype
suffix:semicolon
id|state-&gt;port-&gt;flags
op_assign
id|port-&gt;flags
suffix:semicolon
id|state-&gt;port-&gt;line
op_assign
id|state
op_minus
id|drv-&gt;state
suffix:semicolon
id|state-&gt;port-&gt;mapbase
op_assign
id|port-&gt;mapbase
suffix:semicolon
id|uart_configure_port
c_func
(paren
id|drv
comma
id|state
comma
id|state-&gt;port
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|state-&gt;port-&gt;line
suffix:semicolon
)brace
r_else
id|ret
op_assign
op_minus
id|ENOSPC
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|port_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;uart_unregister_port - de-allocate a port&n; *&t;@drv: pointer to the uart low level driver structure for this port&n; *&t;@line: line index previously returned from uart_register_port()&n; *&n; *&t;Hang up the specified line associated with the low level driver,&n; *&t;and mark the port as unused.&n; */
DECL|function|uart_unregister_port
r_void
id|uart_unregister_port
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
comma
r_int
id|line
)paren
(brace
r_struct
id|uart_state
op_star
id|state
suffix:semicolon
r_if
c_cond
(paren
id|line
OL
l_int|0
op_logical_or
id|line
op_ge
id|drv-&gt;nr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Attempt to unregister &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s%d&quot;
comma
id|drv-&gt;dev_name
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|state
op_assign
id|drv-&gt;state
op_plus
id|line
suffix:semicolon
id|down
c_func
(paren
op_amp
id|port_sem
)paren
suffix:semicolon
id|uart_unconfigure_port
c_func
(paren
id|drv
comma
id|state
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|port_sem
)paren
suffix:semicolon
)brace
DECL|variable|uart_write_wakeup
id|EXPORT_SYMBOL
c_func
(paren
id|uart_write_wakeup
)paren
suffix:semicolon
DECL|variable|uart_register_driver
id|EXPORT_SYMBOL
c_func
(paren
id|uart_register_driver
)paren
suffix:semicolon
DECL|variable|uart_unregister_driver
id|EXPORT_SYMBOL
c_func
(paren
id|uart_unregister_driver
)paren
suffix:semicolon
DECL|variable|uart_suspend_port
id|EXPORT_SYMBOL
c_func
(paren
id|uart_suspend_port
)paren
suffix:semicolon
DECL|variable|uart_resume_port
id|EXPORT_SYMBOL
c_func
(paren
id|uart_resume_port
)paren
suffix:semicolon
DECL|variable|uart_register_port
id|EXPORT_SYMBOL
c_func
(paren
id|uart_register_port
)paren
suffix:semicolon
DECL|variable|uart_unregister_port
id|EXPORT_SYMBOL
c_func
(paren
id|uart_unregister_port
)paren
suffix:semicolon
DECL|variable|uart_add_one_port
id|EXPORT_SYMBOL
c_func
(paren
id|uart_add_one_port
)paren
suffix:semicolon
DECL|variable|uart_remove_one_port
id|EXPORT_SYMBOL
c_func
(paren
id|uart_remove_one_port
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Serial driver core&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
