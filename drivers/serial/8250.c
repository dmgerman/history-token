multiline_comment|/*&n; *  linux/drivers/char/8250.c&n; *&n; *  Driver for 8250/16550-type serial ports&n; *&n; *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts&squot;o.&n; *&n; *  Copyright (C) 2001 Russell King.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; *  $Id: 8250.c,v 1.90 2002/07/28 10:03:27 rmk Exp $&n; *&n; * A note about mapbase / membase&n; *&n; *  mapbase is the physical address of the IO port.&n; *  membase is an &squot;ioremapped&squot; cookie.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/sysrq.h&gt;
macro_line|#include &lt;linux/serial_reg.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/serialP.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#if defined(CONFIG_SERIAL_8250_CONSOLE) &amp;&amp; defined(CONFIG_MAGIC_SYSRQ)
DECL|macro|SUPPORT_SYSRQ
mdefine_line|#define SUPPORT_SYSRQ
macro_line|#endif
macro_line|#include &lt;linux/serial_core.h&gt;
macro_line|#include &quot;8250.h&quot;
multiline_comment|/*&n; * Configuration:&n; *   share_irqs - whether we pass SA_SHIRQ to request_irq().  This option&n; *                is unsafe when used on edge-triggered interrupts.&n; */
DECL|variable|share_irqs
r_int
r_int
id|share_irqs
op_assign
id|SERIAL8250_SHARE_IRQS
suffix:semicolon
multiline_comment|/*&n; * Debugging.&n; */
macro_line|#if 0
mdefine_line|#define DEBUG_AUTOCONF(fmt...)&t;printk(fmt)
macro_line|#else
DECL|macro|DEBUG_AUTOCONF
mdefine_line|#define DEBUG_AUTOCONF(fmt...)&t;do { } while (0)
macro_line|#endif
macro_line|#if 0
mdefine_line|#define DEBUG_INTR(fmt...)&t;printk(fmt)
macro_line|#else
DECL|macro|DEBUG_INTR
mdefine_line|#define DEBUG_INTR(fmt...)&t;do { } while (0)
macro_line|#endif
DECL|macro|PASS_LIMIT
mdefine_line|#define PASS_LIMIT&t;256
multiline_comment|/*&n; * We default to IRQ0 for the &quot;no irq&quot; hack.   Some&n; * machine types want others as well - they&squot;re free&n; * to redefine this in their header file.&n; */
DECL|macro|is_real_interrupt
mdefine_line|#define is_real_interrupt(irq)&t;((irq) != 0)
multiline_comment|/*&n; * This converts from our new CONFIG_ symbols to the symbols&n; * that asm/serial.h expects.  You _NEED_ to comment out the&n; * linux/config.h include contained inside asm/serial.h for&n; * this to work.&n; */
DECL|macro|CONFIG_SERIAL_MANY_PORTS
macro_line|#undef CONFIG_SERIAL_MANY_PORTS
DECL|macro|CONFIG_SERIAL_DETECT_IRQ
macro_line|#undef CONFIG_SERIAL_DETECT_IRQ
DECL|macro|CONFIG_SERIAL_MULTIPORT
macro_line|#undef CONFIG_SERIAL_MULTIPORT
DECL|macro|CONFIG_HUB6
macro_line|#undef CONFIG_HUB6
macro_line|#ifdef CONFIG_SERIAL_8250_DETECT_IRQ
DECL|macro|CONFIG_SERIAL_DETECT_IRQ
mdefine_line|#define CONFIG_SERIAL_DETECT_IRQ 1
macro_line|#endif
macro_line|#ifdef CONFIG_SERIAL_8250_MULTIPORT
DECL|macro|CONFIG_SERIAL_MULTIPORT
mdefine_line|#define CONFIG_SERIAL_MULTIPORT 1
macro_line|#endif
macro_line|#ifdef CONFIG_SERIAL_8250_MANY_PORTS
DECL|macro|CONFIG_SERIAL_MANY_PORTS
mdefine_line|#define CONFIG_SERIAL_MANY_PORTS 1
macro_line|#endif
multiline_comment|/*&n; * HUB6 is always on.  This will be removed once the header&n; * files have been cleaned.&n; */
DECL|macro|CONFIG_HUB6
mdefine_line|#define CONFIG_HUB6 1
macro_line|#include &lt;asm/serial.h&gt;
multiline_comment|/*&n; * SERIAL_PORT_DFNS tells us about built-in ports that have no&n; * standard enumeration mechanism.   Platforms that can find all&n; * serial ports via mechanisms like ACPI or PCI need not supply it.&n; */
macro_line|#ifndef SERIAL_PORT_DFNS
DECL|macro|SERIAL_PORT_DFNS
mdefine_line|#define SERIAL_PORT_DFNS
macro_line|#endif
DECL|variable|old_serial_port
r_static
r_struct
id|old_serial_port
id|old_serial_port
(braket
)braket
op_assign
(brace
id|SERIAL_PORT_DFNS
multiline_comment|/* defined in asm/serial.h */
)brace
suffix:semicolon
DECL|macro|UART_NR
mdefine_line|#define UART_NR&t;(ARRAY_SIZE(old_serial_port) + CONFIG_SERIAL_8250_NR_UARTS)
macro_line|#ifdef CONFIG_SERIAL_8250_RSA
DECL|macro|PORT_RSA_MAX
mdefine_line|#define PORT_RSA_MAX 4
DECL|variable|probe_rsa
r_static
r_int
r_int
id|probe_rsa
(braket
id|PORT_RSA_MAX
)braket
suffix:semicolon
DECL|variable|probe_rsa_count
r_static
r_int
r_int
id|probe_rsa_count
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_8250_RSA  */
DECL|struct|uart_8250_port
r_struct
id|uart_8250_port
(brace
DECL|member|port
r_struct
id|uart_port
id|port
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* &quot;no irq&quot; timer */
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
multiline_comment|/* ports on this IRQ */
DECL|member|capabilities
r_int
r_int
id|capabilities
suffix:semicolon
multiline_comment|/* port capabilities */
DECL|member|tx_loadsz
r_int
r_int
id|tx_loadsz
suffix:semicolon
multiline_comment|/* transmit fifo load size */
DECL|member|rev
r_int
r_int
id|rev
suffix:semicolon
DECL|member|acr
r_int
r_char
id|acr
suffix:semicolon
DECL|member|ier
r_int
r_char
id|ier
suffix:semicolon
DECL|member|lcr
r_int
r_char
id|lcr
suffix:semicolon
DECL|member|mcr
r_int
r_char
id|mcr
suffix:semicolon
DECL|member|mcr_mask
r_int
r_char
id|mcr_mask
suffix:semicolon
multiline_comment|/* mask of user bits */
DECL|member|mcr_force
r_int
r_char
id|mcr_force
suffix:semicolon
multiline_comment|/* mask of forced bits */
DECL|member|lsr_break_flag
r_int
r_char
id|lsr_break_flag
suffix:semicolon
multiline_comment|/*&n;&t; * We provide a per-port pm hook.&n;&t; */
DECL|member|pm
r_void
(paren
op_star
id|pm
)paren
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|state
comma
r_int
r_int
id|old
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|irq_info
r_struct
id|irq_info
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|head
r_struct
id|list_head
op_star
id|head
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|irq_lists
r_static
r_struct
id|irq_info
id|irq_lists
(braket
id|NR_IRQS
)braket
suffix:semicolon
multiline_comment|/*&n; * Here we define the default xmit fifo size used for each type of UART.&n; */
DECL|variable|uart_config
r_static
r_const
r_struct
id|serial8250_config
id|uart_config
(braket
)braket
op_assign
(brace
(braket
id|PORT_UNKNOWN
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;unknown&quot;
comma
dot
id|fifo_size
op_assign
l_int|1
comma
dot
id|tx_loadsz
op_assign
l_int|1
comma
)brace
comma
(braket
id|PORT_8250
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;8250&quot;
comma
dot
id|fifo_size
op_assign
l_int|1
comma
dot
id|tx_loadsz
op_assign
l_int|1
comma
)brace
comma
(braket
id|PORT_16450
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;16450&quot;
comma
dot
id|fifo_size
op_assign
l_int|1
comma
dot
id|tx_loadsz
op_assign
l_int|1
comma
)brace
comma
(braket
id|PORT_16550
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;16550&quot;
comma
dot
id|fifo_size
op_assign
l_int|1
comma
dot
id|tx_loadsz
op_assign
l_int|1
comma
)brace
comma
(braket
id|PORT_16550A
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;16550A&quot;
comma
dot
id|fifo_size
op_assign
l_int|16
comma
dot
id|tx_loadsz
op_assign
l_int|16
comma
dot
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_R_TRIG_10
comma
dot
id|flags
op_assign
id|UART_CAP_FIFO
comma
)brace
comma
(braket
id|PORT_CIRRUS
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Cirrus&quot;
comma
dot
id|fifo_size
op_assign
l_int|1
comma
dot
id|tx_loadsz
op_assign
l_int|1
comma
)brace
comma
(braket
id|PORT_16650
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ST16650&quot;
comma
dot
id|fifo_size
op_assign
l_int|1
comma
dot
id|tx_loadsz
op_assign
l_int|1
comma
dot
id|flags
op_assign
id|UART_CAP_FIFO
op_or
id|UART_CAP_EFR
op_or
id|UART_CAP_SLEEP
comma
)brace
comma
(braket
id|PORT_16650V2
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ST16650V2&quot;
comma
dot
id|fifo_size
op_assign
l_int|32
comma
dot
id|tx_loadsz
op_assign
l_int|16
comma
dot
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_R_TRIG_01
op_or
id|UART_FCR_T_TRIG_00
comma
dot
id|flags
op_assign
id|UART_CAP_FIFO
op_or
id|UART_CAP_EFR
op_or
id|UART_CAP_SLEEP
comma
)brace
comma
(braket
id|PORT_16750
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;TI16750&quot;
comma
dot
id|fifo_size
op_assign
l_int|64
comma
dot
id|tx_loadsz
op_assign
l_int|64
comma
dot
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_R_TRIG_10
op_or
id|UART_FCR7_64BYTE
comma
dot
id|flags
op_assign
id|UART_CAP_FIFO
op_or
id|UART_CAP_SLEEP
op_or
id|UART_CAP_AFE
comma
)brace
comma
(braket
id|PORT_STARTECH
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Startech&quot;
comma
dot
id|fifo_size
op_assign
l_int|1
comma
dot
id|tx_loadsz
op_assign
l_int|1
comma
)brace
comma
(braket
id|PORT_16C950
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;16C950/954&quot;
comma
dot
id|fifo_size
op_assign
l_int|128
comma
dot
id|tx_loadsz
op_assign
l_int|128
comma
dot
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_R_TRIG_10
comma
dot
id|flags
op_assign
id|UART_CAP_FIFO
comma
)brace
comma
(braket
id|PORT_16654
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ST16654&quot;
comma
dot
id|fifo_size
op_assign
l_int|64
comma
dot
id|tx_loadsz
op_assign
l_int|32
comma
dot
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_R_TRIG_01
op_or
id|UART_FCR_T_TRIG_10
comma
dot
id|flags
op_assign
id|UART_CAP_FIFO
op_or
id|UART_CAP_EFR
op_or
id|UART_CAP_SLEEP
comma
)brace
comma
(braket
id|PORT_16850
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;XR16850&quot;
comma
dot
id|fifo_size
op_assign
l_int|128
comma
dot
id|tx_loadsz
op_assign
l_int|128
comma
dot
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_R_TRIG_10
comma
dot
id|flags
op_assign
id|UART_CAP_FIFO
op_or
id|UART_CAP_EFR
op_or
id|UART_CAP_SLEEP
comma
)brace
comma
(braket
id|PORT_RSA
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;RSA&quot;
comma
dot
id|fifo_size
op_assign
l_int|2048
comma
dot
id|tx_loadsz
op_assign
l_int|2048
comma
dot
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_R_TRIG_11
comma
dot
id|flags
op_assign
id|UART_CAP_FIFO
comma
)brace
comma
(braket
id|PORT_NS16550A
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;NS16550A&quot;
comma
dot
id|fifo_size
op_assign
l_int|16
comma
dot
id|tx_loadsz
op_assign
l_int|16
comma
dot
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_R_TRIG_10
comma
dot
id|flags
op_assign
id|UART_CAP_FIFO
op_or
id|UART_NATSEMI
comma
)brace
comma
(braket
id|PORT_XSCALE
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;XScale&quot;
comma
dot
id|fifo_size
op_assign
l_int|32
comma
dot
id|tx_loadsz
op_assign
l_int|32
comma
dot
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_R_TRIG_10
comma
dot
id|flags
op_assign
id|UART_CAP_FIFO
comma
)brace
comma
)brace
suffix:semicolon
DECL|function|serial_in
r_static
id|_INLINE_
r_int
r_int
id|serial_in
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_int
id|offset
)paren
(brace
id|offset
op_lshift_assign
id|up-&gt;port.regshift
suffix:semicolon
r_switch
c_cond
(paren
id|up-&gt;port.iotype
)paren
(brace
r_case
id|UPIO_HUB6
suffix:colon
id|outb
c_func
(paren
id|up-&gt;port.hub6
op_minus
l_int|1
op_plus
id|offset
comma
id|up-&gt;port.iobase
)paren
suffix:semicolon
r_return
id|inb
c_func
(paren
id|up-&gt;port.iobase
op_plus
l_int|1
)paren
suffix:semicolon
r_case
id|UPIO_MEM
suffix:colon
r_return
id|readb
c_func
(paren
id|up-&gt;port.membase
op_plus
id|offset
)paren
suffix:semicolon
r_case
id|UPIO_MEM32
suffix:colon
r_return
id|readl
c_func
(paren
id|up-&gt;port.membase
op_plus
id|offset
)paren
suffix:semicolon
r_default
suffix:colon
r_return
id|inb
c_func
(paren
id|up-&gt;port.iobase
op_plus
id|offset
)paren
suffix:semicolon
)brace
)brace
r_static
id|_INLINE_
r_void
DECL|function|serial_out
id|serial_out
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_int
id|offset
comma
r_int
id|value
)paren
(brace
id|offset
op_lshift_assign
id|up-&gt;port.regshift
suffix:semicolon
r_switch
c_cond
(paren
id|up-&gt;port.iotype
)paren
(brace
r_case
id|UPIO_HUB6
suffix:colon
id|outb
c_func
(paren
id|up-&gt;port.hub6
op_minus
l_int|1
op_plus
id|offset
comma
id|up-&gt;port.iobase
)paren
suffix:semicolon
id|outb
c_func
(paren
id|value
comma
id|up-&gt;port.iobase
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UPIO_MEM
suffix:colon
id|writeb
c_func
(paren
id|value
comma
id|up-&gt;port.membase
op_plus
id|offset
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UPIO_MEM32
suffix:colon
id|writel
c_func
(paren
id|value
comma
id|up-&gt;port.membase
op_plus
id|offset
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|outb
c_func
(paren
id|value
comma
id|up-&gt;port.iobase
op_plus
id|offset
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * We used to support using pause I/O for certain machines.  We&n; * haven&squot;t supported this for a while, but just in case it&squot;s badly&n; * needed for certain old 386 machines, I&squot;ve left these #define&squot;s&n; * in....&n; */
DECL|macro|serial_inp
mdefine_line|#define serial_inp(up, offset)&t;&t;serial_in(up, offset)
DECL|macro|serial_outp
mdefine_line|#define serial_outp(up, offset, value)&t;serial_out(up, offset, value)
multiline_comment|/*&n; * For the 16C950&n; */
DECL|function|serial_icr_write
r_static
r_void
id|serial_icr_write
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_int
id|offset
comma
r_int
id|value
)paren
(brace
id|serial_out
c_func
(paren
id|up
comma
id|UART_SCR
comma
id|offset
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_ICR
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|serial_icr_read
r_static
r_int
r_int
id|serial_icr_read
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_int
id|offset
)paren
(brace
r_int
r_int
id|value
suffix:semicolon
id|serial_icr_write
c_func
(paren
id|up
comma
id|UART_ACR
comma
id|up-&gt;acr
op_or
id|UART_ACR_ICRRD
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_SCR
comma
id|offset
)paren
suffix:semicolon
id|value
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_ICR
)paren
suffix:semicolon
id|serial_icr_write
c_func
(paren
id|up
comma
id|UART_ACR
comma
id|up-&gt;acr
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
multiline_comment|/*&n; * FIFO support.&n; */
DECL|function|serial8250_clear_fifos
r_static
r_inline
r_void
id|serial8250_clear_fifos
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;capabilities
op_amp
id|UART_CAP_FIFO
)paren
(brace
id|serial_outp
c_func
(paren
id|p
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|p
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|p
comma
id|UART_FCR
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * IER sleep support.  UARTs which have EFRs need the &quot;extended&n; * capability&quot; bit enabled.  Note that on XR16C850s, we need to&n; * reset LCR to write to IER.&n; */
DECL|function|serial8250_set_sleep
r_static
r_inline
r_void
id|serial8250_set_sleep
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|p
comma
r_int
id|sleep
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;capabilities
op_amp
id|UART_CAP_SLEEP
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;capabilities
op_amp
id|UART_CAP_EFR
)paren
(brace
id|serial_outp
c_func
(paren
id|p
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|p
comma
id|UART_EFR
comma
id|UART_EFR_ECB
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|p
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
)brace
id|serial_outp
c_func
(paren
id|p
comma
id|UART_IER
comma
id|sleep
ques
c_cond
id|UART_IERX_SLEEP
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;capabilities
op_amp
id|UART_CAP_EFR
)paren
(brace
id|serial_outp
c_func
(paren
id|p
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|p
comma
id|UART_EFR
comma
l_int|0
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|p
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef CONFIG_SERIAL_8250_RSA
multiline_comment|/*&n; * Attempts to turn on the RSA FIFO.  Returns zero on failure.&n; * We set the port uart clock rate if we succeed.&n; */
DECL|function|__enable_rsa
r_static
r_int
id|__enable_rsa
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_int
r_char
id|mode
suffix:semicolon
r_int
id|result
suffix:semicolon
id|mode
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RSA_MSR
)paren
suffix:semicolon
id|result
op_assign
id|mode
op_amp
id|UART_RSA_MSR_FIFO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_RSA_MSR
comma
id|mode
op_or
id|UART_RSA_MSR_FIFO
)paren
suffix:semicolon
id|mode
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RSA_MSR
)paren
suffix:semicolon
id|result
op_assign
id|mode
op_amp
id|UART_RSA_MSR_FIFO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
id|up-&gt;port.uartclk
op_assign
id|SERIAL_RSA_BAUD_BASE
op_star
l_int|16
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|enable_rsa
r_static
r_void
id|enable_rsa
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_RSA
)paren
(brace
r_if
c_cond
(paren
id|up-&gt;port.uartclk
op_ne
id|SERIAL_RSA_BAUD_BASE
op_star
l_int|16
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
id|__enable_rsa
c_func
(paren
id|up
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up-&gt;port.uartclk
op_eq
id|SERIAL_RSA_BAUD_BASE
op_star
l_int|16
)paren
id|serial_outp
c_func
(paren
id|up
comma
id|UART_RSA_FRR
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Attempts to turn off the RSA FIFO.  Returns zero on failure.&n; * It is unknown why interrupts were disabled in here.  However,&n; * the caller is expected to preserve this behaviour by grabbing&n; * the spinlock before calling this function.&n; */
DECL|function|disable_rsa
r_static
r_void
id|disable_rsa
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_int
r_char
id|mode
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_RSA
op_logical_and
id|up-&gt;port.uartclk
op_eq
id|SERIAL_RSA_BAUD_BASE
op_star
l_int|16
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
id|mode
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RSA_MSR
)paren
suffix:semicolon
id|result
op_assign
op_logical_neg
(paren
id|mode
op_amp
id|UART_RSA_MSR_FIFO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_RSA_MSR
comma
id|mode
op_amp
op_complement
id|UART_RSA_MSR_FIFO
)paren
suffix:semicolon
id|mode
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RSA_MSR
)paren
suffix:semicolon
id|result
op_assign
op_logical_neg
(paren
id|mode
op_amp
id|UART_RSA_MSR_FIFO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
id|up-&gt;port.uartclk
op_assign
id|SERIAL_RSA_BAUD_BASE_LO
op_star
l_int|16
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_SERIAL_8250_RSA */
multiline_comment|/*&n; * This is a quickie test to see how big the FIFO is.&n; * It doesn&squot;t work at all the time, more&squot;s the pity.&n; */
DECL|function|size_fifo
r_static
r_int
id|size_fifo
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_int
r_char
id|old_fcr
comma
id|old_mcr
comma
id|old_dll
comma
id|old_dlm
suffix:semicolon
r_int
id|count
suffix:semicolon
id|old_fcr
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_FCR
)paren
suffix:semicolon
id|old_mcr
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_MCR
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|UART_MCR_LOOP
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|UART_LCR_DLAB
)paren
suffix:semicolon
id|old_dll
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_DLL
)paren
suffix:semicolon
id|old_dlm
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_DLM
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_DLL
comma
l_int|0x01
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_DLM
comma
l_int|0x00
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0x03
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|256
suffix:semicolon
id|count
op_increment
)paren
id|serial_outp
c_func
(paren
id|up
comma
id|UART_TX
comma
id|count
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
multiline_comment|/* FIXME - schedule_timeout */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
(paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
op_amp
id|UART_LSR_DR
)paren
op_logical_and
(paren
id|count
OL
l_int|256
)paren
suffix:semicolon
id|count
op_increment
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|old_fcr
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|old_mcr
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|UART_LCR_DLAB
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_DLL
comma
id|old_dll
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_DLM
comma
id|old_dlm
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a helper routine to autodetect StarTech/Exar/Oxsemi UART&squot;s.&n; * When this function is called we know it is at least a StarTech&n; * 16650 V2, but it might be one of several StarTech UARTs, or one of&n; * its clones.  (We treat the broken original StarTech 16650 V1 as a&n; * 16550, and why not?  Startech doesn&squot;t seem to even acknowledge its&n; * existence.)&n; * &n; * What evil have men&squot;s minds wrought...&n; */
DECL|function|autoconfig_has_efr
r_static
r_void
id|autoconfig_has_efr
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_int
r_char
id|id1
comma
id|id2
comma
id|id3
comma
id|rev
comma
id|saved_dll
comma
id|saved_dlm
suffix:semicolon
multiline_comment|/*&n;&t; * First we check to see if it&squot;s an Oxford Semiconductor UART.&n;&t; *&n;&t; * If we have to do this here because some non-National&n;&t; * Semiconductor clone chips lock up if you try writing to the&n;&t; * LSR register (which serial_icr_read does)&n;&t; */
multiline_comment|/*&n;&t; * Check for Oxford Semiconductor 16C950.&n;&t; *&n;&t; * EFR [4] must be set else this test fails.&n;&t; *&n;&t; * This shouldn&squot;t be necessary, but Mike Hudson (Exoray@isys.ca)&n;&t; * claims that it&squot;s needed for 952 dual UART&squot;s (which are not&n;&t; * recommended for new designs).&n;&t; */
id|up-&gt;acr
op_assign
l_int|0
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_EFR
comma
id|UART_EFR_ECB
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0x00
)paren
suffix:semicolon
id|id1
op_assign
id|serial_icr_read
c_func
(paren
id|up
comma
id|UART_ID1
)paren
suffix:semicolon
id|id2
op_assign
id|serial_icr_read
c_func
(paren
id|up
comma
id|UART_ID2
)paren
suffix:semicolon
id|id3
op_assign
id|serial_icr_read
c_func
(paren
id|up
comma
id|UART_ID3
)paren
suffix:semicolon
id|rev
op_assign
id|serial_icr_read
c_func
(paren
id|up
comma
id|UART_REV
)paren
suffix:semicolon
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;950id=%02x:%02x:%02x:%02x &quot;
comma
id|id1
comma
id|id2
comma
id|id3
comma
id|rev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id1
op_eq
l_int|0x16
op_logical_and
id|id2
op_eq
l_int|0xC9
op_logical_and
(paren
id|id3
op_eq
l_int|0x50
op_logical_or
id|id3
op_eq
l_int|0x52
op_logical_or
id|id3
op_eq
l_int|0x54
)paren
)paren
(brace
id|up-&gt;port.type
op_assign
id|PORT_16C950
suffix:semicolon
id|up-&gt;rev
op_assign
id|rev
op_or
(paren
id|id3
op_lshift
l_int|8
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We check for a XR16C850 by setting DLL and DLM to 0, and then&n;&t; * reading back DLL and DLM.  The chip type depends on the DLM&n;&t; * value read back:&n;&t; *  0x10 - XR16C850 and the DLL contains the chip revision.&n;&t; *  0x12 - XR16C2850.&n;&t; *  0x14 - XR16C854.&n;&t; */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|UART_LCR_DLAB
)paren
suffix:semicolon
id|saved_dll
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_DLL
)paren
suffix:semicolon
id|saved_dlm
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_DLM
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_DLL
comma
l_int|0
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_DLM
comma
l_int|0
)paren
suffix:semicolon
id|id2
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_DLL
)paren
suffix:semicolon
id|id1
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_DLM
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_DLL
comma
id|saved_dll
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_DLM
comma
id|saved_dlm
)paren
suffix:semicolon
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;850id=%02x:%02x &quot;
comma
id|id1
comma
id|id2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id1
op_eq
l_int|0x10
op_logical_or
id|id1
op_eq
l_int|0x12
op_logical_or
id|id1
op_eq
l_int|0x14
)paren
(brace
r_if
c_cond
(paren
id|id1
op_eq
l_int|0x10
)paren
id|up-&gt;rev
op_assign
id|id2
suffix:semicolon
id|up-&gt;port.type
op_assign
id|PORT_16850
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * It wasn&squot;t an XR16C850.&n;&t; *&n;&t; * We distinguish between the &squot;654 and the &squot;650 by counting&n;&t; * how many bytes are in the FIFO.  I&squot;m using this for now,&n;&t; * since that&squot;s the technique that was sent to me in the&n;&t; * serial driver update, but I&squot;m not convinced this works.&n;&t; * I&squot;ve had problems doing this in the past.  -TYT&n;&t; */
r_if
c_cond
(paren
id|size_fifo
c_func
(paren
id|up
)paren
op_eq
l_int|64
)paren
id|up-&gt;port.type
op_assign
id|PORT_16654
suffix:semicolon
r_else
id|up-&gt;port.type
op_assign
id|PORT_16650V2
suffix:semicolon
)brace
multiline_comment|/*&n; * We detected a chip without a FIFO.  Only two fall into&n; * this category - the original 8250 and the 16450.  The&n; * 16450 has a scratch register (accessible with LCR=0)&n; */
DECL|function|autoconfig_8250
r_static
r_void
id|autoconfig_8250
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_int
r_char
id|scratch
comma
id|status1
comma
id|status2
suffix:semicolon
id|up-&gt;port.type
op_assign
id|PORT_8250
suffix:semicolon
id|scratch
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_SCR
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_SCR
comma
l_int|0xa5
)paren
suffix:semicolon
id|status1
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_SCR
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_SCR
comma
l_int|0x5a
)paren
suffix:semicolon
id|status2
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_SCR
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_SCR
comma
id|scratch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status1
op_eq
l_int|0xa5
op_logical_and
id|status2
op_eq
l_int|0x5a
)paren
id|up-&gt;port.type
op_assign
id|PORT_16450
suffix:semicolon
)brace
multiline_comment|/*&n; * We know that the chip has FIFOs.  Does it have an EFR?  The&n; * EFR is located in the same register position as the IIR and&n; * we know the top two bits of the IIR are currently set.  The&n; * EFR should contain zero.  Try to read the EFR.&n; */
DECL|function|autoconfig_16550a
r_static
r_void
id|autoconfig_16550a
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_int
r_char
id|status1
comma
id|status2
suffix:semicolon
id|up-&gt;port.type
op_assign
id|PORT_16550A
suffix:semicolon
multiline_comment|/*&n;&t; * Check for presence of the EFR when DLAB is set.&n;&t; * Only ST16C650V1 UARTs pass this test.&n;&t; */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|UART_LCR_DLAB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_EFR
)paren
op_eq
l_int|0
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_EFR
comma
l_int|0xA8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_EFR
)paren
op_ne
l_int|0
)paren
(brace
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;EFRv1 &quot;
)paren
suffix:semicolon
id|up-&gt;port.type
op_assign
id|PORT_16650
suffix:semicolon
)brace
r_else
(brace
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;Motorola 8xxx DUART &quot;
)paren
suffix:semicolon
)brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_EFR
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Maybe it requires 0xbf to be written to the LCR.&n;&t; * (other ST16C650V2 UARTs, TI16C752A, etc)&n;&t; */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_EFR
)paren
op_eq
l_int|0
)paren
(brace
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;EFRv2 &quot;
)paren
suffix:semicolon
id|autoconfig_has_efr
c_func
(paren
id|up
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for a National Semiconductor SuperIO chip.&n;&t; * Attempt to switch to bank 2, read the value of the LOOP bit&n;&t; * from EXCR1. Switch back to bank 0, change it in MCR. Then&n;&t; * switch back to bank 2, read it from EXCR1 again and check&n;&t; * it&squot;s changed. If so, set baud_base in EXCR2 to 921600. -- dwmw2&n;&t; * On PowerPC we don&squot;t want to change baud_base, as we have&n;&t; * a number of different divisors.  -- Tom Rini&n;&t; */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
id|status1
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_MCR
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xE0
)paren
suffix:semicolon
id|status2
op_assign
id|serial_in
c_func
(paren
id|up
comma
l_int|0x02
)paren
suffix:semicolon
multiline_comment|/* EXCR1 */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|status2
op_xor
id|status1
)paren
op_amp
id|UART_MCR_LOOP
)paren
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|status1
op_xor
id|UART_MCR_LOOP
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xE0
)paren
suffix:semicolon
id|status2
op_assign
id|serial_in
c_func
(paren
id|up
comma
l_int|0x02
)paren
suffix:semicolon
multiline_comment|/* EXCR1 */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|status1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status2
op_xor
id|status1
)paren
op_amp
id|UART_MCR_LOOP
)paren
(brace
macro_line|#ifndef CONFIG_PPC
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xE0
)paren
suffix:semicolon
id|status1
op_assign
id|serial_in
c_func
(paren
id|up
comma
l_int|0x04
)paren
suffix:semicolon
multiline_comment|/* EXCR1 */
id|status1
op_and_assign
op_complement
l_int|0xB0
suffix:semicolon
multiline_comment|/* Disable LOCK, mask out PRESL[01] */
id|status1
op_or_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* 1.625 divisor for baud_base --&gt; 921600 */
id|serial_outp
c_func
(paren
id|up
comma
l_int|0x04
comma
id|status1
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
id|up-&gt;port.uartclk
op_assign
l_int|921600
op_star
l_int|16
suffix:semicolon
macro_line|#endif
id|up-&gt;port.type
op_assign
id|PORT_NS16550A
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * No EFR.  Try to detect a TI16750, which only sets bit 5 of&n;&t; * the IIR when 64 byte FIFO mode is enabled when DLAB is set.&n;&t; * Try setting it with and without DLAB set.  Cheap clones&n;&t; * set bit 5 without DLAB set.&n;&t; */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR7_64BYTE
)paren
suffix:semicolon
id|status1
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IIR
)paren
op_rshift
l_int|5
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|UART_LCR_DLAB
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR7_64BYTE
)paren
suffix:semicolon
id|status2
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IIR
)paren
op_rshift
l_int|5
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;iir1=%d iir2=%d &quot;
comma
id|status1
comma
id|status2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status1
op_eq
l_int|6
op_logical_and
id|status2
op_eq
l_int|7
)paren
(brace
id|up-&gt;port.type
op_assign
id|PORT_16750
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This routine is called by rs_init() to initialize a specific serial&n; * port.  It determines what type of UART chip this serial port is&n; * using: 8250, 16450, 16550, 16550A.  The important question is&n; * whether or not this UART is a 16550A or not, since this will&n; * determine whether or not we can use its FIFO features or not.&n; */
DECL|function|autoconfig
r_static
r_void
id|autoconfig
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_int
r_int
id|probeflags
)paren
(brace
r_int
r_char
id|status1
comma
id|scratch
comma
id|scratch2
comma
id|scratch3
suffix:semicolon
r_int
r_char
id|save_lcr
comma
id|save_mcr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|up-&gt;port.iobase
op_logical_and
op_logical_neg
id|up-&gt;port.mapbase
op_logical_and
op_logical_neg
id|up-&gt;port.membase
)paren
r_return
suffix:semicolon
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;ttyS%d: autoconf (0x%04x, 0x%p): &quot;
comma
id|up-&gt;port.line
comma
id|up-&gt;port.iobase
comma
id|up-&gt;port.membase
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We really do need global IRQs disabled here - we&squot;re going to&n;&t; * be frobbing the chips IRQ enable register to see if it exists.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|//&t;save_flags(flags); cli();
r_if
c_cond
(paren
op_logical_neg
(paren
id|up-&gt;port.flags
op_amp
id|UPF_BUGGY_UART
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Do a simple existence test first; if we fail this,&n;&t;&t; * there&squot;s no point trying anything else.&n;&t;&t; * &n;&t;&t; * 0x80 is used as a nonsense port to prevent against&n;&t;&t; * false positives due to ISA bus float.  The&n;&t;&t; * assumption is that 0x80 is a non-existent port;&n;&t;&t; * which should be safe since include/asm/io.h also&n;&t;&t; * makes this assumption.&n;&t;&t; *&n;&t;&t; * Note: this is safe as long as MCR bit 4 is clear&n;&t;&t; * and the device is in &quot;PC&quot; mode.&n;&t;&t; */
id|scratch
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IER
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef __i386__
id|outb
c_func
(paren
l_int|0xff
comma
l_int|0x080
)paren
suffix:semicolon
macro_line|#endif
id|scratch2
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IER
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0x0F
)paren
suffix:semicolon
macro_line|#ifdef __i386__
id|outb
c_func
(paren
l_int|0
comma
l_int|0x080
)paren
suffix:semicolon
macro_line|#endif
id|scratch3
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IER
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
id|scratch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scratch2
op_ne
l_int|0
op_logical_or
id|scratch3
op_ne
l_int|0x0F
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We failed; there&squot;s nothing here&n;&t;&t;&t; */
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;IER test failed (%02x, %02x) &quot;
comma
id|scratch2
comma
id|scratch3
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|save_mcr
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_MCR
)paren
suffix:semicolon
id|save_lcr
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Check to see if a UART is really there.  Certain broken&n;&t; * internal modems based on the Rockwell chipset fail this&n;&t; * test, because they apparently don&squot;t implement the loopback&n;&t; * test mode.  So this test is skipped on the COM 1 through&n;&t; * COM 4 ports.  This *should* be safe, since no board&n;&t; * manufacturer would be stupid enough to design a board&n;&t; * that conflicts with COM 1-4 --- we hope!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|up-&gt;port.flags
op_amp
id|UPF_SKIP_TEST
)paren
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|UART_MCR_LOOP
op_or
l_int|0x0A
)paren
suffix:semicolon
id|status1
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_MSR
)paren
op_amp
l_int|0xF0
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|save_mcr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status1
op_ne
l_int|0x90
)paren
(brace
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;LOOP test failed (%02x) &quot;
comma
id|status1
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * We&squot;re pretty sure there&squot;s a port here.  Lets find out what&n;&t; * type of port it is.  The IIR top two bits allows us to find&n;&t; * out if its 8250 or 16450, 16550, 16550A or later.  This&n;&t; * determines what we test for next.&n;&t; *&n;&t; * We also initialise the EFR (if any) to zero for later.  The&n;&t; * EFR occupies the same register location as the FCR and IIR.&n;&t; */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_EFR
comma
l_int|0
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
id|scratch
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IIR
)paren
op_rshift
l_int|6
suffix:semicolon
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;iir=%d &quot;
comma
id|scratch
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|scratch
)paren
(brace
r_case
l_int|0
suffix:colon
id|autoconfig_8250
c_func
(paren
id|up
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|up-&gt;port.type
op_assign
id|PORT_UNKNOWN
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|up-&gt;port.type
op_assign
id|PORT_16550
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|autoconfig_16550a
c_func
(paren
id|up
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SERIAL_8250_RSA
multiline_comment|/*&n;&t; * Only probe for RSA ports if we got the region.&n;&t; */
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_16550A
op_logical_and
id|probeflags
op_amp
id|PROBE_RSA
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|probe_rsa_count
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|probe_rsa
(braket
id|i
)braket
op_eq
id|up-&gt;port.iobase
op_logical_and
id|__enable_rsa
c_func
(paren
id|up
)paren
)paren
(brace
id|up-&gt;port.type
op_assign
id|PORT_RSA
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|save_lcr
)paren
suffix:semicolon
id|up-&gt;port.fifosize
op_assign
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|fifo_size
suffix:semicolon
id|up-&gt;capabilities
op_assign
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|flags
suffix:semicolon
id|up-&gt;tx_loadsz
op_assign
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|tx_loadsz
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_UNKNOWN
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Reset the UART.&n;&t; */
macro_line|#ifdef CONFIG_SERIAL_8250_RSA
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_RSA
)paren
id|serial_outp
c_func
(paren
id|up
comma
id|UART_RSA_FRR
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|save_mcr
)paren
suffix:semicolon
id|serial8250_clear_fifos
c_func
(paren
id|up
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|//&t;restore_flags(flags);
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;type=%s&bslash;n&quot;
comma
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|name
)paren
suffix:semicolon
)brace
DECL|function|autoconfig_irq
r_static
r_void
id|autoconfig_irq
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_int
r_char
id|save_mcr
comma
id|save_ier
suffix:semicolon
r_int
r_char
id|save_ICP
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|ICP
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|irqs
suffix:semicolon
r_int
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|UPF_FOURPORT
)paren
(brace
id|ICP
op_assign
(paren
id|up-&gt;port.iobase
op_amp
l_int|0xfe0
)paren
op_or
l_int|0x1f
suffix:semicolon
id|save_ICP
op_assign
id|inb_p
c_func
(paren
id|ICP
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x80
comma
id|ICP
)paren
suffix:semicolon
(paren
r_void
)paren
id|inb_p
c_func
(paren
id|ICP
)paren
suffix:semicolon
)brace
multiline_comment|/* forget possible initially masked and pending IRQ */
id|probe_irq_off
c_func
(paren
id|probe_irq_on
c_func
(paren
)paren
)paren
suffix:semicolon
id|save_mcr
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_MCR
)paren
suffix:semicolon
id|save_ier
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IER
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|UART_MCR_OUT1
op_or
id|UART_MCR_OUT2
)paren
suffix:semicolon
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
l_int|0
)paren
suffix:semicolon
id|udelay
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|UPF_FOURPORT
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|UART_MCR_DTR
op_or
id|UART_MCR_RTS
)paren
suffix:semicolon
)brace
r_else
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|UART_MCR_DTR
op_or
id|UART_MCR_RTS
op_or
id|UART_MCR_OUT2
)paren
suffix:semicolon
)brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0x0f
)paren
suffix:semicolon
multiline_comment|/* enable all intrs */
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IIR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_TX
comma
l_int|0xFF
)paren
suffix:semicolon
id|udelay
(paren
l_int|20
)paren
suffix:semicolon
id|irq
op_assign
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|save_mcr
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
id|save_ier
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|UPF_FOURPORT
)paren
id|outb_p
c_func
(paren
id|save_ICP
comma
id|ICP
)paren
suffix:semicolon
id|up-&gt;port.irq
op_assign
(paren
id|irq
OG
l_int|0
)paren
ques
c_cond
id|irq
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|serial8250_stop_tx
r_static
r_void
id|serial8250_stop_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|tty_stop
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;ier
op_amp
id|UART_IER_THRI
)paren
(brace
id|up-&gt;ier
op_and_assign
op_complement
id|UART_IER_THRI
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_16C950
op_logical_and
id|tty_stop
)paren
(brace
id|up-&gt;acr
op_or_assign
id|UART_ACR_TXDIS
suffix:semicolon
id|serial_icr_write
c_func
(paren
id|up
comma
id|UART_ACR
comma
id|up-&gt;acr
)paren
suffix:semicolon
)brace
)brace
DECL|function|serial8250_start_tx
r_static
r_void
id|serial8250_start_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|tty_start
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|up-&gt;ier
op_amp
id|UART_IER_THRI
)paren
)paren
(brace
id|up-&gt;ier
op_or_assign
id|UART_IER_THRI
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We only do this from uart_start&n;&t; */
r_if
c_cond
(paren
id|tty_start
op_logical_and
id|up-&gt;port.type
op_eq
id|PORT_16C950
)paren
(brace
id|up-&gt;acr
op_and_assign
op_complement
id|UART_ACR_TXDIS
suffix:semicolon
id|serial_icr_write
c_func
(paren
id|up
comma
id|UART_ACR
comma
id|up-&gt;acr
)paren
suffix:semicolon
)brace
)brace
DECL|function|serial8250_stop_rx
r_static
r_void
id|serial8250_stop_rx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
id|up-&gt;ier
op_and_assign
op_complement
id|UART_IER_RLSI
suffix:semicolon
id|up-&gt;port.read_status_mask
op_and_assign
op_complement
id|UART_LSR_DR
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
)brace
DECL|function|serial8250_enable_ms
r_static
r_void
id|serial8250_enable_ms
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
id|up-&gt;ier
op_or_assign
id|UART_IER_MSI
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
)brace
r_static
id|_INLINE_
r_void
DECL|function|receive_chars
id|receive_chars
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_int
op_star
id|status
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|up-&gt;port.info-&gt;tty
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_int
id|max_count
op_assign
l_int|256
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
)paren
(brace
id|tty-&gt;flip.work
dot
id|func
c_func
(paren
(paren
r_void
op_star
)paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
r_return
suffix:semicolon
singleline_comment|// if TTY_DONT_FLIP is set
)brace
id|ch
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_assign
id|ch
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_NORMAL
suffix:semicolon
id|up-&gt;port.icount.rx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_star
id|status
op_amp
(paren
id|UART_LSR_BI
op_or
id|UART_LSR_PE
op_or
id|UART_LSR_FE
op_or
id|UART_LSR_OE
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * For statistics only&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_BI
)paren
(brace
op_star
id|status
op_and_assign
op_complement
(paren
id|UART_LSR_FE
op_or
id|UART_LSR_PE
)paren
suffix:semicolon
id|up-&gt;port.icount.brk
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * We do the SysRQ and SAK checking&n;&t;&t;&t;&t; * here because otherwise the break&n;&t;&t;&t;&t; * may get masked by ignore_status_mask&n;&t;&t;&t;&t; * or read_status_mask.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|uart_handle_break
c_func
(paren
op_amp
id|up-&gt;port
)paren
)paren
r_goto
id|ignore_char
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_PE
)paren
id|up-&gt;port.icount.parity
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_FE
)paren
id|up-&gt;port.icount.frame
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_OE
)paren
id|up-&gt;port.icount.overrun
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Mask off conditions which should be ingored.&n;&t;&t;&t; */
op_star
id|status
op_and_assign
id|up-&gt;port.read_status_mask
suffix:semicolon
macro_line|#ifdef CONFIG_SERIAL_8250_CONSOLE
r_if
c_cond
(paren
id|up-&gt;port.line
op_eq
id|up-&gt;port.cons-&gt;index
)paren
(brace
multiline_comment|/* Recover the break flag from console xmit */
op_star
id|status
op_or_assign
id|up-&gt;lsr_break_flag
suffix:semicolon
id|up-&gt;lsr_break_flag
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_BI
)paren
(brace
id|DEBUG_INTR
c_func
(paren
l_string|&quot;handling break....&quot;
)paren
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_BREAK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_PE
)paren
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_PARITY
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_FE
)paren
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_FRAME
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uart_handle_sysrq_char
c_func
(paren
op_amp
id|up-&gt;port
comma
id|ch
comma
id|regs
)paren
)paren
r_goto
id|ignore_char
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|status
op_amp
id|up-&gt;port.ignore_status_mask
)paren
op_eq
l_int|0
)paren
(brace
id|tty-&gt;flip.flag_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|status
op_amp
id|UART_LSR_OE
)paren
op_logical_and
id|tty-&gt;flip.count
OL
id|TTY_FLIPBUF_SIZE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Overrun is special, since it&squot;s reported&n;&t;&t;&t; * immediately, and doesn&squot;t affect the current&n;&t;&t;&t; * character.&n;&t;&t;&t; */
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_OVERRUN
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.count
op_increment
suffix:semicolon
)brace
id|ignore_char
suffix:colon
op_star
id|status
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
op_star
id|status
op_amp
id|UART_LSR_DR
)paren
op_logical_and
(paren
id|max_count
op_decrement
OG
l_int|0
)paren
)paren
suffix:semicolon
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|transmit_chars
r_static
id|_INLINE_
r_void
id|transmit_chars
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_struct
id|circ_buf
op_star
id|xmit
op_assign
op_amp
id|up-&gt;port.info-&gt;xmit
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.x_char
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_TX
comma
id|up-&gt;port.x_char
)paren
suffix:semicolon
id|up-&gt;port.icount.tx
op_increment
suffix:semicolon
id|up-&gt;port.x_char
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
id|xmit
)paren
op_logical_or
id|uart_tx_stopped
c_func
(paren
op_amp
id|up-&gt;port
)paren
)paren
(brace
id|serial8250_stop_tx
c_func
(paren
op_amp
id|up-&gt;port
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|count
op_assign
id|up-&gt;tx_loadsz
suffix:semicolon
r_do
(brace
id|serial_out
c_func
(paren
id|up
comma
id|UART_TX
comma
id|xmit-&gt;buf
(braket
id|xmit-&gt;tail
)braket
)paren
suffix:semicolon
id|xmit-&gt;tail
op_assign
(paren
id|xmit-&gt;tail
op_plus
l_int|1
)paren
op_amp
(paren
id|UART_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|up-&gt;port.icount.tx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
id|xmit
)paren
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_chars_pending
c_func
(paren
id|xmit
)paren
OL
id|WAKEUP_CHARS
)paren
id|uart_write_wakeup
c_func
(paren
op_amp
id|up-&gt;port
)paren
suffix:semicolon
id|DEBUG_INTR
c_func
(paren
l_string|&quot;THRE...&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
id|xmit
)paren
)paren
id|serial8250_stop_tx
c_func
(paren
op_amp
id|up-&gt;port
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|check_modem_status
r_static
id|_INLINE_
r_void
id|check_modem_status
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|UART_MSR_ANY_DELTA
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_TERI
)paren
id|up-&gt;port.icount.rng
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DDSR
)paren
id|up-&gt;port.icount.dsr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DDCD
)paren
id|uart_handle_dcd_change
c_func
(paren
op_amp
id|up-&gt;port
comma
id|status
op_amp
id|UART_MSR_DCD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DCTS
)paren
id|uart_handle_cts_change
c_func
(paren
op_amp
id|up-&gt;port
comma
id|status
op_amp
id|UART_MSR_CTS
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|up-&gt;port.info-&gt;delta_msr_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This handles the interrupt from one port.&n; */
r_static
r_inline
r_void
DECL|function|serial8250_handle_port
id|serial8250_handle_port
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|status
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
id|DEBUG_INTR
c_func
(paren
l_string|&quot;status = %x...&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_LSR_DR
)paren
id|receive_chars
c_func
(paren
id|up
comma
op_amp
id|status
comma
id|regs
)paren
suffix:semicolon
id|check_modem_status
c_func
(paren
id|up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_LSR_THRE
)paren
id|transmit_chars
c_func
(paren
id|up
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the serial driver&squot;s interrupt routine.&n; *&n; * Arjan thinks the old way was overly complex, so it got simplified.&n; * Alan disagrees, saying that need the complexity to handle the weird&n; * nature of ISA shared interrupts.  (This is a special exception.)&n; *&n; * In order to handle ISA shared interrupts properly, we need to check&n; * that all ports have been serviced, and therefore the ISA interrupt&n; * line has been de-asserted.&n; *&n; * This means we need to loop through all ports. checking that they&n; * don&squot;t have an interrupt pending.&n; */
DECL|function|serial8250_interrupt
r_static
id|irqreturn_t
id|serial8250_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irq_info
op_star
id|i
op_assign
id|dev_id
suffix:semicolon
r_struct
id|list_head
op_star
id|l
comma
op_star
id|end
op_assign
l_int|NULL
suffix:semicolon
r_int
id|pass_counter
op_assign
l_int|0
suffix:semicolon
id|DEBUG_INTR
c_func
(paren
l_string|&quot;serial8250_interrupt(%d)...&quot;
comma
id|irq
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
id|l
op_assign
id|i-&gt;head
suffix:semicolon
r_do
(brace
r_struct
id|uart_8250_port
op_star
id|up
suffix:semicolon
r_int
r_int
id|iir
suffix:semicolon
id|up
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|uart_8250_port
comma
id|list
)paren
suffix:semicolon
id|iir
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IIR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iir
op_amp
id|UART_IIR_NO_INT
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
id|serial8250_handle_port
c_func
(paren
id|up
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
id|end
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|end
op_eq
l_int|NULL
)paren
id|end
op_assign
id|l
suffix:semicolon
id|l
op_assign
id|l-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
id|i-&gt;head
op_logical_and
id|pass_counter
op_increment
OG
id|PASS_LIMIT
)paren
(brace
multiline_comment|/* If we hit this, we&squot;re dead. */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;serial8250: too much work for &quot;
l_string|&quot;irq%d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|l
op_ne
id|end
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
id|DEBUG_INTR
c_func
(paren
l_string|&quot;end.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME! Was it really ours? */
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; * To support ISA shared interrupts, we need to have one interrupt&n; * handler that ensures that the IRQ line has been deasserted&n; * before returning.  Failing to do this will result in the IRQ&n; * line being stuck active, and, since ISA irqs are edge triggered,&n; * no more IRQs will be seen.&n; */
DECL|function|serial_do_unlink
r_static
r_void
id|serial_do_unlink
c_func
(paren
r_struct
id|irq_info
op_star
id|i
comma
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|i-&gt;head
)paren
)paren
(brace
r_if
c_cond
(paren
id|i-&gt;head
op_eq
op_amp
id|up-&gt;list
)paren
id|i-&gt;head
op_assign
id|i-&gt;head-&gt;next
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|up-&gt;list
)paren
suffix:semicolon
)brace
r_else
(brace
id|BUG_ON
c_func
(paren
id|i-&gt;head
op_ne
op_amp
id|up-&gt;list
)paren
suffix:semicolon
id|i-&gt;head
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|serial_link_irq_chain
r_static
r_int
id|serial_link_irq_chain
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_struct
id|irq_info
op_star
id|i
op_assign
id|irq_lists
op_plus
id|up-&gt;port.irq
suffix:semicolon
r_int
id|ret
comma
id|irq_flags
op_assign
id|up-&gt;port.flags
op_amp
id|UPF_SHARE_IRQ
ques
c_cond
id|SA_SHIRQ
suffix:colon
l_int|0
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i-&gt;head
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|up-&gt;list
comma
id|i-&gt;head
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|up-&gt;list
)paren
suffix:semicolon
id|i-&gt;head
op_assign
op_amp
id|up-&gt;list
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
id|request_irq
c_func
(paren
id|up-&gt;port.irq
comma
id|serial8250_interrupt
comma
id|irq_flags
comma
l_string|&quot;serial&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|serial_do_unlink
c_func
(paren
id|i
comma
id|up
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|serial_unlink_irq_chain
r_static
r_void
id|serial_unlink_irq_chain
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_struct
id|irq_info
op_star
id|i
op_assign
id|irq_lists
op_plus
id|up-&gt;port.irq
suffix:semicolon
id|BUG_ON
c_func
(paren
id|i-&gt;head
op_eq
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|i-&gt;head
)paren
)paren
id|free_irq
c_func
(paren
id|up-&gt;port.irq
comma
id|i
)paren
suffix:semicolon
id|serial_do_unlink
c_func
(paren
id|i
comma
id|up
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is used to handle ports that do not have an&n; * interrupt.  This doesn&squot;t work very well for 16450&squot;s, but gives&n; * barely passable results for a 16550A.  (Although at the expense&n; * of much CPU overhead).&n; */
DECL|function|serial8250_timeout
r_static
r_void
id|serial8250_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|data
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|iir
suffix:semicolon
id|iir
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IIR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iir
op_amp
id|UART_IIR_NO_INT
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
id|serial8250_handle_port
c_func
(paren
id|up
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
)brace
id|timeout
op_assign
id|up-&gt;port.timeout
suffix:semicolon
id|timeout
op_assign
id|timeout
OG
l_int|6
ques
c_cond
(paren
id|timeout
op_div
l_int|2
op_minus
l_int|2
)paren
suffix:colon
l_int|1
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|up-&gt;timer
comma
id|jiffies
op_plus
id|timeout
)paren
suffix:semicolon
)brace
DECL|function|serial8250_tx_empty
r_static
r_int
r_int
id|serial8250_tx_empty
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_LSR
)paren
op_amp
id|UART_LSR_TEMT
ques
c_cond
id|TIOCSER_TEMT
suffix:colon
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|serial8250_get_mctrl
r_static
r_int
r_int
id|serial8250_get_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DCD
)paren
id|ret
op_or_assign
id|TIOCM_CAR
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_RI
)paren
id|ret
op_or_assign
id|TIOCM_RNG
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DSR
)paren
id|ret
op_or_assign
id|TIOCM_DSR
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_CTS
)paren
id|ret
op_or_assign
id|TIOCM_CTS
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|serial8250_set_mctrl
r_static
r_void
id|serial8250_set_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|mctrl
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_char
id|mcr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_RTS
)paren
id|mcr
op_or_assign
id|UART_MCR_RTS
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_DTR
)paren
id|mcr
op_or_assign
id|UART_MCR_DTR
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_OUT1
)paren
id|mcr
op_or_assign
id|UART_MCR_OUT1
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_OUT2
)paren
id|mcr
op_or_assign
id|UART_MCR_OUT2
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_LOOP
)paren
id|mcr
op_or_assign
id|UART_MCR_LOOP
suffix:semicolon
id|mcr
op_assign
(paren
id|mcr
op_amp
id|up-&gt;mcr_mask
)paren
op_or
id|up-&gt;mcr_force
op_or
id|up-&gt;mcr
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|mcr
)paren
suffix:semicolon
)brace
DECL|function|serial8250_break_ctl
r_static
r_void
id|serial8250_break_ctl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
id|break_state
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|break_state
op_eq
op_minus
l_int|1
)paren
id|up-&gt;lcr
op_or_assign
id|UART_LCR_SBC
suffix:semicolon
r_else
id|up-&gt;lcr
op_and_assign
op_complement
id|UART_LCR_SBC
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|up-&gt;lcr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|serial8250_startup
r_static
r_int
id|serial8250_startup
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|up-&gt;capabilities
op_assign
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|flags
suffix:semicolon
id|up-&gt;mcr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_16C950
)paren
(brace
multiline_comment|/* Wake up and initialize UART */
id|up-&gt;acr
op_assign
l_int|0
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_EFR
comma
id|UART_EFR_ECB
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
id|serial_icr_write
c_func
(paren
id|up
comma
id|UART_CSR
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Reset the UART */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_EFR
comma
id|UART_EFR_ECB
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SERIAL_8250_RSA
multiline_comment|/*&n;&t; * If this is an RSA port, see if we can kick it up to the&n;&t; * higher speed clock.&n;&t; */
id|enable_rsa
c_func
(paren
id|up
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Clear the FIFO buffers and disable them.&n;&t; * (they will be reeanbled in set_termios())&n;&t; */
id|serial8250_clear_fifos
c_func
(paren
id|up
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the interrupt registers.&n;&t; */
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IIR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, there&squot;s no way the LSR could still be 0xff;&n;&t; * if it is, then bail out, because there&squot;s likely no UART&n;&t; * here.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|up-&gt;port.flags
op_amp
id|UPF_BUGGY_UART
)paren
op_logical_and
(paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
op_eq
l_int|0xff
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ttyS%d: LSR safety check engaged!&bslash;n&quot;
comma
id|up-&gt;port.line
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For a XR16C850, we need to set the trigger levels&n;&t; */
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_16850
)paren
(brace
r_int
r_char
id|fctr
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xbf
)paren
suffix:semicolon
id|fctr
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_FCTR
)paren
op_amp
op_complement
(paren
id|UART_FCTR_RX
op_or
id|UART_FCTR_TX
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCTR
comma
id|fctr
op_or
id|UART_FCTR_TRGD
op_or
id|UART_FCTR_RX
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_TRG
comma
id|UART_TRG_96
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCTR
comma
id|fctr
op_or
id|UART_FCTR_TRGD
op_or
id|UART_FCTR_TX
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_TRG
comma
id|UART_TRG_96
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the &quot;interrupt&quot; for this port doesn&squot;t correspond with any&n;&t; * hardware interrupt, we use a timer-based system.  The original&n;&t; * driver used to do this with IRQ0.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|is_real_interrupt
c_func
(paren
id|up-&gt;port.irq
)paren
)paren
(brace
r_int
r_int
id|timeout
op_assign
id|up-&gt;port.timeout
suffix:semicolon
id|timeout
op_assign
id|timeout
OG
l_int|6
ques
c_cond
(paren
id|timeout
op_div
l_int|2
op_minus
l_int|2
)paren
suffix:colon
l_int|1
suffix:semicolon
id|up-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|up
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|up-&gt;timer
comma
id|jiffies
op_plus
id|timeout
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|serial_link_irq_chain
c_func
(paren
id|up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now, initialize the UART&n;&t; */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|UART_LCR_WLEN8
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|UPF_FOURPORT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_real_interrupt
c_func
(paren
id|up-&gt;port.irq
)paren
)paren
id|up-&gt;port.mctrl
op_or_assign
id|TIOCM_OUT1
suffix:semicolon
)brace
r_else
multiline_comment|/*&n;&t;&t; * Most PC uarts need OUT2 raised to enable interrupts.&n;&t;&t; */
r_if
c_cond
(paren
id|is_real_interrupt
c_func
(paren
id|up-&gt;port.irq
)paren
)paren
id|up-&gt;port.mctrl
op_or_assign
id|TIOCM_OUT2
suffix:semicolon
id|serial8250_set_mctrl
c_func
(paren
op_amp
id|up-&gt;port
comma
id|up-&gt;port.mctrl
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Finally, enable interrupts.  Note: Modem status interrupts&n;&t; * are set via set_termios(), which will be occurring imminently&n;&t; * anyway, so we don&squot;t enable them here.&n;&t; */
id|up-&gt;ier
op_assign
id|UART_IER_RLSI
op_or
id|UART_IER_RDI
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|UPF_FOURPORT
)paren
(brace
r_int
r_int
id|icp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Enable interrupts on the AST Fourport board&n;&t;&t; */
id|icp
op_assign
(paren
id|up-&gt;port.iobase
op_amp
l_int|0xfe0
)paren
op_or
l_int|0x01f
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x80
comma
id|icp
)paren
suffix:semicolon
(paren
r_void
)paren
id|inb_p
c_func
(paren
id|icp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * And clear the interrupt registers again for luck.&n;&t; */
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IIR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|serial8250_shutdown
r_static
r_void
id|serial8250_shutdown
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Disable interrupts from this port&n;&t; */
id|up-&gt;ier
op_assign
l_int|0
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|UPF_FOURPORT
)paren
(brace
multiline_comment|/* reset interrupts on the AST Fourport board */
id|inb
c_func
(paren
(paren
id|up-&gt;port.iobase
op_amp
l_int|0xfe0
)paren
op_or
l_int|0x1f
)paren
suffix:semicolon
id|up-&gt;port.mctrl
op_or_assign
id|TIOCM_OUT1
suffix:semicolon
)brace
r_else
id|up-&gt;port.mctrl
op_and_assign
op_complement
id|TIOCM_OUT2
suffix:semicolon
id|serial8250_set_mctrl
c_func
(paren
op_amp
id|up-&gt;port
comma
id|up-&gt;port.mctrl
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable break condition and FIFOs&n;&t; */
id|serial_out
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LCR
)paren
op_amp
op_complement
id|UART_LCR_SBC
)paren
suffix:semicolon
id|serial8250_clear_fifos
c_func
(paren
id|up
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SERIAL_8250_RSA
multiline_comment|/*&n;&t; * Reset the RSA board back to 115kbps compat mode.&n;&t; */
id|disable_rsa
c_func
(paren
id|up
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Read data port to reset things, and then unlink from&n;&t; * the IRQ chain.&n;&t; */
(paren
r_void
)paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_real_interrupt
c_func
(paren
id|up-&gt;port.irq
)paren
)paren
id|del_timer_sync
c_func
(paren
op_amp
id|up-&gt;timer
)paren
suffix:semicolon
r_else
id|serial_unlink_irq_chain
c_func
(paren
id|up
)paren
suffix:semicolon
)brace
DECL|function|serial8250_get_divisor
r_static
r_int
r_int
id|serial8250_get_divisor
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|baud
)paren
(brace
r_int
r_int
id|quot
suffix:semicolon
multiline_comment|/*&n;&t; * Handle magic divisors for baud rates above baud_base on&n;&t; * SMSC SuperIO chips.&n;&t; */
r_if
c_cond
(paren
(paren
id|port-&gt;flags
op_amp
id|UPF_MAGIC_MULTIPLIER
)paren
op_logical_and
id|baud
op_eq
(paren
id|port-&gt;uartclk
op_div
l_int|4
)paren
)paren
id|quot
op_assign
l_int|0x8001
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|port-&gt;flags
op_amp
id|UPF_MAGIC_MULTIPLIER
)paren
op_logical_and
id|baud
op_eq
(paren
id|port-&gt;uartclk
op_div
l_int|8
)paren
)paren
id|quot
op_assign
l_int|0x8002
suffix:semicolon
r_else
id|quot
op_assign
id|uart_get_divisor
c_func
(paren
id|port
comma
id|baud
)paren
suffix:semicolon
r_return
id|quot
suffix:semicolon
)brace
r_static
r_void
DECL|function|serial8250_set_termios
id|serial8250_set_termios
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|termios
op_star
id|termios
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_char
id|cval
comma
id|fcr
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|baud
comma
id|quot
suffix:semicolon
r_switch
c_cond
(paren
id|termios-&gt;c_cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|cval
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|cval
op_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|cval
op_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
id|CS8
suffix:colon
id|cval
op_assign
l_int|0x03
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|termios-&gt;c_cflag
op_amp
id|CSTOPB
)paren
id|cval
op_or_assign
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
id|termios-&gt;c_cflag
op_amp
id|PARENB
)paren
id|cval
op_or_assign
id|UART_LCR_PARITY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|termios-&gt;c_cflag
op_amp
id|PARODD
)paren
)paren
id|cval
op_or_assign
id|UART_LCR_EPAR
suffix:semicolon
macro_line|#ifdef CMSPAR
r_if
c_cond
(paren
id|termios-&gt;c_cflag
op_amp
id|CMSPAR
)paren
id|cval
op_or_assign
id|UART_LCR_SPAR
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Ask the core to calculate the divisor for us.&n;&t; */
id|baud
op_assign
id|uart_get_baud_rate
c_func
(paren
id|port
comma
id|termios
comma
id|old
comma
l_int|0
comma
id|port-&gt;uartclk
op_div
l_int|16
)paren
suffix:semicolon
id|quot
op_assign
id|serial8250_get_divisor
c_func
(paren
id|port
comma
id|baud
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Work around a bug in the Oxford Semiconductor 952 rev B&n;&t; * chip which causes it to seriously miscalculate baud rates&n;&t; * when DLL is 0.&n;&t; */
r_if
c_cond
(paren
(paren
id|quot
op_amp
l_int|0xff
)paren
op_eq
l_int|0
op_logical_and
id|up-&gt;port.type
op_eq
id|PORT_16C950
op_logical_and
id|up-&gt;rev
op_eq
l_int|0x5201
)paren
id|quot
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;capabilities
op_amp
id|UART_CAP_FIFO
op_logical_and
id|up-&gt;port.fifosize
OG
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|baud
OL
l_int|2400
)paren
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_TRIGGER_1
suffix:semicolon
r_else
id|fcr
op_assign
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|fcr
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * MCR-based auto flow control.  When AFE is enabled, RTS will be&n;&t; * deasserted when the receive FIFO contains more characters than&n;&t; * the trigger, or the MCR RTS bit is cleared.  In the case where&n;&t; * the remote UART is not using CTS auto flow control, we must&n;&t; * have sufficient FIFO entries for the latency of the remote&n;&t; * UART to respond.  IOW, at least 32 bytes of FIFO.&n;&t; */
r_if
c_cond
(paren
id|up-&gt;capabilities
op_amp
id|UART_CAP_AFE
op_logical_and
id|up-&gt;port.fifosize
op_ge
l_int|32
)paren
(brace
id|up-&gt;mcr
op_and_assign
op_complement
id|UART_MCR_AFE
suffix:semicolon
r_if
c_cond
(paren
id|termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
id|up-&gt;mcr
op_or_assign
id|UART_MCR_AFE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ok, we&squot;re now changing the port state.  Do it with&n;&t; * interrupts disabled.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update the per-port timeout.&n;&t; */
id|uart_update_timeout
c_func
(paren
id|port
comma
id|termios-&gt;c_cflag
comma
id|baud
)paren
suffix:semicolon
id|up-&gt;port.read_status_mask
op_assign
id|UART_LSR_OE
op_or
id|UART_LSR_THRE
op_or
id|UART_LSR_DR
suffix:semicolon
r_if
c_cond
(paren
id|termios-&gt;c_iflag
op_amp
id|INPCK
)paren
id|up-&gt;port.read_status_mask
op_or_assign
id|UART_LSR_FE
op_or
id|UART_LSR_PE
suffix:semicolon
r_if
c_cond
(paren
id|termios-&gt;c_iflag
op_amp
(paren
id|BRKINT
op_or
id|PARMRK
)paren
)paren
id|up-&gt;port.read_status_mask
op_or_assign
id|UART_LSR_BI
suffix:semicolon
multiline_comment|/*&n;&t; * Characteres to ignore&n;&t; */
id|up-&gt;port.ignore_status_mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|termios-&gt;c_iflag
op_amp
id|IGNPAR
)paren
id|up-&gt;port.ignore_status_mask
op_or_assign
id|UART_LSR_PE
op_or
id|UART_LSR_FE
suffix:semicolon
r_if
c_cond
(paren
id|termios-&gt;c_iflag
op_amp
id|IGNBRK
)paren
(brace
id|up-&gt;port.ignore_status_mask
op_or_assign
id|UART_LSR_BI
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;re ignoring parity and break indicators,&n;&t;&t; * ignore overruns too (for real raw support).&n;&t;&t; */
r_if
c_cond
(paren
id|termios-&gt;c_iflag
op_amp
id|IGNPAR
)paren
id|up-&gt;port.ignore_status_mask
op_or_assign
id|UART_LSR_OE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ignore all characters if CREAD is not set&n;&t; */
r_if
c_cond
(paren
(paren
id|termios-&gt;c_cflag
op_amp
id|CREAD
)paren
op_eq
l_int|0
)paren
id|up-&gt;port.ignore_status_mask
op_or_assign
id|UART_LSR_DR
suffix:semicolon
multiline_comment|/*&n;&t; * CTS flow control flag and modem status interrupts&n;&t; */
id|up-&gt;ier
op_and_assign
op_complement
id|UART_IER_MSI
suffix:semicolon
r_if
c_cond
(paren
id|UART_ENABLE_MS
c_func
(paren
op_amp
id|up-&gt;port
comma
id|termios-&gt;c_cflag
)paren
)paren
id|up-&gt;ier
op_or_assign
id|UART_IER_MSI
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_XSCALE
)paren
id|up-&gt;ier
op_or_assign
id|UART_IER_UUE
op_or
id|UART_IER_RTOIE
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;capabilities
op_amp
id|UART_CAP_EFR
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_EFR
comma
id|termios-&gt;c_cflag
op_amp
id|CRTSCTS
ques
c_cond
id|UART_EFR_CTS
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up-&gt;capabilities
op_amp
id|UART_NATSEMI
)paren
(brace
multiline_comment|/* Switch to bank 2 not bank 1, to avoid resetting EXCR2 */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
l_int|0xe0
)paren
suffix:semicolon
)brace
r_else
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|cval
op_or
id|UART_LCR_DLAB
)paren
suffix:semicolon
multiline_comment|/* set DLAB */
)brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_DLL
comma
id|quot
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* LS of divisor */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_DLM
comma
id|quot
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* MS of divisor */
multiline_comment|/*&n;&t; * LCR DLAB must be set to enable 64-byte FIFO mode. If the FCR&n;&t; * is written without DLAB set, this mode will be disabled.&n;&t; */
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_16750
)paren
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|fcr
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|cval
)paren
suffix:semicolon
multiline_comment|/* reset DLAB */
id|up-&gt;lcr
op_assign
id|cval
suffix:semicolon
multiline_comment|/* Save LCR */
r_if
c_cond
(paren
id|up-&gt;port.type
op_ne
id|PORT_16750
)paren
(brace
r_if
c_cond
(paren
id|fcr
op_amp
id|UART_FCR_ENABLE_FIFO
)paren
(brace
multiline_comment|/* emulated UARTs (Lucent Venus 167x) need two steps */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
)brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|fcr
)paren
suffix:semicolon
multiline_comment|/* set fcr */
)brace
id|serial8250_set_mctrl
c_func
(paren
op_amp
id|up-&gt;port
comma
id|up-&gt;port.mctrl
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|serial8250_pm
id|serial8250_pm
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|state
comma
r_int
r_int
id|oldstate
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|p
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
id|serial8250_set_sleep
c_func
(paren
id|p
comma
id|state
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;pm
)paren
id|p
op_member_access_from_pointer
id|pm
c_func
(paren
id|port
comma
id|state
comma
id|oldstate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Resource handling.  This is complicated by the fact that resources&n; * depend on the port type.  Maybe we should be claiming the standard&n; * 8250 ports, and then trying to get other resources as necessary?&n; */
r_static
r_int
DECL|function|serial8250_request_std_resource
id|serial8250_request_std_resource
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_struct
id|resource
op_star
op_star
id|res
)paren
(brace
r_int
r_int
id|size
op_assign
l_int|8
op_lshift
id|up-&gt;port.regshift
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|up-&gt;port.iotype
)paren
(brace
r_case
id|UPIO_MEM
suffix:colon
r_if
c_cond
(paren
id|up-&gt;port.mapbase
)paren
(brace
op_star
id|res
op_assign
id|request_mem_region
c_func
(paren
id|up-&gt;port.mapbase
comma
id|size
comma
l_string|&quot;serial&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|res
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|UPIO_HUB6
suffix:colon
r_case
id|UPIO_PORT
suffix:colon
op_star
id|res
op_assign
id|request_region
c_func
(paren
id|up-&gt;port.iobase
comma
id|size
comma
l_string|&quot;serial&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|res
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|serial8250_request_rsa_resource
id|serial8250_request_rsa_resource
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_struct
id|resource
op_star
op_star
id|res
)paren
(brace
r_int
r_int
id|size
op_assign
l_int|8
op_lshift
id|up-&gt;port.regshift
suffix:semicolon
r_int
r_int
id|start
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|up-&gt;port.iotype
)paren
(brace
r_case
id|UPIO_MEM
suffix:colon
r_if
c_cond
(paren
id|up-&gt;port.mapbase
)paren
(brace
id|start
op_assign
id|up-&gt;port.mapbase
suffix:semicolon
id|start
op_add_assign
id|UART_RSA_BASE
op_lshift
id|up-&gt;port.regshift
suffix:semicolon
op_star
id|res
op_assign
id|request_mem_region
c_func
(paren
id|start
comma
id|size
comma
l_string|&quot;serial-rsa&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|res
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|UPIO_HUB6
suffix:colon
r_case
id|UPIO_PORT
suffix:colon
id|start
op_assign
id|up-&gt;port.iobase
suffix:semicolon
id|start
op_add_assign
id|UART_RSA_BASE
op_lshift
id|up-&gt;port.regshift
suffix:semicolon
op_star
id|res
op_assign
id|request_region
c_func
(paren
id|start
comma
id|size
comma
l_string|&quot;serial-rsa&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|res
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|serial8250_release_port
r_static
r_void
id|serial8250_release_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|start
comma
id|offset
op_assign
l_int|0
comma
id|size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_RSA
)paren
(brace
id|offset
op_assign
id|UART_RSA_BASE
op_lshift
id|up-&gt;port.regshift
suffix:semicolon
id|size
op_assign
l_int|8
suffix:semicolon
)brace
id|size
op_lshift_assign
id|up-&gt;port.regshift
suffix:semicolon
r_switch
c_cond
(paren
id|up-&gt;port.iotype
)paren
(brace
r_case
id|UPIO_MEM
suffix:colon
r_if
c_cond
(paren
id|up-&gt;port.mapbase
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Unmap the area.&n;&t;&t;&t; */
id|iounmap
c_func
(paren
id|up-&gt;port.membase
)paren
suffix:semicolon
id|up-&gt;port.membase
op_assign
l_int|NULL
suffix:semicolon
id|start
op_assign
id|up-&gt;port.mapbase
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
id|release_mem_region
c_func
(paren
id|start
op_plus
id|offset
comma
id|size
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|start
comma
l_int|8
op_lshift
id|up-&gt;port.regshift
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|UPIO_HUB6
suffix:colon
r_case
id|UPIO_PORT
suffix:colon
id|start
op_assign
id|up-&gt;port.iobase
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
id|release_region
c_func
(paren
id|start
op_plus
id|offset
comma
id|size
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|start
op_plus
id|offset
comma
l_int|8
op_lshift
id|up-&gt;port.regshift
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
DECL|function|serial8250_request_port
r_static
r_int
id|serial8250_request_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_struct
id|resource
op_star
id|res
op_assign
l_int|NULL
comma
op_star
id|res_rsa
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_RSA
)paren
(brace
id|ret
op_assign
id|serial8250_request_rsa_resource
c_func
(paren
id|up
comma
op_amp
id|res_rsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
)brace
id|ret
op_assign
id|serial8250_request_std_resource
c_func
(paren
id|up
comma
op_amp
id|res
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have a mapbase, then request that as well.&n;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_and
id|up-&gt;port.flags
op_amp
id|UPF_IOREMAP
)paren
(brace
r_int
id|size
op_assign
id|res-&gt;end
op_minus
id|res-&gt;start
op_plus
l_int|1
suffix:semicolon
id|up-&gt;port.membase
op_assign
id|ioremap
c_func
(paren
id|up-&gt;port.mapbase
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|up-&gt;port.membase
)paren
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|res_rsa
)paren
id|release_resource
c_func
(paren
id|res_rsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
id|release_resource
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|serial8250_config_port
r_static
r_void
id|serial8250_config_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
id|flags
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_struct
id|resource
op_star
id|res_std
op_assign
l_int|NULL
comma
op_star
id|res_rsa
op_assign
l_int|NULL
suffix:semicolon
r_int
id|probeflags
op_assign
id|PROBE_ANY
suffix:semicolon
r_int
id|ret
suffix:semicolon
macro_line|#ifdef CONFIG_MCA
multiline_comment|/*&n;&t; * Don&squot;t probe for MCA ports on non-MCA machines.&n;&t; */
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|UPF_BOOT_ONLYMCA
op_logical_and
op_logical_neg
id|MCA_bus
)paren
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Find the region that we can probe for.  This in turn&n;&t; * tells us whether we can probe for the type of port.&n;&t; */
id|ret
op_assign
id|serial8250_request_std_resource
c_func
(paren
id|up
comma
op_amp
id|res_std
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
suffix:semicolon
id|ret
op_assign
id|serial8250_request_rsa_resource
c_func
(paren
id|up
comma
op_amp
id|res_rsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|probeflags
op_and_assign
op_complement
id|PROBE_RSA
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UART_CONFIG_TYPE
)paren
id|autoconfig
c_func
(paren
id|up
comma
id|probeflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_ne
id|PORT_UNKNOWN
op_logical_and
id|flags
op_amp
id|UART_CONFIG_IRQ
)paren
id|autoconfig_irq
c_func
(paren
id|up
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the port wasn&squot;t an RSA port, release the resource.&n;&t; */
r_if
c_cond
(paren
id|up-&gt;port.type
op_ne
id|PORT_RSA
op_logical_and
id|res_rsa
)paren
id|release_resource
c_func
(paren
id|res_rsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_UNKNOWN
op_logical_and
id|res_std
)paren
id|release_resource
c_func
(paren
id|res_std
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|serial8250_verify_port
id|serial8250_verify_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|serial_struct
op_star
id|ser
)paren
(brace
r_if
c_cond
(paren
id|ser-&gt;irq
op_ge
id|NR_IRQS
op_logical_or
id|ser-&gt;irq
OL
l_int|0
op_logical_or
id|ser-&gt;baud_base
OL
l_int|9600
op_logical_or
id|ser-&gt;type
OL
id|PORT_UNKNOWN
op_logical_or
id|ser-&gt;type
op_ge
id|ARRAY_SIZE
c_func
(paren
id|uart_config
)paren
op_logical_or
id|ser-&gt;type
op_eq
id|PORT_CIRRUS
op_logical_or
id|ser-&gt;type
op_eq
id|PORT_STARTECH
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_const
r_char
op_star
DECL|function|serial8250_type
id|serial8250_type
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_int
id|type
op_assign
id|port-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|ARRAY_SIZE
c_func
(paren
id|uart_config
)paren
)paren
id|type
op_assign
l_int|0
suffix:semicolon
r_return
id|uart_config
(braket
id|type
)braket
dot
id|name
suffix:semicolon
)brace
DECL|variable|serial8250_pops
r_static
r_struct
id|uart_ops
id|serial8250_pops
op_assign
(brace
dot
id|tx_empty
op_assign
id|serial8250_tx_empty
comma
dot
id|set_mctrl
op_assign
id|serial8250_set_mctrl
comma
dot
id|get_mctrl
op_assign
id|serial8250_get_mctrl
comma
dot
id|stop_tx
op_assign
id|serial8250_stop_tx
comma
dot
id|start_tx
op_assign
id|serial8250_start_tx
comma
dot
id|stop_rx
op_assign
id|serial8250_stop_rx
comma
dot
id|enable_ms
op_assign
id|serial8250_enable_ms
comma
dot
id|break_ctl
op_assign
id|serial8250_break_ctl
comma
dot
id|startup
op_assign
id|serial8250_startup
comma
dot
id|shutdown
op_assign
id|serial8250_shutdown
comma
dot
id|set_termios
op_assign
id|serial8250_set_termios
comma
dot
id|pm
op_assign
id|serial8250_pm
comma
dot
id|type
op_assign
id|serial8250_type
comma
dot
id|release_port
op_assign
id|serial8250_release_port
comma
dot
id|request_port
op_assign
id|serial8250_request_port
comma
dot
id|config_port
op_assign
id|serial8250_config_port
comma
dot
id|verify_port
op_assign
id|serial8250_verify_port
comma
)brace
suffix:semicolon
DECL|variable|serial8250_ports
r_static
r_struct
id|uart_8250_port
id|serial8250_ports
(braket
id|UART_NR
)braket
suffix:semicolon
DECL|function|serial8250_isa_init_ports
r_static
r_void
id|__init
id|serial8250_isa_init_ports
c_func
(paren
r_void
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
suffix:semicolon
r_static
r_int
id|first
op_assign
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
r_return
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|up
op_assign
id|serial8250_ports
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|old_serial_port
)paren
suffix:semicolon
id|i
op_increment
comma
id|up
op_increment
)paren
(brace
id|up-&gt;port.iobase
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|port
suffix:semicolon
id|up-&gt;port.irq
op_assign
id|irq_canonicalize
c_func
(paren
id|old_serial_port
(braket
id|i
)braket
dot
id|irq
)paren
suffix:semicolon
id|up-&gt;port.uartclk
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|baud_base
op_star
l_int|16
suffix:semicolon
id|up-&gt;port.flags
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|flags
suffix:semicolon
id|up-&gt;port.hub6
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|hub6
suffix:semicolon
id|up-&gt;port.membase
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|iomem_base
suffix:semicolon
id|up-&gt;port.iotype
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|io_type
suffix:semicolon
id|up-&gt;port.regshift
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|iomem_reg_shift
suffix:semicolon
id|up-&gt;port.ops
op_assign
op_amp
id|serial8250_pops
suffix:semicolon
r_if
c_cond
(paren
id|share_irqs
)paren
id|up-&gt;port.flags
op_or_assign
id|UPF_SHARE_IRQ
suffix:semicolon
)brace
)brace
DECL|function|serial8250_register_ports
r_static
r_void
id|__init
id|serial8250_register_ports
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
)paren
(brace
r_int
id|i
suffix:semicolon
id|serial8250_isa_init_ports
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UART_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
op_amp
id|serial8250_ports
(braket
id|i
)braket
suffix:semicolon
id|up-&gt;port.line
op_assign
id|i
suffix:semicolon
id|up-&gt;port.ops
op_assign
op_amp
id|serial8250_pops
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|up-&gt;timer
)paren
suffix:semicolon
id|up-&gt;timer.function
op_assign
id|serial8250_timeout
suffix:semicolon
multiline_comment|/*&n;&t;&t; * ALPHA_KLUDGE_MCR needs to be killed.&n;&t;&t; */
id|up-&gt;mcr_mask
op_assign
op_complement
id|ALPHA_KLUDGE_MCR
suffix:semicolon
id|up-&gt;mcr_force
op_assign
id|ALPHA_KLUDGE_MCR
suffix:semicolon
id|uart_add_one_port
c_func
(paren
id|drv
comma
op_amp
id|up-&gt;port
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_SERIAL_8250_CONSOLE
DECL|macro|BOTH_EMPTY
mdefine_line|#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
multiline_comment|/*&n; *&t;Wait for transmitter &amp; holding register to empty&n; */
DECL|function|wait_for_xmitr
r_static
r_inline
r_void
id|wait_for_xmitr
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_int
r_int
id|status
comma
id|tmout
op_assign
l_int|10000
suffix:semicolon
multiline_comment|/* Wait up to 10ms for the character(s) to be sent. */
r_do
(brace
id|status
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_LSR_BI
)paren
id|up-&gt;lsr_break_flag
op_assign
id|UART_LSR_BI
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|tmout
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|status
op_amp
id|BOTH_EMPTY
)paren
op_ne
id|BOTH_EMPTY
)paren
suffix:semicolon
multiline_comment|/* Wait up to 1s for flow control if necessary */
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|UPF_CONS_FLOW
)paren
(brace
id|tmout
op_assign
l_int|1000000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|tmout
op_logical_and
(paren
(paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_MSR
)paren
op_amp
id|UART_MSR_CTS
)paren
op_eq
l_int|0
)paren
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Print a string to the serial port trying not to disturb&n; *&t;any possible real use of the port...&n; *&n; *&t;The console_lock must be held when we get here.&n; */
r_static
r_void
DECL|function|serial8250_console_write
id|serial8250_console_write
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_const
r_char
op_star
id|s
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
op_amp
id|serial8250_ports
(braket
id|co-&gt;index
)braket
suffix:semicolon
r_int
r_int
id|ier
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;First save the UER then disable the interrupts&n;&t; */
id|ier
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_XSCALE
)paren
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|UART_IER_UUE
)paren
suffix:semicolon
r_else
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now, do each character&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|s
op_increment
)paren
(brace
id|wait_for_xmitr
c_func
(paren
id|up
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Send the character out.&n;&t;&t; *&t;If a LF, also do CR...&n;&t;&t; */
id|serial_out
c_func
(paren
id|up
comma
id|UART_TX
comma
op_star
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_eq
l_int|10
)paren
(brace
id|wait_for_xmitr
c_func
(paren
id|up
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_TX
comma
l_int|13
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Finally, wait for transmitter to become empty&n;&t; *&t;and restore the IER&n;&t; */
id|wait_for_xmitr
c_func
(paren
id|up
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|ier
)paren
suffix:semicolon
)brace
DECL|function|serial8250_console_setup
r_static
r_int
id|__init
id|serial8250_console_setup
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_char
op_star
id|options
)paren
(brace
r_struct
id|uart_port
op_star
id|port
suffix:semicolon
r_int
id|baud
op_assign
l_int|9600
suffix:semicolon
r_int
id|bits
op_assign
l_int|8
suffix:semicolon
r_int
id|parity
op_assign
l_char|&squot;n&squot;
suffix:semicolon
r_int
id|flow
op_assign
l_char|&squot;n&squot;
suffix:semicolon
multiline_comment|/*&n;&t; * Check whether an invalid uart number has been specified, and&n;&t; * if so, search for the first available port that does have&n;&t; * console support.&n;&t; */
r_if
c_cond
(paren
id|co-&gt;index
op_ge
id|UART_NR
)paren
id|co-&gt;index
op_assign
l_int|0
suffix:semicolon
id|port
op_assign
op_amp
id|serial8250_ports
(braket
id|co-&gt;index
)braket
dot
id|port
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;ops
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * Temporary fix.&n;&t; */
id|spin_lock_init
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options
)paren
id|uart_parse_options
c_func
(paren
id|options
comma
op_amp
id|baud
comma
op_amp
id|parity
comma
op_amp
id|bits
comma
op_amp
id|flow
)paren
suffix:semicolon
r_return
id|uart_set_options
c_func
(paren
id|port
comma
id|co
comma
id|baud
comma
id|parity
comma
id|bits
comma
id|flow
)paren
suffix:semicolon
)brace
DECL|variable|serial8250_reg
r_static
r_struct
id|uart_driver
id|serial8250_reg
suffix:semicolon
DECL|variable|serial8250_console
r_static
r_struct
id|console
id|serial8250_console
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ttyS&quot;
comma
dot
id|write
op_assign
id|serial8250_console_write
comma
dot
id|device
op_assign
id|uart_console_device
comma
dot
id|setup
op_assign
id|serial8250_console_setup
comma
dot
id|flags
op_assign
id|CON_PRINTBUFFER
comma
dot
id|index
op_assign
op_minus
l_int|1
comma
dot
id|data
op_assign
op_amp
id|serial8250_reg
comma
)brace
suffix:semicolon
DECL|function|serial8250_console_init
r_static
r_int
id|__init
id|serial8250_console_init
c_func
(paren
r_void
)paren
(brace
id|serial8250_isa_init_ports
c_func
(paren
)paren
suffix:semicolon
id|register_console
c_func
(paren
op_amp
id|serial8250_console
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|serial8250_console_init
id|console_initcall
c_func
(paren
id|serial8250_console_init
)paren
suffix:semicolon
DECL|function|serial8250_late_console_init
r_static
r_int
id|__init
id|serial8250_late_console_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|serial8250_console.flags
op_amp
id|CON_ENABLED
)paren
)paren
id|register_console
c_func
(paren
op_amp
id|serial8250_console
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|serial8250_late_console_init
id|late_initcall
c_func
(paren
id|serial8250_late_console_init
)paren
suffix:semicolon
DECL|macro|SERIAL8250_CONSOLE
mdefine_line|#define SERIAL8250_CONSOLE&t;&amp;serial8250_console
macro_line|#else
DECL|macro|SERIAL8250_CONSOLE
mdefine_line|#define SERIAL8250_CONSOLE&t;NULL
macro_line|#endif
DECL|variable|serial8250_reg
r_static
r_struct
id|uart_driver
id|serial8250_reg
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|driver_name
op_assign
l_string|&quot;serial&quot;
comma
dot
id|devfs_name
op_assign
l_string|&quot;tts/&quot;
comma
dot
id|dev_name
op_assign
l_string|&quot;ttyS&quot;
comma
dot
id|major
op_assign
id|TTY_MAJOR
comma
dot
id|minor
op_assign
l_int|64
comma
dot
id|nr
op_assign
id|UART_NR
comma
dot
id|cons
op_assign
id|SERIAL8250_CONSOLE
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * register_serial and unregister_serial allows for 16x50 serial ports to be&n; * configured at run-time, to support PCMCIA modems.&n; */
DECL|function|__register_serial
r_static
r_int
id|__register_serial
c_func
(paren
r_struct
id|serial_struct
op_star
id|req
comma
r_int
id|line
)paren
(brace
r_struct
id|uart_port
id|port
suffix:semicolon
id|port.iobase
op_assign
id|req-&gt;port
suffix:semicolon
id|port.membase
op_assign
id|req-&gt;iomem_base
suffix:semicolon
id|port.irq
op_assign
id|req-&gt;irq
suffix:semicolon
id|port.uartclk
op_assign
id|req-&gt;baud_base
op_star
l_int|16
suffix:semicolon
id|port.fifosize
op_assign
id|req-&gt;xmit_fifo_size
suffix:semicolon
id|port.regshift
op_assign
id|req-&gt;iomem_reg_shift
suffix:semicolon
id|port.iotype
op_assign
id|req-&gt;io_type
suffix:semicolon
id|port.flags
op_assign
id|req-&gt;flags
op_or
id|UPF_BOOT_AUTOCONF
suffix:semicolon
id|port.mapbase
op_assign
id|req-&gt;iomap_base
suffix:semicolon
id|port.line
op_assign
id|line
suffix:semicolon
r_if
c_cond
(paren
id|share_irqs
)paren
id|port.flags
op_or_assign
id|UPF_SHARE_IRQ
suffix:semicolon
r_if
c_cond
(paren
id|HIGH_BITS_OFFSET
)paren
id|port.iobase
op_or_assign
(paren
r_int
)paren
id|req-&gt;port_high
op_lshift
id|HIGH_BITS_OFFSET
suffix:semicolon
multiline_comment|/*&n;&t; * If a clock rate wasn&squot;t specified by the low level&n;&t; * driver, then default to the standard clock rate.&n;&t; */
r_if
c_cond
(paren
id|port.uartclk
op_eq
l_int|0
)paren
id|port.uartclk
op_assign
id|BASE_BAUD
op_star
l_int|16
suffix:semicolon
r_return
id|uart_register_port
c_func
(paren
op_amp
id|serial8250_reg
comma
op_amp
id|port
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;register_serial - configure a 16x50 serial port at runtime&n; *&t;@req: request structure&n; *&n; *&t;Configure the serial port specified by the request. If the&n; *&t;port exists and is in use an error is returned. If the port&n; *&t;is not currently in the table it is added.&n; *&n; *&t;The port is then probed and if necessary the IRQ is autodetected&n; *&t;If this fails an error is returned.&n; *&n; *&t;On success the port is ready to use and the line number is returned.&n; */
DECL|function|register_serial
r_int
id|register_serial
c_func
(paren
r_struct
id|serial_struct
op_star
id|req
)paren
(brace
r_return
id|__register_serial
c_func
(paren
id|req
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|early_serial_setup
r_int
id|__init
id|early_serial_setup
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;line
op_ge
id|ARRAY_SIZE
c_func
(paren
id|serial8250_ports
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|serial8250_isa_init_ports
c_func
(paren
)paren
suffix:semicolon
id|serial8250_ports
(braket
id|port-&gt;line
)braket
dot
id|port
op_assign
op_star
id|port
suffix:semicolon
id|serial8250_ports
(braket
id|port-&gt;line
)braket
dot
id|port.ops
op_assign
op_amp
id|serial8250_pops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;unregister_serial - remove a 16x50 serial port at runtime&n; *&t;@line: serial line number&n; *&n; *&t;Remove one serial port.  This may be called from interrupt&n; *&t;context.&n; */
DECL|function|unregister_serial
r_void
id|unregister_serial
c_func
(paren
r_int
id|line
)paren
(brace
id|uart_unregister_port
c_func
(paren
op_amp
id|serial8250_reg
comma
id|line
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is for ISAPNP only.&n; */
DECL|function|serial8250_get_irq_map
r_void
id|serial8250_get_irq_map
c_func
(paren
r_int
r_int
op_star
id|map
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UART_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|serial8250_ports
(braket
id|i
)braket
dot
id|port.type
op_ne
id|PORT_UNKNOWN
op_logical_and
id|serial8250_ports
(braket
id|i
)braket
dot
id|port.irq
OL
l_int|16
)paren
op_star
id|map
op_or_assign
l_int|1
op_lshift
id|serial8250_ports
(braket
id|i
)braket
dot
id|port.irq
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;serial8250_suspend_port - suspend one serial port&n; *&t;@line:  serial line number&n; *      @level: the level of port suspension, as per uart_suspend_port&n; *&n; *&t;Suspend one serial port.&n; */
DECL|function|serial8250_suspend_port
r_void
id|serial8250_suspend_port
c_func
(paren
r_int
id|line
)paren
(brace
id|uart_suspend_port
c_func
(paren
op_amp
id|serial8250_reg
comma
op_amp
id|serial8250_ports
(braket
id|line
)braket
dot
id|port
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;serial8250_resume_port - resume one serial port&n; *&t;@line:  serial line number&n; *      @level: the level of port resumption, as per uart_resume_port&n; *&n; *&t;Resume one serial port.&n; */
DECL|function|serial8250_resume_port
r_void
id|serial8250_resume_port
c_func
(paren
r_int
id|line
)paren
(brace
id|uart_resume_port
c_func
(paren
op_amp
id|serial8250_reg
comma
op_amp
id|serial8250_ports
(braket
id|line
)braket
dot
id|port
)paren
suffix:semicolon
)brace
DECL|function|serial8250_init
r_static
r_int
id|__init
id|serial8250_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
comma
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Serial: 8250/16550 driver $Revision: 1.90 $ &quot;
l_string|&quot;%d ports, IRQ sharing %sabled&bslash;n&quot;
comma
(paren
r_int
)paren
id|UART_NR
comma
id|share_irqs
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
id|spin_lock_init
c_func
(paren
op_amp
id|irq_lists
(braket
id|i
)braket
dot
id|lock
)paren
suffix:semicolon
id|ret
op_assign
id|uart_register_driver
c_func
(paren
op_amp
id|serial8250_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
id|serial8250_register_ports
c_func
(paren
op_amp
id|serial8250_reg
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|serial8250_exit
r_static
r_void
id|__exit
id|serial8250_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UART_NR
suffix:semicolon
id|i
op_increment
)paren
id|uart_remove_one_port
c_func
(paren
op_amp
id|serial8250_reg
comma
op_amp
id|serial8250_ports
(braket
id|i
)braket
dot
id|port
)paren
suffix:semicolon
id|uart_unregister_driver
c_func
(paren
op_amp
id|serial8250_reg
)paren
suffix:semicolon
)brace
DECL|variable|serial8250_init
id|module_init
c_func
(paren
id|serial8250_init
)paren
suffix:semicolon
DECL|variable|serial8250_exit
id|module_exit
c_func
(paren
id|serial8250_exit
)paren
suffix:semicolon
DECL|variable|register_serial
id|EXPORT_SYMBOL
c_func
(paren
id|register_serial
)paren
suffix:semicolon
DECL|variable|unregister_serial
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_serial
)paren
suffix:semicolon
DECL|variable|serial8250_get_irq_map
id|EXPORT_SYMBOL
c_func
(paren
id|serial8250_get_irq_map
)paren
suffix:semicolon
DECL|variable|serial8250_suspend_port
id|EXPORT_SYMBOL
c_func
(paren
id|serial8250_suspend_port
)paren
suffix:semicolon
DECL|variable|serial8250_resume_port
id|EXPORT_SYMBOL
c_func
(paren
id|serial8250_resume_port
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Generic 8250/16x50 serial driver $Revision: 1.90 $&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|share_irqs
comma
id|uint
comma
l_int|0644
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|share_irqs
comma
l_string|&quot;Share IRQs with other non-8250/16x50 devices&quot;
l_string|&quot; (unsafe)&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SERIAL_8250_RSA
id|module_param_array
c_func
(paren
id|probe_rsa
comma
id|ulong
comma
id|probe_rsa_count
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|probe_rsa
comma
l_string|&quot;Probe I/O ports for RSA&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|TTY_MAJOR
id|MODULE_ALIAS_CHARDEV_MAJOR
c_func
(paren
id|TTY_MAJOR
)paren
suffix:semicolon
eof
