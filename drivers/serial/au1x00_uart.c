multiline_comment|/*&n; *  Driver for 8250/16550-type serial ports&n; *&n; *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts&squot;o.&n; *&n; *  Copyright (C) 2001 Russell King.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * A note about mapbase / membase&n; *&n; *  mapbase is the physical address of the IO port.  Currently, we don&squot;t&n; *  support this very well, and it may well be dropped from this driver&n; *  in future.  As such, mapbase should be NULL.&n; *&n; *  membase is an &squot;ioremapped&squot; cookie.  This is compatible with the old&n; *  serial.c driver, and is currently the preferred form.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/sysrq.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/serialP.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/serial.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/mach-au1x00/au1000.h&gt;
macro_line|#if defined(CONFIG_SERIAL_AU1X00_CONSOLE) &amp;&amp; defined(CONFIG_MAGIC_SYSRQ)
DECL|macro|SUPPORT_SYSRQ
mdefine_line|#define SUPPORT_SYSRQ
macro_line|#endif
macro_line|#include &lt;linux/serial_core.h&gt;
macro_line|#include &quot;8250.h&quot;
multiline_comment|/*&n; * Debugging.&n; */
macro_line|#if 0
mdefine_line|#define DEBUG_AUTOCONF(fmt...)&t;printk(fmt)
macro_line|#else
DECL|macro|DEBUG_AUTOCONF
mdefine_line|#define DEBUG_AUTOCONF(fmt...)&t;do { } while (0)
macro_line|#endif
macro_line|#if 0
mdefine_line|#define DEBUG_INTR(fmt...)&t;printk(fmt)
macro_line|#else
DECL|macro|DEBUG_INTR
mdefine_line|#define DEBUG_INTR(fmt...)&t;do { } while (0)
macro_line|#endif
DECL|macro|PASS_LIMIT
mdefine_line|#define PASS_LIMIT&t;256
multiline_comment|/*&n; * We default to IRQ0 for the &quot;no irq&quot; hack.   Some&n; * machine types want others as well - they&squot;re free&n; * to redefine this in their header file.&n; */
DECL|macro|is_real_interrupt
mdefine_line|#define is_real_interrupt(irq)&t;((irq) != 0)
DECL|variable|old_serial_port
r_static
r_struct
id|old_serial_port
id|old_serial_port
(braket
)braket
op_assign
(brace
(brace
dot
id|baud_base
op_assign
l_int|0
comma
dot
id|iomem_base
op_assign
(paren
id|u8
op_star
)paren
id|UART0_ADDR
comma
dot
id|irq
op_assign
id|AU1000_UART0_INT
comma
dot
id|flags
op_assign
id|STD_COM_FLAGS
comma
dot
id|iomem_reg_shift
op_assign
l_int|2
comma
)brace
comma
(brace
dot
id|baud_base
op_assign
l_int|0
comma
dot
id|iomem_base
op_assign
(paren
id|u8
op_star
)paren
id|UART1_ADDR
comma
dot
id|irq
op_assign
id|AU1000_UART1_INT
comma
dot
id|flags
op_assign
id|STD_COM_FLAGS
comma
dot
id|iomem_reg_shift
op_assign
l_int|2
)brace
comma
(brace
dot
id|baud_base
op_assign
l_int|0
comma
dot
id|iomem_base
op_assign
(paren
id|u8
op_star
)paren
id|UART2_ADDR
comma
dot
id|irq
op_assign
id|AU1000_UART2_INT
comma
dot
id|flags
op_assign
id|STD_COM_FLAGS
comma
dot
id|iomem_reg_shift
op_assign
l_int|2
)brace
comma
(brace
dot
id|baud_base
op_assign
l_int|0
comma
dot
id|iomem_base
op_assign
(paren
id|u8
op_star
)paren
id|UART3_ADDR
comma
dot
id|irq
op_assign
id|AU1000_UART3_INT
comma
dot
id|flags
op_assign
id|STD_COM_FLAGS
comma
dot
id|iomem_reg_shift
op_assign
l_int|2
)brace
)brace
suffix:semicolon
DECL|macro|UART_NR
mdefine_line|#define UART_NR&t;ARRAY_SIZE(old_serial_port)
DECL|struct|uart_8250_port
r_struct
id|uart_8250_port
(brace
DECL|member|port
r_struct
id|uart_port
id|port
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* &quot;no irq&quot; timer */
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
multiline_comment|/* ports on this IRQ */
DECL|member|rev
r_int
r_int
id|rev
suffix:semicolon
DECL|member|acr
r_int
r_char
id|acr
suffix:semicolon
DECL|member|ier
r_int
r_char
id|ier
suffix:semicolon
DECL|member|lcr
r_int
r_char
id|lcr
suffix:semicolon
DECL|member|mcr_mask
r_int
r_char
id|mcr_mask
suffix:semicolon
multiline_comment|/* mask of user bits */
DECL|member|mcr_force
r_int
r_char
id|mcr_force
suffix:semicolon
multiline_comment|/* mask of forced bits */
DECL|member|lsr_break_flag
r_int
r_char
id|lsr_break_flag
suffix:semicolon
multiline_comment|/*&n;&t; * We provide a per-port pm hook.&n;&t; */
DECL|member|pm
r_void
(paren
op_star
id|pm
)paren
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|state
comma
r_int
r_int
id|old
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|irq_info
r_struct
id|irq_info
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|head
r_struct
id|list_head
op_star
id|head
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|irq_lists
r_static
r_struct
id|irq_info
id|irq_lists
(braket
id|NR_IRQS
)braket
suffix:semicolon
multiline_comment|/*&n; * Here we define the default xmit fifo size used for each type of UART.&n; */
DECL|variable|uart_config
r_static
r_const
r_struct
id|serial_uart_config
id|uart_config
(braket
id|PORT_MAX_8250
op_plus
l_int|1
)braket
op_assign
(brace
(brace
l_string|&quot;unknown&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;8250&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;16450&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;16550&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
multiline_comment|/* PORT_16550A */
(brace
l_string|&quot;AU1X00_UART&quot;
comma
l_int|16
comma
id|UART_CLEAR_FIFO
op_or
id|UART_USE_FIFO
)brace
comma
)brace
suffix:semicolon
DECL|function|serial_in
r_static
id|_INLINE_
r_int
r_int
id|serial_in
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_int
id|offset
)paren
(brace
r_return
id|au_readl
c_func
(paren
(paren
r_int
r_int
)paren
id|up-&gt;port.membase
op_plus
id|offset
)paren
suffix:semicolon
)brace
r_static
id|_INLINE_
r_void
DECL|function|serial_out
id|serial_out
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_int
id|offset
comma
r_int
id|value
)paren
(brace
id|au_writel
c_func
(paren
id|value
comma
(paren
r_int
r_int
)paren
id|up-&gt;port.membase
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|macro|serial_inp
mdefine_line|#define serial_inp(up, offset)&t;&t;serial_in(up, offset)
DECL|macro|serial_outp
mdefine_line|#define serial_outp(up, offset, value)&t;serial_out(up, offset, value)
multiline_comment|/*&n; * This routine is called by rs_init() to initialize a specific serial&n; * port.  It determines what type of UART chip this serial port is&n; * using: 8250, 16450, 16550, 16550A.  The important question is&n; * whether or not this UART is a 16550A or not, since this will&n; * determine whether or not we can use its FIFO features or not.&n; */
DECL|function|autoconfig
r_static
r_void
id|autoconfig
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_int
r_int
id|probeflags
)paren
(brace
r_int
r_char
id|save_lcr
comma
id|save_mcr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|up-&gt;port.iobase
op_logical_and
op_logical_neg
id|up-&gt;port.mapbase
op_logical_and
op_logical_neg
id|up-&gt;port.membase
)paren
r_return
suffix:semicolon
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;ttyS%d: autoconf (0x%04x, 0x%08lx): &quot;
comma
id|up-&gt;port.line
comma
id|up-&gt;port.iobase
comma
id|up-&gt;port.membase
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We really do need global IRQs disabled here - we&squot;re going to&n;&t; * be frobbing the chips IRQ enable register to see if it exists.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|//&t;save_flags(flags); cli();
id|save_mcr
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_MCR
)paren
suffix:semicolon
id|save_lcr
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_LCR
)paren
suffix:semicolon
id|up-&gt;port.type
op_assign
id|PORT_16550A
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|save_lcr
)paren
suffix:semicolon
id|up-&gt;port.fifosize
op_assign
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|dfl_xmit_fifo_size
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_UNKNOWN
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Reset the UART.&n;&t; */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|save_mcr
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
(paren
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
)paren
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|//&t;restore_flags(flags);
id|DEBUG_AUTOCONF
c_func
(paren
l_string|&quot;type=%s&bslash;n&quot;
comma
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|name
)paren
suffix:semicolon
)brace
DECL|function|serial8250_stop_tx
r_static
r_void
id|serial8250_stop_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|tty_stop
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;ier
op_amp
id|UART_IER_THRI
)paren
(brace
id|up-&gt;ier
op_and_assign
op_complement
id|UART_IER_THRI
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
)brace
)brace
DECL|function|serial8250_start_tx
r_static
r_void
id|serial8250_start_tx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|tty_start
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|up-&gt;ier
op_amp
id|UART_IER_THRI
)paren
)paren
(brace
id|up-&gt;ier
op_or_assign
id|UART_IER_THRI
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
)brace
)brace
DECL|function|serial8250_stop_rx
r_static
r_void
id|serial8250_stop_rx
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
id|up-&gt;ier
op_and_assign
op_complement
id|UART_IER_RLSI
suffix:semicolon
id|up-&gt;port.read_status_mask
op_and_assign
op_complement
id|UART_LSR_DR
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
)brace
DECL|function|serial8250_enable_ms
r_static
r_void
id|serial8250_enable_ms
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
id|up-&gt;ier
op_or_assign
id|UART_IER_MSI
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
)brace
r_static
id|_INLINE_
r_void
DECL|function|receive_chars
id|receive_chars
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_int
op_star
id|status
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|up-&gt;port.info-&gt;tty
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_int
id|max_count
op_assign
l_int|256
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
)paren
(brace
id|tty-&gt;flip.work
dot
id|func
c_func
(paren
(paren
r_void
op_star
)paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
r_return
suffix:semicolon
singleline_comment|// if TTY_DONT_FLIP is set
)brace
id|ch
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_assign
id|ch
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_NORMAL
suffix:semicolon
id|up-&gt;port.icount.rx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_star
id|status
op_amp
(paren
id|UART_LSR_BI
op_or
id|UART_LSR_PE
op_or
id|UART_LSR_FE
op_or
id|UART_LSR_OE
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * For statistics only&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_BI
)paren
(brace
op_star
id|status
op_and_assign
op_complement
(paren
id|UART_LSR_FE
op_or
id|UART_LSR_PE
)paren
suffix:semicolon
id|up-&gt;port.icount.brk
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * We do the SysRQ and SAK checking&n;&t;&t;&t;&t; * here because otherwise the break&n;&t;&t;&t;&t; * may get masked by ignore_status_mask&n;&t;&t;&t;&t; * or read_status_mask.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|uart_handle_break
c_func
(paren
op_amp
id|up-&gt;port
)paren
)paren
r_goto
id|ignore_char
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_PE
)paren
id|up-&gt;port.icount.parity
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_FE
)paren
id|up-&gt;port.icount.frame
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_OE
)paren
id|up-&gt;port.icount.overrun
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Mask off conditions which should be ingored.&n;&t;&t;&t; */
op_star
id|status
op_and_assign
id|up-&gt;port.read_status_mask
suffix:semicolon
macro_line|#ifdef CONFIG_SERIAL_AU1X00_CONSOLE
r_if
c_cond
(paren
id|up-&gt;port.line
op_eq
id|up-&gt;port.cons-&gt;index
)paren
(brace
multiline_comment|/* Recover the break flag from console xmit */
op_star
id|status
op_or_assign
id|up-&gt;lsr_break_flag
suffix:semicolon
id|up-&gt;lsr_break_flag
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_BI
)paren
(brace
id|DEBUG_INTR
c_func
(paren
l_string|&quot;handling break....&quot;
)paren
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_BREAK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_PE
)paren
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_PARITY
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|status
op_amp
id|UART_LSR_FE
)paren
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_FRAME
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uart_handle_sysrq_char
c_func
(paren
op_amp
id|up-&gt;port
comma
id|ch
comma
id|regs
)paren
)paren
r_goto
id|ignore_char
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|status
op_amp
id|up-&gt;port.ignore_status_mask
)paren
op_eq
l_int|0
)paren
(brace
id|tty-&gt;flip.flag_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|status
op_amp
id|UART_LSR_OE
)paren
op_logical_and
id|tty-&gt;flip.count
OL
id|TTY_FLIPBUF_SIZE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Overrun is special, since it&squot;s reported&n;&t;&t;&t; * immediately, and doesn&squot;t affect the current&n;&t;&t;&t; * character.&n;&t;&t;&t; */
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_OVERRUN
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.count
op_increment
suffix:semicolon
)brace
id|ignore_char
suffix:colon
op_star
id|status
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
op_star
id|status
op_amp
id|UART_LSR_DR
)paren
op_logical_and
(paren
id|max_count
op_decrement
OG
l_int|0
)paren
)paren
suffix:semicolon
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|transmit_chars
r_static
id|_INLINE_
r_void
id|transmit_chars
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_struct
id|circ_buf
op_star
id|xmit
op_assign
op_amp
id|up-&gt;port.info-&gt;xmit
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.x_char
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_TX
comma
id|up-&gt;port.x_char
)paren
suffix:semicolon
id|up-&gt;port.icount.tx
op_increment
suffix:semicolon
id|up-&gt;port.x_char
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
id|xmit
)paren
op_logical_or
id|uart_tx_stopped
c_func
(paren
op_amp
id|up-&gt;port
)paren
)paren
(brace
id|serial8250_stop_tx
c_func
(paren
op_amp
id|up-&gt;port
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|count
op_assign
id|up-&gt;port.fifosize
suffix:semicolon
r_do
(brace
id|serial_out
c_func
(paren
id|up
comma
id|UART_TX
comma
id|xmit-&gt;buf
(braket
id|xmit-&gt;tail
)braket
)paren
suffix:semicolon
id|xmit-&gt;tail
op_assign
(paren
id|xmit-&gt;tail
op_plus
l_int|1
)paren
op_amp
(paren
id|UART_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|up-&gt;port.icount.tx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
id|xmit
)paren
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_chars_pending
c_func
(paren
id|xmit
)paren
OL
id|WAKEUP_CHARS
)paren
id|uart_write_wakeup
c_func
(paren
op_amp
id|up-&gt;port
)paren
suffix:semicolon
id|DEBUG_INTR
c_func
(paren
l_string|&quot;THRE...&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uart_circ_empty
c_func
(paren
id|xmit
)paren
)paren
id|serial8250_stop_tx
c_func
(paren
op_amp
id|up-&gt;port
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|check_modem_status
r_static
id|_INLINE_
r_void
id|check_modem_status
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|UART_MSR_ANY_DELTA
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_TERI
)paren
id|up-&gt;port.icount.rng
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DDSR
)paren
id|up-&gt;port.icount.dsr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DDCD
)paren
id|uart_handle_dcd_change
c_func
(paren
op_amp
id|up-&gt;port
comma
id|status
op_amp
id|UART_MSR_DCD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DCTS
)paren
id|uart_handle_cts_change
c_func
(paren
op_amp
id|up-&gt;port
comma
id|status
op_amp
id|UART_MSR_CTS
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|up-&gt;port.info-&gt;delta_msr_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This handles the interrupt from one port.&n; */
r_static
r_inline
r_void
DECL|function|serial8250_handle_port
id|serial8250_handle_port
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|status
op_assign
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
id|DEBUG_INTR
c_func
(paren
l_string|&quot;status = %x...&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_LSR_DR
)paren
id|receive_chars
c_func
(paren
id|up
comma
op_amp
id|status
comma
id|regs
)paren
suffix:semicolon
id|check_modem_status
c_func
(paren
id|up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_LSR_THRE
)paren
id|transmit_chars
c_func
(paren
id|up
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the serial driver&squot;s interrupt routine.&n; *&n; * Arjan thinks the old way was overly complex, so it got simplified.&n; * Alan disagrees, saying that need the complexity to handle the weird&n; * nature of ISA shared interrupts.  (This is a special exception.)&n; *&n; * In order to handle ISA shared interrupts properly, we need to check&n; * that all ports have been serviced, and therefore the ISA interrupt&n; * line has been de-asserted.&n; *&n; * This means we need to loop through all ports. checking that they&n; * don&squot;t have an interrupt pending.&n; */
DECL|function|serial8250_interrupt
r_static
id|irqreturn_t
id|serial8250_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irq_info
op_star
id|i
op_assign
id|dev_id
suffix:semicolon
r_struct
id|list_head
op_star
id|l
comma
op_star
id|end
op_assign
l_int|NULL
suffix:semicolon
r_int
id|pass_counter
op_assign
l_int|0
suffix:semicolon
id|DEBUG_INTR
c_func
(paren
l_string|&quot;serial8250_interrupt(%d)...&quot;
comma
id|irq
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
id|l
op_assign
id|i-&gt;head
suffix:semicolon
r_do
(brace
r_struct
id|uart_8250_port
op_star
id|up
suffix:semicolon
r_int
r_int
id|iir
suffix:semicolon
id|up
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|uart_8250_port
comma
id|list
)paren
suffix:semicolon
id|iir
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IIR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iir
op_amp
id|UART_IIR_NO_INT
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
id|serial8250_handle_port
c_func
(paren
id|up
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
id|end
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|end
op_eq
l_int|NULL
)paren
id|end
op_assign
id|l
suffix:semicolon
id|l
op_assign
id|l-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
id|i-&gt;head
op_logical_and
id|pass_counter
op_increment
OG
id|PASS_LIMIT
)paren
(brace
multiline_comment|/* If we hit this, we&squot;re dead. */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;serial8250: too much work for &quot;
l_string|&quot;irq%d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|l
op_ne
id|end
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
id|DEBUG_INTR
c_func
(paren
l_string|&quot;end.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME! Was it really ours? */
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; * To support ISA shared interrupts, we need to have one interrupt&n; * handler that ensures that the IRQ line has been deasserted&n; * before returning.  Failing to do this will result in the IRQ&n; * line being stuck active, and, since ISA irqs are edge triggered,&n; * no more IRQs will be seen.&n; */
DECL|function|serial_do_unlink
r_static
r_void
id|serial_do_unlink
c_func
(paren
r_struct
id|irq_info
op_star
id|i
comma
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|i-&gt;head
)paren
)paren
(brace
r_if
c_cond
(paren
id|i-&gt;head
op_eq
op_amp
id|up-&gt;list
)paren
id|i-&gt;head
op_assign
id|i-&gt;head-&gt;next
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|up-&gt;list
)paren
suffix:semicolon
)brace
r_else
(brace
id|BUG_ON
c_func
(paren
id|i-&gt;head
op_ne
op_amp
id|up-&gt;list
)paren
suffix:semicolon
id|i-&gt;head
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|serial_link_irq_chain
r_static
r_int
id|serial_link_irq_chain
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_struct
id|irq_info
op_star
id|i
op_assign
id|irq_lists
op_plus
id|up-&gt;port.irq
suffix:semicolon
r_int
id|ret
comma
id|irq_flags
op_assign
id|up-&gt;port.flags
op_amp
id|UPF_SHARE_IRQ
ques
c_cond
id|SA_SHIRQ
suffix:colon
l_int|0
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i-&gt;head
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|up-&gt;list
comma
id|i-&gt;head
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|up-&gt;list
)paren
suffix:semicolon
id|i-&gt;head
op_assign
op_amp
id|up-&gt;list
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|i-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
id|request_irq
c_func
(paren
id|up-&gt;port.irq
comma
id|serial8250_interrupt
comma
id|irq_flags
comma
l_string|&quot;serial&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|serial_do_unlink
c_func
(paren
id|i
comma
id|up
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|serial_unlink_irq_chain
r_static
r_void
id|serial_unlink_irq_chain
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_struct
id|irq_info
op_star
id|i
op_assign
id|irq_lists
op_plus
id|up-&gt;port.irq
suffix:semicolon
id|BUG_ON
c_func
(paren
id|i-&gt;head
op_eq
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|i-&gt;head
)paren
)paren
id|free_irq
c_func
(paren
id|up-&gt;port.irq
comma
id|i
)paren
suffix:semicolon
id|serial_do_unlink
c_func
(paren
id|i
comma
id|up
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is used to handle ports that do not have an&n; * interrupt.  This doesn&squot;t work very well for 16450&squot;s, but gives&n; * barely passable results for a 16550A.  (Although at the expense&n; * of much CPU overhead).&n; */
DECL|function|serial8250_timeout
r_static
r_void
id|serial8250_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|data
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|iir
suffix:semicolon
id|iir
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IIR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iir
op_amp
id|UART_IIR_NO_INT
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
id|serial8250_handle_port
c_func
(paren
id|up
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|up-&gt;port.lock
)paren
suffix:semicolon
)brace
id|timeout
op_assign
id|up-&gt;port.timeout
suffix:semicolon
id|timeout
op_assign
id|timeout
OG
l_int|6
ques
c_cond
(paren
id|timeout
op_div
l_int|2
op_minus
l_int|2
)paren
suffix:colon
l_int|1
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|up-&gt;timer
comma
id|jiffies
op_plus
id|timeout
)paren
suffix:semicolon
)brace
DECL|function|serial8250_tx_empty
r_static
r_int
r_int
id|serial8250_tx_empty
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_LSR
)paren
op_amp
id|UART_LSR_TEMT
ques
c_cond
id|TIOCSER_TEMT
suffix:colon
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|serial8250_get_mctrl
r_static
r_int
r_int
id|serial8250_get_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DCD
)paren
id|ret
op_or_assign
id|TIOCM_CAR
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_RI
)paren
id|ret
op_or_assign
id|TIOCM_RNG
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_DSR
)paren
id|ret
op_or_assign
id|TIOCM_DSR
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_MSR_CTS
)paren
id|ret
op_or_assign
id|TIOCM_CTS
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|serial8250_set_mctrl
r_static
r_void
id|serial8250_set_mctrl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|mctrl
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_char
id|mcr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_RTS
)paren
id|mcr
op_or_assign
id|UART_MCR_RTS
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_DTR
)paren
id|mcr
op_or_assign
id|UART_MCR_DTR
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_OUT1
)paren
id|mcr
op_or_assign
id|UART_MCR_OUT1
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_OUT2
)paren
id|mcr
op_or_assign
id|UART_MCR_OUT2
suffix:semicolon
r_if
c_cond
(paren
id|mctrl
op_amp
id|TIOCM_LOOP
)paren
id|mcr
op_or_assign
id|UART_MCR_LOOP
suffix:semicolon
id|mcr
op_assign
(paren
id|mcr
op_amp
id|up-&gt;mcr_mask
)paren
op_or
id|up-&gt;mcr_force
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_MCR
comma
id|mcr
)paren
suffix:semicolon
)brace
DECL|function|serial8250_break_ctl
r_static
r_void
id|serial8250_break_ctl
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
id|break_state
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|break_state
op_eq
op_minus
l_int|1
)paren
id|up-&gt;lcr
op_or_assign
id|UART_LCR_SBC
suffix:semicolon
r_else
id|up-&gt;lcr
op_and_assign
op_complement
id|UART_LCR_SBC
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|up-&gt;lcr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|serial8250_startup
r_static
r_int
id|serial8250_startup
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the FIFO buffers and disable them.&n;&t; * (they will be reeanbled in set_termios())&n;&t; */
r_if
c_cond
(paren
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|flags
op_amp
id|UART_CLEAR_FIFO
)paren
(brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear the interrupt registers.&n;&t; */
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IIR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, there&squot;s no way the LSR could still be 0xff;&n;&t; * if it is, then bail out, because there&squot;s likely no UART&n;&t; * here.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|up-&gt;port.flags
op_amp
id|UPF_BUGGY_UART
)paren
op_logical_and
(paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
op_eq
l_int|0xff
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ttyS%d: LSR safety check engaged!&bslash;n&quot;
comma
id|up-&gt;port.line
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|retval
op_assign
id|serial_link_irq_chain
c_func
(paren
id|up
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/*&n;&t; * Now, initialize the UART&n;&t; */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|UART_LCR_WLEN8
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|UPF_FOURPORT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_real_interrupt
c_func
(paren
id|up-&gt;port.irq
)paren
)paren
id|up-&gt;port.mctrl
op_or_assign
id|TIOCM_OUT1
suffix:semicolon
)brace
r_else
multiline_comment|/*&n;&t;&t; * Most PC uarts need OUT2 raised to enable interrupts.&n;&t;&t; */
r_if
c_cond
(paren
id|is_real_interrupt
c_func
(paren
id|up-&gt;port.irq
)paren
)paren
id|up-&gt;port.mctrl
op_or_assign
id|TIOCM_OUT2
suffix:semicolon
id|serial8250_set_mctrl
c_func
(paren
op_amp
id|up-&gt;port
comma
id|up-&gt;port.mctrl
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Finally, enable interrupts.  Note: Modem status interrupts&n;&t; * are set via set_termios(), which will be occurring imminently&n;&t; * anyway, so we don&squot;t enable them here.&n;&t; */
id|up-&gt;ier
op_assign
id|UART_IER_RLSI
op_or
id|UART_IER_RDI
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|UPF_FOURPORT
)paren
(brace
r_int
r_int
id|icp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Enable interrupts on the AST Fourport board&n;&t;&t; */
id|icp
op_assign
(paren
id|up-&gt;port.iobase
op_amp
l_int|0xfe0
)paren
op_or
l_int|0x01f
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x80
comma
id|icp
)paren
suffix:semicolon
(paren
r_void
)paren
id|inb_p
c_func
(paren
id|icp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * And clear the interrupt registers again for luck.&n;&t; */
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_IIR
)paren
suffix:semicolon
(paren
r_void
)paren
id|serial_inp
c_func
(paren
id|up
comma
id|UART_MSR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|serial8250_shutdown
r_static
r_void
id|serial8250_shutdown
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Disable interrupts from this port&n;&t; */
id|up-&gt;ier
op_assign
l_int|0
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|UPF_FOURPORT
)paren
(brace
multiline_comment|/* reset interrupts on the AST Fourport board */
id|inb
c_func
(paren
(paren
id|up-&gt;port.iobase
op_amp
l_int|0xfe0
)paren
op_or
l_int|0x1f
)paren
suffix:semicolon
id|up-&gt;port.mctrl
op_or_assign
id|TIOCM_OUT1
suffix:semicolon
)brace
r_else
id|up-&gt;port.mctrl
op_and_assign
op_complement
id|TIOCM_OUT2
suffix:semicolon
id|serial8250_set_mctrl
c_func
(paren
op_amp
id|up-&gt;port
comma
id|up-&gt;port.mctrl
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable break condition and FIFOs&n;&t; */
id|serial_out
c_func
(paren
id|up
comma
id|UART_LCR
comma
id|serial_inp
c_func
(paren
id|up
comma
id|UART_LCR
)paren
op_amp
op_complement
id|UART_LCR_SBC
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read data port to reset things, and then unlink from&n;&t; * the IRQ chain.&n;&t; */
(paren
r_void
)paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_RX
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_real_interrupt
c_func
(paren
id|up-&gt;port.irq
)paren
)paren
id|del_timer_sync
c_func
(paren
op_amp
id|up-&gt;timer
)paren
suffix:semicolon
r_else
id|serial_unlink_irq_chain
c_func
(paren
id|up
)paren
suffix:semicolon
)brace
DECL|function|serial8250_get_divisor
r_static
r_int
r_int
id|serial8250_get_divisor
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|baud
)paren
(brace
r_int
r_int
id|quot
suffix:semicolon
multiline_comment|/*&n;&t; * Handle magic divisors for baud rates above baud_base on&n;&t; * SMSC SuperIO chips.&n;&t; */
r_if
c_cond
(paren
(paren
id|port-&gt;flags
op_amp
id|UPF_MAGIC_MULTIPLIER
)paren
op_logical_and
id|baud
op_eq
(paren
id|port-&gt;uartclk
op_div
l_int|4
)paren
)paren
id|quot
op_assign
l_int|0x8001
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|port-&gt;flags
op_amp
id|UPF_MAGIC_MULTIPLIER
)paren
op_logical_and
id|baud
op_eq
(paren
id|port-&gt;uartclk
op_div
l_int|8
)paren
)paren
id|quot
op_assign
l_int|0x8002
suffix:semicolon
r_else
id|quot
op_assign
id|uart_get_divisor
c_func
(paren
id|port
comma
id|baud
)paren
suffix:semicolon
r_return
id|quot
suffix:semicolon
)brace
r_static
r_void
DECL|function|serial8250_set_termios
id|serial8250_set_termios
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|termios
op_star
id|termios
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_char
id|cval
comma
id|fcr
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|baud
comma
id|quot
suffix:semicolon
r_switch
c_cond
(paren
id|termios-&gt;c_cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|cval
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|cval
op_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|cval
op_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
id|CS8
suffix:colon
id|cval
op_assign
l_int|0x03
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|termios-&gt;c_cflag
op_amp
id|CSTOPB
)paren
id|cval
op_or_assign
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
id|termios-&gt;c_cflag
op_amp
id|PARENB
)paren
id|cval
op_or_assign
id|UART_LCR_PARITY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|termios-&gt;c_cflag
op_amp
id|PARODD
)paren
)paren
id|cval
op_or_assign
id|UART_LCR_EPAR
suffix:semicolon
macro_line|#ifdef CMSPAR
r_if
c_cond
(paren
id|termios-&gt;c_cflag
op_amp
id|CMSPAR
)paren
id|cval
op_or_assign
id|UART_LCR_SPAR
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Ask the core to calculate the divisor for us.&n;&t; */
id|baud
op_assign
id|uart_get_baud_rate
c_func
(paren
id|port
comma
id|termios
comma
id|old
comma
l_int|0
comma
id|port-&gt;uartclk
op_div
l_int|16
)paren
suffix:semicolon
id|quot
op_assign
id|serial8250_get_divisor
c_func
(paren
id|port
comma
id|baud
)paren
suffix:semicolon
id|quot
op_assign
l_int|0x35
suffix:semicolon
multiline_comment|/* FIXME */
multiline_comment|/*&n;&t; * Work around a bug in the Oxford Semiconductor 952 rev B&n;&t; * chip which causes it to seriously miscalculate baud rates&n;&t; * when DLL is 0.&n;&t; */
r_if
c_cond
(paren
(paren
id|quot
op_amp
l_int|0xff
)paren
op_eq
l_int|0
op_logical_and
id|up-&gt;port.type
op_eq
id|PORT_16C950
op_logical_and
id|up-&gt;rev
op_eq
l_int|0x5201
)paren
id|quot
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|uart_config
(braket
id|up-&gt;port.type
)braket
dot
id|flags
op_amp
id|UART_USE_FIFO
)paren
(brace
r_if
c_cond
(paren
id|baud
OL
l_int|2400
)paren
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_R_TRIGGER_1
suffix:semicolon
r_else
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_R_TRIGGER_8
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ok, we&squot;re now changing the port state.  Do it with&n;&t; * interrupts disabled.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update the per-port timeout.&n;&t; */
id|uart_update_timeout
c_func
(paren
id|port
comma
id|termios-&gt;c_cflag
comma
id|baud
)paren
suffix:semicolon
id|up-&gt;port.read_status_mask
op_assign
id|UART_LSR_OE
op_or
id|UART_LSR_THRE
op_or
id|UART_LSR_DR
suffix:semicolon
r_if
c_cond
(paren
id|termios-&gt;c_iflag
op_amp
id|INPCK
)paren
id|up-&gt;port.read_status_mask
op_or_assign
id|UART_LSR_FE
op_or
id|UART_LSR_PE
suffix:semicolon
r_if
c_cond
(paren
id|termios-&gt;c_iflag
op_amp
(paren
id|BRKINT
op_or
id|PARMRK
)paren
)paren
id|up-&gt;port.read_status_mask
op_or_assign
id|UART_LSR_BI
suffix:semicolon
multiline_comment|/*&n;&t; * Characteres to ignore&n;&t; */
id|up-&gt;port.ignore_status_mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|termios-&gt;c_iflag
op_amp
id|IGNPAR
)paren
id|up-&gt;port.ignore_status_mask
op_or_assign
id|UART_LSR_PE
op_or
id|UART_LSR_FE
suffix:semicolon
r_if
c_cond
(paren
id|termios-&gt;c_iflag
op_amp
id|IGNBRK
)paren
(brace
id|up-&gt;port.ignore_status_mask
op_or_assign
id|UART_LSR_BI
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;re ignoring parity and break indicators,&n;&t;&t; * ignore overruns too (for real raw support).&n;&t;&t; */
r_if
c_cond
(paren
id|termios-&gt;c_iflag
op_amp
id|IGNPAR
)paren
id|up-&gt;port.ignore_status_mask
op_or_assign
id|UART_LSR_OE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ignore all characters if CREAD is not set&n;&t; */
r_if
c_cond
(paren
(paren
id|termios-&gt;c_cflag
op_amp
id|CREAD
)paren
op_eq
l_int|0
)paren
id|up-&gt;port.ignore_status_mask
op_or_assign
id|UART_LSR_DR
suffix:semicolon
multiline_comment|/*&n;&t; * CTS flow control flag and modem status interrupts&n;&t; */
id|up-&gt;ier
op_and_assign
op_complement
id|UART_IER_MSI
suffix:semicolon
r_if
c_cond
(paren
id|UART_ENABLE_MS
c_func
(paren
op_amp
id|up-&gt;port
comma
id|termios-&gt;c_cflag
)paren
)paren
id|up-&gt;ier
op_or_assign
id|UART_IER_MSI
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|up-&gt;ier
)paren
suffix:semicolon
id|serial_outp
c_func
(paren
id|up
comma
l_int|0x28
comma
id|quot
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|up-&gt;lcr
op_assign
id|cval
suffix:semicolon
multiline_comment|/* Save LCR */
r_if
c_cond
(paren
id|up-&gt;port.type
op_ne
id|PORT_16750
)paren
(brace
r_if
c_cond
(paren
id|fcr
op_amp
id|UART_FCR_ENABLE_FIFO
)paren
(brace
multiline_comment|/* emulated UARTs (Lucent Venus 167x) need two steps */
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
)brace
id|serial_outp
c_func
(paren
id|up
comma
id|UART_FCR
comma
id|fcr
)paren
suffix:semicolon
multiline_comment|/* set fcr */
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|up-&gt;port.lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|serial8250_pm
id|serial8250_pm
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
r_int
id|state
comma
r_int
r_int
id|oldstate
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
multiline_comment|/* sleep */
r_if
c_cond
(paren
id|up-&gt;pm
)paren
id|up
op_member_access_from_pointer
id|pm
c_func
(paren
id|port
comma
id|state
comma
id|oldstate
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* wake */
r_if
c_cond
(paren
id|up-&gt;pm
)paren
id|up
op_member_access_from_pointer
id|pm
c_func
(paren
id|port
comma
id|state
comma
id|oldstate
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Resource handling.  This is complicated by the fact that resources&n; * depend on the port type.  Maybe we should be claiming the standard&n; * 8250 ports, and then trying to get other resources as necessary?&n; */
r_static
r_int
DECL|function|serial8250_request_std_resource
id|serial8250_request_std_resource
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
comma
r_struct
id|resource
op_star
op_star
id|res
)paren
(brace
r_int
r_int
id|size
op_assign
l_int|8
op_lshift
id|up-&gt;port.regshift
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|up-&gt;port.iotype
)paren
(brace
r_case
id|SERIAL_IO_MEM
suffix:colon
r_if
c_cond
(paren
id|up-&gt;port.mapbase
)paren
(brace
op_star
id|res
op_assign
id|request_mem_region
c_func
(paren
id|up-&gt;port.mapbase
comma
id|size
comma
l_string|&quot;serial&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|res
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SERIAL_IO_HUB6
suffix:colon
r_case
id|SERIAL_IO_PORT
suffix:colon
op_star
id|res
op_assign
id|request_region
c_func
(paren
id|up-&gt;port.iobase
comma
id|size
comma
l_string|&quot;serial&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|res
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|serial8250_release_port
r_static
r_void
id|serial8250_release_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_int
r_int
id|start
comma
id|offset
op_assign
l_int|0
comma
id|size
op_assign
l_int|0
suffix:semicolon
id|size
op_lshift_assign
id|up-&gt;port.regshift
suffix:semicolon
r_switch
c_cond
(paren
id|up-&gt;port.iotype
)paren
(brace
r_case
id|SERIAL_IO_MEM
suffix:colon
r_if
c_cond
(paren
id|up-&gt;port.mapbase
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Unmap the area.&n;&t;&t;&t; */
id|iounmap
c_func
(paren
id|up-&gt;port.membase
)paren
suffix:semicolon
id|up-&gt;port.membase
op_assign
l_int|NULL
suffix:semicolon
id|start
op_assign
id|up-&gt;port.mapbase
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
id|release_mem_region
c_func
(paren
id|start
op_plus
id|offset
comma
id|size
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|start
comma
l_int|8
op_lshift
id|up-&gt;port.regshift
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SERIAL_IO_HUB6
suffix:colon
r_case
id|SERIAL_IO_PORT
suffix:colon
id|start
op_assign
id|up-&gt;port.iobase
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
id|release_region
c_func
(paren
id|start
op_plus
id|offset
comma
id|size
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|start
op_plus
id|offset
comma
l_int|8
op_lshift
id|up-&gt;port.regshift
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
DECL|function|serial8250_request_port
r_static
r_int
id|serial8250_request_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_struct
id|resource
op_star
id|res
op_assign
l_int|NULL
comma
op_star
id|res_rsa
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|serial8250_request_std_resource
c_func
(paren
id|up
comma
op_amp
id|res
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have a mapbase, then request that as well.&n;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_and
id|up-&gt;port.flags
op_amp
id|UPF_IOREMAP
)paren
(brace
r_int
id|size
op_assign
id|res-&gt;end
op_minus
id|res-&gt;start
op_plus
l_int|1
suffix:semicolon
id|up-&gt;port.membase
op_assign
id|ioremap
c_func
(paren
id|up-&gt;port.mapbase
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|up-&gt;port.membase
)paren
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|res_rsa
)paren
id|release_resource
c_func
(paren
id|res_rsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
id|release_resource
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|serial8250_config_port
r_static
r_void
id|serial8250_config_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_int
id|flags
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
(paren
r_struct
id|uart_8250_port
op_star
)paren
id|port
suffix:semicolon
r_struct
id|resource
op_star
id|res_std
op_assign
l_int|NULL
comma
op_star
id|res_rsa
op_assign
l_int|NULL
suffix:semicolon
r_int
id|probeflags
op_assign
id|PROBE_ANY
suffix:semicolon
id|probeflags
op_and_assign
op_complement
id|PROBE_RSA
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|UART_CONFIG_TYPE
)paren
id|autoconfig
c_func
(paren
id|up
comma
id|probeflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the port wasn&squot;t an RSA port, release the resource.&n;&t; */
r_if
c_cond
(paren
id|up-&gt;port.type
op_ne
id|PORT_RSA
op_logical_and
id|res_rsa
)paren
id|release_resource
c_func
(paren
id|res_rsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;port.type
op_eq
id|PORT_UNKNOWN
op_logical_and
id|res_std
)paren
id|release_resource
c_func
(paren
id|res_std
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|serial8250_verify_port
id|serial8250_verify_port
c_func
(paren
r_struct
id|uart_port
op_star
id|port
comma
r_struct
id|serial_struct
op_star
id|ser
)paren
(brace
r_if
c_cond
(paren
id|ser-&gt;irq
op_ge
id|NR_IRQS
op_logical_or
id|ser-&gt;irq
OL
l_int|0
op_logical_or
id|ser-&gt;baud_base
OL
l_int|9600
op_logical_or
id|ser-&gt;type
template_param
id|PORT_MAX_8250
op_logical_or
id|ser-&gt;type
op_eq
id|PORT_CIRRUS
op_logical_or
id|ser-&gt;type
op_eq
id|PORT_STARTECH
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_const
r_char
op_star
DECL|function|serial8250_type
id|serial8250_type
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
r_int
id|type
op_assign
id|port-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|ARRAY_SIZE
c_func
(paren
id|uart_config
)paren
)paren
id|type
op_assign
l_int|0
suffix:semicolon
r_return
id|uart_config
(braket
id|type
)braket
dot
id|name
suffix:semicolon
)brace
DECL|variable|serial8250_pops
r_static
r_struct
id|uart_ops
id|serial8250_pops
op_assign
(brace
dot
id|tx_empty
op_assign
id|serial8250_tx_empty
comma
dot
id|set_mctrl
op_assign
id|serial8250_set_mctrl
comma
dot
id|get_mctrl
op_assign
id|serial8250_get_mctrl
comma
dot
id|stop_tx
op_assign
id|serial8250_stop_tx
comma
dot
id|start_tx
op_assign
id|serial8250_start_tx
comma
dot
id|stop_rx
op_assign
id|serial8250_stop_rx
comma
dot
id|enable_ms
op_assign
id|serial8250_enable_ms
comma
dot
id|break_ctl
op_assign
id|serial8250_break_ctl
comma
dot
id|startup
op_assign
id|serial8250_startup
comma
dot
id|shutdown
op_assign
id|serial8250_shutdown
comma
dot
id|set_termios
op_assign
id|serial8250_set_termios
comma
dot
id|pm
op_assign
id|serial8250_pm
comma
dot
id|type
op_assign
id|serial8250_type
comma
dot
id|release_port
op_assign
id|serial8250_release_port
comma
dot
id|request_port
op_assign
id|serial8250_request_port
comma
dot
id|config_port
op_assign
id|serial8250_config_port
comma
dot
id|verify_port
op_assign
id|serial8250_verify_port
comma
)brace
suffix:semicolon
DECL|variable|serial8250_ports
r_static
r_struct
id|uart_8250_port
id|serial8250_ports
(braket
id|UART_NR
)braket
suffix:semicolon
DECL|function|serial8250_isa_init_ports
r_static
r_void
id|__init
id|serial8250_isa_init_ports
c_func
(paren
r_void
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
suffix:semicolon
r_static
r_int
id|first
op_assign
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
r_return
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|up
op_assign
id|serial8250_ports
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|old_serial_port
)paren
suffix:semicolon
id|i
op_increment
comma
id|up
op_increment
)paren
(brace
id|up-&gt;port.iobase
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|port
suffix:semicolon
id|up-&gt;port.irq
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|irq
suffix:semicolon
id|up-&gt;port.uartclk
op_assign
id|get_au1x00_uart_baud_base
c_func
(paren
)paren
suffix:semicolon
id|up-&gt;port.flags
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|flags
suffix:semicolon
id|up-&gt;port.hub6
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|hub6
suffix:semicolon
id|up-&gt;port.membase
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|iomem_base
suffix:semicolon
id|up-&gt;port.iotype
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|io_type
suffix:semicolon
id|up-&gt;port.regshift
op_assign
id|old_serial_port
(braket
id|i
)braket
dot
id|iomem_reg_shift
suffix:semicolon
id|up-&gt;port.ops
op_assign
op_amp
id|serial8250_pops
suffix:semicolon
)brace
)brace
DECL|function|serial8250_register_ports
r_static
r_void
id|__init
id|serial8250_register_ports
c_func
(paren
r_struct
id|uart_driver
op_star
id|drv
)paren
(brace
r_int
id|i
suffix:semicolon
id|serial8250_isa_init_ports
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UART_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
op_amp
id|serial8250_ports
(braket
id|i
)braket
suffix:semicolon
id|up-&gt;port.line
op_assign
id|i
suffix:semicolon
id|up-&gt;port.ops
op_assign
op_amp
id|serial8250_pops
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|up-&gt;timer
)paren
suffix:semicolon
id|up-&gt;timer.function
op_assign
id|serial8250_timeout
suffix:semicolon
multiline_comment|/*&n;&t;&t; * ALPHA_KLUDGE_MCR needs to be killed.&n;&t;&t; */
id|up-&gt;mcr_mask
op_assign
op_complement
id|ALPHA_KLUDGE_MCR
suffix:semicolon
id|up-&gt;mcr_force
op_assign
id|ALPHA_KLUDGE_MCR
suffix:semicolon
id|uart_add_one_port
c_func
(paren
id|drv
comma
op_amp
id|up-&gt;port
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_SERIAL_AU1X00_CONSOLE
DECL|macro|BOTH_EMPTY
mdefine_line|#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
multiline_comment|/*&n; *&t;Wait for transmitter &amp; holding register to empty&n; */
DECL|function|wait_for_xmitr
r_static
r_inline
r_void
id|wait_for_xmitr
c_func
(paren
r_struct
id|uart_8250_port
op_star
id|up
)paren
(brace
r_int
r_int
id|status
comma
id|tmout
op_assign
l_int|10000
suffix:semicolon
multiline_comment|/* Wait up to 10ms for the character(s) to be sent. */
r_do
(brace
id|status
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_LSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UART_LSR_BI
)paren
id|up-&gt;lsr_break_flag
op_assign
id|UART_LSR_BI
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|tmout
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|status
op_amp
id|BOTH_EMPTY
)paren
op_ne
id|BOTH_EMPTY
)paren
suffix:semicolon
multiline_comment|/* Wait up to 1s for flow control if necessary */
r_if
c_cond
(paren
id|up-&gt;port.flags
op_amp
id|UPF_CONS_FLOW
)paren
(brace
id|tmout
op_assign
l_int|1000000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|tmout
op_logical_and
(paren
(paren
id|serial_in
c_func
(paren
id|up
comma
id|UART_MSR
)paren
op_amp
id|UART_MSR_CTS
)paren
op_eq
l_int|0
)paren
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Print a string to the serial port trying not to disturb&n; *&t;any possible real use of the port...&n; *&n; *&t;The console_lock must be held when we get here.&n; */
r_static
r_void
DECL|function|serial8250_console_write
id|serial8250_console_write
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_const
r_char
op_star
id|s
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|uart_8250_port
op_star
id|up
op_assign
op_amp
id|serial8250_ports
(braket
id|co-&gt;index
)braket
suffix:semicolon
r_int
r_int
id|ier
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;First save the UER then disable the interrupts&n;&t; */
id|ier
op_assign
id|serial_in
c_func
(paren
id|up
comma
id|UART_IER
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now, do each character&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|s
op_increment
)paren
(brace
id|wait_for_xmitr
c_func
(paren
id|up
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Send the character out.&n;&t;&t; *&t;If a LF, also do CR...&n;&t;&t; */
id|serial_out
c_func
(paren
id|up
comma
id|UART_TX
comma
op_star
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_eq
l_int|10
)paren
(brace
id|wait_for_xmitr
c_func
(paren
id|up
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_TX
comma
l_int|13
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Finally, wait for transmitter to become empty&n;&t; *&t;and restore the IER&n;&t; */
id|wait_for_xmitr
c_func
(paren
id|up
)paren
suffix:semicolon
id|serial_out
c_func
(paren
id|up
comma
id|UART_IER
comma
id|ier
)paren
suffix:semicolon
)brace
DECL|function|serial8250_console_setup
r_static
r_int
id|__init
id|serial8250_console_setup
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_char
op_star
id|options
)paren
(brace
r_struct
id|uart_port
op_star
id|port
suffix:semicolon
r_int
id|baud
op_assign
l_int|9600
suffix:semicolon
r_int
id|bits
op_assign
l_int|8
suffix:semicolon
r_int
id|parity
op_assign
l_char|&squot;n&squot;
suffix:semicolon
r_int
id|flow
op_assign
l_char|&squot;n&squot;
suffix:semicolon
multiline_comment|/*&n;&t; * Check whether an invalid uart number has been specified, and&n;&t; * if so, search for the first available port that does have&n;&t; * console support.&n;&t; */
r_if
c_cond
(paren
id|co-&gt;index
op_ge
id|UART_NR
)paren
id|co-&gt;index
op_assign
l_int|0
suffix:semicolon
id|port
op_assign
op_amp
id|serial8250_ports
(braket
id|co-&gt;index
)braket
dot
id|port
suffix:semicolon
multiline_comment|/*&n;&t; * Temporary fix.&n;&t; */
id|spin_lock_init
c_func
(paren
op_amp
id|port-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|options
)paren
id|uart_parse_options
c_func
(paren
id|options
comma
op_amp
id|baud
comma
op_amp
id|parity
comma
op_amp
id|bits
comma
op_amp
id|flow
)paren
suffix:semicolon
r_return
id|uart_set_options
c_func
(paren
id|port
comma
id|co
comma
id|baud
comma
id|parity
comma
id|bits
comma
id|flow
)paren
suffix:semicolon
)brace
r_extern
r_struct
id|uart_driver
id|serial8250_reg
suffix:semicolon
DECL|variable|serial8250_console
r_static
r_struct
id|console
id|serial8250_console
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ttyS&quot;
comma
dot
id|write
op_assign
id|serial8250_console_write
comma
dot
id|device
op_assign
id|uart_console_device
comma
dot
id|setup
op_assign
id|serial8250_console_setup
comma
dot
id|flags
op_assign
id|CON_PRINTBUFFER
comma
dot
id|index
op_assign
op_minus
l_int|1
comma
dot
id|data
op_assign
op_amp
id|serial8250_reg
comma
)brace
suffix:semicolon
DECL|function|serial8250_console_init
r_static
r_int
id|__init
id|serial8250_console_init
c_func
(paren
r_void
)paren
(brace
id|serial8250_isa_init_ports
c_func
(paren
)paren
suffix:semicolon
id|register_console
c_func
(paren
op_amp
id|serial8250_console
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|serial8250_console_init
id|console_initcall
c_func
(paren
id|serial8250_console_init
)paren
suffix:semicolon
DECL|macro|SERIAL8250_CONSOLE
mdefine_line|#define SERIAL8250_CONSOLE&t;&amp;serial8250_console
macro_line|#else
DECL|macro|SERIAL8250_CONSOLE
mdefine_line|#define SERIAL8250_CONSOLE&t;NULL
macro_line|#endif
DECL|variable|serial8250_reg
r_static
r_struct
id|uart_driver
id|serial8250_reg
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|driver_name
op_assign
l_string|&quot;serial&quot;
comma
dot
id|devfs_name
op_assign
l_string|&quot;tts/&quot;
comma
dot
id|dev_name
op_assign
l_string|&quot;ttyS&quot;
comma
dot
id|major
op_assign
id|TTY_MAJOR
comma
dot
id|minor
op_assign
l_int|64
comma
dot
id|nr
op_assign
id|UART_NR
comma
dot
id|cons
op_assign
id|SERIAL8250_CONSOLE
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * register_serial and unregister_serial allows for 16x50 serial ports to be&n; * configured at run-time, to support PCMCIA modems.&n; */
DECL|function|__register_serial
r_static
r_int
id|__register_serial
c_func
(paren
r_struct
id|serial_struct
op_star
id|req
comma
r_int
id|line
)paren
(brace
r_struct
id|uart_port
id|port
suffix:semicolon
id|port.iobase
op_assign
id|req-&gt;port
suffix:semicolon
id|port.membase
op_assign
id|req-&gt;iomem_base
suffix:semicolon
id|port.irq
op_assign
id|req-&gt;irq
suffix:semicolon
id|port.uartclk
op_assign
id|req-&gt;baud_base
op_star
l_int|16
suffix:semicolon
id|port.fifosize
op_assign
id|req-&gt;xmit_fifo_size
suffix:semicolon
id|port.regshift
op_assign
id|req-&gt;iomem_reg_shift
suffix:semicolon
id|port.iotype
op_assign
id|req-&gt;io_type
suffix:semicolon
id|port.flags
op_assign
id|req-&gt;flags
op_or
id|UPF_BOOT_AUTOCONF
suffix:semicolon
id|port.mapbase
op_assign
id|req-&gt;iomap_base
suffix:semicolon
id|port.line
op_assign
id|line
suffix:semicolon
r_if
c_cond
(paren
id|HIGH_BITS_OFFSET
)paren
id|port.iobase
op_or_assign
(paren
r_int
)paren
id|req-&gt;port_high
op_lshift
id|HIGH_BITS_OFFSET
suffix:semicolon
multiline_comment|/*&n;&t; * If a clock rate wasn&squot;t specified by the low level&n;&t; * driver, then default to the standard clock rate.&n;&t; */
r_if
c_cond
(paren
id|port.uartclk
op_eq
l_int|0
)paren
id|port.uartclk
op_assign
id|BASE_BAUD
op_star
l_int|16
suffix:semicolon
r_return
id|uart_register_port
c_func
(paren
op_amp
id|serial8250_reg
comma
op_amp
id|port
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;register_serial - configure a 16x50 serial port at runtime&n; *&t;@req: request structure&n; *&n; *&t;Configure the serial port specified by the request. If the&n; *&t;port exists and is in use an error is returned. If the port&n; *&t;is not currently in the table it is added.&n; *&n; *&t;The port is then probed and if necessary the IRQ is autodetected&n; *&t;If this fails an error is returned.&n; *&n; *&t;On success the port is ready to use and the line number is returned.&n; */
DECL|function|register_serial
r_int
id|register_serial
c_func
(paren
r_struct
id|serial_struct
op_star
id|req
)paren
(brace
r_return
id|__register_serial
c_func
(paren
id|req
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|early_serial_setup
r_int
id|__init
id|early_serial_setup
c_func
(paren
r_struct
id|uart_port
op_star
id|port
)paren
(brace
id|serial8250_isa_init_ports
c_func
(paren
)paren
suffix:semicolon
id|serial8250_ports
(braket
id|port-&gt;line
)braket
dot
id|port
op_assign
op_star
id|port
suffix:semicolon
id|serial8250_ports
(braket
id|port-&gt;line
)braket
dot
id|port.ops
op_assign
op_amp
id|serial8250_pops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;unregister_serial - remove a 16x50 serial port at runtime&n; *&t;@line: serial line number&n; *&n; *&t;Remove one serial port.  This may be called from interrupt&n; *&t;context.&n; */
DECL|function|unregister_serial
r_void
id|unregister_serial
c_func
(paren
r_int
id|line
)paren
(brace
id|uart_unregister_port
c_func
(paren
op_amp
id|serial8250_reg
comma
id|line
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;serial8250_suspend_port - suspend one serial port&n; *&t;@line:  serial line number&n; *      @level: the level of port suspension, as per uart_suspend_port&n; *&n; *&t;Suspend one serial port.&n; */
DECL|function|serial8250_suspend_port
r_void
id|serial8250_suspend_port
c_func
(paren
r_int
id|line
)paren
(brace
id|uart_suspend_port
c_func
(paren
op_amp
id|serial8250_reg
comma
op_amp
id|serial8250_ports
(braket
id|line
)braket
dot
id|port
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;serial8250_resume_port - resume one serial port&n; *&t;@line:  serial line number&n; *      @level: the level of port resumption, as per uart_resume_port&n; *&n; *&t;Resume one serial port.&n; */
DECL|function|serial8250_resume_port
r_void
id|serial8250_resume_port
c_func
(paren
r_int
id|line
)paren
(brace
id|uart_resume_port
c_func
(paren
op_amp
id|serial8250_reg
comma
op_amp
id|serial8250_ports
(braket
id|line
)braket
dot
id|port
)paren
suffix:semicolon
)brace
DECL|function|serial8250_init
r_static
r_int
id|__init
id|serial8250_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
comma
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Serial: Au1x00 driver&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
id|spin_lock_init
c_func
(paren
op_amp
id|irq_lists
(braket
id|i
)braket
dot
id|lock
)paren
suffix:semicolon
id|ret
op_assign
id|uart_register_driver
c_func
(paren
op_amp
id|serial8250_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
id|serial8250_register_ports
c_func
(paren
op_amp
id|serial8250_reg
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|serial8250_exit
r_static
r_void
id|__exit
id|serial8250_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UART_NR
suffix:semicolon
id|i
op_increment
)paren
id|uart_remove_one_port
c_func
(paren
op_amp
id|serial8250_reg
comma
op_amp
id|serial8250_ports
(braket
id|i
)braket
dot
id|port
)paren
suffix:semicolon
id|uart_unregister_driver
c_func
(paren
op_amp
id|serial8250_reg
)paren
suffix:semicolon
)brace
DECL|variable|serial8250_init
id|module_init
c_func
(paren
id|serial8250_init
)paren
suffix:semicolon
DECL|variable|serial8250_exit
id|module_exit
c_func
(paren
id|serial8250_exit
)paren
suffix:semicolon
DECL|variable|register_serial
id|EXPORT_SYMBOL
c_func
(paren
id|register_serial
)paren
suffix:semicolon
DECL|variable|unregister_serial
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_serial
)paren
suffix:semicolon
DECL|variable|serial8250_suspend_port
id|EXPORT_SYMBOL
c_func
(paren
id|serial8250_suspend_port
)paren
suffix:semicolon
DECL|variable|serial8250_resume_port
id|EXPORT_SYMBOL
c_func
(paren
id|serial8250_resume_port
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Au1x00 serial driver&bslash;n&quot;
)paren
suffix:semicolon
eof
