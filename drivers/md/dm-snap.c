multiline_comment|/*&n; * dm-snapshot.c&n; *&n; * Copyright (C) 2001-2002 Sistina Software (UK) Limited.&n; *&n; * This file is released under the GPL.&n; */
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/device-mapper.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kdev_t.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &quot;dm-snap.h&quot;
macro_line|#include &quot;dm-bio-list.h&quot;
macro_line|#include &quot;kcopyd.h&quot;
multiline_comment|/*&n; * The percentage increment we will wake up users at&n; */
DECL|macro|WAKE_UP_PERCENT
mdefine_line|#define WAKE_UP_PERCENT 5
multiline_comment|/*&n; * kcopyd priority of snapshot operations&n; */
DECL|macro|SNAPSHOT_COPY_PRIORITY
mdefine_line|#define SNAPSHOT_COPY_PRIORITY 2
multiline_comment|/*&n; * Each snapshot reserves this many pages for io&n; */
DECL|macro|SNAPSHOT_PAGES
mdefine_line|#define SNAPSHOT_PAGES 256
DECL|struct|pending_exception
r_struct
id|pending_exception
(brace
DECL|member|e
r_struct
id|exception
id|e
suffix:semicolon
multiline_comment|/*&n;&t; * Origin buffers waiting for this to complete are held&n;&t; * in a bio list&n;&t; */
DECL|member|origin_bios
r_struct
id|bio_list
id|origin_bios
suffix:semicolon
DECL|member|snapshot_bios
r_struct
id|bio_list
id|snapshot_bios
suffix:semicolon
multiline_comment|/*&n;&t; * Other pending_exceptions that are processing this&n;&t; * chunk.  When this list is empty, we know we can&n;&t; * complete the origins.&n;&t; */
DECL|member|siblings
r_struct
id|list_head
id|siblings
suffix:semicolon
multiline_comment|/* Pointer back to snapshot context */
DECL|member|snap
r_struct
id|dm_snapshot
op_star
id|snap
suffix:semicolon
multiline_comment|/*&n;&t; * 1 indicates the exception has already been sent to&n;&t; * kcopyd.&n;&t; */
DECL|member|started
r_int
id|started
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Hash table mapping origin volumes to lists of snapshots and&n; * a lock to protect it&n; */
DECL|variable|exception_cache
r_static
id|kmem_cache_t
op_star
id|exception_cache
suffix:semicolon
DECL|variable|pending_cache
r_static
id|kmem_cache_t
op_star
id|pending_cache
suffix:semicolon
DECL|variable|pending_pool
r_static
id|mempool_t
op_star
id|pending_pool
suffix:semicolon
multiline_comment|/*&n; * One of these per registered origin, held in the snapshot_origins hash&n; */
DECL|struct|origin
r_struct
id|origin
(brace
multiline_comment|/* The origin device */
DECL|member|bdev
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
DECL|member|hash_list
r_struct
id|list_head
id|hash_list
suffix:semicolon
multiline_comment|/* List of snapshots for this origin */
DECL|member|snapshots
r_struct
id|list_head
id|snapshots
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Size of the hash table for origin volumes. If we make this&n; * the size of the minors list then it should be nearly perfect&n; */
DECL|macro|ORIGIN_HASH_SIZE
mdefine_line|#define ORIGIN_HASH_SIZE 256
DECL|macro|ORIGIN_MASK
mdefine_line|#define ORIGIN_MASK      0xFF
DECL|variable|_origins
r_static
r_struct
id|list_head
op_star
id|_origins
suffix:semicolon
DECL|variable|_origins_lock
r_static
r_struct
id|rw_semaphore
id|_origins_lock
suffix:semicolon
DECL|function|init_origin_hash
r_static
r_int
id|init_origin_hash
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|_origins
op_assign
id|kmalloc
c_func
(paren
id|ORIGIN_HASH_SIZE
op_star
r_sizeof
(paren
r_struct
id|list_head
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_origins
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;Device mapper: Snapshot: unable to allocate memory&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ORIGIN_HASH_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
id|_origins
op_plus
id|i
)paren
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|_origins_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|exit_origin_hash
r_static
r_void
id|exit_origin_hash
c_func
(paren
r_void
)paren
(brace
id|kfree
c_func
(paren
id|_origins
)paren
suffix:semicolon
)brace
DECL|function|origin_hash
r_static
r_inline
r_int
r_int
id|origin_hash
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
r_return
id|bdev-&gt;bd_dev
op_amp
id|ORIGIN_MASK
suffix:semicolon
)brace
DECL|function|__lookup_origin
r_static
r_struct
id|origin
op_star
id|__lookup_origin
c_func
(paren
r_struct
id|block_device
op_star
id|origin
)paren
(brace
r_struct
id|list_head
op_star
id|ol
suffix:semicolon
r_struct
id|origin
op_star
id|o
suffix:semicolon
id|ol
op_assign
op_amp
id|_origins
(braket
id|origin_hash
c_func
(paren
id|origin
)paren
)braket
suffix:semicolon
id|list_for_each_entry
(paren
id|o
comma
id|ol
comma
id|hash_list
)paren
r_if
c_cond
(paren
id|bdev_equal
c_func
(paren
id|o-&gt;bdev
comma
id|origin
)paren
)paren
r_return
id|o
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|__insert_origin
r_static
r_void
id|__insert_origin
c_func
(paren
r_struct
id|origin
op_star
id|o
)paren
(brace
r_struct
id|list_head
op_star
id|sl
op_assign
op_amp
id|_origins
(braket
id|origin_hash
c_func
(paren
id|o-&gt;bdev
)paren
)braket
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|o-&gt;hash_list
comma
id|sl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Make a note of the snapshot and its origin so we can look it&n; * up when the origin has a write on it.&n; */
DECL|function|register_snapshot
r_static
r_int
id|register_snapshot
c_func
(paren
r_struct
id|dm_snapshot
op_star
id|snap
)paren
(brace
r_struct
id|origin
op_star
id|o
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
op_assign
id|snap-&gt;origin-&gt;bdev
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|_origins_lock
)paren
suffix:semicolon
id|o
op_assign
id|__lookup_origin
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o
)paren
(brace
multiline_comment|/* New origin */
id|o
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|o
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|_origins_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Initialise the struct */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|o-&gt;snapshots
)paren
suffix:semicolon
id|o-&gt;bdev
op_assign
id|bdev
suffix:semicolon
id|__insert_origin
c_func
(paren
id|o
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|snap-&gt;list
comma
op_amp
id|o-&gt;snapshots
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|_origins_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unregister_snapshot
r_static
r_void
id|unregister_snapshot
c_func
(paren
r_struct
id|dm_snapshot
op_star
id|s
)paren
(brace
r_struct
id|origin
op_star
id|o
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|_origins_lock
)paren
suffix:semicolon
id|o
op_assign
id|__lookup_origin
c_func
(paren
id|s-&gt;origin-&gt;bdev
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|s-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|o-&gt;snapshots
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|o-&gt;hash_list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|o
)paren
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|_origins_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Implementation of the exception hash tables.&n; */
DECL|function|init_exception_table
r_static
r_int
id|init_exception_table
c_func
(paren
r_struct
id|exception_table
op_star
id|et
comma
r_uint32
id|size
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|et-&gt;hash_mask
op_assign
id|size
op_minus
l_int|1
suffix:semicolon
id|et-&gt;table
op_assign
id|dm_vcalloc
c_func
(paren
id|size
comma
r_sizeof
(paren
r_struct
id|list_head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|et-&gt;table
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
id|et-&gt;table
op_plus
id|i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|exit_exception_table
r_static
r_void
id|exit_exception_table
c_func
(paren
r_struct
id|exception_table
op_star
id|et
comma
id|kmem_cache_t
op_star
id|mem
)paren
(brace
r_struct
id|list_head
op_star
id|slot
suffix:semicolon
r_struct
id|exception
op_star
id|ex
comma
op_star
id|next
suffix:semicolon
r_int
id|i
comma
id|size
suffix:semicolon
id|size
op_assign
id|et-&gt;hash_mask
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|slot
op_assign
id|et-&gt;table
op_plus
id|i
suffix:semicolon
id|list_for_each_entry_safe
(paren
id|ex
comma
id|next
comma
id|slot
comma
id|hash_list
)paren
id|kmem_cache_free
c_func
(paren
id|mem
comma
id|ex
)paren
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|et-&gt;table
)paren
suffix:semicolon
)brace
DECL|function|exception_hash
r_static
r_inline
r_uint32
id|exception_hash
c_func
(paren
r_struct
id|exception_table
op_star
id|et
comma
id|chunk_t
id|chunk
)paren
(brace
r_return
id|chunk
op_amp
id|et-&gt;hash_mask
suffix:semicolon
)brace
DECL|function|insert_exception
r_static
r_void
id|insert_exception
c_func
(paren
r_struct
id|exception_table
op_star
id|eh
comma
r_struct
id|exception
op_star
id|e
)paren
(brace
r_struct
id|list_head
op_star
id|l
op_assign
op_amp
id|eh-&gt;table
(braket
id|exception_hash
c_func
(paren
id|eh
comma
id|e-&gt;old_chunk
)paren
)braket
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|e-&gt;hash_list
comma
id|l
)paren
suffix:semicolon
)brace
DECL|function|remove_exception
r_static
r_inline
r_void
id|remove_exception
c_func
(paren
r_struct
id|exception
op_star
id|e
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|e-&gt;hash_list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the exception data for a sector, or NULL if not&n; * remapped.&n; */
DECL|function|lookup_exception
r_static
r_struct
id|exception
op_star
id|lookup_exception
c_func
(paren
r_struct
id|exception_table
op_star
id|et
comma
id|chunk_t
id|chunk
)paren
(brace
r_struct
id|list_head
op_star
id|slot
suffix:semicolon
r_struct
id|exception
op_star
id|e
suffix:semicolon
id|slot
op_assign
op_amp
id|et-&gt;table
(braket
id|exception_hash
c_func
(paren
id|et
comma
id|chunk
)paren
)braket
suffix:semicolon
id|list_for_each_entry
(paren
id|e
comma
id|slot
comma
id|hash_list
)paren
r_if
c_cond
(paren
id|e-&gt;old_chunk
op_eq
id|chunk
)paren
r_return
id|e
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|alloc_exception
r_static
r_inline
r_struct
id|exception
op_star
id|alloc_exception
c_func
(paren
r_void
)paren
(brace
r_struct
id|exception
op_star
id|e
suffix:semicolon
id|e
op_assign
id|kmem_cache_alloc
c_func
(paren
id|exception_cache
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
id|e
op_assign
id|kmem_cache_alloc
c_func
(paren
id|exception_cache
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
DECL|function|free_exception
r_static
r_inline
r_void
id|free_exception
c_func
(paren
r_struct
id|exception
op_star
id|e
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|exception_cache
comma
id|e
)paren
suffix:semicolon
)brace
DECL|function|alloc_pending_exception
r_static
r_inline
r_struct
id|pending_exception
op_star
id|alloc_pending_exception
c_func
(paren
r_void
)paren
(brace
r_return
id|mempool_alloc
c_func
(paren
id|pending_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
)brace
DECL|function|free_pending_exception
r_static
r_inline
r_void
id|free_pending_exception
c_func
(paren
r_struct
id|pending_exception
op_star
id|pe
)paren
(brace
id|mempool_free
c_func
(paren
id|pe
comma
id|pending_pool
)paren
suffix:semicolon
)brace
DECL|function|dm_add_exception
r_int
id|dm_add_exception
c_func
(paren
r_struct
id|dm_snapshot
op_star
id|s
comma
id|chunk_t
id|old
comma
id|chunk_t
r_new
)paren
(brace
r_struct
id|exception
op_star
id|e
suffix:semicolon
id|e
op_assign
id|alloc_exception
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|e-&gt;old_chunk
op_assign
id|old
suffix:semicolon
id|e-&gt;new_chunk
op_assign
r_new
suffix:semicolon
id|insert_exception
c_func
(paren
op_amp
id|s-&gt;complete
comma
id|e
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Hard coded magic.&n; */
DECL|function|calc_max_buckets
r_static
r_int
id|calc_max_buckets
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* use a fixed size of 2MB */
r_int
r_int
id|mem
op_assign
l_int|2
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
id|mem
op_div_assign
r_sizeof
(paren
r_struct
id|list_head
)paren
suffix:semicolon
r_return
id|mem
suffix:semicolon
)brace
multiline_comment|/*&n; * Rounds a number down to a power of 2.&n; */
DECL|function|round_down
r_static
r_inline
r_uint32
id|round_down
c_func
(paren
r_uint32
id|n
)paren
(brace
r_while
c_loop
(paren
id|n
op_amp
(paren
id|n
op_minus
l_int|1
)paren
)paren
id|n
op_and_assign
(paren
id|n
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate room for a suitable hash table.&n; */
DECL|function|init_hash_tables
r_static
r_int
id|init_hash_tables
c_func
(paren
r_struct
id|dm_snapshot
op_star
id|s
)paren
(brace
id|sector_t
id|hash_size
comma
id|cow_dev_size
comma
id|origin_dev_size
comma
id|max_buckets
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate based on the size of the original volume or&n;&t; * the COW volume...&n;&t; */
id|cow_dev_size
op_assign
id|get_dev_size
c_func
(paren
id|s-&gt;cow-&gt;bdev
)paren
suffix:semicolon
id|origin_dev_size
op_assign
id|get_dev_size
c_func
(paren
id|s-&gt;origin-&gt;bdev
)paren
suffix:semicolon
id|max_buckets
op_assign
id|calc_max_buckets
c_func
(paren
)paren
suffix:semicolon
id|hash_size
op_assign
id|min
c_func
(paren
id|origin_dev_size
comma
id|cow_dev_size
)paren
op_rshift
id|s-&gt;chunk_shift
suffix:semicolon
id|hash_size
op_assign
id|min
c_func
(paren
id|hash_size
comma
id|max_buckets
)paren
suffix:semicolon
multiline_comment|/* Round it down to a power of 2 */
id|hash_size
op_assign
id|round_down
c_func
(paren
id|hash_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_exception_table
c_func
(paren
op_amp
id|s-&gt;complete
comma
id|hash_size
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate hash table for in-flight exceptions&n;&t; * Make this smaller than the real hash table&n;&t; */
id|hash_size
op_rshift_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|hash_size
OL
l_int|64
)paren
id|hash_size
op_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|init_exception_table
c_func
(paren
op_amp
id|s-&gt;pending
comma
id|hash_size
)paren
)paren
(brace
id|exit_exception_table
c_func
(paren
op_amp
id|s-&gt;complete
comma
id|exception_cache
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Round a number up to the nearest &squot;size&squot; boundary.  size must&n; * be a power of 2.&n; */
DECL|function|round_up
r_static
r_inline
id|ulong
id|round_up
c_func
(paren
id|ulong
id|n
comma
id|ulong
id|size
)paren
(brace
id|size
op_decrement
suffix:semicolon
r_return
(paren
id|n
op_plus
id|size
)paren
op_amp
op_complement
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Construct a snapshot mapping: &lt;origin_dev&gt; &lt;COW-dev&gt; &lt;p/n&gt; &lt;chunk-size&gt;&n; */
DECL|function|snapshot_ctr
r_static
r_int
id|snapshot_ctr
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_int
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_struct
id|dm_snapshot
op_star
id|s
suffix:semicolon
r_int
r_int
id|chunk_size
suffix:semicolon
r_int
id|r
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_char
id|persistent
suffix:semicolon
r_char
op_star
id|origin_path
suffix:semicolon
r_char
op_star
id|cow_path
suffix:semicolon
r_char
op_star
id|value
suffix:semicolon
r_int
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|argc
OL
l_int|4
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-snapshot: requires exactly 4 arguments&quot;
suffix:semicolon
id|r
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad1
suffix:semicolon
)brace
id|origin_path
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
id|cow_path
op_assign
id|argv
(braket
l_int|1
)braket
suffix:semicolon
id|persistent
op_assign
id|toupper
c_func
(paren
op_star
id|argv
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|persistent
op_ne
l_char|&squot;P&squot;
op_logical_and
id|persistent
op_ne
l_char|&squot;N&squot;
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;Persistent flag is not P or N&quot;
suffix:semicolon
id|r
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad1
suffix:semicolon
)brace
id|chunk_size
op_assign
id|simple_strtoul
c_func
(paren
id|argv
(braket
l_int|3
)braket
comma
op_amp
id|value
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chunk_size
op_eq
l_int|0
op_logical_or
id|value
op_eq
l_int|NULL
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;Invalid chunk size&quot;
suffix:semicolon
id|r
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad1
suffix:semicolon
)brace
id|s
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|s
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
l_int|NULL
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;Cannot allocate snapshot context private &quot;
l_string|&quot;structure&quot;
suffix:semicolon
id|r
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad1
suffix:semicolon
)brace
id|r
op_assign
id|dm_get_device
c_func
(paren
id|ti
comma
id|origin_path
comma
l_int|0
comma
id|ti-&gt;len
comma
id|FMODE_READ
comma
op_amp
id|s-&gt;origin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;Cannot get origin device&quot;
suffix:semicolon
r_goto
id|bad2
suffix:semicolon
)brace
id|r
op_assign
id|dm_get_device
c_func
(paren
id|ti
comma
id|cow_path
comma
l_int|0
comma
l_int|0
comma
id|FMODE_READ
op_or
id|FMODE_WRITE
comma
op_amp
id|s-&gt;cow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|dm_put_device
c_func
(paren
id|ti
comma
id|s-&gt;origin
)paren
suffix:semicolon
id|ti-&gt;error
op_assign
l_string|&quot;Cannot get COW device&quot;
suffix:semicolon
r_goto
id|bad2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Chunk size must be multiple of page size.  Silently&n;&t; * round up if it&squot;s not.&n;&t; */
id|chunk_size
op_assign
id|round_up
c_func
(paren
id|chunk_size
comma
id|PAGE_SIZE
op_rshift
l_int|9
)paren
suffix:semicolon
multiline_comment|/* Validate the chunk size against the device block size */
id|blocksize
op_assign
id|s-&gt;cow-&gt;bdev-&gt;bd_disk-&gt;queue-&gt;hardsect_size
suffix:semicolon
r_if
c_cond
(paren
id|chunk_size
op_mod
(paren
id|blocksize
op_rshift
l_int|9
)paren
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;Chunk size is not a multiple of device blocksize&quot;
suffix:semicolon
id|r
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad3
suffix:semicolon
)brace
multiline_comment|/* Check chunk_size is a power of 2 */
r_if
c_cond
(paren
id|chunk_size
op_amp
(paren
id|chunk_size
op_minus
l_int|1
)paren
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;Chunk size is not a power of 2&quot;
suffix:semicolon
id|r
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad3
suffix:semicolon
)brace
id|s-&gt;chunk_size
op_assign
id|chunk_size
suffix:semicolon
id|s-&gt;chunk_mask
op_assign
id|chunk_size
op_minus
l_int|1
suffix:semicolon
id|s-&gt;type
op_assign
id|persistent
suffix:semicolon
id|s-&gt;chunk_shift
op_assign
id|ffs
c_func
(paren
id|chunk_size
)paren
op_minus
l_int|1
suffix:semicolon
id|s-&gt;valid
op_assign
l_int|1
suffix:semicolon
id|s-&gt;have_metadata
op_assign
l_int|0
suffix:semicolon
id|s-&gt;last_percent
op_assign
l_int|0
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|s-&gt;table
op_assign
id|ti-&gt;table
suffix:semicolon
multiline_comment|/* Allocate hash table for COW data */
r_if
c_cond
(paren
id|init_hash_tables
c_func
(paren
id|s
)paren
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;Unable to allocate hash table space&quot;
suffix:semicolon
id|r
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad3
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check the persistent flag - done here because we need the iobuf&n;&t; * to check the LV header&n;&t; */
id|s-&gt;store.snap
op_assign
id|s
suffix:semicolon
r_if
c_cond
(paren
id|persistent
op_eq
l_char|&squot;P&squot;
)paren
id|r
op_assign
id|dm_create_persistent
c_func
(paren
op_amp
id|s-&gt;store
comma
id|chunk_size
)paren
suffix:semicolon
r_else
id|r
op_assign
id|dm_create_transient
c_func
(paren
op_amp
id|s-&gt;store
comma
id|s
comma
id|blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;Couldn&squot;t create exception store&quot;
suffix:semicolon
id|r
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad4
suffix:semicolon
)brace
id|r
op_assign
id|kcopyd_client_create
c_func
(paren
id|SNAPSHOT_PAGES
comma
op_amp
id|s-&gt;kcopyd_client
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;Could not create kcopyd client&quot;
suffix:semicolon
r_goto
id|bad5
suffix:semicolon
)brace
multiline_comment|/* Add snapshot to the list of snapshots for this origin */
r_if
c_cond
(paren
id|register_snapshot
c_func
(paren
id|s
)paren
)paren
(brace
id|r
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|ti-&gt;error
op_assign
l_string|&quot;Cannot register snapshot origin&quot;
suffix:semicolon
r_goto
id|bad6
suffix:semicolon
)brace
id|ti
op_member_access_from_pointer
r_private
op_assign
id|s
suffix:semicolon
id|ti-&gt;split_io
op_assign
id|chunk_size
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bad6
suffix:colon
id|kcopyd_client_destroy
c_func
(paren
id|s-&gt;kcopyd_client
)paren
suffix:semicolon
id|bad5
suffix:colon
id|s-&gt;store
dot
id|destroy
c_func
(paren
op_amp
id|s-&gt;store
)paren
suffix:semicolon
id|bad4
suffix:colon
id|exit_exception_table
c_func
(paren
op_amp
id|s-&gt;pending
comma
id|pending_cache
)paren
suffix:semicolon
id|exit_exception_table
c_func
(paren
op_amp
id|s-&gt;complete
comma
id|exception_cache
)paren
suffix:semicolon
id|bad3
suffix:colon
id|dm_put_device
c_func
(paren
id|ti
comma
id|s-&gt;cow
)paren
suffix:semicolon
id|dm_put_device
c_func
(paren
id|ti
comma
id|s-&gt;origin
)paren
suffix:semicolon
id|bad2
suffix:colon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
id|bad1
suffix:colon
r_return
id|r
suffix:semicolon
)brace
DECL|function|snapshot_dtr
r_static
r_void
id|snapshot_dtr
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|dm_snapshot
op_star
id|s
op_assign
(paren
r_struct
id|dm_snapshot
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
id|unregister_snapshot
c_func
(paren
id|s
)paren
suffix:semicolon
id|exit_exception_table
c_func
(paren
op_amp
id|s-&gt;pending
comma
id|pending_cache
)paren
suffix:semicolon
id|exit_exception_table
c_func
(paren
op_amp
id|s-&gt;complete
comma
id|exception_cache
)paren
suffix:semicolon
multiline_comment|/* Deallocate memory used */
id|s-&gt;store
dot
id|destroy
c_func
(paren
op_amp
id|s-&gt;store
)paren
suffix:semicolon
id|dm_put_device
c_func
(paren
id|ti
comma
id|s-&gt;origin
)paren
suffix:semicolon
id|dm_put_device
c_func
(paren
id|ti
comma
id|s-&gt;cow
)paren
suffix:semicolon
id|kcopyd_client_destroy
c_func
(paren
id|s-&gt;kcopyd_client
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush a list of buffers.&n; */
DECL|function|flush_bios
r_static
r_void
id|flush_bios
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|bio
op_star
id|n
suffix:semicolon
r_while
c_loop
(paren
id|bio
)paren
(brace
id|n
op_assign
id|bio-&gt;bi_next
suffix:semicolon
id|bio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
id|generic_make_request
c_func
(paren
id|bio
)paren
suffix:semicolon
id|bio
op_assign
id|n
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Error a list of buffers.&n; */
DECL|function|error_bios
r_static
r_void
id|error_bios
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|bio
op_star
id|n
suffix:semicolon
r_while
c_loop
(paren
id|bio
)paren
(brace
id|n
op_assign
id|bio-&gt;bi_next
suffix:semicolon
id|bio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
id|bio_io_error
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
)paren
suffix:semicolon
id|bio
op_assign
id|n
suffix:semicolon
)brace
)brace
DECL|function|__flush_bios
r_static
r_struct
id|bio
op_star
id|__flush_bios
c_func
(paren
r_struct
id|pending_exception
op_star
id|pe
)paren
(brace
r_struct
id|pending_exception
op_star
id|sibling
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|pe-&gt;siblings
)paren
)paren
r_return
id|bio_list_get
c_func
(paren
op_amp
id|pe-&gt;origin_bios
)paren
suffix:semicolon
id|sibling
op_assign
id|list_entry
c_func
(paren
id|pe-&gt;siblings.next
comma
r_struct
id|pending_exception
comma
id|siblings
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|pe-&gt;siblings
)paren
suffix:semicolon
multiline_comment|/* This is fine as long as kcopyd is single-threaded. If kcopyd&n;&t; * becomes multi-threaded, we&squot;ll need some locking here.&n;&t; */
id|bio_list_merge
c_func
(paren
op_amp
id|sibling-&gt;origin_bios
comma
op_amp
id|pe-&gt;origin_bios
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|pending_complete
r_static
r_void
id|pending_complete
c_func
(paren
r_struct
id|pending_exception
op_star
id|pe
comma
r_int
id|success
)paren
(brace
r_struct
id|exception
op_star
id|e
suffix:semicolon
r_struct
id|dm_snapshot
op_star
id|s
op_assign
id|pe-&gt;snap
suffix:semicolon
r_struct
id|bio
op_star
id|flush
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|success
)paren
(brace
id|e
op_assign
id|alloc_exception
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;Unable to allocate exception.&quot;
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|s-&gt;store
dot
id|drop_snapshot
c_func
(paren
op_amp
id|s-&gt;store
)paren
suffix:semicolon
id|s-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|flush
op_assign
id|__flush_bios
c_func
(paren
id|pe
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|error_bios
c_func
(paren
id|bio_list_get
c_func
(paren
op_amp
id|pe-&gt;snapshot_bios
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|e
op_assign
id|pe-&gt;e
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add a proper exception, and remove the&n;&t;&t; * in-flight exception from the list.&n;&t;&t; */
id|down_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|insert_exception
c_func
(paren
op_amp
id|s-&gt;complete
comma
id|e
)paren
suffix:semicolon
id|remove_exception
c_func
(paren
op_amp
id|pe-&gt;e
)paren
suffix:semicolon
id|flush
op_assign
id|__flush_bios
c_func
(paren
id|pe
)paren
suffix:semicolon
multiline_comment|/* Submit any pending write bios */
id|up_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|flush_bios
c_func
(paren
id|bio_list_get
c_func
(paren
op_amp
id|pe-&gt;snapshot_bios
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Read/write error - snapshot is unusable */
id|down_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;valid
)paren
id|DMERR
c_func
(paren
l_string|&quot;Error reading/writing snapshot&quot;
)paren
suffix:semicolon
id|s-&gt;store
dot
id|drop_snapshot
c_func
(paren
op_amp
id|s-&gt;store
)paren
suffix:semicolon
id|s-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|remove_exception
c_func
(paren
op_amp
id|pe-&gt;e
)paren
suffix:semicolon
id|flush
op_assign
id|__flush_bios
c_func
(paren
id|pe
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|error_bios
c_func
(paren
id|bio_list_get
c_func
(paren
op_amp
id|pe-&gt;snapshot_bios
)paren
)paren
suffix:semicolon
id|dm_table_event
c_func
(paren
id|s-&gt;table
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|free_pending_exception
c_func
(paren
id|pe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush
)paren
id|flush_bios
c_func
(paren
id|flush
)paren
suffix:semicolon
)brace
DECL|function|commit_callback
r_static
r_void
id|commit_callback
c_func
(paren
r_void
op_star
id|context
comma
r_int
id|success
)paren
(brace
r_struct
id|pending_exception
op_star
id|pe
op_assign
(paren
r_struct
id|pending_exception
op_star
)paren
id|context
suffix:semicolon
id|pending_complete
c_func
(paren
id|pe
comma
id|success
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when the copy I/O has finished.  kcopyd actually runs&n; * this code so don&squot;t block.&n; */
DECL|function|copy_callback
r_static
r_void
id|copy_callback
c_func
(paren
r_int
id|read_err
comma
r_int
r_int
id|write_err
comma
r_void
op_star
id|context
)paren
(brace
r_struct
id|pending_exception
op_star
id|pe
op_assign
(paren
r_struct
id|pending_exception
op_star
)paren
id|context
suffix:semicolon
r_struct
id|dm_snapshot
op_star
id|s
op_assign
id|pe-&gt;snap
suffix:semicolon
r_if
c_cond
(paren
id|read_err
op_logical_or
id|write_err
)paren
id|pending_complete
c_func
(paren
id|pe
comma
l_int|0
)paren
suffix:semicolon
r_else
multiline_comment|/* Update the metadata if we are persistent */
id|s-&gt;store
dot
id|commit_exception
c_func
(paren
op_amp
id|s-&gt;store
comma
op_amp
id|pe-&gt;e
comma
id|commit_callback
comma
id|pe
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Dispatches the copy operation to kcopyd.&n; */
DECL|function|start_copy
r_static
r_inline
r_void
id|start_copy
c_func
(paren
r_struct
id|pending_exception
op_star
id|pe
)paren
(brace
r_struct
id|dm_snapshot
op_star
id|s
op_assign
id|pe-&gt;snap
suffix:semicolon
r_struct
id|io_region
id|src
comma
id|dest
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
op_assign
id|s-&gt;origin-&gt;bdev
suffix:semicolon
id|sector_t
id|dev_size
suffix:semicolon
id|dev_size
op_assign
id|get_dev_size
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|src.bdev
op_assign
id|bdev
suffix:semicolon
id|src.sector
op_assign
id|chunk_to_sector
c_func
(paren
id|s
comma
id|pe-&gt;e.old_chunk
)paren
suffix:semicolon
id|src.count
op_assign
id|min
c_func
(paren
id|s-&gt;chunk_size
comma
id|dev_size
op_minus
id|src.sector
)paren
suffix:semicolon
id|dest.bdev
op_assign
id|s-&gt;cow-&gt;bdev
suffix:semicolon
id|dest.sector
op_assign
id|chunk_to_sector
c_func
(paren
id|s
comma
id|pe-&gt;e.new_chunk
)paren
suffix:semicolon
id|dest.count
op_assign
id|src.count
suffix:semicolon
multiline_comment|/* Hand over to kcopyd */
id|kcopyd_copy
c_func
(paren
id|s-&gt;kcopyd_client
comma
op_amp
id|src
comma
l_int|1
comma
op_amp
id|dest
comma
l_int|0
comma
id|copy_callback
comma
id|pe
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Looks to see if this snapshot already has a pending exception&n; * for this chunk, otherwise it allocates a new one and inserts&n; * it into the pending table.&n; *&n; * NOTE: a write lock must be held on snap-&gt;lock before calling&n; * this.&n; */
r_static
r_struct
id|pending_exception
op_star
DECL|function|__find_pending_exception
id|__find_pending_exception
c_func
(paren
r_struct
id|dm_snapshot
op_star
id|s
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|exception
op_star
id|e
suffix:semicolon
r_struct
id|pending_exception
op_star
id|pe
suffix:semicolon
id|chunk_t
id|chunk
op_assign
id|sector_to_chunk
c_func
(paren
id|s
comma
id|bio-&gt;bi_sector
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Is there a pending exception for this already ?&n;&t; */
id|e
op_assign
id|lookup_exception
c_func
(paren
op_amp
id|s-&gt;pending
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
(brace
multiline_comment|/* cast the exception to a pending exception */
id|pe
op_assign
id|container_of
c_func
(paren
id|e
comma
r_struct
id|pending_exception
comma
id|e
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Create a new pending exception, we don&squot;t want&n;&t;&t; * to hold the lock while we do this.&n;&t;&t; */
id|up_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|pe
op_assign
id|alloc_pending_exception
c_func
(paren
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|e
op_assign
id|lookup_exception
c_func
(paren
op_amp
id|s-&gt;pending
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
(brace
id|free_pending_exception
c_func
(paren
id|pe
)paren
suffix:semicolon
id|pe
op_assign
id|container_of
c_func
(paren
id|e
comma
r_struct
id|pending_exception
comma
id|e
)paren
suffix:semicolon
)brace
r_else
(brace
id|pe-&gt;e.old_chunk
op_assign
id|chunk
suffix:semicolon
id|bio_list_init
c_func
(paren
op_amp
id|pe-&gt;origin_bios
)paren
suffix:semicolon
id|bio_list_init
c_func
(paren
op_amp
id|pe-&gt;snapshot_bios
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pe-&gt;siblings
)paren
suffix:semicolon
id|pe-&gt;snap
op_assign
id|s
suffix:semicolon
id|pe-&gt;started
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;store
dot
id|prepare_exception
c_func
(paren
op_amp
id|s-&gt;store
comma
op_amp
id|pe-&gt;e
)paren
)paren
(brace
id|free_pending_exception
c_func
(paren
id|pe
)paren
suffix:semicolon
id|s-&gt;valid
op_assign
l_int|0
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|insert_exception
c_func
(paren
op_amp
id|s-&gt;pending
comma
op_amp
id|pe-&gt;e
)paren
suffix:semicolon
)brace
)brace
r_return
id|pe
suffix:semicolon
)brace
DECL|function|remap_exception
r_static
r_inline
r_void
id|remap_exception
c_func
(paren
r_struct
id|dm_snapshot
op_star
id|s
comma
r_struct
id|exception
op_star
id|e
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|bio-&gt;bi_bdev
op_assign
id|s-&gt;cow-&gt;bdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|chunk_to_sector
c_func
(paren
id|s
comma
id|e-&gt;new_chunk
)paren
op_plus
(paren
id|bio-&gt;bi_sector
op_amp
id|s-&gt;chunk_mask
)paren
suffix:semicolon
)brace
DECL|function|snapshot_map
r_static
r_int
id|snapshot_map
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_struct
id|bio
op_star
id|bio
comma
r_union
id|map_info
op_star
id|map_context
)paren
(brace
r_struct
id|exception
op_star
id|e
suffix:semicolon
r_struct
id|dm_snapshot
op_star
id|s
op_assign
(paren
r_struct
id|dm_snapshot
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|r
op_assign
l_int|1
suffix:semicolon
id|chunk_t
id|chunk
suffix:semicolon
r_struct
id|pending_exception
op_star
id|pe
suffix:semicolon
id|chunk
op_assign
id|sector_to_chunk
c_func
(paren
id|s
comma
id|bio-&gt;bi_sector
)paren
suffix:semicolon
multiline_comment|/* Full snapshots are not usable */
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;valid
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Write to snapshot - higher level takes care of RW/RO&n;&t; * flags so we should only get this if we are&n;&t; * writeable.&n;&t; */
r_if
c_cond
(paren
id|bio_rw
c_func
(paren
id|bio
)paren
op_eq
id|WRITE
)paren
(brace
multiline_comment|/* FIXME: should only take write lock if we need&n;&t;&t; * to copy an exception */
id|down_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* If the block is already remapped - use that, else remap it */
id|e
op_assign
id|lookup_exception
c_func
(paren
op_amp
id|s-&gt;complete
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
(brace
id|remap_exception
c_func
(paren
id|s
comma
id|e
comma
id|bio
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|pe
op_assign
id|__find_pending_exception
c_func
(paren
id|s
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pe
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;store.drop_snapshot
)paren
id|s-&gt;store
dot
id|drop_snapshot
c_func
(paren
op_amp
id|s-&gt;store
)paren
suffix:semicolon
id|s-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|r
op_assign
op_minus
id|EIO
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|remap_exception
c_func
(paren
id|s
comma
op_amp
id|pe-&gt;e
comma
id|bio
)paren
suffix:semicolon
id|bio_list_add
c_func
(paren
op_amp
id|pe-&gt;snapshot_bios
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pe-&gt;started
)paren
(brace
multiline_comment|/* this is protected by snap-&gt;lock */
id|pe-&gt;started
op_assign
l_int|1
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|start_copy
c_func
(paren
id|pe
)paren
suffix:semicolon
)brace
r_else
id|up_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * FIXME: this read path scares me because we&n;&t;&t; * always use the origin when we have a pending&n;&t;&t; * exception.  However I can&squot;t think of a&n;&t;&t; * situation where this is wrong - ejt.&n;&t;&t; */
multiline_comment|/* Do reads */
id|down_read
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* See if it it has been remapped */
id|e
op_assign
id|lookup_exception
c_func
(paren
op_amp
id|s-&gt;complete
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
id|remap_exception
c_func
(paren
id|s
comma
id|e
comma
id|bio
)paren
suffix:semicolon
r_else
id|bio-&gt;bi_bdev
op_assign
id|s-&gt;origin-&gt;bdev
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
DECL|function|snapshot_resume
r_static
r_void
id|snapshot_resume
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|dm_snapshot
op_star
id|s
op_assign
(paren
r_struct
id|dm_snapshot
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;have_metadata
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;store
dot
id|read_metadata
c_func
(paren
op_amp
id|s-&gt;store
)paren
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|s-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
)brace
id|s-&gt;have_metadata
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|snapshot_status
r_static
r_int
id|snapshot_status
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
id|status_type_t
id|type
comma
r_char
op_star
id|result
comma
r_int
r_int
id|maxlen
)paren
(brace
r_struct
id|dm_snapshot
op_star
id|snap
op_assign
(paren
r_struct
id|dm_snapshot
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_char
id|cow
(braket
l_int|32
)braket
suffix:semicolon
r_char
id|org
(braket
l_int|32
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|STATUSTYPE_INFO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|snap-&gt;valid
)paren
id|snprintf
c_func
(paren
id|result
comma
id|maxlen
comma
l_string|&quot;Invalid&quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|snap-&gt;store.fraction_full
)paren
(brace
id|sector_t
id|numerator
comma
id|denominator
suffix:semicolon
id|snap-&gt;store
dot
id|fraction_full
c_func
(paren
op_amp
id|snap-&gt;store
comma
op_amp
id|numerator
comma
op_amp
id|denominator
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|result
comma
id|maxlen
comma
id|SECTOR_FORMAT
l_string|&quot;/&quot;
id|SECTOR_FORMAT
comma
id|numerator
comma
id|denominator
)paren
suffix:semicolon
)brace
r_else
id|snprintf
c_func
(paren
id|result
comma
id|maxlen
comma
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|STATUSTYPE_TABLE
suffix:colon
multiline_comment|/*&n;&t;&t; * kdevname returns a static pointer so we need&n;&t;&t; * to make private copies if the output is to&n;&t;&t; * make sense.&n;&t;&t; */
id|format_dev_t
c_func
(paren
id|cow
comma
id|snap-&gt;cow-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
id|format_dev_t
c_func
(paren
id|org
comma
id|snap-&gt;origin-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|result
comma
id|maxlen
comma
l_string|&quot;%s %s %c &quot;
id|SECTOR_FORMAT
comma
id|org
comma
id|cow
comma
id|snap-&gt;type
comma
id|snap-&gt;chunk_size
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * Origin methods&n; *---------------------------------------------------------------*/
DECL|function|list_merge
r_static
r_void
id|list_merge
c_func
(paren
r_struct
id|list_head
op_star
id|l1
comma
r_struct
id|list_head
op_star
id|l2
)paren
(brace
r_struct
id|list_head
op_star
id|l1_n
comma
op_star
id|l2_p
suffix:semicolon
id|l1_n
op_assign
id|l1-&gt;next
suffix:semicolon
id|l2_p
op_assign
id|l2-&gt;prev
suffix:semicolon
id|l1-&gt;next
op_assign
id|l2
suffix:semicolon
id|l2-&gt;prev
op_assign
id|l1
suffix:semicolon
id|l2_p-&gt;next
op_assign
id|l1_n
suffix:semicolon
id|l1_n-&gt;prev
op_assign
id|l2_p
suffix:semicolon
)brace
DECL|function|__origin_write
r_static
r_int
id|__origin_write
c_func
(paren
r_struct
id|list_head
op_star
id|snapshots
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_int
id|r
op_assign
l_int|1
comma
id|first
op_assign
l_int|1
suffix:semicolon
r_struct
id|dm_snapshot
op_star
id|snap
suffix:semicolon
r_struct
id|exception
op_star
id|e
suffix:semicolon
r_struct
id|pending_exception
op_star
id|pe
comma
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
id|chunk_t
id|chunk
suffix:semicolon
multiline_comment|/* Do all the snapshots on this origin */
id|list_for_each_entry
(paren
id|snap
comma
id|snapshots
comma
id|list
)paren
(brace
multiline_comment|/* Only deal with valid snapshots */
r_if
c_cond
(paren
op_logical_neg
id|snap-&gt;valid
)paren
r_continue
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|snap-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remember, different snapshots can have&n;&t;&t; * different chunk sizes.&n;&t;&t; */
id|chunk
op_assign
id|sector_to_chunk
c_func
(paren
id|snap
comma
id|bio-&gt;bi_sector
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check exception table to see if block&n;&t;&t; * is already remapped in this snapshot&n;&t;&t; * and trigger an exception if not.&n;&t;&t; */
id|e
op_assign
id|lookup_exception
c_func
(paren
op_amp
id|snap-&gt;complete
comma
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
(brace
id|pe
op_assign
id|__find_pending_exception
c_func
(paren
id|snap
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pe
)paren
(brace
id|snap-&gt;store
dot
id|drop_snapshot
c_func
(paren
op_amp
id|snap-&gt;store
)paren
suffix:semicolon
id|snap-&gt;valid
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|last
)paren
id|list_merge
c_func
(paren
op_amp
id|pe-&gt;siblings
comma
op_amp
id|last-&gt;siblings
)paren
suffix:semicolon
id|last
op_assign
id|pe
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|up_write
c_func
(paren
op_amp
id|snap-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now that we have a complete pe list we can start the copying.&n;&t; */
r_if
c_cond
(paren
id|last
)paren
(brace
id|pe
op_assign
id|last
suffix:semicolon
r_do
(brace
id|down_write
c_func
(paren
op_amp
id|pe-&gt;snap-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first
)paren
id|bio_list_add
c_func
(paren
op_amp
id|pe-&gt;origin_bios
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pe-&gt;started
)paren
(brace
id|pe-&gt;started
op_assign
l_int|1
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|pe-&gt;snap-&gt;lock
)paren
suffix:semicolon
id|start_copy
c_func
(paren
id|pe
)paren
suffix:semicolon
)brace
r_else
id|up_write
c_func
(paren
op_amp
id|pe-&gt;snap-&gt;lock
)paren
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
id|pe
op_assign
id|list_entry
c_func
(paren
id|pe-&gt;siblings.next
comma
r_struct
id|pending_exception
comma
id|siblings
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pe
op_ne
id|last
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * Called on a write from the origin driver.&n; */
DECL|function|do_origin
r_static
r_int
id|do_origin
c_func
(paren
r_struct
id|dm_dev
op_star
id|origin
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|origin
op_star
id|o
suffix:semicolon
r_int
id|r
op_assign
l_int|1
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|_origins_lock
)paren
suffix:semicolon
id|o
op_assign
id|__lookup_origin
c_func
(paren
id|origin-&gt;bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o
)paren
id|r
op_assign
id|__origin_write
c_func
(paren
op_amp
id|o-&gt;snapshots
comma
id|bio
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|_origins_lock
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * Origin: maps a linear range of a device, with hooks for snapshotting.&n; */
multiline_comment|/*&n; * Construct an origin mapping: &lt;dev_path&gt;&n; * The context for an origin is merely a &squot;struct dm_dev *&squot;&n; * pointing to the real device.&n; */
DECL|function|origin_ctr
r_static
r_int
id|origin_ctr
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_int
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|dm_dev
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_ne
l_int|1
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-origin: incorrect number of arguments&quot;
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|r
op_assign
id|dm_get_device
c_func
(paren
id|ti
comma
id|argv
(braket
l_int|0
)braket
comma
l_int|0
comma
id|ti-&gt;len
comma
id|dm_table_get_mode
c_func
(paren
id|ti-&gt;table
)paren
comma
op_amp
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;Cannot get target device&quot;
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
id|ti
op_member_access_from_pointer
r_private
op_assign
id|dev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|origin_dtr
r_static
r_void
id|origin_dtr
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|dm_dev
op_star
id|dev
op_assign
(paren
r_struct
id|dm_dev
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
id|dm_put_device
c_func
(paren
id|ti
comma
id|dev
)paren
suffix:semicolon
)brace
DECL|function|origin_map
r_static
r_int
id|origin_map
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_struct
id|bio
op_star
id|bio
comma
r_union
id|map_info
op_star
id|map_context
)paren
(brace
r_struct
id|dm_dev
op_star
id|dev
op_assign
(paren
r_struct
id|dm_dev
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|dev-&gt;bdev
suffix:semicolon
multiline_comment|/* Only tell snapshots if this is a write */
r_return
(paren
id|bio_rw
c_func
(paren
id|bio
)paren
op_eq
id|WRITE
)paren
ques
c_cond
id|do_origin
c_func
(paren
id|dev
comma
id|bio
)paren
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|macro|min_not_zero
mdefine_line|#define min_not_zero(l, r) (l == 0) ? r : ((r == 0) ? l : min(l, r))
multiline_comment|/*&n; * Set the target &quot;split_io&quot; field to the minimum of all the snapshots&squot;&n; * chunk sizes.&n; */
DECL|function|origin_resume
r_static
r_void
id|origin_resume
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|dm_dev
op_star
id|dev
op_assign
(paren
r_struct
id|dm_dev
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|dm_snapshot
op_star
id|snap
suffix:semicolon
r_struct
id|origin
op_star
id|o
suffix:semicolon
id|chunk_t
id|chunk_size
op_assign
l_int|0
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|_origins_lock
)paren
suffix:semicolon
id|o
op_assign
id|__lookup_origin
c_func
(paren
id|dev-&gt;bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o
)paren
id|list_for_each_entry
(paren
id|snap
comma
op_amp
id|o-&gt;snapshots
comma
id|list
)paren
id|chunk_size
op_assign
id|min_not_zero
c_func
(paren
id|chunk_size
comma
id|snap-&gt;chunk_size
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|_origins_lock
)paren
suffix:semicolon
id|ti-&gt;split_io
op_assign
id|chunk_size
suffix:semicolon
)brace
DECL|function|origin_status
r_static
r_int
id|origin_status
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
id|status_type_t
id|type
comma
r_char
op_star
id|result
comma
r_int
r_int
id|maxlen
)paren
(brace
r_struct
id|dm_dev
op_star
id|dev
op_assign
(paren
r_struct
id|dm_dev
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_char
id|buffer
(braket
l_int|32
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|STATUSTYPE_INFO
suffix:colon
id|result
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATUSTYPE_TABLE
suffix:colon
id|format_dev_t
c_func
(paren
id|buffer
comma
id|dev-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|result
comma
id|maxlen
comma
l_string|&quot;%s&quot;
comma
id|buffer
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|origin_target
r_static
r_struct
id|target_type
id|origin_target
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;snapshot-origin&quot;
comma
dot
id|version
op_assign
(brace
l_int|1
comma
l_int|0
comma
l_int|1
)brace
comma
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|ctr
op_assign
id|origin_ctr
comma
dot
id|dtr
op_assign
id|origin_dtr
comma
dot
id|map
op_assign
id|origin_map
comma
dot
id|resume
op_assign
id|origin_resume
comma
dot
id|status
op_assign
id|origin_status
comma
)brace
suffix:semicolon
DECL|variable|snapshot_target
r_static
r_struct
id|target_type
id|snapshot_target
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;snapshot&quot;
comma
dot
id|version
op_assign
(brace
l_int|1
comma
l_int|0
comma
l_int|1
)brace
comma
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|ctr
op_assign
id|snapshot_ctr
comma
dot
id|dtr
op_assign
id|snapshot_dtr
comma
dot
id|map
op_assign
id|snapshot_map
comma
dot
id|resume
op_assign
id|snapshot_resume
comma
dot
id|status
op_assign
id|snapshot_status
comma
)brace
suffix:semicolon
DECL|function|dm_snapshot_init
r_static
r_int
id|__init
id|dm_snapshot_init
c_func
(paren
r_void
)paren
(brace
r_int
id|r
suffix:semicolon
id|r
op_assign
id|dm_register_target
c_func
(paren
op_amp
id|snapshot_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;snapshot target register failed %d&quot;
comma
id|r
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
id|r
op_assign
id|dm_register_target
c_func
(paren
op_amp
id|origin_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;Device mapper: Origin: register failed %d&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
r_goto
id|bad1
suffix:semicolon
)brace
id|r
op_assign
id|init_origin_hash
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;init_origin_hash failed.&quot;
)paren
suffix:semicolon
r_goto
id|bad2
suffix:semicolon
)brace
id|exception_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;dm-snapshot-ex&quot;
comma
r_sizeof
(paren
r_struct
id|exception
)paren
comma
id|__alignof__
c_func
(paren
r_struct
id|exception
)paren
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|exception_cache
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;Couldn&squot;t create exception cache.&quot;
)paren
suffix:semicolon
id|r
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad3
suffix:semicolon
)brace
id|pending_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;dm-snapshot-in&quot;
comma
r_sizeof
(paren
r_struct
id|pending_exception
)paren
comma
id|__alignof__
c_func
(paren
r_struct
id|pending_exception
)paren
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pending_cache
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;Couldn&squot;t create pending cache.&quot;
)paren
suffix:semicolon
id|r
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad4
suffix:semicolon
)brace
id|pending_pool
op_assign
id|mempool_create
c_func
(paren
l_int|128
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|pending_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pending_pool
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;Couldn&squot;t create pending pool.&quot;
)paren
suffix:semicolon
id|r
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad5
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|bad5
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|pending_cache
)paren
suffix:semicolon
id|bad4
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|exception_cache
)paren
suffix:semicolon
id|bad3
suffix:colon
id|exit_origin_hash
c_func
(paren
)paren
suffix:semicolon
id|bad2
suffix:colon
id|dm_unregister_target
c_func
(paren
op_amp
id|origin_target
)paren
suffix:semicolon
id|bad1
suffix:colon
id|dm_unregister_target
c_func
(paren
op_amp
id|snapshot_target
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|dm_snapshot_exit
r_static
r_void
id|__exit
id|dm_snapshot_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|r
suffix:semicolon
id|r
op_assign
id|dm_unregister_target
c_func
(paren
op_amp
id|snapshot_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|DMERR
c_func
(paren
l_string|&quot;snapshot unregister failed %d&quot;
comma
id|r
)paren
suffix:semicolon
id|r
op_assign
id|dm_unregister_target
c_func
(paren
op_amp
id|origin_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|DMERR
c_func
(paren
l_string|&quot;origin unregister failed %d&quot;
comma
id|r
)paren
suffix:semicolon
id|exit_origin_hash
c_func
(paren
)paren
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|pending_pool
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|pending_cache
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|exception_cache
)paren
suffix:semicolon
)brace
multiline_comment|/* Module hooks */
DECL|variable|dm_snapshot_init
id|module_init
c_func
(paren
id|dm_snapshot_init
)paren
suffix:semicolon
DECL|variable|dm_snapshot_exit
id|module_exit
c_func
(paren
id|dm_snapshot_exit
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
id|DM_NAME
l_string|&quot; snapshot target&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Joe Thornber&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
