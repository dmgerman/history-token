multiline_comment|/*&n; * Copyright (C) 2003 Sistina Software Limited.&n; * Copyright (C) 2004-2005 Red Hat, Inc. All rights reserved.&n; *&n; * This file is released under the GPL.&n; */
macro_line|#include &quot;dm.h&quot;
macro_line|#include &quot;dm-path-selector.h&quot;
macro_line|#include &quot;dm-hw-handler.h&quot;
macro_line|#include &quot;dm-bio-list.h&quot;
macro_line|#include &quot;dm-bio-record.h&quot;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|macro|MESG_STR
mdefine_line|#define MESG_STR(x) x, sizeof(x)
multiline_comment|/* Path properties */
DECL|struct|pgpath
r_struct
id|pgpath
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|pg
r_struct
id|priority_group
op_star
id|pg
suffix:semicolon
multiline_comment|/* Owning PG */
DECL|member|fail_count
r_int
id|fail_count
suffix:semicolon
multiline_comment|/* Cumulative failure count */
DECL|member|path
r_struct
id|path
id|path
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|path_to_pgpath
mdefine_line|#define path_to_pgpath(__pgp) container_of((__pgp), struct pgpath, path)
multiline_comment|/*&n; * Paths are grouped into Priority Groups and numbered from 1 upwards.&n; * Each has a path selector which controls which path gets used.&n; */
DECL|struct|priority_group
r_struct
id|priority_group
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|m
r_struct
id|multipath
op_star
id|m
suffix:semicolon
multiline_comment|/* Owning multipath instance */
DECL|member|ps
r_struct
id|path_selector
id|ps
suffix:semicolon
DECL|member|pg_num
r_int
id|pg_num
suffix:semicolon
multiline_comment|/* Reference number */
DECL|member|bypassed
r_int
id|bypassed
suffix:semicolon
multiline_comment|/* Temporarily bypass this PG? */
DECL|member|nr_pgpaths
r_int
id|nr_pgpaths
suffix:semicolon
multiline_comment|/* Number of paths in PG */
DECL|member|pgpaths
r_struct
id|list_head
id|pgpaths
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Multipath context */
DECL|struct|multipath
r_struct
id|multipath
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|ti
r_struct
id|dm_target
op_star
id|ti
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|hw_handler
r_struct
id|hw_handler
id|hw_handler
suffix:semicolon
DECL|member|nr_priority_groups
r_int
id|nr_priority_groups
suffix:semicolon
DECL|member|priority_groups
r_struct
id|list_head
id|priority_groups
suffix:semicolon
DECL|member|pg_init_required
r_int
id|pg_init_required
suffix:semicolon
multiline_comment|/* pg_init needs calling? */
DECL|member|nr_valid_paths
r_int
id|nr_valid_paths
suffix:semicolon
multiline_comment|/* Total number of usable paths */
DECL|member|current_pgpath
r_struct
id|pgpath
op_star
id|current_pgpath
suffix:semicolon
DECL|member|current_pg
r_struct
id|priority_group
op_star
id|current_pg
suffix:semicolon
DECL|member|next_pg
r_struct
id|priority_group
op_star
id|next_pg
suffix:semicolon
multiline_comment|/* Switch to this PG if set */
DECL|member|repeat_count
r_int
id|repeat_count
suffix:semicolon
multiline_comment|/* I/Os left before calling PS again */
DECL|member|queue_io
r_int
id|queue_io
suffix:semicolon
multiline_comment|/* Must we queue all I/O? */
DECL|member|queue_if_no_path
r_int
id|queue_if_no_path
suffix:semicolon
multiline_comment|/* Queue I/O if last path fails? */
DECL|member|suspended
r_int
id|suspended
suffix:semicolon
multiline_comment|/* Has dm core suspended our I/O? */
DECL|member|process_queued_ios
r_struct
id|work_struct
id|process_queued_ios
suffix:semicolon
DECL|member|queued_ios
r_struct
id|bio_list
id|queued_ios
suffix:semicolon
DECL|member|queue_size
r_int
id|queue_size
suffix:semicolon
DECL|member|trigger_event
r_struct
id|work_struct
id|trigger_event
suffix:semicolon
multiline_comment|/*&n;&t; * We must use a mempool of mpath_io structs so that we&n;&t; * can resubmit bios on error.&n;&t; */
DECL|member|mpio_pool
id|mempool_t
op_star
id|mpio_pool
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Context information attached to each bio we process.&n; */
DECL|struct|mpath_io
r_struct
id|mpath_io
(brace
DECL|member|pgpath
r_struct
id|pgpath
op_star
id|pgpath
suffix:semicolon
DECL|member|details
r_struct
id|dm_bio_details
id|details
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|action_fn
r_typedef
r_int
(paren
op_star
id|action_fn
)paren
(paren
r_struct
id|pgpath
op_star
id|pgpath
)paren
suffix:semicolon
DECL|macro|MIN_IOS
mdefine_line|#define MIN_IOS 256&t;/* Mempool size */
DECL|variable|_mpio_cache
r_static
id|kmem_cache_t
op_star
id|_mpio_cache
suffix:semicolon
r_static
r_void
id|process_queued_ios
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_void
id|trigger_event
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
multiline_comment|/*-----------------------------------------------&n; * Allocation routines&n; *-----------------------------------------------*/
DECL|function|alloc_pgpath
r_static
r_struct
id|pgpath
op_star
id|alloc_pgpath
c_func
(paren
r_void
)paren
(brace
r_struct
id|pgpath
op_star
id|pgpath
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|pgpath
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgpath
)paren
(brace
id|memset
c_func
(paren
id|pgpath
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pgpath
)paren
)paren
suffix:semicolon
id|pgpath-&gt;path.is_active
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|pgpath
suffix:semicolon
)brace
DECL|function|free_pgpath
r_static
r_inline
r_void
id|free_pgpath
c_func
(paren
r_struct
id|pgpath
op_star
id|pgpath
)paren
(brace
id|kfree
c_func
(paren
id|pgpath
)paren
suffix:semicolon
)brace
DECL|function|alloc_priority_group
r_static
r_struct
id|priority_group
op_star
id|alloc_priority_group
c_func
(paren
r_void
)paren
(brace
r_struct
id|priority_group
op_star
id|pg
suffix:semicolon
id|pg
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|pg
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pg
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|pg
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pg
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pg-&gt;pgpaths
)paren
suffix:semicolon
r_return
id|pg
suffix:semicolon
)brace
DECL|function|free_pgpaths
r_static
r_void
id|free_pgpaths
c_func
(paren
r_struct
id|list_head
op_star
id|pgpaths
comma
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|pgpath
op_star
id|pgpath
comma
op_star
id|tmp
suffix:semicolon
id|list_for_each_entry_safe
(paren
id|pgpath
comma
id|tmp
comma
id|pgpaths
comma
id|list
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|pgpath-&gt;list
)paren
suffix:semicolon
id|dm_put_device
c_func
(paren
id|ti
comma
id|pgpath-&gt;path.dev
)paren
suffix:semicolon
id|free_pgpath
c_func
(paren
id|pgpath
)paren
suffix:semicolon
)brace
)brace
DECL|function|free_priority_group
r_static
r_void
id|free_priority_group
c_func
(paren
r_struct
id|priority_group
op_star
id|pg
comma
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|path_selector
op_star
id|ps
op_assign
op_amp
id|pg-&gt;ps
suffix:semicolon
r_if
c_cond
(paren
id|ps-&gt;type
)paren
(brace
id|ps-&gt;type
op_member_access_from_pointer
id|dtr
c_func
(paren
id|ps
)paren
suffix:semicolon
id|dm_put_path_selector
c_func
(paren
id|ps-&gt;type
)paren
suffix:semicolon
)brace
id|free_pgpaths
c_func
(paren
op_amp
id|pg-&gt;pgpaths
comma
id|ti
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pg
)paren
suffix:semicolon
)brace
DECL|function|alloc_multipath
r_static
r_struct
id|multipath
op_star
id|alloc_multipath
c_func
(paren
r_void
)paren
(brace
r_struct
id|multipath
op_star
id|m
suffix:semicolon
id|m
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|m
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
(brace
id|memset
c_func
(paren
id|m
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|m
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|m-&gt;priority_groups
)paren
suffix:semicolon
id|m-&gt;lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|m-&gt;queue_io
op_assign
l_int|1
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|m-&gt;process_queued_ios
comma
id|process_queued_ios
comma
id|m
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|m-&gt;trigger_event
comma
id|trigger_event
comma
id|m
)paren
suffix:semicolon
id|m-&gt;mpio_pool
op_assign
id|mempool_create
c_func
(paren
id|MIN_IOS
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|_mpio_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;mpio_pool
)paren
(brace
id|kfree
c_func
(paren
id|m
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|m
suffix:semicolon
)brace
DECL|function|free_multipath
r_static
r_void
id|free_multipath
c_func
(paren
r_struct
id|multipath
op_star
id|m
)paren
(brace
r_struct
id|priority_group
op_star
id|pg
comma
op_star
id|tmp
suffix:semicolon
r_struct
id|hw_handler
op_star
id|hwh
op_assign
op_amp
id|m-&gt;hw_handler
suffix:semicolon
id|list_for_each_entry_safe
(paren
id|pg
comma
id|tmp
comma
op_amp
id|m-&gt;priority_groups
comma
id|list
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|pg-&gt;list
)paren
suffix:semicolon
id|free_priority_group
c_func
(paren
id|pg
comma
id|m-&gt;ti
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwh-&gt;type
)paren
(brace
id|hwh-&gt;type
op_member_access_from_pointer
id|dtr
c_func
(paren
id|hwh
)paren
suffix:semicolon
id|dm_put_hw_handler
c_func
(paren
id|hwh-&gt;type
)paren
suffix:semicolon
)brace
id|mempool_destroy
c_func
(paren
id|m-&gt;mpio_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|m
)paren
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------&n; * Path selection&n; *-----------------------------------------------*/
DECL|function|__switch_pg
r_static
r_void
id|__switch_pg
c_func
(paren
r_struct
id|multipath
op_star
id|m
comma
r_struct
id|pgpath
op_star
id|pgpath
)paren
(brace
r_struct
id|hw_handler
op_star
id|hwh
op_assign
op_amp
id|m-&gt;hw_handler
suffix:semicolon
id|m-&gt;current_pg
op_assign
id|pgpath-&gt;pg
suffix:semicolon
multiline_comment|/* Must we initialise the PG first, and queue I/O till it&squot;s ready? */
r_if
c_cond
(paren
id|hwh-&gt;type
op_logical_and
id|hwh-&gt;type-&gt;pg_init
)paren
(brace
id|m-&gt;pg_init_required
op_assign
l_int|1
suffix:semicolon
id|m-&gt;queue_io
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|m-&gt;pg_init_required
op_assign
l_int|0
suffix:semicolon
id|m-&gt;queue_io
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|__choose_path_in_pg
r_static
r_int
id|__choose_path_in_pg
c_func
(paren
r_struct
id|multipath
op_star
id|m
comma
r_struct
id|priority_group
op_star
id|pg
)paren
(brace
r_struct
id|path
op_star
id|path
suffix:semicolon
id|path
op_assign
id|pg-&gt;ps.type
op_member_access_from_pointer
id|select_path
c_func
(paren
op_amp
id|pg-&gt;ps
comma
op_amp
id|m-&gt;repeat_count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|path
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|m-&gt;current_pgpath
op_assign
id|path_to_pgpath
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;current_pg
op_ne
id|pg
)paren
id|__switch_pg
c_func
(paren
id|m
comma
id|m-&gt;current_pgpath
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__choose_pgpath
r_static
r_void
id|__choose_pgpath
c_func
(paren
r_struct
id|multipath
op_star
id|m
)paren
(brace
r_struct
id|priority_group
op_star
id|pg
suffix:semicolon
r_int
id|bypassed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;nr_valid_paths
)paren
r_goto
id|failed
suffix:semicolon
multiline_comment|/* Were we instructed to switch PG? */
r_if
c_cond
(paren
id|m-&gt;next_pg
)paren
(brace
id|pg
op_assign
id|m-&gt;next_pg
suffix:semicolon
id|m-&gt;next_pg
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__choose_path_in_pg
c_func
(paren
id|m
comma
id|pg
)paren
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t change PG until it has no remaining paths */
r_if
c_cond
(paren
id|m-&gt;current_pg
op_logical_and
op_logical_neg
id|__choose_path_in_pg
c_func
(paren
id|m
comma
id|m-&gt;current_pg
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Loop through priority groups until we find a valid path.&n;&t; * First time we skip PGs marked &squot;bypassed&squot;.&n;&t; * Second time we only try the ones we skipped.&n;&t; */
r_do
(brace
id|list_for_each_entry
(paren
id|pg
comma
op_amp
id|m-&gt;priority_groups
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|pg-&gt;bypassed
op_eq
id|bypassed
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__choose_path_in_pg
c_func
(paren
id|m
comma
id|pg
)paren
)paren
r_return
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|bypassed
op_decrement
)paren
suffix:semicolon
id|failed
suffix:colon
id|m-&gt;current_pgpath
op_assign
l_int|NULL
suffix:semicolon
id|m-&gt;current_pg
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|map_io
r_static
r_int
id|map_io
c_func
(paren
r_struct
id|multipath
op_star
id|m
comma
r_struct
id|bio
op_star
id|bio
comma
r_struct
id|mpath_io
op_star
id|mpio
comma
r_int
id|was_queued
)paren
(brace
r_int
id|r
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|pgpath
op_star
id|pgpath
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Do we need to select a new pgpath? */
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;current_pgpath
op_logical_or
(paren
op_logical_neg
id|m-&gt;queue_io
op_logical_and
(paren
id|m-&gt;repeat_count
op_logical_and
op_decrement
id|m-&gt;repeat_count
op_eq
l_int|0
)paren
)paren
)paren
id|__choose_pgpath
c_func
(paren
id|m
)paren
suffix:semicolon
id|pgpath
op_assign
id|m-&gt;current_pgpath
suffix:semicolon
r_if
c_cond
(paren
id|was_queued
)paren
id|m-&gt;queue_size
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pgpath
op_logical_and
id|m-&gt;queue_io
)paren
op_logical_or
(paren
op_logical_neg
id|pgpath
op_logical_and
id|m-&gt;queue_if_no_path
op_logical_and
op_logical_neg
id|m-&gt;suspended
)paren
)paren
(brace
multiline_comment|/* Queue for the daemon to resubmit */
id|bio_list_add
c_func
(paren
op_amp
id|m-&gt;queued_ios
comma
id|bio
)paren
suffix:semicolon
id|m-&gt;queue_size
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;pg_init_required
op_logical_or
op_logical_neg
id|m-&gt;queue_io
)paren
id|schedule_work
c_func
(paren
op_amp
id|m-&gt;process_queued_ios
)paren
suffix:semicolon
id|pgpath
op_assign
l_int|NULL
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|pgpath
)paren
id|r
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Failed */
r_else
id|bio-&gt;bi_bdev
op_assign
id|pgpath-&gt;path.dev-&gt;bdev
suffix:semicolon
id|mpio-&gt;pgpath
op_assign
id|pgpath
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * If we run out of usable paths, should we queue I/O or error it?&n; */
DECL|function|queue_if_no_path
r_static
r_int
id|queue_if_no_path
c_func
(paren
r_struct
id|multipath
op_star
id|m
comma
r_int
id|queue_if_no_path
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|m-&gt;queue_if_no_path
op_assign
id|queue_if_no_path
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;queue_if_no_path
)paren
id|schedule_work
c_func
(paren
op_amp
id|m-&gt;process_queued_ios
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * The multipath daemon is responsible for resubmitting queued ios.&n; *---------------------------------------------------------------*/
DECL|function|dispatch_queued_ios
r_static
r_void
id|dispatch_queued_ios
c_func
(paren
r_struct
id|multipath
op_star
id|m
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|bio
op_star
id|bio
op_assign
l_int|NULL
comma
op_star
id|next
suffix:semicolon
r_struct
id|mpath_io
op_star
id|mpio
suffix:semicolon
r_union
id|map_info
op_star
id|info
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|bio
op_assign
id|bio_list_get
c_func
(paren
op_amp
id|m-&gt;queued_ios
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bio
)paren
(brace
id|next
op_assign
id|bio-&gt;bi_next
suffix:semicolon
id|bio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
id|info
op_assign
id|dm_get_mapinfo
c_func
(paren
id|bio
)paren
suffix:semicolon
id|mpio
op_assign
id|info-&gt;ptr
suffix:semicolon
id|r
op_assign
id|map_io
c_func
(paren
id|m
comma
id|bio
comma
id|mpio
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
id|bio_endio
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
comma
id|r
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r
op_eq
l_int|1
)paren
id|generic_make_request
c_func
(paren
id|bio
)paren
suffix:semicolon
id|bio
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|function|process_queued_ios
r_static
r_void
id|process_queued_ios
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|multipath
op_star
id|m
op_assign
(paren
r_struct
id|multipath
op_star
)paren
id|data
suffix:semicolon
r_struct
id|hw_handler
op_star
id|hwh
op_assign
op_amp
id|m-&gt;hw_handler
suffix:semicolon
r_struct
id|pgpath
op_star
id|pgpath
suffix:semicolon
r_int
id|init_required
comma
id|must_queue
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;current_pgpath
)paren
id|__choose_pgpath
c_func
(paren
id|m
)paren
suffix:semicolon
id|pgpath
op_assign
id|m-&gt;current_pgpath
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pgpath
op_logical_and
id|m-&gt;queue_io
)paren
op_logical_or
(paren
op_logical_neg
id|pgpath
op_logical_and
id|m-&gt;queue_if_no_path
op_logical_and
op_logical_neg
id|m-&gt;suspended
)paren
)paren
id|must_queue
op_assign
l_int|1
suffix:semicolon
id|init_required
op_assign
id|m-&gt;pg_init_required
suffix:semicolon
r_if
c_cond
(paren
id|init_required
)paren
id|m-&gt;pg_init_required
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_required
)paren
id|hwh-&gt;type
op_member_access_from_pointer
id|pg_init
c_func
(paren
id|hwh
comma
id|pgpath-&gt;pg-&gt;bypassed
comma
op_amp
id|pgpath-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|must_queue
)paren
id|dispatch_queued_ios
c_func
(paren
id|m
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * An event is triggered whenever a path is taken out of use.&n; * Includes path failure and PG bypass.&n; */
DECL|function|trigger_event
r_static
r_void
id|trigger_event
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|multipath
op_star
id|m
op_assign
(paren
r_struct
id|multipath
op_star
)paren
id|data
suffix:semicolon
id|dm_table_event
c_func
(paren
id|m-&gt;ti-&gt;table
)paren
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * Constructor/argument parsing:&n; * &lt;#multipath feature args&gt; [&lt;arg&gt;]*&n; * &lt;#hw_handler args&gt; [hw_handler [&lt;arg&gt;]*]&n; * &lt;#priority groups&gt;&n; * &lt;initial priority group&gt;&n; *     [&lt;selector&gt; &lt;#selector args&gt; [&lt;arg&gt;]*&n; *      &lt;#paths&gt; &lt;#per-path selector args&gt;&n; *         [&lt;path&gt; [&lt;arg&gt;]* ]+ ]+&n; *---------------------------------------------------------------*/
DECL|struct|param
r_struct
id|param
(brace
DECL|member|min
r_int
id|min
suffix:semicolon
DECL|member|max
r_int
id|max
suffix:semicolon
DECL|member|error
r_char
op_star
id|error
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|ESTR
mdefine_line|#define ESTR(s) (&quot;dm-multipath: &quot; s)
DECL|function|read_param
r_static
r_int
id|read_param
c_func
(paren
r_struct
id|param
op_star
id|param
comma
r_char
op_star
id|str
comma
r_int
op_star
id|v
comma
r_char
op_star
op_star
id|error
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|str
op_logical_or
(paren
id|sscanf
c_func
(paren
id|str
comma
l_string|&quot;%u&quot;
comma
id|v
)paren
op_ne
l_int|1
)paren
op_logical_or
(paren
op_star
id|v
OL
id|param-&gt;min
)paren
op_logical_or
(paren
op_star
id|v
OG
id|param-&gt;max
)paren
)paren
(brace
op_star
id|error
op_assign
id|param-&gt;error
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|arg_set
r_struct
id|arg_set
(brace
DECL|member|argc
r_int
id|argc
suffix:semicolon
DECL|member|argv
r_char
op_star
op_star
id|argv
suffix:semicolon
)brace
suffix:semicolon
DECL|function|shift
r_static
r_char
op_star
id|shift
c_func
(paren
r_struct
id|arg_set
op_star
id|as
)paren
(brace
r_char
op_star
id|r
suffix:semicolon
r_if
c_cond
(paren
id|as-&gt;argc
)paren
(brace
id|as-&gt;argc
op_decrement
suffix:semicolon
id|r
op_assign
op_star
id|as-&gt;argv
suffix:semicolon
id|as-&gt;argv
op_increment
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|consume
r_static
r_void
id|consume
c_func
(paren
r_struct
id|arg_set
op_star
id|as
comma
r_int
id|n
)paren
(brace
id|BUG_ON
(paren
id|as-&gt;argc
OL
id|n
)paren
suffix:semicolon
id|as-&gt;argc
op_sub_assign
id|n
suffix:semicolon
id|as-&gt;argv
op_add_assign
id|n
suffix:semicolon
)brace
DECL|function|parse_path_selector
r_static
r_int
id|parse_path_selector
c_func
(paren
r_struct
id|arg_set
op_star
id|as
comma
r_struct
id|priority_group
op_star
id|pg
comma
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|path_selector_type
op_star
id|pst
suffix:semicolon
r_int
id|ps_argc
suffix:semicolon
r_static
r_struct
id|param
id|_params
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|1024
comma
id|ESTR
c_func
(paren
l_string|&quot;invalid number of path selector args&quot;
)paren
)brace
comma
)brace
suffix:semicolon
id|pst
op_assign
id|dm_get_path_selector
c_func
(paren
id|shift
c_func
(paren
id|as
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pst
)paren
(brace
id|ti-&gt;error
op_assign
id|ESTR
c_func
(paren
l_string|&quot;unknown path selector type&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|r
op_assign
id|read_param
c_func
(paren
id|_params
comma
id|shift
c_func
(paren
id|as
)paren
comma
op_amp
id|ps_argc
comma
op_amp
id|ti-&gt;error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|r
op_assign
id|pst
op_member_access_from_pointer
id|ctr
c_func
(paren
op_amp
id|pg-&gt;ps
comma
id|ps_argc
comma
id|as-&gt;argv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|dm_put_path_selector
c_func
(paren
id|pst
)paren
suffix:semicolon
id|ti-&gt;error
op_assign
id|ESTR
c_func
(paren
l_string|&quot;path selector constructor failed&quot;
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
id|pg-&gt;ps.type
op_assign
id|pst
suffix:semicolon
id|consume
c_func
(paren
id|as
comma
id|ps_argc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_path
r_static
r_struct
id|pgpath
op_star
id|parse_path
c_func
(paren
r_struct
id|arg_set
op_star
id|as
comma
r_struct
id|path_selector
op_star
id|ps
comma
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|pgpath
op_star
id|p
suffix:semicolon
multiline_comment|/* we need at least a path arg */
r_if
c_cond
(paren
id|as-&gt;argc
OL
l_int|1
)paren
(brace
id|ti-&gt;error
op_assign
id|ESTR
c_func
(paren
l_string|&quot;no device given&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|p
op_assign
id|alloc_pgpath
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|NULL
suffix:semicolon
id|r
op_assign
id|dm_get_device
c_func
(paren
id|ti
comma
id|shift
c_func
(paren
id|as
)paren
comma
id|ti-&gt;begin
comma
id|ti-&gt;len
comma
id|dm_table_get_mode
c_func
(paren
id|ti-&gt;table
)paren
comma
op_amp
id|p-&gt;path.dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|ti-&gt;error
op_assign
id|ESTR
c_func
(paren
l_string|&quot;error getting device&quot;
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
id|r
op_assign
id|ps-&gt;type
op_member_access_from_pointer
id|add_path
c_func
(paren
id|ps
comma
op_amp
id|p-&gt;path
comma
id|as-&gt;argc
comma
id|as-&gt;argv
comma
op_amp
id|ti-&gt;error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|dm_put_device
c_func
(paren
id|ti
comma
id|p-&gt;path.dev
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
id|bad
suffix:colon
id|free_pgpath
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|parse_priority_group
r_static
r_struct
id|priority_group
op_star
id|parse_priority_group
c_func
(paren
r_struct
id|arg_set
op_star
id|as
comma
r_struct
id|multipath
op_star
id|m
comma
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_static
r_struct
id|param
id|_params
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_int|1024
comma
id|ESTR
c_func
(paren
l_string|&quot;invalid number of paths&quot;
)paren
)brace
comma
(brace
l_int|0
comma
l_int|1024
comma
id|ESTR
c_func
(paren
l_string|&quot;invalid number of selector args&quot;
)paren
)brace
)brace
suffix:semicolon
r_int
id|r
suffix:semicolon
r_int
id|i
comma
id|nr_selector_args
comma
id|nr_params
suffix:semicolon
r_struct
id|priority_group
op_star
id|pg
suffix:semicolon
r_if
c_cond
(paren
id|as-&gt;argc
OL
l_int|2
)paren
(brace
id|as-&gt;argc
op_assign
l_int|0
suffix:semicolon
id|ti-&gt;error
op_assign
id|ESTR
c_func
(paren
l_string|&quot;not enough priority group aruments&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|pg
op_assign
id|alloc_priority_group
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pg
)paren
(brace
id|ti-&gt;error
op_assign
id|ESTR
c_func
(paren
l_string|&quot;couldn&squot;t allocate priority group&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|pg-&gt;m
op_assign
id|m
suffix:semicolon
id|r
op_assign
id|parse_path_selector
c_func
(paren
id|as
comma
id|pg
comma
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_goto
id|bad
suffix:semicolon
multiline_comment|/*&n;&t; * read the paths&n;&t; */
id|r
op_assign
id|read_param
c_func
(paren
id|_params
comma
id|shift
c_func
(paren
id|as
)paren
comma
op_amp
id|pg-&gt;nr_pgpaths
comma
op_amp
id|ti-&gt;error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_goto
id|bad
suffix:semicolon
id|r
op_assign
id|read_param
c_func
(paren
id|_params
op_plus
l_int|1
comma
id|shift
c_func
(paren
id|as
)paren
comma
op_amp
id|nr_selector_args
comma
op_amp
id|ti-&gt;error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_goto
id|bad
suffix:semicolon
id|nr_params
op_assign
l_int|1
op_plus
id|nr_selector_args
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pg-&gt;nr_pgpaths
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|pgpath
op_star
id|pgpath
suffix:semicolon
r_struct
id|arg_set
id|path_args
suffix:semicolon
r_if
c_cond
(paren
id|as-&gt;argc
OL
id|nr_params
)paren
r_goto
id|bad
suffix:semicolon
id|path_args.argc
op_assign
id|nr_params
suffix:semicolon
id|path_args.argv
op_assign
id|as-&gt;argv
suffix:semicolon
id|pgpath
op_assign
id|parse_path
c_func
(paren
op_amp
id|path_args
comma
op_amp
id|pg-&gt;ps
comma
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgpath
)paren
r_goto
id|bad
suffix:semicolon
id|pgpath-&gt;pg
op_assign
id|pg
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|pgpath-&gt;list
comma
op_amp
id|pg-&gt;pgpaths
)paren
suffix:semicolon
id|consume
c_func
(paren
id|as
comma
id|nr_params
)paren
suffix:semicolon
)brace
r_return
id|pg
suffix:semicolon
id|bad
suffix:colon
id|free_priority_group
c_func
(paren
id|pg
comma
id|ti
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|parse_hw_handler
r_static
r_int
id|parse_hw_handler
c_func
(paren
r_struct
id|arg_set
op_star
id|as
comma
r_struct
id|multipath
op_star
id|m
comma
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|hw_handler_type
op_star
id|hwht
suffix:semicolon
r_int
id|hw_argc
suffix:semicolon
r_static
r_struct
id|param
id|_params
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|1024
comma
id|ESTR
c_func
(paren
l_string|&quot;invalid number of hardware handler args&quot;
)paren
)brace
comma
)brace
suffix:semicolon
id|r
op_assign
id|read_param
c_func
(paren
id|_params
comma
id|shift
c_func
(paren
id|as
)paren
comma
op_amp
id|hw_argc
comma
op_amp
id|ti-&gt;error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hw_argc
)paren
r_return
l_int|0
suffix:semicolon
id|hwht
op_assign
id|dm_get_hw_handler
c_func
(paren
id|shift
c_func
(paren
id|as
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwht
)paren
(brace
id|ti-&gt;error
op_assign
id|ESTR
c_func
(paren
l_string|&quot;unknown hardware handler type&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|r
op_assign
id|hwht
op_member_access_from_pointer
id|ctr
c_func
(paren
op_amp
id|m-&gt;hw_handler
comma
id|hw_argc
op_minus
l_int|1
comma
id|as-&gt;argv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|dm_put_hw_handler
c_func
(paren
id|hwht
)paren
suffix:semicolon
id|ti-&gt;error
op_assign
id|ESTR
c_func
(paren
l_string|&quot;hardware handler constructor failed&quot;
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
id|m-&gt;hw_handler.type
op_assign
id|hwht
suffix:semicolon
id|consume
c_func
(paren
id|as
comma
id|hw_argc
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_features
r_static
r_int
id|parse_features
c_func
(paren
r_struct
id|arg_set
op_star
id|as
comma
r_struct
id|multipath
op_star
id|m
comma
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
id|argc
suffix:semicolon
r_static
r_struct
id|param
id|_params
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|1
comma
id|ESTR
c_func
(paren
l_string|&quot;invalid number of feature args&quot;
)paren
)brace
comma
)brace
suffix:semicolon
id|r
op_assign
id|read_param
c_func
(paren
id|_params
comma
id|shift
c_func
(paren
id|as
)paren
comma
op_amp
id|argc
comma
op_amp
id|ti-&gt;error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|argc
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strnicmp
c_func
(paren
id|shift
c_func
(paren
id|as
)paren
comma
id|MESG_STR
c_func
(paren
l_string|&quot;queue_if_no_path&quot;
)paren
)paren
)paren
r_return
id|queue_if_no_path
c_func
(paren
id|m
comma
l_int|1
)paren
suffix:semicolon
r_else
(brace
id|ti-&gt;error
op_assign
l_string|&quot;Unrecognised multipath feature request&quot;
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|multipath_ctr
r_static
r_int
id|multipath_ctr
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_int
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
multiline_comment|/* target parameters */
r_static
r_struct
id|param
id|_params
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_int|1024
comma
id|ESTR
c_func
(paren
l_string|&quot;invalid number of priority groups&quot;
)paren
)brace
comma
(brace
l_int|1
comma
l_int|1024
comma
id|ESTR
c_func
(paren
l_string|&quot;invalid initial priority group number&quot;
)paren
)brace
comma
)brace
suffix:semicolon
r_int
id|r
suffix:semicolon
r_struct
id|multipath
op_star
id|m
suffix:semicolon
r_struct
id|arg_set
id|as
suffix:semicolon
r_int
id|pg_count
op_assign
l_int|0
suffix:semicolon
r_int
id|next_pg_num
suffix:semicolon
id|as.argc
op_assign
id|argc
suffix:semicolon
id|as.argv
op_assign
id|argv
suffix:semicolon
id|m
op_assign
id|alloc_multipath
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m
)paren
(brace
id|ti-&gt;error
op_assign
id|ESTR
c_func
(paren
l_string|&quot;can&squot;t allocate multipath&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|r
op_assign
id|parse_features
c_func
(paren
op_amp
id|as
comma
id|m
comma
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_goto
id|bad
suffix:semicolon
id|r
op_assign
id|parse_hw_handler
c_func
(paren
op_amp
id|as
comma
id|m
comma
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_goto
id|bad
suffix:semicolon
id|r
op_assign
id|read_param
c_func
(paren
id|_params
comma
id|shift
c_func
(paren
op_amp
id|as
)paren
comma
op_amp
id|m-&gt;nr_priority_groups
comma
op_amp
id|ti-&gt;error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_goto
id|bad
suffix:semicolon
id|r
op_assign
id|read_param
c_func
(paren
id|_params
op_plus
l_int|1
comma
id|shift
c_func
(paren
op_amp
id|as
)paren
comma
op_amp
id|next_pg_num
comma
op_amp
id|ti-&gt;error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_goto
id|bad
suffix:semicolon
multiline_comment|/* parse the priority groups */
r_while
c_loop
(paren
id|as.argc
)paren
(brace
r_struct
id|priority_group
op_star
id|pg
suffix:semicolon
id|pg
op_assign
id|parse_priority_group
c_func
(paren
op_amp
id|as
comma
id|m
comma
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pg
)paren
(brace
id|r
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
id|m-&gt;nr_valid_paths
op_add_assign
id|pg-&gt;nr_pgpaths
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|pg-&gt;list
comma
op_amp
id|m-&gt;priority_groups
)paren
suffix:semicolon
id|pg_count
op_increment
suffix:semicolon
id|pg-&gt;pg_num
op_assign
id|pg_count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|next_pg_num
)paren
id|m-&gt;next_pg
op_assign
id|pg
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pg_count
op_ne
id|m-&gt;nr_priority_groups
)paren
(brace
id|ti-&gt;error
op_assign
id|ESTR
c_func
(paren
l_string|&quot;priority group count mismatch&quot;
)paren
suffix:semicolon
id|r
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
id|ti
op_member_access_from_pointer
r_private
op_assign
id|m
suffix:semicolon
id|m-&gt;ti
op_assign
id|ti
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bad
suffix:colon
id|free_multipath
c_func
(paren
id|m
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|multipath_dtr
r_static
r_void
id|multipath_dtr
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|multipath
op_star
id|m
op_assign
(paren
r_struct
id|multipath
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
id|free_multipath
c_func
(paren
id|m
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Map bios, recording original fields for later in case we have to resubmit&n; */
DECL|function|multipath_map
r_static
r_int
id|multipath_map
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_struct
id|bio
op_star
id|bio
comma
r_union
id|map_info
op_star
id|map_context
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|mpath_io
op_star
id|mpio
suffix:semicolon
r_struct
id|multipath
op_star
id|m
op_assign
(paren
r_struct
id|multipath
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
id|mpio
op_assign
id|mempool_alloc
c_func
(paren
id|m-&gt;mpio_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|dm_bio_record
c_func
(paren
op_amp
id|mpio-&gt;details
comma
id|bio
)paren
suffix:semicolon
id|map_context-&gt;ptr
op_assign
id|mpio
suffix:semicolon
id|bio-&gt;bi_rw
op_or_assign
(paren
l_int|1
op_lshift
id|BIO_RW_FAILFAST
)paren
suffix:semicolon
id|r
op_assign
id|map_io
c_func
(paren
id|m
comma
id|bio
comma
id|mpio
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
id|mempool_free
c_func
(paren
id|mpio
comma
id|m-&gt;mpio_pool
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * Take a path out of use.&n; */
DECL|function|fail_path
r_static
r_int
id|fail_path
c_func
(paren
r_struct
id|pgpath
op_star
id|pgpath
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|multipath
op_star
id|m
op_assign
id|pgpath-&gt;pg-&gt;m
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgpath-&gt;path.is_active
)paren
r_goto
id|out
suffix:semicolon
id|DMWARN
c_func
(paren
l_string|&quot;dm-multipath: Failing path %s.&quot;
comma
id|pgpath-&gt;path.dev-&gt;name
)paren
suffix:semicolon
id|pgpath-&gt;pg-&gt;ps.type
op_member_access_from_pointer
id|fail_path
c_func
(paren
op_amp
id|pgpath-&gt;pg-&gt;ps
comma
op_amp
id|pgpath-&gt;path
)paren
suffix:semicolon
id|pgpath-&gt;path.is_active
op_assign
l_int|0
suffix:semicolon
id|pgpath-&gt;fail_count
op_increment
suffix:semicolon
id|m-&gt;nr_valid_paths
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|pgpath
op_eq
id|m-&gt;current_pgpath
)paren
id|m-&gt;current_pgpath
op_assign
l_int|NULL
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|m-&gt;trigger_event
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Reinstate a previously-failed path&n; */
DECL|function|reinstate_path
r_static
r_int
id|reinstate_path
c_func
(paren
r_struct
id|pgpath
op_star
id|pgpath
)paren
(brace
r_int
id|r
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|multipath
op_star
id|m
op_assign
id|pgpath-&gt;pg-&gt;m
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgpath-&gt;path.is_active
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgpath-&gt;pg-&gt;ps.type
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;Reinstate path not supported by path selector %s&quot;
comma
id|pgpath-&gt;pg-&gt;ps.type-&gt;name
)paren
suffix:semicolon
id|r
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|r
op_assign
id|pgpath-&gt;pg-&gt;ps.type
op_member_access_from_pointer
id|reinstate_path
c_func
(paren
op_amp
id|pgpath-&gt;pg-&gt;ps
comma
op_amp
id|pgpath-&gt;path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_goto
id|out
suffix:semicolon
id|pgpath-&gt;path.is_active
op_assign
l_int|1
suffix:semicolon
id|m-&gt;current_pgpath
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;nr_valid_paths
op_increment
)paren
id|schedule_work
c_func
(paren
op_amp
id|m-&gt;process_queued_ios
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|m-&gt;trigger_event
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * Fail or reinstate all paths that match the provided struct dm_dev.&n; */
DECL|function|action_dev
r_static
r_int
id|action_dev
c_func
(paren
r_struct
id|multipath
op_star
id|m
comma
r_struct
id|dm_dev
op_star
id|dev
comma
id|action_fn
id|action
)paren
(brace
r_int
id|r
op_assign
l_int|0
suffix:semicolon
r_struct
id|pgpath
op_star
id|pgpath
suffix:semicolon
r_struct
id|priority_group
op_star
id|pg
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|pg
comma
op_amp
id|m-&gt;priority_groups
comma
id|list
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|pgpath
comma
op_amp
id|pg-&gt;pgpaths
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|pgpath-&gt;path.dev
op_eq
id|dev
)paren
id|r
op_assign
id|action
c_func
(paren
id|pgpath
)paren
suffix:semicolon
)brace
)brace
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * Temporarily try to avoid having to use the specified PG&n; */
DECL|function|bypass_pg
r_static
r_void
id|bypass_pg
c_func
(paren
r_struct
id|multipath
op_star
id|m
comma
r_struct
id|priority_group
op_star
id|pg
comma
r_int
id|bypassed
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|pg-&gt;bypassed
op_assign
id|bypassed
suffix:semicolon
id|m-&gt;current_pgpath
op_assign
l_int|NULL
suffix:semicolon
id|m-&gt;current_pg
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|m-&gt;trigger_event
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Switch to using the specified PG from the next I/O that gets mapped&n; */
DECL|function|switch_pg_num
r_static
r_int
id|switch_pg_num
c_func
(paren
r_struct
id|multipath
op_star
id|m
comma
r_const
r_char
op_star
id|pgstr
)paren
(brace
r_struct
id|priority_group
op_star
id|pg
suffix:semicolon
r_int
id|pgnum
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgstr
op_logical_or
(paren
id|sscanf
c_func
(paren
id|pgstr
comma
l_string|&quot;%u&quot;
comma
op_amp
id|pgnum
)paren
op_ne
l_int|1
)paren
op_logical_or
op_logical_neg
id|pgnum
op_logical_or
(paren
id|pgnum
OG
id|m-&gt;nr_priority_groups
)paren
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;invalid PG number supplied to switch_pg_num&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|pg
comma
op_amp
id|m-&gt;priority_groups
comma
id|list
)paren
(brace
id|pg-&gt;bypassed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|pgnum
)paren
r_continue
suffix:semicolon
id|m-&gt;current_pgpath
op_assign
l_int|NULL
suffix:semicolon
id|m-&gt;current_pg
op_assign
l_int|NULL
suffix:semicolon
id|m-&gt;next_pg
op_assign
id|pg
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|m-&gt;trigger_event
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Set/clear bypassed status of a PG.&n; * PGs are numbered upwards from 1 in the order they were declared.&n; */
DECL|function|bypass_pg_num
r_static
r_int
id|bypass_pg_num
c_func
(paren
r_struct
id|multipath
op_star
id|m
comma
r_const
r_char
op_star
id|pgstr
comma
r_int
id|bypassed
)paren
(brace
r_struct
id|priority_group
op_star
id|pg
suffix:semicolon
r_int
id|pgnum
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgstr
op_logical_or
(paren
id|sscanf
c_func
(paren
id|pgstr
comma
l_string|&quot;%u&quot;
comma
op_amp
id|pgnum
)paren
op_ne
l_int|1
)paren
op_logical_or
op_logical_neg
id|pgnum
op_logical_or
(paren
id|pgnum
OG
id|m-&gt;nr_priority_groups
)paren
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;invalid PG number supplied to bypass_pg&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|list_for_each_entry
c_func
(paren
id|pg
comma
op_amp
id|m-&gt;priority_groups
comma
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|pgnum
)paren
r_break
suffix:semicolon
)brace
id|bypass_pg
c_func
(paren
id|m
comma
id|pg
comma
id|bypassed
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * pg_init must call this when it has completed its initialisation&n; */
DECL|function|dm_pg_init_complete
r_void
id|dm_pg_init_complete
c_func
(paren
r_struct
id|path
op_star
id|path
comma
r_int
id|err_flags
)paren
(brace
r_struct
id|pgpath
op_star
id|pgpath
op_assign
id|path_to_pgpath
c_func
(paren
id|path
)paren
suffix:semicolon
r_struct
id|priority_group
op_star
id|pg
op_assign
id|pgpath-&gt;pg
suffix:semicolon
r_struct
id|multipath
op_star
id|m
op_assign
id|pg-&gt;m
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* We insist on failing the path if the PG is already bypassed. */
r_if
c_cond
(paren
id|err_flags
op_logical_and
id|pg-&gt;bypassed
)paren
id|err_flags
op_or_assign
id|MP_FAIL_PATH
suffix:semicolon
r_if
c_cond
(paren
id|err_flags
op_amp
id|MP_FAIL_PATH
)paren
id|fail_path
c_func
(paren
id|pgpath
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err_flags
op_amp
id|MP_BYPASS_PG
)paren
id|bypass_pg
c_func
(paren
id|m
comma
id|pg
comma
l_int|1
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err_flags
)paren
id|m-&gt;queue_io
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|m-&gt;current_pgpath
op_assign
l_int|NULL
suffix:semicolon
id|m-&gt;current_pg
op_assign
l_int|NULL
suffix:semicolon
)brace
id|schedule_work
c_func
(paren
op_amp
id|m-&gt;process_queued_ios
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * end_io handling&n; */
DECL|function|do_end_io
r_static
r_int
id|do_end_io
c_func
(paren
r_struct
id|multipath
op_star
id|m
comma
r_struct
id|bio
op_star
id|bio
comma
r_int
id|error
comma
r_struct
id|mpath_io
op_star
id|mpio
)paren
(brace
r_struct
id|hw_handler
op_star
id|hwh
op_assign
op_amp
id|m-&gt;hw_handler
suffix:semicolon
r_int
id|err_flags
op_assign
id|MP_FAIL_PATH
suffix:semicolon
multiline_comment|/* Default behavior */
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* I/O complete */
id|spin_lock
c_func
(paren
op_amp
id|m-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;nr_valid_paths
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;queue_if_no_path
op_logical_or
id|m-&gt;suspended
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|m-&gt;lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock
c_func
(paren
op_amp
id|m-&gt;lock
)paren
suffix:semicolon
r_goto
id|requeue
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|m-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwh-&gt;type
op_logical_and
id|hwh-&gt;type-&gt;err
)paren
id|err_flags
op_assign
id|hwh-&gt;type
op_member_access_from_pointer
id|err
c_func
(paren
id|hwh
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpio-&gt;pgpath
)paren
(brace
r_if
c_cond
(paren
id|err_flags
op_amp
id|MP_FAIL_PATH
)paren
id|fail_path
c_func
(paren
id|mpio-&gt;pgpath
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err_flags
op_amp
id|MP_BYPASS_PG
)paren
id|bypass_pg
c_func
(paren
id|m
comma
id|mpio-&gt;pgpath-&gt;pg
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err_flags
op_amp
id|MP_ERROR_IO
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|requeue
suffix:colon
id|dm_bio_restore
c_func
(paren
op_amp
id|mpio-&gt;details
comma
id|bio
)paren
suffix:semicolon
multiline_comment|/* queue for the daemon to resubmit or fail */
id|spin_lock
c_func
(paren
op_amp
id|m-&gt;lock
)paren
suffix:semicolon
id|bio_list_add
c_func
(paren
op_amp
id|m-&gt;queued_ios
comma
id|bio
)paren
suffix:semicolon
id|m-&gt;queue_size
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m-&gt;queue_io
)paren
id|schedule_work
c_func
(paren
op_amp
id|m-&gt;process_queued_ios
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|m-&gt;lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* io not complete */
)brace
DECL|function|multipath_end_io
r_static
r_int
id|multipath_end_io
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_struct
id|bio
op_star
id|bio
comma
r_int
id|error
comma
r_union
id|map_info
op_star
id|map_context
)paren
(brace
r_struct
id|multipath
op_star
id|m
op_assign
(paren
r_struct
id|multipath
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|mpath_io
op_star
id|mpio
op_assign
(paren
r_struct
id|mpath_io
op_star
)paren
id|map_context-&gt;ptr
suffix:semicolon
r_struct
id|pgpath
op_star
id|pgpath
op_assign
id|mpio-&gt;pgpath
suffix:semicolon
r_struct
id|path_selector
op_star
id|ps
suffix:semicolon
r_int
id|r
suffix:semicolon
id|r
op_assign
id|do_end_io
c_func
(paren
id|m
comma
id|bio
comma
id|error
comma
id|mpio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgpath
)paren
(brace
id|ps
op_assign
op_amp
id|pgpath-&gt;pg-&gt;ps
suffix:semicolon
r_if
c_cond
(paren
id|ps-&gt;type-&gt;end_io
)paren
id|ps-&gt;type
op_member_access_from_pointer
id|end_io
c_func
(paren
id|ps
comma
op_amp
id|pgpath-&gt;path
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r
op_le
l_int|0
)paren
id|mempool_free
c_func
(paren
id|mpio
comma
id|m-&gt;mpio_pool
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * Suspend can&squot;t complete until all the I/O is processed so if&n; * the last path failed we will now error any queued I/O.&n; */
DECL|function|multipath_presuspend
r_static
r_void
id|multipath_presuspend
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|multipath
op_star
id|m
op_assign
(paren
r_struct
id|multipath
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|m-&gt;suspended
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;queue_if_no_path
)paren
id|schedule_work
c_func
(paren
op_amp
id|m-&gt;process_queued_ios
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|multipath_resume
r_static
r_void
id|multipath_resume
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|multipath
op_star
id|m
op_assign
(paren
r_struct
id|multipath
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|m-&gt;suspended
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Info output has the following format:&n; * num_multipath_feature_args [multipath_feature_args]*&n; * num_handler_status_args [handler_status_args]*&n; * num_groups init_group_number&n; *            [A|D|E num_ps_status_args [ps_status_args]*&n; *             num_paths num_selector_args&n; *             [path_dev A|F fail_count [selector_args]* ]+ ]+&n; *&n; * Table output has the following format (identical to the constructor string):&n; * num_feature_args [features_args]*&n; * num_handler_args hw_handler [hw_handler_args]*&n; * num_groups init_group_number&n; *     [priority selector-name num_ps_args [ps_args]*&n; *      num_paths num_selector_args [path_dev [selector_args]* ]+ ]+&n; */
DECL|function|multipath_status
r_static
r_int
id|multipath_status
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
id|status_type_t
id|type
comma
r_char
op_star
id|result
comma
r_int
r_int
id|maxlen
)paren
(brace
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|multipath
op_star
id|m
op_assign
(paren
r_struct
id|multipath
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|hw_handler
op_star
id|hwh
op_assign
op_amp
id|m-&gt;hw_handler
suffix:semicolon
r_struct
id|priority_group
op_star
id|pg
suffix:semicolon
r_struct
id|pgpath
op_star
id|p
suffix:semicolon
r_int
id|pg_num
suffix:semicolon
r_char
id|state
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Features */
r_if
c_cond
(paren
id|type
op_eq
id|STATUSTYPE_INFO
)paren
id|DMEMIT
c_func
(paren
l_string|&quot;1 %u &quot;
comma
id|m-&gt;queue_size
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|m-&gt;queue_if_no_path
)paren
id|DMEMIT
c_func
(paren
l_string|&quot;1 queue_if_no_path &quot;
)paren
suffix:semicolon
r_else
id|DMEMIT
c_func
(paren
l_string|&quot;0 &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwh-&gt;type
op_logical_and
id|hwh-&gt;type-&gt;status
)paren
id|sz
op_add_assign
id|hwh-&gt;type
op_member_access_from_pointer
id|status
c_func
(paren
id|hwh
comma
id|type
comma
id|result
op_plus
id|sz
comma
id|maxlen
op_minus
id|sz
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|hwh-&gt;type
op_logical_or
id|type
op_eq
id|STATUSTYPE_INFO
)paren
id|DMEMIT
c_func
(paren
l_string|&quot;0 &quot;
)paren
suffix:semicolon
r_else
id|DMEMIT
c_func
(paren
l_string|&quot;1 %s &quot;
comma
id|hwh-&gt;type-&gt;name
)paren
suffix:semicolon
id|DMEMIT
c_func
(paren
l_string|&quot;%u &quot;
comma
id|m-&gt;nr_priority_groups
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;next_pg
)paren
id|pg_num
op_assign
id|m-&gt;next_pg-&gt;pg_num
suffix:semicolon
r_else
r_if
c_cond
(paren
id|m-&gt;current_pg
)paren
id|pg_num
op_assign
id|m-&gt;current_pg-&gt;pg_num
suffix:semicolon
r_else
id|pg_num
op_assign
l_int|1
suffix:semicolon
id|DMEMIT
c_func
(paren
l_string|&quot;%u &quot;
comma
id|pg_num
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|STATUSTYPE_INFO
suffix:colon
id|list_for_each_entry
c_func
(paren
id|pg
comma
op_amp
id|m-&gt;priority_groups
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|pg-&gt;bypassed
)paren
id|state
op_assign
l_char|&squot;D&squot;
suffix:semicolon
multiline_comment|/* Disabled */
r_else
r_if
c_cond
(paren
id|pg
op_eq
id|m-&gt;current_pg
)paren
id|state
op_assign
l_char|&squot;A&squot;
suffix:semicolon
multiline_comment|/* Currently Active */
r_else
id|state
op_assign
l_char|&squot;E&squot;
suffix:semicolon
multiline_comment|/* Enabled */
id|DMEMIT
c_func
(paren
l_string|&quot;%c &quot;
comma
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pg-&gt;ps.type-&gt;status
)paren
id|sz
op_add_assign
id|pg-&gt;ps.type
op_member_access_from_pointer
id|status
c_func
(paren
op_amp
id|pg-&gt;ps
comma
l_int|NULL
comma
id|type
comma
id|result
op_plus
id|sz
comma
id|maxlen
op_minus
id|sz
)paren
suffix:semicolon
r_else
id|DMEMIT
c_func
(paren
l_string|&quot;0 &quot;
)paren
suffix:semicolon
id|DMEMIT
c_func
(paren
l_string|&quot;%u %u &quot;
comma
id|pg-&gt;nr_pgpaths
comma
id|pg-&gt;ps.type-&gt;info_args
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|p
comma
op_amp
id|pg-&gt;pgpaths
comma
id|list
)paren
(brace
id|DMEMIT
c_func
(paren
l_string|&quot;%s %s %u &quot;
comma
id|p-&gt;path.dev-&gt;name
comma
id|p-&gt;path.is_active
ques
c_cond
l_string|&quot;A&quot;
suffix:colon
l_string|&quot;F&quot;
comma
id|p-&gt;fail_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pg-&gt;ps.type-&gt;status
)paren
id|sz
op_add_assign
id|pg-&gt;ps.type
op_member_access_from_pointer
id|status
c_func
(paren
op_amp
id|pg-&gt;ps
comma
op_amp
id|p-&gt;path
comma
id|type
comma
id|result
op_plus
id|sz
comma
id|maxlen
op_minus
id|sz
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|STATUSTYPE_TABLE
suffix:colon
id|list_for_each_entry
c_func
(paren
id|pg
comma
op_amp
id|m-&gt;priority_groups
comma
id|list
)paren
(brace
id|DMEMIT
c_func
(paren
l_string|&quot;%s &quot;
comma
id|pg-&gt;ps.type-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pg-&gt;ps.type-&gt;status
)paren
id|sz
op_add_assign
id|pg-&gt;ps.type
op_member_access_from_pointer
id|status
c_func
(paren
op_amp
id|pg-&gt;ps
comma
l_int|NULL
comma
id|type
comma
id|result
op_plus
id|sz
comma
id|maxlen
op_minus
id|sz
)paren
suffix:semicolon
r_else
id|DMEMIT
c_func
(paren
l_string|&quot;0 &quot;
)paren
suffix:semicolon
id|DMEMIT
c_func
(paren
l_string|&quot;%u %u &quot;
comma
id|pg-&gt;nr_pgpaths
comma
id|pg-&gt;ps.type-&gt;table_args
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|p
comma
op_amp
id|pg-&gt;pgpaths
comma
id|list
)paren
(brace
id|DMEMIT
c_func
(paren
l_string|&quot;%s &quot;
comma
id|p-&gt;path.dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pg-&gt;ps.type-&gt;status
)paren
id|sz
op_add_assign
id|pg-&gt;ps.type
op_member_access_from_pointer
id|status
c_func
(paren
op_amp
id|pg-&gt;ps
comma
op_amp
id|p-&gt;path
comma
id|type
comma
id|result
op_plus
id|sz
comma
id|maxlen
op_minus
id|sz
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|multipath_message
r_static
r_int
id|multipath_message
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|dm_dev
op_star
id|dev
suffix:semicolon
r_struct
id|multipath
op_star
id|m
op_assign
(paren
r_struct
id|multipath
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
id|action_fn
id|action
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strnicmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
id|MESG_STR
c_func
(paren
l_string|&quot;queue_if_no_path&quot;
)paren
)paren
)paren
r_return
id|queue_if_no_path
c_func
(paren
id|m
comma
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strnicmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
id|MESG_STR
c_func
(paren
l_string|&quot;fail_if_no_path&quot;
)paren
)paren
)paren
r_return
id|queue_if_no_path
c_func
(paren
id|m
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
op_ne
l_int|2
)paren
r_goto
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strnicmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
id|MESG_STR
c_func
(paren
l_string|&quot;disable_group&quot;
)paren
)paren
)paren
r_return
id|bypass_pg_num
c_func
(paren
id|m
comma
id|argv
(braket
l_int|1
)braket
comma
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strnicmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
id|MESG_STR
c_func
(paren
l_string|&quot;enable_group&quot;
)paren
)paren
)paren
r_return
id|bypass_pg_num
c_func
(paren
id|m
comma
id|argv
(braket
l_int|1
)braket
comma
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strnicmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
id|MESG_STR
c_func
(paren
l_string|&quot;switch_group&quot;
)paren
)paren
)paren
r_return
id|switch_pg_num
c_func
(paren
id|m
comma
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strnicmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
id|MESG_STR
c_func
(paren
l_string|&quot;reinstate_path&quot;
)paren
)paren
)paren
id|action
op_assign
id|reinstate_path
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strnicmp
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
id|MESG_STR
c_func
(paren
l_string|&quot;fail_path&quot;
)paren
)paren
)paren
id|action
op_assign
id|fail_path
suffix:semicolon
r_else
r_goto
id|error
suffix:semicolon
id|r
op_assign
id|dm_get_device
c_func
(paren
id|ti
comma
id|argv
(braket
l_int|1
)braket
comma
id|ti-&gt;begin
comma
id|ti-&gt;len
comma
id|dm_table_get_mode
c_func
(paren
id|ti-&gt;table
)paren
comma
op_amp
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;dm-multipath message: error getting device %s&quot;
comma
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|r
op_assign
id|action_dev
c_func
(paren
id|m
comma
id|dev
comma
id|action
)paren
suffix:semicolon
id|dm_put_device
c_func
(paren
id|ti
comma
id|dev
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
id|error
suffix:colon
id|DMWARN
c_func
(paren
l_string|&quot;Unrecognised multipath message received.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * Module setup&n; *---------------------------------------------------------------*/
DECL|variable|multipath_target
r_static
r_struct
id|target_type
id|multipath_target
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;multipath&quot;
comma
dot
id|version
op_assign
(brace
l_int|1
comma
l_int|0
comma
l_int|4
)brace
comma
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|ctr
op_assign
id|multipath_ctr
comma
dot
id|dtr
op_assign
id|multipath_dtr
comma
dot
id|map
op_assign
id|multipath_map
comma
dot
id|end_io
op_assign
id|multipath_end_io
comma
dot
id|presuspend
op_assign
id|multipath_presuspend
comma
dot
id|resume
op_assign
id|multipath_resume
comma
dot
id|status
op_assign
id|multipath_status
comma
dot
id|message
op_assign
id|multipath_message
comma
)brace
suffix:semicolon
DECL|function|dm_multipath_init
r_static
r_int
id|__init
id|dm_multipath_init
c_func
(paren
r_void
)paren
(brace
r_int
id|r
suffix:semicolon
multiline_comment|/* allocate a slab for the dm_ios */
id|_mpio_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;dm_mpath&quot;
comma
r_sizeof
(paren
r_struct
id|mpath_io
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_mpio_cache
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|r
op_assign
id|dm_register_target
c_func
(paren
op_amp
id|multipath_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;%s: register failed %d&quot;
comma
id|multipath_target.name
comma
id|r
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|_mpio_cache
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|DMINFO
c_func
(paren
l_string|&quot;dm-multipath version %u.%u.%u loaded&quot;
comma
id|multipath_target.version
(braket
l_int|0
)braket
comma
id|multipath_target.version
(braket
l_int|1
)braket
comma
id|multipath_target.version
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|dm_multipath_exit
r_static
r_void
id|__exit
id|dm_multipath_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|r
suffix:semicolon
id|r
op_assign
id|dm_unregister_target
c_func
(paren
op_amp
id|multipath_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
id|DMERR
c_func
(paren
l_string|&quot;%s: target unregister failed %d&quot;
comma
id|multipath_target.name
comma
id|r
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|_mpio_cache
)paren
suffix:semicolon
)brace
DECL|variable|dm_pg_init_complete
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|dm_pg_init_complete
)paren
suffix:semicolon
DECL|variable|dm_multipath_init
id|module_init
c_func
(paren
id|dm_multipath_init
)paren
suffix:semicolon
DECL|variable|dm_multipath_exit
id|module_exit
c_func
(paren
id|dm_multipath_exit
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
id|DM_NAME
l_string|&quot; multipath target&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Sistina Software &lt;dm-devel@redhat.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
