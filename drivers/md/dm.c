multiline_comment|/*&n; * Copyright (C) 2001, 2002 Sistina Software (UK) Limited.&n; *&n; * This file is released under the GPL.&n; */
macro_line|#include &quot;dm.h&quot;
macro_line|#include &quot;dm-bio-list.h&quot;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
DECL|variable|_name
r_static
r_const
r_char
op_star
id|_name
op_assign
id|DM_NAME
suffix:semicolon
DECL|macro|MAX_DEVICES
mdefine_line|#define MAX_DEVICES 1024
DECL|variable|major
r_static
r_int
r_int
id|major
op_assign
l_int|0
suffix:semicolon
DECL|variable|_major
r_static
r_int
r_int
id|_major
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * One of these is allocated per bio.&n; */
DECL|struct|dm_io
r_struct
id|dm_io
(brace
DECL|member|md
r_struct
id|mapped_device
op_star
id|md
suffix:semicolon
DECL|member|error
r_int
id|error
suffix:semicolon
DECL|member|bio
r_struct
id|bio
op_star
id|bio
suffix:semicolon
DECL|member|io_count
id|atomic_t
id|io_count
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * One of these is allocated per target within a bio.  Hopefully&n; * this will be simplified out one day.&n; */
DECL|struct|target_io
r_struct
id|target_io
(brace
DECL|member|io
r_struct
id|dm_io
op_star
id|io
suffix:semicolon
DECL|member|ti
r_struct
id|dm_target
op_star
id|ti
suffix:semicolon
DECL|member|info
r_union
id|map_info
id|info
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Bits for the md-&gt;flags field.&n; */
DECL|macro|DMF_BLOCK_IO
mdefine_line|#define DMF_BLOCK_IO 0
DECL|macro|DMF_SUSPENDED
mdefine_line|#define DMF_SUSPENDED 1
DECL|macro|DMF_FS_LOCKED
mdefine_line|#define DMF_FS_LOCKED 2
DECL|struct|mapped_device
r_struct
id|mapped_device
(brace
DECL|member|lock
r_struct
id|rw_semaphore
id|lock
suffix:semicolon
DECL|member|map_lock
id|rwlock_t
id|map_lock
suffix:semicolon
DECL|member|holders
id|atomic_t
id|holders
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|queue
id|request_queue_t
op_star
id|queue
suffix:semicolon
DECL|member|disk
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
multiline_comment|/*&n;&t; * A list of ios that arrived while we were suspended.&n;&t; */
DECL|member|pending
id|atomic_t
id|pending
suffix:semicolon
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
DECL|member|deferred
r_struct
id|bio_list
id|deferred
suffix:semicolon
multiline_comment|/*&n;&t; * The current mapping.&n;&t; */
DECL|member|map
r_struct
id|dm_table
op_star
id|map
suffix:semicolon
multiline_comment|/*&n;&t; * io objects are allocated from here.&n;&t; */
DECL|member|io_pool
id|mempool_t
op_star
id|io_pool
suffix:semicolon
DECL|member|tio_pool
id|mempool_t
op_star
id|tio_pool
suffix:semicolon
multiline_comment|/*&n;&t; * Event handling.&n;&t; */
DECL|member|event_nr
id|atomic_t
id|event_nr
suffix:semicolon
DECL|member|eventq
id|wait_queue_head_t
id|eventq
suffix:semicolon
multiline_comment|/*&n;&t; * freeze/thaw support require holding onto a super block&n;&t; */
DECL|member|frozen_sb
r_struct
id|super_block
op_star
id|frozen_sb
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|MIN_IOS
mdefine_line|#define MIN_IOS 256
DECL|variable|_io_cache
r_static
id|kmem_cache_t
op_star
id|_io_cache
suffix:semicolon
DECL|variable|_tio_cache
r_static
id|kmem_cache_t
op_star
id|_tio_cache
suffix:semicolon
DECL|function|local_init
r_static
r_int
id|__init
id|local_init
c_func
(paren
r_void
)paren
(brace
r_int
id|r
suffix:semicolon
multiline_comment|/* allocate a slab for the dm_ios */
id|_io_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;dm_io&quot;
comma
r_sizeof
(paren
r_struct
id|dm_io
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_io_cache
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* allocate a slab for the target ios */
id|_tio_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;dm_tio&quot;
comma
r_sizeof
(paren
r_struct
id|target_io
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_tio_cache
)paren
(brace
id|kmem_cache_destroy
c_func
(paren
id|_io_cache
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|_major
op_assign
id|major
suffix:semicolon
id|r
op_assign
id|register_blkdev
c_func
(paren
id|_major
comma
id|_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
(brace
id|kmem_cache_destroy
c_func
(paren
id|_tio_cache
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|_io_cache
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|_major
)paren
id|_major
op_assign
id|r
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|local_exit
r_static
r_void
id|local_exit
c_func
(paren
r_void
)paren
(brace
id|kmem_cache_destroy
c_func
(paren
id|_tio_cache
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|_io_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unregister_blkdev
c_func
(paren
id|_major
comma
id|_name
)paren
OL
l_int|0
)paren
id|DMERR
c_func
(paren
l_string|&quot;devfs_unregister_blkdev failed&quot;
)paren
suffix:semicolon
id|_major
op_assign
l_int|0
suffix:semicolon
id|DMINFO
c_func
(paren
l_string|&quot;cleaned up&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We have a lot of init/exit functions, so it seems easier to&n; * store them in an array.  The disposable macro &squot;xx&squot;&n; * expands a prefix into a pair of function names.&n; */
r_static
r_struct
(brace
DECL|member|init
r_int
(paren
op_star
id|init
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|member|exit
r_void
(paren
op_star
m_exit
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|variable|_inits
)brace
id|_inits
(braket
)braket
op_assign
(brace
DECL|macro|xx
mdefine_line|#define xx(n) {n ## _init, n ## _exit},
id|xx
c_func
(paren
id|local
)paren
id|xx
c_func
(paren
id|dm_target
)paren
id|xx
c_func
(paren
id|dm_linear
)paren
id|xx
c_func
(paren
id|dm_stripe
)paren
id|xx
c_func
(paren
id|dm_interface
)paren
DECL|macro|xx
macro_line|#undef xx
)brace
suffix:semicolon
DECL|function|dm_init
r_static
r_int
id|__init
id|dm_init
c_func
(paren
r_void
)paren
(brace
r_const
r_int
id|count
op_assign
id|ARRAY_SIZE
c_func
(paren
id|_inits
)paren
suffix:semicolon
r_int
id|r
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|r
op_assign
id|_inits
(braket
id|i
)braket
dot
id|init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_goto
id|bad
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|bad
suffix:colon
r_while
c_loop
(paren
id|i
op_decrement
)paren
id|_inits
(braket
id|i
)braket
dot
m_exit
(paren
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|dm_exit
r_static
r_void
id|__exit
id|dm_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
id|ARRAY_SIZE
c_func
(paren
id|_inits
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
)paren
id|_inits
(braket
id|i
)braket
dot
m_exit
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Block device functions&n; */
DECL|function|dm_blk_open
r_static
r_int
id|dm_blk_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|mapped_device
op_star
id|md
suffix:semicolon
id|md
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
id|dm_get
c_func
(paren
id|md
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dm_blk_close
r_static
r_int
id|dm_blk_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|mapped_device
op_star
id|md
suffix:semicolon
id|md
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
id|dm_put
c_func
(paren
id|md
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|alloc_io
r_static
r_inline
r_struct
id|dm_io
op_star
id|alloc_io
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
r_return
id|mempool_alloc
c_func
(paren
id|md-&gt;io_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
)brace
DECL|function|free_io
r_static
r_inline
r_void
id|free_io
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
comma
r_struct
id|dm_io
op_star
id|io
)paren
(brace
id|mempool_free
c_func
(paren
id|io
comma
id|md-&gt;io_pool
)paren
suffix:semicolon
)brace
DECL|function|alloc_tio
r_static
r_inline
r_struct
id|target_io
op_star
id|alloc_tio
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
r_return
id|mempool_alloc
c_func
(paren
id|md-&gt;tio_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
)brace
DECL|function|free_tio
r_static
r_inline
r_void
id|free_tio
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
comma
r_struct
id|target_io
op_star
id|tio
)paren
(brace
id|mempool_free
c_func
(paren
id|tio
comma
id|md-&gt;tio_pool
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add the bio to the list of deferred io.&n; */
DECL|function|queue_io
r_static
r_int
id|queue_io
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|DMF_BLOCK_IO
comma
op_amp
id|md-&gt;flags
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|bio_list_add
c_func
(paren
op_amp
id|md-&gt;deferred
comma
id|bio
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* deferred successfully */
)brace
multiline_comment|/*&n; * Everyone (including functions in this file), should use this&n; * function to access the md-&gt;map field, and make sure they call&n; * dm_table_put() when finished.&n; */
DECL|function|dm_get_table
r_struct
id|dm_table
op_star
id|dm_get_table
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
r_struct
id|dm_table
op_star
id|t
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|md-&gt;map_lock
)paren
suffix:semicolon
id|t
op_assign
id|md-&gt;map
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
id|dm_table_get
c_func
(paren
id|t
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|md-&gt;map_lock
)paren
suffix:semicolon
r_return
id|t
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * CRUD START:&n; *   A more elegant soln is in the works that uses the queue&n; *   merge fn, unfortunately there are a couple of changes to&n; *   the block layer that I want to make for this.  So in the&n; *   interests of getting something for people to use I give&n; *   you this clearly demarcated crap.&n; *---------------------------------------------------------------*/
multiline_comment|/*&n; * Decrements the number of outstanding ios that a bio has been&n; * cloned into, completing the original io if necc.&n; */
DECL|function|dec_pending
r_static
r_inline
r_void
id|dec_pending
c_func
(paren
r_struct
id|dm_io
op_star
id|io
comma
r_int
id|error
)paren
(brace
r_if
c_cond
(paren
id|error
)paren
id|io-&gt;error
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|io-&gt;io_count
)paren
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|io-&gt;md-&gt;pending
)paren
)paren
multiline_comment|/* nudge anyone waiting on suspend queue */
id|wake_up
c_func
(paren
op_amp
id|io-&gt;md-&gt;wait
)paren
suffix:semicolon
id|bio_endio
c_func
(paren
id|io-&gt;bio
comma
id|io-&gt;bio-&gt;bi_size
comma
id|io-&gt;error
)paren
suffix:semicolon
id|free_io
c_func
(paren
id|io-&gt;md
comma
id|io
)paren
suffix:semicolon
)brace
)brace
DECL|function|clone_endio
r_static
r_int
id|clone_endio
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|done
comma
r_int
id|error
)paren
(brace
r_int
id|r
op_assign
l_int|0
suffix:semicolon
r_struct
id|target_io
op_star
id|tio
op_assign
id|bio-&gt;bi_private
suffix:semicolon
r_struct
id|dm_io
op_star
id|io
op_assign
id|tio-&gt;io
suffix:semicolon
id|dm_endio_fn
id|endio
op_assign
id|tio-&gt;ti-&gt;type-&gt;end_io
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio_flagged
c_func
(paren
id|bio
comma
id|BIO_UPTODATE
)paren
op_logical_and
op_logical_neg
id|error
)paren
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|endio
)paren
(brace
id|r
op_assign
id|endio
c_func
(paren
id|tio-&gt;ti
comma
id|bio
comma
id|error
comma
op_amp
id|tio-&gt;info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
id|error
op_assign
id|r
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r
OG
l_int|0
)paren
multiline_comment|/* the target wants another shot at the io */
r_return
l_int|1
suffix:semicolon
)brace
id|free_tio
c_func
(paren
id|io-&gt;md
comma
id|tio
)paren
suffix:semicolon
id|dec_pending
c_func
(paren
id|io
comma
id|error
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|max_io_len
r_static
id|sector_t
id|max_io_len
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
comma
id|sector_t
id|sector
comma
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
id|sector_t
id|offset
op_assign
id|sector
op_minus
id|ti-&gt;begin
suffix:semicolon
id|sector_t
id|len
op_assign
id|ti-&gt;len
op_minus
id|offset
suffix:semicolon
multiline_comment|/*&n;&t; * Does the target need to split even further ?&n;&t; */
r_if
c_cond
(paren
id|ti-&gt;split_io
)paren
(brace
id|sector_t
id|boundary
suffix:semicolon
id|boundary
op_assign
id|dm_round_up
c_func
(paren
id|offset
op_plus
l_int|1
comma
id|ti-&gt;split_io
)paren
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|boundary
)paren
id|len
op_assign
id|boundary
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|__map_bio
r_static
r_void
id|__map_bio
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_struct
id|bio
op_star
id|clone
comma
r_struct
id|target_io
op_star
id|tio
)paren
(brace
r_int
id|r
suffix:semicolon
multiline_comment|/*&n;&t; * Sanity checks.&n;&t; */
id|BUG_ON
c_func
(paren
op_logical_neg
id|clone-&gt;bi_size
)paren
suffix:semicolon
id|clone-&gt;bi_end_io
op_assign
id|clone_endio
suffix:semicolon
id|clone-&gt;bi_private
op_assign
id|tio
suffix:semicolon
multiline_comment|/*&n;&t; * Map the clone.  If r == 0 we don&squot;t need to do&n;&t; * anything, the target has assumed ownership of&n;&t; * this io.&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|tio-&gt;io-&gt;io_count
)paren
suffix:semicolon
id|r
op_assign
id|ti-&gt;type
op_member_access_from_pointer
id|map
c_func
(paren
id|ti
comma
id|clone
comma
op_amp
id|tio-&gt;info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|0
)paren
multiline_comment|/* the bio has been remapped so dispatch it */
id|generic_make_request
c_func
(paren
id|clone
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
(brace
multiline_comment|/* error the io and bail out */
r_struct
id|dm_io
op_star
id|io
op_assign
id|tio-&gt;io
suffix:semicolon
id|free_tio
c_func
(paren
id|tio-&gt;io-&gt;md
comma
id|tio
)paren
suffix:semicolon
id|dec_pending
c_func
(paren
id|io
comma
op_minus
id|EIO
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|clone
)paren
suffix:semicolon
)brace
)brace
DECL|struct|clone_info
r_struct
id|clone_info
(brace
DECL|member|md
r_struct
id|mapped_device
op_star
id|md
suffix:semicolon
DECL|member|map
r_struct
id|dm_table
op_star
id|map
suffix:semicolon
DECL|member|bio
r_struct
id|bio
op_star
id|bio
suffix:semicolon
DECL|member|io
r_struct
id|dm_io
op_star
id|io
suffix:semicolon
DECL|member|sector
id|sector_t
id|sector
suffix:semicolon
DECL|member|sector_count
id|sector_t
id|sector_count
suffix:semicolon
DECL|member|idx
r_int
r_int
id|idx
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Creates a little bio that is just does part of a bvec.&n; */
DECL|function|split_bvec
r_static
r_struct
id|bio
op_star
id|split_bvec
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
id|sector_t
id|sector
comma
r_int
r_int
id|idx
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|bio
op_star
id|clone
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bv
op_assign
id|bio-&gt;bi_io_vec
op_plus
id|idx
suffix:semicolon
id|clone
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOIO
comma
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|clone-&gt;bi_io_vec
comma
id|bv
comma
r_sizeof
(paren
op_star
id|bv
)paren
)paren
suffix:semicolon
id|clone-&gt;bi_sector
op_assign
id|sector
suffix:semicolon
id|clone-&gt;bi_bdev
op_assign
id|bio-&gt;bi_bdev
suffix:semicolon
id|clone-&gt;bi_rw
op_assign
id|bio-&gt;bi_rw
suffix:semicolon
id|clone-&gt;bi_vcnt
op_assign
l_int|1
suffix:semicolon
id|clone-&gt;bi_size
op_assign
id|to_bytes
c_func
(paren
id|len
)paren
suffix:semicolon
id|clone-&gt;bi_io_vec-&gt;bv_offset
op_assign
id|offset
suffix:semicolon
id|clone-&gt;bi_io_vec-&gt;bv_len
op_assign
id|clone-&gt;bi_size
suffix:semicolon
r_return
id|clone
suffix:semicolon
)brace
multiline_comment|/*&n; * Creates a bio that consists of range of complete bvecs.&n; */
DECL|function|clone_bio
r_static
r_struct
id|bio
op_star
id|clone_bio
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
id|sector_t
id|sector
comma
r_int
r_int
id|idx
comma
r_int
r_int
id|bv_count
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|bio
op_star
id|clone
suffix:semicolon
id|clone
op_assign
id|bio_clone
c_func
(paren
id|bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|clone-&gt;bi_sector
op_assign
id|sector
suffix:semicolon
id|clone-&gt;bi_idx
op_assign
id|idx
suffix:semicolon
id|clone-&gt;bi_vcnt
op_assign
id|idx
op_plus
id|bv_count
suffix:semicolon
id|clone-&gt;bi_size
op_assign
id|to_bytes
c_func
(paren
id|len
)paren
suffix:semicolon
id|clone-&gt;bi_flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|BIO_SEG_VALID
)paren
suffix:semicolon
r_return
id|clone
suffix:semicolon
)brace
DECL|function|__clone_and_map
r_static
r_void
id|__clone_and_map
c_func
(paren
r_struct
id|clone_info
op_star
id|ci
)paren
(brace
r_struct
id|bio
op_star
id|clone
comma
op_star
id|bio
op_assign
id|ci-&gt;bio
suffix:semicolon
r_struct
id|dm_target
op_star
id|ti
op_assign
id|dm_table_find_target
c_func
(paren
id|ci-&gt;map
comma
id|ci-&gt;sector
)paren
suffix:semicolon
id|sector_t
id|len
op_assign
l_int|0
comma
id|max
op_assign
id|max_io_len
c_func
(paren
id|ci-&gt;md
comma
id|ci-&gt;sector
comma
id|ti
)paren
suffix:semicolon
r_struct
id|target_io
op_star
id|tio
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a target io object.&n;&t; */
id|tio
op_assign
id|alloc_tio
c_func
(paren
id|ci-&gt;md
)paren
suffix:semicolon
id|tio-&gt;io
op_assign
id|ci-&gt;io
suffix:semicolon
id|tio-&gt;ti
op_assign
id|ti
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tio-&gt;info
comma
l_int|0
comma
r_sizeof
(paren
id|tio-&gt;info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ci-&gt;sector_count
op_le
id|max
)paren
(brace
multiline_comment|/*&n;&t;&t; * Optimise for the simple case where we can do all of&n;&t;&t; * the remaining io with a single clone.&n;&t;&t; */
id|clone
op_assign
id|clone_bio
c_func
(paren
id|bio
comma
id|ci-&gt;sector
comma
id|ci-&gt;idx
comma
id|bio-&gt;bi_vcnt
op_minus
id|ci-&gt;idx
comma
id|ci-&gt;sector_count
)paren
suffix:semicolon
id|__map_bio
c_func
(paren
id|ti
comma
id|clone
comma
id|tio
)paren
suffix:semicolon
id|ci-&gt;sector_count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|to_sector
c_func
(paren
id|bio-&gt;bi_io_vec
(braket
id|ci-&gt;idx
)braket
dot
id|bv_len
)paren
op_le
id|max
)paren
(brace
multiline_comment|/*&n;&t;&t; * There are some bvecs that don&squot;t span targets.&n;&t;&t; * Do as many of these as possible.&n;&t;&t; */
r_int
id|i
suffix:semicolon
id|sector_t
id|remaining
op_assign
id|max
suffix:semicolon
id|sector_t
id|bv_len
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ci-&gt;idx
suffix:semicolon
id|remaining
op_logical_and
(paren
id|i
OL
id|bio-&gt;bi_vcnt
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bv_len
op_assign
id|to_sector
c_func
(paren
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bv_len
OG
id|remaining
)paren
r_break
suffix:semicolon
id|remaining
op_sub_assign
id|bv_len
suffix:semicolon
id|len
op_add_assign
id|bv_len
suffix:semicolon
)brace
id|clone
op_assign
id|clone_bio
c_func
(paren
id|bio
comma
id|ci-&gt;sector
comma
id|ci-&gt;idx
comma
id|i
op_minus
id|ci-&gt;idx
comma
id|len
)paren
suffix:semicolon
id|__map_bio
c_func
(paren
id|ti
comma
id|clone
comma
id|tio
)paren
suffix:semicolon
id|ci-&gt;sector
op_add_assign
id|len
suffix:semicolon
id|ci-&gt;sector_count
op_sub_assign
id|len
suffix:semicolon
id|ci-&gt;idx
op_assign
id|i
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Create two copy bios to deal with io that has&n;&t;&t; * been split across a target.&n;&t;&t; */
r_struct
id|bio_vec
op_star
id|bv
op_assign
id|bio-&gt;bi_io_vec
op_plus
id|ci-&gt;idx
suffix:semicolon
id|clone
op_assign
id|split_bvec
c_func
(paren
id|bio
comma
id|ci-&gt;sector
comma
id|ci-&gt;idx
comma
id|bv-&gt;bv_offset
comma
id|max
)paren
suffix:semicolon
id|__map_bio
c_func
(paren
id|ti
comma
id|clone
comma
id|tio
)paren
suffix:semicolon
id|ci-&gt;sector
op_add_assign
id|max
suffix:semicolon
id|ci-&gt;sector_count
op_sub_assign
id|max
suffix:semicolon
id|ti
op_assign
id|dm_table_find_target
c_func
(paren
id|ci-&gt;map
comma
id|ci-&gt;sector
)paren
suffix:semicolon
id|len
op_assign
id|to_sector
c_func
(paren
id|bv-&gt;bv_len
)paren
op_minus
id|max
suffix:semicolon
id|clone
op_assign
id|split_bvec
c_func
(paren
id|bio
comma
id|ci-&gt;sector
comma
id|ci-&gt;idx
comma
id|bv-&gt;bv_offset
op_plus
id|to_bytes
c_func
(paren
id|max
)paren
comma
id|len
)paren
suffix:semicolon
id|tio
op_assign
id|alloc_tio
c_func
(paren
id|ci-&gt;md
)paren
suffix:semicolon
id|tio-&gt;io
op_assign
id|ci-&gt;io
suffix:semicolon
id|tio-&gt;ti
op_assign
id|ti
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tio-&gt;info
comma
l_int|0
comma
r_sizeof
(paren
id|tio-&gt;info
)paren
)paren
suffix:semicolon
id|__map_bio
c_func
(paren
id|ti
comma
id|clone
comma
id|tio
)paren
suffix:semicolon
id|ci-&gt;sector
op_add_assign
id|len
suffix:semicolon
id|ci-&gt;sector_count
op_sub_assign
id|len
suffix:semicolon
id|ci-&gt;idx
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Split the bio into several clones.&n; */
DECL|function|__split_bio
r_static
r_void
id|__split_bio
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|clone_info
id|ci
suffix:semicolon
id|ci.map
op_assign
id|dm_get_table
c_func
(paren
id|md
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ci.map
)paren
(brace
id|bio_io_error
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ci.md
op_assign
id|md
suffix:semicolon
id|ci.bio
op_assign
id|bio
suffix:semicolon
id|ci.io
op_assign
id|alloc_io
c_func
(paren
id|md
)paren
suffix:semicolon
id|ci.io-&gt;error
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ci.io-&gt;io_count
comma
l_int|1
)paren
suffix:semicolon
id|ci.io-&gt;bio
op_assign
id|bio
suffix:semicolon
id|ci.io-&gt;md
op_assign
id|md
suffix:semicolon
id|ci.sector
op_assign
id|bio-&gt;bi_sector
suffix:semicolon
id|ci.sector_count
op_assign
id|bio_sectors
c_func
(paren
id|bio
)paren
suffix:semicolon
id|ci.idx
op_assign
id|bio-&gt;bi_idx
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|md-&gt;pending
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ci.sector_count
)paren
id|__clone_and_map
c_func
(paren
op_amp
id|ci
)paren
suffix:semicolon
multiline_comment|/* drop the extra reference count */
id|dec_pending
c_func
(paren
id|ci.io
comma
l_int|0
)paren
suffix:semicolon
id|dm_table_put
c_func
(paren
id|ci.map
)paren
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * CRUD END&n; *---------------------------------------------------------------*/
multiline_comment|/*&n; * The request function that just remaps the bio built up by&n; * dm_merge_bvec.&n; */
DECL|function|dm_request
r_static
r_int
id|dm_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|mapped_device
op_star
id|md
op_assign
id|q-&gt;queuedata
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re suspended we have to queue&n;&t; * this io for later.&n;&t; */
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|DMF_BLOCK_IO
comma
op_amp
id|md-&gt;flags
)paren
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio_rw
c_func
(paren
id|bio
)paren
op_eq
id|READA
)paren
(brace
id|bio_io_error
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|r
op_assign
id|queue_io
c_func
(paren
id|md
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
(brace
id|bio_io_error
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|r
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* deferred successfully */
multiline_comment|/*&n;&t;&t; * We&squot;re in a while loop, because someone could suspend&n;&t;&t; * before we get to the following read lock.&n;&t;&t; */
id|down_read
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
)brace
id|__split_bio
c_func
(paren
id|md
comma
id|bio
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dm_unplug_all
r_static
r_void
id|dm_unplug_all
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|mapped_device
op_star
id|md
op_assign
id|q-&gt;queuedata
suffix:semicolon
r_struct
id|dm_table
op_star
id|map
op_assign
id|dm_get_table
c_func
(paren
id|md
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map
)paren
(brace
id|dm_table_unplug_all
c_func
(paren
id|map
)paren
suffix:semicolon
id|dm_table_put
c_func
(paren
id|map
)paren
suffix:semicolon
)brace
)brace
DECL|function|dm_any_congested
r_static
r_int
id|dm_any_congested
c_func
(paren
r_void
op_star
id|congested_data
comma
r_int
id|bdi_bits
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|mapped_device
op_star
id|md
op_assign
(paren
r_struct
id|mapped_device
op_star
)paren
id|congested_data
suffix:semicolon
r_struct
id|dm_table
op_star
id|map
op_assign
id|dm_get_table
c_func
(paren
id|md
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map
op_logical_or
id|test_bit
c_func
(paren
id|DMF_BLOCK_IO
comma
op_amp
id|md-&gt;flags
)paren
)paren
id|r
op_assign
id|bdi_bits
suffix:semicolon
r_else
id|r
op_assign
id|dm_table_any_congested
c_func
(paren
id|map
comma
id|bdi_bits
)paren
suffix:semicolon
id|dm_table_put
c_func
(paren
id|map
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * A bitset is used to keep track of allocated minor numbers.&n; *---------------------------------------------------------------*/
DECL|variable|_minor_lock
r_static
id|spinlock_t
id|_minor_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|_minor_bits
r_static
r_int
r_int
id|_minor_bits
(braket
id|MAX_DEVICES
op_div
id|BITS_PER_LONG
)braket
suffix:semicolon
DECL|function|free_minor
r_static
r_void
id|free_minor
c_func
(paren
r_int
r_int
id|minor
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|_minor_lock
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|minor
comma
id|_minor_bits
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|_minor_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * See if the device with a specific minor # is free.&n; */
DECL|function|specific_minor
r_static
r_int
id|specific_minor
c_func
(paren
r_int
r_int
id|minor
)paren
(brace
r_int
id|r
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|MAX_DEVICES
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;request for a mapped_device beyond MAX_DEVICES (%d)&quot;
comma
id|MAX_DEVICES
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|_minor_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|minor
comma
id|_minor_bits
)paren
)paren
id|r
op_assign
l_int|0
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|_minor_lock
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|next_free_minor
r_static
r_int
id|next_free_minor
c_func
(paren
r_int
r_int
op_star
id|minor
)paren
(brace
r_int
id|r
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_int
r_int
id|m
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|_minor_lock
)paren
suffix:semicolon
id|m
op_assign
id|find_first_zero_bit
c_func
(paren
id|_minor_bits
comma
id|MAX_DEVICES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_ne
id|MAX_DEVICES
)paren
(brace
id|set_bit
c_func
(paren
id|m
comma
id|_minor_bits
)paren
suffix:semicolon
op_star
id|minor
op_assign
id|m
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|_minor_lock
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|variable|dm_blk_dops
r_static
r_struct
id|block_device_operations
id|dm_blk_dops
suffix:semicolon
multiline_comment|/*&n; * Allocate and initialise a blank device with a given minor.&n; */
DECL|function|alloc_dev
r_static
r_struct
id|mapped_device
op_star
id|alloc_dev
c_func
(paren
r_int
r_int
id|minor
comma
r_int
id|persistent
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|mapped_device
op_star
id|md
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|md
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;unable to allocate device, out of memory.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* get a minor number for the dev */
id|r
op_assign
id|persistent
ques
c_cond
id|specific_minor
c_func
(paren
id|minor
)paren
suffix:colon
id|next_free_minor
c_func
(paren
op_amp
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
r_goto
id|bad1
suffix:semicolon
id|memset
c_func
(paren
id|md
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|md
)paren
)paren
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
id|md-&gt;map_lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|md-&gt;holders
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|md-&gt;event_nr
comma
l_int|0
)paren
suffix:semicolon
id|md-&gt;queue
op_assign
id|blk_alloc_queue
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md-&gt;queue
)paren
r_goto
id|bad1
suffix:semicolon
id|md-&gt;queue-&gt;queuedata
op_assign
id|md
suffix:semicolon
id|md-&gt;queue-&gt;backing_dev_info.congested_fn
op_assign
id|dm_any_congested
suffix:semicolon
id|md-&gt;queue-&gt;backing_dev_info.congested_data
op_assign
id|md
suffix:semicolon
id|blk_queue_make_request
c_func
(paren
id|md-&gt;queue
comma
id|dm_request
)paren
suffix:semicolon
id|md-&gt;queue-&gt;unplug_fn
op_assign
id|dm_unplug_all
suffix:semicolon
id|md-&gt;io_pool
op_assign
id|mempool_create
c_func
(paren
id|MIN_IOS
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|_io_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md-&gt;io_pool
)paren
r_goto
id|bad2
suffix:semicolon
id|md-&gt;tio_pool
op_assign
id|mempool_create
c_func
(paren
id|MIN_IOS
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|_tio_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md-&gt;tio_pool
)paren
r_goto
id|bad3
suffix:semicolon
id|md-&gt;disk
op_assign
id|alloc_disk
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md-&gt;disk
)paren
r_goto
id|bad4
suffix:semicolon
id|md-&gt;disk-&gt;major
op_assign
id|_major
suffix:semicolon
id|md-&gt;disk-&gt;first_minor
op_assign
id|minor
suffix:semicolon
id|md-&gt;disk-&gt;fops
op_assign
op_amp
id|dm_blk_dops
suffix:semicolon
id|md-&gt;disk-&gt;queue
op_assign
id|md-&gt;queue
suffix:semicolon
id|md-&gt;disk-&gt;private_data
op_assign
id|md
suffix:semicolon
id|sprintf
c_func
(paren
id|md-&gt;disk-&gt;disk_name
comma
l_string|&quot;dm-%d&quot;
comma
id|minor
)paren
suffix:semicolon
id|add_disk
c_func
(paren
id|md-&gt;disk
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|md-&gt;pending
comma
l_int|0
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|md-&gt;wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|md-&gt;eventq
)paren
suffix:semicolon
r_return
id|md
suffix:semicolon
id|bad4
suffix:colon
id|mempool_destroy
c_func
(paren
id|md-&gt;tio_pool
)paren
suffix:semicolon
id|bad3
suffix:colon
id|mempool_destroy
c_func
(paren
id|md-&gt;io_pool
)paren
suffix:semicolon
id|bad2
suffix:colon
id|blk_put_queue
c_func
(paren
id|md-&gt;queue
)paren
suffix:semicolon
id|free_minor
c_func
(paren
id|minor
)paren
suffix:semicolon
id|bad1
suffix:colon
id|kfree
c_func
(paren
id|md
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|free_dev
r_static
r_void
id|free_dev
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
id|free_minor
c_func
(paren
id|md-&gt;disk-&gt;first_minor
)paren
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|md-&gt;tio_pool
)paren
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|md-&gt;io_pool
)paren
suffix:semicolon
id|del_gendisk
c_func
(paren
id|md-&gt;disk
)paren
suffix:semicolon
id|put_disk
c_func
(paren
id|md-&gt;disk
)paren
suffix:semicolon
id|blk_put_queue
c_func
(paren
id|md-&gt;queue
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|md
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Bind a table to the device.&n; */
DECL|function|event_callback
r_static
r_void
id|event_callback
c_func
(paren
r_void
op_star
id|context
)paren
(brace
r_struct
id|mapped_device
op_star
id|md
op_assign
(paren
r_struct
id|mapped_device
op_star
)paren
id|context
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|md-&gt;event_nr
)paren
suffix:semicolon
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|md-&gt;eventq
)paren
suffix:semicolon
)brace
DECL|function|__set_size
r_static
r_void
id|__set_size
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
comma
id|sector_t
id|size
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
id|set_capacity
c_func
(paren
id|disk
comma
id|size
)paren
suffix:semicolon
id|bdev
op_assign
id|bdget_disk
c_func
(paren
id|disk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdev
)paren
(brace
id|down
c_func
(paren
op_amp
id|bdev-&gt;bd_inode-&gt;i_sem
)paren
suffix:semicolon
id|i_size_write
c_func
(paren
id|bdev-&gt;bd_inode
comma
(paren
id|loff_t
)paren
id|size
op_lshift
id|SECTOR_SHIFT
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|bdev-&gt;bd_inode-&gt;i_sem
)paren
suffix:semicolon
id|bdput
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
)brace
DECL|function|__bind
r_static
r_int
id|__bind
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
comma
r_struct
id|dm_table
op_star
id|t
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
id|md-&gt;queue
suffix:semicolon
id|sector_t
id|size
suffix:semicolon
id|size
op_assign
id|dm_table_get_size
c_func
(paren
id|t
)paren
suffix:semicolon
id|__set_size
c_func
(paren
id|md-&gt;disk
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|md-&gt;map_lock
)paren
suffix:semicolon
id|md-&gt;map
op_assign
id|t
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|md-&gt;map_lock
)paren
suffix:semicolon
id|dm_table_get
c_func
(paren
id|t
)paren
suffix:semicolon
id|dm_table_event_callback
c_func
(paren
id|md-&gt;map
comma
id|event_callback
comma
id|md
)paren
suffix:semicolon
id|dm_table_set_restrictions
c_func
(paren
id|t
comma
id|q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__unbind
r_static
r_void
id|__unbind
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
r_struct
id|dm_table
op_star
id|map
op_assign
id|md-&gt;map
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
r_return
suffix:semicolon
id|dm_table_event_callback
c_func
(paren
id|map
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|md-&gt;map_lock
)paren
suffix:semicolon
id|md-&gt;map
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|md-&gt;map_lock
)paren
suffix:semicolon
id|dm_table_put
c_func
(paren
id|map
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Constructor for a new device.&n; */
DECL|function|create_aux
r_static
r_int
id|create_aux
c_func
(paren
r_int
r_int
id|minor
comma
r_int
id|persistent
comma
r_struct
id|mapped_device
op_star
op_star
id|result
)paren
(brace
r_struct
id|mapped_device
op_star
id|md
suffix:semicolon
id|md
op_assign
id|alloc_dev
c_func
(paren
id|minor
comma
id|persistent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
op_star
id|result
op_assign
id|md
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dm_create
r_int
id|dm_create
c_func
(paren
r_struct
id|mapped_device
op_star
op_star
id|result
)paren
(brace
r_return
id|create_aux
c_func
(paren
l_int|0
comma
l_int|0
comma
id|result
)paren
suffix:semicolon
)brace
DECL|function|dm_create_with_minor
r_int
id|dm_create_with_minor
c_func
(paren
r_int
r_int
id|minor
comma
r_struct
id|mapped_device
op_star
op_star
id|result
)paren
(brace
r_return
id|create_aux
c_func
(paren
id|minor
comma
l_int|1
comma
id|result
)paren
suffix:semicolon
)brace
DECL|function|dm_get
r_void
id|dm_get
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|md-&gt;holders
)paren
suffix:semicolon
)brace
DECL|function|dm_put
r_void
id|dm_put
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
r_struct
id|dm_table
op_star
id|map
op_assign
id|dm_get_table
c_func
(paren
id|md
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|md-&gt;holders
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|DMF_SUSPENDED
comma
op_amp
id|md-&gt;flags
)paren
op_logical_and
id|map
)paren
id|dm_table_suspend_targets
c_func
(paren
id|map
)paren
suffix:semicolon
id|__unbind
c_func
(paren
id|md
)paren
suffix:semicolon
id|free_dev
c_func
(paren
id|md
)paren
suffix:semicolon
)brace
id|dm_table_put
c_func
(paren
id|map
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the deferred bios&n; */
DECL|function|__flush_deferred_io
r_static
r_void
id|__flush_deferred_io
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
comma
r_struct
id|bio
op_star
id|c
)paren
(brace
r_struct
id|bio
op_star
id|n
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
id|n
op_assign
id|c-&gt;bi_next
suffix:semicolon
id|c-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
id|__split_bio
c_func
(paren
id|md
comma
id|c
)paren
suffix:semicolon
id|c
op_assign
id|n
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Swap in a new table (destroying old one).&n; */
DECL|function|dm_swap_table
r_int
id|dm_swap_table
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
comma
r_struct
id|dm_table
op_star
id|table
)paren
(brace
r_int
id|r
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* device must be suspended */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|DMF_SUSPENDED
comma
op_amp
id|md-&gt;flags
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|__unbind
c_func
(paren
id|md
)paren
suffix:semicolon
id|r
op_assign
id|__bind
c_func
(paren
id|md
comma
id|table
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
id|r
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Functions to lock and unlock any filesystem running on the&n; * device.&n; */
DECL|function|__lock_fs
r_static
r_int
id|__lock_fs
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|DMF_FS_LOCKED
comma
op_amp
id|md-&gt;flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|bdev
op_assign
id|bdget_disk
c_func
(paren
id|md-&gt;disk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdev
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;bdget failed in __lock_fs&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|WARN_ON
c_func
(paren
id|md-&gt;frozen_sb
)paren
suffix:semicolon
id|md-&gt;frozen_sb
op_assign
id|freeze_bdev
c_func
(paren
id|bdev
)paren
suffix:semicolon
multiline_comment|/* don&squot;t bdput right now, we don&squot;t want the bdev&n;&t; * to go away while it is locked.  We&squot;ll bdput&n;&t; * in __unlock_fs&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__unlock_fs
r_static
r_int
id|__unlock_fs
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
id|DMF_FS_LOCKED
comma
op_amp
id|md-&gt;flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|bdev
op_assign
id|bdget_disk
c_func
(paren
id|md-&gt;disk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdev
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;bdget failed in __unlock_fs&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|thaw_bdev
c_func
(paren
id|bdev
comma
id|md-&gt;frozen_sb
)paren
suffix:semicolon
id|md-&gt;frozen_sb
op_assign
l_int|NULL
suffix:semicolon
id|bdput
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|bdput
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We need to be able to change a mapping table under a mounted&n; * filesystem.  For example we might want to move some data in&n; * the background.  Before the table can be swapped with&n; * dm_bind_table, dm_suspend must be called to flush any in&n; * flight bios and ensure that any further io gets deferred.&n; */
DECL|function|dm_suspend
r_int
id|dm_suspend
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
r_struct
id|dm_table
op_star
id|map
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
multiline_comment|/* Flush I/O to the device. */
id|down_read
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|DMF_BLOCK_IO
comma
op_amp
id|md-&gt;flags
)paren
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|__lock_fs
c_func
(paren
id|md
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First we set the BLOCK_IO flag so no more ios will be&n;&t; * mapped.&n;&t; */
id|down_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|DMF_BLOCK_IO
comma
op_amp
id|md-&gt;flags
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we get here we know another thread is&n;&t;&t; * trying to suspend as well, so we leave the fs&n;&t;&t; * locked for this thread.&n;&t;&t; */
id|up_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|DMF_BLOCK_IO
comma
op_amp
id|md-&gt;flags
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|md-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* unplug */
id|map
op_assign
id|dm_get_table
c_func
(paren
id|md
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map
)paren
(brace
id|dm_table_unplug_all
c_func
(paren
id|map
)paren
suffix:semicolon
id|dm_table_put
c_func
(paren
id|map
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Then we wait for the already mapped ios to&n;&t; * complete.&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|md-&gt;pending
)paren
op_logical_or
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|io_schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|md-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* were we interrupted ? */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|md-&gt;pending
)paren
)paren
(brace
id|__unlock_fs
c_func
(paren
id|md
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|DMF_BLOCK_IO
comma
op_amp
id|md-&gt;flags
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|DMF_SUSPENDED
comma
op_amp
id|md-&gt;flags
)paren
suffix:semicolon
id|map
op_assign
id|dm_get_table
c_func
(paren
id|md
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map
)paren
id|dm_table_suspend_targets
c_func
(paren
id|map
)paren
suffix:semicolon
id|dm_table_put
c_func
(paren
id|map
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dm_resume
r_int
id|dm_resume
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
r_struct
id|bio
op_star
id|def
suffix:semicolon
r_struct
id|dm_table
op_star
id|map
op_assign
id|dm_get_table
c_func
(paren
id|md
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map
op_logical_or
op_logical_neg
id|test_bit
c_func
(paren
id|DMF_SUSPENDED
comma
op_amp
id|md-&gt;flags
)paren
op_logical_or
op_logical_neg
id|dm_table_get_size
c_func
(paren
id|map
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
id|dm_table_put
c_func
(paren
id|map
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dm_table_resume_targets
c_func
(paren
id|map
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|DMF_SUSPENDED
comma
op_amp
id|md-&gt;flags
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|DMF_BLOCK_IO
comma
op_amp
id|md-&gt;flags
)paren
suffix:semicolon
id|def
op_assign
id|bio_list_get
c_func
(paren
op_amp
id|md-&gt;deferred
)paren
suffix:semicolon
id|__flush_deferred_io
c_func
(paren
id|md
comma
id|def
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|md-&gt;lock
)paren
suffix:semicolon
id|__unlock_fs
c_func
(paren
id|md
)paren
suffix:semicolon
id|dm_table_unplug_all
c_func
(paren
id|map
)paren
suffix:semicolon
id|dm_table_put
c_func
(paren
id|map
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * Event notification.&n; *---------------------------------------------------------------*/
DECL|function|dm_get_event_nr
r_uint32
id|dm_get_event_nr
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
r_return
id|atomic_read
c_func
(paren
op_amp
id|md-&gt;event_nr
)paren
suffix:semicolon
)brace
DECL|function|dm_wait_event
r_int
id|dm_wait_event
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
comma
r_int
id|event_nr
)paren
(brace
r_return
id|wait_event_interruptible
c_func
(paren
id|md-&gt;eventq
comma
(paren
id|event_nr
op_ne
id|atomic_read
c_func
(paren
op_amp
id|md-&gt;event_nr
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The gendisk is only valid as long as you have a reference&n; * count on &squot;md&squot;.&n; */
DECL|function|dm_disk
r_struct
id|gendisk
op_star
id|dm_disk
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
r_return
id|md-&gt;disk
suffix:semicolon
)brace
DECL|function|dm_suspended
r_int
id|dm_suspended
c_func
(paren
r_struct
id|mapped_device
op_star
id|md
)paren
(brace
r_return
id|test_bit
c_func
(paren
id|DMF_SUSPENDED
comma
op_amp
id|md-&gt;flags
)paren
suffix:semicolon
)brace
DECL|variable|dm_blk_dops
r_static
r_struct
id|block_device_operations
id|dm_blk_dops
op_assign
(brace
dot
id|open
op_assign
id|dm_blk_open
comma
dot
id|release
op_assign
id|dm_blk_close
comma
dot
id|owner
op_assign
id|THIS_MODULE
)brace
suffix:semicolon
multiline_comment|/*&n; * module hooks&n; */
DECL|variable|dm_init
id|module_init
c_func
(paren
id|dm_init
)paren
suffix:semicolon
DECL|variable|dm_exit
id|module_exit
c_func
(paren
id|dm_exit
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|major
comma
id|uint
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|major
comma
l_string|&quot;The major number of the device mapper&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
id|DM_NAME
l_string|&quot; driver&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Joe Thornber &lt;thornber@sistina.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
