multiline_comment|/*&n; * dm-snapshot.c&n; *&n; * Copyright (C) 2001-2002 Sistina Software (UK) Limited.&n; *&n; * This file is released under the GPL.&n; */
macro_line|#include &quot;dm.h&quot;
macro_line|#include &quot;dm-snap.h&quot;
macro_line|#include &quot;dm-io.h&quot;
macro_line|#include &quot;kcopyd.h&quot;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
multiline_comment|/*-----------------------------------------------------------------&n; * Persistent snapshots, by persistent we mean that the snapshot&n; * will survive a reboot.&n; *---------------------------------------------------------------*/
multiline_comment|/*&n; * We need to store a record of which parts of the origin have&n; * been copied to the snapshot device.  The snapshot code&n; * requires that we copy exception chunks to chunk aligned areas&n; * of the COW store.  It makes sense therefore, to store the&n; * metadata in chunk size blocks.&n; *&n; * There is no backward or forward compatibility implemented,&n; * snapshots with different disk versions than the kernel will&n; * not be usable.  It is expected that &quot;lvcreate&quot; will blank out&n; * the start of a fresh COW device before calling the snapshot&n; * constructor.&n; *&n; * The first chunk of the COW device just contains the header.&n; * After this there is a chunk filled with exception metadata,&n; * followed by as many exception chunks as can fit in the&n; * metadata areas.&n; *&n; * All on disk structures are in little-endian format.  The end&n; * of the exceptions info is indicated by an exception with a&n; * new_chunk of 0, which is invalid since it would point to the&n; * header chunk.&n; */
multiline_comment|/*&n; * Magic for persistent snapshots: &quot;SnAp&quot; - Feeble isn&squot;t it.&n; */
DECL|macro|SNAP_MAGIC
mdefine_line|#define SNAP_MAGIC 0x70416e53
multiline_comment|/*&n; * The on-disk version of the metadata.&n; */
DECL|macro|SNAPSHOT_DISK_VERSION
mdefine_line|#define SNAPSHOT_DISK_VERSION 1
DECL|struct|disk_header
r_struct
id|disk_header
(brace
DECL|member|magic
r_uint32
id|magic
suffix:semicolon
multiline_comment|/*&n;&t; * Is this snapshot valid.  There is no way of recovering&n;&t; * an invalid snapshot.&n;&t; */
DECL|member|valid
r_uint32
id|valid
suffix:semicolon
multiline_comment|/*&n;&t; * Simple, incrementing version. no backward&n;&t; * compatibility.&n;&t; */
DECL|member|version
r_uint32
id|version
suffix:semicolon
multiline_comment|/* In sectors */
DECL|member|chunk_size
r_uint32
id|chunk_size
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|disk_exception
r_struct
id|disk_exception
(brace
DECL|member|old_chunk
r_uint64
id|old_chunk
suffix:semicolon
DECL|member|new_chunk
r_uint64
id|new_chunk
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|commit_callback
r_struct
id|commit_callback
(brace
DECL|member|callback
r_void
(paren
op_star
id|callback
)paren
(paren
r_void
op_star
comma
r_int
id|success
)paren
suffix:semicolon
DECL|member|context
r_void
op_star
id|context
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * The top level structure for a persistent exception store.&n; */
DECL|struct|pstore
r_struct
id|pstore
(brace
DECL|member|snap
r_struct
id|dm_snapshot
op_star
id|snap
suffix:semicolon
multiline_comment|/* up pointer to my snapshot */
DECL|member|version
r_int
id|version
suffix:semicolon
DECL|member|valid
r_int
id|valid
suffix:semicolon
DECL|member|chunk_size
r_uint32
id|chunk_size
suffix:semicolon
DECL|member|exceptions_per_area
r_uint32
id|exceptions_per_area
suffix:semicolon
multiline_comment|/*&n;&t; * Now that we have an asynchronous kcopyd there is no&n;&t; * need for large chunk sizes, so it wont hurt to have a&n;&t; * whole chunks worth of metadata in memory at once.&n;&t; */
DECL|member|area
r_void
op_star
id|area
suffix:semicolon
multiline_comment|/*&n;&t; * Used to keep track of which metadata area the data in&n;&t; * &squot;chunk&squot; refers to.&n;&t; */
DECL|member|current_area
r_uint32
id|current_area
suffix:semicolon
multiline_comment|/*&n;&t; * The next free chunk for an exception.&n;&t; */
DECL|member|next_free
r_uint32
id|next_free
suffix:semicolon
multiline_comment|/*&n;&t; * The index of next free exception in the current&n;&t; * metadata area.&n;&t; */
DECL|member|current_committed
r_uint32
id|current_committed
suffix:semicolon
DECL|member|pending_count
id|atomic_t
id|pending_count
suffix:semicolon
DECL|member|callback_count
r_uint32
id|callback_count
suffix:semicolon
DECL|member|callbacks
r_struct
id|commit_callback
op_star
id|callbacks
suffix:semicolon
)brace
suffix:semicolon
DECL|function|sectors_to_pages
r_static
r_inline
r_int
r_int
id|sectors_to_pages
c_func
(paren
r_int
r_int
id|sectors
)paren
(brace
r_return
id|sectors
op_div
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
suffix:semicolon
)brace
DECL|function|alloc_area
r_static
r_int
id|alloc_area
c_func
(paren
r_struct
id|pstore
op_star
id|ps
)paren
(brace
r_int
id|r
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_int
id|len
suffix:semicolon
id|len
op_assign
id|ps-&gt;chunk_size
op_lshift
id|SECTOR_SHIFT
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate the chunk_size block of memory that will hold&n;&t; * a single metadata area.&n;&t; */
id|ps-&gt;area
op_assign
id|vmalloc
c_func
(paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ps-&gt;area
)paren
r_return
id|r
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|free_area
r_static
r_void
id|free_area
c_func
(paren
r_struct
id|pstore
op_star
id|ps
)paren
(brace
id|vfree
c_func
(paren
id|ps-&gt;area
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read or write a chunk aligned and sized block of data from a device.&n; */
DECL|function|chunk_io
r_static
r_int
id|chunk_io
c_func
(paren
r_struct
id|pstore
op_star
id|ps
comma
r_uint32
id|chunk
comma
r_int
id|rw
)paren
(brace
r_struct
id|io_region
id|where
suffix:semicolon
r_int
r_int
id|bits
suffix:semicolon
id|where.bdev
op_assign
id|ps-&gt;snap-&gt;cow-&gt;bdev
suffix:semicolon
id|where.sector
op_assign
id|ps-&gt;chunk_size
op_star
id|chunk
suffix:semicolon
id|where.count
op_assign
id|ps-&gt;chunk_size
suffix:semicolon
r_return
id|dm_io_sync_vm
c_func
(paren
l_int|1
comma
op_amp
id|where
comma
id|rw
comma
id|ps-&gt;area
comma
op_amp
id|bits
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read or write a metadata area.  Remembering to skip the first&n; * chunk which holds the header.&n; */
DECL|function|area_io
r_static
r_int
id|area_io
c_func
(paren
r_struct
id|pstore
op_star
id|ps
comma
r_uint32
id|area
comma
r_int
id|rw
)paren
(brace
r_int
id|r
suffix:semicolon
r_uint32
id|chunk
suffix:semicolon
multiline_comment|/* convert a metadata area index to a chunk index */
id|chunk
op_assign
l_int|1
op_plus
(paren
(paren
id|ps-&gt;exceptions_per_area
op_plus
l_int|1
)paren
op_star
id|area
)paren
suffix:semicolon
id|r
op_assign
id|chunk_io
c_func
(paren
id|ps
comma
id|chunk
comma
id|rw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
id|r
suffix:semicolon
id|ps-&gt;current_area
op_assign
id|area
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|zero_area
r_static
r_int
id|zero_area
c_func
(paren
r_struct
id|pstore
op_star
id|ps
comma
r_uint32
id|area
)paren
(brace
id|memset
c_func
(paren
id|ps-&gt;area
comma
l_int|0
comma
id|ps-&gt;chunk_size
op_lshift
id|SECTOR_SHIFT
)paren
suffix:semicolon
r_return
id|area_io
c_func
(paren
id|ps
comma
id|area
comma
id|WRITE
)paren
suffix:semicolon
)brace
DECL|function|read_header
r_static
r_int
id|read_header
c_func
(paren
r_struct
id|pstore
op_star
id|ps
comma
r_int
op_star
id|new_snapshot
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|disk_header
op_star
id|dh
suffix:semicolon
id|r
op_assign
id|chunk_io
c_func
(paren
id|ps
comma
l_int|0
comma
id|READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
id|r
suffix:semicolon
id|dh
op_assign
(paren
r_struct
id|disk_header
op_star
)paren
id|ps-&gt;area
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|dh-&gt;magic
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|new_snapshot
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|dh-&gt;magic
)paren
op_eq
id|SNAP_MAGIC
)paren
(brace
op_star
id|new_snapshot
op_assign
l_int|0
suffix:semicolon
id|ps-&gt;valid
op_assign
id|le32_to_cpu
c_func
(paren
id|dh-&gt;valid
)paren
suffix:semicolon
id|ps-&gt;version
op_assign
id|le32_to_cpu
c_func
(paren
id|dh-&gt;version
)paren
suffix:semicolon
id|ps-&gt;chunk_size
op_assign
id|le32_to_cpu
c_func
(paren
id|dh-&gt;chunk_size
)paren
suffix:semicolon
)brace
r_else
(brace
id|DMWARN
c_func
(paren
l_string|&quot;Invalid/corrupt snapshot&quot;
)paren
suffix:semicolon
id|r
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
DECL|function|write_header
r_static
r_int
id|write_header
c_func
(paren
r_struct
id|pstore
op_star
id|ps
)paren
(brace
r_struct
id|disk_header
op_star
id|dh
suffix:semicolon
id|memset
c_func
(paren
id|ps-&gt;area
comma
l_int|0
comma
id|ps-&gt;chunk_size
op_lshift
id|SECTOR_SHIFT
)paren
suffix:semicolon
id|dh
op_assign
(paren
r_struct
id|disk_header
op_star
)paren
id|ps-&gt;area
suffix:semicolon
id|dh-&gt;magic
op_assign
id|cpu_to_le32
c_func
(paren
id|SNAP_MAGIC
)paren
suffix:semicolon
id|dh-&gt;valid
op_assign
id|cpu_to_le32
c_func
(paren
id|ps-&gt;valid
)paren
suffix:semicolon
id|dh-&gt;version
op_assign
id|cpu_to_le32
c_func
(paren
id|ps-&gt;version
)paren
suffix:semicolon
id|dh-&gt;chunk_size
op_assign
id|cpu_to_le32
c_func
(paren
id|ps-&gt;chunk_size
)paren
suffix:semicolon
r_return
id|chunk_io
c_func
(paren
id|ps
comma
l_int|0
comma
id|WRITE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Access functions for the disk exceptions, these do the endian conversions.&n; */
DECL|function|get_exception
r_static
r_struct
id|disk_exception
op_star
id|get_exception
c_func
(paren
r_struct
id|pstore
op_star
id|ps
comma
r_uint32
id|index
)paren
(brace
r_if
c_cond
(paren
id|index
op_ge
id|ps-&gt;exceptions_per_area
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
(paren
(paren
r_struct
id|disk_exception
op_star
)paren
id|ps-&gt;area
)paren
op_plus
id|index
suffix:semicolon
)brace
DECL|function|read_exception
r_static
r_int
id|read_exception
c_func
(paren
r_struct
id|pstore
op_star
id|ps
comma
r_uint32
id|index
comma
r_struct
id|disk_exception
op_star
id|result
)paren
(brace
r_struct
id|disk_exception
op_star
id|e
suffix:semicolon
id|e
op_assign
id|get_exception
c_func
(paren
id|ps
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* copy it */
id|result-&gt;old_chunk
op_assign
id|le64_to_cpu
c_func
(paren
id|e-&gt;old_chunk
)paren
suffix:semicolon
id|result-&gt;new_chunk
op_assign
id|le64_to_cpu
c_func
(paren
id|e-&gt;new_chunk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_exception
r_static
r_int
id|write_exception
c_func
(paren
r_struct
id|pstore
op_star
id|ps
comma
r_uint32
id|index
comma
r_struct
id|disk_exception
op_star
id|de
)paren
(brace
r_struct
id|disk_exception
op_star
id|e
suffix:semicolon
id|e
op_assign
id|get_exception
c_func
(paren
id|ps
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* copy it */
id|e-&gt;old_chunk
op_assign
id|cpu_to_le64
c_func
(paren
id|de-&gt;old_chunk
)paren
suffix:semicolon
id|e-&gt;new_chunk
op_assign
id|cpu_to_le64
c_func
(paren
id|de-&gt;new_chunk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Registers the exceptions that are present in the current area.&n; * &squot;full&squot; is filled in to indicate if the area has been&n; * filled.&n; */
DECL|function|insert_exceptions
r_static
r_int
id|insert_exceptions
c_func
(paren
r_struct
id|pstore
op_star
id|ps
comma
r_int
op_star
id|full
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_struct
id|disk_exception
id|de
suffix:semicolon
multiline_comment|/* presume the area is full */
op_star
id|full
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ps-&gt;exceptions_per_area
suffix:semicolon
id|i
op_increment
)paren
(brace
id|r
op_assign
id|read_exception
c_func
(paren
id|ps
comma
id|i
comma
op_amp
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
id|r
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the new_chunk is pointing at the start of&n;&t;&t; * the COW device, where the first metadata area&n;&t;&t; * is we know that we&squot;ve hit the end of the&n;&t;&t; * exceptions.  Therefore the area is not full.&n;&t;&t; */
r_if
c_cond
(paren
id|de.new_chunk
op_eq
l_int|0LL
)paren
(brace
id|ps-&gt;current_committed
op_assign
id|i
suffix:semicolon
op_star
id|full
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Keep track of the start of the free chunks.&n;&t;&t; */
r_if
c_cond
(paren
id|ps-&gt;next_free
op_le
id|de.new_chunk
)paren
id|ps-&gt;next_free
op_assign
id|de.new_chunk
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Otherwise we add the exception to the snapshot.&n;&t;&t; */
id|r
op_assign
id|dm_add_exception
c_func
(paren
id|ps-&gt;snap
comma
id|de.old_chunk
comma
id|de.new_chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
id|r
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_exceptions
r_static
r_int
id|read_exceptions
c_func
(paren
r_struct
id|pstore
op_star
id|ps
)paren
(brace
r_uint32
id|area
suffix:semicolon
r_int
id|r
comma
id|full
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Keeping reading chunks and inserting exceptions until&n;&t; * we find a partially full area.&n;&t; */
r_for
c_loop
(paren
id|area
op_assign
l_int|0
suffix:semicolon
id|full
suffix:semicolon
id|area
op_increment
)paren
(brace
id|r
op_assign
id|area_io
c_func
(paren
id|ps
comma
id|area
comma
id|READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
id|r
suffix:semicolon
id|r
op_assign
id|insert_exceptions
c_func
(paren
id|ps
comma
op_amp
id|full
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
id|r
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_info
r_static
r_inline
r_struct
id|pstore
op_star
id|get_info
c_func
(paren
r_struct
id|exception_store
op_star
id|store
)paren
(brace
r_return
(paren
r_struct
id|pstore
op_star
)paren
id|store-&gt;context
suffix:semicolon
)brace
DECL|function|persistent_fraction_full
r_static
r_void
id|persistent_fraction_full
c_func
(paren
r_struct
id|exception_store
op_star
id|store
comma
id|sector_t
op_star
id|numerator
comma
id|sector_t
op_star
id|denominator
)paren
(brace
op_star
id|numerator
op_assign
id|get_info
c_func
(paren
id|store
)paren
op_member_access_from_pointer
id|next_free
op_star
id|store-&gt;snap-&gt;chunk_size
suffix:semicolon
op_star
id|denominator
op_assign
id|get_dev_size
c_func
(paren
id|store-&gt;snap-&gt;cow-&gt;bdev
)paren
suffix:semicolon
)brace
DECL|function|persistent_destroy
r_static
r_void
id|persistent_destroy
c_func
(paren
r_struct
id|exception_store
op_star
id|store
)paren
(brace
r_struct
id|pstore
op_star
id|ps
op_assign
id|get_info
c_func
(paren
id|store
)paren
suffix:semicolon
id|dm_io_put
c_func
(paren
id|sectors_to_pages
c_func
(paren
id|ps-&gt;chunk_size
)paren
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|ps-&gt;callbacks
)paren
suffix:semicolon
id|free_area
c_func
(paren
id|ps
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ps
)paren
suffix:semicolon
)brace
DECL|function|persistent_read_metadata
r_static
r_int
id|persistent_read_metadata
c_func
(paren
r_struct
id|exception_store
op_star
id|store
)paren
(brace
r_int
id|r
comma
id|new_snapshot
suffix:semicolon
r_struct
id|pstore
op_star
id|ps
op_assign
id|get_info
c_func
(paren
id|store
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read the snapshot header.&n;&t; */
id|r
op_assign
id|read_header
c_func
(paren
id|ps
comma
op_amp
id|new_snapshot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
id|r
suffix:semicolon
multiline_comment|/*&n;&t; * Do we need to setup a new snapshot ?&n;&t; */
r_if
c_cond
(paren
id|new_snapshot
)paren
(brace
id|r
op_assign
id|write_header
c_func
(paren
id|ps
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;write_header failed&quot;
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
id|r
op_assign
id|zero_area
c_func
(paren
id|ps
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;zero_area(0) failed&quot;
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Sanity checks.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ps-&gt;valid
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;snapshot is marked invalid&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ps-&gt;version
op_ne
id|SNAPSHOT_DISK_VERSION
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;unable to handle snapshot disk version %d&quot;
comma
id|ps-&gt;version
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Read the metadata.&n;&t;&t; */
id|r
op_assign
id|read_exceptions
c_func
(paren
id|ps
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
id|r
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|persistent_prepare
r_static
r_int
id|persistent_prepare
c_func
(paren
r_struct
id|exception_store
op_star
id|store
comma
r_struct
id|exception
op_star
id|e
)paren
(brace
r_struct
id|pstore
op_star
id|ps
op_assign
id|get_info
c_func
(paren
id|store
)paren
suffix:semicolon
r_uint32
id|stride
suffix:semicolon
id|sector_t
id|size
op_assign
id|get_dev_size
c_func
(paren
id|store-&gt;snap-&gt;cow-&gt;bdev
)paren
suffix:semicolon
multiline_comment|/* Is there enough room ? */
r_if
c_cond
(paren
id|size
OL
(paren
(paren
id|ps-&gt;next_free
op_plus
l_int|1
)paren
op_star
id|store-&gt;snap-&gt;chunk_size
)paren
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|e-&gt;new_chunk
op_assign
id|ps-&gt;next_free
suffix:semicolon
multiline_comment|/*&n;&t; * Move onto the next free pending, making sure to take&n;&t; * into account the location of the metadata chunks.&n;&t; */
id|stride
op_assign
(paren
id|ps-&gt;exceptions_per_area
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_increment
id|ps-&gt;next_free
op_mod
id|stride
)paren
op_eq
l_int|1
)paren
id|ps-&gt;next_free
op_increment
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|ps-&gt;pending_count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|persistent_commit
r_static
r_void
id|persistent_commit
c_func
(paren
r_struct
id|exception_store
op_star
id|store
comma
r_struct
id|exception
op_star
id|e
comma
r_void
(paren
op_star
id|callback
)paren
(paren
r_void
op_star
comma
r_int
id|success
)paren
comma
r_void
op_star
id|callback_context
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_struct
id|pstore
op_star
id|ps
op_assign
id|get_info
c_func
(paren
id|store
)paren
suffix:semicolon
r_struct
id|disk_exception
id|de
suffix:semicolon
r_struct
id|commit_callback
op_star
id|cb
suffix:semicolon
id|de.old_chunk
op_assign
id|e-&gt;old_chunk
suffix:semicolon
id|de.new_chunk
op_assign
id|e-&gt;new_chunk
suffix:semicolon
id|write_exception
c_func
(paren
id|ps
comma
id|ps-&gt;current_committed
op_increment
comma
op_amp
id|de
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Add the callback to the back of the array.  This code&n;&t; * is the only place where the callback array is&n;&t; * manipulated, and we know that it will never be called&n;&t; * multiple times concurrently.&n;&t; */
id|cb
op_assign
id|ps-&gt;callbacks
op_plus
id|ps-&gt;callback_count
op_increment
suffix:semicolon
id|cb-&gt;callback
op_assign
id|callback
suffix:semicolon
id|cb-&gt;context
op_assign
id|callback_context
suffix:semicolon
multiline_comment|/*&n;&t; * If there are no more exceptions in flight, or we have&n;&t; * filled this metadata area we commit the exceptions to&n;&t; * disk.&n;&t; */
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ps-&gt;pending_count
)paren
op_logical_or
(paren
id|ps-&gt;current_committed
op_eq
id|ps-&gt;exceptions_per_area
)paren
)paren
(brace
id|r
op_assign
id|area_io
c_func
(paren
id|ps
comma
id|ps-&gt;current_area
comma
id|WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|ps-&gt;valid
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ps-&gt;callback_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cb
op_assign
id|ps-&gt;callbacks
op_plus
id|i
suffix:semicolon
id|cb
op_member_access_from_pointer
id|callback
c_func
(paren
id|cb-&gt;context
comma
id|r
op_eq
l_int|0
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
id|ps-&gt;callback_count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Have we completely filled the current area ?&n;&t; */
r_if
c_cond
(paren
id|ps-&gt;current_committed
op_eq
id|ps-&gt;exceptions_per_area
)paren
(brace
id|ps-&gt;current_committed
op_assign
l_int|0
suffix:semicolon
id|r
op_assign
id|zero_area
c_func
(paren
id|ps
comma
id|ps-&gt;current_area
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|ps-&gt;valid
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|persistent_drop
r_static
r_void
id|persistent_drop
c_func
(paren
r_struct
id|exception_store
op_star
id|store
)paren
(brace
r_struct
id|pstore
op_star
id|ps
op_assign
id|get_info
c_func
(paren
id|store
)paren
suffix:semicolon
id|ps-&gt;valid
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|write_header
c_func
(paren
id|ps
)paren
)paren
id|DMWARN
c_func
(paren
l_string|&quot;write header failed&quot;
)paren
suffix:semicolon
)brace
DECL|function|dm_create_persistent
r_int
id|dm_create_persistent
c_func
(paren
r_struct
id|exception_store
op_star
id|store
comma
r_uint32
id|chunk_size
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|pstore
op_star
id|ps
suffix:semicolon
id|r
op_assign
id|dm_io_get
c_func
(paren
id|sectors_to_pages
c_func
(paren
id|chunk_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
id|r
suffix:semicolon
multiline_comment|/* allocate the pstore */
id|ps
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ps
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ps
)paren
(brace
id|r
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
id|ps-&gt;snap
op_assign
id|store-&gt;snap
suffix:semicolon
id|ps-&gt;valid
op_assign
l_int|1
suffix:semicolon
id|ps-&gt;version
op_assign
id|SNAPSHOT_DISK_VERSION
suffix:semicolon
id|ps-&gt;chunk_size
op_assign
id|chunk_size
suffix:semicolon
id|ps-&gt;exceptions_per_area
op_assign
(paren
id|chunk_size
op_lshift
id|SECTOR_SHIFT
)paren
op_div
r_sizeof
(paren
r_struct
id|disk_exception
)paren
suffix:semicolon
id|ps-&gt;next_free
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* skipping the header and first area */
id|ps-&gt;current_committed
op_assign
l_int|0
suffix:semicolon
id|r
op_assign
id|alloc_area
c_func
(paren
id|ps
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_goto
id|bad
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate space for all the callbacks.&n;&t; */
id|ps-&gt;callback_count
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ps-&gt;pending_count
comma
l_int|0
)paren
suffix:semicolon
id|ps-&gt;callbacks
op_assign
id|dm_vcalloc
c_func
(paren
id|ps-&gt;exceptions_per_area
comma
r_sizeof
(paren
op_star
id|ps-&gt;callbacks
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ps-&gt;callbacks
)paren
(brace
id|r
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
id|store-&gt;destroy
op_assign
id|persistent_destroy
suffix:semicolon
id|store-&gt;read_metadata
op_assign
id|persistent_read_metadata
suffix:semicolon
id|store-&gt;prepare_exception
op_assign
id|persistent_prepare
suffix:semicolon
id|store-&gt;commit_exception
op_assign
id|persistent_commit
suffix:semicolon
id|store-&gt;drop_snapshot
op_assign
id|persistent_drop
suffix:semicolon
id|store-&gt;fraction_full
op_assign
id|persistent_fraction_full
suffix:semicolon
id|store-&gt;context
op_assign
id|ps
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bad
suffix:colon
id|dm_io_put
c_func
(paren
id|sectors_to_pages
c_func
(paren
id|chunk_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ps
)paren
(brace
r_if
c_cond
(paren
id|ps-&gt;area
)paren
id|free_area
c_func
(paren
id|ps
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ps
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * Implementation of the store for non-persistent snapshots.&n; *---------------------------------------------------------------*/
DECL|struct|transient_c
r_struct
id|transient_c
(brace
DECL|member|next_free
id|sector_t
id|next_free
suffix:semicolon
)brace
suffix:semicolon
DECL|function|transient_destroy
r_static
r_void
id|transient_destroy
c_func
(paren
r_struct
id|exception_store
op_star
id|store
)paren
(brace
id|kfree
c_func
(paren
id|store-&gt;context
)paren
suffix:semicolon
)brace
DECL|function|transient_read_metadata
r_static
r_int
id|transient_read_metadata
c_func
(paren
r_struct
id|exception_store
op_star
id|store
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|transient_prepare
r_static
r_int
id|transient_prepare
c_func
(paren
r_struct
id|exception_store
op_star
id|store
comma
r_struct
id|exception
op_star
id|e
)paren
(brace
r_struct
id|transient_c
op_star
id|tc
op_assign
(paren
r_struct
id|transient_c
op_star
)paren
id|store-&gt;context
suffix:semicolon
id|sector_t
id|size
op_assign
id|get_dev_size
c_func
(paren
id|store-&gt;snap-&gt;cow-&gt;bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
(paren
id|tc-&gt;next_free
op_plus
id|store-&gt;snap-&gt;chunk_size
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|e-&gt;new_chunk
op_assign
id|sector_to_chunk
c_func
(paren
id|store-&gt;snap
comma
id|tc-&gt;next_free
)paren
suffix:semicolon
id|tc-&gt;next_free
op_add_assign
id|store-&gt;snap-&gt;chunk_size
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|transient_commit
r_static
r_void
id|transient_commit
c_func
(paren
r_struct
id|exception_store
op_star
id|store
comma
r_struct
id|exception
op_star
id|e
comma
r_void
(paren
op_star
id|callback
)paren
(paren
r_void
op_star
comma
r_int
id|success
)paren
comma
r_void
op_star
id|callback_context
)paren
(brace
multiline_comment|/* Just succeed */
id|callback
c_func
(paren
id|callback_context
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|transient_fraction_full
r_static
r_void
id|transient_fraction_full
c_func
(paren
r_struct
id|exception_store
op_star
id|store
comma
id|sector_t
op_star
id|numerator
comma
id|sector_t
op_star
id|denominator
)paren
(brace
op_star
id|numerator
op_assign
(paren
(paren
r_struct
id|transient_c
op_star
)paren
id|store-&gt;context
)paren
op_member_access_from_pointer
id|next_free
suffix:semicolon
op_star
id|denominator
op_assign
id|get_dev_size
c_func
(paren
id|store-&gt;snap-&gt;cow-&gt;bdev
)paren
suffix:semicolon
)brace
DECL|function|dm_create_transient
r_int
id|dm_create_transient
c_func
(paren
r_struct
id|exception_store
op_star
id|store
comma
r_struct
id|dm_snapshot
op_star
id|s
comma
r_int
id|blocksize
)paren
(brace
r_struct
id|transient_c
op_star
id|tc
suffix:semicolon
id|memset
c_func
(paren
id|store
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|store
)paren
)paren
suffix:semicolon
id|store-&gt;destroy
op_assign
id|transient_destroy
suffix:semicolon
id|store-&gt;read_metadata
op_assign
id|transient_read_metadata
suffix:semicolon
id|store-&gt;prepare_exception
op_assign
id|transient_prepare
suffix:semicolon
id|store-&gt;commit_exception
op_assign
id|transient_commit
suffix:semicolon
id|store-&gt;fraction_full
op_assign
id|transient_fraction_full
suffix:semicolon
id|store-&gt;snap
op_assign
id|s
suffix:semicolon
id|tc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|transient_c
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tc
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|tc-&gt;next_free
op_assign
l_int|0
suffix:semicolon
id|store-&gt;context
op_assign
id|tc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
