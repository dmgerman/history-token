multiline_comment|/*&n; * Copyright (C) 2004 SUSE LINUX Products GmbH. All rights reserved.&n; * Copyright (C) 2004 Red Hat, Inc. All rights reserved.&n; *&n; * This file is released under the GPL.&n; *&n; * Multipath support for EMC CLARiiON AX/CX-series hardware.&n; */
macro_line|#include &quot;dm.h&quot;
macro_line|#include &quot;dm-hw-handler.h&quot;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_cmnd.h&gt;
DECL|struct|emc_handler
r_struct
id|emc_handler
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* Whether we should send the short trespass command (FC-series)&n;&t; * or the long version (default for AX/CX CLARiiON arrays). */
DECL|member|short_trespass
r_int
id|short_trespass
suffix:semicolon
multiline_comment|/* Whether or not to honor SCSI reservations when initiating a&n;&t; * switch-over. Default: Don&squot;t. */
DECL|member|hr
r_int
id|hr
suffix:semicolon
DECL|member|sense
r_int
r_char
id|sense
(braket
id|SCSI_SENSE_BUFFERSIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|TRESPASS_PAGE
mdefine_line|#define TRESPASS_PAGE 0x22
DECL|macro|EMC_FAILOVER_TIMEOUT
mdefine_line|#define EMC_FAILOVER_TIMEOUT (60 * HZ)
multiline_comment|/* Code borrowed from dm-lsi-rdac by Mike Christie */
DECL|function|free_bio
r_static
r_inline
r_void
id|free_bio
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|__free_page
c_func
(paren
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_page
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
DECL|function|emc_endio
r_static
r_int
id|emc_endio
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_struct
id|path
op_star
id|path
op_assign
id|bio-&gt;bi_private
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* We also need to look at the sense keys here whether or not to&n;&t; * switch to the next PG etc.&n;&t; *&n;&t; * For now simple logic: either it works or it doesn&squot;t.&n;&t; */
r_if
c_cond
(paren
id|error
)paren
id|dm_pg_init_complete
c_func
(paren
id|path
comma
id|MP_FAIL_PATH
)paren
suffix:semicolon
r_else
id|dm_pg_init_complete
c_func
(paren
id|path
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* request is freed in block layer */
id|free_bio
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_failover_bio
r_static
r_struct
id|bio
op_star
id|get_failover_bio
c_func
(paren
r_struct
id|path
op_star
id|path
comma
r_int
id|data_size
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_ATOMIC
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;dm-emc: get_failover_bio: bio_alloc() failed.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|bio-&gt;bi_rw
op_or_assign
(paren
l_int|1
op_lshift
id|BIO_RW
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|path-&gt;dev-&gt;bdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|path
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|emc_endio
suffix:semicolon
id|page
op_assign
id|alloc_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;dm-emc: get_failover_bio: alloc_page() failed.&quot;
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bio_add_page
c_func
(paren
id|bio
comma
id|page
comma
id|data_size
comma
l_int|0
)paren
op_ne
id|data_size
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;dm-emc: get_failover_bio: alloc_page() failed.&quot;
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|bio
suffix:semicolon
)brace
DECL|function|get_failover_req
r_static
r_struct
id|request
op_star
id|get_failover_req
c_func
(paren
r_struct
id|emc_handler
op_star
id|h
comma
r_struct
id|bio
op_star
id|bio
comma
r_struct
id|path
op_star
id|path
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
op_assign
id|bio-&gt;bi_bdev
suffix:semicolon
r_struct
id|request_queue
op_star
id|q
op_assign
id|bdev_get_queue
c_func
(paren
id|bdev
)paren
suffix:semicolon
multiline_comment|/* FIXME: Figure out why it fails with GFP_ATOMIC. */
id|rq
op_assign
id|blk_get_request
c_func
(paren
id|q
comma
id|WRITE
comma
id|__GFP_WAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;dm-emc: get_failover_req: blk_get_request failed&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|rq-&gt;bio
op_assign
id|rq-&gt;biotail
op_assign
id|bio
suffix:semicolon
id|blk_rq_bio_prep
c_func
(paren
id|q
comma
id|rq
comma
id|bio
)paren
suffix:semicolon
id|rq-&gt;rq_disk
op_assign
id|bdev-&gt;bd_contains-&gt;bd_disk
suffix:semicolon
multiline_comment|/* bio backed don&squot;t set data */
id|rq-&gt;buffer
op_assign
id|rq-&gt;data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* rq data_len used for pc cmd&squot;s request_bufflen */
id|rq-&gt;data_len
op_assign
id|bio-&gt;bi_size
suffix:semicolon
id|rq-&gt;sense
op_assign
id|h-&gt;sense
suffix:semicolon
id|memset
c_func
(paren
id|rq-&gt;sense
comma
l_int|0
comma
id|SCSI_SENSE_BUFFERSIZE
)paren
suffix:semicolon
id|rq-&gt;sense_len
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|rq-&gt;cmd
comma
l_int|0
comma
id|BLK_MAX_CDB
)paren
suffix:semicolon
id|rq-&gt;timeout
op_assign
id|EMC_FAILOVER_TIMEOUT
suffix:semicolon
id|rq-&gt;flags
op_or_assign
(paren
id|REQ_BLOCK_PC
op_or
id|REQ_FAILFAST
op_or
id|REQ_NOMERGE
)paren
suffix:semicolon
r_return
id|rq
suffix:semicolon
)brace
DECL|function|emc_trespass_get
r_static
r_struct
id|request
op_star
id|emc_trespass_get
c_func
(paren
r_struct
id|emc_handler
op_star
id|h
comma
r_struct
id|path
op_star
id|path
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_int
r_char
op_star
id|page22
suffix:semicolon
r_int
r_char
id|long_trespass_pg
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|TRESPASS_PAGE
comma
multiline_comment|/* Page code */
l_int|0x09
comma
multiline_comment|/* Page length - 2 */
id|h-&gt;hr
ques
c_cond
l_int|0x01
suffix:colon
l_int|0x81
comma
multiline_comment|/* Trespass code + Honor reservation bit */
l_int|0xff
comma
l_int|0xff
comma
multiline_comment|/* Trespass target */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
multiline_comment|/* Reserved bytes / unknown */
)brace
suffix:semicolon
r_int
r_char
id|short_trespass_pg
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|TRESPASS_PAGE
comma
multiline_comment|/* Page code */
l_int|0x02
comma
multiline_comment|/* Page length - 2 */
id|h-&gt;hr
ques
c_cond
l_int|0x01
suffix:colon
l_int|0x81
comma
multiline_comment|/* Trespass code + Honor reservation bit */
l_int|0xff
comma
multiline_comment|/* Trespass target */
)brace
suffix:semicolon
r_int
id|data_size
op_assign
id|h-&gt;short_trespass
ques
c_cond
r_sizeof
(paren
id|short_trespass_pg
)paren
suffix:colon
r_sizeof
(paren
id|long_trespass_pg
)paren
suffix:semicolon
multiline_comment|/* get bio backing */
r_if
c_cond
(paren
id|data_size
OG
id|PAGE_SIZE
)paren
multiline_comment|/* this should never happen */
r_return
l_int|NULL
suffix:semicolon
id|bio
op_assign
id|get_failover_bio
c_func
(paren
id|path
comma
id|data_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;dm-emc: emc_trespass_get: no bio&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|page22
op_assign
(paren
r_int
r_char
op_star
)paren
id|bio_data
c_func
(paren
id|bio
)paren
suffix:semicolon
id|memset
c_func
(paren
id|page22
comma
l_int|0
comma
id|data_size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|page22
comma
id|h-&gt;short_trespass
ques
c_cond
id|short_trespass_pg
suffix:colon
id|long_trespass_pg
comma
id|data_size
)paren
suffix:semicolon
multiline_comment|/* get request for block layer packet command */
id|rq
op_assign
id|get_failover_req
c_func
(paren
id|h
comma
id|bio
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;dm-emc: emc_trespass_get: no rq&quot;
)paren
suffix:semicolon
id|free_bio
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Prepare the command. */
id|rq-&gt;cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SELECT
suffix:semicolon
id|rq-&gt;cmd
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
id|rq-&gt;cmd
(braket
l_int|4
)braket
op_assign
id|data_size
suffix:semicolon
id|rq-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|rq-&gt;cmd
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|rq
suffix:semicolon
)brace
DECL|function|emc_pg_init
r_static
r_void
id|emc_pg_init
c_func
(paren
r_struct
id|hw_handler
op_star
id|hwh
comma
r_int
id|bypassed
comma
r_struct
id|path
op_star
id|path
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_struct
id|request_queue
op_star
id|q
op_assign
id|bdev_get_queue
c_func
(paren
id|path-&gt;dev-&gt;bdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We can either blindly init the pg (then look at the sense),&n;&t; * or we can send some commands to get the state here (then&n;&t; * possibly send the fo cmnd), or we can also have the&n;&t; * initial state passed into us and then get an update here.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
(brace
id|DMINFO
c_func
(paren
l_string|&quot;dm-emc: emc_pg_init: no queue&quot;
)paren
suffix:semicolon
r_goto
id|fail_path
suffix:semicolon
)brace
multiline_comment|/* FIXME: The request should be pre-allocated. */
id|rq
op_assign
id|emc_trespass_get
c_func
(paren
id|hwh-&gt;context
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;dm-emc: emc_pg_init: no rq&quot;
)paren
suffix:semicolon
r_goto
id|fail_path
suffix:semicolon
)brace
id|DMINFO
c_func
(paren
l_string|&quot;dm-emc: emc_pg_init: sending switch-over command&quot;
)paren
suffix:semicolon
id|elv_add_request
c_func
(paren
id|q
comma
id|rq
comma
id|ELEVATOR_INSERT_FRONT
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
id|fail_path
suffix:colon
id|dm_pg_init_complete
c_func
(paren
id|path
comma
id|MP_FAIL_PATH
)paren
suffix:semicolon
)brace
DECL|function|alloc_emc_handler
r_static
r_struct
id|emc_handler
op_star
id|alloc_emc_handler
c_func
(paren
r_void
)paren
(brace
r_struct
id|emc_handler
op_star
id|h
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|h
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
)paren
id|spin_lock_init
c_func
(paren
op_amp
id|h-&gt;lock
)paren
suffix:semicolon
r_return
id|h
suffix:semicolon
)brace
DECL|function|emc_ctr
r_static
r_int
id|emc_ctr
c_func
(paren
r_struct
id|hw_handler
op_star
id|hwh
comma
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_struct
id|emc_handler
op_star
id|h
suffix:semicolon
r_int
id|hr
comma
id|short_trespass
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_eq
l_int|0
)paren
(brace
multiline_comment|/* No arguments: use defaults */
id|hr
op_assign
l_int|0
suffix:semicolon
id|short_trespass
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|argc
op_ne
l_int|2
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;dm-emc hwhandler: incorrect number of arguments&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|sscanf
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
l_string|&quot;%u&quot;
comma
op_amp
id|short_trespass
)paren
op_ne
l_int|1
)paren
op_logical_or
(paren
id|short_trespass
OG
l_int|1
)paren
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;dm-emc: invalid trespass mode selected&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sscanf
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;%u&quot;
comma
op_amp
id|hr
)paren
op_ne
l_int|1
)paren
op_logical_or
(paren
id|hr
OG
l_int|1
)paren
)paren
(brace
id|DMWARN
c_func
(paren
l_string|&quot;dm-emc: invalid honor reservation flag selected&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
id|h
op_assign
id|alloc_emc_handler
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|h
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|h
)paren
)paren
suffix:semicolon
id|hwh-&gt;context
op_assign
id|h
suffix:semicolon
r_if
c_cond
(paren
(paren
id|h-&gt;short_trespass
op_assign
id|short_trespass
)paren
)paren
id|DMWARN
c_func
(paren
l_string|&quot;dm-emc: short trespass command will be send&quot;
)paren
suffix:semicolon
r_else
id|DMWARN
c_func
(paren
l_string|&quot;dm-emc: long trespass command will be send&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|h-&gt;hr
op_assign
id|hr
)paren
)paren
id|DMWARN
c_func
(paren
l_string|&quot;dm-emc: honor reservation bit will be set&quot;
)paren
suffix:semicolon
r_else
id|DMWARN
c_func
(paren
l_string|&quot;dm-emc: honor reservation bit will not be set (default)&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|emc_dtr
r_static
r_void
id|emc_dtr
c_func
(paren
r_struct
id|hw_handler
op_star
id|hwh
)paren
(brace
r_struct
id|emc_handler
op_star
id|h
op_assign
(paren
r_struct
id|emc_handler
op_star
)paren
id|hwh-&gt;context
suffix:semicolon
id|kfree
c_func
(paren
id|h
)paren
suffix:semicolon
id|hwh-&gt;context
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|emc_err
r_static
r_int
id|emc_err
c_func
(paren
r_struct
id|hw_handler
op_star
id|hwh
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
multiline_comment|/* FIXME: Patch from axboe still missing */
macro_line|#if 0
r_int
id|sense
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_error
op_amp
id|BIO_SENSE
)paren
(brace
id|sense
op_assign
id|bio-&gt;bi_error
op_amp
l_int|0xffffff
suffix:semicolon
multiline_comment|/* sense key / asc / ascq */
r_if
c_cond
(paren
id|sense
op_eq
l_int|0x020403
)paren
(brace
multiline_comment|/* LUN Not Ready - Manual Intervention Required&n;&t;&t;&t; * indicates this is a passive path.&n;&t;&t;&t; *&n;&t;&t;&t; * FIXME: However, if this is seen and EVPD C0&n;&t;&t;&t; * indicates that this is due to a NDU in&n;&t;&t;&t; * progress, we should set FAIL_PATH too.&n;&t;&t;&t; * This indicates we might have to do a SCSI&n;&t;&t;&t; * inquiry in the end_io path. Ugh. */
r_return
id|MP_BYPASS_PG
op_or
id|MP_RETRY_IO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense
op_eq
l_int|0x052501
)paren
(brace
multiline_comment|/* An array based copy is in progress. Do not&n;&t;&t;&t; * fail the path, do not bypass to another PG,&n;&t;&t;&t; * do not retry. Fail the IO immediately.&n;&t;&t;&t; * (Actually this is the same conclusion as in&n;&t;&t;&t; * the default handler, but lets make sure.) */
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense
op_eq
l_int|0x062900
)paren
(brace
multiline_comment|/* Unit Attention Code. This is the first IO&n;&t;&t;&t; * to the new path, so just retry. */
r_return
id|MP_RETRY_IO
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Try default handler */
r_return
id|dm_scsi_err_handler
c_func
(paren
id|hwh
comma
id|bio
)paren
suffix:semicolon
)brace
DECL|variable|emc_hwh
r_static
r_struct
id|hw_handler_type
id|emc_hwh
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;emc&quot;
comma
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|ctr
op_assign
id|emc_ctr
comma
dot
id|dtr
op_assign
id|emc_dtr
comma
dot
id|pg_init
op_assign
id|emc_pg_init
comma
dot
id|err
op_assign
id|emc_err
comma
)brace
suffix:semicolon
DECL|function|dm_emc_init
r_static
r_int
id|__init
id|dm_emc_init
c_func
(paren
r_void
)paren
(brace
r_int
id|r
op_assign
id|dm_register_hw_handler
c_func
(paren
op_amp
id|emc_hwh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
id|DMERR
c_func
(paren
l_string|&quot;emc: register failed %d&quot;
comma
id|r
)paren
suffix:semicolon
id|DMINFO
c_func
(paren
l_string|&quot;dm-emc version 0.0.3 loaded&quot;
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|dm_emc_exit
r_static
r_void
id|__exit
id|dm_emc_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|r
op_assign
id|dm_unregister_hw_handler
c_func
(paren
op_amp
id|emc_hwh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
id|DMERR
c_func
(paren
l_string|&quot;emc: unregister failed %d&quot;
comma
id|r
)paren
suffix:semicolon
)brace
DECL|variable|dm_emc_init
id|module_init
c_func
(paren
id|dm_emc_init
)paren
suffix:semicolon
DECL|variable|dm_emc_exit
id|module_exit
c_func
(paren
id|dm_emc_exit
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
id|DM_NAME
l_string|&quot; EMC CX/AX/FC-family multipath&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Lars Marowsky-Bree &lt;lmb@suse.de&gt;&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
