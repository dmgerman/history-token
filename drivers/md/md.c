multiline_comment|/*&n;   md.c : Multiple Devices driver for Linux&n;&t;  Copyright (C) 1998, 1999, 2000 Ingo Molnar&n;&n;     completely rewritten, based on the MD driver code from Marc Zyngier&n;&n;   Changes:&n;&n;   - RAID-1/RAID-5 extensions by Miguel de Icaza, Gadi Oxman, Ingo Molnar&n;   - RAID-6 extensions by H. Peter Anvin &lt;hpa@zytor.com&gt;&n;   - boot support for linear and striped mode by Harald Hoyer &lt;HarryH@Royal.Net&gt;&n;   - kerneld support by Boris Tobotras &lt;boris@xtalk.msk.su&gt;&n;   - kmod support by: Cyrus Durgin&n;   - RAID0 bugfixes: Mark Anthony Lisher &lt;markal@iname.com&gt;&n;   - Devfs support by Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&n;   - lots of fixes and improvements to the RAID1/RAID5 and generic&n;     RAID code (such as request based resynchronization):&n;&n;     Neil Brown &lt;neilb@cse.unsw.edu.au&gt;.&n;&n;   This program is free software; you can redistribute it and/or modify&n;   it under the terms of the GNU General Public License as published by&n;   the Free Software Foundation; either version 2, or (at your option)&n;   any later version.&n;&n;   You should have received a copy of the GNU General Public License&n;   (for example /usr/src/linux/COPYING); if not, write to the Free&n;   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;linux/raid/md.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt; /* for invalidate_bdev */
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/unaligned.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MD_MAJOR
DECL|macro|MD_DRIVER
mdefine_line|#define MD_DRIVER
multiline_comment|/* 63 partitions with the alternate major number (mdp) */
DECL|macro|MdpMinorShift
mdefine_line|#define MdpMinorShift 6
DECL|macro|DEBUG
mdefine_line|#define DEBUG 0
DECL|macro|dprintk
mdefine_line|#define dprintk(x...) ((void)(DEBUG &amp;&amp; printk(x)))
macro_line|#ifndef MODULE
r_static
r_void
id|autostart_arrays
(paren
r_int
id|part
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|pers
r_static
id|mdk_personality_t
op_star
id|pers
(braket
id|MAX_PERSONALITY
)braket
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|pers_lock
)paren
suffix:semicolon
multiline_comment|/*&n; * Current RAID-1,4,5 parallel reconstruction &squot;guaranteed speed limit&squot;&n; * is 1000 KB/sec, so the extra system load does not show up that much.&n; * Increase it if you want to have more _guaranteed_ speed. Note that&n; * the RAID driver will use the maximum available bandwith if the IO&n; * subsystem is idle. There is also an &squot;absolute maximum&squot; reconstruction&n; * speed limit - in case reconstruction slows down your system despite&n; * idle IO detection.&n; *&n; * you can change it via /proc/sys/dev/raid/speed_limit_min and _max.&n; */
DECL|variable|sysctl_speed_limit_min
r_static
r_int
id|sysctl_speed_limit_min
op_assign
l_int|1000
suffix:semicolon
DECL|variable|sysctl_speed_limit_max
r_static
r_int
id|sysctl_speed_limit_max
op_assign
l_int|200000
suffix:semicolon
DECL|variable|raid_table_header
r_static
r_struct
id|ctl_table_header
op_star
id|raid_table_header
suffix:semicolon
DECL|variable|raid_table
r_static
id|ctl_table
id|raid_table
(braket
)braket
op_assign
(brace
(brace
dot
id|ctl_name
op_assign
id|DEV_RAID_SPEED_LIMIT_MIN
comma
dot
id|procname
op_assign
l_string|&quot;speed_limit_min&quot;
comma
dot
id|data
op_assign
op_amp
id|sysctl_speed_limit_min
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0644
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|DEV_RAID_SPEED_LIMIT_MAX
comma
dot
id|procname
op_assign
l_string|&quot;speed_limit_max&quot;
comma
dot
id|data
op_assign
op_amp
id|sysctl_speed_limit_max
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0644
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|raid_dir_table
r_static
id|ctl_table
id|raid_dir_table
(braket
)braket
op_assign
(brace
(brace
dot
id|ctl_name
op_assign
id|DEV_RAID
comma
dot
id|procname
op_assign
l_string|&quot;raid&quot;
comma
dot
id|maxlen
op_assign
l_int|0
comma
dot
id|mode
op_assign
l_int|0555
comma
dot
id|child
op_assign
id|raid_table
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|raid_root_table
r_static
id|ctl_table
id|raid_root_table
(braket
)braket
op_assign
(brace
(brace
dot
id|ctl_name
op_assign
id|CTL_DEV
comma
dot
id|procname
op_assign
l_string|&quot;dev&quot;
comma
dot
id|maxlen
op_assign
l_int|0
comma
dot
id|mode
op_assign
l_int|0555
comma
dot
id|child
op_assign
id|raid_dir_table
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|md_fops
r_static
r_struct
id|block_device_operations
id|md_fops
suffix:semicolon
multiline_comment|/*&n; * Enables to iterate over all existing md arrays&n; * all_mddevs_lock protects this list.&n; */
r_static
id|LIST_HEAD
c_func
(paren
id|all_mddevs
)paren
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|all_mddevs_lock
)paren
suffix:semicolon
multiline_comment|/*&n; * iterates through all used mddevs in the system.&n; * We take care to grab the all_mddevs_lock whenever navigating&n; * the list, and to always hold a refcount when unlocked.&n; * Any code which breaks out of this loop while own&n; * a reference to the current mddev and must mddev_put it.&n; */
DECL|macro|ITERATE_MDDEV
mdefine_line|#define ITERATE_MDDEV(mddev,tmp)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;for (({ spin_lock(&amp;all_mddevs_lock); &t;&t;&t;&t;&bslash;&n;&t;&t;tmp = all_mddevs.next;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;mddev = NULL;});&t;&t;&t;&t;&t;&bslash;&n;&t;     ({ if (tmp != &amp;all_mddevs)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;mddev_get(list_entry(tmp, mddev_t, all_mddevs));&bslash;&n;&t;&t;spin_unlock(&amp;all_mddevs_lock);&t;&t;&t;&t;&bslash;&n;&t;&t;if (mddev) mddev_put(mddev);&t;&t;&t;&t;&bslash;&n;&t;&t;mddev = list_entry(tmp, mddev_t, all_mddevs);&t;&t;&bslash;&n;&t;&t;tmp != &amp;all_mddevs;});&t;&t;&t;&t;&t;&bslash;&n;&t;     ({ spin_lock(&amp;all_mddevs_lock);&t;&t;&t;&t;&bslash;&n;&t;&t;tmp = tmp-&gt;next;})&t;&t;&t;&t;&t;&bslash;&n;&t;&t;)
DECL|function|md_fail_request
r_static
r_int
id|md_fail_request
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|bio_io_error
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mddev_get
r_static
r_inline
id|mddev_t
op_star
id|mddev_get
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|mddev-&gt;active
)paren
suffix:semicolon
r_return
id|mddev
suffix:semicolon
)brace
DECL|function|mddev_put
r_static
r_void
id|mddev_put
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_lock
c_func
(paren
op_amp
id|mddev-&gt;active
comma
op_amp
id|all_mddevs_lock
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;raid_disks
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|mddev-&gt;all_mddevs
)paren
suffix:semicolon
id|blk_put_queue
c_func
(paren
id|mddev-&gt;queue
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
)brace
DECL|function|mddev_find
r_static
id|mddev_t
op_star
id|mddev_find
c_func
(paren
id|dev_t
id|unit
)paren
(brace
id|mddev_t
op_star
id|mddev
comma
op_star
r_new
op_assign
l_int|NULL
suffix:semicolon
id|retry
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|mddev
comma
op_amp
id|all_mddevs
comma
id|all_mddevs
)paren
r_if
c_cond
(paren
id|mddev-&gt;unit
op_eq
id|unit
)paren
(brace
id|mddev_get
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
id|kfree
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
id|mddev
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
)paren
(brace
id|list_add
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|all_mddevs
comma
op_amp
id|all_mddevs
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
r_new
op_assign
(paren
id|mddev_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
r_new
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
r_new
comma
l_int|0
comma
r_sizeof
(paren
op_star
r_new
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|unit
op_assign
id|unit
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|unit
)paren
op_eq
id|MD_MAJOR
)paren
r_new
op_member_access_from_pointer
id|md_minor
op_assign
id|MINOR
c_func
(paren
id|unit
)paren
suffix:semicolon
r_else
r_new
op_member_access_from_pointer
id|md_minor
op_assign
id|MINOR
c_func
(paren
id|unit
)paren
op_rshift
id|MdpMinorShift
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|reconfig_sem
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|disks
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|all_mddevs
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|safemode_timer
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|active
comma
l_int|1
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|queue
op_assign
id|blk_alloc_queue
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
op_member_access_from_pointer
id|queue
)paren
(brace
id|kfree
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|blk_queue_make_request
c_func
(paren
r_new
op_member_access_from_pointer
id|queue
comma
id|md_fail_request
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
DECL|function|mddev_lock
r_static
r_inline
r_int
id|mddev_lock
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_return
id|down_interruptible
c_func
(paren
op_amp
id|mddev-&gt;reconfig_sem
)paren
suffix:semicolon
)brace
DECL|function|mddev_lock_uninterruptible
r_static
r_inline
r_void
id|mddev_lock_uninterruptible
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|down
c_func
(paren
op_amp
id|mddev-&gt;reconfig_sem
)paren
suffix:semicolon
)brace
DECL|function|mddev_trylock
r_static
r_inline
r_int
id|mddev_trylock
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_return
id|down_trylock
c_func
(paren
op_amp
id|mddev-&gt;reconfig_sem
)paren
suffix:semicolon
)brace
DECL|function|mddev_unlock
r_static
r_inline
r_void
id|mddev_unlock
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|up
c_func
(paren
op_amp
id|mddev-&gt;reconfig_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;thread
)paren
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
)brace
DECL|function|find_rdev_nr
id|mdk_rdev_t
op_star
id|find_rdev_nr
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|nr
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
id|nr
)paren
r_return
id|rdev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|find_rdev
r_static
id|mdk_rdev_t
op_star
id|find_rdev
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|dev_t
id|dev
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;bdev-&gt;bd_dev
op_eq
id|dev
)paren
r_return
id|rdev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|calc_dev_sboffset
r_inline
r_static
id|sector_t
id|calc_dev_sboffset
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
id|sector_t
id|size
op_assign
id|bdev-&gt;bd_inode-&gt;i_size
op_rshift
id|BLOCK_SIZE_BITS
suffix:semicolon
r_return
id|MD_NEW_SIZE_BLOCKS
c_func
(paren
id|size
)paren
suffix:semicolon
)brace
DECL|function|calc_dev_size
r_static
id|sector_t
id|calc_dev_size
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
comma
r_int
id|chunk_size
)paren
(brace
id|sector_t
id|size
suffix:semicolon
id|size
op_assign
id|rdev-&gt;sb_offset
suffix:semicolon
r_if
c_cond
(paren
id|chunk_size
)paren
id|size
op_and_assign
op_complement
(paren
(paren
id|sector_t
)paren
id|chunk_size
op_div
l_int|1024
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|alloc_disk_sb
r_static
r_int
id|alloc_disk_sb
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;sb_page
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|rdev-&gt;sb_page
op_assign
id|alloc_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb_page
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;md: out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|free_disk_sb
r_static
r_void
id|free_disk_sb
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;sb_page
)paren
(brace
id|page_cache_release
c_func
(paren
id|rdev-&gt;sb_page
)paren
suffix:semicolon
id|rdev-&gt;sb_loaded
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;sb_page
op_assign
l_int|NULL
suffix:semicolon
id|rdev-&gt;sb_offset
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;size
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|bi_complete
r_static
r_int
id|bi_complete
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
id|complete
c_func
(paren
(paren
r_struct
id|completion
op_star
)paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sync_page_io
r_static
r_int
id|sync_page_io
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|sector
comma
r_int
id|size
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|rw
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_KERNEL
comma
l_int|1
)paren
suffix:semicolon
r_struct
id|completion
id|event
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|rw
op_or_assign
(paren
l_int|1
op_lshift
id|BIO_RW_SYNC
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|bdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|sector
suffix:semicolon
id|bio_add_page
c_func
(paren
id|bio
comma
id|page
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|bio-&gt;bi_private
op_assign
op_amp
id|event
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|bi_complete
suffix:semicolon
id|submit_bio
c_func
(paren
id|rw
comma
id|bio
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|ret
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|read_disk_sb
r_static
r_int
id|read_disk_sb
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb_page
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;sb_loaded
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sync_page_io
c_func
(paren
id|rdev-&gt;bdev
comma
id|rdev-&gt;sb_offset
op_lshift
l_int|1
comma
id|MD_SB_BYTES
comma
id|rdev-&gt;sb_page
comma
id|READ
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|rdev-&gt;sb_loaded
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: disabled device %s, could not read superblock.&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|uuid_equal
r_static
r_int
id|uuid_equal
c_func
(paren
id|mdp_super_t
op_star
id|sb1
comma
id|mdp_super_t
op_star
id|sb2
)paren
(brace
r_if
c_cond
(paren
(paren
id|sb1-&gt;set_uuid0
op_eq
id|sb2-&gt;set_uuid0
)paren
op_logical_and
(paren
id|sb1-&gt;set_uuid1
op_eq
id|sb2-&gt;set_uuid1
)paren
op_logical_and
(paren
id|sb1-&gt;set_uuid2
op_eq
id|sb2-&gt;set_uuid2
)paren
op_logical_and
(paren
id|sb1-&gt;set_uuid3
op_eq
id|sb2-&gt;set_uuid3
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sb_equal
r_static
r_int
id|sb_equal
c_func
(paren
id|mdp_super_t
op_star
id|sb1
comma
id|mdp_super_t
op_star
id|sb2
)paren
(brace
r_int
id|ret
suffix:semicolon
id|mdp_super_t
op_star
id|tmp1
comma
op_star
id|tmp2
suffix:semicolon
id|tmp1
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|tmp1
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|tmp2
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|tmp2
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp1
op_logical_or
op_logical_neg
id|tmp2
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md.c: sb1 is not equal to sb2!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
op_star
id|tmp1
op_assign
op_star
id|sb1
suffix:semicolon
op_star
id|tmp2
op_assign
op_star
id|sb2
suffix:semicolon
multiline_comment|/*&n;&t; * nr_disks is not constant&n;&t; */
id|tmp1-&gt;nr_disks
op_assign
l_int|0
suffix:semicolon
id|tmp2-&gt;nr_disks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|tmp1
comma
id|tmp2
comma
id|MD_SB_GENERIC_CONSTANT_WORDS
op_star
l_int|4
)paren
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
r_else
id|ret
op_assign
l_int|1
suffix:semicolon
m_abort
suffix:colon
r_if
c_cond
(paren
id|tmp1
)paren
id|kfree
c_func
(paren
id|tmp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp2
)paren
id|kfree
c_func
(paren
id|tmp2
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|calc_sb_csum
r_static
r_int
r_int
id|calc_sb_csum
c_func
(paren
id|mdp_super_t
op_star
id|sb
)paren
(brace
r_int
r_int
id|disk_csum
comma
id|csum
suffix:semicolon
id|disk_csum
op_assign
id|sb-&gt;sb_csum
suffix:semicolon
id|sb-&gt;sb_csum
op_assign
l_int|0
suffix:semicolon
id|csum
op_assign
id|csum_partial
c_func
(paren
(paren
r_void
op_star
)paren
id|sb
comma
id|MD_SB_BYTES
comma
l_int|0
)paren
suffix:semicolon
id|sb-&gt;sb_csum
op_assign
id|disk_csum
suffix:semicolon
r_return
id|csum
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle superblock details.&n; * We want to be able to handle multiple superblock formats&n; * so we have a common interface to them all, and an array of&n; * different handlers.&n; * We rely on user-space to write the initial superblock, and support&n; * reading and updating of superblocks.&n; * Interface methods are:&n; *   int load_super(mdk_rdev_t *dev, mdk_rdev_t *refdev, int minor_version)&n; *      loads and validates a superblock on dev.&n; *      if refdev != NULL, compare superblocks on both devices&n; *    Return:&n; *      0 - dev has a superblock that is compatible with refdev&n; *      1 - dev has a superblock that is compatible and newer than refdev&n; *          so dev should be used as the refdev in future&n; *     -EINVAL superblock incompatible or invalid&n; *     -othererror e.g. -EIO&n; *&n; *   int validate_super(mddev_t *mddev, mdk_rdev_t *dev)&n; *      Verify that dev is acceptable into mddev.&n; *       The first time, mddev-&gt;raid_disks will be 0, and data from&n; *       dev should be merged in.  Subsequent calls check that dev&n; *       is new enough.  Return 0 or -EINVAL&n; *&n; *   void sync_super(mddev_t *mddev, mdk_rdev_t *dev)&n; *     Update the superblock for rdev with data in mddev&n; *     This does not write to disc.&n; *&n; */
DECL|struct|super_type
r_struct
id|super_type
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|owner
r_struct
id|module
op_star
id|owner
suffix:semicolon
DECL|member|load_super
r_int
(paren
op_star
id|load_super
)paren
(paren
id|mdk_rdev_t
op_star
id|rdev
comma
id|mdk_rdev_t
op_star
id|refdev
comma
r_int
id|minor_version
)paren
suffix:semicolon
DECL|member|validate_super
r_int
(paren
op_star
id|validate_super
)paren
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
suffix:semicolon
DECL|member|sync_super
r_void
(paren
op_star
id|sync_super
)paren
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * load_super for 0.90.0 &n; */
DECL|function|super_90_load
r_static
r_int
id|super_90_load
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
comma
id|mdk_rdev_t
op_star
id|refdev
comma
r_int
id|minor_version
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
comma
id|b2
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|mdp_super_t
op_star
id|sb
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|sector_t
id|sb_offset
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the position of the superblock,&n;&t; * it&squot;s at the end of the disk.&n;&t; *&n;&t; * It also happens to be a multiple of 4Kb.&n;&t; */
id|sb_offset
op_assign
id|calc_dev_sboffset
c_func
(paren
id|rdev-&gt;bdev
)paren
suffix:semicolon
id|rdev-&gt;sb_offset
op_assign
id|sb_offset
suffix:semicolon
id|ret
op_assign
id|read_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
suffix:semicolon
id|sb
op_assign
(paren
id|mdp_super_t
op_star
)paren
id|page_address
c_func
(paren
id|rdev-&gt;sb_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;md_magic
op_ne
id|MD_SB_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: invalid raid superblock magic on %s&bslash;n&quot;
comma
id|b
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sb-&gt;major_version
op_ne
l_int|0
op_logical_or
id|sb-&gt;minor_version
op_ne
l_int|90
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Bad version number %d.%d on %s&bslash;n&quot;
comma
id|sb-&gt;major_version
comma
id|sb-&gt;minor_version
comma
id|b
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sb-&gt;raid_disks
op_le
l_int|0
)paren
r_goto
m_abort
suffix:semicolon
r_if
c_cond
(paren
id|csum_fold
c_func
(paren
id|calc_sb_csum
c_func
(paren
id|sb
)paren
)paren
op_ne
id|csum_fold
c_func
(paren
id|sb-&gt;sb_csum
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: invalid superblock checksum on %s&bslash;n&quot;
comma
id|b
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|rdev-&gt;preferred_minor
op_assign
id|sb-&gt;md_minor
suffix:semicolon
id|rdev-&gt;data_offset
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;level
op_eq
id|MULTIPATH
)paren
id|rdev-&gt;desc_nr
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|rdev-&gt;desc_nr
op_assign
id|sb-&gt;this_disk.number
suffix:semicolon
r_if
c_cond
(paren
id|refdev
op_eq
l_int|0
)paren
id|ret
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|__u64
id|ev1
comma
id|ev2
suffix:semicolon
id|mdp_super_t
op_star
id|refsb
op_assign
(paren
id|mdp_super_t
op_star
)paren
id|page_address
c_func
(paren
id|refdev-&gt;sb_page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uuid_equal
c_func
(paren
id|refsb
comma
id|sb
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s has different UUID to %s&bslash;n&quot;
comma
id|b
comma
id|bdevname
c_func
(paren
id|refdev-&gt;bdev
comma
id|b2
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sb_equal
c_func
(paren
id|refsb
comma
id|sb
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s has same UUID&quot;
l_string|&quot; but different superblock to %s&bslash;n&quot;
comma
id|b
comma
id|bdevname
c_func
(paren
id|refdev-&gt;bdev
comma
id|b2
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|ev1
op_assign
id|md_event
c_func
(paren
id|sb
)paren
suffix:semicolon
id|ev2
op_assign
id|md_event
c_func
(paren
id|refsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ev1
OG
id|ev2
)paren
id|ret
op_assign
l_int|1
suffix:semicolon
r_else
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|rdev-&gt;size
op_assign
id|calc_dev_size
c_func
(paren
id|rdev
comma
id|sb-&gt;chunk_size
)paren
suffix:semicolon
m_abort
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * validate_super for 0.90.0&n; */
DECL|function|super_90_validate
r_static
r_int
id|super_90_validate
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
(paren
id|mdp_super_t
op_star
)paren
id|page_address
c_func
(paren
id|rdev-&gt;sb_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;raid_disks
op_eq
l_int|0
)paren
(brace
id|mddev-&gt;major_version
op_assign
l_int|0
suffix:semicolon
id|mddev-&gt;minor_version
op_assign
id|sb-&gt;minor_version
suffix:semicolon
id|mddev-&gt;patch_version
op_assign
id|sb-&gt;patch_version
suffix:semicolon
id|mddev-&gt;persistent
op_assign
op_logical_neg
id|sb-&gt;not_persistent
suffix:semicolon
id|mddev-&gt;chunk_size
op_assign
id|sb-&gt;chunk_size
suffix:semicolon
id|mddev-&gt;ctime
op_assign
id|sb-&gt;ctime
suffix:semicolon
id|mddev-&gt;utime
op_assign
id|sb-&gt;utime
suffix:semicolon
id|mddev-&gt;level
op_assign
id|sb-&gt;level
suffix:semicolon
id|mddev-&gt;layout
op_assign
id|sb-&gt;layout
suffix:semicolon
id|mddev-&gt;raid_disks
op_assign
id|sb-&gt;raid_disks
suffix:semicolon
id|mddev-&gt;size
op_assign
id|sb-&gt;size
suffix:semicolon
id|mddev-&gt;events
op_assign
id|md_event
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
)paren
id|mddev-&gt;recovery_cp
op_assign
id|MaxSector
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|sb-&gt;events_hi
op_eq
id|sb-&gt;cp_events_hi
op_logical_and
id|sb-&gt;events_lo
op_eq
id|sb-&gt;cp_events_lo
)paren
(brace
id|mddev-&gt;recovery_cp
op_assign
id|sb-&gt;recovery_cp
suffix:semicolon
)brace
r_else
id|mddev-&gt;recovery_cp
op_assign
l_int|0
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|mddev-&gt;uuid
op_plus
l_int|0
comma
op_amp
id|sb-&gt;set_uuid0
comma
l_int|4
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mddev-&gt;uuid
op_plus
l_int|4
comma
op_amp
id|sb-&gt;set_uuid1
comma
l_int|4
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mddev-&gt;uuid
op_plus
l_int|8
comma
op_amp
id|sb-&gt;set_uuid2
comma
l_int|4
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mddev-&gt;uuid
op_plus
l_int|12
comma
op_amp
id|sb-&gt;set_uuid3
comma
l_int|4
)paren
suffix:semicolon
id|mddev-&gt;max_disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
)brace
r_else
(brace
id|__u64
id|ev1
suffix:semicolon
id|ev1
op_assign
id|md_event
c_func
(paren
id|sb
)paren
suffix:semicolon
op_increment
id|ev1
suffix:semicolon
r_if
c_cond
(paren
id|ev1
OL
id|mddev-&gt;events
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;level
op_ne
id|LEVEL_MULTIPATH
)paren
(brace
id|rdev-&gt;raid_disk
op_assign
op_minus
l_int|1
suffix:semicolon
id|rdev-&gt;in_sync
op_assign
id|rdev-&gt;faulty
op_assign
l_int|0
suffix:semicolon
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|rdev-&gt;desc_nr
suffix:semicolon
r_if
c_cond
(paren
id|desc-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_DISK_FAULTY
)paren
)paren
id|rdev-&gt;faulty
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|desc-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_DISK_SYNC
)paren
op_logical_and
id|desc-&gt;raid_disk
OL
id|mddev-&gt;raid_disks
)paren
(brace
id|rdev-&gt;in_sync
op_assign
l_int|1
suffix:semicolon
id|rdev-&gt;raid_disk
op_assign
id|desc-&gt;raid_disk
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * sync_super for 0.90.0&n; */
DECL|function|super_90_sync
r_static
r_void
id|super_90_sync
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|mdp_super_t
op_star
id|sb
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev2
suffix:semicolon
r_int
id|next_spare
op_assign
id|mddev-&gt;raid_disks
suffix:semicolon
multiline_comment|/* make rdev-&gt;sb match mddev data..&n;&t; *&n;&t; * 1/ zero out disks&n;&t; * 2/ Add info for each disk, keeping track of highest desc_nr (next_spare);&n;&t; * 3/ any empty disks &lt; next_spare become removed&n;&t; *&n;&t; * disks[0] gets initialised to REMOVED because&n;&t; * we cannot be sure from other fields if it has&n;&t; * been initialised or not.&n;&t; */
r_int
id|i
suffix:semicolon
r_int
id|active
op_assign
l_int|0
comma
id|working
op_assign
l_int|0
comma
id|failed
op_assign
l_int|0
comma
id|spare
op_assign
l_int|0
comma
id|nr_disks
op_assign
l_int|0
suffix:semicolon
id|sb
op_assign
(paren
id|mdp_super_t
op_star
)paren
id|page_address
c_func
(paren
id|rdev-&gt;sb_page
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sb
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sb
)paren
)paren
suffix:semicolon
id|sb-&gt;md_magic
op_assign
id|MD_SB_MAGIC
suffix:semicolon
id|sb-&gt;major_version
op_assign
id|mddev-&gt;major_version
suffix:semicolon
id|sb-&gt;minor_version
op_assign
id|mddev-&gt;minor_version
suffix:semicolon
id|sb-&gt;patch_version
op_assign
id|mddev-&gt;patch_version
suffix:semicolon
id|sb-&gt;gvalid_words
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ignored */
id|memcpy
c_func
(paren
op_amp
id|sb-&gt;set_uuid0
comma
id|mddev-&gt;uuid
op_plus
l_int|0
comma
l_int|4
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sb-&gt;set_uuid1
comma
id|mddev-&gt;uuid
op_plus
l_int|4
comma
l_int|4
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sb-&gt;set_uuid2
comma
id|mddev-&gt;uuid
op_plus
l_int|8
comma
l_int|4
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sb-&gt;set_uuid3
comma
id|mddev-&gt;uuid
op_plus
l_int|12
comma
l_int|4
)paren
suffix:semicolon
id|sb-&gt;ctime
op_assign
id|mddev-&gt;ctime
suffix:semicolon
id|sb-&gt;level
op_assign
id|mddev-&gt;level
suffix:semicolon
id|sb-&gt;size
op_assign
id|mddev-&gt;size
suffix:semicolon
id|sb-&gt;raid_disks
op_assign
id|mddev-&gt;raid_disks
suffix:semicolon
id|sb-&gt;md_minor
op_assign
id|mddev-&gt;md_minor
suffix:semicolon
id|sb-&gt;not_persistent
op_assign
op_logical_neg
id|mddev-&gt;persistent
suffix:semicolon
id|sb-&gt;utime
op_assign
id|mddev-&gt;utime
suffix:semicolon
id|sb-&gt;state
op_assign
l_int|0
suffix:semicolon
id|sb-&gt;events_hi
op_assign
(paren
id|mddev-&gt;events
op_rshift
l_int|32
)paren
suffix:semicolon
id|sb-&gt;events_lo
op_assign
(paren
id|u32
)paren
id|mddev-&gt;events
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;in_sync
)paren
(brace
id|sb-&gt;recovery_cp
op_assign
id|mddev-&gt;recovery_cp
suffix:semicolon
id|sb-&gt;cp_events_hi
op_assign
(paren
id|mddev-&gt;events
op_rshift
l_int|32
)paren
suffix:semicolon
id|sb-&gt;cp_events_lo
op_assign
(paren
id|u32
)paren
id|mddev-&gt;events
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;recovery_cp
op_eq
id|MaxSector
)paren
id|sb-&gt;state
op_assign
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
suffix:semicolon
)brace
r_else
id|sb-&gt;recovery_cp
op_assign
l_int|0
suffix:semicolon
id|sb-&gt;layout
op_assign
id|mddev-&gt;layout
suffix:semicolon
id|sb-&gt;chunk_size
op_assign
id|mddev-&gt;chunk_size
suffix:semicolon
id|sb-&gt;disks
(braket
l_int|0
)braket
dot
id|state
op_assign
(paren
l_int|1
op_lshift
id|MD_DISK_REMOVED
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev2
comma
id|tmp
)paren
(brace
id|mdp_disk_t
op_star
id|d
suffix:semicolon
r_if
c_cond
(paren
id|rdev2-&gt;raid_disk
op_ge
l_int|0
op_logical_and
id|rdev2-&gt;in_sync
op_logical_and
op_logical_neg
id|rdev2-&gt;faulty
)paren
id|rdev2-&gt;desc_nr
op_assign
id|rdev2-&gt;raid_disk
suffix:semicolon
r_else
id|rdev2-&gt;desc_nr
op_assign
id|next_spare
op_increment
suffix:semicolon
id|d
op_assign
op_amp
id|sb-&gt;disks
(braket
id|rdev2-&gt;desc_nr
)braket
suffix:semicolon
id|nr_disks
op_increment
suffix:semicolon
id|d-&gt;number
op_assign
id|rdev2-&gt;desc_nr
suffix:semicolon
id|d-&gt;major
op_assign
id|MAJOR
c_func
(paren
id|rdev2-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
id|d-&gt;minor
op_assign
id|MINOR
c_func
(paren
id|rdev2-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev2-&gt;raid_disk
op_ge
l_int|0
op_logical_and
id|rdev-&gt;in_sync
op_logical_and
op_logical_neg
id|rdev2-&gt;faulty
)paren
id|d-&gt;raid_disk
op_assign
id|rdev2-&gt;raid_disk
suffix:semicolon
r_else
id|d-&gt;raid_disk
op_assign
id|rdev2-&gt;desc_nr
suffix:semicolon
multiline_comment|/* compatibility */
r_if
c_cond
(paren
id|rdev2-&gt;faulty
)paren
(brace
id|d-&gt;state
op_assign
(paren
l_int|1
op_lshift
id|MD_DISK_FAULTY
)paren
suffix:semicolon
id|failed
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rdev2-&gt;in_sync
)paren
(brace
id|d-&gt;state
op_assign
(paren
l_int|1
op_lshift
id|MD_DISK_ACTIVE
)paren
suffix:semicolon
id|d-&gt;state
op_or_assign
(paren
l_int|1
op_lshift
id|MD_DISK_SYNC
)paren
suffix:semicolon
id|active
op_increment
suffix:semicolon
id|working
op_increment
suffix:semicolon
)brace
r_else
(brace
id|d-&gt;state
op_assign
l_int|0
suffix:semicolon
id|spare
op_increment
suffix:semicolon
id|working
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* now set the &quot;removed&quot; and &quot;faulty&quot; bits on any missing devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mddev-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdp_disk_t
op_star
id|d
op_assign
op_amp
id|sb-&gt;disks
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;state
op_eq
l_int|0
op_logical_and
id|d-&gt;number
op_eq
l_int|0
)paren
(brace
id|d-&gt;number
op_assign
id|i
suffix:semicolon
id|d-&gt;raid_disk
op_assign
id|i
suffix:semicolon
id|d-&gt;state
op_assign
(paren
l_int|1
op_lshift
id|MD_DISK_REMOVED
)paren
suffix:semicolon
id|d-&gt;state
op_or_assign
(paren
l_int|1
op_lshift
id|MD_DISK_FAULTY
)paren
suffix:semicolon
id|failed
op_increment
suffix:semicolon
)brace
)brace
id|sb-&gt;nr_disks
op_assign
id|nr_disks
suffix:semicolon
id|sb-&gt;active_disks
op_assign
id|active
suffix:semicolon
id|sb-&gt;working_disks
op_assign
id|working
suffix:semicolon
id|sb-&gt;failed_disks
op_assign
id|failed
suffix:semicolon
id|sb-&gt;spare_disks
op_assign
id|spare
suffix:semicolon
id|sb-&gt;this_disk
op_assign
id|sb-&gt;disks
(braket
id|rdev-&gt;desc_nr
)braket
suffix:semicolon
id|sb-&gt;sb_csum
op_assign
id|calc_sb_csum
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * version 1 superblock&n; */
DECL|function|calc_sb_1_csum
r_static
r_int
r_int
id|calc_sb_1_csum
c_func
(paren
r_struct
id|mdp_superblock_1
op_star
id|sb
)paren
(brace
r_int
r_int
id|disk_csum
comma
id|csum
suffix:semicolon
r_int
r_int
r_int
id|newcsum
suffix:semicolon
r_int
id|size
op_assign
l_int|256
op_plus
id|le32_to_cpu
c_func
(paren
id|sb-&gt;max_dev
)paren
op_star
l_int|2
suffix:semicolon
r_int
r_int
op_star
id|isuper
op_assign
(paren
r_int
r_int
op_star
)paren
id|sb
suffix:semicolon
r_int
id|i
suffix:semicolon
id|disk_csum
op_assign
id|sb-&gt;sb_csum
suffix:semicolon
id|sb-&gt;sb_csum
op_assign
l_int|0
suffix:semicolon
id|newcsum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|size
op_ge
l_int|4
suffix:semicolon
id|size
op_sub_assign
l_int|4
)paren
id|newcsum
op_add_assign
id|le32_to_cpu
c_func
(paren
op_star
id|isuper
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|2
)paren
id|newcsum
op_add_assign
id|le16_to_cpu
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|isuper
)paren
suffix:semicolon
id|csum
op_assign
(paren
id|newcsum
op_amp
l_int|0xffffffff
)paren
op_plus
(paren
id|newcsum
op_rshift
l_int|32
)paren
suffix:semicolon
id|sb-&gt;sb_csum
op_assign
id|disk_csum
suffix:semicolon
r_return
id|cpu_to_le32
c_func
(paren
id|csum
)paren
suffix:semicolon
)brace
DECL|function|super_1_load
r_static
r_int
id|super_1_load
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
comma
id|mdk_rdev_t
op_star
id|refdev
comma
r_int
id|minor_version
)paren
(brace
r_struct
id|mdp_superblock_1
op_star
id|sb
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|sector_t
id|sb_offset
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
comma
id|b2
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the position of the superblock.&n;&t; * It is always aligned to a 4K boundary and&n;&t; * depeding on minor_version, it can be:&n;&t; * 0: At least 8K, but less than 12K, from end of device&n;&t; * 1: At start of device&n;&t; * 2: 4K from start of device.&n;&t; */
r_switch
c_cond
(paren
id|minor_version
)paren
(brace
r_case
l_int|0
suffix:colon
id|sb_offset
op_assign
id|rdev-&gt;bdev-&gt;bd_inode-&gt;i_size
op_rshift
l_int|9
suffix:semicolon
id|sb_offset
op_sub_assign
l_int|8
op_star
l_int|2
suffix:semicolon
id|sb_offset
op_and_assign
op_complement
(paren
l_int|4
op_star
l_int|2
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* convert from sectors to K */
id|sb_offset
op_div_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|sb_offset
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|sb_offset
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev-&gt;sb_offset
op_assign
id|sb_offset
suffix:semicolon
id|ret
op_assign
id|read_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|sb
op_assign
(paren
r_struct
id|mdp_superblock_1
op_star
)paren
id|page_address
c_func
(paren
id|rdev-&gt;sb_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;magic
op_ne
id|cpu_to_le32
c_func
(paren
id|MD_SB_MAGIC
)paren
op_logical_or
id|sb-&gt;major_version
op_ne
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
op_logical_or
id|le32_to_cpu
c_func
(paren
id|sb-&gt;max_dev
)paren
OG
(paren
l_int|4096
op_minus
l_int|256
)paren
op_div
l_int|2
op_logical_or
id|le64_to_cpu
c_func
(paren
id|sb-&gt;super_offset
)paren
op_ne
(paren
id|rdev-&gt;sb_offset
op_lshift
l_int|1
)paren
op_logical_or
id|sb-&gt;feature_map
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|calc_sb_1_csum
c_func
(paren
id|sb
)paren
op_ne
id|sb-&gt;sb_csum
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: invalid superblock checksum on %s&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le64_to_cpu
c_func
(paren
id|sb-&gt;data_size
)paren
OL
l_int|10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: data_size too small on %s&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev-&gt;preferred_minor
op_assign
l_int|0xffff
suffix:semicolon
id|rdev-&gt;data_offset
op_assign
id|le64_to_cpu
c_func
(paren
id|sb-&gt;data_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|refdev
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_else
(brace
id|__u64
id|ev1
comma
id|ev2
suffix:semicolon
r_struct
id|mdp_superblock_1
op_star
id|refsb
op_assign
(paren
r_struct
id|mdp_superblock_1
op_star
)paren
id|page_address
c_func
(paren
id|refdev-&gt;sb_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|sb-&gt;set_uuid
comma
id|refsb-&gt;set_uuid
comma
l_int|16
)paren
op_ne
l_int|0
op_logical_or
id|sb-&gt;level
op_ne
id|refsb-&gt;level
op_logical_or
id|sb-&gt;layout
op_ne
id|refsb-&gt;layout
op_logical_or
id|sb-&gt;chunksize
op_ne
id|refsb-&gt;chunksize
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s has strangely different&quot;
l_string|&quot; superblock to %s&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
id|bdevname
c_func
(paren
id|refdev-&gt;bdev
comma
id|b2
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ev1
op_assign
id|le64_to_cpu
c_func
(paren
id|sb-&gt;events
)paren
suffix:semicolon
id|ev2
op_assign
id|le64_to_cpu
c_func
(paren
id|refsb-&gt;events
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ev1
OG
id|ev2
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|minor_version
)paren
id|rdev-&gt;size
op_assign
(paren
(paren
id|rdev-&gt;bdev-&gt;bd_inode-&gt;i_size
op_rshift
l_int|9
)paren
op_minus
id|le64_to_cpu
c_func
(paren
id|sb-&gt;data_offset
)paren
)paren
op_div
l_int|2
suffix:semicolon
r_else
id|rdev-&gt;size
op_assign
id|rdev-&gt;sb_offset
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;size
OL
id|le64_to_cpu
c_func
(paren
id|sb-&gt;data_size
)paren
op_div
l_int|2
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|rdev-&gt;size
op_assign
id|le64_to_cpu
c_func
(paren
id|sb-&gt;data_size
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|sb-&gt;chunksize
)paren
)paren
id|rdev-&gt;size
op_and_assign
op_complement
(paren
(paren
id|sector_t
)paren
id|le32_to_cpu
c_func
(paren
id|sb-&gt;chunksize
)paren
op_div
l_int|2
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|super_1_validate
r_static
r_int
id|super_1_validate
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_struct
id|mdp_superblock_1
op_star
id|sb
op_assign
(paren
r_struct
id|mdp_superblock_1
op_star
)paren
id|page_address
c_func
(paren
id|rdev-&gt;sb_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;raid_disks
op_eq
l_int|0
)paren
(brace
id|mddev-&gt;major_version
op_assign
l_int|1
suffix:semicolon
id|mddev-&gt;patch_version
op_assign
l_int|0
suffix:semicolon
id|mddev-&gt;persistent
op_assign
l_int|1
suffix:semicolon
id|mddev-&gt;chunk_size
op_assign
id|le32_to_cpu
c_func
(paren
id|sb-&gt;chunksize
)paren
op_lshift
l_int|9
suffix:semicolon
id|mddev-&gt;ctime
op_assign
id|le64_to_cpu
c_func
(paren
id|sb-&gt;ctime
)paren
op_amp
(paren
(paren
l_int|1ULL
op_lshift
l_int|32
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|mddev-&gt;utime
op_assign
id|le64_to_cpu
c_func
(paren
id|sb-&gt;utime
)paren
op_amp
(paren
(paren
l_int|1ULL
op_lshift
l_int|32
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|mddev-&gt;level
op_assign
id|le32_to_cpu
c_func
(paren
id|sb-&gt;level
)paren
suffix:semicolon
id|mddev-&gt;layout
op_assign
id|le32_to_cpu
c_func
(paren
id|sb-&gt;layout
)paren
suffix:semicolon
id|mddev-&gt;raid_disks
op_assign
id|le32_to_cpu
c_func
(paren
id|sb-&gt;raid_disks
)paren
suffix:semicolon
id|mddev-&gt;size
op_assign
id|le64_to_cpu
c_func
(paren
id|sb-&gt;size
)paren
op_div
l_int|2
suffix:semicolon
id|mddev-&gt;events
op_assign
id|le64_to_cpu
c_func
(paren
id|sb-&gt;events
)paren
suffix:semicolon
id|mddev-&gt;recovery_cp
op_assign
id|le64_to_cpu
c_func
(paren
id|sb-&gt;resync_offset
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mddev-&gt;uuid
comma
id|sb-&gt;set_uuid
comma
l_int|16
)paren
suffix:semicolon
id|mddev-&gt;max_disks
op_assign
(paren
l_int|4096
op_minus
l_int|256
)paren
op_div
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|__u64
id|ev1
suffix:semicolon
id|ev1
op_assign
id|le64_to_cpu
c_func
(paren
id|sb-&gt;events
)paren
suffix:semicolon
op_increment
id|ev1
suffix:semicolon
r_if
c_cond
(paren
id|ev1
OL
id|mddev-&gt;events
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;level
op_ne
id|LEVEL_MULTIPATH
)paren
(brace
r_int
id|role
suffix:semicolon
id|rdev-&gt;desc_nr
op_assign
id|le32_to_cpu
c_func
(paren
id|sb-&gt;dev_number
)paren
suffix:semicolon
id|role
op_assign
id|le16_to_cpu
c_func
(paren
id|sb-&gt;dev_roles
(braket
id|rdev-&gt;desc_nr
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|role
)paren
(brace
r_case
l_int|0xffff
suffix:colon
multiline_comment|/* spare */
id|rdev-&gt;in_sync
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;faulty
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;raid_disk
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xfffe
suffix:colon
multiline_comment|/* faulty */
id|rdev-&gt;in_sync
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;faulty
op_assign
l_int|1
suffix:semicolon
id|rdev-&gt;raid_disk
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|rdev-&gt;in_sync
op_assign
l_int|1
suffix:semicolon
id|rdev-&gt;faulty
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;raid_disk
op_assign
id|role
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|super_1_sync
r_static
r_void
id|super_1_sync
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_struct
id|mdp_superblock_1
op_star
id|sb
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev2
suffix:semicolon
r_int
id|max_dev
comma
id|i
suffix:semicolon
multiline_comment|/* make rdev-&gt;sb match mddev and rdev data. */
id|sb
op_assign
(paren
r_struct
id|mdp_superblock_1
op_star
)paren
id|page_address
c_func
(paren
id|rdev-&gt;sb_page
)paren
suffix:semicolon
id|sb-&gt;feature_map
op_assign
l_int|0
suffix:semicolon
id|sb-&gt;pad0
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|sb-&gt;pad1
comma
l_int|0
comma
r_sizeof
(paren
id|sb-&gt;pad1
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sb-&gt;pad2
comma
l_int|0
comma
r_sizeof
(paren
id|sb-&gt;pad2
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sb-&gt;pad3
comma
l_int|0
comma
r_sizeof
(paren
id|sb-&gt;pad3
)paren
)paren
suffix:semicolon
id|sb-&gt;utime
op_assign
id|cpu_to_le64
c_func
(paren
(paren
id|__u64
)paren
id|mddev-&gt;utime
)paren
suffix:semicolon
id|sb-&gt;events
op_assign
id|cpu_to_le64
c_func
(paren
id|mddev-&gt;events
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;in_sync
)paren
id|sb-&gt;resync_offset
op_assign
id|cpu_to_le64
c_func
(paren
id|mddev-&gt;recovery_cp
)paren
suffix:semicolon
r_else
id|sb-&gt;resync_offset
op_assign
id|cpu_to_le64
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|max_dev
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev2
comma
id|tmp
)paren
r_if
c_cond
(paren
id|rdev2-&gt;desc_nr
op_plus
l_int|1
OG
id|max_dev
)paren
id|max_dev
op_assign
id|rdev2-&gt;desc_nr
op_plus
l_int|1
suffix:semicolon
id|sb-&gt;max_dev
op_assign
id|cpu_to_le32
c_func
(paren
id|max_dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_dev
suffix:semicolon
id|i
op_increment
)paren
id|sb-&gt;dev_roles
(braket
id|max_dev
)braket
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0xfffe
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev2
comma
id|tmp
)paren
(brace
id|i
op_assign
id|rdev2-&gt;desc_nr
suffix:semicolon
r_if
c_cond
(paren
id|rdev2-&gt;faulty
)paren
id|sb-&gt;dev_roles
(braket
id|i
)braket
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0xfffe
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rdev2-&gt;in_sync
)paren
id|sb-&gt;dev_roles
(braket
id|i
)braket
op_assign
id|cpu_to_le16
c_func
(paren
id|rdev2-&gt;raid_disk
)paren
suffix:semicolon
r_else
id|sb-&gt;dev_roles
(braket
id|i
)braket
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0xffff
)paren
suffix:semicolon
)brace
id|sb-&gt;recovery_offset
op_assign
id|cpu_to_le64
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* not supported yet */
id|sb-&gt;sb_csum
op_assign
id|calc_sb_1_csum
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
DECL|variable|super_types
r_struct
id|super_type
id|super_types
(braket
)braket
op_assign
(brace
(braket
l_int|0
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;0.90.0&quot;
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|load_super
op_assign
id|super_90_load
comma
dot
id|validate_super
op_assign
id|super_90_validate
comma
dot
id|sync_super
op_assign
id|super_90_sync
comma
)brace
comma
(braket
l_int|1
)braket
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;md-1&quot;
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|load_super
op_assign
id|super_1_load
comma
dot
id|validate_super
op_assign
id|super_1_validate
comma
dot
id|sync_super
op_assign
id|super_1_sync
comma
)brace
comma
)brace
suffix:semicolon
DECL|function|match_dev_unit
r_static
id|mdk_rdev_t
op_star
id|match_dev_unit
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|dev
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
r_if
c_cond
(paren
id|rdev-&gt;bdev-&gt;bd_contains
op_eq
id|dev-&gt;bdev-&gt;bd_contains
)paren
r_return
id|rdev
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|match_mddev_units
r_static
r_int
id|match_mddev_units
c_func
(paren
id|mddev_t
op_star
id|mddev1
comma
id|mddev_t
op_star
id|mddev2
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev1
comma
id|rdev
comma
id|tmp
)paren
r_if
c_cond
(paren
id|match_dev_unit
c_func
(paren
id|mddev2
comma
id|rdev
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|LIST_HEAD
c_func
(paren
id|pending_raid_disks
)paren
suffix:semicolon
DECL|function|bind_rdev_to_array
r_static
r_int
id|bind_rdev_to_array
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
comma
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|same_pdev
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
comma
id|b2
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|same_pdev
op_assign
id|match_dev_unit
c_func
(paren
id|mddev
comma
id|rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|same_pdev
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: WARNING: %s appears to be on the same physical&quot;
l_string|&quot; disk as %s. True&bslash;n     protection against single-disk&quot;
l_string|&quot; failure might be compromised.&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
id|bdevname
c_func
(paren
id|same_pdev-&gt;bdev
comma
id|b2
)paren
)paren
suffix:semicolon
multiline_comment|/* Verify rdev-&gt;desc_nr is unique.&n;&t; * If it is -1, assign a free number, else&n;&t; * check number is not in use&n;&t; */
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
OL
l_int|0
)paren
(brace
r_int
id|choice
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
id|choice
op_assign
id|mddev-&gt;raid_disks
suffix:semicolon
r_while
c_loop
(paren
id|find_rdev_nr
c_func
(paren
id|mddev
comma
id|choice
)paren
)paren
id|choice
op_increment
suffix:semicolon
id|rdev-&gt;desc_nr
op_assign
id|choice
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|find_rdev_nr
c_func
(paren
id|mddev
comma
id|rdev-&gt;desc_nr
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|rdev-&gt;same_set
comma
op_amp
id|mddev-&gt;disks
)paren
suffix:semicolon
id|rdev-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: bind&lt;%s&gt;&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unbind_rdev_from_array
r_static
r_void
id|unbind_rdev_from_array
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|list_del_init
c_func
(paren
op_amp
id|rdev-&gt;same_set
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: unbind&lt;%s&gt;&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
id|rdev-&gt;mddev
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * prevent the device from being mounted, repartitioned or&n; * otherwise reused by a RAID array (or any other kernel&n; * subsystem), by bd_claiming the device.&n; */
DECL|function|lock_rdev
r_static
r_int
id|lock_rdev
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
comma
id|dev_t
id|dev
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|bdev
op_assign
id|open_by_devnum
c_func
(paren
id|dev
comma
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|bdev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: could not open %s.&bslash;n&quot;
comma
id|__bdevname
c_func
(paren
id|dev
comma
id|b
)paren
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
id|err
op_assign
id|bd_claim
c_func
(paren
id|bdev
comma
id|rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: could not bd_claim %s.&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|bdev
comma
id|b
)paren
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|rdev-&gt;bdev
op_assign
id|bdev
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|unlock_rdev
r_static
r_void
id|unlock_rdev
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
op_assign
id|rdev-&gt;bdev
suffix:semicolon
id|rdev-&gt;bdev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdev
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|bd_release
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
r_void
id|md_autodetect_dev
c_func
(paren
id|dev_t
id|dev
)paren
suffix:semicolon
DECL|function|export_rdev
r_static
r_void
id|export_rdev
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: export_rdev(%s)&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;mddev
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|free_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|rdev-&gt;same_set
)paren
suffix:semicolon
macro_line|#ifndef MODULE
id|md_autodetect_dev
c_func
(paren
id|rdev-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
macro_line|#endif
id|unlock_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
DECL|function|kick_rdev_from_array
r_static
r_void
id|kick_rdev_from_array
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|unbind_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
DECL|function|export_array
r_static
r_void
id|export_array
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|mddev-&gt;raid_disks
op_assign
l_int|0
suffix:semicolon
id|mddev-&gt;major_version
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|print_desc
r_static
r_void
id|print_desc
c_func
(paren
id|mdp_disk_t
op_star
id|desc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; DISK&lt;N:%d,(%d,%d),R:%d,S:%d&gt;&bslash;n&quot;
comma
id|desc-&gt;number
comma
id|desc-&gt;major
comma
id|desc-&gt;minor
comma
id|desc-&gt;raid_disk
comma
id|desc-&gt;state
)paren
suffix:semicolon
)brace
DECL|function|print_sb
r_static
r_void
id|print_sb
c_func
(paren
id|mdp_super_t
op_star
id|sb
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md:  SB: (V:%d.%d.%d) ID:&lt;%08x.%08x.%08x.%08x&gt; CT:%08x&bslash;n&quot;
comma
id|sb-&gt;major_version
comma
id|sb-&gt;minor_version
comma
id|sb-&gt;patch_version
comma
id|sb-&gt;set_uuid0
comma
id|sb-&gt;set_uuid1
comma
id|sb-&gt;set_uuid2
comma
id|sb-&gt;set_uuid3
comma
id|sb-&gt;ctime
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md:     L%d S%08d ND:%d RD:%d md%d LO:%d CS:%d&bslash;n&quot;
comma
id|sb-&gt;level
comma
id|sb-&gt;size
comma
id|sb-&gt;nr_disks
comma
id|sb-&gt;raid_disks
comma
id|sb-&gt;md_minor
comma
id|sb-&gt;layout
comma
id|sb-&gt;chunk_size
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md:     UT:%08x ST:%d AD:%d WD:%d&quot;
l_string|&quot; FD:%d SD:%d CSUM:%08x E:%08lx&bslash;n&quot;
comma
id|sb-&gt;utime
comma
id|sb-&gt;state
comma
id|sb-&gt;active_disks
comma
id|sb-&gt;working_disks
comma
id|sb-&gt;failed_disks
comma
id|sb-&gt;spare_disks
comma
id|sb-&gt;sb_csum
comma
(paren
r_int
r_int
)paren
id|sb-&gt;events_lo
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|desc-&gt;number
op_logical_or
id|desc-&gt;major
op_logical_or
id|desc-&gt;minor
op_logical_or
id|desc-&gt;raid_disk
op_logical_or
(paren
id|desc-&gt;state
op_logical_and
(paren
id|desc-&gt;state
op_ne
l_int|4
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;     D %2d: &quot;
comma
id|i
)paren
suffix:semicolon
id|print_desc
c_func
(paren
id|desc
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md:     THIS: &quot;
)paren
suffix:semicolon
id|print_desc
c_func
(paren
op_amp
id|sb-&gt;this_disk
)paren
suffix:semicolon
)brace
DECL|function|print_rdev
r_static
r_void
id|print_rdev
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: rdev %s, SZ:%08llu F:%d S:%d DN:%u&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|rdev-&gt;size
comma
id|rdev-&gt;faulty
comma
id|rdev-&gt;in_sync
comma
id|rdev-&gt;desc_nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;sb_loaded
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: rdev superblock:&bslash;n&quot;
)paren
suffix:semicolon
id|print_sb
c_func
(paren
(paren
id|mdp_super_t
op_star
)paren
id|page_address
c_func
(paren
id|rdev-&gt;sb_page
)paren
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: no rdev superblock!&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|md_print_devices
r_void
id|md_print_devices
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
comma
op_star
id|tmp2
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md:&t;**********************************&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md:&t;* &lt;COMPLETE RAID STATE PRINTOUT&gt; *&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md:&t;**********************************&bslash;n&quot;
)paren
suffix:semicolon
id|ITERATE_MDDEV
c_func
(paren
id|mddev
comma
id|tmp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: &quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp2
)paren
id|printk
c_func
(paren
l_string|&quot;&lt;%s&gt;&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp2
)paren
id|print_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;md:&t;**********************************&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|write_disk_sb
r_static
r_int
id|write_disk_sb
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb_loaded
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;(write) %s&squot;s sb offset: %llu&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|rdev-&gt;sb_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sync_page_io
c_func
(paren
id|rdev-&gt;bdev
comma
id|rdev-&gt;sb_offset
op_lshift
l_int|1
comma
id|MD_SB_BYTES
comma
id|rdev-&gt;sb_page
comma
id|WRITE
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md: write_disk_sb failed for device %s&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|sync_sbs
r_static
r_void
id|sync_sbs
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|super_types
(braket
id|mddev-&gt;major_version
)braket
dot
id|sync_super
c_func
(paren
id|mddev
comma
id|rdev
)paren
suffix:semicolon
id|rdev-&gt;sb_loaded
op_assign
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|md_update_sb
r_static
r_void
id|md_update_sb
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|err
comma
id|count
op_assign
l_int|100
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|0
suffix:semicolon
id|repeat
suffix:colon
id|mddev-&gt;utime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
id|mddev-&gt;events
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;events
)paren
(brace
multiline_comment|/*&n;&t;&t; * oops, this 64-bit counter should never wrap.&n;&t;&t; * Either we are in around ~1 trillion A.C., assuming&n;&t;&t; * 1 reboot per second, or we have a bug:&n;&t;&t; */
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|mddev-&gt;events
op_decrement
suffix:semicolon
)brace
id|sync_sbs
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * do not write anything to disk if using&n;&t; * nonpersistent superblocks&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;persistent
)paren
r_return
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: updating %s RAID superblock on device (in sync %d)&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
comma
id|mddev-&gt;in_sync
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
id|dprintk
c_func
(paren
l_string|&quot;(skipping faulty &quot;
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;faulty
)paren
(brace
id|err
op_add_assign
id|write_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
r_else
id|dprintk
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|mddev-&gt;level
op_eq
id|LEVEL_MULTIPATH
)paren
multiline_comment|/* only need to write one superblock... */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: errors occurred during superblock&quot;
l_string|&quot; update, repeating&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
"&bslash;"
l_string|&quot;md: excessive errors occurred during superblock update, exiting&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Import a device. If &squot;super_format&squot; &gt;= 0, then sanity check the superblock&n; *&n; * mark the device faulty if:&n; *&n; *   - the device is nonexistent (zero size)&n; *   - the device has no valid superblock&n; *&n; * a faulty rdev _never_ has rdev-&gt;sb set.&n; */
DECL|function|md_import_device
r_static
id|mdk_rdev_t
op_star
id|md_import_device
c_func
(paren
id|dev_t
id|newdev
comma
r_int
id|super_format
comma
r_int
id|super_minor
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_int
id|err
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|sector_t
id|size
suffix:semicolon
id|rdev
op_assign
(paren
id|mdk_rdev_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rdev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: could not alloc mem for new device!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|rdev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|rdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|alloc_disk_sb
c_func
(paren
id|rdev
)paren
)paren
)paren
r_goto
id|abort_free
suffix:semicolon
id|err
op_assign
id|lock_rdev
c_func
(paren
id|rdev
comma
id|newdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|abort_free
suffix:semicolon
id|rdev-&gt;desc_nr
op_assign
op_minus
l_int|1
suffix:semicolon
id|rdev-&gt;faulty
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;in_sync
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;data_offset
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|rdev-&gt;nr_pending
comma
l_int|0
)paren
suffix:semicolon
id|size
op_assign
id|rdev-&gt;bdev-&gt;bd_inode-&gt;i_size
op_rshift
id|BLOCK_SIZE_BITS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s has zero or unknown size, marking faulty!&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_free
suffix:semicolon
)brace
r_if
c_cond
(paren
id|super_format
op_ge
l_int|0
)paren
(brace
id|err
op_assign
id|super_types
(braket
id|super_format
)braket
dot
id|load_super
c_func
(paren
id|rdev
comma
l_int|NULL
comma
id|super_minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EINVAL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s has invalid sb, not importing!&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
r_goto
id|abort_free
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: could not read %s&squot;s sb, not importing!&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
r_goto
id|abort_free
suffix:semicolon
)brace
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rdev-&gt;same_set
)paren
suffix:semicolon
r_return
id|rdev
suffix:semicolon
id|abort_free
suffix:colon
r_if
c_cond
(paren
id|rdev-&gt;sb_page
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;bdev
)paren
id|unlock_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|free_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check a full RAID array for plausibility&n; */
DECL|function|analyze_sbs
r_static
r_int
id|analyze_sbs
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
comma
op_star
id|freshest
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|freshest
op_assign
l_int|NULL
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
r_switch
c_cond
(paren
id|super_types
(braket
id|mddev-&gt;major_version
)braket
dot
id|load_super
c_func
(paren
id|rdev
comma
id|freshest
comma
id|mddev-&gt;minor_version
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
id|freshest
op_assign
id|rdev
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
"&bslash;"
l_string|&quot;md: fatal superblock inconsistency in %s&quot;
l_string|&quot; -- removing from array&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
id|super_types
(braket
id|mddev-&gt;major_version
)braket
dot
id|validate_super
c_func
(paren
id|mddev
comma
id|freshest
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev
op_ne
id|freshest
)paren
r_if
c_cond
(paren
id|super_types
(braket
id|mddev-&gt;major_version
)braket
dot
id|validate_super
c_func
(paren
id|mddev
comma
id|rdev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: kicking non-fresh %s&quot;
l_string|&quot; from array!&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;level
op_eq
id|LEVEL_MULTIPATH
)paren
(brace
id|rdev-&gt;desc_nr
op_assign
id|i
op_increment
suffix:semicolon
id|rdev-&gt;raid_disk
op_assign
id|rdev-&gt;desc_nr
suffix:semicolon
id|rdev-&gt;in_sync
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|mddev-&gt;recovery_cp
op_ne
id|MaxSector
)paren
op_logical_and
(paren
(paren
id|mddev-&gt;level
op_eq
l_int|1
)paren
op_logical_or
(paren
(paren
id|mddev-&gt;level
op_ge
l_int|4
)paren
op_logical_and
(paren
id|mddev-&gt;level
op_le
l_int|6
)paren
)paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: %s: raid array is not clean&quot;
l_string|&quot; -- starting background reconstruction&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|mdp_major
r_int
id|mdp_major
op_assign
l_int|0
suffix:semicolon
DECL|function|md_probe
r_static
r_struct
id|kobject
op_star
id|md_probe
c_func
(paren
id|dev_t
id|dev
comma
r_int
op_star
id|part
comma
r_void
op_star
id|data
)paren
(brace
r_static
id|DECLARE_MUTEX
c_func
(paren
id|disks_sem
)paren
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
id|mddev_find
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
r_int
id|partitioned
op_assign
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
op_ne
id|MD_MAJOR
)paren
suffix:semicolon
r_int
id|shift
op_assign
id|partitioned
ques
c_cond
id|MdpMinorShift
suffix:colon
l_int|0
suffix:semicolon
r_int
id|unit
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
op_rshift
id|shift
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
r_return
l_int|NULL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|disks_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;gendisk
)paren
(brace
id|up
c_func
(paren
op_amp
id|disks_sem
)paren
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|disk
op_assign
id|alloc_disk
c_func
(paren
l_int|1
op_lshift
id|shift
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk
)paren
(brace
id|up
c_func
(paren
op_amp
id|disks_sem
)paren
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|disk-&gt;major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|disk-&gt;first_minor
op_assign
id|unit
op_lshift
id|shift
suffix:semicolon
r_if
c_cond
(paren
id|partitioned
)paren
(brace
id|sprintf
c_func
(paren
id|disk-&gt;disk_name
comma
l_string|&quot;md_d%d&quot;
comma
id|unit
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|disk-&gt;devfs_name
comma
l_string|&quot;md/d%d&quot;
comma
id|unit
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|disk-&gt;disk_name
comma
l_string|&quot;md%d&quot;
comma
id|unit
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|disk-&gt;devfs_name
comma
l_string|&quot;md/%d&quot;
comma
id|unit
)paren
suffix:semicolon
)brace
id|disk-&gt;fops
op_assign
op_amp
id|md_fops
suffix:semicolon
id|disk-&gt;private_data
op_assign
id|mddev
suffix:semicolon
id|disk-&gt;queue
op_assign
id|mddev-&gt;queue
suffix:semicolon
id|add_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
id|mddev-&gt;gendisk
op_assign
id|disk
suffix:semicolon
id|up
c_func
(paren
op_amp
id|disks_sem
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_void
id|md_wakeup_thread
c_func
(paren
id|mdk_thread_t
op_star
id|thread
)paren
suffix:semicolon
DECL|function|md_safemode_timeout
r_static
r_void
id|md_safemode_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
(paren
id|mddev_t
op_star
)paren
id|data
suffix:semicolon
id|mddev-&gt;safemode
op_assign
l_int|1
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
)brace
DECL|function|do_md_run
r_static
r_int
id|do_md_run
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|pnum
comma
id|err
suffix:semicolon
r_int
id|chunk_size
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t; * Analyze all RAID superblock(s)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;raid_disks
op_logical_and
id|analyze_sbs
c_func
(paren
id|mddev
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|chunk_size
op_assign
id|mddev-&gt;chunk_size
suffix:semicolon
id|pnum
op_assign
id|level_to_pers
c_func
(paren
id|mddev-&gt;level
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pnum
op_ne
id|MULTIPATH
)paren
op_logical_and
(paren
id|pnum
op_ne
id|RAID1
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|chunk_size
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * &squot;default chunksize&squot; in the old md code used to&n;&t;&t;&t; * be PAGE_SIZE, baaad.&n;&t;&t;&t; * we abort here to be on the safe side. We don&squot;t&n;&t;&t;&t; * want to continue the bad practice.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;no chunksize specified, see &squot;man raidtab&squot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chunk_size
OG
id|MAX_CHUNK_SIZE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;too big chunk_size: %d &gt; %d&bslash;n&quot;
comma
id|chunk_size
comma
id|MAX_CHUNK_SIZE
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * chunk-size has to be a power of 2 and multiples of PAGE_SIZE&n;&t;&t; */
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|ffz
c_func
(paren
op_complement
id|chunk_size
)paren
)paren
op_ne
id|chunk_size
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chunk_size
OL
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;too small chunk_size: %d &lt; %ld&bslash;n&quot;
comma
id|chunk_size
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* devices must have minimum size of one chunk */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;size
OL
id|chunk_size
op_div
l_int|1024
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: Dev %s smaller than chunk_size:&quot;
l_string|&quot; %lluk &lt; %dk&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|rdev-&gt;size
comma
id|chunk_size
op_div
l_int|1024
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|pnum
op_ge
id|MAX_PERSONALITY
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KMOD
r_if
c_cond
(paren
op_logical_neg
id|pers
(braket
id|pnum
)braket
)paren
(brace
id|request_module
c_func
(paren
l_string|&quot;md-personality-%d&quot;
comma
id|pnum
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Drop all container device buffers, from now on&n;&t; * the only valid external interface is through the md&n;&t; * device.&n;&t; * Also find largest hardsector size&n;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
r_continue
suffix:semicolon
id|sync_blockdev
c_func
(paren
id|rdev-&gt;bdev
)paren
suffix:semicolon
id|invalidate_bdev
c_func
(paren
id|rdev-&gt;bdev
comma
l_int|0
)paren
suffix:semicolon
)brace
id|md_probe
c_func
(paren
id|mddev-&gt;unit
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|disk
op_assign
id|mddev-&gt;gendisk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pers_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pers
(braket
id|pnum
)braket
op_logical_or
op_logical_neg
id|try_module_get
c_func
(paren
id|pers
(braket
id|pnum
)braket
op_member_access_from_pointer
id|owner
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|pers_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: personality %d is not loaded!&bslash;n&quot;
comma
id|pnum
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mddev-&gt;pers
op_assign
id|pers
(braket
id|pnum
)braket
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pers_lock
)paren
suffix:semicolon
id|mddev-&gt;resync_max_sectors
op_assign
id|mddev-&gt;size
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/* may be over-ridden by personality */
id|err
op_assign
id|mddev-&gt;pers
op_member_access_from_pointer
id|run
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: pers-&gt;run() failed ...&bslash;n&quot;
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|mddev-&gt;pers-&gt;owner
)paren
suffix:semicolon
id|mddev-&gt;pers
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|mddev-&gt;writes_pending
comma
l_int|0
)paren
suffix:semicolon
id|mddev-&gt;safemode
op_assign
l_int|0
suffix:semicolon
id|mddev-&gt;safemode_timer.function
op_assign
id|md_safemode_timeout
suffix:semicolon
id|mddev-&gt;safemode_timer.data
op_assign
(paren
r_int
r_int
)paren
id|mddev
suffix:semicolon
id|mddev-&gt;safemode_delay
op_assign
(paren
l_int|20
op_star
id|HZ
)paren
op_div
l_int|1000
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* 20 msec delay */
id|mddev-&gt;in_sync
op_assign
l_int|1
suffix:semicolon
id|set_bit
c_func
(paren
id|MD_RECOVERY_NEEDED
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sb_dirty
)paren
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|set_capacity
c_func
(paren
id|disk
comma
id|mddev-&gt;array_size
op_lshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If we call blk_queue_make_request here, it will&n;&t; * re-initialise max_sectors etc which may have been&n;&t; * refined inside -&gt; run.  So just set the bits we need to set.&n;&t; * Most initialisation happended when we called&n;&t; * blk_queue_make_request(..., md_fail_request)&n;&t; * earlier.&n;&t; */
id|mddev-&gt;queue-&gt;queuedata
op_assign
id|mddev
suffix:semicolon
id|mddev-&gt;queue-&gt;make_request_fn
op_assign
id|mddev-&gt;pers-&gt;make_request
suffix:semicolon
id|mddev-&gt;changed
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|restart_array
r_static
r_int
id|restart_array
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|mddev-&gt;gendisk
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * Complain if it has no devices&n;&t; */
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
(brace
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;ro
)paren
r_goto
id|out
suffix:semicolon
id|mddev-&gt;safemode
op_assign
l_int|0
suffix:semicolon
id|mddev-&gt;ro
op_assign
l_int|0
suffix:semicolon
id|set_disk_ro
c_func
(paren
id|disk
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: %s switched to read-write mode.&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Kick recovery or resync if necessary&n;&t;&t; */
id|set_bit
c_func
(paren
id|MD_RECOVERY_NEEDED
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: %s has no personality assigned.&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|do_md_stop
r_static
r_int
id|do_md_stop
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|ro
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
op_assign
id|mddev-&gt;gendisk
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;active
)paren
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md: %s still in use.&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;sync_thread
)paren
(brace
id|set_bit
c_func
(paren
id|MD_RECOVERY_INTR
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
id|md_unregister_thread
c_func
(paren
id|mddev-&gt;sync_thread
)paren
suffix:semicolon
id|mddev-&gt;sync_thread
op_assign
l_int|NULL
suffix:semicolon
)brace
id|del_timer_sync
c_func
(paren
op_amp
id|mddev-&gt;safemode_timer
)paren
suffix:semicolon
id|invalidate_partition
c_func
(paren
id|disk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ro
)paren
(brace
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
r_goto
id|out
suffix:semicolon
id|mddev-&gt;ro
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
id|set_disk_ro
c_func
(paren
id|disk
comma
l_int|0
)paren
suffix:semicolon
id|blk_queue_make_request
c_func
(paren
id|mddev-&gt;queue
comma
id|md_fail_request
)paren
suffix:semicolon
id|mddev-&gt;pers
op_member_access_from_pointer
id|stop
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|mddev-&gt;pers-&gt;owner
)paren
suffix:semicolon
id|mddev-&gt;pers
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
id|mddev-&gt;ro
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;in_sync
)paren
(brace
multiline_comment|/* mark array as shutdown cleanly */
id|mddev-&gt;in_sync
op_assign
l_int|1
suffix:semicolon
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ro
)paren
id|set_disk_ro
c_func
(paren
id|disk
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Free resources if final stop&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ro
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: %s stopped.&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|export_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mddev-&gt;array_size
op_assign
l_int|0
suffix:semicolon
id|disk
op_assign
id|mddev-&gt;gendisk
suffix:semicolon
r_if
c_cond
(paren
id|disk
)paren
id|set_capacity
c_func
(paren
id|disk
comma
l_int|0
)paren
suffix:semicolon
id|mddev-&gt;changed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: %s switched to read-only mode.&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|autorun_array
r_static
r_void
id|autorun_array
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: running: &quot;
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;%s&gt;&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|do_md_run
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: do_md_run() returned %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|do_md_stop
(paren
id|mddev
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * lets try to run arrays based on all disks that have arrived&n; * until now. (those are in pending_raid_disks)&n; *&n; * the method: pick the first pending disk, collect all disks with&n; * the same UUID, remove all from the pending list and put them into&n; * the &squot;same_array&squot; list. Then order this list based on superblock&n; * update time (freshest comes first), kick out &squot;old&squot; disks and&n; * compare superblocks. If everything&squot;s fine then run it.&n; *&n; * If &quot;unit&quot; is allocated, then bump its reference count&n; */
DECL|function|autorun_devices
r_static
r_void
id|autorun_devices
c_func
(paren
r_int
id|part
)paren
(brace
r_struct
id|list_head
id|candidates
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev0
comma
op_star
id|rdev
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: autorun ...&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|pending_raid_disks
)paren
)paren
(brace
id|dev_t
id|dev
suffix:semicolon
id|rdev0
op_assign
id|list_entry
c_func
(paren
id|pending_raid_disks.next
comma
id|mdk_rdev_t
comma
id|same_set
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: considering %s ...&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev0-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|candidates
)paren
suffix:semicolon
id|ITERATE_RDEV_PENDING
c_func
(paren
id|rdev
comma
id|tmp
)paren
r_if
c_cond
(paren
id|super_90_load
c_func
(paren
id|rdev
comma
id|rdev0
comma
l_int|0
)paren
op_ge
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md:  adding %s ...&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
id|list_move
c_func
(paren
op_amp
id|rdev-&gt;same_set
comma
op_amp
id|candidates
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * now we have a set of devices, with all of them having&n;&t;&t; * mostly sane superblocks. It&squot;s time to allocate the&n;&t;&t; * mddev.&n;&t;&t; */
r_if
c_cond
(paren
id|rdev0-&gt;preferred_minor
OL
l_int|0
op_logical_or
id|rdev0-&gt;preferred_minor
op_ge
id|MAX_MD_DEVS
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: unit number in %s is bad: %d&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev0-&gt;bdev
comma
id|b
)paren
comma
id|rdev0-&gt;preferred_minor
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|part
)paren
id|dev
op_assign
id|MKDEV
c_func
(paren
id|mdp_major
comma
id|rdev0-&gt;preferred_minor
op_lshift
id|MdpMinorShift
)paren
suffix:semicolon
r_else
id|dev
op_assign
id|MKDEV
c_func
(paren
id|MD_MAJOR
comma
id|rdev0-&gt;preferred_minor
)paren
suffix:semicolon
id|md_probe
c_func
(paren
id|dev
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|mddev
op_assign
id|mddev_find
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: cannot allocate memory for md drive.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev_lock
c_func
(paren
id|mddev
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s locked, cannot run&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mddev-&gt;raid_disks
op_logical_or
id|mddev-&gt;major_version
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s already running, cannot run %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
comma
id|bdevname
c_func
(paren
id|rdev0-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: created %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|ITERATE_RDEV_GENERIC
c_func
(paren
id|candidates
comma
id|rdev
comma
id|tmp
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|rdev-&gt;same_set
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
)paren
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
id|autorun_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
multiline_comment|/* on success, candidates will be empty, on error&n;&t;&t; * it won&squot;t...&n;&t;&t; */
id|ITERATE_RDEV_GENERIC
c_func
(paren
id|candidates
comma
id|rdev
comma
id|tmp
)paren
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: ... autorun DONE.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * import RAID devices based on one partition&n; * if possible, the array gets run as well.&n; */
DECL|function|autostart_array
r_static
r_int
id|autostart_array
c_func
(paren
id|dev_t
id|startdev
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EINVAL
comma
id|i
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
l_int|NULL
suffix:semicolon
id|mdk_rdev_t
op_star
id|start_rdev
op_assign
l_int|NULL
comma
op_star
id|rdev
suffix:semicolon
id|start_rdev
op_assign
id|md_import_device
c_func
(paren
id|startdev
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|start_rdev
)paren
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* NOTE: this can only work for 0.90.0 superblocks */
id|sb
op_assign
(paren
id|mdp_super_t
op_star
)paren
id|page_address
c_func
(paren
id|start_rdev-&gt;sb_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;major_version
op_ne
l_int|0
op_logical_or
id|sb-&gt;minor_version
op_ne
l_int|90
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: can only autostart 0.90.0 arrays&bslash;n&quot;
)paren
suffix:semicolon
id|export_rdev
c_func
(paren
id|start_rdev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start_rdev-&gt;faulty
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: can not autostart based on faulty %s!&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|start_rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
id|export_rdev
c_func
(paren
id|start_rdev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|start_rdev-&gt;same_set
comma
op_amp
id|pending_raid_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdp_disk_t
op_star
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|i
suffix:semicolon
id|dev_t
id|dev
op_assign
id|MKDEV
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
id|startdev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
op_ne
id|desc-&gt;major
op_logical_or
id|MINOR
c_func
(paren
id|dev
)paren
op_ne
id|desc-&gt;minor
)paren
r_continue
suffix:semicolon
id|rdev
op_assign
id|md_import_device
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rdev
)paren
)paren
r_continue
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|rdev-&gt;same_set
comma
op_amp
id|pending_raid_disks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * possibly return codes&n;&t; */
id|autorun_devices
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_version
r_static
r_int
id|get_version
c_func
(paren
r_void
id|__user
op_star
id|arg
)paren
(brace
id|mdu_version_t
id|ver
suffix:semicolon
id|ver.major
op_assign
id|MD_MAJOR_VERSION
suffix:semicolon
id|ver.minor
op_assign
id|MD_MINOR_VERSION
suffix:semicolon
id|ver.patchlevel
op_assign
id|MD_PATCHLEVEL_VERSION
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ver
comma
r_sizeof
(paren
id|ver
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_array_info
r_static
r_int
id|get_array_info
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_void
id|__user
op_star
id|arg
)paren
(brace
id|mdu_array_info_t
id|info
suffix:semicolon
r_int
id|nr
comma
id|working
comma
id|active
comma
id|failed
comma
id|spare
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|nr
op_assign
id|working
op_assign
id|active
op_assign
id|failed
op_assign
id|spare
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|nr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
id|failed
op_increment
suffix:semicolon
r_else
(brace
id|working
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;in_sync
)paren
id|active
op_increment
suffix:semicolon
r_else
id|spare
op_increment
suffix:semicolon
)brace
)brace
id|info.major_version
op_assign
id|mddev-&gt;major_version
suffix:semicolon
id|info.minor_version
op_assign
id|mddev-&gt;minor_version
suffix:semicolon
id|info.patch_version
op_assign
id|MD_PATCHLEVEL_VERSION
suffix:semicolon
id|info.ctime
op_assign
id|mddev-&gt;ctime
suffix:semicolon
id|info.level
op_assign
id|mddev-&gt;level
suffix:semicolon
id|info.size
op_assign
id|mddev-&gt;size
suffix:semicolon
id|info.nr_disks
op_assign
id|nr
suffix:semicolon
id|info.raid_disks
op_assign
id|mddev-&gt;raid_disks
suffix:semicolon
id|info.md_minor
op_assign
id|mddev-&gt;md_minor
suffix:semicolon
id|info.not_persistent
op_assign
op_logical_neg
id|mddev-&gt;persistent
suffix:semicolon
id|info.utime
op_assign
id|mddev-&gt;utime
suffix:semicolon
id|info.state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;in_sync
)paren
id|info.state
op_assign
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
suffix:semicolon
id|info.active_disks
op_assign
id|active
suffix:semicolon
id|info.working_disks
op_assign
id|working
suffix:semicolon
id|info.failed_disks
op_assign
id|failed
suffix:semicolon
id|info.spare_disks
op_assign
id|spare
suffix:semicolon
id|info.layout
op_assign
id|mddev-&gt;layout
suffix:semicolon
id|info.chunk_size
op_assign
id|mddev-&gt;chunk_size
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_disk_info
r_static
r_int
id|get_disk_info
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_void
id|__user
op_star
id|arg
)paren
(brace
id|mdu_disk_info_t
id|info
suffix:semicolon
r_int
r_int
id|nr
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
id|arg
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|nr
op_assign
id|info.number
suffix:semicolon
id|rdev
op_assign
id|find_rdev_nr
c_func
(paren
id|mddev
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev
)paren
(brace
id|info.major
op_assign
id|MAJOR
c_func
(paren
id|rdev-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
id|info.minor
op_assign
id|MINOR
c_func
(paren
id|rdev-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
id|info.raid_disk
op_assign
id|rdev-&gt;raid_disk
suffix:semicolon
id|info.state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
id|info.state
op_or_assign
(paren
l_int|1
op_lshift
id|MD_DISK_FAULTY
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rdev-&gt;in_sync
)paren
(brace
id|info.state
op_or_assign
(paren
l_int|1
op_lshift
id|MD_DISK_ACTIVE
)paren
suffix:semicolon
id|info.state
op_or_assign
(paren
l_int|1
op_lshift
id|MD_DISK_SYNC
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|info.major
op_assign
id|info.minor
op_assign
l_int|0
suffix:semicolon
id|info.raid_disk
op_assign
op_minus
l_int|1
suffix:semicolon
id|info.state
op_assign
(paren
l_int|1
op_lshift
id|MD_DISK_REMOVED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_new_disk
r_static
r_int
id|add_new_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdu_disk_info_t
op_star
id|info
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
comma
id|b2
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|dev_t
id|dev
op_assign
id|MKDEV
c_func
(paren
id|info-&gt;major
comma
id|info-&gt;minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;major
op_ne
id|MAJOR
c_func
(paren
id|dev
)paren
op_logical_or
id|info-&gt;minor
op_ne
id|MINOR
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;raid_disks
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* expecting a device which has a superblock */
id|rdev
op_assign
id|md_import_device
c_func
(paren
id|dev
comma
id|mddev-&gt;major_version
comma
id|mddev-&gt;minor_version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rdev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: md_import_device returned %ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|rdev
)paren
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev0
op_assign
id|list_entry
c_func
(paren
id|mddev-&gt;disks.next
comma
id|mdk_rdev_t
comma
id|same_set
)paren
suffix:semicolon
r_int
id|err
op_assign
id|super_types
(braket
id|mddev-&gt;major_version
)braket
dot
id|load_super
c_func
(paren
id|rdev
comma
id|rdev0
comma
id|mddev-&gt;minor_version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s has different UUID to %s&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
id|bdevname
c_func
(paren
id|rdev0-&gt;bdev
comma
id|b2
)paren
)paren
suffix:semicolon
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
id|err
op_assign
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * add_new_disk can be used once the array is assembled&n;&t; * to add &quot;hot spares&quot;.  They must already have a superblock&n;&t; * written&n;&t; */
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers-&gt;hot_add_disk
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: personality does not support diskops!&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev
op_assign
id|md_import_device
c_func
(paren
id|dev
comma
id|mddev-&gt;major_version
comma
id|mddev-&gt;minor_version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rdev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: md_import_device returned %ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|rdev
)paren
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
id|rdev-&gt;in_sync
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* just to be sure */
id|rdev-&gt;raid_disk
op_assign
op_minus
l_int|1
suffix:semicolon
id|err
op_assign
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;thread
)paren
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* otherwise, add_new_disk is only allowed&n;&t; * for major_version==0 superblocks&n;&t; */
r_if
c_cond
(paren
id|mddev-&gt;major_version
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: ADD_NEW_DISK not supported&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_DISK_FAULTY
)paren
)paren
)paren
(brace
r_int
id|err
suffix:semicolon
id|rdev
op_assign
id|md_import_device
(paren
id|dev
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rdev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: error, md_import_device() returned %ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|rdev
)paren
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
id|rdev-&gt;desc_nr
op_assign
id|info-&gt;number
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;raid_disk
OL
id|mddev-&gt;raid_disks
)paren
id|rdev-&gt;raid_disk
op_assign
id|info-&gt;raid_disk
suffix:semicolon
r_else
id|rdev-&gt;raid_disk
op_assign
op_minus
l_int|1
suffix:semicolon
id|rdev-&gt;faulty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;raid_disk
OL
id|mddev-&gt;raid_disks
)paren
id|rdev-&gt;in_sync
op_assign
(paren
id|info-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_DISK_SYNC
)paren
)paren
suffix:semicolon
r_else
id|rdev-&gt;in_sync
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;persistent
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: nonpersistent superblock ...&bslash;n&quot;
)paren
suffix:semicolon
id|rdev-&gt;sb_offset
op_assign
id|rdev-&gt;bdev-&gt;bd_inode-&gt;i_size
op_rshift
id|BLOCK_SIZE_BITS
suffix:semicolon
)brace
r_else
id|rdev-&gt;sb_offset
op_assign
id|calc_dev_sboffset
c_func
(paren
id|rdev-&gt;bdev
)paren
suffix:semicolon
id|rdev-&gt;size
op_assign
id|calc_dev_size
c_func
(paren
id|rdev
comma
id|mddev-&gt;chunk_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;size
op_logical_or
(paren
id|mddev-&gt;size
OG
id|rdev-&gt;size
)paren
)paren
id|mddev-&gt;size
op_assign
id|rdev-&gt;size
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hot_remove_disk
r_static
r_int
id|hot_remove_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|dev_t
id|dev
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|rdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;raid_disk
op_ge
l_int|0
)paren
r_goto
id|busy
suffix:semicolon
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|busy
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: cannot remove active disk %s from %s ... &bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
DECL|function|hot_add_disk
r_static
r_int
id|hot_add_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|dev_t
id|dev
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;major_version
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: HOT_ADD may only be used with&quot;
l_string|&quot; version-0 superblocks.&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers-&gt;hot_add_disk
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: personality does not support diskops!&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev
op_assign
id|md_import_device
(paren
id|dev
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rdev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: error, md_import_device() returned %ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|rdev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;persistent
)paren
id|rdev-&gt;sb_offset
op_assign
id|calc_dev_sboffset
c_func
(paren
id|rdev-&gt;bdev
)paren
suffix:semicolon
r_else
id|rdev-&gt;sb_offset
op_assign
id|rdev-&gt;bdev-&gt;bd_inode-&gt;i_size
op_rshift
id|BLOCK_SIZE_BITS
suffix:semicolon
id|size
op_assign
id|calc_dev_size
c_func
(paren
id|rdev
comma
id|mddev-&gt;chunk_size
)paren
suffix:semicolon
id|rdev-&gt;size
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|mddev-&gt;size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: disk size %llu blocks &lt; array size %llu&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|size
comma
(paren
r_int
r_int
r_int
)paren
id|mddev-&gt;size
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|abort_export
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: can not hot-add faulty %s disk to %s!&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_export
suffix:semicolon
)brace
id|rdev-&gt;in_sync
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;desc_nr
op_assign
op_minus
l_int|1
suffix:semicolon
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The rest should better be atomic, we can have disk failures&n;&t; * noticed in interrupt contexts ...&n;&t; */
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
id|mddev-&gt;max_disks
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: can not hot-add to full array!&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|abort_unbind_export
suffix:semicolon
)brace
id|rdev-&gt;raid_disk
op_assign
op_minus
l_int|1
suffix:semicolon
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Kick recovery, maybe this spare has to be added to the&n;&t; * array immediately.&n;&t; */
id|set_bit
c_func
(paren
id|MD_RECOVERY_NEEDED
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|abort_unbind_export
suffix:colon
id|unbind_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|abort_export
suffix:colon
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * set_array_info is used two different ways&n; * The original usage is when creating a new array.&n; * In this usage, raid_disks is &gt; 0 and it together with&n; *  level, size, not_persistent,layout,chunksize determine the&n; *  shape of the array.&n; *  This will always create an array with a type-0.90.0 superblock.&n; * The newer usage is when assembling an array.&n; *  In this case raid_disks will be 0, and the major_version field is&n; *  use to determine which style super-blocks are to be found on the devices.&n; *  The minor and patch _version numbers are also kept incase the&n; *  super_block handler wishes to interpret them.&n; */
DECL|function|set_array_info
r_static
r_int
id|set_array_info
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdu_array_info_t
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;raid_disks
op_eq
l_int|0
)paren
(brace
multiline_comment|/* just setting version number for superblock loading */
r_if
c_cond
(paren
id|info-&gt;major_version
OL
l_int|0
op_logical_or
id|info-&gt;major_version
op_ge
r_sizeof
(paren
id|super_types
)paren
op_div
r_sizeof
(paren
id|super_types
(braket
l_int|0
)braket
)paren
op_logical_or
id|super_types
(braket
id|info-&gt;major_version
)braket
dot
id|name
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* maybe try to auto-load a module? */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: superblock version %d not known&bslash;n&quot;
comma
id|info-&gt;major_version
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mddev-&gt;major_version
op_assign
id|info-&gt;major_version
suffix:semicolon
id|mddev-&gt;minor_version
op_assign
id|info-&gt;minor_version
suffix:semicolon
id|mddev-&gt;patch_version
op_assign
id|info-&gt;patch_version
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mddev-&gt;major_version
op_assign
id|MD_MAJOR_VERSION
suffix:semicolon
id|mddev-&gt;minor_version
op_assign
id|MD_MINOR_VERSION
suffix:semicolon
id|mddev-&gt;patch_version
op_assign
id|MD_PATCHLEVEL_VERSION
suffix:semicolon
id|mddev-&gt;ctime
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
id|mddev-&gt;level
op_assign
id|info-&gt;level
suffix:semicolon
id|mddev-&gt;size
op_assign
id|info-&gt;size
suffix:semicolon
id|mddev-&gt;raid_disks
op_assign
id|info-&gt;raid_disks
suffix:semicolon
multiline_comment|/* don&squot;t set md_minor, it is determined by which /dev/md* was&n;&t; * openned&n;&t; */
r_if
c_cond
(paren
id|info-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
)paren
id|mddev-&gt;recovery_cp
op_assign
id|MaxSector
suffix:semicolon
r_else
id|mddev-&gt;recovery_cp
op_assign
l_int|0
suffix:semicolon
id|mddev-&gt;persistent
op_assign
op_logical_neg
id|info-&gt;not_persistent
suffix:semicolon
id|mddev-&gt;layout
op_assign
id|info-&gt;layout
suffix:semicolon
id|mddev-&gt;chunk_size
op_assign
id|info-&gt;chunk_size
suffix:semicolon
id|mddev-&gt;max_disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Generate a 128 bit UUID&n;&t; */
id|get_random_bytes
c_func
(paren
id|mddev-&gt;uuid
comma
l_int|16
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * update_array_info is used to change the configuration of an&n; * on-line array.&n; * The version, ctime,level,size,raid_disks,not_persistent, layout,chunk_size&n; * fields in the info are checked against the array.&n; * Any differences that cannot be handled will cause an error.&n; * Normally, only one change can be managed at a time.&n; */
DECL|function|update_array_info
r_static
r_int
id|update_array_info
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdu_array_info_t
op_star
id|info
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;major_version
op_ne
id|info-&gt;major_version
op_logical_or
id|mddev-&gt;minor_version
op_ne
id|info-&gt;minor_version
op_logical_or
multiline_comment|/*&t;    mddev-&gt;patch_version != info-&gt;patch_version || */
id|mddev-&gt;ctime
op_ne
id|info-&gt;ctime
op_logical_or
id|mddev-&gt;level
op_ne
id|info-&gt;level
op_logical_or
multiline_comment|/*&t;    mddev-&gt;layout        != info-&gt;layout        || */
op_logical_neg
id|mddev-&gt;persistent
op_ne
id|info-&gt;not_persistent
op_logical_or
id|mddev-&gt;chunk_size
op_ne
id|info-&gt;chunk_size
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Check there is only one change */
r_if
c_cond
(paren
id|mddev-&gt;size
op_ne
id|info-&gt;size
)paren
id|cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;raid_disks
op_ne
id|info-&gt;raid_disks
)paren
id|cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;layout
op_ne
id|info-&gt;layout
)paren
id|cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;layout
op_ne
id|info-&gt;layout
)paren
(brace
multiline_comment|/* Change layout&n;&t;&t; * we don&squot;t need to do anything at the md level, the&n;&t;&t; * personality will take care of it all.&n;&t;&t; */
r_if
c_cond
(paren
id|mddev-&gt;pers-&gt;reconfig
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
r_return
id|mddev-&gt;pers
op_member_access_from_pointer
id|reconfig
c_func
(paren
id|mddev
comma
id|info-&gt;layout
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;size
op_ne
id|info-&gt;size
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers-&gt;resize
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* The &quot;size&quot; is the amount of each device that is used.&n;&t;&t; * This can only make sense for arrays with redundancy.&n;&t;&t; * linear and raid0 always use whatever space is available&n;&t;&t; * We can only consider changing the size if no resync&n;&t;&t; * or reconstruction is happening, and if the new size&n;&t;&t; * is acceptable. It must fit before the sb_offset or,&n;&t;&t; * if that is &lt;data_offset, it must fit before the&n;&t;&t; * size of each device.&n;&t;&t; * If size is zero, we find the largest size that fits.&n;&t;&t; */
r_if
c_cond
(paren
id|mddev-&gt;sync_thread
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|sector_t
id|avail
suffix:semicolon
r_int
id|fit
op_assign
(paren
id|info-&gt;size
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;sb_offset
OG
id|rdev-&gt;data_offset
)paren
id|avail
op_assign
(paren
id|rdev-&gt;sb_offset
op_star
l_int|2
)paren
op_minus
id|rdev-&gt;data_offset
suffix:semicolon
r_else
id|avail
op_assign
id|get_capacity
c_func
(paren
id|rdev-&gt;bdev-&gt;bd_disk
)paren
op_minus
id|rdev-&gt;data_offset
suffix:semicolon
r_if
c_cond
(paren
id|fit
op_logical_and
(paren
id|info-&gt;size
op_eq
l_int|0
op_logical_or
id|info-&gt;size
OG
id|avail
op_div
l_int|2
)paren
)paren
id|info-&gt;size
op_assign
id|avail
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|avail
OL
(paren
(paren
id|sector_t
)paren
id|info-&gt;size
op_lshift
l_int|1
)paren
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|rv
op_assign
id|mddev-&gt;pers
op_member_access_from_pointer
id|resize
c_func
(paren
id|mddev
comma
(paren
id|sector_t
)paren
id|info-&gt;size
op_star
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rv
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
id|bdev
op_assign
id|bdget_disk
c_func
(paren
id|mddev-&gt;gendisk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdev
)paren
(brace
id|down
c_func
(paren
op_amp
id|bdev-&gt;bd_inode-&gt;i_sem
)paren
suffix:semicolon
id|i_size_write
c_func
(paren
id|bdev-&gt;bd_inode
comma
id|mddev-&gt;array_size
op_lshift
l_int|10
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|bdev-&gt;bd_inode-&gt;i_sem
)paren
suffix:semicolon
id|bdput
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|mddev-&gt;raid_disks
op_ne
id|info-&gt;raid_disks
)paren
(brace
multiline_comment|/* change the number of raid disks */
r_if
c_cond
(paren
id|mddev-&gt;pers-&gt;reshape
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;raid_disks
op_le
l_int|0
op_logical_or
id|info-&gt;raid_disks
op_ge
id|mddev-&gt;max_disks
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sync_thread
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|rv
op_assign
id|mddev-&gt;pers
op_member_access_from_pointer
id|reshape
c_func
(paren
id|mddev
comma
id|info-&gt;raid_disks
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rv
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
id|bdev
op_assign
id|bdget_disk
c_func
(paren
id|mddev-&gt;gendisk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdev
)paren
(brace
id|down
c_func
(paren
op_amp
id|bdev-&gt;bd_inode-&gt;i_sem
)paren
suffix:semicolon
id|i_size_write
c_func
(paren
id|bdev-&gt;bd_inode
comma
id|mddev-&gt;array_size
op_lshift
l_int|10
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|bdev-&gt;bd_inode-&gt;i_sem
)paren
suffix:semicolon
id|bdput
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
)brace
)brace
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|set_disk_faulty
r_static
r_int
id|set_disk_faulty
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|dev_t
id|dev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|rdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|md_error
c_func
(paren
id|mddev
comma
id|rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|md_ioctl
r_static
r_int
id|md_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_void
id|__user
op_star
id|argp
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|hd_geometry
id|__user
op_star
id|loc
op_assign
id|argp
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/*&n;&t; * Commands dealing with the RAID driver but not any&n;&t; * particular array:&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|RAID_VERSION
suffix:colon
id|err
op_assign
id|get_version
c_func
(paren
id|argp
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
id|PRINT_RAID_DEBUG
suffix:colon
id|err
op_assign
l_int|0
suffix:semicolon
id|md_print_devices
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#ifndef MODULE
r_case
id|RAID_AUTORUN
suffix:colon
id|err
op_assign
l_int|0
suffix:semicolon
id|autostart_arrays
c_func
(paren
id|arg
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commands creating/starting a new array:&n;&t; */
id|mddev
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|START_ARRAY
)paren
(brace
multiline_comment|/* START_ARRAY doesn&squot;t need to lock the array as autostart_array&n;&t;&t; * does the locking, and it could even be a different array&n;&t;&t; */
r_static
r_int
id|cnt
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s(pid %d) used deprecated START_ARRAY ioctl. &quot;
l_string|&quot;This will not be supported beyond 2.6&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|cnt
op_decrement
suffix:semicolon
)brace
id|err
op_assign
id|autostart_array
c_func
(paren
id|new_decode_dev
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: autostart failed!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_goto
id|done
suffix:semicolon
)brace
id|err
op_assign
id|mddev_lock
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: ioctl lock interrupted, reason %d, cmd %d&bslash;n&quot;
comma
id|err
comma
id|cmd
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SET_ARRAY_INFO
suffix:colon
(brace
id|mdu_array_info_t
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
id|memset
c_func
(paren
op_amp
id|info
comma
l_int|0
comma
r_sizeof
(paren
id|info
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
id|argp
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
(brace
id|err
op_assign
id|update_array_info
c_func
(paren
id|mddev
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: couldn&squot;t update&quot;
l_string|&quot; array info. %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
r_goto
id|done_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: array %s already has disks!&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;raid_disks
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: array %s already initialised!&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
id|err
op_assign
id|set_array_info
c_func
(paren
id|mddev
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: couldn&squot;t set&quot;
l_string|&quot; array info. %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
)brace
r_goto
id|done_unlock
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commands querying/configuring an existing array:&n;&t; */
multiline_comment|/* if we are initialised yet, only ADD_NEW_DISK or STOP_ARRAY is allowed */
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;raid_disks
op_logical_and
id|cmd
op_ne
id|ADD_NEW_DISK
op_logical_and
id|cmd
op_ne
id|STOP_ARRAY
op_logical_and
id|cmd
op_ne
id|RUN_ARRAY
)paren
(brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commands even a read-only array can execute:&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|GET_ARRAY_INFO
suffix:colon
id|err
op_assign
id|get_array_info
c_func
(paren
id|mddev
comma
id|argp
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|GET_DISK_INFO
suffix:colon
id|err
op_assign
id|get_disk_info
c_func
(paren
id|mddev
comma
id|argp
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|RESTART_ARRAY_RW
suffix:colon
id|err
op_assign
id|restart_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|STOP_ARRAY
suffix:colon
id|err
op_assign
id|do_md_stop
(paren
id|mddev
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|STOP_ARRAY_RO
suffix:colon
id|err
op_assign
id|do_md_stop
(paren
id|mddev
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
multiline_comment|/*&n;&t; * We have a problem here : there is no easy way to give a CHS&n;&t; * virtual geometry. We currently pretend that we have a 2 heads&n;&t; * 4 sectors (with a BIG number of cylinders...). This drives&n;&t; * dosfs just mad... ;-)&n;&t; */
r_case
id|HDIO_GETGEO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|loc
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
id|err
op_assign
id|put_user
(paren
l_int|2
comma
(paren
r_char
id|__user
op_star
)paren
op_amp
id|loc-&gt;heads
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|abort_unlock
suffix:semicolon
id|err
op_assign
id|put_user
(paren
l_int|4
comma
(paren
r_char
id|__user
op_star
)paren
op_amp
id|loc-&gt;sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|abort_unlock
suffix:semicolon
id|err
op_assign
id|put_user
c_func
(paren
id|get_capacity
c_func
(paren
id|mddev-&gt;gendisk
)paren
op_div
l_int|8
comma
(paren
r_int
id|__user
op_star
)paren
op_amp
id|loc-&gt;cylinders
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|abort_unlock
suffix:semicolon
id|err
op_assign
id|put_user
(paren
id|get_start_sect
c_func
(paren
id|inode-&gt;i_bdev
)paren
comma
(paren
r_int
id|__user
op_star
)paren
op_amp
id|loc-&gt;start
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The remaining ioctls are changing the state of the&n;&t; * superblock, so we do not allow read-only arrays&n;&t; * here:&n;&t; */
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
(brace
id|err
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|ADD_NEW_DISK
suffix:colon
(brace
id|mdu_disk_info_t
id|info
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
id|argp
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|err
op_assign
id|add_new_disk
c_func
(paren
id|mddev
comma
op_amp
id|info
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
)brace
r_case
id|HOT_REMOVE_DISK
suffix:colon
id|err
op_assign
id|hot_remove_disk
c_func
(paren
id|mddev
comma
id|new_decode_dev
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|HOT_ADD_DISK
suffix:colon
id|err
op_assign
id|hot_add_disk
c_func
(paren
id|mddev
comma
id|new_decode_dev
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|SET_DISK_FAULTY
suffix:colon
id|err
op_assign
id|set_disk_faulty
c_func
(paren
id|mddev
comma
id|new_decode_dev
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|RUN_ARRAY
suffix:colon
id|err
op_assign
id|do_md_run
(paren
id|mddev
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|_IOC_TYPE
c_func
(paren
id|cmd
)paren
op_eq
id|MD_MAJOR
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s(pid %d) used&quot;
l_string|&quot; obsolete MD ioctl, upgrade your&quot;
l_string|&quot; software to use new ictls.&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
id|done_unlock
suffix:colon
id|abort_unlock
suffix:colon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|err
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
m_abort
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|md_open
r_static
r_int
id|md_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
multiline_comment|/*&n;&t; * Succeed if we can lock the mddev, which confirms that&n;&t; * it isn&squot;t being stopped right now.&n;&t; */
id|mddev_t
op_star
id|mddev
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|mddev_lock
c_func
(paren
id|mddev
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|mddev_get
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|check_disk_change
c_func
(paren
id|inode-&gt;i_bdev
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|md_release
r_static
r_int
id|md_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|md_media_changed
r_static
r_int
id|md_media_changed
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|disk-&gt;private_data
suffix:semicolon
r_return
id|mddev-&gt;changed
suffix:semicolon
)brace
DECL|function|md_revalidate
r_static
r_int
id|md_revalidate
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|disk-&gt;private_data
suffix:semicolon
id|mddev-&gt;changed
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|md_fops
r_static
r_struct
id|block_device_operations
id|md_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|md_open
comma
dot
id|release
op_assign
id|md_release
comma
dot
id|ioctl
op_assign
id|md_ioctl
comma
dot
id|media_changed
op_assign
id|md_media_changed
comma
dot
id|revalidate_disk
op_assign
id|md_revalidate
comma
)brace
suffix:semicolon
DECL|function|md_thread
r_int
id|md_thread
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
id|mdk_thread_t
op_star
id|thread
op_assign
id|arg
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Detach thread&n;&t; */
id|daemonize
c_func
(paren
id|thread-&gt;name
comma
id|mdname
c_func
(paren
id|thread-&gt;mddev
)paren
)paren
suffix:semicolon
id|current-&gt;exit_signal
op_assign
id|SIGCHLD
suffix:semicolon
id|allow_signal
c_func
(paren
id|SIGKILL
)paren
suffix:semicolon
id|thread-&gt;tsk
op_assign
id|current
suffix:semicolon
multiline_comment|/*&n;&t; * md_thread is a &squot;system-thread&squot;, it&squot;s priority should be very&n;&t; * high. We avoid resource deadlocks individually in each&n;&t; * raid personality. (RAID5 does preallocation) We also use RR and&n;&t; * the very same RT priority as kswapd, thus we will never get&n;&t; * into a priority inversion deadlock.&n;&t; *&n;&t; * we definitely have to have equal or higher priority than&n;&t; * bdflush, otherwise bdflush will deadlock if there are too&n;&t; * many dirty RAID5 blocks.&n;&t; */
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|complete
c_func
(paren
id|thread-&gt;event
)paren
suffix:semicolon
r_while
c_loop
(paren
id|thread-&gt;run
)paren
(brace
r_void
(paren
op_star
id|run
)paren
(paren
id|mddev_t
op_star
)paren
suffix:semicolon
id|wait_event_interruptible
c_func
(paren
id|thread-&gt;wqueue
comma
id|test_bit
c_func
(paren
id|THREAD_WAKEUP
comma
op_amp
id|thread-&gt;flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
id|refrigerator
c_func
(paren
id|PF_FREEZE
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|THREAD_WAKEUP
comma
op_amp
id|thread-&gt;flags
)paren
suffix:semicolon
id|run
op_assign
id|thread-&gt;run
suffix:semicolon
r_if
c_cond
(paren
id|run
)paren
id|run
c_func
(paren
id|thread-&gt;mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
id|complete
c_func
(paren
id|thread-&gt;event
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|md_wakeup_thread
r_void
id|md_wakeup_thread
c_func
(paren
id|mdk_thread_t
op_star
id|thread
)paren
(brace
r_if
c_cond
(paren
id|thread
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;md: waking up MD thread %s.&bslash;n&quot;
comma
id|thread-&gt;tsk-&gt;comm
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|THREAD_WAKEUP
comma
op_amp
id|thread-&gt;flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|thread-&gt;wqueue
)paren
suffix:semicolon
)brace
)brace
DECL|function|md_register_thread
id|mdk_thread_t
op_star
id|md_register_thread
c_func
(paren
r_void
(paren
op_star
id|run
)paren
(paren
id|mddev_t
op_star
)paren
comma
id|mddev_t
op_star
id|mddev
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|mdk_thread_t
op_star
id|thread
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|completion
id|event
suffix:semicolon
id|thread
op_assign
(paren
id|mdk_thread_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|mdk_thread_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thread
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|thread
comma
l_int|0
comma
r_sizeof
(paren
id|mdk_thread_t
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|thread-&gt;wqueue
)paren
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|thread-&gt;event
op_assign
op_amp
id|event
suffix:semicolon
id|thread-&gt;run
op_assign
id|run
suffix:semicolon
id|thread-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|thread-&gt;name
op_assign
id|name
suffix:semicolon
id|ret
op_assign
id|kernel_thread
c_func
(paren
id|md_thread
comma
id|thread
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|thread
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|wait_for_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
r_return
id|thread
suffix:semicolon
)brace
DECL|function|md_interrupt_thread
r_static
r_void
id|md_interrupt_thread
c_func
(paren
id|mdk_thread_t
op_star
id|thread
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|thread-&gt;tsk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;interrupting MD-thread pid %d&bslash;n&quot;
comma
id|thread-&gt;tsk-&gt;pid
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|thread-&gt;tsk
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|md_unregister_thread
r_void
id|md_unregister_thread
c_func
(paren
id|mdk_thread_t
op_star
id|thread
)paren
(brace
r_struct
id|completion
id|event
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|thread-&gt;event
op_assign
op_amp
id|event
suffix:semicolon
id|thread-&gt;run
op_assign
l_int|NULL
suffix:semicolon
id|thread-&gt;name
op_assign
l_int|NULL
suffix:semicolon
id|md_interrupt_thread
c_func
(paren
id|thread
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|thread
)paren
suffix:semicolon
)brace
DECL|function|md_error
r_void
id|md_error
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rdev
op_logical_or
id|rdev-&gt;faulty
)paren
r_return
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;md_error dev:%s, rdev:(%d:%d), (caller: %p,%p,%p,%p).&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
comma
id|MAJOR
c_func
(paren
id|rdev-&gt;bdev-&gt;bd_dev
)paren
comma
id|MINOR
c_func
(paren
id|rdev-&gt;bdev-&gt;bd_dev
)paren
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
comma
id|__builtin_return_address
c_func
(paren
l_int|1
)paren
comma
id|__builtin_return_address
c_func
(paren
l_int|2
)paren
comma
id|__builtin_return_address
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers-&gt;error_handler
)paren
r_return
suffix:semicolon
id|mddev-&gt;pers
op_member_access_from_pointer
id|error_handler
c_func
(paren
id|mddev
comma
id|rdev
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|MD_RECOVERY_INTR
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|MD_RECOVERY_NEEDED
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
)brace
multiline_comment|/* seq_file implementation /proc/mdstat */
DECL|function|status_unused
r_static
r_void
id|status_unused
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;unused devices: &quot;
)paren
suffix:semicolon
id|ITERATE_RDEV_PENDING
c_func
(paren
id|rdev
comma
id|tmp
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%s &quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&lt;none&gt;&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|status_resync
r_static
r_void
id|status_resync
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
r_int
id|max_blocks
comma
id|resync
comma
id|res
comma
id|dt
comma
id|db
comma
id|rt
suffix:semicolon
id|resync
op_assign
(paren
id|mddev-&gt;curr_resync
op_minus
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;recovery_active
)paren
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|MD_RECOVERY_SYNC
comma
op_amp
id|mddev-&gt;recovery
)paren
)paren
id|max_blocks
op_assign
id|mddev-&gt;resync_max_sectors
op_rshift
l_int|1
suffix:semicolon
r_else
id|max_blocks
op_assign
id|mddev-&gt;size
suffix:semicolon
multiline_comment|/*&n;&t; * Should not happen.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|max_blocks
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|res
op_assign
(paren
id|resync
op_div
l_int|1024
)paren
op_star
l_int|1000
op_div
(paren
id|max_blocks
op_div
l_int|1024
op_plus
l_int|1
)paren
suffix:semicolon
(brace
r_int
id|i
comma
id|x
op_assign
id|res
op_div
l_int|50
comma
id|y
op_assign
l_int|20
op_minus
id|x
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;[&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|x
suffix:semicolon
id|i
op_increment
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;=&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|y
suffix:semicolon
id|i
op_increment
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;] &quot;
)paren
suffix:semicolon
)brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot; %s =%3lu.%lu%% (%lu/%lu)&quot;
comma
(paren
id|test_bit
c_func
(paren
id|MD_RECOVERY_SYNC
comma
op_amp
id|mddev-&gt;recovery
)paren
ques
c_cond
l_string|&quot;resync&quot;
suffix:colon
l_string|&quot;recovery&quot;
)paren
comma
id|res
op_div
l_int|10
comma
id|res
op_mod
l_int|10
comma
id|resync
comma
id|max_blocks
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We do not want to overflow, so the order of operands and&n;&t; * the * 100 / 100 trick are important. We do a +1 to be&n;&t; * safe against division by zero. We only estimate anyway.&n;&t; *&n;&t; * dt: time from mark until now&n;&t; * db: blocks written from mark until now&n;&t; * rt: remaining time&n;&t; */
id|dt
op_assign
(paren
(paren
id|jiffies
op_minus
id|mddev-&gt;resync_mark
)paren
op_div
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dt
)paren
id|dt
op_increment
suffix:semicolon
id|db
op_assign
id|resync
op_minus
(paren
id|mddev-&gt;resync_mark_cnt
op_div
l_int|2
)paren
suffix:semicolon
id|rt
op_assign
(paren
id|dt
op_star
(paren
(paren
id|max_blocks
op_minus
id|resync
)paren
op_div
(paren
id|db
op_div
l_int|100
op_plus
l_int|1
)paren
)paren
)paren
op_div
l_int|100
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot; finish=%lu.%lumin&quot;
comma
id|rt
op_div
l_int|60
comma
(paren
id|rt
op_mod
l_int|60
)paren
op_div
l_int|6
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot; speed=%ldK/sec&quot;
comma
id|db
op_div
id|dt
)paren
suffix:semicolon
)brace
DECL|function|md_seq_start
r_static
r_void
op_star
id|md_seq_start
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|loff_t
id|l
op_assign
op_star
id|pos
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
r_if
c_cond
(paren
id|l
op_ge
l_int|0x10000
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|l
op_decrement
)paren
multiline_comment|/* header */
r_return
(paren
r_void
op_star
)paren
l_int|1
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|all_mddevs
)paren
r_if
c_cond
(paren
op_logical_neg
id|l
op_decrement
)paren
(brace
id|mddev
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
id|mddev_t
comma
id|all_mddevs
)paren
suffix:semicolon
id|mddev_get
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
r_return
id|mddev
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|l
op_decrement
)paren
r_return
(paren
r_void
op_star
)paren
l_int|2
suffix:semicolon
multiline_comment|/* tail */
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|md_seq_next
r_static
r_void
op_star
id|md_seq_next
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mddev_t
op_star
id|next_mddev
comma
op_star
id|mddev
op_assign
id|v
suffix:semicolon
op_increment
op_star
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
(paren
r_void
op_star
)paren
l_int|2
)paren
r_return
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
(paren
r_void
op_star
)paren
l_int|1
)paren
id|tmp
op_assign
id|all_mddevs.next
suffix:semicolon
r_else
id|tmp
op_assign
id|mddev-&gt;all_mddevs.next
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
op_amp
id|all_mddevs
)paren
id|next_mddev
op_assign
id|mddev_get
c_func
(paren
id|list_entry
c_func
(paren
id|tmp
comma
id|mddev_t
comma
id|all_mddevs
)paren
)paren
suffix:semicolon
r_else
(brace
id|next_mddev
op_assign
(paren
r_void
op_star
)paren
l_int|2
suffix:semicolon
op_star
id|pos
op_assign
l_int|0x10000
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v
op_ne
(paren
r_void
op_star
)paren
l_int|1
)paren
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
id|next_mddev
suffix:semicolon
)brace
DECL|function|md_seq_stop
r_static
r_void
id|md_seq_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|v
suffix:semicolon
r_if
c_cond
(paren
id|mddev
op_logical_and
id|v
op_ne
(paren
r_void
op_star
)paren
l_int|1
op_logical_and
id|v
op_ne
(paren
r_void
op_star
)paren
l_int|2
)paren
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
DECL|function|md_seq_show
r_static
r_int
id|md_seq_show
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|v
suffix:semicolon
id|sector_t
id|size
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp2
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
(paren
r_void
op_star
)paren
l_int|1
)paren
(brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;Personalities : &quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pers_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PERSONALITY
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|pers
(braket
id|i
)braket
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;[%s] &quot;
comma
id|pers
(braket
id|i
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pers_lock
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|v
op_eq
(paren
r_void
op_star
)paren
l_int|2
)paren
(brace
id|status_unused
c_func
(paren
id|seq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev_lock
c_func
(paren
id|mddev
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
op_logical_or
id|mddev-&gt;raid_disks
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%s : %sactive&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
comma
id|mddev-&gt;pers
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;in&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot; (read-only)&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot; %s&quot;
comma
id|mddev-&gt;pers-&gt;name
)paren
suffix:semicolon
)brace
id|size
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp2
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot; %s[%d]&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
id|rdev-&gt;desc_nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;(F)&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|size
op_add_assign
id|rdev-&gt;size
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;n      %llu blocks&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|mddev-&gt;array_size
)paren
suffix:semicolon
r_else
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;n      %llu blocks&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
(brace
id|mddev-&gt;pers-&gt;status
(paren
id|seq
comma
id|mddev
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;n      &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;curr_resync
OG
l_int|2
)paren
id|status_resync
(paren
id|seq
comma
id|mddev
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mddev-&gt;curr_resync
op_eq
l_int|1
op_logical_or
id|mddev-&gt;curr_resync
op_eq
l_int|2
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&t;resync=DELAYED&quot;
)paren
suffix:semicolon
)brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|md_seq_ops
r_static
r_struct
id|seq_operations
id|md_seq_ops
op_assign
(brace
dot
id|start
op_assign
id|md_seq_start
comma
dot
id|next
op_assign
id|md_seq_next
comma
dot
id|stop
op_assign
id|md_seq_stop
comma
dot
id|show
op_assign
id|md_seq_show
comma
)brace
suffix:semicolon
DECL|function|md_seq_open
r_static
r_int
id|md_seq_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|seq_open
c_func
(paren
id|file
comma
op_amp
id|md_seq_ops
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|variable|md_seq_fops
r_static
r_struct
id|file_operations
id|md_seq_fops
op_assign
(brace
dot
id|open
op_assign
id|md_seq_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|seq_release
comma
)brace
suffix:semicolon
DECL|function|register_md_personality
r_int
id|register_md_personality
c_func
(paren
r_int
id|pnum
comma
id|mdk_personality_t
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|pnum
op_ge
id|MAX_PERSONALITY
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: tried to install personality %s as nr %d, but max is %lu&bslash;n&quot;
comma
id|p-&gt;name
comma
id|pnum
comma
id|MAX_PERSONALITY
op_minus
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|pers_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pers
(braket
id|pnum
)braket
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|pers_lock
)paren
suffix:semicolon
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|pers
(braket
id|pnum
)braket
op_assign
id|p
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: %s personality registered as nr %d&bslash;n&quot;
comma
id|p-&gt;name
comma
id|pnum
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pers_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unregister_md_personality
r_int
id|unregister_md_personality
c_func
(paren
r_int
id|pnum
)paren
(brace
r_if
c_cond
(paren
id|pnum
op_ge
id|MAX_PERSONALITY
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: %s personality unregistered&bslash;n&quot;
comma
id|pers
(braket
id|pnum
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pers_lock
)paren
suffix:semicolon
id|pers
(braket
id|pnum
)braket
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pers_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|is_mddev_idle
r_static
r_int
id|is_mddev_idle
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|idle
suffix:semicolon
r_int
r_int
id|curr_events
suffix:semicolon
id|idle
op_assign
l_int|1
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|rdev-&gt;bdev-&gt;bd_contains-&gt;bd_disk
suffix:semicolon
id|curr_events
op_assign
id|disk_stat_read
c_func
(paren
id|disk
comma
id|read_sectors
)paren
op_plus
id|disk_stat_read
c_func
(paren
id|disk
comma
id|write_sectors
)paren
op_minus
id|atomic_read
c_func
(paren
op_amp
id|disk-&gt;sync_io
)paren
suffix:semicolon
multiline_comment|/* Allow some slack between valud of curr_events and last_events,&n;&t;&t; * as there are some uninteresting races.&n;&t;&t; * Note: the following is an unsigned comparison.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|curr_events
op_minus
id|rdev-&gt;last_events
op_plus
l_int|32
)paren
OG
l_int|64
)paren
(brace
id|rdev-&gt;last_events
op_assign
id|curr_events
suffix:semicolon
id|idle
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|idle
suffix:semicolon
)brace
DECL|function|md_done_sync
r_void
id|md_done_sync
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|blocks
comma
r_int
id|ok
)paren
(brace
multiline_comment|/* another &quot;blocks&quot; (512byte) blocks have been synced */
id|atomic_sub
c_func
(paren
id|blocks
comma
op_amp
id|mddev-&gt;recovery_active
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|mddev-&gt;recovery_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ok
)paren
(brace
id|set_bit
c_func
(paren
id|MD_RECOVERY_ERR
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
singleline_comment|// stop recovery, signal do_sync ....
)brace
)brace
DECL|function|md_write_start
r_void
id|md_write_start
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;writes_pending
)paren
)paren
(brace
id|mddev_lock_uninterruptible
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;in_sync
)paren
(brace
id|mddev-&gt;in_sync
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|mddev-&gt;safemode_timer
)paren
suffix:semicolon
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|mddev-&gt;writes_pending
)paren
suffix:semicolon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
r_else
id|atomic_inc
c_func
(paren
op_amp
id|mddev-&gt;writes_pending
)paren
suffix:semicolon
)brace
DECL|function|md_write_end
r_void
id|md_write_end
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|mddev-&gt;writes_pending
)paren
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;safemode
op_eq
l_int|2
)paren
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
r_else
id|mod_timer
c_func
(paren
op_amp
id|mddev-&gt;safemode_timer
comma
id|jiffies
op_plus
id|mddev-&gt;safemode_delay
)paren
suffix:semicolon
)brace
)brace
DECL|function|md_enter_safemode
r_static
r_inline
r_void
id|md_enter_safemode
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;safemode
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;safemode
op_eq
l_int|2
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;writes_pending
)paren
op_logical_or
id|mddev-&gt;in_sync
op_logical_or
id|mddev-&gt;recovery_cp
op_ne
id|MaxSector
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* avoid the lock */
id|mddev_lock_uninterruptible
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;safemode
op_logical_and
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;writes_pending
)paren
op_logical_and
op_logical_neg
id|mddev-&gt;in_sync
op_logical_and
id|mddev-&gt;recovery_cp
op_eq
id|MaxSector
)paren
(brace
id|mddev-&gt;in_sync
op_assign
l_int|1
suffix:semicolon
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;safemode
op_eq
l_int|1
)paren
id|mddev-&gt;safemode
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|md_handle_safemode
r_void
id|md_handle_safemode
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: %s in immediate safe mode&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|mddev-&gt;safemode
op_assign
l_int|2
suffix:semicolon
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
id|md_enter_safemode
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
DECL|variable|resync_wait
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|resync_wait
)paren
suffix:semicolon
DECL|macro|SYNC_MARKS
mdefine_line|#define SYNC_MARKS&t;10
DECL|macro|SYNC_MARK_STEP
mdefine_line|#define&t;SYNC_MARK_STEP&t;(3*HZ)
DECL|function|md_do_sync
r_static
r_void
id|md_do_sync
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mddev_t
op_star
id|mddev2
suffix:semicolon
r_int
r_int
id|currspeed
op_assign
l_int|0
comma
id|window
suffix:semicolon
id|sector_t
id|max_sectors
comma
id|j
suffix:semicolon
r_int
r_int
id|mark
(braket
id|SYNC_MARKS
)braket
suffix:semicolon
id|sector_t
id|mark_cnt
(braket
id|SYNC_MARKS
)braket
suffix:semicolon
r_int
id|last_mark
comma
id|m
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|sector_t
id|last_check
suffix:semicolon
multiline_comment|/* just incase thread restarts... */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|MD_RECOVERY_DONE
comma
op_amp
id|mddev-&gt;recovery
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* we overload curr_resync somewhat here.&n;&t; * 0 == not engaged in resync at all&n;&t; * 2 == checking that there is no conflict with another sync&n;&t; * 1 == like 2, but have yielded to allow conflicting resync to&n;&t; *&t;&t;commense&n;&t; * other == active in resync - this many blocks&n;&t; *&n;&t; * Before starting a resync we must have set curr_resync to&n;&t; * 2, and then checked that every &quot;conflicting&quot; array has curr_resync&n;&t; * less than ours.  When we find one that is the same or higher&n;&t; * we wait on resync_wait.  To avoid deadlock, we reduce curr_resync&n;&t; * to 1 if we choose to yield (based arbitrarily on address of mddev structure).&n;&t; * This will mean we have to start checking from the beginning again.&n;&t; *&n;&t; */
r_do
(brace
id|mddev-&gt;curr_resync
op_assign
l_int|2
suffix:semicolon
id|try_again
suffix:colon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
r_goto
id|skip
suffix:semicolon
)brace
id|ITERATE_MDDEV
c_func
(paren
id|mddev2
comma
id|tmp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev2
op_eq
id|mddev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mddev2-&gt;curr_resync
op_logical_and
id|match_mddev_units
c_func
(paren
id|mddev
comma
id|mddev2
)paren
)paren
(brace
id|DEFINE_WAIT
c_func
(paren
id|wq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev
OL
id|mddev2
op_logical_and
id|mddev-&gt;curr_resync
op_eq
l_int|2
)paren
(brace
multiline_comment|/* arbitrarily yield */
id|mddev-&gt;curr_resync
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|resync_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev
OG
id|mddev2
op_logical_and
id|mddev-&gt;curr_resync
op_eq
l_int|1
)paren
multiline_comment|/* no need to wait here, we can wait the next&n;&t;&t;&t;&t;&t; * time &squot;round when curr_resync == 2&n;&t;&t;&t;&t;&t; */
r_continue
suffix:semicolon
id|prepare_to_wait
c_func
(paren
op_amp
id|resync_wait
comma
op_amp
id|wq
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
op_logical_and
id|mddev2-&gt;curr_resync
op_ge
id|mddev-&gt;curr_resync
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: delaying resync of %s&quot;
l_string|&quot; until %s has finished resync (they&quot;
l_string|&quot; share one or more physical units)&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
comma
id|mdname
c_func
(paren
id|mddev2
)paren
)paren
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev2
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|finish_wait
c_func
(paren
op_amp
id|resync_wait
comma
op_amp
id|wq
)paren
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
id|finish_wait
c_func
(paren
op_amp
id|resync_wait
comma
op_amp
id|wq
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|mddev-&gt;curr_resync
OL
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|MD_RECOVERY_SYNC
comma
op_amp
id|mddev-&gt;recovery
)paren
)paren
multiline_comment|/* resync follows the size requested by the personality,&n;&t;&t; * which default to physical size, but can be virtual size&n;&t;&t; */
id|max_sectors
op_assign
id|mddev-&gt;resync_max_sectors
suffix:semicolon
r_else
multiline_comment|/* recovery follows the physical size of devices */
id|max_sectors
op_assign
id|mddev-&gt;size
op_lshift
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: syncing RAID array %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: minimum _guaranteed_ reconstruction speed:&quot;
l_string|&quot; %d KB/sec/disc.&bslash;n&quot;
comma
id|sysctl_speed_limit_min
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: using maximum available idle IO bandwith &quot;
l_string|&quot;(but not more than %d KB/sec) for reconstruction.&bslash;n&quot;
comma
id|sysctl_speed_limit_max
)paren
suffix:semicolon
id|is_mddev_idle
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/* this also initializes IO event counters */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|MD_RECOVERY_SYNC
comma
op_amp
id|mddev-&gt;recovery
)paren
)paren
id|j
op_assign
id|mddev-&gt;recovery_cp
suffix:semicolon
r_else
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|SYNC_MARKS
suffix:semicolon
id|m
op_increment
)paren
(brace
id|mark
(braket
id|m
)braket
op_assign
id|jiffies
suffix:semicolon
id|mark_cnt
(braket
id|m
)braket
op_assign
id|j
suffix:semicolon
)brace
id|last_mark
op_assign
l_int|0
suffix:semicolon
id|mddev-&gt;resync_mark
op_assign
id|mark
(braket
id|last_mark
)braket
suffix:semicolon
id|mddev-&gt;resync_mark_cnt
op_assign
id|mark_cnt
(braket
id|last_mark
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Tune reconstruction:&n;&t; */
id|window
op_assign
l_int|32
op_star
(paren
id|PAGE_SIZE
op_div
l_int|512
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: using %dk window, over a total of %llu blocks.&bslash;n&quot;
comma
id|window
op_div
l_int|2
comma
(paren
r_int
r_int
r_int
)paren
id|max_sectors
op_div
l_int|2
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mddev-&gt;recovery_active
comma
l_int|0
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|mddev-&gt;recovery_wait
)paren
suffix:semicolon
id|last_check
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|j
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: resuming recovery of %s from checkpoint.&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|mddev-&gt;curr_resync
op_assign
id|j
suffix:semicolon
)brace
r_while
c_loop
(paren
id|j
OL
id|max_sectors
)paren
(brace
r_int
id|sectors
suffix:semicolon
id|sectors
op_assign
id|mddev-&gt;pers
op_member_access_from_pointer
id|sync_request
c_func
(paren
id|mddev
comma
id|j
comma
id|currspeed
OL
id|sysctl_speed_limit_min
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sectors
OL
l_int|0
)paren
(brace
id|set_bit
c_func
(paren
id|MD_RECOVERY_ERR
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|atomic_add
c_func
(paren
id|sectors
comma
op_amp
id|mddev-&gt;recovery_active
)paren
suffix:semicolon
id|j
op_add_assign
id|sectors
suffix:semicolon
r_if
c_cond
(paren
id|j
OG
l_int|1
)paren
id|mddev-&gt;curr_resync
op_assign
id|j
suffix:semicolon
r_if
c_cond
(paren
id|last_check
op_plus
id|window
OG
id|j
op_logical_or
id|j
op_eq
id|max_sectors
)paren
r_continue
suffix:semicolon
id|last_check
op_assign
id|j
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|MD_RECOVERY_INTR
comma
op_amp
id|mddev-&gt;recovery
)paren
op_logical_or
id|test_bit
c_func
(paren
id|MD_RECOVERY_ERR
comma
op_amp
id|mddev-&gt;recovery
)paren
)paren
r_break
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|mark
(braket
id|last_mark
)braket
op_plus
id|SYNC_MARK_STEP
)paren
)paren
(brace
multiline_comment|/* step marks */
r_int
id|next
op_assign
(paren
id|last_mark
op_plus
l_int|1
)paren
op_mod
id|SYNC_MARKS
suffix:semicolon
id|mddev-&gt;resync_mark
op_assign
id|mark
(braket
id|next
)braket
suffix:semicolon
id|mddev-&gt;resync_mark_cnt
op_assign
id|mark_cnt
(braket
id|next
)braket
suffix:semicolon
id|mark
(braket
id|next
)braket
op_assign
id|jiffies
suffix:semicolon
id|mark_cnt
(braket
id|next
)braket
op_assign
id|j
op_minus
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;recovery_active
)paren
suffix:semicolon
id|last_mark
op_assign
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * got a signal, exit.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: md_do_sync() got signal ... exiting&bslash;n&quot;
)paren
suffix:semicolon
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|MD_RECOVERY_INTR
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * this loop exits only if either when we are slower than&n;&t;&t; * the &squot;hard&squot; speed limit, or the system was IO-idle for&n;&t;&t; * a jiffy.&n;&t;&t; * the system might be non-idle CPU-wise, but we only care&n;&t;&t; * about not overloading the IO subsystem. (things like an&n;&t;&t; * e2fsck being done on the RAID array should execute fast)&n;&t;&t; */
id|mddev-&gt;queue
op_member_access_from_pointer
id|unplug_fn
c_func
(paren
id|mddev-&gt;queue
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|currspeed
op_assign
(paren
(paren
r_int
r_int
)paren
(paren
id|j
op_minus
id|mddev-&gt;resync_mark_cnt
)paren
)paren
op_div
l_int|2
op_div
(paren
(paren
id|jiffies
op_minus
id|mddev-&gt;resync_mark
)paren
op_div
id|HZ
op_plus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|currspeed
OG
id|sysctl_speed_limit_min
)paren
(brace
r_if
c_cond
(paren
(paren
id|currspeed
OG
id|sysctl_speed_limit_max
)paren
op_logical_or
op_logical_neg
id|is_mddev_idle
c_func
(paren
id|mddev
)paren
)paren
(brace
id|msleep_interruptible
c_func
(paren
l_int|250
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: %s: sync done.&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * this also signals &squot;finished resyncing&squot; to md_stop&n;&t; */
id|out
suffix:colon
id|mddev-&gt;queue
op_member_access_from_pointer
id|unplug_fn
c_func
(paren
id|mddev-&gt;queue
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|mddev-&gt;recovery_wait
comma
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;recovery_active
)paren
)paren
suffix:semicolon
multiline_comment|/* tell personality that we are finished */
id|mddev-&gt;pers
op_member_access_from_pointer
id|sync_request
c_func
(paren
id|mddev
comma
id|max_sectors
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|MD_RECOVERY_ERR
comma
op_amp
id|mddev-&gt;recovery
)paren
op_logical_and
id|mddev-&gt;curr_resync
OG
l_int|2
op_logical_and
id|mddev-&gt;curr_resync
op_ge
id|mddev-&gt;recovery_cp
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|MD_RECOVERY_INTR
comma
op_amp
id|mddev-&gt;recovery
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: checkpointing recovery of %s.&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|mddev-&gt;recovery_cp
op_assign
id|mddev-&gt;curr_resync
suffix:semicolon
)brace
r_else
id|mddev-&gt;recovery_cp
op_assign
id|MaxSector
suffix:semicolon
)brace
id|md_enter_safemode
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|skip
suffix:colon
id|mddev-&gt;curr_resync
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|resync_wait
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|MD_RECOVERY_DONE
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is regularly called by all per-raid-array threads to&n; * deal with generic issues like resync and super-block update.&n; * Raid personalities that don&squot;t have a thread (linear/raid0) do not&n; * need this as they never do any recovery or update the superblock.&n; *&n; * It does not do any resync itself, but rather &quot;forks&quot; off other threads&n; * to do that as needed.&n; * When it is determined that resync is needed, we set MD_RECOVERY_RUNNING in&n; * &quot;-&gt;recovery&quot; and create a thread at -&gt;sync_thread.&n; * When the thread finishes it sets MD_RECOVERY_DONE (and might set MD_RECOVERY_ERR)&n; * and wakeups up this thread which will reap the thread and finish up.&n; * This thread also removes any faulty devices (with nr_pending == 0).&n; *&n; * The overall approach is:&n; *  1/ if the superblock needs updating, update it.&n; *  2/ If a recovery thread is running, don&squot;t do anything else.&n; *  3/ If recovery has finished, clean up, possibly marking spares active.&n; *  4/ If there are any faulty devices, remove them.&n; *  5/ If array is degraded, try to add spares devices&n; *  6/ If array has spares or is not in-sync, start a resync thread.&n; */
DECL|function|md_check_recovery
r_void
id|md_check_recovery
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|rtmp
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: recovery thread got woken up ...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mddev-&gt;sb_dirty
op_logical_or
id|test_bit
c_func
(paren
id|MD_RECOVERY_NEEDED
comma
op_amp
id|mddev-&gt;recovery
)paren
op_logical_or
id|test_bit
c_func
(paren
id|MD_RECOVERY_DONE
comma
op_amp
id|mddev-&gt;recovery
)paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|mddev_trylock
c_func
(paren
id|mddev
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|spares
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sb_dirty
)paren
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|MD_RECOVERY_RUNNING
comma
op_amp
id|mddev-&gt;recovery
)paren
op_logical_and
op_logical_neg
id|test_bit
c_func
(paren
id|MD_RECOVERY_DONE
comma
op_amp
id|mddev-&gt;recovery
)paren
)paren
(brace
multiline_comment|/* resync/recovery still happening */
id|clear_bit
c_func
(paren
id|MD_RECOVERY_NEEDED
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;sync_thread
)paren
(brace
multiline_comment|/* resync has finished, collect result */
id|md_unregister_thread
c_func
(paren
id|mddev-&gt;sync_thread
)paren
suffix:semicolon
id|mddev-&gt;sync_thread
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|MD_RECOVERY_ERR
comma
op_amp
id|mddev-&gt;recovery
)paren
op_logical_and
op_logical_neg
id|test_bit
c_func
(paren
id|MD_RECOVERY_INTR
comma
op_amp
id|mddev-&gt;recovery
)paren
)paren
(brace
multiline_comment|/* success...*/
multiline_comment|/* activate any spares */
id|mddev-&gt;pers
op_member_access_from_pointer
id|spare_active
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mddev-&gt;recovery
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* flag recovery needed just to double check */
id|set_bit
c_func
(paren
id|MD_RECOVERY_NEEDED
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;recovery
)paren
multiline_comment|/* probably just the RECOVERY_NEEDED flag */
id|mddev-&gt;recovery
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no recovery is running.&n;&t;&t; * remove any failed drives, then&n;&t;&t; * add spares if possible&n;&t;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|rtmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;raid_disk
op_ge
l_int|0
op_logical_and
id|rdev-&gt;faulty
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|rdev-&gt;nr_pending
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|hot_remove_disk
c_func
(paren
id|mddev
comma
id|rdev-&gt;raid_disk
)paren
op_eq
l_int|0
)paren
id|rdev-&gt;raid_disk
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;faulty
op_logical_and
id|rdev-&gt;raid_disk
op_ge
l_int|0
op_logical_and
op_logical_neg
id|rdev-&gt;in_sync
)paren
id|spares
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;degraded
)paren
(brace
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|rtmp
)paren
r_if
c_cond
(paren
id|rdev-&gt;raid_disk
OL
l_int|0
op_logical_and
op_logical_neg
id|rdev-&gt;faulty
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|hot_add_disk
c_func
(paren
id|mddev
comma
id|rdev
)paren
)paren
id|spares
op_increment
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|spares
op_logical_and
(paren
id|mddev-&gt;recovery_cp
op_eq
id|MaxSector
)paren
)paren
(brace
multiline_comment|/* nothing we can do ... */
r_goto
id|unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;pers-&gt;sync_request
)paren
(brace
id|set_bit
c_func
(paren
id|MD_RECOVERY_RUNNING
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spares
)paren
id|set_bit
c_func
(paren
id|MD_RECOVERY_SYNC
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
id|mddev-&gt;sync_thread
op_assign
id|md_register_thread
c_func
(paren
id|md_do_sync
comma
id|mddev
comma
l_string|&quot;%s_resync&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sync_thread
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: could not start resync&quot;
l_string|&quot; thread...&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
multiline_comment|/* leave the spares where they are, it shouldn&squot;t hurt */
id|mddev-&gt;recovery
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;sync_thread
)paren
suffix:semicolon
)brace
)brace
id|unlock
suffix:colon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
)brace
DECL|function|md_notify_reboot
r_int
id|md_notify_reboot
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|code
comma
r_void
op_star
id|x
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|code
op_eq
id|SYS_DOWN
)paren
op_logical_or
(paren
id|code
op_eq
id|SYS_HALT
)paren
op_logical_or
(paren
id|code
op_eq
id|SYS_POWER_OFF
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: stopping all md devices.&bslash;n&quot;
)paren
suffix:semicolon
id|ITERATE_MDDEV
c_func
(paren
id|mddev
comma
id|tmp
)paren
r_if
c_cond
(paren
id|mddev_trylock
c_func
(paren
id|mddev
)paren
op_eq
l_int|0
)paren
id|do_md_stop
(paren
id|mddev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * certain more exotic SCSI devices are known to be&n;&t;&t; * volatile wrt too early system reboots. While the&n;&t;&t; * right place to handle this issue is the given&n;&t;&t; * driver, we do want to have a safe RAID driver ...&n;&t;&t; */
id|mdelay
c_func
(paren
l_int|1000
op_star
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|md_notifier
r_struct
id|notifier_block
id|md_notifier
op_assign
(brace
dot
id|notifier_call
op_assign
id|md_notify_reboot
comma
dot
id|next
op_assign
l_int|NULL
comma
dot
id|priority
op_assign
id|INT_MAX
comma
multiline_comment|/* before any real devices */
)brace
suffix:semicolon
DECL|function|md_geninit
r_static
r_void
id|md_geninit
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|p
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;md: sizeof(mdp_super_t) = %d&bslash;n&quot;
comma
(paren
r_int
)paren
r_sizeof
(paren
id|mdp_super_t
)paren
)paren
suffix:semicolon
id|p
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;mdstat&quot;
comma
id|S_IRUGO
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|p-&gt;proc_fops
op_assign
op_amp
id|md_seq_fops
suffix:semicolon
)brace
DECL|function|md_init
r_int
id|__init
id|md_init
c_func
(paren
r_void
)paren
(brace
r_int
id|minor
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: md driver %d.%d.%d MAX_MD_DEVS=%d,&quot;
l_string|&quot; MD_SB_DISKS=%d&bslash;n&quot;
comma
id|MD_MAJOR_VERSION
comma
id|MD_MINOR_VERSION
comma
id|MD_PATCHLEVEL_VERSION
comma
id|MAX_MD_DEVS
comma
id|MD_SB_DISKS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;md&quot;
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mdp_major
op_assign
id|register_blkdev
c_func
(paren
l_int|0
comma
l_string|&quot;mdp&quot;
)paren
)paren
op_le
l_int|0
)paren
(brace
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;md&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|devfs_mk_dir
c_func
(paren
l_string|&quot;md&quot;
)paren
suffix:semicolon
id|blk_register_region
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
l_int|0
)paren
comma
id|MAX_MD_DEVS
comma
id|THIS_MODULE
comma
id|md_probe
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|blk_register_region
c_func
(paren
id|MKDEV
c_func
(paren
id|mdp_major
comma
l_int|0
)paren
comma
id|MAX_MD_DEVS
op_lshift
id|MdpMinorShift
comma
id|THIS_MODULE
comma
id|md_probe
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|minor
op_assign
l_int|0
suffix:semicolon
id|minor
OL
id|MAX_MD_DEVS
suffix:semicolon
op_increment
id|minor
)paren
id|devfs_mk_bdev
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|minor
)paren
comma
id|S_IFBLK
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
l_string|&quot;md/%d&quot;
comma
id|minor
)paren
suffix:semicolon
r_for
c_loop
(paren
id|minor
op_assign
l_int|0
suffix:semicolon
id|minor
OL
id|MAX_MD_DEVS
suffix:semicolon
op_increment
id|minor
)paren
id|devfs_mk_bdev
c_func
(paren
id|MKDEV
c_func
(paren
id|mdp_major
comma
id|minor
op_lshift
id|MdpMinorShift
)paren
comma
id|S_IFBLK
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
l_string|&quot;md/mdp%d&quot;
comma
id|minor
)paren
suffix:semicolon
id|register_reboot_notifier
c_func
(paren
op_amp
id|md_notifier
)paren
suffix:semicolon
id|raid_table_header
op_assign
id|register_sysctl_table
c_func
(paren
id|raid_root_table
comma
l_int|1
)paren
suffix:semicolon
id|md_geninit
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifndef MODULE
multiline_comment|/*&n; * Searches all registered partitions for autorun RAID arrays&n; * at boot time.&n; */
DECL|variable|detected_devices
r_static
id|dev_t
id|detected_devices
(braket
l_int|128
)braket
suffix:semicolon
DECL|variable|dev_cnt
r_static
r_int
id|dev_cnt
suffix:semicolon
DECL|function|md_autodetect_dev
r_void
id|md_autodetect_dev
c_func
(paren
id|dev_t
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev_cnt
op_ge
l_int|0
op_logical_and
id|dev_cnt
OL
l_int|127
)paren
id|detected_devices
(braket
id|dev_cnt
op_increment
)braket
op_assign
id|dev
suffix:semicolon
)brace
DECL|function|autostart_arrays
r_static
r_void
id|autostart_arrays
c_func
(paren
r_int
id|part
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: Autodetecting RAID arrays.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_t
id|dev
op_assign
id|detected_devices
(braket
id|i
)braket
suffix:semicolon
id|rdev
op_assign
id|md_import_device
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rdev
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|rdev-&gt;same_set
comma
op_amp
id|pending_raid_disks
)paren
suffix:semicolon
)brace
id|dev_cnt
op_assign
l_int|0
suffix:semicolon
id|autorun_devices
c_func
(paren
id|part
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|md_exit
r_static
id|__exit
r_void
id|md_exit
c_func
(paren
r_void
)paren
(brace
id|mddev_t
op_star
id|mddev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|blk_unregister_region
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
l_int|0
)paren
comma
id|MAX_MD_DEVS
)paren
suffix:semicolon
id|blk_unregister_region
c_func
(paren
id|MKDEV
c_func
(paren
id|mdp_major
comma
l_int|0
)paren
comma
id|MAX_MD_DEVS
op_lshift
id|MdpMinorShift
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_MD_DEVS
suffix:semicolon
id|i
op_increment
)paren
id|devfs_remove
c_func
(paren
l_string|&quot;md/%d&quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_MD_DEVS
suffix:semicolon
id|i
op_increment
)paren
id|devfs_remove
c_func
(paren
l_string|&quot;md/d%d&quot;
comma
id|i
)paren
suffix:semicolon
id|devfs_remove
c_func
(paren
l_string|&quot;md&quot;
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;md&quot;
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|mdp_major
comma
l_string|&quot;mdp&quot;
)paren
suffix:semicolon
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|md_notifier
)paren
suffix:semicolon
id|unregister_sysctl_table
c_func
(paren
id|raid_table_header
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;mdstat&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|ITERATE_MDDEV
c_func
(paren
id|mddev
comma
id|tmp
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|mddev-&gt;gendisk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk
)paren
r_continue
suffix:semicolon
id|export_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|del_gendisk
c_func
(paren
id|disk
)paren
suffix:semicolon
id|put_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
id|mddev-&gt;gendisk
op_assign
l_int|NULL
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
)brace
id|module_init
c_func
(paren
id|md_init
)paren
id|module_exit
c_func
(paren
id|md_exit
)paren
id|EXPORT_SYMBOL
c_func
(paren
id|register_md_personality
)paren
suffix:semicolon
DECL|variable|EXPORT_SYMBOL
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_md_personality
)paren
suffix:semicolon
DECL|variable|md_error
id|EXPORT_SYMBOL
c_func
(paren
id|md_error
)paren
suffix:semicolon
DECL|variable|md_done_sync
id|EXPORT_SYMBOL
c_func
(paren
id|md_done_sync
)paren
suffix:semicolon
DECL|variable|md_write_start
id|EXPORT_SYMBOL
c_func
(paren
id|md_write_start
)paren
suffix:semicolon
DECL|variable|md_write_end
id|EXPORT_SYMBOL
c_func
(paren
id|md_write_end
)paren
suffix:semicolon
DECL|variable|md_handle_safemode
id|EXPORT_SYMBOL
c_func
(paren
id|md_handle_safemode
)paren
suffix:semicolon
DECL|variable|md_register_thread
id|EXPORT_SYMBOL
c_func
(paren
id|md_register_thread
)paren
suffix:semicolon
DECL|variable|md_unregister_thread
id|EXPORT_SYMBOL
c_func
(paren
id|md_unregister_thread
)paren
suffix:semicolon
DECL|variable|md_wakeup_thread
id|EXPORT_SYMBOL
c_func
(paren
id|md_wakeup_thread
)paren
suffix:semicolon
DECL|variable|md_print_devices
id|EXPORT_SYMBOL
c_func
(paren
id|md_print_devices
)paren
suffix:semicolon
DECL|variable|md_check_recovery
id|EXPORT_SYMBOL
c_func
(paren
id|md_check_recovery
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
