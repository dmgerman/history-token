multiline_comment|/*&n;   md.c : Multiple Devices driver for Linux&n;&t;  Copyright (C) 1998, 1999, 2000 Ingo Molnar&n;&n;     completely rewritten, based on the MD driver code from Marc Zyngier&n;&n;   Changes:&n;&n;   - RAID-1/RAID-5 extensions by Miguel de Icaza, Gadi Oxman, Ingo Molnar&n;   - boot support for linear and striped mode by Harald Hoyer &lt;HarryH@Royal.Net&gt;&n;   - kerneld support by Boris Tobotras &lt;boris@xtalk.msk.su&gt;&n;   - kmod support by: Cyrus Durgin&n;   - RAID0 bugfixes: Mark Anthony Lisher &lt;markal@iname.com&gt;&n;   - Devfs support by Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&n;   - lots of fixes and improvements to the RAID1/RAID5 and generic&n;     RAID code (such as request based resynchronization):&n;&n;     Neil Brown &lt;neilb@cse.unsw.edu.au&gt;.&n;&n;   This program is free software; you can redistribute it and/or modify&n;   it under the terms of the GNU General Public License as published by&n;   the Free Software Foundation; either version 2, or (at your option)&n;   any later version.&n;&n;   You should have received a copy of the GNU General Public License&n;   (for example /usr/src/linux/COPYING); if not, write to the Free&n;   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;linux/raid/md.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/raid/xor.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MD_MAJOR
DECL|macro|MD_DRIVER
mdefine_line|#define MD_DRIVER
DECL|macro|DEVICE_NR
mdefine_line|#define DEVICE_NR(device) (minor(device))
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|DEBUG
mdefine_line|#define DEBUG 0
macro_line|#if DEBUG
DECL|macro|dprintk
macro_line|# define dprintk(x...) printk(x)
macro_line|#else
DECL|macro|dprintk
macro_line|# define dprintk(x...) do { } while(0)
macro_line|#endif
macro_line|#ifndef MODULE
r_static
r_void
id|autostart_arrays
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|pers
r_static
id|mdk_personality_t
op_star
id|pers
(braket
id|MAX_PERSONALITY
)braket
suffix:semicolon
multiline_comment|/*&n; * Current RAID-1,4,5 parallel reconstruction &squot;guaranteed speed limit&squot;&n; * is 1000 KB/sec, so the extra system load does not show up that much.&n; * Increase it if you want to have more _guaranteed_ speed. Note that&n; * the RAID driver will use the maximum available bandwith if the IO&n; * subsystem is idle. There is also an &squot;absolute maximum&squot; reconstruction&n; * speed limit - in case reconstruction slows down your system despite&n; * idle IO detection.&n; *&n; * you can change it via /proc/sys/dev/raid/speed_limit_min and _max.&n; */
DECL|variable|sysctl_speed_limit_min
r_static
r_int
id|sysctl_speed_limit_min
op_assign
l_int|1000
suffix:semicolon
DECL|variable|sysctl_speed_limit_max
r_static
r_int
id|sysctl_speed_limit_max
op_assign
l_int|200000
suffix:semicolon
DECL|variable|raid_table_header
r_static
r_struct
id|ctl_table_header
op_star
id|raid_table_header
suffix:semicolon
DECL|variable|raid_table
r_static
id|ctl_table
id|raid_table
(braket
)braket
op_assign
(brace
(brace
id|DEV_RAID_SPEED_LIMIT_MIN
comma
l_string|&quot;speed_limit_min&quot;
comma
op_amp
id|sysctl_speed_limit_min
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
id|DEV_RAID_SPEED_LIMIT_MAX
comma
l_string|&quot;speed_limit_max&quot;
comma
op_amp
id|sysctl_speed_limit_max
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|raid_dir_table
r_static
id|ctl_table
id|raid_dir_table
(braket
)braket
op_assign
(brace
(brace
id|DEV_RAID
comma
l_string|&quot;raid&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|raid_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|raid_root_table
r_static
id|ctl_table
id|raid_root_table
(braket
)braket
op_assign
(brace
(brace
id|CTL_DEV
comma
l_string|&quot;dev&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|raid_dir_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * these have to be allocated separately because external&n; * subsystems want to have a pre-defined structure&n; */
DECL|variable|md_hd_struct
r_struct
id|hd_struct
id|md_hd_struct
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
r_static
r_void
id|md_recover_arrays
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|md_recovery_thread
r_static
id|mdk_thread_t
op_star
id|md_recovery_thread
suffix:semicolon
DECL|variable|md_size
r_int
id|md_size
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|variable|md_fops
r_static
r_struct
id|block_device_operations
id|md_fops
suffix:semicolon
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
DECL|variable|md_gendisk
r_static
r_struct
id|gendisk
id|md_gendisk
op_assign
(brace
id|major
suffix:colon
id|MD_MAJOR
comma
id|major_name
suffix:colon
l_string|&quot;md&quot;
comma
id|minor_shift
suffix:colon
l_int|0
comma
id|part
suffix:colon
id|md_hd_struct
comma
id|sizes
suffix:colon
id|md_size
comma
id|nr_real
suffix:colon
id|MAX_MD_DEVS
comma
id|next
suffix:colon
l_int|NULL
comma
id|fops
suffix:colon
op_amp
id|md_fops
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Enables to iterate over all existing md arrays&n; * all_mddevs_lock protects this list as well as mddev_map.&n; */
r_static
id|LIST_HEAD
c_func
(paren
id|all_mddevs
)paren
suffix:semicolon
DECL|variable|all_mddevs_lock
r_static
id|spinlock_t
id|all_mddevs_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * iterates through all used mddevs in the system.&n; * We take care to grab the all_mddevs_lock whenever navigating&n; * the list, and to always hold a refcount when unlocked.&n; * Any code which breaks out of this loop while own&n; * a reference to the current mddev and must mddev_put it.&n; */
DECL|macro|ITERATE_MDDEV
mdefine_line|#define ITERATE_MDDEV(mddev,tmp)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;for (spin_lock(&amp;all_mddevs_lock), &t;&t;&t;&t;&bslash;&n;&t;&t;     (tmp = all_mddevs.next),&t;&t;&t;&t;&bslash;&n;&t;&t;     (mddev = NULL);&t;&t;&t;&t;&t;&bslash;&n;&t;     (void)(tmp != &amp;all_mddevs &amp;&amp;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;mddev_get(list_entry(tmp, mddev_t, all_mddevs))),&bslash;&n;&t;&t;     spin_unlock(&amp;all_mddevs_lock),&t;&t;&t;&bslash;&n;&t;&t;     (mddev ? mddev_put(mddev):(void)NULL),&t;&t;&bslash;&n;&t;&t;     (mddev = list_entry(tmp, mddev_t, all_mddevs)),&t;&bslash;&n;&t;&t;     (tmp != &amp;all_mddevs);&t;&t;&t;&t;&bslash;&n;&t;     spin_lock(&amp;all_mddevs_lock),&t;&t;&t;&t;&bslash;&n;&t;&t;     (tmp = tmp-&gt;next)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;)
DECL|variable|mddev_map
r_static
id|mddev_t
op_star
id|mddev_map
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|function|md_fail_request
r_static
r_int
id|md_fail_request
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|bio_io_error
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mddev_get
r_static
r_inline
id|mddev_t
op_star
id|mddev_get
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|mddev-&gt;active
)paren
suffix:semicolon
r_return
id|mddev
suffix:semicolon
)brace
DECL|function|mddev_put
r_static
r_void
id|mddev_put
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_lock
c_func
(paren
op_amp
id|mddev-&gt;active
comma
op_amp
id|all_mddevs_lock
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|mddev-&gt;all_mddevs
)paren
suffix:semicolon
id|mddev_map
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
)brace
DECL|function|mddev_find
r_static
id|mddev_t
op_star
id|mddev_find
c_func
(paren
r_int
id|unit
)paren
(brace
id|mddev_t
op_star
id|mddev
comma
op_star
r_new
op_assign
l_int|NULL
suffix:semicolon
id|retry
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev_map
(braket
id|unit
)braket
)paren
(brace
id|mddev
op_assign
id|mddev_get
c_func
(paren
id|mddev_map
(braket
id|unit
)braket
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
id|kfree
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
id|mddev
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
)paren
(brace
id|mddev_map
(braket
id|unit
)braket
op_assign
r_new
suffix:semicolon
id|list_add
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|all_mddevs
comma
op_amp
id|all_mddevs
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|all_mddevs_lock
)paren
suffix:semicolon
r_new
op_assign
(paren
id|mddev_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
r_new
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
r_new
comma
l_int|0
comma
r_sizeof
(paren
op_star
r_new
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|__minor
op_assign
id|unit
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|reconfig_sem
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|disks
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|all_mddevs
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|active
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
DECL|function|mddev_lock
r_static
r_inline
r_int
id|mddev_lock
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_return
id|down_interruptible
c_func
(paren
op_amp
id|mddev-&gt;reconfig_sem
)paren
suffix:semicolon
)brace
DECL|function|mddev_trylock
r_static
r_inline
r_int
id|mddev_trylock
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_return
id|down_trylock
c_func
(paren
op_amp
id|mddev-&gt;reconfig_sem
)paren
suffix:semicolon
)brace
DECL|function|mddev_unlock
r_static
r_inline
r_void
id|mddev_unlock
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|up
c_func
(paren
op_amp
id|mddev-&gt;reconfig_sem
)paren
suffix:semicolon
)brace
DECL|function|find_rdev_nr
id|mdk_rdev_t
op_star
id|find_rdev_nr
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|nr
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
id|nr
)paren
r_return
id|rdev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|find_rdev
id|mdk_rdev_t
op_star
id|find_rdev
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|rdev-&gt;dev
comma
id|dev
)paren
)paren
r_return
id|rdev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
id|LIST_HEAD
c_func
(paren
id|device_names
)paren
suffix:semicolon
DECL|function|partition_name
r_char
op_star
id|partition_name
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|gendisk
op_star
id|hd
suffix:semicolon
r_static
r_char
id|nomem
(braket
)braket
op_assign
l_string|&quot;&lt;nomem&gt;&quot;
suffix:semicolon
id|dev_name_t
op_star
id|dname
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|device_names
)paren
(brace
id|dname
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
id|dev_name_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|dname-&gt;dev
comma
id|dev
)paren
)paren
r_return
id|dname-&gt;name
suffix:semicolon
)brace
id|dname
op_assign
(paren
id|dev_name_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|dname
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dname
)paren
r_return
id|nomem
suffix:semicolon
multiline_comment|/*&n;&t; * ok, add this new device name to the list&n;&t; */
id|hd
op_assign
id|get_gendisk
(paren
id|dev
)paren
suffix:semicolon
id|dname-&gt;name
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|hd
)paren
id|dname-&gt;name
op_assign
id|disk_name
(paren
id|hd
comma
id|minor
c_func
(paren
id|dev
)paren
comma
id|dname-&gt;namebuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dname-&gt;name
)paren
(brace
id|sprintf
(paren
id|dname-&gt;namebuf
comma
l_string|&quot;[dev %s]&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|dname-&gt;name
op_assign
id|dname-&gt;namebuf
suffix:semicolon
)brace
id|dname-&gt;dev
op_assign
id|dev
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dname-&gt;list
comma
op_amp
id|device_names
)paren
suffix:semicolon
r_return
id|dname-&gt;name
suffix:semicolon
)brace
DECL|function|calc_dev_sboffset
r_static
r_int
r_int
id|calc_dev_sboffset
c_func
(paren
id|kdev_t
id|dev
comma
id|mddev_t
op_star
id|mddev
comma
r_int
id|persistent
)paren
(brace
r_int
r_int
id|size
op_assign
(paren
id|blkdev_size_in_bytes
c_func
(paren
id|dev
)paren
op_rshift
id|BLOCK_SIZE_BITS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|persistent
)paren
id|size
op_assign
id|MD_NEW_SIZE_BLOCKS
c_func
(paren
id|size
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|calc_dev_size
r_static
r_int
r_int
id|calc_dev_size
c_func
(paren
id|kdev_t
id|dev
comma
id|mddev_t
op_star
id|mddev
comma
r_int
id|persistent
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
id|size
op_assign
id|calc_dev_sboffset
c_func
(paren
id|dev
comma
id|mddev
comma
id|persistent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;sb-&gt;chunk_size
)paren
id|size
op_and_assign
op_complement
(paren
id|mddev-&gt;sb-&gt;chunk_size
op_div
l_int|1024
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|zoned_raid_size
r_static
r_int
r_int
id|zoned_raid_size
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * do size and offset calculations.&n;&t; */
id|mask
op_assign
op_complement
(paren
id|mddev-&gt;sb-&gt;chunk_size
op_div
l_int|1024
op_minus
l_int|1
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|rdev-&gt;size
op_and_assign
id|mask
suffix:semicolon
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_add_assign
id|rdev-&gt;size
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|remove_descriptor
r_static
r_void
id|remove_descriptor
c_func
(paren
id|mdp_disk_t
op_star
id|disk
comma
id|mdp_super_t
op_star
id|sb
)paren
(brace
r_if
c_cond
(paren
id|disk_active
c_func
(paren
id|disk
)paren
)paren
(brace
id|sb-&gt;working_disks
op_decrement
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|disk_spare
c_func
(paren
id|disk
)paren
)paren
(brace
id|sb-&gt;spare_disks
op_decrement
suffix:semicolon
id|sb-&gt;working_disks
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|sb-&gt;failed_disks
op_decrement
suffix:semicolon
)brace
)brace
id|sb-&gt;nr_disks
op_decrement
suffix:semicolon
id|disk-&gt;major
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;minor
op_assign
l_int|0
suffix:semicolon
id|mark_disk_removed
c_func
(paren
id|disk
)paren
suffix:semicolon
)brace
DECL|macro|BAD_MAGIC
mdefine_line|#define BAD_MAGIC KERN_ERR &bslash;&n;&quot;md: invalid raid superblock magic on %s&bslash;n&quot;
DECL|macro|BAD_MINOR
mdefine_line|#define BAD_MINOR KERN_ERR &bslash;&n;&quot;md: %s: invalid raid minor (%x)&bslash;n&quot;
DECL|macro|OUT_OF_MEM
mdefine_line|#define OUT_OF_MEM KERN_ALERT &bslash;&n;&quot;md: out of memory.&bslash;n&quot;
DECL|macro|NO_SB
mdefine_line|#define NO_SB KERN_ERR &bslash;&n;&quot;md: disabled device %s, could not read superblock.&bslash;n&quot;
DECL|macro|BAD_CSUM
mdefine_line|#define BAD_CSUM KERN_WARNING &bslash;&n;&quot;md: invalid superblock checksum on %s&bslash;n&quot;
DECL|function|alloc_array_sb
r_static
r_int
id|alloc_array_sb
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mddev-&gt;sb
op_assign
(paren
id|mdp_super_t
op_star
)paren
id|__get_free_page
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|clear_page
c_func
(paren
id|mddev-&gt;sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|alloc_disk_sb
r_static
r_int
id|alloc_disk_sb
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;sb_page
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|rdev-&gt;sb_page
op_assign
id|alloc_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb_page
)paren
(brace
id|printk
c_func
(paren
id|OUT_OF_MEM
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev-&gt;sb
op_assign
(paren
id|mdp_super_t
op_star
)paren
id|page_address
c_func
(paren
id|rdev-&gt;sb_page
)paren
suffix:semicolon
id|clear_page
c_func
(paren
id|rdev-&gt;sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|free_disk_sb
r_static
r_void
id|free_disk_sb
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;sb_page
)paren
(brace
id|page_cache_release
c_func
(paren
id|rdev-&gt;sb_page
)paren
suffix:semicolon
id|rdev-&gt;sb
op_assign
l_int|NULL
suffix:semicolon
id|rdev-&gt;sb_page
op_assign
l_int|NULL
suffix:semicolon
id|rdev-&gt;sb_offset
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;size
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;faulty
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|bi_complete
r_static
r_void
id|bi_complete
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|complete
c_func
(paren
(paren
r_struct
id|completion
op_star
)paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
)brace
DECL|function|sync_page_io
r_static
r_int
id|sync_page_io
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|sector
comma
r_int
id|size
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|rw
)paren
(brace
r_struct
id|bio
id|bio
suffix:semicolon
r_struct
id|bio_vec
id|vec
suffix:semicolon
r_struct
id|completion
id|event
suffix:semicolon
id|bio_init
c_func
(paren
op_amp
id|bio
)paren
suffix:semicolon
id|bio.bi_io_vec
op_assign
op_amp
id|vec
suffix:semicolon
id|vec.bv_page
op_assign
id|page
suffix:semicolon
id|vec.bv_len
op_assign
id|size
suffix:semicolon
id|vec.bv_offset
op_assign
l_int|0
suffix:semicolon
id|bio.bi_vcnt
op_assign
l_int|1
suffix:semicolon
id|bio.bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio.bi_size
op_assign
id|size
suffix:semicolon
id|bio.bi_bdev
op_assign
id|bdev
suffix:semicolon
id|bio.bi_sector
op_assign
id|sector
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|bio.bi_private
op_assign
op_amp
id|event
suffix:semicolon
id|bio.bi_end_io
op_assign
id|bi_complete
suffix:semicolon
id|submit_bio
c_func
(paren
id|rw
comma
op_amp
id|bio
)paren
suffix:semicolon
id|blk_run_queues
c_func
(paren
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
r_return
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio.bi_flags
)paren
suffix:semicolon
)brace
DECL|function|read_disk_sb
r_static
r_int
id|read_disk_sb
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_int
r_int
id|sb_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Calculate the position of the superblock,&n;&t; * it&squot;s at the end of the disk.&n;&t; *&n;&t; * It also happens to be a multiple of 4Kb.&n;&t; */
id|sb_offset
op_assign
id|calc_dev_sboffset
c_func
(paren
id|rdev-&gt;dev
comma
id|rdev-&gt;mddev
comma
l_int|1
)paren
suffix:semicolon
id|rdev-&gt;sb_offset
op_assign
id|sb_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sync_page_io
c_func
(paren
id|rdev-&gt;bdev
comma
id|sb_offset
op_lshift
l_int|1
comma
id|MD_SB_BYTES
comma
id|rdev-&gt;sb_page
comma
id|READ
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; [events: %08lx]&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|rdev-&gt;sb-&gt;events_lo
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|printk
c_func
(paren
id|NO_SB
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|calc_sb_csum
r_static
r_int
r_int
id|calc_sb_csum
c_func
(paren
id|mdp_super_t
op_star
id|sb
)paren
(brace
r_int
r_int
id|disk_csum
comma
id|csum
suffix:semicolon
id|disk_csum
op_assign
id|sb-&gt;sb_csum
suffix:semicolon
id|sb-&gt;sb_csum
op_assign
l_int|0
suffix:semicolon
id|csum
op_assign
id|csum_partial
c_func
(paren
(paren
r_void
op_star
)paren
id|sb
comma
id|MD_SB_BYTES
comma
l_int|0
)paren
suffix:semicolon
id|sb-&gt;sb_csum
op_assign
id|disk_csum
suffix:semicolon
r_return
id|csum
suffix:semicolon
)brace
multiline_comment|/*&n; * Check one RAID superblock for generic plausibility&n; */
DECL|function|check_disk_sb
r_static
r_int
id|check_disk_sb
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|mdp_super_t
op_star
id|sb
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|sb
op_assign
id|rdev-&gt;sb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sb-&gt;md_magic
op_ne
id|MD_SB_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|BAD_MAGIC
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sb-&gt;md_minor
op_ge
id|MAX_MD_DEVS
)paren
(brace
id|printk
c_func
(paren
id|BAD_MINOR
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|sb-&gt;md_minor
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|calc_sb_csum
c_func
(paren
id|sb
)paren
op_ne
id|sb-&gt;sb_csum
)paren
(brace
id|printk
c_func
(paren
id|BAD_CSUM
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
m_abort
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|match_dev_unit
r_static
id|mdk_rdev_t
op_star
id|match_dev_unit
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|dev
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
r_if
c_cond
(paren
id|rdev-&gt;bdev-&gt;bd_contains
op_eq
id|dev-&gt;bdev-&gt;bd_contains
)paren
r_return
id|rdev
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|match_mddev_units
r_static
r_int
id|match_mddev_units
c_func
(paren
id|mddev_t
op_star
id|mddev1
comma
id|mddev_t
op_star
id|mddev2
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev1
comma
id|rdev
comma
id|tmp
)paren
r_if
c_cond
(paren
id|match_dev_unit
c_func
(paren
id|mddev2
comma
id|rdev
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|LIST_HEAD
c_func
(paren
id|all_raid_disks
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|pending_raid_disks
)paren
suffix:semicolon
DECL|function|bind_rdev_to_array
r_static
r_void
id|bind_rdev_to_array
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
comma
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|same_pdev
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|same_pdev
op_assign
id|match_dev_unit
c_func
(paren
id|mddev
comma
id|rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|same_pdev
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md%d: WARNING: %s appears to be on the same physical disk as %s. True&bslash;n&quot;
l_string|&quot;     protection against single-disk failure might be compromised.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|partition_name
c_func
(paren
id|same_pdev-&gt;dev
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|rdev-&gt;same_set
comma
op_amp
id|mddev-&gt;disks
)paren
suffix:semicolon
id|rdev-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: bind&lt;%s&gt;&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
)brace
DECL|function|unbind_rdev_from_array
r_static
r_void
id|unbind_rdev_from_array
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|list_del_init
c_func
(paren
op_amp
id|rdev-&gt;same_set
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: unbind&lt;%s&gt;&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|rdev-&gt;mddev
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * prevent the device from being mounted, repartitioned or&n; * otherwise reused by a RAID array (or any other kernel&n; * subsystem), by opening the device. [simply getting an&n; * inode is not enough, the SCSI module usage code needs&n; * an explicit open() on the device]&n; */
DECL|function|lock_rdev
r_static
r_int
id|lock_rdev
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
id|bdev
op_assign
id|bdget
c_func
(paren
id|kdev_t_to_nr
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|err
op_assign
id|blkdev_get
c_func
(paren
id|bdev
comma
id|FMODE_READ
op_or
id|FMODE_WRITE
comma
l_int|0
comma
id|BDEV_RAW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|err
op_assign
id|bd_claim
c_func
(paren
id|bdev
comma
id|lock_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|blkdev_put
c_func
(paren
id|bdev
comma
id|BDEV_RAW
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|rdev-&gt;bdev
op_assign
id|bdev
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|unlock_rdev
r_static
r_void
id|unlock_rdev
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
op_assign
id|rdev-&gt;bdev
suffix:semicolon
id|rdev-&gt;bdev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdev
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|bd_release
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|bdev
comma
id|BDEV_RAW
)paren
suffix:semicolon
)brace
r_void
id|md_autodetect_dev
c_func
(paren
id|kdev_t
id|dev
)paren
suffix:semicolon
DECL|function|export_rdev
r_static
r_void
id|export_rdev
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: export_rdev(%s)&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;mddev
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|unlock_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|free_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|rdev-&gt;all
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|rdev-&gt;pending
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: (%s was pending)&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|rdev-&gt;pending
)paren
suffix:semicolon
)brace
macro_line|#ifndef MODULE
id|md_autodetect_dev
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
macro_line|#endif
id|rdev-&gt;dev
op_assign
id|NODEV
suffix:semicolon
id|rdev-&gt;faulty
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
DECL|function|kick_rdev_from_array
r_static
r_void
id|kick_rdev_from_array
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|unbind_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
DECL|function|export_array
r_static
r_void
id|export_array
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sb
)paren
(brace
id|mddev-&gt;sb
op_assign
l_int|NULL
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|sb
)paren
suffix:semicolon
)brace
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|free_mddev
r_static
r_void
id|free_mddev
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|export_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
l_int|0
suffix:semicolon
id|md_hd_struct
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
DECL|macro|BAD_CSUM
macro_line|#undef BAD_CSUM
DECL|macro|BAD_MAGIC
macro_line|#undef BAD_MAGIC
DECL|macro|OUT_OF_MEM
macro_line|#undef OUT_OF_MEM
DECL|macro|NO_SB
macro_line|#undef NO_SB
DECL|function|print_desc
r_static
r_void
id|print_desc
c_func
(paren
id|mdp_disk_t
op_star
id|desc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; DISK&lt;N:%d,%s(%d,%d),R:%d,S:%d&gt;&bslash;n&quot;
comma
id|desc-&gt;number
comma
id|partition_name
c_func
(paren
id|mk_kdev
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
)paren
comma
id|desc-&gt;major
comma
id|desc-&gt;minor
comma
id|desc-&gt;raid_disk
comma
id|desc-&gt;state
)paren
suffix:semicolon
)brace
DECL|function|print_sb
r_static
r_void
id|print_sb
c_func
(paren
id|mdp_super_t
op_star
id|sb
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md:  SB: (V:%d.%d.%d) ID:&lt;%08x.%08x.%08x.%08x&gt; CT:%08x&bslash;n&quot;
comma
id|sb-&gt;major_version
comma
id|sb-&gt;minor_version
comma
id|sb-&gt;patch_version
comma
id|sb-&gt;set_uuid0
comma
id|sb-&gt;set_uuid1
comma
id|sb-&gt;set_uuid2
comma
id|sb-&gt;set_uuid3
comma
id|sb-&gt;ctime
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md:     L%d S%08d ND:%d RD:%d md%d LO:%d CS:%d&bslash;n&quot;
comma
id|sb-&gt;level
comma
id|sb-&gt;size
comma
id|sb-&gt;nr_disks
comma
id|sb-&gt;raid_disks
comma
id|sb-&gt;md_minor
comma
id|sb-&gt;layout
comma
id|sb-&gt;chunk_size
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md:     UT:%08x ST:%d AD:%d WD:%d FD:%d SD:%d CSUM:%08x E:%08lx&bslash;n&quot;
comma
id|sb-&gt;utime
comma
id|sb-&gt;state
comma
id|sb-&gt;active_disks
comma
id|sb-&gt;working_disks
comma
id|sb-&gt;failed_disks
comma
id|sb-&gt;spare_disks
comma
id|sb-&gt;sb_csum
comma
(paren
r_int
r_int
)paren
id|sb-&gt;events_lo
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|desc-&gt;number
op_logical_or
id|desc-&gt;major
op_logical_or
id|desc-&gt;minor
op_logical_or
id|desc-&gt;raid_disk
op_logical_or
(paren
id|desc-&gt;state
op_logical_and
(paren
id|desc-&gt;state
op_ne
l_int|4
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;     D %2d: &quot;
comma
id|i
)paren
suffix:semicolon
id|print_desc
c_func
(paren
id|desc
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md:     THIS: &quot;
)paren
suffix:semicolon
id|print_desc
c_func
(paren
op_amp
id|sb-&gt;this_disk
)paren
suffix:semicolon
)brace
DECL|function|print_rdev
r_static
r_void
id|print_rdev
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: rdev %s: O:%s, SZ:%08ld F:%d DN:%d &quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|partition_name
c_func
(paren
id|rdev-&gt;old_dev
)paren
comma
id|rdev-&gt;size
comma
id|rdev-&gt;faulty
comma
id|rdev-&gt;desc_nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;sb
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: rdev superblock:&bslash;n&quot;
)paren
suffix:semicolon
id|print_sb
c_func
(paren
id|rdev-&gt;sb
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: no rdev superblock!&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|md_print_devices
r_void
id|md_print_devices
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
comma
op_star
id|tmp2
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md:&t;**********************************&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md:&t;* &lt;COMPLETE RAID STATE PRINTOUT&gt; *&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;md:&t;**********************************&bslash;n&quot;
)paren
suffix:semicolon
id|ITERATE_MDDEV
c_func
(paren
id|mddev
comma
id|tmp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;md%d: &quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp2
)paren
id|printk
c_func
(paren
l_string|&quot;&lt;%s&gt;&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sb
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; array superblock:&bslash;n&quot;
)paren
suffix:semicolon
id|print_sb
c_func
(paren
id|mddev-&gt;sb
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; no array superblock.&bslash;n&quot;
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp2
)paren
id|print_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;md:&t;**********************************&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|sb_equal
r_static
r_int
id|sb_equal
c_func
(paren
id|mdp_super_t
op_star
id|sb1
comma
id|mdp_super_t
op_star
id|sb2
)paren
(brace
r_int
id|ret
suffix:semicolon
id|mdp_super_t
op_star
id|tmp1
comma
op_star
id|tmp2
suffix:semicolon
id|tmp1
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|tmp1
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|tmp2
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|tmp2
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp1
op_logical_or
op_logical_neg
id|tmp2
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md.c: sb1 is not equal to sb2!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
op_star
id|tmp1
op_assign
op_star
id|sb1
suffix:semicolon
op_star
id|tmp2
op_assign
op_star
id|sb2
suffix:semicolon
multiline_comment|/*&n;&t; * nr_disks is not constant&n;&t; */
id|tmp1-&gt;nr_disks
op_assign
l_int|0
suffix:semicolon
id|tmp2-&gt;nr_disks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|tmp1
comma
id|tmp2
comma
id|MD_SB_GENERIC_CONSTANT_WORDS
op_star
l_int|4
)paren
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
r_else
id|ret
op_assign
l_int|1
suffix:semicolon
m_abort
suffix:colon
r_if
c_cond
(paren
id|tmp1
)paren
id|kfree
c_func
(paren
id|tmp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp2
)paren
id|kfree
c_func
(paren
id|tmp2
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|uuid_equal
r_static
r_int
id|uuid_equal
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev1
comma
id|mdk_rdev_t
op_star
id|rdev2
)paren
(brace
r_if
c_cond
(paren
(paren
id|rdev1-&gt;sb-&gt;set_uuid0
op_eq
id|rdev2-&gt;sb-&gt;set_uuid0
)paren
op_logical_and
(paren
id|rdev1-&gt;sb-&gt;set_uuid1
op_eq
id|rdev2-&gt;sb-&gt;set_uuid1
)paren
op_logical_and
(paren
id|rdev1-&gt;sb-&gt;set_uuid2
op_eq
id|rdev2-&gt;sb-&gt;set_uuid2
)paren
op_logical_and
(paren
id|rdev1-&gt;sb-&gt;set_uuid3
op_eq
id|rdev2-&gt;sb-&gt;set_uuid3
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|find_rdev_all
r_static
id|mdk_rdev_t
op_star
id|find_rdev_all
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|all_raid_disks
)paren
(brace
id|rdev
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
id|mdk_rdev_t
comma
id|all
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|rdev-&gt;dev
comma
id|dev
)paren
)paren
r_return
id|rdev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|write_disk_sb
r_static
r_int
id|write_disk_sb
c_func
(paren
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|kdev_t
id|dev
op_assign
id|rdev-&gt;dev
suffix:semicolon
r_int
r_int
id|sb_offset
comma
id|size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;sb-&gt;md_magic
op_ne
id|MD_SB_MAGIC
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|sb_offset
op_assign
id|calc_dev_sboffset
c_func
(paren
id|dev
comma
id|rdev-&gt;mddev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;sb_offset
op_ne
id|sb_offset
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&squot;s sb offset has changed from %ld to %ld, skipping&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|rdev-&gt;sb_offset
comma
id|sb_offset
)paren
suffix:semicolon
r_goto
id|skip
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the disk went offline meanwhile and it&squot;s just a spare, then&n;&t; * its size has changed to zero silently, and the MD code does&n;&t; * not yet know that it&squot;s faulty.&n;&t; */
id|size
op_assign
id|calc_dev_size
c_func
(paren
id|dev
comma
id|rdev-&gt;mddev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ne
id|rdev-&gt;size
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&squot;s size has changed from %ld to %ld since import, skipping&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|rdev-&gt;size
comma
id|size
)paren
suffix:semicolon
r_goto
id|skip
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(write) %s&squot;s sb offset: %ld&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|sb_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sync_page_io
c_func
(paren
id|rdev-&gt;bdev
comma
id|sb_offset
op_lshift
l_int|1
comma
id|MD_SB_BYTES
comma
id|rdev-&gt;sb_page
comma
id|WRITE
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|skip
suffix:colon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|printk
c_func
(paren
l_string|&quot;md: write_disk_sb failed for device %s&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|set_this_disk
r_static
r_void
id|set_this_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_int
id|i
comma
id|ok
op_assign
l_int|0
suffix:semicolon
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|desc
op_assign
id|mddev-&gt;sb-&gt;disks
op_plus
id|i
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|desc
)paren
)paren
(brace
r_if
c_cond
(paren
id|mk_kdev
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
op_eq
id|rdev-&gt;dev
)paren
id|ok
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|mk_kdev
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
comma
id|rdev-&gt;dev
)paren
)paren
(brace
id|rdev-&gt;sb-&gt;this_disk
op_assign
op_star
id|desc
suffix:semicolon
id|rdev-&gt;desc_nr
op_assign
id|desc-&gt;number
suffix:semicolon
id|ok
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ok
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|sync_sbs
r_static
r_int
id|sync_sbs
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mdp_super_t
op_star
id|sb
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
op_logical_or
id|rdev-&gt;alias_device
)paren
r_continue
suffix:semicolon
id|sb
op_assign
id|rdev-&gt;sb
suffix:semicolon
op_star
id|sb
op_assign
op_star
id|mddev-&gt;sb
suffix:semicolon
id|set_this_disk
c_func
(paren
id|mddev
comma
id|rdev
)paren
suffix:semicolon
id|sb-&gt;sb_csum
op_assign
id|calc_sb_csum
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__md_update_sb
r_void
id|__md_update_sb
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|err
comma
id|count
op_assign
l_int|100
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|0
suffix:semicolon
id|repeat
suffix:colon
id|mddev-&gt;sb-&gt;utime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_increment
id|mddev-&gt;sb-&gt;events_lo
)paren
)paren
op_increment
id|mddev-&gt;sb-&gt;events_hi
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mddev-&gt;sb-&gt;events_lo
op_or
id|mddev-&gt;sb-&gt;events_hi
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * oops, this 64-bit counter should never wrap.&n;&t;&t; * Either we are in around ~1 trillion A.C., assuming&n;&t;&t; * 1 reboot per second, or we have a bug:&n;&t;&t; */
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|mddev-&gt;sb-&gt;events_lo
op_assign
id|mddev-&gt;sb-&gt;events_hi
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
id|sync_sbs
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * do not write anything to disk if using&n;&t; * nonpersistent superblocks&n;&t; */
r_if
c_cond
(paren
id|mddev-&gt;sb-&gt;not_persistent
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: updating md%d RAID superblock on device&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
id|printk
c_func
(paren
l_string|&quot;(skipping faulty &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;alias_device
)paren
id|printk
c_func
(paren
l_string|&quot;(skipping alias &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;faulty
op_logical_and
op_logical_neg
id|rdev-&gt;alias_device
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;[events: %08lx]&quot;
comma
(paren
r_int
r_int
)paren
id|rdev-&gt;sb-&gt;events_lo
)paren
suffix:semicolon
id|err
op_add_assign
id|write_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: errors occurred during superblock update, repeating&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: excessive errors occurred during superblock update, exiting&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|md_update_sb
r_void
id|md_update_sb
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
id|mddev_lock
c_func
(paren
id|mddev
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sb_dirty
)paren
id|__md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Import a device. If &squot;on_disk&squot;, then sanity check the superblock&n; *&n; * mark the device faulty if:&n; *&n; *   - the device is nonexistent (zero size)&n; *   - the device has no valid superblock&n; *&n; * a faulty rdev _never_ has rdev-&gt;sb set.&n; */
DECL|function|md_import_device
r_static
r_int
id|md_import_device
c_func
(paren
id|kdev_t
id|newdev
comma
r_int
id|on_disk
)paren
(brace
r_int
id|err
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|find_rdev_all
c_func
(paren
id|newdev
)paren
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
id|rdev
op_assign
(paren
id|mdk_rdev_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rdev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: could not alloc mem for %s!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|newdev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|rdev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|rdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|alloc_disk_sb
c_func
(paren
id|rdev
)paren
)paren
)paren
r_goto
id|abort_free
suffix:semicolon
id|rdev-&gt;dev
op_assign
id|newdev
suffix:semicolon
r_if
c_cond
(paren
id|lock_rdev
c_func
(paren
id|rdev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: could not lock %s, zero-size? Marking faulty.&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|newdev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_free
suffix:semicolon
)brace
id|rdev-&gt;desc_nr
op_assign
op_minus
l_int|1
suffix:semicolon
id|rdev-&gt;faulty
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
(paren
id|blkdev_size_in_bytes
c_func
(paren
id|newdev
)paren
op_rshift
id|BLOCK_SIZE_BITS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s has zero or unknown size, marking faulty!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|newdev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_free
suffix:semicolon
)brace
r_if
c_cond
(paren
id|on_disk
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|read_disk_sb
c_func
(paren
id|rdev
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: could not read %s&squot;s sb, not importing!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|newdev
)paren
)paren
suffix:semicolon
r_goto
id|abort_free
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|check_disk_sb
c_func
(paren
id|rdev
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s has invalid sb, not importing!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|newdev
)paren
)paren
suffix:semicolon
r_goto
id|abort_free
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;sb-&gt;level
op_ne
op_minus
l_int|4
)paren
(brace
id|rdev-&gt;old_dev
op_assign
id|mk_kdev
c_func
(paren
id|rdev-&gt;sb-&gt;this_disk.major
comma
id|rdev-&gt;sb-&gt;this_disk.minor
)paren
suffix:semicolon
id|rdev-&gt;desc_nr
op_assign
id|rdev-&gt;sb-&gt;this_disk.number
suffix:semicolon
)brace
r_else
(brace
id|rdev-&gt;old_dev
op_assign
id|NODEV
suffix:semicolon
id|rdev-&gt;desc_nr
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|list_add
c_func
(paren
op_amp
id|rdev-&gt;all
comma
op_amp
id|all_raid_disks
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rdev-&gt;pending
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rdev-&gt;same_set
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
op_logical_and
id|rdev-&gt;sb
)paren
id|free_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|abort_free
suffix:colon
r_if
c_cond
(paren
id|rdev-&gt;sb
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;bdev
)paren
id|unlock_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|free_disk_sb
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Check a full RAID array for plausibility&n; */
DECL|macro|INCONSISTENT
mdefine_line|#define INCONSISTENT KERN_ERR &bslash;&n;&quot;md: fatal superblock inconsistency in %s -- removing from array&bslash;n&quot;
DECL|macro|OUT_OF_DATE
mdefine_line|#define OUT_OF_DATE KERN_ERR &bslash;&n;&quot;md: superblock update time inconsistency -- using the most recent one&bslash;n&quot;
DECL|macro|OLD_VERSION
mdefine_line|#define OLD_VERSION KERN_ALERT &bslash;&n;&quot;md: md%d: unsupported raid array version %d.%d.%d&bslash;n&quot;
DECL|macro|NOT_CLEAN_IGNORE
mdefine_line|#define NOT_CLEAN_IGNORE KERN_ERR &bslash;&n;&quot;md: md%d: raid array is not clean -- starting background reconstruction&bslash;n&quot;
DECL|macro|UNKNOWN_LEVEL
mdefine_line|#define UNKNOWN_LEVEL KERN_ERR &bslash;&n;&quot;md: md%d: unsupported raid level %d&bslash;n&quot;
DECL|function|analyze_sbs
r_static
r_int
id|analyze_sbs
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|out_of_date
op_assign
l_int|0
comma
id|i
comma
id|first
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
comma
op_star
id|tmp2
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
comma
op_star
id|rdev2
comma
op_star
id|freshest
suffix:semicolon
id|mdp_super_t
op_star
id|sb
suffix:semicolon
multiline_comment|/*&n;&t; * Verify the RAID superblock on each real device&n;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_disk_sb
c_func
(paren
id|rdev
)paren
)paren
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The superblock constant part has to be the same&n;&t; * for all disks in the array.&n;&t; */
id|sb
op_assign
l_int|NULL
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
(brace
id|sb
op_assign
id|rdev-&gt;sb
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sb_equal
c_func
(paren
id|sb
comma
id|rdev-&gt;sb
)paren
)paren
(brace
id|printk
c_func
(paren
id|INCONSISTENT
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * OK, we have all disks and the array is ready to run. Let&squot;s&n;&t; * find the freshest superblock, that one will be the superblock&n;&t; * that represents the whole array.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
r_if
c_cond
(paren
id|alloc_array_sb
c_func
(paren
id|mddev
)paren
)paren
r_goto
m_abort
suffix:semicolon
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|freshest
op_assign
l_int|NULL
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|__u64
id|ev1
comma
id|ev2
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if the checksum is invalid, use the superblock&n;&t;&t; * only as a last resort. (decrease it&squot;s age by&n;&t;&t; * one event)&n;&t;&t; */
r_if
c_cond
(paren
id|calc_sb_csum
c_func
(paren
id|rdev-&gt;sb
)paren
op_ne
id|rdev-&gt;sb-&gt;sb_csum
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;sb-&gt;events_lo
op_logical_or
id|rdev-&gt;sb-&gt;events_hi
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|rdev-&gt;sb-&gt;events_lo
op_decrement
)paren
)paren
id|rdev-&gt;sb-&gt;events_hi
op_decrement
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: %s&squot;s event counter: %08lx&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
(paren
r_int
r_int
)paren
id|rdev-&gt;sb-&gt;events_lo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|freshest
)paren
(brace
id|freshest
op_assign
id|rdev
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Find the newest superblock version&n;&t;&t; */
id|ev1
op_assign
id|md_event
c_func
(paren
id|rdev-&gt;sb
)paren
suffix:semicolon
id|ev2
op_assign
id|md_event
c_func
(paren
id|freshest-&gt;sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ev1
op_ne
id|ev2
)paren
(brace
id|out_of_date
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ev1
OG
id|ev2
)paren
id|freshest
op_assign
id|rdev
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|out_of_date
)paren
(brace
id|printk
c_func
(paren
id|OUT_OF_DATE
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: freshest: %s&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|freshest-&gt;dev
)paren
)paren
suffix:semicolon
)brace
id|memcpy
(paren
id|sb
comma
id|freshest-&gt;sb
comma
r_sizeof
(paren
op_star
id|sb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * at this point we have picked the &squot;best&squot; superblock&n;&t; * from all available superblocks.&n;&t; * now we validate this superblock and kick out possibly&n;&t; * failed disks.&n;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
multiline_comment|/*&n;&t;&t; * Kick all non-fresh devices&n;&t;&t; */
id|__u64
id|ev1
comma
id|ev2
suffix:semicolon
id|ev1
op_assign
id|md_event
c_func
(paren
id|rdev-&gt;sb
)paren
suffix:semicolon
id|ev2
op_assign
id|md_event
c_func
(paren
id|sb
)paren
suffix:semicolon
op_increment
id|ev1
suffix:semicolon
r_if
c_cond
(paren
id|ev1
OL
id|ev2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: kicking non-fresh %s from array!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Fix up changed device names ... but only if this disk has a&n;&t; * recent update time. Use faulty checksum ones too.&n;&t; */
r_if
c_cond
(paren
id|mddev-&gt;sb-&gt;level
op_ne
op_minus
l_int|4
)paren
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|__u64
id|ev1
comma
id|ev2
comma
id|ev3
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
op_logical_or
id|rdev-&gt;alias_device
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|ev1
op_assign
id|md_event
c_func
(paren
id|rdev-&gt;sb
)paren
suffix:semicolon
id|ev2
op_assign
id|md_event
c_func
(paren
id|sb
)paren
suffix:semicolon
id|ev3
op_assign
id|ev2
suffix:semicolon
op_decrement
id|ev3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kdev_same
c_func
(paren
id|rdev-&gt;dev
comma
id|rdev-&gt;old_dev
)paren
op_logical_and
(paren
(paren
id|ev1
op_eq
id|ev2
)paren
op_logical_or
(paren
id|ev1
op_eq
id|ev3
)paren
)paren
)paren
(brace
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: device name has changed from %s to %s since last import!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;old_dev
)paren
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|desc
op_assign
op_amp
id|sb-&gt;disks
(braket
id|rdev-&gt;desc_nr
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kdev_same
c_func
(paren
id|rdev-&gt;old_dev
comma
id|mk_kdev
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|desc-&gt;major
op_assign
id|major
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
id|desc-&gt;minor
op_assign
id|minor
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
id|desc
op_assign
op_amp
id|rdev-&gt;sb-&gt;this_disk
suffix:semicolon
id|desc-&gt;major
op_assign
id|major
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
id|desc-&gt;minor
op_assign
id|minor
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Remove unavailable and faulty devices ...&n;&t; *&n;&t; * note that if an array becomes completely unrunnable due to&n;&t; * missing devices, we do not write the superblock back, so the&n;&t; * administrator has a chance to fix things up. The removal thus&n;&t; * only happens if it&squot;s nonfatal to the contents of the array.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|found
suffix:semicolon
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|i
suffix:semicolon
id|dev
op_assign
id|mk_kdev
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We kick faulty devices/descriptors immediately.&n;&t;&t; *&n;&t;&t; * Note: multipath devices are a special case.  Since we&n;&t;&t; * were able to read the superblock on the path, we don&squot;t&n;&t;&t; * care if it was previously marked as faulty, it&squot;s up now&n;&t;&t; * so enable it.&n;&t;&t; */
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|desc
)paren
op_logical_and
id|mddev-&gt;sb-&gt;level
op_ne
op_minus
l_int|4
)paren
(brace
id|found
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_ne
id|desc-&gt;number
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md%d: kicking faulty %s!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
r_if
c_cond
(paren
id|kdev_none
c_func
(paren
id|dev
)paren
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md%d: removing former faulty %s!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
)brace
id|remove_descriptor
c_func
(paren
id|desc
comma
id|sb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|desc
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * multipath entry marked as faulty, unfaulty it&n;&t;&t;&t; */
id|rdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev
)paren
(brace
id|mark_disk_spare
c_func
(paren
id|desc
)paren
suffix:semicolon
)brace
r_else
id|remove_descriptor
c_func
(paren
id|desc
comma
id|sb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kdev_none
c_func
(paren
id|dev
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Is this device present in the rdev ring?&n;&t;&t; */
id|found
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Multi-path IO special-case: since we have no&n;&t;&t;&t; * this_disk descriptor at auto-detect time,&n;&t;&t;&t; * we cannot check rdev-&gt;number.&n;&t;&t;&t; * We can check the device though.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|sb-&gt;level
op_eq
op_minus
l_int|4
)paren
op_logical_and
id|kdev_same
c_func
(paren
id|rdev-&gt;dev
comma
id|mk_kdev
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
id|desc-&gt;number
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md%d: former device %s is unavailable, removing from array!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|remove_descriptor
c_func
(paren
id|desc
comma
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Double check wether all devices mentioned in the&n;&t; * superblock are in the rdev ring.&n;&t; */
id|first
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|i
suffix:semicolon
id|dev
op_assign
id|mk_kdev
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kdev_none
c_func
(paren
id|dev
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|desc
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * In the case of Multipath-IO, we have no&n;&t;&t; * other information source to find out which&n;&t;&t; * disk is which, only the position of the device&n;&t;&t; * in the superblock:&n;&t;&t; */
r_if
c_cond
(paren
id|mddev-&gt;sb-&gt;level
op_eq
op_minus
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|rdev-&gt;desc_nr
op_ne
op_minus
l_int|1
)paren
op_logical_and
(paren
id|rdev-&gt;desc_nr
op_ne
id|i
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|rdev-&gt;desc_nr
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
id|rdev-&gt;alias_device
op_assign
l_int|1
suffix:semicolon
r_else
id|first
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Kick all rdevs that are not in the&n;&t; * descriptor array:&n;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
op_minus
l_int|1
)paren
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do a final reality check.&n;&t; */
r_if
c_cond
(paren
id|mddev-&gt;sb-&gt;level
op_ne
op_minus
l_int|4
)paren
(brace
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * is the desc_nr unique?&n;&t;&t;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev2
comma
id|tmp2
)paren
(brace
r_if
c_cond
(paren
(paren
id|rdev2
op_ne
id|rdev
)paren
op_logical_and
(paren
id|rdev2-&gt;desc_nr
op_eq
id|rdev-&gt;desc_nr
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * is the device unique?&n;&t;&t;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev2
comma
id|tmp2
)paren
(brace
r_if
c_cond
(paren
id|rdev2
op_ne
id|rdev
op_logical_and
id|kdev_same
c_func
(paren
id|rdev2-&gt;dev
comma
id|rdev-&gt;dev
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Check if we can support this RAID array&n;&t; */
r_if
c_cond
(paren
id|sb-&gt;major_version
op_ne
id|MD_MAJOR_VERSION
op_logical_or
id|sb-&gt;minor_version
OG
id|MD_MINOR_VERSION
)paren
(brace
id|printk
c_func
(paren
id|OLD_VERSION
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;major_version
comma
id|sb-&gt;minor_version
comma
id|sb-&gt;patch_version
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sb-&gt;state
op_ne
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
)paren
op_logical_and
(paren
(paren
id|sb-&gt;level
op_eq
l_int|1
)paren
op_logical_or
(paren
id|sb-&gt;level
op_eq
l_int|4
)paren
op_logical_or
(paren
id|sb-&gt;level
op_eq
l_int|5
)paren
)paren
)paren
id|printk
c_func
(paren
id|NOT_CLEAN_IGNORE
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
m_abort
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|INCONSISTENT
macro_line|#undef INCONSISTENT
DECL|macro|OUT_OF_DATE
macro_line|#undef OUT_OF_DATE
DECL|macro|OLD_VERSION
macro_line|#undef OLD_VERSION
DECL|macro|OLD_LEVEL
macro_line|#undef OLD_LEVEL
DECL|function|device_size_calculation
r_static
r_int
id|device_size_calculation
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|data_disks
op_assign
l_int|0
comma
id|persistent
suffix:semicolon
r_int
r_int
id|readahead
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
multiline_comment|/*&n;&t; * Do device size calculation. Bail out if too small.&n;&t; * (we have to do this after having validated chunk_size,&n;&t; * because device size has to be modulo chunk_size)&n;&t; */
id|persistent
op_assign
op_logical_neg
id|mddev-&gt;sb-&gt;not_persistent
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;size
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rdev-&gt;size
op_assign
id|calc_dev_size
c_func
(paren
id|rdev-&gt;dev
comma
id|mddev
comma
id|persistent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;size
OL
id|sb-&gt;chunk_size
op_div
l_int|1024
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: Dev %s smaller than chunk_size: %ldk &lt; %dk&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|rdev-&gt;size
comma
id|sb-&gt;chunk_size
op_div
l_int|1024
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|sb-&gt;level
)paren
(brace
r_case
op_minus
l_int|4
suffix:colon
id|data_disks
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
l_int|3
suffix:colon
id|data_disks
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
l_int|2
suffix:colon
id|data_disks
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
l_int|1
suffix:colon
id|zoned_raid_size
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|data_disks
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
id|zoned_raid_size
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|data_disks
op_assign
id|sb-&gt;raid_disks
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|data_disks
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_case
l_int|5
suffix:colon
id|data_disks
op_assign
id|sb-&gt;raid_disks
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|UNKNOWN_LEVEL
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;level
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
)paren
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
id|sb-&gt;size
op_star
id|data_disks
suffix:semicolon
id|readahead
op_assign
(paren
id|VM_MAX_READAHEAD
op_star
l_int|1024
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;level
op_logical_or
(paren
id|sb-&gt;level
op_eq
l_int|4
)paren
op_logical_or
(paren
id|sb-&gt;level
op_eq
l_int|5
)paren
)paren
(brace
id|readahead
op_assign
(paren
id|mddev-&gt;sb-&gt;chunk_size
op_rshift
id|PAGE_SHIFT
)paren
op_star
l_int|4
op_star
id|data_disks
suffix:semicolon
r_if
c_cond
(paren
id|readahead
OL
id|data_disks
op_star
(paren
id|MAX_SECTORS
op_rshift
(paren
id|PAGE_SHIFT
op_minus
l_int|9
)paren
)paren
op_star
l_int|2
)paren
id|readahead
op_assign
id|data_disks
op_star
(paren
id|MAX_SECTORS
op_rshift
(paren
id|PAGE_SHIFT
op_minus
l_int|9
)paren
)paren
op_star
l_int|2
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// (no multipath branch - it uses the default setting)
r_if
c_cond
(paren
id|sb-&gt;level
op_eq
op_minus
l_int|3
)paren
id|readahead
op_assign
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md%d: max total readahead window set to %ldk&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|readahead
op_star
(paren
id|PAGE_SIZE
op_div
l_int|1024
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md%d: %d data-disks, max readahead per data-disk: %ldk&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|data_disks
comma
id|readahead
op_div
id|data_disks
op_star
(paren
id|PAGE_SIZE
op_div
l_int|1024
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
m_abort
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|TOO_BIG_CHUNKSIZE
mdefine_line|#define TOO_BIG_CHUNKSIZE KERN_ERR &bslash;&n;&quot;too big chunk_size: %d &gt; %d&bslash;n&quot;
DECL|macro|TOO_SMALL_CHUNKSIZE
mdefine_line|#define TOO_SMALL_CHUNKSIZE KERN_ERR &bslash;&n;&quot;too small chunk_size: %d &lt; %ld&bslash;n&quot;
DECL|macro|BAD_CHUNKSIZE
mdefine_line|#define BAD_CHUNKSIZE KERN_ERR &bslash;&n;&quot;no chunksize specified, see &squot;man raidtab&squot;&bslash;n&quot;
DECL|function|do_md_run
r_static
r_int
id|do_md_run
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|pnum
comma
id|err
suffix:semicolon
r_int
id|chunk_size
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t; * Resize disks to align partitions size on a given&n;&t; * chunk size.&n;&t; */
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Analyze all RAID superblock(s)&n;&t; */
r_if
c_cond
(paren
id|analyze_sbs
c_func
(paren
id|mddev
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|chunk_size
op_assign
id|mddev-&gt;sb-&gt;chunk_size
suffix:semicolon
id|pnum
op_assign
id|level_to_pers
c_func
(paren
id|mddev-&gt;sb-&gt;level
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pnum
op_ne
id|MULTIPATH
)paren
op_logical_and
(paren
id|pnum
op_ne
id|RAID1
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|chunk_size
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * &squot;default chunksize&squot; in the old md code used to&n;&t;&t;&t; * be PAGE_SIZE, baaad.&n;&t;&t;&t; * we abort here to be on the safe side. We dont&n;&t;&t;&t; * want to continue the bad practice.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|BAD_CHUNKSIZE
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chunk_size
OG
id|MAX_CHUNK_SIZE
)paren
(brace
id|printk
c_func
(paren
id|TOO_BIG_CHUNKSIZE
comma
id|chunk_size
comma
id|MAX_CHUNK_SIZE
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * chunk-size has to be a power of 2 and multiples of PAGE_SIZE&n;&t;&t; */
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|ffz
c_func
(paren
op_complement
id|chunk_size
)paren
)paren
op_ne
id|chunk_size
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chunk_size
OL
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
id|TOO_SMALL_CHUNKSIZE
comma
id|chunk_size
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|chunk_size
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: RAID level %d does not need chunksize! Continuing anyway.&bslash;n&quot;
comma
id|mddev-&gt;sb-&gt;level
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pnum
op_ge
id|MAX_PERSONALITY
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pers
(braket
id|pnum
)braket
)paren
(brace
macro_line|#ifdef CONFIG_KMOD
r_char
id|module_name
(braket
l_int|80
)braket
suffix:semicolon
id|sprintf
(paren
id|module_name
comma
l_string|&quot;md-personality-%d&quot;
comma
id|pnum
)paren
suffix:semicolon
id|request_module
(paren
id|module_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pers
(braket
id|pnum
)braket
)paren
macro_line|#endif
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: personality %d is not loaded!&bslash;n&quot;
comma
id|pnum
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|device_size_calculation
c_func
(paren
id|mddev
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * Drop all container device buffers, from now on&n;&t; * the only valid external interface is through the md&n;&t; * device.&n;&t; * Also find largest hardsector size&n;&t; */
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
r_continue
suffix:semicolon
id|invalidate_device
c_func
(paren
id|rdev-&gt;dev
comma
l_int|1
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; * Aside of obvious breakage (code below results in block size set&n;&t; * according to the sector size of last component instead of the&n;&t; * maximal sector size), we have more interesting problem here.&n;&t; * Namely, we actually ought to set _sector_ size for the array&n;&t; * and that requires per-array request queues.  Disabled for now.&n;&t; */
id|md_blocksizes
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|bdev_hardsect_size
c_func
(paren
id|rdev-&gt;bdev
)paren
OG
id|md_blocksizes
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
)paren
id|md_blocksizes
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_assign
id|bdev_hardsect_size
c_func
(paren
id|rdev-&gt;bdev
)paren
suffix:semicolon
macro_line|#endif
)brace
id|mddev-&gt;pers
op_assign
id|pers
(braket
id|pnum
)braket
suffix:semicolon
id|blk_queue_make_request
c_func
(paren
op_amp
id|mddev-&gt;queue
comma
id|mddev-&gt;pers-&gt;make_request
)paren
suffix:semicolon
id|mddev-&gt;queue.queuedata
op_assign
id|mddev
suffix:semicolon
id|err
op_assign
id|mddev-&gt;pers
op_member_access_from_pointer
id|run
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: pers-&gt;run() failed ...&bslash;n&quot;
)paren
suffix:semicolon
id|mddev-&gt;pers
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mddev-&gt;in_sync
op_assign
(paren
id|mddev-&gt;sb-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
)paren
suffix:semicolon
multiline_comment|/* if personality doesn&squot;t have &quot;sync_request&quot;, then&n;&t; * a dirty array doesn&squot;t mean anything&n;&t; */
r_if
c_cond
(paren
id|mddev-&gt;pers-&gt;sync_request
)paren
id|mddev-&gt;sb-&gt;state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
suffix:semicolon
id|__md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|md_recover_arrays
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * md_size has units of 1K blocks, which are&n;&t; * twice as large as sectors.&n;&t; */
id|md_hd_struct
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|register_disk
c_func
(paren
op_amp
id|md_gendisk
comma
id|mk_kdev
c_func
(paren
id|MAJOR_NR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
comma
l_int|1
comma
op_amp
id|md_fops
comma
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
op_lshift
l_int|1
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|macro|TOO_BIG_CHUNKSIZE
macro_line|#undef TOO_BIG_CHUNKSIZE
DECL|macro|BAD_CHUNKSIZE
macro_line|#undef BAD_CHUNKSIZE
DECL|function|restart_array
r_static
r_int
id|restart_array
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * Complain if it has no devices&n;&t; */
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
(brace
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;ro
)paren
r_goto
id|out
suffix:semicolon
id|mddev-&gt;ro
op_assign
l_int|0
suffix:semicolon
id|set_device_ro
c_func
(paren
id|mddev_to_kdev
c_func
(paren
id|mddev
)paren
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: md%d switched to read-write mode.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Kick recovery or resync if necessary&n;&t;&t; */
id|md_recover_arrays
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: md%d has no personality assigned.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|macro|STILL_MOUNTED
mdefine_line|#define STILL_MOUNTED KERN_WARNING &bslash;&n;&quot;md: md%d still mounted.&bslash;n&quot;
DECL|macro|STILL_IN_USE
mdefine_line|#define&t;STILL_IN_USE &bslash;&n;&quot;md: md%d still in use.&bslash;n&quot;
DECL|function|do_md_stop
r_static
r_int
id|do_md_stop
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|ro
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|mddev_to_kdev
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;active
)paren
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|STILL_IN_USE
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;sync_thread
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;recovery_running
OG
l_int|0
)paren
id|mddev-&gt;recovery_running
op_assign
op_minus
id|EINTR
suffix:semicolon
id|md_unregister_thread
c_func
(paren
id|mddev-&gt;sync_thread
)paren
suffix:semicolon
id|mddev-&gt;sync_thread
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;spare
)paren
(brace
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|mddev-&gt;spare
comma
id|DISKOP_SPARE_INACTIVE
)paren
suffix:semicolon
id|mddev-&gt;spare
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|invalidate_device
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ro
)paren
(brace
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
r_goto
id|out
suffix:semicolon
id|mddev-&gt;ro
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
id|set_device_ro
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|stop
c_func
(paren
id|mddev
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
id|set_device_ro
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
id|mddev-&gt;ro
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;sb
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * mark it clean only if there was no resync&n;&t;&t;&t; * interrupted.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|mddev-&gt;in_sync
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: marking sb clean...&bslash;n&quot;
)paren
suffix:semicolon
id|mddev-&gt;sb-&gt;state
op_or_assign
l_int|1
op_lshift
id|MD_SB_CLEAN
suffix:semicolon
)brace
id|__md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ro
)paren
id|set_device_ro
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Free resources if final stop&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ro
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: md%d stopped.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|free_mddev
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: md%d switched to read-only mode.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * We have to safely support old arrays too.&n; */
DECL|function|detect_old_array
r_int
id|detect_old_array
c_func
(paren
id|mdp_super_t
op_star
id|sb
)paren
(brace
r_if
c_cond
(paren
id|sb-&gt;major_version
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;minor_version
op_ge
l_int|90
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|autorun_array
r_static
r_void
id|autorun_array
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: running: &quot;
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&lt;%s&gt;&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|do_md_run
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md :do_md_run() returned %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * prevent the writeback of an unrunnable array&n;&t;&t; */
id|mddev-&gt;sb_dirty
op_assign
l_int|0
suffix:semicolon
id|do_md_stop
(paren
id|mddev
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * lets try to run arrays based on all disks that have arrived&n; * until now. (those are in the -&gt;pending list)&n; *&n; * the method: pick the first pending disk, collect all disks with&n; * the same UUID, remove all from the pending list and put them into&n; * the &squot;same_array&squot; list. Then order this list based on superblock&n; * update time (freshest comes first), kick out &squot;old&squot; disks and&n; * compare superblocks. If everything&squot;s fine then run it.&n; *&n; * If &quot;unit&quot; is allocated, then bump its reference count&n; */
DECL|function|autorun_devices
r_static
r_void
id|autorun_devices
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
id|candidates
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev0
comma
op_star
id|rdev
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: autorun ...&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|pending_raid_disks
)paren
)paren
(brace
id|rdev0
op_assign
id|list_entry
c_func
(paren
id|pending_raid_disks.next
comma
id|mdk_rdev_t
comma
id|pending
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: considering %s ...&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev0-&gt;dev
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|candidates
)paren
suffix:semicolon
id|ITERATE_RDEV_PENDING
c_func
(paren
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|uuid_equal
c_func
(paren
id|rdev0
comma
id|rdev
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sb_equal
c_func
(paren
id|rdev0-&gt;sb
comma
id|rdev-&gt;sb
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s has same UUID as %s, but superblocks differ ...&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|partition_name
c_func
(paren
id|rdev0-&gt;dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md:  adding %s ...&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|rdev-&gt;pending
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|rdev-&gt;pending
comma
op_amp
id|candidates
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * now we have a set of devices, with all of them having&n;&t;&t; * mostly sane superblocks. It&squot;s time to allocate the&n;&t;&t; * mddev.&n;&t;&t; */
id|mddev
op_assign
id|mddev_find
c_func
(paren
id|rdev0-&gt;sb-&gt;md_minor
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: cannot allocate memory for md drive.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev_lock
c_func
(paren
id|mddev
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: md%d locked, cannot run&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mddev-&gt;sb
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: md%d already running, cannot run %s&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|rdev0-&gt;dev
)paren
)paren
suffix:semicolon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: created md%d&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|ITERATE_RDEV_GENERIC
c_func
(paren
id|candidates
comma
id|pending
comma
id|rdev
comma
id|tmp
)paren
(brace
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|rdev-&gt;pending
)paren
suffix:semicolon
)brace
id|autorun_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
multiline_comment|/* on success, candidates will be empty, on error&n;&t;&t; * it wont...&n;&t;&t; */
id|ITERATE_RDEV_GENERIC
c_func
(paren
id|candidates
comma
id|pending
comma
id|rdev
comma
id|tmp
)paren
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: ... autorun DONE.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * import RAID devices based on one partition&n; * if possible, the array gets run as well.&n; */
DECL|macro|BAD_VERSION
mdefine_line|#define BAD_VERSION KERN_ERR &bslash;&n;&quot;md: %s has RAID superblock version 0.%d, autodetect needs v0.90 or higher&bslash;n&quot;
DECL|macro|OUT_OF_MEM
mdefine_line|#define OUT_OF_MEM KERN_ALERT &bslash;&n;&quot;md: out of memory.&bslash;n&quot;
DECL|macro|NO_DEVICE
mdefine_line|#define NO_DEVICE KERN_ERR &bslash;&n;&quot;md: disabled device %s&bslash;n&quot;
DECL|macro|AUTOADD_FAILED
mdefine_line|#define AUTOADD_FAILED KERN_ERR &bslash;&n;&quot;md: auto-adding devices to md%d FAILED (error %d).&bslash;n&quot;
DECL|macro|AUTOADD_FAILED_USED
mdefine_line|#define AUTOADD_FAILED_USED KERN_ERR &bslash;&n;&quot;md: cannot auto-add device %s to md%d, already used.&bslash;n&quot;
DECL|macro|AUTORUN_FAILED
mdefine_line|#define AUTORUN_FAILED KERN_ERR &bslash;&n;&quot;md: auto-running md%d FAILED (error %d).&bslash;n&quot;
DECL|macro|MDDEV_BUSY
mdefine_line|#define MDDEV_BUSY KERN_ERR &bslash;&n;&quot;md: cannot auto-add to md%d, already running.&bslash;n&quot;
DECL|macro|AUTOADDING
mdefine_line|#define AUTOADDING KERN_INFO &bslash;&n;&quot;md: auto-adding devices to md%d, based on %s&squot;s superblock.&bslash;n&quot;
DECL|macro|AUTORUNNING
mdefine_line|#define AUTORUNNING KERN_INFO &bslash;&n;&quot;md: auto-running md%d.&bslash;n&quot;
DECL|function|autostart_array
r_static
r_int
id|autostart_array
c_func
(paren
id|kdev_t
id|startdev
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EINVAL
comma
id|i
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
l_int|NULL
suffix:semicolon
id|mdk_rdev_t
op_star
id|start_rdev
op_assign
l_int|NULL
comma
op_star
id|rdev
suffix:semicolon
r_if
c_cond
(paren
id|md_import_device
c_func
(paren
id|startdev
comma
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: could not import %s!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|startdev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|start_rdev
op_assign
id|find_rdev_all
c_func
(paren
id|startdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|start_rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start_rdev-&gt;faulty
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: can not autostart based on faulty %s!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|startdev
)paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|start_rdev-&gt;pending
comma
op_amp
id|pending_raid_disks
)paren
suffix:semicolon
id|sb
op_assign
id|start_rdev-&gt;sb
suffix:semicolon
id|err
op_assign
id|detect_old_array
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: array version is too old to be autostarted ,&quot;
l_string|&quot;use raidtools 0.90 mkraid --upgrade to upgrade the array &quot;
l_string|&quot;without data loss!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdp_disk_t
op_star
id|desc
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|desc
op_assign
id|sb-&gt;disks
op_plus
id|i
suffix:semicolon
id|dev
op_assign
id|mk_kdev
c_func
(paren
id|desc-&gt;major
comma
id|desc-&gt;minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kdev_none
c_func
(paren
id|dev
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|dev
comma
id|startdev
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|md_import_device
c_func
(paren
id|dev
comma
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: could not import %s, trying to run array nevertheless.&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev_all
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|rdev-&gt;pending
comma
op_amp
id|pending_raid_disks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * possibly return codes&n;&t; */
id|autorun_devices
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
m_abort
suffix:colon
r_if
c_cond
(paren
id|start_rdev
)paren
id|export_rdev
c_func
(paren
id|start_rdev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|macro|BAD_VERSION
macro_line|#undef BAD_VERSION
DECL|macro|OUT_OF_MEM
macro_line|#undef OUT_OF_MEM
DECL|macro|NO_DEVICE
macro_line|#undef NO_DEVICE
DECL|macro|AUTOADD_FAILED_USED
macro_line|#undef AUTOADD_FAILED_USED
DECL|macro|AUTOADD_FAILED
macro_line|#undef AUTOADD_FAILED
DECL|macro|AUTORUN_FAILED
macro_line|#undef AUTORUN_FAILED
DECL|macro|AUTOADDING
macro_line|#undef AUTOADDING
DECL|macro|AUTORUNNING
macro_line|#undef AUTORUNNING
DECL|function|get_version
r_static
r_int
id|get_version
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
id|mdu_version_t
id|ver
suffix:semicolon
id|ver.major
op_assign
id|MD_MAJOR_VERSION
suffix:semicolon
id|ver.minor
op_assign
id|MD_MINOR_VERSION
suffix:semicolon
id|ver.patchlevel
op_assign
id|MD_PATCHLEVEL_VERSION
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|ver
comma
r_sizeof
(paren
id|ver
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SET_FROM_SB
mdefine_line|#define SET_FROM_SB(x) info.x = mddev-&gt;sb-&gt;x
DECL|function|get_array_info
r_static
r_int
id|get_array_info
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_void
op_star
id|arg
)paren
(brace
id|mdu_array_info_t
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|SET_FROM_SB
c_func
(paren
id|major_version
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|minor_version
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|patch_version
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|ctime
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|level
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|size
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|nr_disks
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|raid_disks
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|md_minor
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|not_persistent
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|utime
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|state
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|active_disks
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|working_disks
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|failed_disks
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|spare_disks
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|layout
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|chunk_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SET_FROM_SB
macro_line|#undef SET_FROM_SB
DECL|macro|SET_FROM_SB
mdefine_line|#define SET_FROM_SB(x) info.x = mddev-&gt;sb-&gt;disks[nr].x
DECL|function|get_disk_info
r_static
r_int
id|get_disk_info
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_void
op_star
id|arg
)paren
(brace
id|mdu_disk_info_t
id|info
suffix:semicolon
r_int
r_int
id|nr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
id|arg
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|nr
op_assign
id|info.number
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ge
id|MD_SB_DISKS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|major
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|minor
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|raid_disk
)paren
suffix:semicolon
id|SET_FROM_SB
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SET_FROM_SB
macro_line|#undef SET_FROM_SB
DECL|macro|SET_SB
mdefine_line|#define SET_SB(x) mddev-&gt;sb-&gt;disks[nr].x = info-&gt;x
DECL|function|add_new_disk
r_static
r_int
id|add_new_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdu_disk_info_t
op_star
id|info
)paren
(brace
r_int
id|err
comma
id|size
comma
id|persistent
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_int
r_int
id|nr
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|dev
op_assign
id|mk_kdev
c_func
(paren
id|info-&gt;major
comma
id|info-&gt;minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_rdev_all
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: device %s already used in a RAID array!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
)paren
(brace
multiline_comment|/* expecting a device which has a superblock */
id|err
op_assign
id|md_import_device
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: md_import_device returned %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev_all
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev0
op_assign
id|list_entry
c_func
(paren
id|mddev-&gt;disks.next
comma
id|mdk_rdev_t
comma
id|same_set
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uuid_equal
c_func
(paren
id|rdev0
comma
id|rdev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s has different UUID to %s&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|partition_name
c_func
(paren
id|rdev0-&gt;dev
)paren
)paren
suffix:semicolon
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sb_equal
c_func
(paren
id|rdev0-&gt;sb
comma
id|rdev-&gt;sb
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s has same UUID but different superblock to %s&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|partition_name
c_func
(paren
id|rdev0-&gt;dev
)paren
)paren
suffix:semicolon
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|nr
op_assign
id|info-&gt;number
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ge
id|mddev-&gt;sb-&gt;nr_disks
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|SET_SB
c_func
(paren
id|number
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|major
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|minor
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|raid_disk
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_DISK_FAULTY
)paren
)paren
)paren
(brace
id|err
op_assign
id|md_import_device
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: error, md_import_device() returned %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev_all
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev-&gt;old_dev
op_assign
id|dev
suffix:semicolon
id|rdev-&gt;desc_nr
op_assign
id|info-&gt;number
suffix:semicolon
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
suffix:semicolon
id|persistent
op_assign
op_logical_neg
id|mddev-&gt;sb-&gt;not_persistent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|persistent
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: nonpersistent superblock ...&bslash;n&quot;
)paren
suffix:semicolon
id|size
op_assign
id|calc_dev_size
c_func
(paren
id|dev
comma
id|mddev
comma
id|persistent
)paren
suffix:semicolon
id|rdev-&gt;sb_offset
op_assign
id|calc_dev_sboffset
c_func
(paren
id|dev
comma
id|mddev
comma
id|persistent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb-&gt;size
op_logical_or
(paren
id|mddev-&gt;sb-&gt;size
OG
id|size
)paren
)paren
id|mddev-&gt;sb-&gt;size
op_assign
id|size
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * sync all other superblocks with the main superblock&n;&t; */
id|sync_sbs
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SET_SB
macro_line|#undef SET_SB
DECL|function|hot_generate_error
r_static
r_int
id|hot_generate_error
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
r_struct
id|request_queue
op_star
id|q
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mdp_disk_t
op_star
id|disk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: trying to generate %s error in md%d ... &bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|rdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|disk
op_assign
op_amp
id|mddev-&gt;sb-&gt;disks
(braket
id|rdev-&gt;desc_nr
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk_active
c_func
(paren
id|disk
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|q
op_assign
id|bdev_get_queue
c_func
(paren
id|rdev-&gt;bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: okay, generating error!&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|//&t;q-&gt;oneshot_error = 1; // disabled for now
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hot_remove_disk
r_static
r_int
id|hot_remove_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
r_int
id|err
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mdp_disk_t
op_star
id|disk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: trying to remove %s from md%d ... &bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers-&gt;diskop
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md%d: personality does not support diskops!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|disk
op_assign
op_amp
id|mddev-&gt;sb-&gt;disks
(braket
id|rdev-&gt;desc_nr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|disk_active
c_func
(paren
id|disk
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
id|busy
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disk_removed
c_func
(paren
id|disk
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|err
op_assign
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|disk
comma
id|DISKOP_HOT_REMOVE_DISK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EBUSY
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
id|busy
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|remove_descriptor
c_func
(paren
id|disk
comma
id|mddev-&gt;sb
)paren
suffix:semicolon
id|kick_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|__md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|busy
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: cannot remove active disk %s from md%d ... &bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
DECL|function|hot_add_disk
r_static
r_int
id|hot_add_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
r_int
id|i
comma
id|err
comma
id|persistent
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mdp_disk_t
op_star
id|disk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: trying to hot-add %s to md%d ... &bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers-&gt;diskop
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md%d: personality does not support diskops!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|persistent
op_assign
op_logical_neg
id|mddev-&gt;sb-&gt;not_persistent
suffix:semicolon
id|size
op_assign
id|calc_dev_size
c_func
(paren
id|dev
comma
id|mddev
comma
id|persistent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|mddev-&gt;sb-&gt;size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md%d: disk size %d blocks &lt; array size %d&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|size
comma
id|mddev-&gt;sb-&gt;size
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|err
op_assign
id|md_import_device
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: error, md_import_device() returned %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rdev
op_assign
id|find_rdev_all
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: can not hot-add faulty %s disk to md%d!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_export
suffix:semicolon
)brace
id|bind_rdev_to_array
c_func
(paren
id|rdev
comma
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The rest should better be atomic, we can have disk failures&n;&t; * noticed in interrupt contexts ...&n;&t; */
id|rdev-&gt;old_dev
op_assign
id|dev
suffix:semicolon
id|rdev-&gt;size
op_assign
id|size
suffix:semicolon
id|rdev-&gt;sb_offset
op_assign
id|calc_dev_sboffset
c_func
(paren
id|dev
comma
id|mddev
comma
id|persistent
)paren
suffix:semicolon
id|disk
op_assign
id|mddev-&gt;sb-&gt;disks
op_plus
id|mddev-&gt;sb-&gt;raid_disks
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|mddev-&gt;sb-&gt;raid_disks
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|disk
op_assign
id|mddev-&gt;sb-&gt;disks
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk-&gt;major
op_logical_and
op_logical_neg
id|disk-&gt;minor
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|disk_removed
c_func
(paren
id|disk
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|MD_SB_DISKS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md%d: can not hot-add to full array!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|abort_unbind_export
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disk_removed
c_func
(paren
id|disk
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * reuse slot&n;&t;&t; */
r_if
c_cond
(paren
id|disk-&gt;number
op_ne
id|i
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_unbind_export
suffix:semicolon
)brace
)brace
r_else
(brace
id|disk-&gt;number
op_assign
id|i
suffix:semicolon
)brace
id|disk-&gt;raid_disk
op_assign
id|disk-&gt;number
suffix:semicolon
id|disk-&gt;major
op_assign
id|major
c_func
(paren
id|dev
)paren
suffix:semicolon
id|disk-&gt;minor
op_assign
id|minor
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|disk
comma
id|DISKOP_HOT_ADD_DISK
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_unbind_export
suffix:semicolon
)brace
id|mark_disk_spare
c_func
(paren
id|disk
)paren
suffix:semicolon
id|mddev-&gt;sb-&gt;nr_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb-&gt;spare_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb-&gt;working_disks
op_increment
suffix:semicolon
id|__md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Kick recovery, maybe this spare has to be added to the&n;&t; * array immediately.&n;&t; */
id|md_recover_arrays
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|abort_unbind_export
suffix:colon
id|unbind_rdev_from_array
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|abort_export
suffix:colon
id|export_rdev
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|macro|SET_SB
mdefine_line|#define SET_SB(x) mddev-&gt;sb-&gt;x = info-&gt;x
DECL|function|set_array_info
r_static
r_int
id|set_array_info
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdu_array_info_t
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|alloc_array_sb
c_func
(paren
id|mddev
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|mddev-&gt;sb-&gt;major_version
op_assign
id|MD_MAJOR_VERSION
suffix:semicolon
id|mddev-&gt;sb-&gt;minor_version
op_assign
id|MD_MINOR_VERSION
suffix:semicolon
id|mddev-&gt;sb-&gt;patch_version
op_assign
id|MD_PATCHLEVEL_VERSION
suffix:semicolon
id|mddev-&gt;sb-&gt;ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|SET_SB
c_func
(paren
id|level
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|size
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|nr_disks
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|raid_disks
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|md_minor
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|not_persistent
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|state
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|active_disks
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|working_disks
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|failed_disks
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|spare_disks
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|layout
)paren
suffix:semicolon
id|SET_SB
c_func
(paren
id|chunk_size
)paren
suffix:semicolon
id|mddev-&gt;sb-&gt;md_magic
op_assign
id|MD_SB_MAGIC
suffix:semicolon
multiline_comment|/*&n;&t; * Generate a 128 bit UUID&n;&t; */
id|get_random_bytes
c_func
(paren
op_amp
id|mddev-&gt;sb-&gt;set_uuid0
comma
l_int|4
)paren
suffix:semicolon
id|get_random_bytes
c_func
(paren
op_amp
id|mddev-&gt;sb-&gt;set_uuid1
comma
l_int|4
)paren
suffix:semicolon
id|get_random_bytes
c_func
(paren
op_amp
id|mddev-&gt;sb-&gt;set_uuid2
comma
l_int|4
)paren
suffix:semicolon
id|get_random_bytes
c_func
(paren
op_amp
id|mddev-&gt;sb-&gt;set_uuid3
comma
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SET_SB
macro_line|#undef SET_SB
DECL|function|set_disk_faulty
r_static
r_int
id|set_disk_faulty
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|rdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
r_return
l_int|0
suffix:semicolon
id|ret
op_assign
id|md_error
c_func
(paren
id|mddev
comma
id|rdev-&gt;bdev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|md_ioctl
r_static
r_int
id|md_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|minor
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|hd_geometry
op_star
id|loc
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
l_int|NULL
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|dev
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
id|minor
op_assign
id|minor
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|MAX_MD_DEVS
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commands dealing with the RAID driver but not any&n;&t; * particular array:&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|RAID_VERSION
suffix:colon
id|err
op_assign
id|get_version
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
id|PRINT_RAID_DEBUG
suffix:colon
id|err
op_assign
l_int|0
suffix:semicolon
id|md_print_devices
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#ifndef MODULE
r_case
id|RAID_AUTORUN
suffix:colon
id|err
op_assign
l_int|0
suffix:semicolon
id|autostart_arrays
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
macro_line|#endif
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* Return device size */
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|err
op_assign
id|put_user
c_func
(paren
id|md_hd_struct
(braket
id|minor
)braket
dot
id|nr_sects
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
id|BLKGETSIZE64
suffix:colon
multiline_comment|/* Return device size */
id|err
op_assign
id|put_user
c_func
(paren
(paren
id|u64
)paren
id|md_hd_struct
(braket
id|minor
)braket
dot
id|nr_sects
op_lshift
l_int|9
comma
(paren
id|u64
op_star
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
r_case
id|BLKBSZGET
suffix:colon
r_case
id|BLKBSZSET
suffix:colon
id|err
op_assign
id|blk_ioctl
c_func
(paren
id|inode-&gt;i_bdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commands creating/starting a new array:&n;&t; */
id|mddev
op_assign
id|inode-&gt;i_bdev-&gt;bd_inode-&gt;u.generic_ip
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|err
op_assign
id|mddev_lock
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: ioctl lock interrupted, reason %d, cmd %d&bslash;n&quot;
comma
id|err
comma
id|cmd
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SET_ARRAY_INFO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: array md%d already has disks!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;sb
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: array md%d already has a superblock!&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
)paren
(brace
id|mdu_array_info_t
id|info
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
id|err
op_assign
id|set_array_info
c_func
(paren
id|mddev
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: couldnt set array info. %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
)brace
r_goto
id|done_unlock
suffix:semicolon
r_case
id|START_ARRAY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * possibly make it lock the array ...&n;&t;&t;&t; */
id|err
op_assign
id|autostart_array
c_func
(paren
id|val_to_kdev
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: autostart %s failed!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|val_to_kdev
c_func
(paren
id|arg
)paren
)paren
)paren
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
r_goto
id|done_unlock
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commands querying/configuring an existing array:&n;&t; */
multiline_comment|/* if we don&squot;t have a superblock yet, only ADD_NEW_DISK or STOP_ARRAY is allowed */
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sb
op_logical_and
id|cmd
op_ne
id|ADD_NEW_DISK
op_logical_and
id|cmd
op_ne
id|STOP_ARRAY
op_logical_and
id|cmd
op_ne
id|RUN_ARRAY
)paren
(brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commands even a read-only array can execute:&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|GET_ARRAY_INFO
suffix:colon
id|err
op_assign
id|get_array_info
c_func
(paren
id|mddev
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|GET_DISK_INFO
suffix:colon
id|err
op_assign
id|get_disk_info
c_func
(paren
id|mddev
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|RESTART_ARRAY_RW
suffix:colon
id|err
op_assign
id|restart_array
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|STOP_ARRAY
suffix:colon
id|err
op_assign
id|do_md_stop
(paren
id|mddev
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|STOP_ARRAY_RO
suffix:colon
id|err
op_assign
id|do_md_stop
(paren
id|mddev
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
multiline_comment|/*&n;&t; * We have a problem here : there is no easy way to give a CHS&n;&t; * virtual geometry. We currently pretend that we have a 2 heads&n;&t; * 4 sectors (with a BIG number of cylinders...). This drives&n;&t; * dosfs just mad... ;-)&n;&t; */
r_case
id|HDIO_GETGEO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|loc
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
id|err
op_assign
id|put_user
(paren
l_int|2
comma
(paren
r_char
op_star
)paren
op_amp
id|loc-&gt;heads
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|abort_unlock
suffix:semicolon
id|err
op_assign
id|put_user
(paren
l_int|4
comma
(paren
r_char
op_star
)paren
op_amp
id|loc-&gt;sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|abort_unlock
suffix:semicolon
id|err
op_assign
id|put_user
(paren
id|md_hd_struct
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
dot
id|nr_sects
op_div
l_int|8
comma
(paren
r_int
op_star
)paren
op_amp
id|loc-&gt;cylinders
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|abort_unlock
suffix:semicolon
id|err
op_assign
id|put_user
(paren
id|get_start_sect
c_func
(paren
id|dev
)paren
comma
(paren
r_int
op_star
)paren
op_amp
id|loc-&gt;start
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The remaining ioctls are changing the state of the&n;&t; * superblock, so we do not allow read-only arrays&n;&t; * here:&n;&t; */
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
(brace
id|err
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|ADD_NEW_DISK
suffix:colon
(brace
id|mdu_disk_info_t
id|info
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|err
op_assign
id|add_new_disk
c_func
(paren
id|mddev
comma
op_amp
id|info
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
)brace
r_case
id|HOT_GENERATE_ERROR
suffix:colon
id|err
op_assign
id|hot_generate_error
c_func
(paren
id|mddev
comma
id|val_to_kdev
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|HOT_REMOVE_DISK
suffix:colon
id|err
op_assign
id|hot_remove_disk
c_func
(paren
id|mddev
comma
id|val_to_kdev
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|HOT_ADD_DISK
suffix:colon
id|err
op_assign
id|hot_add_disk
c_func
(paren
id|mddev
comma
id|val_to_kdev
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|SET_DISK_FAULTY
suffix:colon
id|err
op_assign
id|set_disk_faulty
c_func
(paren
id|mddev
comma
id|val_to_kdev
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_goto
id|done_unlock
suffix:semicolon
r_case
id|RUN_ARRAY
suffix:colon
(brace
id|err
op_assign
id|do_md_run
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * we have to clean up the mess if&n;&t;&t;&t; * the array cannot be run for some&n;&t;&t;&t; * reason ...&n;&t;&t;&t; */
r_if
c_cond
(paren
id|err
)paren
(brace
id|mddev-&gt;sb_dirty
op_assign
l_int|0
suffix:semicolon
id|do_md_stop
(paren
id|mddev
comma
l_int|0
)paren
suffix:semicolon
)brace
r_goto
id|done_unlock
suffix:semicolon
)brace
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: %s(pid %d) used obsolete MD ioctl, &quot;
l_string|&quot;upgrade your software to use new ictls.&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|abort_unlock
suffix:semicolon
)brace
id|done_unlock
suffix:colon
id|abort_unlock
suffix:colon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|err
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
m_abort
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|md_open
r_static
r_int
id|md_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
multiline_comment|/*&n;&t; * Succeed if we can find or allocate a mddev structure.&n;&t; */
id|mddev_t
op_star
id|mddev
op_assign
id|mddev_find
c_func
(paren
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|mddev_lock
c_func
(paren
id|mddev
)paren
)paren
)paren
r_goto
id|put
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|inode-&gt;i_bdev-&gt;bd_inode-&gt;u.generic_ip
op_assign
id|mddev_get
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|put
suffix:colon
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|md_release
r_static
r_int
id|md_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|inode-&gt;i_bdev-&gt;bd_inode-&gt;u.generic_ip
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|md_fops
r_static
r_struct
id|block_device_operations
id|md_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|open
suffix:colon
id|md_open
comma
id|release
suffix:colon
id|md_release
comma
id|ioctl
suffix:colon
id|md_ioctl
comma
)brace
suffix:semicolon
DECL|function|flush_curr_signals
r_static
r_inline
r_void
id|flush_curr_signals
c_func
(paren
r_void
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
)brace
DECL|function|md_thread
r_int
id|md_thread
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
id|mdk_thread_t
op_star
id|thread
op_assign
id|arg
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Detach thread&n;&t; */
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|reparent_to_init
c_func
(paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
id|thread-&gt;name
)paren
suffix:semicolon
id|current-&gt;exit_signal
op_assign
id|SIGCHLD
suffix:semicolon
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sigmask
c_func
(paren
id|SIGKILL
)paren
)paren
suffix:semicolon
id|flush_curr_signals
c_func
(paren
)paren
suffix:semicolon
id|thread-&gt;tsk
op_assign
id|current
suffix:semicolon
multiline_comment|/*&n;&t; * md_thread is a &squot;system-thread&squot;, it&squot;s priority should be very&n;&t; * high. We avoid resource deadlocks individually in each&n;&t; * raid personality. (RAID5 does preallocation) We also use RR and&n;&t; * the very same RT priority as kswapd, thus we will never get&n;&t; * into a priority inversion deadlock.&n;&t; *&n;&t; * we definitely have to have equal or higher priority than&n;&t; * bdflush, otherwise bdflush will deadlock if there are too&n;&t; * many dirty RAID5 blocks.&n;&t; */
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|complete
c_func
(paren
id|thread-&gt;event
)paren
suffix:semicolon
r_while
c_loop
(paren
id|thread-&gt;run
)paren
(brace
r_void
(paren
op_star
id|run
)paren
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
id|wait_event_interruptible
c_func
(paren
id|thread-&gt;wqueue
comma
id|test_bit
c_func
(paren
id|THREAD_WAKEUP
comma
op_amp
id|thread-&gt;flags
)paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|THREAD_WAKEUP
comma
op_amp
id|thread-&gt;flags
)paren
suffix:semicolon
id|run
op_assign
id|thread-&gt;run
suffix:semicolon
r_if
c_cond
(paren
id|run
)paren
(brace
id|run
c_func
(paren
id|thread-&gt;data
)paren
suffix:semicolon
id|blk_run_queues
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
id|flush_curr_signals
c_func
(paren
)paren
suffix:semicolon
)brace
id|complete
c_func
(paren
id|thread-&gt;event
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|md_wakeup_thread
r_void
id|md_wakeup_thread
c_func
(paren
id|mdk_thread_t
op_star
id|thread
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;md: waking up MD thread %p.&bslash;n&quot;
comma
id|thread
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|THREAD_WAKEUP
comma
op_amp
id|thread-&gt;flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|thread-&gt;wqueue
)paren
suffix:semicolon
)brace
DECL|function|md_register_thread
id|mdk_thread_t
op_star
id|md_register_thread
c_func
(paren
r_void
(paren
op_star
id|run
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|data
comma
r_const
r_char
op_star
id|name
)paren
(brace
id|mdk_thread_t
op_star
id|thread
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|completion
id|event
suffix:semicolon
id|thread
op_assign
(paren
id|mdk_thread_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|mdk_thread_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thread
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|thread
comma
l_int|0
comma
r_sizeof
(paren
id|mdk_thread_t
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|thread-&gt;wqueue
)paren
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|thread-&gt;event
op_assign
op_amp
id|event
suffix:semicolon
id|thread-&gt;run
op_assign
id|run
suffix:semicolon
id|thread-&gt;data
op_assign
id|data
suffix:semicolon
id|thread-&gt;name
op_assign
id|name
suffix:semicolon
id|ret
op_assign
id|kernel_thread
c_func
(paren
id|md_thread
comma
id|thread
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|thread
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|wait_for_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
r_return
id|thread
suffix:semicolon
)brace
DECL|function|md_interrupt_thread
r_void
id|md_interrupt_thread
c_func
(paren
id|mdk_thread_t
op_star
id|thread
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|thread-&gt;tsk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;interrupting MD-thread pid %d&bslash;n&quot;
comma
id|thread-&gt;tsk-&gt;pid
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|thread-&gt;tsk
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|md_unregister_thread
r_void
id|md_unregister_thread
c_func
(paren
id|mdk_thread_t
op_star
id|thread
)paren
(brace
r_struct
id|completion
id|event
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|thread-&gt;event
op_assign
op_amp
id|event
suffix:semicolon
id|thread-&gt;run
op_assign
l_int|NULL
suffix:semicolon
id|thread-&gt;name
op_assign
l_int|NULL
suffix:semicolon
id|md_interrupt_thread
c_func
(paren
id|thread
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|thread
)paren
suffix:semicolon
)brace
DECL|function|md_recover_arrays
r_static
r_void
id|md_recover_arrays
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|md_recovery_thread
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|md_wakeup_thread
c_func
(paren
id|md_recovery_thread
)paren
suffix:semicolon
)brace
DECL|function|md_error
r_int
id|md_error
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
id|mdk_rdev_t
op_star
id|rrdev
suffix:semicolon
id|kdev_t
id|rdev
op_assign
id|to_kdev_t
c_func
(paren
id|bdev-&gt;bd_dev
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;md_error dev:(%d:%d), rdev:(%d:%d), (caller: %p,%p,%p,%p).&bslash;n&quot;
comma
id|MD_MAJOR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|major
c_func
(paren
id|rdev
)paren
comma
id|minor
c_func
(paren
id|rdev
)paren
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
comma
id|__builtin_return_address
c_func
(paren
l_int|1
)paren
comma
id|__builtin_return_address
c_func
(paren
l_int|2
)paren
comma
id|__builtin_return_address
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|rrdev
op_assign
id|find_rdev
c_func
(paren
id|mddev
comma
id|rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rrdev
op_logical_or
id|rrdev-&gt;faulty
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers-&gt;error_handler
op_logical_or
id|mddev-&gt;pers
op_member_access_from_pointer
id|error_handler
c_func
(paren
id|mddev
comma
id|rdev
)paren
op_le
l_int|0
)paren
(brace
id|rrdev-&gt;faulty
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * if recovery was running, stop it now.&n;&t; */
r_if
c_cond
(paren
id|mddev-&gt;recovery_running
)paren
id|mddev-&gt;recovery_running
op_assign
op_minus
id|EIO
suffix:semicolon
id|md_recover_arrays
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|status_unused
r_static
r_int
id|status_unused
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_int
id|sz
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;unused devices: &quot;
)paren
suffix:semicolon
id|ITERATE_RDEV_ALL
c_func
(paren
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|rdev-&gt;same_set
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The device is not yet used by any array.&n;&t;&t;&t; */
id|i
op_increment
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;%s &quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&lt;none&gt;&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
DECL|function|status_resync
r_static
r_int
id|status_resync
c_func
(paren
r_char
op_star
id|page
comma
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|max_blocks
comma
id|resync
comma
id|res
comma
id|dt
comma
id|db
comma
id|rt
suffix:semicolon
id|resync
op_assign
(paren
id|mddev-&gt;curr_resync
op_minus
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;recovery_active
)paren
)paren
op_div
l_int|2
suffix:semicolon
id|max_blocks
op_assign
id|mddev-&gt;sb-&gt;size
suffix:semicolon
multiline_comment|/*&n;&t; * Should not happen.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|max_blocks
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|res
op_assign
(paren
id|resync
op_div
l_int|1024
)paren
op_star
l_int|1000
op_div
(paren
id|max_blocks
op_div
l_int|1024
op_plus
l_int|1
)paren
suffix:semicolon
(brace
r_int
id|i
comma
id|x
op_assign
id|res
op_div
l_int|50
comma
id|y
op_assign
l_int|20
op_minus
id|x
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;[&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|x
suffix:semicolon
id|i
op_increment
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;=&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|y
suffix:semicolon
id|i
op_increment
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;] &quot;
)paren
suffix:semicolon
)brace
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; %s =%3lu.%lu%% (%lu/%lu)&quot;
comma
(paren
id|mddev-&gt;spare
ques
c_cond
l_string|&quot;recovery&quot;
suffix:colon
l_string|&quot;resync&quot;
)paren
comma
id|res
op_div
l_int|10
comma
id|res
op_mod
l_int|10
comma
id|resync
comma
id|max_blocks
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We do not want to overflow, so the order of operands and&n;&t; * the * 100 / 100 trick are important. We do a +1 to be&n;&t; * safe against division by zero. We only estimate anyway.&n;&t; *&n;&t; * dt: time from mark until now&n;&t; * db: blocks written from mark until now&n;&t; * rt: remaining time&n;&t; */
id|dt
op_assign
(paren
(paren
id|jiffies
op_minus
id|mddev-&gt;resync_mark
)paren
op_div
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dt
)paren
id|dt
op_increment
suffix:semicolon
id|db
op_assign
id|resync
op_minus
(paren
id|mddev-&gt;resync_mark_cnt
op_div
l_int|2
)paren
suffix:semicolon
id|rt
op_assign
(paren
id|dt
op_star
(paren
(paren
id|max_blocks
op_minus
id|resync
)paren
op_div
(paren
id|db
op_div
l_int|100
op_plus
l_int|1
)paren
)paren
)paren
op_div
l_int|100
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; finish=%lu.%lumin&quot;
comma
id|rt
op_div
l_int|60
comma
(paren
id|rt
op_mod
l_int|60
)paren
op_div
l_int|6
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; speed=%ldK/sec&quot;
comma
id|db
op_div
id|dt
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
DECL|function|md_status_read_proc
r_static
r_int
id|md_status_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|sz
op_assign
l_int|0
comma
id|j
comma
id|size
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
comma
op_star
id|tmp2
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;Personalities : &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MAX_PERSONALITY
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|pers
(braket
id|j
)braket
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;[%s] &quot;
comma
id|pers
(braket
id|j
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ITERATE_MDDEV
c_func
(paren
id|mddev
comma
id|tmp
)paren
r_if
c_cond
(paren
id|mddev_lock
c_func
(paren
id|mddev
)paren
op_eq
l_int|0
)paren
(brace
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;md%d : %sactive&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|mddev-&gt;pers
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;in&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;ro
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; (read-only)&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; %s&quot;
comma
id|mddev-&gt;pers-&gt;name
)paren
suffix:semicolon
)brace
id|size
op_assign
l_int|0
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp2
)paren
(brace
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; %s[%d]&quot;
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|rdev-&gt;desc_nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;(F)&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|size
op_add_assign
id|rdev-&gt;size
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n      %d blocks&quot;
comma
id|md_size
(braket
id|mdidx
c_func
(paren
id|mddev
)paren
)braket
)paren
suffix:semicolon
r_else
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n      %d blocks&quot;
comma
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;pers
)paren
(brace
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sz
op_add_assign
id|mddev-&gt;pers-&gt;status
(paren
id|page
op_plus
id|sz
comma
id|mddev
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n      &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;curr_resync
OG
l_int|1
)paren
id|sz
op_add_assign
id|status_resync
(paren
id|page
op_plus
id|sz
comma
id|mddev
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mddev-&gt;curr_resync
op_eq
l_int|1
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&t;resync=DELAYED&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
id|sz
op_add_assign
id|status_unused
c_func
(paren
id|page
op_plus
id|sz
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
DECL|function|register_md_personality
r_int
id|register_md_personality
c_func
(paren
r_int
id|pnum
comma
id|mdk_personality_t
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|pnum
op_ge
id|MAX_PERSONALITY
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pers
(braket
id|pnum
)braket
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|pers
(braket
id|pnum
)braket
op_assign
id|p
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: %s personality registered as nr %d&bslash;n&quot;
comma
id|p-&gt;name
comma
id|pnum
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unregister_md_personality
r_int
id|unregister_md_personality
c_func
(paren
r_int
id|pnum
)paren
(brace
r_if
c_cond
(paren
id|pnum
op_ge
id|MAX_PERSONALITY
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: %s personality unregistered&bslash;n&quot;
comma
id|pers
(braket
id|pnum
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|pers
(braket
id|pnum
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_spare
id|mdp_disk_t
op_star
id|get_spare
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|mdp_disk_t
op_star
id|disk
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|disk
op_assign
op_amp
id|sb-&gt;disks
(braket
id|rdev-&gt;desc_nr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|disk_faulty
c_func
(paren
id|disk
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disk_active
c_func
(paren
id|disk
)paren
)paren
r_continue
suffix:semicolon
r_return
id|disk
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|sync_io
r_static
r_int
r_int
id|sync_io
(braket
id|DK_MAX_MAJOR
)braket
(braket
id|DK_MAX_DISK
)braket
suffix:semicolon
DECL|function|md_sync_acct
r_void
id|md_sync_acct
c_func
(paren
id|kdev_t
id|dev
comma
r_int
r_int
id|nr_sectors
)paren
(brace
r_int
r_int
id|major
op_assign
id|major
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
id|index
op_assign
id|disk_index
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|index
op_ge
id|DK_MAX_DISK
)paren
op_logical_or
(paren
id|major
op_ge
id|DK_MAX_MAJOR
)paren
)paren
r_return
suffix:semicolon
id|sync_io
(braket
id|major
)braket
(braket
id|index
)braket
op_add_assign
id|nr_sectors
suffix:semicolon
)brace
DECL|function|is_mddev_idle
r_static
r_int
id|is_mddev_idle
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|idle
suffix:semicolon
r_int
r_int
id|curr_events
suffix:semicolon
id|idle
op_assign
l_int|1
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_int
id|major
op_assign
id|major
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
r_int
id|idx
op_assign
id|disk_index
c_func
(paren
id|rdev-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|idx
op_ge
id|DK_MAX_DISK
)paren
op_logical_or
(paren
id|major
op_ge
id|DK_MAX_MAJOR
)paren
)paren
r_continue
suffix:semicolon
id|curr_events
op_assign
id|kstat.dk_drive_rblk
(braket
id|major
)braket
(braket
id|idx
)braket
op_plus
id|kstat.dk_drive_wblk
(braket
id|major
)braket
(braket
id|idx
)braket
suffix:semicolon
id|curr_events
op_sub_assign
id|sync_io
(braket
id|major
)braket
(braket
id|idx
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|curr_events
op_minus
id|rdev-&gt;last_events
)paren
OG
l_int|32
)paren
(brace
id|rdev-&gt;last_events
op_assign
id|curr_events
suffix:semicolon
id|idle
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|idle
suffix:semicolon
)brace
DECL|function|md_done_sync
r_void
id|md_done_sync
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|blocks
comma
r_int
id|ok
)paren
(brace
multiline_comment|/* another &quot;blocks&quot; (512byte) blocks have been synced */
id|atomic_sub
c_func
(paren
id|blocks
comma
op_amp
id|mddev-&gt;recovery_active
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|mddev-&gt;recovery_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ok
)paren
(brace
id|mddev-&gt;recovery_running
op_assign
op_minus
id|EIO
suffix:semicolon
id|md_recover_arrays
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// stop recovery, signal do_sync ....
)brace
)brace
DECL|variable|resync_wait
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|resync_wait
)paren
suffix:semicolon
DECL|macro|SYNC_MARKS
mdefine_line|#define SYNC_MARKS&t;10
DECL|macro|SYNC_MARK_STEP
mdefine_line|#define&t;SYNC_MARK_STEP&t;(3*HZ)
DECL|function|md_do_sync
r_static
r_void
id|md_do_sync
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|data
suffix:semicolon
id|mddev_t
op_star
id|mddev2
suffix:semicolon
r_int
r_int
id|max_sectors
comma
id|currspeed
op_assign
l_int|0
comma
id|j
comma
id|window
comma
id|err
suffix:semicolon
r_int
r_int
id|mark
(braket
id|SYNC_MARKS
)braket
suffix:semicolon
r_int
r_int
id|mark_cnt
(braket
id|SYNC_MARKS
)braket
suffix:semicolon
r_int
id|last_mark
comma
id|m
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|last_check
suffix:semicolon
multiline_comment|/* just incase thread restarts... */
r_if
c_cond
(paren
id|mddev-&gt;recovery_running
op_le
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* we overload curr_resync somewhat here.&n;&t; * 0 == not engaged in resync at all&n;&t; * 2 == checking that there is no conflict with another sync&n;&t; * 1 == like 2, but have yielded to allow conflicting resync to&n;&t; *&t;&t;commense&n;&t; * other == active in resync - this many blocks&n;&t; */
r_do
(brace
id|mddev-&gt;curr_resync
op_assign
l_int|2
suffix:semicolon
id|ITERATE_MDDEV
c_func
(paren
id|mddev2
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|mddev2
op_eq
id|mddev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mddev2-&gt;curr_resync
op_logical_and
id|match_mddev_units
c_func
(paren
id|mddev
comma
id|mddev2
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: delaying resync of md%d until md%d &quot;
l_string|&quot;has finished resync (they share one or more physical units)&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|mdidx
c_func
(paren
id|mddev2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev
OL
id|mddev2
)paren
multiline_comment|/* arbitrarily yield */
id|mddev-&gt;curr_resync
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|wait_event_interruptible
c_func
(paren
id|resync_wait
comma
id|mddev2-&gt;curr_resync
OL
l_int|2
)paren
)paren
(brace
id|flush_curr_signals
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINTR
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev2
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
id|mddev-&gt;curr_resync
OL
l_int|2
)paren
suffix:semicolon
id|max_sectors
op_assign
id|mddev-&gt;sb-&gt;size
op_lshift
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: syncing RAID array md%d&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: minimum _guaranteed_ reconstruction speed: %d KB/sec/disc.&bslash;n&quot;
comma
id|sysctl_speed_limit_min
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: using maximum available idle IO bandwith &quot;
l_string|&quot;(but not more than %d KB/sec) for reconstruction.&bslash;n&quot;
comma
id|sysctl_speed_limit_max
)paren
suffix:semicolon
id|is_mddev_idle
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/* this also initializes IO event counters */
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|SYNC_MARKS
suffix:semicolon
id|m
op_increment
)paren
(brace
id|mark
(braket
id|m
)braket
op_assign
id|jiffies
suffix:semicolon
id|mark_cnt
(braket
id|m
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|last_mark
op_assign
l_int|0
suffix:semicolon
id|mddev-&gt;resync_mark
op_assign
id|mark
(braket
id|last_mark
)braket
suffix:semicolon
id|mddev-&gt;resync_mark_cnt
op_assign
id|mark_cnt
(braket
id|last_mark
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Tune reconstruction:&n;&t; */
id|window
op_assign
l_int|32
op_star
(paren
id|PAGE_SIZE
op_div
l_int|512
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: using %dk window, over a total of %d blocks.&bslash;n&quot;
comma
id|window
op_div
l_int|2
comma
id|max_sectors
op_div
l_int|2
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mddev-&gt;recovery_active
comma
l_int|0
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|mddev-&gt;recovery_wait
)paren
suffix:semicolon
id|last_check
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|max_sectors
suffix:semicolon
)paren
(brace
r_int
id|sectors
suffix:semicolon
id|sectors
op_assign
id|mddev-&gt;pers
op_member_access_from_pointer
id|sync_request
c_func
(paren
id|mddev
comma
id|j
comma
id|currspeed
OL
id|sysctl_speed_limit_min
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sectors
OL
l_int|0
)paren
(brace
id|err
op_assign
id|sectors
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|atomic_add
c_func
(paren
id|sectors
comma
op_amp
id|mddev-&gt;recovery_active
)paren
suffix:semicolon
id|j
op_add_assign
id|sectors
suffix:semicolon
r_if
c_cond
(paren
id|j
OG
l_int|1
)paren
id|mddev-&gt;curr_resync
op_assign
id|j
suffix:semicolon
r_if
c_cond
(paren
id|last_check
op_plus
id|window
OG
id|j
)paren
r_continue
suffix:semicolon
id|last_check
op_assign
id|j
suffix:semicolon
id|blk_run_queues
c_func
(paren
)paren
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|jiffies
op_ge
id|mark
(braket
id|last_mark
)braket
op_plus
id|SYNC_MARK_STEP
)paren
(brace
multiline_comment|/* step marks */
r_int
id|next
op_assign
(paren
id|last_mark
op_plus
l_int|1
)paren
op_mod
id|SYNC_MARKS
suffix:semicolon
id|mddev-&gt;resync_mark
op_assign
id|mark
(braket
id|next
)braket
suffix:semicolon
id|mddev-&gt;resync_mark_cnt
op_assign
id|mark_cnt
(braket
id|next
)braket
suffix:semicolon
id|mark
(braket
id|next
)braket
op_assign
id|jiffies
suffix:semicolon
id|mark_cnt
(braket
id|next
)braket
op_assign
id|j
op_minus
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;recovery_active
)paren
suffix:semicolon
id|last_mark
op_assign
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * got a signal, exit.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: md_do_sync() got signal ... exiting&bslash;n&quot;
)paren
suffix:semicolon
id|flush_curr_signals
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINTR
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * this loop exits only if either when we are slower than&n;&t;&t; * the &squot;hard&squot; speed limit, or the system was IO-idle for&n;&t;&t; * a jiffy.&n;&t;&t; * the system might be non-idle CPU-wise, but we only care&n;&t;&t; * about not overloading the IO subsystem. (things like an&n;&t;&t; * e2fsck being done on the RAID array should execute fast)&n;&t;&t; */
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|currspeed
op_assign
(paren
id|j
op_minus
id|mddev-&gt;resync_mark_cnt
)paren
op_div
l_int|2
op_div
(paren
(paren
id|jiffies
op_minus
id|mddev-&gt;resync_mark
)paren
op_div
id|HZ
op_plus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|currspeed
OG
id|sysctl_speed_limit_min
)paren
(brace
r_if
c_cond
(paren
(paren
id|currspeed
OG
id|sysctl_speed_limit_max
)paren
op_logical_or
op_logical_neg
id|is_mddev_idle
c_func
(paren
id|mddev
)paren
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: md%d: sync done.&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * this also signals &squot;finished resyncing&squot; to md_stop&n;&t; */
id|out
suffix:colon
id|wait_event
c_func
(paren
id|mddev-&gt;recovery_wait
comma
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;recovery_active
)paren
)paren
suffix:semicolon
multiline_comment|/* tell personality that we are finished */
id|mddev-&gt;pers
op_member_access_from_pointer
id|sync_request
c_func
(paren
id|mddev
comma
id|max_sectors
comma
l_int|1
)paren
suffix:semicolon
id|mddev-&gt;curr_resync
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|mddev-&gt;recovery_running
op_assign
id|err
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;recovery_running
OG
l_int|0
)paren
id|mddev-&gt;recovery_running
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;recovery_running
op_eq
l_int|0
)paren
id|mddev-&gt;in_sync
op_assign
l_int|1
suffix:semicolon
id|md_recover_arrays
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the kernel thread that watches all md arrays for re-sync action&n; * that might be needed.&n; * It does not do any resync itself, but rather &quot;forks&quot; off other threads&n; * to do that as needed.&n; * When it is determined that resync is needed, we set &quot;-&gt;recovery_running&quot; and&n; * create a thread at -&gt;sync_thread.&n; * When the thread finishes is clears recovery_running (or set and error)&n; * and wakeup up this thread which will reap the thread and finish up.&n; */
DECL|function|md_do_recovery
r_void
id|md_do_recovery
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|mdp_super_t
op_star
id|sb
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: recovery thread got woken up ...&bslash;n&quot;
)paren
suffix:semicolon
id|ITERATE_MDDEV
c_func
(paren
id|mddev
comma
id|tmp
)paren
r_if
c_cond
(paren
id|mddev_lock
c_func
(paren
id|mddev
)paren
op_eq
l_int|0
)paren
(brace
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb
op_logical_or
op_logical_neg
id|mddev-&gt;pers
op_logical_or
op_logical_neg
id|mddev-&gt;pers-&gt;diskop
op_logical_or
id|mddev-&gt;ro
)paren
r_goto
id|unlock
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;recovery_running
OG
l_int|0
)paren
multiline_comment|/* resync/recovery still happening */
r_goto
id|unlock
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sync_thread
)paren
(brace
multiline_comment|/* resync has finished, collect result */
id|md_unregister_thread
c_func
(paren
id|mddev-&gt;sync_thread
)paren
suffix:semicolon
id|mddev-&gt;sync_thread
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;recovery_running
OL
l_int|0
)paren
(brace
multiline_comment|/* some sort of failure.&n;&t;&t;&t;&t; * If we were doing a reconstruction,&n;&t;&t;&t;&t; * we need to retrieve the spare&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|mddev-&gt;spare
)paren
(brace
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|mddev-&gt;spare
comma
id|DISKOP_SPARE_INACTIVE
)paren
suffix:semicolon
id|mddev-&gt;spare
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* success...*/
r_if
c_cond
(paren
id|mddev-&gt;spare
)paren
(brace
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|mddev-&gt;spare
comma
id|DISKOP_SPARE_ACTIVE
)paren
suffix:semicolon
id|mark_disk_sync
c_func
(paren
id|mddev-&gt;spare
)paren
suffix:semicolon
id|mark_disk_active
c_func
(paren
id|mddev-&gt;spare
)paren
suffix:semicolon
id|sb-&gt;active_disks
op_increment
suffix:semicolon
id|sb-&gt;spare_disks
op_decrement
suffix:semicolon
id|mddev-&gt;spare
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|__md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mddev-&gt;recovery_running
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|resync_wait
)paren
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;recovery_running
)paren
(brace
multiline_comment|/* that&squot;s odd.. */
id|mddev-&gt;recovery_running
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|resync_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sb-&gt;active_disks
OL
id|sb-&gt;raid_disks
)paren
(brace
id|mddev-&gt;spare
op_assign
id|get_spare
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;spare
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md%d: no spare disk to reconstruct array! &quot;
l_string|&quot;-- continuing in degraded mode&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md%d: resyncing spare disk %s to replace failed disk&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|partition_name
c_func
(paren
id|mk_kdev
c_func
(paren
id|mddev-&gt;spare-&gt;major
comma
id|mddev-&gt;spare-&gt;minor
)paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;spare
op_logical_and
id|mddev-&gt;in_sync
)paren
(brace
multiline_comment|/* nothing we can do ... */
r_goto
id|unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;pers-&gt;sync_request
)paren
(brace
id|mddev-&gt;sync_thread
op_assign
id|md_register_thread
c_func
(paren
id|md_do_sync
comma
id|mddev
comma
l_string|&quot;md_resync&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;sync_thread
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md%d: could not start resync thread...&bslash;n&quot;
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;spare
)paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|mddev-&gt;spare
comma
id|DISKOP_SPARE_INACTIVE
)paren
suffix:semicolon
id|mddev-&gt;spare
op_assign
l_int|NULL
suffix:semicolon
id|mddev-&gt;recovery_running
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|mddev-&gt;spare
)paren
id|mddev-&gt;pers
op_member_access_from_pointer
id|diskop
c_func
(paren
id|mddev
comma
op_amp
id|mddev-&gt;spare
comma
id|DISKOP_SPARE_WRITE
)paren
suffix:semicolon
id|mddev-&gt;recovery_running
op_assign
l_int|1
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;sync_thread
)paren
suffix:semicolon
)brace
)brace
id|unlock
suffix:colon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: recovery thread finished ...&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|md_notify_reboot
r_int
id|md_notify_reboot
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|code
comma
r_void
op_star
id|x
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|code
op_eq
id|SYS_DOWN
)paren
op_logical_or
(paren
id|code
op_eq
id|SYS_HALT
)paren
op_logical_or
(paren
id|code
op_eq
id|SYS_POWER_OFF
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: stopping all md devices.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NOTIFY_DONE
suffix:semicolon
id|ITERATE_MDDEV
c_func
(paren
id|mddev
comma
id|tmp
)paren
r_if
c_cond
(paren
id|mddev_trylock
c_func
(paren
id|mddev
)paren
op_eq
l_int|0
)paren
id|do_md_stop
(paren
id|mddev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * certain more exotic SCSI devices are known to be&n;&t;&t; * volatile wrt too early system reboots. While the&n;&t;&t; * right place to handle this issue is the given&n;&t;&t; * driver, we do want to have a safe RAID driver ...&n;&t;&t; */
id|mdelay
c_func
(paren
l_int|1000
op_star
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|md_notifier
r_struct
id|notifier_block
id|md_notifier
op_assign
(brace
id|notifier_call
suffix:colon
id|md_notify_reboot
comma
id|next
suffix:colon
l_int|NULL
comma
id|priority
suffix:colon
id|INT_MAX
comma
multiline_comment|/* before any real devices */
)brace
suffix:semicolon
DECL|function|md_geninit
r_static
r_void
id|md_geninit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_MD_DEVS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|md_size
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|md_size
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;md: sizeof(mdp_super_t) = %d&bslash;n&quot;
comma
(paren
r_int
)paren
r_sizeof
(paren
id|mdp_super_t
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|create_proc_read_entry
c_func
(paren
l_string|&quot;mdstat&quot;
comma
l_int|0
comma
l_int|NULL
comma
id|md_status_read_proc
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|md_queue_proc
id|request_queue_t
op_star
id|md_queue_proc
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|mddev_find
c_func
(paren
id|minor
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|request_queue_t
op_star
id|q
op_assign
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|mddev-&gt;active
)paren
OL
l_int|2
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;pers
)paren
id|q
op_assign
op_amp
id|mddev-&gt;queue
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/* the caller must hold a reference... */
r_return
id|q
suffix:semicolon
)brace
DECL|function|md_init
r_int
id|__init
id|md_init
c_func
(paren
r_void
)paren
(brace
r_static
r_char
op_star
id|name
op_assign
l_string|&quot;mdrecoveryd&quot;
suffix:semicolon
r_int
id|minor
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: md driver %d.%d.%d MAX_MD_DEVS=%d, MD_SB_DISKS=%d&bslash;n&quot;
comma
id|MD_MAJOR_VERSION
comma
id|MD_MINOR_VERSION
comma
id|MD_PATCHLEVEL_VERSION
comma
id|MAX_MD_DEVS
comma
id|MD_SB_DISKS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_register_blkdev
(paren
id|MAJOR_NR
comma
l_string|&quot;md&quot;
comma
op_amp
id|md_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;md: Unable to get major %d for md&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;md&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t use devfs_register_series because we want to fill md_hd_struct */
r_for
c_loop
(paren
id|minor
op_assign
l_int|0
suffix:semicolon
id|minor
OL
id|MAX_MD_DEVS
suffix:semicolon
op_increment
id|minor
)paren
(brace
r_char
id|devname
(braket
l_int|128
)braket
suffix:semicolon
id|sprintf
(paren
id|devname
comma
l_string|&quot;%u&quot;
comma
id|minor
)paren
suffix:semicolon
id|md_hd_struct
(braket
id|minor
)braket
dot
id|de
op_assign
id|devfs_register
(paren
id|devfs_handle
comma
id|devname
comma
id|DEVFS_FL_DEFAULT
comma
id|MAJOR_NR
comma
id|minor
comma
id|S_IFBLK
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|md_fops
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* all requests on an uninitialised device get failed... */
id|blk_queue_make_request
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|md_fail_request
)paren
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|queue
op_assign
id|md_queue_proc
suffix:semicolon
id|add_gendisk
c_func
(paren
op_amp
id|md_gendisk
)paren
suffix:semicolon
id|md_recovery_thread
op_assign
id|md_register_thread
c_func
(paren
id|md_do_recovery
comma
l_int|NULL
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md_recovery_thread
)paren
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;md: bug: couldn&squot;t allocate md_recovery_thread&bslash;n&quot;
)paren
suffix:semicolon
id|register_reboot_notifier
c_func
(paren
op_amp
id|md_notifier
)paren
suffix:semicolon
id|raid_table_header
op_assign
id|register_sysctl_table
c_func
(paren
id|raid_root_table
comma
l_int|1
)paren
suffix:semicolon
id|md_geninit
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifndef MODULE
multiline_comment|/*&n; * When md (and any require personalities) are compiled into the kernel&n; * (not a module), arrays can be assembles are boot time using with AUTODETECT&n; * where specially marked partitions are registered with md_autodetect_dev(),&n; * and with MD_BOOT where devices to be collected are given on the boot line&n; * with md=.....&n; * The code for that is here.&n; */
r_struct
(brace
DECL|member|set
r_int
id|set
suffix:semicolon
DECL|member|noautodetect
r_int
id|noautodetect
suffix:semicolon
DECL|variable|__initdata
)brace
id|raid_setup_args
id|__initdata
suffix:semicolon
multiline_comment|/*&n; * Searches all registered partitions for autorun RAID arrays&n; * at boot time.&n; */
DECL|variable|detected_devices
r_static
id|kdev_t
id|detected_devices
(braket
l_int|128
)braket
suffix:semicolon
DECL|variable|dev_cnt
r_static
r_int
id|dev_cnt
suffix:semicolon
DECL|function|md_autodetect_dev
r_void
id|md_autodetect_dev
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev_cnt
op_ge
l_int|0
op_logical_and
id|dev_cnt
OL
l_int|127
)paren
id|detected_devices
(braket
id|dev_cnt
op_increment
)braket
op_assign
id|dev
suffix:semicolon
)brace
DECL|function|autostart_arrays
r_static
r_void
id|autostart_arrays
c_func
(paren
r_void
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: Autodetecting RAID arrays.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kdev_t
id|dev
op_assign
id|detected_devices
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|md_import_device
c_func
(paren
id|dev
comma
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;md: could not import %s!&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Sanity checks:&n;&t;&t; */
id|rdev
op_assign
id|find_rdev_all
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|rdev-&gt;pending
comma
op_amp
id|pending_raid_disks
)paren
suffix:semicolon
)brace
id|dev_cnt
op_assign
l_int|0
suffix:semicolon
id|autorun_devices
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_struct
(brace
DECL|member|device_set
r_char
id|device_set
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|member|pers
r_int
id|pers
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|member|chunk
r_int
id|chunk
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|member|device_names
r_char
op_star
id|device_names
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|variable|__initdata
)brace
id|md_setup_args
id|__initdata
suffix:semicolon
multiline_comment|/*&n; * Parse the command-line parameters given our kernel, but do not&n; * actually try to invoke the MD device now; that is handled by&n; * md_setup_drive after the low-level disk drivers have initialised.&n; *&n; * 27/11/1999: Fixed to work correctly with the 2.3 kernel (which&n; *             assigns the task of parsing integer arguments to the&n; *             invoked program now).  Added ability to initialise all&n; *             the MD devices (by specifying multiple &quot;md=&quot; lines)&n; *             instead of just one.  -- KTK&n; * 18May2000: Added support for persistant-superblock arrays:&n; *             md=n,0,factor,fault,device-list   uses RAID0 for device n&n; *             md=n,-1,factor,fault,device-list  uses LINEAR for device n&n; *             md=n,device-list      reads a RAID superblock from the devices&n; *             elements in device-list are read by name_to_kdev_t so can be&n; *             a hex number or something like /dev/hda1 /dev/sdb&n; * 2001-06-03: Dave Cinege &lt;dcinege@psychosis.com&gt;&n; *&t;&t;Shifted name_to_kdev_t() and related operations to md_set_drive()&n; *&t;&t;for later execution. Rewrote section to make devfs compatible.&n; */
DECL|function|md_setup
r_static
r_int
id|__init
id|md_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|minor
comma
id|level
comma
id|factor
comma
id|fault
suffix:semicolon
r_char
op_star
id|pername
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_char
op_star
id|str1
op_assign
id|str
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|minor
)paren
op_ne
l_int|2
)paren
(brace
multiline_comment|/* MD Number */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: Too few arguments supplied to md=.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|minor
op_ge
id|MAX_MD_DEVS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: md=%d, Minor device number too high.&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|md_setup_args.device_names
(braket
id|minor
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: md=%d, Specified more than once. &quot;
l_string|&quot;Replacing previous definition.&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|level
)paren
)paren
(brace
multiline_comment|/* RAID Personality */
r_case
l_int|2
suffix:colon
multiline_comment|/* could be 0 or -1.. */
r_if
c_cond
(paren
op_logical_neg
id|level
op_logical_or
id|level
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|factor
)paren
op_ne
l_int|2
op_logical_or
multiline_comment|/* Chunk Size */
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|fault
)paren
op_ne
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: Too few arguments supplied to md=.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|md_setup_args.pers
(braket
id|minor
)braket
op_assign
id|level
suffix:semicolon
id|md_setup_args.chunk
(braket
id|minor
)braket
op_assign
l_int|1
op_lshift
(paren
id|factor
op_plus
l_int|12
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|level
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
id|level
op_assign
id|LINEAR
suffix:semicolon
id|pername
op_assign
l_string|&quot;linear&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
id|level
op_assign
id|RAID0
suffix:semicolon
id|pername
op_assign
l_string|&quot;raid0&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: The kernel has not been configured for raid%d support!&bslash;n&quot;
comma
id|level
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|md_setup_args.pers
(braket
id|minor
)braket
op_assign
id|level
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* FALL THROUGH */
r_case
l_int|1
suffix:colon
multiline_comment|/* the first device is numeric */
id|str
op_assign
id|str1
suffix:semicolon
multiline_comment|/* FALL THROUGH */
r_case
l_int|0
suffix:colon
id|md_setup_args.pers
(braket
id|minor
)braket
op_assign
l_int|0
suffix:semicolon
id|pername
op_assign
l_string|&quot;super-block&quot;
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: Will configure md%d (%s) from %s, below.&bslash;n&quot;
comma
id|minor
comma
id|pername
comma
id|str
)paren
suffix:semicolon
id|md_setup_args.device_names
(braket
id|minor
)braket
op_assign
id|str
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_extern
id|kdev_t
id|name_to_kdev_t
c_func
(paren
r_char
op_star
id|line
)paren
id|__init
suffix:semicolon
DECL|function|md_setup_drive
r_void
id|__init
id|md_setup_drive
c_func
(paren
r_void
)paren
(brace
r_int
id|minor
comma
id|i
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|kdev_t
id|devices
(braket
id|MD_SB_DISKS
op_plus
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|minor
op_assign
l_int|0
suffix:semicolon
id|minor
OL
id|MAX_MD_DEVS
suffix:semicolon
id|minor
op_increment
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|devname
suffix:semicolon
id|mdu_disk_info_t
id|dinfo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|devname
op_assign
id|md_setup_args.device_names
(braket
id|minor
)braket
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
op_logical_and
id|devname
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_void
op_star
id|handle
suffix:semicolon
id|p
op_assign
id|strchr
c_func
(paren
id|devname
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
id|dev
op_assign
id|name_to_kdev_t
c_func
(paren
id|devname
)paren
suffix:semicolon
id|handle
op_assign
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
id|devname
comma
id|major
c_func
(paren
id|dev
)paren
comma
id|minor
c_func
(paren
id|dev
)paren
comma
id|DEVFS_SPECIAL_BLK
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handle
op_ne
l_int|0
)paren
(brace
r_int
id|major
comma
id|minor
suffix:semicolon
id|devfs_get_maj_min
c_func
(paren
id|handle
comma
op_amp
id|major
comma
op_amp
id|minor
)paren
suffix:semicolon
id|dev
op_assign
id|mk_kdev
c_func
(paren
id|major
comma
id|minor
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kdev_none
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: Unknown device name: %s&bslash;n&quot;
comma
id|devname
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|devices
(braket
id|i
)braket
op_assign
id|dev
suffix:semicolon
id|md_setup_args.device_set
(braket
id|minor
)braket
op_assign
l_int|1
suffix:semicolon
id|devname
op_assign
id|p
suffix:semicolon
)brace
id|devices
(braket
id|i
)braket
op_assign
id|to_kdev_t
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md_setup_args.device_set
(braket
id|minor
)braket
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: Loading md%d: %s&bslash;n&quot;
comma
id|minor
comma
id|md_setup_args.device_names
(braket
id|minor
)braket
)paren
suffix:semicolon
id|mddev
op_assign
id|mddev_find
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: kmalloc failed - cannot start array %d&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev_lock
c_func
(paren
id|mddev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: Ignoring md=%d, cannot lock!&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mddev-&gt;sb
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mddev-&gt;disks
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: Ignoring md=%d, already autodetected. (Use raid=noautodetect)&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|md_setup_args.pers
(braket
id|minor
)braket
)paren
(brace
multiline_comment|/* non-persistent */
id|mdu_array_info_t
id|ainfo
suffix:semicolon
id|ainfo.level
op_assign
id|pers_to_level
c_func
(paren
id|md_setup_args.pers
(braket
id|minor
)braket
)paren
suffix:semicolon
id|ainfo.size
op_assign
l_int|0
suffix:semicolon
id|ainfo.nr_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.raid_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.md_minor
op_assign
id|minor
suffix:semicolon
id|ainfo.not_persistent
op_assign
l_int|1
suffix:semicolon
id|ainfo.state
op_assign
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
suffix:semicolon
id|ainfo.active_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.working_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.failed_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.spare_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.layout
op_assign
l_int|0
suffix:semicolon
id|ainfo.chunk_size
op_assign
id|md_setup_args.chunk
(braket
id|minor
)braket
suffix:semicolon
id|err
op_assign
id|set_array_info
c_func
(paren
id|mddev
comma
op_amp
id|ainfo
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|err
op_logical_and
id|i
op_le
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev
op_assign
id|devices
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|kdev_none
c_func
(paren
id|dev
)paren
)paren
r_break
suffix:semicolon
id|dinfo.number
op_assign
id|i
suffix:semicolon
id|dinfo.raid_disk
op_assign
id|i
suffix:semicolon
id|dinfo.state
op_assign
(paren
l_int|1
op_lshift
id|MD_DISK_ACTIVE
)paren
op_or
(paren
l_int|1
op_lshift
id|MD_DISK_SYNC
)paren
suffix:semicolon
id|dinfo.major
op_assign
id|major
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dinfo.minor
op_assign
id|minor
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mddev-&gt;sb-&gt;nr_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb-&gt;raid_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb-&gt;active_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb-&gt;working_disks
op_increment
suffix:semicolon
id|err
op_assign
id|add_new_disk
(paren
id|mddev
comma
op_amp
id|dinfo
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* persistent */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev
op_assign
id|devices
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|kdev_none
c_func
(paren
id|dev
)paren
)paren
r_break
suffix:semicolon
id|dinfo.major
op_assign
id|major
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dinfo.minor
op_assign
id|minor
c_func
(paren
id|dev
)paren
suffix:semicolon
id|add_new_disk
(paren
id|mddev
comma
op_amp
id|dinfo
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|do_md_run
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|mddev-&gt;sb_dirty
op_assign
l_int|0
suffix:semicolon
id|do_md_stop
c_func
(paren
id|mddev
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: starting md%d failed&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
id|mddev_unlock
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mddev_put
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
)brace
DECL|function|raid_setup
r_static
r_int
id|__init
id|raid_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|len
comma
id|pos
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|str
)paren
op_plus
l_int|1
suffix:semicolon
id|pos
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|len
)paren
(brace
r_char
op_star
id|comma
op_assign
id|strchr
c_func
(paren
id|str
op_plus
id|pos
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_int
id|wlen
suffix:semicolon
r_if
c_cond
(paren
id|comma
)paren
id|wlen
op_assign
(paren
id|comma
op_minus
id|str
)paren
op_minus
id|pos
suffix:semicolon
r_else
id|wlen
op_assign
(paren
id|len
op_minus
l_int|1
)paren
op_minus
id|pos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;noautodetect&quot;
comma
id|wlen
)paren
)paren
id|raid_setup_args.noautodetect
op_assign
l_int|1
suffix:semicolon
id|pos
op_add_assign
id|wlen
op_plus
l_int|1
suffix:semicolon
)brace
id|raid_setup_args.set
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|md_run_setup
r_int
id|__init
id|md_run_setup
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|raid_setup_args.noautodetect
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: Skipping autodetection of RAID arrays. (raid=noautodetect)&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|autostart_arrays
c_func
(paren
)paren
suffix:semicolon
id|md_setup_drive
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;raid=&quot;
comma
id|raid_setup
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;md=&quot;
comma
id|md_setup
)paren
suffix:semicolon
DECL|variable|md_init
id|__initcall
c_func
(paren
id|md_init
)paren
suffix:semicolon
DECL|variable|md_run_setup
id|__initcall
c_func
(paren
id|md_run_setup
)paren
suffix:semicolon
macro_line|#else /* It is a MODULE */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|md_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|free_device_names
r_static
r_void
id|free_device_names
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|device_names
)paren
)paren
(brace
r_struct
id|dname
op_star
id|tmp
op_assign
id|list_entry
c_func
(paren
id|device_names.next
comma
id|dev_name_t
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|tmp-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|md_unregister_thread
c_func
(paren
id|md_recovery_thread
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|devfs_handle
)paren
suffix:semicolon
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;md&quot;
)paren
suffix:semicolon
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|md_notifier
)paren
suffix:semicolon
id|unregister_sysctl_table
c_func
(paren
id|raid_table_header
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|remove_proc_entry
c_func
(paren
l_string|&quot;mdstat&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
id|del_gendisk
c_func
(paren
op_amp
id|md_gendisk
)paren
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|queue
op_assign
l_int|NULL
suffix:semicolon
id|blk_clear
c_func
(paren
id|MAJOR_NR
)paren
suffix:semicolon
id|free_device_names
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|md_size
id|EXPORT_SYMBOL
c_func
(paren
id|md_size
)paren
suffix:semicolon
DECL|variable|register_md_personality
id|EXPORT_SYMBOL
c_func
(paren
id|register_md_personality
)paren
suffix:semicolon
DECL|variable|unregister_md_personality
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_md_personality
)paren
suffix:semicolon
DECL|variable|partition_name
id|EXPORT_SYMBOL
c_func
(paren
id|partition_name
)paren
suffix:semicolon
DECL|variable|md_error
id|EXPORT_SYMBOL
c_func
(paren
id|md_error
)paren
suffix:semicolon
DECL|variable|md_sync_acct
id|EXPORT_SYMBOL
c_func
(paren
id|md_sync_acct
)paren
suffix:semicolon
DECL|variable|md_done_sync
id|EXPORT_SYMBOL
c_func
(paren
id|md_done_sync
)paren
suffix:semicolon
DECL|variable|md_register_thread
id|EXPORT_SYMBOL
c_func
(paren
id|md_register_thread
)paren
suffix:semicolon
DECL|variable|md_unregister_thread
id|EXPORT_SYMBOL
c_func
(paren
id|md_unregister_thread
)paren
suffix:semicolon
DECL|variable|md_update_sb
id|EXPORT_SYMBOL
c_func
(paren
id|md_update_sb
)paren
suffix:semicolon
DECL|variable|md_wakeup_thread
id|EXPORT_SYMBOL
c_func
(paren
id|md_wakeup_thread
)paren
suffix:semicolon
DECL|variable|md_print_devices
id|EXPORT_SYMBOL
c_func
(paren
id|md_print_devices
)paren
suffix:semicolon
DECL|variable|find_rdev_nr
id|EXPORT_SYMBOL
c_func
(paren
id|find_rdev_nr
)paren
suffix:semicolon
DECL|variable|md_interrupt_thread
id|EXPORT_SYMBOL
c_func
(paren
id|md_interrupt_thread
)paren
suffix:semicolon
DECL|variable|get_spare
id|EXPORT_SYMBOL
c_func
(paren
id|get_spare
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
