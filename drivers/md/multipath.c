multiline_comment|/*&n; * multipath.c : Multiple Devices driver for Linux&n; *&n; * Copyright (C) 1999, 2000, 2001 Ingo Molnar, Red Hat&n; *&n; * Copyright (C) 1996, 1997, 1998 Ingo Molnar, Miguel de Icaza, Gadi Oxman&n; *&n; * MULTIPATH management functions.&n; *&n; * derived from raid1.c.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * You should have received a copy of the GNU General Public License&n; * (for example /usr/src/linux/COPYING); if not, write to the Free&n; * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/raid/multipath.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MD_MAJOR
DECL|macro|MD_DRIVER
mdefine_line|#define MD_DRIVER
DECL|macro|MD_PERSONALITY
mdefine_line|#define MD_PERSONALITY
DECL|macro|MAX_WORK_PER_DISK
mdefine_line|#define MAX_WORK_PER_DISK 128
DECL|macro|NR_RESERVED_BUFS
mdefine_line|#define&t;NR_RESERVED_BUFS&t;32
multiline_comment|/*&n; * The following can be used to debug the driver&n; */
DECL|macro|MULTIPATH_DEBUG
mdefine_line|#define MULTIPATH_DEBUG&t;0
macro_line|#if MULTIPATH_DEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x...)   printk(x)
DECL|macro|inline
mdefine_line|#define inline
DECL|macro|__inline__
mdefine_line|#define __inline__
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x...)  do { } while (0)
macro_line|#endif
DECL|variable|multipath_personality
r_static
id|mdk_personality_t
id|multipath_personality
suffix:semicolon
DECL|variable|retry_list_lock
r_static
id|spinlock_t
id|retry_list_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|multipath_retry_list
DECL|variable|multipath_retry_tail
r_struct
id|multipath_bh
op_star
id|multipath_retry_list
op_assign
l_int|NULL
comma
op_star
op_star
id|multipath_retry_tail
suffix:semicolon
r_static
r_int
id|multipath_diskop
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdp_disk_t
op_star
op_star
id|d
comma
r_int
id|state
)paren
suffix:semicolon
DECL|function|multipath_alloc_mpbh
r_static
r_struct
id|multipath_bh
op_star
id|multipath_alloc_mpbh
c_func
(paren
id|multipath_conf_t
op_star
id|conf
)paren
(brace
r_struct
id|multipath_bh
op_star
id|mp_bh
op_assign
l_int|NULL
suffix:semicolon
r_do
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;freer1_blocked
op_logical_and
id|conf-&gt;freer1
)paren
(brace
id|mp_bh
op_assign
id|conf-&gt;freer1
suffix:semicolon
id|conf-&gt;freer1
op_assign
id|mp_bh-&gt;next_mp
suffix:semicolon
id|conf-&gt;freer1_cnt
op_decrement
suffix:semicolon
id|mp_bh-&gt;next_mp
op_assign
l_int|NULL
suffix:semicolon
id|mp_bh-&gt;state
op_assign
(paren
l_int|1
op_lshift
id|MPBH_PreAlloc
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp_bh
)paren
r_return
id|mp_bh
suffix:semicolon
id|mp_bh
op_assign
(paren
r_struct
id|multipath_bh
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|multipath_bh
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp_bh
)paren
(brace
id|memset
c_func
(paren
id|mp_bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|mp_bh
)paren
)paren
suffix:semicolon
r_return
id|mp_bh
suffix:semicolon
)brace
id|conf-&gt;freer1_blocked
op_assign
l_int|1
suffix:semicolon
id|wait_disk_event
c_func
(paren
id|conf-&gt;wait_buffer
comma
op_logical_neg
id|conf-&gt;freer1_blocked
op_logical_or
id|conf-&gt;freer1_cnt
OG
id|NR_RESERVED_BUFS
op_div
l_int|2
)paren
suffix:semicolon
id|conf-&gt;freer1_blocked
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|multipath_free_mpbh
r_static
r_inline
r_void
id|multipath_free_mpbh
c_func
(paren
r_struct
id|multipath_bh
op_star
id|mp_bh
)paren
(brace
id|multipath_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mp_bh-&gt;mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|MPBH_PreAlloc
comma
op_amp
id|mp_bh-&gt;state
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|mp_bh-&gt;bio
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
id|mp_bh-&gt;next_mp
op_assign
id|conf-&gt;freer1
suffix:semicolon
id|conf-&gt;freer1
op_assign
id|mp_bh
suffix:semicolon
id|conf-&gt;freer1_cnt
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_buffer
)paren
suffix:semicolon
)brace
r_else
(brace
id|kfree
c_func
(paren
id|mp_bh
)paren
suffix:semicolon
)brace
)brace
DECL|function|multipath_grow_mpbh
r_static
r_int
id|multipath_grow_mpbh
(paren
id|multipath_conf_t
op_star
id|conf
comma
r_int
id|cnt
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|cnt
)paren
(brace
r_struct
id|multipath_bh
op_star
id|mp_bh
suffix:semicolon
id|mp_bh
op_assign
(paren
r_struct
id|multipath_bh
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|mp_bh
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp_bh
)paren
r_break
suffix:semicolon
id|memset
c_func
(paren
id|mp_bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|mp_bh
)paren
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|MPBH_PreAlloc
comma
op_amp
id|mp_bh-&gt;state
)paren
suffix:semicolon
id|mp_bh-&gt;mddev
op_assign
id|conf-&gt;mddev
suffix:semicolon
id|multipath_free_mpbh
c_func
(paren
id|mp_bh
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
DECL|function|multipath_shrink_mpbh
r_static
r_void
id|multipath_shrink_mpbh
c_func
(paren
id|multipath_conf_t
op_star
id|conf
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|conf-&gt;freer1
)paren
(brace
r_struct
id|multipath_bh
op_star
id|mp_bh
op_assign
id|conf-&gt;freer1
suffix:semicolon
id|conf-&gt;freer1
op_assign
id|mp_bh-&gt;next_mp
suffix:semicolon
id|conf-&gt;freer1_cnt
op_decrement
suffix:semicolon
id|kfree
c_func
(paren
id|mp_bh
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
)brace
DECL|function|multipath_map
r_static
r_int
id|multipath_map
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
op_star
id|dev
)paren
(brace
id|multipath_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
comma
id|disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
multiline_comment|/*&n;&t; * Later we do read balancing on the read side &n;&t; * now we use the first available disk.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|conf-&gt;multipaths
(braket
id|i
)braket
dot
id|operational
)paren
(brace
op_star
id|dev
op_assign
id|conf-&gt;multipaths
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;multipath_map(): no more operational IO paths?&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|multipath_reschedule_retry
r_static
r_void
id|multipath_reschedule_retry
(paren
r_struct
id|multipath_bh
op_star
id|mp_bh
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
id|mp_bh-&gt;mddev
suffix:semicolon
id|multipath_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|multipath_retry_list
op_eq
l_int|NULL
)paren
id|multipath_retry_tail
op_assign
op_amp
id|multipath_retry_list
suffix:semicolon
op_star
id|multipath_retry_tail
op_assign
id|mp_bh
suffix:semicolon
id|multipath_retry_tail
op_assign
op_amp
id|mp_bh-&gt;next_mp
suffix:semicolon
id|mp_bh-&gt;next_mp
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|conf-&gt;thread
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * multipath_end_bh_io() is called when we have finished servicing a multipathed&n; * operation and are ready to return a success/failure code to the buffer&n; * cache layer.&n; */
DECL|function|multipath_end_bh_io
r_static
r_void
id|multipath_end_bh_io
(paren
r_struct
id|multipath_bh
op_star
id|mp_bh
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|mp_bh-&gt;master_bio
suffix:semicolon
id|bio_endio
c_func
(paren
id|bio
comma
id|uptodate
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|mp_bh-&gt;bio
)paren
suffix:semicolon
id|multipath_free_mpbh
c_func
(paren
id|mp_bh
)paren
suffix:semicolon
)brace
DECL|function|multipath_end_request
r_void
id|multipath_end_request
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
r_struct
id|multipath_bh
op_star
id|mp_bh
op_assign
(paren
r_struct
id|multipath_bh
op_star
)paren
(paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * this branch is our &squot;one multipath IO has finished&squot; event handler:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
(paren
id|mp_bh-&gt;mddev
comma
id|bio-&gt;bi_dev
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * Set MPBH_Uptodate in our master buffer_head, so that&n;&t;&t; * we will return a good error code for to the higher&n;&t;&t; * levels even if IO on some other multipathed buffer fails.&n;&t;&t; *&n;&t;&t; * The &squot;master&squot; represents the complex operation to &n;&t;&t; * user-side. So if something waits for IO, then it will&n;&t;&t; * wait for the &squot;master&squot; buffer_head.&n;&t;&t; */
id|set_bit
(paren
id|MPBH_Uptodate
comma
op_amp
id|mp_bh-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
)paren
(brace
id|multipath_end_bh_io
c_func
(paren
id|mp_bh
comma
id|uptodate
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * oops, IO error:&n;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;multipath: %s: rescheduling sector %lu&bslash;n&quot;
comma
id|partition_name
c_func
(paren
id|bio-&gt;bi_dev
)paren
comma
id|bio-&gt;bi_sector
)paren
suffix:semicolon
id|multipath_reschedule_retry
c_func
(paren
id|mp_bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine returns the disk from which the requested read should&n; * be done.&n; */
DECL|function|multipath_read_balance
r_static
r_int
id|multipath_read_balance
(paren
id|multipath_conf_t
op_star
id|conf
)paren
(brace
r_int
id|disk
suffix:semicolon
r_for
c_loop
(paren
id|disk
op_assign
l_int|0
suffix:semicolon
id|disk
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|disk
op_increment
)paren
r_if
c_cond
(paren
id|conf-&gt;multipaths
(braket
id|disk
)braket
dot
id|operational
)paren
r_return
id|disk
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|multipath_make_request
r_static
r_int
id|multipath_make_request
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|rw
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|multipath_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_struct
id|bio
op_star
id|real_bio
suffix:semicolon
r_struct
id|multipath_bh
op_star
id|mp_bh
suffix:semicolon
r_struct
id|multipath_info
op_star
id|multipath
suffix:semicolon
multiline_comment|/*&n; * make_request() can abort the operation when READA is being&n; * used and no empty request is available.&n; *&n; * Currently, just replace the command with READ/WRITE.&n; */
r_if
c_cond
(paren
id|rw
op_eq
id|READA
)paren
id|rw
op_assign
id|READ
suffix:semicolon
id|mp_bh
op_assign
id|multipath_alloc_mpbh
(paren
id|conf
)paren
suffix:semicolon
id|mp_bh-&gt;master_bio
op_assign
id|bio
suffix:semicolon
id|mp_bh-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|mp_bh-&gt;cmd
op_assign
id|rw
suffix:semicolon
multiline_comment|/*&n;&t; * read balancing logic:&n;&t; */
id|multipath
op_assign
id|conf-&gt;multipaths
op_plus
id|multipath_read_balance
c_func
(paren
id|conf
)paren
suffix:semicolon
id|real_bio
op_assign
id|bio_clone
c_func
(paren
id|bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|real_bio-&gt;bi_dev
op_assign
id|multipath-&gt;dev
suffix:semicolon
id|real_bio-&gt;bi_rw
op_assign
id|rw
suffix:semicolon
id|real_bio-&gt;bi_end_io
op_assign
id|multipath_end_request
suffix:semicolon
id|real_bio-&gt;bi_private
op_assign
id|mp_bh
suffix:semicolon
id|mp_bh-&gt;bio
op_assign
id|real_bio
suffix:semicolon
id|generic_make_request
c_func
(paren
id|real_bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|multipath_status
r_static
r_int
id|multipath_status
(paren
r_char
op_star
id|page
comma
id|mddev_t
op_star
id|mddev
)paren
(brace
id|multipath_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|sz
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; [%d/%d] [&quot;
comma
id|conf-&gt;raid_disks
comma
id|conf-&gt;working_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;%s&quot;
comma
id|conf-&gt;multipaths
(braket
id|i
)braket
dot
id|operational
ques
c_cond
l_string|&quot;U&quot;
suffix:colon
l_string|&quot;_&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;]&quot;
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
DECL|macro|LAST_DISK
mdefine_line|#define LAST_DISK KERN_ALERT &bslash;&n;&quot;multipath: only one IO path left and IO error.&bslash;n&quot;
DECL|macro|NO_SPARE_DISK
mdefine_line|#define NO_SPARE_DISK KERN_ALERT &bslash;&n;&quot;multipath: no spare IO path left!&bslash;n&quot;
DECL|macro|DISK_FAILED
mdefine_line|#define DISK_FAILED KERN_ALERT &bslash;&n;&quot;multipath: IO failure on %s, disabling IO path. &bslash;n&quot; &bslash;&n;&quot;&t;Operation continuing on %d IO paths.&bslash;n&quot;
DECL|function|mark_disk_bad
r_static
r_void
id|mark_disk_bad
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|failed
)paren
(brace
id|multipath_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_struct
id|multipath_info
op_star
id|multipath
op_assign
id|conf-&gt;multipaths
op_plus
id|failed
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|multipath-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|mark_disk_faulty
c_func
(paren
id|sb-&gt;disks
op_plus
id|multipath-&gt;number
)paren
suffix:semicolon
id|mark_disk_nonsync
c_func
(paren
id|sb-&gt;disks
op_plus
id|multipath-&gt;number
)paren
suffix:semicolon
id|mark_disk_inactive
c_func
(paren
id|sb-&gt;disks
op_plus
id|multipath-&gt;number
)paren
suffix:semicolon
id|sb-&gt;active_disks
op_decrement
suffix:semicolon
id|sb-&gt;working_disks
op_decrement
suffix:semicolon
id|sb-&gt;failed_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|1
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|conf-&gt;thread
)paren
suffix:semicolon
id|conf-&gt;working_disks
op_decrement
suffix:semicolon
id|printk
(paren
id|DISK_FAILED
comma
id|partition_name
(paren
id|multipath-&gt;dev
)paren
comma
id|conf-&gt;working_disks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Careful, this can execute in IRQ contexts as well!&n; */
DECL|function|multipath_error
r_static
r_int
id|multipath_error
(paren
id|mddev_t
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
id|multipath_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_struct
id|multipath_info
op_star
id|multipaths
op_assign
id|conf-&gt;multipaths
suffix:semicolon
r_int
id|disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
r_int
id|other_paths
op_assign
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;working_disks
op_eq
l_int|1
)paren
(brace
id|other_paths
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|multipaths
(braket
id|i
)braket
dot
id|spare
)paren
(brace
id|other_paths
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|other_paths
)paren
(brace
multiline_comment|/*&n;&t;&t; * Uh oh, we can do nothing if this is our last path, but&n;&t;&t; * first check if this is a queued request for a device&n;&t;&t; * which has just failed.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|multipaths
(braket
id|i
)braket
dot
id|dev
comma
id|dev
)paren
op_logical_and
op_logical_neg
id|multipaths
(braket
id|i
)braket
dot
id|operational
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|printk
(paren
id|LAST_DISK
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Mark disk as unusable&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|multipaths
(braket
id|i
)braket
dot
id|dev
comma
id|dev
)paren
op_logical_and
id|multipaths
(braket
id|i
)braket
dot
id|operational
)paren
(brace
id|mark_disk_bad
c_func
(paren
id|mddev
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;working_disks
)paren
(brace
r_int
id|err
op_assign
l_int|1
suffix:semicolon
id|mdp_disk_t
op_star
id|spare
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|spare
op_assign
id|get_spare
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spare
)paren
(brace
id|err
op_assign
id|multipath_diskop
c_func
(paren
id|mddev
comma
op_amp
id|spare
comma
id|DISKOP_SPARE_WRITE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;got DISKOP_SPARE_WRITE err: %d. (spare_faulty(): %d)&bslash;n&quot;
comma
id|err
comma
id|disk_faulty
c_func
(paren
id|spare
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
op_logical_neg
id|disk_faulty
c_func
(paren
id|spare
)paren
)paren
(brace
id|multipath_diskop
c_func
(paren
id|mddev
comma
op_amp
id|spare
comma
id|DISKOP_SPARE_ACTIVE
)paren
suffix:semicolon
id|mark_disk_sync
c_func
(paren
id|spare
)paren
suffix:semicolon
id|mark_disk_active
c_func
(paren
id|spare
)paren
suffix:semicolon
id|sb-&gt;active_disks
op_increment
suffix:semicolon
id|sb-&gt;spare_disks
op_decrement
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|LAST_DISK
macro_line|#undef LAST_DISK
DECL|macro|NO_SPARE_DISK
macro_line|#undef NO_SPARE_DISK
DECL|macro|DISK_FAILED
macro_line|#undef DISK_FAILED
DECL|function|print_multipath_conf
r_static
r_void
id|print_multipath_conf
(paren
id|multipath_conf_t
op_star
id|conf
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|multipath_info
op_star
id|tmp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MULTIPATH conf printout:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(conf==NULL)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; --- wd:%d rd:%d nd:%d&bslash;n&quot;
comma
id|conf-&gt;working_disks
comma
id|conf-&gt;raid_disks
comma
id|conf-&gt;nr_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;multipaths
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;spare
op_logical_or
id|tmp-&gt;operational
op_logical_or
id|tmp-&gt;number
op_logical_or
id|tmp-&gt;raid_disk
op_logical_or
id|tmp-&gt;used_slot
)paren
id|printk
c_func
(paren
l_string|&quot; disk%d, s:%d, o:%d, n:%d rd:%d us:%d dev:%s&bslash;n&quot;
comma
id|i
comma
id|tmp-&gt;spare
comma
id|tmp-&gt;operational
comma
id|tmp-&gt;number
comma
id|tmp-&gt;raid_disk
comma
id|tmp-&gt;used_slot
comma
id|partition_name
c_func
(paren
id|tmp-&gt;dev
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|multipath_diskop
r_static
r_int
id|multipath_diskop
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdp_disk_t
op_star
op_star
id|d
comma
r_int
id|state
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|failed_disk
op_assign
op_minus
l_int|1
comma
id|spare_disk
op_assign
op_minus
l_int|1
comma
id|removed_disk
op_assign
op_minus
l_int|1
comma
id|added_disk
op_assign
op_minus
l_int|1
suffix:semicolon
id|multipath_conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|multipath_info
op_star
id|tmp
comma
op_star
id|sdisk
comma
op_star
id|fdisk
comma
op_star
id|rdisk
comma
op_star
id|adisk
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|mdp_disk_t
op_star
id|failed_desc
comma
op_star
id|spare_desc
comma
op_star
id|added_desc
suffix:semicolon
id|mdk_rdev_t
op_star
id|spare_rdev
comma
op_star
id|failed_rdev
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
id|print_multipath_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * find the disk ...&n;&t; */
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|DISKOP_SPARE_ACTIVE
suffix:colon
multiline_comment|/*&n;&t;&t; * Find the failed disk within the MULTIPATH configuration ...&n;&t;&t; * (this can only be in the first conf-&gt;working_disks part)&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;multipaths
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|tmp-&gt;operational
op_logical_and
op_logical_neg
id|tmp-&gt;spare
)paren
op_logical_or
op_logical_neg
id|tmp-&gt;used_slot
)paren
(brace
id|failed_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * When we activate a spare disk we _must_ have a disk in&n;&t;&t; * the lower (active) part of the array to replace. &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|failed_disk
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|failed_disk
op_ge
id|conf-&gt;raid_disks
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_case
id|DISKOP_SPARE_WRITE
suffix:colon
r_case
id|DISKOP_SPARE_INACTIVE
suffix:colon
multiline_comment|/*&n;&t;&t; * Find the spare disk ... (can only be in the &squot;high&squot;&n;&t;&t; * area of the array)&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;multipaths
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;spare
op_logical_and
id|tmp-&gt;number
op_eq
(paren
op_star
id|d
)paren
op_member_access_from_pointer
id|number
)paren
(brace
id|spare_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|spare_disk
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISKOP_HOT_REMOVE_DISK
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;multipaths
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;used_slot
op_logical_and
(paren
id|tmp-&gt;number
op_eq
(paren
op_star
id|d
)paren
op_member_access_from_pointer
id|number
)paren
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;operational
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;hot-remove-disk, slot %d is identified to be the requested disk (number %d), but is still operational!&bslash;n&quot;
comma
id|i
comma
(paren
op_star
id|d
)paren
op_member_access_from_pointer
id|number
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|removed_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|removed_disk
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DISKOP_HOT_ADD_DISK
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;multipaths
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;used_slot
)paren
(brace
id|added_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|added_disk
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|state
)paren
(brace
multiline_comment|/*&n;&t; * Switch the spare disk to write-only mode:&n;&t; */
r_case
id|DISKOP_SPARE_WRITE
suffix:colon
id|sdisk
op_assign
id|conf-&gt;multipaths
op_plus
id|spare_disk
suffix:semicolon
id|sdisk-&gt;operational
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * Deactivate a spare disk:&n;&t; */
r_case
id|DISKOP_SPARE_INACTIVE
suffix:colon
id|sdisk
op_assign
id|conf-&gt;multipaths
op_plus
id|spare_disk
suffix:semicolon
id|sdisk-&gt;operational
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * Activate (mark read-write) the (now sync) spare disk,&n;&t; * which means we switch it&squot;s &squot;raid position&squot; (-&gt;raid_disk)&n;&t; * with the failed disk. (only the first &squot;conf-&gt;nr_disks&squot;&n;&t; * slots are used for &squot;real&squot; disks and we must preserve this&n;&t; * property)&n;&t; */
r_case
id|DISKOP_SPARE_ACTIVE
suffix:colon
id|sdisk
op_assign
id|conf-&gt;multipaths
op_plus
id|spare_disk
suffix:semicolon
id|fdisk
op_assign
id|conf-&gt;multipaths
op_plus
id|failed_disk
suffix:semicolon
id|spare_desc
op_assign
op_amp
id|sb-&gt;disks
(braket
id|sdisk-&gt;number
)braket
suffix:semicolon
id|failed_desc
op_assign
op_amp
id|sb-&gt;disks
(braket
id|fdisk-&gt;number
)braket
suffix:semicolon
r_if
c_cond
(paren
id|spare_desc
op_ne
op_star
id|d
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|spare_desc-&gt;raid_disk
op_ne
id|sdisk-&gt;raid_disk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sdisk-&gt;raid_disk
op_ne
id|spare_disk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|failed_desc-&gt;raid_disk
op_ne
id|fdisk-&gt;raid_disk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdisk-&gt;raid_disk
op_ne
id|failed_disk
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * do the switch finally&n;&t;&t; */
id|spare_rdev
op_assign
id|find_rdev_nr
c_func
(paren
id|mddev
comma
id|spare_desc-&gt;number
)paren
suffix:semicolon
id|failed_rdev
op_assign
id|find_rdev_nr
c_func
(paren
id|mddev
comma
id|failed_desc-&gt;number
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|spare_rdev-&gt;desc_nr
comma
id|failed_rdev-&gt;desc_nr
)paren
suffix:semicolon
id|spare_rdev-&gt;alias_device
op_assign
l_int|0
suffix:semicolon
id|failed_rdev-&gt;alias_device
op_assign
l_int|1
suffix:semicolon
id|xchg_values
c_func
(paren
op_star
id|spare_desc
comma
op_star
id|failed_desc
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
op_star
id|fdisk
comma
op_star
id|sdisk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * (careful, &squot;failed&squot; and &squot;spare&squot; are switched from now on)&n;&t;&t; *&n;&t;&t; * we want to preserve linear numbering and we want to&n;&t;&t; * give the proper raid_disk number to the now activated&n;&t;&t; * disk. (this means we switch back these values)&n;&t;&t; */
id|xchg_values
c_func
(paren
id|spare_desc-&gt;raid_disk
comma
id|failed_desc-&gt;raid_disk
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|sdisk-&gt;raid_disk
comma
id|fdisk-&gt;raid_disk
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|spare_desc-&gt;number
comma
id|failed_desc-&gt;number
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|sdisk-&gt;number
comma
id|fdisk-&gt;number
)paren
suffix:semicolon
op_star
id|d
op_assign
id|failed_desc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdisk-&gt;bdev
)paren
id|sdisk-&gt;used_slot
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * this really activates the spare.&n;&t;&t; */
id|fdisk-&gt;spare
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if we activate a spare, we definitely replace a&n;&t;&t; * non-operational disk slot in the &squot;low&squot; area of&n;&t;&t; * the disk array.&n;&t;&t; */
id|conf-&gt;working_disks
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISKOP_HOT_REMOVE_DISK
suffix:colon
id|rdisk
op_assign
id|conf-&gt;multipaths
op_plus
id|removed_disk
suffix:semicolon
r_if
c_cond
(paren
id|rdisk-&gt;spare
op_logical_and
(paren
id|removed_disk
OL
id|conf-&gt;raid_disks
)paren
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|bdev
op_assign
id|rdisk-&gt;bdev
suffix:semicolon
id|rdisk-&gt;dev
op_assign
id|NODEV
suffix:semicolon
id|rdisk-&gt;bdev
op_assign
l_int|NULL
suffix:semicolon
id|rdisk-&gt;used_slot
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;nr_disks
op_decrement
suffix:semicolon
id|bdput
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DISKOP_HOT_ADD_DISK
suffix:colon
id|adisk
op_assign
id|conf-&gt;multipaths
op_plus
id|added_disk
suffix:semicolon
id|added_desc
op_assign
op_star
id|d
suffix:semicolon
r_if
c_cond
(paren
id|added_disk
op_ne
id|added_desc-&gt;number
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|adisk-&gt;number
op_assign
id|added_desc-&gt;number
suffix:semicolon
id|adisk-&gt;raid_disk
op_assign
id|added_desc-&gt;raid_disk
suffix:semicolon
id|adisk-&gt;dev
op_assign
id|mk_kdev
c_func
(paren
id|added_desc-&gt;major
comma
id|added_desc-&gt;minor
)paren
suffix:semicolon
multiline_comment|/* it will be held open by rdev */
id|adisk-&gt;bdev
op_assign
id|bdget
c_func
(paren
id|kdev_t_to_nr
c_func
(paren
id|adisk-&gt;dev
)paren
)paren
suffix:semicolon
id|adisk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|adisk-&gt;spare
op_assign
l_int|1
suffix:semicolon
id|adisk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|conf-&gt;nr_disks
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
m_abort
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_multipath_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|macro|IO_ERROR
mdefine_line|#define IO_ERROR KERN_ALERT &bslash;&n;&quot;multipath: %s: unrecoverable IO read error for block %lu&bslash;n&quot;
DECL|macro|REDIRECT_SECTOR
mdefine_line|#define REDIRECT_SECTOR KERN_ERR &bslash;&n;&quot;multipath: %s: redirecting sector %lu to another IO path&bslash;n&quot;
multiline_comment|/*&n; * This is a kernel thread which:&n; *&n; *&t;1.&t;Retries failed read operations on working multipaths.&n; *&t;2.&t;Updates the raid superblock when problems encounter.&n; *&t;3.&t;Performs writes following reads for array syncronising.&n; */
DECL|function|multipathd
r_static
r_void
id|multipathd
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|multipath_bh
op_star
id|mp_bh
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
id|mp_bh
op_assign
id|multipath_retry_list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp_bh
)paren
r_break
suffix:semicolon
id|multipath_retry_list
op_assign
id|mp_bh-&gt;next_mp
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
id|mddev
op_assign
id|mp_bh-&gt;mddev
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sb_dirty
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;dirty sb detected, updating.&bslash;n&quot;
)paren
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|0
suffix:semicolon
id|md_update_sb
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
id|bio
op_assign
id|mp_bh-&gt;bio
suffix:semicolon
id|dev
op_assign
id|bio-&gt;bi_dev
suffix:semicolon
id|multipath_map
(paren
id|mddev
comma
op_amp
id|bio-&gt;bi_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|bio-&gt;bi_dev
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|IO_ERROR
comma
id|partition_name
c_func
(paren
id|bio-&gt;bi_dev
)paren
comma
id|bio-&gt;bi_sector
)paren
suffix:semicolon
id|multipath_end_bh_io
c_func
(paren
id|mp_bh
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|REDIRECT_SECTOR
comma
id|partition_name
c_func
(paren
id|bio-&gt;bi_dev
)paren
comma
id|bio-&gt;bi_sector
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|macro|IO_ERROR
macro_line|#undef IO_ERROR
DECL|macro|REDIRECT_SECTOR
macro_line|#undef REDIRECT_SECTOR
multiline_comment|/*&n; * This will catch the scenario in which one of the multipaths was&n; * mounted as a normal device rather than as a part of a raid set.&n; *&n; * check_consistency is very personality-dependent, eg. RAID5 cannot&n; * do this check, it uses another method.&n; */
DECL|function|__check_consistency
r_static
r_int
id|__check_consistency
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|row
)paren
(brace
id|multipath_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|rc
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;multipaths
(braket
id|i
)braket
dot
id|operational
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(checking disk %d)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|dev
op_assign
id|conf-&gt;multipaths
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
id|bdev
op_assign
id|conf-&gt;multipaths
(braket
id|i
)braket
dot
id|bdev
suffix:semicolon
id|set_blocksize
c_func
(paren
id|dev
comma
l_int|4096
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|__bread
c_func
(paren
id|bdev
comma
id|row
op_div
l_int|4
comma
l_int|4096
)paren
)paren
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
(brace
id|buffer
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_break
suffix:semicolon
id|memcpy
c_func
(paren
id|buffer
comma
id|bh-&gt;b_data
comma
l_int|4096
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|buffer
comma
id|bh-&gt;b_data
comma
l_int|4096
)paren
)paren
(brace
id|rc
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bforget
c_func
(paren
id|bh
)paren
suffix:semicolon
id|fsync_bdev
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|invalidate_bdev
c_func
(paren
id|bdev
comma
l_int|0
)paren
suffix:semicolon
id|bh
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer
)paren
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|bdev
op_assign
id|bh-&gt;b_bdev
suffix:semicolon
id|bforget
c_func
(paren
id|bh
)paren
suffix:semicolon
id|fsync_bdev
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|invalidate_bdev
c_func
(paren
id|bdev
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|check_consistency
r_static
r_int
id|check_consistency
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_if
c_cond
(paren
id|__check_consistency
c_func
(paren
id|mddev
comma
l_int|0
)paren
)paren
multiline_comment|/*&n; * we do not do this currently, as it&squot;s perfectly possible to&n; * have an inconsistent array when it&squot;s freshly created. Only&n; * newly written data has to be consistent.&n; */
r_return
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|INVALID_LEVEL
mdefine_line|#define INVALID_LEVEL KERN_WARNING &bslash;&n;&quot;multipath: md%d: raid level not set to multipath IO (%d)&bslash;n&quot;
DECL|macro|NO_SB
mdefine_line|#define NO_SB KERN_ERR &bslash;&n;&quot;multipath: disabled IO path %s (couldn&squot;t access raid superblock)&bslash;n&quot;
DECL|macro|ERRORS
mdefine_line|#define ERRORS KERN_ERR &bslash;&n;&quot;multipath: disabled IO path %s (errors detected)&bslash;n&quot;
DECL|macro|NOT_IN_SYNC
mdefine_line|#define NOT_IN_SYNC KERN_ERR &bslash;&n;&quot;multipath: making IO path %s a spare path (not in sync)&bslash;n&quot;
DECL|macro|INCONSISTENT
mdefine_line|#define INCONSISTENT KERN_ERR &bslash;&n;&quot;multipath: disabled IO path %s (inconsistent descriptor)&bslash;n&quot;
DECL|macro|ALREADY_RUNNING
mdefine_line|#define ALREADY_RUNNING KERN_ERR &bslash;&n;&quot;multipath: disabled IO path %s (multipath %d already operational)&bslash;n&quot;
DECL|macro|OPERATIONAL
mdefine_line|#define OPERATIONAL KERN_INFO &bslash;&n;&quot;multipath: device %s operational as IO path %d&bslash;n&quot;
DECL|macro|MEM_ERROR
mdefine_line|#define MEM_ERROR KERN_ERR &bslash;&n;&quot;multipath: couldn&squot;t allocate memory for md%d&bslash;n&quot;
DECL|macro|SPARE
mdefine_line|#define SPARE KERN_INFO &bslash;&n;&quot;multipath: spare IO path %s&bslash;n&quot;
DECL|macro|NONE_OPERATIONAL
mdefine_line|#define NONE_OPERATIONAL KERN_ERR &bslash;&n;&quot;multipath: no operational IO paths for md%d&bslash;n&quot;
DECL|macro|SB_DIFFERENCES
mdefine_line|#define SB_DIFFERENCES KERN_ERR &bslash;&n;&quot;multipath: detected IO path differences!&bslash;n&quot;
DECL|macro|ARRAY_IS_ACTIVE
mdefine_line|#define ARRAY_IS_ACTIVE KERN_INFO &bslash;&n;&quot;multipath: array md%d active with %d out of %d IO paths (%d spare IO paths)&bslash;n&quot;
DECL|macro|THREAD_ERROR
mdefine_line|#define THREAD_ERROR KERN_ERR &bslash;&n;&quot;multipath: couldn&squot;t allocate thread for md%d&bslash;n&quot;
DECL|function|multipath_run
r_static
r_int
id|multipath_run
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|multipath_conf_t
op_star
id|conf
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|disk_idx
suffix:semicolon
r_struct
id|multipath_info
op_star
id|disk
comma
op_star
id|disk2
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|mdp_disk_t
op_star
id|desc
comma
op_star
id|desc2
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
comma
op_star
id|def_rdev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|num_rdevs
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;level
op_ne
op_minus
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|INVALID_LEVEL
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;level
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * copy the already verified devices into our private MULTIPATH&n;&t; * bookkeeping area. [whatever we allocate in multipath_run(),&n;&t; * should be freed in multipath_stop()]&n;&t; */
id|conf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|multipath_conf_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
id|conf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
id|printk
c_func
(paren
id|MEM_ERROR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|conf
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|conf
)paren
)paren
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
multiline_comment|/* this is a &quot;should never happen&quot; case and if it */
multiline_comment|/* ever does happen, a continue; won&squot;t help */
id|printk
c_func
(paren
id|ERRORS
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* this is a &quot;should never happen&quot; case and if it */
multiline_comment|/* ever does happen, a continue; won&squot;t help */
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|desc
op_assign
op_amp
id|sb-&gt;disks
(braket
id|rdev-&gt;desc_nr
)braket
suffix:semicolon
id|disk_idx
op_assign
id|desc-&gt;raid_disk
suffix:semicolon
id|disk
op_assign
id|conf-&gt;multipaths
op_plus
id|disk_idx
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk_sync
c_func
(paren
id|desc
)paren
)paren
id|printk
c_func
(paren
id|NOT_IN_SYNC
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Mark all disks as spare to start with, then pick our&n;&t;&t; * active disk.  If we have a disk that is marked active&n;&t;&t; * in the sb, then use it, else use the first rdev.&n;&t;&t; */
id|disk-&gt;number
op_assign
id|desc-&gt;number
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|desc-&gt;raid_disk
suffix:semicolon
id|disk-&gt;dev
op_assign
id|rdev-&gt;dev
suffix:semicolon
id|disk-&gt;bdev
op_assign
id|rdev-&gt;bdev
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|rdev-&gt;bdev-&gt;bd_count
)paren
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|mark_disk_sync
c_func
(paren
id|desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disk_active
c_func
(paren
id|desc
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;working_disks
)paren
(brace
id|printk
c_func
(paren
id|OPERATIONAL
comma
id|partition_name
c_func
(paren
id|rdev-&gt;dev
)paren
comma
id|desc-&gt;raid_disk
)paren
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;working_disks
op_increment
suffix:semicolon
id|def_rdev
op_assign
id|rdev
suffix:semicolon
)brace
r_else
(brace
id|mark_disk_spare
c_func
(paren
id|desc
)paren
suffix:semicolon
)brace
)brace
r_else
id|mark_disk_spare
c_func
(paren
id|desc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num_rdevs
op_increment
)paren
(brace
id|def_rdev
op_assign
id|rdev
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;working_disks
op_logical_and
id|num_rdevs
)paren
(brace
id|desc
op_assign
op_amp
id|sb-&gt;disks
(braket
id|def_rdev-&gt;desc_nr
)braket
suffix:semicolon
id|disk
op_assign
id|conf-&gt;multipaths
op_plus
id|desc-&gt;raid_disk
suffix:semicolon
id|printk
c_func
(paren
id|OPERATIONAL
comma
id|partition_name
c_func
(paren
id|def_rdev-&gt;dev
)paren
comma
id|disk-&gt;raid_disk
)paren
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;working_disks
op_increment
suffix:semicolon
id|mark_disk_active
c_func
(paren
id|desc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make sure our active path is in desc spot 0&n;&t; */
r_if
c_cond
(paren
id|def_rdev-&gt;desc_nr
op_ne
l_int|0
)paren
(brace
id|rdev
op_assign
id|find_rdev_nr
c_func
(paren
id|mddev
comma
l_int|0
)paren
suffix:semicolon
id|desc
op_assign
op_amp
id|sb-&gt;disks
(braket
id|def_rdev-&gt;desc_nr
)braket
suffix:semicolon
id|desc2
op_assign
id|sb-&gt;disks
suffix:semicolon
id|disk
op_assign
id|conf-&gt;multipaths
op_plus
id|desc-&gt;raid_disk
suffix:semicolon
id|disk2
op_assign
id|conf-&gt;multipaths
op_plus
id|desc2-&gt;raid_disk
suffix:semicolon
id|xchg_values
c_func
(paren
op_star
id|desc2
comma
op_star
id|desc
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
op_star
id|disk2
comma
op_star
id|disk
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|desc2-&gt;number
comma
id|desc-&gt;number
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|disk2-&gt;number
comma
id|disk-&gt;number
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|desc2-&gt;raid_disk
comma
id|desc-&gt;raid_disk
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|disk2-&gt;raid_disk
comma
id|disk-&gt;raid_disk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rdev
)paren
(brace
id|xchg_values
c_func
(paren
id|def_rdev-&gt;desc_nr
comma
id|rdev-&gt;desc_nr
)paren
suffix:semicolon
)brace
r_else
(brace
id|def_rdev-&gt;desc_nr
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|conf-&gt;raid_disks
op_assign
id|sb-&gt;raid_disks
op_assign
id|sb-&gt;active_disks
op_assign
l_int|1
suffix:semicolon
id|conf-&gt;nr_disks
op_assign
id|sb-&gt;nr_disks
op_assign
id|sb-&gt;working_disks
op_assign
id|num_rdevs
suffix:semicolon
id|sb-&gt;failed_disks
op_assign
l_int|0
suffix:semicolon
id|sb-&gt;spare_disks
op_assign
id|num_rdevs
op_minus
l_int|1
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|1
suffix:semicolon
id|conf-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|conf-&gt;device_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|conf-&gt;wait_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;working_disks
)paren
(brace
id|printk
c_func
(paren
id|NONE_OPERATIONAL
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
multiline_comment|/* pre-allocate some buffer_head structures.&n;&t; * As a minimum, 1 mpbh and raid_disks buffer_heads&n;&t; * would probably get us by in tight memory situations,&n;&t; * but a few more is probably a good idea.&n;&t; * For now, try NR_RESERVED_BUFS mpbh and&n;&t; * NR_RESERVED_BUFS*raid_disks bufferheads&n;&t; * This will allow at least NR_RESERVED_BUFS concurrent&n;&t; * reads or writes even if kmalloc starts failing&n;&t; */
r_if
c_cond
(paren
id|multipath_grow_mpbh
c_func
(paren
id|conf
comma
id|NR_RESERVED_BUFS
)paren
OL
id|NR_RESERVED_BUFS
)paren
(brace
id|printk
c_func
(paren
id|MEM_ERROR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sb-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * we do sanity checks even if the device says&n;&t;&t; * it&squot;s clean ...&n;&t;&t; */
r_if
c_cond
(paren
id|check_consistency
c_func
(paren
id|mddev
)paren
)paren
(brace
id|printk
c_func
(paren
id|SB_DIFFERENCES
)paren
suffix:semicolon
id|sb-&gt;state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
suffix:semicolon
)brace
)brace
(brace
r_const
r_char
op_star
id|name
op_assign
l_string|&quot;multipathd&quot;
suffix:semicolon
id|conf-&gt;thread
op_assign
id|md_register_thread
c_func
(paren
id|multipathd
comma
id|conf
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;thread
)paren
(brace
id|printk
c_func
(paren
id|THREAD_ERROR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Regenerate the &quot;device is in sync with the raid set&quot; bit for&n;&t; * each device.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mark_disk_nonsync
c_func
(paren
id|sb-&gt;disks
op_plus
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sb-&gt;raid_disks
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sb-&gt;disks
(braket
id|i
)braket
dot
id|number
op_eq
id|conf-&gt;multipaths
(braket
id|j
)braket
dot
id|number
)paren
id|mark_disk_sync
c_func
(paren
id|sb-&gt;disks
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|ARRAY_IS_ACTIVE
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;active_disks
comma
id|sb-&gt;raid_disks
comma
id|sb-&gt;spare_disks
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, everything is just fine now&n;&t; */
r_return
l_int|0
suffix:semicolon
id|out_free_conf
suffix:colon
id|multipath_shrink_mpbh
c_func
(paren
id|conf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|conf-&gt;multipaths
(braket
id|i
)braket
dot
id|bdev
)paren
id|bdput
c_func
(paren
id|conf-&gt;multipaths
(braket
id|i
)braket
dot
id|bdev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|macro|INVALID_LEVEL
macro_line|#undef INVALID_LEVEL
DECL|macro|NO_SB
macro_line|#undef NO_SB
DECL|macro|ERRORS
macro_line|#undef ERRORS
DECL|macro|NOT_IN_SYNC
macro_line|#undef NOT_IN_SYNC
DECL|macro|INCONSISTENT
macro_line|#undef INCONSISTENT
DECL|macro|ALREADY_RUNNING
macro_line|#undef ALREADY_RUNNING
DECL|macro|OPERATIONAL
macro_line|#undef OPERATIONAL
DECL|macro|SPARE
macro_line|#undef SPARE
DECL|macro|NONE_OPERATIONAL
macro_line|#undef NONE_OPERATIONAL
DECL|macro|SB_DIFFERENCES
macro_line|#undef SB_DIFFERENCES
DECL|macro|ARRAY_IS_ACTIVE
macro_line|#undef ARRAY_IS_ACTIVE
DECL|function|multipath_stop
r_static
r_int
id|multipath_stop
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|multipath_conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|md_unregister_thread
c_func
(paren
id|conf-&gt;thread
)paren
suffix:semicolon
id|multipath_shrink_mpbh
c_func
(paren
id|conf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|conf-&gt;multipaths
(braket
id|i
)braket
dot
id|bdev
)paren
id|bdput
c_func
(paren
id|conf-&gt;multipaths
(braket
id|i
)braket
dot
id|bdev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|multipath_personality
r_static
id|mdk_personality_t
id|multipath_personality
op_assign
(brace
id|name
suffix:colon
l_string|&quot;multipath&quot;
comma
id|make_request
suffix:colon
id|multipath_make_request
comma
id|run
suffix:colon
id|multipath_run
comma
id|stop
suffix:colon
id|multipath_stop
comma
id|status
suffix:colon
id|multipath_status
comma
id|error_handler
suffix:colon
id|multipath_error
comma
id|diskop
suffix:colon
id|multipath_diskop
comma
)brace
suffix:semicolon
DECL|function|multipath_init
r_static
r_int
id|__init
id|multipath_init
(paren
r_void
)paren
(brace
r_return
id|register_md_personality
(paren
id|MULTIPATH
comma
op_amp
id|multipath_personality
)paren
suffix:semicolon
)brace
DECL|function|multipath_exit
r_static
r_void
id|__exit
id|multipath_exit
(paren
r_void
)paren
(brace
id|unregister_md_personality
(paren
id|MULTIPATH
)paren
suffix:semicolon
)brace
DECL|variable|multipath_init
id|module_init
c_func
(paren
id|multipath_init
)paren
suffix:semicolon
DECL|variable|multipath_exit
id|module_exit
c_func
(paren
id|multipath_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
