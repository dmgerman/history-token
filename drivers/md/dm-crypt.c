multiline_comment|/*&n; * Copyright (C) 2003 Christophe Saout &lt;christophe@saout.de&gt;&n; * Copyright (C) 2004 Clemens Fruhwirth &lt;clemens@endorphin.org&gt;&n; *&n; * This file is released under the GPL.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/crypto.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/scatterlist.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &quot;dm.h&quot;
DECL|macro|PFX
mdefine_line|#define PFX&t;&quot;crypt: &quot;
multiline_comment|/*&n; * per bio private data&n; */
DECL|struct|crypt_io
r_struct
id|crypt_io
(brace
DECL|member|target
r_struct
id|dm_target
op_star
id|target
suffix:semicolon
DECL|member|bio
r_struct
id|bio
op_star
id|bio
suffix:semicolon
DECL|member|first_clone
r_struct
id|bio
op_star
id|first_clone
suffix:semicolon
DECL|member|work
r_struct
id|work_struct
id|work
suffix:semicolon
DECL|member|pending
id|atomic_t
id|pending
suffix:semicolon
DECL|member|error
r_int
id|error
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * context holding the current state of a multi-part conversion&n; */
DECL|struct|convert_context
r_struct
id|convert_context
(brace
DECL|member|bio_in
r_struct
id|bio
op_star
id|bio_in
suffix:semicolon
DECL|member|bio_out
r_struct
id|bio
op_star
id|bio_out
suffix:semicolon
DECL|member|offset_in
r_int
r_int
id|offset_in
suffix:semicolon
DECL|member|offset_out
r_int
r_int
id|offset_out
suffix:semicolon
DECL|member|idx_in
r_int
r_int
id|idx_in
suffix:semicolon
DECL|member|idx_out
r_int
r_int
id|idx_out
suffix:semicolon
DECL|member|sector
id|sector_t
id|sector
suffix:semicolon
DECL|member|write
r_int
id|write
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|crypt_config
suffix:semicolon
DECL|struct|crypt_iv_operations
r_struct
id|crypt_iv_operations
(brace
DECL|member|ctr
r_int
(paren
op_star
id|ctr
)paren
(paren
r_struct
id|crypt_config
op_star
id|cc
comma
r_struct
id|dm_target
op_star
id|ti
comma
r_const
r_char
op_star
id|opts
)paren
suffix:semicolon
DECL|member|dtr
r_void
(paren
op_star
id|dtr
)paren
(paren
r_struct
id|crypt_config
op_star
id|cc
)paren
suffix:semicolon
DECL|member|status
r_const
r_char
op_star
(paren
op_star
id|status
)paren
(paren
r_struct
id|crypt_config
op_star
id|cc
)paren
suffix:semicolon
DECL|member|generator
r_int
(paren
op_star
id|generator
)paren
(paren
r_struct
id|crypt_config
op_star
id|cc
comma
id|u8
op_star
id|iv
comma
id|sector_t
id|sector
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Crypt: maps a linear range of a block device&n; * and encrypts / decrypts at the same time.&n; */
DECL|struct|crypt_config
r_struct
id|crypt_config
(brace
DECL|member|dev
r_struct
id|dm_dev
op_star
id|dev
suffix:semicolon
DECL|member|start
id|sector_t
id|start
suffix:semicolon
multiline_comment|/*&n;&t; * pool for per bio private data and&n;&t; * for encryption buffer pages&n;&t; */
DECL|member|io_pool
id|mempool_t
op_star
id|io_pool
suffix:semicolon
DECL|member|page_pool
id|mempool_t
op_star
id|page_pool
suffix:semicolon
multiline_comment|/*&n;&t; * crypto related data&n;&t; */
DECL|member|iv_gen_ops
r_struct
id|crypt_iv_operations
op_star
id|iv_gen_ops
suffix:semicolon
DECL|member|iv_mode
r_char
op_star
id|iv_mode
suffix:semicolon
DECL|member|iv_gen_private
r_void
op_star
id|iv_gen_private
suffix:semicolon
DECL|member|iv_offset
id|sector_t
id|iv_offset
suffix:semicolon
DECL|member|iv_size
r_int
r_int
id|iv_size
suffix:semicolon
DECL|member|tfm
r_struct
id|crypto_tfm
op_star
id|tfm
suffix:semicolon
DECL|member|key_size
r_int
r_int
id|key_size
suffix:semicolon
DECL|member|key
id|u8
id|key
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|MIN_IOS
mdefine_line|#define MIN_IOS        256
DECL|macro|MIN_POOL_PAGES
mdefine_line|#define MIN_POOL_PAGES 32
DECL|macro|MIN_BIO_PAGES
mdefine_line|#define MIN_BIO_PAGES  8
DECL|variable|_crypt_io_pool
r_static
id|kmem_cache_t
op_star
id|_crypt_io_pool
suffix:semicolon
multiline_comment|/*&n; * Mempool alloc and free functions for the page&n; */
DECL|function|mempool_alloc_page
r_static
r_void
op_star
id|mempool_alloc_page
c_func
(paren
r_int
id|gfp_mask
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|alloc_page
c_func
(paren
id|gfp_mask
)paren
suffix:semicolon
)brace
DECL|function|mempool_free_page
r_static
r_void
id|mempool_free_page
c_func
(paren
r_void
op_star
id|page
comma
r_void
op_star
id|data
)paren
(brace
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Different IV generation algorithms:&n; *&n; * plain: the initial vector is the 32-bit low-endian version of the sector&n; *        number, padded with zeros if neccessary.&n; *&n; * ess_iv: &quot;encrypted sector|salt initial vector&quot;, the sector number is&n; *         encrypted with the bulk cipher using a salt as key. The salt&n; *         should be derived from the bulk cipher&squot;s key via hashing.&n; *&n; * plumb: unimplemented, see:&n; * http://article.gmane.org/gmane.linux.kernel.device-mapper.dm-crypt/454&n; */
DECL|function|crypt_iv_plain_gen
r_static
r_int
id|crypt_iv_plain_gen
c_func
(paren
r_struct
id|crypt_config
op_star
id|cc
comma
id|u8
op_star
id|iv
comma
id|sector_t
id|sector
)paren
(brace
id|memset
c_func
(paren
id|iv
comma
l_int|0
comma
id|cc-&gt;iv_size
)paren
suffix:semicolon
op_star
(paren
id|u32
op_star
)paren
id|iv
op_assign
id|cpu_to_le32
c_func
(paren
id|sector
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|crypt_iv_essiv_ctr
r_static
r_int
id|crypt_iv_essiv_ctr
c_func
(paren
r_struct
id|crypt_config
op_star
id|cc
comma
r_struct
id|dm_target
op_star
id|ti
comma
r_const
r_char
op_star
id|opts
)paren
(brace
r_struct
id|crypto_tfm
op_star
id|essiv_tfm
suffix:semicolon
r_struct
id|crypto_tfm
op_star
id|hash_tfm
suffix:semicolon
r_struct
id|scatterlist
id|sg
suffix:semicolon
r_int
r_int
id|saltsize
suffix:semicolon
id|u8
op_star
id|salt
suffix:semicolon
r_if
c_cond
(paren
id|opts
op_eq
l_int|NULL
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Digest algorithm missing for ESSIV mode&quot;
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Hash the cipher key with the given hash algorithm */
id|hash_tfm
op_assign
id|crypto_alloc_tfm
c_func
(paren
id|opts
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hash_tfm
op_eq
l_int|NULL
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Error initializing ESSIV hash&quot;
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|crypto_tfm_alg_type
c_func
(paren
id|hash_tfm
)paren
op_ne
id|CRYPTO_ALG_TYPE_DIGEST
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Expected digest algorithm for ESSIV hash&quot;
suffix:semicolon
id|crypto_free_tfm
c_func
(paren
id|hash_tfm
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|saltsize
op_assign
id|crypto_tfm_alg_digestsize
c_func
(paren
id|hash_tfm
)paren
suffix:semicolon
id|salt
op_assign
id|kmalloc
c_func
(paren
id|saltsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|salt
op_eq
l_int|NULL
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Error kmallocing salt storage in ESSIV&quot;
suffix:semicolon
id|crypto_free_tfm
c_func
(paren
id|hash_tfm
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|sg.page
op_assign
id|virt_to_page
c_func
(paren
id|cc-&gt;key
)paren
suffix:semicolon
id|sg.offset
op_assign
id|offset_in_page
c_func
(paren
id|cc-&gt;key
)paren
suffix:semicolon
id|sg.length
op_assign
id|cc-&gt;key_size
suffix:semicolon
id|crypto_digest_digest
c_func
(paren
id|hash_tfm
comma
op_amp
id|sg
comma
l_int|1
comma
id|salt
)paren
suffix:semicolon
id|crypto_free_tfm
c_func
(paren
id|hash_tfm
)paren
suffix:semicolon
multiline_comment|/* Setup the essiv_tfm with the given salt */
id|essiv_tfm
op_assign
id|crypto_alloc_tfm
c_func
(paren
id|crypto_tfm_alg_name
c_func
(paren
id|cc-&gt;tfm
)paren
comma
id|CRYPTO_TFM_MODE_ECB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|essiv_tfm
op_eq
l_int|NULL
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Error allocating crypto tfm for ESSIV&quot;
suffix:semicolon
id|kfree
c_func
(paren
id|salt
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|crypto_tfm_alg_blocksize
c_func
(paren
id|essiv_tfm
)paren
op_ne
id|crypto_tfm_alg_ivsize
c_func
(paren
id|cc-&gt;tfm
)paren
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Block size of ESSIV cipher does &quot;
l_string|&quot;not match IV size of block cipher&quot;
suffix:semicolon
id|crypto_free_tfm
c_func
(paren
id|essiv_tfm
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|salt
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|crypto_cipher_setkey
c_func
(paren
id|essiv_tfm
comma
id|salt
comma
id|saltsize
)paren
OL
l_int|0
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Failed to set key for ESSIV cipher&quot;
suffix:semicolon
id|crypto_free_tfm
c_func
(paren
id|essiv_tfm
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|salt
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|salt
)paren
suffix:semicolon
id|cc-&gt;iv_gen_private
op_assign
(paren
r_void
op_star
)paren
id|essiv_tfm
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|crypt_iv_essiv_dtr
r_static
r_void
id|crypt_iv_essiv_dtr
c_func
(paren
r_struct
id|crypt_config
op_star
id|cc
)paren
(brace
id|crypto_free_tfm
c_func
(paren
(paren
r_struct
id|crypto_tfm
op_star
)paren
id|cc-&gt;iv_gen_private
)paren
suffix:semicolon
id|cc-&gt;iv_gen_private
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|crypt_iv_essiv_gen
r_static
r_int
id|crypt_iv_essiv_gen
c_func
(paren
r_struct
id|crypt_config
op_star
id|cc
comma
id|u8
op_star
id|iv
comma
id|sector_t
id|sector
)paren
(brace
r_struct
id|scatterlist
id|sg
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
id|memset
c_func
(paren
id|iv
comma
l_int|0
comma
id|cc-&gt;iv_size
)paren
suffix:semicolon
op_star
(paren
id|u64
op_star
)paren
id|iv
op_assign
id|cpu_to_le64
c_func
(paren
id|sector
)paren
suffix:semicolon
id|sg.page
op_assign
id|virt_to_page
c_func
(paren
id|iv
)paren
suffix:semicolon
id|sg.offset
op_assign
id|offset_in_page
c_func
(paren
id|iv
)paren
suffix:semicolon
id|sg.length
op_assign
id|cc-&gt;iv_size
suffix:semicolon
id|crypto_cipher_encrypt
c_func
(paren
(paren
r_struct
id|crypto_tfm
op_star
)paren
id|cc-&gt;iv_gen_private
comma
op_amp
id|sg
comma
op_amp
id|sg
comma
id|cc-&gt;iv_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|crypt_iv_plain_ops
r_static
r_struct
id|crypt_iv_operations
id|crypt_iv_plain_ops
op_assign
(brace
dot
id|generator
op_assign
id|crypt_iv_plain_gen
)brace
suffix:semicolon
DECL|variable|crypt_iv_essiv_ops
r_static
r_struct
id|crypt_iv_operations
id|crypt_iv_essiv_ops
op_assign
(brace
dot
id|ctr
op_assign
id|crypt_iv_essiv_ctr
comma
dot
id|dtr
op_assign
id|crypt_iv_essiv_dtr
comma
dot
id|generator
op_assign
id|crypt_iv_essiv_gen
)brace
suffix:semicolon
r_static
r_inline
r_int
DECL|function|crypt_convert_scatterlist
id|crypt_convert_scatterlist
c_func
(paren
r_struct
id|crypt_config
op_star
id|cc
comma
r_struct
id|scatterlist
op_star
id|out
comma
r_struct
id|scatterlist
op_star
id|in
comma
r_int
r_int
id|length
comma
r_int
id|write
comma
id|sector_t
id|sector
)paren
(brace
id|u8
id|iv
(braket
id|cc-&gt;iv_size
)braket
suffix:semicolon
r_int
id|r
suffix:semicolon
r_if
c_cond
(paren
id|cc-&gt;iv_gen_ops
)paren
(brace
id|r
op_assign
id|cc-&gt;iv_gen_ops
op_member_access_from_pointer
id|generator
c_func
(paren
id|cc
comma
id|iv
comma
id|sector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
r_return
id|r
suffix:semicolon
r_if
c_cond
(paren
id|write
)paren
id|r
op_assign
id|crypto_cipher_encrypt_iv
c_func
(paren
id|cc-&gt;tfm
comma
id|out
comma
id|in
comma
id|length
comma
id|iv
)paren
suffix:semicolon
r_else
id|r
op_assign
id|crypto_cipher_decrypt_iv
c_func
(paren
id|cc-&gt;tfm
comma
id|out
comma
id|in
comma
id|length
comma
id|iv
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|write
)paren
id|r
op_assign
id|crypto_cipher_encrypt
c_func
(paren
id|cc-&gt;tfm
comma
id|out
comma
id|in
comma
id|length
)paren
suffix:semicolon
r_else
id|r
op_assign
id|crypto_cipher_decrypt
c_func
(paren
id|cc-&gt;tfm
comma
id|out
comma
id|in
comma
id|length
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
r_static
r_void
DECL|function|crypt_convert_init
id|crypt_convert_init
c_func
(paren
r_struct
id|crypt_config
op_star
id|cc
comma
r_struct
id|convert_context
op_star
id|ctx
comma
r_struct
id|bio
op_star
id|bio_out
comma
r_struct
id|bio
op_star
id|bio_in
comma
id|sector_t
id|sector
comma
r_int
id|write
)paren
(brace
id|ctx-&gt;bio_in
op_assign
id|bio_in
suffix:semicolon
id|ctx-&gt;bio_out
op_assign
id|bio_out
suffix:semicolon
id|ctx-&gt;offset_in
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;offset_out
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;idx_in
op_assign
id|bio_in
ques
c_cond
id|bio_in-&gt;bi_idx
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;idx_out
op_assign
id|bio_out
ques
c_cond
id|bio_out-&gt;bi_idx
suffix:colon
l_int|0
suffix:semicolon
id|ctx-&gt;sector
op_assign
id|sector
op_plus
id|cc-&gt;iv_offset
suffix:semicolon
id|ctx-&gt;write
op_assign
id|write
suffix:semicolon
)brace
multiline_comment|/*&n; * Encrypt / decrypt data from one bio to another one (can be the same one)&n; */
DECL|function|crypt_convert
r_static
r_int
id|crypt_convert
c_func
(paren
r_struct
id|crypt_config
op_star
id|cc
comma
r_struct
id|convert_context
op_star
id|ctx
)paren
(brace
r_int
id|r
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ctx-&gt;idx_in
OL
id|ctx-&gt;bio_in-&gt;bi_vcnt
op_logical_and
id|ctx-&gt;idx_out
OL
id|ctx-&gt;bio_out-&gt;bi_vcnt
)paren
(brace
r_struct
id|bio_vec
op_star
id|bv_in
op_assign
id|bio_iovec_idx
c_func
(paren
id|ctx-&gt;bio_in
comma
id|ctx-&gt;idx_in
)paren
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bv_out
op_assign
id|bio_iovec_idx
c_func
(paren
id|ctx-&gt;bio_out
comma
id|ctx-&gt;idx_out
)paren
suffix:semicolon
r_struct
id|scatterlist
id|sg_in
op_assign
(brace
dot
id|page
op_assign
id|bv_in-&gt;bv_page
comma
dot
id|offset
op_assign
id|bv_in-&gt;bv_offset
op_plus
id|ctx-&gt;offset_in
comma
dot
id|length
op_assign
l_int|1
op_lshift
id|SECTOR_SHIFT
)brace
suffix:semicolon
r_struct
id|scatterlist
id|sg_out
op_assign
(brace
dot
id|page
op_assign
id|bv_out-&gt;bv_page
comma
dot
id|offset
op_assign
id|bv_out-&gt;bv_offset
op_plus
id|ctx-&gt;offset_out
comma
dot
id|length
op_assign
l_int|1
op_lshift
id|SECTOR_SHIFT
)brace
suffix:semicolon
id|ctx-&gt;offset_in
op_add_assign
id|sg_in.length
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;offset_in
op_ge
id|bv_in-&gt;bv_len
)paren
(brace
id|ctx-&gt;offset_in
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;idx_in
op_increment
suffix:semicolon
)brace
id|ctx-&gt;offset_out
op_add_assign
id|sg_out.length
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;offset_out
op_ge
id|bv_out-&gt;bv_len
)paren
(brace
id|ctx-&gt;offset_out
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;idx_out
op_increment
suffix:semicolon
)brace
id|r
op_assign
id|crypt_convert_scatterlist
c_func
(paren
id|cc
comma
op_amp
id|sg_out
comma
op_amp
id|sg_in
comma
id|sg_in.length
comma
id|ctx-&gt;write
comma
id|ctx-&gt;sector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
r_break
suffix:semicolon
id|ctx-&gt;sector
op_increment
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * Generate a new unfragmented bio with the given size&n; * This should never violate the device limitations&n; * May return a smaller bio when running out of pages&n; */
r_static
r_struct
id|bio
op_star
DECL|function|crypt_alloc_buffer
id|crypt_alloc_buffer
c_func
(paren
r_struct
id|crypt_config
op_star
id|cc
comma
r_int
r_int
id|size
comma
r_struct
id|bio
op_star
id|base_bio
comma
r_int
r_int
op_star
id|bio_vec_idx
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
r_int
id|nr_iovecs
op_assign
(paren
id|size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_int
id|gfp_mask
op_assign
id|GFP_NOIO
op_or
id|__GFP_HIGHMEM
suffix:semicolon
r_int
r_int
id|flags
op_assign
id|current-&gt;flags
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Tell VM to act less aggressively and fail earlier.&n;&t; * This is not necessary but increases throughput.&n;&t; * FIXME: Is this really intelligent?&n;&t; */
id|current-&gt;flags
op_and_assign
op_complement
id|PF_MEMALLOC
suffix:semicolon
r_if
c_cond
(paren
id|base_bio
)paren
id|bio
op_assign
id|bio_clone
c_func
(paren
id|base_bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_else
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOIO
comma
id|nr_iovecs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PF_MEMALLOC
)paren
id|current-&gt;flags
op_or_assign
id|PF_MEMALLOC
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* if the last bio was not complete, continue where that one ended */
id|bio-&gt;bi_idx
op_assign
op_star
id|bio_vec_idx
suffix:semicolon
id|bio-&gt;bi_vcnt
op_assign
op_star
id|bio_vec_idx
suffix:semicolon
id|bio-&gt;bi_size
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|BIO_SEG_VALID
)paren
suffix:semicolon
multiline_comment|/* bio-&gt;bi_idx pages have already been allocated */
id|size
op_sub_assign
id|bio-&gt;bi_idx
op_star
id|PAGE_SIZE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|bio-&gt;bi_idx
suffix:semicolon
id|i
OL
id|nr_iovecs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|bio_vec
op_star
id|bv
op_assign
id|bio_iovec_idx
c_func
(paren
id|bio
comma
id|i
)paren
suffix:semicolon
id|bv-&gt;bv_page
op_assign
id|mempool_alloc
c_func
(paren
id|cc-&gt;page_pool
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bv-&gt;bv_page
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if additional pages cannot be allocated without waiting,&n;&t;&t; * return a partially allocated bio, the caller will then try&n;&t;&t; * to allocate additional bios while submitting this partial bio&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|i
op_minus
id|bio-&gt;bi_idx
)paren
op_eq
(paren
id|MIN_BIO_PAGES
op_minus
l_int|1
)paren
)paren
id|gfp_mask
op_assign
(paren
id|gfp_mask
op_or
id|__GFP_NOWARN
)paren
op_amp
op_complement
id|__GFP_WAIT
suffix:semicolon
id|bv-&gt;bv_offset
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|bv-&gt;bv_len
op_assign
id|PAGE_SIZE
suffix:semicolon
r_else
id|bv-&gt;bv_len
op_assign
id|size
suffix:semicolon
id|bio-&gt;bi_size
op_add_assign
id|bv-&gt;bv_len
suffix:semicolon
id|bio-&gt;bi_vcnt
op_increment
suffix:semicolon
id|size
op_sub_assign
id|bv-&gt;bv_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|PF_MEMALLOC
)paren
id|current-&gt;flags
op_or_assign
id|PF_MEMALLOC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio-&gt;bi_size
)paren
(brace
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Remember the last bio_vec allocated to be able&n;&t; * to correctly continue after the splitting.&n;&t; */
op_star
id|bio_vec_idx
op_assign
id|bio-&gt;bi_vcnt
suffix:semicolon
r_return
id|bio
suffix:semicolon
)brace
DECL|function|crypt_free_buffer_pages
r_static
r_void
id|crypt_free_buffer_pages
c_func
(paren
r_struct
id|crypt_config
op_star
id|cc
comma
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes
)paren
(brace
r_int
r_int
id|i
comma
id|start
comma
id|end
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bv
suffix:semicolon
multiline_comment|/*&n;&t; * This is ugly, but Jens Axboe thinks that using bi_idx in the&n;&t; * endio function is too dangerous at the moment, so I calculate the&n;&t; * correct position using bi_vcnt and bi_size.&n;&t; * The bv_offset and bv_len fields might already be modified but we&n;&t; * know that we always allocated whole pages.&n;&t; * A fix to the bi_idx issue in the kernel is in the works, so&n;&t; * we will hopefully be able to revert to the cleaner solution soon.&n;&t; */
id|i
op_assign
id|bio-&gt;bi_vcnt
op_minus
l_int|1
suffix:semicolon
id|bv
op_assign
id|bio_iovec_idx
c_func
(paren
id|bio
comma
id|i
)paren
suffix:semicolon
id|end
op_assign
(paren
id|i
op_lshift
id|PAGE_SHIFT
)paren
op_plus
(paren
id|bv-&gt;bv_offset
op_plus
id|bv-&gt;bv_len
)paren
op_minus
id|bio-&gt;bi_size
suffix:semicolon
id|start
op_assign
id|end
op_minus
id|bytes
suffix:semicolon
id|start
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio-&gt;bi_size
)paren
id|end
op_assign
id|bio-&gt;bi_vcnt
suffix:semicolon
r_else
id|end
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|start
suffix:semicolon
id|i
OL
id|end
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bv
op_assign
id|bio_iovec_idx
c_func
(paren
id|bio
comma
id|i
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bv-&gt;bv_page
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|bv-&gt;bv_page
comma
id|cc-&gt;page_pool
)paren
suffix:semicolon
id|bv-&gt;bv_page
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * One of the bios was finished. Check for completion of&n; * the whole request and correctly clean up the buffer.&n; */
DECL|function|dec_pending
r_static
r_void
id|dec_pending
c_func
(paren
r_struct
id|crypt_io
op_star
id|io
comma
r_int
id|error
)paren
(brace
r_struct
id|crypt_config
op_star
id|cc
op_assign
(paren
r_struct
id|crypt_config
op_star
)paren
id|io-&gt;target
op_member_access_from_pointer
r_private
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
id|io-&gt;error
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|io-&gt;pending
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|io-&gt;first_clone
)paren
id|bio_put
c_func
(paren
id|io-&gt;first_clone
)paren
suffix:semicolon
id|bio_endio
c_func
(paren
id|io-&gt;bio
comma
id|io-&gt;bio-&gt;bi_size
comma
id|io-&gt;error
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|io
comma
id|cc-&gt;io_pool
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * kcryptd:&n; *&n; * Needed because it would be very unwise to do decryption in an&n; * interrupt context, so bios returning from read requests get&n; * queued here.&n; */
DECL|variable|_kcryptd_workqueue
r_static
r_struct
id|workqueue_struct
op_star
id|_kcryptd_workqueue
suffix:semicolon
DECL|function|kcryptd_do_work
r_static
r_void
id|kcryptd_do_work
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|crypt_io
op_star
id|io
op_assign
(paren
r_struct
id|crypt_io
op_star
)paren
id|data
suffix:semicolon
r_struct
id|crypt_config
op_star
id|cc
op_assign
(paren
r_struct
id|crypt_config
op_star
)paren
id|io-&gt;target
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|convert_context
id|ctx
suffix:semicolon
r_int
id|r
suffix:semicolon
id|crypt_convert_init
c_func
(paren
id|cc
comma
op_amp
id|ctx
comma
id|io-&gt;bio
comma
id|io-&gt;bio
comma
id|io-&gt;bio-&gt;bi_sector
op_minus
id|io-&gt;target-&gt;begin
comma
l_int|0
)paren
suffix:semicolon
id|r
op_assign
id|crypt_convert
c_func
(paren
id|cc
comma
op_amp
id|ctx
)paren
suffix:semicolon
id|dec_pending
c_func
(paren
id|io
comma
id|r
)paren
suffix:semicolon
)brace
DECL|function|kcryptd_queue_io
r_static
r_void
id|kcryptd_queue_io
c_func
(paren
r_struct
id|crypt_io
op_star
id|io
)paren
(brace
id|INIT_WORK
c_func
(paren
op_amp
id|io-&gt;work
comma
id|kcryptd_do_work
comma
id|io
)paren
suffix:semicolon
id|queue_work
c_func
(paren
id|_kcryptd_workqueue
comma
op_amp
id|io-&gt;work
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Decode key from its hex representation&n; */
DECL|function|crypt_decode_key
r_static
r_int
id|crypt_decode_key
c_func
(paren
id|u8
op_star
id|key
comma
r_char
op_star
id|hex
comma
r_int
r_int
id|size
)paren
(brace
r_char
id|buffer
(braket
l_int|3
)braket
suffix:semicolon
r_char
op_star
id|endp
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|buffer
(braket
l_int|2
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buffer
(braket
l_int|0
)braket
op_assign
op_star
id|hex
op_increment
suffix:semicolon
id|buffer
(braket
l_int|1
)braket
op_assign
op_star
id|hex
op_increment
suffix:semicolon
id|key
(braket
id|i
)braket
op_assign
(paren
id|u8
)paren
id|simple_strtoul
c_func
(paren
id|buffer
comma
op_amp
id|endp
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|endp
op_ne
op_amp
id|buffer
(braket
l_int|2
)braket
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|hex
op_ne
l_char|&squot;&bslash;0&squot;
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Encode key into its hex representation&n; */
DECL|function|crypt_encode_key
r_static
r_void
id|crypt_encode_key
c_func
(paren
r_char
op_star
id|hex
comma
id|u8
op_star
id|key
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|hex
comma
l_string|&quot;%02x&quot;
comma
op_star
id|key
)paren
suffix:semicolon
id|hex
op_add_assign
l_int|2
suffix:semicolon
id|key
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Construct an encryption mapping:&n; * &lt;cipher&gt; &lt;key&gt; &lt;iv_offset&gt; &lt;dev_path&gt; &lt;start&gt;&n; */
DECL|function|crypt_ctr
r_static
r_int
id|crypt_ctr
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_int
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_struct
id|crypt_config
op_star
id|cc
suffix:semicolon
r_struct
id|crypto_tfm
op_star
id|tfm
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
r_char
op_star
id|cipher
suffix:semicolon
r_char
op_star
id|chainmode
suffix:semicolon
r_char
op_star
id|ivmode
suffix:semicolon
r_char
op_star
id|ivopts
suffix:semicolon
r_int
r_int
id|crypto_flags
suffix:semicolon
r_int
r_int
id|key_size
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_ne
l_int|5
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Not enough arguments&quot;
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|tmp
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
id|cipher
op_assign
id|strsep
c_func
(paren
op_amp
id|tmp
comma
l_string|&quot;-&quot;
)paren
suffix:semicolon
id|chainmode
op_assign
id|strsep
c_func
(paren
op_amp
id|tmp
comma
l_string|&quot;-&quot;
)paren
suffix:semicolon
id|ivopts
op_assign
id|strsep
c_func
(paren
op_amp
id|tmp
comma
l_string|&quot;-&quot;
)paren
suffix:semicolon
id|ivmode
op_assign
id|strsep
c_func
(paren
op_amp
id|ivopts
comma
l_string|&quot;:&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
id|DMWARN
c_func
(paren
id|PFX
l_string|&quot;Unexpected additional cipher options&quot;
)paren
suffix:semicolon
id|key_size
op_assign
id|strlen
c_func
(paren
id|argv
(braket
l_int|1
)braket
)paren
op_rshift
l_int|1
suffix:semicolon
id|cc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|cc
)paren
op_plus
id|key_size
op_star
r_sizeof
(paren
id|u8
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_eq
l_int|NULL
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Cannot allocate transparent encryption context&quot;
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|cc-&gt;key_size
op_assign
id|key_size
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|key_size
op_logical_and
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-&quot;
)paren
op_ne
l_int|0
)paren
op_logical_or
(paren
id|key_size
op_logical_and
id|crypt_decode_key
c_func
(paren
id|cc-&gt;key
comma
id|argv
(braket
l_int|1
)braket
comma
id|key_size
)paren
OL
l_int|0
)paren
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Error decoding key&quot;
suffix:semicolon
r_goto
id|bad1
suffix:semicolon
)brace
multiline_comment|/* Compatiblity mode for old dm-crypt cipher strings */
r_if
c_cond
(paren
op_logical_neg
id|chainmode
op_logical_or
(paren
id|strcmp
c_func
(paren
id|chainmode
comma
l_string|&quot;plain&quot;
)paren
op_eq
l_int|0
op_logical_and
op_logical_neg
id|ivmode
)paren
)paren
(brace
id|chainmode
op_assign
l_string|&quot;cbc&quot;
suffix:semicolon
id|ivmode
op_assign
l_string|&quot;plain&quot;
suffix:semicolon
)brace
multiline_comment|/* Choose crypto_flags according to chainmode */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|chainmode
comma
l_string|&quot;cbc&quot;
)paren
op_eq
l_int|0
)paren
id|crypto_flags
op_assign
id|CRYPTO_TFM_MODE_CBC
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|chainmode
comma
l_string|&quot;ecb&quot;
)paren
op_eq
l_int|0
)paren
id|crypto_flags
op_assign
id|CRYPTO_TFM_MODE_ECB
suffix:semicolon
r_else
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Unknown chaining mode&quot;
suffix:semicolon
r_goto
id|bad1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|crypto_flags
op_ne
id|CRYPTO_TFM_MODE_ECB
op_logical_and
op_logical_neg
id|ivmode
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;This chaining mode requires an IV mechanism&quot;
suffix:semicolon
r_goto
id|bad1
suffix:semicolon
)brace
id|tfm
op_assign
id|crypto_alloc_tfm
c_func
(paren
id|cipher
comma
id|crypto_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tfm
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Error allocating crypto tfm&quot;
suffix:semicolon
r_goto
id|bad1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|crypto_tfm_alg_type
c_func
(paren
id|tfm
)paren
op_ne
id|CRYPTO_ALG_TYPE_CIPHER
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Expected cipher algorithm&quot;
suffix:semicolon
r_goto
id|bad2
suffix:semicolon
)brace
id|cc-&gt;tfm
op_assign
id|tfm
suffix:semicolon
multiline_comment|/*&n;&t; * Choose ivmode. Valid modes: &quot;plain&quot;, &quot;essiv:&lt;esshash&gt;&quot;.&n;&t; * See comments at iv code&n;&t; */
r_if
c_cond
(paren
id|ivmode
op_eq
l_int|NULL
)paren
id|cc-&gt;iv_gen_ops
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ivmode
comma
l_string|&quot;plain&quot;
)paren
op_eq
l_int|0
)paren
id|cc-&gt;iv_gen_ops
op_assign
op_amp
id|crypt_iv_plain_ops
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ivmode
comma
l_string|&quot;essiv&quot;
)paren
op_eq
l_int|0
)paren
id|cc-&gt;iv_gen_ops
op_assign
op_amp
id|crypt_iv_essiv_ops
suffix:semicolon
r_else
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Invalid IV mode&quot;
suffix:semicolon
r_goto
id|bad2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cc-&gt;iv_gen_ops
op_logical_and
id|cc-&gt;iv_gen_ops-&gt;ctr
op_logical_and
id|cc-&gt;iv_gen_ops
op_member_access_from_pointer
id|ctr
c_func
(paren
id|cc
comma
id|ti
comma
id|ivopts
)paren
OL
l_int|0
)paren
r_goto
id|bad2
suffix:semicolon
r_if
c_cond
(paren
id|tfm-&gt;crt_cipher.cit_decrypt_iv
op_logical_and
id|tfm-&gt;crt_cipher.cit_encrypt_iv
)paren
multiline_comment|/* at least a 64 bit sector number should fit in our buffer */
id|cc-&gt;iv_size
op_assign
id|max
c_func
(paren
id|crypto_tfm_alg_ivsize
c_func
(paren
id|tfm
)paren
comma
(paren
r_int
r_int
)paren
(paren
r_sizeof
(paren
id|u64
)paren
op_div
r_sizeof
(paren
id|u8
)paren
)paren
)paren
suffix:semicolon
r_else
(brace
id|cc-&gt;iv_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cc-&gt;iv_gen_ops
)paren
(brace
id|DMWARN
c_func
(paren
id|PFX
l_string|&quot;Selected cipher does not support IVs&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc-&gt;iv_gen_ops-&gt;dtr
)paren
id|cc-&gt;iv_gen_ops
op_member_access_from_pointer
id|dtr
c_func
(paren
id|cc
)paren
suffix:semicolon
id|cc-&gt;iv_gen_ops
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|cc-&gt;io_pool
op_assign
id|mempool_create
c_func
(paren
id|MIN_IOS
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|_crypt_io_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cc-&gt;io_pool
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Cannot allocate crypt io mempool&quot;
suffix:semicolon
r_goto
id|bad3
suffix:semicolon
)brace
id|cc-&gt;page_pool
op_assign
id|mempool_create
c_func
(paren
id|MIN_POOL_PAGES
comma
id|mempool_alloc_page
comma
id|mempool_free_page
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cc-&gt;page_pool
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Cannot allocate page mempool&quot;
suffix:semicolon
r_goto
id|bad4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tfm-&gt;crt_cipher
dot
id|cit_setkey
c_func
(paren
id|tfm
comma
id|cc-&gt;key
comma
id|key_size
)paren
OL
l_int|0
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Error setting key&quot;
suffix:semicolon
r_goto
id|bad5
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sscanf
c_func
(paren
id|argv
(braket
l_int|2
)braket
comma
id|SECTOR_FORMAT
comma
op_amp
id|cc-&gt;iv_offset
)paren
op_ne
l_int|1
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Invalid iv_offset sector&quot;
suffix:semicolon
r_goto
id|bad5
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sscanf
c_func
(paren
id|argv
(braket
l_int|4
)braket
comma
id|SECTOR_FORMAT
comma
op_amp
id|cc-&gt;start
)paren
op_ne
l_int|1
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Invalid device sector&quot;
suffix:semicolon
r_goto
id|bad5
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dm_get_device
c_func
(paren
id|ti
comma
id|argv
(braket
l_int|3
)braket
comma
id|cc-&gt;start
comma
id|ti-&gt;len
comma
id|dm_table_get_mode
c_func
(paren
id|ti-&gt;table
)paren
comma
op_amp
id|cc-&gt;dev
)paren
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Device lookup failed&quot;
suffix:semicolon
r_goto
id|bad5
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ivmode
op_logical_and
id|cc-&gt;iv_gen_ops
)paren
(brace
r_if
c_cond
(paren
id|ivopts
)paren
op_star
(paren
id|ivopts
op_minus
l_int|1
)paren
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|cc-&gt;iv_mode
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|ivmode
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cc-&gt;iv_mode
)paren
(brace
id|ti-&gt;error
op_assign
id|PFX
l_string|&quot;Error kmallocing iv_mode string&quot;
suffix:semicolon
r_goto
id|bad5
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|cc-&gt;iv_mode
comma
id|ivmode
)paren
suffix:semicolon
)brace
r_else
id|cc-&gt;iv_mode
op_assign
l_int|NULL
suffix:semicolon
id|ti
op_member_access_from_pointer
r_private
op_assign
id|cc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bad5
suffix:colon
id|mempool_destroy
c_func
(paren
id|cc-&gt;page_pool
)paren
suffix:semicolon
id|bad4
suffix:colon
id|mempool_destroy
c_func
(paren
id|cc-&gt;io_pool
)paren
suffix:semicolon
id|bad3
suffix:colon
r_if
c_cond
(paren
id|cc-&gt;iv_gen_ops
op_logical_and
id|cc-&gt;iv_gen_ops-&gt;dtr
)paren
id|cc-&gt;iv_gen_ops
op_member_access_from_pointer
id|dtr
c_func
(paren
id|cc
)paren
suffix:semicolon
id|bad2
suffix:colon
id|crypto_free_tfm
c_func
(paren
id|tfm
)paren
suffix:semicolon
id|bad1
suffix:colon
id|kfree
c_func
(paren
id|cc
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|crypt_dtr
r_static
r_void
id|crypt_dtr
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|crypt_config
op_star
id|cc
op_assign
(paren
r_struct
id|crypt_config
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|cc-&gt;page_pool
)paren
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|cc-&gt;io_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc-&gt;iv_mode
)paren
id|kfree
c_func
(paren
id|cc-&gt;iv_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc-&gt;iv_gen_ops
op_logical_and
id|cc-&gt;iv_gen_ops-&gt;dtr
)paren
id|cc-&gt;iv_gen_ops
op_member_access_from_pointer
id|dtr
c_func
(paren
id|cc
)paren
suffix:semicolon
id|crypto_free_tfm
c_func
(paren
id|cc-&gt;tfm
)paren
suffix:semicolon
id|dm_put_device
c_func
(paren
id|ti
comma
id|cc-&gt;dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cc
)paren
suffix:semicolon
)brace
DECL|function|crypt_endio
r_static
r_int
id|crypt_endio
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|done
comma
r_int
id|error
)paren
(brace
r_struct
id|crypt_io
op_star
id|io
op_assign
(paren
r_struct
id|crypt_io
op_star
)paren
id|bio-&gt;bi_private
suffix:semicolon
r_struct
id|crypt_config
op_star
id|cc
op_assign
(paren
r_struct
id|crypt_config
op_star
)paren
id|io-&gt;target
op_member_access_from_pointer
r_private
suffix:semicolon
r_if
c_cond
(paren
id|bio_data_dir
c_func
(paren
id|bio
)paren
op_eq
id|WRITE
)paren
(brace
multiline_comment|/*&n;&t;&t; * free the processed pages, even if&n;&t;&t; * it&squot;s only a partially completed write&n;&t;&t; */
id|crypt_free_buffer_pages
c_func
(paren
id|cc
comma
id|bio
comma
id|done
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * successful reads are decrypted by the worker thread&n;&t; */
r_if
c_cond
(paren
(paren
id|bio_data_dir
c_func
(paren
id|bio
)paren
op_eq
id|READ
)paren
op_logical_and
id|bio_flagged
c_func
(paren
id|bio
comma
id|BIO_UPTODATE
)paren
)paren
(brace
id|kcryptd_queue_io
c_func
(paren
id|io
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dec_pending
c_func
(paren
id|io
comma
id|error
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|bio
op_star
DECL|function|crypt_clone
id|crypt_clone
c_func
(paren
r_struct
id|crypt_config
op_star
id|cc
comma
r_struct
id|crypt_io
op_star
id|io
comma
r_struct
id|bio
op_star
id|bio
comma
id|sector_t
id|sector
comma
r_int
r_int
op_star
id|bvec_idx
comma
r_struct
id|convert_context
op_star
id|ctx
)paren
(brace
r_struct
id|bio
op_star
id|clone
suffix:semicolon
r_if
c_cond
(paren
id|bio_data_dir
c_func
(paren
id|bio
)paren
op_eq
id|WRITE
)paren
(brace
id|clone
op_assign
id|crypt_alloc_buffer
c_func
(paren
id|cc
comma
id|bio-&gt;bi_size
comma
id|io-&gt;first_clone
comma
id|bvec_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clone
)paren
(brace
id|ctx-&gt;bio_out
op_assign
id|clone
suffix:semicolon
r_if
c_cond
(paren
id|crypt_convert
c_func
(paren
id|cc
comma
id|ctx
)paren
OL
l_int|0
)paren
(brace
id|crypt_free_buffer_pages
c_func
(paren
id|cc
comma
id|clone
comma
id|clone-&gt;bi_size
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|clone
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The block layer might modify the bvec array, so always&n;&t;&t; * copy the required bvecs because we need the original&n;&t;&t; * one in order to decrypt the whole bio data *afterwards*.&n;&t;&t; */
id|clone
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOIO
comma
id|bio_segments
c_func
(paren
id|bio
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clone
)paren
(brace
id|clone-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|clone-&gt;bi_vcnt
op_assign
id|bio_segments
c_func
(paren
id|bio
)paren
suffix:semicolon
id|clone-&gt;bi_size
op_assign
id|bio-&gt;bi_size
suffix:semicolon
id|memcpy
c_func
(paren
id|clone-&gt;bi_io_vec
comma
id|bio_iovec
c_func
(paren
id|bio
)paren
comma
r_sizeof
(paren
r_struct
id|bio_vec
)paren
op_star
id|clone-&gt;bi_vcnt
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|clone
)paren
r_return
l_int|NULL
suffix:semicolon
id|clone-&gt;bi_private
op_assign
id|io
suffix:semicolon
id|clone-&gt;bi_end_io
op_assign
id|crypt_endio
suffix:semicolon
id|clone-&gt;bi_bdev
op_assign
id|cc-&gt;dev-&gt;bdev
suffix:semicolon
id|clone-&gt;bi_sector
op_assign
id|cc-&gt;start
op_plus
id|sector
suffix:semicolon
id|clone-&gt;bi_rw
op_assign
id|bio-&gt;bi_rw
suffix:semicolon
r_return
id|clone
suffix:semicolon
)brace
DECL|function|crypt_map
r_static
r_int
id|crypt_map
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_struct
id|bio
op_star
id|bio
comma
r_union
id|map_info
op_star
id|map_context
)paren
(brace
r_struct
id|crypt_config
op_star
id|cc
op_assign
(paren
r_struct
id|crypt_config
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|crypt_io
op_star
id|io
op_assign
id|mempool_alloc
c_func
(paren
id|cc-&gt;io_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_struct
id|convert_context
id|ctx
suffix:semicolon
r_struct
id|bio
op_star
id|clone
suffix:semicolon
r_int
r_int
id|remaining
op_assign
id|bio-&gt;bi_size
suffix:semicolon
id|sector_t
id|sector
op_assign
id|bio-&gt;bi_sector
op_minus
id|ti-&gt;begin
suffix:semicolon
r_int
r_int
id|bvec_idx
op_assign
l_int|0
suffix:semicolon
id|io-&gt;target
op_assign
id|ti
suffix:semicolon
id|io-&gt;bio
op_assign
id|bio
suffix:semicolon
id|io-&gt;first_clone
op_assign
l_int|NULL
suffix:semicolon
id|io-&gt;error
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|io-&gt;pending
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* hold a reference */
r_if
c_cond
(paren
id|bio_data_dir
c_func
(paren
id|bio
)paren
op_eq
id|WRITE
)paren
id|crypt_convert_init
c_func
(paren
id|cc
comma
op_amp
id|ctx
comma
l_int|NULL
comma
id|bio
comma
id|sector
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The allocated buffers can be smaller than the whole bio,&n;&t; * so repeat the whole process until all the data can be handled.&n;&t; */
r_while
c_loop
(paren
id|remaining
)paren
(brace
id|clone
op_assign
id|crypt_clone
c_func
(paren
id|cc
comma
id|io
comma
id|bio
comma
id|sector
comma
op_amp
id|bvec_idx
comma
op_amp
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clone
)paren
r_goto
id|cleanup
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io-&gt;first_clone
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * hold a reference to the first clone, because it&n;&t;&t;&t; * holds the bio_vec array and that can&squot;t be freed&n;&t;&t;&t; * before all other clones are released&n;&t;&t;&t; */
id|bio_get
c_func
(paren
id|clone
)paren
suffix:semicolon
id|io-&gt;first_clone
op_assign
id|clone
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|io-&gt;pending
)paren
suffix:semicolon
id|remaining
op_sub_assign
id|clone-&gt;bi_size
suffix:semicolon
id|sector
op_add_assign
id|bio_sectors
c_func
(paren
id|clone
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|clone
)paren
suffix:semicolon
multiline_comment|/* out of memory -&gt; run queues */
r_if
c_cond
(paren
id|remaining
)paren
id|blk_congestion_wait
c_func
(paren
id|bio_data_dir
c_func
(paren
id|clone
)paren
comma
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
)brace
multiline_comment|/* drop reference, clones could have returned before we reach this */
id|dec_pending
c_func
(paren
id|io
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|cleanup
suffix:colon
r_if
c_cond
(paren
id|io-&gt;first_clone
)paren
(brace
id|dec_pending
c_func
(paren
id|io
comma
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if no bio has been dispatched yet, we can directly return the error */
id|mempool_free
c_func
(paren
id|io
comma
id|cc-&gt;io_pool
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|crypt_status
r_static
r_int
id|crypt_status
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
id|status_type_t
id|type
comma
r_char
op_star
id|result
comma
r_int
r_int
id|maxlen
)paren
(brace
r_struct
id|crypt_config
op_star
id|cc
op_assign
(paren
r_struct
id|crypt_config
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_char
id|buffer
(braket
l_int|32
)braket
suffix:semicolon
r_const
r_char
op_star
id|cipher
suffix:semicolon
r_const
r_char
op_star
id|chainmode
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|STATUSTYPE_INFO
suffix:colon
id|result
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATUSTYPE_TABLE
suffix:colon
id|cipher
op_assign
id|crypto_tfm_alg_name
c_func
(paren
id|cc-&gt;tfm
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cc-&gt;tfm-&gt;crt_cipher.cit_mode
)paren
(brace
r_case
id|CRYPTO_TFM_MODE_CBC
suffix:colon
id|chainmode
op_assign
l_string|&quot;cbc&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CRYPTO_TFM_MODE_ECB
suffix:colon
id|chainmode
op_assign
l_string|&quot;ecb&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cc-&gt;iv_mode
)paren
id|DMEMIT
c_func
(paren
l_string|&quot;%s-%s-%s &quot;
comma
id|cipher
comma
id|chainmode
comma
id|cc-&gt;iv_mode
)paren
suffix:semicolon
r_else
id|DMEMIT
c_func
(paren
l_string|&quot;%s-%s &quot;
comma
id|cipher
comma
id|chainmode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc-&gt;key_size
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|maxlen
op_minus
id|sz
)paren
OL
(paren
(paren
id|cc-&gt;key_size
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|crypt_encode_key
c_func
(paren
id|result
op_plus
id|sz
comma
id|cc-&gt;key
comma
id|cc-&gt;key_size
)paren
suffix:semicolon
id|sz
op_add_assign
id|cc-&gt;key_size
op_lshift
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sz
op_ge
id|maxlen
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|result
(braket
id|sz
op_increment
)braket
op_assign
l_char|&squot;-&squot;
suffix:semicolon
)brace
id|format_dev_t
c_func
(paren
id|buffer
comma
id|cc-&gt;dev-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
id|DMEMIT
c_func
(paren
l_string|&quot; &quot;
id|SECTOR_FORMAT
l_string|&quot; %s &quot;
id|SECTOR_FORMAT
comma
id|cc-&gt;iv_offset
comma
id|buffer
comma
id|cc-&gt;start
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|crypt_target
r_static
r_struct
id|target_type
id|crypt_target
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;crypt&quot;
comma
dot
id|version
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|0
)brace
comma
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|ctr
op_assign
id|crypt_ctr
comma
dot
id|dtr
op_assign
id|crypt_dtr
comma
dot
id|map
op_assign
id|crypt_map
comma
dot
id|status
op_assign
id|crypt_status
comma
)brace
suffix:semicolon
DECL|function|dm_crypt_init
r_static
r_int
id|__init
id|dm_crypt_init
c_func
(paren
r_void
)paren
(brace
r_int
id|r
suffix:semicolon
id|_crypt_io_pool
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;dm-crypt_io&quot;
comma
r_sizeof
(paren
r_struct
id|crypt_io
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_crypt_io_pool
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|_kcryptd_workqueue
op_assign
id|create_workqueue
c_func
(paren
l_string|&quot;kcryptd&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_kcryptd_workqueue
)paren
(brace
id|r
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|DMERR
c_func
(paren
id|PFX
l_string|&quot;couldn&squot;t create kcryptd&quot;
)paren
suffix:semicolon
r_goto
id|bad1
suffix:semicolon
)brace
id|r
op_assign
id|dm_register_target
c_func
(paren
op_amp
id|crypt_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
(brace
id|DMERR
c_func
(paren
id|PFX
l_string|&quot;register failed %d&quot;
comma
id|r
)paren
suffix:semicolon
r_goto
id|bad2
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|bad2
suffix:colon
id|destroy_workqueue
c_func
(paren
id|_kcryptd_workqueue
)paren
suffix:semicolon
id|bad1
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|_crypt_io_pool
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|dm_crypt_exit
r_static
r_void
id|__exit
id|dm_crypt_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|r
op_assign
id|dm_unregister_target
c_func
(paren
op_amp
id|crypt_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
id|DMERR
c_func
(paren
id|PFX
l_string|&quot;unregister failed %d&quot;
comma
id|r
)paren
suffix:semicolon
id|destroy_workqueue
c_func
(paren
id|_kcryptd_workqueue
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|_crypt_io_pool
)paren
suffix:semicolon
)brace
DECL|variable|dm_crypt_init
id|module_init
c_func
(paren
id|dm_crypt_init
)paren
suffix:semicolon
DECL|variable|dm_crypt_exit
id|module_exit
c_func
(paren
id|dm_crypt_exit
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Christophe Saout &lt;christophe@saout.de&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
id|DM_NAME
l_string|&quot; target for transparent encryption / decryption&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
