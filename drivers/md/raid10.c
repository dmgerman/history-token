multiline_comment|/*&n; * raid10.c : Multiple Devices driver for Linux&n; *&n; * Copyright (C) 2000-2004 Neil Brown&n; *&n; * RAID-10 support for md.&n; *&n; * Base on code in raid1.c.  See raid1.c for futher copyright information.&n; *&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * You should have received a copy of the GNU General Public License&n; * (for example /usr/src/linux/COPYING); if not, write to the Free&n; * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/raid/raid10.h&gt;
multiline_comment|/*&n; * RAID10 provides a combination of RAID0 and RAID1 functionality.&n; * The layout of data is defined by&n; *    chunk_size&n; *    raid_disks&n; *    near_copies (stored in low byte of layout)&n; *    far_copies (stored in second byte of layout)&n; *&n; * The data to be stored is divided into chunks using chunksize.&n; * Each device is divided into far_copies sections.&n; * In each section, chunks are laid out in a style similar to raid0, but&n; * near_copies copies of each chunk is stored (each on a different drive).&n; * The starting device for each section is offset near_copies from the starting&n; * device of the previous section.&n; * Thus there are (near_copies*far_copies) of each chunk, and each is on a different&n; * drive.&n; * near_copies and far_copies must be at least one, and there product is at most&n; * raid_disks.&n; */
multiline_comment|/*&n; * Number of guaranteed r10bios in case of extreme VM load:&n; */
DECL|macro|NR_RAID10_BIOS
mdefine_line|#define&t;NR_RAID10_BIOS 256
r_static
r_void
id|unplug_slaves
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
suffix:semicolon
DECL|function|r10bio_pool_alloc
r_static
r_void
op_star
id|r10bio_pool_alloc
c_func
(paren
r_int
id|gfp_flags
comma
r_void
op_star
id|data
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|data
suffix:semicolon
id|r10bio_t
op_star
id|r10_bio
suffix:semicolon
r_int
id|size
op_assign
m_offsetof
(paren
r_struct
id|r10bio_s
comma
id|devs
(braket
id|conf-&gt;copies
)braket
)paren
suffix:semicolon
multiline_comment|/* allocate a r10bio with room for raid_disks entries in the bios array */
id|r10_bio
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r10_bio
)paren
id|memset
c_func
(paren
id|r10_bio
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_else
id|unplug_slaves
c_func
(paren
id|conf-&gt;mddev
)paren
suffix:semicolon
r_return
id|r10_bio
suffix:semicolon
)brace
DECL|function|r10bio_pool_free
r_static
r_void
id|r10bio_pool_free
c_func
(paren
r_void
op_star
id|r10_bio
comma
r_void
op_star
id|data
)paren
(brace
id|kfree
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
)brace
DECL|macro|RESYNC_BLOCK_SIZE
mdefine_line|#define RESYNC_BLOCK_SIZE (64*1024)
singleline_comment|//#define RESYNC_BLOCK_SIZE PAGE_SIZE
DECL|macro|RESYNC_SECTORS
mdefine_line|#define RESYNC_SECTORS (RESYNC_BLOCK_SIZE &gt;&gt; 9)
DECL|macro|RESYNC_PAGES
mdefine_line|#define RESYNC_PAGES ((RESYNC_BLOCK_SIZE + PAGE_SIZE-1) / PAGE_SIZE)
DECL|macro|RESYNC_WINDOW
mdefine_line|#define RESYNC_WINDOW (2048*1024)
multiline_comment|/*&n; * When performing a resync, we need to read and compare, so&n; * we need as many pages are there are copies.&n; * When performing a recovery, we need 2 bios, one for read,&n; * one for write (we recover only one drive per r10buf)&n; *&n; */
DECL|function|r10buf_pool_alloc
r_static
r_void
op_star
id|r10buf_pool_alloc
c_func
(paren
r_int
id|gfp_flags
comma
r_void
op_star
id|data
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|data
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|r10bio_t
op_star
id|r10_bio
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|nalloc
suffix:semicolon
id|r10_bio
op_assign
id|r10bio_pool_alloc
c_func
(paren
id|gfp_flags
comma
id|conf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r10_bio
)paren
(brace
id|unplug_slaves
c_func
(paren
id|conf-&gt;mddev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|MD_RECOVERY_SYNC
comma
op_amp
id|conf-&gt;mddev-&gt;recovery
)paren
)paren
id|nalloc
op_assign
id|conf-&gt;copies
suffix:semicolon
multiline_comment|/* resync */
r_else
id|nalloc
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* recovery */
multiline_comment|/*&n;&t; * Allocate bios.&n;&t; */
r_for
c_loop
(paren
id|j
op_assign
id|nalloc
suffix:semicolon
id|j
op_decrement
suffix:semicolon
)paren
(brace
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|gfp_flags
comma
id|RESYNC_PAGES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
r_goto
id|out_free_bio
suffix:semicolon
id|r10_bio-&gt;devs
(braket
id|j
)braket
dot
id|bio
op_assign
id|bio
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate RESYNC_PAGES data pages and attach them&n;&t; * where needed.&n;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nalloc
suffix:semicolon
id|j
op_increment
)paren
(brace
id|bio
op_assign
id|r10_bio-&gt;devs
(braket
id|j
)braket
dot
id|bio
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RESYNC_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|page
op_assign
id|alloc_page
c_func
(paren
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|page
)paren
)paren
r_goto
id|out_free_pages
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
op_assign
id|page
suffix:semicolon
)brace
)brace
r_return
id|r10_bio
suffix:semicolon
id|out_free_pages
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|__free_page
c_func
(paren
id|bio-&gt;bi_io_vec
(braket
id|i
op_minus
l_int|1
)braket
dot
id|bv_page
)paren
suffix:semicolon
r_while
c_loop
(paren
id|j
op_decrement
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RESYNC_PAGES
suffix:semicolon
id|i
op_increment
)paren
id|__free_page
c_func
(paren
id|r10_bio-&gt;devs
(braket
id|j
)braket
dot
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
)paren
suffix:semicolon
id|j
op_assign
op_minus
l_int|1
suffix:semicolon
id|out_free_bio
suffix:colon
r_while
c_loop
(paren
op_increment
id|j
OL
id|nalloc
)paren
id|bio_put
c_func
(paren
id|r10_bio-&gt;devs
(braket
id|j
)braket
dot
id|bio
)paren
suffix:semicolon
id|r10bio_pool_free
c_func
(paren
id|r10_bio
comma
id|conf
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|r10buf_pool_free
r_static
r_void
id|r10buf_pool_free
c_func
(paren
r_void
op_star
id|__r10_bio
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|data
suffix:semicolon
id|r10bio_t
op_star
id|r10bio
op_assign
id|__r10_bio
suffix:semicolon
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|conf-&gt;copies
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|r10bio-&gt;devs
(braket
id|j
)braket
dot
id|bio
suffix:semicolon
r_if
c_cond
(paren
id|bio
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RESYNC_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|__free_page
c_func
(paren
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
)paren
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
)brace
id|r10bio_pool_free
c_func
(paren
id|r10bio
comma
id|conf
)paren
suffix:semicolon
)brace
DECL|function|put_all_bios
r_static
r_void
id|put_all_bios
c_func
(paren
id|conf_t
op_star
id|conf
comma
id|r10bio_t
op_star
id|r10_bio
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;copies
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|bio
op_star
op_star
id|bio
op_assign
op_amp
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bio
)paren
id|bio_put
c_func
(paren
op_star
id|bio
)paren
suffix:semicolon
op_star
id|bio
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|free_r10bio
r_static
r_inline
r_void
id|free_r10bio
c_func
(paren
id|r10bio_t
op_star
id|r10_bio
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r10_bio-&gt;mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wake up any possible resync thread that waits for the device&n;&t; * to go idle.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;resync_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|conf-&gt;nr_pending
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;resync_lock
comma
id|flags
)paren
suffix:semicolon
id|put_all_bios
c_func
(paren
id|conf
comma
id|r10_bio
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|r10_bio
comma
id|conf-&gt;r10bio_pool
)paren
suffix:semicolon
)brace
DECL|function|put_buf
r_static
r_inline
r_void
id|put_buf
c_func
(paren
id|r10bio_t
op_star
id|r10_bio
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r10_bio-&gt;mddev
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|mempool_free
c_func
(paren
id|r10_bio
comma
id|conf-&gt;r10buf_pool
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;resync_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;barrier
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
op_decrement
id|conf-&gt;barrier
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|conf-&gt;nr_pending
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;resync_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|reschedule_retry
r_static
r_void
id|reschedule_retry
c_func
(paren
id|r10bio_t
op_star
id|r10_bio
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
id|r10_bio-&gt;mddev
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|r10_bio-&gt;retry_list
comma
op_amp
id|conf-&gt;retry_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * raid_end_bio_io() is called when we have finished servicing a mirrored&n; * operation and are ready to return a success/failure code to the buffer&n; * cache layer.&n; */
DECL|function|raid_end_bio_io
r_static
r_void
id|raid_end_bio_io
c_func
(paren
id|r10bio_t
op_star
id|r10_bio
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|r10_bio-&gt;master_bio
suffix:semicolon
id|bio_endio
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
comma
id|test_bit
c_func
(paren
id|R10BIO_Uptodate
comma
op_amp
id|r10_bio-&gt;state
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
)paren
suffix:semicolon
id|free_r10bio
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update disk head position estimator based on IRQ completion info.&n; */
DECL|function|update_head_pos
r_static
r_inline
r_void
id|update_head_pos
c_func
(paren
r_int
id|slot
comma
id|r10bio_t
op_star
id|r10_bio
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r10_bio-&gt;mddev
)paren
suffix:semicolon
id|conf-&gt;mirrors
(braket
id|r10_bio-&gt;devs
(braket
id|slot
)braket
dot
id|devnum
)braket
dot
id|head_position
op_assign
id|r10_bio-&gt;devs
(braket
id|slot
)braket
dot
id|addr
op_plus
(paren
id|r10_bio-&gt;sectors
)paren
suffix:semicolon
)brace
DECL|function|raid10_end_read_request
r_static
r_int
id|raid10_end_read_request
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
id|r10bio_t
op_star
id|r10_bio
op_assign
(paren
id|r10bio_t
op_star
)paren
(paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
r_int
id|slot
comma
id|dev
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r10_bio-&gt;mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
id|slot
op_assign
id|r10_bio-&gt;read_slot
suffix:semicolon
id|dev
op_assign
id|r10_bio-&gt;devs
(braket
id|slot
)braket
dot
id|devnum
suffix:semicolon
multiline_comment|/*&n;&t; * this branch is our &squot;one mirror IO has finished&squot; event handler:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
c_func
(paren
id|r10_bio-&gt;mddev
comma
id|conf-&gt;mirrors
(braket
id|dev
)braket
dot
id|rdev
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * Set R10BIO_Uptodate in our master bio, so that&n;&t;&t; * we will return a good error code to the higher&n;&t;&t; * levels even if IO on some other mirrored buffer fails.&n;&t;&t; *&n;&t;&t; * The &squot;master&squot; represents the composite IO operation to&n;&t;&t; * user-side. So if something waits for IO, then it will&n;&t;&t; * wait for the &squot;master&squot; bio.&n;&t;&t; */
id|set_bit
c_func
(paren
id|R10BIO_Uptodate
comma
op_amp
id|r10_bio-&gt;state
)paren
suffix:semicolon
id|update_head_pos
c_func
(paren
id|slot
comma
id|r10_bio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we have only one bio on the read side&n;&t; */
r_if
c_cond
(paren
id|uptodate
)paren
id|raid_end_bio_io
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t; * oops, read error:&n;&t;&t; */
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
id|printk_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid10: %s: rescheduling sector %llu&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|conf-&gt;mirrors
(braket
id|dev
)braket
dot
id|rdev-&gt;bdev
comma
id|b
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|r10_bio-&gt;sector
)paren
suffix:semicolon
id|reschedule_retry
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
)brace
id|rdev_dec_pending
c_func
(paren
id|conf-&gt;mirrors
(braket
id|dev
)braket
dot
id|rdev
comma
id|conf-&gt;mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|raid10_end_write_request
r_static
r_int
id|raid10_end_write_request
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
id|r10bio_t
op_star
id|r10_bio
op_assign
(paren
id|r10bio_t
op_star
)paren
(paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
r_int
id|slot
comma
id|dev
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r10_bio-&gt;mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
id|conf-&gt;copies
suffix:semicolon
id|slot
op_increment
)paren
r_if
c_cond
(paren
id|r10_bio-&gt;devs
(braket
id|slot
)braket
dot
id|bio
op_eq
id|bio
)paren
r_break
suffix:semicolon
id|dev
op_assign
id|r10_bio-&gt;devs
(braket
id|slot
)braket
dot
id|devnum
suffix:semicolon
multiline_comment|/*&n;&t; * this branch is our &squot;one mirror IO has finished&squot; event handler:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
c_func
(paren
id|r10_bio-&gt;mddev
comma
id|conf-&gt;mirrors
(braket
id|dev
)braket
dot
id|rdev
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * Set R10BIO_Uptodate in our master bio, so that&n;&t;&t; * we will return a good error code for to the higher&n;&t;&t; * levels even if IO on some other mirrored buffer fails.&n;&t;&t; *&n;&t;&t; * The &squot;master&squot; represents the composite IO operation to&n;&t;&t; * user-side. So if something waits for IO, then it will&n;&t;&t; * wait for the &squot;master&squot; bio.&n;&t;&t; */
id|set_bit
c_func
(paren
id|R10BIO_Uptodate
comma
op_amp
id|r10_bio-&gt;state
)paren
suffix:semicolon
id|update_head_pos
c_func
(paren
id|slot
comma
id|r10_bio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&n;&t; * Let&squot;s see if all mirrored write operations have finished&n;&t; * already.&n;&t; */
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
)paren
)paren
(brace
id|md_write_end
c_func
(paren
id|r10_bio-&gt;mddev
)paren
suffix:semicolon
id|raid_end_bio_io
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
)brace
id|rdev_dec_pending
c_func
(paren
id|conf-&gt;mirrors
(braket
id|dev
)braket
dot
id|rdev
comma
id|conf-&gt;mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * RAID10 layout manager&n; * Aswell as the chunksize and raid_disks count, there are two&n; * parameters: near_copies and far_copies.&n; * near_copies * far_copies must be &lt;= raid_disks.&n; * Normally one of these will be 1.&n; * If both are 1, we get raid0.&n; * If near_copies == raid_disks, we get raid1.&n; *&n; * Chunks are layed out in raid0 style with near_copies copies of the&n; * first chunk, followed by near_copies copies of the next chunk and&n; * so on.&n; * If far_copies &gt; 1, then after 1/far_copies of the array has been assigned&n; * as described above, we start again with a device offset of near_copies.&n; * So we effectively have another copy of the whole array further down all&n; * the drives, but with blocks on different drives.&n; * With this layout, and block is never stored twice on the one device.&n; *&n; * raid10_find_phys finds the sector offset of a given virtual sector&n; * on each device that it is on. If a block isn&squot;t on a device,&n; * that entry in the array is set to MaxSector.&n; *&n; * raid10_find_virt does the reverse mapping, from a device and a&n; * sector offset to a virtual address&n; */
DECL|function|raid10_find_phys
r_static
r_void
id|raid10_find_phys
c_func
(paren
id|conf_t
op_star
id|conf
comma
id|r10bio_t
op_star
id|r10bio
)paren
(brace
r_int
id|n
comma
id|f
suffix:semicolon
id|sector_t
id|sector
suffix:semicolon
id|sector_t
id|chunk
suffix:semicolon
id|sector_t
id|stripe
suffix:semicolon
r_int
id|dev
suffix:semicolon
r_int
id|slot
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* now calculate first sector/dev */
id|chunk
op_assign
id|r10bio-&gt;sector
op_rshift
id|conf-&gt;chunk_shift
suffix:semicolon
id|sector
op_assign
id|r10bio-&gt;sector
op_amp
id|conf-&gt;chunk_mask
suffix:semicolon
id|chunk
op_mul_assign
id|conf-&gt;near_copies
suffix:semicolon
id|stripe
op_assign
id|chunk
suffix:semicolon
id|dev
op_assign
id|sector_div
c_func
(paren
id|stripe
comma
id|conf-&gt;raid_disks
)paren
suffix:semicolon
id|sector
op_add_assign
id|stripe
op_lshift
id|conf-&gt;chunk_shift
suffix:semicolon
multiline_comment|/* and calculate all the others */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|conf-&gt;near_copies
suffix:semicolon
id|n
op_increment
)paren
(brace
r_int
id|d
op_assign
id|dev
suffix:semicolon
id|sector_t
id|s
op_assign
id|sector
suffix:semicolon
id|r10bio-&gt;devs
(braket
id|slot
)braket
dot
id|addr
op_assign
id|sector
suffix:semicolon
id|r10bio-&gt;devs
(braket
id|slot
)braket
dot
id|devnum
op_assign
id|d
suffix:semicolon
id|slot
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
l_int|1
suffix:semicolon
id|f
OL
id|conf-&gt;far_copies
suffix:semicolon
id|f
op_increment
)paren
(brace
id|d
op_add_assign
id|conf-&gt;near_copies
suffix:semicolon
r_if
c_cond
(paren
id|d
op_ge
id|conf-&gt;raid_disks
)paren
id|d
op_sub_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|s
op_add_assign
id|conf-&gt;stride
suffix:semicolon
id|r10bio-&gt;devs
(braket
id|slot
)braket
dot
id|devnum
op_assign
id|d
suffix:semicolon
id|r10bio-&gt;devs
(braket
id|slot
)braket
dot
id|addr
op_assign
id|s
suffix:semicolon
id|slot
op_increment
suffix:semicolon
)brace
id|dev
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
id|conf-&gt;raid_disks
)paren
(brace
id|dev
op_assign
l_int|0
suffix:semicolon
id|sector
op_add_assign
(paren
id|conf-&gt;chunk_mask
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|BUG_ON
c_func
(paren
id|slot
op_ne
id|conf-&gt;copies
)paren
suffix:semicolon
)brace
DECL|function|raid10_find_virt
r_static
id|sector_t
id|raid10_find_virt
c_func
(paren
id|conf_t
op_star
id|conf
comma
id|sector_t
id|sector
comma
r_int
id|dev
)paren
(brace
id|sector_t
id|offset
comma
id|chunk
comma
id|vchunk
suffix:semicolon
r_while
c_loop
(paren
id|sector
OG
id|conf-&gt;stride
)paren
(brace
id|sector
op_sub_assign
id|conf-&gt;stride
suffix:semicolon
r_if
c_cond
(paren
id|dev
OL
id|conf-&gt;near_copies
)paren
id|dev
op_add_assign
id|conf-&gt;raid_disks
op_minus
id|conf-&gt;near_copies
suffix:semicolon
r_else
id|dev
op_sub_assign
id|conf-&gt;near_copies
suffix:semicolon
)brace
id|offset
op_assign
id|sector
op_amp
id|conf-&gt;chunk_mask
suffix:semicolon
id|chunk
op_assign
id|sector
op_rshift
id|conf-&gt;chunk_shift
suffix:semicolon
id|vchunk
op_assign
id|chunk
op_star
id|conf-&gt;raid_disks
op_plus
id|dev
suffix:semicolon
id|sector_div
c_func
(paren
id|vchunk
comma
id|conf-&gt;near_copies
)paren
suffix:semicolon
r_return
(paren
id|vchunk
op_lshift
id|conf-&gt;chunk_shift
)paren
op_plus
id|offset
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;raid10_mergeable_bvec -- tell bio layer if a two requests can be merged&n; *&t;@q: request queue&n; *&t;@bio: the buffer head that&squot;s been built up so far&n; *&t;@biovec: the request that could be merged to it.&n; *&n; *&t;Return amount of bytes we can accept at this offset&n; *      If near_copies == raid_disk, there are no striping issues,&n; *      but in that case, the function isn&squot;t called at all.&n; */
DECL|function|raid10_mergeable_bvec
r_static
r_int
id|raid10_mergeable_bvec
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|bio
op_star
id|bio
comma
r_struct
id|bio_vec
op_star
id|bio_vec
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|q-&gt;queuedata
suffix:semicolon
id|sector_t
id|sector
op_assign
id|bio-&gt;bi_sector
op_plus
id|get_start_sect
c_func
(paren
id|bio-&gt;bi_bdev
)paren
suffix:semicolon
r_int
id|max
suffix:semicolon
r_int
r_int
id|chunk_sectors
op_assign
id|mddev-&gt;chunk_size
op_rshift
l_int|9
suffix:semicolon
r_int
r_int
id|bio_sectors
op_assign
id|bio-&gt;bi_size
op_rshift
l_int|9
suffix:semicolon
id|max
op_assign
(paren
id|chunk_sectors
op_minus
(paren
(paren
id|sector
op_amp
(paren
id|chunk_sectors
op_minus
l_int|1
)paren
)paren
op_plus
id|bio_sectors
)paren
)paren
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|max
OL
l_int|0
)paren
id|max
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bio_add cannot handle a negative return */
r_if
c_cond
(paren
id|max
op_le
id|bio_vec-&gt;bv_len
op_logical_and
id|bio_sectors
op_eq
l_int|0
)paren
r_return
id|bio_vec-&gt;bv_len
suffix:semicolon
r_else
r_return
id|max
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine returns the disk from which the requested read should&n; * be done. There is a per-array &squot;next expected sequential IO&squot; sector&n; * number - if this matches on the next IO then we use the last disk.&n; * There is also a per-disk &squot;last know head position&squot; sector that is&n; * maintained from IRQ contexts, both the normal and the resync IO&n; * completion handlers update this position correctly. If there is no&n; * perfect sequential match then we pick the disk whose head is closest.&n; *&n; * If there are 2 mirrors in the same 2 devices, performance degrades&n; * because position is mirror, not device based.&n; *&n; * The rdev for the device selected will have nr_pending incremented.&n; */
multiline_comment|/*&n; * FIXME: possibly should rethink readbalancing and do it differently&n; * depending on near_copies / far_copies geometry.&n; */
DECL|function|read_balance
r_static
r_int
id|read_balance
c_func
(paren
id|conf_t
op_star
id|conf
comma
id|r10bio_t
op_star
id|r10_bio
)paren
(brace
r_const
r_int
r_int
id|this_sector
op_assign
id|r10_bio-&gt;sector
suffix:semicolon
r_int
id|disk
comma
id|slot
comma
id|nslot
suffix:semicolon
r_const
r_int
id|sectors
op_assign
id|r10_bio-&gt;sectors
suffix:semicolon
id|sector_t
id|new_distance
comma
id|current_distance
suffix:semicolon
id|raid10_find_phys
c_func
(paren
id|conf
comma
id|r10_bio
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if we can balance. We can balance on the whole&n;&t; * device if no resync is going on, or below the resync window.&n;&t; * We take the first readable disk when above the resync window.&n;&t; */
r_if
c_cond
(paren
id|conf-&gt;mddev-&gt;recovery_cp
OL
id|MaxSector
op_logical_and
(paren
id|this_sector
op_plus
id|sectors
op_ge
id|conf-&gt;next_resync
)paren
)paren
(brace
multiline_comment|/* make sure that disk is operational */
id|slot
op_assign
l_int|0
suffix:semicolon
id|disk
op_assign
id|r10_bio-&gt;devs
(braket
id|slot
)braket
dot
id|devnum
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|rdev
op_logical_or
op_logical_neg
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|rdev-&gt;in_sync
)paren
(brace
id|slot
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_eq
id|conf-&gt;copies
)paren
(brace
id|slot
op_assign
l_int|0
suffix:semicolon
id|disk
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|disk
op_assign
id|r10_bio-&gt;devs
(braket
id|slot
)braket
dot
id|devnum
suffix:semicolon
)brace
r_goto
id|rb_out
suffix:semicolon
)brace
multiline_comment|/* make sure the disk is operational */
id|slot
op_assign
l_int|0
suffix:semicolon
id|disk
op_assign
id|r10_bio-&gt;devs
(braket
id|slot
)braket
dot
id|devnum
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|rdev
op_logical_or
op_logical_neg
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|rdev-&gt;in_sync
)paren
(brace
id|slot
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_eq
id|conf-&gt;copies
)paren
(brace
id|disk
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|rb_out
suffix:semicolon
)brace
id|disk
op_assign
id|r10_bio-&gt;devs
(braket
id|slot
)braket
dot
id|devnum
suffix:semicolon
)brace
id|current_distance
op_assign
id|abs
c_func
(paren
id|this_sector
op_minus
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|head_position
)paren
suffix:semicolon
multiline_comment|/* Find the disk whose head is closest */
r_for
c_loop
(paren
id|nslot
op_assign
id|slot
suffix:semicolon
id|nslot
OL
id|conf-&gt;copies
suffix:semicolon
id|nslot
op_increment
)paren
(brace
r_int
id|ndisk
op_assign
id|r10_bio-&gt;devs
(braket
id|nslot
)braket
dot
id|devnum
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|ndisk
)braket
dot
id|rdev
op_logical_or
op_logical_neg
id|conf-&gt;mirrors
(braket
id|ndisk
)braket
dot
id|rdev-&gt;in_sync
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|ndisk
)braket
dot
id|rdev-&gt;nr_pending
)paren
)paren
(brace
id|disk
op_assign
id|ndisk
suffix:semicolon
id|slot
op_assign
id|nslot
suffix:semicolon
r_break
suffix:semicolon
)brace
id|new_distance
op_assign
id|abs
c_func
(paren
id|r10_bio-&gt;devs
(braket
id|nslot
)braket
dot
id|addr
op_minus
id|conf-&gt;mirrors
(braket
id|ndisk
)braket
dot
id|head_position
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_distance
OL
id|current_distance
)paren
(brace
id|current_distance
op_assign
id|new_distance
suffix:semicolon
id|disk
op_assign
id|ndisk
suffix:semicolon
id|slot
op_assign
id|nslot
suffix:semicolon
)brace
)brace
id|rb_out
suffix:colon
id|r10_bio-&gt;read_slot
op_assign
id|slot
suffix:semicolon
multiline_comment|/*&t;conf-&gt;next_seq_sect = this_sector + sectors;*/
r_if
c_cond
(paren
id|disk
op_ge
l_int|0
op_logical_and
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|rdev
)paren
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_return
id|disk
suffix:semicolon
)brace
DECL|function|unplug_slaves
r_static
r_void
id|unplug_slaves
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mddev-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev
suffix:semicolon
r_if
c_cond
(paren
id|rdev
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|rdev-&gt;nr_pending
)paren
)paren
(brace
id|request_queue_t
op_star
id|r_queue
op_assign
id|bdev_get_queue
c_func
(paren
id|rdev-&gt;bdev
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r_queue-&gt;unplug_fn
)paren
id|r_queue
op_member_access_from_pointer
id|unplug_fn
c_func
(paren
id|r_queue
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|raid10_unplug
r_static
r_void
id|raid10_unplug
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
id|unplug_slaves
c_func
(paren
id|q-&gt;queuedata
)paren
suffix:semicolon
)brace
DECL|function|raid10_issue_flush
r_static
r_int
id|raid10_issue_flush
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|gendisk
op_star
id|disk
comma
id|sector_t
op_star
id|error_sector
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|q-&gt;queuedata
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mddev-&gt;raid_disks
op_logical_and
id|ret
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev
suffix:semicolon
r_if
c_cond
(paren
id|rdev
op_logical_and
op_logical_neg
id|rdev-&gt;faulty
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
op_assign
id|rdev-&gt;bdev
suffix:semicolon
id|request_queue_t
op_star
id|r_queue
op_assign
id|bdev_get_queue
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r_queue-&gt;issue_flush_fn
)paren
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_else
id|ret
op_assign
id|r_queue
op_member_access_from_pointer
id|issue_flush_fn
c_func
(paren
id|r_queue
comma
id|bdev-&gt;bd_disk
comma
id|error_sector
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Throttle resync depth, so that we can both get proper overlapping of&n; * requests, but are still able to handle normal requests quickly.&n; */
DECL|macro|RESYNC_DEPTH
mdefine_line|#define RESYNC_DEPTH 32
DECL|function|device_barrier
r_static
r_void
id|device_barrier
c_func
(paren
id|conf_t
op_star
id|conf
comma
id|sector_t
id|sect
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_idle
comma
op_logical_neg
id|waitqueue_active
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
comma
id|conf-&gt;resync_lock
comma
id|unplug_slaves
c_func
(paren
id|conf-&gt;mddev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;barrier
op_increment
)paren
(brace
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_idle
comma
op_logical_neg
id|conf-&gt;nr_pending
comma
id|conf-&gt;resync_lock
comma
id|unplug_slaves
c_func
(paren
id|conf-&gt;mddev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;nr_pending
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_resume
comma
id|conf-&gt;barrier
OL
id|RESYNC_DEPTH
comma
id|conf-&gt;resync_lock
comma
id|unplug_slaves
c_func
(paren
id|conf-&gt;mddev
)paren
)paren
suffix:semicolon
id|conf-&gt;next_resync
op_assign
id|sect
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
)brace
DECL|function|make_request
r_static
r_int
id|make_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|q-&gt;queuedata
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mirror_info_t
op_star
id|mirror
suffix:semicolon
id|r10bio_t
op_star
id|r10_bio
suffix:semicolon
r_struct
id|bio
op_star
id|read_bio
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|chunk_sects
op_assign
id|conf-&gt;chunk_mask
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* If this request crosses a chunk boundary, we need to&n;&t; * split it.  This will only happen for 1 PAGE (or less) requests.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|bio-&gt;bi_sector
op_amp
id|conf-&gt;chunk_mask
)paren
op_plus
(paren
id|bio-&gt;bi_size
op_rshift
l_int|9
)paren
OG
id|chunk_sects
op_logical_and
id|conf-&gt;near_copies
OL
id|conf-&gt;raid_disks
)paren
)paren
(brace
r_struct
id|bio_pair
op_star
id|bp
suffix:semicolon
multiline_comment|/* Sanity check -- queue functions should prevent this happening */
r_if
c_cond
(paren
id|bio-&gt;bi_vcnt
op_ne
l_int|1
op_logical_or
id|bio-&gt;bi_idx
op_ne
l_int|0
)paren
r_goto
id|bad_map
suffix:semicolon
multiline_comment|/* This is a one page bio that upper layers&n;&t;&t; * refuse to split for us, so we need to split it.&n;&t;&t; */
id|bp
op_assign
id|bio_split
c_func
(paren
id|bio
comma
id|bio_split_pool
comma
id|chunk_sects
op_minus
(paren
id|bio-&gt;bi_sector
op_amp
(paren
id|chunk_sects
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|make_request
c_func
(paren
id|q
comma
op_amp
id|bp-&gt;bio1
)paren
)paren
id|generic_make_request
c_func
(paren
op_amp
id|bp-&gt;bio1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|make_request
c_func
(paren
id|q
comma
op_amp
id|bp-&gt;bio2
)paren
)paren
id|generic_make_request
c_func
(paren
op_amp
id|bp-&gt;bio2
)paren
suffix:semicolon
id|bio_pair_release
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bad_map
suffix:colon
id|printk
c_func
(paren
l_string|&quot;raid10_make_request bug: can&squot;t convert block across chunks&quot;
l_string|&quot; or bigger than %dk %llu %d&bslash;n&quot;
comma
id|chunk_sects
op_div
l_int|2
comma
(paren
r_int
r_int
r_int
)paren
id|bio-&gt;bi_sector
comma
id|bio-&gt;bi_size
op_rshift
l_int|10
)paren
suffix:semicolon
id|bio_io_error
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Register the new request and wait if the reconstruction&n;&t; * thread has put up a bar for new requests.&n;&t; * Continue immediately if no resync is active currently.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_resume
comma
op_logical_neg
id|conf-&gt;barrier
comma
id|conf-&gt;resync_lock
comma
)paren
suffix:semicolon
id|conf-&gt;nr_pending
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio_data_dir
c_func
(paren
id|bio
)paren
op_eq
id|WRITE
)paren
(brace
id|disk_stat_inc
c_func
(paren
id|mddev-&gt;gendisk
comma
id|writes
)paren
suffix:semicolon
id|disk_stat_add
c_func
(paren
id|mddev-&gt;gendisk
comma
id|write_sectors
comma
id|bio_sectors
c_func
(paren
id|bio
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|disk_stat_inc
c_func
(paren
id|mddev-&gt;gendisk
comma
id|reads
)paren
suffix:semicolon
id|disk_stat_add
c_func
(paren
id|mddev-&gt;gendisk
comma
id|read_sectors
comma
id|bio_sectors
c_func
(paren
id|bio
)paren
)paren
suffix:semicolon
)brace
id|r10_bio
op_assign
id|mempool_alloc
c_func
(paren
id|conf-&gt;r10bio_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|r10_bio-&gt;master_bio
op_assign
id|bio
suffix:semicolon
id|r10_bio-&gt;sectors
op_assign
id|bio-&gt;bi_size
op_rshift
l_int|9
suffix:semicolon
id|r10_bio-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|r10_bio-&gt;sector
op_assign
id|bio-&gt;bi_sector
suffix:semicolon
r_if
c_cond
(paren
id|bio_data_dir
c_func
(paren
id|bio
)paren
op_eq
id|READ
)paren
(brace
multiline_comment|/*&n;&t;&t; * read balancing logic:&n;&t;&t; */
r_int
id|disk
op_assign
id|read_balance
c_func
(paren
id|conf
comma
id|r10_bio
)paren
suffix:semicolon
r_int
id|slot
op_assign
id|r10_bio-&gt;read_slot
suffix:semicolon
r_if
c_cond
(paren
id|disk
OL
l_int|0
)paren
(brace
id|raid_end_bio_io
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mirror
op_assign
id|conf-&gt;mirrors
op_plus
id|disk
suffix:semicolon
id|read_bio
op_assign
id|bio_clone
c_func
(paren
id|bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|r10_bio-&gt;devs
(braket
id|slot
)braket
dot
id|bio
op_assign
id|read_bio
suffix:semicolon
id|read_bio-&gt;bi_sector
op_assign
id|r10_bio-&gt;devs
(braket
id|slot
)braket
dot
id|addr
op_plus
id|mirror-&gt;rdev-&gt;data_offset
suffix:semicolon
id|read_bio-&gt;bi_bdev
op_assign
id|mirror-&gt;rdev-&gt;bdev
suffix:semicolon
id|read_bio-&gt;bi_end_io
op_assign
id|raid10_end_read_request
suffix:semicolon
id|read_bio-&gt;bi_rw
op_assign
id|READ
suffix:semicolon
id|read_bio-&gt;bi_private
op_assign
id|r10_bio
suffix:semicolon
id|generic_make_request
c_func
(paren
id|read_bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * WRITE:&n;&t; */
multiline_comment|/* first select target devices under spinlock and&n;&t; * inc refcount on their rdev.  Record them by setting&n;&t; * bios[x] to bio&n;&t; */
id|raid10_find_phys
c_func
(paren
id|conf
comma
id|r10_bio
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;copies
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|d
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|devnum
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev
op_logical_and
op_logical_neg
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;faulty
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio
op_assign
id|bio
suffix:semicolon
)brace
r_else
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
comma
l_int|1
)paren
suffix:semicolon
id|md_write_start
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;copies
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|bio
op_star
id|mbio
suffix:semicolon
r_int
id|d
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|devnum
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio
)paren
r_continue
suffix:semicolon
id|mbio
op_assign
id|bio_clone
c_func
(paren
id|bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio
op_assign
id|mbio
suffix:semicolon
id|mbio-&gt;bi_sector
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|addr
op_plus
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;data_offset
suffix:semicolon
id|mbio-&gt;bi_bdev
op_assign
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;bdev
suffix:semicolon
id|mbio-&gt;bi_end_io
op_assign
id|raid10_end_write_request
suffix:semicolon
id|mbio-&gt;bi_rw
op_assign
id|WRITE
suffix:semicolon
id|mbio-&gt;bi_private
op_assign
id|r10_bio
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|mbio
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
)paren
)paren
(brace
id|md_write_end
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|raid_end_bio_io
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|status
r_static
r_void
id|status
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
id|mddev_t
op_star
id|mddev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;near_copies
OL
id|conf-&gt;raid_disks
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot; %dK chunks&quot;
comma
id|mddev-&gt;chunk_size
op_div
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;near_copies
OG
l_int|1
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot; %d near-copies&quot;
comma
id|conf-&gt;near_copies
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;far_copies
OG
l_int|1
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot; %d far-copies&quot;
comma
id|conf-&gt;far_copies
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot; [%d/%d] [&quot;
comma
id|conf-&gt;raid_disks
comma
id|conf-&gt;working_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%s&quot;
comma
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev
op_logical_and
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;in_sync
ques
c_cond
l_string|&quot;U&quot;
suffix:colon
l_string|&quot;_&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;]&quot;
)paren
suffix:semicolon
)brace
DECL|function|error
r_static
r_void
id|error
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it is not operational, then we have already marked it as dead&n;&t; * else if it is the last working disks, ignore the error, let the&n;&t; * next level up know.&n;&t; * else mark the drive as failed&n;&t; */
r_if
c_cond
(paren
id|rdev-&gt;in_sync
op_logical_and
id|conf-&gt;working_disks
op_eq
l_int|1
)paren
multiline_comment|/*&n;&t;&t; * Don&squot;t fail the drive, just return an IO error.&n;&t;&t; * The test should really be more sophisticated than&n;&t;&t; * &quot;working_disks == 1&quot;, but it isn&squot;t critical, and&n;&t;&t; * can wait until we do more sophisticated &quot;is the drive&n;&t;&t; * really dead&quot; tests...&n;&t;&t; */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;in_sync
)paren
(brace
id|mddev-&gt;degraded
op_increment
suffix:semicolon
id|conf-&gt;working_disks
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if recovery is running, make sure it aborts.&n;&t;&t; */
id|set_bit
c_func
(paren
id|MD_RECOVERY_ERR
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
)brace
id|rdev-&gt;in_sync
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;faulty
op_assign
l_int|1
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;raid10: Disk failure on %s, disabling device. &bslash;n&quot;
l_string|&quot;&t;Operation continuing on %d devices&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
id|conf-&gt;working_disks
)paren
suffix:semicolon
)brace
DECL|function|print_conf
r_static
r_void
id|print_conf
c_func
(paren
id|conf_t
op_star
id|conf
)paren
(brace
r_int
id|i
suffix:semicolon
id|mirror_info_t
op_star
id|tmp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RAID10 conf printout:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(!conf)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; --- wd:%d rd:%d&bslash;n&quot;
comma
id|conf-&gt;working_disks
comma
id|conf-&gt;raid_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|tmp
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;rdev
)paren
id|printk
c_func
(paren
l_string|&quot; disk %d, wo:%d, o:%d, dev:%s&bslash;n&quot;
comma
id|i
comma
op_logical_neg
id|tmp-&gt;rdev-&gt;in_sync
comma
op_logical_neg
id|tmp-&gt;rdev-&gt;faulty
comma
id|bdevname
c_func
(paren
id|tmp-&gt;rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|close_sync
r_static
r_void
id|close_sync
c_func
(paren
id|conf_t
op_star
id|conf
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_resume
comma
op_logical_neg
id|conf-&gt;barrier
comma
id|conf-&gt;resync_lock
comma
id|unplug_slaves
c_func
(paren
id|conf-&gt;mddev
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;barrier
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|conf-&gt;r10buf_pool
)paren
suffix:semicolon
id|conf-&gt;r10buf_pool
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|raid10_spare_active
r_static
r_int
id|raid10_spare_active
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|i
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
id|mirror_info_t
op_star
id|tmp
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find all non-in_sync disks within the RAID10 configuration&n;&t; * and mark them in_sync&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;rdev
op_logical_and
op_logical_neg
id|tmp-&gt;rdev-&gt;faulty
op_logical_and
op_logical_neg
id|tmp-&gt;rdev-&gt;in_sync
)paren
(brace
id|conf-&gt;working_disks
op_increment
suffix:semicolon
id|mddev-&gt;degraded
op_decrement
suffix:semicolon
id|tmp-&gt;rdev-&gt;in_sync
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|raid10_add_disk
r_static
r_int
id|raid10_add_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_int
id|mirror
suffix:semicolon
id|mirror_info_t
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;recovery_cp
OL
id|MaxSector
)paren
multiline_comment|/* only hot-add to in-sync arrays, as recovery is&n;&t;&t; * very different from resync&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mirror
op_assign
l_int|0
suffix:semicolon
id|mirror
OL
id|mddev-&gt;raid_disks
suffix:semicolon
id|mirror
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_assign
id|conf-&gt;mirrors
op_plus
id|mirror
)paren
op_member_access_from_pointer
id|rdev
)paren
(brace
id|p-&gt;rdev
op_assign
id|rdev
suffix:semicolon
id|blk_queue_stack_limits
c_func
(paren
id|mddev-&gt;queue
comma
id|rdev-&gt;bdev-&gt;bd_disk-&gt;queue
)paren
suffix:semicolon
multiline_comment|/* as we don&squot;t honour merge_bvec_fn, we must never risk&n;&t;&t;&t; * violating it, so limit -&gt;max_sector to one PAGE, as&n;&t;&t;&t; * a one page request is never in violation.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rdev-&gt;bdev-&gt;bd_disk-&gt;queue-&gt;merge_bvec_fn
op_logical_and
id|mddev-&gt;queue-&gt;max_sectors
OG
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
)paren
id|mddev-&gt;queue-&gt;max_sectors
op_assign
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
suffix:semicolon
id|p-&gt;head_position
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;raid_disk
op_assign
id|mirror
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
DECL|function|raid10_remove_disk
r_static
r_int
id|raid10_remove_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|number
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|err
op_assign
l_int|1
suffix:semicolon
id|mirror_info_t
op_star
id|p
op_assign
id|conf-&gt;mirrors
op_plus
id|number
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;rdev
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;rdev-&gt;in_sync
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|p-&gt;rdev-&gt;nr_pending
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|p-&gt;rdev
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
m_abort
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|end_sync_read
r_static
r_int
id|end_sync_read
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
id|r10bio_t
op_star
id|r10_bio
op_assign
(paren
id|r10bio_t
op_star
)paren
(paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r10_bio-&gt;mddev
)paren
suffix:semicolon
r_int
id|i
comma
id|d
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;copies
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio
op_eq
id|bio
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|conf-&gt;copies
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|update_head_pos
c_func
(paren
id|i
comma
id|r10_bio
)paren
suffix:semicolon
id|d
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|devnum
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
c_func
(paren
id|r10_bio-&gt;mddev
comma
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev
)paren
suffix:semicolon
multiline_comment|/* for reconstruct, we always reschedule after a read.&n;&t; * for resync, only after all reads&n;&t; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|R10BIO_IsRecover
comma
op_amp
id|r10_bio-&gt;state
)paren
op_logical_or
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
)paren
)paren
(brace
multiline_comment|/* we have read all the blocks,&n;&t;&t; * do the comparison in process context in raid10d&n;&t;&t; */
id|reschedule_retry
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
)brace
id|rdev_dec_pending
c_func
(paren
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev
comma
id|conf-&gt;mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|end_sync_write
r_static
r_int
id|end_sync_write
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
id|r10bio_t
op_star
id|r10_bio
op_assign
(paren
id|r10bio_t
op_star
)paren
(paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
id|r10_bio-&gt;mddev
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
comma
id|d
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;copies
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio
op_eq
id|bio
)paren
r_break
suffix:semicolon
id|d
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|devnum
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
c_func
(paren
id|mddev
comma
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev
)paren
suffix:semicolon
id|update_head_pos
c_func
(paren
id|i
comma
id|r10_bio
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
)paren
)paren
(brace
r_if
c_cond
(paren
id|r10_bio-&gt;master_bio
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* the primary of several recovery bios */
id|md_done_sync
c_func
(paren
id|mddev
comma
id|r10_bio-&gt;sectors
comma
l_int|1
)paren
suffix:semicolon
id|put_buf
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|r10bio_t
op_star
id|r10_bio2
op_assign
(paren
id|r10bio_t
op_star
)paren
id|r10_bio-&gt;master_bio
suffix:semicolon
id|put_buf
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
id|r10_bio
op_assign
id|r10_bio2
suffix:semicolon
)brace
)brace
id|rdev_dec_pending
c_func
(paren
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev
comma
id|mddev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: sync and recover and handled very differently for raid10&n; * This code is for resync.&n; * For resync, we read through virtual addresses and read all blocks.&n; * If there is any error, we schedule a write.  The lowest numbered&n; * drive is authoritative.&n; * However requests come for physical address, so we need to map.&n; * For every physical address there are raid_disks/copies virtual addresses,&n; * which is always are least one, but is not necessarly an integer.&n; * This means that a physical address can span multiple chunks, so we may&n; * have to submit multiple io requests for a single sync request.&n; */
multiline_comment|/*&n; * We check if all blocks are in-sync and only write to blocks that&n; * aren&squot;t in sync&n; */
DECL|function|sync_request_write
r_static
r_void
id|sync_request_write
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|r10bio_t
op_star
id|r10_bio
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
comma
id|first
suffix:semicolon
r_struct
id|bio
op_star
id|tbio
comma
op_star
id|fbio
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* find the first device with a block */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;copies
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio-&gt;bi_flags
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|conf-&gt;copies
)paren
r_goto
id|done
suffix:semicolon
id|first
op_assign
id|i
suffix:semicolon
id|fbio
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio
suffix:semicolon
multiline_comment|/* now find blocks with errors */
r_for
c_loop
(paren
id|i
op_assign
id|first
op_plus
l_int|1
suffix:semicolon
id|i
OL
id|conf-&gt;copies
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|vcnt
comma
id|j
comma
id|d
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio-&gt;bi_flags
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* We know that the bi_io_vec layout is the same for&n;&t;&t; * both &squot;first&squot; and &squot;i&squot;, so we just compare them.&n;&t;&t; * All vec entries are PAGE_SIZE;&n;&t;&t; */
id|tbio
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio
suffix:semicolon
id|vcnt
op_assign
id|r10_bio-&gt;sectors
op_rshift
(paren
id|PAGE_SHIFT
op_minus
l_int|9
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|vcnt
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|page_address
c_func
(paren
id|fbio-&gt;bi_io_vec
(braket
id|j
)braket
dot
id|bv_page
)paren
comma
id|page_address
c_func
(paren
id|tbio-&gt;bi_io_vec
(braket
id|j
)braket
dot
id|bv_page
)paren
comma
id|PAGE_SIZE
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
id|vcnt
)paren
r_continue
suffix:semicolon
multiline_comment|/* Ok, we need to write this bio&n;&t;&t; * First we need to fixup bv_offset, bv_len and&n;&t;&t; * bi_vecs, as the read request might have corrupted these&n;&t;&t; */
id|tbio-&gt;bi_vcnt
op_assign
id|vcnt
suffix:semicolon
id|tbio-&gt;bi_size
op_assign
id|r10_bio-&gt;sectors
op_lshift
l_int|9
suffix:semicolon
id|tbio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|tbio-&gt;bi_phys_segments
op_assign
l_int|0
suffix:semicolon
id|tbio-&gt;bi_hw_segments
op_assign
l_int|0
suffix:semicolon
id|tbio-&gt;bi_hw_front_size
op_assign
l_int|0
suffix:semicolon
id|tbio-&gt;bi_hw_back_size
op_assign
l_int|0
suffix:semicolon
id|tbio-&gt;bi_flags
op_and_assign
op_complement
(paren
id|BIO_POOL_MASK
op_minus
l_int|1
)paren
suffix:semicolon
id|tbio-&gt;bi_flags
op_or_assign
l_int|1
op_lshift
id|BIO_UPTODATE
suffix:semicolon
id|tbio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
id|tbio-&gt;bi_rw
op_assign
id|WRITE
suffix:semicolon
id|tbio-&gt;bi_private
op_assign
id|r10_bio
suffix:semicolon
id|tbio-&gt;bi_sector
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|addr
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|vcnt
suffix:semicolon
id|j
op_increment
)paren
(brace
id|tbio-&gt;bi_io_vec
(braket
id|j
)braket
dot
id|bv_offset
op_assign
l_int|0
suffix:semicolon
id|tbio-&gt;bi_io_vec
(braket
id|j
)braket
dot
id|bv_len
op_assign
id|PAGE_SIZE
suffix:semicolon
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|tbio-&gt;bi_io_vec
(braket
id|j
)braket
dot
id|bv_page
)paren
comma
id|page_address
c_func
(paren
id|fbio-&gt;bi_io_vec
(braket
id|j
)braket
dot
id|bv_page
)paren
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
id|tbio-&gt;bi_end_io
op_assign
id|end_sync_write
suffix:semicolon
id|d
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|devnum
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
)paren
suffix:semicolon
id|md_sync_acct
c_func
(paren
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;bdev
comma
id|tbio-&gt;bi_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|tbio
)paren
suffix:semicolon
)brace
id|done
suffix:colon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
)paren
)paren
(brace
id|md_done_sync
c_func
(paren
id|mddev
comma
id|r10_bio-&gt;sectors
comma
l_int|1
)paren
suffix:semicolon
id|put_buf
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Now for the recovery code.&n; * Recovery happens across physical sectors.&n; * We recover all non-is_sync drives by finding the virtual address of&n; * each, and then choose a working drive that also has that virt address.&n; * There is a separate r10_bio for each non-in_sync drive.&n; * Only the first two slots are in use. The first for reading,&n; * The second for writing.&n; *&n; */
DECL|function|recovery_request_write
r_static
r_void
id|recovery_request_write
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|r10bio_t
op_star
id|r10_bio
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
comma
id|d
suffix:semicolon
r_struct
id|bio
op_star
id|bio
comma
op_star
id|wbio
suffix:semicolon
multiline_comment|/* move the pages across to the second bio&n;&t; * and submit the write request&n;&t; */
id|bio
op_assign
id|r10_bio-&gt;devs
(braket
l_int|0
)braket
dot
id|bio
suffix:semicolon
id|wbio
op_assign
id|r10_bio-&gt;devs
(braket
l_int|1
)braket
dot
id|bio
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|wbio-&gt;bi_vcnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|p
op_assign
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
op_assign
id|wbio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
suffix:semicolon
id|wbio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
op_assign
id|p
suffix:semicolon
)brace
id|d
op_assign
id|r10_bio-&gt;devs
(braket
l_int|1
)braket
dot
id|devnum
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|md_sync_acct
c_func
(paren
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;bdev
comma
id|wbio-&gt;bi_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|wbio
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a kernel thread which:&n; *&n; *&t;1.&t;Retries failed read operations on working mirrors.&n; *&t;2.&t;Updates the raid superblock when problems encounter.&n; *&t;3.&t;Performs writes following reads for array syncronising.&n; */
DECL|function|raid10d
r_static
r_void
id|raid10d
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|r10bio_t
op_star
id|r10_bio
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|conf-&gt;retry_list
suffix:semicolon
r_int
id|unplug
op_assign
l_int|0
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|md_check_recovery
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|md_handle_safemode
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|head
)paren
)paren
r_break
suffix:semicolon
id|r10_bio
op_assign
id|list_entry
c_func
(paren
id|head-&gt;prev
comma
id|r10bio_t
comma
id|retry_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|head-&gt;prev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
id|mddev
op_assign
id|r10_bio-&gt;mddev
suffix:semicolon
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|R10BIO_IsSync
comma
op_amp
id|r10_bio-&gt;state
)paren
)paren
(brace
id|sync_request_write
c_func
(paren
id|mddev
comma
id|r10_bio
)paren
suffix:semicolon
id|unplug
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|R10BIO_IsRecover
comma
op_amp
id|r10_bio-&gt;state
)paren
)paren
(brace
id|recovery_request_write
c_func
(paren
id|mddev
comma
id|r10_bio
)paren
suffix:semicolon
id|unplug
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_int
id|mirror
suffix:semicolon
id|bio
op_assign
id|r10_bio-&gt;devs
(braket
id|r10_bio-&gt;read_slot
)braket
dot
id|bio
suffix:semicolon
id|r10_bio-&gt;devs
(braket
id|r10_bio-&gt;read_slot
)braket
dot
id|bio
op_assign
l_int|NULL
suffix:semicolon
id|mirror
op_assign
id|read_balance
c_func
(paren
id|conf
comma
id|r10_bio
)paren
suffix:semicolon
id|r10_bio-&gt;devs
(braket
id|r10_bio-&gt;read_slot
)braket
dot
id|bio
op_assign
id|bio
suffix:semicolon
r_if
c_cond
(paren
id|mirror
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;raid10: %s: unrecoverable I/O&quot;
l_string|&quot; read error for block %llu&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|bio-&gt;bi_bdev
comma
id|b
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|r10_bio-&gt;sector
)paren
suffix:semicolon
id|raid_end_bio_io
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
)brace
r_else
(brace
id|rdev
op_assign
id|conf-&gt;mirrors
(braket
id|mirror
)braket
dot
id|rdev
suffix:semicolon
r_if
c_cond
(paren
id|printk_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid10: %s: redirecting sector %llu to&quot;
l_string|&quot; another mirror&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|r10_bio-&gt;sector
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|rdev-&gt;bdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|r10_bio-&gt;devs
(braket
id|r10_bio-&gt;read_slot
)braket
dot
id|addr
op_plus
id|rdev-&gt;data_offset
suffix:semicolon
id|bio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
id|bio-&gt;bi_flags
op_and_assign
(paren
l_int|1
op_lshift
id|BIO_CLONED
)paren
suffix:semicolon
id|bio-&gt;bi_flags
op_or_assign
l_int|1
op_lshift
id|BIO_UPTODATE
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_assign
id|r10_bio-&gt;sectors
op_lshift
l_int|9
suffix:semicolon
id|bio-&gt;bi_rw
op_assign
id|READ
suffix:semicolon
id|unplug
op_assign
l_int|1
suffix:semicolon
id|generic_make_request
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;device_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unplug
)paren
id|unplug_slaves
c_func
(paren
id|mddev
)paren
suffix:semicolon
)brace
DECL|function|init_resync
r_static
r_int
id|init_resync
c_func
(paren
id|conf_t
op_star
id|conf
)paren
(brace
r_int
id|buffs
suffix:semicolon
id|buffs
op_assign
id|RESYNC_WINDOW
op_div
id|RESYNC_BLOCK_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;r10buf_pool
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|conf-&gt;r10buf_pool
op_assign
id|mempool_create
c_func
(paren
id|buffs
comma
id|r10buf_pool_alloc
comma
id|r10buf_pool_free
comma
id|conf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;r10buf_pool
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|conf-&gt;next_resync
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * perform a &quot;sync&quot; on one &quot;block&quot;&n; *&n; * We need to make sure that no normal I/O request - particularly write&n; * requests - conflict with active sync requests.&n; *&n; * This is achieved by tracking pending requests and a &squot;barrier&squot; concept&n; * that can be installed to exclude normal IO requests.&n; *&n; * Resync and recovery are handled very differently.&n; * We differentiate by looking at MD_RECOVERY_SYNC in mddev-&gt;recovery.&n; *&n; * For resync, we iterate over virtual addresses, read all copies,&n; * and update if there are differences.  If only one copy is live,&n; * skip it.&n; * For recovery, we iterate over physical addresses, read a good&n; * value for each non-in_sync drive, and over-write.&n; *&n; * So, for recovery we may have several outstanding complex requests for a&n; * given address, one for each out-of-sync device.  We model this by allocating&n; * a number of r10_bio structures, one for each out-of-sync device.&n; * As we setup these structures, we collect all bio&squot;s together into a list&n; * which we then process collectively to add pages, and then process again&n; * to pass to generic_make_request.&n; *&n; * The r10_bio structures are linked using a borrowed master_bio pointer.&n; * This link is counted in -&gt;remaining.  When the r10_bio that points to NULL&n; * has its remaining count decremented to 0, the whole complex operation&n; * is complete.&n; *&n; */
DECL|function|sync_request
r_static
r_int
id|sync_request
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|sector_t
id|sector_nr
comma
r_int
id|go_faster
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|r10bio_t
op_star
id|r10_bio
suffix:semicolon
r_struct
id|bio
op_star
id|biolist
op_assign
l_int|NULL
comma
op_star
id|bio
suffix:semicolon
id|sector_t
id|max_sector
comma
id|nr_sectors
suffix:semicolon
r_int
id|disk
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sector_t
id|sectors_skipped
op_assign
l_int|0
suffix:semicolon
r_int
id|chunks_skipped
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;r10buf_pool
)paren
r_if
c_cond
(paren
id|init_resync
c_func
(paren
id|conf
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|skipped
suffix:colon
id|max_sector
op_assign
id|mddev-&gt;size
op_lshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|MD_RECOVERY_SYNC
comma
op_amp
id|mddev-&gt;recovery
)paren
)paren
id|max_sector
op_assign
id|mddev-&gt;resync_max_sectors
suffix:semicolon
r_if
c_cond
(paren
id|sector_nr
op_ge
id|max_sector
)paren
(brace
id|close_sync
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|sectors_skipped
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chunks_skipped
op_ge
id|conf-&gt;raid_disks
)paren
(brace
multiline_comment|/* if there has been nothing to do on any drive,&n;&t;&t; * then there is nothing to do at all..&n;&t;&t; */
id|sector_t
id|sec
op_assign
id|max_sector
op_minus
id|sector_nr
suffix:semicolon
id|md_done_sync
c_func
(paren
id|mddev
comma
id|sec
comma
l_int|1
)paren
suffix:semicolon
r_return
id|sec
op_plus
id|sectors_skipped
suffix:semicolon
)brace
multiline_comment|/* make sure whole request will fit in a chunk - if chunks&n;&t; * are meaningful&n;&t; */
r_if
c_cond
(paren
id|conf-&gt;near_copies
template_param
(paren
id|sector_nr
op_or
id|conf-&gt;chunk_mask
)paren
)paren
id|max_sector
op_assign
(paren
id|sector_nr
op_or
id|conf-&gt;chunk_mask
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If there is non-resync activity waiting for us then&n;&t; * put in a delay to throttle resync.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|go_faster
op_logical_and
id|waitqueue_active
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
)paren
id|msleep_interruptible
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|device_barrier
c_func
(paren
id|conf
comma
id|sector_nr
op_plus
id|RESYNC_SECTORS
)paren
suffix:semicolon
multiline_comment|/* Again, very different code for resync and recovery.&n;&t; * Both must result in an r10bio with a list of bios that&n;&t; * have bi_end_io, bi_sector, bi_bdev set,&n;&t; * and bi_private set to the r10bio.&n;&t; * For recovery, we may actually create several r10bios&n;&t; * with 2 bios in each, that correspond to the bios in the main one.&n;&t; * In this case, the subordinate r10bios link back through a&n;&t; * borrowed master_bio pointer, and the counter in the master&n;&t; * includes a ref from each subordinate.&n;&t; */
multiline_comment|/* First, we decide what to do and set -&gt;bi_end_io&n;&t; * To end_sync_read if we want to read, and&n;&t; * end_sync_write if we will want to write.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|MD_RECOVERY_SYNC
comma
op_amp
id|mddev-&gt;recovery
)paren
)paren
(brace
multiline_comment|/* recovery... the complicated one */
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
id|r10_bio
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev
op_logical_and
op_logical_neg
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;in_sync
)paren
(brace
multiline_comment|/* want to reconstruct this device */
id|r10bio_t
op_star
id|rb2
op_assign
id|r10_bio
suffix:semicolon
id|r10_bio
op_assign
id|mempool_alloc
c_func
(paren
id|conf-&gt;r10buf_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|conf-&gt;nr_pending
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rb2
)paren
id|conf-&gt;barrier
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
comma
l_int|0
)paren
suffix:semicolon
id|r10_bio-&gt;master_bio
op_assign
(paren
r_struct
id|bio
op_star
)paren
id|rb2
suffix:semicolon
r_if
c_cond
(paren
id|rb2
)paren
id|atomic_inc
c_func
(paren
op_amp
id|rb2-&gt;remaining
)paren
suffix:semicolon
id|r10_bio-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|set_bit
c_func
(paren
id|R10BIO_IsRecover
comma
op_amp
id|r10_bio-&gt;state
)paren
suffix:semicolon
id|r10_bio-&gt;sector
op_assign
id|raid10_find_virt
c_func
(paren
id|conf
comma
id|sector_nr
comma
id|i
)paren
suffix:semicolon
id|raid10_find_phys
c_func
(paren
id|conf
comma
id|r10_bio
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|conf-&gt;copies
suffix:semicolon
id|j
op_increment
)paren
(brace
r_int
id|d
op_assign
id|r10_bio-&gt;devs
(braket
id|j
)braket
dot
id|devnum
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev
op_logical_and
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;in_sync
)paren
(brace
multiline_comment|/* This is where we read from */
id|bio
op_assign
id|r10_bio-&gt;devs
(braket
l_int|0
)braket
dot
id|bio
suffix:semicolon
id|bio-&gt;bi_next
op_assign
id|biolist
suffix:semicolon
id|biolist
op_assign
id|bio
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|r10_bio
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|end_sync_read
suffix:semicolon
id|bio-&gt;bi_rw
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|r10_bio-&gt;devs
(braket
id|j
)braket
dot
id|addr
op_plus
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;data_offset
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;bdev
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
)paren
suffix:semicolon
multiline_comment|/* and we write to &squot;i&squot; */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|conf-&gt;copies
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|r10_bio-&gt;devs
(braket
id|k
)braket
dot
id|devnum
op_eq
id|i
)paren
r_break
suffix:semicolon
id|bio
op_assign
id|r10_bio-&gt;devs
(braket
l_int|1
)braket
dot
id|bio
suffix:semicolon
id|bio-&gt;bi_next
op_assign
id|biolist
suffix:semicolon
id|biolist
op_assign
id|bio
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|r10_bio
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|end_sync_write
suffix:semicolon
id|bio-&gt;bi_rw
op_assign
l_int|1
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|r10_bio-&gt;devs
(braket
id|k
)braket
dot
id|addr
op_plus
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;data_offset
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;bdev
suffix:semicolon
id|r10_bio-&gt;devs
(braket
l_int|0
)braket
dot
id|devnum
op_assign
id|d
suffix:semicolon
id|r10_bio-&gt;devs
(braket
l_int|1
)braket
dot
id|devnum
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|j
op_eq
id|conf-&gt;copies
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|biolist
op_eq
l_int|NULL
)paren
(brace
r_while
c_loop
(paren
id|r10_bio
)paren
(brace
id|r10bio_t
op_star
id|rb2
op_assign
id|r10_bio
suffix:semicolon
id|r10_bio
op_assign
(paren
id|r10bio_t
op_star
)paren
id|rb2-&gt;master_bio
suffix:semicolon
id|rb2-&gt;master_bio
op_assign
l_int|NULL
suffix:semicolon
id|put_buf
c_func
(paren
id|rb2
)paren
suffix:semicolon
)brace
r_goto
id|giveup
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* resync. Schedule a read for every block at this virt offset */
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|r10_bio
op_assign
id|mempool_alloc
c_func
(paren
id|conf-&gt;r10buf_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|conf-&gt;nr_pending
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|r10_bio-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
comma
l_int|0
)paren
suffix:semicolon
id|r10_bio-&gt;master_bio
op_assign
l_int|NULL
suffix:semicolon
id|r10_bio-&gt;sector
op_assign
id|sector_nr
suffix:semicolon
id|set_bit
c_func
(paren
id|R10BIO_IsSync
comma
op_amp
id|r10_bio-&gt;state
)paren
suffix:semicolon
id|raid10_find_phys
c_func
(paren
id|conf
comma
id|r10_bio
)paren
suffix:semicolon
id|r10_bio-&gt;sectors
op_assign
(paren
id|sector_nr
op_or
id|conf-&gt;chunk_mask
)paren
op_minus
id|sector_nr
op_plus
l_int|1
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;copies
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|d
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|devnum
suffix:semicolon
id|bio
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev
op_eq
l_int|NULL
op_logical_or
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;faulty
)paren
r_continue
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|r10_bio-&gt;remaining
)paren
suffix:semicolon
id|bio-&gt;bi_next
op_assign
id|biolist
suffix:semicolon
id|biolist
op_assign
id|bio
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|r10_bio
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|end_sync_read
suffix:semicolon
id|bio-&gt;bi_rw
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|addr
op_plus
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;data_offset
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;bdev
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|2
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;copies
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|d
op_assign
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|devnum
suffix:semicolon
r_if
c_cond
(paren
id|r10_bio-&gt;devs
(braket
id|i
)braket
dot
id|bio-&gt;bi_end_io
)paren
id|atomic_dec
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|d
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
)brace
id|put_buf
c_func
(paren
id|r10_bio
)paren
suffix:semicolon
r_goto
id|giveup
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|bio
op_assign
id|biolist
suffix:semicolon
id|bio
suffix:semicolon
id|bio
op_assign
id|bio-&gt;bi_next
)paren
(brace
id|bio-&gt;bi_flags
op_and_assign
op_complement
(paren
id|BIO_POOL_MASK
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_end_io
)paren
id|bio-&gt;bi_flags
op_or_assign
l_int|1
op_lshift
id|BIO_UPTODATE
suffix:semicolon
id|bio-&gt;bi_vcnt
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_phys_segments
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_hw_segments
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_assign
l_int|0
suffix:semicolon
)brace
id|nr_sectors
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|len
op_assign
id|PAGE_SIZE
suffix:semicolon
id|disk
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sector_nr
op_plus
(paren
id|len
op_rshift
l_int|9
)paren
OG
id|max_sector
)paren
id|len
op_assign
(paren
id|max_sector
op_minus
id|sector_nr
)paren
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|bio
op_assign
id|biolist
suffix:semicolon
id|bio
suffix:semicolon
id|bio
op_assign
id|bio-&gt;bi_next
)paren
(brace
id|page
op_assign
id|bio-&gt;bi_io_vec
(braket
id|bio-&gt;bi_vcnt
)braket
dot
id|bv_page
suffix:semicolon
r_if
c_cond
(paren
id|bio_add_page
c_func
(paren
id|bio
comma
id|page
comma
id|len
comma
l_int|0
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* stop here */
r_struct
id|bio
op_star
id|bio2
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
id|bio-&gt;bi_vcnt
)braket
dot
id|bv_page
op_assign
id|page
suffix:semicolon
r_for
c_loop
(paren
id|bio2
op_assign
id|biolist
suffix:semicolon
id|bio2
op_logical_and
id|bio2
op_ne
id|bio
suffix:semicolon
id|bio2
op_assign
id|bio2-&gt;bi_next
)paren
(brace
multiline_comment|/* remove last page from this bio */
id|bio2-&gt;bi_vcnt
op_decrement
suffix:semicolon
id|bio2-&gt;bi_size
op_sub_assign
id|len
suffix:semicolon
id|bio2-&gt;bi_flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|BIO_SEG_VALID
)paren
suffix:semicolon
)brace
r_goto
id|bio_full
suffix:semicolon
)brace
id|disk
op_assign
id|i
suffix:semicolon
)brace
id|nr_sectors
op_add_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|sector_nr
op_add_assign
id|len
op_rshift
l_int|9
suffix:semicolon
)brace
r_while
c_loop
(paren
id|biolist-&gt;bi_vcnt
OL
id|RESYNC_PAGES
)paren
suffix:semicolon
id|bio_full
suffix:colon
id|r10_bio-&gt;sectors
op_assign
id|nr_sectors
suffix:semicolon
r_while
c_loop
(paren
id|biolist
)paren
(brace
id|bio
op_assign
id|biolist
suffix:semicolon
id|biolist
op_assign
id|biolist-&gt;bi_next
suffix:semicolon
id|bio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
id|r10_bio
op_assign
id|bio-&gt;bi_private
suffix:semicolon
id|r10_bio-&gt;sectors
op_assign
id|nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_end_io
op_eq
id|end_sync_read
)paren
(brace
id|md_sync_acct
c_func
(paren
id|bio-&gt;bi_bdev
comma
id|nr_sectors
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
)brace
r_return
id|nr_sectors
suffix:semicolon
id|giveup
suffix:colon
multiline_comment|/* There is nowhere to write, so all non-sync&n;&t; * drives must be failed, so try the next chunk...&n;&t; */
(brace
r_int
id|sec
op_assign
id|max_sector
op_minus
id|sector_nr
suffix:semicolon
id|sectors_skipped
op_add_assign
id|sec
suffix:semicolon
id|chunks_skipped
op_increment
suffix:semicolon
id|sector_nr
op_assign
id|max_sector
suffix:semicolon
id|md_done_sync
c_func
(paren
id|mddev
comma
id|sec
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|skipped
suffix:semicolon
)brace
)brace
DECL|function|run
r_static
r_int
id|run
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|conf_t
op_star
id|conf
suffix:semicolon
r_int
id|i
comma
id|disk_idx
suffix:semicolon
id|mirror_info_t
op_star
id|disk
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|nc
comma
id|fc
suffix:semicolon
id|sector_t
id|stride
comma
id|size
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;level
op_ne
l_int|10
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid10: %s: raid level not set correctly... (%d)&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
comma
id|mddev-&gt;level
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|nc
op_assign
id|mddev-&gt;layout
op_amp
l_int|255
suffix:semicolon
id|fc
op_assign
(paren
id|mddev-&gt;layout
op_rshift
l_int|8
)paren
op_amp
l_int|255
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nc
op_star
id|fc
)paren
template_param
id|mddev-&gt;raid_disks
op_logical_or
(paren
id|mddev-&gt;layout
op_rshift
l_int|16
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid10: %s: unsupported raid10 layout: 0x%8x&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
comma
id|mddev-&gt;layout
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * copy the already verified devices into our private RAID10&n;&t; * bookkeeping area. [whatever we allocate in run(),&n;&t; * should be freed in stop()]&n;&t; */
id|conf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|conf_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
id|conf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid10: couldn&squot;t allocate memory for %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|conf
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|conf
)paren
)paren
suffix:semicolon
id|conf-&gt;mirrors
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|mirror_info
)paren
op_star
id|mddev-&gt;raid_disks
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mirrors
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid10: couldn&squot;t allocate memory for %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
id|memset
c_func
(paren
id|conf-&gt;mirrors
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mirror_info
)paren
op_star
id|mddev-&gt;raid_disks
)paren
suffix:semicolon
id|conf-&gt;near_copies
op_assign
id|nc
suffix:semicolon
id|conf-&gt;far_copies
op_assign
id|fc
suffix:semicolon
id|conf-&gt;copies
op_assign
id|nc
op_star
id|fc
suffix:semicolon
id|conf-&gt;chunk_mask
op_assign
(paren
id|sector_t
)paren
(paren
id|mddev-&gt;chunk_size
op_rshift
l_int|9
)paren
op_minus
l_int|1
suffix:semicolon
id|conf-&gt;chunk_shift
op_assign
id|ffz
c_func
(paren
op_complement
id|mddev-&gt;chunk_size
)paren
op_minus
l_int|9
suffix:semicolon
id|stride
op_assign
id|mddev-&gt;size
op_rshift
(paren
id|conf-&gt;chunk_shift
op_minus
l_int|1
)paren
suffix:semicolon
id|sector_div
c_func
(paren
id|stride
comma
id|fc
)paren
suffix:semicolon
id|conf-&gt;stride
op_assign
id|stride
op_lshift
id|conf-&gt;chunk_shift
suffix:semicolon
id|conf-&gt;r10bio_pool
op_assign
id|mempool_create
c_func
(paren
id|NR_RAID10_BIOS
comma
id|r10bio_pool_alloc
comma
id|r10bio_pool_free
comma
id|conf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;r10bio_pool
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid10: couldn&squot;t allocate memory for %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
id|mddev-&gt;queue-&gt;unplug_fn
op_assign
id|raid10_unplug
suffix:semicolon
id|mddev-&gt;queue-&gt;issue_flush_fn
op_assign
id|raid10_issue_flush
suffix:semicolon
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|disk_idx
op_assign
id|rdev-&gt;raid_disk
suffix:semicolon
r_if
c_cond
(paren
id|disk_idx
op_ge
id|mddev-&gt;raid_disks
op_logical_or
id|disk_idx
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|disk
op_assign
id|conf-&gt;mirrors
op_plus
id|disk_idx
suffix:semicolon
id|disk-&gt;rdev
op_assign
id|rdev
suffix:semicolon
id|blk_queue_stack_limits
c_func
(paren
id|mddev-&gt;queue
comma
id|rdev-&gt;bdev-&gt;bd_disk-&gt;queue
)paren
suffix:semicolon
multiline_comment|/* as we don&squot;t honour merge_bvec_fn, we must never risk&n;&t;&t; * violating it, so limit -&gt;max_sector to one PAGE, as&n;&t;&t; * a one page request is never in violation.&n;&t;&t; */
r_if
c_cond
(paren
id|rdev-&gt;bdev-&gt;bd_disk-&gt;queue-&gt;merge_bvec_fn
op_logical_and
id|mddev-&gt;queue-&gt;max_sectors
OG
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
)paren
id|mddev-&gt;queue-&gt;max_sectors
op_assign
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
suffix:semicolon
id|disk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;faulty
op_logical_and
id|rdev-&gt;in_sync
)paren
id|conf-&gt;working_disks
op_increment
suffix:semicolon
)brace
id|conf-&gt;raid_disks
op_assign
id|mddev-&gt;raid_disks
suffix:semicolon
id|conf-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|conf-&gt;device_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|conf-&gt;retry_list
)paren
suffix:semicolon
id|conf-&gt;resync_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;working_disks
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid10: no operational mirrors for %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
id|mddev-&gt;degraded
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|disk
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk-&gt;rdev
)paren
(brace
id|disk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
id|mddev-&gt;degraded
op_increment
suffix:semicolon
)brace
)brace
id|mddev-&gt;thread
op_assign
id|md_register_thread
c_func
(paren
id|raid10d
comma
id|mddev
comma
l_string|&quot;%s_raid10&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;thread
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid10: couldn&squot;t allocate thread for %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;raid10: raid set %s active with %d out of %d devices&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
comma
id|mddev-&gt;raid_disks
op_minus
id|mddev-&gt;degraded
comma
id|mddev-&gt;raid_disks
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, everything is just fine now&n;&t; */
id|size
op_assign
id|conf-&gt;stride
op_star
id|conf-&gt;raid_disks
suffix:semicolon
id|sector_div
c_func
(paren
id|size
comma
id|conf-&gt;near_copies
)paren
suffix:semicolon
id|mddev-&gt;array_size
op_assign
id|size
op_div
l_int|2
suffix:semicolon
id|mddev-&gt;resync_max_sectors
op_assign
id|size
suffix:semicolon
multiline_comment|/* Calculate max read-ahead size.&n;&t; * We need to readahead at least twice a whole stripe....&n;&t; * maybe...&n;&t; */
(brace
r_int
id|stripe
op_assign
id|conf-&gt;raid_disks
op_star
id|mddev-&gt;chunk_size
op_div
id|PAGE_CACHE_SIZE
suffix:semicolon
id|stripe
op_div_assign
id|conf-&gt;near_copies
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;queue-&gt;backing_dev_info.ra_pages
OL
l_int|2
op_star
id|stripe
)paren
id|mddev-&gt;queue-&gt;backing_dev_info.ra_pages
op_assign
l_int|2
op_star
id|stripe
suffix:semicolon
)brace
r_if
c_cond
(paren
id|conf-&gt;near_copies
OL
id|mddev-&gt;raid_disks
)paren
id|blk_queue_merge_bvec
c_func
(paren
id|mddev-&gt;queue
comma
id|raid10_mergeable_bvec
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_free_conf
suffix:colon
r_if
c_cond
(paren
id|conf-&gt;r10bio_pool
)paren
id|mempool_destroy
c_func
(paren
id|conf-&gt;r10bio_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;mirrors
)paren
id|kfree
c_func
(paren
id|conf-&gt;mirrors
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|stop
r_static
r_int
id|stop
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|md_unregister_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
id|mddev-&gt;thread
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;r10bio_pool
)paren
id|mempool_destroy
c_func
(paren
id|conf-&gt;r10bio_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;mirrors
)paren
id|kfree
c_func
(paren
id|conf-&gt;mirrors
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|raid10_personality
r_static
id|mdk_personality_t
id|raid10_personality
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;raid10&quot;
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|make_request
op_assign
id|make_request
comma
dot
id|run
op_assign
id|run
comma
dot
id|stop
op_assign
id|stop
comma
dot
id|status
op_assign
id|status
comma
dot
id|error_handler
op_assign
id|error
comma
dot
id|hot_add_disk
op_assign
id|raid10_add_disk
comma
dot
id|hot_remove_disk
op_assign
id|raid10_remove_disk
comma
dot
id|spare_active
op_assign
id|raid10_spare_active
comma
dot
id|sync_request
op_assign
id|sync_request
comma
)brace
suffix:semicolon
DECL|function|raid_init
r_static
r_int
id|__init
id|raid_init
c_func
(paren
r_void
)paren
(brace
r_return
id|register_md_personality
c_func
(paren
id|RAID10
comma
op_amp
id|raid10_personality
)paren
suffix:semicolon
)brace
DECL|function|raid_exit
r_static
r_void
id|raid_exit
c_func
(paren
r_void
)paren
(brace
id|unregister_md_personality
c_func
(paren
id|RAID10
)paren
suffix:semicolon
)brace
DECL|variable|raid_init
id|module_init
c_func
(paren
id|raid_init
)paren
suffix:semicolon
DECL|variable|raid_exit
id|module_exit
c_func
(paren
id|raid_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_ALIAS
c_func
(paren
l_string|&quot;md-personality-9&quot;
)paren
suffix:semicolon
multiline_comment|/* RAID10 */
eof
