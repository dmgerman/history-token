multiline_comment|/*&n; * Copyright (C) 2003 Sistina Software Limited.&n; *&n; * This file is released under the GPL.&n; */
macro_line|#include &quot;dm.h&quot;
macro_line|#include &quot;dm-bio-list.h&quot;
macro_line|#include &quot;dm-io.h&quot;
macro_line|#include &quot;dm-log.h&quot;
macro_line|#include &quot;kcopyd.h&quot;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
DECL|variable|_kmirrord_wq
r_static
r_struct
id|workqueue_struct
op_star
id|_kmirrord_wq
suffix:semicolon
DECL|variable|_kmirrord_work
r_static
r_struct
id|work_struct
id|_kmirrord_work
suffix:semicolon
DECL|function|wake
r_static
r_inline
r_void
id|wake
c_func
(paren
r_void
)paren
(brace
id|queue_work
c_func
(paren
id|_kmirrord_wq
comma
op_amp
id|_kmirrord_work
)paren
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * Region hash&n; *&n; * The mirror splits itself up into discrete regions.  Each&n; * region can be in one of three states: clean, dirty,&n; * nosync.  There is no need to put clean regions in the hash.&n; *&n; * In addition to being present in the hash table a region _may_&n; * be present on one of three lists.&n; *&n; *   clean_regions: Regions on this list have no io pending to&n; *   them, they are in sync, we are no longer interested in them,&n; *   they are dull.  rh_update_states() will remove them from the&n; *   hash table.&n; *&n; *   quiesced_regions: These regions have been spun down, ready&n; *   for recovery.  rh_recovery_start() will remove regions from&n; *   this list and hand them to kmirrord, which will schedule the&n; *   recovery io with kcopyd.&n; *&n; *   recovered_regions: Regions that kcopyd has successfully&n; *   recovered.  rh_update_states() will now schedule any delayed&n; *   io, up the recovery_count, and remove the region from the&n; *   hash.&n; *&n; * There are 2 locks:&n; *   A rw spin lock &squot;hash_lock&squot; protects just the hash table,&n; *   this is never held in write mode from interrupt context,&n; *   which I believe means that we only have to disable irqs when&n; *   doing a write lock.&n; *&n; *   An ordinary spin lock &squot;region_lock&squot; that protects the three&n; *   lists in the region_hash, with the &squot;state&squot;, &squot;list&squot; and&n; *   &squot;bhs_delayed&squot; fields of the regions.  This is used from irq&n; *   context, so all other uses will have to suspend local irqs.&n; *---------------------------------------------------------------*/
r_struct
id|mirror_set
suffix:semicolon
DECL|struct|region_hash
r_struct
id|region_hash
(brace
DECL|member|ms
r_struct
id|mirror_set
op_star
id|ms
suffix:semicolon
DECL|member|region_size
id|sector_t
id|region_size
suffix:semicolon
DECL|member|region_shift
r_int
id|region_shift
suffix:semicolon
multiline_comment|/* holds persistent region state */
DECL|member|log
r_struct
id|dirty_log
op_star
id|log
suffix:semicolon
multiline_comment|/* hash table */
DECL|member|hash_lock
id|rwlock_t
id|hash_lock
suffix:semicolon
DECL|member|region_pool
id|mempool_t
op_star
id|region_pool
suffix:semicolon
DECL|member|mask
r_int
r_int
id|mask
suffix:semicolon
DECL|member|nr_buckets
r_int
r_int
id|nr_buckets
suffix:semicolon
DECL|member|buckets
r_struct
id|list_head
op_star
id|buckets
suffix:semicolon
DECL|member|region_lock
id|spinlock_t
id|region_lock
suffix:semicolon
DECL|member|recovery_count
r_struct
id|semaphore
id|recovery_count
suffix:semicolon
DECL|member|clean_regions
r_struct
id|list_head
id|clean_regions
suffix:semicolon
DECL|member|quiesced_regions
r_struct
id|list_head
id|quiesced_regions
suffix:semicolon
DECL|member|recovered_regions
r_struct
id|list_head
id|recovered_regions
suffix:semicolon
)brace
suffix:semicolon
r_enum
(brace
DECL|enumerator|RH_CLEAN
id|RH_CLEAN
comma
DECL|enumerator|RH_DIRTY
id|RH_DIRTY
comma
DECL|enumerator|RH_NOSYNC
id|RH_NOSYNC
comma
DECL|enumerator|RH_RECOVERING
id|RH_RECOVERING
)brace
suffix:semicolon
DECL|struct|region
r_struct
id|region
(brace
DECL|member|rh
r_struct
id|region_hash
op_star
id|rh
suffix:semicolon
multiline_comment|/* FIXME: can we get rid of this ? */
DECL|member|key
id|region_t
id|key
suffix:semicolon
DECL|member|state
r_int
id|state
suffix:semicolon
DECL|member|hash_list
r_struct
id|list_head
id|hash_list
suffix:semicolon
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|pending
id|atomic_t
id|pending
suffix:semicolon
DECL|member|delayed_bios
r_struct
id|bio_list
id|delayed_bios
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Conversion fns&n; */
DECL|function|bio_to_region
r_static
r_inline
id|region_t
id|bio_to_region
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_return
id|bio-&gt;bi_sector
op_rshift
id|rh-&gt;region_shift
suffix:semicolon
)brace
DECL|function|region_to_sector
r_static
r_inline
id|sector_t
id|region_to_sector
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
id|region_t
id|region
)paren
(brace
r_return
id|region
op_lshift
id|rh-&gt;region_shift
suffix:semicolon
)brace
multiline_comment|/* FIXME move this */
r_static
r_void
id|queue_bio
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
comma
r_struct
id|bio
op_star
id|bio
comma
r_int
id|rw
)paren
suffix:semicolon
DECL|function|region_alloc
r_static
r_void
op_star
id|region_alloc
c_func
(paren
r_int
id|gfp_mask
comma
r_void
op_star
id|pool_data
)paren
(brace
r_return
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|region
)paren
comma
id|gfp_mask
)paren
suffix:semicolon
)brace
DECL|function|region_free
r_static
r_void
id|region_free
c_func
(paren
r_void
op_star
id|element
comma
r_void
op_star
id|pool_data
)paren
(brace
id|kfree
c_func
(paren
id|element
)paren
suffix:semicolon
)brace
DECL|macro|MIN_REGIONS
mdefine_line|#define MIN_REGIONS 64
DECL|macro|MAX_RECOVERY
mdefine_line|#define MAX_RECOVERY 1
DECL|function|rh_init
r_static
r_int
id|rh_init
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
r_struct
id|mirror_set
op_star
id|ms
comma
r_struct
id|dirty_log
op_star
id|log
comma
id|sector_t
id|region_size
comma
id|region_t
id|nr_regions
)paren
(brace
r_int
r_int
id|nr_buckets
comma
id|max_buckets
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate a suitable number of buckets for our hash&n;&t; * table.&n;&t; */
id|max_buckets
op_assign
id|nr_regions
op_rshift
l_int|6
suffix:semicolon
r_for
c_loop
(paren
id|nr_buckets
op_assign
l_int|128u
suffix:semicolon
id|nr_buckets
OL
id|max_buckets
suffix:semicolon
id|nr_buckets
op_lshift_assign
l_int|1
)paren
suffix:semicolon
id|nr_buckets
op_rshift_assign
l_int|1
suffix:semicolon
id|rh-&gt;ms
op_assign
id|ms
suffix:semicolon
id|rh-&gt;log
op_assign
id|log
suffix:semicolon
id|rh-&gt;region_size
op_assign
id|region_size
suffix:semicolon
id|rh-&gt;region_shift
op_assign
id|ffs
c_func
(paren
id|region_size
)paren
op_minus
l_int|1
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
id|rh-&gt;mask
op_assign
id|nr_buckets
op_minus
l_int|1
suffix:semicolon
id|rh-&gt;nr_buckets
op_assign
id|nr_buckets
suffix:semicolon
id|rh-&gt;buckets
op_assign
id|vmalloc
c_func
(paren
id|nr_buckets
op_star
r_sizeof
(paren
op_star
id|rh-&gt;buckets
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rh-&gt;buckets
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;unable to allocate region hash memory&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_buckets
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
id|rh-&gt;buckets
op_plus
id|i
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|rh-&gt;recovery_count
comma
l_int|0
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rh-&gt;clean_regions
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rh-&gt;quiesced_regions
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rh-&gt;recovered_regions
)paren
suffix:semicolon
id|rh-&gt;region_pool
op_assign
id|mempool_create
c_func
(paren
id|MIN_REGIONS
comma
id|region_alloc
comma
id|region_free
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rh-&gt;region_pool
)paren
(brace
id|vfree
c_func
(paren
id|rh-&gt;buckets
)paren
suffix:semicolon
id|rh-&gt;buckets
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rh_exit
r_static
r_void
id|rh_exit
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
)paren
(brace
r_int
r_int
id|h
suffix:semicolon
r_struct
id|region
op_star
id|reg
comma
op_star
id|nreg
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|rh-&gt;quiesced_regions
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|rh-&gt;nr_buckets
suffix:semicolon
id|h
op_increment
)paren
(brace
id|list_for_each_entry_safe
c_func
(paren
id|reg
comma
id|nreg
comma
id|rh-&gt;buckets
op_plus
id|h
comma
id|hash_list
)paren
(brace
id|BUG_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|reg-&gt;pending
)paren
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|reg
comma
id|rh-&gt;region_pool
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rh-&gt;log
)paren
id|dm_destroy_dirty_log
c_func
(paren
id|rh-&gt;log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rh-&gt;region_pool
)paren
id|mempool_destroy
c_func
(paren
id|rh-&gt;region_pool
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|rh-&gt;buckets
)paren
suffix:semicolon
)brace
DECL|macro|RH_HASH_MULT
mdefine_line|#define RH_HASH_MULT 2654435387U
DECL|function|rh_hash
r_static
r_inline
r_int
r_int
id|rh_hash
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
id|region_t
id|region
)paren
(brace
r_return
(paren
r_int
r_int
)paren
(paren
(paren
id|region
op_star
id|RH_HASH_MULT
)paren
op_rshift
l_int|12
)paren
op_amp
id|rh-&gt;mask
suffix:semicolon
)brace
DECL|function|__rh_lookup
r_static
r_struct
id|region
op_star
id|__rh_lookup
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
id|region_t
id|region
)paren
(brace
r_struct
id|region
op_star
id|reg
suffix:semicolon
id|list_for_each_entry
(paren
id|reg
comma
id|rh-&gt;buckets
op_plus
id|rh_hash
c_func
(paren
id|rh
comma
id|region
)paren
comma
id|hash_list
)paren
r_if
c_cond
(paren
id|reg-&gt;key
op_eq
id|region
)paren
r_return
id|reg
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|__rh_insert
r_static
r_void
id|__rh_insert
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
r_struct
id|region
op_star
id|reg
)paren
(brace
r_int
r_int
id|h
op_assign
id|rh_hash
c_func
(paren
id|rh
comma
id|reg-&gt;key
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|reg-&gt;hash_list
comma
id|rh-&gt;buckets
op_plus
id|h
)paren
suffix:semicolon
)brace
DECL|function|__rh_alloc
r_static
r_struct
id|region
op_star
id|__rh_alloc
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
id|region_t
id|region
)paren
(brace
r_struct
id|region
op_star
id|reg
comma
op_star
id|nreg
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
id|nreg
op_assign
id|mempool_alloc
c_func
(paren
id|rh-&gt;region_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|nreg-&gt;state
op_assign
id|rh-&gt;log-&gt;type
op_member_access_from_pointer
id|in_sync
c_func
(paren
id|rh-&gt;log
comma
id|region
comma
l_int|1
)paren
ques
c_cond
id|RH_CLEAN
suffix:colon
id|RH_NOSYNC
suffix:semicolon
id|nreg-&gt;rh
op_assign
id|rh
suffix:semicolon
id|nreg-&gt;key
op_assign
id|region
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|nreg-&gt;list
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|nreg-&gt;pending
comma
l_int|0
)paren
suffix:semicolon
id|bio_list_init
c_func
(paren
op_amp
id|nreg-&gt;delayed_bios
)paren
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
id|reg
op_assign
id|__rh_lookup
c_func
(paren
id|rh
comma
id|region
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
)paren
multiline_comment|/* we lost the race */
id|mempool_free
c_func
(paren
id|nreg
comma
id|rh-&gt;region_pool
)paren
suffix:semicolon
r_else
(brace
id|__rh_insert
c_func
(paren
id|rh
comma
id|nreg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nreg-&gt;state
op_eq
id|RH_CLEAN
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|nreg-&gt;list
comma
op_amp
id|rh-&gt;clean_regions
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
)brace
id|reg
op_assign
id|nreg
suffix:semicolon
)brace
id|write_unlock_irq
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
DECL|function|__rh_find
r_static
r_inline
r_struct
id|region
op_star
id|__rh_find
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
id|region_t
id|region
)paren
(brace
r_struct
id|region
op_star
id|reg
suffix:semicolon
id|reg
op_assign
id|__rh_lookup
c_func
(paren
id|rh
comma
id|region
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reg
)paren
id|reg
op_assign
id|__rh_alloc
c_func
(paren
id|rh
comma
id|region
)paren
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
DECL|function|rh_state
r_static
r_int
id|rh_state
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
id|region_t
id|region
comma
r_int
id|may_block
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|region
op_star
id|reg
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
id|reg
op_assign
id|__rh_lookup
c_func
(paren
id|rh
comma
id|region
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
)paren
r_return
id|reg-&gt;state
suffix:semicolon
multiline_comment|/*&n;&t; * The region wasn&squot;t in the hash, so we fall back to the&n;&t; * dirty log.&n;&t; */
id|r
op_assign
id|rh-&gt;log-&gt;type
op_member_access_from_pointer
id|in_sync
c_func
(paren
id|rh-&gt;log
comma
id|region
comma
id|may_block
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Any error from the dirty log (eg. -EWOULDBLOCK) gets&n;&t; * taken as a RH_NOSYNC&n;&t; */
r_return
id|r
op_eq
l_int|1
ques
c_cond
id|RH_CLEAN
suffix:colon
id|RH_NOSYNC
suffix:semicolon
)brace
DECL|function|rh_in_sync
r_static
r_inline
r_int
id|rh_in_sync
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
id|region_t
id|region
comma
r_int
id|may_block
)paren
(brace
r_int
id|state
op_assign
id|rh_state
c_func
(paren
id|rh
comma
id|region
comma
id|may_block
)paren
suffix:semicolon
r_return
id|state
op_eq
id|RH_CLEAN
op_logical_or
id|state
op_eq
id|RH_DIRTY
suffix:semicolon
)brace
DECL|function|dispatch_bios
r_static
r_void
id|dispatch_bios
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
comma
r_struct
id|bio_list
op_star
id|bio_list
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bio
op_assign
id|bio_list_pop
c_func
(paren
id|bio_list
)paren
)paren
)paren
(brace
id|queue_bio
c_func
(paren
id|ms
comma
id|bio
comma
id|WRITE
)paren
suffix:semicolon
)brace
)brace
DECL|function|rh_update_states
r_static
r_void
id|rh_update_states
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
)paren
(brace
r_struct
id|region
op_star
id|reg
comma
op_star
id|next
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|clean
)paren
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|recovered
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Quickly grab the lists.&n;&t; */
id|write_lock_irq
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|rh-&gt;clean_regions
)paren
)paren
(brace
id|list_splice
c_func
(paren
op_amp
id|rh-&gt;clean_regions
comma
op_amp
id|clean
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rh-&gt;clean_regions
)paren
suffix:semicolon
id|list_for_each_entry
(paren
id|reg
comma
op_amp
id|clean
comma
id|list
)paren
(brace
id|rh-&gt;log-&gt;type
op_member_access_from_pointer
id|clear_region
c_func
(paren
id|rh-&gt;log
comma
id|reg-&gt;key
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|reg-&gt;hash_list
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|rh-&gt;recovered_regions
)paren
)paren
(brace
id|list_splice
c_func
(paren
op_amp
id|rh-&gt;recovered_regions
comma
op_amp
id|recovered
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rh-&gt;recovered_regions
)paren
suffix:semicolon
id|list_for_each_entry
(paren
id|reg
comma
op_amp
id|recovered
comma
id|list
)paren
id|list_del
c_func
(paren
op_amp
id|reg-&gt;hash_list
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * All the regions on the recovered and clean lists have&n;&t; * now been pulled out of the system, so no need to do&n;&t; * any more locking.&n;&t; */
id|list_for_each_entry_safe
(paren
id|reg
comma
id|next
comma
op_amp
id|recovered
comma
id|list
)paren
(brace
id|rh-&gt;log-&gt;type
op_member_access_from_pointer
id|clear_region
c_func
(paren
id|rh-&gt;log
comma
id|reg-&gt;key
)paren
suffix:semicolon
id|rh-&gt;log-&gt;type
op_member_access_from_pointer
id|complete_resync_work
c_func
(paren
id|rh-&gt;log
comma
id|reg-&gt;key
comma
l_int|1
)paren
suffix:semicolon
id|dispatch_bios
c_func
(paren
id|rh-&gt;ms
comma
op_amp
id|reg-&gt;delayed_bios
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|rh-&gt;recovery_count
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|reg
comma
id|rh-&gt;region_pool
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|recovered
)paren
)paren
id|rh-&gt;log-&gt;type
op_member_access_from_pointer
id|flush
c_func
(paren
id|rh-&gt;log
)paren
suffix:semicolon
id|list_for_each_entry_safe
(paren
id|reg
comma
id|next
comma
op_amp
id|clean
comma
id|list
)paren
id|mempool_free
c_func
(paren
id|reg
comma
id|rh-&gt;region_pool
)paren
suffix:semicolon
)brace
DECL|function|rh_inc
r_static
r_void
id|rh_inc
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
id|region_t
id|region
)paren
(brace
r_struct
id|region
op_star
id|reg
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
id|reg
op_assign
id|__rh_find
c_func
(paren
id|rh
comma
id|region
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;state
op_eq
id|RH_CLEAN
)paren
(brace
id|rh-&gt;log-&gt;type
op_member_access_from_pointer
id|mark_region
c_func
(paren
id|rh-&gt;log
comma
id|reg-&gt;key
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
id|reg-&gt;state
op_assign
id|RH_DIRTY
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|reg-&gt;list
)paren
suffix:semicolon
multiline_comment|/* take off the clean list */
id|spin_unlock_irq
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|reg-&gt;pending
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
)brace
DECL|function|rh_inc_pending
r_static
r_void
id|rh_inc_pending
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
r_struct
id|bio_list
op_star
id|bios
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_for
c_loop
(paren
id|bio
op_assign
id|bios-&gt;head
suffix:semicolon
id|bio
suffix:semicolon
id|bio
op_assign
id|bio-&gt;bi_next
)paren
id|rh_inc
c_func
(paren
id|rh
comma
id|bio_to_region
c_func
(paren
id|rh
comma
id|bio
)paren
)paren
suffix:semicolon
)brace
DECL|function|rh_dec
r_static
r_void
id|rh_dec
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
id|region_t
id|region
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|region
op_star
id|reg
suffix:semicolon
r_int
id|should_wake
op_assign
l_int|0
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
id|reg
op_assign
id|__rh_lookup
c_func
(paren
id|rh
comma
id|region
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|reg-&gt;pending
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|rh-&gt;region_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;state
op_eq
id|RH_RECOVERING
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|reg-&gt;list
comma
op_amp
id|rh-&gt;quiesced_regions
)paren
suffix:semicolon
)brace
r_else
(brace
id|reg-&gt;state
op_assign
id|RH_CLEAN
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|reg-&gt;list
comma
op_amp
id|rh-&gt;clean_regions
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|rh-&gt;region_lock
comma
id|flags
)paren
suffix:semicolon
id|should_wake
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|should_wake
)paren
id|wake
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Starts quiescing a region in preparation for recovery.&n; */
DECL|function|__rh_recovery_prepare
r_static
r_int
id|__rh_recovery_prepare
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|region
op_star
id|reg
suffix:semicolon
id|region_t
id|region
suffix:semicolon
multiline_comment|/*&n;&t; * Ask the dirty log what&squot;s next.&n;&t; */
id|r
op_assign
id|rh-&gt;log-&gt;type
op_member_access_from_pointer
id|get_resync_work
c_func
(paren
id|rh-&gt;log
comma
op_amp
id|region
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_le
l_int|0
)paren
r_return
id|r
suffix:semicolon
multiline_comment|/*&n;&t; * Get this region, and start it quiescing by setting the&n;&t; * recovering flag.&n;&t; */
id|read_lock
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
id|reg
op_assign
id|__rh_find
c_func
(paren
id|rh
comma
id|region
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
id|reg-&gt;state
op_assign
id|RH_RECOVERING
suffix:semicolon
multiline_comment|/* Already quiesced ? */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|reg-&gt;pending
)paren
)paren
id|list_del_init
c_func
(paren
op_amp
id|reg-&gt;list
)paren
suffix:semicolon
r_else
(brace
id|list_del_init
c_func
(paren
op_amp
id|reg-&gt;list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|reg-&gt;list
comma
op_amp
id|rh-&gt;quiesced_regions
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|rh_recovery_prepare
r_static
r_void
id|rh_recovery_prepare
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|down_trylock
c_func
(paren
op_amp
id|rh-&gt;recovery_count
)paren
)paren
r_if
c_cond
(paren
id|__rh_recovery_prepare
c_func
(paren
id|rh
)paren
op_le
l_int|0
)paren
(brace
id|up
c_func
(paren
op_amp
id|rh-&gt;recovery_count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Returns any quiesced regions.&n; */
DECL|function|rh_recovery_start
r_static
r_struct
id|region
op_star
id|rh_recovery_start
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
)paren
(brace
r_struct
id|region
op_star
id|reg
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|rh-&gt;quiesced_regions
)paren
)paren
(brace
id|reg
op_assign
id|list_entry
c_func
(paren
id|rh-&gt;quiesced_regions.next
comma
r_struct
id|region
comma
id|list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|reg-&gt;list
)paren
suffix:semicolon
multiline_comment|/* remove from the quiesced list */
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
multiline_comment|/* FIXME: success ignored for now */
DECL|function|rh_recovery_end
r_static
r_void
id|rh_recovery_end
c_func
(paren
r_struct
id|region
op_star
id|reg
comma
r_int
id|success
)paren
(brace
r_struct
id|region_hash
op_star
id|rh
op_assign
id|reg-&gt;rh
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|reg-&gt;list
comma
op_amp
id|reg-&gt;rh-&gt;recovered_regions
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rh-&gt;region_lock
)paren
suffix:semicolon
id|wake
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|rh_flush
r_static
r_void
id|rh_flush
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
)paren
(brace
id|rh-&gt;log-&gt;type
op_member_access_from_pointer
id|flush
c_func
(paren
id|rh-&gt;log
)paren
suffix:semicolon
)brace
DECL|function|rh_delay
r_static
r_void
id|rh_delay
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|region
op_star
id|reg
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
id|reg
op_assign
id|__rh_find
c_func
(paren
id|rh
comma
id|bio_to_region
c_func
(paren
id|rh
comma
id|bio
)paren
)paren
suffix:semicolon
id|bio_list_add
c_func
(paren
op_amp
id|reg-&gt;delayed_bios
comma
id|bio
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|rh-&gt;hash_lock
)paren
suffix:semicolon
)brace
DECL|function|rh_stop_recovery
r_static
r_void
id|rh_stop_recovery
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* wait for any recovering regions */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_RECOVERY
suffix:semicolon
id|i
op_increment
)paren
id|down
c_func
(paren
op_amp
id|rh-&gt;recovery_count
)paren
suffix:semicolon
)brace
DECL|function|rh_start_recovery
r_static
r_void
id|rh_start_recovery
c_func
(paren
r_struct
id|region_hash
op_star
id|rh
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_RECOVERY
suffix:semicolon
id|i
op_increment
)paren
id|up
c_func
(paren
op_amp
id|rh-&gt;recovery_count
)paren
suffix:semicolon
id|wake
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * Mirror set structures.&n; *---------------------------------------------------------------*/
DECL|struct|mirror
r_struct
id|mirror
(brace
DECL|member|error_count
id|atomic_t
id|error_count
suffix:semicolon
DECL|member|dev
r_struct
id|dm_dev
op_star
id|dev
suffix:semicolon
DECL|member|offset
id|sector_t
id|offset
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|mirror_set
r_struct
id|mirror_set
(brace
DECL|member|ti
r_struct
id|dm_target
op_star
id|ti
suffix:semicolon
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|rh
r_struct
id|region_hash
id|rh
suffix:semicolon
DECL|member|kcopyd_client
r_struct
id|kcopyd_client
op_star
id|kcopyd_client
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* protects the next two lists */
DECL|member|reads
r_struct
id|bio_list
id|reads
suffix:semicolon
DECL|member|writes
r_struct
id|bio_list
id|writes
suffix:semicolon
multiline_comment|/* recovery */
DECL|member|nr_regions
id|region_t
id|nr_regions
suffix:semicolon
DECL|member|in_sync
r_int
id|in_sync
suffix:semicolon
DECL|member|nr_mirrors
r_int
r_int
id|nr_mirrors
suffix:semicolon
DECL|member|mirror
r_struct
id|mirror
id|mirror
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Every mirror should look like this one.&n; */
DECL|macro|DEFAULT_MIRROR
mdefine_line|#define DEFAULT_MIRROR 0
multiline_comment|/*&n; * This is yucky.  We squirrel the mirror_set struct away inside&n; * bi_next for write buffers.  This is safe since the bh&n; * doesn&squot;t get submitted to the lower levels of block layer.&n; */
DECL|function|bio_get_ms
r_static
r_struct
id|mirror_set
op_star
id|bio_get_ms
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_return
(paren
r_struct
id|mirror_set
op_star
)paren
id|bio-&gt;bi_next
suffix:semicolon
)brace
DECL|function|bio_set_ms
r_static
r_void
id|bio_set_ms
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_struct
id|mirror_set
op_star
id|ms
)paren
(brace
id|bio-&gt;bi_next
op_assign
(paren
r_struct
id|bio
op_star
)paren
id|ms
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * Recovery.&n; *&n; * When a mirror is first activated we may find that some regions&n; * are in the no-sync state.  We have to recover these by&n; * recopying from the default mirror to all the others.&n; *---------------------------------------------------------------*/
DECL|function|recovery_complete
r_static
r_void
id|recovery_complete
c_func
(paren
r_int
id|read_err
comma
r_int
r_int
id|write_err
comma
r_void
op_star
id|context
)paren
(brace
r_struct
id|region
op_star
id|reg
op_assign
(paren
r_struct
id|region
op_star
)paren
id|context
suffix:semicolon
multiline_comment|/* FIXME: better error handling */
id|rh_recovery_end
c_func
(paren
id|reg
comma
id|read_err
op_logical_or
id|write_err
)paren
suffix:semicolon
)brace
DECL|function|recover
r_static
r_int
id|recover
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
comma
r_struct
id|region
op_star
id|reg
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_struct
id|io_region
id|from
comma
id|to
(braket
id|KCOPYD_MAX_REGIONS
)braket
comma
op_star
id|dest
suffix:semicolon
r_struct
id|mirror
op_star
id|m
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fill in the source */
id|m
op_assign
id|ms-&gt;mirror
op_plus
id|DEFAULT_MIRROR
suffix:semicolon
id|from.bdev
op_assign
id|m-&gt;dev-&gt;bdev
suffix:semicolon
id|from.sector
op_assign
id|m-&gt;offset
op_plus
id|region_to_sector
c_func
(paren
id|reg-&gt;rh
comma
id|reg-&gt;key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;key
op_eq
(paren
id|ms-&gt;nr_regions
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The final region may be smaller than&n;&t;&t; * region_size.&n;&t;&t; */
id|from.count
op_assign
id|ms-&gt;ti-&gt;len
op_amp
(paren
id|reg-&gt;rh-&gt;region_size
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|from.count
)paren
id|from.count
op_assign
id|reg-&gt;rh-&gt;region_size
suffix:semicolon
)brace
r_else
id|from.count
op_assign
id|reg-&gt;rh-&gt;region_size
suffix:semicolon
multiline_comment|/* fill in the destinations */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|dest
op_assign
id|to
suffix:semicolon
id|i
OL
id|ms-&gt;nr_mirrors
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|DEFAULT_MIRROR
)paren
r_continue
suffix:semicolon
id|m
op_assign
id|ms-&gt;mirror
op_plus
id|i
suffix:semicolon
id|dest-&gt;bdev
op_assign
id|m-&gt;dev-&gt;bdev
suffix:semicolon
id|dest-&gt;sector
op_assign
id|m-&gt;offset
op_plus
id|region_to_sector
c_func
(paren
id|reg-&gt;rh
comma
id|reg-&gt;key
)paren
suffix:semicolon
id|dest-&gt;count
op_assign
id|from.count
suffix:semicolon
id|dest
op_increment
suffix:semicolon
)brace
multiline_comment|/* hand to kcopyd */
id|set_bit
c_func
(paren
id|KCOPYD_IGNORE_ERROR
comma
op_amp
id|flags
)paren
suffix:semicolon
id|r
op_assign
id|kcopyd_copy
c_func
(paren
id|ms-&gt;kcopyd_client
comma
op_amp
id|from
comma
id|ms-&gt;nr_mirrors
op_minus
l_int|1
comma
id|to
comma
id|flags
comma
id|recovery_complete
comma
id|reg
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|do_recovery
r_static
r_void
id|do_recovery
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
)paren
(brace
r_int
id|r
suffix:semicolon
r_struct
id|region
op_star
id|reg
suffix:semicolon
r_struct
id|dirty_log
op_star
id|log
op_assign
id|ms-&gt;rh.log
suffix:semicolon
multiline_comment|/*&n;&t; * Start quiescing some regions.&n;&t; */
id|rh_recovery_prepare
c_func
(paren
op_amp
id|ms-&gt;rh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy any already quiesced regions.&n;&t; */
r_while
c_loop
(paren
(paren
id|reg
op_assign
id|rh_recovery_start
c_func
(paren
op_amp
id|ms-&gt;rh
)paren
)paren
)paren
(brace
id|r
op_assign
id|recover
c_func
(paren
id|ms
comma
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|rh_recovery_end
c_func
(paren
id|reg
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update the in sync flag.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ms-&gt;in_sync
op_logical_and
(paren
id|log-&gt;type
op_member_access_from_pointer
id|get_sync_count
c_func
(paren
id|log
)paren
op_eq
id|ms-&gt;nr_regions
)paren
)paren
(brace
multiline_comment|/* the sync is complete */
id|dm_table_event
c_func
(paren
id|ms-&gt;ti-&gt;table
)paren
suffix:semicolon
id|ms-&gt;in_sync
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * Reads&n; *---------------------------------------------------------------*/
DECL|function|choose_mirror
r_static
r_struct
id|mirror
op_star
id|choose_mirror
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
comma
id|sector_t
id|sector
)paren
(brace
multiline_comment|/* FIXME: add read balancing */
r_return
id|ms-&gt;mirror
op_plus
id|DEFAULT_MIRROR
suffix:semicolon
)brace
multiline_comment|/*&n; * remap a buffer to a particular mirror.&n; */
DECL|function|map_bio
r_static
r_void
id|map_bio
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
comma
r_struct
id|mirror
op_star
id|m
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|bio-&gt;bi_bdev
op_assign
id|m-&gt;dev-&gt;bdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|m-&gt;offset
op_plus
(paren
id|bio-&gt;bi_sector
op_minus
id|ms-&gt;ti-&gt;begin
)paren
suffix:semicolon
)brace
DECL|function|do_reads
r_static
r_void
id|do_reads
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
comma
r_struct
id|bio_list
op_star
id|reads
)paren
(brace
id|region_t
id|region
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_struct
id|mirror
op_star
id|m
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bio
op_assign
id|bio_list_pop
c_func
(paren
id|reads
)paren
)paren
)paren
(brace
id|region
op_assign
id|bio_to_region
c_func
(paren
op_amp
id|ms-&gt;rh
comma
id|bio
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We can only read balance if the region is in sync.&n;&t;&t; */
r_if
c_cond
(paren
id|rh_in_sync
c_func
(paren
op_amp
id|ms-&gt;rh
comma
id|region
comma
l_int|0
)paren
)paren
id|m
op_assign
id|choose_mirror
c_func
(paren
id|ms
comma
id|bio-&gt;bi_sector
)paren
suffix:semicolon
r_else
id|m
op_assign
id|ms-&gt;mirror
op_plus
id|DEFAULT_MIRROR
suffix:semicolon
id|map_bio
c_func
(paren
id|ms
comma
id|m
comma
id|bio
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * Writes.&n; *&n; * We do different things with the write io depending on the&n; * state of the region that it&squot;s in:&n; *&n; * SYNC: &t;increment pending, use kcopyd to write to *all* mirrors&n; * RECOVERING:&t;delay the io until recovery completes&n; * NOSYNC:&t;increment pending, just write to the default mirror&n; *---------------------------------------------------------------*/
DECL|function|write_callback
r_static
r_void
id|write_callback
c_func
(paren
r_int
r_int
id|error
comma
r_void
op_star
id|context
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
id|uptodate
op_assign
l_int|1
suffix:semicolon
r_struct
id|bio
op_star
id|bio
op_assign
(paren
r_struct
id|bio
op_star
)paren
id|context
suffix:semicolon
r_struct
id|mirror_set
op_star
id|ms
suffix:semicolon
id|ms
op_assign
id|bio_get_ms
c_func
(paren
id|bio
)paren
suffix:semicolon
id|bio_set_ms
c_func
(paren
id|bio
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE: We don&squot;t decrement the pending count here,&n;&t; * instead it is done by the targets endio function.&n;&t; * This way we handle both writes to SYNC and NOSYNC&n;&t; * regions with the same code.&n;&t; */
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; * only error the io if all mirrors failed.&n;&t;&t; * FIXME: bogus&n;&t;&t; */
id|uptodate
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ms-&gt;nr_mirrors
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|i
comma
op_amp
id|error
)paren
)paren
(brace
id|uptodate
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|bio_endio
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|do_write
r_static
r_void
id|do_write
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_struct
id|io_region
id|io
(braket
id|KCOPYD_MAX_REGIONS
op_plus
l_int|1
)braket
suffix:semicolon
r_struct
id|mirror
op_star
id|m
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ms-&gt;nr_mirrors
suffix:semicolon
id|i
op_increment
)paren
(brace
id|m
op_assign
id|ms-&gt;mirror
op_plus
id|i
suffix:semicolon
id|io
(braket
id|i
)braket
dot
id|bdev
op_assign
id|m-&gt;dev-&gt;bdev
suffix:semicolon
id|io
(braket
id|i
)braket
dot
id|sector
op_assign
id|m-&gt;offset
op_plus
(paren
id|bio-&gt;bi_sector
op_minus
id|ms-&gt;ti-&gt;begin
)paren
suffix:semicolon
id|io
(braket
id|i
)braket
dot
id|count
op_assign
id|bio-&gt;bi_size
op_rshift
l_int|9
suffix:semicolon
)brace
id|bio_set_ms
c_func
(paren
id|bio
comma
id|ms
)paren
suffix:semicolon
id|dm_io_async_bvec
c_func
(paren
id|ms-&gt;nr_mirrors
comma
id|io
comma
id|WRITE
comma
id|bio-&gt;bi_io_vec
op_plus
id|bio-&gt;bi_idx
comma
id|write_callback
comma
id|bio
)paren
suffix:semicolon
)brace
DECL|function|do_writes
r_static
r_void
id|do_writes
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
comma
r_struct
id|bio_list
op_star
id|writes
)paren
(brace
r_int
id|state
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_struct
id|bio_list
id|sync
comma
id|nosync
comma
id|recover
comma
op_star
id|this_list
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|writes-&gt;head
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Classify each write.&n;&t; */
id|bio_list_init
c_func
(paren
op_amp
id|sync
)paren
suffix:semicolon
id|bio_list_init
c_func
(paren
op_amp
id|nosync
)paren
suffix:semicolon
id|bio_list_init
c_func
(paren
op_amp
id|recover
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bio
op_assign
id|bio_list_pop
c_func
(paren
id|writes
)paren
)paren
)paren
(brace
id|state
op_assign
id|rh_state
c_func
(paren
op_amp
id|ms-&gt;rh
comma
id|bio_to_region
c_func
(paren
op_amp
id|ms-&gt;rh
comma
id|bio
)paren
comma
l_int|1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|RH_CLEAN
suffix:colon
r_case
id|RH_DIRTY
suffix:colon
id|this_list
op_assign
op_amp
id|sync
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RH_NOSYNC
suffix:colon
id|this_list
op_assign
op_amp
id|nosync
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RH_RECOVERING
suffix:colon
id|this_list
op_assign
op_amp
id|recover
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bio_list_add
c_func
(paren
id|this_list
comma
id|bio
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Increment the pending counts for any regions that will&n;&t; * be written to (writes to recover regions are going to&n;&t; * be delayed).&n;&t; */
id|rh_inc_pending
c_func
(paren
op_amp
id|ms-&gt;rh
comma
op_amp
id|sync
)paren
suffix:semicolon
id|rh_inc_pending
c_func
(paren
op_amp
id|ms-&gt;rh
comma
op_amp
id|nosync
)paren
suffix:semicolon
id|rh_flush
c_func
(paren
op_amp
id|ms-&gt;rh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Dispatch io.&n;&t; */
r_while
c_loop
(paren
(paren
id|bio
op_assign
id|bio_list_pop
c_func
(paren
op_amp
id|sync
)paren
)paren
)paren
id|do_write
c_func
(paren
id|ms
comma
id|bio
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bio
op_assign
id|bio_list_pop
c_func
(paren
op_amp
id|recover
)paren
)paren
)paren
id|rh_delay
c_func
(paren
op_amp
id|ms-&gt;rh
comma
id|bio
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bio
op_assign
id|bio_list_pop
c_func
(paren
op_amp
id|nosync
)paren
)paren
)paren
(brace
id|map_bio
c_func
(paren
id|ms
comma
id|ms-&gt;mirror
op_plus
id|DEFAULT_MIRROR
comma
id|bio
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * kmirrord&n; *---------------------------------------------------------------*/
r_static
id|LIST_HEAD
c_func
(paren
id|_mirror_sets
)paren
suffix:semicolon
r_static
id|DECLARE_RWSEM
c_func
(paren
id|_mirror_sets_lock
)paren
suffix:semicolon
DECL|function|do_mirror
r_static
r_void
id|do_mirror
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
)paren
(brace
r_struct
id|bio_list
id|reads
comma
id|writes
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ms-&gt;lock
)paren
suffix:semicolon
id|reads
op_assign
id|ms-&gt;reads
suffix:semicolon
id|writes
op_assign
id|ms-&gt;writes
suffix:semicolon
id|bio_list_init
c_func
(paren
op_amp
id|ms-&gt;reads
)paren
suffix:semicolon
id|bio_list_init
c_func
(paren
op_amp
id|ms-&gt;writes
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ms-&gt;lock
)paren
suffix:semicolon
id|rh_update_states
c_func
(paren
op_amp
id|ms-&gt;rh
)paren
suffix:semicolon
id|do_recovery
c_func
(paren
id|ms
)paren
suffix:semicolon
id|do_reads
c_func
(paren
id|ms
comma
op_amp
id|reads
)paren
suffix:semicolon
id|do_writes
c_func
(paren
id|ms
comma
op_amp
id|writes
)paren
suffix:semicolon
)brace
DECL|function|do_work
r_static
r_void
id|do_work
c_func
(paren
r_void
op_star
id|ignored
)paren
(brace
r_struct
id|mirror_set
op_star
id|ms
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|_mirror_sets_lock
)paren
suffix:semicolon
id|list_for_each_entry
(paren
id|ms
comma
op_amp
id|_mirror_sets
comma
id|list
)paren
id|do_mirror
c_func
(paren
id|ms
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|_mirror_sets_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*-----------------------------------------------------------------&n; * Target functions&n; *---------------------------------------------------------------*/
DECL|function|alloc_context
r_static
r_struct
id|mirror_set
op_star
id|alloc_context
c_func
(paren
r_int
r_int
id|nr_mirrors
comma
id|sector_t
id|region_size
comma
r_struct
id|dm_target
op_star
id|ti
comma
r_struct
id|dirty_log
op_star
id|dl
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|mirror_set
op_star
id|ms
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|array_too_big
c_func
(paren
r_sizeof
(paren
op_star
id|ms
)paren
comma
r_sizeof
(paren
id|ms-&gt;mirror
(braket
l_int|0
)braket
)paren
comma
id|nr_mirrors
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
op_star
id|ms
)paren
op_plus
(paren
r_sizeof
(paren
id|ms-&gt;mirror
(braket
l_int|0
)braket
)paren
op_star
id|nr_mirrors
)paren
suffix:semicolon
id|ms
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ms
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-mirror: Cannot allocate mirror context&quot;
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ms
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ms-&gt;lock
)paren
suffix:semicolon
id|ms-&gt;ti
op_assign
id|ti
suffix:semicolon
id|ms-&gt;nr_mirrors
op_assign
id|nr_mirrors
suffix:semicolon
id|ms-&gt;nr_regions
op_assign
id|dm_div_up
c_func
(paren
id|ti-&gt;len
comma
id|region_size
)paren
suffix:semicolon
id|ms-&gt;in_sync
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rh_init
c_func
(paren
op_amp
id|ms-&gt;rh
comma
id|ms
comma
id|dl
comma
id|region_size
comma
id|ms-&gt;nr_regions
)paren
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-mirror: Error creating dirty region hash&quot;
suffix:semicolon
id|kfree
c_func
(paren
id|ms
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|ms
suffix:semicolon
)brace
DECL|function|free_context
r_static
r_void
id|free_context
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
comma
r_struct
id|dm_target
op_star
id|ti
comma
r_int
r_int
id|m
)paren
(brace
r_while
c_loop
(paren
id|m
op_decrement
)paren
id|dm_put_device
c_func
(paren
id|ti
comma
id|ms-&gt;mirror
(braket
id|m
)braket
dot
id|dev
)paren
suffix:semicolon
id|rh_exit
c_func
(paren
op_amp
id|ms-&gt;rh
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ms
)paren
suffix:semicolon
)brace
DECL|function|_check_region_size
r_static
r_inline
r_int
id|_check_region_size
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
id|sector_t
id|size
)paren
(brace
r_return
op_logical_neg
(paren
id|size
op_mod
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
op_logical_or
(paren
id|size
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
op_logical_or
id|size
OG
id|ti-&gt;len
)paren
suffix:semicolon
)brace
DECL|function|get_mirror
r_static
r_int
id|get_mirror
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
comma
r_struct
id|dm_target
op_star
id|ti
comma
r_int
r_int
id|mirror
comma
r_char
op_star
op_star
id|argv
)paren
(brace
id|sector_t
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|sscanf
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
id|SECTOR_FORMAT
comma
op_amp
id|offset
)paren
op_ne
l_int|1
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-mirror: Invalid offset&quot;
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dm_get_device
c_func
(paren
id|ti
comma
id|argv
(braket
l_int|0
)braket
comma
id|offset
comma
id|ti-&gt;len
comma
id|dm_table_get_mode
c_func
(paren
id|ti-&gt;table
)paren
comma
op_amp
id|ms-&gt;mirror
(braket
id|mirror
)braket
dot
id|dev
)paren
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-mirror: Device lookup failure&quot;
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|ms-&gt;mirror
(braket
id|mirror
)braket
dot
id|offset
op_assign
id|offset
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_mirror_set
r_static
r_int
id|add_mirror_set
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|_mirror_sets_lock
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|ms-&gt;list
comma
op_amp
id|_mirror_sets
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|_mirror_sets_lock
)paren
suffix:semicolon
id|wake
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|del_mirror_set
r_static
r_void
id|del_mirror_set
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|_mirror_sets_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|ms-&gt;list
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|_mirror_sets_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create dirty log: log_type #log_params &lt;log_params&gt;&n; */
DECL|function|create_dirty_log
r_static
r_struct
id|dirty_log
op_star
id|create_dirty_log
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_int
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
comma
r_int
r_int
op_star
id|args_used
)paren
(brace
r_int
r_int
id|param_count
suffix:semicolon
r_struct
id|dirty_log
op_star
id|dl
suffix:semicolon
r_if
c_cond
(paren
id|argc
OL
l_int|2
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-mirror: Insufficient mirror log arguments&quot;
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sscanf
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;%u&quot;
comma
op_amp
id|param_count
)paren
op_ne
l_int|1
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-mirror: Invalid mirror log argument count&quot;
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_star
id|args_used
op_assign
l_int|2
op_plus
id|param_count
suffix:semicolon
r_if
c_cond
(paren
id|argc
OL
op_star
id|args_used
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-mirror: Insufficient mirror log arguments&quot;
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|dl
op_assign
id|dm_create_dirty_log
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
id|ti
comma
id|param_count
comma
id|argv
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dl
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-mirror: Error creating mirror dirty log&quot;
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|_check_region_size
c_func
(paren
id|ti
comma
id|dl-&gt;type
op_member_access_from_pointer
id|get_region_size
c_func
(paren
id|dl
)paren
)paren
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-mirror: Invalid region size&quot;
suffix:semicolon
id|dm_destroy_dirty_log
c_func
(paren
id|dl
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|dl
suffix:semicolon
)brace
multiline_comment|/*&n; * Construct a mirror mapping:&n; *&n; * log_type #log_params &lt;log_params&gt;&n; * #mirrors [mirror_path offset]{2,}&n; *&n; * log_type is &quot;core&quot; or &quot;disk&quot;&n; * #log_params is between 1 and 3&n; */
DECL|macro|DM_IO_PAGES
mdefine_line|#define DM_IO_PAGES 64
DECL|function|mirror_ctr
r_static
r_int
id|mirror_ctr
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_int
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
r_int
id|nr_mirrors
comma
id|m
comma
id|args_used
suffix:semicolon
r_struct
id|mirror_set
op_star
id|ms
suffix:semicolon
r_struct
id|dirty_log
op_star
id|dl
suffix:semicolon
id|dl
op_assign
id|create_dirty_log
c_func
(paren
id|ti
comma
id|argc
comma
id|argv
comma
op_amp
id|args_used
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dl
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|argv
op_add_assign
id|args_used
suffix:semicolon
id|argc
op_sub_assign
id|args_used
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|argc
op_logical_or
id|sscanf
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
l_string|&quot;%u&quot;
comma
op_amp
id|nr_mirrors
)paren
op_ne
l_int|1
op_logical_or
id|nr_mirrors
template_param
id|KCOPYD_MAX_REGIONS
op_plus
l_int|1
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-mirror: Invalid number of mirrors&quot;
suffix:semicolon
id|dm_destroy_dirty_log
c_func
(paren
id|dl
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|argv
op_increment
comma
id|argc
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_ne
id|nr_mirrors
op_star
l_int|2
)paren
(brace
id|ti-&gt;error
op_assign
l_string|&quot;dm-mirror: Wrong number of mirror arguments&quot;
suffix:semicolon
id|dm_destroy_dirty_log
c_func
(paren
id|dl
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ms
op_assign
id|alloc_context
c_func
(paren
id|nr_mirrors
comma
id|dl-&gt;type
op_member_access_from_pointer
id|get_region_size
c_func
(paren
id|dl
)paren
comma
id|ti
comma
id|dl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ms
)paren
(brace
id|dm_destroy_dirty_log
c_func
(paren
id|dl
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Get the mirror parameter sets */
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|nr_mirrors
suffix:semicolon
id|m
op_increment
)paren
(brace
id|r
op_assign
id|get_mirror
c_func
(paren
id|ms
comma
id|ti
comma
id|m
comma
id|argv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|free_context
c_func
(paren
id|ms
comma
id|ti
comma
id|m
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
id|argv
op_add_assign
l_int|2
suffix:semicolon
id|argc
op_sub_assign
l_int|2
suffix:semicolon
)brace
id|ti
op_member_access_from_pointer
r_private
op_assign
id|ms
suffix:semicolon
id|r
op_assign
id|kcopyd_client_create
c_func
(paren
id|DM_IO_PAGES
comma
op_amp
id|ms-&gt;kcopyd_client
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|free_context
c_func
(paren
id|ms
comma
id|ti
comma
id|ms-&gt;nr_mirrors
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
id|add_mirror_set
c_func
(paren
id|ms
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mirror_dtr
r_static
r_void
id|mirror_dtr
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|mirror_set
op_star
id|ms
op_assign
(paren
r_struct
id|mirror_set
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
id|del_mirror_set
c_func
(paren
id|ms
)paren
suffix:semicolon
id|kcopyd_client_destroy
c_func
(paren
id|ms-&gt;kcopyd_client
)paren
suffix:semicolon
id|free_context
c_func
(paren
id|ms
comma
id|ti
comma
id|ms-&gt;nr_mirrors
)paren
suffix:semicolon
)brace
DECL|function|queue_bio
r_static
r_void
id|queue_bio
c_func
(paren
r_struct
id|mirror_set
op_star
id|ms
comma
r_struct
id|bio
op_star
id|bio
comma
r_int
id|rw
)paren
(brace
r_int
id|should_wake
op_assign
l_int|0
suffix:semicolon
r_struct
id|bio_list
op_star
id|bl
suffix:semicolon
id|bl
op_assign
(paren
id|rw
op_eq
id|WRITE
)paren
ques
c_cond
op_amp
id|ms-&gt;writes
suffix:colon
op_amp
id|ms-&gt;reads
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ms-&gt;lock
)paren
suffix:semicolon
id|should_wake
op_assign
op_logical_neg
(paren
id|bl-&gt;head
)paren
suffix:semicolon
id|bio_list_add
c_func
(paren
id|bl
comma
id|bio
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ms-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|should_wake
)paren
id|wake
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Mirror mapping function&n; */
DECL|function|mirror_map
r_static
r_int
id|mirror_map
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_struct
id|bio
op_star
id|bio
comma
r_union
id|map_info
op_star
id|map_context
)paren
(brace
r_int
id|r
comma
id|rw
op_assign
id|bio_rw
c_func
(paren
id|bio
)paren
suffix:semicolon
r_struct
id|mirror
op_star
id|m
suffix:semicolon
r_struct
id|mirror_set
op_star
id|ms
op_assign
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
id|map_context-&gt;ll
op_assign
id|bio-&gt;bi_sector
op_rshift
id|ms-&gt;rh.region_shift
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
)paren
(brace
id|queue_bio
c_func
(paren
id|ms
comma
id|bio
comma
id|rw
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|r
op_assign
id|ms-&gt;rh.log-&gt;type
op_member_access_from_pointer
id|in_sync
c_func
(paren
id|ms-&gt;rh.log
comma
id|bio_to_region
c_func
(paren
op_amp
id|ms-&gt;rh
comma
id|bio
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
op_logical_and
id|r
op_ne
op_minus
id|EWOULDBLOCK
)paren
r_return
id|r
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
op_minus
id|EWOULDBLOCK
)paren
multiline_comment|/* FIXME: ugly */
id|r
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t want to fast track a recovery just for a read&n;&t; * ahead.  So we just let it silently fail.&n;&t; * FIXME: get rid of this.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|r
op_logical_and
id|rw
op_eq
id|READA
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
(brace
multiline_comment|/* Pass this io over to the daemon */
id|queue_bio
c_func
(paren
id|ms
comma
id|bio
comma
id|rw
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|m
op_assign
id|choose_mirror
c_func
(paren
id|ms
comma
id|bio-&gt;bi_sector
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|map_bio
c_func
(paren
id|ms
comma
id|m
comma
id|bio
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|mirror_end_io
r_static
r_int
id|mirror_end_io
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
r_struct
id|bio
op_star
id|bio
comma
r_int
id|error
comma
r_union
id|map_info
op_star
id|map_context
)paren
(brace
r_int
id|rw
op_assign
id|bio_rw
c_func
(paren
id|bio
)paren
suffix:semicolon
r_struct
id|mirror_set
op_star
id|ms
op_assign
(paren
r_struct
id|mirror_set
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
id|region_t
id|region
op_assign
id|map_context-&gt;ll
suffix:semicolon
multiline_comment|/*&n;&t; * We need to dec pending if this was a write.&n;&t; */
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
)paren
id|rh_dec
c_func
(paren
op_amp
id|ms-&gt;rh
comma
id|region
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mirror_postsuspend
r_static
r_void
id|mirror_postsuspend
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|mirror_set
op_star
id|ms
op_assign
(paren
r_struct
id|mirror_set
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|dirty_log
op_star
id|log
op_assign
id|ms-&gt;rh.log
suffix:semicolon
id|rh_stop_recovery
c_func
(paren
op_amp
id|ms-&gt;rh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;type-&gt;suspend
op_logical_and
id|log-&gt;type
op_member_access_from_pointer
id|suspend
c_func
(paren
id|log
)paren
)paren
multiline_comment|/* FIXME: need better error handling */
id|DMWARN
c_func
(paren
l_string|&quot;log suspend failed&quot;
)paren
suffix:semicolon
)brace
DECL|function|mirror_resume
r_static
r_void
id|mirror_resume
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
)paren
(brace
r_struct
id|mirror_set
op_star
id|ms
op_assign
(paren
r_struct
id|mirror_set
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|dirty_log
op_star
id|log
op_assign
id|ms-&gt;rh.log
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;type-&gt;resume
op_logical_and
id|log-&gt;type
op_member_access_from_pointer
id|resume
c_func
(paren
id|log
)paren
)paren
multiline_comment|/* FIXME: need better error handling */
id|DMWARN
c_func
(paren
l_string|&quot;log resume failed&quot;
)paren
suffix:semicolon
id|rh_start_recovery
c_func
(paren
op_amp
id|ms-&gt;rh
)paren
suffix:semicolon
)brace
DECL|function|mirror_status
r_static
r_int
id|mirror_status
c_func
(paren
r_struct
id|dm_target
op_star
id|ti
comma
id|status_type_t
id|type
comma
r_char
op_star
id|result
comma
r_int
r_int
id|maxlen
)paren
(brace
r_char
id|buffer
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_int
id|m
comma
id|sz
suffix:semicolon
r_struct
id|mirror_set
op_star
id|ms
op_assign
(paren
r_struct
id|mirror_set
op_star
)paren
id|ti
op_member_access_from_pointer
r_private
suffix:semicolon
id|sz
op_assign
id|ms-&gt;rh.log-&gt;type
op_member_access_from_pointer
id|status
c_func
(paren
id|ms-&gt;rh.log
comma
id|type
comma
id|result
comma
id|maxlen
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|STATUSTYPE_INFO
suffix:colon
id|DMEMIT
c_func
(paren
l_string|&quot;%d &quot;
comma
id|ms-&gt;nr_mirrors
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|ms-&gt;nr_mirrors
suffix:semicolon
id|m
op_increment
)paren
(brace
id|format_dev_t
c_func
(paren
id|buffer
comma
id|ms-&gt;mirror
(braket
id|m
)braket
dot
id|dev-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
id|DMEMIT
c_func
(paren
l_string|&quot;%s &quot;
comma
id|buffer
)paren
suffix:semicolon
)brace
id|DMEMIT
c_func
(paren
id|SECTOR_FORMAT
l_string|&quot;/&quot;
id|SECTOR_FORMAT
comma
id|ms-&gt;rh.log-&gt;type
op_member_access_from_pointer
id|get_sync_count
c_func
(paren
id|ms-&gt;rh.log
)paren
comma
id|ms-&gt;nr_regions
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATUSTYPE_TABLE
suffix:colon
id|DMEMIT
c_func
(paren
l_string|&quot;%d &quot;
comma
id|ms-&gt;nr_mirrors
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|ms-&gt;nr_mirrors
suffix:semicolon
id|m
op_increment
)paren
(brace
id|format_dev_t
c_func
(paren
id|buffer
comma
id|ms-&gt;mirror
(braket
id|m
)braket
dot
id|dev-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
id|DMEMIT
c_func
(paren
l_string|&quot;%s &quot;
id|SECTOR_FORMAT
l_string|&quot; &quot;
comma
id|buffer
comma
id|ms-&gt;mirror
(braket
id|m
)braket
dot
id|offset
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|mirror_target
r_static
r_struct
id|target_type
id|mirror_target
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;mirror&quot;
comma
dot
id|version
op_assign
(brace
l_int|1
comma
l_int|0
comma
l_int|1
)brace
comma
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|ctr
op_assign
id|mirror_ctr
comma
dot
id|dtr
op_assign
id|mirror_dtr
comma
dot
id|map
op_assign
id|mirror_map
comma
dot
id|end_io
op_assign
id|mirror_end_io
comma
dot
id|postsuspend
op_assign
id|mirror_postsuspend
comma
dot
id|resume
op_assign
id|mirror_resume
comma
dot
id|status
op_assign
id|mirror_status
comma
)brace
suffix:semicolon
DECL|function|dm_mirror_init
r_static
r_int
id|__init
id|dm_mirror_init
c_func
(paren
r_void
)paren
(brace
r_int
id|r
suffix:semicolon
id|r
op_assign
id|dm_dirty_log_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
id|r
suffix:semicolon
id|_kmirrord_wq
op_assign
id|create_workqueue
c_func
(paren
l_string|&quot;kmirrord&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_kmirrord_wq
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;couldn&squot;t start kmirrord&quot;
)paren
suffix:semicolon
id|dm_dirty_log_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
id|INIT_WORK
c_func
(paren
op_amp
id|_kmirrord_work
comma
id|do_work
comma
l_int|NULL
)paren
suffix:semicolon
id|r
op_assign
id|dm_register_target
c_func
(paren
op_amp
id|mirror_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
(brace
id|DMERR
c_func
(paren
l_string|&quot;%s: Failed to register mirror target&quot;
comma
id|mirror_target.name
)paren
suffix:semicolon
id|dm_dirty_log_exit
c_func
(paren
)paren
suffix:semicolon
id|destroy_workqueue
c_func
(paren
id|_kmirrord_wq
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
DECL|function|dm_mirror_exit
r_static
r_void
id|__exit
id|dm_mirror_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|r
suffix:semicolon
id|r
op_assign
id|dm_unregister_target
c_func
(paren
op_amp
id|mirror_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
id|DMERR
c_func
(paren
l_string|&quot;%s: unregister failed %d&quot;
comma
id|mirror_target.name
comma
id|r
)paren
suffix:semicolon
id|destroy_workqueue
c_func
(paren
id|_kmirrord_wq
)paren
suffix:semicolon
id|dm_dirty_log_exit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Module hooks */
DECL|variable|dm_mirror_init
id|module_init
c_func
(paren
id|dm_mirror_init
)paren
suffix:semicolon
DECL|variable|dm_mirror_exit
id|module_exit
c_func
(paren
id|dm_mirror_exit
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
id|DM_NAME
l_string|&quot; mirror target&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Joe Thornber&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
