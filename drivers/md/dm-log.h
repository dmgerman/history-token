multiline_comment|/*&n; * Copyright (C) 2003 Sistina Software&n; *&n; * This file is released under the LGPL.&n; */
macro_line|#ifndef DM_DIRTY_LOG
DECL|macro|DM_DIRTY_LOG
mdefine_line|#define DM_DIRTY_LOG
macro_line|#include &quot;dm.h&quot;
DECL|typedef|region_t
r_typedef
id|sector_t
id|region_t
suffix:semicolon
r_struct
id|dirty_log_type
suffix:semicolon
DECL|struct|dirty_log
r_struct
id|dirty_log
(brace
DECL|member|type
r_struct
id|dirty_log_type
op_star
id|type
suffix:semicolon
DECL|member|context
r_void
op_star
id|context
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|dirty_log_type
r_struct
id|dirty_log_type
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|module
r_struct
id|module
op_star
id|module
suffix:semicolon
DECL|member|use_count
r_int
r_int
id|use_count
suffix:semicolon
DECL|member|ctr
r_int
(paren
op_star
id|ctr
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
comma
r_struct
id|dm_target
op_star
id|ti
comma
r_int
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
suffix:semicolon
DECL|member|dtr
r_void
(paren
op_star
id|dtr
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There are times when we don&squot;t want the log to touch&n;&t; * the disk.&n;&t; */
DECL|member|suspend
r_int
(paren
op_star
id|suspend
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
)paren
suffix:semicolon
DECL|member|resume
r_int
(paren
op_star
id|resume
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Retrieves the smallest size of region that the log can&n;&t; * deal with.&n;&t; */
DECL|member|get_region_size
r_uint32
(paren
op_star
id|get_region_size
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * A predicate to say whether a region is clean or not.&n;&t; * May block.&n;&t; */
DECL|member|is_clean
r_int
(paren
op_star
id|is_clean
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
comma
id|region_t
id|region
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Returns: 0, 1, -EWOULDBLOCK, &lt; 0&n;&t; *&n;&t; * A predicate function to check the area given by&n;&t; * [sector, sector + len) is in sync.&n;&t; *&n;&t; * If -EWOULDBLOCK is returned the state of the region is&n;&t; * unknown, typically this will result in a read being&n;&t; * passed to a daemon to deal with, since a daemon is&n;&t; * allowed to block.&n;&t; */
DECL|member|in_sync
r_int
(paren
op_star
id|in_sync
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
comma
id|region_t
id|region
comma
r_int
id|can_block
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Flush the current log state (eg, to disk).  This&n;&t; * function may block.&n;&t; */
DECL|member|flush
r_int
(paren
op_star
id|flush
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark an area as clean or dirty.  These functions may&n;&t; * block, though for performance reasons blocking should&n;&t; * be extremely rare (eg, allocating another chunk of&n;&t; * memory for some reason).&n;&t; */
DECL|member|mark_region
r_void
(paren
op_star
id|mark_region
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
comma
id|region_t
id|region
)paren
suffix:semicolon
DECL|member|clear_region
r_void
(paren
op_star
id|clear_region
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
comma
id|region_t
id|region
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Returns: &lt;0 (error), 0 (no region), 1 (region)&n;&t; *&n;&t; * The mirrord will need perform recovery on regions of&n;&t; * the mirror that are in the NOSYNC state.  This&n;&t; * function asks the log to tell the caller about the&n;&t; * next region that this machine should recover.&n;&t; *&n;&t; * Do not confuse this function with &squot;in_sync()&squot;, one&n;&t; * tells you if an area is synchronised, the other&n;&t; * assigns recovery work.&n;&t;*/
DECL|member|get_resync_work
r_int
(paren
op_star
id|get_resync_work
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
comma
id|region_t
op_star
id|region
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This notifies the log that the resync of an area has&n;&t; * been completed.  The log should then mark this region&n;&t; * as CLEAN.&n;&t; */
DECL|member|complete_resync_work
r_void
(paren
op_star
id|complete_resync_work
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
comma
id|region_t
id|region
comma
r_int
id|success
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Returns the number of regions that are in sync.&n;         */
DECL|member|get_sync_count
id|region_t
(paren
op_star
id|get_sync_count
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Support function for mirror status requests.&n;&t; */
DECL|member|status
r_int
(paren
op_star
id|status
)paren
(paren
r_struct
id|dirty_log
op_star
id|log
comma
id|status_type_t
id|status_type
comma
r_char
op_star
id|result
comma
r_int
r_int
id|maxlen
)paren
suffix:semicolon
)brace
suffix:semicolon
r_int
id|dm_register_dirty_log_type
c_func
(paren
r_struct
id|dirty_log_type
op_star
id|type
)paren
suffix:semicolon
r_int
id|dm_unregister_dirty_log_type
c_func
(paren
r_struct
id|dirty_log_type
op_star
id|type
)paren
suffix:semicolon
multiline_comment|/*&n; * Make sure you use these two functions, rather than calling&n; * type-&gt;constructor/destructor() directly.&n; */
r_struct
id|dirty_log
op_star
id|dm_create_dirty_log
c_func
(paren
r_const
r_char
op_star
id|type_name
comma
r_struct
id|dm_target
op_star
id|ti
comma
r_int
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
suffix:semicolon
r_void
id|dm_destroy_dirty_log
c_func
(paren
r_struct
id|dirty_log
op_star
id|log
)paren
suffix:semicolon
multiline_comment|/*&n; * init/exit functions.&n; */
r_int
id|dm_dirty_log_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|dm_dirty_log_exit
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
eof
