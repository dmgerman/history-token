multiline_comment|/*&n; * kernel/lvm.c&n; *&n; * Copyright (C) 1997 - 2000  Heinz Mauelshagen, Sistina Software&n; *&n; * February-November 1997&n; * April-May,July-August,November 1998&n; * January-March,May,July,September,October 1999&n; * January,February,July,September-November 2000&n; * January 2001&n; *&n; *&n; * LVM driver is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * LVM driver is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with GNU CC; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 59 Temple Place - Suite 330,&n; * Boston, MA 02111-1307, USA.&n; *&n; */
multiline_comment|/*&n; * Changelog&n; *&n; *    09/11/1997 - added chr ioctls VG_STATUS_GET_COUNT&n; *                 and VG_STATUS_GET_NAMELIST&n; *    18/01/1998 - change lvm_chr_open/close lock handling&n; *    30/04/1998 - changed LV_STATUS ioctl to LV_STATUS_BYNAME and&n; *               - added   LV_STATUS_BYINDEX ioctl&n; *               - used lvm_status_byname_req_t and&n; *                      lvm_status_byindex_req_t vars&n; *    04/05/1998 - added multiple device support&n; *    08/05/1998 - added support to set/clear extendable flag in volume group&n; *    09/05/1998 - changed output of lvm_proc_get_global_info() because of&n; *                 support for free (eg. longer) logical volume names&n; *    12/05/1998 - added spin_locks (thanks to Pascal van Dam&n; *                 &lt;pascal@ramoth.xs4all.nl&gt;)&n; *    25/05/1998 - fixed handling of locked PEs in lvm_map() and lvm_chr_ioctl()&n; *    26/05/1998 - reactivated verify_area by access_ok&n; *    07/06/1998 - used vmalloc/vfree instead of kmalloc/kfree to go&n; *                 beyond 128/256 KB max allocation limit per call&n; *               - #ifdef blocked spin_lock calls to avoid compile errors&n; *                 with 2.0.x&n; *    11/06/1998 - another enhancement to spinlock code in lvm_chr_open()&n; *                 and use of LVM_VERSION_CODE instead of my own macros&n; *                 (thanks to  Michael Marxmeier &lt;mike@msede.com&gt;)&n; *    07/07/1998 - added statistics in lvm_map()&n; *    08/07/1998 - saved statistics in lvm_do_lv_extend_reduce()&n; *    25/07/1998 - used __initfunc macro&n; *    02/08/1998 - changes for official char/block major numbers&n; *    07/08/1998 - avoided init_module() and cleanup_module() to be static&n; *    30/08/1998 - changed VG lv_open counter from sum of LV lv_open counters&n; *                 to sum of LVs open (no matter how often each is)&n; *    01/09/1998 - fixed lvm_gendisk.part[] index error&n; *    07/09/1998 - added copying of lv_current_pe-array&n; *                 in LV_STATUS_BYINDEX ioctl&n; *    17/11/1998 - added KERN_* levels to printk&n; *    13/01/1999 - fixed LV index bug in lvm_do_lv_create() which hit lvrename&n; *    07/02/1999 - fixed spinlock handling bug in case of LVM_RESET&n; *                 by moving spinlock code from lvm_chr_open()&n; *                 to lvm_chr_ioctl()&n; *               - added LVM_LOCK_LVM ioctl to lvm_chr_ioctl()&n; *               - allowed LVM_RESET and retrieval commands to go ahead;&n; *                 only other update ioctls are blocked now&n; *               - fixed pv-&gt;pe to NULL for pv_status&n; *               - using lv_req structure in lvm_chr_ioctl() now&n; *               - fixed NULL ptr reference bug in lvm_do_lv_extend_reduce()&n; *                 caused by uncontiguous PV array in lvm_chr_ioctl(VG_REDUCE)&n; *    09/02/1999 - changed BLKRASET and BLKRAGET in lvm_chr_ioctl() to&n; *                 handle lgoical volume private read ahead sector&n; *               - implemented LV read_ahead handling with lvm_blk_read()&n; *                 and lvm_blk_write()&n; *    10/02/1999 - implemented 2.[12].* support function lvm_hd_name()&n; *                 to be used in drivers/block/genhd.c by disk_name()&n; *    12/02/1999 - fixed index bug in lvm_blk_ioctl(), HDIO_GETGEO&n; *               - enhanced gendisk insert/remove handling&n; *    16/02/1999 - changed to dynamic block minor number allocation to&n; *                 have as much as 99 volume groups with 256 logical volumes&n; *                 as the grand total; this allows having 1 volume group with&n; *                 up to 256 logical volumes in it&n; *    21/02/1999 - added LV open count information to proc filesystem&n; *               - substituted redundant LVM_RESET code by calls&n; *                 to lvm_do_vg_remove()&n; *    22/02/1999 - used schedule_timeout() to be more responsive&n; *                 in case of lvm_do_vg_remove() with lots of logical volumes&n; *    19/03/1999 - fixed NULL pointer bug in module_init/lvm_init&n; *    17/05/1999 - used DECLARE_WAIT_QUEUE_HEAD macro (&gt;2.3.0)&n; *               - enhanced lvm_hd_name support&n; *    03/07/1999 - avoided use of KERNEL_VERSION macro based ifdefs and&n; *                 memcpy_tofs/memcpy_fromfs macro redefinitions&n; *    06/07/1999 - corrected reads/writes statistic counter copy in case&n; *                 of striped logical volume&n; *    28/07/1999 - implemented snapshot logical volumes&n; *                 - lvm_chr_ioctl&n; *                   - LV_STATUS_BYINDEX&n; *                   - LV_STATUS_BYNAME&n; *                 - lvm_do_lv_create&n; *                 - lvm_do_lv_remove&n; *                 - lvm_map&n; *                 - new lvm_snapshot_remap_block&n; *                 - new lvm_snapshot_remap_new_block&n; *    08/10/1999 - implemented support for multiple snapshots per&n; *                 original logical volume&n; *    12/10/1999 - support for 2.3.19&n; *    11/11/1999 - support for 2.3.28&n; *    21/11/1999 - changed lvm_map() interface to buffer_head based&n; *    19/12/1999 - support for 2.3.33&n; *    01/01/2000 - changed locking concept in lvm_map(),&n; *                 lvm_do_vg_create() and lvm_do_lv_remove()&n; *    15/01/2000 - fixed PV_FLUSH bug in lvm_chr_ioctl()&n; *    24/01/2000 - ported to 2.3.40 including Alan Cox&squot;s pointer changes etc.&n; *    29/01/2000 - used kmalloc/kfree again for all small structures&n; *    20/01/2000 - cleaned up lvm_chr_ioctl by moving code&n; *                 to seperated functions&n; *               - avoided &quot;/dev/&quot; in proc filesystem output&n; *               - avoided inline strings functions lvm_strlen etc.&n; *    14/02/2000 - support for 2.3.43&n; *               - integrated Andrea Arcagneli&squot;s snapshot code&n; *    25/06/2000 - james (chip) , IKKHAYD! roffl&n; *    26/06/2000 - enhanced lv_extend_reduce for snapshot logical volume support&n; *    06/09/2000 - added devfs support&n; *    07/09/2000 - changed IOP version to 9&n; *               - started to add new char ioctl LV_STATUS_BYDEV_T to support&n; *                 getting an lv_t based on the dev_t of the Logical Volume&n; *    14/09/2000 - enhanced lvm_do_lv_create to upcall VFS functions&n; *                 to sync and lock, activate snapshot and unlock the FS&n; *                 (to support journaled filesystems)&n; *    18/09/2000 - hardsector size support&n; *    27/09/2000 - implemented lvm_do_lv_rename() and lvm_do_vg_rename()&n; *    30/10/2000 - added Andi Kleen&squot;s LV_BMAP ioctl to support LILO&n; *    01/11/2000 - added memory information on hash tables to&n; *                 lvm_proc_get_global_info()&n; *    02/11/2000 - implemented /proc/lvm/ hierarchy&n; *    22/11/2000 - changed lvm_do_create_proc_entry_of_pv () to work&n; *                 with devfs&n; *    26/11/2000 - corrected #ifdef locations for PROC_FS&n; *    28/11/2000 - fixed lvm_do_vg_extend() NULL pointer BUG&n; *               - fixed lvm_do_create_proc_entry_of_pv() buffer tampering BUG&n; *    08/01/2001 - Removed conditional compiles related to PROC_FS,&n; *                 procfs is always supported now. (JT)&n; *    12/01/2001 - avoided flushing logical volume in case of shrinking&n; *                 because of unnecessary overhead in case of heavy updates&n; *    25/01/2001 - Allow RO open of an inactive LV so it can be reactivated.&n; *    31/01/2001 - If you try and BMAP a snapshot you now get an -EPERM&n; *    01/02/2001 - factored __remap_snapshot out of lvm_map&n; *    12/02/2001 - move devfs code to create VG before LVs&n; *    14/02/2001 - tidied device defines for blk.h&n; *               - tidied debug statements&n; *               - more lvm_map tidying&n; *    14/02/2001 - bug: vg[] member not set back to NULL if activation fails&n; *    28/02/2001 - introduced the P_DEV macro and changed some internel&n; *                 functions to be static [AD]&n; *    28/02/2001 - factored lvm_get_snapshot_use_rate out of blk_ioctl [AD]&n; *               - fixed user address accessing bug in lvm_do_lv_create()&n; *                 where the check for an existing LV takes place right at&n; *                 the beginning&n; *    01/03/2001 - Add VG_CREATE_OLD for IOP 10 compatibility&n; *    02/03/2001 - Don&squot;t destroy usermode pointers in lv_t structures duing LV_&n; *                 STATUS_BYxxx and remove redundant lv_t variables from same.&n; *    05/03/2001 - restore copying pe_t array in lvm_do_lv_status_byname. For&n; *                 lvdisplay -v (PC)&n; *               - restore copying pe_t array in lvm_do_lv_status_byindex (HM)&n; *               - added copying pe_t array in lvm_do_lv_status_bydev (HM)&n; *               - enhanced lvm_do_lv_status_by{name,index,dev} to be capable&n; *                 to copy the lv_block_exception_t array to userspace (HM)&n; *    08/03/2001 - factored lvm_do_pv_flush out of lvm_chr_ioctl [HM]&n; *    09/03/2001 - Added _lock_open_count to ensure we only drop the lock&n; *                 when the locking process closes.&n; *    05/04/2001 - lvm_map bugs: don&squot;t use b_blocknr/b_dev in lvm_map, it&n; *&t;&t;   destroys stacking devices. call b_end_io on failed maps.&n; *&t;&t;   (Jens Axboe)&n; *               - Defer writes to an extent that is being moved [JT + AD]&n; *    28/05/2001 - implemented missing BLKSSZGET ioctl [AD]&n; *    28/12/2001 - buffer_head -&gt; bio&n; *                 removed huge allocation of a lv_t on stack&n; *                 (Anders Gustafsson)&n; *    07/01/2002 - fixed sizeof(lv_t) differences in user/kernel-space&n; *                 removed another huge allocation of a lv_t on stack&n; *                 (Anders Gustafsson)&n; *&n; */
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR LVM_BLK_MAJOR
DECL|macro|DEVICE_OFF
mdefine_line|#define DEVICE_OFF(device)
DECL|macro|LOCAL_END_REQUEST
mdefine_line|#define LOCAL_END_REQUEST
multiline_comment|/* lvm_do_lv_create calls fsync_dev_lockfs()/unlockfs() */
multiline_comment|/* #define&t;LVM_VFS_ENHANCEMENT */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/ioctl.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifdef CONFIG_KERNELD
macro_line|#include &lt;linux/kerneld.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/lvm.h&gt;
macro_line|#include &quot;lvm-internal.h&quot;
DECL|macro|LVM_CORRECT_READ_AHEAD
mdefine_line|#define&t;LVM_CORRECT_READ_AHEAD( a) &bslash;&n;   if      ( a &lt; LVM_MIN_READ_AHEAD || &bslash;&n;             a &gt; LVM_MAX_READ_AHEAD) a = LVM_MAX_READ_AHEAD;
macro_line|#ifndef WRITEA
DECL|macro|WRITEA
macro_line|#  define WRITEA WRITE
macro_line|#endif
multiline_comment|/*&n; * External function prototypes&n; */
r_static
r_int
id|lvm_make_request_fn
c_func
(paren
id|request_queue_t
op_star
comma
r_struct
id|bio
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_blk_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
id|uint
comma
id|ulong
)paren
suffix:semicolon
r_static
r_int
id|lvm_blk_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_blk_close
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_get_snapshot_use_rate
c_func
(paren
id|lv_t
op_star
id|lv_ptr
comma
r_void
op_star
id|arg
)paren
suffix:semicolon
r_static
r_int
id|lvm_user_bmap
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|lv_bmap
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_chr_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_chr_close
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_chr_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
id|uint
comma
id|ulong
)paren
suffix:semicolon
multiline_comment|/* End external function prototypes */
multiline_comment|/*&n; * Internal function prototypes&n; */
r_static
r_void
id|lvm_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|lvm_init_vars
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef LVM_HD_NAME
r_extern
r_void
(paren
op_star
id|lvm_hd_name_ptr
)paren
(paren
r_char
op_star
comma
r_int
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|lvm_map
c_func
(paren
r_struct
id|bio
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lock_lvm
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_le_remap
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_pv_create
c_func
(paren
id|pv_t
op_star
comma
id|vg_t
op_star
comma
id|ulong
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_pv_remove
c_func
(paren
id|vg_t
op_star
comma
id|ulong
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_create
c_func
(paren
r_int
comma
r_char
op_star
comma
id|userlv_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_extend_reduce
c_func
(paren
r_int
comma
r_char
op_star
comma
id|userlv_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_remove
c_func
(paren
r_int
comma
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_rename
c_func
(paren
id|vg_t
op_star
comma
id|lv_req_t
op_star
comma
id|userlv_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_status_byname
c_func
(paren
id|vg_t
op_star
id|r
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_status_byindex
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_lv_status_bydev
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_pe_lock_unlock
c_func
(paren
id|vg_t
op_star
id|r
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_pv_change
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_pv_status
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_pv_flush
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_vg_create
c_func
(paren
r_void
op_star
comma
r_int
id|minor
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_vg_extend
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_vg_reduce
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_vg_rename
c_func
(paren
id|vg_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|lvm_do_vg_remove
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|lvm_geninit
c_func
(paren
r_struct
id|gendisk
op_star
)paren
suffix:semicolon
r_static
r_void
id|__update_hardsectsize
c_func
(paren
id|lv_t
op_star
id|lv
)paren
suffix:semicolon
r_static
r_void
id|_queue_io
c_func
(paren
r_struct
id|bio
op_star
id|bh
comma
r_int
id|rw
)paren
suffix:semicolon
r_static
r_struct
id|bio
op_star
id|_dequeue_io
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|_flush_io
c_func
(paren
r_struct
id|bio
op_star
id|bh
)paren
suffix:semicolon
r_static
r_int
id|_open_pv
c_func
(paren
id|pv_t
op_star
id|pv
)paren
suffix:semicolon
r_static
r_void
id|_close_pv
c_func
(paren
id|pv_t
op_star
id|pv
)paren
suffix:semicolon
r_static
r_int
r_int
id|_sectors_to_k
c_func
(paren
r_int
r_int
id|sect
)paren
suffix:semicolon
macro_line|#ifdef LVM_HD_NAME
r_void
id|lvm_hd_name
c_func
(paren
r_char
op_star
comma
r_int
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* END Internal function prototypes */
multiline_comment|/* variables */
DECL|variable|lvm_version
r_char
op_star
id|lvm_version
op_assign
l_string|&quot;LVM version &quot;
id|LVM_RELEASE_NAME
l_string|&quot;(&quot;
id|LVM_RELEASE_DATE
l_string|&quot;)&quot;
suffix:semicolon
DECL|variable|lvm_iop_version
id|ushort
id|lvm_iop_version
op_assign
id|LVM_DRIVER_IOP_VERSION
suffix:semicolon
DECL|variable|loadtime
r_int
id|loadtime
op_assign
l_int|0
suffix:semicolon
DECL|variable|lvm_name
r_const
r_char
op_star
r_const
id|lvm_name
op_assign
id|LVM_NAME
suffix:semicolon
multiline_comment|/* volume group descriptor area pointers */
DECL|variable|vg
id|vg_t
op_star
id|vg
(braket
id|ABS_MAX_VG
)braket
suffix:semicolon
multiline_comment|/* map from block minor number to VG and LV numbers */
r_typedef
r_struct
(brace
DECL|member|vg_number
r_int
id|vg_number
suffix:semicolon
DECL|member|lv_number
r_int
id|lv_number
suffix:semicolon
DECL|typedef|vg_lv_map_t
)brace
id|vg_lv_map_t
suffix:semicolon
DECL|variable|vg_lv_map
r_static
id|vg_lv_map_t
id|vg_lv_map
(braket
id|ABS_MAX_LV
)braket
suffix:semicolon
multiline_comment|/* Request structures (lvm_chr_ioctl()) */
DECL|variable|pv_change_req
r_static
id|pv_change_req_t
id|pv_change_req
suffix:semicolon
DECL|variable|pv_status_req
r_static
id|pv_status_req_t
id|pv_status_req
suffix:semicolon
DECL|variable|pe_lock_req
r_volatile
r_static
id|pe_lock_req_t
id|pe_lock_req
suffix:semicolon
DECL|variable|le_remap_req
r_static
id|le_remap_req_t
id|le_remap_req
suffix:semicolon
DECL|variable|lv_req
r_static
id|lv_req_t
id|lv_req
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
DECL|variable|lvm_reset_spindown
r_static
r_int
id|lvm_reset_spindown
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|pv_name
r_static
r_char
id|pv_name
(braket
id|NAME_LEN
)braket
suffix:semicolon
multiline_comment|/* static char rootvg[NAME_LEN] = { 0, }; */
DECL|variable|lock
r_static
r_int
id|lock
op_assign
l_int|0
suffix:semicolon
DECL|variable|_lock_open_count
r_static
r_int
id|_lock_open_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|vg_count
r_static
id|uint
id|vg_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|lvm_chr_open_count
r_static
r_int
id|lvm_chr_open_count
op_assign
l_int|0
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|lvm_wait
)paren
suffix:semicolon
DECL|variable|lvm_lock
r_static
id|spinlock_t
id|lvm_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|lvm_snapshot_lock
r_static
id|spinlock_t
id|lvm_snapshot_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|_pe_requests
r_static
r_struct
id|bio
op_star
id|_pe_requests
suffix:semicolon
r_static
id|DECLARE_RWSEM
c_func
(paren
id|_pe_lock
)paren
suffix:semicolon
DECL|variable|lvm_chr_fops
r_struct
id|file_operations
id|lvm_chr_fops
op_assign
(brace
id|open
suffix:colon
id|lvm_chr_open
comma
id|release
suffix:colon
id|lvm_chr_close
comma
id|ioctl
suffix:colon
id|lvm_chr_ioctl
comma
)brace
suffix:semicolon
multiline_comment|/* block device operations structure needed for 2.3.38? and above */
DECL|variable|lvm_blk_dops
r_struct
id|block_device_operations
id|lvm_blk_dops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|open
suffix:colon
id|lvm_blk_open
comma
id|release
suffix:colon
id|lvm_blk_close
comma
id|ioctl
suffix:colon
id|lvm_blk_ioctl
comma
)brace
suffix:semicolon
multiline_comment|/* gendisk structures */
DECL|variable|lvm_hd_struct
r_static
r_struct
id|hd_struct
id|lvm_hd_struct
(braket
id|MAX_LV
)braket
suffix:semicolon
DECL|variable|lvm_blocksizes
r_static
r_int
id|lvm_blocksizes
(braket
id|MAX_LV
)braket
suffix:semicolon
DECL|variable|lvm_size
r_static
r_int
id|lvm_size
(braket
id|MAX_LV
)braket
suffix:semicolon
DECL|variable|lvm_gendisk
r_static
r_struct
id|gendisk
id|lvm_gendisk
op_assign
(brace
id|major
suffix:colon
id|MAJOR_NR
comma
id|major_name
suffix:colon
id|LVM_NAME
comma
id|minor_shift
suffix:colon
l_int|0
comma
id|part
suffix:colon
id|lvm_hd_struct
comma
id|sizes
suffix:colon
id|lvm_size
comma
id|nr_real
suffix:colon
id|MAX_LV
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Driver initialization...&n; */
DECL|function|lvm_init
r_int
id|lvm_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|devfs_register_chrdev
c_func
(paren
id|LVM_CHAR_MAJOR
comma
id|lvm_name
comma
op_amp
id|lvm_chr_fops
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s -- devfs_register_chrdev failed&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devfs_register_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|lvm_name
comma
op_amp
id|lvm_blk_dops
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s -- devfs_register_blkdev failed&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_unregister_chrdev
c_func
(paren
id|LVM_CHAR_MAJOR
comma
id|lvm_name
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s -- devfs_unregister_chrdev failed&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|lvm_init_fs
c_func
(paren
)paren
suffix:semicolon
id|lvm_init_vars
c_func
(paren
)paren
suffix:semicolon
id|lvm_geninit
c_func
(paren
op_amp
id|lvm_gendisk
)paren
suffix:semicolon
id|add_gendisk
c_func
(paren
op_amp
id|lvm_gendisk
)paren
suffix:semicolon
macro_line|#ifdef LVM_HD_NAME
multiline_comment|/* reference from drivers/block/genhd.c */
id|lvm_hd_name_ptr
op_assign
id|lvm_hd_name
suffix:semicolon
macro_line|#endif
id|blk_queue_make_request
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|lvm_make_request_fn
)paren
suffix:semicolon
multiline_comment|/* initialise the pe lock */
id|pe_lock_req.lock
op_assign
id|UNLOCK_PE
suffix:semicolon
multiline_comment|/* optional read root VGDA */
multiline_comment|/*&n;   if ( *rootvg != 0) vg_read_with_pv_and_lv ( rootvg, &amp;vg);&n;*/
macro_line|#ifdef MODULE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s module loaded&bslash;n&quot;
comma
id|lvm_version
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&bslash;n&quot;
comma
id|lvm_version
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_init() */
multiline_comment|/*&n; * cleanup...&n; */
DECL|function|lvm_cleanup
r_static
r_void
id|lvm_cleanup
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|devfs_unregister_chrdev
c_func
(paren
id|LVM_CHAR_MAJOR
comma
id|lvm_name
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s -- devfs_unregister_chrdev failed&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|lvm_name
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s -- devfs_unregister_blkdev failed&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
id|del_gendisk
c_func
(paren
op_amp
id|lvm_gendisk
)paren
suffix:semicolon
id|blk_clear
c_func
(paren
id|MAJOR_NR
)paren
suffix:semicolon
macro_line|#ifdef LVM_HD_NAME
multiline_comment|/* reference from linux/drivers/block/genhd.c */
id|lvm_hd_name_ptr
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
multiline_comment|/* unregister with procfs and devfs */
id|lvm_fin_fs
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s -- Module successfully deactivated&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* lvm_cleanup() */
multiline_comment|/*&n; * support function to initialize lvm variables&n; */
DECL|function|lvm_init_vars
r_static
r_void
id|__init
id|lvm_init_vars
c_func
(paren
r_void
)paren
(brace
r_int
id|v
suffix:semicolon
id|loadtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|lvm_lock
op_assign
id|lvm_snapshot_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|pe_lock_req.lock
op_assign
id|UNLOCK_PE
suffix:semicolon
id|pe_lock_req.data.lv_dev
op_assign
id|NODEV
suffix:semicolon
id|pe_lock_req.data.pv_dev
op_assign
id|NODEV
suffix:semicolon
id|pe_lock_req.data.pv_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize VG pointers */
r_for
c_loop
(paren
id|v
op_assign
l_int|0
suffix:semicolon
id|v
OL
id|ABS_MAX_VG
suffix:semicolon
id|v
op_increment
)paren
id|vg
(braket
id|v
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Initialize LV -&gt; VG association */
r_for
c_loop
(paren
id|v
op_assign
l_int|0
suffix:semicolon
id|v
OL
id|ABS_MAX_LV
suffix:semicolon
id|v
op_increment
)paren
(brace
multiline_comment|/* index ABS_MAX_VG never used for real VG */
id|vg_lv_map
(braket
id|v
)braket
dot
id|vg_number
op_assign
id|ABS_MAX_VG
suffix:semicolon
id|vg_lv_map
(braket
id|v
)braket
dot
id|lv_number
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* lvm_init_vars() */
multiline_comment|/********************************************************************&n; *&n; * Character device functions&n; *&n; ********************************************************************/
DECL|macro|MODE_TO_STR
mdefine_line|#define MODE_TO_STR(mode) (mode) &amp; FMODE_READ ? &quot;READ&quot; : &quot;&quot;, &bslash;&n;&t;&t;&t;  (mode) &amp; FMODE_WRITE ? &quot;WRITE&quot; : &quot;&quot;
multiline_comment|/*&n; * character device open routine&n; */
DECL|function|lvm_chr_open
r_static
r_int
id|lvm_chr_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|minor
op_assign
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|P_DEV
c_func
(paren
l_string|&quot;chr_open MINOR: %d  VG#: %d  mode: %s%s  lock: %d&bslash;n&quot;
comma
id|minor
comma
id|VG_CHR
c_func
(paren
id|minor
)paren
comma
id|MODE_TO_STR
c_func
(paren
id|file-&gt;f_mode
)paren
comma
id|lock
)paren
suffix:semicolon
multiline_comment|/* super user validation */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* Group special file open */
r_if
c_cond
(paren
id|VG_CHR
c_func
(paren
id|minor
)paren
OG
id|MAX_VG
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lvm_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock
op_eq
id|current-&gt;pid
)paren
(brace
id|_lock_open_count
op_increment
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lvm_lock
)paren
suffix:semicolon
id|lvm_chr_open_count
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_chr_open() */
multiline_comment|/*&n; * character device i/o-control routine&n; *&n; * Only one changing process can do changing ioctl at one time,&n; * others will block.&n; *&n; */
DECL|function|lvm_chr_ioctl
r_static
r_int
id|lvm_chr_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|uint
id|command
comma
id|ulong
id|a
)paren
(brace
r_int
id|minor
op_assign
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|uint
id|extendable
comma
id|l
comma
id|v
suffix:semicolon
r_void
op_star
id|arg
op_assign
(paren
r_void
op_star
)paren
id|a
suffix:semicolon
id|userlv_t
id|ulv
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
multiline_comment|/* otherwise cc will complain about unused variables */
(paren
r_void
)paren
id|lvm_lock
suffix:semicolon
id|P_IOCTL
c_func
(paren
l_string|&quot;chr MINOR: %d  command: 0x%X  arg: %p  VG#: %d  mode: %s%s&bslash;n&quot;
comma
id|minor
comma
id|command
comma
id|arg
comma
id|VG_CHR
c_func
(paren
id|minor
)paren
comma
id|MODE_TO_STR
c_func
(paren
id|file-&gt;f_mode
)paren
)paren
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
r_if
c_cond
(paren
id|lvm_reset_spindown
OG
l_int|0
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
macro_line|#endif
multiline_comment|/* Main command switch */
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|LVM_LOCK_LVM
suffix:colon
multiline_comment|/* lock the LVM */
r_return
id|lvm_do_lock_lvm
c_func
(paren
)paren
suffix:semicolon
r_case
id|LVM_GET_IOP_VERSION
suffix:colon
multiline_comment|/* check lvm version to ensure driver/tools+lib&n;&t;&t;   interoperability */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|lvm_iop_version
comma
r_sizeof
(paren
id|ushort
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
r_case
id|LVM_RESET
suffix:colon
multiline_comment|/* lock reset function */
id|lvm_reset_spindown
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|v
op_assign
l_int|0
suffix:semicolon
id|v
OL
id|ABS_MAX_VG
suffix:semicolon
id|v
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg
(braket
id|v
)braket
op_ne
l_int|NULL
)paren
id|lvm_do_vg_remove
c_func
(paren
id|v
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
r_while
c_loop
(paren
id|GET_USE_COUNT
c_func
(paren
op_amp
id|__this_module
)paren
OL
l_int|1
)paren
id|MOD_INC_USE_COUNT
suffix:semicolon
r_while
c_loop
(paren
id|GET_USE_COUNT
c_func
(paren
op_amp
id|__this_module
)paren
OG
l_int|1
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif /* MODULE */
id|lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* release lock */
id|wake_up_interruptible
c_func
(paren
op_amp
id|lvm_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif /* LVM_TOTAL_RESET */
r_case
id|LE_REMAP
suffix:colon
multiline_comment|/* remap a logical extent (after moving the physical extent) */
r_return
id|lvm_do_le_remap
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|PE_LOCK_UNLOCK
suffix:colon
multiline_comment|/* lock/unlock i/o to a physical extent to move it to another&n;&t;&t;   physical volume (move&squot;s done in user space&squot;s pvmove) */
r_return
id|lvm_do_pe_lock_unlock
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|VG_CREATE_OLD
suffix:colon
multiline_comment|/* create a VGDA */
r_return
id|lvm_do_vg_create
c_func
(paren
id|arg
comma
id|minor
)paren
suffix:semicolon
r_case
id|VG_CREATE
suffix:colon
multiline_comment|/* create a VGDA, assume VG number is filled in */
r_return
id|lvm_do_vg_create
c_func
(paren
id|arg
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_case
id|VG_EXTEND
suffix:colon
multiline_comment|/* extend a volume group */
r_return
id|lvm_do_vg_extend
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|VG_REDUCE
suffix:colon
multiline_comment|/* reduce a volume group */
r_return
id|lvm_do_vg_reduce
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|VG_RENAME
suffix:colon
multiline_comment|/* rename a volume group */
r_return
id|lvm_do_vg_rename
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|VG_REMOVE
suffix:colon
multiline_comment|/* remove an inactive VGDA */
r_return
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
r_case
id|VG_SET_EXTENDABLE
suffix:colon
multiline_comment|/* set/clear extendability flag of volume group */
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|extendable
comma
id|arg
comma
r_sizeof
(paren
id|extendable
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|extendable
op_eq
id|VG_EXTENDABLE
op_logical_or
id|extendable
op_eq
op_complement
id|VG_EXTENDABLE
)paren
(brace
r_if
c_cond
(paren
id|extendable
op_eq
id|VG_EXTENDABLE
)paren
id|vg_ptr-&gt;vg_status
op_or_assign
id|VG_EXTENDABLE
suffix:semicolon
r_else
id|vg_ptr-&gt;vg_status
op_and_assign
op_complement
id|VG_EXTENDABLE
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|VG_STATUS
suffix:colon
multiline_comment|/* get volume group data (only the vg_t struct) */
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
id|vg_ptr
comma
r_sizeof
(paren
id|vg_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|VG_STATUS_GET_COUNT
suffix:colon
multiline_comment|/* get volume group count */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|vg_count
comma
r_sizeof
(paren
id|vg_count
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|VG_STATUS_GET_NAMELIST
suffix:colon
multiline_comment|/* get volume group names */
r_for
c_loop
(paren
id|l
op_assign
id|v
op_assign
l_int|0
suffix:semicolon
id|v
OL
id|ABS_MAX_VG
suffix:semicolon
id|v
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg
(braket
id|v
)braket
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
op_plus
id|l
op_star
id|NAME_LEN
comma
id|vg
(braket
id|v
)braket
op_member_access_from_pointer
id|vg_name
comma
id|NAME_LEN
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_increment
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|LV_CREATE
suffix:colon
r_case
id|LV_EXTEND
suffix:colon
r_case
id|LV_REDUCE
suffix:colon
r_case
id|LV_REMOVE
suffix:colon
r_case
id|LV_RENAME
suffix:colon
multiline_comment|/* create, extend, reduce, remove or rename a logical volume */
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv_req
comma
id|arg
comma
r_sizeof
(paren
id|lv_req
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|command
op_ne
id|LV_REMOVE
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ulv
comma
id|lv_req.lv
comma
r_sizeof
(paren
id|userlv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|LV_CREATE
suffix:colon
r_return
id|lvm_do_lv_create
c_func
(paren
id|minor
comma
id|lv_req.lv_name
comma
op_amp
id|ulv
)paren
suffix:semicolon
r_case
id|LV_EXTEND
suffix:colon
r_case
id|LV_REDUCE
suffix:colon
r_return
id|lvm_do_lv_extend_reduce
c_func
(paren
id|minor
comma
id|lv_req.lv_name
comma
op_amp
id|ulv
)paren
suffix:semicolon
r_case
id|LV_REMOVE
suffix:colon
r_return
id|lvm_do_lv_remove
c_func
(paren
id|minor
comma
id|lv_req.lv_name
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_case
id|LV_RENAME
suffix:colon
r_return
id|lvm_do_lv_rename
c_func
(paren
id|vg_ptr
comma
op_amp
id|lv_req
comma
op_amp
id|ulv
)paren
suffix:semicolon
)brace
r_case
id|LV_STATUS_BYNAME
suffix:colon
multiline_comment|/* get status of a logical volume by name */
r_return
id|lvm_do_lv_status_byname
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|LV_STATUS_BYINDEX
suffix:colon
multiline_comment|/* get status of a logical volume by index */
r_return
id|lvm_do_lv_status_byindex
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|LV_STATUS_BYDEV
suffix:colon
multiline_comment|/* get status of a logical volume by device */
r_return
id|lvm_do_lv_status_bydev
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|PV_CHANGE
suffix:colon
multiline_comment|/* change a physical volume */
r_return
id|lvm_do_pv_change
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|PV_STATUS
suffix:colon
multiline_comment|/* get physical volume data (pv_t structure only) */
r_return
id|lvm_do_pv_status
c_func
(paren
id|vg_ptr
comma
id|arg
)paren
suffix:semicolon
r_case
id|PV_FLUSH
suffix:colon
multiline_comment|/* physical volume buffer flush/invalidate */
r_return
id|lvm_do_pv_flush
c_func
(paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s -- lvm_chr_ioctl: unknown command 0x%x&bslash;n&quot;
comma
id|lvm_name
comma
id|command
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_chr_ioctl */
multiline_comment|/*&n; * character device close routine&n; */
DECL|function|lvm_chr_close
r_static
r_int
id|lvm_chr_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|P_DEV
c_func
(paren
l_string|&quot;chr_close MINOR: %d  VG#: %d&bslash;n&quot;
comma
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
comma
id|VG_CHR
c_func
(paren
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
)paren
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
r_if
c_cond
(paren
id|lvm_reset_spindown
OG
l_int|0
)paren
(brace
id|lvm_reset_spindown
op_assign
l_int|0
suffix:semicolon
id|lvm_chr_open_count
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|lvm_chr_open_count
OG
l_int|0
)paren
id|lvm_chr_open_count
op_decrement
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lvm_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock
op_eq
id|current-&gt;pid
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|_lock_open_count
)paren
(brace
id|P_DEV
c_func
(paren
l_string|&quot;chr_close: unlocking LVM for pid %d&bslash;n&quot;
comma
id|lock
)paren
suffix:semicolon
id|lock
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|lvm_wait
)paren
suffix:semicolon
)brace
r_else
id|_lock_open_count
op_decrement
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lvm_lock
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_chr_close() */
multiline_comment|/********************************************************************&n; *&n; * Block device functions&n; *&n; ********************************************************************/
multiline_comment|/*&n; * block device open routine&n; */
DECL|function|lvm_blk_open
r_static
r_int
id|lvm_blk_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|P_DEV
c_func
(paren
l_string|&quot;blk_open MINOR: %d  VG#: %d  LV#: %d  mode: %s%s&bslash;n&quot;
comma
id|minor
comma
id|VG_BLK
c_func
(paren
id|minor
)paren
comma
id|LV_BLK
c_func
(paren
id|minor
)paren
comma
id|MODE_TO_STR
c_func
(paren
id|file-&gt;f_mode
)paren
)paren
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
r_if
c_cond
(paren
id|lvm_reset_spindown
OG
l_int|0
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|vg_ptr
op_ne
l_int|NULL
op_logical_and
(paren
id|vg_ptr-&gt;vg_status
op_amp
id|VG_ACTIVE
)paren
op_logical_and
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|LV_BLK
c_func
(paren
id|minor
)paren
)braket
)paren
op_ne
l_int|NULL
op_logical_and
id|LV_BLK
c_func
(paren
id|minor
)paren
op_ge
l_int|0
op_logical_and
id|LV_BLK
c_func
(paren
id|minor
)paren
OL
id|vg_ptr-&gt;lv_max
)paren
(brace
multiline_comment|/* Check parallel LV spindown (LV remove) */
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_status
op_amp
id|LV_SPINDOWN
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* Check inactive LV and open for read/write */
multiline_comment|/* We need to be able to &quot;read&quot; an inactive LV&n;&t;&t;   to re-activate it again */
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|lv_ptr-&gt;u.lv_status
op_amp
id|LV_ACTIVE
)paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv_ptr-&gt;u.lv_access
op_amp
id|LV_WRITE
)paren
op_logical_and
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* be sure to increment VG counter */
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_open
op_eq
l_int|0
)paren
id|vg_ptr-&gt;lv_open
op_increment
suffix:semicolon
id|lv_ptr-&gt;u.lv_open
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|P_DEV
c_func
(paren
l_string|&quot;blk_open OK, LV size %d&bslash;n&quot;
comma
id|lv_ptr-&gt;u.lv_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* lvm_blk_open() */
multiline_comment|/*&n; * block device i/o-control routine&n; */
DECL|function|lvm_blk_ioctl
r_static
r_int
id|lvm_blk_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|uint
id|command
comma
id|ulong
id|a
)paren
(brace
r_int
id|minor
op_assign
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|LV_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
r_void
op_star
id|arg
op_assign
(paren
r_void
op_star
)paren
id|a
suffix:semicolon
r_struct
id|hd_geometry
op_star
id|hd
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|a
suffix:semicolon
id|P_IOCTL
c_func
(paren
l_string|&quot;blk MINOR: %d  command: 0x%X  arg: %p  VG#: %d  LV#: %d  &quot;
l_string|&quot;mode: %s%s&bslash;n&quot;
comma
id|minor
comma
id|command
comma
id|arg
comma
id|VG_BLK
c_func
(paren
id|minor
)paren
comma
id|LV_BLK
c_func
(paren
id|minor
)paren
comma
id|MODE_TO_STR
c_func
(paren
id|file-&gt;f_mode
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|BLKSSZGET
suffix:colon
multiline_comment|/* get block device sector size as needed e.g. by fdisk */
r_return
id|put_user
c_func
(paren
id|get_hardsect_size
c_func
(paren
id|inode-&gt;i_rdev
)paren
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* return device size */
id|P_IOCTL
c_func
(paren
l_string|&quot;BLKGETSIZE: %u&bslash;n&quot;
comma
id|lv_ptr-&gt;u.lv_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|lv_ptr-&gt;u.lv_size
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKGETSIZE64
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
(paren
id|u64
)paren
id|lv_ptr-&gt;u.lv_size
op_lshift
l_int|9
comma
(paren
id|u64
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
multiline_comment|/* flush buffer cache */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|P_IOCTL
c_func
(paren
l_string|&quot;BLKFLSBUF&bslash;n&quot;
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKRASET
suffix:colon
multiline_comment|/* set read ahead for block device */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|P_IOCTL
c_func
(paren
l_string|&quot;BLKRASET: %ld sectors for %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|arg
comma
id|kdevname
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|arg
template_param
id|LVM_MAX_READ_AHEAD
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|lv_ptr-&gt;u.lv_read_ahead
op_assign
(paren
r_int
)paren
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKRAGET
suffix:colon
multiline_comment|/* get current read ahead setting */
id|P_IOCTL
c_func
(paren
l_string|&quot;BLKRAGET %d&bslash;n&quot;
comma
id|lv_ptr-&gt;u.lv_read_ahead
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|lv_ptr-&gt;u.lv_read_ahead
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDIO_GETGEO
suffix:colon
multiline_comment|/* get disk geometry */
id|P_IOCTL
c_func
(paren
l_string|&quot;%s -- lvm_blk_ioctl -- HDIO_GETGEO&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
(brace
r_int
r_char
id|heads
op_assign
l_int|64
suffix:semicolon
r_int
r_char
id|sectors
op_assign
l_int|32
suffix:semicolon
r_int
id|start
op_assign
l_int|0
suffix:semicolon
r_int
id|cylinders
op_assign
id|lv_ptr-&gt;u.lv_size
op_div
id|heads
op_div
id|sectors
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|hd-&gt;heads
comma
op_amp
id|heads
comma
r_sizeof
(paren
id|heads
)paren
)paren
op_ne
l_int|0
op_logical_or
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|hd-&gt;sectors
comma
op_amp
id|sectors
comma
r_sizeof
(paren
id|sectors
)paren
)paren
op_ne
l_int|0
op_logical_or
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
op_amp
id|hd-&gt;cylinders
comma
op_amp
id|cylinders
comma
r_sizeof
(paren
id|cylinders
)paren
)paren
op_ne
l_int|0
op_logical_or
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
op_amp
id|hd-&gt;start
comma
op_amp
id|start
comma
r_sizeof
(paren
id|start
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|P_IOCTL
c_func
(paren
l_string|&quot;%s -- lvm_blk_ioctl -- cylinders: %d&bslash;n&quot;
comma
id|lvm_name
comma
id|cylinders
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|LV_SET_ACCESS
suffix:colon
multiline_comment|/* set access flags of a logical volume */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|lv_ptr-&gt;u.lv_access
op_assign
(paren
id|ulong
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_access
op_amp
id|LV_WRITE
)paren
id|set_device_ro
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
comma
l_int|0
)paren
suffix:semicolon
r_else
id|set_device_ro
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LV_SET_STATUS
suffix:colon
multiline_comment|/* set status flags of a logical volume */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|ulong
)paren
id|arg
op_amp
id|LV_ACTIVE
)paren
op_logical_and
id|lv_ptr-&gt;u.lv_open
OG
l_int|1
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|lv_ptr-&gt;u.lv_status
op_assign
(paren
id|ulong
)paren
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LV_BMAP
suffix:colon
multiline_comment|/* turn logical block into (dev_t, block).  non privileged. */
multiline_comment|/* don&squot;t bmap a snapshot, since the mapping can change */
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_return
id|lvm_user_bmap
c_func
(paren
id|inode
comma
(paren
r_struct
id|lv_bmap
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|LV_SET_ALLOCATION
suffix:colon
multiline_comment|/* set allocation flags of a logical volume */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|lv_ptr-&gt;u.lv_allocation
op_assign
(paren
id|ulong
)paren
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LV_SNAPSHOT_USE_RATE
suffix:colon
r_return
id|lvm_get_snapshot_use_rate
c_func
(paren
id|lv_ptr
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s -- lvm_blk_ioctl: unknown command 0x%x&bslash;n&quot;
comma
id|lvm_name
comma
id|command
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_blk_ioctl() */
multiline_comment|/*&n; * block device close routine&n; */
DECL|function|lvm_blk_close
r_static
r_int
id|lvm_blk_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|LV_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|P_DEV
c_func
(paren
l_string|&quot;blk_close MINOR: %d  VG#: %d  LV#: %d&bslash;n&quot;
comma
id|minor
comma
id|VG_BLK
c_func
(paren
id|minor
)paren
comma
id|LV_BLK
c_func
(paren
id|minor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_open
op_eq
l_int|1
)paren
id|vg_ptr-&gt;lv_open
op_decrement
suffix:semicolon
id|lv_ptr-&gt;u.lv_open
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_blk_close() */
DECL|function|lvm_get_snapshot_use_rate
r_static
r_int
id|lvm_get_snapshot_use_rate
c_func
(paren
id|lv_t
op_star
id|lv
comma
r_void
op_star
id|arg
)paren
(brace
id|lv_snapshot_use_rate_req_t
id|lv_rate_req
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv_rate_req
comma
id|arg
comma
r_sizeof
(paren
id|lv_rate_req
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|lv_rate_req.rate
template_param
l_int|100
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|lv_rate_req.block
)paren
(brace
r_case
l_int|0
suffix:colon
id|lv-&gt;lv_snapshot_use_rate
op_assign
id|lv_rate_req.rate
suffix:semicolon
r_if
c_cond
(paren
id|lv-&gt;u.lv_remap_ptr
op_star
l_int|100
op_div
id|lv-&gt;u.lv_remap_end
OL
id|lv-&gt;lv_snapshot_use_rate
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|lv-&gt;lv_snapshot_wait
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|O_NONBLOCK
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|lv_rate_req.rate
op_assign
id|lv-&gt;u.lv_remap_ptr
op_star
l_int|100
op_div
id|lv-&gt;u.lv_remap_end
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|lv_rate_req
comma
r_sizeof
(paren
id|lv_rate_req
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|lvm_user_bmap
r_static
r_int
id|lvm_user_bmap
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|lv_bmap
op_star
id|user_result
)paren
(brace
r_struct
id|bio
id|bio
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|block
comma
op_amp
id|user_result-&gt;lv_block
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|bio
comma
l_int|0
comma
r_sizeof
(paren
id|bio
)paren
)paren
suffix:semicolon
id|bio.bi_dev
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
id|bio.bi_size
op_assign
id|block_size
c_func
(paren
id|bio.bi_dev
)paren
suffix:semicolon
multiline_comment|/* NEEDED by bio_sectors */
id|bio.bi_sector
op_assign
id|block
op_star
id|bio_sectors
c_func
(paren
op_amp
id|bio
)paren
suffix:semicolon
id|bio.bi_rw
op_assign
id|READ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|lvm_map
c_func
(paren
op_amp
id|bio
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;lvm map failed: %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|kdev_t_to_nr
c_func
(paren
id|bio.bi_dev
)paren
comma
op_amp
id|user_result-&gt;lv_dev
)paren
op_logical_or
id|put_user
c_func
(paren
id|bio.bi_sector
op_div
id|bio_sectors
c_func
(paren
op_amp
id|bio
)paren
comma
op_amp
id|user_result-&gt;lv_block
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * block device support function for /usr/src/linux/drivers/block/ll_rw_blk.c&n; * (see init_module/lvm_init)&n; */
DECL|function|__remap_snapshot
r_static
r_void
id|__remap_snapshot
c_func
(paren
id|kdev_t
id|rdev
comma
id|ulong
id|rsector
comma
id|ulong
id|pe_start
comma
id|lv_t
op_star
id|lv
comma
id|vg_t
op_star
id|vg
)paren
(brace
multiline_comment|/* copy a chunk from the origin to a snapshot device */
id|down_write
c_func
(paren
op_amp
id|lv-&gt;lv_lock
)paren
suffix:semicolon
multiline_comment|/* we must redo lvm_snapshot_remap_block in order to avoid a&n;&t;   race condition in the gap where no lock was held */
r_if
c_cond
(paren
op_logical_neg
id|lvm_snapshot_remap_block
c_func
(paren
op_amp
id|rdev
comma
op_amp
id|rsector
comma
id|pe_start
comma
id|lv
)paren
op_logical_and
op_logical_neg
id|lvm_snapshot_COW
c_func
(paren
id|rdev
comma
id|rsector
comma
id|pe_start
comma
id|rsector
comma
id|vg
comma
id|lv
)paren
)paren
id|lvm_write_COW_table_block
c_func
(paren
id|vg
comma
id|lv
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|lv-&gt;lv_lock
)paren
suffix:semicolon
)brace
DECL|function|_remap_snapshot
r_static
r_inline
r_void
id|_remap_snapshot
c_func
(paren
id|kdev_t
id|rdev
comma
id|ulong
id|rsector
comma
id|ulong
id|pe_start
comma
id|lv_t
op_star
id|lv
comma
id|vg_t
op_star
id|vg
)paren
(brace
r_int
id|r
suffix:semicolon
multiline_comment|/* check to see if this chunk is already in the snapshot */
id|down_read
c_func
(paren
op_amp
id|lv-&gt;lv_lock
)paren
suffix:semicolon
id|r
op_assign
id|lvm_snapshot_remap_block
c_func
(paren
op_amp
id|rdev
comma
op_amp
id|rsector
comma
id|pe_start
comma
id|lv
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|lv-&gt;lv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
multiline_comment|/* we haven&squot;t yet copied this block to the snapshot */
id|__remap_snapshot
c_func
(paren
id|rdev
comma
id|rsector
comma
id|pe_start
comma
id|lv
comma
id|vg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * extents destined for a pe that is on the move should be deferred&n; */
DECL|function|_should_defer
r_static
r_inline
r_int
id|_should_defer
c_func
(paren
id|kdev_t
id|pv
comma
id|ulong
id|sector
comma
r_uint32
id|pe_size
)paren
(brace
r_return
(paren
(paren
id|pe_lock_req.lock
op_eq
id|LOCK_PE
)paren
op_logical_and
id|kdev_same
c_func
(paren
id|pv
comma
id|pe_lock_req.data.pv_dev
)paren
op_logical_and
(paren
id|sector
op_ge
id|pe_lock_req.data.pv_offset
)paren
op_logical_and
(paren
id|sector
OL
(paren
id|pe_lock_req.data.pv_offset
op_plus
id|pe_size
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|_defer_extent
r_static
r_inline
r_int
id|_defer_extent
c_func
(paren
r_struct
id|bio
op_star
id|bh
comma
r_int
id|rw
comma
id|kdev_t
id|pv
comma
id|ulong
id|sector
comma
r_uint32
id|pe_size
)paren
(brace
r_if
c_cond
(paren
id|pe_lock_req.lock
op_eq
id|LOCK_PE
)paren
(brace
id|down_read
c_func
(paren
op_amp
id|_pe_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_should_defer
c_func
(paren
id|pv
comma
id|sector
comma
id|pe_size
)paren
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|_pe_lock
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|_pe_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_should_defer
c_func
(paren
id|pv
comma
id|sector
comma
id|pe_size
)paren
)paren
id|_queue_io
c_func
(paren
id|bh
comma
id|rw
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|_pe_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|_pe_lock
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lvm_map
r_static
r_int
id|lvm_map
c_func
(paren
r_struct
id|bio
op_star
id|bi
)paren
(brace
r_int
id|minor
op_assign
id|minor
c_func
(paren
id|bi-&gt;bi_dev
)paren
suffix:semicolon
id|ulong
id|index
suffix:semicolon
id|ulong
id|pe_start
suffix:semicolon
id|ulong
id|size
op_assign
id|bio_sectors
c_func
(paren
id|bi
)paren
suffix:semicolon
id|ulong
id|rsector_org
op_assign
id|bi-&gt;bi_sector
suffix:semicolon
id|ulong
id|rsector_map
suffix:semicolon
id|kdev_t
id|rdev_map
suffix:semicolon
id|vg_t
op_star
id|vg_this
op_assign
id|vg
(braket
id|VG_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|lv_t
op_star
id|lv
op_assign
id|vg_this-&gt;lv
(braket
id|LV_BLK
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
r_int
id|rw
op_assign
id|bio_rw
c_func
(paren
id|bi
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|lv-&gt;lv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv-&gt;u.lv_status
op_amp
id|LV_ACTIVE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;%s - lvm_map: ll_rw_blk for inactive LV %s&bslash;n&quot;
comma
id|lvm_name
comma
id|lv-&gt;u.lv_name
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rw
op_eq
id|WRITE
op_logical_or
id|rw
op_eq
id|WRITEA
)paren
op_logical_and
op_logical_neg
(paren
id|lv-&gt;u.lv_access
op_amp
id|LV_WRITE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s - lvm_map: ll_rw_blk write for readonly LV %s&bslash;n&quot;
comma
id|lvm_name
comma
id|lv-&gt;u.lv_name
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
id|P_MAP
c_func
(paren
l_string|&quot;%s - lvm_map minor: %d  *rdev: %s  *rsector: %lu  size:%lu&bslash;n&quot;
comma
id|lvm_name
comma
id|minor
comma
id|kdevname
c_func
(paren
id|bi-&gt;bi_dev
)paren
comma
id|rsector_org
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rsector_org
op_plus
id|size
OG
id|lv-&gt;u.lv_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;%s - lvm_map access beyond end of device; *rsector: &quot;
l_string|&quot;%lu or size: %lu wrong for minor: %2d&bslash;n&quot;
comma
id|lvm_name
comma
id|rsector_org
comma
id|size
comma
id|minor
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lv-&gt;u.lv_stripes
OL
l_int|2
)paren
(brace
multiline_comment|/* linear mapping */
multiline_comment|/* get the index */
id|index
op_assign
id|rsector_org
op_div
id|vg_this-&gt;pe_size
suffix:semicolon
id|pe_start
op_assign
id|lv-&gt;u.lv_current_pe
(braket
id|index
)braket
dot
id|pe
suffix:semicolon
id|rsector_map
op_assign
id|lv-&gt;u.lv_current_pe
(braket
id|index
)braket
dot
id|pe
op_plus
(paren
id|rsector_org
op_mod
id|vg_this-&gt;pe_size
)paren
suffix:semicolon
id|rdev_map
op_assign
id|lv-&gt;u.lv_current_pe
(braket
id|index
)braket
dot
id|dev
suffix:semicolon
id|P_MAP
c_func
(paren
l_string|&quot;u.lv_current_pe[%ld].pe: %d  rdev: %s  rsector:%ld&bslash;n&quot;
comma
id|index
comma
id|lv-&gt;u.lv_current_pe
(braket
id|index
)braket
dot
id|pe
comma
id|kdevname
c_func
(paren
id|rdev_map
)paren
comma
id|rsector_map
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* striped mapping */
id|ulong
id|stripe_index
suffix:semicolon
id|ulong
id|stripe_length
suffix:semicolon
id|stripe_length
op_assign
id|vg_this-&gt;pe_size
op_star
id|lv-&gt;u.lv_stripes
suffix:semicolon
id|stripe_index
op_assign
(paren
id|rsector_org
op_mod
id|stripe_length
)paren
op_div
id|lv-&gt;u.lv_stripesize
suffix:semicolon
id|index
op_assign
id|rsector_org
op_div
id|stripe_length
op_plus
(paren
id|stripe_index
op_mod
id|lv-&gt;u.lv_stripes
)paren
op_star
(paren
id|lv-&gt;u.lv_allocated_le
op_div
id|lv-&gt;u.lv_stripes
)paren
suffix:semicolon
id|pe_start
op_assign
id|lv-&gt;u.lv_current_pe
(braket
id|index
)braket
dot
id|pe
suffix:semicolon
id|rsector_map
op_assign
id|lv-&gt;u.lv_current_pe
(braket
id|index
)braket
dot
id|pe
op_plus
(paren
id|rsector_org
op_mod
id|stripe_length
)paren
op_minus
(paren
id|stripe_index
op_mod
id|lv-&gt;u.lv_stripes
)paren
op_star
id|lv-&gt;u.lv_stripesize
op_minus
id|stripe_index
op_div
id|lv-&gt;u.lv_stripes
op_star
(paren
id|lv-&gt;u.lv_stripes
op_minus
l_int|1
)paren
op_star
id|lv-&gt;u.lv_stripesize
suffix:semicolon
id|rdev_map
op_assign
id|lv-&gt;u.lv_current_pe
(braket
id|index
)braket
dot
id|dev
suffix:semicolon
id|P_MAP
c_func
(paren
l_string|&quot;u.lv_current_pe[%ld].pe: %d  rdev: %s  rsector:%ld&bslash;n&quot;
l_string|&quot;stripe_length: %ld  stripe_index: %ld&bslash;n&quot;
comma
id|index
comma
id|lv-&gt;u.lv_current_pe
(braket
id|index
)braket
dot
id|pe
comma
id|kdevname
c_func
(paren
id|rdev_map
)paren
comma
id|rsector_map
comma
id|stripe_length
comma
id|stripe_index
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Queue writes to physical extents on the move until move completes.&n;&t; * Don&squot;t get _pe_lock until there is a reasonable expectation that&n;&t; * we need to queue this request, because this is in the fast path.&n;&t; */
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
op_logical_or
id|rw
op_eq
id|WRITEA
)paren
(brace
r_if
c_cond
(paren
id|_defer_extent
c_func
(paren
id|bi
comma
id|rw
comma
id|rdev_map
comma
id|rsector_map
comma
id|vg_this-&gt;pe_size
)paren
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|lv-&gt;lv_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|lv-&gt;u.lv_current_pe
(braket
id|index
)braket
dot
id|writes
op_increment
suffix:semicolon
multiline_comment|/* statistic */
)brace
r_else
id|lv-&gt;u.lv_current_pe
(braket
id|index
)braket
dot
id|reads
op_increment
suffix:semicolon
multiline_comment|/* statistic */
multiline_comment|/* snapshot volume exception handling on physical device address base */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv-&gt;u.lv_access
op_amp
(paren
id|LV_SNAPSHOT
op_or
id|LV_SNAPSHOT_ORG
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|lv-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
multiline_comment|/* remap snapshot */
r_if
c_cond
(paren
id|lv-&gt;u.lv_block_exception
)paren
id|lvm_snapshot_remap_block
c_func
(paren
op_amp
id|rdev_map
comma
op_amp
id|rsector_map
comma
id|pe_start
comma
id|lv
)paren
suffix:semicolon
r_else
r_goto
id|bad
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
op_logical_or
id|rw
op_eq
id|WRITEA
)paren
(brace
multiline_comment|/* snapshot origin */
id|lv_t
op_star
id|snap
suffix:semicolon
multiline_comment|/* start with first snapshot and loop through all of&n;&t;&t;   them */
r_for
c_loop
(paren
id|snap
op_assign
id|lv-&gt;u.lv_snapshot_next
suffix:semicolon
id|snap
suffix:semicolon
id|snap
op_assign
id|snap-&gt;u.lv_snapshot_next
)paren
(brace
multiline_comment|/* Check for inactive snapshot */
r_if
c_cond
(paren
op_logical_neg
(paren
id|snap-&gt;u.lv_status
op_amp
id|LV_ACTIVE
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Serializes the COW with the accesses to the&n;&t;&t;&t;   snapshot device */
id|_remap_snapshot
c_func
(paren
id|rdev_map
comma
id|rsector_map
comma
id|pe_start
comma
id|snap
comma
id|vg_this
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|bi-&gt;bi_dev
op_assign
id|rdev_map
suffix:semicolon
id|bi-&gt;bi_sector
op_assign
id|rsector_map
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|lv-&gt;lv_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|bad
suffix:colon
id|bio_io_error
c_func
(paren
id|bi
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|lv-&gt;lv_lock
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* lvm_map() */
multiline_comment|/*&n; * internal support functions&n; */
macro_line|#ifdef LVM_HD_NAME
multiline_comment|/*&n; * generate &quot;hard disk&quot; name&n; */
DECL|function|lvm_hd_name
r_void
id|lvm_hd_name
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|minor
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg
(braket
id|VG_BLK
c_func
(paren
id|minor
)paren
)braket
op_eq
l_int|NULL
op_logical_or
(paren
id|lv_ptr
op_assign
id|vg
(braket
id|VG_BLK
c_func
(paren
id|minor
)paren
)braket
op_member_access_from_pointer
id|lv
(braket
id|LV_BLK
c_func
(paren
id|minor
)paren
)braket
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|lv_ptr-&gt;u.lv_name
)paren
op_minus
l_int|5
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
op_amp
id|lv_ptr-&gt;u.lv_name
(braket
l_int|5
)braket
comma
id|len
)paren
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * make request function&n; */
DECL|function|lvm_make_request_fn
r_static
r_int
id|lvm_make_request_fn
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_return
(paren
id|lvm_map
c_func
(paren
id|bio
)paren
op_le
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n; *&n; * Character device support functions&n; *&n; ********************************************************************/
multiline_comment|/*&n; * character device support function logical volume manager lock&n; */
DECL|function|lvm_do_lock_lvm
r_static
r_int
id|lvm_do_lock_lvm
c_func
(paren
r_void
)paren
(brace
id|lock_try_again
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|lvm_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock
op_ne
l_int|0
op_logical_and
id|lock
op_ne
id|current-&gt;pid
)paren
(brace
id|P_DEV
c_func
(paren
l_string|&quot;lvm_do_lock_lvm: locked by pid %d ...&bslash;n&quot;
comma
id|lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lvm_lock
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|lvm_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
r_if
c_cond
(paren
id|lvm_reset_spindown
OG
l_int|0
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
macro_line|#endif
r_goto
id|lock_try_again
suffix:semicolon
)brace
id|lock
op_assign
id|current-&gt;pid
suffix:semicolon
id|P_DEV
c_func
(paren
l_string|&quot;lvm_do_lock_lvm: locking LVM for pid %d&bslash;n&quot;
comma
id|lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lvm_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lock_lvm */
multiline_comment|/*&n; * character device support function lock/unlock physical extend&n; */
DECL|function|lvm_do_pe_lock_unlock
r_static
r_int
id|lvm_do_pe_lock_unlock
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|pe_lock_req_t
id|new_lock
suffix:semicolon
r_struct
id|bio
op_star
id|bh
suffix:semicolon
id|uint
id|p
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_lock
comma
id|arg
comma
r_sizeof
(paren
id|new_lock
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|new_lock.lock
)paren
(brace
r_case
id|LOCK_PE
suffix:colon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_ne
l_int|NULL
op_logical_and
id|kdev_same
c_func
(paren
id|new_lock.data.pv_dev
comma
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pv_dev
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
id|vg_ptr-&gt;pv_max
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/*&n;&t;&t; * this sync releaves memory pressure to lessen the&n;&t;&t; * likelyhood of pvmove being paged out - resulting in&n;&t;&t; * deadlock.&n;&t;&t; *&n;&t;&t; * This method of doing a pvmove is broken&n;&t;&t; */
id|fsync_dev
c_func
(paren
id|pe_lock_req.data.lv_dev
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|_pe_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pe_lock_req.lock
op_eq
id|LOCK_PE
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|_pe_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Should we do to_kdev_t() on the pv_dev and u.lv_dev??? */
id|pe_lock_req.lock
op_assign
id|LOCK_PE
suffix:semicolon
id|pe_lock_req.data.lv_dev
op_assign
id|new_lock.data.lv_dev
suffix:semicolon
id|pe_lock_req.data.pv_dev
op_assign
id|new_lock.data.pv_dev
suffix:semicolon
id|pe_lock_req.data.pv_offset
op_assign
id|new_lock.data.pv_offset
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|_pe_lock
)paren
suffix:semicolon
multiline_comment|/* some requests may have got through since the fsync */
id|fsync_dev
c_func
(paren
id|pe_lock_req.data.pv_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNLOCK_PE
suffix:colon
id|down_write
c_func
(paren
op_amp
id|_pe_lock
)paren
suffix:semicolon
id|pe_lock_req.lock
op_assign
id|UNLOCK_PE
suffix:semicolon
id|pe_lock_req.data.lv_dev
op_assign
id|NODEV
suffix:semicolon
id|pe_lock_req.data.pv_dev
op_assign
id|NODEV
suffix:semicolon
id|pe_lock_req.data.pv_offset
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|_dequeue_io
c_func
(paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|_pe_lock
)paren
suffix:semicolon
multiline_comment|/* handle all deferred io for this PE */
id|_flush_io
c_func
(paren
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * character device support function logical extend remap&n; */
DECL|function|lvm_do_le_remap
r_static
r_int
id|lvm_do_le_remap
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|uint
id|l
comma
id|le
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|le_remap_req
comma
id|arg
comma
r_sizeof
(paren
id|le_remap_req_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|lv_ptr-&gt;u.lv_name
comma
id|le_remap_req.lv_name
)paren
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|le
op_assign
l_int|0
suffix:semicolon
id|le
OL
id|lv_ptr-&gt;u.lv_allocated_le
suffix:semicolon
id|le
op_increment
)paren
(brace
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|lv_ptr-&gt;u.lv_current_pe
(braket
id|le
)braket
dot
id|dev
comma
id|le_remap_req.old_dev
)paren
op_logical_and
id|lv_ptr-&gt;u.lv_current_pe
(braket
id|le
)braket
dot
id|pe
op_eq
id|le_remap_req.old_pe
)paren
(brace
id|lv_ptr-&gt;u.lv_current_pe
(braket
id|le
)braket
dot
id|dev
op_assign
id|le_remap_req.new_dev
suffix:semicolon
id|lv_ptr-&gt;u.lv_current_pe
(braket
id|le
)braket
dot
id|pe
op_assign
id|le_remap_req.new_pe
suffix:semicolon
id|__update_hardsectsize
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* lvm_do_le_remap() */
multiline_comment|/*&n; * character device support function VGDA create&n; */
DECL|function|lvm_do_vg_create
r_static
r_int
id|lvm_do_vg_create
c_func
(paren
r_void
op_star
id|arg
comma
r_int
id|minor
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ulong
id|l
comma
id|ls
op_assign
l_int|0
comma
id|p
comma
id|size
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
suffix:semicolon
id|lv_t
op_star
op_star
id|snap_lv_ptr
suffix:semicolon
id|lv_t
op_star
id|tmplv
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vg_ptr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|vg_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- VG_CREATE: kmalloc error VG at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* get the volume group structure */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|vg_ptr
comma
id|arg
comma
r_sizeof
(paren
id|vg_t
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|P_IOCTL
c_func
(paren
l_string|&quot;lvm_do_vg_create ERROR: copy VG ptr %p (%d bytes)&bslash;n&quot;
comma
id|arg
comma
r_sizeof
(paren
id|vg_t
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* VG_CREATE now uses minor number in VG structure */
r_if
c_cond
(paren
id|minor
op_eq
op_minus
l_int|1
)paren
id|minor
op_assign
id|vg_ptr-&gt;vg_number
suffix:semicolon
multiline_comment|/* Validate it */
r_if
c_cond
(paren
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
op_ne
l_int|NULL
)paren
(brace
id|P_IOCTL
c_func
(paren
l_string|&quot;lvm_do_vg_create ERROR: VG %d in use&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* we are not that active so far... */
id|vg_ptr-&gt;vg_status
op_and_assign
op_complement
id|VG_ACTIVE
suffix:semicolon
id|vg_ptr-&gt;pe_allocated
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr-&gt;pv_max
OG
id|ABS_MAX_PV
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s -- Can&squot;t activate VG: ABS_MAX_PV too small&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv_max
OG
id|ABS_MAX_LV
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s -- Can&squot;t activate VG: ABS_MAX_LV too small for %u&bslash;n&quot;
comma
id|lvm_name
comma
id|vg_ptr-&gt;lv_max
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* create devfs and procfs entries */
id|lvm_fs_create_vg
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
op_assign
id|vg_ptr
suffix:semicolon
multiline_comment|/* get the physical volume structures */
id|vg_ptr-&gt;pv_act
op_assign
id|vg_ptr-&gt;pv_cur
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
id|pv_t
op_star
id|pvp
suffix:semicolon
multiline_comment|/* user space address */
r_if
c_cond
(paren
(paren
id|pvp
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|ret
op_assign
id|lvm_do_pv_create
c_func
(paren
id|pvp
comma
id|vg_ptr
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
)brace
id|size
op_assign
id|vg_ptr-&gt;lv_max
op_star
r_sizeof
(paren
id|lv_t
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|snap_lv_ptr
op_assign
id|vmalloc
(paren
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- VG_CREATE: vmalloc error snapshot LVs at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|memset
c_func
(paren
id|snap_lv_ptr
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmplv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|lv_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- VG_CREATE: kmalloc error LV at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|snap_lv_ptr
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* get the logical volume structures */
id|vg_ptr-&gt;lv_cur
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
id|lv_t
op_star
id|lvp
suffix:semicolon
multiline_comment|/* user space address */
r_if
c_cond
(paren
(paren
id|lvp
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmplv
comma
id|lvp
comma
r_sizeof
(paren
id|userlv_t
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|P_IOCTL
c_func
(paren
l_string|&quot;ERROR: copying LV ptr %p (%d bytes)&bslash;n&quot;
comma
id|lvp
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
suffix:semicolon
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|snap_lv_ptr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmplv
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmplv-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
id|snap_lv_ptr
(braket
id|ls
)braket
op_assign
id|lvp
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
id|ls
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* only create original logical volumes for now */
r_if
c_cond
(paren
id|lvm_do_lv_create
c_func
(paren
id|minor
comma
id|tmplv-&gt;u.lv_name
comma
op_amp
id|tmplv-&gt;u
)paren
op_ne
l_int|0
)paren
(brace
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|snap_lv_ptr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmplv
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Second path to correct snapshot logical volumes which are not&n;&t;   in place during first path above */
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|ls
suffix:semicolon
id|l
op_increment
)paren
(brace
id|lv_t
op_star
id|lvp
op_assign
id|snap_lv_ptr
(braket
id|l
)braket
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmplv
comma
id|lvp
comma
r_sizeof
(paren
id|userlv_t
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|snap_lv_ptr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmplv
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lvm_do_lv_create
c_func
(paren
id|minor
comma
id|tmplv-&gt;u.lv_name
comma
op_amp
id|tmplv-&gt;u
)paren
op_ne
l_int|0
)paren
(brace
id|lvm_do_vg_remove
c_func
(paren
id|minor
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|snap_lv_ptr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmplv
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
id|vfree
c_func
(paren
id|snap_lv_ptr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmplv
)paren
suffix:semicolon
id|vg_count
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* let&squot;s go active */
id|vg_ptr-&gt;vg_status
op_or_assign
id|VG_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_vg_create() */
multiline_comment|/*&n; * character device support function VGDA extend&n; */
DECL|function|lvm_do_vg_extend
r_static
r_int
id|lvm_do_vg_extend
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|uint
id|p
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr-&gt;pv_cur
OL
id|vg_ptr-&gt;pv_max
)paren
(brace
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
)paren
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
id|lvm_do_pv_create
c_func
(paren
id|arg
comma
id|vg_ptr
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
suffix:semicolon
id|vg_ptr-&gt;pe_total
op_add_assign
id|pv_ptr-&gt;pe_total
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* lvm_do_vg_extend() */
multiline_comment|/*&n; * character device support function VGDA reduce&n; */
DECL|function|lvm_do_vg_reduce
r_static
r_int
id|lvm_do_vg_reduce
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|uint
id|p
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|pv_name
comma
id|arg
comma
r_sizeof
(paren
id|pv_name
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pv_ptr
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|pv_ptr-&gt;pv_name
comma
id|pv_name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pv_ptr-&gt;lv_cur
OG
l_int|0
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|lvm_do_pv_remove
c_func
(paren
id|vg_ptr
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* Make PV pointer array contiguous */
r_for
c_loop
(paren
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
op_minus
l_int|1
suffix:semicolon
id|p
op_increment
)paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
op_plus
l_int|1
)braket
suffix:semicolon
id|vg_ptr-&gt;pv
(braket
id|p
op_plus
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* lvm_do_vg_reduce */
multiline_comment|/*&n; * character device support function VG rename&n; */
DECL|function|lvm_do_vg_rename
r_static
r_int
id|lvm_do_vg_rename
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|l
op_assign
l_int|0
comma
id|p
op_assign
l_int|0
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_char
id|vg_name
(braket
id|NAME_LEN
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_char
id|lv_name
(braket
id|NAME_LEN
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_char
op_star
id|ptr
op_assign
l_int|NULL
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
op_assign
l_int|NULL
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|vg_name
comma
id|arg
comma
r_sizeof
(paren
id|vg_name
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|lvm_fs_remove_vg
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
id|strncpy
(paren
id|vg_ptr-&gt;vg_name
comma
id|vg_name
comma
r_sizeof
(paren
id|vg_name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|strncpy
c_func
(paren
id|lv_ptr-&gt;u.vg_name
comma
id|vg_name
comma
r_sizeof
(paren
id|vg_name
)paren
)paren
suffix:semicolon
id|ptr
op_assign
id|strrchr
c_func
(paren
id|lv_ptr-&gt;u.lv_name
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_eq
l_int|NULL
)paren
id|ptr
op_assign
id|lv_ptr-&gt;u.lv_name
suffix:semicolon
id|strncpy
c_func
(paren
id|lv_name
comma
id|ptr
comma
r_sizeof
(paren
id|lv_name
)paren
)paren
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
id|LVM_DIR_PREFIX
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|lv_ptr-&gt;u.lv_name
comma
id|LVM_DIR_PREFIX
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|lv_ptr-&gt;u.lv_name
comma
id|vg_name
comma
id|NAME_LEN
op_minus
id|len
)paren
suffix:semicolon
id|len
op_add_assign
id|strlen
(paren
id|vg_name
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|lv_ptr-&gt;u.lv_name
comma
id|lv_name
comma
id|NAME_LEN
op_minus
id|len
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|strncpy
c_func
(paren
id|pv_ptr-&gt;vg_name
comma
id|vg_name
comma
id|NAME_LEN
)paren
suffix:semicolon
)brace
id|lvm_fs_create_vg
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_vg_rename */
multiline_comment|/*&n; * character device support function VGDA remove&n; */
DECL|function|lvm_do_vg_remove
r_static
r_int
id|lvm_do_vg_remove
c_func
(paren
r_int
id|minor
)paren
(brace
r_int
id|i
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
r_if
c_cond
(paren
id|vg_ptr-&gt;lv_open
OG
l_int|0
op_logical_and
id|lvm_reset_spindown
op_eq
l_int|0
)paren
macro_line|#else
r_if
c_cond
(paren
id|vg_ptr-&gt;lv_open
OG
l_int|0
)paren
macro_line|#endif
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* let&squot;s go inactive */
id|vg_ptr-&gt;vg_status
op_and_assign
op_complement
id|VG_ACTIVE
suffix:semicolon
multiline_comment|/* remove from procfs and devfs */
id|lvm_fs_remove_vg
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
multiline_comment|/* free LVs */
multiline_comment|/* first free snapshot logical volumes */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|i
)braket
op_ne
l_int|NULL
op_logical_and
id|vg_ptr-&gt;lv
(braket
id|i
)braket
op_member_access_from_pointer
id|u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
id|lvm_do_lv_remove
c_func
(paren
id|minor
comma
l_int|NULL
comma
id|i
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* then free the rest of the LVs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|lvm_do_lv_remove
c_func
(paren
id|minor
comma
l_int|NULL
comma
id|i
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* free PVs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|P_KFREE
c_func
(paren
l_string|&quot;%s -- kfree %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
id|lvm_do_pv_remove
c_func
(paren
id|vg_ptr
comma
id|i
)paren
suffix:semicolon
)brace
)brace
id|P_KFREE
c_func
(paren
l_string|&quot;%s -- kfree %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vg_ptr
)paren
suffix:semicolon
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
op_assign
l_int|NULL
suffix:semicolon
id|vg_count
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_vg_remove() */
multiline_comment|/*&n; * character device support function physical volume create&n; */
DECL|function|lvm_do_pv_create
r_static
r_int
id|lvm_do_pv_create
c_func
(paren
id|pv_t
op_star
id|pvp
comma
id|vg_t
op_star
id|vg_ptr
comma
id|ulong
id|p
)paren
(brace
id|pv_t
op_star
id|pv
suffix:semicolon
r_int
id|err
suffix:semicolon
id|pv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|pv_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pv
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- PV_CREATE: kmalloc error PV at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pv
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pv
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|pv
comma
id|pvp
comma
r_sizeof
(paren
id|pv_t
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|P_IOCTL
c_func
(paren
l_string|&quot;lvm_do_pv_create ERROR: copy PV ptr %p (%d bytes)&bslash;n&quot;
comma
id|pvp
comma
r_sizeof
(paren
id|pv_t
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pv
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|_open_pv
c_func
(paren
id|pv
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|pv
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* We don&squot;t need the PE list&n;&t;   in kernel space as with LVs pe_t list (see below) */
id|pv-&gt;pe
op_assign
l_int|NULL
suffix:semicolon
id|pv-&gt;pe_allocated
op_assign
l_int|0
suffix:semicolon
id|pv-&gt;pv_status
op_assign
id|PV_ACTIVE
suffix:semicolon
id|vg_ptr-&gt;pv_act
op_increment
suffix:semicolon
id|vg_ptr-&gt;pv_cur
op_increment
suffix:semicolon
id|lvm_fs_create_pv
c_func
(paren
id|vg_ptr
comma
id|pv
)paren
suffix:semicolon
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_assign
id|pv
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_pv_create() */
multiline_comment|/*&n; * character device support function physical volume remove&n; */
DECL|function|lvm_do_pv_remove
r_static
r_int
id|lvm_do_pv_remove
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
id|ulong
id|p
)paren
(brace
id|pv_t
op_star
id|pv
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
suffix:semicolon
id|lvm_fs_remove_pv
c_func
(paren
id|vg_ptr
comma
id|pv
)paren
suffix:semicolon
id|vg_ptr-&gt;pe_total
op_sub_assign
id|pv-&gt;pe_total
suffix:semicolon
id|vg_ptr-&gt;pv_cur
op_decrement
suffix:semicolon
id|vg_ptr-&gt;pv_act
op_decrement
suffix:semicolon
id|_close_pv
c_func
(paren
id|pv
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pv
)paren
suffix:semicolon
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__update_hardsectsize
r_static
r_void
id|__update_hardsectsize
c_func
(paren
id|lv_t
op_star
id|lv
)paren
(brace
r_int
id|le
comma
id|e
suffix:semicolon
r_int
id|max_hardsectsize
op_assign
l_int|0
comma
id|hardsectsize
suffix:semicolon
r_for
c_loop
(paren
id|le
op_assign
l_int|0
suffix:semicolon
id|le
OL
id|lv-&gt;u.lv_allocated_le
suffix:semicolon
id|le
op_increment
)paren
(brace
id|hardsectsize
op_assign
id|get_hardsect_size
c_func
(paren
id|lv-&gt;u.lv_current_pe
(braket
id|le
)braket
dot
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hardsectsize
op_eq
l_int|0
)paren
id|hardsectsize
op_assign
l_int|512
suffix:semicolon
r_if
c_cond
(paren
id|hardsectsize
OG
id|max_hardsectsize
)paren
id|max_hardsectsize
op_assign
id|hardsectsize
suffix:semicolon
)brace
multiline_comment|/* only perform this operation on active snapshots */
r_if
c_cond
(paren
(paren
id|lv-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
op_logical_and
(paren
id|lv-&gt;u.lv_status
op_amp
id|LV_ACTIVE
)paren
)paren
(brace
r_for
c_loop
(paren
id|e
op_assign
l_int|0
suffix:semicolon
id|e
OL
id|lv-&gt;u.lv_remap_end
suffix:semicolon
id|e
op_increment
)paren
(brace
id|hardsectsize
op_assign
id|get_hardsect_size
c_func
(paren
id|lv-&gt;u.lv_block_exception
(braket
id|e
)braket
dot
id|rdev_new
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hardsectsize
op_eq
l_int|0
)paren
id|hardsectsize
op_assign
l_int|512
suffix:semicolon
r_if
c_cond
(paren
id|hardsectsize
OG
id|max_hardsectsize
)paren
id|max_hardsectsize
op_assign
id|hardsectsize
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * character device support function logical volume create&n; */
DECL|function|lvm_do_lv_create
r_static
r_int
id|lvm_do_lv_create
c_func
(paren
r_int
id|minor
comma
r_char
op_star
id|lv_name
comma
id|userlv_t
op_star
id|ulv
)paren
(brace
r_int
id|e
comma
id|ret
comma
id|l
comma
id|le
comma
id|l_new
comma
id|p
comma
id|size
comma
id|activate
op_assign
l_int|1
suffix:semicolon
id|ulong
id|lv_status_save
suffix:semicolon
id|lv_block_exception_t
op_star
id|lvbe
op_assign
id|ulv-&gt;lv_block_exception
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
op_assign
l_int|NULL
suffix:semicolon
id|pe_t
op_star
id|pep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pep
op_assign
id|ulv-&gt;lv_current_pe
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|_sectors_to_k
c_func
(paren
id|ulv-&gt;lv_chunk_size
)paren
OG
id|LVM_SNAPSHOT_MAX_CHUNK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_cur
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_member_access_from_pointer
id|u.lv_name
comma
id|lv_name
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
multiline_comment|/* in case of lv_remove(), lv_create() pair */
id|l_new
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|ulv-&gt;lv_number
)braket
op_eq
l_int|NULL
)paren
id|l_new
op_assign
id|ulv-&gt;lv_number
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_eq
l_int|NULL
)paren
r_if
c_cond
(paren
id|l_new
op_eq
op_minus
l_int|1
)paren
id|l_new
op_assign
id|l
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|l_new
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_else
id|l
op_assign
id|l_new
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|lv_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- LV_CREATE: kmalloc error LV at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* copy preloaded LV */
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|lv_ptr
comma
(paren
r_char
op_star
)paren
id|ulv
comma
r_sizeof
(paren
id|userlv_t
)paren
)paren
suffix:semicolon
id|lv_status_save
op_assign
id|lv_ptr-&gt;u.lv_status
suffix:semicolon
id|lv_ptr-&gt;u.lv_status
op_and_assign
op_complement
id|LV_ACTIVE
suffix:semicolon
id|lv_ptr-&gt;u.lv_snapshot_org
op_assign
l_int|NULL
suffix:semicolon
id|lv_ptr-&gt;u.lv_snapshot_prev
op_assign
l_int|NULL
suffix:semicolon
id|lv_ptr-&gt;u.lv_snapshot_next
op_assign
l_int|NULL
suffix:semicolon
id|lv_ptr-&gt;u.lv_block_exception
op_assign
l_int|NULL
suffix:semicolon
id|lv_ptr-&gt;lv_iobuf
op_assign
l_int|NULL
suffix:semicolon
id|lv_ptr-&gt;lv_COW_table_iobuf
op_assign
l_int|NULL
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_hash_table
op_assign
l_int|NULL
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_hash_table_size
op_assign
l_int|0
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_hash_mask
op_assign
l_int|0
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|lv_ptr-&gt;lv_lock
)paren
suffix:semicolon
id|lv_ptr-&gt;lv_snapshot_use_rate
op_assign
l_int|0
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
id|lv_ptr
suffix:semicolon
multiline_comment|/* get the PE structures from user space if this&n;&t;   is not a snapshot logical volume */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv_ptr-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
)paren
(brace
id|size
op_assign
id|lv_ptr-&gt;u.lv_allocated_le
op_star
r_sizeof
(paren
id|pe_t
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lv_ptr-&gt;u.lv_current_pe
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- LV_CREATE: vmalloc error LV_CURRENT_PE of %d Byte &quot;
l_string|&quot;at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|size
comma
id|__LINE__
)paren
suffix:semicolon
id|P_KFREE
c_func
(paren
l_string|&quot;%s -- kfree %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|lv_ptr-&gt;u.lv_current_pe
comma
id|pep
comma
id|size
)paren
)paren
(brace
id|P_IOCTL
c_func
(paren
l_string|&quot;ERROR: copying PE ptr %p (%d bytes)&bslash;n&quot;
comma
id|pep
comma
r_sizeof
(paren
id|size
)paren
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|lv_ptr-&gt;u.lv_current_pe
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* correct the PE count in PVs */
r_for
c_loop
(paren
id|le
op_assign
l_int|0
suffix:semicolon
id|le
OL
id|lv_ptr-&gt;u.lv_allocated_le
suffix:semicolon
id|le
op_increment
)paren
(brace
id|vg_ptr-&gt;pe_allocated
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_cur
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pv_dev
comma
id|lv_ptr-&gt;u.lv_current_pe
(braket
id|le
)braket
dot
id|dev
)paren
)paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pe_allocated
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Get snapshot exception data and block list */
r_if
c_cond
(paren
id|lvbe
op_ne
l_int|NULL
)paren
(brace
id|lv_ptr-&gt;u.lv_snapshot_org
op_assign
id|vg_ptr-&gt;lv
(braket
id|LV_BLK
c_func
(paren
id|lv_ptr-&gt;u.lv_snapshot_minor
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_snapshot_org
op_ne
l_int|NULL
)paren
(brace
id|size
op_assign
id|lv_ptr-&gt;u.lv_remap_end
op_star
r_sizeof
(paren
id|lv_block_exception_t
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s -- zero length exception table requested&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|lv_ptr-&gt;u.lv_block_exception
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- lvm_do_lv_create: vmalloc error LV_BLOCK_EXCEPTION &quot;
l_string|&quot;of %d byte at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|size
comma
id|__LINE__
)paren
suffix:semicolon
id|P_KFREE
c_func
(paren
l_string|&quot;%s -- kfree %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|lv_ptr-&gt;u.lv_block_exception
comma
id|lvbe
comma
id|size
)paren
)paren
(brace
id|vfree
c_func
(paren
id|lv_ptr-&gt;u.lv_block_exception
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_block_exception
(braket
l_int|0
)braket
dot
id|rsector_org
op_eq
id|LVM_SNAPSHOT_DROPPED_SECTOR
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s -- lvm_do_lv_create: snapshot has been dropped and will not be activated&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
id|activate
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* point to the original logical volume */
id|lv_ptr
op_assign
id|lv_ptr-&gt;u.lv_snapshot_org
suffix:semicolon
id|lv_ptr-&gt;u.lv_snapshot_minor
op_assign
l_int|0
suffix:semicolon
id|lv_ptr-&gt;u.lv_snapshot_org
op_assign
id|lv_ptr
suffix:semicolon
multiline_comment|/* our new one now back points to the previous last in the chain&n;&t;&t;&t;&t;   which can be the original logical volume */
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
suffix:semicolon
multiline_comment|/* now lv_ptr points to our new last snapshot logical volume */
id|lv_ptr-&gt;u.lv_current_pe
op_assign
id|lv_ptr-&gt;u.lv_snapshot_org-&gt;u.lv_current_pe
suffix:semicolon
id|lv_ptr-&gt;lv_allocated_snapshot_le
op_assign
id|lv_ptr-&gt;u.lv_allocated_le
suffix:semicolon
id|lv_ptr-&gt;u.lv_allocated_le
op_assign
id|lv_ptr-&gt;u.lv_snapshot_org-&gt;u.lv_allocated_le
suffix:semicolon
id|lv_ptr-&gt;u.lv_current_le
op_assign
id|lv_ptr-&gt;u.lv_snapshot_org-&gt;u.lv_current_le
suffix:semicolon
id|lv_ptr-&gt;u.lv_size
op_assign
id|lv_ptr-&gt;u.lv_snapshot_org-&gt;u.lv_size
suffix:semicolon
id|lv_ptr-&gt;u.lv_stripes
op_assign
id|lv_ptr-&gt;u.lv_snapshot_org-&gt;u.lv_stripes
suffix:semicolon
id|lv_ptr-&gt;u.lv_stripesize
op_assign
id|lv_ptr-&gt;u.lv_snapshot_org-&gt;u.lv_stripesize
suffix:semicolon
multiline_comment|/* Update the VG PE(s) used by snapshot reserve space. */
id|vg_ptr-&gt;pe_allocated
op_add_assign
id|lv_ptr-&gt;lv_allocated_snapshot_le
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|lvm_snapshot_alloc
c_func
(paren
id|lv_ptr
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|vfree
c_func
(paren
id|lv_ptr-&gt;u.lv_block_exception
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_for
c_loop
(paren
id|e
op_assign
l_int|0
suffix:semicolon
id|e
OL
id|lv_ptr-&gt;u.lv_remap_ptr
suffix:semicolon
id|e
op_increment
)paren
id|lvm_hash_link
(paren
id|lv_ptr-&gt;u.lv_block_exception
op_plus
id|e
comma
id|lv_ptr-&gt;u.lv_block_exception
(braket
id|e
)braket
dot
id|rdev_org
comma
id|lv_ptr-&gt;u.lv_block_exception
(braket
id|e
)braket
dot
id|rsector_org
comma
id|lv_ptr
)paren
suffix:semicolon
multiline_comment|/* need to fill the COW exception table data&n;&t;&t;&t;&t;   into the page for disk i/o */
r_if
c_cond
(paren
id|lvm_snapshot_fill_COW_page
c_func
(paren
id|vg_ptr
comma
id|lv_ptr
)paren
)paren
(brace
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|init_waitqueue_head
c_func
(paren
op_amp
id|lv_ptr-&gt;lv_snapshot_wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_else
(brace
id|kfree
c_func
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* if ( vg[VG_CHR(minor)]-&gt;lv[l]-&gt;u.lv_access &amp; LV_SNAPSHOT) */
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
suffix:semicolon
id|lvm_gendisk.part
(braket
id|minor
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|lvm_gendisk.part
(braket
id|minor
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
)braket
dot
id|nr_sects
op_assign
id|lv_ptr-&gt;u.lv_size
suffix:semicolon
id|lvm_size
(braket
id|minor
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
)braket
op_assign
id|lv_ptr-&gt;u.lv_size
op_rshift
l_int|1
suffix:semicolon
id|vg_lv_map
(braket
id|minor
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
)braket
dot
id|vg_number
op_assign
id|vg_ptr-&gt;vg_number
suffix:semicolon
id|vg_lv_map
(braket
id|minor
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
)braket
dot
id|lv_number
op_assign
id|lv_ptr-&gt;u.lv_number
suffix:semicolon
id|LVM_CORRECT_READ_AHEAD
c_func
(paren
id|lv_ptr-&gt;u.lv_read_ahead
)paren
suffix:semicolon
id|vg_ptr-&gt;lv_cur
op_increment
suffix:semicolon
id|lv_ptr-&gt;u.lv_status
op_assign
id|lv_status_save
suffix:semicolon
id|__update_hardsectsize
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
multiline_comment|/* optionally add our new snapshot LV */
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
id|lv_t
op_star
id|org
op_assign
id|lv_ptr-&gt;u.lv_snapshot_org
comma
op_star
id|last
suffix:semicolon
multiline_comment|/* sync the original logical volume */
id|fsync_dev
c_func
(paren
id|org-&gt;u.lv_dev
)paren
suffix:semicolon
macro_line|#ifdef&t;LVM_VFS_ENHANCEMENT
multiline_comment|/* VFS function call to sync and lock the filesystem */
id|fsync_dev_lockfs
c_func
(paren
id|org-&gt;u.lv_dev
)paren
suffix:semicolon
macro_line|#endif
id|down_write
c_func
(paren
op_amp
id|org-&gt;lv_lock
)paren
suffix:semicolon
id|org-&gt;u.lv_access
op_or_assign
id|LV_SNAPSHOT_ORG
suffix:semicolon
id|lv_ptr-&gt;u.lv_access
op_and_assign
op_complement
id|LV_SNAPSHOT_ORG
suffix:semicolon
multiline_comment|/* this can only hide an userspace bug */
multiline_comment|/* Link in the list of snapshot volumes */
r_for
c_loop
(paren
id|last
op_assign
id|org
suffix:semicolon
id|last-&gt;u.lv_snapshot_next
suffix:semicolon
id|last
op_assign
id|last-&gt;u.lv_snapshot_next
)paren
suffix:semicolon
id|lv_ptr-&gt;u.lv_snapshot_prev
op_assign
id|last
suffix:semicolon
id|last-&gt;u.lv_snapshot_next
op_assign
id|lv_ptr
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|org-&gt;lv_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* activate the logical volume */
r_if
c_cond
(paren
id|activate
)paren
(brace
id|lv_ptr-&gt;u.lv_status
op_or_assign
id|LV_ACTIVE
suffix:semicolon
)brace
r_else
id|lv_ptr-&gt;u.lv_status
op_and_assign
op_complement
id|LV_ACTIVE
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_access
op_amp
id|LV_WRITE
)paren
id|set_device_ro
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
comma
l_int|0
)paren
suffix:semicolon
r_else
id|set_device_ro
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef&t;LVM_VFS_ENHANCEMENT
multiline_comment|/* VFS function call to unlock the filesystem */
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
id|unlockfs
c_func
(paren
id|lv_ptr-&gt;u.lv_snapshot_org-&gt;u.lv_dev
)paren
suffix:semicolon
macro_line|#endif
id|lv_ptr-&gt;vg
op_assign
id|vg_ptr
suffix:semicolon
id|lvm_gendisk.part
(braket
id|minor
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
)braket
dot
id|de
op_assign
id|lvm_fs_create_lv
c_func
(paren
id|vg_ptr
comma
id|lv_ptr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_create() */
multiline_comment|/*&n; * character device support function logical volume remove&n; */
DECL|function|lvm_do_lv_remove
r_static
r_int
id|lvm_do_lv_remove
c_func
(paren
r_int
id|minor
comma
r_char
op_star
id|lv_name
comma
r_int
id|l
)paren
(brace
id|uint
id|le
comma
id|p
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
op_minus
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_member_access_from_pointer
id|u.lv_name
comma
id|lv_name
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|l
op_eq
id|vg_ptr-&gt;lv_max
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
suffix:semicolon
macro_line|#ifdef LVM_TOTAL_RESET
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_open
OG
l_int|0
op_logical_and
id|lvm_reset_spindown
op_eq
l_int|0
)paren
macro_line|#else
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_open
OG
l_int|0
)paren
macro_line|#endif
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* check for deletion of snapshot source while&n;&t;   snapshot volume still exists */
r_if
c_cond
(paren
(paren
id|lv_ptr-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT_ORG
)paren
op_logical_and
id|lv_ptr-&gt;u.lv_snapshot_next
op_ne
l_int|NULL
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|lvm_fs_remove_lv
c_func
(paren
id|vg_ptr
comma
id|lv_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
multiline_comment|/*&n;&t;&t; * Atomically make the the snapshot invisible&n;&t;&t; * to the original lv before playing with it.&n;&t;&t; */
id|lv_t
op_star
id|org
op_assign
id|lv_ptr-&gt;u.lv_snapshot_org
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|org-&gt;lv_lock
)paren
suffix:semicolon
multiline_comment|/* remove this snapshot logical volume from the chain */
id|lv_ptr-&gt;u.lv_snapshot_prev-&gt;u.lv_snapshot_next
op_assign
id|lv_ptr-&gt;u.lv_snapshot_next
suffix:semicolon
r_if
c_cond
(paren
id|lv_ptr-&gt;u.lv_snapshot_next
op_ne
l_int|NULL
)paren
(brace
id|lv_ptr-&gt;u.lv_snapshot_next-&gt;u.lv_snapshot_prev
op_assign
id|lv_ptr-&gt;u.lv_snapshot_prev
suffix:semicolon
)brace
multiline_comment|/* no more snapshots? */
r_if
c_cond
(paren
op_logical_neg
id|org-&gt;u.lv_snapshot_next
)paren
(brace
id|org-&gt;u.lv_access
op_and_assign
op_complement
id|LV_SNAPSHOT_ORG
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|org-&gt;lv_lock
)paren
suffix:semicolon
id|lvm_snapshot_release
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
multiline_comment|/* Update the VG PE(s) used by snapshot reserve space. */
id|vg_ptr-&gt;pe_allocated
op_sub_assign
id|lv_ptr-&gt;lv_allocated_snapshot_le
suffix:semicolon
)brace
id|lv_ptr-&gt;u.lv_status
op_or_assign
id|LV_SPINDOWN
suffix:semicolon
multiline_comment|/* sync the buffers */
id|fsync_dev
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
suffix:semicolon
id|lv_ptr-&gt;u.lv_status
op_and_assign
op_complement
id|LV_ACTIVE
suffix:semicolon
multiline_comment|/* invalidate the buffers */
id|invalidate_buffers
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
suffix:semicolon
multiline_comment|/* reset generic hd */
id|lvm_gendisk.part
(braket
id|minor
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
)braket
dot
id|start_sect
op_assign
op_minus
l_int|1
suffix:semicolon
id|lvm_gendisk.part
(braket
id|minor
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
id|lvm_gendisk.part
(braket
id|minor
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
)braket
dot
id|de
op_assign
l_int|0
suffix:semicolon
id|lvm_size
(braket
id|minor
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset VG/LV mapping */
id|vg_lv_map
(braket
id|minor
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
)braket
dot
id|vg_number
op_assign
id|ABS_MAX_VG
suffix:semicolon
id|vg_lv_map
(braket
id|minor
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
)paren
)braket
dot
id|lv_number
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* correct the PE count in PVs if this is not a snapshot&n;           logical volume */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lv_ptr-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
)paren
(brace
multiline_comment|/* only if this is no snapshot logical volume because&n;&t;&t;   we share the u.lv_current_pe[] structs with the&n;&t;&t;   original logical volume */
r_for
c_loop
(paren
id|le
op_assign
l_int|0
suffix:semicolon
id|le
OL
id|lv_ptr-&gt;u.lv_allocated_le
suffix:semicolon
id|le
op_increment
)paren
(brace
id|vg_ptr-&gt;pe_allocated
op_decrement
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_cur
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pv_dev
comma
id|lv_ptr-&gt;u.lv_current_pe
(braket
id|le
)braket
dot
id|dev
)paren
)paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pe_allocated
op_decrement
suffix:semicolon
)brace
)brace
id|vfree
c_func
(paren
id|lv_ptr-&gt;u.lv_current_pe
)paren
suffix:semicolon
)brace
id|P_KFREE
c_func
(paren
l_string|&quot;%s -- kfree %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lv_ptr
)paren
suffix:semicolon
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_assign
l_int|NULL
suffix:semicolon
id|vg_ptr-&gt;lv_cur
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_remove() */
multiline_comment|/*&n; * logical volume extend / reduce&n; */
DECL|function|__extend_reduce_snapshot
r_static
r_int
id|__extend_reduce_snapshot
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
id|lv_t
op_star
id|old_lv
comma
id|lv_t
op_star
id|new_lv
)paren
(brace
id|ulong
id|size
suffix:semicolon
id|lv_block_exception_t
op_star
id|lvbe
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_lv-&gt;u.lv_block_exception
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|size
op_assign
id|new_lv-&gt;u.lv_remap_end
op_star
r_sizeof
(paren
id|lv_block_exception_t
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lvbe
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- lvm_do_lv_extend_reduce: vmalloc &quot;
l_string|&quot;error LV_BLOCK_EXCEPTION of %lu Byte at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|size
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|new_lv-&gt;u.lv_remap_end
OG
id|old_lv-&gt;u.lv_remap_end
)paren
op_logical_and
(paren
id|copy_from_user
c_func
(paren
id|lvbe
comma
id|new_lv-&gt;u.lv_block_exception
comma
id|size
)paren
)paren
)paren
(brace
id|vfree
c_func
(paren
id|lvbe
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|new_lv-&gt;u.lv_block_exception
op_assign
id|lvbe
suffix:semicolon
r_if
c_cond
(paren
id|lvm_snapshot_alloc_hash_table
c_func
(paren
id|new_lv
)paren
)paren
(brace
id|vfree
c_func
(paren
id|new_lv-&gt;u.lv_block_exception
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__extend_reduce
r_static
r_int
id|__extend_reduce
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
id|lv_t
op_star
id|old_lv
comma
id|lv_t
op_star
id|new_lv
)paren
(brace
id|ulong
id|size
comma
id|l
comma
id|p
comma
id|end
suffix:semicolon
id|pe_t
op_star
id|pe
suffix:semicolon
multiline_comment|/* allocate space for new pe structures */
id|size
op_assign
id|new_lv-&gt;u.lv_current_le
op_star
r_sizeof
(paren
id|pe_t
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pe
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- lvm_do_lv_extend_reduce: &quot;
l_string|&quot;vmalloc error LV_CURRENT_PE of %lu Byte at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|size
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* get the PE structures from user space */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|pe
comma
id|new_lv-&gt;u.lv_current_pe
comma
id|size
)paren
)paren
(brace
r_if
c_cond
(paren
id|old_lv-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
id|vfree
c_func
(paren
id|new_lv-&gt;lv_snapshot_hash_table
)paren
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|pe
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|new_lv-&gt;u.lv_current_pe
op_assign
id|pe
suffix:semicolon
multiline_comment|/* reduce allocation counters on PV(s) */
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|old_lv-&gt;u.lv_allocated_le
suffix:semicolon
id|l
op_increment
)paren
(brace
id|vg_ptr-&gt;pe_allocated
op_decrement
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_cur
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pv_dev
comma
id|old_lv-&gt;u.lv_current_pe
(braket
id|l
)braket
dot
id|dev
)paren
)paren
(brace
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pe_allocated
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* extend the PE count in PVs */
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|new_lv-&gt;u.lv_allocated_le
suffix:semicolon
id|l
op_increment
)paren
(brace
id|vg_ptr-&gt;pe_allocated
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_cur
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pv_dev
comma
id|new_lv-&gt;u.lv_current_pe
(braket
id|l
)braket
dot
id|dev
)paren
)paren
(brace
id|vg_ptr-&gt;pv
(braket
id|p
)braket
op_member_access_from_pointer
id|pe_allocated
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* save availiable i/o statistic data */
r_if
c_cond
(paren
id|old_lv-&gt;u.lv_stripes
OL
l_int|2
)paren
(brace
multiline_comment|/* linear logical volume */
id|end
op_assign
id|min
c_func
(paren
id|old_lv-&gt;u.lv_current_le
comma
id|new_lv-&gt;u.lv_current_le
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|end
suffix:semicolon
id|l
op_increment
)paren
(brace
id|new_lv-&gt;u.lv_current_pe
(braket
id|l
)braket
dot
id|reads
op_add_assign
id|old_lv-&gt;u.lv_current_pe
(braket
id|l
)braket
dot
id|reads
suffix:semicolon
id|new_lv-&gt;u.lv_current_pe
(braket
id|l
)braket
dot
id|writes
op_add_assign
id|old_lv-&gt;u.lv_current_pe
(braket
id|l
)braket
dot
id|writes
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* striped logical volume */
id|uint
id|i
comma
id|j
comma
id|source
comma
id|dest
comma
id|end
comma
id|old_stripe_size
comma
id|new_stripe_size
suffix:semicolon
id|old_stripe_size
op_assign
id|old_lv-&gt;u.lv_allocated_le
op_div
id|old_lv-&gt;u.lv_stripes
suffix:semicolon
id|new_stripe_size
op_assign
id|new_lv-&gt;u.lv_allocated_le
op_div
id|new_lv-&gt;u.lv_stripes
suffix:semicolon
id|end
op_assign
id|min
c_func
(paren
id|old_stripe_size
comma
id|new_stripe_size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|source
op_assign
id|dest
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|new_lv-&gt;u.lv_stripes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|end
suffix:semicolon
id|j
op_increment
)paren
(brace
id|new_lv-&gt;u.lv_current_pe
(braket
id|dest
op_plus
id|j
)braket
dot
id|reads
op_add_assign
id|old_lv-&gt;u.lv_current_pe
(braket
id|source
op_plus
id|j
)braket
dot
id|reads
suffix:semicolon
id|new_lv-&gt;u.lv_current_pe
(braket
id|dest
op_plus
id|j
)braket
dot
id|writes
op_add_assign
id|old_lv-&gt;u.lv_current_pe
(braket
id|source
op_plus
id|j
)braket
dot
id|writes
suffix:semicolon
)brace
id|source
op_add_assign
id|old_stripe_size
suffix:semicolon
id|dest
op_add_assign
id|new_stripe_size
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lvm_do_lv_extend_reduce
r_static
r_int
id|lvm_do_lv_extend_reduce
c_func
(paren
r_int
id|minor
comma
r_char
op_star
id|lv_name
comma
id|userlv_t
op_star
id|ulv
)paren
(brace
r_int
id|r
suffix:semicolon
id|ulong
id|l
comma
id|e
comma
id|size
suffix:semicolon
id|vg_t
op_star
id|vg_ptr
op_assign
id|vg
(braket
id|VG_CHR
c_func
(paren
id|minor
)paren
)braket
suffix:semicolon
id|lv_t
op_star
id|old_lv
suffix:semicolon
id|lv_t
op_star
id|new_lv
suffix:semicolon
id|pe_t
op_star
id|pe
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_lv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|lv_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s -- LV_EXTEND/REDUCE: kmallor error LV at line %d&bslash;n&quot;
comma
id|lvm_name
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|new_lv
comma
l_int|0
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|new_lv-&gt;u
comma
id|ulv
comma
r_sizeof
(paren
id|userlv_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pe
op_assign
id|new_lv-&gt;u.lv_current_pe
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_member_access_from_pointer
id|u.lv_name
comma
id|lv_name
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
id|vg_ptr-&gt;lv_max
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|old_lv
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
suffix:semicolon
r_if
c_cond
(paren
id|old_lv-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
multiline_comment|/* only perform this operation on active snapshots */
r_if
c_cond
(paren
id|old_lv-&gt;u.lv_status
op_amp
id|LV_ACTIVE
)paren
id|r
op_assign
id|__extend_reduce_snapshot
c_func
(paren
id|vg_ptr
comma
id|old_lv
comma
id|new_lv
)paren
suffix:semicolon
r_else
id|r
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
id|r
op_assign
id|__extend_reduce
c_func
(paren
id|vg_ptr
comma
id|old_lv
comma
id|new_lv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* copy relevent fields */
id|down_write
c_func
(paren
op_amp
id|old_lv-&gt;lv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_lv-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT
)paren
(brace
id|size
op_assign
(paren
id|new_lv-&gt;u.lv_remap_end
OG
id|old_lv-&gt;u.lv_remap_end
)paren
ques
c_cond
id|old_lv-&gt;u.lv_remap_ptr
suffix:colon
id|new_lv-&gt;u.lv_remap_end
suffix:semicolon
id|size
op_mul_assign
r_sizeof
(paren
id|lv_block_exception_t
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_lv-&gt;u.lv_block_exception
comma
id|old_lv-&gt;u.lv_block_exception
comma
id|size
)paren
suffix:semicolon
id|old_lv-&gt;u.lv_remap_end
op_assign
id|new_lv-&gt;u.lv_remap_end
suffix:semicolon
id|old_lv-&gt;u.lv_block_exception
op_assign
id|new_lv-&gt;u.lv_block_exception
suffix:semicolon
id|old_lv-&gt;lv_snapshot_hash_table
op_assign
id|new_lv-&gt;lv_snapshot_hash_table
suffix:semicolon
id|old_lv-&gt;lv_snapshot_hash_table_size
op_assign
id|new_lv-&gt;lv_snapshot_hash_table_size
suffix:semicolon
id|old_lv-&gt;lv_snapshot_hash_mask
op_assign
id|new_lv-&gt;lv_snapshot_hash_mask
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
l_int|0
suffix:semicolon
id|e
OL
id|new_lv-&gt;u.lv_remap_ptr
suffix:semicolon
id|e
op_increment
)paren
id|lvm_hash_link
c_func
(paren
id|new_lv-&gt;u.lv_block_exception
op_plus
id|e
comma
id|new_lv-&gt;u.lv_block_exception
(braket
id|e
)braket
dot
id|rdev_org
comma
id|new_lv-&gt;u.lv_block_exception
(braket
id|e
)braket
dot
id|rsector_org
comma
id|new_lv
)paren
suffix:semicolon
)brace
r_else
(brace
id|vfree
c_func
(paren
id|old_lv-&gt;u.lv_current_pe
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|old_lv-&gt;lv_snapshot_hash_table
)paren
suffix:semicolon
id|old_lv-&gt;u.lv_size
op_assign
id|new_lv-&gt;u.lv_size
suffix:semicolon
id|old_lv-&gt;u.lv_allocated_le
op_assign
id|new_lv-&gt;u.lv_allocated_le
suffix:semicolon
id|old_lv-&gt;u.lv_current_le
op_assign
id|new_lv-&gt;u.lv_current_le
suffix:semicolon
id|old_lv-&gt;u.lv_current_pe
op_assign
id|new_lv-&gt;u.lv_current_pe
suffix:semicolon
id|lvm_gendisk.part
(braket
id|minor
c_func
(paren
id|old_lv-&gt;u.lv_dev
)paren
)braket
dot
id|nr_sects
op_assign
id|old_lv-&gt;u.lv_size
suffix:semicolon
id|lvm_size
(braket
id|minor
c_func
(paren
id|old_lv-&gt;u.lv_dev
)paren
)braket
op_assign
id|old_lv-&gt;u.lv_size
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|old_lv-&gt;u.lv_access
op_amp
id|LV_SNAPSHOT_ORG
)paren
(brace
id|lv_t
op_star
id|snap
suffix:semicolon
r_for
c_loop
(paren
id|snap
op_assign
id|old_lv-&gt;u.lv_snapshot_next
suffix:semicolon
id|snap
suffix:semicolon
id|snap
op_assign
id|snap-&gt;u.lv_snapshot_next
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|snap-&gt;lv_lock
)paren
suffix:semicolon
id|snap-&gt;u.lv_current_pe
op_assign
id|old_lv-&gt;u.lv_current_pe
suffix:semicolon
id|snap-&gt;u.lv_allocated_le
op_assign
id|old_lv-&gt;u.lv_allocated_le
suffix:semicolon
id|snap-&gt;u.lv_current_le
op_assign
id|old_lv-&gt;u.lv_current_le
suffix:semicolon
id|snap-&gt;u.lv_size
op_assign
id|old_lv-&gt;u.lv_size
suffix:semicolon
id|lvm_gendisk.part
(braket
id|minor
c_func
(paren
id|snap-&gt;u.lv_dev
)paren
)braket
dot
id|nr_sects
op_assign
id|old_lv-&gt;u.lv_size
suffix:semicolon
id|lvm_size
(braket
id|minor
c_func
(paren
id|snap-&gt;u.lv_dev
)paren
)braket
op_assign
id|old_lv-&gt;u.lv_size
op_rshift
l_int|1
suffix:semicolon
id|__update_hardsectsize
c_func
(paren
id|snap
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|snap-&gt;lv_lock
)paren
suffix:semicolon
)brace
)brace
)brace
id|__update_hardsectsize
c_func
(paren
id|old_lv
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|old_lv-&gt;lv_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_extend_reduce() */
multiline_comment|/*&n; * character device support function logical volume status by name&n; */
DECL|function|lvm_do_lv_status_byname
r_static
r_int
id|lvm_do_lv_status_byname
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|uint
id|l
suffix:semicolon
id|lv_status_byname_req_t
id|lv_status_byname_req
suffix:semicolon
r_void
op_star
id|saved_ptr1
suffix:semicolon
r_void
op_star
id|saved_ptr2
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv_status_byname_req
comma
id|arg
comma
r_sizeof
(paren
id|lv_status_byname_req_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|lv_status_byname_req.lv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|lv_ptr-&gt;u.lv_name
comma
id|lv_status_byname_req.lv_name
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Save usermode pointers */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|saved_ptr1
comma
op_amp
id|lv_status_byname_req.lv-&gt;u.lv_current_pe
comma
r_sizeof
(paren
r_void
op_star
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|saved_ptr2
comma
op_amp
id|lv_status_byname_req.lv-&gt;u.lv_block_exception
comma
r_sizeof
(paren
r_void
op_star
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|lv_status_byname_req.lv
comma
id|lv_ptr
comma
r_sizeof
(paren
id|userlv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|saved_ptr1
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|saved_ptr1
comma
id|lv_ptr-&gt;u.lv_current_pe
comma
id|lv_ptr-&gt;u.lv_allocated_le
op_star
r_sizeof
(paren
id|pe_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* Restore usermode pointers */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
op_amp
id|lv_status_byname_req.lv-&gt;u.lv_current_pe
comma
op_amp
id|saved_ptr1
comma
r_sizeof
(paren
r_void
op_star
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_status_byname() */
multiline_comment|/*&n; * character device support function logical volume status by index&n; */
DECL|function|lvm_do_lv_status_byindex
r_static
r_int
id|lvm_do_lv_status_byindex
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|lv_status_byindex_req_t
id|lv_status_byindex_req
suffix:semicolon
r_void
op_star
id|saved_ptr1
suffix:semicolon
r_void
op_star
id|saved_ptr2
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv_status_byindex_req
comma
id|arg
comma
r_sizeof
(paren
id|lv_status_byindex_req
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|lv_status_byindex_req.lv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|lv_status_byindex_req.lv_index
OL
l_int|0
op_logical_or
id|lv_status_byindex_req.lv_index
op_ge
id|MAX_LV
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|lv_status_byindex_req.lv_index
)braket
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* Save usermode pointers */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|saved_ptr1
comma
op_amp
id|lv_status_byindex_req.lv-&gt;u.lv_current_pe
comma
r_sizeof
(paren
r_void
op_star
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|saved_ptr2
comma
op_amp
id|lv_status_byindex_req.lv-&gt;u.lv_block_exception
comma
r_sizeof
(paren
r_void
op_star
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|lv_status_byindex_req.lv
comma
id|lv_ptr
comma
r_sizeof
(paren
id|userlv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|saved_ptr1
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|saved_ptr1
comma
id|lv_ptr-&gt;u.lv_current_pe
comma
id|lv_ptr-&gt;u.lv_allocated_le
op_star
r_sizeof
(paren
id|pe_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* Restore usermode pointers */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
op_amp
id|lv_status_byindex_req.lv-&gt;u.lv_current_pe
comma
op_amp
id|saved_ptr1
comma
r_sizeof
(paren
r_void
op_star
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_status_byindex() */
multiline_comment|/*&n; * character device support function logical volume status by device number&n; */
DECL|function|lvm_do_lv_status_bydev
r_static
r_int
id|lvm_do_lv_status_bydev
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|l
suffix:semicolon
id|lv_status_bydev_req_t
id|lv_status_bydev_req
suffix:semicolon
r_void
op_star
id|saved_ptr1
suffix:semicolon
r_void
op_star
id|saved_ptr2
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lv_status_bydev_req
comma
id|arg
comma
r_sizeof
(paren
id|lv_status_bydev_req
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|vg_ptr-&gt;lv
(braket
id|l
)braket
op_member_access_from_pointer
id|u.lv_dev
comma
id|to_kdev_t
c_func
(paren
id|lv_status_bydev_req.dev
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|l
op_eq
id|vg_ptr-&gt;lv_max
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
suffix:semicolon
multiline_comment|/* Save usermode pointers */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|saved_ptr1
comma
op_amp
id|lv_status_bydev_req.lv-&gt;u.lv_current_pe
comma
r_sizeof
(paren
r_void
op_star
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|saved_ptr2
comma
op_amp
id|lv_status_bydev_req.lv-&gt;u.lv_block_exception
comma
r_sizeof
(paren
r_void
op_star
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|lv_status_bydev_req.lv
comma
id|lv_ptr
comma
r_sizeof
(paren
id|lv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|saved_ptr1
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|saved_ptr1
comma
id|lv_ptr-&gt;u.lv_current_pe
comma
id|lv_ptr-&gt;u.lv_allocated_le
op_star
r_sizeof
(paren
id|pe_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* Restore usermode pointers */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
op_amp
id|lv_status_bydev_req.lv-&gt;u.lv_current_pe
comma
op_amp
id|saved_ptr1
comma
r_sizeof
(paren
r_void
op_star
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_status_bydev() */
multiline_comment|/*&n; * character device support function rename a logical volume&n; */
DECL|function|lvm_do_lv_rename
r_static
r_int
id|lvm_do_lv_rename
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
id|lv_req_t
op_star
id|lv_req
comma
id|userlv_t
op_star
id|ulv
)paren
(brace
r_int
id|l
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|lv_t
op_star
id|lv_ptr
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|vg_ptr-&gt;lv_max
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|lv_ptr
op_assign
id|vg_ptr-&gt;lv
(braket
id|l
)braket
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|kdev_same
c_func
(paren
id|lv_ptr-&gt;u.lv_dev
comma
id|ulv-&gt;lv_dev
)paren
)paren
(brace
id|lvm_fs_remove_lv
c_func
(paren
id|vg_ptr
comma
id|lv_ptr
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|lv_ptr-&gt;u.lv_name
comma
id|lv_req-&gt;lv_name
comma
id|NAME_LEN
)paren
suffix:semicolon
id|lvm_fs_create_lv
c_func
(paren
id|vg_ptr
comma
id|lv_ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|l
op_eq
id|vg_ptr-&gt;lv_max
)paren
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* lvm_do_lv_rename */
multiline_comment|/*&n; * character device support function physical volume change&n; */
DECL|function|lvm_do_pv_change
r_static
r_int
id|lvm_do_pv_change
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|uint
id|p
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
r_struct
id|block_device
op_star
id|bd
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|pv_change_req
comma
id|arg
comma
r_sizeof
(paren
id|pv_change_req
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pv_ptr
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|pv_ptr-&gt;pv_name
comma
id|pv_change_req.pv_name
)paren
op_eq
l_int|0
)paren
(brace
id|bd
op_assign
id|pv_ptr-&gt;bd
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|pv_ptr
comma
id|pv_change_req.pv
comma
r_sizeof
(paren
id|pv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|pv_ptr-&gt;bd
op_assign
id|bd
suffix:semicolon
multiline_comment|/* We don&squot;t need the PE list&n;&t;&t;&t;   in kernel space as with LVs pe_t list */
id|pv_ptr-&gt;pe
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* lvm_do_pv_change() */
multiline_comment|/*&n; * character device support function get physical volume status&n; */
DECL|function|lvm_do_pv_status
r_static
r_int
id|lvm_do_pv_status
c_func
(paren
id|vg_t
op_star
id|vg_ptr
comma
r_void
op_star
id|arg
)paren
(brace
id|uint
id|p
suffix:semicolon
id|pv_t
op_star
id|pv_ptr
suffix:semicolon
r_if
c_cond
(paren
id|vg_ptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|pv_status_req
comma
id|arg
comma
r_sizeof
(paren
id|pv_status_req
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|vg_ptr-&gt;pv_max
suffix:semicolon
id|p
op_increment
)paren
(brace
id|pv_ptr
op_assign
id|vg_ptr-&gt;pv
(braket
id|p
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pv_ptr
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|pv_ptr-&gt;pv_name
comma
id|pv_status_req.pv_name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|pv_status_req.pv
comma
id|pv_ptr
comma
r_sizeof
(paren
id|pv_t
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* lvm_do_pv_status() */
multiline_comment|/*&n; * character device support function flush and invalidate all buffers of a PV&n; */
DECL|function|lvm_do_pv_flush
r_static
r_int
id|lvm_do_pv_flush
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
id|pv_flush_req_t
id|pv_flush_req
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|pv_flush_req
comma
id|arg
comma
r_sizeof
(paren
id|pv_flush_req
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|fsync_dev
c_func
(paren
id|pv_flush_req.pv_dev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|pv_flush_req.pv_dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * support function initialize gendisk variables&n; */
DECL|function|lvm_geninit
r_static
r_void
id|__init
id|lvm_geninit
c_func
(paren
r_struct
id|gendisk
op_star
id|lvm_gdisk
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_GENDISK
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s -- lvm_gendisk&bslash;n&quot;
comma
id|lvm_name
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_LV
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lvm_gendisk.part
(braket
id|i
)braket
dot
id|start_sect
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* avoid partition check */
id|lvm_size
(braket
id|i
)braket
op_assign
id|lvm_gendisk.part
(braket
id|i
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
id|lvm_blocksizes
(braket
id|i
)braket
op_assign
id|BLOCK_SIZE
suffix:semicolon
)brace
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|lvm_size
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|lvm_blocksizes
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* lvm_gen_init() */
multiline_comment|/* Must have down_write(_pe_lock) when we enqueue buffers */
DECL|function|_queue_io
r_static
r_void
id|_queue_io
c_func
(paren
r_struct
id|bio
op_star
id|bh
comma
r_int
id|rw
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;bi_next
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|bh-&gt;bi_next
op_assign
id|_pe_requests
suffix:semicolon
id|_pe_requests
op_assign
id|bh
suffix:semicolon
)brace
multiline_comment|/* Must have down_write(_pe_lock) when we dequeue buffers */
DECL|function|_dequeue_io
r_static
r_struct
id|bio
op_star
id|_dequeue_io
c_func
(paren
r_void
)paren
(brace
r_struct
id|bio
op_star
id|bh
op_assign
id|_pe_requests
suffix:semicolon
id|_pe_requests
op_assign
l_int|NULL
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
multiline_comment|/*&n; * We do not need to hold _pe_lock to flush buffers.  bh should be taken from&n; * _pe_requests under down_write(_pe_lock), and then _pe_requests can be set&n; * NULL and we drop _pe_lock.  Any new buffers defered at this time will be&n; * added to a new list, and the old buffers can have their I/O restarted&n; * asynchronously.&n; *&n; * If, for some reason, the same PE is locked again before all of these writes&n; * have finished, then these buffers will just be re-queued (i.e. no danger).&n; */
DECL|function|_flush_io
r_static
r_void
id|_flush_io
c_func
(paren
r_struct
id|bio
op_star
id|bh
)paren
(brace
r_while
c_loop
(paren
id|bh
)paren
(brace
r_struct
id|bio
op_star
id|next
op_assign
id|bh-&gt;bi_next
suffix:semicolon
id|bh-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* resubmit this buffer head */
id|bh-&gt;bi_rw
op_assign
id|WRITE
suffix:semicolon
multiline_comment|/* needed? */
id|generic_make_request
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * we must open the pv&squot;s before we use them&n; */
DECL|function|_open_pv
r_static
r_int
id|_open_pv
c_func
(paren
id|pv_t
op_star
id|pv
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|block_device
op_star
id|bd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bd
op_assign
id|bdget
c_func
(paren
id|kdev_t_to_nr
c_func
(paren
id|pv-&gt;pv_dev
)paren
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|err
op_assign
id|blkdev_get
c_func
(paren
id|bd
comma
id|FMODE_READ
op_or
id|FMODE_WRITE
comma
l_int|0
comma
id|BDEV_FILE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|pv-&gt;bd
op_assign
id|bd
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|_close_pv
r_static
r_void
id|_close_pv
c_func
(paren
id|pv_t
op_star
id|pv
)paren
(brace
r_if
c_cond
(paren
id|pv
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
op_assign
id|pv-&gt;bd
suffix:semicolon
id|pv-&gt;bd
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|bdev
)paren
id|blkdev_put
c_func
(paren
id|bdev
comma
id|BDEV_FILE
)paren
suffix:semicolon
)brace
)brace
DECL|function|_sectors_to_k
r_static
r_int
r_int
id|_sectors_to_k
c_func
(paren
r_int
r_int
id|sect
)paren
(brace
r_if
c_cond
(paren
id|SECTOR_SIZE
OG
l_int|1024
)paren
(brace
r_return
id|sect
op_star
(paren
id|SECTOR_SIZE
op_div
l_int|1024
)paren
suffix:semicolon
)brace
r_return
id|sect
op_div
(paren
l_int|1024
op_div
id|SECTOR_SIZE
)paren
suffix:semicolon
)brace
DECL|variable|lvm_init
id|module_init
c_func
(paren
id|lvm_init
)paren
suffix:semicolon
DECL|variable|lvm_cleanup
id|module_exit
c_func
(paren
id|lvm_cleanup
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
