multiline_comment|/*&n; * raid1.c : Multiple Devices driver for Linux&n; *&n; * Copyright (C) 1999, 2000, 2001 Ingo Molnar, Red Hat&n; *&n; * Copyright (C) 1996, 1997, 1998 Ingo Molnar, Miguel de Icaza, Gadi Oxman&n; *&n; * RAID-1 management functions.&n; *&n; * Better read-balancing code written by Mika Kuoppala &lt;miku@iki.fi&gt;, 2000&n; *&n; * Fixes to reconstruction by Jakob &#xfffd;stergaard&quot; &lt;jakob@ostenfeld.dk&gt;&n; * Various fixes by Neil Brown &lt;neilb@cse.unsw.edu.au&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * You should have received a copy of the GNU General Public License&n; * (for example /usr/src/linux/COPYING); if not, write to the Free&n; * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/raid/raid1.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MD_MAJOR
DECL|macro|MD_DRIVER
mdefine_line|#define MD_DRIVER
DECL|macro|MD_PERSONALITY
mdefine_line|#define MD_PERSONALITY
multiline_comment|/*&n; * Number of guaranteed r1bios in case of extreme VM load:&n; */
DECL|macro|NR_RAID1_BIOS
mdefine_line|#define&t;NR_RAID1_BIOS 256
DECL|variable|raid1_personality
r_static
id|mdk_personality_t
id|raid1_personality
suffix:semicolon
DECL|variable|retry_list_lock
r_static
id|spinlock_t
id|retry_list_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|retry_list_head
)paren
suffix:semicolon
DECL|function|r1bio_pool_alloc
r_static
r_void
op_star
id|r1bio_pool_alloc
c_func
(paren
r_int
id|gfp_flags
comma
r_void
op_star
id|data
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|data
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
suffix:semicolon
multiline_comment|/* allocate a r1bio with room for raid_disks entries in the bios array */
id|r1_bio
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|r1bio_t
)paren
op_plus
r_sizeof
(paren
r_struct
id|bio
op_star
)paren
op_star
id|mddev-&gt;raid_disks
comma
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r1_bio
)paren
id|memset
c_func
(paren
id|r1_bio
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|r1_bio
)paren
op_plus
r_sizeof
(paren
r_struct
id|bio
op_star
)paren
op_star
id|mddev-&gt;raid_disks
)paren
suffix:semicolon
r_return
id|r1_bio
suffix:semicolon
)brace
DECL|function|r1bio_pool_free
r_static
r_void
id|r1bio_pool_free
c_func
(paren
r_void
op_star
id|r1_bio
comma
r_void
op_star
id|data
)paren
(brace
id|kfree
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
)brace
singleline_comment|//#define RESYNC_BLOCK_SIZE (64*1024)
DECL|macro|RESYNC_BLOCK_SIZE
mdefine_line|#define RESYNC_BLOCK_SIZE PAGE_SIZE
DECL|macro|RESYNC_SECTORS
mdefine_line|#define RESYNC_SECTORS (RESYNC_BLOCK_SIZE &gt;&gt; 9)
DECL|macro|RESYNC_PAGES
mdefine_line|#define RESYNC_PAGES ((RESYNC_BLOCK_SIZE + PAGE_SIZE-1) / PAGE_SIZE)
DECL|macro|RESYNC_WINDOW
mdefine_line|#define RESYNC_WINDOW (2048*1024)
DECL|function|r1buf_pool_alloc
r_static
r_void
op_star
id|r1buf_pool_alloc
c_func
(paren
r_int
id|gfp_flags
comma
r_void
op_star
id|data
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|data
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|r1_bio
op_assign
id|r1bio_pool_alloc
c_func
(paren
id|gfp_flags
comma
id|conf-&gt;mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r1_bio
)paren
r_return
l_int|NULL
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|gfp_flags
comma
id|RESYNC_PAGES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
r_goto
id|out_free_r1_bio
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate RESYNC_PAGES data pages for this iovec.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RESYNC_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|page
op_assign
id|alloc_page
c_func
(paren
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|page
)paren
)paren
r_goto
id|out_free_pages
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
op_assign
id|page
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_len
op_assign
id|PAGE_SIZE
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_offset
op_assign
l_int|0
suffix:semicolon
)brace
id|bio-&gt;bi_vcnt
op_assign
id|RESYNC_PAGES
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_assign
id|RESYNC_BLOCK_SIZE
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
l_int|NULL
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|bio-&gt;bi_cnt
comma
l_int|1
)paren
suffix:semicolon
id|r1_bio-&gt;master_bio
op_assign
id|bio
suffix:semicolon
r_return
id|r1_bio
suffix:semicolon
id|out_free_pages
suffix:colon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
id|__free_page
c_func
(paren
id|bio-&gt;bi_io_vec
(braket
id|j
)braket
dot
id|bv_page
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
id|out_free_r1_bio
suffix:colon
id|r1bio_pool_free
c_func
(paren
id|r1_bio
comma
id|conf-&gt;mddev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|r1buf_pool_free
r_static
r_void
id|r1buf_pool_free
c_func
(paren
r_void
op_star
id|__r1_bio
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|data
suffix:semicolon
id|r1bio_t
op_star
id|r1bio
op_assign
id|__r1_bio
suffix:semicolon
r_struct
id|bio
op_star
id|bio
op_assign
id|r1bio-&gt;master_bio
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|bio-&gt;bi_cnt
)paren
op_ne
l_int|1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RESYNC_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|__free_page
c_func
(paren
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
)paren
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
id|r1bio_pool_free
c_func
(paren
id|r1bio
comma
id|conf-&gt;mddev
)paren
suffix:semicolon
)brace
DECL|function|put_all_bios
r_static
r_void
id|put_all_bios
c_func
(paren
id|conf_t
op_star
id|conf
comma
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|bio
op_star
op_star
id|bio
op_assign
id|r1_bio-&gt;bios
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bio
)paren
id|bio_put
c_func
(paren
op_star
id|bio
)paren
suffix:semicolon
op_star
id|bio
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|free_r1bio
r_static
r_inline
r_void
id|free_r1bio
c_func
(paren
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bio-&gt;mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wake up any possible resync thread that waits for the device&n;&t; * to go idle.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;resync_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|conf-&gt;nr_pending
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;resync_lock
comma
id|flags
)paren
suffix:semicolon
id|put_all_bios
c_func
(paren
id|conf
comma
id|r1_bio
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|r1_bio
comma
id|conf-&gt;r1bio_pool
)paren
suffix:semicolon
)brace
DECL|function|put_buf
r_static
r_inline
r_void
id|put_buf
c_func
(paren
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bio-&gt;mddev
)paren
suffix:semicolon
r_struct
id|bio
op_star
id|bio
op_assign
id|r1_bio-&gt;master_bio
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * undo any possible partial request fixup magic:&n;&t; */
r_if
c_cond
(paren
id|bio-&gt;bi_size
op_ne
id|RESYNC_BLOCK_SIZE
)paren
id|bio-&gt;bi_io_vec
(braket
id|bio-&gt;bi_vcnt
op_minus
l_int|1
)braket
dot
id|bv_len
op_assign
id|PAGE_SIZE
suffix:semicolon
id|put_all_bios
c_func
(paren
id|conf
comma
id|r1_bio
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|r1_bio
comma
id|conf-&gt;r1buf_pool
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;resync_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;barrier
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
op_decrement
id|conf-&gt;barrier
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|conf-&gt;nr_pending
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;resync_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|map
r_static
r_int
id|map
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
op_star
id|rdevp
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
comma
id|disks
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
multiline_comment|/*&n;&t; * Later we do read balancing on the read side&n;&t; * now we use the first available disk.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdk_rdev_t
op_star
id|rdev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev
suffix:semicolon
r_if
c_cond
(paren
id|rdev
op_logical_and
id|rdev-&gt;in_sync
)paren
(brace
op_star
id|rdevp
op_assign
id|rdev
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1_map(): huh, no more operational devices?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|reschedule_retry
r_static
r_void
id|reschedule_retry
c_func
(paren
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
id|r1_bio-&gt;mddev
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|r1_bio-&gt;retry_list
comma
op_amp
id|retry_list_head
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * raid_end_bio_io() is called when we have finished servicing a mirrored&n; * operation and are ready to return a success/failure code to the buffer&n; * cache layer.&n; */
DECL|function|raid_end_bio_io
r_static
r_void
id|raid_end_bio_io
c_func
(paren
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|r1_bio-&gt;master_bio
suffix:semicolon
id|bio_endio
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
comma
id|test_bit
c_func
(paren
id|R1BIO_Uptodate
comma
op_amp
id|r1_bio-&gt;state
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
)paren
suffix:semicolon
id|free_r1bio
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update disk head position estimator based on IRQ completion info.&n; */
DECL|function|update_head_pos
r_static
r_inline
r_void
id|update_head_pos
c_func
(paren
r_int
id|disk
comma
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bio-&gt;mddev
)paren
suffix:semicolon
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|head_position
op_assign
id|r1_bio-&gt;sector
op_plus
(paren
id|r1_bio-&gt;sectors
)paren
suffix:semicolon
)brace
DECL|function|raid1_end_read_request
r_static
r_int
id|raid1_end_read_request
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
op_assign
(paren
id|r1bio_t
op_star
)paren
(paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
r_int
id|mirror
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bio-&gt;mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
id|mirror
op_assign
id|r1_bio-&gt;read_disk
suffix:semicolon
multiline_comment|/*&n;&t; * this branch is our &squot;one mirror IO has finished&squot; event handler:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
c_func
(paren
id|r1_bio-&gt;mddev
comma
id|conf-&gt;mirrors
(braket
id|mirror
)braket
dot
id|rdev
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * Set R1BIO_Uptodate in our master bio, so that&n;&t;&t; * we will return a good error code for to the higher&n;&t;&t; * levels even if IO on some other mirrored buffer fails.&n;&t;&t; *&n;&t;&t; * The &squot;master&squot; represents the composite IO operation to&n;&t;&t; * user-side. So if something waits for IO, then it will&n;&t;&t; * wait for the &squot;master&squot; bio.&n;&t;&t; */
id|set_bit
c_func
(paren
id|R1BIO_Uptodate
comma
op_amp
id|r1_bio-&gt;state
)paren
suffix:semicolon
id|update_head_pos
c_func
(paren
id|mirror
comma
id|r1_bio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we have only one bio on the read side&n;&t; */
r_if
c_cond
(paren
id|uptodate
)paren
id|raid_end_bio_io
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t; * oops, read error:&n;&t;&t; */
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: %s: rescheduling sector %llu&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|conf-&gt;mirrors
(braket
id|mirror
)braket
dot
id|rdev-&gt;bdev
comma
id|b
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|r1_bio-&gt;sector
)paren
suffix:semicolon
id|reschedule_retry
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|mirror
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|raid1_end_write_request
r_static
r_int
id|raid1_end_write_request
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
op_assign
(paren
id|r1bio_t
op_star
)paren
(paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
r_int
id|mirror
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bio-&gt;mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|mirror
op_assign
l_int|0
suffix:semicolon
id|mirror
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|mirror
op_increment
)paren
r_if
c_cond
(paren
id|r1_bio-&gt;bios
(braket
id|mirror
)braket
op_eq
id|bio
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * this branch is our &squot;one mirror IO has finished&squot; event handler:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
c_func
(paren
id|r1_bio-&gt;mddev
comma
id|conf-&gt;mirrors
(braket
id|mirror
)braket
dot
id|rdev
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * Set R1BIO_Uptodate in our master bio, so that&n;&t;&t; * we will return a good error code for to the higher&n;&t;&t; * levels even if IO on some other mirrored buffer fails.&n;&t;&t; *&n;&t;&t; * The &squot;master&squot; represents the composite IO operation to&n;&t;&t; * user-side. So if something waits for IO, then it will&n;&t;&t; * wait for the &squot;master&squot; bio.&n;&t;&t; */
id|set_bit
c_func
(paren
id|R1BIO_Uptodate
comma
op_amp
id|r1_bio-&gt;state
)paren
suffix:semicolon
id|update_head_pos
c_func
(paren
id|mirror
comma
id|r1_bio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&n;&t; * Let&squot;s see if all mirrored write operations have finished&n;&t; * already.&n;&t; */
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r1_bio-&gt;remaining
)paren
)paren
(brace
id|md_write_end
c_func
(paren
id|r1_bio-&gt;mddev
)paren
suffix:semicolon
id|raid_end_bio_io
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|mirror
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine returns the disk from which the requested read should&n; * be done. There is a per-array &squot;next expected sequential IO&squot; sector&n; * number - if this matches on the next IO then we use the last disk.&n; * There is also a per-disk &squot;last know head position&squot; sector that is&n; * maintained from IRQ contexts, both the normal and the resync IO&n; * completion handlers update this position correctly. If there is no&n; * perfect sequential match then we pick the disk whose head is closest.&n; *&n; * If there are 2 mirrors in the same 2 devices, performance degrades&n; * because position is mirror, not device based.&n; *&n; * The rdev for the device selected will have nr_pending incremented.&n; */
DECL|function|read_balance
r_static
r_int
id|read_balance
c_func
(paren
id|conf_t
op_star
id|conf
comma
r_struct
id|bio
op_star
id|bio
comma
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
r_const
r_int
r_int
id|this_sector
op_assign
id|r1_bio-&gt;sector
suffix:semicolon
r_int
id|new_disk
op_assign
id|conf-&gt;last_used
comma
id|disk
op_assign
id|new_disk
suffix:semicolon
r_const
r_int
id|sectors
op_assign
id|bio-&gt;bi_size
op_rshift
l_int|9
suffix:semicolon
id|sector_t
id|new_distance
comma
id|current_distance
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if it if we can balance. We can balance on the whole&n;&t; * device if no resync is going on, or below the resync window.&n;&t; * We take the first readable disk when above the resync window.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mddev-&gt;in_sync
op_logical_and
(paren
id|this_sector
op_plus
id|sectors
op_ge
id|conf-&gt;next_resync
)paren
)paren
(brace
multiline_comment|/* make sure that disk is operational */
id|new_disk
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|rdev
op_logical_or
op_logical_neg
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|rdev-&gt;in_sync
)paren
(brace
id|new_disk
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|new_disk
op_eq
id|conf-&gt;raid_disks
)paren
(brace
id|new_disk
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_goto
id|rb_out
suffix:semicolon
)brace
multiline_comment|/* make sure the disk is operational */
r_while
c_loop
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|rdev
op_logical_or
op_logical_neg
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|rdev-&gt;in_sync
)paren
(brace
r_if
c_cond
(paren
id|new_disk
op_le
l_int|0
)paren
id|new_disk
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|new_disk
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|new_disk
op_eq
id|disk
)paren
(brace
id|new_disk
op_assign
id|conf-&gt;last_used
suffix:semicolon
r_goto
id|rb_out
suffix:semicolon
)brace
)brace
id|disk
op_assign
id|new_disk
suffix:semicolon
multiline_comment|/* now disk == new_disk == starting point for search */
multiline_comment|/*&n;&t; * Don&squot;t change to another disk for sequential reads:&n;&t; */
r_if
c_cond
(paren
id|conf-&gt;next_seq_sect
op_eq
id|this_sector
)paren
r_goto
id|rb_out
suffix:semicolon
r_if
c_cond
(paren
id|this_sector
op_eq
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|head_position
)paren
r_goto
id|rb_out
suffix:semicolon
id|current_distance
op_assign
id|abs
c_func
(paren
id|this_sector
op_minus
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|head_position
)paren
suffix:semicolon
multiline_comment|/* Find the disk whose head is closest */
r_do
(brace
r_if
c_cond
(paren
id|disk
op_le
l_int|0
)paren
id|disk
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|disk
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|rdev
op_logical_or
op_logical_neg
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|rdev-&gt;in_sync
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|rdev-&gt;nr_pending
)paren
)paren
(brace
id|new_disk
op_assign
id|disk
suffix:semicolon
r_break
suffix:semicolon
)brace
id|new_distance
op_assign
id|abs
c_func
(paren
id|this_sector
op_minus
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|head_position
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_distance
OL
id|current_distance
)paren
(brace
id|current_distance
op_assign
id|new_distance
suffix:semicolon
id|new_disk
op_assign
id|disk
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|disk
op_ne
id|conf-&gt;last_used
)paren
suffix:semicolon
id|rb_out
suffix:colon
id|r1_bio-&gt;read_disk
op_assign
id|new_disk
suffix:semicolon
id|conf-&gt;next_seq_sect
op_assign
id|this_sector
op_plus
id|sectors
suffix:semicolon
id|conf-&gt;last_used
op_assign
id|new_disk
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|rdev
)paren
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_return
id|new_disk
suffix:semicolon
)brace
multiline_comment|/*&n; * Throttle resync depth, so that we can both get proper overlapping of&n; * requests, but are still able to handle normal requests quickly.&n; */
DECL|macro|RESYNC_DEPTH
mdefine_line|#define RESYNC_DEPTH 32
DECL|function|device_barrier
r_static
r_void
id|device_barrier
c_func
(paren
id|conf_t
op_star
id|conf
comma
id|sector_t
id|sect
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_idle
comma
op_logical_neg
id|waitqueue_active
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
comma
id|conf-&gt;resync_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;barrier
op_increment
)paren
(brace
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_idle
comma
op_logical_neg
id|conf-&gt;nr_pending
comma
id|conf-&gt;resync_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;nr_pending
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_resume
comma
id|conf-&gt;barrier
OL
id|RESYNC_DEPTH
comma
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|conf-&gt;next_resync
op_assign
id|sect
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
)brace
DECL|function|make_request
r_static
r_int
id|make_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|q-&gt;queuedata
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mirror_info_t
op_star
id|mirror
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
suffix:semicolon
r_struct
id|bio
op_star
id|read_bio
suffix:semicolon
r_int
id|i
comma
id|disks
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
multiline_comment|/*&n;&t; * Register the new request and wait if the reconstruction&n;&t; * thread has put up a bar for new requests.&n;&t; * Continue immediately if no resync is active currently.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_resume
comma
op_logical_neg
id|conf-&gt;barrier
comma
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|conf-&gt;nr_pending
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio_data_dir
c_func
(paren
id|bio
)paren
op_eq
id|WRITE
)paren
(brace
id|disk_stat_inc
c_func
(paren
id|mddev-&gt;gendisk
comma
id|writes
)paren
suffix:semicolon
id|disk_stat_add
c_func
(paren
id|mddev-&gt;gendisk
comma
id|write_sectors
comma
id|bio_sectors
c_func
(paren
id|bio
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|disk_stat_inc
c_func
(paren
id|mddev-&gt;gendisk
comma
id|reads
)paren
suffix:semicolon
id|disk_stat_add
c_func
(paren
id|mddev-&gt;gendisk
comma
id|read_sectors
comma
id|bio_sectors
c_func
(paren
id|bio
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * make_request() can abort the operation when READA is being&n;&t; * used and no empty request is available.&n;&t; *&n;&t; */
id|r1_bio
op_assign
id|mempool_alloc
c_func
(paren
id|conf-&gt;r1bio_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|r1_bio-&gt;master_bio
op_assign
id|bio
suffix:semicolon
id|r1_bio-&gt;sectors
op_assign
id|bio-&gt;bi_size
op_rshift
l_int|9
suffix:semicolon
id|r1_bio-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|r1_bio-&gt;sector
op_assign
id|bio-&gt;bi_sector
suffix:semicolon
r_if
c_cond
(paren
id|bio_data_dir
c_func
(paren
id|bio
)paren
op_eq
id|READ
)paren
(brace
multiline_comment|/*&n;&t;&t; * read balancing logic:&n;&t;&t; */
id|mirror
op_assign
id|conf-&gt;mirrors
op_plus
id|read_balance
c_func
(paren
id|conf
comma
id|bio
comma
id|r1_bio
)paren
suffix:semicolon
id|read_bio
op_assign
id|bio_clone
c_func
(paren
id|bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|r1_bio-&gt;bios
(braket
id|r1_bio-&gt;read_disk
)braket
op_assign
id|read_bio
suffix:semicolon
id|read_bio-&gt;bi_sector
op_assign
id|r1_bio-&gt;sector
op_plus
id|mirror-&gt;rdev-&gt;data_offset
suffix:semicolon
id|read_bio-&gt;bi_bdev
op_assign
id|mirror-&gt;rdev-&gt;bdev
suffix:semicolon
id|read_bio-&gt;bi_end_io
op_assign
id|raid1_end_read_request
suffix:semicolon
id|read_bio-&gt;bi_rw
op_assign
id|READ
suffix:semicolon
id|read_bio-&gt;bi_private
op_assign
id|r1_bio
suffix:semicolon
id|generic_make_request
c_func
(paren
id|read_bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * WRITE:&n;&t; */
multiline_comment|/* first select target devices under spinlock and&n;&t; * inc refcount on their rdev.  Record them by setting&n;&t; * bios[x] to bio&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev
op_logical_and
op_logical_neg
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;faulty
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|r1_bio-&gt;bios
(braket
id|i
)braket
op_assign
id|bio
suffix:semicolon
)brace
r_else
id|r1_bio-&gt;bios
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|r1_bio-&gt;remaining
comma
l_int|1
)paren
suffix:semicolon
id|md_write_start
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|bio
op_star
id|mbio
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r1_bio-&gt;bios
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|mbio
op_assign
id|bio_clone
c_func
(paren
id|bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|r1_bio-&gt;bios
(braket
id|i
)braket
op_assign
id|mbio
suffix:semicolon
id|mbio-&gt;bi_sector
op_assign
id|r1_bio-&gt;sector
op_plus
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;data_offset
suffix:semicolon
id|mbio-&gt;bi_bdev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;bdev
suffix:semicolon
id|mbio-&gt;bi_end_io
op_assign
id|raid1_end_write_request
suffix:semicolon
id|mbio-&gt;bi_rw
op_assign
id|WRITE
suffix:semicolon
id|mbio-&gt;bi_private
op_assign
id|r1_bio
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|r1_bio-&gt;remaining
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|mbio
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r1_bio-&gt;remaining
)paren
)paren
(brace
id|md_write_end
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|raid_end_bio_io
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|status
r_static
r_void
id|status
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
id|mddev_t
op_star
id|mddev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot; [%d/%d] [&quot;
comma
id|conf-&gt;raid_disks
comma
id|conf-&gt;working_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%s&quot;
comma
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev
op_logical_and
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;in_sync
ques
c_cond
l_string|&quot;U&quot;
suffix:colon
l_string|&quot;_&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;]&quot;
)paren
suffix:semicolon
)brace
DECL|function|error
r_static
r_void
id|error
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it is not operational, then we have already marked it as dead&n;&t; * else if it is the last working disks, ignore the error, let the&n;&t; * next level up know.&n;&t; * else mark the drive as failed&n;&t; */
r_if
c_cond
(paren
id|rdev-&gt;in_sync
op_logical_and
id|conf-&gt;working_disks
op_eq
l_int|1
)paren
multiline_comment|/*&n;&t;&t; * Don&squot;t fail the drive, act as though we were just a&n;&t;&t; * normal single drive&n;&t;&t; */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;in_sync
)paren
(brace
id|mddev-&gt;degraded
op_increment
suffix:semicolon
id|conf-&gt;working_disks
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if recovery is running, make sure it aborts.&n;&t;&t; */
id|set_bit
c_func
(paren
id|MD_RECOVERY_ERR
comma
op_amp
id|mddev-&gt;recovery
)paren
suffix:semicolon
)brace
id|rdev-&gt;in_sync
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;faulty
op_assign
l_int|1
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;raid1: Disk failure on %s, disabling device. &bslash;n&quot;
l_string|&quot;&t;Operation continuing on %d devices&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
id|conf-&gt;working_disks
)paren
suffix:semicolon
)brace
DECL|function|print_conf
r_static
r_void
id|print_conf
c_func
(paren
id|conf_t
op_star
id|conf
)paren
(brace
r_int
id|i
suffix:semicolon
id|mirror_info_t
op_star
id|tmp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RAID1 conf printout:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(!conf)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; --- wd:%d rd:%d&bslash;n&quot;
comma
id|conf-&gt;working_disks
comma
id|conf-&gt;raid_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|tmp
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;rdev
)paren
id|printk
c_func
(paren
l_string|&quot; disk %d, wo:%d, o:%d, dev:%s&bslash;n&quot;
comma
id|i
comma
op_logical_neg
id|tmp-&gt;rdev-&gt;in_sync
comma
op_logical_neg
id|tmp-&gt;rdev-&gt;faulty
comma
id|bdevname
c_func
(paren
id|tmp-&gt;rdev-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|close_sync
r_static
r_void
id|close_sync
c_func
(paren
id|conf_t
op_star
id|conf
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_resume
comma
op_logical_neg
id|conf-&gt;barrier
comma
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;barrier
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|conf-&gt;r1buf_pool
)paren
suffix:semicolon
id|conf-&gt;r1buf_pool
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|raid1_spare_active
r_static
r_int
id|raid1_spare_active
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|i
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
id|mirror_info_t
op_star
id|tmp
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find all failed disks within the RAID1 configuration &n;&t; * and mark them readable&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;rdev
op_logical_and
op_logical_neg
id|tmp-&gt;rdev-&gt;faulty
op_logical_and
op_logical_neg
id|tmp-&gt;rdev-&gt;in_sync
)paren
(brace
id|conf-&gt;working_disks
op_increment
suffix:semicolon
id|mddev-&gt;degraded
op_decrement
suffix:semicolon
id|tmp-&gt;rdev-&gt;in_sync
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|raid1_add_disk
r_static
r_int
id|raid1_add_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_int
id|mirror
suffix:semicolon
id|mirror_info_t
op_star
id|p
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mirror
op_assign
l_int|0
suffix:semicolon
id|mirror
OL
id|mddev-&gt;raid_disks
suffix:semicolon
id|mirror
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_assign
id|conf-&gt;mirrors
op_plus
id|mirror
)paren
op_member_access_from_pointer
id|rdev
)paren
(brace
id|p-&gt;rdev
op_assign
id|rdev
suffix:semicolon
id|blk_queue_stack_limits
c_func
(paren
id|mddev-&gt;queue
comma
id|rdev-&gt;bdev-&gt;bd_disk-&gt;queue
)paren
suffix:semicolon
multiline_comment|/* as we don&squot;t honour merge_bvec_fn, we must never risk&n;&t;&t;&t; * violating it, so limit -&gt;max_sector to one PAGE, as&n;&t;&t;&t; * a one page request is never in violation.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rdev-&gt;bdev-&gt;bd_disk-&gt;queue-&gt;merge_bvec_fn
op_logical_and
id|mddev-&gt;queue-&gt;max_sectors
OG
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
)paren
id|mddev-&gt;queue-&gt;max_sectors
op_assign
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
suffix:semicolon
id|p-&gt;head_position
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;raid_disk
op_assign
id|mirror
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
DECL|function|raid1_remove_disk
r_static
r_int
id|raid1_remove_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|number
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|err
op_assign
l_int|1
suffix:semicolon
id|mirror_info_t
op_star
id|p
op_assign
id|conf-&gt;mirrors
op_plus
id|number
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;rdev
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;rdev-&gt;in_sync
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|p-&gt;rdev-&gt;nr_pending
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|p-&gt;rdev
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
m_abort
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|end_sync_read
r_static
r_int
id|end_sync_read
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
op_assign
(paren
id|r1bio_t
op_star
)paren
(paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bio-&gt;mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|r1_bio-&gt;bios
(braket
id|r1_bio-&gt;read_disk
)braket
op_ne
id|bio
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|update_head_pos
c_func
(paren
id|r1_bio-&gt;read_disk
comma
id|r1_bio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we have read a block, now it needs to be re-written,&n;&t; * or re-read if the read failed.&n;&t; * We don&squot;t do much here, just schedule handling by raid1d&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
c_func
(paren
id|r1_bio-&gt;mddev
comma
id|conf-&gt;mirrors
(braket
id|r1_bio-&gt;read_disk
)braket
dot
id|rdev
)paren
suffix:semicolon
r_else
id|set_bit
c_func
(paren
id|R1BIO_Uptodate
comma
op_amp
id|r1_bio-&gt;state
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|r1_bio-&gt;read_disk
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|reschedule_retry
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|end_sync_write
r_static
r_int
id|end_sync_write
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
op_assign
(paren
id|r1bio_t
op_star
)paren
(paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
id|r1_bio-&gt;mddev
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|mirror
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|r1_bio-&gt;bios
(braket
id|i
)braket
op_eq
id|bio
)paren
(brace
id|mirror
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
c_func
(paren
id|mddev
comma
id|conf-&gt;mirrors
(braket
id|mirror
)braket
dot
id|rdev
)paren
suffix:semicolon
id|update_head_pos
c_func
(paren
id|mirror
comma
id|r1_bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r1_bio-&gt;remaining
)paren
)paren
(brace
id|md_done_sync
c_func
(paren
id|mddev
comma
id|r1_bio-&gt;sectors
comma
id|uptodate
)paren
suffix:semicolon
id|put_buf
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|mirror
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sync_request_write
r_static
r_void
id|sync_request_write
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|disks
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
r_struct
id|bio
op_star
id|bio
comma
op_star
id|mbio
suffix:semicolon
id|bio
op_assign
id|r1_bio-&gt;master_bio
suffix:semicolon
multiline_comment|/*&n;&t; * have to allocate lots of bio structures and&n;&t; * schedule writes&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|R1BIO_Uptodate
comma
op_amp
id|r1_bio-&gt;state
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * There is no point trying a read-for-reconstruct as&n;&t;&t; * reconstruct is about to be aborted&n;&t;&t; */
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;raid1: %s: unrecoverable I/O read error&quot;
l_string|&quot; for block %llu&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|bio-&gt;bi_bdev
comma
id|b
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|r1_bio-&gt;sector
)paren
suffix:semicolon
id|md_done_sync
c_func
(paren
id|mddev
comma
id|r1_bio-&gt;sectors
comma
l_int|0
)paren
suffix:semicolon
id|put_buf
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|r1_bio-&gt;bios
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev
op_logical_or
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;faulty
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|r1_bio-&gt;read_disk
)paren
multiline_comment|/*&n;&t;&t;&t; * we read from here, no need to write&n;&t;&t;&t; */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;in_sync
op_logical_and
id|r1_bio-&gt;sector
op_plus
(paren
id|bio-&gt;bi_size
op_rshift
l_int|9
)paren
op_le
id|mddev-&gt;recovery_cp
)paren
multiline_comment|/*&n;&t;&t;&t; * don&squot;t need to write this we are just rebuilding&n;&t;&t;&t; */
r_continue
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|r1_bio-&gt;bios
(braket
id|i
)braket
op_assign
id|bio
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|r1_bio-&gt;remaining
comma
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|disks
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|r1_bio-&gt;bios
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|mbio
op_assign
id|bio_clone
c_func
(paren
id|bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|r1_bio-&gt;bios
(braket
id|i
)braket
op_assign
id|mbio
suffix:semicolon
id|mbio-&gt;bi_bdev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;bdev
suffix:semicolon
id|mbio-&gt;bi_sector
op_assign
id|r1_bio-&gt;sector
op_plus
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev-&gt;data_offset
suffix:semicolon
id|mbio-&gt;bi_end_io
op_assign
id|end_sync_write
suffix:semicolon
id|mbio-&gt;bi_rw
op_assign
id|WRITE
suffix:semicolon
id|mbio-&gt;bi_private
op_assign
id|r1_bio
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|r1_bio-&gt;remaining
)paren
suffix:semicolon
id|md_sync_acct
c_func
(paren
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|rdev
comma
id|mbio-&gt;bi_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|mbio
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r1_bio-&gt;remaining
)paren
)paren
(brace
id|md_done_sync
c_func
(paren
id|mddev
comma
id|r1_bio-&gt;sectors
comma
l_int|1
)paren
suffix:semicolon
id|put_buf
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is a kernel thread which:&n; *&n; *&t;1.&t;Retries failed read operations on working mirrors.&n; *&t;2.&t;Updates the raid superblock when problems encounter.&n; *&t;3.&t;Performs writes following reads for array syncronising.&n; */
DECL|function|raid1d
r_static
r_void
id|raid1d
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|retry_list_head
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
id|md_check_recovery
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|md_handle_safemode
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|head
)paren
)paren
r_break
suffix:semicolon
id|r1_bio
op_assign
id|list_entry
c_func
(paren
id|head-&gt;prev
comma
id|r1bio_t
comma
id|retry_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|head-&gt;prev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
id|mddev
op_assign
id|r1_bio-&gt;mddev
suffix:semicolon
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|bio
op_assign
id|r1_bio-&gt;master_bio
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|R1BIO_IsSync
comma
op_amp
id|r1_bio-&gt;state
)paren
)paren
(brace
id|sync_request_write
c_func
(paren
id|mddev
comma
id|r1_bio
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|map
c_func
(paren
id|mddev
comma
op_amp
id|rdev
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;raid1: %s: unrecoverable I/O&quot;
l_string|&quot; read error for block %llu&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|bio-&gt;bi_bdev
comma
id|b
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|r1_bio-&gt;sector
)paren
suffix:semicolon
id|raid_end_bio_io
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: %s: redirecting sector %llu to&quot;
l_string|&quot; another mirror&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev-&gt;bdev
comma
id|b
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|r1_bio-&gt;sector
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|rdev-&gt;bdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|r1_bio-&gt;sector
op_plus
id|rdev-&gt;data_offset
suffix:semicolon
id|bio-&gt;bi_rw
op_assign
id|READ
suffix:semicolon
id|generic_make_request
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|init_resync
r_static
r_int
id|init_resync
c_func
(paren
id|conf_t
op_star
id|conf
)paren
(brace
r_int
id|buffs
suffix:semicolon
id|buffs
op_assign
id|RESYNC_WINDOW
op_div
id|RESYNC_BLOCK_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;r1buf_pool
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|conf-&gt;r1buf_pool
op_assign
id|mempool_create
c_func
(paren
id|buffs
comma
id|r1buf_pool_alloc
comma
id|r1buf_pool_free
comma
id|conf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;r1buf_pool
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|conf-&gt;next_resync
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * perform a &quot;sync&quot; on one &quot;block&quot;&n; *&n; * We need to make sure that no normal I/O request - particularly write&n; * requests - conflict with active sync requests.&n; *&n; * This is achieved by tracking pending requests and a &squot;barrier&squot; concept&n; * that can be installed to exclude normal IO requests.&n; */
DECL|function|sync_request
r_static
r_int
id|sync_request
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|sector_t
id|sector_nr
comma
r_int
id|go_faster
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mirror_info_t
op_star
id|mirror
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|sector_t
id|max_sector
comma
id|nr_sectors
suffix:semicolon
r_int
id|disk
comma
id|partial
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;r1buf_pool
)paren
r_if
c_cond
(paren
id|init_resync
c_func
(paren
id|conf
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|max_sector
op_assign
id|mddev-&gt;size
op_lshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sector_nr
op_ge
id|max_sector
)paren
(brace
id|close_sync
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there is non-resync activity waiting for us then&n;&t; * put in a delay to throttle resync.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|go_faster
op_logical_and
id|waitqueue_active
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
)paren
id|schedule_timeout
c_func
(paren
id|HZ
)paren
suffix:semicolon
id|device_barrier
c_func
(paren
id|conf
comma
id|sector_nr
op_plus
id|RESYNC_SECTORS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If reconstructing, and &gt;1 working disc,&n;&t; * could dedicate one to rebuild and others to&n;&t; * service read requests ..&n;&t; */
id|disk
op_assign
id|conf-&gt;last_used
suffix:semicolon
multiline_comment|/* make sure disk is operational */
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|rdev
op_eq
l_int|NULL
op_logical_or
op_logical_neg
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|rdev-&gt;in_sync
)paren
(brace
r_if
c_cond
(paren
id|disk
op_le
l_int|0
)paren
id|disk
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|disk
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|disk
op_eq
id|conf-&gt;last_used
)paren
r_break
suffix:semicolon
)brace
id|conf-&gt;last_used
op_assign
id|disk
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|rdev-&gt;nr_pending
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|mirror
op_assign
id|conf-&gt;mirrors
op_plus
id|disk
suffix:semicolon
id|r1_bio
op_assign
id|mempool_alloc
c_func
(paren
id|conf-&gt;r1buf_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|conf-&gt;nr_pending
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|r1_bio-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|r1_bio-&gt;sector
op_assign
id|sector_nr
suffix:semicolon
id|set_bit
c_func
(paren
id|R1BIO_IsSync
comma
op_amp
id|r1_bio-&gt;state
)paren
suffix:semicolon
id|r1_bio-&gt;read_disk
op_assign
id|disk
suffix:semicolon
id|bio
op_assign
id|r1_bio-&gt;master_bio
suffix:semicolon
id|nr_sectors
op_assign
id|RESYNC_BLOCK_SIZE
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|max_sector
op_minus
id|sector_nr
OL
id|nr_sectors
)paren
id|nr_sectors
op_assign
id|max_sector
op_minus
id|sector_nr
suffix:semicolon
id|bio-&gt;bi_size
op_assign
id|nr_sectors
op_lshift
l_int|9
suffix:semicolon
id|bio-&gt;bi_vcnt
op_assign
(paren
id|bio-&gt;bi_size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/*&n;&t; * Is there a partial page at the end of the request?&n;&t; */
id|partial
op_assign
id|bio-&gt;bi_size
op_mod
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|partial
)paren
id|bio-&gt;bi_io_vec
(braket
id|bio-&gt;bi_vcnt
op_minus
l_int|1
)braket
dot
id|bv_len
op_assign
id|partial
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|sector_nr
op_plus
id|mirror-&gt;rdev-&gt;data_offset
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|mirror-&gt;rdev-&gt;bdev
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|end_sync_read
suffix:semicolon
id|bio-&gt;bi_rw
op_assign
id|READ
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|r1_bio
suffix:semicolon
id|bio_get
c_func
(paren
id|bio
)paren
suffix:semicolon
id|r1_bio-&gt;bios
(braket
id|r1_bio-&gt;read_disk
)braket
op_assign
id|bio
suffix:semicolon
id|r1_bio-&gt;sectors
op_assign
id|nr_sectors
suffix:semicolon
id|md_sync_acct
c_func
(paren
id|mirror-&gt;rdev
comma
id|nr_sectors
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
id|nr_sectors
suffix:semicolon
)brace
DECL|function|run
r_static
r_int
id|run
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|conf_t
op_star
id|conf
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|disk_idx
suffix:semicolon
id|mirror_info_t
op_star
id|disk
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;level
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;raid1: %s: raid level not set to mirroring (%d)&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
comma
id|mddev-&gt;level
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * copy the already verified devices into our private RAID1&n;&t; * bookkeeping area. [whatever we allocate in run(),&n;&t; * should be freed in stop()]&n;&t; */
id|conf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|conf_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
id|conf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: couldn&squot;t allocate memory for %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|conf
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|conf
)paren
)paren
suffix:semicolon
id|conf-&gt;mirrors
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|mirror_info
)paren
op_star
id|mddev-&gt;raid_disks
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mirrors
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: couldn&squot;t allocate memory for %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
id|memset
c_func
(paren
id|conf-&gt;mirrors
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mirror_info
)paren
op_star
id|mddev-&gt;raid_disks
)paren
suffix:semicolon
id|conf-&gt;r1bio_pool
op_assign
id|mempool_create
c_func
(paren
id|NR_RAID1_BIOS
comma
id|r1bio_pool_alloc
comma
id|r1bio_pool_free
comma
id|mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;r1bio_pool
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: couldn&squot;t allocate memory for %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
id|disk_idx
op_assign
id|rdev-&gt;raid_disk
suffix:semicolon
r_if
c_cond
(paren
id|disk_idx
op_ge
id|mddev-&gt;raid_disks
op_logical_or
id|disk_idx
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|disk
op_assign
id|conf-&gt;mirrors
op_plus
id|disk_idx
suffix:semicolon
id|disk-&gt;rdev
op_assign
id|rdev
suffix:semicolon
id|blk_queue_stack_limits
c_func
(paren
id|mddev-&gt;queue
comma
id|rdev-&gt;bdev-&gt;bd_disk-&gt;queue
)paren
suffix:semicolon
multiline_comment|/* as we don&squot;t honour merge_bvec_fn, we must never risk&n;&t;&t; * violating it, so limit -&gt;max_sector to one PAGE, as&n;&t;&t; * a one page request is never in violation.&n;&t;&t; */
r_if
c_cond
(paren
id|rdev-&gt;bdev-&gt;bd_disk-&gt;queue-&gt;merge_bvec_fn
op_logical_and
id|mddev-&gt;queue-&gt;max_sectors
OG
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
)paren
id|mddev-&gt;queue-&gt;max_sectors
op_assign
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
suffix:semicolon
id|disk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;faulty
op_logical_and
id|rdev-&gt;in_sync
)paren
id|conf-&gt;working_disks
op_increment
suffix:semicolon
)brace
id|conf-&gt;raid_disks
op_assign
id|mddev-&gt;raid_disks
suffix:semicolon
id|conf-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|conf-&gt;device_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;working_disks
op_eq
l_int|1
)paren
id|mddev-&gt;recovery_cp
op_assign
id|MaxSector
suffix:semicolon
id|conf-&gt;resync_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;working_disks
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: no operational mirrors for %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
id|mddev-&gt;degraded
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|disk
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk-&gt;rdev
)paren
(brace
id|disk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
id|mddev-&gt;degraded
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * find the first working one and use it as a starting point&n;&t; * to read balancing.&n;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|conf-&gt;raid_disks
op_logical_and
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|j
)braket
dot
id|rdev
op_logical_or
op_logical_neg
id|conf-&gt;mirrors
(braket
id|j
)braket
dot
id|rdev-&gt;in_sync
)paren
suffix:semicolon
id|j
op_increment
)paren
multiline_comment|/* nothing */
suffix:semicolon
id|conf-&gt;last_used
op_assign
id|j
suffix:semicolon
(brace
id|mddev-&gt;thread
op_assign
id|md_register_thread
c_func
(paren
id|raid1d
comma
id|mddev
comma
l_string|&quot;%s_raid1&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mddev-&gt;thread
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: couldn&squot;t allocate thread for %s&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;raid1: raid set %s active with %d out of %d mirrors&bslash;n&quot;
comma
id|mdname
c_func
(paren
id|mddev
)paren
comma
id|mddev-&gt;raid_disks
op_minus
id|mddev-&gt;degraded
comma
id|mddev-&gt;raid_disks
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, everything is just fine now&n;&t; */
id|mddev-&gt;array_size
op_assign
id|mddev-&gt;size
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_free_conf
suffix:colon
r_if
c_cond
(paren
id|conf-&gt;r1bio_pool
)paren
id|mempool_destroy
c_func
(paren
id|conf-&gt;r1bio_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;mirrors
)paren
id|kfree
c_func
(paren
id|conf-&gt;mirrors
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|stop
r_static
r_int
id|stop
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|md_unregister_thread
c_func
(paren
id|mddev-&gt;thread
)paren
suffix:semicolon
id|mddev-&gt;thread
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;r1bio_pool
)paren
id|mempool_destroy
c_func
(paren
id|conf-&gt;r1bio_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;mirrors
)paren
id|kfree
c_func
(paren
id|conf-&gt;mirrors
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|raid1_personality
r_static
id|mdk_personality_t
id|raid1_personality
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;raid1&quot;
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|make_request
op_assign
id|make_request
comma
dot
id|run
op_assign
id|run
comma
dot
id|stop
op_assign
id|stop
comma
dot
id|status
op_assign
id|status
comma
dot
id|error_handler
op_assign
id|error
comma
dot
id|hot_add_disk
op_assign
id|raid1_add_disk
comma
dot
id|hot_remove_disk
op_assign
id|raid1_remove_disk
comma
dot
id|spare_active
op_assign
id|raid1_spare_active
comma
dot
id|sync_request
op_assign
id|sync_request
comma
)brace
suffix:semicolon
DECL|function|raid_init
r_static
r_int
id|__init
id|raid_init
c_func
(paren
r_void
)paren
(brace
r_return
id|register_md_personality
c_func
(paren
id|RAID1
comma
op_amp
id|raid1_personality
)paren
suffix:semicolon
)brace
DECL|function|raid_exit
r_static
r_void
id|raid_exit
c_func
(paren
r_void
)paren
(brace
id|unregister_md_personality
c_func
(paren
id|RAID1
)paren
suffix:semicolon
)brace
DECL|variable|raid_init
id|module_init
c_func
(paren
id|raid_init
)paren
suffix:semicolon
DECL|variable|raid_exit
id|module_exit
c_func
(paren
id|raid_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_ALIAS
c_func
(paren
l_string|&quot;md-personality-3&quot;
)paren
suffix:semicolon
multiline_comment|/* RAID1 */
eof
