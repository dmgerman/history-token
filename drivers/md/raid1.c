multiline_comment|/*&n; * raid1.c : Multiple Devices driver for Linux&n; *&n; * Copyright (C) 1999, 2000, 2001 Ingo Molnar, Red Hat&n; *&n; * Copyright (C) 1996, 1997, 1998 Ingo Molnar, Miguel de Icaza, Gadi Oxman&n; *&n; * RAID-1 management functions.&n; *&n; * Better read-balancing code written by Mika Kuoppala &lt;miku@iki.fi&gt;, 2000&n; *&n; * Fixes to reconstruction by Jakob &#xfffd;stergaard&quot; &lt;jakob@ostenfeld.dk&gt;&n; * Various fixes by Neil Brown &lt;neilb@cse.unsw.edu.au&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * You should have received a copy of the GNU General Public License&n; * (for example /usr/src/linux/COPYING); if not, write to the Free&n; * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/raid/raid1.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MD_MAJOR
DECL|macro|MD_DRIVER
mdefine_line|#define MD_DRIVER
DECL|macro|MD_PERSONALITY
mdefine_line|#define MD_PERSONALITY
DECL|macro|DEVICE_NR
mdefine_line|#define DEVICE_NR(device) (minor(device))
multiline_comment|/*&n; * Number of guaranteed r1bios in case of extreme VM load:&n; */
DECL|macro|NR_RAID1_BIOS
mdefine_line|#define&t;NR_RAID1_BIOS 256
DECL|variable|raid1_personality
r_static
id|mdk_personality_t
id|raid1_personality
suffix:semicolon
DECL|variable|retry_list_lock
r_static
id|spinlock_t
id|retry_list_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|retry_list_head
)paren
suffix:semicolon
DECL|function|r1bio_pool_alloc
r_static
r_void
op_star
id|r1bio_pool_alloc
c_func
(paren
r_int
id|gfp_flags
comma
r_void
op_star
id|data
)paren
(brace
id|r1bio_t
op_star
id|r1_bio
suffix:semicolon
id|r1_bio
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|r1bio_t
)paren
comma
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r1_bio
)paren
id|memset
c_func
(paren
id|r1_bio
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|r1_bio
)paren
)paren
suffix:semicolon
r_return
id|r1_bio
suffix:semicolon
)brace
DECL|function|r1bio_pool_free
r_static
r_void
id|r1bio_pool_free
c_func
(paren
r_void
op_star
id|r1_bio
comma
r_void
op_star
id|data
)paren
(brace
id|kfree
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
)brace
DECL|macro|RESYNC_BLOCK_SIZE
mdefine_line|#define RESYNC_BLOCK_SIZE (64*1024)
DECL|macro|RESYNC_SECTORS
mdefine_line|#define RESYNC_SECTORS (RESYNC_BLOCK_SIZE &gt;&gt; 9)
DECL|macro|RESYNC_PAGES
mdefine_line|#define RESYNC_PAGES ((RESYNC_BLOCK_SIZE + PAGE_SIZE-1) / PAGE_SIZE)
DECL|macro|RESYNC_WINDOW
mdefine_line|#define RESYNC_WINDOW (2048*1024)
DECL|function|r1buf_pool_alloc
r_static
r_void
op_star
id|r1buf_pool_alloc
c_func
(paren
r_int
id|gfp_flags
comma
r_void
op_star
id|data
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|data
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|r1_bio
op_assign
id|mempool_alloc
c_func
(paren
id|conf-&gt;r1bio_pool
comma
id|gfp_flags
)paren
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|gfp_flags
comma
id|RESYNC_PAGES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
r_goto
id|out_free_r1_bio
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RESYNC_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|page
op_assign
id|alloc_page
c_func
(paren
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|page
)paren
)paren
r_goto
id|out_free_pages
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
op_assign
id|page
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_len
op_assign
id|PAGE_SIZE
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_offset
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate a single data page for this iovec.&n;&t; */
id|bio-&gt;bi_vcnt
op_assign
id|RESYNC_PAGES
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_assign
id|RESYNC_BLOCK_SIZE
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
l_int|NULL
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|bio-&gt;bi_cnt
comma
l_int|1
)paren
suffix:semicolon
id|r1_bio-&gt;master_bio
op_assign
id|bio
suffix:semicolon
r_return
id|r1_bio
suffix:semicolon
id|out_free_pages
suffix:colon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
id|__free_page
c_func
(paren
id|bio-&gt;bi_io_vec
(braket
id|j
)braket
dot
id|bv_page
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
id|out_free_r1_bio
suffix:colon
id|mempool_free
c_func
(paren
id|r1_bio
comma
id|conf-&gt;r1bio_pool
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|r1buf_pool_free
r_static
r_void
id|r1buf_pool_free
c_func
(paren
r_void
op_star
id|__r1_bio
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|data
suffix:semicolon
id|r1bio_t
op_star
id|r1bio
op_assign
id|__r1_bio
suffix:semicolon
r_struct
id|bio
op_star
id|bio
op_assign
id|r1bio-&gt;master_bio
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|bio-&gt;bi_cnt
)paren
op_ne
l_int|1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RESYNC_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|__free_page
c_func
(paren
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
)paren
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
id|i
)braket
dot
id|bv_page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|bio-&gt;bi_cnt
)paren
op_ne
l_int|1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|r1bio
comma
id|conf-&gt;r1bio_pool
)paren
suffix:semicolon
)brace
DECL|function|put_all_bios
r_static
r_void
id|put_all_bios
c_func
(paren
id|conf_t
op_star
id|conf
comma
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|r1_bio-&gt;read_bio
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|r1_bio-&gt;read_bio-&gt;bi_cnt
)paren
op_ne
l_int|1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|r1_bio-&gt;read_bio
)paren
suffix:semicolon
id|r1_bio-&gt;read_bio
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|bio
op_star
op_star
id|bio
op_assign
id|r1_bio-&gt;write_bios
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bio
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
op_star
id|bio
)paren
op_member_access_from_pointer
id|bi_cnt
)paren
op_ne
l_int|1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|bio_put
c_func
(paren
op_star
id|bio
)paren
suffix:semicolon
)brace
op_star
id|bio
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|free_r1bio
r_static
r_inline
r_void
id|free_r1bio
c_func
(paren
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bio-&gt;mddev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wake up any possible resync thread that waits for the device&n;&t; * to go idle.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;resync_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|conf-&gt;nr_pending
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;resync_lock
comma
id|flags
)paren
suffix:semicolon
id|put_all_bios
c_func
(paren
id|conf
comma
id|r1_bio
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|r1_bio
comma
id|conf-&gt;r1bio_pool
)paren
suffix:semicolon
)brace
DECL|function|put_buf
r_static
r_inline
r_void
id|put_buf
c_func
(paren
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bio-&gt;mddev
)paren
suffix:semicolon
r_struct
id|bio
op_star
id|bio
op_assign
id|r1_bio-&gt;master_bio
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|conf-&gt;resync_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|conf-&gt;nr_pending
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|conf-&gt;resync_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * undo any possible partial request fixup magic:&n;&t; */
r_if
c_cond
(paren
id|bio-&gt;bi_size
op_ne
id|RESYNC_BLOCK_SIZE
)paren
id|bio-&gt;bi_io_vec
(braket
id|bio-&gt;bi_vcnt
op_minus
l_int|1
)braket
dot
id|bv_len
op_assign
id|PAGE_SIZE
suffix:semicolon
id|put_all_bios
c_func
(paren
id|conf
comma
id|r1_bio
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|r1_bio
comma
id|conf-&gt;r1buf_pool
)paren
suffix:semicolon
)brace
DECL|function|map
r_static
r_int
id|map
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_struct
id|block_device
op_star
op_star
id|bdev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
comma
id|disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
multiline_comment|/*&n;&t; * Later we do read balancing on the read side&n;&t; * now we use the first available disk.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
)paren
(brace
op_star
id|bdev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|bdev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;raid1_map(): huh, no more operational devices?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|reschedule_retry
r_static
r_void
id|reschedule_retry
c_func
(paren
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
id|r1_bio-&gt;mddev
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|r1_bio-&gt;retry_list
comma
op_amp
id|retry_list_head
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|conf-&gt;thread
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * raid_end_bio_io() is called when we have finished servicing a mirrored&n; * operation and are ready to return a success/failure code to the buffer&n; * cache layer.&n; */
DECL|function|raid_end_bio_io
r_static
r_void
id|raid_end_bio_io
c_func
(paren
id|r1bio_t
op_star
id|r1_bio
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|r1_bio-&gt;master_bio
suffix:semicolon
id|bio_endio
c_func
(paren
id|bio
comma
id|uptodate
)paren
suffix:semicolon
id|free_r1bio
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update disk head position estimator based on IRQ completion info.&n; */
DECL|function|update_head_pos
r_static
r_void
r_inline
id|update_head_pos
c_func
(paren
r_int
id|disk
comma
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bio-&gt;mddev
)paren
suffix:semicolon
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|head_position
op_assign
id|r1_bio-&gt;sector
op_plus
(paren
id|r1_bio-&gt;master_bio-&gt;bi_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|nr_pending
)paren
suffix:semicolon
)brace
DECL|function|end_request
r_static
r_void
id|end_request
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
op_assign
(paren
id|r1bio_t
op_star
)paren
(paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
r_int
id|mirror
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bio-&gt;mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r1_bio-&gt;cmd
op_eq
id|READ
op_logical_or
id|r1_bio-&gt;cmd
op_eq
id|READA
)paren
id|mirror
op_assign
id|r1_bio-&gt;read_disk
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|mirror
op_assign
l_int|0
suffix:semicolon
id|mirror
OL
id|MD_SB_DISKS
suffix:semicolon
id|mirror
op_increment
)paren
r_if
c_cond
(paren
id|r1_bio-&gt;write_bios
(braket
id|mirror
)braket
op_eq
id|bio
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * this branch is our &squot;one mirror IO has finished&squot; event handler:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
c_func
(paren
id|r1_bio-&gt;mddev
comma
id|conf-&gt;mirrors
(braket
id|mirror
)braket
dot
id|bdev
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * Set R1BIO_Uptodate in our master bio, so that&n;&t;&t; * we will return a good error code for to the higher&n;&t;&t; * levels even if IO on some other mirrored buffer fails.&n;&t;&t; *&n;&t;&t; * The &squot;master&squot; represents the composite IO operation to&n;&t;&t; * user-side. So if something waits for IO, then it will&n;&t;&t; * wait for the &squot;master&squot; bio.&n;&t;&t; */
id|set_bit
c_func
(paren
id|R1BIO_Uptodate
comma
op_amp
id|r1_bio-&gt;state
)paren
suffix:semicolon
id|update_head_pos
c_func
(paren
id|mirror
comma
id|r1_bio
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r1_bio-&gt;cmd
op_eq
id|READ
)paren
op_logical_or
(paren
id|r1_bio-&gt;cmd
op_eq
id|READA
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|r1_bio-&gt;read_bio
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we have only one bio on the read side&n;&t;&t; */
r_if
c_cond
(paren
id|uptodate
)paren
(brace
id|raid_end_bio_io
c_func
(paren
id|r1_bio
comma
id|uptodate
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * oops, read error:&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: %s: rescheduling sector %lu&bslash;n&quot;
comma
id|bdev_partition_name
c_func
(paren
id|bio-&gt;bi_bdev
)paren
comma
id|r1_bio-&gt;sector
)paren
suffix:semicolon
id|reschedule_retry
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r1_bio-&gt;read_bio
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * WRITE:&n;&t; *&n;&t; * Let&squot;s see if all mirrored write operations have finished&n;&t; * already.&n;&t; */
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r1_bio-&gt;remaining
)paren
)paren
id|raid_end_bio_io
c_func
(paren
id|r1_bio
comma
id|uptodate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine returns the disk from which the requested read should&n; * be done. There is a per-array &squot;next expected sequential IO&squot; sector&n; * number - if this matches on the next IO then we use the last disk.&n; * There is also a per-disk &squot;last know head position&squot; sector that is&n; * maintained from IRQ contexts, both the normal and the resync IO&n; * completion handlers update this position correctly. If there is no&n; * perfect sequential match then we pick the disk whose head is closest.&n; *&n; * If there are 2 mirrors in the same 2 devices, performance degrades&n; * because position is mirror, not device based.&n; */
DECL|function|read_balance
r_static
r_int
id|read_balance
c_func
(paren
id|conf_t
op_star
id|conf
comma
r_struct
id|bio
op_star
id|bio
comma
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
r_const
r_int
r_int
id|this_sector
op_assign
id|r1_bio-&gt;sector
suffix:semicolon
r_int
id|new_disk
op_assign
id|conf-&gt;last_used
comma
id|disk
op_assign
id|new_disk
suffix:semicolon
r_const
r_int
id|sectors
op_assign
id|bio-&gt;bi_size
op_rshift
l_int|9
suffix:semicolon
id|sector_t
id|new_distance
comma
id|current_distance
suffix:semicolon
multiline_comment|/*&n;&t; * Check if it if we can balance. We can balance on the whole&n;&t; * device if no resync is going on, or below the resync window.&n;&t; * We take the first readable disk when above the resync window.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mddev-&gt;in_sync
op_logical_and
(paren
id|this_sector
op_plus
id|sectors
op_ge
id|conf-&gt;next_resync
)paren
)paren
(brace
multiline_comment|/* make sure that disk is operational */
id|new_disk
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|operational
op_logical_or
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|write_only
)paren
(brace
id|new_disk
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|new_disk
op_eq
id|conf-&gt;raid_disks
)paren
(brace
id|new_disk
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_goto
id|rb_out
suffix:semicolon
)brace
multiline_comment|/* make sure the disk is operational */
r_while
c_loop
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|operational
)paren
(brace
r_if
c_cond
(paren
id|new_disk
op_le
l_int|0
)paren
id|new_disk
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|new_disk
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|new_disk
op_eq
id|disk
)paren
(brace
id|new_disk
op_assign
id|conf-&gt;last_used
suffix:semicolon
r_goto
id|rb_out
suffix:semicolon
)brace
)brace
id|disk
op_assign
id|new_disk
suffix:semicolon
multiline_comment|/* now disk == new_disk == starting point for search */
multiline_comment|/*&n;&t; * Don&squot;t change to another disk for sequential reads:&n;&t; */
r_if
c_cond
(paren
id|conf-&gt;next_seq_sect
op_eq
id|this_sector
)paren
r_goto
id|rb_out
suffix:semicolon
r_if
c_cond
(paren
id|this_sector
op_eq
id|conf-&gt;mirrors
(braket
id|new_disk
)braket
dot
id|head_position
)paren
r_goto
id|rb_out
suffix:semicolon
id|current_distance
op_assign
id|abs
c_func
(paren
id|this_sector
op_minus
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|head_position
)paren
suffix:semicolon
multiline_comment|/* Find the disk whose head is closest */
r_do
(brace
r_if
c_cond
(paren
id|disk
op_le
l_int|0
)paren
id|disk
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|disk
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|write_only
)paren
op_logical_or
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|operational
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|nr_pending
)paren
)paren
(brace
id|new_disk
op_assign
id|disk
suffix:semicolon
r_break
suffix:semicolon
)brace
id|new_distance
op_assign
id|abs
c_func
(paren
id|this_sector
op_minus
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|head_position
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_distance
OL
id|current_distance
)paren
(brace
id|current_distance
op_assign
id|new_distance
suffix:semicolon
id|new_disk
op_assign
id|disk
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|disk
op_ne
id|conf-&gt;last_used
)paren
suffix:semicolon
id|rb_out
suffix:colon
id|r1_bio-&gt;read_disk
op_assign
id|new_disk
suffix:semicolon
id|conf-&gt;next_seq_sect
op_assign
id|this_sector
op_plus
id|sectors
suffix:semicolon
id|conf-&gt;last_used
op_assign
id|new_disk
suffix:semicolon
r_return
id|new_disk
suffix:semicolon
)brace
multiline_comment|/*&n; * Throttle resync depth, so that we can both get proper overlapping of&n; * requests, but are still able to handle normal requests quickly.&n; */
DECL|macro|RESYNC_DEPTH
mdefine_line|#define RESYNC_DEPTH 32
DECL|function|device_barrier
r_static
r_void
id|device_barrier
c_func
(paren
id|conf_t
op_star
id|conf
comma
id|sector_t
id|sect
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_idle
comma
op_logical_neg
id|waitqueue_active
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
comma
id|conf-&gt;resync_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;barrier
op_increment
)paren
(brace
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_idle
comma
op_logical_neg
id|conf-&gt;nr_pending
comma
id|conf-&gt;resync_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;nr_pending
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_resume
comma
id|conf-&gt;barrier
OL
id|RESYNC_DEPTH
comma
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|conf-&gt;next_resync
op_assign
id|sect
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
)brace
DECL|function|resume_device
r_static
r_void
id|resume_device
c_func
(paren
id|conf_t
op_star
id|conf
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;barrier
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
op_decrement
id|conf-&gt;barrier
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
)brace
DECL|function|make_request
r_static
r_int
id|make_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|mddev_t
op_star
id|mddev
op_assign
id|q-&gt;queuedata
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mirror_info_t
op_star
id|mirror
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
suffix:semicolon
r_struct
id|bio
op_star
id|read_bio
suffix:semicolon
r_int
id|i
comma
id|sum_bios
op_assign
l_int|0
comma
id|disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
multiline_comment|/*&n;&t; * Register the new request and wait if the reconstruction&n;&t; * thread has put up a bar for new requests.&n;&t; * Continue immediately if no resync is active currently.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_resume
comma
op_logical_neg
id|conf-&gt;barrier
comma
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|conf-&gt;nr_pending
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * make_request() can abort the operation when READA is being&n;&t; * used and no empty request is available.&n;&t; *&n;&t; */
id|r1_bio
op_assign
id|mempool_alloc
c_func
(paren
id|conf-&gt;r1bio_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|r1_bio-&gt;master_bio
op_assign
id|bio
suffix:semicolon
id|r1_bio-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|r1_bio-&gt;sector
op_assign
id|bio-&gt;bi_sector
suffix:semicolon
id|r1_bio-&gt;cmd
op_assign
id|bio_data_dir
c_func
(paren
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r1_bio-&gt;cmd
op_eq
id|READ
)paren
(brace
multiline_comment|/*&n;&t;&t; * read balancing logic:&n;&t;&t; */
id|mirror
op_assign
id|conf-&gt;mirrors
op_plus
id|read_balance
c_func
(paren
id|conf
comma
id|bio
comma
id|r1_bio
)paren
suffix:semicolon
id|read_bio
op_assign
id|bio_clone
c_func
(paren
id|bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r1_bio-&gt;read_bio
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|r1_bio-&gt;read_bio
op_assign
id|read_bio
suffix:semicolon
id|read_bio-&gt;bi_sector
op_assign
id|r1_bio-&gt;sector
suffix:semicolon
id|read_bio-&gt;bi_bdev
op_assign
id|mirror-&gt;bdev
suffix:semicolon
id|read_bio-&gt;bi_end_io
op_assign
id|end_request
suffix:semicolon
id|read_bio-&gt;bi_rw
op_assign
id|r1_bio-&gt;cmd
suffix:semicolon
id|read_bio-&gt;bi_private
op_assign
id|r1_bio
suffix:semicolon
id|generic_make_request
c_func
(paren
id|read_bio
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|r1_bio-&gt;read_disk
)braket
dot
id|nr_pending
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * WRITE:&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|bio
op_star
id|mbio
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
)paren
r_continue
suffix:semicolon
id|mbio
op_assign
id|bio_clone
c_func
(paren
id|bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r1_bio-&gt;write_bios
(braket
id|i
)braket
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|r1_bio-&gt;write_bios
(braket
id|i
)braket
op_assign
id|mbio
suffix:semicolon
id|mbio-&gt;bi_sector
op_assign
id|r1_bio-&gt;sector
suffix:semicolon
id|mbio-&gt;bi_bdev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|bdev
suffix:semicolon
id|mbio-&gt;bi_end_io
op_assign
id|end_request
suffix:semicolon
id|mbio-&gt;bi_rw
op_assign
id|r1_bio-&gt;cmd
suffix:semicolon
id|mbio-&gt;bi_private
op_assign
id|r1_bio
suffix:semicolon
id|sum_bios
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sum_bios
)paren
(brace
multiline_comment|/*&n;&t;&t; * If all mirrors are non-operational&n;&t;&t; * then return an IO error:&n;&t;&t; */
id|raid_end_bio_io
c_func
(paren
id|r1_bio
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|r1_bio-&gt;remaining
comma
id|sum_bios
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to be a bit careful about the semaphore above, thats&n;&t; * why we start the requests separately. Since generic_make_request()&n;&t; * can sleep, this is the safer solution. Imagine, end_request&n;&t; * decreasing the semaphore before we could have set it up ...&n;&t; * We could play tricks with the semaphore (presetting it and&n;&t; * correcting at the end if sum_bios is not &squot;n&squot; but we have to&n;&t; * do end_request by hand if all requests finish until we had a&n;&t; * chance to set up the semaphore correctly ... lots of races).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|bio
op_star
id|mbio
suffix:semicolon
id|mbio
op_assign
id|r1_bio-&gt;write_bios
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mbio
)paren
r_continue
suffix:semicolon
id|generic_make_request
c_func
(paren
id|mbio
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|nr_pending
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|status
r_static
r_int
id|status
c_func
(paren
r_char
op_star
id|page
comma
id|mddev_t
op_star
id|mddev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|sz
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; [%d/%d] [&quot;
comma
id|conf-&gt;raid_disks
comma
id|conf-&gt;working_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
id|sz
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;%s&quot;
comma
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
ques
c_cond
l_string|&quot;U&quot;
suffix:colon
l_string|&quot;_&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;]&quot;
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
DECL|macro|LAST_DISK
mdefine_line|#define LAST_DISK KERN_ALERT &bslash;&n;&quot;raid1: only one disk left and IO error.&bslash;n&quot;
DECL|macro|NO_SPARE_DISK
mdefine_line|#define NO_SPARE_DISK KERN_ALERT &bslash;&n;&quot;raid1: no spare disk left, degrading mirror level by one.&bslash;n&quot;
DECL|macro|DISK_FAILED
mdefine_line|#define DISK_FAILED KERN_ALERT &bslash;&n;&quot;raid1: Disk failure on %s, disabling device. &bslash;n&quot; &bslash;&n;&quot;&t;Operation continuing on %d devices&bslash;n&quot;
DECL|macro|START_SYNCING
mdefine_line|#define START_SYNCING KERN_ALERT &bslash;&n;&quot;raid1: start syncing spare disk.&bslash;n&quot;
DECL|macro|ALREADY_SYNCING
mdefine_line|#define ALREADY_SYNCING KERN_INFO &bslash;&n;&quot;raid1: syncing already in progress.&bslash;n&quot;
DECL|function|mark_disk_bad
r_static
r_void
id|mark_disk_bad
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|failed
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mirror_info_t
op_star
id|mirror
op_assign
id|conf-&gt;mirrors
op_plus
id|failed
suffix:semicolon
id|mirror-&gt;operational
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mirror-&gt;write_only
)paren
(brace
id|mddev-&gt;degraded
op_increment
suffix:semicolon
id|conf-&gt;working_disks
op_decrement
suffix:semicolon
)brace
id|mddev-&gt;sb_dirty
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|DISK_FAILED
comma
id|bdev_partition_name
c_func
(paren
id|mirror-&gt;bdev
)paren
comma
id|conf-&gt;working_disks
)paren
suffix:semicolon
)brace
DECL|function|error
r_static
r_int
id|error
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mirror_info_t
op_star
id|mirrors
op_assign
id|conf-&gt;mirrors
suffix:semicolon
r_int
id|disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Find the drive.&n;&t; * If it is not operational, then we have already marked it as dead&n;&t; * else if it is the last working disks, ignore the error, let the&n;&t; * next level up know.&n;&t; * else mark the drive as failed&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|mirrors
(braket
id|i
)braket
dot
id|bdev
op_eq
id|bdev
op_logical_and
id|mirrors
(braket
id|i
)braket
dot
id|operational
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|disks
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|conf-&gt;raid_disks
op_logical_and
id|conf-&gt;working_disks
op_eq
l_int|1
)paren
multiline_comment|/*&n;&t;&t; * Don&squot;t fail the drive, act as though we were just a&n;&t;&t; * normal single drive&n;&t;&t; */
r_return
l_int|1
suffix:semicolon
id|mark_disk_bad
c_func
(paren
id|mddev
comma
id|i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|print_conf
r_static
r_void
id|print_conf
c_func
(paren
id|conf_t
op_star
id|conf
)paren
(brace
r_int
id|i
suffix:semicolon
id|mirror_info_t
op_star
id|tmp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RAID1 conf printout:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(!conf)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; --- wd:%d rd:%d&bslash;n&quot;
comma
id|conf-&gt;working_disks
comma
id|conf-&gt;raid_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; disk %d, s:%d, o:%d, n:%d rd:%d us:%d dev:%s&bslash;n&quot;
comma
id|i
comma
id|tmp-&gt;spare
comma
id|tmp-&gt;operational
comma
id|tmp-&gt;number
comma
id|tmp-&gt;raid_disk
comma
id|tmp-&gt;used_slot
comma
id|bdev_partition_name
c_func
(paren
id|tmp-&gt;bdev
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|close_sync
r_static
r_void
id|close_sync
c_func
(paren
id|conf_t
op_star
id|conf
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|wait_event_lock_irq
c_func
(paren
id|conf-&gt;wait_resume
comma
op_logical_neg
id|conf-&gt;barrier
comma
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;barrier
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|conf-&gt;r1buf_pool
)paren
suffix:semicolon
id|conf-&gt;r1buf_pool
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|raid1_spare_active
r_static
r_int
id|raid1_spare_active
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|failed_disk
op_assign
op_minus
l_int|1
comma
id|spare_disk
op_assign
op_minus
l_int|1
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
id|mirror_info_t
op_star
id|tmp
comma
op_star
id|sdisk
comma
op_star
id|fdisk
suffix:semicolon
id|mdk_rdev_t
op_star
id|spare_rdev
comma
op_star
id|failed_rdev
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the failed disk within the RAID1 configuration ...&n;&t; * (this can only be in the first conf-&gt;working_disks part)&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|tmp-&gt;operational
op_logical_and
op_logical_neg
id|tmp-&gt;spare
)paren
op_logical_or
op_logical_neg
id|tmp-&gt;used_slot
)paren
(brace
id|failed_disk
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * When we activate a spare disk we _must_ have a disk in&n;&t; * the lower (active) part of the array to replace.&n;&t; */
r_if
c_cond
(paren
id|failed_disk
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find the spare disk ... (can only be in the &squot;high&squot;&n;&t; * area of the array)&n;&t; */
id|spare_disk
op_assign
id|mddev-&gt;spare-&gt;raid_disk
suffix:semicolon
id|sdisk
op_assign
id|conf-&gt;mirrors
op_plus
id|spare_disk
suffix:semicolon
id|fdisk
op_assign
id|conf-&gt;mirrors
op_plus
id|failed_disk
suffix:semicolon
multiline_comment|/*&n;&t; * do the switch finally&n;&t; */
id|spare_rdev
op_assign
id|find_rdev_nr
c_func
(paren
id|mddev
comma
id|spare_disk
)paren
suffix:semicolon
id|failed_rdev
op_assign
id|find_rdev_nr
c_func
(paren
id|mddev
comma
id|failed_disk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There must be a spare_rdev, but there may not be a&n;&t; * failed_rdev. That slot might be empty...&n;&t; */
id|spare_rdev-&gt;desc_nr
op_assign
id|failed_disk
suffix:semicolon
id|spare_rdev-&gt;raid_disk
op_assign
id|failed_disk
suffix:semicolon
r_if
c_cond
(paren
id|failed_rdev
)paren
(brace
id|failed_rdev-&gt;desc_nr
op_assign
id|spare_disk
suffix:semicolon
id|failed_rdev-&gt;raid_disk
op_assign
id|spare_disk
suffix:semicolon
)brace
id|xchg_values
c_func
(paren
op_star
id|fdisk
comma
op_star
id|sdisk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * (careful, &squot;failed&squot; and &squot;spare&squot; are switched from now on)&n;&t; *&n;&t; * we want to preserve linear numbering and we want to&n;&t; * give the proper raid_disk number to the now activated&n;&t; * disk. (this means we switch back these values)&n;&t; */
id|xchg_values
c_func
(paren
id|sdisk-&gt;raid_disk
comma
id|fdisk-&gt;raid_disk
)paren
suffix:semicolon
id|xchg_values
c_func
(paren
id|sdisk-&gt;number
comma
id|fdisk-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdisk-&gt;bdev
)paren
id|sdisk-&gt;used_slot
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * this really activates the spare.&n;&t; */
id|fdisk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|fdisk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * if we activate a spare, we definitely replace a&n;&t; * non-operational disk slot in the &squot;low&squot; area of&n;&t; * the disk array.&n;&t; */
id|conf-&gt;working_disks
op_increment
suffix:semicolon
id|mddev-&gt;degraded
op_decrement
suffix:semicolon
m_abort
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|raid1_spare_inactive
r_static
r_int
id|raid1_spare_inactive
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
id|mirror_info_t
op_star
id|p
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|p
op_assign
id|conf-&gt;mirrors
op_plus
id|mddev-&gt;spare-&gt;raid_disk
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|p-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|p-&gt;write_only
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|raid1_spare_write
r_static
r_int
id|raid1_spare_write
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
id|mirror_info_t
op_star
id|p
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|p
op_assign
id|conf-&gt;mirrors
op_plus
id|mddev-&gt;spare-&gt;raid_disk
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|p-&gt;operational
op_assign
l_int|1
suffix:semicolon
id|p-&gt;write_only
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|raid1_add_disk
r_static
r_int
id|raid1_add_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|mdk_rdev_t
op_star
id|rdev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|err
op_assign
l_int|1
suffix:semicolon
id|mirror_info_t
op_star
id|p
op_assign
id|conf-&gt;mirrors
op_plus
id|rdev-&gt;raid_disk
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;used_slot
)paren
(brace
id|p-&gt;number
op_assign
id|rdev-&gt;desc_nr
suffix:semicolon
id|p-&gt;raid_disk
op_assign
id|rdev-&gt;raid_disk
suffix:semicolon
multiline_comment|/* it will be held open by rdev */
id|p-&gt;bdev
op_assign
id|rdev-&gt;bdev
suffix:semicolon
id|p-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|p-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|p-&gt;spare
op_assign
l_int|1
suffix:semicolon
id|p-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|p-&gt;head_position
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|raid1_remove_disk
r_static
r_int
id|raid1_remove_disk
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
r_int
id|number
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|err
op_assign
l_int|1
suffix:semicolon
id|mirror_info_t
op_star
id|p
op_assign
id|conf-&gt;mirrors
op_plus
id|number
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;used_slot
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;operational
)paren
(brace
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|p-&gt;bdev
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;used_slot
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
m_abort
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;device_lock
)paren
suffix:semicolon
id|print_conf
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|macro|IO_ERROR
mdefine_line|#define IO_ERROR KERN_ALERT &bslash;&n;&quot;raid1: %s: unrecoverable I/O read error for block %lu&bslash;n&quot;
DECL|macro|REDIRECT_SECTOR
mdefine_line|#define REDIRECT_SECTOR KERN_ERR &bslash;&n;&quot;raid1: %s: redirecting sector %lu to another mirror&bslash;n&quot;
DECL|function|end_sync_read
r_static
r_void
id|end_sync_read
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
op_assign
(paren
id|r1bio_t
op_star
)paren
(paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|r1_bio-&gt;mddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r1_bio-&gt;read_bio
op_ne
id|bio
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|update_head_pos
c_func
(paren
id|r1_bio-&gt;read_disk
comma
id|r1_bio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we have read a block, now it needs to be re-written,&n;&t; * or re-read if the read failed.&n;&t; * We don&squot;t do much here, just schedule handling by raid1d&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
c_func
(paren
id|r1_bio-&gt;mddev
comma
id|conf-&gt;mirrors
(braket
id|r1_bio-&gt;read_disk
)braket
dot
id|bdev
)paren
suffix:semicolon
r_else
id|set_bit
c_func
(paren
id|R1BIO_Uptodate
comma
op_amp
id|r1_bio-&gt;state
)paren
suffix:semicolon
id|reschedule_retry
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
)brace
DECL|function|end_sync_write
r_static
r_void
id|end_sync_write
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
op_assign
(paren
id|r1bio_t
op_star
)paren
(paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
id|mddev_t
op_star
id|mddev
op_assign
id|r1_bio-&gt;mddev
suffix:semicolon
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|mirror
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|r1_bio-&gt;write_bios
(braket
id|i
)braket
op_eq
id|bio
)paren
(brace
id|mirror
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
c_func
(paren
id|mddev
comma
id|conf-&gt;mirrors
(braket
id|mirror
)braket
dot
id|bdev
)paren
suffix:semicolon
id|update_head_pos
c_func
(paren
id|mirror
comma
id|r1_bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|r1_bio-&gt;remaining
)paren
)paren
(brace
id|md_done_sync
c_func
(paren
id|mddev
comma
id|r1_bio-&gt;master_bio-&gt;bi_size
op_rshift
l_int|9
comma
id|uptodate
)paren
suffix:semicolon
id|resume_device
c_func
(paren
id|conf
)paren
suffix:semicolon
id|put_buf
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
)brace
)brace
DECL|function|sync_request_write
r_static
r_void
id|sync_request_write
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|r1bio_t
op_star
id|r1_bio
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
r_int
id|i
comma
id|sum_bios
op_assign
l_int|0
suffix:semicolon
r_int
id|disks
op_assign
id|MD_SB_DISKS
suffix:semicolon
r_struct
id|bio
op_star
id|bio
comma
op_star
id|mbio
suffix:semicolon
id|bio
op_assign
id|r1_bio-&gt;master_bio
suffix:semicolon
multiline_comment|/*&n;&t; * have to allocate lots of bio structures and&n;&t; * schedule writes&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|R1BIO_Uptodate
comma
op_amp
id|r1_bio-&gt;state
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * There is no point trying a read-for-reconstruct as&n;&t;&t; * reconstruct is about to be aborted&n;&t;&t; */
id|printk
c_func
(paren
id|IO_ERROR
comma
id|bdev_partition_name
c_func
(paren
id|bio-&gt;bi_bdev
)paren
comma
id|r1_bio-&gt;sector
)paren
suffix:semicolon
id|md_done_sync
c_func
(paren
id|mddev
comma
id|r1_bio-&gt;master_bio-&gt;bi_size
op_rshift
l_int|9
comma
l_int|0
)paren
suffix:semicolon
id|resume_device
c_func
(paren
id|conf
)paren
suffix:semicolon
id|put_buf
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|conf-&gt;last_used
)paren
multiline_comment|/*&n;&t;&t;&t; * we read from here, no need to write&n;&t;&t;&t; */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|conf-&gt;raid_disks
op_logical_and
id|mddev-&gt;in_sync
)paren
multiline_comment|/*&n;&t;&t;&t; * don&squot;t need to write this we are just rebuilding&n;&t;&t;&t; */
r_continue
suffix:semicolon
id|mbio
op_assign
id|bio_clone
c_func
(paren
id|bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r1_bio-&gt;write_bios
(braket
id|i
)braket
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|r1_bio-&gt;write_bios
(braket
id|i
)braket
op_assign
id|mbio
suffix:semicolon
id|mbio-&gt;bi_bdev
op_assign
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|bdev
suffix:semicolon
id|mbio-&gt;bi_sector
op_assign
id|r1_bio-&gt;sector
suffix:semicolon
id|mbio-&gt;bi_end_io
op_assign
id|end_sync_write
suffix:semicolon
id|mbio-&gt;bi_rw
op_assign
id|WRITE
suffix:semicolon
id|mbio-&gt;bi_private
op_assign
id|r1_bio
suffix:semicolon
id|sum_bios
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|disks
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|r1_bio-&gt;remaining
comma
id|sum_bios
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sum_bios
)paren
(brace
multiline_comment|/*&n;&t;&t; * Nowhere to write this to... I guess we&n;&t;&t; * must be done&n;&t;&t; */
id|printk
c_func
(paren
id|IO_ERROR
comma
id|bdev_partition_name
c_func
(paren
id|bio-&gt;bi_bdev
)paren
comma
id|r1_bio-&gt;sector
)paren
suffix:semicolon
id|md_done_sync
c_func
(paren
id|mddev
comma
id|r1_bio-&gt;master_bio-&gt;bi_size
op_rshift
l_int|9
comma
l_int|0
)paren
suffix:semicolon
id|resume_device
c_func
(paren
id|conf
)paren
suffix:semicolon
id|put_buf
c_func
(paren
id|r1_bio
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mbio
op_assign
id|r1_bio-&gt;write_bios
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mbio
)paren
r_continue
suffix:semicolon
id|md_sync_acct
c_func
(paren
id|mbio-&gt;bi_bdev
comma
id|mbio-&gt;bi_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|mbio
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|i
)braket
dot
id|nr_pending
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is a kernel thread which:&n; *&n; *&t;1.&t;Retries failed read operations on working mirrors.&n; *&t;2.&t;Updates the raid superblock when problems encounter.&n; *&t;3.&t;Performs writes following reads for array syncronising.&n; */
DECL|function|raid1d
r_static
r_void
id|raid1d
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|retry_list_head
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|mddev_t
op_star
id|mddev
suffix:semicolon
id|conf_t
op_star
id|conf
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|head
)paren
)paren
r_break
suffix:semicolon
id|r1_bio
op_assign
id|list_entry
c_func
(paren
id|head-&gt;prev
comma
id|r1bio_t
comma
id|retry_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|head-&gt;prev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
id|mddev
op_assign
id|r1_bio-&gt;mddev
suffix:semicolon
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|bio
op_assign
id|r1_bio-&gt;master_bio
suffix:semicolon
r_switch
c_cond
(paren
id|r1_bio-&gt;cmd
)paren
(brace
r_case
id|SPECIAL
suffix:colon
id|sync_request_write
c_func
(paren
id|mddev
comma
id|r1_bio
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ
suffix:colon
r_case
id|READA
suffix:colon
id|bdev
op_assign
id|bio-&gt;bi_bdev
suffix:semicolon
id|map
c_func
(paren
id|mddev
comma
op_amp
id|bio-&gt;bi_bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_bdev
op_eq
id|bdev
)paren
(brace
id|printk
c_func
(paren
id|IO_ERROR
comma
id|bdev_partition_name
c_func
(paren
id|bio-&gt;bi_bdev
)paren
comma
id|r1_bio-&gt;sector
)paren
suffix:semicolon
id|raid_end_bio_io
c_func
(paren
id|r1_bio
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|REDIRECT_SECTOR
comma
id|bdev_partition_name
c_func
(paren
id|bio-&gt;bi_bdev
)paren
comma
id|r1_bio-&gt;sector
)paren
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|r1_bio-&gt;sector
suffix:semicolon
id|bio-&gt;bi_rw
op_assign
id|r1_bio-&gt;cmd
suffix:semicolon
id|generic_make_request
c_func
(paren
id|bio
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|r1_bio-&gt;read_disk
)braket
dot
id|nr_pending
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_list_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|init_resync
r_static
r_int
id|init_resync
c_func
(paren
id|conf_t
op_star
id|conf
)paren
(brace
r_int
id|buffs
suffix:semicolon
id|buffs
op_assign
id|RESYNC_WINDOW
op_div
id|RESYNC_BLOCK_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;r1buf_pool
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|conf-&gt;r1buf_pool
op_assign
id|mempool_create
c_func
(paren
id|buffs
comma
id|r1buf_pool_alloc
comma
id|r1buf_pool_free
comma
id|conf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;r1buf_pool
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|conf-&gt;next_resync
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * perform a &quot;sync&quot; on one &quot;block&quot;&n; *&n; * We need to make sure that no normal I/O request - particularly write&n; * requests - conflict with active sync requests.&n; *&n; * This is achieved by tracking pending requests and a &squot;barrier&squot; concept&n; * that can be installed to exclude normal IO requests.&n; */
DECL|function|sync_request
r_static
r_int
id|sync_request
c_func
(paren
id|mddev_t
op_star
id|mddev
comma
id|sector_t
id|sector_nr
comma
r_int
id|go_faster
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|mirror_info_t
op_star
id|mirror
suffix:semicolon
id|r1bio_t
op_star
id|r1_bio
suffix:semicolon
r_struct
id|bio
op_star
id|read_bio
comma
op_star
id|bio
suffix:semicolon
id|sector_t
id|max_sector
comma
id|nr_sectors
suffix:semicolon
r_int
id|disk
comma
id|partial
suffix:semicolon
r_if
c_cond
(paren
id|sector_nr
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|init_resync
c_func
(paren
id|conf
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|max_sector
op_assign
id|mddev-&gt;sb-&gt;size
op_lshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sector_nr
op_ge
id|max_sector
)paren
(brace
id|close_sync
c_func
(paren
id|conf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there is non-resync activity waiting for us then&n;&t; * put in a delay to throttle resync.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|go_faster
op_logical_and
id|waitqueue_active
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
)paren
id|schedule_timeout
c_func
(paren
id|HZ
)paren
suffix:semicolon
id|device_barrier
c_func
(paren
id|conf
comma
id|sector_nr
op_plus
id|RESYNC_SECTORS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If reconstructing, and &gt;1 working disc,&n;&t; * could dedicate one to rebuild and others to&n;&t; * service read requests ..&n;&t; */
id|disk
op_assign
id|conf-&gt;last_used
suffix:semicolon
multiline_comment|/* make sure disk is operational */
r_while
c_loop
(paren
op_logical_neg
id|conf-&gt;mirrors
(braket
id|disk
)braket
dot
id|operational
)paren
(brace
r_if
c_cond
(paren
id|disk
op_le
l_int|0
)paren
id|disk
op_assign
id|conf-&gt;raid_disks
suffix:semicolon
id|disk
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|disk
op_eq
id|conf-&gt;last_used
)paren
r_break
suffix:semicolon
)brace
id|conf-&gt;last_used
op_assign
id|disk
suffix:semicolon
id|mirror
op_assign
id|conf-&gt;mirrors
op_plus
id|conf-&gt;last_used
suffix:semicolon
id|r1_bio
op_assign
id|mempool_alloc
c_func
(paren
id|conf-&gt;r1buf_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|conf-&gt;nr_pending
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|conf-&gt;resync_lock
)paren
suffix:semicolon
id|r1_bio-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|r1_bio-&gt;sector
op_assign
id|sector_nr
suffix:semicolon
id|r1_bio-&gt;cmd
op_assign
id|SPECIAL
suffix:semicolon
id|bio
op_assign
id|r1_bio-&gt;master_bio
suffix:semicolon
id|nr_sectors
op_assign
id|RESYNC_BLOCK_SIZE
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|max_sector
op_minus
id|sector_nr
OL
id|nr_sectors
)paren
id|nr_sectors
op_assign
id|max_sector
op_minus
id|sector_nr
suffix:semicolon
id|bio-&gt;bi_size
op_assign
id|nr_sectors
op_lshift
l_int|9
suffix:semicolon
id|bio-&gt;bi_vcnt
op_assign
(paren
id|bio-&gt;bi_size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/*&n;&t; * Is there a partial page at the end of the request?&n;&t; */
id|partial
op_assign
id|bio-&gt;bi_size
op_mod
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|partial
)paren
id|bio-&gt;bi_io_vec
(braket
id|bio-&gt;bi_vcnt
op_minus
l_int|1
)braket
dot
id|bv_len
op_assign
id|partial
suffix:semicolon
id|read_bio
op_assign
id|bio_clone
c_func
(paren
id|r1_bio-&gt;master_bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|read_bio-&gt;bi_sector
op_assign
id|sector_nr
suffix:semicolon
id|read_bio-&gt;bi_bdev
op_assign
id|mirror-&gt;bdev
suffix:semicolon
id|read_bio-&gt;bi_end_io
op_assign
id|end_sync_read
suffix:semicolon
id|read_bio-&gt;bi_rw
op_assign
id|READ
suffix:semicolon
id|read_bio-&gt;bi_private
op_assign
id|r1_bio
suffix:semicolon
r_if
c_cond
(paren
id|r1_bio-&gt;read_bio
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|r1_bio-&gt;read_bio
op_assign
id|read_bio
suffix:semicolon
id|md_sync_acct
c_func
(paren
id|read_bio-&gt;bi_bdev
comma
id|nr_sectors
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|read_bio
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|conf-&gt;mirrors
(braket
id|conf-&gt;last_used
)braket
dot
id|nr_pending
)paren
suffix:semicolon
r_return
id|nr_sectors
suffix:semicolon
)brace
DECL|macro|INVALID_LEVEL
mdefine_line|#define INVALID_LEVEL KERN_WARNING &bslash;&n;&quot;raid1: md%d: raid level not set to mirroring (%d)&bslash;n&quot;
DECL|macro|NO_SB
mdefine_line|#define NO_SB KERN_ERR &bslash;&n;&quot;raid1: disabled mirror %s (couldn&squot;t access raid superblock)&bslash;n&quot;
DECL|macro|ERRORS
mdefine_line|#define ERRORS KERN_ERR &bslash;&n;&quot;raid1: disabled mirror %s (errors detected)&bslash;n&quot;
DECL|macro|NOT_IN_SYNC
mdefine_line|#define NOT_IN_SYNC KERN_ERR &bslash;&n;&quot;raid1: disabled mirror %s (not in sync)&bslash;n&quot;
DECL|macro|INCONSISTENT
mdefine_line|#define INCONSISTENT KERN_ERR &bslash;&n;&quot;raid1: disabled mirror %s (inconsistent descriptor)&bslash;n&quot;
DECL|macro|ALREADY_RUNNING
mdefine_line|#define ALREADY_RUNNING KERN_ERR &bslash;&n;&quot;raid1: disabled mirror %s (mirror %d already operational)&bslash;n&quot;
DECL|macro|OPERATIONAL
mdefine_line|#define OPERATIONAL KERN_INFO &bslash;&n;&quot;raid1: device %s operational as mirror %d&bslash;n&quot;
DECL|macro|MEM_ERROR
mdefine_line|#define MEM_ERROR KERN_ERR &bslash;&n;&quot;raid1: couldn&squot;t allocate memory for md%d&bslash;n&quot;
DECL|macro|SPARE
mdefine_line|#define SPARE KERN_INFO &bslash;&n;&quot;raid1: spare disk %s&bslash;n&quot;
DECL|macro|NONE_OPERATIONAL
mdefine_line|#define NONE_OPERATIONAL KERN_ERR &bslash;&n;&quot;raid1: no operational mirrors for md%d&bslash;n&quot;
DECL|macro|ARRAY_IS_ACTIVE
mdefine_line|#define ARRAY_IS_ACTIVE KERN_INFO &bslash;&n;&quot;raid1: raid set md%d active with %d out of %d mirrors&bslash;n&quot;
DECL|macro|THREAD_ERROR
mdefine_line|#define THREAD_ERROR KERN_ERR &bslash;&n;&quot;raid1: couldn&squot;t allocate thread for md%d&bslash;n&quot;
DECL|macro|START_RESYNC
mdefine_line|#define START_RESYNC KERN_WARNING &bslash;&n;&quot;raid1: raid set md%d not clean; reconstructing mirrors&bslash;n&quot;
DECL|function|run
r_static
r_int
id|run
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|conf_t
op_star
id|conf
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|disk_idx
suffix:semicolon
id|mirror_info_t
op_star
id|disk
suffix:semicolon
id|mdp_super_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|mdk_rdev_t
op_star
id|rdev
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;level
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|INVALID_LEVEL
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;level
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * copy the already verified devices into our private RAID1&n;&t; * bookkeeping area. [whatever we allocate in run(),&n;&t; * should be freed in stop()]&n;&t; */
id|conf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|conf_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
id|conf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
)paren
(brace
id|printk
c_func
(paren
id|MEM_ERROR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|conf
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|conf
)paren
)paren
suffix:semicolon
id|conf-&gt;r1bio_pool
op_assign
id|mempool_create
c_func
(paren
id|NR_RAID1_BIOS
comma
id|r1bio_pool_alloc
comma
id|r1bio_pool_free
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;r1bio_pool
)paren
(brace
id|printk
c_func
(paren
id|MEM_ERROR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
singleline_comment|//&t;for (tmp = (mddev)-&gt;disks.next; rdev = ((mdk_rdev_t *)((char *)(tmp)-(unsigned long)(&amp;((mdk_rdev_t *)0)-&gt;same_set))), tmp = tmp-&gt;next, tmp-&gt;prev != &amp;(mddev)-&gt;disks ; ) {
id|ITERATE_RDEV
c_func
(paren
id|mddev
comma
id|rdev
comma
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|printk
c_func
(paren
id|ERRORS
comma
id|bdev_partition_name
c_func
(paren
id|rdev-&gt;bdev
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;sb
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rdev-&gt;desc_nr
op_eq
op_minus
l_int|1
)paren
(brace
id|MD_BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|disk_idx
op_assign
id|rdev-&gt;raid_disk
suffix:semicolon
id|disk
op_assign
id|conf-&gt;mirrors
op_plus
id|disk_idx
suffix:semicolon
r_if
c_cond
(paren
id|rdev-&gt;faulty
)paren
(brace
id|disk-&gt;number
op_assign
id|rdev-&gt;desc_nr
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|disk_idx
suffix:semicolon
id|disk-&gt;bdev
op_assign
id|rdev-&gt;bdev
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;in_sync
)paren
(brace
r_if
c_cond
(paren
id|disk-&gt;operational
)paren
(brace
id|printk
c_func
(paren
id|ALREADY_RUNNING
comma
id|bdev_partition_name
c_func
(paren
id|rdev-&gt;bdev
)paren
comma
id|disk_idx
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
id|OPERATIONAL
comma
id|bdev_partition_name
c_func
(paren
id|rdev-&gt;bdev
)paren
comma
id|disk_idx
)paren
suffix:semicolon
id|disk-&gt;number
op_assign
id|rdev-&gt;desc_nr
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|disk_idx
suffix:semicolon
id|disk-&gt;bdev
op_assign
id|rdev-&gt;bdev
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
id|conf-&gt;working_disks
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Must be a spare disk ..&n;&t;&t; */
id|printk
c_func
(paren
id|SPARE
comma
id|bdev_partition_name
c_func
(paren
id|rdev-&gt;bdev
)paren
)paren
suffix:semicolon
id|disk-&gt;number
op_assign
id|rdev-&gt;desc_nr
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|disk_idx
suffix:semicolon
id|disk-&gt;bdev
op_assign
id|rdev-&gt;bdev
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|conf-&gt;raid_disks
op_assign
id|sb-&gt;raid_disks
suffix:semicolon
id|conf-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|conf-&gt;device_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|conf-&gt;resync_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|conf-&gt;wait_idle
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|conf-&gt;wait_resume
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;working_disks
)paren
(brace
id|printk
c_func
(paren
id|NONE_OPERATIONAL
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
id|mddev-&gt;degraded
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|disk
op_assign
id|conf-&gt;mirrors
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk-&gt;used_slot
)paren
(brace
id|disk-&gt;number
op_assign
id|i
suffix:semicolon
id|disk-&gt;raid_disk
op_assign
id|i
suffix:semicolon
id|disk-&gt;bdev
op_assign
l_int|NULL
suffix:semicolon
id|disk-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|disk-&gt;used_slot
op_assign
l_int|1
suffix:semicolon
id|disk-&gt;head_position
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|disk-&gt;used_slot
)paren
id|mddev-&gt;degraded
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * find the first working one and use it as a starting point&n;&t; * to read balancing.&n;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|conf-&gt;mirrors
(braket
id|j
)braket
dot
id|operational
op_logical_and
id|j
OL
id|MD_SB_DISKS
suffix:semicolon
id|j
op_increment
)paren
multiline_comment|/* nothing */
suffix:semicolon
id|conf-&gt;last_used
op_assign
id|j
suffix:semicolon
(brace
r_const
r_char
op_star
id|name
op_assign
l_string|&quot;raid1d&quot;
suffix:semicolon
id|conf-&gt;thread
op_assign
id|md_register_thread
c_func
(paren
id|raid1d
comma
id|conf
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;thread
)paren
(brace
id|printk
c_func
(paren
id|THREAD_ERROR
comma
id|mdidx
c_func
(paren
id|mddev
)paren
)paren
suffix:semicolon
r_goto
id|out_free_conf
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|ARRAY_IS_ACTIVE
comma
id|mdidx
c_func
(paren
id|mddev
)paren
comma
id|sb-&gt;raid_disks
op_minus
id|mddev-&gt;degraded
comma
id|sb-&gt;raid_disks
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, everything is just fine now&n;&t; */
r_return
l_int|0
suffix:semicolon
id|out_free_conf
suffix:colon
r_if
c_cond
(paren
id|conf-&gt;r1bio_pool
)paren
id|mempool_destroy
c_func
(paren
id|conf-&gt;r1bio_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|stop
r_static
r_int
id|stop
c_func
(paren
id|mddev_t
op_star
id|mddev
)paren
(brace
id|conf_t
op_star
id|conf
op_assign
id|mddev_to_conf
c_func
(paren
id|mddev
)paren
suffix:semicolon
id|md_unregister_thread
c_func
(paren
id|conf-&gt;thread
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;r1bio_pool
)paren
id|mempool_destroy
c_func
(paren
id|conf-&gt;r1bio_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|raid1_personality
r_static
id|mdk_personality_t
id|raid1_personality
op_assign
(brace
id|name
suffix:colon
l_string|&quot;raid1&quot;
comma
id|make_request
suffix:colon
id|make_request
comma
id|run
suffix:colon
id|run
comma
id|stop
suffix:colon
id|stop
comma
id|status
suffix:colon
id|status
comma
id|error_handler
suffix:colon
id|error
comma
id|hot_add_disk
suffix:colon
id|raid1_add_disk
comma
id|hot_remove_disk
suffix:colon
id|raid1_remove_disk
comma
id|spare_write
suffix:colon
id|raid1_spare_write
comma
id|spare_inactive
suffix:colon
id|raid1_spare_inactive
comma
id|spare_active
suffix:colon
id|raid1_spare_active
comma
id|sync_request
suffix:colon
id|sync_request
)brace
suffix:semicolon
DECL|function|raid_init
r_static
r_int
id|__init
id|raid_init
c_func
(paren
r_void
)paren
(brace
r_return
id|register_md_personality
c_func
(paren
id|RAID1
comma
op_amp
id|raid1_personality
)paren
suffix:semicolon
)brace
DECL|function|raid_exit
r_static
r_void
id|raid_exit
c_func
(paren
r_void
)paren
(brace
id|unregister_md_personality
c_func
(paren
id|RAID1
)paren
suffix:semicolon
)brace
DECL|variable|raid_init
id|module_init
c_func
(paren
id|raid_init
)paren
suffix:semicolon
DECL|variable|raid_exit
id|module_exit
c_func
(paren
id|raid_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
