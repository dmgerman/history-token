multiline_comment|/*&n;    w83781d.c - Part of lm_sensors, Linux kernel modules for hardware&n;                monitoring&n;    Copyright (c) 1998 - 2001  Frodo Looijaard &lt;frodol@dds.nl&gt;,&n;    Philip Edelbrock &lt;phil@netroedge.com&gt;,&n;    and Mark Studebaker &lt;mdsxyz123@yahoo.com&gt;&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2 of the License, or&n;    (at your option) any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;*/
multiline_comment|/*&n;    Supports following chips:&n;&n;    Chip&t;#vin&t;#fanin&t;#pwm&t;#temp&t;wchipid&t;vendid&t;i2c&t;ISA&n;    as99127f&t;7&t;3&t;0&t;3&t;0x31&t;0x12c3&t;yes&t;no&n;    as99127f rev.2 (type_name = as99127f)&t;0x31&t;0x5ca3&t;yes&t;no&n;    w83781d&t;7&t;3&t;0&t;3&t;0x10-1&t;0x5ca3&t;yes&t;yes&n;    w83627hf&t;9&t;3&t;2&t;3&t;0x21&t;0x5ca3&t;yes&t;yes(LPC)&n;    w83627thf&t;9&t;3&t;2&t;3&t;0x90&t;0x5ca3&t;no&t;yes(LPC)&n;    w83782d&t;9&t;3&t;2-4&t;3&t;0x30&t;0x5ca3&t;yes&t;yes&n;    w83783s&t;5-6&t;3&t;2&t;1-2&t;0x40&t;0x5ca3&t;yes&t;no&n;    w83697hf&t;8&t;2&t;2&t;2&t;0x60&t;0x5ca3&t;no&t;yes(LPC)&n;&n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/i2c.h&gt;
macro_line|#include &lt;linux/i2c-sensor.h&gt;
macro_line|#include &lt;linux/i2c-vid.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;lm75.h&quot;
multiline_comment|/* RT Table support #defined so we can take it out if it gets bothersome */
DECL|macro|W83781D_RT
mdefine_line|#define W83781D_RT&t;&t;&t;1
multiline_comment|/* Addresses to scan */
DECL|variable|normal_i2c
r_static
r_int
r_int
id|normal_i2c
(braket
)braket
op_assign
(brace
l_int|0x20
comma
l_int|0x21
comma
l_int|0x22
comma
l_int|0x23
comma
l_int|0x24
comma
l_int|0x25
comma
l_int|0x26
comma
l_int|0x27
comma
l_int|0x28
comma
l_int|0x29
comma
l_int|0x2a
comma
l_int|0x2b
comma
l_int|0x2c
comma
l_int|0x2d
comma
l_int|0x2e
comma
l_int|0x2f
comma
id|I2C_CLIENT_END
)brace
suffix:semicolon
DECL|variable|normal_isa
r_static
r_int
r_int
id|normal_isa
(braket
)braket
op_assign
(brace
l_int|0x0290
comma
id|I2C_CLIENT_ISA_END
)brace
suffix:semicolon
multiline_comment|/* Insmod parameters */
id|SENSORS_INSMOD_6
c_func
(paren
id|w83781d
comma
id|w83782d
comma
id|w83783s
comma
id|w83627hf
comma
id|as99127f
comma
id|w83697hf
)paren
suffix:semicolon
id|I2C_CLIENT_MODULE_PARM
c_func
(paren
id|force_subclients
comma
l_string|&quot;List of subclient addresses: &quot;
l_string|&quot;{bus, clientaddr, subclientaddr1, subclientaddr2}&quot;
)paren
suffix:semicolon
DECL|variable|init
r_static
r_int
id|init
op_assign
l_int|1
suffix:semicolon
id|module_param
c_func
(paren
id|init
comma
r_bool
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|init
comma
l_string|&quot;Set to zero to bypass chip initialization&quot;
)paren
suffix:semicolon
multiline_comment|/* Constants specified below */
multiline_comment|/* Length of ISA address segment */
DECL|macro|W83781D_EXTENT
mdefine_line|#define W83781D_EXTENT&t;&t;&t;8
multiline_comment|/* Where are the ISA address/data registers relative to the base address */
DECL|macro|W83781D_ADDR_REG_OFFSET
mdefine_line|#define W83781D_ADDR_REG_OFFSET&t;&t;5
DECL|macro|W83781D_DATA_REG_OFFSET
mdefine_line|#define W83781D_DATA_REG_OFFSET&t;&t;6
multiline_comment|/* The W83781D registers */
multiline_comment|/* The W83782D registers for nr=7,8 are in bank 5 */
DECL|macro|W83781D_REG_IN_MAX
mdefine_line|#define W83781D_REG_IN_MAX(nr)&t;&t;((nr &lt; 7) ? (0x2b + (nr) * 2) : &bslash;&n;&t;&t;&t;&t;&t;&t;    (0x554 + (((nr) - 7) * 2)))
DECL|macro|W83781D_REG_IN_MIN
mdefine_line|#define W83781D_REG_IN_MIN(nr)&t;&t;((nr &lt; 7) ? (0x2c + (nr) * 2) : &bslash;&n;&t;&t;&t;&t;&t;&t;    (0x555 + (((nr) - 7) * 2)))
DECL|macro|W83781D_REG_IN
mdefine_line|#define W83781D_REG_IN(nr)&t;&t;((nr &lt; 7) ? (0x20 + (nr)) : &bslash;&n;&t;&t;&t;&t;&t;&t;    (0x550 + (nr) - 7))
DECL|macro|W83781D_REG_FAN_MIN
mdefine_line|#define W83781D_REG_FAN_MIN(nr)&t;&t;(0x3a + (nr))
DECL|macro|W83781D_REG_FAN
mdefine_line|#define W83781D_REG_FAN(nr)&t;&t;(0x27 + (nr))
DECL|macro|W83781D_REG_BANK
mdefine_line|#define W83781D_REG_BANK&t;&t;0x4E
DECL|macro|W83781D_REG_TEMP2_CONFIG
mdefine_line|#define W83781D_REG_TEMP2_CONFIG&t;0x152
DECL|macro|W83781D_REG_TEMP3_CONFIG
mdefine_line|#define W83781D_REG_TEMP3_CONFIG&t;0x252
DECL|macro|W83781D_REG_TEMP
mdefine_line|#define W83781D_REG_TEMP(nr)&t;&t;((nr == 3) ? (0x0250) : &bslash;&n;&t;&t;&t;&t;&t;((nr == 2) ? (0x0150) : &bslash;&n;&t;&t;&t;&t;&t;&t;     (0x27)))
DECL|macro|W83781D_REG_TEMP_HYST
mdefine_line|#define W83781D_REG_TEMP_HYST(nr)&t;((nr == 3) ? (0x253) : &bslash;&n;&t;&t;&t;&t;&t;((nr == 2) ? (0x153) : &bslash;&n;&t;&t;&t;&t;&t;&t;     (0x3A)))
DECL|macro|W83781D_REG_TEMP_OVER
mdefine_line|#define W83781D_REG_TEMP_OVER(nr)&t;((nr == 3) ? (0x255) : &bslash;&n;&t;&t;&t;&t;&t;((nr == 2) ? (0x155) : &bslash;&n;&t;&t;&t;&t;&t;&t;     (0x39)))
DECL|macro|W83781D_REG_CONFIG
mdefine_line|#define W83781D_REG_CONFIG&t;&t;0x40
DECL|macro|W83781D_REG_ALARM1
mdefine_line|#define W83781D_REG_ALARM1&t;&t;0x41
DECL|macro|W83781D_REG_ALARM2
mdefine_line|#define W83781D_REG_ALARM2&t;&t;0x42
DECL|macro|W83781D_REG_ALARM3
mdefine_line|#define W83781D_REG_ALARM3&t;&t;0x450&t;/* not on W83781D */
DECL|macro|W83781D_REG_IRQ
mdefine_line|#define W83781D_REG_IRQ&t;&t;&t;0x4C
DECL|macro|W83781D_REG_BEEP_CONFIG
mdefine_line|#define W83781D_REG_BEEP_CONFIG&t;&t;0x4D
DECL|macro|W83781D_REG_BEEP_INTS1
mdefine_line|#define W83781D_REG_BEEP_INTS1&t;&t;0x56
DECL|macro|W83781D_REG_BEEP_INTS2
mdefine_line|#define W83781D_REG_BEEP_INTS2&t;&t;0x57
DECL|macro|W83781D_REG_BEEP_INTS3
mdefine_line|#define W83781D_REG_BEEP_INTS3&t;&t;0x453&t;/* not on W83781D */
DECL|macro|W83781D_REG_VID_FANDIV
mdefine_line|#define W83781D_REG_VID_FANDIV&t;&t;0x47
DECL|macro|W83781D_REG_CHIPID
mdefine_line|#define W83781D_REG_CHIPID&t;&t;0x49
DECL|macro|W83781D_REG_WCHIPID
mdefine_line|#define W83781D_REG_WCHIPID&t;&t;0x58
DECL|macro|W83781D_REG_CHIPMAN
mdefine_line|#define W83781D_REG_CHIPMAN&t;&t;0x4F
DECL|macro|W83781D_REG_PIN
mdefine_line|#define W83781D_REG_PIN&t;&t;&t;0x4B
multiline_comment|/* 782D/783S only */
DECL|macro|W83781D_REG_VBAT
mdefine_line|#define W83781D_REG_VBAT&t;&t;0x5D
multiline_comment|/* PWM 782D (1-4) and 783S (1-2) only */
DECL|macro|W83781D_REG_PWM1
mdefine_line|#define W83781D_REG_PWM1&t;&t;0x5B&t;/* 782d and 783s/627hf datasheets disagree */
multiline_comment|/* on which is which; */
DECL|macro|W83781D_REG_PWM2
mdefine_line|#define W83781D_REG_PWM2&t;&t;0x5A&t;/* We follow the 782d convention here, */
multiline_comment|/* However 782d is probably wrong. */
DECL|macro|W83781D_REG_PWM3
mdefine_line|#define W83781D_REG_PWM3&t;&t;0x5E
DECL|macro|W83781D_REG_PWM4
mdefine_line|#define W83781D_REG_PWM4&t;&t;0x5F
DECL|macro|W83781D_REG_PWMCLK12
mdefine_line|#define W83781D_REG_PWMCLK12&t;&t;0x5C
DECL|macro|W83781D_REG_PWMCLK34
mdefine_line|#define W83781D_REG_PWMCLK34&t;&t;0x45C
DECL|variable|regpwm
r_static
r_const
id|u8
id|regpwm
(braket
)braket
op_assign
(brace
id|W83781D_REG_PWM1
comma
id|W83781D_REG_PWM2
comma
id|W83781D_REG_PWM3
comma
id|W83781D_REG_PWM4
)brace
suffix:semicolon
DECL|macro|W83781D_REG_PWM
mdefine_line|#define W83781D_REG_PWM(nr)&t;&t;(regpwm[(nr) - 1])
DECL|macro|W83781D_REG_I2C_ADDR
mdefine_line|#define W83781D_REG_I2C_ADDR&t;&t;0x48
DECL|macro|W83781D_REG_I2C_SUBADDR
mdefine_line|#define W83781D_REG_I2C_SUBADDR&t;&t;0x4A
multiline_comment|/* The following are undocumented in the data sheets however we&n;   received the information in an email from Winbond tech support */
multiline_comment|/* Sensor selection - not on 781d */
DECL|macro|W83781D_REG_SCFG1
mdefine_line|#define W83781D_REG_SCFG1&t;&t;0x5D
DECL|variable|BIT_SCFG1
r_static
r_const
id|u8
id|BIT_SCFG1
(braket
)braket
op_assign
(brace
l_int|0x02
comma
l_int|0x04
comma
l_int|0x08
)brace
suffix:semicolon
DECL|macro|W83781D_REG_SCFG2
mdefine_line|#define W83781D_REG_SCFG2&t;&t;0x59
DECL|variable|BIT_SCFG2
r_static
r_const
id|u8
id|BIT_SCFG2
(braket
)braket
op_assign
(brace
l_int|0x10
comma
l_int|0x20
comma
l_int|0x40
)brace
suffix:semicolon
DECL|macro|W83781D_DEFAULT_BETA
mdefine_line|#define W83781D_DEFAULT_BETA&t;&t;3435
multiline_comment|/* RT Table registers */
DECL|macro|W83781D_REG_RT_IDX
mdefine_line|#define W83781D_REG_RT_IDX&t;&t;0x50
DECL|macro|W83781D_REG_RT_VAL
mdefine_line|#define W83781D_REG_RT_VAL&t;&t;0x51
multiline_comment|/* Conversions. Rounding and limit checking is only done on the TO_REG&n;   variants. Note that you should be a bit careful with which arguments&n;   these macros are called: arguments may be evaluated more than once.&n;   Fixing this is just not worth it. */
DECL|macro|IN_TO_REG
mdefine_line|#define IN_TO_REG(val)&t;&t;&t;(SENSORS_LIMIT((((val) * 10 + 8)/16),0,255))
DECL|macro|IN_FROM_REG
mdefine_line|#define IN_FROM_REG(val)&t;&t;(((val) * 16) / 10)
r_static
r_inline
id|u8
DECL|function|FAN_TO_REG
id|FAN_TO_REG
c_func
(paren
r_int
id|rpm
comma
r_int
id|div
)paren
(brace
r_if
c_cond
(paren
id|rpm
op_eq
l_int|0
)paren
r_return
l_int|255
suffix:semicolon
id|rpm
op_assign
id|SENSORS_LIMIT
c_func
(paren
id|rpm
comma
l_int|1
comma
l_int|1000000
)paren
suffix:semicolon
r_return
id|SENSORS_LIMIT
c_func
(paren
(paren
l_int|1350000
op_plus
id|rpm
op_star
id|div
op_div
l_int|2
)paren
op_div
(paren
id|rpm
op_star
id|div
)paren
comma
l_int|1
comma
l_int|254
)paren
suffix:semicolon
)brace
DECL|macro|FAN_FROM_REG
mdefine_line|#define FAN_FROM_REG(val,div)&t;&t;((val) == 0   ? -1 : &bslash;&n;&t;&t;&t;&t;&t;((val) == 255 ? 0 : &bslash;&n;&t;&t;&t;&t;&t;&t;&t;1350000 / ((val) * (div))))
DECL|macro|TEMP_TO_REG
mdefine_line|#define TEMP_TO_REG(val)&t;&t;(SENSORS_LIMIT(((val) &lt; 0 ? (val)+0x100*1000 &bslash;&n;&t;&t;&t;&t;&t;&t;: (val)) / 1000, 0, 0xff))
DECL|macro|TEMP_FROM_REG
mdefine_line|#define TEMP_FROM_REG(val)&t;&t;(((val) &amp; 0x80 ? (val)-0x100 : (val)) * 1000)
DECL|macro|ALARMS_FROM_REG
mdefine_line|#define ALARMS_FROM_REG(val)&t;&t;(val)
DECL|macro|PWM_FROM_REG
mdefine_line|#define PWM_FROM_REG(val)&t;&t;(val)
DECL|macro|PWM_TO_REG
mdefine_line|#define PWM_TO_REG(val)&t;&t;&t;(SENSORS_LIMIT((val),0,255))
DECL|macro|BEEP_MASK_FROM_REG
mdefine_line|#define BEEP_MASK_FROM_REG(val,type)&t;((type) == as99127f ? &bslash;&n;&t;&t;&t;&t;&t; (val) ^ 0x7fff : (val))
DECL|macro|BEEP_MASK_TO_REG
mdefine_line|#define BEEP_MASK_TO_REG(val,type)&t;((type) == as99127f ? &bslash;&n;&t;&t;&t;&t;&t; (~(val)) &amp; 0x7fff : (val) &amp; 0xffffff)
DECL|macro|BEEP_ENABLE_TO_REG
mdefine_line|#define BEEP_ENABLE_TO_REG(val)&t;&t;((val) ? 1 : 0)
DECL|macro|BEEP_ENABLE_FROM_REG
mdefine_line|#define BEEP_ENABLE_FROM_REG(val)&t;((val) ? 1 : 0)
DECL|macro|DIV_FROM_REG
mdefine_line|#define DIV_FROM_REG(val)&t;&t;(1 &lt;&lt; (val))
r_static
r_inline
id|u8
DECL|function|DIV_TO_REG
id|DIV_TO_REG
c_func
(paren
r_int
id|val
comma
r_enum
id|chips
id|type
)paren
(brace
r_int
id|i
suffix:semicolon
id|val
op_assign
id|SENSORS_LIMIT
c_func
(paren
id|val
comma
l_int|1
comma
(paren
(paren
id|type
op_eq
id|w83781d
op_logical_or
id|type
op_eq
id|as99127f
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|128
)paren
)paren
op_rshift
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|val
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|val
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_return
(paren
(paren
id|u8
)paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* There are some complications in a module like this. First off, W83781D chips&n;   may be both present on the SMBus and the ISA bus, and we have to handle&n;   those cases separately at some places. Second, there might be several&n;   W83781D chips available (well, actually, that is probably never done; but&n;   it is a clean illustration of how to handle a case like that). Finally,&n;   a specific chip may be attached to *both* ISA and SMBus, and we would&n;   not like to detect it double. Fortunately, in the case of the W83781D at&n;   least, a register tells us what SMBus address we are on, so that helps&n;   a bit - except if there could be more than one SMBus. Groan. No solution&n;   for this yet. */
multiline_comment|/* This module may seem overly long and complicated. In fact, it is not so&n;   bad. Quite a lot of bookkeeping is done. A real driver can often cut&n;   some corners. */
multiline_comment|/* For each registered W83781D, we need to keep some data in memory. That&n;   data is pointed to by w83781d_list[NR]-&gt;data. The structure itself is&n;   dynamically allocated, at the same time when a new w83781d client is&n;   allocated. */
DECL|struct|w83781d_data
r_struct
id|w83781d_data
(brace
DECL|member|client
r_struct
id|i2c_client
id|client
suffix:semicolon
DECL|member|lock
r_struct
id|semaphore
id|lock
suffix:semicolon
DECL|member|type
r_enum
id|chips
id|type
suffix:semicolon
DECL|member|update_lock
r_struct
id|semaphore
id|update_lock
suffix:semicolon
DECL|member|valid
r_char
id|valid
suffix:semicolon
multiline_comment|/* !=0 if following fields are valid */
DECL|member|last_updated
r_int
r_int
id|last_updated
suffix:semicolon
multiline_comment|/* In jiffies */
DECL|member|lm75
r_struct
id|i2c_client
op_star
id|lm75
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* for secondary I2C addresses */
multiline_comment|/* array of 2 pointers to subclients */
DECL|member|in
id|u8
id|in
(braket
l_int|9
)braket
suffix:semicolon
multiline_comment|/* Register value - 8 &amp; 9 for 782D only */
DECL|member|in_max
id|u8
id|in_max
(braket
l_int|9
)braket
suffix:semicolon
multiline_comment|/* Register value - 8 &amp; 9 for 782D only */
DECL|member|in_min
id|u8
id|in_min
(braket
l_int|9
)braket
suffix:semicolon
multiline_comment|/* Register value - 8 &amp; 9 for 782D only */
DECL|member|fan
id|u8
id|fan
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|fan_min
id|u8
id|fan_min
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|temp
id|u8
id|temp
suffix:semicolon
DECL|member|temp_max
id|u8
id|temp_max
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|temp_max_hyst
id|u8
id|temp_max_hyst
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|temp_add
id|u16
id|temp_add
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|temp_max_add
id|u16
id|temp_max_add
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|temp_max_hyst_add
id|u16
id|temp_max_hyst_add
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|fan_div
id|u8
id|fan_div
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Register encoding, shifted right */
DECL|member|vid
id|u8
id|vid
suffix:semicolon
multiline_comment|/* Register encoding, combined */
DECL|member|alarms
id|u32
id|alarms
suffix:semicolon
multiline_comment|/* Register encoding, combined */
DECL|member|beep_mask
id|u32
id|beep_mask
suffix:semicolon
multiline_comment|/* Register encoding, combined */
DECL|member|beep_enable
id|u8
id|beep_enable
suffix:semicolon
multiline_comment|/* Boolean */
DECL|member|pwm
id|u8
id|pwm
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|pwmenable
id|u8
id|pwmenable
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Boolean */
DECL|member|sens
id|u16
id|sens
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* 782D/783S only.&n;&t;&t;&t;&t;   1 = pentium diode; 2 = 3904 diode;&n;&t;&t;&t;&t;   3000-5000 = thermistor beta.&n;&t;&t;&t;&t;   Default = 3435. &n;&t;&t;&t;&t;   Other Betas unimplemented */
macro_line|#ifdef W83781D_RT
DECL|member|rt
id|u8
id|rt
(braket
l_int|3
)braket
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* Register value */
macro_line|#endif
DECL|member|vrm
id|u8
id|vrm
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
id|w83781d_attach_adapter
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
)paren
suffix:semicolon
r_static
r_int
id|w83781d_detect
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
comma
r_int
id|address
comma
r_int
id|kind
)paren
suffix:semicolon
r_static
r_int
id|w83781d_detach_client
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
)paren
suffix:semicolon
r_static
r_int
id|w83781d_read_value
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
comma
id|u16
r_register
)paren
suffix:semicolon
r_static
r_int
id|w83781d_write_value
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
comma
id|u16
r_register
comma
id|u16
id|value
)paren
suffix:semicolon
r_static
r_struct
id|w83781d_data
op_star
id|w83781d_update_device
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|w83781d_init_client
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
)paren
suffix:semicolon
DECL|variable|w83781d_driver
r_static
r_struct
id|i2c_driver
id|w83781d_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;w83781d&quot;
comma
dot
id|id
op_assign
id|I2C_DRIVERID_W83781D
comma
dot
id|flags
op_assign
id|I2C_DF_NOTIFY
comma
dot
id|attach_adapter
op_assign
id|w83781d_attach_adapter
comma
dot
id|detach_client
op_assign
id|w83781d_detach_client
comma
)brace
suffix:semicolon
multiline_comment|/* following are the sysfs callback functions */
DECL|macro|show_in_reg
mdefine_line|#define show_in_reg(reg) &bslash;&n;static ssize_t show_##reg (struct device *dev, char *buf, int nr) &bslash;&n;{ &bslash;&n;&t;struct w83781d_data *data = w83781d_update_device(dev); &bslash;&n;&t;return sprintf(buf,&quot;%ld&bslash;n&quot;, (long)IN_FROM_REG(data-&gt;reg[nr] * 10)); &bslash;&n;}
DECL|variable|in
id|show_in_reg
c_func
(paren
id|in
)paren
suffix:semicolon
DECL|variable|in_min
id|show_in_reg
c_func
(paren
id|in_min
)paren
suffix:semicolon
DECL|variable|in_max
id|show_in_reg
c_func
(paren
id|in_max
)paren
suffix:semicolon
DECL|macro|store_in_reg
mdefine_line|#define store_in_reg(REG, reg) &bslash;&n;static ssize_t store_in_##reg (struct device *dev, const char *buf, size_t count, int nr) &bslash;&n;{ &bslash;&n;&t;struct i2c_client *client = to_i2c_client(dev); &bslash;&n;&t;struct w83781d_data *data = i2c_get_clientdata(client); &bslash;&n;&t;u32 val; &bslash;&n;&t; &bslash;&n;&t;val = simple_strtoul(buf, NULL, 10) / 10; &bslash;&n;&t;data-&gt;in_##reg[nr] = IN_TO_REG(val); &bslash;&n;&t;w83781d_write_value(client, W83781D_REG_IN_##REG(nr), data-&gt;in_##reg[nr]); &bslash;&n;&t; &bslash;&n;&t;return count; &bslash;&n;}
id|store_in_reg
c_func
(paren
id|MIN
comma
id|min
)paren
suffix:semicolon
id|store_in_reg
c_func
(paren
id|MAX
comma
id|max
)paren
suffix:semicolon
DECL|macro|sysfs_in_offset
mdefine_line|#define sysfs_in_offset(offset) &bslash;&n;static ssize_t &bslash;&n;show_regs_in_##offset (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;        return show_in(dev, buf, offset); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(in##offset##_input, S_IRUGO, show_regs_in_##offset, NULL);
DECL|macro|sysfs_in_reg_offset
mdefine_line|#define sysfs_in_reg_offset(reg, offset) &bslash;&n;static ssize_t show_regs_in_##reg##offset (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_in_##reg (dev, buf, offset); &bslash;&n;} &bslash;&n;static ssize_t store_regs_in_##reg##offset (struct device *dev, const char *buf, size_t count) &bslash;&n;{ &bslash;&n;&t;return store_in_##reg (dev, buf, count, offset); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(in##offset##_##reg, S_IRUGO| S_IWUSR, show_regs_in_##reg##offset, store_regs_in_##reg##offset);
DECL|macro|sysfs_in_offsets
mdefine_line|#define sysfs_in_offsets(offset) &bslash;&n;sysfs_in_offset(offset); &bslash;&n;sysfs_in_reg_offset(min, offset); &bslash;&n;sysfs_in_reg_offset(max, offset);
id|sysfs_in_offsets
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|sysfs_in_offsets
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sysfs_in_offsets
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|sysfs_in_offsets
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|sysfs_in_offsets
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|sysfs_in_offsets
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|sysfs_in_offsets
c_func
(paren
l_int|6
)paren
suffix:semicolon
id|sysfs_in_offsets
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|sysfs_in_offsets
c_func
(paren
l_int|8
)paren
suffix:semicolon
DECL|macro|device_create_file_in
mdefine_line|#define device_create_file_in(client, offset) &bslash;&n;do { &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_in##offset##_input); &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_in##offset##_min); &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_in##offset##_max); &bslash;&n;} while (0)
DECL|macro|show_fan_reg
mdefine_line|#define show_fan_reg(reg) &bslash;&n;static ssize_t show_##reg (struct device *dev, char *buf, int nr) &bslash;&n;{ &bslash;&n;&t;struct w83781d_data *data = w83781d_update_device(dev); &bslash;&n;&t;return sprintf(buf,&quot;%ld&bslash;n&quot;, &bslash;&n;&t;&t;FAN_FROM_REG(data-&gt;reg[nr-1], (long)DIV_FROM_REG(data-&gt;fan_div[nr-1]))); &bslash;&n;}
DECL|variable|fan
id|show_fan_reg
c_func
(paren
id|fan
)paren
suffix:semicolon
DECL|variable|fan_min
id|show_fan_reg
c_func
(paren
id|fan_min
)paren
suffix:semicolon
r_static
id|ssize_t
DECL|function|store_fan_min
id|store_fan_min
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|nr
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
id|u32
id|val
suffix:semicolon
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|data-&gt;fan_min
(braket
id|nr
op_minus
l_int|1
)braket
op_assign
id|FAN_TO_REG
c_func
(paren
id|val
comma
id|DIV_FROM_REG
c_func
(paren
id|data-&gt;fan_div
(braket
id|nr
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_FAN_MIN
c_func
(paren
id|nr
)paren
comma
id|data-&gt;fan_min
(braket
id|nr
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|macro|sysfs_fan_offset
mdefine_line|#define sysfs_fan_offset(offset) &bslash;&n;static ssize_t show_regs_fan_##offset (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_fan(dev, buf, offset); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(fan##offset##_input, S_IRUGO, show_regs_fan_##offset, NULL);
DECL|macro|sysfs_fan_min_offset
mdefine_line|#define sysfs_fan_min_offset(offset) &bslash;&n;static ssize_t show_regs_fan_min##offset (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_fan_min(dev, buf, offset); &bslash;&n;} &bslash;&n;static ssize_t store_regs_fan_min##offset (struct device *dev, const char *buf, size_t count) &bslash;&n;{ &bslash;&n;&t;return store_fan_min(dev, buf, count, offset); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR, show_regs_fan_min##offset, store_regs_fan_min##offset);
id|sysfs_fan_offset
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sysfs_fan_min_offset
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sysfs_fan_offset
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|sysfs_fan_min_offset
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|sysfs_fan_offset
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|sysfs_fan_min_offset
c_func
(paren
l_int|3
)paren
suffix:semicolon
DECL|macro|device_create_file_fan
mdefine_line|#define device_create_file_fan(client, offset) &bslash;&n;do { &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_fan##offset##_input); &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_fan##offset##_min); &bslash;&n;} while (0)
DECL|macro|show_temp_reg
mdefine_line|#define show_temp_reg(reg) &bslash;&n;static ssize_t show_##reg (struct device *dev, char *buf, int nr) &bslash;&n;{ &bslash;&n;&t;struct w83781d_data *data = w83781d_update_device(dev); &bslash;&n;&t;if (nr &gt;= 2) {&t;/* TEMP2 and TEMP3 */ &bslash;&n;&t;&t;return sprintf(buf,&quot;%d&bslash;n&quot;, &bslash;&n;&t;&t;&t;LM75_TEMP_FROM_REG(data-&gt;reg##_add[nr-2])); &bslash;&n;&t;} else {&t;/* TEMP1 */ &bslash;&n;&t;&t;return sprintf(buf,&quot;%ld&bslash;n&quot;, (long)TEMP_FROM_REG(data-&gt;reg)); &bslash;&n;&t;} &bslash;&n;}
DECL|variable|temp
id|show_temp_reg
c_func
(paren
id|temp
)paren
suffix:semicolon
DECL|variable|temp_max
id|show_temp_reg
c_func
(paren
id|temp_max
)paren
suffix:semicolon
DECL|variable|temp_max_hyst
id|show_temp_reg
c_func
(paren
id|temp_max_hyst
)paren
suffix:semicolon
DECL|macro|store_temp_reg
mdefine_line|#define store_temp_reg(REG, reg) &bslash;&n;static ssize_t store_temp_##reg (struct device *dev, const char *buf, size_t count, int nr) &bslash;&n;{ &bslash;&n;&t;struct i2c_client *client = to_i2c_client(dev); &bslash;&n;&t;struct w83781d_data *data = i2c_get_clientdata(client); &bslash;&n;&t;s32 val; &bslash;&n;&t; &bslash;&n;&t;val = simple_strtol(buf, NULL, 10); &bslash;&n;&t; &bslash;&n;&t;if (nr &gt;= 2) {&t;/* TEMP2 and TEMP3 */ &bslash;&n;&t;&t;data-&gt;temp_##reg##_add[nr-2] = LM75_TEMP_TO_REG(val); &bslash;&n;&t;&t;w83781d_write_value(client, W83781D_REG_TEMP_##REG(nr), &bslash;&n;&t;&t;&t;&t;data-&gt;temp_##reg##_add[nr-2]); &bslash;&n;&t;} else {&t;/* TEMP1 */ &bslash;&n;&t;&t;data-&gt;temp_##reg = TEMP_TO_REG(val); &bslash;&n;&t;&t;w83781d_write_value(client, W83781D_REG_TEMP_##REG(nr), &bslash;&n;&t;&t;&t;data-&gt;temp_##reg); &bslash;&n;&t;} &bslash;&n;&t; &bslash;&n;&t;return count; &bslash;&n;}
id|store_temp_reg
c_func
(paren
id|OVER
comma
id|max
)paren
suffix:semicolon
id|store_temp_reg
c_func
(paren
id|HYST
comma
id|max_hyst
)paren
suffix:semicolon
DECL|macro|sysfs_temp_offset
mdefine_line|#define sysfs_temp_offset(offset) &bslash;&n;static ssize_t &bslash;&n;show_regs_temp_##offset (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_temp(dev, buf, offset); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(temp##offset##_input, S_IRUGO, show_regs_temp_##offset, NULL);
DECL|macro|sysfs_temp_reg_offset
mdefine_line|#define sysfs_temp_reg_offset(reg, offset) &bslash;&n;static ssize_t show_regs_temp_##reg##offset (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_temp_##reg (dev, buf, offset); &bslash;&n;} &bslash;&n;static ssize_t store_regs_temp_##reg##offset (struct device *dev, const char *buf, size_t count) &bslash;&n;{ &bslash;&n;&t;return store_temp_##reg (dev, buf, count, offset); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(temp##offset##_##reg, S_IRUGO| S_IWUSR, show_regs_temp_##reg##offset, store_regs_temp_##reg##offset);
DECL|macro|sysfs_temp_offsets
mdefine_line|#define sysfs_temp_offsets(offset) &bslash;&n;sysfs_temp_offset(offset); &bslash;&n;sysfs_temp_reg_offset(max, offset); &bslash;&n;sysfs_temp_reg_offset(max_hyst, offset);
id|sysfs_temp_offsets
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sysfs_temp_offsets
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|sysfs_temp_offsets
c_func
(paren
l_int|3
)paren
suffix:semicolon
DECL|macro|device_create_file_temp
mdefine_line|#define device_create_file_temp(client, offset) &bslash;&n;do { &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_temp##offset##_input); &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_temp##offset##_max); &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_temp##offset##_max_hyst); &bslash;&n;} while (0)
r_static
id|ssize_t
DECL|function|show_vid_reg
id|show_vid_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|w83781d_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|vid_from_reg
c_func
(paren
id|data-&gt;vid
comma
id|data-&gt;vrm
)paren
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|cpu0_vid
comma
id|S_IRUGO
comma
id|show_vid_reg
comma
l_int|NULL
)paren
suffix:semicolon
DECL|macro|device_create_file_vid
mdefine_line|#define device_create_file_vid(client) &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_cpu0_vid);
r_static
id|ssize_t
DECL|function|show_vrm_reg
id|show_vrm_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|w83781d_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|data-&gt;vrm
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|store_vrm_reg
id|store_vrm_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
id|u32
id|val
suffix:semicolon
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|data-&gt;vrm
op_assign
id|val
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|vrm
comma
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|show_vrm_reg
comma
id|store_vrm_reg
)paren
suffix:semicolon
DECL|macro|device_create_file_vrm
mdefine_line|#define device_create_file_vrm(client) &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_vrm);
r_static
id|ssize_t
DECL|function|show_alarms_reg
id|show_alarms_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|w83781d_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|ALARMS_FROM_REG
c_func
(paren
id|data-&gt;alarms
)paren
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|alarms
comma
id|S_IRUGO
comma
id|show_alarms_reg
comma
l_int|NULL
)paren
suffix:semicolon
DECL|macro|device_create_file_alarms
mdefine_line|#define device_create_file_alarms(client) &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_alarms);
DECL|function|show_beep_mask
r_static
id|ssize_t
id|show_beep_mask
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|w83781d_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|BEEP_MASK_FROM_REG
c_func
(paren
id|data-&gt;beep_mask
comma
id|data-&gt;type
)paren
)paren
suffix:semicolon
)brace
DECL|function|show_beep_enable
r_static
id|ssize_t
id|show_beep_enable
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|w83781d_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|BEEP_ENABLE_FROM_REG
c_func
(paren
id|data-&gt;beep_enable
)paren
)paren
suffix:semicolon
)brace
DECL|macro|BEEP_ENABLE
mdefine_line|#define BEEP_ENABLE&t;&t;&t;0&t;/* Store beep_enable */
DECL|macro|BEEP_MASK
mdefine_line|#define BEEP_MASK&t;&t;&t;1&t;/* Store beep_mask */
r_static
id|ssize_t
DECL|function|store_beep_reg
id|store_beep_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|update_mask
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
id|u32
id|val
comma
id|val2
suffix:semicolon
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|update_mask
op_eq
id|BEEP_MASK
)paren
(brace
multiline_comment|/* We are storing beep_mask */
id|data-&gt;beep_mask
op_assign
id|BEEP_MASK_TO_REG
c_func
(paren
id|val
comma
id|data-&gt;type
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_BEEP_INTS1
comma
id|data-&gt;beep_mask
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data-&gt;type
op_ne
id|w83781d
)paren
op_logical_and
(paren
id|data-&gt;type
op_ne
id|as99127f
)paren
)paren
(brace
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_BEEP_INTS3
comma
(paren
(paren
id|data-&gt;beep_mask
)paren
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
id|val2
op_assign
(paren
id|data-&gt;beep_mask
op_rshift
l_int|8
)paren
op_amp
l_int|0x7f
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We are storing beep_enable */
id|val2
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_BEEP_INTS2
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|data-&gt;beep_enable
op_assign
id|BEEP_ENABLE_TO_REG
c_func
(paren
id|val
)paren
suffix:semicolon
)brace
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_BEEP_INTS2
comma
id|val2
op_or
id|data-&gt;beep_enable
op_lshift
l_int|7
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|macro|sysfs_beep
mdefine_line|#define sysfs_beep(REG, reg) &bslash;&n;static ssize_t show_regs_beep_##reg (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_beep_##reg(dev, buf); &bslash;&n;} &bslash;&n;static ssize_t store_regs_beep_##reg (struct device *dev, const char *buf, size_t count) &bslash;&n;{ &bslash;&n;&t;return store_beep_reg(dev, buf, count, BEEP_##REG); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(beep_##reg, S_IRUGO | S_IWUSR, show_regs_beep_##reg, store_regs_beep_##reg);
id|sysfs_beep
c_func
(paren
id|ENABLE
comma
id|enable
)paren
suffix:semicolon
id|sysfs_beep
c_func
(paren
id|MASK
comma
id|mask
)paren
suffix:semicolon
DECL|macro|device_create_file_beep
mdefine_line|#define device_create_file_beep(client) &bslash;&n;do { &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_beep_enable); &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_beep_mask); &bslash;&n;} while (0)
r_static
id|ssize_t
DECL|function|show_fan_div_reg
id|show_fan_div_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|w83781d_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|DIV_FROM_REG
c_func
(paren
id|data-&gt;fan_div
(braket
id|nr
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Note: we save and restore the fan minimum here, because its value is&n;   determined in part by the fan divisor.  This follows the principle of&n;   least suprise; the user doesn&squot;t expect the fan minimum to change just&n;   because the divisor changed. */
r_static
id|ssize_t
DECL|function|store_fan_div_reg
id|store_fan_div_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|nr
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_int
r_int
id|min
suffix:semicolon
id|u8
id|reg
suffix:semicolon
multiline_comment|/* Save fan_min */
id|min
op_assign
id|FAN_FROM_REG
c_func
(paren
id|data-&gt;fan_min
(braket
id|nr
)braket
comma
id|DIV_FROM_REG
c_func
(paren
id|data-&gt;fan_div
(braket
id|nr
)braket
)paren
)paren
suffix:semicolon
id|data-&gt;fan_div
(braket
id|nr
)braket
op_assign
id|DIV_TO_REG
c_func
(paren
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
comma
id|data-&gt;type
)paren
suffix:semicolon
id|reg
op_assign
(paren
id|w83781d_read_value
c_func
(paren
id|client
comma
id|nr
op_eq
l_int|2
ques
c_cond
id|W83781D_REG_PIN
suffix:colon
id|W83781D_REG_VID_FANDIV
)paren
op_amp
(paren
id|nr
op_eq
l_int|0
ques
c_cond
l_int|0xcf
suffix:colon
l_int|0x3f
)paren
)paren
op_or
(paren
(paren
id|data-&gt;fan_div
(braket
id|nr
)braket
op_amp
l_int|0x03
)paren
op_lshift
(paren
id|nr
op_eq
l_int|0
ques
c_cond
l_int|4
suffix:colon
l_int|6
)paren
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|nr
op_eq
l_int|2
ques
c_cond
id|W83781D_REG_PIN
suffix:colon
id|W83781D_REG_VID_FANDIV
comma
id|reg
)paren
suffix:semicolon
multiline_comment|/* w83781d and as99127f don&squot;t have extended divisor bits */
r_if
c_cond
(paren
id|data-&gt;type
op_ne
id|w83781d
op_logical_and
id|data-&gt;type
op_ne
id|as99127f
)paren
(brace
id|reg
op_assign
(paren
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_VBAT
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
(paren
l_int|5
op_plus
id|nr
)paren
)paren
)paren
op_or
(paren
(paren
id|data-&gt;fan_div
(braket
id|nr
)braket
op_amp
l_int|0x04
)paren
op_lshift
(paren
l_int|3
op_plus
id|nr
)paren
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_VBAT
comma
id|reg
)paren
suffix:semicolon
)brace
multiline_comment|/* Restore fan_min */
id|data-&gt;fan_min
(braket
id|nr
)braket
op_assign
id|FAN_TO_REG
c_func
(paren
id|min
comma
id|DIV_FROM_REG
c_func
(paren
id|data-&gt;fan_div
(braket
id|nr
)braket
)paren
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_FAN_MIN
c_func
(paren
id|nr
op_plus
l_int|1
)paren
comma
id|data-&gt;fan_min
(braket
id|nr
)braket
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|macro|sysfs_fan_div
mdefine_line|#define sysfs_fan_div(offset) &bslash;&n;static ssize_t show_regs_fan_div_##offset (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_fan_div_reg(dev, buf, offset); &bslash;&n;} &bslash;&n;static ssize_t store_regs_fan_div_##offset (struct device *dev, const char *buf, size_t count) &bslash;&n;{ &bslash;&n;&t;return store_fan_div_reg(dev, buf, count, offset - 1); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(fan##offset##_div, S_IRUGO | S_IWUSR, show_regs_fan_div_##offset, store_regs_fan_div_##offset);
id|sysfs_fan_div
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sysfs_fan_div
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|sysfs_fan_div
c_func
(paren
l_int|3
)paren
suffix:semicolon
DECL|macro|device_create_file_fan_div
mdefine_line|#define device_create_file_fan_div(client, offset) &bslash;&n;do { &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_fan##offset##_div); &bslash;&n;} while (0)
r_static
id|ssize_t
DECL|function|show_pwm_reg
id|show_pwm_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|w83781d_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|PWM_FROM_REG
c_func
(paren
id|data-&gt;pwm
(braket
id|nr
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|show_pwmenable_reg
id|show_pwmenable_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|w83781d_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|data-&gt;pwmenable
(braket
id|nr
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|store_pwm_reg
id|store_pwm_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|nr
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
id|u32
id|val
suffix:semicolon
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|data-&gt;pwm
(braket
id|nr
op_minus
l_int|1
)braket
op_assign
id|PWM_TO_REG
c_func
(paren
id|val
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_PWM
c_func
(paren
id|nr
)paren
comma
id|data-&gt;pwm
(braket
id|nr
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|store_pwmenable_reg
id|store_pwmenable_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|nr
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
id|u32
id|val
comma
id|reg
suffix:semicolon
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|1
suffix:colon
id|reg
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_PWMCLK12
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_PWMCLK12
comma
(paren
id|reg
op_amp
l_int|0xf7
)paren
op_or
(paren
id|val
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|reg
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_BEEP_CONFIG
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_BEEP_CONFIG
comma
(paren
id|reg
op_amp
l_int|0xef
)paren
op_or
(paren
op_logical_neg
id|val
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
id|data-&gt;pwmenable
(braket
id|nr
op_minus
l_int|1
)braket
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|macro|sysfs_pwm
mdefine_line|#define sysfs_pwm(offset) &bslash;&n;static ssize_t show_regs_pwm_##offset (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_pwm_reg(dev, buf, offset); &bslash;&n;} &bslash;&n;static ssize_t store_regs_pwm_##offset (struct device *dev, &bslash;&n;&t;&t;const char *buf, size_t count) &bslash;&n;{ &bslash;&n;&t;return store_pwm_reg(dev, buf, count, offset); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(pwm##offset, S_IRUGO | S_IWUSR, &bslash;&n;&t;&t;show_regs_pwm_##offset, store_regs_pwm_##offset);
DECL|macro|sysfs_pwmenable
mdefine_line|#define sysfs_pwmenable(offset) &bslash;&n;static ssize_t show_regs_pwmenable_##offset (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_pwmenable_reg(dev, buf, offset); &bslash;&n;} &bslash;&n;static ssize_t store_regs_pwmenable_##offset (struct device *dev, &bslash;&n;&t;&t;const char *buf, size_t count) &bslash;&n;{ &bslash;&n;&t;return store_pwmenable_reg(dev, buf, count, offset); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(pwm##offset##_enable, S_IRUGO | S_IWUSR, &bslash;&n;&t;&t;show_regs_pwmenable_##offset, store_regs_pwmenable_##offset);
id|sysfs_pwm
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sysfs_pwm
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|sysfs_pwmenable
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* only PWM2 can be enabled/disabled */
id|sysfs_pwm
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|sysfs_pwm
c_func
(paren
l_int|4
)paren
suffix:semicolon
DECL|macro|device_create_file_pwm
mdefine_line|#define device_create_file_pwm(client, offset) &bslash;&n;do { &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_pwm##offset); &bslash;&n;} while (0)
DECL|macro|device_create_file_pwmenable
mdefine_line|#define device_create_file_pwmenable(client, offset) &bslash;&n;do { &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_pwm##offset##_enable); &bslash;&n;} while (0)
r_static
id|ssize_t
DECL|function|show_sensor_reg
id|show_sensor_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|w83781d_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|data-&gt;sens
(braket
id|nr
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|store_sensor_reg
id|store_sensor_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|nr
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
id|u32
id|val
comma
id|tmp
suffix:semicolon
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* PII/Celeron diode */
id|tmp
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_SCFG1
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_SCFG1
comma
id|tmp
op_or
id|BIT_SCFG1
(braket
id|nr
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|tmp
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_SCFG2
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_SCFG2
comma
id|tmp
op_or
id|BIT_SCFG2
(braket
id|nr
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|data-&gt;sens
(braket
id|nr
op_minus
l_int|1
)braket
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* 3904 */
id|tmp
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_SCFG1
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_SCFG1
comma
id|tmp
op_or
id|BIT_SCFG1
(braket
id|nr
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|tmp
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_SCFG2
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_SCFG2
comma
id|tmp
op_amp
op_complement
id|BIT_SCFG2
(braket
id|nr
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|data-&gt;sens
(braket
id|nr
op_minus
l_int|1
)braket
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|W83781D_DEFAULT_BETA
suffix:colon
multiline_comment|/* thermistor */
id|tmp
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_SCFG1
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_SCFG1
comma
id|tmp
op_amp
op_complement
id|BIT_SCFG1
(braket
id|nr
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|data-&gt;sens
(braket
id|nr
op_minus
l_int|1
)braket
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dev_err
c_func
(paren
id|dev
comma
l_string|&quot;Invalid sensor type %ld; must be 1, 2, or %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|val
comma
id|W83781D_DEFAULT_BETA
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|macro|sysfs_sensor
mdefine_line|#define sysfs_sensor(offset) &bslash;&n;static ssize_t show_regs_sensor_##offset (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;    return show_sensor_reg(dev, buf, offset); &bslash;&n;} &bslash;&n;static ssize_t store_regs_sensor_##offset (struct device *dev, const char *buf, size_t count) &bslash;&n;{ &bslash;&n;    return store_sensor_reg(dev, buf, count, offset); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(temp##offset##_type, S_IRUGO | S_IWUSR, show_regs_sensor_##offset, store_regs_sensor_##offset);
id|sysfs_sensor
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sysfs_sensor
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|sysfs_sensor
c_func
(paren
l_int|3
)paren
suffix:semicolon
DECL|macro|device_create_file_sensor
mdefine_line|#define device_create_file_sensor(client, offset) &bslash;&n;do { &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_temp##offset##_type); &bslash;&n;} while (0)
macro_line|#ifdef W83781D_RT
r_static
id|ssize_t
DECL|function|show_rt_reg
id|show_rt_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|w83781d_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|i
comma
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|j
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot; %ld&quot;
comma
(paren
r_int
)paren
id|data-&gt;rt
(braket
id|nr
op_minus
l_int|1
)braket
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|j
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%ld&quot;
comma
(paren
r_int
)paren
id|data-&gt;rt
(braket
id|nr
op_minus
l_int|1
)braket
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|j
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|j
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|store_rt_reg
id|store_rt_reg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|nr
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
id|u32
id|val
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|buf
op_plus
id|count
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* fixme: no bounds checking 0-255 */
id|data-&gt;rt
(braket
id|nr
op_minus
l_int|1
)braket
(braket
id|i
)braket
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_RT_IDX
comma
id|i
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_RT_VAL
comma
id|data-&gt;rt
(braket
id|nr
op_minus
l_int|1
)braket
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|macro|sysfs_rt
mdefine_line|#define sysfs_rt(offset) &bslash;&n;static ssize_t show_regs_rt_##offset (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_rt_reg(dev, buf, offset); &bslash;&n;} &bslash;&n;static ssize_t store_regs_rt_##offset (struct device *dev, const char *buf, size_t count) &bslash;&n;{ &bslash;&n;    return store_rt_reg(dev, buf, count, offset); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(rt##offset, S_IRUGO | S_IWUSR, show_regs_rt_##offset, store_regs_rt_##offset);
id|sysfs_rt
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sysfs_rt
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|sysfs_rt
c_func
(paren
l_int|3
)paren
suffix:semicolon
DECL|macro|device_create_file_rt
mdefine_line|#define device_create_file_rt(client, offset) &bslash;&n;do { &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_rt##offset); &bslash;&n;} while (0)
macro_line|#endif&t;&t;&t;&t;/* ifdef W83781D_RT */
multiline_comment|/* This function is called when:&n;     * w83781d_driver is inserted (when this module is loaded), for each&n;       available adapter&n;     * when a new adapter is inserted (and w83781d_driver is still present) */
r_static
r_int
DECL|function|w83781d_attach_adapter
id|w83781d_attach_adapter
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|adapter
op_member_access_from_pointer
r_class
op_amp
id|I2C_CLASS_HWMON
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|i2c_detect
c_func
(paren
id|adapter
comma
op_amp
id|addr_data
comma
id|w83781d_detect
)paren
suffix:semicolon
)brace
multiline_comment|/* Assumes that adapter is of I2C, not ISA variety.&n; * OTHERWISE DON&squot;T CALL THIS&n; */
r_static
r_int
DECL|function|w83781d_detect_subclients
id|w83781d_detect_subclients
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
comma
r_int
id|address
comma
r_int
id|kind
comma
r_struct
id|i2c_client
op_star
id|new_client
)paren
(brace
r_int
id|i
comma
id|val1
op_assign
l_int|0
comma
id|id
suffix:semicolon
r_int
id|err
suffix:semicolon
r_const
r_char
op_star
id|client_name
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|new_client
)paren
suffix:semicolon
id|data-&gt;lm75
(braket
l_int|0
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i2c_client
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|data-&gt;lm75
(braket
l_int|0
)braket
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|ERROR_SC_0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|data-&gt;lm75
(braket
l_int|0
)braket
comma
l_int|0x00
comma
r_sizeof
(paren
r_struct
id|i2c_client
)paren
)paren
suffix:semicolon
id|id
op_assign
id|i2c_adapter_id
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|force_subclients
(braket
l_int|0
)braket
op_eq
id|id
op_logical_and
id|force_subclients
(braket
l_int|1
)braket
op_eq
id|address
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
op_le
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|force_subclients
(braket
id|i
)braket
template_param
l_int|0x4f
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;Invalid subclient &quot;
l_string|&quot;address %d; must be 0x48-0x4f&bslash;n&quot;
comma
id|force_subclients
(braket
id|i
)braket
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|ERROR_SC_1
suffix:semicolon
)brace
)brace
id|w83781d_write_value
c_func
(paren
id|new_client
comma
id|W83781D_REG_I2C_SUBADDR
comma
(paren
id|force_subclients
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_or
(paren
(paren
id|force_subclients
(braket
l_int|3
)braket
op_amp
l_int|0x07
)paren
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
id|data-&gt;lm75
(braket
l_int|0
)braket
op_member_access_from_pointer
id|addr
op_assign
id|force_subclients
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_else
(brace
id|val1
op_assign
id|w83781d_read_value
c_func
(paren
id|new_client
comma
id|W83781D_REG_I2C_SUBADDR
)paren
suffix:semicolon
id|data-&gt;lm75
(braket
l_int|0
)braket
op_member_access_from_pointer
id|addr
op_assign
l_int|0x48
op_plus
(paren
id|val1
op_amp
l_int|0x07
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kind
op_ne
id|w83783s
)paren
(brace
id|data-&gt;lm75
(braket
l_int|1
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i2c_client
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|data-&gt;lm75
(braket
l_int|1
)braket
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|ERROR_SC_1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|data-&gt;lm75
(braket
l_int|1
)braket
comma
l_int|0x0
comma
r_sizeof
(paren
r_struct
id|i2c_client
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|force_subclients
(braket
l_int|0
)braket
op_eq
id|id
op_logical_and
id|force_subclients
(braket
l_int|1
)braket
op_eq
id|address
)paren
(brace
id|data-&gt;lm75
(braket
l_int|1
)braket
op_member_access_from_pointer
id|addr
op_assign
id|force_subclients
(braket
l_int|3
)braket
suffix:semicolon
)brace
r_else
(brace
id|data-&gt;lm75
(braket
l_int|1
)braket
op_member_access_from_pointer
id|addr
op_assign
l_int|0x48
op_plus
(paren
(paren
id|val1
op_rshift
l_int|4
)paren
op_amp
l_int|0x07
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data-&gt;lm75
(braket
l_int|0
)braket
op_member_access_from_pointer
id|addr
op_eq
id|data-&gt;lm75
(braket
l_int|1
)braket
op_member_access_from_pointer
id|addr
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;Duplicate addresses 0x%x for subclients.&bslash;n&quot;
comma
id|data-&gt;lm75
(braket
l_int|0
)braket
op_member_access_from_pointer
id|addr
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|ERROR_SC_2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|kind
op_eq
id|w83781d
)paren
id|client_name
op_assign
l_string|&quot;w83781d subclient&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|kind
op_eq
id|w83782d
)paren
id|client_name
op_assign
l_string|&quot;w83782d subclient&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|kind
op_eq
id|w83783s
)paren
id|client_name
op_assign
l_string|&quot;w83783s subclient&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|kind
op_eq
id|w83627hf
)paren
id|client_name
op_assign
l_string|&quot;w83627hf subclient&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|kind
op_eq
id|as99127f
)paren
id|client_name
op_assign
l_string|&quot;as99127f subclient&quot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* store all data in w83781d */
id|i2c_set_clientdata
c_func
(paren
id|data-&gt;lm75
(braket
id|i
)braket
comma
l_int|NULL
)paren
suffix:semicolon
id|data-&gt;lm75
(braket
id|i
)braket
op_member_access_from_pointer
id|adapter
op_assign
id|adapter
suffix:semicolon
id|data-&gt;lm75
(braket
id|i
)braket
op_member_access_from_pointer
id|driver
op_assign
op_amp
id|w83781d_driver
suffix:semicolon
id|data-&gt;lm75
(braket
id|i
)braket
op_member_access_from_pointer
id|flags
op_assign
l_int|0
suffix:semicolon
id|strlcpy
c_func
(paren
id|data-&gt;lm75
(braket
id|i
)braket
op_member_access_from_pointer
id|name
comma
id|client_name
comma
id|I2C_NAME_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|i2c_attach_client
c_func
(paren
id|data-&gt;lm75
(braket
id|i
)braket
)paren
)paren
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;Subclient %d &quot;
l_string|&quot;registration at address 0x%x &quot;
l_string|&quot;failed.&bslash;n&quot;
comma
id|i
comma
id|data-&gt;lm75
(braket
id|i
)braket
op_member_access_from_pointer
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1
)paren
r_goto
id|ERROR_SC_3
suffix:semicolon
r_goto
id|ERROR_SC_2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kind
op_eq
id|w83783s
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Undo inits in case of errors */
id|ERROR_SC_3
suffix:colon
id|i2c_detach_client
c_func
(paren
id|data-&gt;lm75
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ERROR_SC_2
suffix:colon
r_if
c_cond
(paren
l_int|NULL
op_ne
id|data-&gt;lm75
(braket
l_int|1
)braket
)paren
id|kfree
c_func
(paren
id|data-&gt;lm75
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|ERROR_SC_1
suffix:colon
r_if
c_cond
(paren
l_int|NULL
op_ne
id|data-&gt;lm75
(braket
l_int|0
)braket
)paren
id|kfree
c_func
(paren
id|data-&gt;lm75
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ERROR_SC_0
suffix:colon
r_return
id|err
suffix:semicolon
)brace
r_static
r_int
DECL|function|w83781d_detect
id|w83781d_detect
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
comma
r_int
id|address
comma
r_int
id|kind
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|val1
op_assign
l_int|0
comma
id|val2
suffix:semicolon
r_struct
id|i2c_client
op_star
id|new_client
suffix:semicolon
r_struct
id|w83781d_data
op_star
id|data
suffix:semicolon
r_int
id|err
suffix:semicolon
r_const
r_char
op_star
id|client_name
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_int
id|is_isa
op_assign
id|i2c_is_isa_adapter
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_enum
id|vendor
(brace
id|winbond
comma
id|asus
)brace
id|vendid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_isa
op_logical_and
op_logical_neg
id|i2c_check_functionality
c_func
(paren
id|adapter
comma
id|I2C_FUNC_SMBUS_BYTE_DATA
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|ERROR0
suffix:semicolon
)brace
multiline_comment|/* Prevent users from forcing a kind for a bus it isn&squot;t supposed&n;&t;   to possibly be on */
r_if
c_cond
(paren
id|is_isa
op_logical_and
(paren
id|kind
op_eq
id|as99127f
op_logical_or
id|kind
op_eq
id|w83783s
)paren
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|adapter-&gt;dev
comma
l_string|&quot;Cannot force I2C-only chip for ISA address 0x%02x.&bslash;n&quot;
comma
id|address
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|ERROR0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_isa
op_logical_and
id|kind
op_eq
id|w83697hf
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|adapter-&gt;dev
comma
l_string|&quot;Cannot force ISA-only chip for I2C address 0x%02x.&bslash;n&quot;
comma
id|address
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|ERROR0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_isa
)paren
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|address
comma
id|W83781D_EXTENT
comma
id|w83781d_driver.name
)paren
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|adapter-&gt;dev
comma
l_string|&quot;Request of region &quot;
l_string|&quot;0x%x-0x%x for w83781d failed&bslash;n&quot;
comma
id|address
comma
id|address
op_plus
id|W83781D_EXTENT
op_minus
l_int|1
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|ERROR0
suffix:semicolon
)brace
multiline_comment|/* Probe whether there is anything available on this address. Already&n;&t;   done for SMBus clients */
r_if
c_cond
(paren
id|kind
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|is_isa
)paren
(brace
DECL|macro|REALLY_SLOW_IO
mdefine_line|#define REALLY_SLOW_IO
multiline_comment|/* We need the timeouts for at least some LM78-like&n;&t;&t;&t;   chips. But only if we read &squot;undefined&squot; registers. */
id|i
op_assign
id|inb_p
c_func
(paren
id|address
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|address
op_plus
l_int|2
)paren
op_ne
id|i
op_logical_or
id|inb_p
c_func
(paren
id|address
op_plus
l_int|3
)paren
op_ne
id|i
op_logical_or
id|inb_p
c_func
(paren
id|address
op_plus
l_int|7
)paren
op_ne
id|i
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|adapter-&gt;dev
comma
l_string|&quot;Detection of w83781d &quot;
l_string|&quot;chip failed at step 1&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|ERROR1
suffix:semicolon
)brace
DECL|macro|REALLY_SLOW_IO
macro_line|#undef REALLY_SLOW_IO
multiline_comment|/* Let&squot;s just hope nothing breaks here */
id|i
op_assign
id|inb_p
c_func
(paren
id|address
op_plus
l_int|5
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|outb_p
c_func
(paren
op_complement
id|i
op_amp
l_int|0x7f
comma
id|address
op_plus
l_int|5
)paren
suffix:semicolon
id|val2
op_assign
id|inb_p
c_func
(paren
id|address
op_plus
l_int|5
)paren
op_amp
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|val2
op_ne
(paren
op_complement
id|i
op_amp
l_int|0x7f
)paren
)paren
(brace
id|outb_p
c_func
(paren
id|i
comma
id|address
op_plus
l_int|5
)paren
suffix:semicolon
id|dev_dbg
c_func
(paren
op_amp
id|adapter-&gt;dev
comma
l_string|&quot;Detection of w83781d &quot;
l_string|&quot;chip failed at step 2 (0x%x != &quot;
l_string|&quot;0x%x at 0x%x)&bslash;n&quot;
comma
id|val2
comma
op_complement
id|i
op_amp
l_int|0x7f
comma
id|address
op_plus
l_int|5
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|ERROR1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* OK. For now, we presume we have a valid client. We now create the&n;&t;   client structure, even though we cannot fill it completely yet.&n;&t;   But it allows us to access w83781d_{read,write}_value. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|w83781d_data
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|ERROR1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|data
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|w83781d_data
)paren
)paren
suffix:semicolon
id|new_client
op_assign
op_amp
id|data-&gt;client
suffix:semicolon
id|i2c_set_clientdata
c_func
(paren
id|new_client
comma
id|data
)paren
suffix:semicolon
id|new_client-&gt;addr
op_assign
id|address
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
id|new_client-&gt;adapter
op_assign
id|adapter
suffix:semicolon
id|new_client-&gt;driver
op_assign
op_amp
id|w83781d_driver
suffix:semicolon
id|new_client-&gt;flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now, we do the remaining detection. */
multiline_comment|/* The w8378?d may be stuck in some other bank than bank 0. This may&n;&t;   make reading other information impossible. Specify a force=... or&n;&t;   force_*=... parameter, and the Winbond will be reset to the right&n;&t;   bank. */
r_if
c_cond
(paren
id|kind
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|w83781d_read_value
c_func
(paren
id|new_client
comma
id|W83781D_REG_CONFIG
)paren
op_amp
l_int|0x80
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;Detection failed at step &quot;
l_string|&quot;3&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|ERROR2
suffix:semicolon
)brace
id|val1
op_assign
id|w83781d_read_value
c_func
(paren
id|new_client
comma
id|W83781D_REG_BANK
)paren
suffix:semicolon
id|val2
op_assign
id|w83781d_read_value
c_func
(paren
id|new_client
comma
id|W83781D_REG_CHIPMAN
)paren
suffix:semicolon
multiline_comment|/* Check for Winbond or Asus ID if in bank 0 */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|val1
op_amp
l_int|0x07
)paren
)paren
op_logical_and
(paren
(paren
(paren
op_logical_neg
(paren
id|val1
op_amp
l_int|0x80
)paren
)paren
op_logical_and
(paren
id|val2
op_ne
l_int|0xa3
)paren
op_logical_and
(paren
id|val2
op_ne
l_int|0xc3
)paren
)paren
op_logical_or
(paren
(paren
id|val1
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|val2
op_ne
l_int|0x5c
)paren
op_logical_and
(paren
id|val2
op_ne
l_int|0x12
)paren
)paren
)paren
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;Detection failed at step &quot;
l_string|&quot;4&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|ERROR2
suffix:semicolon
)brace
multiline_comment|/* If Winbond SMBus, check address at 0x48.&n;&t;&t;   Asus doesn&squot;t support, except for as99127f rev.2 */
r_if
c_cond
(paren
(paren
op_logical_neg
id|is_isa
)paren
op_logical_and
(paren
(paren
(paren
op_logical_neg
(paren
id|val1
op_amp
l_int|0x80
)paren
)paren
op_logical_and
(paren
id|val2
op_eq
l_int|0xa3
)paren
)paren
op_logical_or
(paren
(paren
id|val1
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|val2
op_eq
l_int|0x5c
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|w83781d_read_value
(paren
id|new_client
comma
id|W83781D_REG_I2C_ADDR
)paren
op_ne
id|address
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;Detection failed &quot;
l_string|&quot;at step 5&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|ERROR2
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* We have either had a force parameter, or we have already detected the&n;&t;   Winbond. Put it now into bank 0 and Vendor ID High Byte */
id|w83781d_write_value
c_func
(paren
id|new_client
comma
id|W83781D_REG_BANK
comma
(paren
id|w83781d_read_value
c_func
(paren
id|new_client
comma
id|W83781D_REG_BANK
)paren
op_amp
l_int|0x78
)paren
op_or
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* Determine the chip type. */
r_if
c_cond
(paren
id|kind
op_le
l_int|0
)paren
(brace
multiline_comment|/* get vendor ID */
id|val2
op_assign
id|w83781d_read_value
c_func
(paren
id|new_client
comma
id|W83781D_REG_CHIPMAN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val2
op_eq
l_int|0x5c
)paren
id|vendid
op_assign
id|winbond
suffix:semicolon
r_else
r_if
c_cond
(paren
id|val2
op_eq
l_int|0x12
)paren
id|vendid
op_assign
id|asus
suffix:semicolon
r_else
(brace
id|dev_dbg
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;Chip was made by neither &quot;
l_string|&quot;Winbond nor Asus?&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|ERROR2
suffix:semicolon
)brace
id|val1
op_assign
id|w83781d_read_value
c_func
(paren
id|new_client
comma
id|W83781D_REG_WCHIPID
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val1
op_eq
l_int|0x10
op_logical_or
id|val1
op_eq
l_int|0x11
)paren
op_logical_and
id|vendid
op_eq
id|winbond
)paren
id|kind
op_assign
id|w83781d
suffix:semicolon
r_else
r_if
c_cond
(paren
id|val1
op_eq
l_int|0x30
op_logical_and
id|vendid
op_eq
id|winbond
)paren
id|kind
op_assign
id|w83782d
suffix:semicolon
r_else
r_if
c_cond
(paren
id|val1
op_eq
l_int|0x40
op_logical_and
id|vendid
op_eq
id|winbond
op_logical_and
op_logical_neg
id|is_isa
op_logical_and
id|address
op_eq
l_int|0x2d
)paren
id|kind
op_assign
id|w83783s
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|val1
op_eq
l_int|0x21
op_logical_or
id|val1
op_eq
l_int|0x90
)paren
op_logical_and
id|vendid
op_eq
id|winbond
)paren
id|kind
op_assign
id|w83627hf
suffix:semicolon
r_else
r_if
c_cond
(paren
id|val1
op_eq
l_int|0x31
op_logical_and
op_logical_neg
id|is_isa
op_logical_and
id|address
op_ge
l_int|0x28
)paren
id|kind
op_assign
id|as99127f
suffix:semicolon
r_else
r_if
c_cond
(paren
id|val1
op_eq
l_int|0x60
op_logical_and
id|vendid
op_eq
id|winbond
op_logical_and
id|is_isa
)paren
id|kind
op_assign
id|w83697hf
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|kind
op_eq
l_int|0
)paren
id|dev_warn
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;Ignoring &squot;force&squot; &quot;
l_string|&quot;parameter for unknown chip at &quot;
l_string|&quot;adapter %d, address 0x%02x&bslash;n&quot;
comma
id|i2c_adapter_id
c_func
(paren
id|adapter
)paren
comma
id|address
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|ERROR2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|kind
op_eq
id|w83781d
)paren
(brace
id|client_name
op_assign
l_string|&quot;w83781d&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kind
op_eq
id|w83782d
)paren
(brace
id|client_name
op_assign
l_string|&quot;w83782d&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kind
op_eq
id|w83783s
)paren
(brace
id|client_name
op_assign
l_string|&quot;w83783s&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kind
op_eq
id|w83627hf
)paren
(brace
r_if
c_cond
(paren
id|val1
op_eq
l_int|0x90
)paren
id|client_name
op_assign
l_string|&quot;w83627thf&quot;
suffix:semicolon
r_else
id|client_name
op_assign
l_string|&quot;w83627hf&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kind
op_eq
id|as99127f
)paren
(brace
id|client_name
op_assign
l_string|&quot;as99127f&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kind
op_eq
id|w83697hf
)paren
(brace
id|client_name
op_assign
l_string|&quot;w83697hf&quot;
suffix:semicolon
)brace
multiline_comment|/* Fill in the remaining client fields and put into the global list */
id|strlcpy
c_func
(paren
id|new_client-&gt;name
comma
id|client_name
comma
id|I2C_NAME_SIZE
)paren
suffix:semicolon
id|data-&gt;type
op_assign
id|kind
suffix:semicolon
id|data-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|data-&gt;update_lock
)paren
suffix:semicolon
multiline_comment|/* Tell the I2C layer a new client has arrived */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|i2c_attach_client
c_func
(paren
id|new_client
)paren
)paren
)paren
r_goto
id|ERROR2
suffix:semicolon
multiline_comment|/* attach secondary i2c lm75-like clients */
r_if
c_cond
(paren
op_logical_neg
id|is_isa
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|w83781d_detect_subclients
c_func
(paren
id|adapter
comma
id|address
comma
id|kind
comma
id|new_client
)paren
)paren
)paren
r_goto
id|ERROR3
suffix:semicolon
)brace
r_else
(brace
id|data-&gt;lm75
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
id|data-&gt;lm75
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Initialize the chip */
id|w83781d_init_client
c_func
(paren
id|new_client
)paren
suffix:semicolon
multiline_comment|/* A few vars need to be filled upon startup */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data-&gt;fan_min
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|new_client
comma
id|W83781D_REG_FAN_MIN
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kind
op_ne
id|w83781d
op_logical_and
id|kind
op_ne
id|as99127f
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|data-&gt;pwmenable
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Register sysfs hooks */
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kind
op_ne
id|w83783s
op_logical_and
id|kind
op_ne
id|w83697hf
)paren
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|1
)paren
suffix:semicolon
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|2
)paren
suffix:semicolon
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|3
)paren
suffix:semicolon
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|4
)paren
suffix:semicolon
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|5
)paren
suffix:semicolon
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kind
op_ne
id|as99127f
op_logical_and
id|kind
op_ne
id|w83781d
op_logical_and
id|kind
op_ne
id|w83783s
)paren
(brace
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|7
)paren
suffix:semicolon
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|8
)paren
suffix:semicolon
)brace
id|device_create_file_fan
c_func
(paren
id|new_client
comma
l_int|1
)paren
suffix:semicolon
id|device_create_file_fan
c_func
(paren
id|new_client
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kind
op_ne
id|w83697hf
)paren
id|device_create_file_fan
c_func
(paren
id|new_client
comma
l_int|3
)paren
suffix:semicolon
id|device_create_file_temp
c_func
(paren
id|new_client
comma
l_int|1
)paren
suffix:semicolon
id|device_create_file_temp
c_func
(paren
id|new_client
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kind
op_ne
id|w83783s
op_logical_and
id|kind
op_ne
id|w83697hf
)paren
id|device_create_file_temp
c_func
(paren
id|new_client
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kind
op_ne
id|w83697hf
)paren
id|device_create_file_vid
c_func
(paren
id|new_client
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kind
op_ne
id|w83697hf
)paren
id|device_create_file_vrm
c_func
(paren
id|new_client
)paren
suffix:semicolon
id|device_create_file_fan_div
c_func
(paren
id|new_client
comma
l_int|1
)paren
suffix:semicolon
id|device_create_file_fan_div
c_func
(paren
id|new_client
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kind
op_ne
id|w83697hf
)paren
id|device_create_file_fan_div
c_func
(paren
id|new_client
comma
l_int|3
)paren
suffix:semicolon
id|device_create_file_alarms
c_func
(paren
id|new_client
)paren
suffix:semicolon
id|device_create_file_beep
c_func
(paren
id|new_client
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kind
op_ne
id|w83781d
op_logical_and
id|kind
op_ne
id|as99127f
)paren
(brace
id|device_create_file_pwm
c_func
(paren
id|new_client
comma
l_int|1
)paren
suffix:semicolon
id|device_create_file_pwm
c_func
(paren
id|new_client
comma
l_int|2
)paren
suffix:semicolon
id|device_create_file_pwmenable
c_func
(paren
id|new_client
comma
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kind
op_eq
id|w83782d
op_logical_and
op_logical_neg
id|is_isa
)paren
(brace
id|device_create_file_pwm
c_func
(paren
id|new_client
comma
l_int|3
)paren
suffix:semicolon
id|device_create_file_pwm
c_func
(paren
id|new_client
comma
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kind
op_ne
id|as99127f
op_logical_and
id|kind
op_ne
id|w83781d
)paren
(brace
id|device_create_file_sensor
c_func
(paren
id|new_client
comma
l_int|1
)paren
suffix:semicolon
id|device_create_file_sensor
c_func
(paren
id|new_client
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kind
op_ne
id|w83783s
op_logical_and
id|kind
op_ne
id|w83697hf
)paren
id|device_create_file_sensor
c_func
(paren
id|new_client
comma
l_int|3
)paren
suffix:semicolon
)brace
macro_line|#ifdef W83781D_RT
r_if
c_cond
(paren
id|kind
op_eq
id|w83781d
)paren
(brace
id|device_create_file_rt
c_func
(paren
id|new_client
comma
l_int|1
)paren
suffix:semicolon
id|device_create_file_rt
c_func
(paren
id|new_client
comma
l_int|2
)paren
suffix:semicolon
id|device_create_file_rt
c_func
(paren
id|new_client
comma
l_int|3
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
id|ERROR3
suffix:colon
id|i2c_detach_client
c_func
(paren
id|new_client
)paren
suffix:semicolon
id|ERROR2
suffix:colon
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
id|ERROR1
suffix:colon
r_if
c_cond
(paren
id|is_isa
)paren
id|release_region
c_func
(paren
id|address
comma
id|W83781D_EXTENT
)paren
suffix:semicolon
id|ERROR0
suffix:colon
r_return
id|err
suffix:semicolon
)brace
r_static
r_int
DECL|function|w83781d_detach_client
id|w83781d_detach_client
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|i2c_is_isa_client
c_func
(paren
id|client
)paren
)paren
id|release_region
c_func
(paren
id|client-&gt;addr
comma
id|W83781D_EXTENT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|i2c_detach_client
c_func
(paren
id|client
)paren
)paren
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|client-&gt;dev
comma
l_string|&quot;Client deregistration failed, client not detached.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* subclients */
id|kfree
c_func
(paren
id|client
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* main client */
id|kfree
c_func
(paren
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The SMBus locks itself, usually, but nothing may access the Winbond between&n;   bank switches. ISA access must always be locked explicitly! &n;   We ignore the W83781D BUSY flag at this moment - it could lead to deadlocks,&n;   would slow down the W83781D access and should not be necessary. &n;   There are some ugly typecasts here, but the good news is - they should&n;   nowhere else be necessary! */
r_static
r_int
DECL|function|w83781d_read_value
id|w83781d_read_value
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
comma
id|u16
id|reg
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_int
id|res
comma
id|word_sized
comma
id|bank
suffix:semicolon
r_struct
id|i2c_client
op_star
id|cl
suffix:semicolon
id|down
c_func
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2c_is_isa_client
c_func
(paren
id|client
)paren
)paren
(brace
id|word_sized
op_assign
(paren
(paren
(paren
id|reg
op_amp
l_int|0xff00
)paren
op_eq
l_int|0x100
)paren
op_logical_or
(paren
(paren
id|reg
op_amp
l_int|0xff00
)paren
op_eq
l_int|0x200
)paren
)paren
op_logical_and
(paren
(paren
(paren
id|reg
op_amp
l_int|0x00ff
)paren
op_eq
l_int|0x50
)paren
op_logical_or
(paren
(paren
id|reg
op_amp
l_int|0x00ff
)paren
op_eq
l_int|0x53
)paren
op_logical_or
(paren
(paren
id|reg
op_amp
l_int|0x00ff
)paren
op_eq
l_int|0x55
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_amp
l_int|0xff00
)paren
(brace
id|outb_p
c_func
(paren
id|W83781D_REG_BANK
comma
id|client-&gt;addr
op_plus
id|W83781D_ADDR_REG_OFFSET
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|reg
op_rshift
l_int|8
comma
id|client-&gt;addr
op_plus
id|W83781D_DATA_REG_OFFSET
)paren
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|reg
op_amp
l_int|0xff
comma
id|client-&gt;addr
op_plus
id|W83781D_ADDR_REG_OFFSET
)paren
suffix:semicolon
id|res
op_assign
id|inb_p
c_func
(paren
id|client-&gt;addr
op_plus
id|W83781D_DATA_REG_OFFSET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|word_sized
)paren
(brace
id|outb_p
c_func
(paren
(paren
id|reg
op_amp
l_int|0xff
)paren
op_plus
l_int|1
comma
id|client-&gt;addr
op_plus
id|W83781D_ADDR_REG_OFFSET
)paren
suffix:semicolon
id|res
op_assign
(paren
id|res
op_lshift
l_int|8
)paren
op_plus
id|inb_p
c_func
(paren
id|client-&gt;addr
op_plus
id|W83781D_DATA_REG_OFFSET
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg
op_amp
l_int|0xff00
)paren
(brace
id|outb_p
c_func
(paren
id|W83781D_REG_BANK
comma
id|client-&gt;addr
op_plus
id|W83781D_ADDR_REG_OFFSET
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|client-&gt;addr
op_plus
id|W83781D_DATA_REG_OFFSET
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|bank
op_assign
(paren
id|reg
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|bank
OG
l_int|2
)paren
multiline_comment|/* switch banks */
id|i2c_smbus_write_byte_data
c_func
(paren
id|client
comma
id|W83781D_REG_BANK
comma
id|bank
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bank
op_eq
l_int|0
op_logical_or
id|bank
OG
l_int|2
)paren
(brace
id|res
op_assign
id|i2c_smbus_read_byte_data
c_func
(paren
id|client
comma
id|reg
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* switch to subclient */
id|cl
op_assign
id|data-&gt;lm75
(braket
id|bank
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* convert from ISA to LM75 I2C addresses */
r_switch
c_cond
(paren
id|reg
op_amp
l_int|0xff
)paren
(brace
r_case
l_int|0x50
suffix:colon
multiline_comment|/* TEMP */
id|res
op_assign
id|swab16
c_func
(paren
id|i2c_smbus_read_word_data
c_func
(paren
id|cl
comma
l_int|0
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x52
suffix:colon
multiline_comment|/* CONFIG */
id|res
op_assign
id|i2c_smbus_read_byte_data
c_func
(paren
id|cl
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x53
suffix:colon
multiline_comment|/* HYST */
id|res
op_assign
id|swab16
c_func
(paren
id|i2c_smbus_read_word_data
c_func
(paren
id|cl
comma
l_int|2
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x55
suffix:colon
multiline_comment|/* OVER */
r_default
suffix:colon
id|res
op_assign
id|swab16
c_func
(paren
id|i2c_smbus_read_word_data
c_func
(paren
id|cl
comma
l_int|3
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bank
OG
l_int|2
)paren
id|i2c_smbus_write_byte_data
c_func
(paren
id|client
comma
id|W83781D_REG_BANK
comma
l_int|0
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_static
r_int
DECL|function|w83781d_write_value
id|w83781d_write_value
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
comma
id|u16
id|reg
comma
id|u16
id|value
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_int
id|word_sized
comma
id|bank
suffix:semicolon
r_struct
id|i2c_client
op_star
id|cl
suffix:semicolon
id|down
c_func
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2c_is_isa_client
c_func
(paren
id|client
)paren
)paren
(brace
id|word_sized
op_assign
(paren
(paren
(paren
id|reg
op_amp
l_int|0xff00
)paren
op_eq
l_int|0x100
)paren
op_logical_or
(paren
(paren
id|reg
op_amp
l_int|0xff00
)paren
op_eq
l_int|0x200
)paren
)paren
op_logical_and
(paren
(paren
(paren
id|reg
op_amp
l_int|0x00ff
)paren
op_eq
l_int|0x53
)paren
op_logical_or
(paren
(paren
id|reg
op_amp
l_int|0x00ff
)paren
op_eq
l_int|0x55
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_amp
l_int|0xff00
)paren
(brace
id|outb_p
c_func
(paren
id|W83781D_REG_BANK
comma
id|client-&gt;addr
op_plus
id|W83781D_ADDR_REG_OFFSET
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|reg
op_rshift
l_int|8
comma
id|client-&gt;addr
op_plus
id|W83781D_DATA_REG_OFFSET
)paren
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|reg
op_amp
l_int|0xff
comma
id|client-&gt;addr
op_plus
id|W83781D_ADDR_REG_OFFSET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|word_sized
)paren
(brace
id|outb_p
c_func
(paren
id|value
op_rshift
l_int|8
comma
id|client-&gt;addr
op_plus
id|W83781D_DATA_REG_OFFSET
)paren
suffix:semicolon
id|outb_p
c_func
(paren
(paren
id|reg
op_amp
l_int|0xff
)paren
op_plus
l_int|1
comma
id|client-&gt;addr
op_plus
id|W83781D_ADDR_REG_OFFSET
)paren
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|value
op_amp
l_int|0xff
comma
id|client-&gt;addr
op_plus
id|W83781D_DATA_REG_OFFSET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_amp
l_int|0xff00
)paren
(brace
id|outb_p
c_func
(paren
id|W83781D_REG_BANK
comma
id|client-&gt;addr
op_plus
id|W83781D_ADDR_REG_OFFSET
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|client-&gt;addr
op_plus
id|W83781D_DATA_REG_OFFSET
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|bank
op_assign
(paren
id|reg
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|bank
OG
l_int|2
)paren
multiline_comment|/* switch banks */
id|i2c_smbus_write_byte_data
c_func
(paren
id|client
comma
id|W83781D_REG_BANK
comma
id|bank
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bank
op_eq
l_int|0
op_logical_or
id|bank
OG
l_int|2
)paren
(brace
id|i2c_smbus_write_byte_data
c_func
(paren
id|client
comma
id|reg
op_amp
l_int|0xff
comma
id|value
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* switch to subclient */
id|cl
op_assign
id|data-&gt;lm75
(braket
id|bank
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* convert from ISA to LM75 I2C addresses */
r_switch
c_cond
(paren
id|reg
op_amp
l_int|0xff
)paren
(brace
r_case
l_int|0x52
suffix:colon
multiline_comment|/* CONFIG */
id|i2c_smbus_write_byte_data
c_func
(paren
id|cl
comma
l_int|1
comma
id|value
op_amp
l_int|0xff
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x53
suffix:colon
multiline_comment|/* HYST */
id|i2c_smbus_write_word_data
c_func
(paren
id|cl
comma
l_int|2
comma
id|swab16
c_func
(paren
id|value
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x55
suffix:colon
multiline_comment|/* OVER */
id|i2c_smbus_write_word_data
c_func
(paren
id|cl
comma
l_int|3
comma
id|swab16
c_func
(paren
id|value
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bank
OG
l_int|2
)paren
id|i2c_smbus_write_byte_data
c_func
(paren
id|client
comma
id|W83781D_REG_BANK
comma
l_int|0
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Called when we have found a new W83781D. It should set limits, etc. */
r_static
r_void
DECL|function|w83781d_init_client
id|w83781d_init_client
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
)paren
(brace
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_int
id|i
comma
id|p
suffix:semicolon
r_int
id|type
op_assign
id|data-&gt;type
suffix:semicolon
id|u8
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|init
op_logical_and
id|type
op_ne
id|as99127f
)paren
(brace
multiline_comment|/* this resets registers we don&squot;t have&n;&t;&t;&t;&t;&t;   documentation for on the as99127f */
multiline_comment|/* save these registers */
id|i
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_BEEP_CONFIG
)paren
suffix:semicolon
id|p
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_PWMCLK12
)paren
suffix:semicolon
multiline_comment|/* Reset all except Watchdog values and last conversion values&n;&t;&t;   This sets fan-divs to 2, among others */
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_CONFIG
comma
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* Restore the registers and disable power-on abnormal beep.&n;&t;&t;   This saves FAN 1/2/3 input/output values set by BIOS. */
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_BEEP_CONFIG
comma
id|i
op_or
l_int|0x80
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_PWMCLK12
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* Disable master beep-enable (reset turns it on).&n;&t;&t;   Individual beep_mask should be reset to off but for some reason&n;&t;&t;   disabling this bit helps some people not get beeped */
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_BEEP_INTS2
comma
l_int|0
)paren
suffix:semicolon
)brace
id|data-&gt;vrm
op_assign
id|i2c_which_vrm
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_ne
id|w83781d
)paren
op_logical_and
(paren
id|type
op_ne
id|as99127f
)paren
)paren
(brace
id|tmp
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_SCFG1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_amp
id|BIT_SCFG1
(braket
id|i
op_minus
l_int|1
)braket
)paren
)paren
(brace
id|data-&gt;sens
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|W83781D_DEFAULT_BETA
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|w83781d_read_value
(paren
id|client
comma
id|W83781D_REG_SCFG2
)paren
op_amp
id|BIT_SCFG2
(braket
id|i
op_minus
l_int|1
)braket
)paren
id|data-&gt;sens
(braket
id|i
op_minus
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
r_else
id|data-&gt;sens
(braket
id|i
op_minus
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|type
op_eq
id|w83783s
op_logical_or
id|type
op_eq
id|w83697hf
)paren
op_logical_and
(paren
id|i
op_eq
l_int|2
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
macro_line|#ifdef W83781D_RT
multiline_comment|/*&n;   Fill up the RT Tables.&n;   We assume that they are 32 bytes long, in order for temp 1-3.&n;   Data sheet documentation is sparse.&n;   We also assume that it is only for the 781D although I suspect&n;   that the others support it as well....&n;*/
r_if
c_cond
(paren
id|init
op_logical_and
id|type
op_eq
id|w83781d
)paren
(brace
id|u16
id|k
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;    Auto-indexing doesn&squot;t seem to work...&n;    w83781d_write_value(client,W83781D_REG_RT_IDX,0);&n;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|32
suffix:semicolon
id|j
op_increment
)paren
(brace
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_RT_IDX
comma
id|k
op_increment
)paren
suffix:semicolon
id|data-&gt;rt
(braket
id|i
)braket
(braket
id|j
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_RT_VAL
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* W83781D_RT */
r_if
c_cond
(paren
id|init
op_logical_and
id|type
op_ne
id|as99127f
)paren
(brace
multiline_comment|/* Enable temp2 */
id|tmp
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP2_CONFIG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
l_int|0x01
)paren
(brace
id|dev_warn
c_func
(paren
op_amp
id|client-&gt;dev
comma
l_string|&quot;Enabling temp2, readings &quot;
l_string|&quot;might not make sense&bslash;n&quot;
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP2_CONFIG
comma
id|tmp
op_amp
l_int|0xfe
)paren
suffix:semicolon
)brace
multiline_comment|/* Enable temp3 */
r_if
c_cond
(paren
id|type
op_ne
id|w83783s
op_logical_and
id|type
op_ne
id|w83697hf
)paren
(brace
id|tmp
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP3_CONFIG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
l_int|0x01
)paren
(brace
id|dev_warn
c_func
(paren
op_amp
id|client-&gt;dev
comma
l_string|&quot;Enabling temp3, &quot;
l_string|&quot;readings might not make sense&bslash;n&quot;
)paren
suffix:semicolon
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP3_CONFIG
comma
id|tmp
op_amp
l_int|0xfe
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|type
op_ne
id|w83781d
)paren
(brace
multiline_comment|/* enable comparator mode for temp2 and temp3 so&n;&t;&t;&t;   alarm indication will work correctly */
id|i
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_IRQ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_amp
l_int|0x40
)paren
)paren
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_IRQ
comma
id|i
op_or
l_int|0x40
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Start monitoring */
id|w83781d_write_value
c_func
(paren
id|client
comma
id|W83781D_REG_CONFIG
comma
(paren
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_CONFIG
)paren
op_amp
l_int|0xf7
)paren
op_or
l_int|0x01
)paren
suffix:semicolon
)brace
DECL|function|w83781d_update_device
r_static
r_struct
id|w83781d_data
op_star
id|w83781d_update_device
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|w83781d_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|down
c_func
(paren
op_amp
id|data-&gt;update_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|data-&gt;last_updated
op_plus
id|HZ
op_plus
id|HZ
op_div
l_int|2
)paren
op_logical_or
op_logical_neg
id|data-&gt;valid
)paren
(brace
id|dev_dbg
c_func
(paren
id|dev
comma
l_string|&quot;Starting device update&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|data-&gt;type
op_eq
id|w83783s
op_logical_or
id|data-&gt;type
op_eq
id|w83697hf
)paren
op_logical_and
(paren
id|i
op_eq
l_int|1
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* 783S has no in1 */
id|data-&gt;in
(braket
id|i
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_IN
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|data-&gt;in_min
(braket
id|i
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_IN_MIN
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|data-&gt;in_max
(braket
id|i
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_IN_MAX
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data-&gt;type
op_ne
id|w83782d
)paren
op_logical_and
(paren
id|data-&gt;type
op_ne
id|w83697hf
)paren
op_logical_and
(paren
id|data-&gt;type
op_ne
id|w83627hf
)paren
op_logical_and
(paren
id|i
op_eq
l_int|6
)paren
)paren
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data-&gt;fan
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_FAN
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|data-&gt;fan_min
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_FAN_MIN
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data-&gt;type
op_ne
id|w83781d
op_logical_and
id|data-&gt;type
op_ne
id|as99127f
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data-&gt;pwm
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_PWM
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data-&gt;type
op_ne
id|w83782d
op_logical_or
id|i2c_is_isa_client
c_func
(paren
id|client
)paren
)paren
op_logical_and
id|i
op_eq
l_int|2
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Only PWM2 can be disabled */
id|data-&gt;pwmenable
(braket
l_int|1
)braket
op_assign
(paren
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_PWMCLK12
)paren
op_amp
l_int|0x08
)paren
op_rshift
l_int|3
suffix:semicolon
)brace
id|data-&gt;temp
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|data-&gt;temp_max
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP_OVER
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|data-&gt;temp_max_hyst
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP_HYST
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|data-&gt;temp_add
(braket
l_int|0
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
id|data-&gt;temp_max_add
(braket
l_int|0
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP_OVER
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
id|data-&gt;temp_max_hyst_add
(braket
l_int|0
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP_HYST
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;type
op_ne
id|w83783s
op_logical_and
id|data-&gt;type
op_ne
id|w83697hf
)paren
(brace
id|data-&gt;temp_add
(braket
l_int|1
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
id|data-&gt;temp_max_add
(braket
l_int|1
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP_OVER
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
id|data-&gt;temp_max_hyst_add
(braket
l_int|1
)braket
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_TEMP_HYST
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
)brace
id|i
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_VID_FANDIV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;type
op_ne
id|w83697hf
)paren
(brace
id|data-&gt;vid
op_assign
id|i
op_amp
l_int|0x0f
suffix:semicolon
id|data-&gt;vid
op_or_assign
(paren
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_CHIPID
)paren
op_amp
l_int|0x01
)paren
op_lshift
l_int|4
suffix:semicolon
)brace
id|data-&gt;fan_div
(braket
l_int|0
)braket
op_assign
(paren
id|i
op_rshift
l_int|4
)paren
op_amp
l_int|0x03
suffix:semicolon
id|data-&gt;fan_div
(braket
l_int|1
)braket
op_assign
(paren
id|i
op_rshift
l_int|6
)paren
op_amp
l_int|0x03
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;type
op_ne
id|w83697hf
)paren
(brace
id|data-&gt;fan_div
(braket
l_int|2
)braket
op_assign
(paren
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_PIN
)paren
op_rshift
l_int|6
)paren
op_amp
l_int|0x03
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|data-&gt;type
op_ne
id|w83781d
)paren
op_logical_and
(paren
id|data-&gt;type
op_ne
id|as99127f
)paren
)paren
(brace
id|i
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_VBAT
)paren
suffix:semicolon
id|data-&gt;fan_div
(braket
l_int|0
)braket
op_or_assign
(paren
id|i
op_rshift
l_int|3
)paren
op_amp
l_int|0x04
suffix:semicolon
id|data-&gt;fan_div
(braket
l_int|1
)braket
op_or_assign
(paren
id|i
op_rshift
l_int|4
)paren
op_amp
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;type
op_ne
id|w83697hf
)paren
id|data-&gt;fan_div
(braket
l_int|2
)braket
op_or_assign
(paren
id|i
op_rshift
l_int|5
)paren
op_amp
l_int|0x04
suffix:semicolon
)brace
id|data-&gt;alarms
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_ALARM1
)paren
op_plus
(paren
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_ALARM2
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data-&gt;type
op_eq
id|w83782d
)paren
op_logical_or
(paren
id|data-&gt;type
op_eq
id|w83627hf
)paren
)paren
(brace
id|data-&gt;alarms
op_or_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_ALARM3
)paren
op_lshift
l_int|16
suffix:semicolon
)brace
id|i
op_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_BEEP_INTS2
)paren
suffix:semicolon
id|data-&gt;beep_enable
op_assign
id|i
op_rshift
l_int|7
suffix:semicolon
id|data-&gt;beep_mask
op_assign
(paren
(paren
id|i
op_amp
l_int|0x7f
)paren
op_lshift
l_int|8
)paren
op_plus
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_BEEP_INTS1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data-&gt;type
op_ne
id|w83781d
)paren
op_logical_and
(paren
id|data-&gt;type
op_ne
id|as99127f
)paren
)paren
(brace
id|data-&gt;beep_mask
op_or_assign
id|w83781d_read_value
c_func
(paren
id|client
comma
id|W83781D_REG_BEEP_INTS3
)paren
op_lshift
l_int|16
suffix:semicolon
)brace
id|data-&gt;last_updated
op_assign
id|jiffies
suffix:semicolon
id|data-&gt;valid
op_assign
l_int|1
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|data-&gt;update_lock
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|sensors_w83781d_init
id|sensors_w83781d_init
c_func
(paren
r_void
)paren
(brace
r_return
id|i2c_add_driver
c_func
(paren
op_amp
id|w83781d_driver
)paren
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|sensors_w83781d_exit
id|sensors_w83781d_exit
c_func
(paren
r_void
)paren
(brace
id|i2c_del_driver
c_func
(paren
op_amp
id|w83781d_driver
)paren
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Frodo Looijaard &lt;frodol@dds.nl&gt;, &quot;
l_string|&quot;Philip Edelbrock &lt;phil@netroedge.com&gt;, &quot;
l_string|&quot;and Mark Studebaker &lt;mdsxyz123@yahoo.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;W83781D driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|sensors_w83781d_init
id|module_init
c_func
(paren
id|sensors_w83781d_init
)paren
suffix:semicolon
DECL|variable|sensors_w83781d_exit
id|module_exit
c_func
(paren
id|sensors_w83781d_exit
)paren
suffix:semicolon
eof
