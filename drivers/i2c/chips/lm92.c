multiline_comment|/*&n; * lm92 - Hardware monitoring driver&n; * Copyright (C) 2005  Jean Delvare &lt;khali@linux-fr.org&gt;&n; *&n; * Based on the lm90 driver, with some ideas taken from the lm_sensors&n; * lm92 driver as well.&n; *&n; * The LM92 is a sensor chip made by National Semiconductor. It reports&n; * its own temperature with a 0.0625 deg resolution and a 0.33 deg&n; * accuracy. Complete datasheet can be obtained from National&squot;s website&n; * at:&n; *   http://www.national.com/pf/LM/LM92.html&n; *&n; * This driver also supports the MAX6635 sensor chip made by Maxim.&n; * This chip is compatible with the LM92, but has a lesser accuracy&n; * (1.0 deg). Complete datasheet can be obtained from Maxim&squot;s website&n; * at:&n; *   http://www.maxim-ic.com/quick_view2.cfm/qv_pk/3074&n; *&n; * Since the LM92 was the first chipset supported by this driver, most&n; * comments will refer to this chipset, but are actually general and&n; * concern all supported chipsets, unless mentioned otherwise.&n; *&n; * Support could easily be added for the National Semiconductor LM76&n; * and Maxim MAX6633 and MAX6634 chips, which are mostly compatible&n; * with the LM92.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/i2c.h&gt;
macro_line|#include &lt;linux/i2c-sensor.h&gt;
multiline_comment|/* The LM92 and MAX6635 have 2 two-state pins for address selection,&n;   resulting in 4 possible addresses. */
DECL|variable|normal_i2c
r_static
r_int
r_int
id|normal_i2c
(braket
)braket
op_assign
(brace
l_int|0x48
comma
l_int|0x49
comma
l_int|0x4a
comma
l_int|0x4b
comma
id|I2C_CLIENT_END
)brace
suffix:semicolon
DECL|variable|normal_isa
r_static
r_int
r_int
id|normal_isa
(braket
)braket
op_assign
(brace
id|I2C_CLIENT_ISA_END
)brace
suffix:semicolon
multiline_comment|/* Insmod parameters */
DECL|variable|lm92
id|SENSORS_INSMOD_1
c_func
(paren
id|lm92
)paren
suffix:semicolon
multiline_comment|/* The LM92 registers */
DECL|macro|LM92_REG_CONFIG
mdefine_line|#define LM92_REG_CONFIG&t;&t;&t;0x01 /* 8-bit, RW */
DECL|macro|LM92_REG_TEMP
mdefine_line|#define LM92_REG_TEMP&t;&t;&t;0x00 /* 16-bit, RO */
DECL|macro|LM92_REG_TEMP_HYST
mdefine_line|#define LM92_REG_TEMP_HYST&t;&t;0x02 /* 16-bit, RW */
DECL|macro|LM92_REG_TEMP_CRIT
mdefine_line|#define LM92_REG_TEMP_CRIT&t;&t;0x03 /* 16-bit, RW */
DECL|macro|LM92_REG_TEMP_LOW
mdefine_line|#define LM92_REG_TEMP_LOW&t;&t;0x04 /* 16-bit, RW */
DECL|macro|LM92_REG_TEMP_HIGH
mdefine_line|#define LM92_REG_TEMP_HIGH&t;&t;0x05 /* 16-bit, RW */
DECL|macro|LM92_REG_MAN_ID
mdefine_line|#define LM92_REG_MAN_ID&t;&t;&t;0x07 /* 16-bit, RO, LM92 only */
multiline_comment|/* The LM92 uses signed 13-bit values with LSB = 0.0625 degree Celsius,&n;   left-justified in 16-bit registers. No rounding is done, with such&n;   a resolution it&squot;s just not worth it. Note that the MAX6635 doesn&squot;t&n;   make use of the 4 lower bits for limits (i.e. effective resolution&n;   for limits is 1 degree Celsius). */
DECL|function|TEMP_FROM_REG
r_static
r_inline
r_int
id|TEMP_FROM_REG
c_func
(paren
id|s16
id|reg
)paren
(brace
r_return
id|reg
op_div
l_int|8
op_star
l_int|625
op_div
l_int|10
suffix:semicolon
)brace
DECL|function|TEMP_TO_REG
r_static
r_inline
id|s16
id|TEMP_TO_REG
c_func
(paren
r_int
id|val
)paren
(brace
r_if
c_cond
(paren
id|val
op_le
op_minus
l_int|60000
)paren
r_return
op_minus
l_int|60000
op_star
l_int|10
op_div
l_int|625
op_star
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|160000
)paren
r_return
l_int|160000
op_star
l_int|10
op_div
l_int|625
op_star
l_int|8
suffix:semicolon
r_return
id|val
op_star
l_int|10
op_div
l_int|625
op_star
l_int|8
suffix:semicolon
)brace
multiline_comment|/* Alarm flags are stored in the 3 LSB of the temperature register */
DECL|function|ALARMS_FROM_REG
r_static
r_inline
id|u8
id|ALARMS_FROM_REG
c_func
(paren
id|s16
id|reg
)paren
(brace
r_return
id|reg
op_amp
l_int|0x0007
suffix:semicolon
)brace
multiline_comment|/* Driver data (common to all clients) */
DECL|variable|lm92_driver
r_static
r_struct
id|i2c_driver
id|lm92_driver
suffix:semicolon
multiline_comment|/* Client data (each client gets its own) */
DECL|struct|lm92_data
r_struct
id|lm92_data
(brace
DECL|member|client
r_struct
id|i2c_client
id|client
suffix:semicolon
DECL|member|update_lock
r_struct
id|semaphore
id|update_lock
suffix:semicolon
DECL|member|valid
r_char
id|valid
suffix:semicolon
multiline_comment|/* zero until following fields are valid */
DECL|member|last_updated
r_int
r_int
id|last_updated
suffix:semicolon
multiline_comment|/* in jiffies */
multiline_comment|/* registers values */
DECL|member|temp1_input
DECL|member|temp1_crit
DECL|member|temp1_min
DECL|member|temp1_max
DECL|member|temp1_hyst
id|s16
id|temp1_input
comma
id|temp1_crit
comma
id|temp1_min
comma
id|temp1_max
comma
id|temp1_hyst
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Sysfs attributes and callback functions&n; */
DECL|function|lm92_update_device
r_static
r_struct
id|lm92_data
op_star
id|lm92_update_device
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|lm92_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|data-&gt;update_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|data-&gt;last_updated
op_plus
id|HZ
)paren
op_logical_or
op_logical_neg
id|data-&gt;valid
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|client-&gt;dev
comma
l_string|&quot;Updating lm92 data&bslash;n&quot;
)paren
suffix:semicolon
id|data-&gt;temp1_input
op_assign
id|swab16
c_func
(paren
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP
)paren
)paren
suffix:semicolon
id|data-&gt;temp1_hyst
op_assign
id|swab16
c_func
(paren
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_HYST
)paren
)paren
suffix:semicolon
id|data-&gt;temp1_crit
op_assign
id|swab16
c_func
(paren
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_CRIT
)paren
)paren
suffix:semicolon
id|data-&gt;temp1_min
op_assign
id|swab16
c_func
(paren
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_LOW
)paren
)paren
suffix:semicolon
id|data-&gt;temp1_max
op_assign
id|swab16
c_func
(paren
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_HIGH
)paren
)paren
suffix:semicolon
id|data-&gt;last_updated
op_assign
id|jiffies
suffix:semicolon
id|data-&gt;valid
op_assign
l_int|1
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|data-&gt;update_lock
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|macro|show_temp
mdefine_line|#define show_temp(value) &bslash;&n;static ssize_t show_##value(struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;struct lm92_data *data = lm92_update_device(dev); &bslash;&n;&t;return sprintf(buf, &quot;%d&bslash;n&quot;, TEMP_FROM_REG(data-&gt;value)); &bslash;&n;}
DECL|variable|temp1_input
id|show_temp
c_func
(paren
id|temp1_input
)paren
suffix:semicolon
DECL|variable|temp1_crit
id|show_temp
c_func
(paren
id|temp1_crit
)paren
suffix:semicolon
DECL|variable|temp1_min
id|show_temp
c_func
(paren
id|temp1_min
)paren
suffix:semicolon
DECL|variable|temp1_max
id|show_temp
c_func
(paren
id|temp1_max
)paren
suffix:semicolon
DECL|macro|set_temp
mdefine_line|#define set_temp(value, reg) &bslash;&n;static ssize_t set_##value(struct device *dev, const char *buf, &bslash;&n;&t;size_t count) &bslash;&n;{ &bslash;&n;&t;struct i2c_client *client = to_i2c_client(dev); &bslash;&n;&t;struct lm92_data *data = i2c_get_clientdata(client); &bslash;&n;&t;long val = simple_strtol(buf, NULL, 10); &bslash;&n; &bslash;&n;&t;down(&amp;data-&gt;update_lock); &bslash;&n;&t;data-&gt;value = TEMP_TO_REG(val); &bslash;&n;&t;i2c_smbus_write_word_data(client, reg, swab16(data-&gt;value)); &bslash;&n;&t;up(&amp;data-&gt;update_lock); &bslash;&n;&t;return count; &bslash;&n;}
id|set_temp
c_func
(paren
id|temp1_crit
comma
id|LM92_REG_TEMP_CRIT
)paren
suffix:semicolon
id|set_temp
c_func
(paren
id|temp1_min
comma
id|LM92_REG_TEMP_LOW
)paren
suffix:semicolon
id|set_temp
c_func
(paren
id|temp1_max
comma
id|LM92_REG_TEMP_HIGH
)paren
suffix:semicolon
DECL|function|show_temp1_crit_hyst
r_static
id|ssize_t
id|show_temp1_crit_hyst
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|lm92_data
op_star
id|data
op_assign
id|lm92_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|TEMP_FROM_REG
c_func
(paren
id|data-&gt;temp1_crit
)paren
op_minus
id|TEMP_FROM_REG
c_func
(paren
id|data-&gt;temp1_hyst
)paren
)paren
suffix:semicolon
)brace
DECL|function|show_temp1_max_hyst
r_static
id|ssize_t
id|show_temp1_max_hyst
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|lm92_data
op_star
id|data
op_assign
id|lm92_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|TEMP_FROM_REG
c_func
(paren
id|data-&gt;temp1_max
)paren
op_minus
id|TEMP_FROM_REG
c_func
(paren
id|data-&gt;temp1_hyst
)paren
)paren
suffix:semicolon
)brace
DECL|function|show_temp1_min_hyst
r_static
id|ssize_t
id|show_temp1_min_hyst
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|lm92_data
op_star
id|data
op_assign
id|lm92_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|TEMP_FROM_REG
c_func
(paren
id|data-&gt;temp1_min
)paren
op_plus
id|TEMP_FROM_REG
c_func
(paren
id|data-&gt;temp1_hyst
)paren
)paren
suffix:semicolon
)brace
DECL|function|set_temp1_crit_hyst
r_static
id|ssize_t
id|set_temp1_crit_hyst
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|lm92_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_int
id|val
op_assign
id|simple_strtol
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|data-&gt;update_lock
)paren
suffix:semicolon
id|data-&gt;temp1_hyst
op_assign
id|TEMP_FROM_REG
c_func
(paren
id|data-&gt;temp1_crit
)paren
op_minus
id|val
suffix:semicolon
id|i2c_smbus_write_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_HYST
comma
id|swab16
c_func
(paren
id|TEMP_TO_REG
c_func
(paren
id|data-&gt;temp1_hyst
)paren
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|data-&gt;update_lock
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|show_alarms
r_static
id|ssize_t
id|show_alarms
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|lm92_data
op_star
id|data
op_assign
id|lm92_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|ALARMS_FROM_REG
c_func
(paren
id|data-&gt;temp1_input
)paren
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|temp1_input
comma
id|S_IRUGO
comma
id|show_temp1_input
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|temp1_crit
comma
id|S_IWUSR
op_or
id|S_IRUGO
comma
id|show_temp1_crit
comma
id|set_temp1_crit
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|temp1_crit_hyst
comma
id|S_IWUSR
op_or
id|S_IRUGO
comma
id|show_temp1_crit_hyst
comma
id|set_temp1_crit_hyst
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|temp1_min
comma
id|S_IWUSR
op_or
id|S_IRUGO
comma
id|show_temp1_min
comma
id|set_temp1_min
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|temp1_min_hyst
comma
id|S_IRUGO
comma
id|show_temp1_min_hyst
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|temp1_max
comma
id|S_IWUSR
op_or
id|S_IRUGO
comma
id|show_temp1_max
comma
id|set_temp1_max
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|temp1_max_hyst
comma
id|S_IRUGO
comma
id|show_temp1_max_hyst
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|alarms
comma
id|S_IRUGO
comma
id|show_alarms
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n; * Detection and registration&n; */
DECL|function|lm92_init_client
r_static
r_void
id|lm92_init_client
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
)paren
(brace
id|u8
id|config
suffix:semicolon
multiline_comment|/* Start the conversions if needed */
id|config
op_assign
id|i2c_smbus_read_byte_data
c_func
(paren
id|client
comma
id|LM92_REG_CONFIG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config
op_amp
l_int|0x01
)paren
id|i2c_smbus_write_byte_data
c_func
(paren
id|client
comma
id|LM92_REG_CONFIG
comma
id|config
op_amp
l_int|0xFE
)paren
suffix:semicolon
)brace
multiline_comment|/* The MAX6635 has no identification register, so we have to use tricks&n;   to identify it reliably. This is somewhat slow.&n;   Note that we do NOT rely on the 2 MSB of the configuration register&n;   always reading 0, as suggested by the datasheet, because it was once&n;   reported not to be true. */
DECL|function|max6635_check
r_static
r_int
id|max6635_check
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
)paren
(brace
id|u16
id|temp_low
comma
id|temp_high
comma
id|temp_hyst
comma
id|temp_crit
suffix:semicolon
id|u8
id|conf
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* No manufacturer ID register, so a read from this address will&n;&t;   always return the last read value. */
id|temp_low
op_assign
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_LOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_MAN_ID
)paren
op_ne
id|temp_low
)paren
r_return
l_int|0
suffix:semicolon
id|temp_high
op_assign
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_HIGH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_MAN_ID
)paren
op_ne
id|temp_high
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Limits are stored as integer values (signed, 9-bit). */
r_if
c_cond
(paren
(paren
id|temp_low
op_amp
l_int|0x7f00
)paren
op_logical_or
(paren
id|temp_high
op_amp
l_int|0x7f00
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|temp_hyst
op_assign
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_HYST
)paren
suffix:semicolon
id|temp_crit
op_assign
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_CRIT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp_hyst
op_amp
l_int|0x7f00
)paren
op_logical_or
(paren
id|temp_crit
op_amp
l_int|0x7f00
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Registers addresses were found to cycle over 16-byte boundaries.&n;&t;   We don&squot;t test all registers with all offsets so as to save some&n;&t;   reads and time, but this should still be sufficient to dismiss&n;&t;   non-MAX6635 chips. */
id|conf
op_assign
id|i2c_smbus_read_byte_data
c_func
(paren
id|client
comma
id|LM92_REG_CONFIG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|96
suffix:semicolon
id|i
op_mul_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|temp_hyst
op_ne
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_HYST
op_plus
id|i
op_minus
l_int|16
)paren
op_logical_or
id|temp_crit
op_ne
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_CRIT
op_plus
id|i
)paren
op_logical_or
id|temp_low
op_ne
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_LOW
op_plus
id|i
op_plus
l_int|16
)paren
op_logical_or
id|temp_high
op_ne
id|i2c_smbus_read_word_data
c_func
(paren
id|client
comma
id|LM92_REG_TEMP_HIGH
op_plus
id|i
op_plus
l_int|32
)paren
op_logical_or
id|conf
op_ne
id|i2c_smbus_read_byte_data
c_func
(paren
id|client
comma
id|LM92_REG_CONFIG
op_plus
id|i
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* The following function does more than just detection. If detection&n;   succeeds, it also registers the new chip. */
DECL|function|lm92_detect
r_static
r_int
id|lm92_detect
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
comma
r_int
id|address
comma
r_int
id|kind
)paren
(brace
r_struct
id|i2c_client
op_star
id|new_client
suffix:semicolon
r_struct
id|lm92_data
op_star
id|data
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i2c_check_functionality
c_func
(paren
id|adapter
comma
id|I2C_FUNC_SMBUS_BYTE_DATA
op_or
id|I2C_FUNC_SMBUS_WORD_DATA
)paren
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lm92_data
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|memset
c_func
(paren
id|data
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lm92_data
)paren
)paren
suffix:semicolon
multiline_comment|/* Fill in enough client fields so that we can read from the chip,&n;&t;   which is required for identication */
id|new_client
op_assign
op_amp
id|data-&gt;client
suffix:semicolon
id|i2c_set_clientdata
c_func
(paren
id|new_client
comma
id|data
)paren
suffix:semicolon
id|new_client-&gt;addr
op_assign
id|address
suffix:semicolon
id|new_client-&gt;adapter
op_assign
id|adapter
suffix:semicolon
id|new_client-&gt;driver
op_assign
op_amp
id|lm92_driver
suffix:semicolon
id|new_client-&gt;flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* A negative kind means that the driver was loaded with no force&n;&t;   parameter (default), so we must identify the chip. */
r_if
c_cond
(paren
id|kind
OL
l_int|0
)paren
(brace
id|u8
id|config
op_assign
id|i2c_smbus_read_byte_data
c_func
(paren
id|new_client
comma
id|LM92_REG_CONFIG
)paren
suffix:semicolon
id|u16
id|man_id
op_assign
id|i2c_smbus_read_word_data
c_func
(paren
id|new_client
comma
id|LM92_REG_MAN_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|config
op_amp
l_int|0xe0
)paren
op_eq
l_int|0x00
op_logical_and
id|man_id
op_eq
l_int|0x0180
)paren
(brace
id|pr_info
c_func
(paren
l_string|&quot;lm92: Found National Semiconductor LM92 chip&bslash;n&quot;
)paren
suffix:semicolon
id|kind
op_assign
id|lm92
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|max6635_check
c_func
(paren
id|new_client
)paren
)paren
(brace
id|pr_info
c_func
(paren
l_string|&quot;lm92: Found Maxim MAX6635 chip&bslash;n&quot;
)paren
suffix:semicolon
id|kind
op_assign
id|lm92
suffix:semicolon
multiline_comment|/* No separate prefix */
)brace
r_else
r_goto
id|exit_free
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kind
op_eq
l_int|0
)paren
multiline_comment|/* Default to an LM92 if forced */
id|kind
op_assign
id|lm92
suffix:semicolon
multiline_comment|/* Give it the proper name */
r_if
c_cond
(paren
id|kind
op_eq
id|lm92
)paren
(brace
id|name
op_assign
l_string|&quot;lm92&quot;
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Supposedly cannot happen */
id|dev_dbg
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;Kind out of range?&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|exit_free
suffix:semicolon
)brace
multiline_comment|/* Fill in the remaining client fields */
id|strlcpy
c_func
(paren
id|new_client-&gt;name
comma
id|name
comma
id|I2C_NAME_SIZE
)paren
suffix:semicolon
id|data-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|data-&gt;update_lock
)paren
suffix:semicolon
multiline_comment|/* Tell the i2c subsystem a new client has arrived */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|i2c_attach_client
c_func
(paren
id|new_client
)paren
)paren
)paren
r_goto
id|exit_free
suffix:semicolon
multiline_comment|/* Initialize the chipset */
id|lm92_init_client
c_func
(paren
id|new_client
)paren
suffix:semicolon
multiline_comment|/* Register sysfs hooks */
id|device_create_file
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
op_amp
id|dev_attr_temp1_input
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
op_amp
id|dev_attr_temp1_crit
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
op_amp
id|dev_attr_temp1_crit_hyst
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
op_amp
id|dev_attr_temp1_min
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
op_amp
id|dev_attr_temp1_min_hyst
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
op_amp
id|dev_attr_temp1_max
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
op_amp
id|dev_attr_temp1_max_hyst
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
op_amp
id|dev_attr_alarms
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|exit_free
suffix:colon
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|lm92_attach_adapter
r_static
r_int
id|lm92_attach_adapter
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|adapter
op_member_access_from_pointer
r_class
op_amp
id|I2C_CLASS_HWMON
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|i2c_detect
c_func
(paren
id|adapter
comma
op_amp
id|addr_data
comma
id|lm92_detect
)paren
suffix:semicolon
)brace
DECL|function|lm92_detach_client
r_static
r_int
id|lm92_detach_client
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|i2c_detach_client
c_func
(paren
id|client
)paren
)paren
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|client-&gt;dev
comma
l_string|&quot;Client deregistration failed, &quot;
l_string|&quot;client not detached.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Module and driver stuff&n; */
DECL|variable|lm92_driver
r_static
r_struct
id|i2c_driver
id|lm92_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;lm92&quot;
comma
dot
id|id
op_assign
id|I2C_DRIVERID_LM92
comma
dot
id|flags
op_assign
id|I2C_DF_NOTIFY
comma
dot
id|attach_adapter
op_assign
id|lm92_attach_adapter
comma
dot
id|detach_client
op_assign
id|lm92_detach_client
comma
)brace
suffix:semicolon
DECL|function|sensors_lm92_init
r_static
r_int
id|__init
id|sensors_lm92_init
c_func
(paren
r_void
)paren
(brace
r_return
id|i2c_add_driver
c_func
(paren
op_amp
id|lm92_driver
)paren
suffix:semicolon
)brace
DECL|function|sensors_lm92_exit
r_static
r_void
id|__exit
id|sensors_lm92_exit
c_func
(paren
r_void
)paren
(brace
id|i2c_del_driver
c_func
(paren
op_amp
id|lm92_driver
)paren
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Jean Delvare &lt;khali@linux-fr.org&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;LM92/MAX6635 driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|sensors_lm92_init
id|module_init
c_func
(paren
id|sensors_lm92_init
)paren
suffix:semicolon
DECL|variable|sensors_lm92_exit
id|module_exit
c_func
(paren
id|sensors_lm92_exit
)paren
suffix:semicolon
eof
