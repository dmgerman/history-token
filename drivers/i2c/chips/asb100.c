multiline_comment|/*&n;    asb100.c - Part of lm_sensors, Linux kernel modules for hardware&n;&t;        monitoring&n;&n;    Copyright (C) 2004 Mark M. Hoffman &lt;mhoffman@lightlink.com&gt;&n;&n;&t;(derived from w83781d.c)&n;&n;    Copyright (C) 1998 - 2003  Frodo Looijaard &lt;frodol@dds.nl&gt;,&n;    Philip Edelbrock &lt;phil@netroedge.com&gt;, and&n;    Mark Studebaker &lt;mdsxyz123@yahoo.com&gt;&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2 of the License, or&n;    (at your option) any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;*/
multiline_comment|/*&n;    This driver supports the hardware sensor chips: Asus ASB100 and&n;    ASB100-A &quot;BACH&quot;.&n;&n;    ASB100-A supports pwm1, while plain ASB100 does not.  There is no known&n;    way for the driver to tell which one is there.&n;&n;    Chip&t;#vin&t;#fanin&t;#pwm&t;#temp&t;wchipid&t;vendid&t;i2c&t;ISA&n;    asb100&t;7&t;3&t;1&t;4&t;0x31&t;0x0694&t;yes&t;no&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/i2c.h&gt;
macro_line|#include &lt;linux/i2c-sensor.h&gt;
macro_line|#include &lt;linux/i2c-vid.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &quot;lm75.h&quot;
multiline_comment|/*&n;&t;HISTORY:&n;&t;2003-12-29&t;1.0.0&t;Ported from lm_sensors project for kernel 2.6&n;*/
DECL|macro|ASB100_VERSION
mdefine_line|#define ASB100_VERSION &quot;1.0.0&quot;
multiline_comment|/* I2C addresses to scan */
DECL|variable|normal_i2c
r_static
r_int
r_int
id|normal_i2c
(braket
)braket
op_assign
(brace
l_int|0x2d
comma
id|I2C_CLIENT_END
)brace
suffix:semicolon
multiline_comment|/* ISA addresses to scan (none) */
DECL|variable|normal_isa
r_static
r_int
r_int
id|normal_isa
(braket
)braket
op_assign
(brace
id|I2C_CLIENT_ISA_END
)brace
suffix:semicolon
multiline_comment|/* Insmod parameters */
DECL|variable|asb100
id|SENSORS_INSMOD_1
c_func
(paren
id|asb100
)paren
suffix:semicolon
id|I2C_CLIENT_MODULE_PARM
c_func
(paren
id|force_subclients
comma
l_string|&quot;List of subclient addresses: &quot;
l_string|&quot;{bus, clientaddr, subclientaddr1, subclientaddr2}&quot;
)paren
suffix:semicolon
multiline_comment|/* Voltage IN registers 0-6 */
DECL|macro|ASB100_REG_IN
mdefine_line|#define ASB100_REG_IN(nr)&t;(0x20 + (nr))
DECL|macro|ASB100_REG_IN_MAX
mdefine_line|#define ASB100_REG_IN_MAX(nr)&t;(0x2b + (nr * 2))
DECL|macro|ASB100_REG_IN_MIN
mdefine_line|#define ASB100_REG_IN_MIN(nr)&t;(0x2c + (nr * 2))
multiline_comment|/* FAN IN registers 1-3 */
DECL|macro|ASB100_REG_FAN
mdefine_line|#define ASB100_REG_FAN(nr)&t;(0x28 + (nr))
DECL|macro|ASB100_REG_FAN_MIN
mdefine_line|#define ASB100_REG_FAN_MIN(nr)&t;(0x3b + (nr))
multiline_comment|/* TEMPERATURE registers 1-4 */
DECL|variable|asb100_reg_temp
r_static
r_const
id|u16
id|asb100_reg_temp
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0x27
comma
l_int|0x150
comma
l_int|0x250
comma
l_int|0x17
)brace
suffix:semicolon
DECL|variable|asb100_reg_temp_max
r_static
r_const
id|u16
id|asb100_reg_temp_max
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0x39
comma
l_int|0x155
comma
l_int|0x255
comma
l_int|0x18
)brace
suffix:semicolon
DECL|variable|asb100_reg_temp_hyst
r_static
r_const
id|u16
id|asb100_reg_temp_hyst
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0x3a
comma
l_int|0x153
comma
l_int|0x253
comma
l_int|0x19
)brace
suffix:semicolon
DECL|macro|ASB100_REG_TEMP
mdefine_line|#define ASB100_REG_TEMP(nr) (asb100_reg_temp[nr])
DECL|macro|ASB100_REG_TEMP_MAX
mdefine_line|#define ASB100_REG_TEMP_MAX(nr) (asb100_reg_temp_max[nr])
DECL|macro|ASB100_REG_TEMP_HYST
mdefine_line|#define ASB100_REG_TEMP_HYST(nr) (asb100_reg_temp_hyst[nr])
DECL|macro|ASB100_REG_TEMP2_CONFIG
mdefine_line|#define ASB100_REG_TEMP2_CONFIG&t;0x0152
DECL|macro|ASB100_REG_TEMP3_CONFIG
mdefine_line|#define ASB100_REG_TEMP3_CONFIG&t;0x0252
DECL|macro|ASB100_REG_CONFIG
mdefine_line|#define ASB100_REG_CONFIG&t;0x40
DECL|macro|ASB100_REG_ALARM1
mdefine_line|#define ASB100_REG_ALARM1&t;0x41
DECL|macro|ASB100_REG_ALARM2
mdefine_line|#define ASB100_REG_ALARM2&t;0x42
DECL|macro|ASB100_REG_SMIM1
mdefine_line|#define ASB100_REG_SMIM1&t;0x43
DECL|macro|ASB100_REG_SMIM2
mdefine_line|#define ASB100_REG_SMIM2&t;0x44
DECL|macro|ASB100_REG_VID_FANDIV
mdefine_line|#define ASB100_REG_VID_FANDIV&t;0x47
DECL|macro|ASB100_REG_I2C_ADDR
mdefine_line|#define ASB100_REG_I2C_ADDR&t;0x48
DECL|macro|ASB100_REG_CHIPID
mdefine_line|#define ASB100_REG_CHIPID&t;0x49
DECL|macro|ASB100_REG_I2C_SUBADDR
mdefine_line|#define ASB100_REG_I2C_SUBADDR&t;0x4a
DECL|macro|ASB100_REG_PIN
mdefine_line|#define ASB100_REG_PIN&t;&t;0x4b
DECL|macro|ASB100_REG_IRQ
mdefine_line|#define ASB100_REG_IRQ&t;&t;0x4c
DECL|macro|ASB100_REG_BANK
mdefine_line|#define ASB100_REG_BANK&t;&t;0x4e
DECL|macro|ASB100_REG_CHIPMAN
mdefine_line|#define ASB100_REG_CHIPMAN&t;0x4f
DECL|macro|ASB100_REG_WCHIPID
mdefine_line|#define ASB100_REG_WCHIPID&t;0x58
multiline_comment|/* bit 7 -&gt; enable, bits 0-3 -&gt; duty cycle */
DECL|macro|ASB100_REG_PWM1
mdefine_line|#define ASB100_REG_PWM1&t;&t;0x59
multiline_comment|/* CONVERSIONS&n;   Rounding and limit checking is only done on the TO_REG variants. */
multiline_comment|/* These constants are a guess, consistent w/ w83781d */
DECL|macro|ASB100_IN_MIN
mdefine_line|#define ASB100_IN_MIN (   0)
DECL|macro|ASB100_IN_MAX
mdefine_line|#define ASB100_IN_MAX (4080)
multiline_comment|/* IN: 1/1000 V (0V to 4.08V)&n;   REG: 16mV/bit */
DECL|function|IN_TO_REG
r_static
id|u8
id|IN_TO_REG
c_func
(paren
r_int
id|val
)paren
(brace
r_int
id|nval
op_assign
id|SENSORS_LIMIT
c_func
(paren
id|val
comma
id|ASB100_IN_MIN
comma
id|ASB100_IN_MAX
)paren
suffix:semicolon
r_return
(paren
id|nval
op_plus
l_int|8
)paren
op_div
l_int|16
suffix:semicolon
)brace
DECL|function|IN_FROM_REG
r_static
r_int
id|IN_FROM_REG
c_func
(paren
id|u8
id|reg
)paren
(brace
r_return
id|reg
op_star
l_int|16
suffix:semicolon
)brace
DECL|function|FAN_TO_REG
r_static
id|u8
id|FAN_TO_REG
c_func
(paren
r_int
id|rpm
comma
r_int
id|div
)paren
(brace
r_if
c_cond
(paren
id|rpm
op_eq
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rpm
op_eq
l_int|0
)paren
r_return
l_int|255
suffix:semicolon
id|rpm
op_assign
id|SENSORS_LIMIT
c_func
(paren
id|rpm
comma
l_int|1
comma
l_int|1000000
)paren
suffix:semicolon
r_return
id|SENSORS_LIMIT
c_func
(paren
(paren
l_int|1350000
op_plus
id|rpm
op_star
id|div
op_div
l_int|2
)paren
op_div
(paren
id|rpm
op_star
id|div
)paren
comma
l_int|1
comma
l_int|254
)paren
suffix:semicolon
)brace
DECL|function|FAN_FROM_REG
r_static
r_int
id|FAN_FROM_REG
c_func
(paren
id|u8
id|val
comma
r_int
id|div
)paren
(brace
r_return
id|val
op_eq
l_int|0
ques
c_cond
op_minus
l_int|1
suffix:colon
id|val
op_eq
l_int|255
ques
c_cond
l_int|0
suffix:colon
l_int|1350000
op_div
(paren
id|val
op_star
id|div
)paren
suffix:semicolon
)brace
multiline_comment|/* These constants are a guess, consistent w/ w83781d */
DECL|macro|ASB100_TEMP_MIN
mdefine_line|#define ASB100_TEMP_MIN (-128000)
DECL|macro|ASB100_TEMP_MAX
mdefine_line|#define ASB100_TEMP_MAX ( 127000)
multiline_comment|/* TEMP: 0.001C/bit (-128C to +127C)&n;   REG: 1C/bit, two&squot;s complement */
DECL|function|TEMP_TO_REG
r_static
id|u8
id|TEMP_TO_REG
c_func
(paren
r_int
id|temp
)paren
(brace
r_int
id|ntemp
op_assign
id|SENSORS_LIMIT
c_func
(paren
id|temp
comma
id|ASB100_TEMP_MIN
comma
id|ASB100_TEMP_MAX
)paren
suffix:semicolon
id|ntemp
op_add_assign
(paren
id|ntemp
OL
l_int|0
ques
c_cond
op_minus
l_int|500
suffix:colon
l_int|500
)paren
suffix:semicolon
r_return
(paren
id|u8
)paren
(paren
id|ntemp
op_div
l_int|1000
)paren
suffix:semicolon
)brace
DECL|function|TEMP_FROM_REG
r_static
r_int
id|TEMP_FROM_REG
c_func
(paren
id|u8
id|reg
)paren
(brace
r_return
(paren
id|s8
)paren
id|reg
op_star
l_int|1000
suffix:semicolon
)brace
multiline_comment|/* PWM: 0 - 255 per sensors documentation&n;   REG: (6.25% duty cycle per bit) */
DECL|function|ASB100_PWM_TO_REG
r_static
id|u8
id|ASB100_PWM_TO_REG
c_func
(paren
r_int
id|pwm
)paren
(brace
id|pwm
op_assign
id|SENSORS_LIMIT
c_func
(paren
id|pwm
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
r_return
(paren
id|u8
)paren
(paren
id|pwm
op_div
l_int|16
)paren
suffix:semicolon
)brace
DECL|function|ASB100_PWM_FROM_REG
r_static
r_int
id|ASB100_PWM_FROM_REG
c_func
(paren
id|u8
id|reg
)paren
(brace
r_return
id|reg
op_star
l_int|16
suffix:semicolon
)brace
DECL|macro|ALARMS_FROM_REG
mdefine_line|#define ALARMS_FROM_REG(val) (val)
DECL|macro|DIV_FROM_REG
mdefine_line|#define DIV_FROM_REG(val) (1 &lt;&lt; (val))
multiline_comment|/* FAN DIV: 1, 2, 4, or 8 (defaults to 2)&n;   REG: 0, 1, 2, or 3 (respectively) (defaults to 1) */
DECL|function|DIV_TO_REG
r_static
id|u8
id|DIV_TO_REG
c_func
(paren
r_int
id|val
)paren
(brace
r_return
id|val
op_eq
l_int|8
ques
c_cond
l_int|3
suffix:colon
id|val
op_eq
l_int|4
ques
c_cond
l_int|2
suffix:colon
id|val
op_eq
l_int|1
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/* For each registered client, we need to keep some data in memory. That&n;   data is pointed to by client-&gt;data. The structure itself is&n;   dynamically allocated, at the same time the client itself is allocated. */
DECL|struct|asb100_data
r_struct
id|asb100_data
(brace
DECL|member|client
r_struct
id|i2c_client
id|client
suffix:semicolon
DECL|member|lock
r_struct
id|semaphore
id|lock
suffix:semicolon
DECL|member|type
r_enum
id|chips
id|type
suffix:semicolon
DECL|member|update_lock
r_struct
id|semaphore
id|update_lock
suffix:semicolon
DECL|member|last_updated
r_int
r_int
id|last_updated
suffix:semicolon
multiline_comment|/* In jiffies */
multiline_comment|/* array of 2 pointers to subclients */
DECL|member|lm75
r_struct
id|i2c_client
op_star
id|lm75
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|valid
r_char
id|valid
suffix:semicolon
multiline_comment|/* !=0 if following fields are valid */
DECL|member|in
id|u8
id|in
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|in_max
id|u8
id|in_max
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|in_min
id|u8
id|in_min
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|fan
id|u8
id|fan
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|fan_min
id|u8
id|fan_min
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Register value */
DECL|member|temp
id|u16
id|temp
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Register value (0 and 3 are u8 only) */
DECL|member|temp_max
id|u16
id|temp_max
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Register value (0 and 3 are u8 only) */
DECL|member|temp_hyst
id|u16
id|temp_hyst
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Register value (0 and 3 are u8 only) */
DECL|member|fan_div
id|u8
id|fan_div
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Register encoding, right justified */
DECL|member|pwm
id|u8
id|pwm
suffix:semicolon
multiline_comment|/* Register encoding */
DECL|member|vid
id|u8
id|vid
suffix:semicolon
multiline_comment|/* Register encoding, combined */
DECL|member|alarms
id|u32
id|alarms
suffix:semicolon
multiline_comment|/* Register encoding, combined */
DECL|member|vrm
id|u8
id|vrm
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
id|asb100_read_value
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
comma
id|u16
id|reg
)paren
suffix:semicolon
r_static
r_void
id|asb100_write_value
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
comma
id|u16
id|reg
comma
id|u16
id|val
)paren
suffix:semicolon
r_static
r_int
id|asb100_attach_adapter
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
)paren
suffix:semicolon
r_static
r_int
id|asb100_detect
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
comma
r_int
id|address
comma
r_int
id|kind
)paren
suffix:semicolon
r_static
r_int
id|asb100_detach_client
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
)paren
suffix:semicolon
r_static
r_struct
id|asb100_data
op_star
id|asb100_update_device
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|asb100_init_client
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
)paren
suffix:semicolon
DECL|variable|asb100_driver
r_static
r_struct
id|i2c_driver
id|asb100_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;asb100&quot;
comma
dot
id|id
op_assign
id|I2C_DRIVERID_ASB100
comma
dot
id|flags
op_assign
id|I2C_DF_NOTIFY
comma
dot
id|attach_adapter
op_assign
id|asb100_attach_adapter
comma
dot
id|detach_client
op_assign
id|asb100_detach_client
comma
)brace
suffix:semicolon
multiline_comment|/* 7 Voltages */
DECL|macro|show_in_reg
mdefine_line|#define show_in_reg(reg) &bslash;&n;static ssize_t show_##reg (struct device *dev, char *buf, int nr) &bslash;&n;{ &bslash;&n;&t;struct asb100_data *data = asb100_update_device(dev); &bslash;&n;&t;return sprintf(buf, &quot;%d&bslash;n&quot;, IN_FROM_REG(data-&gt;reg[nr])); &bslash;&n;}
id|show_in_reg
c_func
(paren
id|in
)paren
id|show_in_reg
c_func
(paren
id|in_min
)paren
id|show_in_reg
c_func
(paren
id|in_max
)paren
DECL|macro|set_in_reg
mdefine_line|#define set_in_reg(REG, reg) &bslash;&n;static ssize_t set_in_##reg(struct device *dev, const char *buf, &bslash;&n;&t;&t;size_t count, int nr) &bslash;&n;{ &bslash;&n;&t;struct i2c_client *client = to_i2c_client(dev); &bslash;&n;&t;struct asb100_data *data = i2c_get_clientdata(client); &bslash;&n;&t;unsigned long val = simple_strtoul(buf, NULL, 10); &bslash;&n;&t;data-&gt;in_##reg[nr] = IN_TO_REG(val); &bslash;&n;&t;asb100_write_value(client, ASB100_REG_IN_##REG(nr), &bslash;&n;&t;&t;data-&gt;in_##reg[nr]); &bslash;&n;&t;return count; &bslash;&n;}
id|set_in_reg
c_func
(paren
id|MIN
comma
id|min
)paren
id|set_in_reg
c_func
(paren
id|MAX
comma
id|max
)paren
DECL|macro|sysfs_in
mdefine_line|#define sysfs_in(offset) &bslash;&n;static ssize_t &bslash;&n;&t;show_in##offset (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_in(dev, buf, offset); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(in##offset##_input, S_IRUGO, &bslash;&n;&t;&t;show_in##offset, NULL); &bslash;&n;static ssize_t &bslash;&n;&t;show_in##offset##_min (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_in_min(dev, buf, offset); &bslash;&n;} &bslash;&n;static ssize_t &bslash;&n;&t;show_in##offset##_max (struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_in_max(dev, buf, offset); &bslash;&n;} &bslash;&n;static ssize_t set_in##offset##_min (struct device *dev, &bslash;&n;&t;&t;const char *buf, size_t count) &bslash;&n;{ &bslash;&n;&t;return set_in_min(dev, buf, count, offset); &bslash;&n;} &bslash;&n;static ssize_t set_in##offset##_max (struct device *dev, &bslash;&n;&t;&t;const char *buf, size_t count) &bslash;&n;{ &bslash;&n;&t;return set_in_max(dev, buf, count, offset); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR, &bslash;&n;&t;&t;show_in##offset##_min, set_in##offset##_min); &bslash;&n;static DEVICE_ATTR(in##offset##_max, S_IRUGO | S_IWUSR, &bslash;&n;&t;&t;show_in##offset##_max, set_in##offset##_max);
id|sysfs_in
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|sysfs_in
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sysfs_in
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|sysfs_in
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|sysfs_in
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|sysfs_in
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|sysfs_in
c_func
(paren
l_int|6
)paren
suffix:semicolon
DECL|macro|device_create_file_in
mdefine_line|#define device_create_file_in(client, offset) do { &bslash;&n;&t;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_in##offset##_input); &bslash;&n;&t;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_in##offset##_min); &bslash;&n;&t;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_in##offset##_max); &bslash;&n;} while (0)
multiline_comment|/* 3 Fans */
DECL|function|show_fan
r_static
id|ssize_t
id|show_fan
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_struct
id|asb100_data
op_star
id|data
op_assign
id|asb100_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|FAN_FROM_REG
c_func
(paren
id|data-&gt;fan
(braket
id|nr
)braket
comma
id|DIV_FROM_REG
c_func
(paren
id|data-&gt;fan_div
(braket
id|nr
)braket
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|show_fan_min
r_static
id|ssize_t
id|show_fan_min
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_struct
id|asb100_data
op_star
id|data
op_assign
id|asb100_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|FAN_FROM_REG
c_func
(paren
id|data-&gt;fan_min
(braket
id|nr
)braket
comma
id|DIV_FROM_REG
c_func
(paren
id|data-&gt;fan_div
(braket
id|nr
)braket
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|show_fan_div
r_static
id|ssize_t
id|show_fan_div
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_struct
id|asb100_data
op_star
id|data
op_assign
id|asb100_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|DIV_FROM_REG
c_func
(paren
id|data-&gt;fan_div
(braket
id|nr
)braket
)paren
)paren
suffix:semicolon
)brace
DECL|function|set_fan_min
r_static
id|ssize_t
id|set_fan_min
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|nr
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|asb100_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
id|u32
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|data-&gt;fan_min
(braket
id|nr
)braket
op_assign
id|FAN_TO_REG
c_func
(paren
id|val
comma
id|DIV_FROM_REG
c_func
(paren
id|data-&gt;fan_div
(braket
id|nr
)braket
)paren
)paren
suffix:semicolon
id|asb100_write_value
c_func
(paren
id|client
comma
id|ASB100_REG_FAN_MIN
c_func
(paren
id|nr
)paren
comma
id|data-&gt;fan_min
(braket
id|nr
)braket
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* Note: we save and restore the fan minimum here, because its value is&n;   determined in part by the fan divisor.  This follows the principle of&n;   least suprise; the user doesn&squot;t expect the fan minimum to change just&n;   because the divisor changed. */
DECL|function|set_fan_div
r_static
id|ssize_t
id|set_fan_div
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|nr
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|asb100_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_int
r_int
id|min
op_assign
id|FAN_FROM_REG
c_func
(paren
id|data-&gt;fan_min
(braket
id|nr
)braket
comma
id|DIV_FROM_REG
c_func
(paren
id|data-&gt;fan_div
(braket
id|nr
)braket
)paren
)paren
suffix:semicolon
r_int
r_int
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_int
id|reg
suffix:semicolon
id|data-&gt;fan_div
(braket
id|nr
)braket
op_assign
id|DIV_TO_REG
c_func
(paren
id|val
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|nr
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* fan 1 */
id|reg
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_VID_FANDIV
)paren
suffix:semicolon
id|reg
op_assign
(paren
id|reg
op_amp
l_int|0xcf
)paren
op_or
(paren
id|data-&gt;fan_div
(braket
l_int|0
)braket
op_lshift
l_int|4
)paren
suffix:semicolon
id|asb100_write_value
c_func
(paren
id|client
comma
id|ASB100_REG_VID_FANDIV
comma
id|reg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* fan 2 */
id|reg
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_VID_FANDIV
)paren
suffix:semicolon
id|reg
op_assign
(paren
id|reg
op_amp
l_int|0x3f
)paren
op_or
(paren
id|data-&gt;fan_div
(braket
l_int|1
)braket
op_lshift
l_int|6
)paren
suffix:semicolon
id|asb100_write_value
c_func
(paren
id|client
comma
id|ASB100_REG_VID_FANDIV
comma
id|reg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* fan 3 */
id|reg
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_PIN
)paren
suffix:semicolon
id|reg
op_assign
(paren
id|reg
op_amp
l_int|0x3f
)paren
op_or
(paren
id|data-&gt;fan_div
(braket
l_int|2
)braket
op_lshift
l_int|6
)paren
suffix:semicolon
id|asb100_write_value
c_func
(paren
id|client
comma
id|ASB100_REG_PIN
comma
id|reg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|data-&gt;fan_min
(braket
id|nr
)braket
op_assign
id|FAN_TO_REG
c_func
(paren
id|min
comma
id|DIV_FROM_REG
c_func
(paren
id|data-&gt;fan_div
(braket
id|nr
)braket
)paren
)paren
suffix:semicolon
id|asb100_write_value
c_func
(paren
id|client
comma
id|ASB100_REG_FAN_MIN
c_func
(paren
id|nr
)paren
comma
id|data-&gt;fan_min
(braket
id|nr
)braket
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|macro|sysfs_fan
mdefine_line|#define sysfs_fan(offset) &bslash;&n;static ssize_t show_fan##offset(struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_fan(dev, buf, offset - 1); &bslash;&n;} &bslash;&n;static ssize_t show_fan##offset##_min(struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_fan_min(dev, buf, offset - 1); &bslash;&n;} &bslash;&n;static ssize_t show_fan##offset##_div(struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_fan_div(dev, buf, offset - 1); &bslash;&n;} &bslash;&n;static ssize_t set_fan##offset##_min(struct device *dev, const char *buf, &bslash;&n;&t;&t;&t;&t;&t;size_t count) &bslash;&n;{ &bslash;&n;&t;return set_fan_min(dev, buf, count, offset - 1); &bslash;&n;} &bslash;&n;static ssize_t set_fan##offset##_div(struct device *dev, const char *buf, &bslash;&n;&t;&t;&t;&t;&t;size_t count) &bslash;&n;{ &bslash;&n;&t;return set_fan_div(dev, buf, count, offset - 1); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(fan##offset##_input, S_IRUGO, &bslash;&n;&t;&t;show_fan##offset, NULL); &bslash;&n;static DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR, &bslash;&n;&t;&t;show_fan##offset##_min, set_fan##offset##_min); &bslash;&n;static DEVICE_ATTR(fan##offset##_div, S_IRUGO | S_IWUSR, &bslash;&n;&t;&t;show_fan##offset##_div, set_fan##offset##_div);
id|sysfs_fan
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sysfs_fan
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|sysfs_fan
c_func
(paren
l_int|3
)paren
suffix:semicolon
DECL|macro|device_create_file_fan
mdefine_line|#define device_create_file_fan(client, offset) do { &bslash;&n;&t;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_fan##offset##_input); &bslash;&n;&t;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_fan##offset##_min); &bslash;&n;&t;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_fan##offset##_div); &bslash;&n;} while (0)
multiline_comment|/* 4 Temp. Sensors */
DECL|function|sprintf_temp_from_reg
r_static
r_int
id|sprintf_temp_from_reg
c_func
(paren
id|u16
id|reg
comma
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|nr
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
id|ret
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|LM75_TEMP_FROM_REG
c_func
(paren
id|reg
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_case
l_int|3
suffix:colon
r_default
suffix:colon
id|ret
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|TEMP_FROM_REG
c_func
(paren
id|reg
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|show_temp_reg
mdefine_line|#define show_temp_reg(reg) &bslash;&n;static ssize_t show_##reg(struct device *dev, char *buf, int nr) &bslash;&n;{ &bslash;&n;&t;struct asb100_data *data = asb100_update_device(dev); &bslash;&n;&t;return sprintf_temp_from_reg(data-&gt;reg[nr], buf, nr); &bslash;&n;}
DECL|variable|temp
id|show_temp_reg
c_func
(paren
id|temp
)paren
suffix:semicolon
DECL|variable|temp_max
id|show_temp_reg
c_func
(paren
id|temp_max
)paren
suffix:semicolon
DECL|variable|temp_hyst
id|show_temp_reg
c_func
(paren
id|temp_hyst
)paren
suffix:semicolon
DECL|macro|set_temp_reg
mdefine_line|#define set_temp_reg(REG, reg) &bslash;&n;static ssize_t set_##reg(struct device *dev, const char *buf, &bslash;&n;&t;&t;&t;size_t count, int nr) &bslash;&n;{ &bslash;&n;&t;struct i2c_client *client = to_i2c_client(dev); &bslash;&n;&t;struct asb100_data *data = i2c_get_clientdata(client); &bslash;&n;&t;unsigned long val = simple_strtoul(buf, NULL, 10); &bslash;&n;&t;switch (nr) { &bslash;&n;&t;case 1: case 2: &bslash;&n;&t;&t;data-&gt;reg[nr] = LM75_TEMP_TO_REG(val); &bslash;&n;&t;&t;break; &bslash;&n;&t;case 0: case 3: default: &bslash;&n;&t;&t;data-&gt;reg[nr] = TEMP_TO_REG(val); &bslash;&n;&t;&t;break; &bslash;&n;&t;} &bslash;&n;&t;asb100_write_value(client, ASB100_REG_TEMP_##REG(nr+1), &bslash;&n;&t;&t;&t;data-&gt;reg[nr]); &bslash;&n;&t;return count; &bslash;&n;}
id|set_temp_reg
c_func
(paren
id|MAX
comma
id|temp_max
)paren
suffix:semicolon
id|set_temp_reg
c_func
(paren
id|HYST
comma
id|temp_hyst
)paren
suffix:semicolon
DECL|macro|sysfs_temp
mdefine_line|#define sysfs_temp(num) &bslash;&n;static ssize_t show_temp##num(struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_temp(dev, buf, num-1); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(temp##num##_input, S_IRUGO, show_temp##num, NULL); &bslash;&n;static ssize_t show_temp_max##num(struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_temp_max(dev, buf, num-1); &bslash;&n;} &bslash;&n;static ssize_t set_temp_max##num(struct device *dev, const char *buf, &bslash;&n;&t;&t;&t;&t;&t;size_t count) &bslash;&n;{ &bslash;&n;&t;return set_temp_max(dev, buf, count, num-1); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(temp##num##_max, S_IRUGO | S_IWUSR, &bslash;&n;&t;&t;show_temp_max##num, set_temp_max##num); &bslash;&n;static ssize_t show_temp_hyst##num(struct device *dev, char *buf) &bslash;&n;{ &bslash;&n;&t;return show_temp_hyst(dev, buf, num-1); &bslash;&n;} &bslash;&n;static ssize_t set_temp_hyst##num(struct device *dev, const char *buf, &bslash;&n;&t;&t;&t;&t;&t;size_t count) &bslash;&n;{ &bslash;&n;&t;return set_temp_hyst(dev, buf, count, num-1); &bslash;&n;} &bslash;&n;static DEVICE_ATTR(temp##num##_max_hyst, S_IRUGO | S_IWUSR, &bslash;&n;&t;&t;show_temp_hyst##num, set_temp_hyst##num);
id|sysfs_temp
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sysfs_temp
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|sysfs_temp
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|sysfs_temp
c_func
(paren
l_int|4
)paren
suffix:semicolon
multiline_comment|/* VID */
DECL|macro|device_create_file_temp
mdefine_line|#define device_create_file_temp(client, num) do { &bslash;&n;&t;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_temp##num##_input); &bslash;&n;&t;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_temp##num##_max); &bslash;&n;&t;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_temp##num##_max_hyst); &bslash;&n;} while (0)
DECL|function|show_vid
r_static
id|ssize_t
id|show_vid
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|asb100_data
op_star
id|data
op_assign
id|asb100_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|vid_from_reg
c_func
(paren
id|data-&gt;vid
comma
id|data-&gt;vrm
)paren
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|cpu0_vid
comma
id|S_IRUGO
comma
id|show_vid
comma
l_int|NULL
)paren
suffix:semicolon
DECL|macro|device_create_file_vid
mdefine_line|#define device_create_file_vid(client) &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_cpu0_vid)
multiline_comment|/* VRM */
DECL|function|show_vrm
r_static
id|ssize_t
id|show_vrm
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|asb100_data
op_star
id|data
op_assign
id|asb100_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|data-&gt;vrm
)paren
suffix:semicolon
)brace
DECL|function|set_vrm
r_static
id|ssize_t
id|set_vrm
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|asb100_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_int
r_int
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|data-&gt;vrm
op_assign
id|val
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* Alarms */
r_static
id|DEVICE_ATTR
c_func
(paren
id|vrm
comma
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|show_vrm
comma
id|set_vrm
)paren
suffix:semicolon
DECL|macro|device_create_file_vrm
mdefine_line|#define device_create_file_vrm(client) &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_vrm);
DECL|function|show_alarms
r_static
id|ssize_t
id|show_alarms
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|asb100_data
op_star
id|data
op_assign
id|asb100_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|ALARMS_FROM_REG
c_func
(paren
id|data-&gt;alarms
)paren
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|alarms
comma
id|S_IRUGO
comma
id|show_alarms
comma
l_int|NULL
)paren
suffix:semicolon
DECL|macro|device_create_file_alarms
mdefine_line|#define device_create_file_alarms(client) &bslash;&n;device_create_file(&amp;client-&gt;dev, &amp;dev_attr_alarms)
multiline_comment|/* 1 PWM */
DECL|function|show_pwm1
r_static
id|ssize_t
id|show_pwm1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|asb100_data
op_star
id|data
op_assign
id|asb100_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|ASB100_PWM_FROM_REG
c_func
(paren
id|data-&gt;pwm
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
)brace
DECL|function|set_pwm1
r_static
id|ssize_t
id|set_pwm1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|asb100_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_int
r_int
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|data-&gt;pwm
op_and_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* keep the enable bit */
id|data-&gt;pwm
op_or_assign
(paren
l_int|0x0f
op_amp
id|ASB100_PWM_TO_REG
c_func
(paren
id|val
)paren
)paren
suffix:semicolon
id|asb100_write_value
c_func
(paren
id|client
comma
id|ASB100_REG_PWM1
comma
id|data-&gt;pwm
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|show_pwm_enable1
r_static
id|ssize_t
id|show_pwm_enable1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|asb100_data
op_star
id|data
op_assign
id|asb100_update_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
(paren
id|data-&gt;pwm
op_amp
l_int|0x80
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|set_pwm_enable1
r_static
id|ssize_t
id|set_pwm_enable1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|asb100_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_int
r_int
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|data-&gt;pwm
op_and_assign
l_int|0x0f
suffix:semicolon
multiline_comment|/* keep the duty cycle bits */
id|data-&gt;pwm
op_or_assign
(paren
id|val
ques
c_cond
l_int|0x80
suffix:colon
l_int|0x00
)paren
suffix:semicolon
id|asb100_write_value
c_func
(paren
id|client
comma
id|ASB100_REG_PWM1
comma
id|data-&gt;pwm
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|pwm1
comma
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|show_pwm1
comma
id|set_pwm1
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|pwm1_enable
comma
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|show_pwm_enable1
comma
id|set_pwm_enable1
)paren
suffix:semicolon
DECL|macro|device_create_file_pwm1
mdefine_line|#define device_create_file_pwm1(client) do { &bslash;&n;&t;device_create_file(&amp;new_client-&gt;dev, &amp;dev_attr_pwm1); &bslash;&n;&t;device_create_file(&amp;new_client-&gt;dev, &amp;dev_attr_pwm1_enable); &bslash;&n;} while (0)
multiline_comment|/* This function is called when:&n;&t;asb100_driver is inserted (when this module is loaded), for each&n;&t;&t;available adapter&n;&t;when a new adapter is inserted (and asb100_driver is still present)&n; */
DECL|function|asb100_attach_adapter
r_static
r_int
id|asb100_attach_adapter
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|adapter
op_member_access_from_pointer
r_class
op_amp
id|I2C_CLASS_HWMON
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|i2c_detect
c_func
(paren
id|adapter
comma
op_amp
id|addr_data
comma
id|asb100_detect
)paren
suffix:semicolon
)brace
DECL|function|asb100_detect_subclients
r_static
r_int
id|asb100_detect_subclients
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
comma
r_int
id|address
comma
r_int
id|kind
comma
r_struct
id|i2c_client
op_star
id|new_client
)paren
(brace
r_int
id|i
comma
id|id
comma
id|err
suffix:semicolon
r_struct
id|asb100_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|new_client
)paren
suffix:semicolon
id|data-&gt;lm75
(braket
l_int|0
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i2c_client
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|data-&gt;lm75
(braket
l_int|0
)braket
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|ERROR_SC_0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|data-&gt;lm75
(braket
l_int|0
)braket
comma
l_int|0x00
comma
r_sizeof
(paren
r_struct
id|i2c_client
)paren
)paren
suffix:semicolon
id|data-&gt;lm75
(braket
l_int|1
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i2c_client
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|data-&gt;lm75
(braket
l_int|1
)braket
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|ERROR_SC_1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|data-&gt;lm75
(braket
l_int|1
)braket
comma
l_int|0x00
comma
r_sizeof
(paren
r_struct
id|i2c_client
)paren
)paren
suffix:semicolon
id|id
op_assign
id|i2c_adapter_id
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|force_subclients
(braket
l_int|0
)braket
op_eq
id|id
op_logical_and
id|force_subclients
(braket
l_int|1
)braket
op_eq
id|address
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
op_le
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|force_subclients
(braket
id|i
)braket
template_param
l_int|0x4f
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;invalid subclient &quot;
l_string|&quot;address %d; must be 0x48-0x4f&bslash;n&quot;
comma
id|force_subclients
(braket
id|i
)braket
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|ERROR_SC_2
suffix:semicolon
)brace
)brace
id|asb100_write_value
c_func
(paren
id|new_client
comma
id|ASB100_REG_I2C_SUBADDR
comma
(paren
id|force_subclients
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_or
(paren
(paren
id|force_subclients
(braket
l_int|3
)braket
op_amp
l_int|0x07
)paren
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
id|data-&gt;lm75
(braket
l_int|0
)braket
op_member_access_from_pointer
id|addr
op_assign
id|force_subclients
(braket
l_int|2
)braket
suffix:semicolon
id|data-&gt;lm75
(braket
l_int|1
)braket
op_member_access_from_pointer
id|addr
op_assign
id|force_subclients
(braket
l_int|3
)braket
suffix:semicolon
)brace
r_else
(brace
r_int
id|val
op_assign
id|asb100_read_value
c_func
(paren
id|new_client
comma
id|ASB100_REG_I2C_SUBADDR
)paren
suffix:semicolon
id|data-&gt;lm75
(braket
l_int|0
)braket
op_member_access_from_pointer
id|addr
op_assign
l_int|0x48
op_plus
(paren
id|val
op_amp
l_int|0x07
)paren
suffix:semicolon
id|data-&gt;lm75
(braket
l_int|1
)braket
op_member_access_from_pointer
id|addr
op_assign
l_int|0x48
op_plus
(paren
(paren
id|val
op_rshift
l_int|4
)paren
op_amp
l_int|0x07
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data-&gt;lm75
(braket
l_int|0
)braket
op_member_access_from_pointer
id|addr
op_eq
id|data-&gt;lm75
(braket
l_int|1
)braket
op_member_access_from_pointer
id|addr
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;duplicate addresses 0x%x &quot;
l_string|&quot;for subclients&bslash;n&quot;
comma
id|data-&gt;lm75
(braket
l_int|0
)braket
op_member_access_from_pointer
id|addr
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|ERROR_SC_2
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2c_set_clientdata
c_func
(paren
id|data-&gt;lm75
(braket
id|i
)braket
comma
l_int|NULL
)paren
suffix:semicolon
id|data-&gt;lm75
(braket
id|i
)braket
op_member_access_from_pointer
id|adapter
op_assign
id|adapter
suffix:semicolon
id|data-&gt;lm75
(braket
id|i
)braket
op_member_access_from_pointer
id|driver
op_assign
op_amp
id|asb100_driver
suffix:semicolon
id|data-&gt;lm75
(braket
id|i
)braket
op_member_access_from_pointer
id|flags
op_assign
l_int|0
suffix:semicolon
id|strlcpy
c_func
(paren
id|data-&gt;lm75
(braket
id|i
)braket
op_member_access_from_pointer
id|name
comma
l_string|&quot;asb100 subclient&quot;
comma
id|I2C_NAME_SIZE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|i2c_attach_client
c_func
(paren
id|data-&gt;lm75
(braket
l_int|0
)braket
)paren
)paren
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;subclient %d registration &quot;
l_string|&quot;at address 0x%x failed.&bslash;n&quot;
comma
id|i
comma
id|data-&gt;lm75
(braket
l_int|0
)braket
op_member_access_from_pointer
id|addr
)paren
suffix:semicolon
r_goto
id|ERROR_SC_2
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|i2c_attach_client
c_func
(paren
id|data-&gt;lm75
(braket
l_int|1
)braket
)paren
)paren
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;subclient %d registration &quot;
l_string|&quot;at address 0x%x failed.&bslash;n&quot;
comma
id|i
comma
id|data-&gt;lm75
(braket
l_int|1
)braket
op_member_access_from_pointer
id|addr
)paren
suffix:semicolon
r_goto
id|ERROR_SC_3
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Undo inits in case of errors */
id|ERROR_SC_3
suffix:colon
id|i2c_detach_client
c_func
(paren
id|data-&gt;lm75
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ERROR_SC_2
suffix:colon
id|kfree
c_func
(paren
id|data-&gt;lm75
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|ERROR_SC_1
suffix:colon
id|kfree
c_func
(paren
id|data-&gt;lm75
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ERROR_SC_0
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|asb100_detect
r_static
r_int
id|asb100_detect
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
comma
r_int
id|address
comma
r_int
id|kind
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|i2c_client
op_star
id|new_client
suffix:semicolon
r_struct
id|asb100_data
op_star
id|data
suffix:semicolon
multiline_comment|/* asb100 is SMBus only */
r_if
c_cond
(paren
id|i2c_is_isa_adapter
c_func
(paren
id|adapter
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;asb100.o: detect failed, &quot;
l_string|&quot;cannot attach to legacy adapter!&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|ERROR0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i2c_check_functionality
c_func
(paren
id|adapter
comma
id|I2C_FUNC_SMBUS_BYTE_DATA
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;asb100.o: detect failed, &quot;
l_string|&quot;smbus byte data not supported!&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|ERROR0
suffix:semicolon
)brace
multiline_comment|/* OK. For now, we presume we have a valid client. We now create the&n;&t;   client structure, even though we cannot fill it completely yet.&n;&t;   But it allows us to access asb100_{read,write}_value. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|asb100_data
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;asb100.o: detect failed, kmalloc failed!&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|ERROR0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|data
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|asb100_data
)paren
)paren
suffix:semicolon
id|new_client
op_assign
op_amp
id|data-&gt;client
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
id|i2c_set_clientdata
c_func
(paren
id|new_client
comma
id|data
)paren
suffix:semicolon
id|new_client-&gt;addr
op_assign
id|address
suffix:semicolon
id|new_client-&gt;adapter
op_assign
id|adapter
suffix:semicolon
id|new_client-&gt;driver
op_assign
op_amp
id|asb100_driver
suffix:semicolon
id|new_client-&gt;flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now, we do the remaining detection. */
multiline_comment|/* The chip may be stuck in some other bank than bank 0. This may&n;&t;   make reading other information impossible. Specify a force=... or&n;&t;   force_*=... parameter, and the chip will be reset to the right&n;&t;   bank. */
r_if
c_cond
(paren
id|kind
OL
l_int|0
)paren
(brace
r_int
id|val1
op_assign
id|asb100_read_value
c_func
(paren
id|new_client
comma
id|ASB100_REG_BANK
)paren
suffix:semicolon
r_int
id|val2
op_assign
id|asb100_read_value
c_func
(paren
id|new_client
comma
id|ASB100_REG_CHIPMAN
)paren
suffix:semicolon
multiline_comment|/* If we&squot;re in bank 0 */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|val1
op_amp
l_int|0x07
)paren
)paren
op_logical_and
multiline_comment|/* Check for ASB100 ID (low byte) */
(paren
(paren
(paren
op_logical_neg
(paren
id|val1
op_amp
l_int|0x80
)paren
)paren
op_logical_and
(paren
id|val2
op_ne
l_int|0x94
)paren
)paren
op_logical_or
multiline_comment|/* Check for ASB100 ID (high byte ) */
(paren
(paren
id|val1
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|val2
op_ne
l_int|0x06
)paren
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;asb100.o: detect failed, &quot;
l_string|&quot;bad chip id 0x%02x!&bslash;n&quot;
comma
id|val2
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|ERROR1
suffix:semicolon
)brace
)brace
multiline_comment|/* kind &lt; 0 */
multiline_comment|/* We have either had a force parameter, or we have already detected&n;&t;   Winbond. Put it now into bank 0 and Vendor ID High Byte */
id|asb100_write_value
c_func
(paren
id|new_client
comma
id|ASB100_REG_BANK
comma
(paren
id|asb100_read_value
c_func
(paren
id|new_client
comma
id|ASB100_REG_BANK
)paren
op_amp
l_int|0x78
)paren
op_or
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* Determine the chip type. */
r_if
c_cond
(paren
id|kind
op_le
l_int|0
)paren
(brace
r_int
id|val1
op_assign
id|asb100_read_value
c_func
(paren
id|new_client
comma
id|ASB100_REG_WCHIPID
)paren
suffix:semicolon
r_int
id|val2
op_assign
id|asb100_read_value
c_func
(paren
id|new_client
comma
id|ASB100_REG_CHIPMAN
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val1
op_eq
l_int|0x31
)paren
op_logical_and
(paren
id|val2
op_eq
l_int|0x06
)paren
)paren
id|kind
op_assign
id|asb100
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|kind
op_eq
l_int|0
)paren
id|dev_warn
c_func
(paren
op_amp
id|new_client-&gt;dev
comma
l_string|&quot;ignoring &quot;
l_string|&quot;&squot;force&squot; parameter for unknown chip &quot;
l_string|&quot;at adapter %d, address 0x%02x.&bslash;n&quot;
comma
id|i2c_adapter_id
c_func
(paren
id|adapter
)paren
comma
id|address
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|ERROR1
suffix:semicolon
)brace
)brace
multiline_comment|/* Fill in remaining client fields and put it into the global list */
id|strlcpy
c_func
(paren
id|new_client-&gt;name
comma
l_string|&quot;asb100&quot;
comma
id|I2C_NAME_SIZE
)paren
suffix:semicolon
id|data-&gt;type
op_assign
id|kind
suffix:semicolon
id|data-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|data-&gt;update_lock
)paren
suffix:semicolon
multiline_comment|/* Tell the I2C layer a new client has arrived */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|i2c_attach_client
c_func
(paren
id|new_client
)paren
)paren
)paren
r_goto
id|ERROR1
suffix:semicolon
multiline_comment|/* Attach secondary lm75 clients */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|asb100_detect_subclients
c_func
(paren
id|adapter
comma
id|address
comma
id|kind
comma
id|new_client
)paren
)paren
)paren
r_goto
id|ERROR2
suffix:semicolon
multiline_comment|/* Initialize the chip */
id|asb100_init_client
c_func
(paren
id|new_client
)paren
suffix:semicolon
multiline_comment|/* A few vars need to be filled upon startup */
id|data-&gt;fan_min
(braket
l_int|0
)braket
op_assign
id|asb100_read_value
c_func
(paren
id|new_client
comma
id|ASB100_REG_FAN_MIN
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|data-&gt;fan_min
(braket
l_int|1
)braket
op_assign
id|asb100_read_value
c_func
(paren
id|new_client
comma
id|ASB100_REG_FAN_MIN
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|data-&gt;fan_min
(braket
l_int|2
)braket
op_assign
id|asb100_read_value
c_func
(paren
id|new_client
comma
id|ASB100_REG_FAN_MIN
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
multiline_comment|/* Register sysfs hooks */
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|0
)paren
suffix:semicolon
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|1
)paren
suffix:semicolon
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|2
)paren
suffix:semicolon
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|3
)paren
suffix:semicolon
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|4
)paren
suffix:semicolon
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|5
)paren
suffix:semicolon
id|device_create_file_in
c_func
(paren
id|new_client
comma
l_int|6
)paren
suffix:semicolon
id|device_create_file_fan
c_func
(paren
id|new_client
comma
l_int|1
)paren
suffix:semicolon
id|device_create_file_fan
c_func
(paren
id|new_client
comma
l_int|2
)paren
suffix:semicolon
id|device_create_file_fan
c_func
(paren
id|new_client
comma
l_int|3
)paren
suffix:semicolon
id|device_create_file_temp
c_func
(paren
id|new_client
comma
l_int|1
)paren
suffix:semicolon
id|device_create_file_temp
c_func
(paren
id|new_client
comma
l_int|2
)paren
suffix:semicolon
id|device_create_file_temp
c_func
(paren
id|new_client
comma
l_int|3
)paren
suffix:semicolon
id|device_create_file_temp
c_func
(paren
id|new_client
comma
l_int|4
)paren
suffix:semicolon
id|device_create_file_vid
c_func
(paren
id|new_client
)paren
suffix:semicolon
id|device_create_file_vrm
c_func
(paren
id|new_client
)paren
suffix:semicolon
id|device_create_file_alarms
c_func
(paren
id|new_client
)paren
suffix:semicolon
id|device_create_file_pwm1
c_func
(paren
id|new_client
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|ERROR2
suffix:colon
id|i2c_detach_client
c_func
(paren
id|new_client
)paren
suffix:semicolon
id|ERROR1
suffix:colon
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
id|ERROR0
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|asb100_detach_client
r_static
r_int
id|asb100_detach_client
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|i2c_detach_client
c_func
(paren
id|client
)paren
)paren
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|client-&gt;dev
comma
l_string|&quot;client deregistration failed; &quot;
l_string|&quot;client not detached.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* subclients */
id|kfree
c_func
(paren
id|client
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* main client */
id|kfree
c_func
(paren
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The SMBus locks itself, usually, but nothing may access the chip between&n;   bank switches. */
DECL|function|asb100_read_value
r_static
r_int
id|asb100_read_value
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
comma
id|u16
id|reg
)paren
(brace
r_struct
id|asb100_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_struct
id|i2c_client
op_star
id|cl
suffix:semicolon
r_int
id|res
comma
id|bank
suffix:semicolon
id|down
c_func
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
id|bank
op_assign
(paren
id|reg
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|bank
OG
l_int|2
)paren
multiline_comment|/* switch banks */
id|i2c_smbus_write_byte_data
c_func
(paren
id|client
comma
id|ASB100_REG_BANK
comma
id|bank
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bank
op_eq
l_int|0
op_logical_or
id|bank
OG
l_int|2
)paren
(brace
id|res
op_assign
id|i2c_smbus_read_byte_data
c_func
(paren
id|client
comma
id|reg
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* switch to subclient */
id|cl
op_assign
id|data-&gt;lm75
(braket
id|bank
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* convert from ISA to LM75 I2C addresses */
r_switch
c_cond
(paren
id|reg
op_amp
l_int|0xff
)paren
(brace
r_case
l_int|0x50
suffix:colon
multiline_comment|/* TEMP */
id|res
op_assign
id|swab16
c_func
(paren
id|i2c_smbus_read_word_data
(paren
id|cl
comma
l_int|0
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x52
suffix:colon
multiline_comment|/* CONFIG */
id|res
op_assign
id|i2c_smbus_read_byte_data
c_func
(paren
id|cl
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x53
suffix:colon
multiline_comment|/* HYST */
id|res
op_assign
id|swab16
c_func
(paren
id|i2c_smbus_read_word_data
(paren
id|cl
comma
l_int|2
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x55
suffix:colon
multiline_comment|/* MAX */
r_default
suffix:colon
id|res
op_assign
id|swab16
c_func
(paren
id|i2c_smbus_read_word_data
(paren
id|cl
comma
l_int|3
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bank
OG
l_int|2
)paren
id|i2c_smbus_write_byte_data
c_func
(paren
id|client
comma
id|ASB100_REG_BANK
comma
l_int|0
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|asb100_write_value
r_static
r_void
id|asb100_write_value
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
comma
id|u16
id|reg
comma
id|u16
id|value
)paren
(brace
r_struct
id|asb100_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_struct
id|i2c_client
op_star
id|cl
suffix:semicolon
r_int
id|bank
suffix:semicolon
id|down
c_func
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
id|bank
op_assign
(paren
id|reg
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|bank
OG
l_int|2
)paren
multiline_comment|/* switch banks */
id|i2c_smbus_write_byte_data
c_func
(paren
id|client
comma
id|ASB100_REG_BANK
comma
id|bank
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bank
op_eq
l_int|0
op_logical_or
id|bank
OG
l_int|2
)paren
(brace
id|i2c_smbus_write_byte_data
c_func
(paren
id|client
comma
id|reg
op_amp
l_int|0xff
comma
id|value
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* switch to subclient */
id|cl
op_assign
id|data-&gt;lm75
(braket
id|bank
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* convert from ISA to LM75 I2C addresses */
r_switch
c_cond
(paren
id|reg
op_amp
l_int|0xff
)paren
(brace
r_case
l_int|0x52
suffix:colon
multiline_comment|/* CONFIG */
id|i2c_smbus_write_byte_data
c_func
(paren
id|cl
comma
l_int|1
comma
id|value
op_amp
l_int|0xff
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x53
suffix:colon
multiline_comment|/* HYST */
id|i2c_smbus_write_word_data
c_func
(paren
id|cl
comma
l_int|2
comma
id|swab16
c_func
(paren
id|value
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x55
suffix:colon
multiline_comment|/* MAX */
id|i2c_smbus_write_word_data
c_func
(paren
id|cl
comma
l_int|3
comma
id|swab16
c_func
(paren
id|value
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bank
OG
l_int|2
)paren
id|i2c_smbus_write_byte_data
c_func
(paren
id|client
comma
id|ASB100_REG_BANK
comma
l_int|0
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|asb100_init_client
r_static
r_void
id|asb100_init_client
c_func
(paren
r_struct
id|i2c_client
op_star
id|client
)paren
(brace
r_struct
id|asb100_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_int
id|vid
op_assign
l_int|0
suffix:semicolon
id|vid
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_VID_FANDIV
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|vid
op_or_assign
(paren
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_CHIPID
)paren
op_amp
l_int|0x01
)paren
op_lshift
l_int|4
suffix:semicolon
id|data-&gt;vrm
op_assign
id|i2c_which_vrm
c_func
(paren
)paren
suffix:semicolon
id|vid
op_assign
id|vid_from_reg
c_func
(paren
id|vid
comma
id|data-&gt;vrm
)paren
suffix:semicolon
multiline_comment|/* Start monitoring */
id|asb100_write_value
c_func
(paren
id|client
comma
id|ASB100_REG_CONFIG
comma
(paren
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_CONFIG
)paren
op_amp
l_int|0xf7
)paren
op_or
l_int|0x01
)paren
suffix:semicolon
)brace
DECL|function|asb100_update_device
r_static
r_struct
id|asb100_data
op_star
id|asb100_update_device
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|i2c_client
op_star
id|client
op_assign
id|to_i2c_client
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|asb100_data
op_star
id|data
op_assign
id|i2c_get_clientdata
c_func
(paren
id|client
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|down
c_func
(paren
op_amp
id|data-&gt;update_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
op_minus
id|data-&gt;last_updated
comma
(paren
r_int
r_int
)paren
(paren
id|HZ
op_plus
id|HZ
op_div
l_int|2
)paren
)paren
op_logical_or
id|time_before
c_func
(paren
id|jiffies
comma
id|data-&gt;last_updated
)paren
op_logical_or
op_logical_neg
id|data-&gt;valid
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|client-&gt;dev
comma
l_string|&quot;starting device update...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* 7 voltage inputs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data-&gt;in
(braket
id|i
)braket
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_IN
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|data-&gt;in_min
(braket
id|i
)braket
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_IN_MIN
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|data-&gt;in_max
(braket
id|i
)braket
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_IN_MAX
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* 3 fan inputs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data-&gt;fan
(braket
id|i
)braket
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_FAN
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|data-&gt;fan_min
(braket
id|i
)braket
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_FAN_MIN
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* 4 temperature inputs */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data-&gt;temp
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_TEMP
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|data-&gt;temp_max
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_TEMP_MAX
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|data-&gt;temp_hyst
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_TEMP_HYST
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* VID and fan divisors */
id|i
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_VID_FANDIV
)paren
suffix:semicolon
id|data-&gt;vid
op_assign
id|i
op_amp
l_int|0x0f
suffix:semicolon
id|data-&gt;vid
op_or_assign
(paren
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_CHIPID
)paren
op_amp
l_int|0x01
)paren
op_lshift
l_int|4
suffix:semicolon
id|data-&gt;fan_div
(braket
l_int|0
)braket
op_assign
(paren
id|i
op_rshift
l_int|4
)paren
op_amp
l_int|0x03
suffix:semicolon
id|data-&gt;fan_div
(braket
l_int|1
)braket
op_assign
(paren
id|i
op_rshift
l_int|6
)paren
op_amp
l_int|0x03
suffix:semicolon
id|data-&gt;fan_div
(braket
l_int|2
)braket
op_assign
(paren
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_PIN
)paren
op_rshift
l_int|6
)paren
op_amp
l_int|0x03
suffix:semicolon
multiline_comment|/* PWM */
id|data-&gt;pwm
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_PWM1
)paren
suffix:semicolon
multiline_comment|/* alarms */
id|data-&gt;alarms
op_assign
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_ALARM1
)paren
op_plus
(paren
id|asb100_read_value
c_func
(paren
id|client
comma
id|ASB100_REG_ALARM2
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|data-&gt;last_updated
op_assign
id|jiffies
suffix:semicolon
id|data-&gt;valid
op_assign
l_int|1
suffix:semicolon
id|dev_dbg
c_func
(paren
op_amp
id|client-&gt;dev
comma
l_string|&quot;... device update complete&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|data-&gt;update_lock
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|function|asb100_init
r_static
r_int
id|__init
id|asb100_init
c_func
(paren
r_void
)paren
(brace
r_return
id|i2c_add_driver
c_func
(paren
op_amp
id|asb100_driver
)paren
suffix:semicolon
)brace
DECL|function|asb100_exit
r_static
r_void
id|__exit
id|asb100_exit
c_func
(paren
r_void
)paren
(brace
id|i2c_del_driver
c_func
(paren
op_amp
id|asb100_driver
)paren
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Mark M. Hoffman &lt;mhoffman@lightlink.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;ASB100 Bach driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|asb100_init
id|module_init
c_func
(paren
id|asb100_init
)paren
suffix:semicolon
DECL|variable|asb100_exit
id|module_exit
c_func
(paren
id|asb100_exit
)paren
suffix:semicolon
eof
