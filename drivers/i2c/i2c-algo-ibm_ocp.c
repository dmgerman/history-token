multiline_comment|/*&n;   -------------------------------------------------------------------------&n;   i2c-algo-ibm_ocp.c i2c driver algorithms for IBM PPC 405 adapters&t;    &n;   -------------------------------------------------------------------------&n;      &n;   Ian DaSilva, MontaVista Software, Inc.&n;   idasilva@mvista.com or source@mvista.com&n;&n;   Copyright 2000 MontaVista Software Inc.&n;&n;   Changes made to support the IIC peripheral on the IBM PPC 405&n;&n;&n;   ---------------------------------------------------------------------------&n;   This file was highly leveraged from i2c-algo-pcf.c, which was created&n;   by Simon G. Vogl and Hans Berglund:&n;&n;&n;     Copyright (C) 1995-1997 Simon G. Vogl&n;                   1998-2000 Hans Berglund&n;&n;   With some changes from Ky&#xfffd;sti M&#xfffd;lkki &lt;kmalkki@cc.hut.fi&gt; and &n;   Frodo Looijaard &lt;frodol@dds.nl&gt; ,and also from Martin Bailey&n;   &lt;mbailey@littlefeet-inc.com&gt;&n;&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2 of the License, or&n;    (at your option) any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;   ---------------------------------------------------------------------------&n;&n;   History: 01/20/12 - Armin&n;   &t;akuster@mvista.com&n;   &t;ported up to 2.4.16+&t;&n;&n;   Version 02/03/25 - Armin&n;       converted to ocp format&n;       removed commented out or #if 0 code&n;       added G&#xfffd;rard Basler&squot;s fix to iic_combined_transaction() such that it &n;       returns the number of successfully completed transfers .&n;*/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/i2c.h&gt;
macro_line|#include &quot;i2c-algo-ibm_ocp.h&quot;
singleline_comment|//ACC#include &lt;asm/ocp.h&gt;
macro_line|#ifdef MODULE_LICENSE
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* ----- global defines ----------------------------------------------- */
DECL|macro|DEB
mdefine_line|#define DEB(x) if (i2c_debug&gt;=1) x
DECL|macro|DEB2
mdefine_line|#define DEB2(x) if (i2c_debug&gt;=2) x
DECL|macro|DEB3
mdefine_line|#define DEB3(x) if (i2c_debug&gt;=3) x /* print several statistical values*/
DECL|macro|DEBPROTO
mdefine_line|#define DEBPROTO(x) if (i2c_debug&gt;=9) x;
multiline_comment|/* debug the protocol by showing transferred bits */
DECL|macro|DEF_TIMEOUT
mdefine_line|#define DEF_TIMEOUT 5
multiline_comment|/* debugging - slow down transfer to have a look at the data .. &t;*/
multiline_comment|/* I use this with two leds&amp;resistors, each one connected to sda,scl &t;*/
multiline_comment|/* respectively. This makes sure that the algorithm works. Some chips   */
multiline_comment|/* might not like this, as they have an internal timeout of some mils&t;*/
multiline_comment|/*&n;#define SLO_IO      jif=jiffies;while(jiffies&lt;=jif+i2c_table[minor].veryslow)&bslash;&n;                        if (need_resched) schedule();&n;*/
multiline_comment|/* ----- global variables ---------------------------------------------&t;*/
macro_line|#ifdef SLO_IO
DECL|variable|jif
r_int
id|jif
suffix:semicolon
macro_line|#endif
multiline_comment|/* module parameters:&n; */
DECL|variable|i2c_debug
r_static
r_int
id|i2c_debug
op_assign
l_int|0
suffix:semicolon
DECL|variable|iic_scan
r_static
r_int
id|iic_scan
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* have a look at what&squot;s hanging &squot;round&t;&t;*/
multiline_comment|/* --- setting states on the bus with the right timing: ---------------&t;*/
DECL|macro|iic_outb
mdefine_line|#define iic_outb(adap, reg, val) adap-&gt;setiic(adap-&gt;data, (int) &amp;(reg), val)
DECL|macro|iic_inb
mdefine_line|#define iic_inb(adap, reg) adap-&gt;getiic(adap-&gt;data, (int) &amp;(reg))
DECL|macro|IICO_I2C_SDAHIGH
mdefine_line|#define IICO_I2C_SDAHIGH&t;0x0780
DECL|macro|IICO_I2C_SDALOW
mdefine_line|#define IICO_I2C_SDALOW&t;&t;0x0781
DECL|macro|IICO_I2C_SCLHIGH
mdefine_line|#define IICO_I2C_SCLHIGH&t;0x0782
DECL|macro|IICO_I2C_SCLLOW
mdefine_line|#define IICO_I2C_SCLLOW&t;&t;0x0783
DECL|macro|IICO_I2C_LINEREAD
mdefine_line|#define IICO_I2C_LINEREAD&t;0x0784
DECL|macro|IIC_SINGLE_XFER
mdefine_line|#define IIC_SINGLE_XFER&t;&t;0
DECL|macro|IIC_COMBINED_XFER
mdefine_line|#define IIC_COMBINED_XFER&t;1
DECL|macro|IIC_ERR_LOST_ARB
mdefine_line|#define IIC_ERR_LOST_ARB        -2
DECL|macro|IIC_ERR_INCOMPLETE_XFR
mdefine_line|#define IIC_ERR_INCOMPLETE_XFR  -3
DECL|macro|IIC_ERR_NACK
mdefine_line|#define IIC_ERR_NACK            -1
multiline_comment|/* --- other auxiliary functions --------------------------------------&t;*/
singleline_comment|//
singleline_comment|// Description: Puts this process to sleep for a period equal to timeout 
singleline_comment|//
DECL|function|iic_sleep
r_static
r_inline
r_void
id|iic_sleep
c_func
(paren
r_int
r_int
id|timeout
)paren
(brace
id|schedule_timeout
c_func
(paren
id|timeout
op_star
id|HZ
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Description: This performs the IBM PPC 405 IIC initialization sequence
singleline_comment|// as described in the PPC405GP data book.
singleline_comment|//
DECL|function|iic_init
r_static
r_int
id|iic_init
(paren
r_struct
id|i2c_algo_iic_data
op_star
id|adap
)paren
(brace
r_struct
id|iic_regs
op_star
id|iic
suffix:semicolon
r_struct
id|iic_ibm
op_star
id|adap_priv_data
op_assign
id|adap-&gt;data
suffix:semicolon
r_int
r_int
id|retval
suffix:semicolon
id|iic
op_assign
(paren
r_struct
id|iic_regs
op_star
)paren
id|adap_priv_data-&gt;iic_base
suffix:semicolon
multiline_comment|/* Clear master low master address */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;lmadr
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Clear high master address */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;hmadr
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Clear low slave address */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;lsadr
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Clear high slave address */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;hsadr
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Clear status */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;sts
comma
l_int|0x0a
)paren
suffix:semicolon
multiline_comment|/* Clear extended status */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;extsts
comma
l_int|0x8f
)paren
suffix:semicolon
multiline_comment|/* Set clock division */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;clkdiv
comma
l_int|0x04
)paren
suffix:semicolon
id|retval
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;clkdiv
)paren
suffix:semicolon
id|DEB
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;iic_init: CLKDIV register = %x&bslash;n&quot;
comma
id|retval
)paren
)paren
suffix:semicolon
multiline_comment|/* Enable interrupts on Requested Master Transfer Complete */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;intmsk
comma
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* Clear transfer count */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;xfrcnt
comma
l_int|0x0
)paren
suffix:semicolon
multiline_comment|/* Clear extended control and status */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;xtcntlss
comma
l_int|0xf0
)paren
suffix:semicolon
multiline_comment|/* Set mode control (flush master data buf, enable hold SCL, exit */
multiline_comment|/* unknown state.                                                 */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;mdcntl
comma
l_int|0x47
)paren
suffix:semicolon
multiline_comment|/* Clear control register */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;cntl
comma
l_int|0x0
)paren
suffix:semicolon
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_init: Initialized IIC on PPC 405&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Description: After we issue a transaction on the IIC bus, this function
singleline_comment|// is called.  It puts this process to sleep until we get an interrupt from
singleline_comment|// from the controller telling us that the transaction we requested in complete.
singleline_comment|//
DECL|function|wait_for_pin
r_static
r_int
id|wait_for_pin
c_func
(paren
r_struct
id|i2c_algo_iic_data
op_star
id|adap
comma
r_int
op_star
id|status
)paren
(brace
r_int
id|timeout
op_assign
id|DEF_TIMEOUT
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_struct
id|iic_regs
op_star
id|iic
suffix:semicolon
r_struct
id|iic_ibm
op_star
id|adap_priv_data
op_assign
id|adap-&gt;data
suffix:semicolon
id|iic
op_assign
(paren
r_struct
id|iic_regs
op_star
)paren
id|adap_priv_data-&gt;iic_base
suffix:semicolon
op_star
id|status
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;sts
)paren
suffix:semicolon
macro_line|#ifndef STUB_I2C
r_while
c_loop
(paren
id|timeout
op_decrement
op_logical_and
(paren
op_star
id|status
op_amp
l_int|0x01
)paren
)paren
(brace
id|adap
op_member_access_from_pointer
id|waitforpin
c_func
(paren
id|adap-&gt;data
)paren
suffix:semicolon
op_star
id|status
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;sts
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|timeout
op_le
l_int|0
)paren
(brace
multiline_comment|/* Issue stop signal on the bus, and force an interrupt */
id|retval
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;cntl
)paren
suffix:semicolon
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;cntl
comma
id|retval
op_or
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* Clear status register */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;sts
comma
l_int|0x0a
)paren
suffix:semicolon
multiline_comment|/* Exit unknown bus state */
id|retval
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;mdcntl
)paren
suffix:semicolon
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;mdcntl
comma
(paren
id|retval
op_or
l_int|0x02
)paren
)paren
suffix:semicolon
singleline_comment|// Check the status of the controller.  Does it still see a
singleline_comment|// pending transfer, even though we&squot;ve tried to stop any
singleline_comment|// ongoing transaction?
id|retval
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;sts
)paren
suffix:semicolon
id|retval
op_assign
id|retval
op_amp
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
singleline_comment|// The iic controller is hosed.  It is not responding to any
singleline_comment|// of our commands.  We have already tried to force it into
singleline_comment|// a known state, but it has not worked.  Our only choice now
singleline_comment|// is a soft reset, which will clear all registers, and force
singleline_comment|// us to re-initialize the controller.
multiline_comment|/* Soft reset */
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;xtcntlss
comma
l_int|0x01
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
id|iic_init
c_func
(paren
id|adap
)paren
suffix:semicolon
multiline_comment|/* Is the pending transfer bit in the sts reg finally cleared? */
id|retval
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;sts
)paren
suffix:semicolon
id|retval
op_assign
id|retval
op_amp
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;The IIC Controller is hosed.  A processor reset is required&bslash;n&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// For some reason, even though the interrupt bit in this
singleline_comment|// register was set during iic_init, it didn&squot;t take.  We
singleline_comment|// need to set it again.  Don&squot;t ask me why....this is just what
singleline_comment|// I saw when testing timeouts.
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;intmsk
comma
l_int|0x01
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//------------------------------------
singleline_comment|// Utility functions
singleline_comment|//
singleline_comment|//
singleline_comment|// Description: Look at the status register to see if there was an error
singleline_comment|// in the requested transaction.  If there is, look at the extended status
singleline_comment|// register and determine the exact cause.
singleline_comment|//
DECL|function|analyze_status
r_int
id|analyze_status
c_func
(paren
r_struct
id|i2c_algo_iic_data
op_star
id|adap
comma
r_int
op_star
id|error_code
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|iic_regs
op_star
id|iic
suffix:semicolon
r_struct
id|iic_ibm
op_star
id|adap_priv_data
op_assign
id|adap-&gt;data
suffix:semicolon
id|iic
op_assign
(paren
r_struct
id|iic_regs
op_star
)paren
id|adap_priv_data-&gt;iic_base
suffix:semicolon
id|ret
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;sts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_amp
l_int|0x04
)paren
(brace
singleline_comment|// Error occurred
id|ret
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;extsts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_amp
l_int|0x04
)paren
(brace
singleline_comment|// Lost arbitration
op_star
id|error_code
op_assign
id|IIC_ERR_LOST_ARB
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_amp
l_int|0x02
)paren
(brace
singleline_comment|// Incomplete transfer
op_star
id|error_code
op_assign
id|IIC_ERR_INCOMPLETE_XFR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_amp
l_int|0x01
)paren
(brace
singleline_comment|// Master transfer aborted by a NACK during the transfer of the 
singleline_comment|// address byte
op_star
id|error_code
op_assign
id|IIC_ERR_NACK
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Description: This function is called by the upper layers to do the
singleline_comment|// grunt work for a master send transaction
singleline_comment|//
DECL|function|iic_sendbytes
r_static
r_int
id|iic_sendbytes
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|i2c_adap
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|xfer_flag
)paren
(brace
r_struct
id|iic_regs
op_star
id|iic
suffix:semicolon
r_struct
id|i2c_algo_iic_data
op_star
id|adap
op_assign
id|i2c_adap-&gt;algo_data
suffix:semicolon
r_struct
id|iic_ibm
op_star
id|adap_priv_data
op_assign
id|adap-&gt;data
suffix:semicolon
r_int
id|wrcount
comma
id|status
comma
id|timeout
suffix:semicolon
r_int
id|loops
comma
id|remainder
comma
id|i
comma
id|j
suffix:semicolon
r_int
id|ret
comma
id|error_code
suffix:semicolon
id|iic
op_assign
(paren
r_struct
id|iic_regs
op_star
)paren
id|adap_priv_data-&gt;iic_base
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|wrcount
op_assign
l_int|0
suffix:semicolon
id|loops
op_assign
id|count
op_div
l_int|4
suffix:semicolon
id|remainder
op_assign
id|count
op_mod
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|loops
OG
l_int|1
)paren
op_logical_and
(paren
id|remainder
op_eq
l_int|0
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|loops
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
singleline_comment|//
singleline_comment|// Write four bytes to master data buffer
singleline_comment|//
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|4
suffix:semicolon
id|j
op_increment
)paren
(brace
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;mdbuf
comma
id|buf
(braket
id|wrcount
op_increment
)braket
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Issue command to IICO device to begin transmission
singleline_comment|//
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;cntl
comma
l_int|0x35
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// Wait for transmission to complete.  When it does, 
singleline_comment|//loop to the top of the for statement and write the 
singleline_comment|// next four bytes.
singleline_comment|//
id|timeout
op_assign
id|wait_for_pin
c_func
(paren
id|adap
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OL
l_int|0
)paren
(brace
singleline_comment|//
singleline_comment|// Error handling
singleline_comment|//
singleline_comment|//printk(KERN_ERR &quot;Error: write timeout&bslash;n&quot;);
r_return
id|wrcount
suffix:semicolon
)brace
id|ret
op_assign
id|analyze_status
c_func
(paren
id|adap
comma
op_amp
id|error_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|error_code
op_eq
id|IIC_ERR_INCOMPLETE_XFR
)paren
(brace
singleline_comment|// Return the number of bytes transferred
id|ret
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;xfrcnt
)paren
suffix:semicolon
id|ret
op_assign
id|ret
op_amp
l_int|0x07
suffix:semicolon
r_return
(paren
id|wrcount
op_minus
l_int|4
op_plus
id|ret
)paren
suffix:semicolon
)brace
r_else
r_return
id|error_code
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|loops
op_ge
l_int|1
)paren
op_logical_and
(paren
id|remainder
OG
l_int|0
)paren
)paren
(brace
singleline_comment|//printk(KERN_DEBUG &quot;iic_sendbytes: (loops &gt;= 1)&bslash;n&quot;);
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|loops
suffix:semicolon
id|i
op_increment
)paren
(brace
singleline_comment|//
singleline_comment|// Write four bytes to master data buffer
singleline_comment|//
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|4
suffix:semicolon
id|j
op_increment
)paren
(brace
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;mdbuf
comma
id|buf
(braket
id|wrcount
op_increment
)braket
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Issue command to IICO device to begin transmission
singleline_comment|//
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;cntl
comma
l_int|0x35
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// Wait for transmission to complete.  When it does,
singleline_comment|//loop to the top of the for statement and write the
singleline_comment|// next four bytes.
singleline_comment|//
id|timeout
op_assign
id|wait_for_pin
c_func
(paren
id|adap
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OL
l_int|0
)paren
(brace
singleline_comment|//
singleline_comment|// Error handling
singleline_comment|//
singleline_comment|//printk(KERN_ERR &quot;Error: write timeout&bslash;n&quot;);
r_return
id|wrcount
suffix:semicolon
)brace
id|ret
op_assign
id|analyze_status
c_func
(paren
id|adap
comma
op_amp
id|error_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|error_code
op_eq
id|IIC_ERR_INCOMPLETE_XFR
)paren
(brace
singleline_comment|// Return the number of bytes transferred
id|ret
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;xfrcnt
)paren
suffix:semicolon
id|ret
op_assign
id|ret
op_amp
l_int|0x07
suffix:semicolon
r_return
(paren
id|wrcount
op_minus
l_int|4
op_plus
id|ret
)paren
suffix:semicolon
)brace
r_else
r_return
id|error_code
suffix:semicolon
)brace
)brace
)brace
singleline_comment|//printk(KERN_DEBUG &quot;iic_sendbytes: expedite write&bslash;n&quot;);
r_if
c_cond
(paren
id|remainder
op_eq
l_int|0
)paren
(brace
id|remainder
op_assign
l_int|4
suffix:semicolon
)brace
singleline_comment|// remainder = remainder - 1;
singleline_comment|//
singleline_comment|// Write the remaining bytes (less than or equal to 4)
singleline_comment|//
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remainder
suffix:semicolon
id|i
op_increment
)paren
(brace
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;mdbuf
comma
id|buf
(braket
id|wrcount
op_increment
)braket
)paren
suffix:semicolon
singleline_comment|//printk(KERN_DEBUG &quot;iic_sendbytes:  data transferred = %x, wrcount = %d&bslash;n&quot;, buf[wrcount-1], (wrcount-1));
)brace
singleline_comment|//printk(KERN_DEBUG &quot;iic_sendbytes: Issuing write&bslash;n&quot;);
r_if
c_cond
(paren
id|xfer_flag
op_eq
id|IIC_COMBINED_XFER
)paren
(brace
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;cntl
comma
(paren
l_int|0x09
op_or
(paren
(paren
id|remainder
op_minus
l_int|1
)paren
op_lshift
l_int|4
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;cntl
comma
(paren
l_int|0x01
op_or
(paren
(paren
id|remainder
op_minus
l_int|1
)paren
op_lshift
l_int|4
)paren
)paren
)paren
suffix:semicolon
)brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_sendbytes: Waiting for interrupt&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|timeout
op_assign
id|wait_for_pin
c_func
(paren
id|adap
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OL
l_int|0
)paren
(brace
singleline_comment|//
singleline_comment|// Error handling
singleline_comment|//
singleline_comment|//printk(KERN_ERR &quot;Error: write timeout&bslash;n&quot;);
r_return
id|wrcount
suffix:semicolon
)brace
id|ret
op_assign
id|analyze_status
c_func
(paren
id|adap
comma
op_amp
id|error_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|error_code
op_eq
id|IIC_ERR_INCOMPLETE_XFR
)paren
(brace
singleline_comment|// Return the number of bytes transferred
id|ret
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;xfrcnt
)paren
suffix:semicolon
id|ret
op_assign
id|ret
op_amp
l_int|0x07
suffix:semicolon
r_return
(paren
id|wrcount
op_minus
l_int|4
op_plus
id|ret
)paren
suffix:semicolon
)brace
r_else
r_return
id|error_code
suffix:semicolon
)brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_sendbytes: Got interrupt&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|wrcount
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Description: Called by the upper layers to do the grunt work for
singleline_comment|// a master read transaction.
singleline_comment|//
DECL|function|iic_readbytes
r_static
r_int
id|iic_readbytes
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|i2c_adap
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|xfer_type
)paren
(brace
r_struct
id|iic_regs
op_star
id|iic
suffix:semicolon
r_int
id|rdcount
op_assign
l_int|0
comma
id|i
comma
id|status
comma
id|timeout
suffix:semicolon
r_struct
id|i2c_algo_iic_data
op_star
id|adap
op_assign
id|i2c_adap-&gt;algo_data
suffix:semicolon
r_struct
id|iic_ibm
op_star
id|adap_priv_data
op_assign
id|adap-&gt;data
suffix:semicolon
r_int
id|loops
comma
id|remainder
comma
id|j
suffix:semicolon
r_int
id|ret
comma
id|error_code
suffix:semicolon
id|iic
op_assign
(paren
r_struct
id|iic_regs
op_star
)paren
id|adap_priv_data-&gt;iic_base
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|loops
op_assign
id|count
op_div
l_int|4
suffix:semicolon
id|remainder
op_assign
id|count
op_mod
l_int|4
suffix:semicolon
singleline_comment|//printk(KERN_DEBUG &quot;iic_readbytes: loops = %d, remainder = %d&bslash;n&quot;, loops, remainder);
r_if
c_cond
(paren
(paren
id|loops
OG
l_int|1
)paren
op_logical_and
(paren
id|remainder
op_eq
l_int|0
)paren
)paren
(brace
singleline_comment|//printk(KERN_DEBUG &quot;iic_readbytes: (loops &gt; 1) &amp;&amp; (remainder == 0)&bslash;n&quot;);
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|loops
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
singleline_comment|//
singleline_comment|// Issue command to begin master read (4 bytes maximum)
singleline_comment|//
singleline_comment|//printk(KERN_DEBUG &quot;---&gt;Issued read command&bslash;n&quot;);
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;cntl
comma
l_int|0x37
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// Wait for transmission to complete.  When it does,
singleline_comment|// loop to the top of the for statement and write the
singleline_comment|// next four bytes.
singleline_comment|//
singleline_comment|//printk(KERN_DEBUG &quot;---&gt;Waiting for interrupt&bslash;n&quot;);
id|timeout
op_assign
id|wait_for_pin
c_func
(paren
id|adap
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OL
l_int|0
)paren
(brace
singleline_comment|// Error Handler
singleline_comment|//printk(KERN_ERR &quot;Error: read timed out&bslash;n&quot;);
r_return
id|rdcount
suffix:semicolon
)brace
singleline_comment|//printk(KERN_DEBUG &quot;---&gt;Got interrupt&bslash;n&quot;);
id|ret
op_assign
id|analyze_status
c_func
(paren
id|adap
comma
op_amp
id|error_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|error_code
op_eq
id|IIC_ERR_INCOMPLETE_XFR
)paren
(brace
r_return
id|rdcount
suffix:semicolon
)brace
r_else
r_return
id|error_code
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|4
suffix:semicolon
id|j
op_increment
)paren
(brace
singleline_comment|// Wait for data to shuffle to top of data buffer
singleline_comment|// This value needs to optimized.
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|buf
(braket
id|rdcount
)braket
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;mdbuf
)paren
suffix:semicolon
id|rdcount
op_increment
suffix:semicolon
singleline_comment|//printk(KERN_DEBUG &quot;---&gt;Read one byte&bslash;n&quot;);
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|loops
op_ge
l_int|1
)paren
op_logical_and
(paren
id|remainder
OG
l_int|0
)paren
)paren
(brace
singleline_comment|//printk(KERN_DEBUG &quot;iic_readbytes: (loops &gt;=1) &amp;&amp; (remainder &gt; 0)&bslash;n&quot;);
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|loops
suffix:semicolon
id|i
op_increment
)paren
(brace
singleline_comment|//
singleline_comment|// Issue command to begin master read (4 bytes maximum)
singleline_comment|//
singleline_comment|//printk(KERN_DEBUG &quot;---&gt;Issued read command&bslash;n&quot;);
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;cntl
comma
l_int|0x37
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// Wait for transmission to complete.  When it does,
singleline_comment|// loop to the top of the for statement and write the
singleline_comment|// next four bytes.
singleline_comment|//
singleline_comment|//printk(KERN_DEBUG &quot;---&gt;Waiting for interrupt&bslash;n&quot;);
id|timeout
op_assign
id|wait_for_pin
c_func
(paren
id|adap
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OL
l_int|0
)paren
(brace
singleline_comment|// Error Handler
singleline_comment|//printk(KERN_ERR &quot;Error: read timed out&bslash;n&quot;);
r_return
id|rdcount
suffix:semicolon
)brace
singleline_comment|//printk(KERN_DEBUG &quot;---&gt;Got interrupt&bslash;n&quot;);
id|ret
op_assign
id|analyze_status
c_func
(paren
id|adap
comma
op_amp
id|error_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|error_code
op_eq
id|IIC_ERR_INCOMPLETE_XFR
)paren
(brace
r_return
id|rdcount
suffix:semicolon
)brace
r_else
r_return
id|error_code
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|4
suffix:semicolon
id|j
op_increment
)paren
(brace
singleline_comment|// Wait for data to shuffle to top of data buffer
singleline_comment|// This value needs to optimized.
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|buf
(braket
id|rdcount
)braket
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;mdbuf
)paren
suffix:semicolon
id|rdcount
op_increment
suffix:semicolon
singleline_comment|//printk(KERN_DEBUG &quot;---&gt;Read one byte&bslash;n&quot;);
)brace
)brace
)brace
singleline_comment|//printk(KERN_DEBUG &quot;iic_readbytes: expedite read&bslash;n&quot;);
r_if
c_cond
(paren
id|remainder
op_eq
l_int|0
)paren
(brace
id|remainder
op_assign
l_int|4
suffix:semicolon
)brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_readbytes: writing %x to IICO_CNTL&bslash;n&quot;
comma
(paren
l_int|0x03
op_or
(paren
(paren
id|remainder
op_minus
l_int|1
)paren
op_lshift
l_int|4
)paren
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfer_type
op_eq
id|IIC_COMBINED_XFER
)paren
(brace
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;cntl
comma
(paren
l_int|0x0b
op_or
(paren
(paren
id|remainder
op_minus
l_int|1
)paren
op_lshift
l_int|4
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;cntl
comma
(paren
l_int|0x03
op_or
(paren
(paren
id|remainder
op_minus
l_int|1
)paren
op_lshift
l_int|4
)paren
)paren
)paren
suffix:semicolon
)brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_readbytes: Wait for pin&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|timeout
op_assign
id|wait_for_pin
c_func
(paren
id|adap
comma
op_amp
id|status
)paren
suffix:semicolon
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_readbytes: Got the interrupt&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OL
l_int|0
)paren
(brace
singleline_comment|// Error Handler
singleline_comment|//printk(KERN_ERR &quot;Error: read timed out&bslash;n&quot;);
r_return
id|rdcount
suffix:semicolon
)brace
id|ret
op_assign
id|analyze_status
c_func
(paren
id|adap
comma
op_amp
id|error_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|error_code
op_eq
id|IIC_ERR_INCOMPLETE_XFR
)paren
(brace
r_return
id|rdcount
suffix:semicolon
)brace
r_else
r_return
id|error_code
suffix:semicolon
)brace
singleline_comment|//printk(KERN_DEBUG &quot;iic_readbyte: Begin reading data buffer&bslash;n&quot;);
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remainder
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
(braket
id|rdcount
)braket
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;mdbuf
)paren
suffix:semicolon
singleline_comment|// printk(KERN_DEBUG &quot;iic_readbytes:  Character read = %x&bslash;n&quot;, buf[rdcount]);
id|rdcount
op_increment
suffix:semicolon
)brace
r_return
id|rdcount
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Description:  This function implements combined transactions.  Combined
singleline_comment|// transactions consist of combinations of reading and writing blocks of data.
singleline_comment|// Each transfer (i.e. a read or a write) is separated by a repeated start
singleline_comment|// condition.
singleline_comment|//
DECL|function|iic_combined_transaction
r_static
r_int
id|iic_combined_transaction
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|i2c_adap
comma
r_struct
id|i2c_msg
id|msgs
(braket
)braket
comma
r_int
id|num
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|i2c_msg
op_star
id|pmsg
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Beginning combined transaction&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pmsg
op_assign
op_amp
id|msgs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pmsg-&gt;flags
op_amp
id|I2C_M_RD
)paren
(brace
singleline_comment|// Last read or write segment needs to be terminated with a stop
r_if
c_cond
(paren
id|i
OL
id|num
op_minus
l_int|1
)paren
(brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;This one is a read&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Doing the last read&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|iic_readbytes
c_func
(paren
id|i2c_adap
comma
id|pmsg-&gt;buf
comma
id|pmsg-&gt;len
comma
(paren
id|i
OL
id|num
op_minus
l_int|1
)paren
ques
c_cond
id|IIC_COMBINED_XFER
suffix:colon
id|IIC_SINGLE_XFER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|pmsg-&gt;len
)paren
(brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;i2c-algo-ppc405.o: fail: &quot;
l_string|&quot;only read %d bytes.&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
r_else
(brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;i2c-algo-ppc405.o: read %d bytes.&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|pmsg-&gt;flags
op_amp
id|I2C_M_RD
)paren
)paren
(brace
singleline_comment|// Last read or write segment needs to be terminated with a stop
r_if
c_cond
(paren
id|i
OL
id|num
op_minus
l_int|1
)paren
(brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;This one is a write&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Doing the last write&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|iic_sendbytes
c_func
(paren
id|i2c_adap
comma
id|pmsg-&gt;buf
comma
id|pmsg-&gt;len
comma
(paren
id|i
OL
id|num
op_minus
l_int|1
)paren
ques
c_cond
id|IIC_COMBINED_XFER
suffix:colon
id|IIC_SINGLE_XFER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|pmsg-&gt;len
)paren
(brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;i2c-algo-ppc405.o: fail: &quot;
l_string|&quot;only wrote %d bytes.&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
r_else
(brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;i2c-algo-ppc405.o: wrote %d bytes.&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|num
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Description: Whenever we initiate a transaction, the first byte clocked
singleline_comment|// onto the bus after the start condition is the address (7 bit) of the
singleline_comment|// device we want to talk to.  This function manipulates the address specified
singleline_comment|// so that it makes sense to the hardware when written to the IIC peripheral.
singleline_comment|//
singleline_comment|// Note: 10 bit addresses are not supported in this driver, although they are
singleline_comment|// supported by the hardware.  This functionality needs to be implemented.
singleline_comment|//
DECL|function|iic_doAddress
r_static
r_inline
r_int
id|iic_doAddress
c_func
(paren
r_struct
id|i2c_algo_iic_data
op_star
id|adap
comma
r_struct
id|i2c_msg
op_star
id|msg
comma
r_int
id|retries
)paren
(brace
r_struct
id|iic_regs
op_star
id|iic
suffix:semicolon
r_int
r_int
id|flags
op_assign
id|msg-&gt;flags
suffix:semicolon
r_int
r_char
id|addr
suffix:semicolon
r_struct
id|iic_ibm
op_star
id|adap_priv_data
op_assign
id|adap-&gt;data
suffix:semicolon
id|iic
op_assign
(paren
r_struct
id|iic_regs
op_star
)paren
id|adap_priv_data-&gt;iic_base
suffix:semicolon
singleline_comment|//
singleline_comment|// The following segment for 10 bit addresses needs to be ported
singleline_comment|//
multiline_comment|/* Ten bit addresses not supported right now&n;&t;if ( (flags &amp; I2C_M_TEN)  ) { &n;&t;&t;// a ten bit address&n;&t;&t;addr = 0xf0 | (( msg-&gt;addr &gt;&gt; 7) &amp; 0x03);&n;&t;&t;DEB2(printk(KERN_DEBUG &quot;addr0: %d&bslash;n&quot;,addr));&n;&t;&t;// try extended address code...&n;&t;&t;ret = try_address(adap, addr, retries);&n;&t;&t;if (ret!=1) {&n;&t;&t;&t;printk(KERN_ERR &quot;iic_doAddress: died at extended address code.&bslash;n&quot;);&n;&t;&t;&t;return -EREMOTEIO;&n;&t;&t;}&n;&t;&t;// the remaining 8 bit address&n;&t;&t;iic_outb(adap,msg-&gt;addr &amp; 0x7f);&n;&t;&t;// Status check comes here&n;&t;&t;if (ret != 1) {&n;&t;&t;&t;printk(KERN_ERR &quot;iic_doAddress: died at 2nd address code.&bslash;n&quot;);&n;&t;&t;&t;return -EREMOTEIO;&n;&t;&t;}&n;&t;&t;if ( flags &amp; I2C_M_RD ) {&n;&t;&t;&t;i2c_repstart(adap);&n;&t;&t;&t;// okay, now switch into reading mode&n;&t;&t;&t;addr |= 0x01;&n;&t;&t;&t;ret = try_address(adap, addr, retries);&n;&t;&t;&t;if (ret!=1) {&n;&t;&t;&t;&t;printk(KERN_ERR &quot;iic_doAddress: died at extended address code.&bslash;n&quot;);&n;&t;&t;&t;&t;return -EREMOTEIO;&n;&t;&t;&t;}&n;&t;&t;}&n;&t;} else ----------&gt; // normal 7 bit address&n;&n;Ten bit addresses not supported yet */
id|addr
op_assign
(paren
id|msg-&gt;addr
op_lshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|I2C_M_RD
)paren
id|addr
op_or_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|I2C_M_REV_DIR_ADDR
)paren
id|addr
op_xor_assign
l_int|1
suffix:semicolon
singleline_comment|//
singleline_comment|// Write to the low slave address
singleline_comment|//
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;lmadr
comma
id|addr
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// Write zero to the high slave register since we are
singleline_comment|// only using 7 bit addresses
singleline_comment|//
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;hmadr
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Description: Prepares the controller for a transaction (clearing status
singleline_comment|// registers, data buffers, etc), and then calls either iic_readbytes or
singleline_comment|// iic_sendbytes to do the actual transaction.
singleline_comment|//
DECL|function|iic_xfer
r_static
r_int
id|iic_xfer
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|i2c_adap
comma
r_struct
id|i2c_msg
id|msgs
(braket
)braket
comma
r_int
id|num
)paren
(brace
r_struct
id|iic_regs
op_star
id|iic
suffix:semicolon
r_struct
id|i2c_algo_iic_data
op_star
id|adap
op_assign
id|i2c_adap-&gt;algo_data
suffix:semicolon
r_struct
id|iic_ibm
op_star
id|adap_priv_data
op_assign
id|adap-&gt;data
suffix:semicolon
r_struct
id|i2c_msg
op_star
id|pmsg
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|iic
op_assign
(paren
r_struct
id|iic_regs
op_star
)paren
id|adap_priv_data-&gt;iic_base
suffix:semicolon
id|pmsg
op_assign
op_amp
id|msgs
(braket
id|i
)braket
suffix:semicolon
singleline_comment|//
singleline_comment|// Clear status register
singleline_comment|//
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_xfer: iic_xfer: Clearing status register&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;sts
comma
l_int|0x0a
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// Wait for any pending transfers to complete
singleline_comment|//
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_xfer: Waiting for any pending transfers to complete&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ret
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;sts
)paren
)paren
op_eq
l_int|0x01
)paren
(brace
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Flush master data buf
singleline_comment|//
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_xfer: Clearing master data buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;mdcntl
)paren
suffix:semicolon
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;mdcntl
comma
id|ret
op_or
l_int|0x40
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// Load slave address
singleline_comment|//
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_xfer: Loading slave address&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|iic_doAddress
c_func
(paren
id|adap
comma
id|pmsg
comma
id|i2c_adap-&gt;retries
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// Check to see if the bus is busy
singleline_comment|//
id|ret
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;extsts
)paren
suffix:semicolon
singleline_comment|// Mask off the irrelevent bits
id|ret
op_assign
id|ret
op_amp
l_int|0x70
suffix:semicolon
singleline_comment|// When the bus is free, the BCS bits in the EXTSTS register are 0b100
r_if
c_cond
(paren
id|ret
op_ne
l_int|0x40
)paren
(brace
r_return
id|IIC_ERR_LOST_ARB
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Combined transaction (read and write)
singleline_comment|//
r_if
c_cond
(paren
id|num
OG
l_int|1
)paren
(brace
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_xfer: Call combined transaction&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|iic_combined_transaction
c_func
(paren
id|i2c_adap
comma
id|msgs
comma
id|num
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Read only
singleline_comment|//
r_else
r_if
c_cond
(paren
(paren
id|num
op_eq
l_int|1
)paren
op_logical_and
(paren
id|pmsg-&gt;flags
op_amp
id|I2C_M_RD
)paren
)paren
(brace
singleline_comment|//
singleline_comment|// Tell device to begin reading data from the  master data 
singleline_comment|//
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_xfer: Call adapter&squot;s read&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|iic_readbytes
c_func
(paren
id|i2c_adap
comma
id|pmsg-&gt;buf
comma
id|pmsg-&gt;len
comma
id|IIC_SINGLE_XFER
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Write only
singleline_comment|//
r_else
r_if
c_cond
(paren
(paren
id|num
op_eq
l_int|1
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|pmsg-&gt;flags
op_amp
id|I2C_M_RD
)paren
)paren
)paren
(brace
singleline_comment|//
singleline_comment|// Write data to master data buffers and tell our device
singleline_comment|// to begin transmitting
singleline_comment|//
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iic_xfer: Call adapter&squot;s write&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|iic_sendbytes
c_func
(paren
id|i2c_adap
comma
id|pmsg-&gt;buf
comma
id|pmsg-&gt;len
comma
id|IIC_SINGLE_XFER
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Description: Implements device specific ioctls.  Higher level ioctls can
singleline_comment|// be found in i2c-core.c and are typical of any i2c controller (specifying
singleline_comment|// slave address, timeouts, etc).  These ioctls take advantage of any hardware
singleline_comment|// features built into the controller for which this algorithm-adapter set
singleline_comment|// was written.  These ioctls allow you to take control of the data and clock
singleline_comment|// lines on the IBM PPC 405 IIC controller and set the either high or low,
singleline_comment|// similar to a GPIO pin.
singleline_comment|//
DECL|function|algo_control
r_static
r_int
id|algo_control
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|iic_regs
op_star
id|iic
suffix:semicolon
r_struct
id|i2c_algo_iic_data
op_star
id|adap
op_assign
id|adapter-&gt;algo_data
suffix:semicolon
r_struct
id|iic_ibm
op_star
id|adap_priv_data
op_assign
id|adap-&gt;data
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|lines
suffix:semicolon
id|iic
op_assign
(paren
r_struct
id|iic_regs
op_star
)paren
id|adap_priv_data-&gt;iic_base
suffix:semicolon
id|lines
op_assign
id|iic_inb
c_func
(paren
id|adap
comma
id|iic-&gt;directcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|IICO_I2C_SDAHIGH
)paren
(brace
id|lines
op_assign
id|lines
op_amp
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|lines
)paren
(brace
id|lines
op_assign
l_int|0x04
suffix:semicolon
)brace
r_else
id|lines
op_assign
l_int|0
suffix:semicolon
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;directcntl
comma
(paren
l_int|0x08
op_or
id|lines
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|IICO_I2C_SDALOW
)paren
(brace
id|lines
op_assign
id|lines
op_amp
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|lines
)paren
(brace
id|lines
op_assign
l_int|0x04
suffix:semicolon
)brace
r_else
id|lines
op_assign
l_int|0
suffix:semicolon
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;directcntl
comma
(paren
l_int|0x00
op_or
id|lines
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|IICO_I2C_SCLHIGH
)paren
(brace
id|lines
op_assign
id|lines
op_amp
l_int|0x02
suffix:semicolon
r_if
c_cond
(paren
id|lines
)paren
(brace
id|lines
op_assign
l_int|0x08
suffix:semicolon
)brace
r_else
id|lines
op_assign
l_int|0
suffix:semicolon
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;directcntl
comma
(paren
l_int|0x04
op_or
id|lines
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|IICO_I2C_SCLLOW
)paren
(brace
id|lines
op_assign
id|lines
op_amp
l_int|0x02
suffix:semicolon
r_if
c_cond
(paren
id|lines
)paren
(brace
id|lines
op_assign
l_int|0x08
suffix:semicolon
)brace
r_else
id|lines
op_assign
l_int|0
suffix:semicolon
id|iic_outb
c_func
(paren
id|adap
comma
id|iic-&gt;directcntl
comma
(paren
l_int|0x00
op_or
id|lines
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|IICO_I2C_LINEREAD
)paren
(brace
id|ret
op_assign
id|lines
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|iic_func
r_static
id|u32
id|iic_func
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adap
)paren
(brace
r_return
id|I2C_FUNC_SMBUS_EMUL
op_or
id|I2C_FUNC_10BIT_ADDR
op_or
id|I2C_FUNC_PROTOCOL_MANGLING
suffix:semicolon
)brace
multiline_comment|/* -----exported algorithm data: -------------------------------------&t;*/
DECL|variable|iic_algo
r_static
r_struct
id|i2c_algorithm
id|iic_algo
op_assign
(brace
l_string|&quot;IBM on-chip IIC algorithm&quot;
comma
id|I2C_ALGO_OCP
comma
id|iic_xfer
comma
l_int|NULL
comma
l_int|NULL
comma
multiline_comment|/* slave_xmit&t;&t;*/
l_int|NULL
comma
multiline_comment|/* slave_recv&t;&t;*/
id|algo_control
comma
multiline_comment|/* ioctl&t;&t;*/
id|iic_func
comma
multiline_comment|/* functionality&t;*/
)brace
suffix:semicolon
multiline_comment|/* &n; * registering functions to load algorithms at runtime &n; */
singleline_comment|//
singleline_comment|// Description: Register bus structure
singleline_comment|//
DECL|function|i2c_ocp_add_bus
r_int
id|i2c_ocp_add_bus
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adap
)paren
(brace
r_struct
id|i2c_algo_iic_data
op_star
id|iic_adap
op_assign
id|adap-&gt;algo_data
suffix:semicolon
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;i2c-algo-iic.o: hw routines for %s registered.&bslash;n&quot;
comma
id|adap-&gt;name
)paren
)paren
suffix:semicolon
multiline_comment|/* register new adapter to i2c module... */
id|adap-&gt;id
op_or_assign
id|iic_algo.id
suffix:semicolon
id|adap-&gt;algo
op_assign
op_amp
id|iic_algo
suffix:semicolon
id|adap-&gt;timeout
op_assign
l_int|100
suffix:semicolon
multiline_comment|/* default values, should&t;*/
id|adap-&gt;retries
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* be replaced by defines&t;*/
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
id|iic_init
c_func
(paren
id|iic_adap
)paren
suffix:semicolon
id|i2c_add_adapter
c_func
(paren
id|adap
)paren
suffix:semicolon
multiline_comment|/* scan bus */
multiline_comment|/* By default scanning the bus is turned off. */
r_if
c_cond
(paren
id|iic_scan
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; i2c-algo-iic.o: scanning bus %s.&bslash;n&quot;
comma
id|adap-&gt;name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Done
singleline_comment|//
DECL|function|i2c_ocp_del_bus
r_int
id|i2c_ocp_del_bus
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adap
)paren
(brace
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res
op_assign
id|i2c_del_adapter
c_func
(paren
id|adap
)paren
)paren
OL
l_int|0
)paren
r_return
id|res
suffix:semicolon
id|DEB2
c_func
(paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;i2c-algo-iic.o: adapter unregistered: %s&bslash;n&quot;
comma
id|adap-&gt;name
)paren
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Done
singleline_comment|//
DECL|function|i2c_algo_iic_init
r_int
id|__init
id|i2c_algo_iic_init
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IBM On-chip iic (i2c) algorithm module 2002.27.03&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i2c_algo_iic_exit
r_void
id|i2c_algo_iic_exit
c_func
(paren
r_void
)paren
(brace
r_return
suffix:semicolon
)brace
DECL|variable|i2c_ocp_add_bus
id|EXPORT_SYMBOL
c_func
(paren
id|i2c_ocp_add_bus
)paren
suffix:semicolon
DECL|variable|i2c_ocp_del_bus
id|EXPORT_SYMBOL
c_func
(paren
id|i2c_ocp_del_bus
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// The MODULE_* macros resolve to nothing if MODULES is not defined
singleline_comment|// when this file is compiled.
singleline_comment|//
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;MontaVista Software &lt;www.mvista.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;PPC 405 iic algorithm&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|iic_test
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|iic_scan
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|i2c_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|iic_test
comma
l_string|&quot;Test if the I2C bus is available&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|iic_scan
comma
l_string|&quot;Scan for active chips on the bus&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|i2c_debug
comma
l_string|&quot;debug level - 0 off; 1 normal; 2,3 more verbose; 9 iic-protocol&quot;
)paren
suffix:semicolon
DECL|variable|i2c_algo_iic_init
id|module_init
c_func
(paren
id|i2c_algo_iic_init
)paren
suffix:semicolon
DECL|variable|i2c_algo_iic_exit
id|module_exit
c_func
(paren
id|i2c_algo_iic_exit
)paren
suffix:semicolon
eof
