multiline_comment|/*&n; *  linux/drivers/block/as-iosched.c&n; *&n; *  Anticipatory &amp; deadline i/o scheduler.&n; *&n; *  Copyright (C) 2002 Jens Axboe &lt;axboe@suse.de&gt;&n; *                     Nick Piggin &lt;piggin@cyberone.com.au&gt;&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/elevator.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/hash.h&gt;
macro_line|#include &lt;linux/rbtree.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
DECL|macro|REQ_SYNC
mdefine_line|#define REQ_SYNC&t;1
DECL|macro|REQ_ASYNC
mdefine_line|#define REQ_ASYNC&t;0
multiline_comment|/*&n; * See Documentation/as-iosched.txt&n; */
multiline_comment|/*&n; * max time before a read is submitted.&n; */
DECL|macro|default_read_expire
mdefine_line|#define default_read_expire (HZ / 8)
multiline_comment|/*&n; * ditto for writes, these limits are not hard, even&n; * if the disk is capable of satisfying them.&n; */
DECL|macro|default_write_expire
mdefine_line|#define default_write_expire (HZ / 4)
multiline_comment|/*&n; * read_batch_expire describes how long we will allow a stream of reads to&n; * persist before looking to see whether it is time to switch over to writes.&n; */
DECL|macro|default_read_batch_expire
mdefine_line|#define default_read_batch_expire (HZ / 4)
multiline_comment|/*&n; * write_batch_expire describes how long we want a stream of writes to run for.&n; * This is not a hard limit, but a target we set for the auto-tuning thingy.&n; * See, the problem is: we can send a lot of writes to disk cache / TCQ in&n; * a short amount of time...&n; */
DECL|macro|default_write_batch_expire
mdefine_line|#define default_write_batch_expire (HZ / 16)
multiline_comment|/*&n; * max time we may wait to anticipate a read (default around 6ms)&n; */
DECL|macro|default_antic_expire
mdefine_line|#define default_antic_expire ((HZ / 150) ? HZ / 150 : 1)
multiline_comment|/*&n; * Keep track of up to 20ms thinktimes. We can go as big as we like here,&n; * however huge values tend to interfere and not decay fast enough. A program&n; * might be in a non-io phase of operation. Waiting on user input for example,&n; * or doing a lengthy computation. A small penalty can be justified there, and&n; * will still catch out those processes that constantly have large thinktimes.&n; */
DECL|macro|MAX_THINKTIME
mdefine_line|#define MAX_THINKTIME (HZ/50UL)
multiline_comment|/* Bits in as_io_context.state */
DECL|enum|as_io_states
r_enum
id|as_io_states
(brace
DECL|enumerator|AS_TASK_RUNNING
id|AS_TASK_RUNNING
op_assign
l_int|0
comma
multiline_comment|/* Process has not exitted */
DECL|enumerator|AS_TASK_IOSTARTED
id|AS_TASK_IOSTARTED
comma
multiline_comment|/* Process has started some IO */
DECL|enumerator|AS_TASK_IORUNNING
id|AS_TASK_IORUNNING
comma
multiline_comment|/* Process has completed some IO */
)brace
suffix:semicolon
DECL|enum|anticipation_status
r_enum
id|anticipation_status
(brace
DECL|enumerator|ANTIC_OFF
id|ANTIC_OFF
op_assign
l_int|0
comma
multiline_comment|/* Not anticipating (normal operation)&t;*/
DECL|enumerator|ANTIC_WAIT_REQ
id|ANTIC_WAIT_REQ
comma
multiline_comment|/* The last read has not yet completed  */
DECL|enumerator|ANTIC_WAIT_NEXT
id|ANTIC_WAIT_NEXT
comma
multiline_comment|/* Currently anticipating a request vs&n;&t;&t;&t;&t;   last read (which has completed) */
DECL|enumerator|ANTIC_FINISHED
id|ANTIC_FINISHED
comma
multiline_comment|/* Anticipating but have found a candidate&n;&t;&t;&t;&t; * or timed out */
)brace
suffix:semicolon
DECL|struct|as_data
r_struct
id|as_data
(brace
multiline_comment|/*&n;&t; * run time data&n;&t; */
DECL|member|q
r_struct
id|request_queue
op_star
id|q
suffix:semicolon
multiline_comment|/* the &quot;owner&quot; queue */
multiline_comment|/*&n;&t; * requests (as_rq s) are present on both sort_list and fifo_list&n;&t; */
DECL|member|sort_list
r_struct
id|rb_root
id|sort_list
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|fifo_list
r_struct
id|list_head
id|fifo_list
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|next_arq
r_struct
id|as_rq
op_star
id|next_arq
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* next in sort order */
DECL|member|last_sector
id|sector_t
id|last_sector
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* last REQ_SYNC &amp; REQ_ASYNC sectors */
DECL|member|dispatch
r_struct
id|list_head
op_star
id|dispatch
suffix:semicolon
multiline_comment|/* driver dispatch queue */
DECL|member|hash
r_struct
id|list_head
op_star
id|hash
suffix:semicolon
multiline_comment|/* request hash */
DECL|member|exit_prob
r_int
r_int
id|exit_prob
suffix:semicolon
multiline_comment|/* probability a task will exit while&n;&t;&t;&t;&t;&t;   being waited on */
DECL|member|new_ttime_total
r_int
r_int
id|new_ttime_total
suffix:semicolon
multiline_comment|/* mean thinktime on new proc */
DECL|member|new_ttime_mean
r_int
r_int
id|new_ttime_mean
suffix:semicolon
DECL|member|new_seek_total
id|u64
id|new_seek_total
suffix:semicolon
multiline_comment|/* mean seek on new proc */
DECL|member|new_seek_mean
id|sector_t
id|new_seek_mean
suffix:semicolon
DECL|member|current_batch_expires
r_int
r_int
id|current_batch_expires
suffix:semicolon
DECL|member|last_check_fifo
r_int
r_int
id|last_check_fifo
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|changed_batch
r_int
id|changed_batch
suffix:semicolon
multiline_comment|/* 1: waiting for old batch to end */
DECL|member|new_batch
r_int
id|new_batch
suffix:semicolon
multiline_comment|/* 1: waiting on first read complete */
DECL|member|batch_data_dir
r_int
id|batch_data_dir
suffix:semicolon
multiline_comment|/* current batch REQ_SYNC / REQ_ASYNC */
DECL|member|write_batch_count
r_int
id|write_batch_count
suffix:semicolon
multiline_comment|/* max # of reqs in a write batch */
DECL|member|current_write_count
r_int
id|current_write_count
suffix:semicolon
multiline_comment|/* how many requests left this batch */
DECL|member|write_batch_idled
r_int
id|write_batch_idled
suffix:semicolon
multiline_comment|/* has the write batch gone idle? */
DECL|member|arq_pool
id|mempool_t
op_star
id|arq_pool
suffix:semicolon
DECL|member|antic_status
r_enum
id|anticipation_status
id|antic_status
suffix:semicolon
DECL|member|antic_start
r_int
r_int
id|antic_start
suffix:semicolon
multiline_comment|/* jiffies: when it started */
DECL|member|antic_timer
r_struct
id|timer_list
id|antic_timer
suffix:semicolon
multiline_comment|/* anticipatory scheduling timer */
DECL|member|antic_work
r_struct
id|work_struct
id|antic_work
suffix:semicolon
multiline_comment|/* Deferred unplugging */
DECL|member|io_context
r_struct
id|io_context
op_star
id|io_context
suffix:semicolon
multiline_comment|/* Identify the expected process */
DECL|member|ioc_finished
r_int
id|ioc_finished
suffix:semicolon
multiline_comment|/* IO associated with io_context is finished */
DECL|member|nr_dispatched
r_int
id|nr_dispatched
suffix:semicolon
multiline_comment|/*&n;&t; * settings that change how the i/o scheduler behaves&n;&t; */
DECL|member|fifo_expire
r_int
r_int
id|fifo_expire
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|batch_expire
r_int
r_int
id|batch_expire
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|antic_expire
r_int
r_int
id|antic_expire
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|list_entry_fifo
mdefine_line|#define list_entry_fifo(ptr)&t;list_entry((ptr), struct as_rq, fifo)
multiline_comment|/*&n; * per-request data.&n; */
DECL|enum|arq_state
r_enum
id|arq_state
(brace
DECL|enumerator|AS_RQ_NEW
id|AS_RQ_NEW
op_assign
l_int|0
comma
multiline_comment|/* New - not referenced and not on any lists */
DECL|enumerator|AS_RQ_QUEUED
id|AS_RQ_QUEUED
comma
multiline_comment|/* In the request queue. It belongs to the&n;&t;&t;&t;&t;   scheduler */
DECL|enumerator|AS_RQ_DISPATCHED
id|AS_RQ_DISPATCHED
comma
multiline_comment|/* On the dispatch list. It belongs to the&n;&t;&t;&t;&t;   driver now */
DECL|enumerator|AS_RQ_PRESCHED
id|AS_RQ_PRESCHED
comma
multiline_comment|/* Debug poisoning for requests being used */
DECL|enumerator|AS_RQ_REMOVED
id|AS_RQ_REMOVED
comma
DECL|enumerator|AS_RQ_MERGED
id|AS_RQ_MERGED
comma
DECL|enumerator|AS_RQ_POSTSCHED
id|AS_RQ_POSTSCHED
comma
multiline_comment|/* when they shouldn&squot;t be */
)brace
suffix:semicolon
DECL|struct|as_rq
r_struct
id|as_rq
(brace
multiline_comment|/*&n;&t; * rbtree index, key is the starting offset&n;&t; */
DECL|member|rb_node
r_struct
id|rb_node
id|rb_node
suffix:semicolon
DECL|member|rb_key
id|sector_t
id|rb_key
suffix:semicolon
DECL|member|request
r_struct
id|request
op_star
id|request
suffix:semicolon
DECL|member|io_context
r_struct
id|io_context
op_star
id|io_context
suffix:semicolon
multiline_comment|/* The submitting task */
multiline_comment|/*&n;&t; * request hash, key is the ending offset (for back merge lookup)&n;&t; */
DECL|member|hash
r_struct
id|list_head
id|hash
suffix:semicolon
DECL|member|on_hash
r_int
r_int
id|on_hash
suffix:semicolon
multiline_comment|/*&n;&t; * expire fifo&n;&t; */
DECL|member|fifo
r_struct
id|list_head
id|fifo
suffix:semicolon
DECL|member|expires
r_int
r_int
id|expires
suffix:semicolon
DECL|member|is_sync
r_int
r_int
id|is_sync
suffix:semicolon
DECL|member|state
r_enum
id|arq_state
id|state
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|RQ_DATA
mdefine_line|#define RQ_DATA(rq)&t;((struct as_rq *) (rq)-&gt;elevator_private)
DECL|variable|arq_pool
r_static
id|kmem_cache_t
op_star
id|arq_pool
suffix:semicolon
multiline_comment|/*&n; * IO Context helper functions&n; */
multiline_comment|/* Called to deallocate the as_io_context */
DECL|function|free_as_io_context
r_static
r_void
id|free_as_io_context
c_func
(paren
r_struct
id|as_io_context
op_star
id|aic
)paren
(brace
id|kfree
c_func
(paren
id|aic
)paren
suffix:semicolon
)brace
multiline_comment|/* Called when the task exits */
DECL|function|exit_as_io_context
r_static
r_void
id|exit_as_io_context
c_func
(paren
r_struct
id|as_io_context
op_star
id|aic
)paren
(brace
id|WARN_ON
c_func
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|AS_TASK_RUNNING
comma
op_amp
id|aic-&gt;state
)paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|AS_TASK_RUNNING
comma
op_amp
id|aic-&gt;state
)paren
suffix:semicolon
)brace
DECL|function|alloc_as_io_context
r_static
r_struct
id|as_io_context
op_star
id|alloc_as_io_context
c_func
(paren
r_void
)paren
(brace
r_struct
id|as_io_context
op_star
id|ret
suffix:semicolon
id|ret
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ret
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|ret-&gt;dtor
op_assign
id|free_as_io_context
suffix:semicolon
id|ret
op_member_access_from_pointer
m_exit
op_assign
id|exit_as_io_context
suffix:semicolon
id|ret-&gt;state
op_assign
l_int|1
op_lshift
id|AS_TASK_RUNNING
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ret-&gt;nr_queued
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ret-&gt;nr_dispatched
comma
l_int|0
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ret-&gt;lock
)paren
suffix:semicolon
id|ret-&gt;ttime_total
op_assign
l_int|0
suffix:semicolon
id|ret-&gt;ttime_samples
op_assign
l_int|0
suffix:semicolon
id|ret-&gt;ttime_mean
op_assign
l_int|0
suffix:semicolon
id|ret-&gt;seek_total
op_assign
l_int|0
suffix:semicolon
id|ret-&gt;seek_samples
op_assign
l_int|0
suffix:semicolon
id|ret-&gt;seek_mean
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * If the current task has no AS IO context then create one and initialise it.&n; * Then take a ref on the task&squot;s io context and return it.&n; */
DECL|function|as_get_io_context
r_static
r_struct
id|io_context
op_star
id|as_get_io_context
c_func
(paren
r_void
)paren
(brace
r_struct
id|io_context
op_star
id|ioc
op_assign
id|get_io_context
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioc
op_logical_and
op_logical_neg
id|ioc-&gt;aic
)paren
(brace
id|ioc-&gt;aic
op_assign
id|alloc_as_io_context
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioc-&gt;aic
)paren
(brace
id|put_io_context
c_func
(paren
id|ioc
)paren
suffix:semicolon
id|ioc
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|ioc
suffix:semicolon
)brace
multiline_comment|/*&n; * the back merge hash support functions&n; */
DECL|variable|as_hash_shift
r_static
r_const
r_int
id|as_hash_shift
op_assign
l_int|6
suffix:semicolon
DECL|macro|AS_HASH_BLOCK
mdefine_line|#define AS_HASH_BLOCK(sec)&t;((sec) &gt;&gt; 3)
DECL|macro|AS_HASH_FN
mdefine_line|#define AS_HASH_FN(sec)&t;&t;(hash_long(AS_HASH_BLOCK((sec)), as_hash_shift))
DECL|macro|AS_HASH_ENTRIES
mdefine_line|#define AS_HASH_ENTRIES&t;&t;(1 &lt;&lt; as_hash_shift)
DECL|macro|rq_hash_key
mdefine_line|#define rq_hash_key(rq)&t;&t;((rq)-&gt;sector + (rq)-&gt;nr_sectors)
DECL|macro|list_entry_hash
mdefine_line|#define list_entry_hash(ptr)&t;list_entry((ptr), struct as_rq, hash)
DECL|function|__as_del_arq_hash
r_static
r_inline
r_void
id|__as_del_arq_hash
c_func
(paren
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
id|arq-&gt;on_hash
op_assign
l_int|0
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|arq-&gt;hash
)paren
suffix:semicolon
)brace
DECL|function|as_del_arq_hash
r_static
r_inline
r_void
id|as_del_arq_hash
c_func
(paren
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
r_if
c_cond
(paren
id|arq-&gt;on_hash
)paren
id|__as_del_arq_hash
c_func
(paren
id|arq
)paren
suffix:semicolon
)brace
DECL|function|as_remove_merge_hints
r_static
r_void
id|as_remove_merge_hints
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
id|as_del_arq_hash
c_func
(paren
id|arq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;last_merge
op_eq
id|arq-&gt;request
)paren
id|q-&gt;last_merge
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|as_add_arq_hash
r_static
r_void
id|as_add_arq_hash
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|arq-&gt;request
suffix:semicolon
id|BUG_ON
c_func
(paren
id|arq-&gt;on_hash
)paren
suffix:semicolon
id|arq-&gt;on_hash
op_assign
l_int|1
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|arq-&gt;hash
comma
op_amp
id|ad-&gt;hash
(braket
id|AS_HASH_FN
c_func
(paren
id|rq_hash_key
c_func
(paren
id|rq
)paren
)paren
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * move hot entry to front of chain&n; */
DECL|function|as_hot_arq_hash
r_static
r_inline
r_void
id|as_hot_arq_hash
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|arq-&gt;request
suffix:semicolon
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|ad-&gt;hash
(braket
id|AS_HASH_FN
c_func
(paren
id|rq_hash_key
c_func
(paren
id|rq
)paren
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arq-&gt;on_hash
)paren
(brace
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arq-&gt;hash.prev
op_ne
id|head
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|arq-&gt;hash
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|arq-&gt;hash
comma
id|head
)paren
suffix:semicolon
)brace
)brace
DECL|function|as_find_arq_hash
r_static
r_struct
id|request
op_star
id|as_find_arq_hash
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
id|sector_t
id|offset
)paren
(brace
r_struct
id|list_head
op_star
id|hash_list
op_assign
op_amp
id|ad-&gt;hash
(braket
id|AS_HASH_FN
c_func
(paren
id|offset
)paren
)braket
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|next
op_assign
id|hash_list-&gt;next
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
id|next
)paren
op_ne
id|hash_list
)paren
(brace
r_struct
id|as_rq
op_star
id|arq
op_assign
id|list_entry_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
r_struct
id|request
op_star
id|__rq
op_assign
id|arq-&gt;request
suffix:semicolon
id|next
op_assign
id|entry-&gt;next
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|arq-&gt;on_hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq_mergeable
c_func
(paren
id|__rq
)paren
)paren
(brace
id|as_remove_merge_hints
c_func
(paren
id|ad-&gt;q
comma
id|arq
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq_hash_key
c_func
(paren
id|__rq
)paren
op_eq
id|offset
)paren
r_return
id|__rq
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * rb tree support functions&n; */
DECL|macro|RB_NONE
mdefine_line|#define RB_NONE&t;&t;(2)
DECL|macro|RB_EMPTY
mdefine_line|#define RB_EMPTY(root)&t;((root)-&gt;rb_node == NULL)
DECL|macro|ON_RB
mdefine_line|#define ON_RB(node)&t;((node)-&gt;rb_color != RB_NONE)
DECL|macro|RB_CLEAR
mdefine_line|#define RB_CLEAR(node)&t;((node)-&gt;rb_color = RB_NONE)
DECL|macro|rb_entry_arq
mdefine_line|#define rb_entry_arq(node)&t;rb_entry((node), struct as_rq, rb_node)
DECL|macro|ARQ_RB_ROOT
mdefine_line|#define ARQ_RB_ROOT(ad, arq)&t;(&amp;(ad)-&gt;sort_list[(arq)-&gt;is_sync])
DECL|macro|rq_rb_key
mdefine_line|#define rq_rb_key(rq)&t;&t;(rq)-&gt;sector
multiline_comment|/*&n; * as_find_first_arq finds the first (lowest sector numbered) request&n; * for the specified data_dir. Used to sweep back to the start of the disk&n; * (1-way elevator) after we process the last (highest sector) request.&n; */
DECL|function|as_find_first_arq
r_static
r_struct
id|as_rq
op_star
id|as_find_first_arq
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_int
id|data_dir
)paren
(brace
r_struct
id|rb_node
op_star
id|n
op_assign
id|ad-&gt;sort_list
(braket
id|data_dir
)braket
dot
id|rb_node
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|n-&gt;rb_left
op_eq
l_int|NULL
)paren
r_return
id|rb_entry_arq
c_func
(paren
id|n
)paren
suffix:semicolon
id|n
op_assign
id|n-&gt;rb_left
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Add the request to the rb tree if it is unique.  If there is an alias (an&n; * existing request against the same sector), which can happen when using&n; * direct IO, then return the alias.&n; */
DECL|function|as_add_arq_rb
r_static
r_struct
id|as_rq
op_star
id|as_add_arq_rb
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
r_struct
id|rb_node
op_star
op_star
id|p
op_assign
op_amp
id|ARQ_RB_ROOT
c_func
(paren
id|ad
comma
id|arq
)paren
op_member_access_from_pointer
id|rb_node
suffix:semicolon
r_struct
id|rb_node
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|as_rq
op_star
id|__arq
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|arq-&gt;request
suffix:semicolon
id|arq-&gt;rb_key
op_assign
id|rq_rb_key
c_func
(paren
id|rq
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|__arq
op_assign
id|rb_entry_arq
c_func
(paren
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arq-&gt;rb_key
OL
id|__arq-&gt;rb_key
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
id|arq-&gt;rb_key
OG
id|__arq-&gt;rb_key
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_right
suffix:semicolon
r_else
r_return
id|__arq
suffix:semicolon
)brace
id|rb_link_node
c_func
(paren
op_amp
id|arq-&gt;rb_node
comma
id|parent
comma
id|p
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|arq-&gt;rb_node
comma
id|ARQ_RB_ROOT
c_func
(paren
id|ad
comma
id|arq
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|as_del_arq_rb
r_static
r_inline
r_void
id|as_del_arq_rb
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ON_RB
c_func
(paren
op_amp
id|arq-&gt;rb_node
)paren
)paren
(brace
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rb_erase
c_func
(paren
op_amp
id|arq-&gt;rb_node
comma
id|ARQ_RB_ROOT
c_func
(paren
id|ad
comma
id|arq
)paren
)paren
suffix:semicolon
id|RB_CLEAR
c_func
(paren
op_amp
id|arq-&gt;rb_node
)paren
suffix:semicolon
)brace
r_static
r_struct
id|request
op_star
DECL|function|as_find_arq_rb
id|as_find_arq_rb
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
id|sector_t
id|sector
comma
r_int
id|data_dir
)paren
(brace
r_struct
id|rb_node
op_star
id|n
op_assign
id|ad-&gt;sort_list
(braket
id|data_dir
)braket
dot
id|rb_node
suffix:semicolon
r_struct
id|as_rq
op_star
id|arq
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
id|arq
op_assign
id|rb_entry_arq
c_func
(paren
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sector
OL
id|arq-&gt;rb_key
)paren
id|n
op_assign
id|n-&gt;rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sector
OG
id|arq-&gt;rb_key
)paren
id|n
op_assign
id|n-&gt;rb_right
suffix:semicolon
r_else
r_return
id|arq-&gt;request
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * IO Scheduler proper&n; */
DECL|macro|MAXBACK
mdefine_line|#define MAXBACK (1024 * 1024)&t;/*&n;&t;&t;&t;&t; * Maximum distance the disk will go backward&n;&t;&t;&t;&t; * for a request.&n;&t;&t;&t;&t; */
DECL|macro|BACK_PENALTY
mdefine_line|#define BACK_PENALTY&t;2
multiline_comment|/*&n; * as_choose_req selects the preferred one of two requests of the same data_dir&n; * ignoring time - eg. timeouts, which is the job of as_dispatch_request&n; */
r_static
r_struct
id|as_rq
op_star
DECL|function|as_choose_req
id|as_choose_req
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|arq1
comma
r_struct
id|as_rq
op_star
id|arq2
)paren
(brace
r_int
id|data_dir
suffix:semicolon
id|sector_t
id|last
comma
id|s1
comma
id|s2
comma
id|d1
comma
id|d2
suffix:semicolon
r_int
id|r1_wrap
op_assign
l_int|0
comma
id|r2_wrap
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* requests are behind the disk head */
r_const
id|sector_t
id|maxback
op_assign
id|MAXBACK
suffix:semicolon
r_if
c_cond
(paren
id|arq1
op_eq
l_int|NULL
op_logical_or
id|arq1
op_eq
id|arq2
)paren
r_return
id|arq2
suffix:semicolon
r_if
c_cond
(paren
id|arq2
op_eq
l_int|NULL
)paren
r_return
id|arq1
suffix:semicolon
id|data_dir
op_assign
id|arq1-&gt;is_sync
suffix:semicolon
id|last
op_assign
id|ad-&gt;last_sector
(braket
id|data_dir
)braket
suffix:semicolon
id|s1
op_assign
id|arq1-&gt;request-&gt;sector
suffix:semicolon
id|s2
op_assign
id|arq2-&gt;request-&gt;sector
suffix:semicolon
id|BUG_ON
c_func
(paren
id|data_dir
op_ne
id|arq2-&gt;is_sync
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Strict one way elevator _except_ in the case where we allow&n;&t; * short backward seeks which are biased as twice the cost of a&n;&t; * similar forward seek.&n;&t; */
r_if
c_cond
(paren
id|s1
op_ge
id|last
)paren
id|d1
op_assign
id|s1
op_minus
id|last
suffix:semicolon
r_else
r_if
c_cond
(paren
id|s1
op_plus
id|maxback
op_ge
id|last
)paren
id|d1
op_assign
(paren
id|last
op_minus
id|s1
)paren
op_star
id|BACK_PENALTY
suffix:semicolon
r_else
(brace
id|r1_wrap
op_assign
l_int|1
suffix:semicolon
id|d1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* shut up, gcc */
)brace
r_if
c_cond
(paren
id|s2
op_ge
id|last
)paren
id|d2
op_assign
id|s2
op_minus
id|last
suffix:semicolon
r_else
r_if
c_cond
(paren
id|s2
op_plus
id|maxback
op_ge
id|last
)paren
id|d2
op_assign
(paren
id|last
op_minus
id|s2
)paren
op_star
id|BACK_PENALTY
suffix:semicolon
r_else
(brace
id|r2_wrap
op_assign
l_int|1
suffix:semicolon
id|d2
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Found required data */
r_if
c_cond
(paren
op_logical_neg
id|r1_wrap
op_logical_and
id|r2_wrap
)paren
r_return
id|arq1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|r2_wrap
op_logical_and
id|r1_wrap
)paren
r_return
id|arq2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r1_wrap
op_logical_and
id|r2_wrap
)paren
(brace
multiline_comment|/* both behind the head */
r_if
c_cond
(paren
id|s1
op_le
id|s2
)paren
r_return
id|arq1
suffix:semicolon
r_else
r_return
id|arq2
suffix:semicolon
)brace
multiline_comment|/* Both requests in front of the head */
r_if
c_cond
(paren
id|d1
OL
id|d2
)paren
r_return
id|arq1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|d2
OL
id|d1
)paren
r_return
id|arq2
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|s1
op_ge
id|s2
)paren
r_return
id|arq1
suffix:semicolon
r_else
r_return
id|arq2
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * as_find_next_arq finds the next request after @prev in elevator order.&n; * this with as_choose_req form the basis for how the scheduler chooses&n; * what request to process next. Anticipation works on top of this.&n; */
DECL|function|as_find_next_arq
r_static
r_struct
id|as_rq
op_star
id|as_find_next_arq
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|last
)paren
(brace
r_const
r_int
id|data_dir
op_assign
id|last-&gt;is_sync
suffix:semicolon
r_struct
id|as_rq
op_star
id|ret
suffix:semicolon
r_struct
id|rb_node
op_star
id|rbnext
op_assign
id|rb_next
c_func
(paren
op_amp
id|last-&gt;rb_node
)paren
suffix:semicolon
r_struct
id|rb_node
op_star
id|rbprev
op_assign
id|rb_prev
c_func
(paren
op_amp
id|last-&gt;rb_node
)paren
suffix:semicolon
r_struct
id|as_rq
op_star
id|arq_next
comma
op_star
id|arq_prev
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|ON_RB
c_func
(paren
op_amp
id|last-&gt;rb_node
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbprev
)paren
id|arq_prev
op_assign
id|rb_entry_arq
c_func
(paren
id|rbprev
)paren
suffix:semicolon
r_else
id|arq_prev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|rbnext
)paren
id|arq_next
op_assign
id|rb_entry_arq
c_func
(paren
id|rbnext
)paren
suffix:semicolon
r_else
(brace
id|arq_next
op_assign
id|as_find_first_arq
c_func
(paren
id|ad
comma
id|data_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arq_next
op_eq
id|last
)paren
id|arq_next
op_assign
l_int|NULL
suffix:semicolon
)brace
id|ret
op_assign
id|as_choose_req
c_func
(paren
id|ad
comma
id|arq_next
comma
id|arq_prev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * anticipatory scheduling functions follow&n; */
multiline_comment|/*&n; * as_antic_expired tells us when we have anticipated too long.&n; * The funny &quot;absolute difference&quot; math on the elapsed time is to handle&n; * jiffy wraps, and disks which have been idle for 0x80000000 jiffies.&n; */
DECL|function|as_antic_expired
r_static
r_int
id|as_antic_expired
c_func
(paren
r_struct
id|as_data
op_star
id|ad
)paren
(brace
r_int
id|delta_jif
suffix:semicolon
id|delta_jif
op_assign
id|jiffies
op_minus
id|ad-&gt;antic_start
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|delta_jif
OL
l_int|0
)paren
)paren
id|delta_jif
op_assign
op_minus
id|delta_jif
suffix:semicolon
r_if
c_cond
(paren
id|delta_jif
OL
id|ad-&gt;antic_expire
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * as_antic_waitnext starts anticipating that a nice request will soon be&n; * submitted. See also as_antic_waitreq&n; */
DECL|function|as_antic_waitnext
r_static
r_void
id|as_antic_waitnext
c_func
(paren
r_struct
id|as_data
op_star
id|ad
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ad-&gt;antic_status
op_ne
id|ANTIC_OFF
op_logical_and
id|ad-&gt;antic_status
op_ne
id|ANTIC_WAIT_REQ
)paren
suffix:semicolon
id|timeout
op_assign
id|ad-&gt;antic_start
op_plus
id|ad-&gt;antic_expire
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|ad-&gt;antic_timer
comma
id|timeout
)paren
suffix:semicolon
id|ad-&gt;antic_status
op_assign
id|ANTIC_WAIT_NEXT
suffix:semicolon
)brace
multiline_comment|/*&n; * as_antic_waitreq starts anticipating. We don&squot;t start timing the anticipation&n; * until the request that we&squot;re anticipating on has finished. This means we&n; * are timing from when the candidate process wakes up hopefully.&n; */
DECL|function|as_antic_waitreq
r_static
r_void
id|as_antic_waitreq
c_func
(paren
r_struct
id|as_data
op_star
id|ad
)paren
(brace
id|BUG_ON
c_func
(paren
id|ad-&gt;antic_status
op_eq
id|ANTIC_FINISHED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;antic_status
op_eq
id|ANTIC_OFF
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ad-&gt;io_context
op_logical_or
id|ad-&gt;ioc_finished
)paren
id|as_antic_waitnext
c_func
(paren
id|ad
)paren
suffix:semicolon
r_else
id|ad-&gt;antic_status
op_assign
id|ANTIC_WAIT_REQ
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is called directly by the functions in this file to stop anticipation.&n; * We kill the timer and schedule a call to the request_fn asap.&n; */
DECL|function|as_antic_stop
r_static
r_void
id|as_antic_stop
c_func
(paren
r_struct
id|as_data
op_star
id|ad
)paren
(brace
r_int
id|status
op_assign
id|ad-&gt;antic_status
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|ANTIC_WAIT_REQ
op_logical_or
id|status
op_eq
id|ANTIC_WAIT_NEXT
)paren
(brace
r_if
c_cond
(paren
id|status
op_eq
id|ANTIC_WAIT_NEXT
)paren
id|del_timer
c_func
(paren
op_amp
id|ad-&gt;antic_timer
)paren
suffix:semicolon
id|ad-&gt;antic_status
op_assign
id|ANTIC_FINISHED
suffix:semicolon
multiline_comment|/* see as_work_handler */
id|kblockd_schedule_work
c_func
(paren
op_amp
id|ad-&gt;antic_work
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * as_antic_timeout is the timer function set by as_antic_waitnext.&n; */
DECL|function|as_antic_timeout
r_static
r_void
id|as_antic_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|request_queue
op_star
id|q
op_assign
(paren
r_struct
id|request_queue
op_star
)paren
id|data
suffix:semicolon
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;antic_status
op_eq
id|ANTIC_WAIT_REQ
op_logical_or
id|ad-&gt;antic_status
op_eq
id|ANTIC_WAIT_NEXT
)paren
(brace
r_struct
id|as_io_context
op_star
id|aic
op_assign
id|ad-&gt;io_context-&gt;aic
suffix:semicolon
id|ad-&gt;antic_status
op_assign
id|ANTIC_FINISHED
suffix:semicolon
id|kblockd_schedule_work
c_func
(paren
op_amp
id|ad-&gt;antic_work
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic-&gt;ttime_samples
op_eq
l_int|0
)paren
(brace
multiline_comment|/* process anticipated on has exitted or timed out*/
id|ad-&gt;exit_prob
op_assign
(paren
l_int|7
op_star
id|ad-&gt;exit_prob
op_plus
l_int|256
)paren
op_div
l_int|8
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * as_close_req decides if one request is considered &quot;close&quot; to the&n; * previous one issued.&n; */
DECL|function|as_close_req
r_static
r_int
id|as_close_req
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
r_int
r_int
id|delay
suffix:semicolon
multiline_comment|/* milliseconds */
id|sector_t
id|last
op_assign
id|ad-&gt;last_sector
(braket
id|ad-&gt;batch_data_dir
)braket
suffix:semicolon
id|sector_t
id|next
op_assign
id|arq-&gt;request-&gt;sector
suffix:semicolon
id|sector_t
id|delta
suffix:semicolon
multiline_comment|/* acceptable close offset (in sectors) */
r_if
c_cond
(paren
id|ad-&gt;antic_status
op_eq
id|ANTIC_OFF
op_logical_or
op_logical_neg
id|ad-&gt;ioc_finished
)paren
id|delay
op_assign
l_int|0
suffix:semicolon
r_else
id|delay
op_assign
(paren
(paren
id|jiffies
op_minus
id|ad-&gt;antic_start
)paren
op_star
l_int|1000
)paren
op_div
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|delay
op_le
l_int|1
)paren
id|delta
op_assign
l_int|64
suffix:semicolon
r_else
r_if
c_cond
(paren
id|delay
op_le
l_int|20
op_logical_and
id|delay
op_le
id|ad-&gt;antic_expire
)paren
id|delta
op_assign
l_int|64
op_lshift
(paren
id|delay
op_minus
l_int|1
)paren
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
r_return
(paren
id|last
op_minus
(paren
id|delta
op_rshift
l_int|1
)paren
op_le
id|next
)paren
op_logical_and
(paren
id|next
op_le
id|last
op_plus
id|delta
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * as_can_break_anticipation returns true if we have been anticipating this&n; * request.&n; *&n; * It also returns true if the process against which we are anticipating&n; * submits a write - that&squot;s presumably an fsync, O_SYNC write, etc. We want to&n; * dispatch it ASAP, because we know that application will not be submitting&n; * any new reads.&n; *&n; * If the task which has submitted the request has exitted, break anticipation.&n; *&n; * If this task has queued some other IO, do not enter enticipation.&n; */
DECL|function|as_can_break_anticipation
r_static
r_int
id|as_can_break_anticipation
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
r_struct
id|io_context
op_star
id|ioc
suffix:semicolon
r_struct
id|as_io_context
op_star
id|aic
suffix:semicolon
id|sector_t
id|s
suffix:semicolon
id|ioc
op_assign
id|ad-&gt;io_context
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|ioc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arq
op_logical_and
id|ioc
op_eq
id|arq-&gt;io_context
)paren
(brace
multiline_comment|/* request from same process */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ad-&gt;ioc_finished
op_logical_and
id|as_antic_expired
c_func
(paren
id|ad
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * In this situation status should really be FINISHED,&n;&t;&t; * however the timer hasn&squot;t had the chance to run yet.&n;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
id|aic
op_assign
id|ioc-&gt;aic
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aic
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|AS_TASK_RUNNING
comma
op_amp
id|aic-&gt;state
)paren
)paren
(brace
multiline_comment|/* process anticipated on has exitted */
r_if
c_cond
(paren
id|aic-&gt;ttime_samples
op_eq
l_int|0
)paren
id|ad-&gt;exit_prob
op_assign
(paren
l_int|7
op_star
id|ad-&gt;exit_prob
op_plus
l_int|256
)paren
op_div
l_int|8
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|aic-&gt;nr_queued
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* process has more requests queued */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|aic-&gt;nr_dispatched
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* process has more requests dispatched */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arq
op_logical_and
id|arq-&gt;is_sync
op_eq
id|REQ_SYNC
op_logical_and
id|as_close_req
c_func
(paren
id|ad
comma
id|arq
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Found a close request that is not one of ours.&n;&t;&t; *&n;&t;&t; * This makes close requests from another process reset&n;&t;&t; * our thinktime delay. Is generally useful when there are&n;&t;&t; * two or more cooperating processes working in the same&n;&t;&t; * area.&n;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|aic-&gt;lock
)paren
suffix:semicolon
id|aic-&gt;last_end_request
op_assign
id|jiffies
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|aic-&gt;lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aic-&gt;ttime_samples
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ad-&gt;new_ttime_mean
OG
id|ad-&gt;antic_expire
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;exit_prob
OG
l_int|128
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|aic-&gt;ttime_mean
OG
id|ad-&gt;antic_expire
)paren
(brace
multiline_comment|/* the process thinks too much between requests */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|arq
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;last_sector
(braket
id|REQ_SYNC
)braket
OL
id|arq-&gt;request-&gt;sector
)paren
id|s
op_assign
id|arq-&gt;request-&gt;sector
op_minus
id|ad-&gt;last_sector
(braket
id|REQ_SYNC
)braket
suffix:semicolon
r_else
id|s
op_assign
id|ad-&gt;last_sector
(braket
id|REQ_SYNC
)braket
op_minus
id|arq-&gt;request-&gt;sector
suffix:semicolon
r_if
c_cond
(paren
id|aic-&gt;seek_samples
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Process has just started IO. Use past statistics to&n;&t;&t; * guage success possibility&n;&t;&t; */
r_if
c_cond
(paren
id|ad-&gt;new_seek_mean
OG
id|s
)paren
(brace
multiline_comment|/* this request is better than what we&squot;re expecting */
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|aic-&gt;seek_mean
OG
id|s
)paren
(brace
multiline_comment|/* this request is better than what we&squot;re expecting */
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * as_can_anticipate indicates weather we should either run arq&n; * or keep anticipating a better request.&n; */
DECL|function|as_can_anticipate
r_static
r_int
id|as_can_anticipate
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ad-&gt;io_context
)paren
multiline_comment|/*&n;&t;&t; * Last request submitted was a write&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;antic_status
op_eq
id|ANTIC_FINISHED
)paren
multiline_comment|/*&n;&t;&t; * Don&squot;t restart if we have just finished. Run the next request&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|as_can_break_anticipation
c_func
(paren
id|ad
comma
id|arq
)paren
)paren
multiline_comment|/*&n;&t;&t; * This request is a good candidate. Don&squot;t keep anticipating,&n;&t;&t; * run it.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * OK from here, we haven&squot;t finished, and don&squot;t have a decent request!&n;&t; * Status is either ANTIC_OFF so start waiting,&n;&t; * ANTIC_WAIT_REQ so continue waiting for request to finish&n;&t; * or ANTIC_WAIT_NEXT so continue waiting for an acceptable request.&n;&t; *&n;&t; */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|as_update_thinktime
r_static
r_void
id|as_update_thinktime
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_io_context
op_star
id|aic
comma
r_int
r_int
id|ttime
)paren
(brace
multiline_comment|/* fixed point: 1.0 == 1&lt;&lt;8 */
r_if
c_cond
(paren
id|aic-&gt;ttime_samples
op_eq
l_int|0
)paren
(brace
id|ad-&gt;new_ttime_total
op_assign
(paren
l_int|7
op_star
id|ad-&gt;new_ttime_total
op_plus
l_int|256
op_star
id|ttime
)paren
op_div
l_int|8
suffix:semicolon
id|ad-&gt;new_ttime_mean
op_assign
id|ad-&gt;new_ttime_total
op_div
l_int|256
suffix:semicolon
id|ad-&gt;exit_prob
op_assign
(paren
l_int|7
op_star
id|ad-&gt;exit_prob
)paren
op_div
l_int|8
suffix:semicolon
)brace
id|aic-&gt;ttime_samples
op_assign
(paren
l_int|7
op_star
id|aic-&gt;ttime_samples
op_plus
l_int|256
)paren
op_div
l_int|8
suffix:semicolon
id|aic-&gt;ttime_total
op_assign
(paren
l_int|7
op_star
id|aic-&gt;ttime_total
op_plus
l_int|256
op_star
id|ttime
)paren
op_div
l_int|8
suffix:semicolon
id|aic-&gt;ttime_mean
op_assign
(paren
id|aic-&gt;ttime_total
op_plus
l_int|128
)paren
op_div
id|aic-&gt;ttime_samples
suffix:semicolon
)brace
DECL|function|as_update_seekdist
r_static
r_void
id|as_update_seekdist
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_io_context
op_star
id|aic
comma
id|sector_t
id|sdist
)paren
(brace
id|u64
id|total
suffix:semicolon
r_if
c_cond
(paren
id|aic-&gt;seek_samples
op_eq
l_int|0
)paren
(brace
id|ad-&gt;new_seek_total
op_assign
(paren
l_int|7
op_star
id|ad-&gt;new_seek_total
op_plus
l_int|256
op_star
(paren
id|u64
)paren
id|sdist
)paren
op_div
l_int|8
suffix:semicolon
id|ad-&gt;new_seek_mean
op_assign
id|ad-&gt;new_seek_total
op_div
l_int|256
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Don&squot;t allow the seek distance to get too large from the&n;&t; * odd fragment, pagein, etc&n;&t; */
r_if
c_cond
(paren
id|aic-&gt;seek_samples
op_le
l_int|60
)paren
multiline_comment|/* second&amp;third seek */
id|sdist
op_assign
id|min
c_func
(paren
id|sdist
comma
(paren
id|aic-&gt;seek_mean
op_star
l_int|4
)paren
op_plus
l_int|2
op_star
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
r_else
id|sdist
op_assign
id|min
c_func
(paren
id|sdist
comma
(paren
id|aic-&gt;seek_mean
op_star
l_int|4
)paren
op_plus
l_int|2
op_star
l_int|1024
op_star
l_int|64
)paren
suffix:semicolon
id|aic-&gt;seek_samples
op_assign
(paren
l_int|7
op_star
id|aic-&gt;seek_samples
op_plus
l_int|256
)paren
op_div
l_int|8
suffix:semicolon
id|aic-&gt;seek_total
op_assign
(paren
l_int|7
op_star
id|aic-&gt;seek_total
op_plus
(paren
id|u64
)paren
l_int|256
op_star
id|sdist
)paren
op_div
l_int|8
suffix:semicolon
id|total
op_assign
id|aic-&gt;seek_total
op_plus
(paren
id|aic-&gt;seek_samples
op_div
l_int|2
)paren
suffix:semicolon
id|do_div
c_func
(paren
id|total
comma
id|aic-&gt;seek_samples
)paren
suffix:semicolon
id|aic-&gt;seek_mean
op_assign
(paren
id|sector_t
)paren
id|total
suffix:semicolon
)brace
multiline_comment|/*&n; * as_update_iohist keeps a decaying histogram of IO thinktimes, and&n; * updates @aic-&gt;ttime_mean based on that. It is called when a new&n; * request is queued.&n; */
DECL|function|as_update_iohist
r_static
r_void
id|as_update_iohist
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_io_context
op_star
id|aic
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|as_rq
op_star
id|arq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_int
id|data_dir
op_assign
id|arq-&gt;is_sync
suffix:semicolon
r_int
r_int
id|thinktime
suffix:semicolon
id|sector_t
id|seek_dist
suffix:semicolon
r_if
c_cond
(paren
id|aic
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|data_dir
op_eq
id|REQ_SYNC
)paren
(brace
r_int
r_int
id|in_flight
op_assign
id|atomic_read
c_func
(paren
op_amp
id|aic-&gt;nr_queued
)paren
op_plus
id|atomic_read
c_func
(paren
op_amp
id|aic-&gt;nr_dispatched
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|aic-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|AS_TASK_IORUNNING
comma
op_amp
id|aic-&gt;state
)paren
op_logical_or
id|test_bit
c_func
(paren
id|AS_TASK_IOSTARTED
comma
op_amp
id|aic-&gt;state
)paren
)paren
(brace
multiline_comment|/* Calculate read -&gt; read thinktime */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|AS_TASK_IORUNNING
comma
op_amp
id|aic-&gt;state
)paren
op_logical_and
id|in_flight
op_eq
l_int|0
)paren
(brace
id|thinktime
op_assign
id|jiffies
op_minus
id|aic-&gt;last_end_request
suffix:semicolon
id|thinktime
op_assign
id|min
c_func
(paren
id|thinktime
comma
id|MAX_THINKTIME
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|thinktime
op_assign
l_int|0
suffix:semicolon
id|as_update_thinktime
c_func
(paren
id|ad
comma
id|aic
comma
id|thinktime
)paren
suffix:semicolon
multiline_comment|/* Calculate read -&gt; read seek distance */
r_if
c_cond
(paren
id|aic-&gt;last_request_pos
OL
id|rq-&gt;sector
)paren
id|seek_dist
op_assign
id|rq-&gt;sector
op_minus
id|aic-&gt;last_request_pos
suffix:semicolon
r_else
id|seek_dist
op_assign
id|aic-&gt;last_request_pos
op_minus
id|rq-&gt;sector
suffix:semicolon
id|as_update_seekdist
c_func
(paren
id|ad
comma
id|aic
comma
id|seek_dist
)paren
suffix:semicolon
)brace
id|aic-&gt;last_request_pos
op_assign
id|rq-&gt;sector
op_plus
id|rq-&gt;nr_sectors
suffix:semicolon
id|set_bit
c_func
(paren
id|AS_TASK_IOSTARTED
comma
op_amp
id|aic-&gt;state
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|aic-&gt;lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * as_update_arq must be called whenever a request (arq) is added to&n; * the sort_list. This function keeps caches up to date, and checks if the&n; * request might be one we are &quot;anticipating&quot;&n; */
DECL|function|as_update_arq
r_static
r_void
id|as_update_arq
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
r_const
r_int
id|data_dir
op_assign
id|arq-&gt;is_sync
suffix:semicolon
multiline_comment|/* keep the next_arq cache up to date */
id|ad-&gt;next_arq
(braket
id|data_dir
)braket
op_assign
id|as_choose_req
c_func
(paren
id|ad
comma
id|arq
comma
id|ad-&gt;next_arq
(braket
id|data_dir
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * have we been anticipating this request?&n;&t; * or does it come from the same process as the one we are anticipating&n;&t; * for?&n;&t; */
r_if
c_cond
(paren
id|ad-&gt;antic_status
op_eq
id|ANTIC_WAIT_REQ
op_logical_or
id|ad-&gt;antic_status
op_eq
id|ANTIC_WAIT_NEXT
)paren
(brace
r_if
c_cond
(paren
id|as_can_break_anticipation
c_func
(paren
id|ad
comma
id|arq
)paren
)paren
id|as_antic_stop
c_func
(paren
id|ad
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Gathers timings and resizes the write batch automatically&n; */
DECL|function|update_write_batch
r_static
r_void
id|update_write_batch
c_func
(paren
r_struct
id|as_data
op_star
id|ad
)paren
(brace
r_int
r_int
id|batch
op_assign
id|ad-&gt;batch_expire
(braket
id|REQ_ASYNC
)braket
suffix:semicolon
r_int
id|write_time
suffix:semicolon
id|write_time
op_assign
(paren
id|jiffies
op_minus
id|ad-&gt;current_batch_expires
)paren
op_plus
id|batch
suffix:semicolon
r_if
c_cond
(paren
id|write_time
OL
l_int|0
)paren
id|write_time
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|write_time
OG
id|batch
op_logical_and
op_logical_neg
id|ad-&gt;write_batch_idled
)paren
(brace
r_if
c_cond
(paren
id|write_time
OG
id|batch
op_star
l_int|3
)paren
id|ad-&gt;write_batch_count
op_div_assign
l_int|2
suffix:semicolon
r_else
id|ad-&gt;write_batch_count
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|write_time
OL
id|batch
op_logical_and
id|ad-&gt;current_write_count
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|batch
OG
id|write_time
op_star
l_int|3
)paren
id|ad-&gt;write_batch_count
op_mul_assign
l_int|2
suffix:semicolon
r_else
id|ad-&gt;write_batch_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ad-&gt;write_batch_count
OL
l_int|1
)paren
id|ad-&gt;write_batch_count
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * as_completed_request is to be called when a request has completed and&n; * returned something to the requesting process, be it an error or data.&n; */
DECL|function|as_completed_request
r_static
r_void
id|as_completed_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|as_rq
op_star
id|arq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|rq-&gt;queuelist
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arq-&gt;state
op_eq
id|AS_RQ_PRESCHED
)paren
(brace
id|WARN_ON
c_func
(paren
id|arq-&gt;io_context
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arq-&gt;state
op_eq
id|AS_RQ_MERGED
)paren
r_goto
id|out_ioc
suffix:semicolon
r_if
c_cond
(paren
id|arq-&gt;state
op_ne
id|AS_RQ_REMOVED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arq-&gt;state %d&bslash;n&quot;
comma
id|arq-&gt;state
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|blk_fs_request
c_func
(paren
id|rq
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;changed_batch
op_logical_and
id|ad-&gt;nr_dispatched
op_eq
l_int|1
)paren
(brace
id|kblockd_schedule_work
c_func
(paren
op_amp
id|ad-&gt;antic_work
)paren
suffix:semicolon
id|ad-&gt;changed_batch
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;batch_data_dir
op_eq
id|REQ_SYNC
)paren
id|ad-&gt;new_batch
op_assign
l_int|1
suffix:semicolon
)brace
id|WARN_ON
c_func
(paren
id|ad-&gt;nr_dispatched
op_eq
l_int|0
)paren
suffix:semicolon
id|ad-&gt;nr_dispatched
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; * Start counting the batch from when a request of that direction is&n;&t; * actually serviced. This should help devices with big TCQ windows&n;&t; * and writeback caches&n;&t; */
r_if
c_cond
(paren
id|ad-&gt;new_batch
op_logical_and
id|ad-&gt;batch_data_dir
op_eq
id|arq-&gt;is_sync
)paren
(brace
id|update_write_batch
c_func
(paren
id|ad
)paren
suffix:semicolon
id|ad-&gt;current_batch_expires
op_assign
id|jiffies
op_plus
id|ad-&gt;batch_expire
(braket
id|REQ_SYNC
)braket
suffix:semicolon
id|ad-&gt;new_batch
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ad-&gt;io_context
op_eq
id|arq-&gt;io_context
op_logical_and
id|ad-&gt;io_context
)paren
(brace
id|ad-&gt;antic_start
op_assign
id|jiffies
suffix:semicolon
id|ad-&gt;ioc_finished
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;antic_status
op_eq
id|ANTIC_WAIT_REQ
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We were waiting on this request, now anticipate&n;&t;&t;&t; * the next one&n;&t;&t;&t; */
id|as_antic_waitnext
c_func
(paren
id|ad
)paren
suffix:semicolon
)brace
)brace
id|out_ioc
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arq-&gt;io_context
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|arq-&gt;is_sync
op_eq
id|REQ_SYNC
)paren
(brace
r_struct
id|as_io_context
op_star
id|aic
op_assign
id|arq-&gt;io_context-&gt;aic
suffix:semicolon
r_if
c_cond
(paren
id|aic
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|aic-&gt;lock
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|AS_TASK_IORUNNING
comma
op_amp
id|aic-&gt;state
)paren
suffix:semicolon
id|aic-&gt;last_end_request
op_assign
id|jiffies
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|aic-&gt;lock
)paren
suffix:semicolon
)brace
)brace
id|put_io_context
c_func
(paren
id|arq-&gt;io_context
)paren
suffix:semicolon
id|out
suffix:colon
id|arq-&gt;state
op_assign
id|AS_RQ_POSTSCHED
suffix:semicolon
)brace
multiline_comment|/*&n; * as_remove_queued_request removes a request from the pre dispatch queue&n; * without updating refcounts. It is expected the caller will drop the&n; * reference unless it replaces the request at somepart of the elevator&n; * (ie. the dispatch queue)&n; */
DECL|function|as_remove_queued_request
r_static
r_void
id|as_remove_queued_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|as_rq
op_star
id|arq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_const
r_int
id|data_dir
op_assign
id|arq-&gt;is_sync
suffix:semicolon
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
id|WARN_ON
c_func
(paren
id|arq-&gt;state
op_ne
id|AS_RQ_QUEUED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arq-&gt;io_context
op_logical_and
id|arq-&gt;io_context-&gt;aic
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|arq-&gt;io_context-&gt;aic-&gt;nr_queued
)paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|arq-&gt;io_context-&gt;aic-&gt;nr_queued
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update the &quot;next_arq&quot; cache if we are about to remove its&n;&t; * entry&n;&t; */
r_if
c_cond
(paren
id|ad-&gt;next_arq
(braket
id|data_dir
)braket
op_eq
id|arq
)paren
id|ad-&gt;next_arq
(braket
id|data_dir
)braket
op_assign
id|as_find_next_arq
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|arq-&gt;fifo
)paren
suffix:semicolon
id|as_remove_merge_hints
c_func
(paren
id|q
comma
id|arq
)paren
suffix:semicolon
id|as_del_arq_rb
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * as_remove_dispatched_request is called to remove a request which has gone&n; * to the dispatch list.&n; */
DECL|function|as_remove_dispatched_request
r_static
r_void
id|as_remove_dispatched_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|as_rq
op_star
id|arq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_struct
id|as_io_context
op_star
id|aic
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arq
)paren
(brace
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|WARN_ON
c_func
(paren
id|arq-&gt;state
op_ne
id|AS_RQ_DISPATCHED
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
id|ON_RB
c_func
(paren
op_amp
id|arq-&gt;rb_node
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arq-&gt;io_context
op_logical_and
id|arq-&gt;io_context-&gt;aic
)paren
(brace
id|aic
op_assign
id|arq-&gt;io_context-&gt;aic
suffix:semicolon
r_if
c_cond
(paren
id|aic
)paren
(brace
id|WARN_ON
c_func
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|aic-&gt;nr_dispatched
)paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|aic-&gt;nr_dispatched
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * as_remove_request is called when a driver has finished with a request.&n; * This should be only called for dispatched requests, but for some reason&n; * a POWER4 box running hwscan it does not.&n; */
DECL|function|as_remove_request
r_static
r_void
id|as_remove_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|as_rq
op_star
id|arq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|arq-&gt;state
op_eq
id|AS_RQ_NEW
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|ON_RB
c_func
(paren
op_amp
id|arq-&gt;rb_node
)paren
)paren
(brace
r_if
c_cond
(paren
id|arq-&gt;state
op_ne
id|AS_RQ_QUEUED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arq-&gt;state %d&bslash;n&quot;
comma
id|arq-&gt;state
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We&squot;ll lose the aliased request(s) here. I don&squot;t think this&n;&t;&t; * will ever happen, but if it does, hopefully someone will&n;&t;&t; * report it.&n;&t;&t; */
id|WARN_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|rq-&gt;queuelist
)paren
)paren
suffix:semicolon
id|as_remove_queued_request
c_func
(paren
id|q
comma
id|rq
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|arq-&gt;state
op_ne
id|AS_RQ_DISPATCHED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arq-&gt;state %d&bslash;n&quot;
comma
id|arq-&gt;state
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|as_remove_dispatched_request
c_func
(paren
id|q
comma
id|rq
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|arq-&gt;state
op_assign
id|AS_RQ_REMOVED
suffix:semicolon
)brace
multiline_comment|/*&n; * as_fifo_expired returns 0 if there are no expired reads on the fifo,&n; * 1 otherwise.  It is ratelimited so that we only perform the check once per&n; * `fifo_expire&squot; interval.  Otherwise a large number of expired requests&n; * would create a hopeless seekstorm.&n; *&n; * See as_antic_expired comment.&n; */
DECL|function|as_fifo_expired
r_static
r_int
id|as_fifo_expired
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_int
id|adir
)paren
(brace
r_struct
id|as_rq
op_star
id|arq
suffix:semicolon
r_int
id|delta_jif
suffix:semicolon
id|delta_jif
op_assign
id|jiffies
op_minus
id|ad-&gt;last_check_fifo
(braket
id|adir
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|delta_jif
OL
l_int|0
)paren
)paren
id|delta_jif
op_assign
op_minus
id|delta_jif
suffix:semicolon
r_if
c_cond
(paren
id|delta_jif
OL
id|ad-&gt;fifo_expire
(braket
id|adir
)braket
)paren
r_return
l_int|0
suffix:semicolon
id|ad-&gt;last_check_fifo
(braket
id|adir
)braket
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|ad-&gt;fifo_list
(braket
id|adir
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|arq
op_assign
id|list_entry_fifo
c_func
(paren
id|ad-&gt;fifo_list
(braket
id|adir
)braket
dot
id|next
)paren
suffix:semicolon
r_return
id|time_after
c_func
(paren
id|jiffies
comma
id|arq-&gt;expires
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * as_batch_expired returns true if the current batch has expired. A batch&n; * is a set of reads or a set of writes.&n; */
DECL|function|as_batch_expired
r_static
r_inline
r_int
id|as_batch_expired
c_func
(paren
r_struct
id|as_data
op_star
id|ad
)paren
(brace
r_if
c_cond
(paren
id|ad-&gt;changed_batch
op_logical_or
id|ad-&gt;new_batch
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;batch_data_dir
op_eq
id|REQ_SYNC
)paren
multiline_comment|/* TODO! add a check so a complete fifo gets written? */
r_return
id|time_after
c_func
(paren
id|jiffies
comma
id|ad-&gt;current_batch_expires
)paren
suffix:semicolon
r_return
id|time_after
c_func
(paren
id|jiffies
comma
id|ad-&gt;current_batch_expires
)paren
op_logical_or
id|ad-&gt;current_write_count
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * move an entry to dispatch queue&n; */
DECL|function|as_move_to_dispatch
r_static
r_void
id|as_move_to_dispatch
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|arq-&gt;request
suffix:semicolon
r_struct
id|list_head
op_star
id|insert
suffix:semicolon
r_const
r_int
id|data_dir
op_assign
id|arq-&gt;is_sync
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|ON_RB
c_func
(paren
op_amp
id|arq-&gt;rb_node
)paren
)paren
suffix:semicolon
id|as_antic_stop
c_func
(paren
id|ad
)paren
suffix:semicolon
id|ad-&gt;antic_status
op_assign
id|ANTIC_OFF
suffix:semicolon
multiline_comment|/*&n;&t; * This has to be set in order to be correctly updated by&n;&t; * as_find_next_arq&n;&t; */
id|ad-&gt;last_sector
(braket
id|data_dir
)braket
op_assign
id|rq-&gt;sector
op_plus
id|rq-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|data_dir
op_eq
id|REQ_SYNC
)paren
(brace
multiline_comment|/* In case we have to anticipate after this */
id|copy_io_context
c_func
(paren
op_amp
id|ad-&gt;io_context
comma
op_amp
id|arq-&gt;io_context
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ad-&gt;io_context
)paren
(brace
id|put_io_context
c_func
(paren
id|ad-&gt;io_context
)paren
suffix:semicolon
id|ad-&gt;io_context
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ad-&gt;current_write_count
op_ne
l_int|0
)paren
id|ad-&gt;current_write_count
op_decrement
suffix:semicolon
)brace
id|ad-&gt;ioc_finished
op_assign
l_int|0
suffix:semicolon
id|ad-&gt;next_arq
(braket
id|data_dir
)braket
op_assign
id|as_find_next_arq
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * take it off the sort and fifo list, add to dispatch queue&n;&t; */
id|insert
op_assign
id|ad-&gt;dispatch-&gt;prev
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|rq-&gt;queuelist
)paren
)paren
(brace
r_struct
id|request
op_star
id|__rq
op_assign
id|list_entry_rq
c_func
(paren
id|rq-&gt;queuelist.next
)paren
suffix:semicolon
r_struct
id|as_rq
op_star
id|__arq
op_assign
id|RQ_DATA
c_func
(paren
id|__rq
)paren
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|__rq-&gt;queuelist
comma
id|ad-&gt;dispatch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__arq-&gt;io_context
op_logical_and
id|__arq-&gt;io_context-&gt;aic
)paren
id|atomic_inc
c_func
(paren
op_amp
id|__arq-&gt;io_context-&gt;aic-&gt;nr_dispatched
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
id|__arq-&gt;state
op_ne
id|AS_RQ_QUEUED
)paren
suffix:semicolon
id|__arq-&gt;state
op_assign
id|AS_RQ_DISPATCHED
suffix:semicolon
id|ad-&gt;nr_dispatched
op_increment
suffix:semicolon
)brace
id|as_remove_queued_request
c_func
(paren
id|ad-&gt;q
comma
id|rq
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|rq-&gt;queuelist
comma
id|insert
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arq-&gt;io_context
op_logical_and
id|arq-&gt;io_context-&gt;aic
)paren
id|atomic_inc
c_func
(paren
op_amp
id|arq-&gt;io_context-&gt;aic-&gt;nr_dispatched
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
id|arq-&gt;state
op_ne
id|AS_RQ_QUEUED
)paren
suffix:semicolon
id|arq-&gt;state
op_assign
id|AS_RQ_DISPATCHED
suffix:semicolon
id|ad-&gt;nr_dispatched
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * as_dispatch_request selects the best request according to&n; * read/write expire, batch expire, etc, and moves it to the dispatch&n; * queue. Returns 1 if a request was found, 0 otherwise.&n; */
DECL|function|as_dispatch_request
r_static
r_int
id|as_dispatch_request
c_func
(paren
r_struct
id|as_data
op_star
id|ad
)paren
(brace
r_struct
id|as_rq
op_star
id|arq
suffix:semicolon
r_const
r_int
id|reads
op_assign
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ad-&gt;fifo_list
(braket
id|REQ_SYNC
)braket
)paren
suffix:semicolon
r_const
r_int
id|writes
op_assign
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ad-&gt;fifo_list
(braket
id|REQ_ASYNC
)braket
)paren
suffix:semicolon
multiline_comment|/* Signal that the write batch was uncontended, so we can&squot;t time it */
r_if
c_cond
(paren
id|ad-&gt;batch_data_dir
op_eq
id|REQ_ASYNC
op_logical_and
op_logical_neg
id|reads
)paren
(brace
r_if
c_cond
(paren
id|ad-&gt;current_write_count
op_eq
l_int|0
op_logical_or
op_logical_neg
id|writes
)paren
id|ad-&gt;write_batch_idled
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|reads
op_logical_or
id|writes
)paren
op_logical_or
id|ad-&gt;antic_status
op_eq
id|ANTIC_WAIT_REQ
op_logical_or
id|ad-&gt;antic_status
op_eq
id|ANTIC_WAIT_NEXT
op_logical_or
id|ad-&gt;changed_batch
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|reads
op_logical_and
id|writes
op_logical_and
id|as_batch_expired
c_func
(paren
id|ad
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * batch is still running or no reads or no writes&n;&t;&t; */
id|arq
op_assign
id|ad-&gt;next_arq
(braket
id|ad-&gt;batch_data_dir
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;batch_data_dir
op_eq
id|REQ_SYNC
op_logical_and
id|ad-&gt;antic_expire
)paren
(brace
r_if
c_cond
(paren
id|as_fifo_expired
c_func
(paren
id|ad
comma
id|REQ_SYNC
)paren
)paren
r_goto
id|fifo_expired
suffix:semicolon
r_if
c_cond
(paren
id|as_can_anticipate
c_func
(paren
id|ad
comma
id|arq
)paren
)paren
(brace
id|as_antic_waitreq
c_func
(paren
id|ad
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|arq
)paren
(brace
multiline_comment|/* we have a &quot;next request&quot; */
r_if
c_cond
(paren
id|reads
op_logical_and
op_logical_neg
id|writes
)paren
id|ad-&gt;current_batch_expires
op_assign
id|jiffies
op_plus
id|ad-&gt;batch_expire
(braket
id|REQ_SYNC
)braket
suffix:semicolon
r_goto
id|dispatch_request
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * at this point we are not running a batch. select the appropriate&n;&t; * data direction (read / write)&n;&t; */
r_if
c_cond
(paren
id|reads
)paren
(brace
id|BUG_ON
c_func
(paren
id|RB_EMPTY
c_func
(paren
op_amp
id|ad-&gt;sort_list
(braket
id|REQ_SYNC
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writes
op_logical_and
id|ad-&gt;batch_data_dir
op_eq
id|REQ_SYNC
)paren
multiline_comment|/*&n;&t;&t;&t; * Last batch was a read, switch to writes&n;&t;&t;&t; */
r_goto
id|dispatch_writes
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;batch_data_dir
op_eq
id|REQ_ASYNC
)paren
(brace
id|WARN_ON
c_func
(paren
id|ad-&gt;new_batch
)paren
suffix:semicolon
id|ad-&gt;changed_batch
op_assign
l_int|1
suffix:semicolon
)brace
id|ad-&gt;batch_data_dir
op_assign
id|REQ_SYNC
suffix:semicolon
id|arq
op_assign
id|list_entry_fifo
c_func
(paren
id|ad-&gt;fifo_list
(braket
id|ad-&gt;batch_data_dir
)braket
dot
id|next
)paren
suffix:semicolon
id|ad-&gt;last_check_fifo
(braket
id|ad-&gt;batch_data_dir
)braket
op_assign
id|jiffies
suffix:semicolon
r_goto
id|dispatch_request
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * the last batch was a read&n;&t; */
r_if
c_cond
(paren
id|writes
)paren
(brace
id|dispatch_writes
suffix:colon
id|BUG_ON
c_func
(paren
id|RB_EMPTY
c_func
(paren
op_amp
id|ad-&gt;sort_list
(braket
id|REQ_ASYNC
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;batch_data_dir
op_eq
id|REQ_SYNC
)paren
(brace
id|ad-&gt;changed_batch
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * new_batch might be 1 when the queue runs out of&n;&t;&t;&t; * reads. A subsequent submission of a write might&n;&t;&t;&t; * cause a change of batch before the read is finished.&n;&t;&t;&t; */
id|ad-&gt;new_batch
op_assign
l_int|0
suffix:semicolon
)brace
id|ad-&gt;batch_data_dir
op_assign
id|REQ_ASYNC
suffix:semicolon
id|ad-&gt;current_write_count
op_assign
id|ad-&gt;write_batch_count
suffix:semicolon
id|ad-&gt;write_batch_idled
op_assign
l_int|0
suffix:semicolon
id|arq
op_assign
id|ad-&gt;next_arq
(braket
id|ad-&gt;batch_data_dir
)braket
suffix:semicolon
r_goto
id|dispatch_request
suffix:semicolon
)brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|dispatch_request
suffix:colon
multiline_comment|/*&n;&t; * If a request has expired, service it.&n;&t; */
r_if
c_cond
(paren
id|as_fifo_expired
c_func
(paren
id|ad
comma
id|ad-&gt;batch_data_dir
)paren
)paren
(brace
id|fifo_expired
suffix:colon
id|arq
op_assign
id|list_entry_fifo
c_func
(paren
id|ad-&gt;fifo_list
(braket
id|ad-&gt;batch_data_dir
)braket
dot
id|next
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|arq
op_eq
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ad-&gt;changed_batch
)paren
(brace
id|WARN_ON
c_func
(paren
id|ad-&gt;new_batch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;nr_dispatched
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;batch_data_dir
op_eq
id|REQ_ASYNC
)paren
id|ad-&gt;current_batch_expires
op_assign
id|jiffies
op_plus
id|ad-&gt;batch_expire
(braket
id|REQ_ASYNC
)braket
suffix:semicolon
r_else
id|ad-&gt;new_batch
op_assign
l_int|1
suffix:semicolon
id|ad-&gt;changed_batch
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * arq is the selected appropriate request.&n;&t; */
id|as_move_to_dispatch
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|as_next_request
r_static
r_struct
id|request
op_star
id|as_next_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * if there are still requests on the dispatch queue, grab the first&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|ad-&gt;dispatch
)paren
op_logical_or
id|as_dispatch_request
c_func
(paren
id|ad
)paren
)paren
id|rq
op_assign
id|list_entry_rq
c_func
(paren
id|ad-&gt;dispatch-&gt;next
)paren
suffix:semicolon
r_return
id|rq
suffix:semicolon
)brace
multiline_comment|/*&n; * Add arq to a list behind alias&n; */
r_static
r_inline
r_void
DECL|function|as_add_aliased_request
id|as_add_aliased_request
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|arq
comma
r_struct
id|as_rq
op_star
id|alias
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
id|arq-&gt;request
suffix:semicolon
r_struct
id|list_head
op_star
id|insert
op_assign
id|alias-&gt;request-&gt;queuelist.prev
suffix:semicolon
multiline_comment|/*&n;&t; * Transfer list of aliases&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|req-&gt;queuelist
)paren
)paren
(brace
r_struct
id|request
op_star
id|__rq
op_assign
id|list_entry_rq
c_func
(paren
id|req-&gt;queuelist.next
)paren
suffix:semicolon
r_struct
id|as_rq
op_star
id|__arq
op_assign
id|RQ_DATA
c_func
(paren
id|__rq
)paren
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|__rq-&gt;queuelist
comma
op_amp
id|alias-&gt;request-&gt;queuelist
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
id|__arq-&gt;state
op_ne
id|AS_RQ_QUEUED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Another request with the same start sector on the rbtree.&n;&t; * Link this request to that sector. They are untangled in&n;&t; * as_move_to_dispatch&n;&t; */
id|list_add
c_func
(paren
op_amp
id|arq-&gt;request-&gt;queuelist
comma
id|insert
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t want to have to handle merges.&n;&t; */
id|as_remove_merge_hints
c_func
(paren
id|ad-&gt;q
comma
id|arq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * add arq to rbtree and fifo&n; */
DECL|function|as_add_request
r_static
r_void
id|as_add_request
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_struct
id|as_rq
op_star
id|arq
)paren
(brace
r_struct
id|as_rq
op_star
id|alias
suffix:semicolon
r_int
id|data_dir
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|arq-&gt;request
)paren
op_eq
id|READ
op_logical_or
id|current-&gt;flags
op_amp
id|PF_SYNCWRITE
)paren
id|arq-&gt;is_sync
op_assign
l_int|1
suffix:semicolon
r_else
id|arq-&gt;is_sync
op_assign
l_int|0
suffix:semicolon
id|data_dir
op_assign
id|arq-&gt;is_sync
suffix:semicolon
id|arq-&gt;io_context
op_assign
id|as_get_io_context
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arq-&gt;io_context
)paren
(brace
id|as_update_iohist
c_func
(paren
id|ad
comma
id|arq-&gt;io_context-&gt;aic
comma
id|arq-&gt;request
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|arq-&gt;io_context-&gt;aic-&gt;nr_queued
)paren
suffix:semicolon
)brace
id|alias
op_assign
id|as_add_arq_rb
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|alias
)paren
(brace
multiline_comment|/*&n;&t;&t; * set expire time (only used for reads) and add to fifo list&n;&t;&t; */
id|arq-&gt;expires
op_assign
id|jiffies
op_plus
id|ad-&gt;fifo_expire
(braket
id|data_dir
)braket
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|arq-&gt;fifo
comma
op_amp
id|ad-&gt;fifo_list
(braket
id|data_dir
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq_mergeable
c_func
(paren
id|arq-&gt;request
)paren
)paren
(brace
id|as_add_arq_hash
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ad-&gt;q-&gt;last_merge
)paren
id|ad-&gt;q-&gt;last_merge
op_assign
id|arq-&gt;request
suffix:semicolon
)brace
id|as_update_arq
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
multiline_comment|/* keep state machine up to date */
)brace
r_else
(brace
id|as_add_aliased_request
c_func
(paren
id|ad
comma
id|arq
comma
id|alias
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * have we been anticipating this request?&n;&t;&t; * or does it come from the same process as the one we are&n;&t;&t; * anticipating for?&n;&t;&t; */
r_if
c_cond
(paren
id|ad-&gt;antic_status
op_eq
id|ANTIC_WAIT_REQ
op_logical_or
id|ad-&gt;antic_status
op_eq
id|ANTIC_WAIT_NEXT
)paren
(brace
r_if
c_cond
(paren
id|as_can_break_anticipation
c_func
(paren
id|ad
comma
id|arq
)paren
)paren
id|as_antic_stop
c_func
(paren
id|ad
)paren
suffix:semicolon
)brace
)brace
id|arq-&gt;state
op_assign
id|AS_RQ_QUEUED
suffix:semicolon
)brace
multiline_comment|/*&n; * requeue the request. The request has not been completed, nor is it a&n; * new request, so don&squot;t touch accounting.&n; */
DECL|function|as_requeue_request
r_static
r_void
id|as_requeue_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|as_rq
op_star
id|arq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arq
)paren
(brace
r_if
c_cond
(paren
id|arq-&gt;state
op_ne
id|AS_RQ_REMOVED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arq-&gt;state %d&bslash;n&quot;
comma
id|arq-&gt;state
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|arq-&gt;state
op_assign
id|AS_RQ_DISPATCHED
suffix:semicolon
r_if
c_cond
(paren
id|arq-&gt;io_context
op_logical_and
id|arq-&gt;io_context-&gt;aic
)paren
id|atomic_inc
c_func
(paren
op_amp
id|arq-&gt;io_context-&gt;aic-&gt;nr_dispatched
)paren
suffix:semicolon
)brace
r_else
id|WARN_ON
c_func
(paren
id|blk_fs_request
c_func
(paren
id|rq
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|rq-&gt;flags
op_amp
(paren
id|REQ_HARDBARRIER
op_or
id|REQ_SOFTBARRIER
)paren
)paren
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|rq-&gt;queuelist
comma
id|ad-&gt;dispatch
)paren
suffix:semicolon
multiline_comment|/* Stop anticipating - let this request get through */
id|as_antic_stop
c_func
(paren
id|ad
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|as_insert_request
id|as_insert_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
comma
r_int
id|where
)paren
(brace
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|as_rq
op_star
id|arq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arq
)paren
(brace
r_if
c_cond
(paren
id|arq-&gt;state
op_ne
id|AS_RQ_PRESCHED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arq-&gt;state: %d&bslash;n&quot;
comma
id|arq-&gt;state
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|arq-&gt;state
op_assign
id|AS_RQ_NEW
suffix:semicolon
)brace
multiline_comment|/* barriers must flush the reorder queue */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|rq-&gt;flags
op_amp
(paren
id|REQ_SOFTBARRIER
op_or
id|REQ_HARDBARRIER
)paren
op_logical_and
id|where
op_eq
id|ELEVATOR_INSERT_SORT
)paren
)paren
(brace
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|where
op_assign
id|ELEVATOR_INSERT_BACK
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|where
)paren
(brace
r_case
id|ELEVATOR_INSERT_BACK
suffix:colon
r_while
c_loop
(paren
id|ad-&gt;next_arq
(braket
id|REQ_SYNC
)braket
)paren
id|as_move_to_dispatch
c_func
(paren
id|ad
comma
id|ad-&gt;next_arq
(braket
id|REQ_SYNC
)braket
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ad-&gt;next_arq
(braket
id|REQ_ASYNC
)braket
)paren
id|as_move_to_dispatch
c_func
(paren
id|ad
comma
id|ad-&gt;next_arq
(braket
id|REQ_ASYNC
)braket
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|rq-&gt;queuelist
comma
id|ad-&gt;dispatch
)paren
suffix:semicolon
id|as_antic_stop
c_func
(paren
id|ad
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ELEVATOR_INSERT_FRONT
suffix:colon
id|list_add
c_func
(paren
op_amp
id|rq-&gt;queuelist
comma
id|ad-&gt;dispatch
)paren
suffix:semicolon
id|as_antic_stop
c_func
(paren
id|ad
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ELEVATOR_INSERT_SORT
suffix:colon
id|BUG_ON
c_func
(paren
op_logical_neg
id|blk_fs_request
c_func
(paren
id|rq
)paren
)paren
suffix:semicolon
id|as_add_request
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * as_queue_empty tells us if there are requests left in the device. It may&n; * not be the case that a driver can get the next request even if the queue&n; * is not empty - it is used in the block layer to check for plugging and&n; * merging opportunities&n; */
DECL|function|as_queue_empty
r_static
r_int
id|as_queue_empty
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ad-&gt;fifo_list
(braket
id|REQ_ASYNC
)braket
)paren
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ad-&gt;fifo_list
(braket
id|REQ_SYNC
)braket
)paren
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
id|ad-&gt;dispatch
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_struct
id|request
op_star
DECL|function|as_former_request
id|as_former_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|as_rq
op_star
id|arq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_struct
id|rb_node
op_star
id|rbprev
op_assign
id|rb_prev
c_func
(paren
op_amp
id|arq-&gt;rb_node
)paren
suffix:semicolon
r_struct
id|request
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|rbprev
)paren
id|ret
op_assign
id|rb_entry_arq
c_func
(paren
id|rbprev
)paren
op_member_access_from_pointer
id|request
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_struct
id|request
op_star
DECL|function|as_latter_request
id|as_latter_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|as_rq
op_star
id|arq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_struct
id|rb_node
op_star
id|rbnext
op_assign
id|rb_next
c_func
(paren
op_amp
id|arq-&gt;rb_node
)paren
suffix:semicolon
r_struct
id|request
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|rbnext
)paren
id|ret
op_assign
id|rb_entry_arq
c_func
(paren
id|rbnext
)paren
op_member_access_from_pointer
id|request
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|as_merge
id|as_merge
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
op_star
id|req
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
id|sector_t
id|rb_key
op_assign
id|bio-&gt;bi_sector
op_plus
id|bio_sectors
c_func
(paren
id|bio
)paren
suffix:semicolon
r_struct
id|request
op_star
id|__rq
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * try last_merge to avoid going to hash&n;&t; */
id|ret
op_assign
id|elv_try_last_merge
c_func
(paren
id|q
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|ELEVATOR_NO_MERGE
)paren
(brace
id|__rq
op_assign
id|q-&gt;last_merge
suffix:semicolon
r_goto
id|out_insert
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * see if the merge hash can satisfy a back merge&n;&t; */
id|__rq
op_assign
id|as_find_arq_hash
c_func
(paren
id|ad
comma
id|bio-&gt;bi_sector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__rq
)paren
(brace
id|BUG_ON
c_func
(paren
id|__rq-&gt;sector
op_plus
id|__rq-&gt;nr_sectors
op_ne
id|bio-&gt;bi_sector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elv_rq_merge_ok
c_func
(paren
id|__rq
comma
id|bio
)paren
)paren
(brace
id|ret
op_assign
id|ELEVATOR_BACK_MERGE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * check for front merge&n;&t; */
id|__rq
op_assign
id|as_find_arq_rb
c_func
(paren
id|ad
comma
id|rb_key
comma
id|bio_data_dir
c_func
(paren
id|bio
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__rq
)paren
(brace
id|BUG_ON
c_func
(paren
id|rb_key
op_ne
id|rq_rb_key
c_func
(paren
id|__rq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elv_rq_merge_ok
c_func
(paren
id|__rq
comma
id|bio
)paren
)paren
(brace
id|ret
op_assign
id|ELEVATOR_FRONT_MERGE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_return
id|ELEVATOR_NO_MERGE
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|rq_mergeable
c_func
(paren
id|__rq
)paren
)paren
id|q-&gt;last_merge
op_assign
id|__rq
suffix:semicolon
id|out_insert
suffix:colon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_if
c_cond
(paren
id|rq_mergeable
c_func
(paren
id|__rq
)paren
)paren
id|as_hot_arq_hash
c_func
(paren
id|ad
comma
id|RQ_DATA
c_func
(paren
id|__rq
)paren
)paren
suffix:semicolon
)brace
op_star
id|req
op_assign
id|__rq
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|as_merged_request
r_static
r_void
id|as_merged_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
)paren
(brace
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|as_rq
op_star
id|arq
op_assign
id|RQ_DATA
c_func
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * hash always needs to be repositioned, key is end sector&n;&t; */
id|as_del_arq_hash
c_func
(paren
id|arq
)paren
suffix:semicolon
id|as_add_arq_hash
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if the merge was a front merge, we need to reposition request&n;&t; */
r_if
c_cond
(paren
id|rq_rb_key
c_func
(paren
id|req
)paren
op_ne
id|arq-&gt;rb_key
)paren
(brace
r_struct
id|as_rq
op_star
id|alias
comma
op_star
id|next_arq
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;next_arq
(braket
id|arq-&gt;is_sync
)braket
op_eq
id|arq
)paren
id|next_arq
op_assign
id|as_find_next_arq
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Note! We should really be moving any old aliased requests&n;&t;&t; * off this request and try to insert them into the rbtree. We&n;&t;&t; * currently don&squot;t bother. Ditto the next function.&n;&t;&t; */
id|as_del_arq_rb
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|alias
op_assign
id|as_add_arq_rb
c_func
(paren
id|ad
comma
id|arq
)paren
)paren
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|arq-&gt;fifo
)paren
suffix:semicolon
id|as_add_aliased_request
c_func
(paren
id|ad
comma
id|arq
comma
id|alias
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next_arq
)paren
id|ad-&gt;next_arq
(braket
id|arq-&gt;is_sync
)braket
op_assign
id|next_arq
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Note! At this stage of this and the next function, our next&n;&t;&t; * request may not be optimal - eg the request may have &quot;grown&quot;&n;&t;&t; * behind the disk head. We currently don&squot;t bother adjusting.&n;&t;&t; */
)brace
r_if
c_cond
(paren
id|arq-&gt;on_hash
)paren
id|q-&gt;last_merge
op_assign
id|req
suffix:semicolon
)brace
r_static
r_void
DECL|function|as_merged_requests
id|as_merged_requests
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_struct
id|request
op_star
id|next
)paren
(brace
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|as_rq
op_star
id|arq
op_assign
id|RQ_DATA
c_func
(paren
id|req
)paren
suffix:semicolon
r_struct
id|as_rq
op_star
id|anext
op_assign
id|RQ_DATA
c_func
(paren
id|next
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|arq
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|anext
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reposition arq (this is the merged request) in hash, and in rbtree&n;&t; * in case of a front merge&n;&t; */
id|as_del_arq_hash
c_func
(paren
id|arq
)paren
suffix:semicolon
id|as_add_arq_hash
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq_rb_key
c_func
(paren
id|req
)paren
op_ne
id|arq-&gt;rb_key
)paren
(brace
r_struct
id|as_rq
op_star
id|alias
comma
op_star
id|next_arq
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;next_arq
(braket
id|arq-&gt;is_sync
)braket
op_eq
id|arq
)paren
id|next_arq
op_assign
id|as_find_next_arq
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
id|as_del_arq_rb
c_func
(paren
id|ad
comma
id|arq
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|alias
op_assign
id|as_add_arq_rb
c_func
(paren
id|ad
comma
id|arq
)paren
)paren
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|arq-&gt;fifo
)paren
suffix:semicolon
id|as_add_aliased_request
c_func
(paren
id|ad
comma
id|arq
comma
id|alias
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next_arq
)paren
id|ad-&gt;next_arq
(braket
id|arq-&gt;is_sync
)braket
op_assign
id|next_arq
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * if anext expires before arq, assign its expire time to arq&n;&t; * and move into anext position (anext will be deleted) in fifo&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|arq-&gt;fifo
)paren
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|anext-&gt;fifo
)paren
)paren
(brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|anext-&gt;expires
comma
id|arq-&gt;expires
)paren
)paren
(brace
id|list_move
c_func
(paren
op_amp
id|arq-&gt;fifo
comma
op_amp
id|anext-&gt;fifo
)paren
suffix:semicolon
id|arq-&gt;expires
op_assign
id|anext-&gt;expires
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Don&squot;t copy here but swap, because when anext is&n;&t;&t;&t; * removed below, it must contain the unused context&n;&t;&t;&t; */
id|swap_io_context
c_func
(paren
op_amp
id|arq-&gt;io_context
comma
op_amp
id|anext-&gt;io_context
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Transfer list of aliases&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|next-&gt;queuelist
)paren
)paren
(brace
r_struct
id|request
op_star
id|__rq
op_assign
id|list_entry_rq
c_func
(paren
id|next-&gt;queuelist.next
)paren
suffix:semicolon
r_struct
id|as_rq
op_star
id|__arq
op_assign
id|RQ_DATA
c_func
(paren
id|__rq
)paren
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|__rq-&gt;queuelist
comma
op_amp
id|req-&gt;queuelist
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
id|__arq-&gt;state
op_ne
id|AS_RQ_QUEUED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * kill knowledge of next, this one is a goner&n;&t; */
id|as_remove_queued_request
c_func
(paren
id|q
comma
id|next
)paren
suffix:semicolon
id|anext-&gt;state
op_assign
id|AS_RQ_MERGED
suffix:semicolon
)brace
multiline_comment|/*&n; * This is executed in a &quot;deferred&quot; process context, by kblockd. It calls the&n; * driver&squot;s request_fn so the driver can submit that request.&n; *&n; * IMPORTANT! This guy will reenter the elevator, so set up all queue global&n; * state before calling, and don&squot;t rely on any state over calls.&n; *&n; * FIXME! dispatch queue is not a queue at all!&n; */
DECL|function|as_work_handler
r_static
r_void
id|as_work_handler
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|request_queue
op_star
id|q
op_assign
id|data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|as_next_request
c_func
(paren
id|q
)paren
)paren
id|q
op_member_access_from_pointer
id|request_fn
c_func
(paren
id|q
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|as_put_request
r_static
r_void
id|as_put_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|as_rq
op_star
id|arq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arq
)paren
(brace
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arq-&gt;state
op_ne
id|AS_RQ_POSTSCHED
op_logical_and
id|arq-&gt;state
op_ne
id|AS_RQ_PRESCHED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;arq-&gt;state %d&bslash;n&quot;
comma
id|arq-&gt;state
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|mempool_free
c_func
(paren
id|arq
comma
id|ad-&gt;arq_pool
)paren
suffix:semicolon
id|rq-&gt;elevator_private
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|as_set_request
r_static
r_int
id|as_set_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|as_rq
op_star
id|arq
op_assign
id|mempool_alloc
c_func
(paren
id|ad-&gt;arq_pool
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arq
)paren
(brace
id|memset
c_func
(paren
id|arq
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|arq
)paren
)paren
suffix:semicolon
id|RB_CLEAR
c_func
(paren
op_amp
id|arq-&gt;rb_node
)paren
suffix:semicolon
id|arq-&gt;request
op_assign
id|rq
suffix:semicolon
id|arq-&gt;state
op_assign
id|AS_RQ_PRESCHED
suffix:semicolon
id|arq-&gt;io_context
op_assign
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|arq-&gt;hash
)paren
suffix:semicolon
id|arq-&gt;on_hash
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|arq-&gt;fifo
)paren
suffix:semicolon
id|rq-&gt;elevator_private
op_assign
id|arq
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|as_may_queue
r_static
r_int
id|as_may_queue
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|as_data
op_star
id|ad
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|io_context
op_star
id|ioc
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;antic_status
op_eq
id|ANTIC_WAIT_REQ
op_logical_or
id|ad-&gt;antic_status
op_eq
id|ANTIC_WAIT_NEXT
)paren
(brace
id|ioc
op_assign
id|as_get_io_context
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;io_context
op_eq
id|ioc
)paren
id|ret
op_assign
l_int|1
suffix:semicolon
id|put_io_context
c_func
(paren
id|ioc
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|as_exit
r_static
r_void
id|as_exit
c_func
(paren
id|request_queue_t
op_star
id|q
comma
id|elevator_t
op_star
id|e
)paren
(brace
r_struct
id|as_data
op_star
id|ad
op_assign
id|e-&gt;elevator_data
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|ad-&gt;antic_timer
)paren
suffix:semicolon
id|kblockd_flush
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ad-&gt;fifo_list
(braket
id|REQ_SYNC
)braket
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ad-&gt;fifo_list
(braket
id|REQ_ASYNC
)braket
)paren
)paren
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|ad-&gt;arq_pool
)paren
suffix:semicolon
id|put_io_context
c_func
(paren
id|ad-&gt;io_context
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ad-&gt;hash
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ad
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * initialize elevator private data (as_data), and alloc a arq for&n; * each request on the free lists&n; */
DECL|function|as_init
r_static
r_int
id|as_init
c_func
(paren
id|request_queue_t
op_star
id|q
comma
id|elevator_t
op_star
id|e
)paren
(brace
r_struct
id|as_data
op_star
id|ad
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arq_pool
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ad
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ad
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ad
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|ad
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ad
)paren
)paren
suffix:semicolon
id|ad-&gt;q
op_assign
id|q
suffix:semicolon
multiline_comment|/* Identify what queue the data belongs to */
id|ad-&gt;hash
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|list_head
)paren
op_star
id|AS_HASH_ENTRIES
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ad-&gt;hash
)paren
(brace
id|kfree
c_func
(paren
id|ad
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ad-&gt;arq_pool
op_assign
id|mempool_create
c_func
(paren
id|BLKDEV_MIN_RQ
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|arq_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ad-&gt;arq_pool
)paren
(brace
id|kfree
c_func
(paren
id|ad-&gt;hash
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ad
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* anticipatory scheduling helpers */
id|ad-&gt;antic_timer.function
op_assign
id|as_antic_timeout
suffix:semicolon
id|ad-&gt;antic_timer.data
op_assign
(paren
r_int
r_int
)paren
id|q
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|ad-&gt;antic_timer
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|ad-&gt;antic_work
comma
id|as_work_handler
comma
id|q
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AS_HASH_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ad-&gt;hash
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ad-&gt;fifo_list
(braket
id|REQ_SYNC
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ad-&gt;fifo_list
(braket
id|REQ_ASYNC
)braket
)paren
suffix:semicolon
id|ad-&gt;sort_list
(braket
id|REQ_SYNC
)braket
op_assign
id|RB_ROOT
suffix:semicolon
id|ad-&gt;sort_list
(braket
id|REQ_ASYNC
)braket
op_assign
id|RB_ROOT
suffix:semicolon
id|ad-&gt;dispatch
op_assign
op_amp
id|q-&gt;queue_head
suffix:semicolon
id|ad-&gt;fifo_expire
(braket
id|REQ_SYNC
)braket
op_assign
id|default_read_expire
suffix:semicolon
id|ad-&gt;fifo_expire
(braket
id|REQ_ASYNC
)braket
op_assign
id|default_write_expire
suffix:semicolon
id|ad-&gt;antic_expire
op_assign
id|default_antic_expire
suffix:semicolon
id|ad-&gt;batch_expire
(braket
id|REQ_SYNC
)braket
op_assign
id|default_read_batch_expire
suffix:semicolon
id|ad-&gt;batch_expire
(braket
id|REQ_ASYNC
)braket
op_assign
id|default_write_batch_expire
suffix:semicolon
id|e-&gt;elevator_data
op_assign
id|ad
suffix:semicolon
id|ad-&gt;current_batch_expires
op_assign
id|jiffies
op_plus
id|ad-&gt;batch_expire
(braket
id|REQ_SYNC
)braket
suffix:semicolon
id|ad-&gt;write_batch_count
op_assign
id|ad-&gt;batch_expire
(braket
id|REQ_ASYNC
)braket
op_div
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|ad-&gt;write_batch_count
OL
l_int|2
)paren
id|ad-&gt;write_batch_count
op_assign
l_int|2
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * sysfs parts below&n; */
DECL|struct|as_fs_entry
r_struct
id|as_fs_entry
(brace
DECL|member|attr
r_struct
id|attribute
id|attr
suffix:semicolon
DECL|member|show
id|ssize_t
(paren
op_star
id|show
)paren
(paren
r_struct
id|as_data
op_star
comma
r_char
op_star
)paren
suffix:semicolon
DECL|member|store
id|ssize_t
(paren
op_star
id|store
)paren
(paren
r_struct
id|as_data
op_star
comma
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
)brace
suffix:semicolon
r_static
id|ssize_t
DECL|function|as_var_show
id|as_var_show
c_func
(paren
r_int
r_int
id|var
comma
r_char
op_star
id|page
)paren
(brace
id|var
op_assign
(paren
id|var
op_star
l_int|1000
)paren
op_div
id|HZ
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|var
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|as_var_store
id|as_var_store
c_func
(paren
r_int
r_int
op_star
id|var
comma
r_const
r_char
op_star
id|page
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_char
op_star
id|p
op_assign
(paren
r_char
op_star
)paren
id|page
suffix:semicolon
id|tmp
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
l_int|0
)paren
(brace
id|tmp
op_assign
(paren
id|tmp
op_star
id|HZ
)paren
op_div
l_int|1000
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
l_int|0
)paren
id|tmp
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|var
op_assign
id|tmp
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|as_est_show
r_static
id|ssize_t
id|as_est_show
c_func
(paren
r_struct
id|as_data
op_star
id|ad
comma
r_char
op_star
id|page
)paren
(brace
r_int
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|pos
comma
l_string|&quot;%lu %% exit probability&bslash;n&quot;
comma
l_int|100
op_star
id|ad-&gt;exit_prob
op_div
l_int|256
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|pos
comma
l_string|&quot;%lu ms new thinktime&bslash;n&quot;
comma
id|ad-&gt;new_ttime_mean
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|pos
comma
l_string|&quot;%llu sectors new seek distance&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ad-&gt;new_seek_mean
)paren
suffix:semicolon
r_return
id|pos
suffix:semicolon
)brace
DECL|macro|SHOW_FUNCTION
mdefine_line|#define SHOW_FUNCTION(__FUNC, __VAR)&t;&t;&t;&t;&t;&bslash;&n;static ssize_t __FUNC(struct as_data *ad, char *page)&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return as_var_show(__VAR, (page));&t;&t;&t;&bslash;&n;}
id|SHOW_FUNCTION
c_func
(paren
id|as_readexpire_show
comma
id|ad-&gt;fifo_expire
(braket
id|REQ_SYNC
)braket
)paren
suffix:semicolon
id|SHOW_FUNCTION
c_func
(paren
id|as_writeexpire_show
comma
id|ad-&gt;fifo_expire
(braket
id|REQ_ASYNC
)braket
)paren
suffix:semicolon
id|SHOW_FUNCTION
c_func
(paren
id|as_anticexpire_show
comma
id|ad-&gt;antic_expire
)paren
suffix:semicolon
id|SHOW_FUNCTION
c_func
(paren
id|as_read_batchexpire_show
comma
id|ad-&gt;batch_expire
(braket
id|REQ_SYNC
)braket
)paren
suffix:semicolon
id|SHOW_FUNCTION
c_func
(paren
id|as_write_batchexpire_show
comma
id|ad-&gt;batch_expire
(braket
id|REQ_ASYNC
)braket
)paren
suffix:semicolon
DECL|macro|SHOW_FUNCTION
macro_line|#undef SHOW_FUNCTION
DECL|macro|STORE_FUNCTION
mdefine_line|#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX)&t;&t;&t;&t;&bslash;&n;static ssize_t __FUNC(struct as_data *ad, const char *page, size_t count)&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int ret = as_var_store(__PTR, (page), count);&t;&t;&bslash;&n;&t;if (*(__PTR) &lt; (MIN))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;*(__PTR) = (MIN);&t;&t;&t;&t;&t;&bslash;&n;&t;else if (*(__PTR) &gt; (MAX))&t;&t;&t;&t;&t;&bslash;&n;&t;&t;*(__PTR) = (MAX);&t;&t;&t;&t;&t;&bslash;&n;&t;return ret;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
id|STORE_FUNCTION
c_func
(paren
id|as_readexpire_store
comma
op_amp
id|ad-&gt;fifo_expire
(braket
id|REQ_SYNC
)braket
comma
l_int|0
comma
id|INT_MAX
)paren
suffix:semicolon
id|STORE_FUNCTION
c_func
(paren
id|as_writeexpire_store
comma
op_amp
id|ad-&gt;fifo_expire
(braket
id|REQ_ASYNC
)braket
comma
l_int|0
comma
id|INT_MAX
)paren
suffix:semicolon
id|STORE_FUNCTION
c_func
(paren
id|as_anticexpire_store
comma
op_amp
id|ad-&gt;antic_expire
comma
l_int|0
comma
id|INT_MAX
)paren
suffix:semicolon
id|STORE_FUNCTION
c_func
(paren
id|as_read_batchexpire_store
comma
op_amp
id|ad-&gt;batch_expire
(braket
id|REQ_SYNC
)braket
comma
l_int|0
comma
id|INT_MAX
)paren
suffix:semicolon
id|STORE_FUNCTION
c_func
(paren
id|as_write_batchexpire_store
comma
op_amp
id|ad-&gt;batch_expire
(braket
id|REQ_ASYNC
)braket
comma
l_int|0
comma
id|INT_MAX
)paren
suffix:semicolon
DECL|macro|STORE_FUNCTION
macro_line|#undef STORE_FUNCTION
DECL|variable|as_est_entry
r_static
r_struct
id|as_fs_entry
id|as_est_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;est_time&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
)brace
comma
dot
id|show
op_assign
id|as_est_show
comma
)brace
suffix:semicolon
DECL|variable|as_readexpire_entry
r_static
r_struct
id|as_fs_entry
id|as_readexpire_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;read_expire&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|as_readexpire_show
comma
dot
id|store
op_assign
id|as_readexpire_store
comma
)brace
suffix:semicolon
DECL|variable|as_writeexpire_entry
r_static
r_struct
id|as_fs_entry
id|as_writeexpire_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;write_expire&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|as_writeexpire_show
comma
dot
id|store
op_assign
id|as_writeexpire_store
comma
)brace
suffix:semicolon
DECL|variable|as_anticexpire_entry
r_static
r_struct
id|as_fs_entry
id|as_anticexpire_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;antic_expire&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|as_anticexpire_show
comma
dot
id|store
op_assign
id|as_anticexpire_store
comma
)brace
suffix:semicolon
DECL|variable|as_read_batchexpire_entry
r_static
r_struct
id|as_fs_entry
id|as_read_batchexpire_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;read_batch_expire&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|as_read_batchexpire_show
comma
dot
id|store
op_assign
id|as_read_batchexpire_store
comma
)brace
suffix:semicolon
DECL|variable|as_write_batchexpire_entry
r_static
r_struct
id|as_fs_entry
id|as_write_batchexpire_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;write_batch_expire&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|as_write_batchexpire_show
comma
dot
id|store
op_assign
id|as_write_batchexpire_store
comma
)brace
suffix:semicolon
DECL|variable|default_attrs
r_static
r_struct
id|attribute
op_star
id|default_attrs
(braket
)braket
op_assign
(brace
op_amp
id|as_est_entry.attr
comma
op_amp
id|as_readexpire_entry.attr
comma
op_amp
id|as_writeexpire_entry.attr
comma
op_amp
id|as_anticexpire_entry.attr
comma
op_amp
id|as_read_batchexpire_entry.attr
comma
op_amp
id|as_write_batchexpire_entry.attr
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|macro|to_as
mdefine_line|#define to_as(atr) container_of((atr), struct as_fs_entry, attr)
r_static
id|ssize_t
DECL|function|as_attr_show
id|as_attr_show
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
comma
r_struct
id|attribute
op_star
id|attr
comma
r_char
op_star
id|page
)paren
(brace
id|elevator_t
op_star
id|e
op_assign
id|container_of
c_func
(paren
id|kobj
comma
id|elevator_t
comma
id|kobj
)paren
suffix:semicolon
r_struct
id|as_fs_entry
op_star
id|entry
op_assign
id|to_as
c_func
(paren
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;show
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|entry
op_member_access_from_pointer
id|show
c_func
(paren
id|e-&gt;elevator_data
comma
id|page
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|as_attr_store
id|as_attr_store
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
comma
r_struct
id|attribute
op_star
id|attr
comma
r_const
r_char
op_star
id|page
comma
r_int
id|length
)paren
(brace
id|elevator_t
op_star
id|e
op_assign
id|container_of
c_func
(paren
id|kobj
comma
id|elevator_t
comma
id|kobj
)paren
suffix:semicolon
r_struct
id|as_fs_entry
op_star
id|entry
op_assign
id|to_as
c_func
(paren
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;store
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|entry
op_member_access_from_pointer
id|store
c_func
(paren
id|e-&gt;elevator_data
comma
id|page
comma
id|length
)paren
suffix:semicolon
)brace
DECL|variable|as_sysfs_ops
r_static
r_struct
id|sysfs_ops
id|as_sysfs_ops
op_assign
(brace
dot
id|show
op_assign
id|as_attr_show
comma
dot
id|store
op_assign
id|as_attr_store
comma
)brace
suffix:semicolon
DECL|variable|as_ktype
r_static
r_struct
id|kobj_type
id|as_ktype
op_assign
(brace
dot
id|sysfs_ops
op_assign
op_amp
id|as_sysfs_ops
comma
dot
id|default_attrs
op_assign
id|default_attrs
comma
)brace
suffix:semicolon
DECL|function|as_slab_setup
r_static
r_int
id|__init
id|as_slab_setup
c_func
(paren
r_void
)paren
(brace
id|arq_pool
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;as_arq&quot;
comma
r_sizeof
(paren
r_struct
id|as_rq
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arq_pool
)paren
id|panic
c_func
(paren
l_string|&quot;as: can&squot;t init slab pool&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|as_slab_setup
id|subsys_initcall
c_func
(paren
id|as_slab_setup
)paren
suffix:semicolon
DECL|variable|iosched_as
id|elevator_t
id|iosched_as
op_assign
(brace
dot
id|elevator_merge_fn
op_assign
id|as_merge
comma
dot
id|elevator_merged_fn
op_assign
id|as_merged_request
comma
dot
id|elevator_merge_req_fn
op_assign
id|as_merged_requests
comma
dot
id|elevator_next_req_fn
op_assign
id|as_next_request
comma
dot
id|elevator_add_req_fn
op_assign
id|as_insert_request
comma
dot
id|elevator_remove_req_fn
op_assign
id|as_remove_request
comma
dot
id|elevator_requeue_req_fn
op_assign
id|as_requeue_request
comma
dot
id|elevator_queue_empty_fn
op_assign
id|as_queue_empty
comma
dot
id|elevator_completed_req_fn
op_assign
id|as_completed_request
comma
dot
id|elevator_former_req_fn
op_assign
id|as_former_request
comma
dot
id|elevator_latter_req_fn
op_assign
id|as_latter_request
comma
dot
id|elevator_set_req_fn
op_assign
id|as_set_request
comma
dot
id|elevator_put_req_fn
op_assign
id|as_put_request
comma
dot
id|elevator_may_queue_fn
op_assign
id|as_may_queue
comma
dot
id|elevator_init_fn
op_assign
id|as_init
comma
dot
id|elevator_exit_fn
op_assign
id|as_exit
comma
dot
id|elevator_ktype
op_assign
op_amp
id|as_ktype
comma
dot
id|elevator_name
op_assign
l_string|&quot;anticipatory&quot;
comma
)brace
suffix:semicolon
DECL|variable|iosched_as
id|EXPORT_SYMBOL
c_func
(paren
id|iosched_as
)paren
suffix:semicolon
eof
