multiline_comment|/*&n; *    Disk Array driver for Compaq SMART2 Controllers&n; *    Copyright 1998 Compaq Computer Corporation&n; *&n; *    This program is free software; you can redistribute it and/or modify&n; *    it under the terms of the GNU General Public License as published by&n; *    the Free Software Foundation; either version 2 of the License, or&n; *    (at your option) any later version.&n; *&n; *    This program is distributed in the hope that it will be useful,&n; *    but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or&n; *    NON INFRINGEMENT.  See the GNU General Public License for more details.&n; *&n; *    You should have received a copy of the GNU General Public License&n; *    along with this program; if not, write to the Free Software&n; *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *    Questions/Comments/Bugfixes to Cpqarray-discuss@lists.sourceforge.net&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;&t;/* CONFIG_PROC_FS */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|macro|SMART2_DRIVER_VERSION
mdefine_line|#define SMART2_DRIVER_VERSION(maj,min,submin) ((maj&lt;&lt;16)|(min&lt;&lt;8)|(submin))
DECL|macro|DRIVER_NAME
mdefine_line|#define DRIVER_NAME &quot;Compaq SMART2 Driver (v 2.6.0)&quot;
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION SMART2_DRIVER_VERSION(2,6,0)
multiline_comment|/* Embedded module documentation macros - see modules.h */
multiline_comment|/* Original author Chris Frantz - Compaq Computer Corporation */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Compaq Computer Corporation&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Driver for Compaq Smart2 Array Controllers version 2.6.0&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
macro_line|#include &quot;cpqarray.h&quot;
macro_line|#include &quot;ida_cmd.h&quot;
macro_line|#include &quot;smart1,2.h&quot;
macro_line|#include &quot;ida_ioctl.h&quot;
DECL|macro|READ_AHEAD
mdefine_line|#define READ_AHEAD&t;128
DECL|macro|NR_CMDS
mdefine_line|#define NR_CMDS&t;&t;128 /* This could probably go as high as ~400 */
DECL|macro|MAX_CTLR
mdefine_line|#define MAX_CTLR&t;8
DECL|macro|CTLR_SHIFT
mdefine_line|#define CTLR_SHIFT&t;8
DECL|macro|CPQARRAY_DMA_MASK
mdefine_line|#define CPQARRAY_DMA_MASK&t;0xFFFFFFFF&t;/* 32 bit DMA */
DECL|variable|nr_ctlr
r_static
r_int
id|nr_ctlr
suffix:semicolon
DECL|variable|hba
r_static
id|ctlr_info_t
op_star
id|hba
(braket
id|MAX_CTLR
)braket
suffix:semicolon
DECL|variable|eisa
r_static
r_int
id|eisa
(braket
l_int|8
)braket
suffix:semicolon
DECL|macro|NR_PRODUCTS
mdefine_line|#define NR_PRODUCTS (sizeof(products)/sizeof(struct board_type))
multiline_comment|/*  board_id = Subsystem Device ID &amp; Vendor ID&n; *  product = Marketing Name for the board&n; *  access = Address of the struct of function pointers &n; */
DECL|variable|products
r_static
r_struct
id|board_type
id|products
(braket
)braket
op_assign
(brace
(brace
l_int|0x0040110E
comma
l_string|&quot;IDA&quot;
comma
op_amp
id|smart1_access
)brace
comma
(brace
l_int|0x0140110E
comma
l_string|&quot;IDA-2&quot;
comma
op_amp
id|smart1_access
)brace
comma
(brace
l_int|0x1040110E
comma
l_string|&quot;IAES&quot;
comma
op_amp
id|smart1_access
)brace
comma
(brace
l_int|0x2040110E
comma
l_string|&quot;SMART&quot;
comma
op_amp
id|smart1_access
)brace
comma
(brace
l_int|0x3040110E
comma
l_string|&quot;SMART-2/E&quot;
comma
op_amp
id|smart2e_access
)brace
comma
(brace
l_int|0x40300E11
comma
l_string|&quot;SMART-2/P&quot;
comma
op_amp
id|smart2_access
)brace
comma
(brace
l_int|0x40310E11
comma
l_string|&quot;SMART-2SL&quot;
comma
op_amp
id|smart2_access
)brace
comma
(brace
l_int|0x40320E11
comma
l_string|&quot;Smart Array 3200&quot;
comma
op_amp
id|smart2_access
)brace
comma
(brace
l_int|0x40330E11
comma
l_string|&quot;Smart Array 3100ES&quot;
comma
op_amp
id|smart2_access
)brace
comma
(brace
l_int|0x40340E11
comma
l_string|&quot;Smart Array 221&quot;
comma
op_amp
id|smart2_access
)brace
comma
(brace
l_int|0x40400E11
comma
l_string|&quot;Integrated Array&quot;
comma
op_amp
id|smart4_access
)brace
comma
(brace
l_int|0x40480E11
comma
l_string|&quot;Compaq Raid LC2&quot;
comma
op_amp
id|smart4_access
)brace
comma
(brace
l_int|0x40500E11
comma
l_string|&quot;Smart Array 4200&quot;
comma
op_amp
id|smart4_access
)brace
comma
(brace
l_int|0x40510E11
comma
l_string|&quot;Smart Array 4250ES&quot;
comma
op_amp
id|smart4_access
)brace
comma
(brace
l_int|0x40580E11
comma
l_string|&quot;Smart Array 431&quot;
comma
op_amp
id|smart4_access
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* define the PCI info for the PCI cards this driver can control */
DECL|variable|cpqarray_pci_device_id
r_const
r_struct
id|pci_device_id
id|cpqarray_pci_device_id
(braket
)braket
op_assign
(brace
(brace
id|PCI_VENDOR_ID_DEC
comma
id|PCI_DEVICE_ID_COMPAQ_42XX
comma
l_int|0x0E11
comma
l_int|0x4058
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* SA431 */
(brace
id|PCI_VENDOR_ID_DEC
comma
id|PCI_DEVICE_ID_COMPAQ_42XX
comma
l_int|0x0E11
comma
l_int|0x4051
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* SA4250ES */
(brace
id|PCI_VENDOR_ID_DEC
comma
id|PCI_DEVICE_ID_COMPAQ_42XX
comma
l_int|0x0E11
comma
l_int|0x4050
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* SA4200 */
(brace
id|PCI_VENDOR_ID_NCR
comma
id|PCI_DEVICE_ID_NCR_53C1510
comma
l_int|0x0E11
comma
l_int|0x4048
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* LC2 */
(brace
id|PCI_VENDOR_ID_NCR
comma
id|PCI_DEVICE_ID_NCR_53C1510
comma
l_int|0x0E11
comma
l_int|0x4040
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* Integrated Array */
(brace
id|PCI_VENDOR_ID_COMPAQ
comma
id|PCI_DEVICE_ID_COMPAQ_SMART2P
comma
l_int|0x0E11
comma
l_int|0x4034
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* SA 221 */
(brace
id|PCI_VENDOR_ID_COMPAQ
comma
id|PCI_DEVICE_ID_COMPAQ_SMART2P
comma
l_int|0x0E11
comma
l_int|0x4033
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* SA 3100ES*/
(brace
id|PCI_VENDOR_ID_COMPAQ
comma
id|PCI_DEVICE_ID_COMPAQ_SMART2P
comma
l_int|0x0E11
comma
l_int|0x4032
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* SA 3200*/
(brace
id|PCI_VENDOR_ID_COMPAQ
comma
id|PCI_DEVICE_ID_COMPAQ_SMART2P
comma
l_int|0x0E11
comma
l_int|0x4031
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* SA 2SL*/
(brace
id|PCI_VENDOR_ID_COMPAQ
comma
id|PCI_DEVICE_ID_COMPAQ_SMART2P
comma
l_int|0x0E11
comma
l_int|0x4030
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* SA 2P */
(brace
l_int|0
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|cpqarray_pci_device_id
)paren
suffix:semicolon
DECL|variable|ida_gendisk
r_static
r_struct
id|gendisk
op_star
id|ida_gendisk
(braket
id|MAX_CTLR
)braket
(braket
id|NWD
)braket
suffix:semicolon
multiline_comment|/* Debug... */
DECL|macro|DBG
mdefine_line|#define DBG(s)&t;do { s } while(0)
multiline_comment|/* Debug (general info)... */
DECL|macro|DBGINFO
mdefine_line|#define DBGINFO(s) do { } while(0)
multiline_comment|/* Debug Paranoid... */
DECL|macro|DBGP
mdefine_line|#define DBGP(s)  do { } while(0)
multiline_comment|/* Debug Extra Paranoid... */
DECL|macro|DBGPX
mdefine_line|#define DBGPX(s) do { } while(0)
r_int
id|cpqarray_init_step2
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|cpqarray_pci_init
c_func
(paren
id|ctlr_info_t
op_star
id|c
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
suffix:semicolon
r_static
r_void
op_star
id|remap_pci_mem
c_func
(paren
id|ulong
id|base
comma
id|ulong
id|size
)paren
suffix:semicolon
r_static
r_int
id|cpqarray_eisa_detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|pollcomplete
c_func
(paren
r_int
id|ctlr
)paren
suffix:semicolon
r_static
r_void
id|getgeometry
c_func
(paren
r_int
id|ctlr
)paren
suffix:semicolon
r_static
r_void
id|start_fwbk
c_func
(paren
r_int
id|ctlr
)paren
suffix:semicolon
r_static
id|cmdlist_t
op_star
id|cmd_alloc
c_func
(paren
id|ctlr_info_t
op_star
id|h
comma
r_int
id|get_from_pool
)paren
suffix:semicolon
r_static
r_void
id|cmd_free
c_func
(paren
id|ctlr_info_t
op_star
id|h
comma
id|cmdlist_t
op_star
id|c
comma
r_int
id|got_from_pool
)paren
suffix:semicolon
r_static
r_void
id|free_hba
c_func
(paren
r_int
id|i
)paren
suffix:semicolon
r_static
r_int
id|alloc_cpqarray_hba
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|sendcmd
c_func
(paren
id|__u8
id|cmd
comma
r_int
id|ctlr
comma
r_void
op_star
id|buff
comma
r_int
id|size
comma
r_int
r_int
id|blk
comma
r_int
r_int
id|blkcnt
comma
r_int
r_int
id|log_unit
)paren
suffix:semicolon
r_static
r_int
id|ida_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
suffix:semicolon
r_static
r_int
id|ida_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
suffix:semicolon
r_static
r_int
id|ida_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|ida_ctlr_ioctl
c_func
(paren
id|ctlr_info_t
op_star
id|h
comma
r_int
id|dsk
comma
id|ida_ioctl_t
op_star
id|io
)paren
suffix:semicolon
r_static
r_void
id|do_ida_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
suffix:semicolon
r_static
r_void
id|start_io
c_func
(paren
id|ctlr_info_t
op_star
id|h
)paren
suffix:semicolon
r_static
r_inline
r_void
id|addQ
c_func
(paren
id|cmdlist_t
op_star
op_star
id|Qptr
comma
id|cmdlist_t
op_star
id|c
)paren
suffix:semicolon
r_static
r_inline
id|cmdlist_t
op_star
id|removeQ
c_func
(paren
id|cmdlist_t
op_star
op_star
id|Qptr
comma
id|cmdlist_t
op_star
id|c
)paren
suffix:semicolon
r_static
r_inline
r_void
id|complete_buffers
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
id|ok
)paren
suffix:semicolon
r_static
r_inline
r_void
id|complete_command
c_func
(paren
id|cmdlist_t
op_star
id|cmd
comma
r_int
id|timeout
)paren
suffix:semicolon
r_static
id|irqreturn_t
id|do_ida_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|ida_timer
c_func
(paren
r_int
r_int
id|tdata
)paren
suffix:semicolon
r_static
r_int
id|ida_revalidate
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
suffix:semicolon
r_static
r_int
id|revalidate_allvol
c_func
(paren
id|ctlr_info_t
op_star
id|host
)paren
suffix:semicolon
r_static
r_int
id|cpqarray_register_ctlr
c_func
(paren
r_int
id|ctlr
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_void
id|ida_procinit
c_func
(paren
r_int
id|i
)paren
suffix:semicolon
r_static
r_int
id|ida_proc_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
macro_line|#else
DECL|function|ida_procinit
r_static
r_void
id|ida_procinit
c_func
(paren
r_int
id|i
)paren
(brace
)brace
macro_line|#endif
DECL|function|get_drv
r_static
r_inline
id|drv_info_t
op_star
id|get_drv
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_return
id|disk-&gt;private_data
suffix:semicolon
)brace
DECL|function|get_host
r_static
r_inline
id|ctlr_info_t
op_star
id|get_host
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_return
id|disk-&gt;queue-&gt;queuedata
suffix:semicolon
)brace
DECL|variable|ida_fops
r_static
r_struct
id|block_device_operations
id|ida_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|ida_open
comma
dot
id|release
op_assign
id|ida_release
comma
dot
id|ioctl
op_assign
id|ida_ioctl
comma
dot
id|revalidate_disk
op_assign
id|ida_revalidate
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|variable|proc_array
r_static
r_struct
id|proc_dir_entry
op_star
id|proc_array
suffix:semicolon
multiline_comment|/*&n; * Get us a file in /proc/array that says something about each controller.&n; * Create /proc/array if it doesn&squot;t exist yet.&n; */
DECL|function|ida_procinit
r_static
r_void
id|__init
id|ida_procinit
c_func
(paren
r_int
id|i
)paren
(brace
r_if
c_cond
(paren
id|proc_array
op_eq
l_int|NULL
)paren
(brace
id|proc_array
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;cpqarray&quot;
comma
id|proc_root_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc_array
)paren
r_return
suffix:semicolon
)brace
id|create_proc_read_entry
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
comma
l_int|0
comma
id|proc_array
comma
id|ida_proc_get_info
comma
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Report information about this controller.&n; */
DECL|function|ida_proc_get_info
r_static
r_int
id|ida_proc_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|size
comma
id|i
comma
id|ctlr
suffix:semicolon
id|ctlr_info_t
op_star
id|h
op_assign
(paren
id|ctlr_info_t
op_star
)paren
id|data
suffix:semicolon
id|drv_info_t
op_star
id|drv
suffix:semicolon
macro_line|#ifdef CPQ_PROC_PRINT_QUEUES
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#endif
id|ctlr
op_assign
id|h-&gt;ctlr
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%s:  Compaq %s Controller&bslash;n&quot;
l_string|&quot;       Board ID: 0x%08lx&bslash;n&quot;
l_string|&quot;       Firmware Revision: %c%c%c%c&bslash;n&quot;
l_string|&quot;       Controller Sig: 0x%08lx&bslash;n&quot;
l_string|&quot;       Memory Address: 0x%08lx&bslash;n&quot;
l_string|&quot;       I/O Port: 0x%04x&bslash;n&quot;
l_string|&quot;       IRQ: %d&bslash;n&quot;
l_string|&quot;       Logical drives: %d&bslash;n&quot;
l_string|&quot;       Physical drives: %d&bslash;n&bslash;n&quot;
l_string|&quot;       Current Q depth: %d&bslash;n&quot;
l_string|&quot;       Max Q depth since init: %d&bslash;n&bslash;n&quot;
comma
id|h-&gt;devname
comma
id|h-&gt;product_name
comma
(paren
r_int
r_int
)paren
id|h-&gt;board_id
comma
id|h-&gt;firm_rev
(braket
l_int|0
)braket
comma
id|h-&gt;firm_rev
(braket
l_int|1
)braket
comma
id|h-&gt;firm_rev
(braket
l_int|2
)braket
comma
id|h-&gt;firm_rev
(braket
l_int|3
)braket
comma
(paren
r_int
r_int
)paren
id|h-&gt;ctlr_sig
comma
(paren
r_int
r_int
)paren
id|h-&gt;vaddr
comma
(paren
r_int
r_int
)paren
id|h-&gt;io_mem_addr
comma
(paren
r_int
r_int
)paren
id|h-&gt;intr
comma
id|h-&gt;log_drives
comma
id|h-&gt;phys_drives
comma
id|h-&gt;Qdepth
comma
id|h-&gt;maxQsinceinit
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Logical Drive Info:&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|h-&gt;log_drives
suffix:semicolon
id|i
op_increment
)paren
(brace
id|drv
op_assign
op_amp
id|h-&gt;drv
(braket
id|i
)braket
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;ida/c%dd%d: blksz=%d nr_blks=%d&bslash;n&quot;
comma
id|ctlr
comma
id|i
comma
id|drv-&gt;blk_size
comma
id|drv-&gt;nr_blks
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
)brace
macro_line|#ifdef CPQ_PROC_PRINT_QUEUES
id|spin_lock_irqsave
c_func
(paren
id|IDA_LOCK
c_func
(paren
id|h-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;nCurrent Queues:&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|c
op_assign
id|h-&gt;reqQ
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;reqQ = %p&quot;
comma
id|c
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
id|c
op_assign
id|c-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|c
op_logical_and
id|c
op_ne
id|h-&gt;reqQ
)paren
(brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;-&gt;%p&quot;
comma
id|c
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|c
op_assign
id|c-&gt;next
suffix:semicolon
)brace
id|c
op_assign
id|h-&gt;cmpQ
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;ncmpQ = %p&quot;
comma
id|c
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
id|c
op_assign
id|c-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|c
op_logical_and
id|c
op_ne
id|h-&gt;cmpQ
)paren
(brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;-&gt;%p&quot;
comma
id|c
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|c
op_assign
id|c-&gt;next
suffix:semicolon
)brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|IDA_LOCK
c_func
(paren
id|h-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;nr_allocs = %d&bslash;nnr_frees = %d&bslash;n&quot;
comma
id|h-&gt;nr_allocs
comma
id|h-&gt;nr_frees
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
id|MODULE_PARM
c_func
(paren
id|eisa
comma
l_string|&quot;1-8i&quot;
)paren
suffix:semicolon
multiline_comment|/* This is a bit of a hack,&n; * necessary to support both eisa and pci&n; */
DECL|function|cpqarray_init
r_int
id|__init
id|cpqarray_init
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|cpqarray_init_step2
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|release_io_mem
r_static
r_void
id|release_io_mem
c_func
(paren
id|ctlr_info_t
op_star
id|c
)paren
(brace
multiline_comment|/* if IO mem was not protected do nothing */
r_if
c_cond
(paren
id|c-&gt;io_mem_addr
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|release_region
c_func
(paren
id|c-&gt;io_mem_addr
comma
id|c-&gt;io_mem_length
)paren
suffix:semicolon
id|c-&gt;io_mem_addr
op_assign
l_int|0
suffix:semicolon
id|c-&gt;io_mem_length
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|cpqarray_remove_one
r_static
r_void
id|__devexit
id|cpqarray_remove_one
c_func
(paren
r_int
id|i
)paren
(brace
r_int
id|j
suffix:semicolon
r_char
id|buff
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* sendcmd will turn off interrupt, and send the flush...&n;&t; * To write all data in the battery backed cache to disks&n;&t; * no data returned, but don&squot;t want to send NULL to sendcmd */
r_if
c_cond
(paren
id|sendcmd
c_func
(paren
id|FLUSH_CACHE
comma
id|i
comma
id|buff
comma
l_int|4
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Unable to flush cache on controller %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|intr
comma
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|vaddr
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|COMPAQ_SMART2_MAJOR
op_plus
id|i
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|timer
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
comma
id|proc_array
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|pci_dev
comma
id|NR_CMDS
op_star
r_sizeof
(paren
id|cmdlist_t
)paren
comma
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
)paren
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_dhandle
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NWD
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ida_gendisk
(braket
id|i
)braket
(braket
id|j
)braket
op_member_access_from_pointer
id|flags
op_amp
id|GENHD_FL_UP
)paren
id|del_gendisk
c_func
(paren
id|ida_gendisk
(braket
id|i
)braket
(braket
id|j
)braket
)paren
suffix:semicolon
id|devfs_remove
c_func
(paren
l_string|&quot;ida/c%dd%d&quot;
comma
id|i
comma
id|j
)paren
suffix:semicolon
id|put_disk
c_func
(paren
id|ida_gendisk
(braket
id|i
)braket
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|queue
)paren
suffix:semicolon
id|release_io_mem
c_func
(paren
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
id|free_hba
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
DECL|function|cpqarray_remove_one_pci
r_static
r_void
id|__devexit
id|cpqarray_remove_one_pci
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_int
id|i
suffix:semicolon
id|ctlr_info_t
op_star
id|tmp_ptr
suffix:semicolon
r_if
c_cond
(paren
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: Unable to remove device &bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tmp_ptr
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|i
op_assign
id|tmp_ptr-&gt;ctlr
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: controller %d appears to have&quot;
l_string|&quot;already been removed &bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
l_int|NULL
)paren
suffix:semicolon
id|cpqarray_remove_one
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* removing an instance that was not removed automatically..&n; * must be an eisa card.&n; */
DECL|function|cpqarray_remove_one_eisa
r_static
r_void
id|__devexit
id|cpqarray_remove_one_eisa
(paren
r_int
id|i
)paren
(brace
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: controller %d appears to have&quot;
l_string|&quot;already been removed &bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cpqarray_remove_one
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* pdev is NULL for eisa */
DECL|function|cpqarray_register_ctlr
r_static
r_int
id|cpqarray_register_ctlr
c_func
(paren
r_int
id|i
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
id|request_queue_t
op_star
id|q
suffix:semicolon
r_int
id|j
suffix:semicolon
multiline_comment|/* &n;&t; * register block devices&n;&t; * Find disks and fill in structs&n;&t; * Get an interrupt, set the Q depth and get into /proc&n;&t; */
multiline_comment|/* If this successful it should insure that we are the only */
multiline_comment|/* instance of the driver */
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|COMPAQ_SMART2_MAJOR
op_plus
id|i
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
)paren
(brace
r_goto
id|Enomem4
suffix:semicolon
)brace
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|access
dot
id|set_intr_mask
c_func
(paren
id|hba
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|intr
comma
id|do_ida_intr
comma
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
op_or
id|SA_SAMPLE_RANDOM
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
comma
id|hba
(braket
id|i
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: Unable to get irq %d for %s&bslash;n&quot;
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|intr
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
r_goto
id|Enomem3
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NWD
suffix:semicolon
id|j
op_increment
)paren
(brace
id|ida_gendisk
(braket
id|i
)braket
(braket
id|j
)braket
op_assign
id|alloc_disk
c_func
(paren
l_int|1
op_lshift
id|NWD_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ida_gendisk
(braket
id|i
)braket
(braket
id|j
)braket
)paren
r_goto
id|Enomem2
suffix:semicolon
)brace
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
op_assign
(paren
id|cmdlist_t
op_star
)paren
id|pci_alloc_consistent
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|pci_dev
comma
id|NR_CMDS
op_star
r_sizeof
(paren
id|cmdlist_t
)paren
comma
op_amp
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_dhandle
)paren
)paren
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
op_assign
id|kmalloc
c_func
(paren
(paren
(paren
id|NR_CMDS
op_plus
id|BITS_PER_LONG
op_minus
l_int|1
)paren
op_div
id|BITS_PER_LONG
)paren
op_star
r_sizeof
(paren
r_int
r_int
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
op_logical_or
op_logical_neg
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
)paren
r_goto
id|Enomem1
suffix:semicolon
id|memset
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
comma
l_int|0
comma
id|NR_CMDS
op_star
r_sizeof
(paren
id|cmdlist_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
comma
l_int|0
comma
(paren
(paren
id|NR_CMDS
op_plus
id|BITS_PER_LONG
op_minus
l_int|1
)paren
op_div
id|BITS_PER_LONG
)paren
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cpqarray: Finding drives on %s&quot;
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|lock
)paren
suffix:semicolon
id|q
op_assign
id|blk_init_queue
c_func
(paren
id|do_ida_request
comma
op_amp
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_goto
id|Enomem1
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|queue
op_assign
id|q
suffix:semicolon
id|q-&gt;queuedata
op_assign
id|hba
(braket
id|i
)braket
suffix:semicolon
id|getgeometry
c_func
(paren
id|i
)paren
suffix:semicolon
id|start_fwbk
c_func
(paren
id|i
)paren
suffix:semicolon
id|ida_procinit
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdev
)paren
id|blk_queue_bounce_limit
c_func
(paren
id|q
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|pci_dev-&gt;dma_mask
)paren
suffix:semicolon
multiline_comment|/* This is a hardware imposed limit. */
id|blk_queue_max_hw_segments
c_func
(paren
id|q
comma
id|SG_MAX
)paren
suffix:semicolon
multiline_comment|/* This is a driver limit and could be eliminated. */
id|blk_queue_max_phys_segments
c_func
(paren
id|q
comma
id|SG_MAX
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|timer
)paren
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|timer.expires
op_assign
id|jiffies
op_plus
id|IDA_TIMER
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|timer.data
op_assign
(paren
r_int
r_int
)paren
id|hba
(braket
id|i
)braket
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|timer.function
op_assign
id|ida_timer
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|timer
)paren
suffix:semicolon
multiline_comment|/* Enable IRQ now that spinlock and rate limit timer are set up */
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|access
dot
id|set_intr_mask
c_func
(paren
id|hba
(braket
id|i
)braket
comma
id|FIFO_NOT_EMPTY
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NWD
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|ida_gendisk
(braket
id|i
)braket
(braket
id|j
)braket
suffix:semicolon
id|drv_info_t
op_star
id|drv
op_assign
op_amp
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|drv
(braket
id|j
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|disk-&gt;disk_name
comma
l_string|&quot;ida/c%dd%d&quot;
comma
id|i
comma
id|j
)paren
suffix:semicolon
id|disk-&gt;major
op_assign
id|COMPAQ_SMART2_MAJOR
op_plus
id|i
suffix:semicolon
id|disk-&gt;first_minor
op_assign
id|j
op_lshift
id|NWD_SHIFT
suffix:semicolon
id|disk-&gt;fops
op_assign
op_amp
id|ida_fops
suffix:semicolon
r_if
c_cond
(paren
id|j
op_logical_and
op_logical_neg
id|drv-&gt;nr_blks
)paren
r_continue
suffix:semicolon
id|blk_queue_hardsect_size
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|queue
comma
id|drv-&gt;blk_size
)paren
suffix:semicolon
id|set_capacity
c_func
(paren
id|disk
comma
id|drv-&gt;nr_blks
)paren
suffix:semicolon
id|disk-&gt;queue
op_assign
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|queue
suffix:semicolon
id|disk-&gt;private_data
op_assign
id|drv
suffix:semicolon
id|add_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
)brace
multiline_comment|/* done ! */
r_return
id|i
suffix:semicolon
id|Enomem1
suffix:colon
id|nr_ctlr
op_assign
id|i
suffix:semicolon
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
)paren
id|pci_free_consistent
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|pci_dev
comma
id|NR_CMDS
op_star
r_sizeof
(paren
id|cmdlist_t
)paren
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_dhandle
)paren
suffix:semicolon
id|Enomem2
suffix:colon
r_while
c_loop
(paren
id|j
op_decrement
)paren
(brace
id|put_disk
c_func
(paren
id|ida_gendisk
(braket
id|i
)braket
(braket
id|j
)braket
)paren
suffix:semicolon
id|ida_gendisk
(braket
id|i
)braket
(braket
id|j
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|intr
comma
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
id|Enomem3
suffix:colon
id|unregister_blkdev
c_func
(paren
id|COMPAQ_SMART2_MAJOR
op_plus
id|i
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
id|Enomem4
suffix:colon
r_if
c_cond
(paren
id|pdev
)paren
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
l_int|NULL
)paren
suffix:semicolon
id|release_io_mem
c_func
(paren
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
id|free_hba
c_func
(paren
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: out of memory&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|cpqarray_init_one
r_static
r_int
id|__init
id|cpqarray_init_one
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|ent
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cpqarray: Device 0x%x has been found at&quot;
l_string|&quot; bus %d dev %d func %d&bslash;n&quot;
comma
id|pdev-&gt;device
comma
id|pdev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|pdev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|pdev-&gt;devfn
)paren
)paren
suffix:semicolon
id|i
op_assign
id|alloc_cpqarray_hba
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|hba
(braket
id|i
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|ctlr_info_t
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
comma
l_string|&quot;ida%d&quot;
comma
id|i
)paren
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|ctlr
op_assign
id|i
suffix:semicolon
multiline_comment|/* Initialize the pdev driver private data */
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpqarray_pci_init
c_func
(paren
id|hba
(braket
id|i
)braket
comma
id|pdev
)paren
op_ne
l_int|0
)paren
(brace
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
l_int|NULL
)paren
suffix:semicolon
id|release_io_mem
c_func
(paren
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
id|free_hba
c_func
(paren
id|i
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
(paren
id|cpqarray_register_ctlr
c_func
(paren
id|i
comma
id|pdev
)paren
)paren
suffix:semicolon
)brace
DECL|variable|cpqarray_pci_driver
r_static
r_struct
id|pci_driver
id|cpqarray_pci_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;cpqarray&quot;
comma
id|probe
suffix:colon
id|cpqarray_init_one
comma
id|remove
suffix:colon
id|__devexit_p
c_func
(paren
id|cpqarray_remove_one_pci
)paren
comma
id|id_table
suffix:colon
id|cpqarray_pci_device_id
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *  This is it.  Find all the controllers and register them.&n; *  returns the number of block devices registered.&n; */
DECL|function|cpqarray_init_step2
r_int
id|__init
id|cpqarray_init_step2
c_func
(paren
r_void
)paren
(brace
r_int
id|num_cntlrs_reg
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* detect controllers */
id|printk
c_func
(paren
id|DRIVER_NAME
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* TODO: If it&squot;s an eisa only system, will rc return negative? */
id|rc
op_assign
id|pci_register_driver
c_func
(paren
op_amp
id|cpqarray_pci_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|cpqarray_eisa_detect
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_CTLR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
id|num_cntlrs_reg
op_increment
suffix:semicolon
)brace
r_return
id|num_cntlrs_reg
suffix:semicolon
)brace
multiline_comment|/* Function to find the first free pointer into our hba[] array */
multiline_comment|/* Returns -1 if no free entries are left.  */
DECL|function|alloc_cpqarray_hba
r_static
r_int
id|alloc_cpqarray_hba
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_CTLR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|hba
(braket
id|i
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ctlr_info_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_return
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: This driver supports a maximum&quot;
l_string|&quot; of 8 controllers.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|free_hba
r_static
r_void
id|free_hba
c_func
(paren
r_int
id|i
)paren
(brace
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
id|hba
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the IO address of the controller, its IRQ and so forth.  Fill&n; * in some basic stuff into the ctlr_info_t structure.&n; */
DECL|function|cpqarray_pci_init
r_static
r_int
id|cpqarray_pci_init
c_func
(paren
id|ctlr_info_t
op_star
id|c
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
id|ushort
id|vendor_id
comma
id|device_id
comma
id|command
suffix:semicolon
id|unchar
id|cache_line_size
comma
id|latency_timer
suffix:semicolon
id|unchar
id|irq
comma
id|revision
suffix:semicolon
r_int
r_int
id|addr
(braket
l_int|6
)braket
suffix:semicolon
id|__u32
id|board_id
suffix:semicolon
r_int
id|i
suffix:semicolon
id|c-&gt;pci_dev
op_assign
id|pdev
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: Unable to Enable PCI device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|vendor_id
op_assign
id|pdev-&gt;vendor
suffix:semicolon
id|device_id
op_assign
id|pdev-&gt;device
suffix:semicolon
id|irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|addr
(braket
id|i
)braket
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|pdev
comma
id|CPQARRAY_DMA_MASK
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: Unable to set DMA mask&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CACHE_LINE_SIZE
comma
op_amp
id|cache_line_size
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|latency_timer
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
l_int|0x2c
comma
op_amp
id|board_id
)paren
suffix:semicolon
multiline_comment|/* check to see if controller has been disabled */
r_if
c_cond
(paren
op_logical_neg
(paren
id|command
op_amp
l_int|0x02
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: controller appears to be disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|DBGINFO
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;vendor_id = %x&bslash;n&quot;
comma
id|vendor_id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;device_id = %x&bslash;n&quot;
comma
id|device_id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;command = %x&bslash;n&quot;
comma
id|command
)paren
suffix:semicolon
r_for
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;addr[%d] = %lx&bslash;n&quot;
comma
id|i
comma
id|addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;revision = %x&bslash;n&quot;
comma
id|revision
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;irq = %x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cache_line_size = %x&bslash;n&quot;
comma
id|cache_line_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;latency_timer = %x&bslash;n&quot;
comma
id|latency_timer
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;board_id = %x&bslash;n&quot;
comma
id|board_id
)paren
suffix:semicolon
)paren
suffix:semicolon
id|c-&gt;intr
op_assign
id|irq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pci_resource_flags
c_func
(paren
id|pdev
comma
id|i
)paren
op_amp
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
(brace
multiline_comment|/* IO space */
id|c-&gt;io_mem_addr
op_assign
id|addr
(braket
id|i
)braket
suffix:semicolon
id|c-&gt;io_mem_length
op_assign
id|pci_resource_end
c_func
(paren
id|pdev
comma
id|i
)paren
op_minus
id|pci_resource_start
c_func
(paren
id|pdev
comma
id|i
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|c-&gt;io_mem_addr
comma
id|c-&gt;io_mem_length
comma
l_string|&quot;cpqarray&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray I/O memory range already in use addr %lx length = %ld&bslash;n&quot;
comma
id|c-&gt;io_mem_addr
comma
id|c-&gt;io_mem_length
)paren
suffix:semicolon
id|c-&gt;io_mem_addr
op_assign
l_int|0
suffix:semicolon
id|c-&gt;io_mem_length
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|c-&gt;paddr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|pci_resource_flags
c_func
(paren
id|pdev
comma
id|i
)paren
op_amp
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
)paren
(brace
id|c-&gt;paddr
op_assign
id|pci_resource_start
(paren
id|pdev
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;paddr
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|c-&gt;vaddr
op_assign
id|remap_pci_mem
c_func
(paren
id|c-&gt;paddr
comma
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;vaddr
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|c-&gt;board_id
op_assign
id|board_id
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PRODUCTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|board_id
op_eq
id|products
(braket
id|i
)braket
dot
id|board_id
)paren
(brace
id|c-&gt;product_name
op_assign
id|products
(braket
id|i
)braket
dot
id|product_name
suffix:semicolon
id|c-&gt;access
op_assign
op_star
(paren
id|products
(braket
id|i
)braket
dot
id|access
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|NR_PRODUCTS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Sorry, I don&squot;t know how&quot;
l_string|&quot; to access the SMART Array controller %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|board_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Map (physical) PCI mem into (virtual) kernel space&n; */
DECL|function|remap_pci_mem
r_static
r_void
op_star
id|remap_pci_mem
c_func
(paren
id|ulong
id|base
comma
id|ulong
id|size
)paren
(brace
id|ulong
id|page_base
op_assign
(paren
(paren
id|ulong
)paren
id|base
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|ulong
id|page_offs
op_assign
(paren
(paren
id|ulong
)paren
id|base
)paren
op_minus
id|page_base
suffix:semicolon
r_void
op_star
id|page_remapped
op_assign
id|ioremap
c_func
(paren
id|page_base
comma
id|page_offs
op_plus
id|size
)paren
suffix:semicolon
r_return
(paren
id|page_remapped
ques
c_cond
(paren
id|page_remapped
op_plus
id|page_offs
)paren
suffix:colon
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#ifndef MODULE
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,13)
multiline_comment|/*&n; * Config string is a comma separated set of i/o addresses of EISA cards.&n; */
DECL|function|cpqarray_setup
r_static
r_int
id|cpqarray_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|i
comma
id|ints
(braket
l_int|9
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ints
(braket
l_int|0
)braket
op_logical_and
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|eisa
(braket
id|i
)braket
op_assign
id|ints
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;smart2=&quot;
comma
id|cpqarray_setup
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n; * Copy the contents of the ints[] array passed to us by init.&n; */
DECL|function|cpqarray_setup
r_void
id|cpqarray_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ints
(braket
l_int|0
)braket
op_logical_and
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|eisa
(braket
id|i
)braket
op_assign
id|ints
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n; * Find an EISA controller&squot;s signature.  Set up an hba if we find it.&n; */
DECL|function|cpqarray_eisa_detect
r_static
r_int
id|cpqarray_eisa_detect
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
suffix:semicolon
id|__u32
id|board_id
suffix:semicolon
r_int
id|intr
suffix:semicolon
r_int
id|ctlr
suffix:semicolon
r_int
id|num_ctlr
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
l_int|8
op_logical_and
id|eisa
(braket
id|i
)braket
)paren
(brace
id|ctlr
op_assign
id|alloc_cpqarray_hba
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctlr
op_eq
op_minus
l_int|1
)paren
(brace
r_break
suffix:semicolon
)brace
id|board_id
op_assign
id|inl
c_func
(paren
id|eisa
(braket
id|i
)braket
op_plus
l_int|0xC80
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_PRODUCTS
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|board_id
op_eq
id|products
(braket
id|j
)braket
dot
id|board_id
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
id|NR_PRODUCTS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Sorry, I don&squot;t know how&quot;
l_string|&quot; to access the SMART Array controller %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|board_id
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|memset
c_func
(paren
id|hba
(braket
id|ctlr
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|ctlr_info_t
)paren
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|io_mem_addr
op_assign
id|eisa
(braket
id|i
)braket
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|io_mem_length
op_assign
l_int|0x7FF
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|io_mem_addr
comma
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|io_mem_length
comma
l_string|&quot;cpqarray&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: I/O range already in &quot;
l_string|&quot;use addr = %lx length = %ld&bslash;n&quot;
comma
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|io_mem_addr
comma
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|io_mem_length
)paren
suffix:semicolon
id|free_hba
c_func
(paren
id|ctlr
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Read the config register to find our interrupt&n;&t;&t; */
id|intr
op_assign
id|inb
c_func
(paren
id|eisa
(braket
id|i
)braket
op_plus
l_int|0xCC0
)paren
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|intr
op_amp
l_int|1
)paren
id|intr
op_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|intr
op_amp
l_int|2
)paren
id|intr
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|intr
op_amp
l_int|4
)paren
id|intr
op_assign
l_int|14
suffix:semicolon
r_else
r_if
c_cond
(paren
id|intr
op_amp
l_int|8
)paren
id|intr
op_assign
l_int|15
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|intr
op_assign
id|intr
suffix:semicolon
id|sprintf
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|devname
comma
l_string|&quot;ida%d&quot;
comma
id|nr_ctlr
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|product_name
op_assign
id|products
(braket
id|j
)braket
dot
id|product_name
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|access
op_assign
op_star
(paren
id|products
(braket
id|j
)braket
dot
id|access
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|ctlr
op_assign
id|ctlr
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|board_id
op_assign
id|board_id
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|pci_dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* not PCI */
id|DBGINFO
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;i = %d, j = %d&bslash;n&quot;
comma
id|i
comma
id|j
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;irq = %x&bslash;n&quot;
comma
id|intr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;product name = %s&bslash;n&quot;
comma
id|products
(braket
id|j
)braket
dot
id|product_name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;board_id = %x&bslash;n&quot;
comma
id|board_id
)paren
suffix:semicolon
)paren
suffix:semicolon
id|num_ctlr
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cpqarray_register_ctlr
c_func
(paren
id|ctlr
comma
l_int|NULL
)paren
op_eq
op_minus
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Can&squot;t register EISA controller %d&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
)brace
r_return
id|num_ctlr
suffix:semicolon
)brace
multiline_comment|/*&n; * Open.  Make sure the device is really there.&n; */
DECL|function|ida_open
r_static
r_int
id|ida_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
id|drv_info_t
op_star
id|drv
op_assign
id|get_drv
c_func
(paren
id|inode-&gt;i_bdev-&gt;bd_disk
)paren
suffix:semicolon
id|ctlr_info_t
op_star
id|host
op_assign
id|get_host
c_func
(paren
id|inode-&gt;i_bdev-&gt;bd_disk
)paren
suffix:semicolon
id|DBGINFO
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;ida_open %s&bslash;n&quot;
comma
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;disk_name
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Root is allowed to open raw volume zero even if it&squot;s not configured&n;&t; * so array config can still work.  I don&squot;t think I really like this,&n;&t; * but I&squot;m already using way to many device nodes to claim another one&n;&t; * for &quot;raw controller&quot;.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;nr_blks
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
op_logical_and
id|drv
op_ne
id|host-&gt;drv
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|host-&gt;usage_count
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close.  Sync first.&n; */
DECL|function|ida_release
r_static
r_int
id|ida_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
id|ctlr_info_t
op_star
id|host
op_assign
id|get_host
c_func
(paren
id|inode-&gt;i_bdev-&gt;bd_disk
)paren
suffix:semicolon
id|host-&gt;usage_count
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Enqueuing and dequeuing functions for cmdlists.&n; */
DECL|function|addQ
r_static
r_inline
r_void
id|addQ
c_func
(paren
id|cmdlist_t
op_star
op_star
id|Qptr
comma
id|cmdlist_t
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
op_star
id|Qptr
op_eq
l_int|NULL
)paren
(brace
op_star
id|Qptr
op_assign
id|c
suffix:semicolon
id|c-&gt;next
op_assign
id|c-&gt;prev
op_assign
id|c
suffix:semicolon
)brace
r_else
(brace
id|c-&gt;prev
op_assign
(paren
op_star
id|Qptr
)paren
op_member_access_from_pointer
id|prev
suffix:semicolon
id|c-&gt;next
op_assign
(paren
op_star
id|Qptr
)paren
suffix:semicolon
(paren
op_star
id|Qptr
)paren
op_member_access_from_pointer
id|prev-&gt;next
op_assign
id|c
suffix:semicolon
(paren
op_star
id|Qptr
)paren
op_member_access_from_pointer
id|prev
op_assign
id|c
suffix:semicolon
)brace
)brace
DECL|function|removeQ
r_static
r_inline
id|cmdlist_t
op_star
id|removeQ
c_func
(paren
id|cmdlist_t
op_star
op_star
id|Qptr
comma
id|cmdlist_t
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
id|c
op_logical_and
id|c-&gt;next
op_ne
id|c
)paren
(brace
r_if
c_cond
(paren
op_star
id|Qptr
op_eq
id|c
)paren
op_star
id|Qptr
op_assign
id|c-&gt;next
suffix:semicolon
id|c-&gt;prev-&gt;next
op_assign
id|c-&gt;next
suffix:semicolon
id|c-&gt;next-&gt;prev
op_assign
id|c-&gt;prev
suffix:semicolon
)brace
r_else
(brace
op_star
id|Qptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a request and submit it to the controller.&n; * This routine needs to grab all the requests it possibly can from the&n; * req Q and submit them.  Interrupts are off (and need to be off) when you&n; * are in here (either via the dummy do_ida_request functions or by being&n; * called from the interrupt handler&n; */
DECL|function|do_ida_request
r_static
r_void
id|do_ida_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
id|ctlr_info_t
op_star
id|h
op_assign
id|q-&gt;queuedata
suffix:semicolon
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_struct
id|request
op_star
id|creq
suffix:semicolon
r_struct
id|scatterlist
id|tmp_sg
(braket
id|SG_MAX
)braket
suffix:semicolon
r_int
id|i
comma
id|dir
comma
id|seg
suffix:semicolon
r_if
c_cond
(paren
id|blk_queue_plugged
c_func
(paren
id|q
)paren
)paren
r_goto
id|startio
suffix:semicolon
id|queue_next
suffix:colon
id|creq
op_assign
id|elv_next_request
c_func
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|creq
)paren
r_goto
id|startio
suffix:semicolon
r_if
c_cond
(paren
id|creq-&gt;nr_phys_segments
OG
id|SG_MAX
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
id|cmd_alloc
c_func
(paren
id|h
comma
l_int|1
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|startio
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|creq
)paren
suffix:semicolon
id|c-&gt;ctlr
op_assign
id|h-&gt;ctlr
suffix:semicolon
id|c-&gt;hdr.unit
op_assign
(paren
id|drv_info_t
op_star
)paren
(paren
id|creq-&gt;rq_disk-&gt;private_data
)paren
op_minus
id|h-&gt;drv
suffix:semicolon
id|c-&gt;hdr.size
op_assign
r_sizeof
(paren
id|rblk_t
)paren
op_rshift
l_int|2
suffix:semicolon
id|c-&gt;size
op_add_assign
r_sizeof
(paren
id|rblk_t
)paren
suffix:semicolon
id|c-&gt;req.hdr.blk
op_assign
id|creq-&gt;sector
suffix:semicolon
id|c-&gt;rq
op_assign
id|creq
suffix:semicolon
id|DBGPX
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;sector=%d, nr_sectors=%d&bslash;n&quot;
comma
id|creq-&gt;sector
comma
id|creq-&gt;nr_sectors
)paren
suffix:semicolon
)paren
suffix:semicolon
id|seg
op_assign
id|blk_rq_map_sg
c_func
(paren
id|q
comma
id|creq
comma
id|tmp_sg
)paren
suffix:semicolon
multiline_comment|/* Now do all the DMA Mappings */
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|creq
)paren
op_eq
id|READ
)paren
id|dir
op_assign
id|PCI_DMA_FROMDEVICE
suffix:semicolon
r_else
id|dir
op_assign
id|PCI_DMA_TODEVICE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|seg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c-&gt;req.sg
(braket
id|i
)braket
dot
id|size
op_assign
id|tmp_sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|c-&gt;req.sg
(braket
id|i
)braket
dot
id|addr
op_assign
(paren
id|__u32
)paren
id|pci_map_page
c_func
(paren
id|h-&gt;pci_dev
comma
id|tmp_sg
(braket
id|i
)braket
dot
id|page
comma
id|tmp_sg
(braket
id|i
)braket
dot
id|offset
comma
id|tmp_sg
(braket
id|i
)braket
dot
id|length
comma
id|dir
)paren
suffix:semicolon
)brace
id|DBGPX
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Submitting %d sectors in %d segments&bslash;n&quot;
comma
id|creq-&gt;nr_sectors
comma
id|seg
)paren
suffix:semicolon
)paren
suffix:semicolon
id|c-&gt;req.hdr.sg_cnt
op_assign
id|seg
suffix:semicolon
id|c-&gt;req.hdr.blk_cnt
op_assign
id|creq-&gt;nr_sectors
suffix:semicolon
id|c-&gt;req.hdr.cmd
op_assign
(paren
id|rq_data_dir
c_func
(paren
id|creq
)paren
op_eq
id|READ
)paren
ques
c_cond
id|IDA_READ
suffix:colon
id|IDA_WRITE
suffix:semicolon
id|c-&gt;type
op_assign
id|CMD_RWREQ
suffix:semicolon
multiline_comment|/* Put the request on the tail of the request queue */
id|addQ
c_func
(paren
op_amp
id|h-&gt;reqQ
comma
id|c
)paren
suffix:semicolon
id|h-&gt;Qdepth
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;Qdepth
OG
id|h-&gt;maxQsinceinit
)paren
id|h-&gt;maxQsinceinit
op_assign
id|h-&gt;Qdepth
suffix:semicolon
r_goto
id|queue_next
suffix:semicolon
id|startio
suffix:colon
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * start_io submits everything on a controller&squot;s request queue&n; * and moves it to the completion queue.&n; *&n; * Interrupts had better be off if you&squot;re in here&n; */
DECL|function|start_io
r_static
r_void
id|start_io
c_func
(paren
id|ctlr_info_t
op_star
id|h
)paren
(brace
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
id|h-&gt;reqQ
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Can&squot;t do anything if we&squot;re busy */
r_if
c_cond
(paren
id|h-&gt;access
dot
id|fifo_full
c_func
(paren
id|h
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Get the first entry from the request Q */
id|removeQ
c_func
(paren
op_amp
id|h-&gt;reqQ
comma
id|c
)paren
suffix:semicolon
id|h-&gt;Qdepth
op_decrement
suffix:semicolon
multiline_comment|/* Tell the controller to do our bidding */
id|h-&gt;access
dot
id|submit_command
c_func
(paren
id|h
comma
id|c
)paren
suffix:semicolon
multiline_comment|/* Get onto the completion Q */
id|addQ
c_func
(paren
op_amp
id|h-&gt;cmpQ
comma
id|c
)paren
suffix:semicolon
)brace
)brace
DECL|function|complete_buffers
r_static
r_inline
r_void
id|complete_buffers
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
id|ok
)paren
(brace
r_struct
id|bio
op_star
id|xbh
suffix:semicolon
r_while
c_loop
(paren
id|bio
)paren
(brace
r_int
id|nr_sectors
op_assign
id|bio_sectors
c_func
(paren
id|bio
)paren
suffix:semicolon
id|xbh
op_assign
id|bio-&gt;bi_next
suffix:semicolon
id|bio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
id|blk_finished_io
c_func
(paren
id|nr_sectors
)paren
suffix:semicolon
id|bio_endio
c_func
(paren
id|bio
comma
id|nr_sectors
op_lshift
l_int|9
comma
id|ok
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
)paren
suffix:semicolon
id|bio
op_assign
id|xbh
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Mark all buffers that cmd was responsible for&n; */
DECL|function|complete_command
r_static
r_inline
r_void
id|complete_command
c_func
(paren
id|cmdlist_t
op_star
id|cmd
comma
r_int
id|timeout
)paren
(brace
r_int
id|ok
op_assign
l_int|1
suffix:semicolon
r_int
id|i
comma
id|ddir
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;req.hdr.rcode
op_amp
id|RCODE_NONFATAL
op_logical_and
(paren
id|hba
(braket
id|cmd-&gt;ctlr
)braket
op_member_access_from_pointer
id|misc_tflags
op_amp
id|MISC_NONFATAL_WARN
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Non Fatal error on ida/c%dd%d&bslash;n&quot;
comma
id|cmd-&gt;ctlr
comma
id|cmd-&gt;hdr.unit
)paren
suffix:semicolon
id|hba
(braket
id|cmd-&gt;ctlr
)braket
op_member_access_from_pointer
id|misc_tflags
op_or_assign
id|MISC_NONFATAL_WARN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd-&gt;req.hdr.rcode
op_amp
id|RCODE_FATAL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Fatal error on ida/c%dd%d&bslash;n&quot;
comma
id|cmd-&gt;ctlr
comma
id|cmd-&gt;hdr.unit
)paren
suffix:semicolon
id|ok
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd-&gt;req.hdr.rcode
op_amp
id|RCODE_INVREQ
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Invalid request on ida/c%dd%d = (cmd=%x sect=%d cnt=%d sg=%d ret=%x)&bslash;n&quot;
comma
id|cmd-&gt;ctlr
comma
id|cmd-&gt;hdr.unit
comma
id|cmd-&gt;req.hdr.cmd
comma
id|cmd-&gt;req.hdr.blk
comma
id|cmd-&gt;req.hdr.blk_cnt
comma
id|cmd-&gt;req.hdr.sg_cnt
comma
id|cmd-&gt;req.hdr.rcode
)paren
suffix:semicolon
id|ok
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
)paren
id|ok
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unmap the DMA mapping for all the scatter gather elements */
r_if
c_cond
(paren
id|cmd-&gt;req.hdr.cmd
op_eq
id|IDA_READ
)paren
id|ddir
op_assign
id|PCI_DMA_FROMDEVICE
suffix:semicolon
r_else
id|ddir
op_assign
id|PCI_DMA_TODEVICE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;req.hdr.sg_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pci_unmap_page
c_func
(paren
id|hba
(braket
id|cmd-&gt;ctlr
)braket
op_member_access_from_pointer
id|pci_dev
comma
id|cmd-&gt;req.sg
(braket
id|i
)braket
dot
id|addr
comma
id|cmd-&gt;req.sg
(braket
id|i
)braket
dot
id|size
comma
id|ddir
)paren
suffix:semicolon
)brace
id|complete_buffers
c_func
(paren
id|cmd-&gt;rq-&gt;bio
comma
id|ok
)paren
suffix:semicolon
id|DBGPX
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Done with %p&bslash;n&quot;
comma
id|cmd-&gt;rq
)paren
suffix:semicolon
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|cmd-&gt;rq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  The controller will interrupt us upon completion of commands.&n; *  Find the command on the completion queue, remove it, tell the OS and&n; *  try to queue up more IO&n; */
DECL|function|do_ida_intr
r_static
id|irqreturn_t
id|do_ida_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|ctlr_info_t
op_star
id|h
op_assign
id|dev_id
suffix:semicolon
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_int
r_int
id|istat
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|__u32
id|a
comma
id|a1
suffix:semicolon
id|istat
op_assign
id|h-&gt;access
dot
id|intr_pending
c_func
(paren
id|h
)paren
suffix:semicolon
multiline_comment|/* Is this interrupt for us? */
r_if
c_cond
(paren
id|istat
op_eq
l_int|0
)paren
r_return
id|IRQ_NONE
suffix:semicolon
multiline_comment|/*&n;&t; * If there are completed commands in the completion queue,&n;&t; * we had better do something about it.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
id|IDA_LOCK
c_func
(paren
id|h-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istat
op_amp
id|FIFO_NOT_EMPTY
)paren
(brace
r_while
c_loop
(paren
(paren
id|a
op_assign
id|h-&gt;access
dot
id|command_completed
c_func
(paren
id|h
)paren
)paren
)paren
(brace
id|a1
op_assign
id|a
suffix:semicolon
id|a
op_and_assign
op_complement
l_int|3
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
id|h-&gt;cmpQ
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Completion of %08lx ignored&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|a1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c-&gt;busaddr
op_ne
id|a
)paren
(brace
id|c
op_assign
id|c-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|h-&gt;cmpQ
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we&squot;ve found the command, take it off the&n;&t;&t;&t; * completion Q and free it&n;&t;&t;&t; */
r_if
c_cond
(paren
id|c-&gt;busaddr
op_eq
id|a
)paren
(brace
id|removeQ
c_func
(paren
op_amp
id|h-&gt;cmpQ
comma
id|c
)paren
suffix:semicolon
multiline_comment|/*  Check for invalid command.&n;                                 *  Controller returns command error,&n;                                 *  But rcode = 0.&n;                                 */
r_if
c_cond
(paren
(paren
id|a1
op_amp
l_int|0x03
)paren
op_logical_and
(paren
id|c-&gt;req.hdr.rcode
op_eq
l_int|0
)paren
)paren
(brace
id|c-&gt;req.hdr.rcode
op_assign
id|RCODE_INVREQ
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;type
op_eq
id|CMD_RWREQ
)paren
(brace
id|complete_command
c_func
(paren
id|c
comma
l_int|0
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|h
comma
id|c
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c-&gt;type
op_eq
id|CMD_IOCTL_PEND
)paren
(brace
id|c-&gt;type
op_assign
id|CMD_IOCTL_DONE
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * See if we can queue up some more IO&n;&t; */
id|do_ida_request
c_func
(paren
id|h-&gt;queue
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|IDA_LOCK
c_func
(paren
id|h-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; * This timer was for timing out requests that haven&squot;t happened after&n; * IDA_TIMEOUT.  That wasn&squot;t such a good idea.  This timer is used to&n; * reset a flags structure so we don&squot;t flood the user with&n; * &quot;Non-Fatal error&quot; messages.&n; */
DECL|function|ida_timer
r_static
r_void
id|ida_timer
c_func
(paren
r_int
r_int
id|tdata
)paren
(brace
id|ctlr_info_t
op_star
id|h
op_assign
(paren
id|ctlr_info_t
op_star
)paren
id|tdata
suffix:semicolon
id|h-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|IDA_TIMER
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|h-&gt;timer
)paren
suffix:semicolon
id|h-&gt;misc_tflags
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  ida_ioctl does some miscellaneous stuff like reporting drive geometry,&n; *  setting readahead and submitting commands from userspace to the controller.&n; */
DECL|function|ida_ioctl
r_static
r_int
id|ida_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|drv_info_t
op_star
id|drv
op_assign
id|get_drv
c_func
(paren
id|inode-&gt;i_bdev-&gt;bd_disk
)paren
suffix:semicolon
id|ctlr_info_t
op_star
id|host
op_assign
id|get_host
c_func
(paren
id|inode-&gt;i_bdev-&gt;bd_disk
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|diskinfo
(braket
l_int|4
)braket
suffix:semicolon
r_struct
id|hd_geometry
op_star
id|geo
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
id|ida_ioctl_t
op_star
id|io
op_assign
(paren
id|ida_ioctl_t
op_star
)paren
id|arg
suffix:semicolon
id|ida_ioctl_t
op_star
id|my_io
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
r_if
c_cond
(paren
id|drv-&gt;cylinders
)paren
(brace
id|diskinfo
(braket
l_int|0
)braket
op_assign
id|drv-&gt;heads
suffix:semicolon
id|diskinfo
(braket
l_int|1
)braket
op_assign
id|drv-&gt;sectors
suffix:semicolon
id|diskinfo
(braket
l_int|2
)braket
op_assign
id|drv-&gt;cylinders
suffix:semicolon
)brace
r_else
(brace
id|diskinfo
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|diskinfo
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
id|diskinfo
(braket
l_int|2
)braket
op_assign
id|drv-&gt;nr_blks
op_div
(paren
l_int|0xff
op_star
l_int|0x3f
)paren
suffix:semicolon
)brace
id|put_user
c_func
(paren
id|diskinfo
(braket
l_int|0
)braket
comma
op_amp
id|geo-&gt;heads
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|diskinfo
(braket
l_int|1
)braket
comma
op_amp
id|geo-&gt;sectors
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|diskinfo
(braket
l_int|2
)braket
comma
op_amp
id|geo-&gt;cylinders
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|get_start_sect
c_func
(paren
id|inode-&gt;i_bdev
)paren
comma
op_amp
id|geo-&gt;start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|IDAGETDRVINFO
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
op_amp
id|io-&gt;c.drv
comma
id|drv
comma
r_sizeof
(paren
id|drv_info_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|IDAPASSTHRU
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|my_io
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ida_ioctl_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|my_io
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|my_io
comma
id|io
comma
r_sizeof
(paren
op_star
id|my_io
)paren
)paren
)paren
r_goto
id|out_passthru
suffix:semicolon
id|error
op_assign
id|ida_ctlr_ioctl
c_func
(paren
id|host
comma
id|drv
op_minus
id|host-&gt;drv
comma
id|my_io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_passthru
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|io
comma
id|my_io
comma
r_sizeof
(paren
op_star
id|my_io
)paren
)paren
)paren
r_goto
id|out_passthru
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out_passthru
suffix:colon
id|kfree
c_func
(paren
id|my_io
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
r_case
id|IDAGETCTLRSIG
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|put_user
c_func
(paren
id|host-&gt;ctlr_sig
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|IDAREVALIDATEVOLS
suffix:colon
r_if
c_cond
(paren
id|iminor
c_func
(paren
id|inode
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_return
id|revalidate_allvol
c_func
(paren
id|host
)paren
suffix:semicolon
r_case
id|IDADRIVERVERSION
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|put_user
c_func
(paren
id|DRIVER_VERSION
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|IDAGETPCIINFO
suffix:colon
(brace
id|ida_pci_info_struct
id|pciinfo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pciinfo.bus
op_assign
id|host-&gt;pci_dev-&gt;bus-&gt;number
suffix:semicolon
id|pciinfo.dev_fn
op_assign
id|host-&gt;pci_dev-&gt;devfn
suffix:semicolon
id|pciinfo.board_id
op_assign
id|host-&gt;board_id
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|pciinfo
comma
r_sizeof
(paren
id|ida_pci_info_struct
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * ida_ctlr_ioctl is for passing commands to the controller from userspace.&n; * The command block (io) has already been copied to kernel space for us,&n; * however, any elements in the sglist need to be copied to kernel space&n; * or copied back to userspace.&n; *&n; * Only root may perform a controller passthru command, however I&squot;m not doing&n; * any serious sanity checking on the arguments.  Doing an IDA_WRITE_MEDIA and&n; * putting a 64M buffer in the sglist is probably a *bad* idea.&n; */
DECL|function|ida_ctlr_ioctl
r_static
r_int
id|ida_ctlr_ioctl
c_func
(paren
id|ctlr_info_t
op_star
id|h
comma
r_int
id|dsk
comma
id|ida_ioctl_t
op_star
id|io
)paren
(brace
r_int
id|ctlr
op_assign
id|h-&gt;ctlr
suffix:semicolon
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_void
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
id|cmd_alloc
c_func
(paren
id|h
comma
l_int|0
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|c-&gt;ctlr
op_assign
id|ctlr
suffix:semicolon
id|c-&gt;hdr.unit
op_assign
(paren
id|io-&gt;unit
op_amp
id|UNITVALID
)paren
ques
c_cond
(paren
id|io-&gt;unit
op_amp
op_complement
id|UNITVALID
)paren
suffix:colon
id|dsk
suffix:semicolon
id|c-&gt;hdr.size
op_assign
r_sizeof
(paren
id|rblk_t
)paren
op_rshift
l_int|2
suffix:semicolon
id|c-&gt;size
op_add_assign
r_sizeof
(paren
id|rblk_t
)paren
suffix:semicolon
id|c-&gt;req.hdr.cmd
op_assign
id|io-&gt;cmd
suffix:semicolon
id|c-&gt;req.hdr.blk
op_assign
id|io-&gt;blk
suffix:semicolon
id|c-&gt;req.hdr.blk_cnt
op_assign
id|io-&gt;blk_cnt
suffix:semicolon
id|c-&gt;type
op_assign
id|CMD_IOCTL_PEND
suffix:semicolon
multiline_comment|/* Pre submit processing */
r_switch
c_cond
(paren
id|io-&gt;cmd
)paren
(brace
r_case
id|PASSTHRU_A
suffix:colon
id|p
op_assign
id|kmalloc
c_func
(paren
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|cmd_free
c_func
(paren
id|h
comma
id|c
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|p
comma
(paren
r_void
op_star
)paren
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|addr
comma
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
)paren
)paren
(brace
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|h
comma
id|c
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|c-&gt;req.hdr.blk
op_assign
id|pci_map_single
c_func
(paren
id|h-&gt;pci_dev
comma
op_amp
(paren
id|io-&gt;c
)paren
comma
r_sizeof
(paren
id|ida_ioctl_t
)paren
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
op_assign
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|pci_map_single
c_func
(paren
id|h-&gt;pci_dev
comma
id|p
comma
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|c-&gt;req.hdr.sg_cnt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IDA_READ
suffix:colon
r_case
id|READ_FLASH_ROM
suffix:colon
r_case
id|SENSE_CONTROLLER_PERFORMANCE
suffix:colon
id|p
op_assign
id|kmalloc
c_func
(paren
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|cmd_free
c_func
(paren
id|h
comma
id|c
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
op_assign
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|pci_map_single
c_func
(paren
id|h-&gt;pci_dev
comma
id|p
comma
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|c-&gt;req.hdr.sg_cnt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IDA_WRITE
suffix:colon
r_case
id|IDA_WRITE_MEDIA
suffix:colon
r_case
id|DIAG_PASS_THRU
suffix:colon
r_case
id|COLLECT_BUFFER
suffix:colon
r_case
id|WRITE_FLASH_ROM
suffix:colon
id|p
op_assign
id|kmalloc
c_func
(paren
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|cmd_free
c_func
(paren
id|h
comma
id|c
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|p
comma
(paren
r_void
op_star
)paren
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|addr
comma
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
)paren
)paren
(brace
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|h
comma
id|c
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
op_assign
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|pci_map_single
c_func
(paren
id|h-&gt;pci_dev
comma
id|p
comma
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|c-&gt;req.hdr.sg_cnt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
op_assign
r_sizeof
(paren
id|io-&gt;c
)paren
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|pci_map_single
c_func
(paren
id|h-&gt;pci_dev
comma
op_amp
id|io-&gt;c
comma
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|c-&gt;req.hdr.sg_cnt
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put the request on the tail of the request queue */
id|spin_lock_irqsave
c_func
(paren
id|IDA_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|addQ
c_func
(paren
op_amp
id|h-&gt;reqQ
comma
id|c
)paren
suffix:semicolon
id|h-&gt;Qdepth
op_increment
suffix:semicolon
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|IDA_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Wait for completion */
r_while
c_loop
(paren
id|c-&gt;type
op_ne
id|CMD_IOCTL_DONE
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Unmap the DMA  */
id|pci_unmap_single
c_func
(paren
id|h-&gt;pci_dev
comma
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|addr
comma
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
multiline_comment|/* Post submit processing */
r_switch
c_cond
(paren
id|io-&gt;cmd
)paren
(brace
r_case
id|PASSTHRU_A
suffix:colon
id|pci_unmap_single
c_func
(paren
id|h-&gt;pci_dev
comma
id|c-&gt;req.hdr.blk
comma
r_sizeof
(paren
id|ida_ioctl_t
)paren
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
r_case
id|IDA_READ
suffix:colon
r_case
id|DIAG_PASS_THRU
suffix:colon
r_case
id|SENSE_CONTROLLER_PERFORMANCE
suffix:colon
r_case
id|READ_FLASH_ROM
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|addr
comma
id|p
comma
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
)paren
)paren
(brace
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* fall through and free p */
r_case
id|IDA_WRITE
suffix:colon
r_case
id|IDA_WRITE_MEDIA
suffix:colon
r_case
id|COLLECT_BUFFER
suffix:colon
r_case
id|WRITE_FLASH_ROM
suffix:colon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
multiline_comment|/* Nothing to do */
)brace
id|io-&gt;rcode
op_assign
id|c-&gt;req.hdr.rcode
suffix:semicolon
id|cmd_free
c_func
(paren
id|h
comma
id|c
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Commands are pre-allocated in a large block.  Here we use a simple bitmap&n; * scheme to suballocte them to the driver.  Operations that are not time&n; * critical (and can wait for kmalloc and possibly sleep) can pass in NULL&n; * as the first argument to get a new command.&n; */
DECL|function|cmd_alloc
r_static
id|cmdlist_t
op_star
id|cmd_alloc
c_func
(paren
id|ctlr_info_t
op_star
id|h
comma
r_int
id|get_from_pool
)paren
(brace
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dma_addr_t
id|cmd_dhandle
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_from_pool
)paren
(brace
id|c
op_assign
(paren
id|cmdlist_t
op_star
)paren
id|pci_alloc_consistent
c_func
(paren
id|h-&gt;pci_dev
comma
r_sizeof
(paren
id|cmdlist_t
)paren
comma
op_amp
id|cmd_dhandle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
r_do
(brace
id|i
op_assign
id|find_first_zero_bit
c_func
(paren
id|h-&gt;cmd_pool_bits
comma
id|NR_CMDS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NR_CMDS
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
id|i
op_amp
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
comma
id|h-&gt;cmd_pool_bits
op_plus
(paren
id|i
op_div
id|BITS_PER_LONG
)paren
)paren
op_ne
l_int|0
)paren
(brace
suffix:semicolon
)brace
id|c
op_assign
id|h-&gt;cmd_pool
op_plus
id|i
suffix:semicolon
id|cmd_dhandle
op_assign
id|h-&gt;cmd_pool_dhandle
op_plus
id|i
op_star
r_sizeof
(paren
id|cmdlist_t
)paren
suffix:semicolon
id|h-&gt;nr_allocs
op_increment
suffix:semicolon
)brace
id|memset
c_func
(paren
id|c
comma
l_int|0
comma
r_sizeof
(paren
id|cmdlist_t
)paren
)paren
suffix:semicolon
id|c-&gt;busaddr
op_assign
id|cmd_dhandle
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
DECL|function|cmd_free
r_static
r_void
id|cmd_free
c_func
(paren
id|ctlr_info_t
op_star
id|h
comma
id|cmdlist_t
op_star
id|c
comma
r_int
id|got_from_pool
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|got_from_pool
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|h-&gt;pci_dev
comma
r_sizeof
(paren
id|cmdlist_t
)paren
comma
id|c
comma
id|c-&gt;busaddr
)paren
suffix:semicolon
)brace
r_else
(brace
id|i
op_assign
id|c
op_minus
id|h-&gt;cmd_pool
suffix:semicolon
id|clear_bit
c_func
(paren
id|i
op_amp
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
comma
id|h-&gt;cmd_pool_bits
op_plus
(paren
id|i
op_div
id|BITS_PER_LONG
)paren
)paren
suffix:semicolon
id|h-&gt;nr_frees
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/***********************************************************************&n;    name:        sendcmd&n;    Send a command to an IDA using the memory mapped FIFO interface&n;    and wait for it to complete.  &n;    This routine should only be called at init time.&n;***********************************************************************/
DECL|function|sendcmd
r_static
r_int
id|sendcmd
c_func
(paren
id|__u8
id|cmd
comma
r_int
id|ctlr
comma
r_void
op_star
id|buff
comma
r_int
id|size
comma
r_int
r_int
id|blk
comma
r_int
r_int
id|blkcnt
comma
r_int
r_int
id|log_unit
)paren
(brace
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_int
id|complete
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|ctlr_info_t
op_star
id|info_p
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
id|c
op_assign
id|cmd_alloc
c_func
(paren
id|info_p
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
r_return
id|IO_ERROR
suffix:semicolon
)brace
id|c-&gt;ctlr
op_assign
id|ctlr
suffix:semicolon
id|c-&gt;hdr.unit
op_assign
id|log_unit
suffix:semicolon
id|c-&gt;hdr.prio
op_assign
l_int|0
suffix:semicolon
id|c-&gt;hdr.size
op_assign
r_sizeof
(paren
id|rblk_t
)paren
op_rshift
l_int|2
suffix:semicolon
id|c-&gt;size
op_add_assign
r_sizeof
(paren
id|rblk_t
)paren
suffix:semicolon
multiline_comment|/* The request information. */
id|c-&gt;req.hdr.next
op_assign
l_int|0
suffix:semicolon
id|c-&gt;req.hdr.rcode
op_assign
l_int|0
suffix:semicolon
id|c-&gt;req.bp
op_assign
l_int|0
suffix:semicolon
id|c-&gt;req.hdr.sg_cnt
op_assign
l_int|1
suffix:semicolon
id|c-&gt;req.hdr.reserved
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
op_assign
l_int|512
suffix:semicolon
r_else
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
op_assign
id|size
suffix:semicolon
id|c-&gt;req.hdr.blk
op_assign
id|blk
suffix:semicolon
id|c-&gt;req.hdr.blk_cnt
op_assign
id|blkcnt
suffix:semicolon
id|c-&gt;req.hdr.cmd
op_assign
(paren
r_int
r_char
)paren
id|cmd
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|addr
op_assign
(paren
id|__u32
)paren
id|pci_map_single
c_func
(paren
id|info_p-&gt;pci_dev
comma
id|buff
comma
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable interrupt&n;&t; */
id|info_p-&gt;access
dot
id|set_intr_mask
c_func
(paren
id|info_p
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Make sure there is room in the command FIFO */
multiline_comment|/* Actually it should be completely empty at this time. */
r_for
c_loop
(paren
id|i
op_assign
l_int|200000
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|temp
op_assign
id|info_p-&gt;access
dot
id|fifo_full
c_func
(paren
id|info_p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray ida%d: idaSendPciCmd FIFO full,&quot;
l_string|&quot; waiting!&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Send the cmd&n;&t; */
id|info_p-&gt;access
dot
id|submit_command
c_func
(paren
id|info_p
comma
id|c
)paren
suffix:semicolon
id|complete
op_assign
id|pollcomplete
c_func
(paren
id|ctlr
)paren
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|info_p-&gt;pci_dev
comma
(paren
id|dma_addr_t
)paren
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|addr
comma
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|complete
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|complete
op_ne
id|c-&gt;busaddr
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray ida%d: idaSendPciCmd &quot;
l_string|&quot;Invalid command list address returned! (%08lx)&bslash;n&quot;
comma
id|ctlr
comma
(paren
r_int
r_int
)paren
id|complete
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
comma
l_int|1
)paren
suffix:semicolon
r_return
(paren
id|IO_ERROR
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray ida%d: idaSendPciCmd Timeout out, &quot;
l_string|&quot;No command list address returned!&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
comma
l_int|1
)paren
suffix:semicolon
r_return
(paren
id|IO_ERROR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;req.hdr.rcode
op_amp
l_int|0x00FE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|c-&gt;req.hdr.rcode
op_amp
id|BIG_PROBLEM
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray ida%d: idaSendPciCmd, error: &quot;
l_string|&quot;Controller failed at init time &quot;
l_string|&quot;cmd: 0x%x, return code = 0x%x&bslash;n&quot;
comma
id|ctlr
comma
id|c-&gt;req.hdr.cmd
comma
id|c-&gt;req.hdr.rcode
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
comma
l_int|1
)paren
suffix:semicolon
r_return
(paren
id|IO_ERROR
)paren
suffix:semicolon
)brace
)brace
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
comma
l_int|1
)paren
suffix:semicolon
r_return
(paren
id|IO_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * revalidate_allvol is for online array config utilities.  After a&n; * utility reconfigures the drives in the array, it can use this function&n; * (through an ioctl) to make the driver zap any previous disk structs for&n; * that controller and get new ones.&n; *&n; * Right now I&squot;m using the getgeometry() function to do this, but this&n; * function should probably be finer grained and allow you to revalidate one&n; * particualar logical volume (instead of all of them on a particular&n; * controller).&n; */
DECL|function|revalidate_allvol
r_static
r_int
id|revalidate_allvol
c_func
(paren
id|ctlr_info_t
op_star
id|host
)paren
(brace
r_int
id|ctlr
op_assign
id|host-&gt;ctlr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|IDA_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;usage_count
OG
l_int|1
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
id|IDA_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Device busy for volume&quot;
l_string|&quot; revalidation (usage=%d)&bslash;n&quot;
comma
id|host-&gt;usage_count
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|host-&gt;usage_count
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|IDA_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the partition and block size structures for all volumes&n;&t; * on this controller to zero.  We will reread all of this data&n;&t; */
id|set_capacity
c_func
(paren
id|ida_gendisk
(braket
id|ctlr
)braket
(braket
l_int|0
)braket
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|NWD
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|ida_gendisk
(braket
id|ctlr
)braket
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|disk-&gt;flags
op_amp
id|GENHD_FL_UP
)paren
id|del_gendisk
c_func
(paren
id|disk
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|host-&gt;drv
comma
l_int|0
comma
r_sizeof
(paren
id|drv_info_t
)paren
op_star
id|NWD
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the array controller not to give us any interrupts while&n;&t; * we check the new geometry.  Then turn interrupts back on when&n;&t; * we&squot;re done.&n;&t; */
id|host-&gt;access
dot
id|set_intr_mask
c_func
(paren
id|host
comma
l_int|0
)paren
suffix:semicolon
id|getgeometry
c_func
(paren
id|ctlr
)paren
suffix:semicolon
id|host-&gt;access
dot
id|set_intr_mask
c_func
(paren
id|host
comma
id|FIFO_NOT_EMPTY
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NWD
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|ida_gendisk
(braket
id|ctlr
)braket
(braket
id|i
)braket
suffix:semicolon
id|drv_info_t
op_star
id|drv
op_assign
op_amp
id|host-&gt;drv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
op_logical_neg
id|drv-&gt;nr_blks
)paren
r_continue
suffix:semicolon
id|blk_queue_hardsect_size
c_func
(paren
id|host-&gt;queue
comma
id|drv-&gt;blk_size
)paren
suffix:semicolon
id|set_capacity
c_func
(paren
id|disk
comma
id|drv-&gt;nr_blks
)paren
suffix:semicolon
id|disk-&gt;queue
op_assign
id|host-&gt;queue
suffix:semicolon
id|disk-&gt;private_data
op_assign
id|drv
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
id|add_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
)brace
id|host-&gt;usage_count
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ida_revalidate
r_static
r_int
id|ida_revalidate
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
id|drv_info_t
op_star
id|drv
op_assign
id|disk-&gt;private_data
suffix:semicolon
id|set_capacity
c_func
(paren
id|disk
comma
id|drv-&gt;nr_blks
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;    name: pollcomplete&n;    Wait polling for a command to complete.&n;    The memory mapped FIFO is polled for the completion.&n;    Used only at init time, interrupts disabled.&n; ********************************************************************/
DECL|function|pollcomplete
r_static
r_int
id|pollcomplete
c_func
(paren
r_int
id|ctlr
)paren
(brace
r_int
id|done
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Wait (up to 2 seconds) for a command to complete */
r_for
c_loop
(paren
id|i
op_assign
l_int|200000
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|done
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|access
dot
id|command_completed
c_func
(paren
id|hba
(braket
id|ctlr
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
op_eq
l_int|0
)paren
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* a short fixed delay */
)brace
r_else
r_return
(paren
id|done
)paren
suffix:semicolon
)brace
multiline_comment|/* Invalid address to tell caller we ran out of time */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*****************************************************************&n;    start_fwbk&n;    Starts controller firmwares background processing. &n;    Currently only the Integrated Raid controller needs this done.&n;    If the PCI mem address registers are written to after this, &n;&t; data corruption may occur&n;*****************************************************************/
DECL|function|start_fwbk
r_static
r_void
id|start_fwbk
c_func
(paren
r_int
id|ctlr
)paren
(brace
id|id_ctlr_t
op_star
id|id_ctlr_buf
suffix:semicolon
r_int
id|ret_code
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|board_id
op_ne
l_int|0x40400E11
)paren
op_logical_and
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|board_id
op_ne
l_int|0x40480E11
)paren
)paren
(brace
multiline_comment|/* Not a Integrated Raid, so there is nothing for us to do */
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cpqarray: Starting firmware&squot;s background&quot;
l_string|&quot; processing&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Command does not return anything, but idasend command needs a &n;&t;&t;buffer */
id|id_ctlr_buf
op_assign
(paren
id|id_ctlr_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|id_ctlr_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id_ctlr_buf
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Out of memory. &quot;
l_string|&quot;Unable to start background processing.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ret_code
op_assign
id|sendcmd
c_func
(paren
id|RESUME_BACKGROUND_ACTIVITY
comma
id|ctlr
comma
id|id_ctlr_buf
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_code
op_ne
id|IO_OK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Unable to start&quot;
l_string|&quot; background processing&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************&n;    getgeometry&n;    Get ida logical volume geometry from the controller &n;    This is a large bit of code which once existed in two flavors,&n;    It is used only at init time.&n;*****************************************************************/
DECL|function|getgeometry
r_static
r_void
id|getgeometry
c_func
(paren
r_int
id|ctlr
)paren
(brace
id|id_log_drv_t
op_star
id|id_ldrive
suffix:semicolon
id|id_ctlr_t
op_star
id|id_ctlr_buf
suffix:semicolon
id|sense_log_drv_stat_t
op_star
id|id_lstatus_buf
suffix:semicolon
id|config_t
op_star
id|sense_config_buf
suffix:semicolon
r_int
r_int
id|log_unit
comma
id|log_index
suffix:semicolon
r_int
id|ret_code
comma
id|size
suffix:semicolon
id|drv_info_t
op_star
id|drv
suffix:semicolon
id|ctlr_info_t
op_star
id|info_p
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|info_p-&gt;log_drv_map
op_assign
l_int|0
suffix:semicolon
id|id_ldrive
op_assign
(paren
id|id_log_drv_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|id_log_drv_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id_ldrive
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray:  out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|id_ctlr_buf
op_assign
(paren
id|id_ctlr_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|id_ctlr_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id_ctlr_buf
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray:  out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|id_lstatus_buf
op_assign
(paren
id|sense_log_drv_stat_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|sense_log_drv_stat_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id_lstatus_buf
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray:  out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sense_config_buf
op_assign
(paren
id|config_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|config_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sense_config_buf
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|id_lstatus_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray:  out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|id_ldrive
comma
l_int|0
comma
r_sizeof
(paren
id|id_log_drv_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|id_ctlr_buf
comma
l_int|0
comma
r_sizeof
(paren
id|id_ctlr_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|id_lstatus_buf
comma
l_int|0
comma
r_sizeof
(paren
id|sense_log_drv_stat_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sense_config_buf
comma
l_int|0
comma
r_sizeof
(paren
id|config_t
)paren
)paren
suffix:semicolon
id|info_p-&gt;phys_drives
op_assign
l_int|0
suffix:semicolon
id|info_p-&gt;log_drv_map
op_assign
l_int|0
suffix:semicolon
id|info_p-&gt;drv_assign_map
op_assign
l_int|0
suffix:semicolon
id|info_p-&gt;drv_spare_map
op_assign
l_int|0
suffix:semicolon
id|info_p-&gt;mp_failed_drv_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* only initialized here */
multiline_comment|/* Get controllers info for this logical drive */
id|ret_code
op_assign
id|sendcmd
c_func
(paren
id|ID_CTLR
comma
id|ctlr
comma
id|id_ctlr_buf
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_code
op_eq
id|IO_ERROR
)paren
(brace
multiline_comment|/*&n;&t;&t; * If can&squot;t get controller info, set the logical drive map to 0,&n;&t;&t; * so the idastubopen will fail on all logical drives&n;&t;&t; * on the controller.&n;&t;&t; */
multiline_comment|/* Free all the buffers and return */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: error sending ID controller&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sense_config_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_lstatus_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info_p-&gt;log_drives
op_assign
id|id_ctlr_buf-&gt;nr_drvs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|info_p-&gt;firm_rev
(braket
id|i
)braket
op_assign
id|id_ctlr_buf-&gt;firm_rev
(braket
id|i
)braket
suffix:semicolon
)brace
id|info_p-&gt;ctlr_sig
op_assign
id|id_ctlr_buf-&gt;cfg_sig
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; (%s)&bslash;n&quot;
comma
id|info_p-&gt;product_name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize logical drive map to zero&n;&t; */
id|log_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Get drive geometry for all logical drives&n;&t; */
r_if
c_cond
(paren
id|id_ctlr_buf-&gt;nr_drvs
OG
l_int|16
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray ida%d:  This driver supports &quot;
l_string|&quot;16 logical drives per controller.&bslash;n.  &quot;
l_string|&quot; Additional drives will not be &quot;
l_string|&quot;detected&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|log_unit
op_assign
l_int|0
suffix:semicolon
(paren
id|log_index
OL
id|id_ctlr_buf-&gt;nr_drvs
)paren
op_logical_and
(paren
id|log_unit
OL
id|NWD
)paren
suffix:semicolon
id|log_unit
op_increment
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|ida_gendisk
(braket
id|ctlr
)braket
(braket
id|log_unit
)braket
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
id|sense_log_drv_stat_t
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Send &quot;Identify logical drive status&quot; cmd&n;&t;&t; */
id|ret_code
op_assign
id|sendcmd
c_func
(paren
id|SENSE_LOG_DRV_STAT
comma
id|ctlr
comma
id|id_lstatus_buf
comma
id|size
comma
l_int|0
comma
l_int|0
comma
id|log_unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_code
op_eq
id|IO_ERROR
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;   If can&squot;t get logical drive status, set&n;&t;&t;&t;   the logical drive map to 0, so the&n;&t;&t;&t;   idastubopen will fail for all logical drives&n;&t;&t;&t;   on the controller. &n;&t;&t;&t; */
id|info_p-&gt;log_drv_map
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray ida%d: idaGetGeometry - Controller&quot;
l_string|&quot; failed to report status of logical drive %d&bslash;n&quot;
l_string|&quot;Access to this controller has been disabled&bslash;n&quot;
comma
id|ctlr
comma
id|log_unit
)paren
suffix:semicolon
multiline_comment|/* Free all the buffers and return */
id|kfree
c_func
(paren
id|sense_config_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_lstatus_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;   Make sure the logical drive is configured&n;&t;&t; */
r_if
c_cond
(paren
id|id_lstatus_buf-&gt;status
op_ne
id|LOG_NOT_CONF
)paren
(brace
id|ret_code
op_assign
id|sendcmd
c_func
(paren
id|ID_LOG_DRV
comma
id|ctlr
comma
id|id_ldrive
comma
r_sizeof
(paren
id|id_log_drv_t
)paren
comma
l_int|0
comma
l_int|0
comma
id|log_unit
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;   If error, the bit for this&n;&t;&t;&t;   logical drive won&squot;t be set and&n;&t;&t;&t;   idastubopen will return error. &n;&t;&t;&t; */
r_if
c_cond
(paren
id|ret_code
op_ne
id|IO_ERROR
)paren
(brace
id|drv
op_assign
op_amp
id|info_p-&gt;drv
(braket
id|log_unit
)braket
suffix:semicolon
id|drv-&gt;blk_size
op_assign
id|id_ldrive-&gt;blk_size
suffix:semicolon
id|drv-&gt;nr_blks
op_assign
id|id_ldrive-&gt;nr_blks
suffix:semicolon
id|drv-&gt;cylinders
op_assign
id|id_ldrive-&gt;drv.cyl
suffix:semicolon
id|drv-&gt;heads
op_assign
id|id_ldrive-&gt;drv.heads
suffix:semicolon
id|drv-&gt;sectors
op_assign
id|id_ldrive-&gt;drv.sect_per_track
suffix:semicolon
id|info_p-&gt;log_drv_map
op_or_assign
(paren
l_int|1
op_lshift
id|log_unit
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cpqarray ida/c%dd%d: blksz=%d nr_blks=%d&bslash;n&quot;
comma
id|ctlr
comma
id|log_unit
comma
id|drv-&gt;blk_size
comma
id|drv-&gt;nr_blks
)paren
suffix:semicolon
id|ret_code
op_assign
id|sendcmd
c_func
(paren
id|SENSE_CONFIG
comma
id|ctlr
comma
id|sense_config_buf
comma
r_sizeof
(paren
id|config_t
)paren
comma
l_int|0
comma
l_int|0
comma
id|log_unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_code
op_eq
id|IO_ERROR
)paren
(brace
id|info_p-&gt;log_drv_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Free all the buffers and return */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: error sending sense config&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sense_config_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_lstatus_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|disk-&gt;devfs_name
comma
l_string|&quot;ida/c%dd%d&quot;
comma
id|ctlr
comma
id|log_unit
)paren
suffix:semicolon
id|info_p-&gt;phys_drives
op_assign
id|sense_config_buf-&gt;ctlr_phys_drv
suffix:semicolon
id|info_p-&gt;drv_assign_map
op_or_assign
id|sense_config_buf-&gt;drv_asgn_map
suffix:semicolon
id|info_p-&gt;drv_assign_map
op_or_assign
id|sense_config_buf-&gt;spare_asgn_map
suffix:semicolon
id|info_p-&gt;drv_spare_map
op_or_assign
id|sense_config_buf-&gt;spare_asgn_map
suffix:semicolon
)brace
multiline_comment|/* end of if no error on id_ldrive */
id|log_index
op_assign
id|log_index
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* end of if logical drive configured */
)brace
multiline_comment|/* end of for log_unit */
id|kfree
c_func
(paren
id|sense_config_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_lstatus_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|cpqarray_exit
r_static
r_void
id|__exit
id|cpqarray_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|pci_unregister_driver
c_func
(paren
op_amp
id|cpqarray_pci_driver
)paren
suffix:semicolon
multiline_comment|/* Double check that all controller entries have been removed */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_CTLR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Removing EISA &quot;
l_string|&quot;controller %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|cpqarray_remove_one_eisa
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
id|devfs_remove
c_func
(paren
l_string|&quot;ida&quot;
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;cpqarray&quot;
comma
id|proc_root_driver
)paren
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|cpqarray_init
)paren
id|module_exit
c_func
(paren
id|cpqarray_exit
)paren
eof
