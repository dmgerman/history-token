multiline_comment|/*&n; *  linux/drivers/block/cfq-iosched.c&n; *&n; *  CFQ, or complete fairness queueing, disk scheduler.&n; *&n; *  Based on ideas from a previously unfinished io&n; *  scheduler (round robin per-process disk scheduling) and Andrea Arcangeli.&n; *&n; *  Copyright (C) 2003 Jens Axboe &lt;axboe@suse.de&gt;&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/elevator.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/hash.h&gt;
macro_line|#include &lt;linux/rbtree.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
multiline_comment|/*&n; * tunables&n; */
DECL|variable|cfq_quantum
r_static
r_int
id|cfq_quantum
op_assign
l_int|4
suffix:semicolon
DECL|variable|cfq_queued
r_static
r_int
id|cfq_queued
op_assign
l_int|8
suffix:semicolon
DECL|macro|CFQ_QHASH_SHIFT
mdefine_line|#define CFQ_QHASH_SHIFT&t;&t;6
DECL|macro|CFQ_QHASH_ENTRIES
mdefine_line|#define CFQ_QHASH_ENTRIES&t;(1 &lt;&lt; CFQ_QHASH_SHIFT)
DECL|macro|list_entry_qhash
mdefine_line|#define list_entry_qhash(entry)&t;list_entry((entry), struct cfq_queue, cfq_hash)
DECL|macro|CFQ_MHASH_SHIFT
mdefine_line|#define CFQ_MHASH_SHIFT&t;&t;8
DECL|macro|CFQ_MHASH_BLOCK
mdefine_line|#define CFQ_MHASH_BLOCK(sec)&t;((sec) &gt;&gt; 3)
DECL|macro|CFQ_MHASH_ENTRIES
mdefine_line|#define CFQ_MHASH_ENTRIES&t;(1 &lt;&lt; CFQ_MHASH_SHIFT)
DECL|macro|CFQ_MHASH_FN
mdefine_line|#define CFQ_MHASH_FN(sec)&t;(hash_long(CFQ_MHASH_BLOCK((sec)),CFQ_MHASH_SHIFT))
DECL|macro|ON_MHASH
mdefine_line|#define ON_MHASH(crq)&t;&t;!list_empty(&amp;(crq)-&gt;hash)
DECL|macro|rq_hash_key
mdefine_line|#define rq_hash_key(rq)&t;&t;((rq)-&gt;sector + (rq)-&gt;nr_sectors)
DECL|macro|list_entry_hash
mdefine_line|#define list_entry_hash(ptr)&t;list_entry((ptr), struct cfq_rq, hash)
DECL|macro|list_entry_cfqq
mdefine_line|#define list_entry_cfqq(ptr)&t;list_entry((ptr), struct cfq_queue, cfq_list)
DECL|macro|RQ_DATA
mdefine_line|#define RQ_DATA(rq)&t;&t;((struct cfq_rq *) (rq)-&gt;elevator_private)
DECL|variable|crq_pool
r_static
id|kmem_cache_t
op_star
id|crq_pool
suffix:semicolon
DECL|variable|cfq_pool
r_static
id|kmem_cache_t
op_star
id|cfq_pool
suffix:semicolon
DECL|variable|cfq_mpool
r_static
id|mempool_t
op_star
id|cfq_mpool
suffix:semicolon
DECL|struct|cfq_data
r_struct
id|cfq_data
(brace
DECL|member|rr_list
r_struct
id|list_head
id|rr_list
suffix:semicolon
DECL|member|dispatch
r_struct
id|list_head
op_star
id|dispatch
suffix:semicolon
DECL|member|cfq_hash
r_struct
id|list_head
op_star
id|cfq_hash
suffix:semicolon
DECL|member|crq_hash
r_struct
id|list_head
op_star
id|crq_hash
suffix:semicolon
DECL|member|busy_queues
r_int
r_int
id|busy_queues
suffix:semicolon
DECL|member|max_queued
r_int
r_int
id|max_queued
suffix:semicolon
DECL|member|crq_pool
id|mempool_t
op_star
id|crq_pool
suffix:semicolon
DECL|member|queue
id|request_queue_t
op_star
id|queue
suffix:semicolon
multiline_comment|/*&n;&t; * tunables&n;&t; */
DECL|member|cfq_quantum
r_int
r_int
id|cfq_quantum
suffix:semicolon
DECL|member|cfq_queued
r_int
r_int
id|cfq_queued
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|cfq_queue
r_struct
id|cfq_queue
(brace
DECL|member|cfq_hash
r_struct
id|list_head
id|cfq_hash
suffix:semicolon
DECL|member|cfq_list
r_struct
id|list_head
id|cfq_list
suffix:semicolon
DECL|member|sort_list
r_struct
id|rb_root
id|sort_list
suffix:semicolon
DECL|member|pid
r_int
id|pid
suffix:semicolon
DECL|member|queued
r_int
id|queued
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; * with a simple addition like this, we can do io priorities. almost.&n;&t; * does need a split request free list, too.&n;&t; */
r_int
id|io_prio
macro_line|#endif
)brace
suffix:semicolon
DECL|struct|cfq_rq
r_struct
id|cfq_rq
(brace
DECL|member|rb_node
r_struct
id|rb_node
id|rb_node
suffix:semicolon
DECL|member|rb_key
id|sector_t
id|rb_key
suffix:semicolon
DECL|member|request
r_struct
id|request
op_star
id|request
suffix:semicolon
DECL|member|cfq_queue
r_struct
id|cfq_queue
op_star
id|cfq_queue
suffix:semicolon
DECL|member|hash
r_struct
id|list_head
id|hash
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
id|cfq_put_queue
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_queue
op_star
id|cfqq
)paren
suffix:semicolon
r_static
r_struct
id|cfq_queue
op_star
id|cfq_find_cfq_hash
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_int
id|pid
)paren
suffix:semicolon
r_static
r_void
id|cfq_dispatch_sort
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_queue
op_star
id|cfqq
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
suffix:semicolon
multiline_comment|/*&n; * lots of deadline iosched dupes, can be abstracted later...&n; */
DECL|function|__cfq_del_crq_hash
r_static
r_inline
r_void
id|__cfq_del_crq_hash
c_func
(paren
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|crq-&gt;hash
)paren
suffix:semicolon
)brace
DECL|function|cfq_del_crq_hash
r_static
r_inline
r_void
id|cfq_del_crq_hash
c_func
(paren
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_if
c_cond
(paren
id|ON_MHASH
c_func
(paren
id|crq
)paren
)paren
id|__cfq_del_crq_hash
c_func
(paren
id|crq
)paren
suffix:semicolon
)brace
DECL|function|cfq_remove_merge_hints
r_static
r_void
id|cfq_remove_merge_hints
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
id|cfq_del_crq_hash
c_func
(paren
id|crq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;last_merge
op_eq
id|crq-&gt;request
)paren
id|q-&gt;last_merge
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|cfq_add_crq_hash
r_static
r_inline
r_void
id|cfq_add_crq_hash
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|crq-&gt;request
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ON_MHASH
c_func
(paren
id|crq
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|crq-&gt;hash
comma
op_amp
id|cfqd-&gt;crq_hash
(braket
id|CFQ_MHASH_FN
c_func
(paren
id|rq_hash_key
c_func
(paren
id|rq
)paren
)paren
)braket
)paren
suffix:semicolon
)brace
DECL|function|cfq_find_rq_hash
r_static
r_struct
id|request
op_star
id|cfq_find_rq_hash
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
id|sector_t
id|offset
)paren
(brace
r_struct
id|list_head
op_star
id|hash_list
op_assign
op_amp
id|cfqd-&gt;crq_hash
(braket
id|CFQ_MHASH_FN
c_func
(paren
id|offset
)paren
)braket
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|next
op_assign
id|hash_list-&gt;next
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
id|next
)paren
op_ne
id|hash_list
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|list_entry_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
r_struct
id|request
op_star
id|__rq
op_assign
id|crq-&gt;request
suffix:semicolon
id|next
op_assign
id|entry-&gt;next
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|ON_MHASH
c_func
(paren
id|crq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq_mergeable
c_func
(paren
id|__rq
)paren
)paren
(brace
id|__cfq_del_crq_hash
c_func
(paren
id|crq
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq_hash_key
c_func
(paren
id|__rq
)paren
op_eq
id|offset
)paren
r_return
id|__rq
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * rb tree support functions&n; */
DECL|macro|RB_NONE
mdefine_line|#define RB_NONE&t;&t;(2)
DECL|macro|RB_EMPTY
mdefine_line|#define RB_EMPTY(node)&t;((node)-&gt;rb_node == NULL)
DECL|macro|RB_CLEAR
mdefine_line|#define RB_CLEAR(node)&t;((node)-&gt;rb_color = RB_NONE)
DECL|macro|RB_CLEAR_ROOT
mdefine_line|#define RB_CLEAR_ROOT(root)&t;((root)-&gt;rb_node = NULL)
DECL|macro|ON_RB
mdefine_line|#define ON_RB(node)&t;((node)-&gt;rb_color != RB_NONE)
DECL|macro|rb_entry_crq
mdefine_line|#define rb_entry_crq(node)&t;rb_entry((node), struct cfq_rq, rb_node)
DECL|macro|rq_rb_key
mdefine_line|#define rq_rb_key(rq)&t;&t;(rq)-&gt;sector
DECL|function|cfq_del_crq_rb
r_static
r_inline
r_void
id|cfq_del_crq_rb
c_func
(paren
r_struct
id|cfq_queue
op_star
id|cfqq
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_if
c_cond
(paren
id|ON_RB
c_func
(paren
op_amp
id|crq-&gt;rb_node
)paren
)paren
(brace
id|cfqq-&gt;queued
(braket
id|rq_data_dir
c_func
(paren
id|crq-&gt;request
)paren
)braket
op_decrement
suffix:semicolon
id|rb_erase
c_func
(paren
op_amp
id|crq-&gt;rb_node
comma
op_amp
id|cfqq-&gt;sort_list
)paren
suffix:semicolon
id|crq-&gt;cfq_queue
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_static
r_struct
id|cfq_rq
op_star
DECL|function|__cfq_add_crq_rb
id|__cfq_add_crq_rb
c_func
(paren
r_struct
id|cfq_queue
op_star
id|cfqq
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_struct
id|rb_node
op_star
op_star
id|p
op_assign
op_amp
id|cfqq-&gt;sort_list.rb_node
suffix:semicolon
r_struct
id|rb_node
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|__crq
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|__crq
op_assign
id|rb_entry_crq
c_func
(paren
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq-&gt;rb_key
OL
id|__crq-&gt;rb_key
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
id|crq-&gt;rb_key
OG
id|__crq-&gt;rb_key
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_right
suffix:semicolon
r_else
r_return
id|__crq
suffix:semicolon
)brace
id|rb_link_node
c_func
(paren
op_amp
id|crq-&gt;rb_node
comma
id|parent
comma
id|p
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
DECL|function|cfq_add_crq_rb
id|cfq_add_crq_rb
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_queue
op_star
id|cfqq
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|crq-&gt;request
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|__alias
suffix:semicolon
id|crq-&gt;rb_key
op_assign
id|rq_rb_key
c_func
(paren
id|rq
)paren
suffix:semicolon
id|cfqq-&gt;queued
(braket
id|rq_data_dir
c_func
(paren
id|rq
)paren
)braket
op_increment
suffix:semicolon
id|retry
suffix:colon
id|__alias
op_assign
id|__cfq_add_crq_rb
c_func
(paren
id|cfqq
comma
id|crq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__alias
)paren
(brace
id|rb_insert_color
c_func
(paren
op_amp
id|crq-&gt;rb_node
comma
op_amp
id|cfqq-&gt;sort_list
)paren
suffix:semicolon
id|crq-&gt;cfq_queue
op_assign
id|cfqq
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cfq_dispatch_sort
c_func
(paren
id|cfqd
comma
id|cfqq
comma
id|__alias
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
r_static
r_struct
id|request
op_star
DECL|function|cfq_find_rq_rb
id|cfq_find_rq_rb
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
id|sector_t
id|sector
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|cfq_find_cfq_hash
c_func
(paren
id|cfqd
comma
id|current-&gt;tgid
)paren
suffix:semicolon
r_struct
id|rb_node
op_star
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqq
)paren
r_goto
id|out
suffix:semicolon
id|n
op_assign
id|cfqq-&gt;sort_list.rb_node
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|rb_entry_crq
c_func
(paren
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sector
OL
id|crq-&gt;rb_key
)paren
id|n
op_assign
id|n-&gt;rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sector
OG
id|crq-&gt;rb_key
)paren
id|n
op_assign
id|n-&gt;rb_right
suffix:semicolon
r_else
r_return
id|crq-&gt;request
suffix:semicolon
)brace
id|out
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|cfq_remove_request
r_static
r_void
id|cfq_remove_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|crq-&gt;cfq_queue
suffix:semicolon
id|cfq_remove_merge_hints
c_func
(paren
id|q
comma
id|crq
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|rq-&gt;queuelist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfqq
)paren
(brace
id|cfq_del_crq_rb
c_func
(paren
id|cfqq
comma
id|crq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RB_EMPTY
c_func
(paren
op_amp
id|cfqq-&gt;sort_list
)paren
)paren
id|cfq_put_queue
c_func
(paren
id|cfqd
comma
id|cfqq
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_int
DECL|function|cfq_merge
id|cfq_merge
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
op_star
id|req
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|request
op_star
id|__rq
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|elv_try_last_merge
c_func
(paren
id|q
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|ELEVATOR_NO_MERGE
)paren
(brace
id|__rq
op_assign
id|q-&gt;last_merge
suffix:semicolon
r_goto
id|out_insert
suffix:semicolon
)brace
id|__rq
op_assign
id|cfq_find_rq_hash
c_func
(paren
id|cfqd
comma
id|bio-&gt;bi_sector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__rq
)paren
(brace
id|BUG_ON
c_func
(paren
id|__rq-&gt;sector
op_plus
id|__rq-&gt;nr_sectors
op_ne
id|bio-&gt;bi_sector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elv_rq_merge_ok
c_func
(paren
id|__rq
comma
id|bio
)paren
)paren
(brace
id|ret
op_assign
id|ELEVATOR_BACK_MERGE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|__rq
op_assign
id|cfq_find_rq_rb
c_func
(paren
id|cfqd
comma
id|bio-&gt;bi_sector
op_plus
id|bio_sectors
c_func
(paren
id|bio
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__rq
)paren
(brace
r_if
c_cond
(paren
id|elv_rq_merge_ok
c_func
(paren
id|__rq
comma
id|bio
)paren
)paren
(brace
id|ret
op_assign
id|ELEVATOR_FRONT_MERGE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_return
id|ELEVATOR_NO_MERGE
suffix:semicolon
id|out
suffix:colon
id|q-&gt;last_merge
op_assign
id|__rq
suffix:semicolon
id|out_insert
suffix:colon
op_star
id|req
op_assign
id|__rq
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cfq_merged_request
r_static
r_void
id|cfq_merged_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|req
)paren
suffix:semicolon
id|cfq_del_crq_hash
c_func
(paren
id|crq
)paren
suffix:semicolon
id|cfq_add_crq_hash
c_func
(paren
id|cfqd
comma
id|crq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ON_RB
c_func
(paren
op_amp
id|crq-&gt;rb_node
)paren
op_logical_and
(paren
id|rq_rb_key
c_func
(paren
id|req
)paren
op_ne
id|crq-&gt;rb_key
)paren
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|crq-&gt;cfq_queue
suffix:semicolon
id|cfq_del_crq_rb
c_func
(paren
id|cfqq
comma
id|crq
)paren
suffix:semicolon
id|cfq_add_crq_rb
c_func
(paren
id|cfqd
comma
id|cfqq
comma
id|crq
)paren
suffix:semicolon
)brace
id|q-&gt;last_merge
op_assign
id|req
suffix:semicolon
)brace
r_static
r_void
DECL|function|cfq_merged_requests
id|cfq_merged_requests
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_struct
id|request
op_star
id|next
)paren
(brace
id|cfq_merged_request
c_func
(paren
id|q
comma
id|req
)paren
suffix:semicolon
id|cfq_remove_request
c_func
(paren
id|q
comma
id|next
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|cfq_dispatch_sort
id|cfq_dispatch_sort
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_queue
op_star
id|cfqq
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
id|cfqd-&gt;dispatch
comma
op_star
id|entry
op_assign
id|head
suffix:semicolon
r_struct
id|request
op_star
id|__rq
suffix:semicolon
id|cfq_del_crq_rb
c_func
(paren
id|cfqq
comma
id|crq
)paren
suffix:semicolon
id|cfq_remove_merge_hints
c_func
(paren
id|cfqd-&gt;queue
comma
id|crq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|__rq
op_assign
id|list_entry_rq
c_func
(paren
id|head-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq-&gt;request-&gt;sector
OL
id|__rq-&gt;sector
)paren
(brace
id|entry
op_assign
id|head-&gt;prev
suffix:semicolon
r_goto
id|link
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|entry
op_assign
id|entry-&gt;prev
)paren
op_ne
id|head
)paren
(brace
id|__rq
op_assign
id|list_entry_rq
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq-&gt;request-&gt;sector
op_le
id|__rq-&gt;sector
)paren
r_break
suffix:semicolon
)brace
id|link
suffix:colon
id|list_add_tail
c_func
(paren
op_amp
id|crq-&gt;request-&gt;queuelist
comma
id|entry
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__cfq_dispatch_requests
id|__cfq_dispatch_requests
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_queue
op_star
id|cfqq
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|rb_entry_crq
c_func
(paren
id|rb_first
c_func
(paren
op_amp
id|cfqq-&gt;sort_list
)paren
)paren
suffix:semicolon
id|cfq_dispatch_sort
c_func
(paren
id|cfqd
comma
id|cfqq
comma
id|crq
)paren
suffix:semicolon
)brace
DECL|function|cfq_dispatch_requests
r_static
r_int
id|cfq_dispatch_requests
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|cfq_data
op_star
id|cfqd
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|tmp
suffix:semicolon
r_int
id|ret
comma
id|queued
comma
id|good_queues
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|cfqd-&gt;rr_list
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|queued
op_assign
id|ret
op_assign
l_int|0
suffix:semicolon
id|restart
suffix:colon
id|good_queues
op_assign
l_int|0
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|tmp
comma
op_amp
id|cfqd-&gt;rr_list
)paren
(brace
id|cfqq
op_assign
id|list_entry_cfqq
c_func
(paren
id|cfqd-&gt;rr_list.next
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|RB_EMPTY
c_func
(paren
op_amp
id|cfqq-&gt;sort_list
)paren
)paren
suffix:semicolon
id|__cfq_dispatch_requests
c_func
(paren
id|q
comma
id|cfqd
comma
id|cfqq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RB_EMPTY
c_func
(paren
op_amp
id|cfqq-&gt;sort_list
)paren
)paren
id|cfq_put_queue
c_func
(paren
id|cfqd
comma
id|cfqq
)paren
suffix:semicolon
r_else
id|good_queues
op_increment
suffix:semicolon
id|queued
op_increment
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|queued
OL
id|cfqd-&gt;cfq_quantum
)paren
op_logical_and
id|good_queues
)paren
r_goto
id|restart
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cfq_next_request
r_static
r_struct
id|request
op_star
id|cfq_next_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|cfqd-&gt;dispatch
)paren
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
suffix:semicolon
id|dispatch
suffix:colon
id|rq
op_assign
id|list_entry_rq
c_func
(paren
id|cfqd-&gt;dispatch-&gt;next
)paren
suffix:semicolon
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq
)paren
id|cfq_remove_merge_hints
c_func
(paren
id|q
comma
id|crq
)paren
suffix:semicolon
r_return
id|rq
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cfq_dispatch_requests
c_func
(paren
id|q
comma
id|cfqd
)paren
)paren
r_goto
id|dispatch
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|cfq_queue
op_star
DECL|function|__cfq_find_cfq_hash
id|__cfq_find_cfq_hash
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_int
id|pid
comma
r_const
r_int
id|hashval
)paren
(brace
r_struct
id|list_head
op_star
id|hash_list
op_assign
op_amp
id|cfqd-&gt;cfq_hash
(braket
id|hashval
)braket
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
id|hash_list
)paren
(brace
r_struct
id|cfq_queue
op_star
id|__cfqq
op_assign
id|list_entry_qhash
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__cfqq-&gt;pid
op_eq
id|pid
)paren
r_return
id|__cfqq
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|cfq_find_cfq_hash
r_static
r_struct
id|cfq_queue
op_star
id|cfq_find_cfq_hash
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_int
id|pid
)paren
(brace
r_const
r_int
id|hashval
op_assign
id|hash_long
c_func
(paren
id|current-&gt;tgid
comma
id|CFQ_QHASH_SHIFT
)paren
suffix:semicolon
r_return
id|__cfq_find_cfq_hash
c_func
(paren
id|cfqd
comma
id|pid
comma
id|hashval
)paren
suffix:semicolon
)brace
DECL|function|cfq_put_queue
r_static
r_void
id|cfq_put_queue
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_queue
op_star
id|cfqq
)paren
(brace
id|cfqd-&gt;busy_queues
op_decrement
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cfqq-&gt;cfq_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cfqq-&gt;cfq_hash
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|cfqq
comma
id|cfq_mpool
)paren
suffix:semicolon
)brace
DECL|function|__cfq_get_queue
r_static
r_struct
id|cfq_queue
op_star
id|__cfq_get_queue
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_int
id|pid
comma
r_int
id|gfp_mask
)paren
(brace
r_const
r_int
id|hashval
op_assign
id|hash_long
c_func
(paren
id|current-&gt;tgid
comma
id|CFQ_QHASH_SHIFT
)paren
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|__cfq_find_cfq_hash
c_func
(paren
id|cfqd
comma
id|pid
comma
id|hashval
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqq
)paren
(brace
id|cfqq
op_assign
id|mempool_alloc
c_func
(paren
id|cfq_mpool
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfqq
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cfqq-&gt;cfq_hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cfqq-&gt;cfq_list
)paren
suffix:semicolon
id|RB_CLEAR_ROOT
c_func
(paren
op_amp
id|cfqq-&gt;sort_list
)paren
suffix:semicolon
id|cfqq-&gt;pid
op_assign
id|pid
suffix:semicolon
id|cfqq-&gt;queued
(braket
l_int|0
)braket
op_assign
id|cfqq-&gt;queued
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|cfqq-&gt;cfq_hash
comma
op_amp
id|cfqd-&gt;cfq_hash
(braket
id|hashval
)braket
)paren
suffix:semicolon
)brace
)brace
r_return
id|cfqq
suffix:semicolon
)brace
DECL|function|cfq_get_queue
r_static
r_struct
id|cfq_queue
op_star
id|cfq_get_queue
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_int
id|pid
comma
r_int
id|gfp_mask
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
id|cfqd-&gt;queue
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|cfqq
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
id|cfqq
op_assign
id|__cfq_get_queue
c_func
(paren
id|cfqd
comma
id|pid
comma
id|gfp_mask
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
r_return
id|cfqq
suffix:semicolon
)brace
DECL|function|cfq_enqueue
r_static
r_void
id|cfq_enqueue
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
suffix:semicolon
id|cfqq
op_assign
id|__cfq_get_queue
c_func
(paren
id|cfqd
comma
id|current-&gt;tgid
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfqq
)paren
(brace
id|cfq_add_crq_rb
c_func
(paren
id|cfqd
comma
id|cfqq
comma
id|crq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|cfqq-&gt;cfq_list
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|cfqq-&gt;cfq_list
comma
op_amp
id|cfqd-&gt;rr_list
)paren
suffix:semicolon
id|cfqd-&gt;busy_queues
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * should can only happen if the request wasn&squot;t allocated&n;&t;&t; * through blk_alloc_request(), eg stack requests from ide-cd&n;&t;&t; * (those should be removed) _and_ we are in OOM.&n;&t;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|crq-&gt;request-&gt;queuelist
comma
id|cfqd-&gt;dispatch
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|cfq_insert_request
id|cfq_insert_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
comma
r_int
id|where
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|where
)paren
(brace
r_case
id|ELEVATOR_INSERT_BACK
suffix:colon
r_while
c_loop
(paren
id|cfq_dispatch_requests
c_func
(paren
id|q
comma
id|cfqd
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|rq-&gt;queuelist
comma
id|cfqd-&gt;dispatch
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ELEVATOR_INSERT_FRONT
suffix:colon
id|list_add
c_func
(paren
op_amp
id|rq-&gt;queuelist
comma
id|cfqd-&gt;dispatch
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ELEVATOR_INSERT_SORT
suffix:colon
id|BUG_ON
c_func
(paren
op_logical_neg
id|blk_fs_request
c_func
(paren
id|rq
)paren
)paren
suffix:semicolon
id|cfq_enqueue
c_func
(paren
id|cfqd
comma
id|crq
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: bad insert point %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|where
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq_mergeable
c_func
(paren
id|rq
)paren
)paren
(brace
id|cfq_add_crq_hash
c_func
(paren
id|cfqd
comma
id|crq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;last_merge
)paren
id|q-&gt;last_merge
op_assign
id|rq
suffix:semicolon
)brace
)brace
DECL|function|cfq_queue_empty
r_static
r_int
id|cfq_queue_empty
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|cfqd-&gt;dispatch
)paren
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|cfqd-&gt;rr_list
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|request
op_star
DECL|function|cfq_former_request
id|cfq_former_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_struct
id|rb_node
op_star
id|rbprev
op_assign
id|rb_prev
c_func
(paren
op_amp
id|crq-&gt;rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbprev
)paren
r_return
id|rb_entry_crq
c_func
(paren
id|rbprev
)paren
op_member_access_from_pointer
id|request
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_struct
id|request
op_star
DECL|function|cfq_latter_request
id|cfq_latter_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_struct
id|rb_node
op_star
id|rbnext
op_assign
id|rb_next
c_func
(paren
op_amp
id|crq-&gt;rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbnext
)paren
r_return
id|rb_entry_crq
c_func
(paren
id|rbnext
)paren
op_member_access_from_pointer
id|request
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|cfq_may_queue
r_static
r_int
id|cfq_may_queue
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|cfqq
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqd-&gt;busy_queues
)paren
r_goto
id|out
suffix:semicolon
id|cfqq
op_assign
id|cfq_find_cfq_hash
c_func
(paren
id|cfqd
comma
id|current-&gt;tgid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfqq
)paren
(brace
r_int
id|limit
op_assign
(paren
id|q-&gt;nr_requests
op_minus
id|cfqd-&gt;cfq_queued
)paren
op_div
id|cfqd-&gt;busy_queues
suffix:semicolon
r_if
c_cond
(paren
id|limit
OL
l_int|3
)paren
id|limit
op_assign
l_int|3
suffix:semicolon
r_else
r_if
c_cond
(paren
id|limit
OG
id|cfqd-&gt;max_queued
)paren
id|limit
op_assign
id|cfqd-&gt;max_queued
suffix:semicolon
r_if
c_cond
(paren
id|cfqq-&gt;queued
(braket
id|rw
)braket
OG
id|limit
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cfq_put_request
r_static
r_void
id|cfq_put_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_struct
id|request_list
op_star
id|rl
suffix:semicolon
r_int
id|other_rw
suffix:semicolon
r_if
c_cond
(paren
id|crq
)paren
(brace
id|BUG_ON
c_func
(paren
id|q-&gt;last_merge
op_eq
id|rq
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ON_MHASH
c_func
(paren
id|crq
)paren
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|crq
comma
id|cfqd-&gt;crq_pool
)paren
suffix:semicolon
id|rq-&gt;elevator_private
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * work-around for may_queue &quot;bug&quot;: if a read gets issued and refused&n;&t; * to queue because writes ate all the allowed slots and no other&n;&t; * reads are pending for this queue, it could get stuck infinitely&n;&t; * since freed_request() only checks the waitqueue for writes when&n;&t; * freeing them. or vice versa for a single write vs many reads.&n;&t; * so check here whether &quot;the other&quot; data direction might be able&n;&t; * to queue and wake them&n;&t; */
id|rl
op_assign
op_amp
id|q-&gt;rq
suffix:semicolon
id|other_rw
op_assign
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_xor
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|rl-&gt;count
(braket
id|other_rw
)braket
op_le
id|q-&gt;nr_requests
)paren
(brace
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|rl-&gt;wait
(braket
id|other_rw
)braket
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|rl-&gt;wait
(braket
id|other_rw
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|function|cfq_set_request
r_static
r_int
id|cfq_set_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator.elevator_data
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|cfqq
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|crq
suffix:semicolon
multiline_comment|/*&n;&t; * prepare a queue up front, so cfq_enqueue() doesn&squot;t have to&n;&t; */
id|cfqq
op_assign
id|cfq_get_queue
c_func
(paren
id|cfqd
comma
id|current-&gt;tgid
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqq
)paren
r_return
l_int|1
suffix:semicolon
id|crq
op_assign
id|mempool_alloc
c_func
(paren
id|cfqd-&gt;crq_pool
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq
)paren
(brace
id|RB_CLEAR
c_func
(paren
op_amp
id|crq-&gt;rb_node
)paren
suffix:semicolon
id|crq-&gt;request
op_assign
id|rq
suffix:semicolon
id|crq-&gt;cfq_queue
op_assign
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|crq-&gt;hash
)paren
suffix:semicolon
id|rq-&gt;elevator_private
op_assign
id|crq
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cfq_exit
r_static
r_void
id|cfq_exit
c_func
(paren
id|request_queue_t
op_star
id|q
comma
id|elevator_t
op_star
id|e
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|e-&gt;elevator_data
suffix:semicolon
id|e-&gt;elevator_data
op_assign
l_int|NULL
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|cfqd-&gt;crq_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cfqd-&gt;crq_hash
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cfqd-&gt;cfq_hash
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cfqd
)paren
suffix:semicolon
)brace
DECL|function|cfq_init
r_static
r_int
id|cfq_init
c_func
(paren
id|request_queue_t
op_star
id|q
comma
id|elevator_t
op_star
id|e
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
suffix:semicolon
r_int
id|i
suffix:semicolon
id|cfqd
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|cfqd
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqd
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|cfqd
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cfqd
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cfqd-&gt;rr_list
)paren
suffix:semicolon
id|cfqd-&gt;crq_hash
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|list_head
)paren
op_star
id|CFQ_MHASH_ENTRIES
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqd-&gt;crq_hash
)paren
r_goto
id|out_crqhash
suffix:semicolon
id|cfqd-&gt;cfq_hash
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|list_head
)paren
op_star
id|CFQ_QHASH_ENTRIES
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqd-&gt;cfq_hash
)paren
r_goto
id|out_cfqhash
suffix:semicolon
id|cfqd-&gt;crq_pool
op_assign
id|mempool_create
c_func
(paren
id|BLKDEV_MIN_RQ
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|crq_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqd-&gt;crq_pool
)paren
r_goto
id|out_crqpool
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CFQ_MHASH_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cfqd-&gt;crq_hash
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CFQ_QHASH_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cfqd-&gt;cfq_hash
(braket
id|i
)braket
)paren
suffix:semicolon
id|cfqd-&gt;dispatch
op_assign
op_amp
id|q-&gt;queue_head
suffix:semicolon
id|e-&gt;elevator_data
op_assign
id|cfqd
suffix:semicolon
id|cfqd-&gt;queue
op_assign
id|q
suffix:semicolon
multiline_comment|/*&n;&t; * just set it to some high value, we want anyone to be able to queue&n;&t; * some requests. fairness is handled differently&n;&t; */
id|cfqd-&gt;max_queued
op_assign
id|q-&gt;nr_requests
suffix:semicolon
id|q-&gt;nr_requests
op_assign
l_int|8192
suffix:semicolon
id|cfqd-&gt;cfq_queued
op_assign
id|cfq_queued
suffix:semicolon
id|cfqd-&gt;cfq_quantum
op_assign
id|cfq_quantum
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_crqpool
suffix:colon
id|kfree
c_func
(paren
id|cfqd-&gt;cfq_hash
)paren
suffix:semicolon
id|out_cfqhash
suffix:colon
id|kfree
c_func
(paren
id|cfqd-&gt;crq_hash
)paren
suffix:semicolon
id|out_crqhash
suffix:colon
id|kfree
c_func
(paren
id|cfqd
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|cfq_slab_setup
r_static
r_int
id|__init
id|cfq_slab_setup
c_func
(paren
r_void
)paren
(brace
id|crq_pool
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;crq_pool&quot;
comma
r_sizeof
(paren
r_struct
id|cfq_rq
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|crq_pool
)paren
id|panic
c_func
(paren
l_string|&quot;cfq_iosched: can&squot;t init crq pool&bslash;n&quot;
)paren
suffix:semicolon
id|cfq_pool
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;cfq_pool&quot;
comma
r_sizeof
(paren
r_struct
id|cfq_queue
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfq_pool
)paren
id|panic
c_func
(paren
l_string|&quot;cfq_iosched: can&squot;t init cfq pool&bslash;n&quot;
)paren
suffix:semicolon
id|cfq_mpool
op_assign
id|mempool_create
c_func
(paren
l_int|64
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|cfq_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfq_mpool
)paren
id|panic
c_func
(paren
l_string|&quot;cfq_iosched: can&squot;t init cfq mpool&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|cfq_slab_setup
id|subsys_initcall
c_func
(paren
id|cfq_slab_setup
)paren
suffix:semicolon
multiline_comment|/*&n; * sysfs parts below --&gt;&n; */
DECL|struct|cfq_fs_entry
r_struct
id|cfq_fs_entry
(brace
DECL|member|attr
r_struct
id|attribute
id|attr
suffix:semicolon
DECL|member|show
id|ssize_t
(paren
op_star
id|show
)paren
(paren
r_struct
id|cfq_data
op_star
comma
r_char
op_star
)paren
suffix:semicolon
DECL|member|store
id|ssize_t
(paren
op_star
id|store
)paren
(paren
r_struct
id|cfq_data
op_star
comma
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
)brace
suffix:semicolon
r_static
id|ssize_t
DECL|function|cfq_var_show
id|cfq_var_show
c_func
(paren
r_int
r_int
id|var
comma
r_char
op_star
id|page
)paren
(brace
r_return
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|var
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|cfq_var_store
id|cfq_var_store
c_func
(paren
r_int
r_int
op_star
id|var
comma
r_const
r_char
op_star
id|page
comma
r_int
id|count
)paren
(brace
r_char
op_star
id|p
op_assign
(paren
r_char
op_star
)paren
id|page
suffix:semicolon
op_star
id|var
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|10
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|macro|SHOW_FUNCTION
mdefine_line|#define SHOW_FUNCTION(__FUNC, __VAR)&t;&t;&t;&t;&t;&bslash;&n;static ssize_t __FUNC(struct cfq_data *cfqd, char *page)&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return cfq_var_show(__VAR, (page));&t;&t;&t;&t;&bslash;&n;}
id|SHOW_FUNCTION
c_func
(paren
id|cfq_quantum_show
comma
id|cfqd-&gt;cfq_quantum
)paren
suffix:semicolon
id|SHOW_FUNCTION
c_func
(paren
id|cfq_queued_show
comma
id|cfqd-&gt;cfq_queued
)paren
suffix:semicolon
DECL|macro|SHOW_FUNCTION
macro_line|#undef SHOW_FUNCTION
DECL|macro|STORE_FUNCTION
mdefine_line|#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX)&t;&t;&t;&t;&bslash;&n;static ssize_t __FUNC(struct cfq_data *cfqd, const char *page, size_t count)&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int ret = cfq_var_store(__PTR, (page), count);&t;&t;&t;&bslash;&n;&t;if (*(__PTR) &lt; (MIN))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;*(__PTR) = (MIN);&t;&t;&t;&t;&t;&bslash;&n;&t;else if (*(__PTR) &gt; (MAX))&t;&t;&t;&t;&t;&bslash;&n;&t;&t;*(__PTR) = (MAX);&t;&t;&t;&t;&t;&bslash;&n;&t;return ret;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
id|STORE_FUNCTION
c_func
(paren
id|cfq_quantum_store
comma
op_amp
id|cfqd-&gt;cfq_quantum
comma
l_int|1
comma
id|INT_MAX
)paren
suffix:semicolon
id|STORE_FUNCTION
c_func
(paren
id|cfq_queued_store
comma
op_amp
id|cfqd-&gt;cfq_queued
comma
l_int|1
comma
id|INT_MAX
)paren
suffix:semicolon
DECL|macro|STORE_FUNCTION
macro_line|#undef STORE_FUNCTION
DECL|variable|cfq_quantum_entry
r_static
r_struct
id|cfq_fs_entry
id|cfq_quantum_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;quantum&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|cfq_quantum_show
comma
dot
id|store
op_assign
id|cfq_quantum_store
comma
)brace
suffix:semicolon
DECL|variable|cfq_queued_entry
r_static
r_struct
id|cfq_fs_entry
id|cfq_queued_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;queued&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|cfq_queued_show
comma
dot
id|store
op_assign
id|cfq_queued_store
comma
)brace
suffix:semicolon
DECL|variable|default_attrs
r_static
r_struct
id|attribute
op_star
id|default_attrs
(braket
)braket
op_assign
(brace
op_amp
id|cfq_quantum_entry.attr
comma
op_amp
id|cfq_queued_entry.attr
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|macro|to_cfq
mdefine_line|#define to_cfq(atr) container_of((atr), struct cfq_fs_entry, attr)
r_static
id|ssize_t
DECL|function|cfq_attr_show
id|cfq_attr_show
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
comma
r_struct
id|attribute
op_star
id|attr
comma
r_char
op_star
id|page
)paren
(brace
id|elevator_t
op_star
id|e
op_assign
id|container_of
c_func
(paren
id|kobj
comma
id|elevator_t
comma
id|kobj
)paren
suffix:semicolon
r_struct
id|cfq_fs_entry
op_star
id|entry
op_assign
id|to_cfq
c_func
(paren
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;show
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|entry
op_member_access_from_pointer
id|show
c_func
(paren
id|e-&gt;elevator_data
comma
id|page
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|cfq_attr_store
id|cfq_attr_store
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
comma
r_struct
id|attribute
op_star
id|attr
comma
r_const
r_char
op_star
id|page
comma
r_int
id|length
)paren
(brace
id|elevator_t
op_star
id|e
op_assign
id|container_of
c_func
(paren
id|kobj
comma
id|elevator_t
comma
id|kobj
)paren
suffix:semicolon
r_struct
id|cfq_fs_entry
op_star
id|entry
op_assign
id|to_cfq
c_func
(paren
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;store
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|entry
op_member_access_from_pointer
id|store
c_func
(paren
id|e-&gt;elevator_data
comma
id|page
comma
id|length
)paren
suffix:semicolon
)brace
DECL|variable|cfq_sysfs_ops
r_static
r_struct
id|sysfs_ops
id|cfq_sysfs_ops
op_assign
(brace
dot
id|show
op_assign
id|cfq_attr_show
comma
dot
id|store
op_assign
id|cfq_attr_store
comma
)brace
suffix:semicolon
DECL|variable|cfq_ktype
r_struct
id|kobj_type
id|cfq_ktype
op_assign
(brace
dot
id|sysfs_ops
op_assign
op_amp
id|cfq_sysfs_ops
comma
dot
id|default_attrs
op_assign
id|default_attrs
comma
)brace
suffix:semicolon
DECL|variable|iosched_cfq
id|elevator_t
id|iosched_cfq
op_assign
(brace
dot
id|elevator_name
op_assign
l_string|&quot;cfq&quot;
comma
dot
id|elevator_ktype
op_assign
op_amp
id|cfq_ktype
comma
dot
id|elevator_merge_fn
op_assign
id|cfq_merge
comma
dot
id|elevator_merged_fn
op_assign
id|cfq_merged_request
comma
dot
id|elevator_merge_req_fn
op_assign
id|cfq_merged_requests
comma
dot
id|elevator_next_req_fn
op_assign
id|cfq_next_request
comma
dot
id|elevator_add_req_fn
op_assign
id|cfq_insert_request
comma
dot
id|elevator_remove_req_fn
op_assign
id|cfq_remove_request
comma
dot
id|elevator_queue_empty_fn
op_assign
id|cfq_queue_empty
comma
dot
id|elevator_former_req_fn
op_assign
id|cfq_former_request
comma
dot
id|elevator_latter_req_fn
op_assign
id|cfq_latter_request
comma
dot
id|elevator_set_req_fn
op_assign
id|cfq_set_request
comma
dot
id|elevator_put_req_fn
op_assign
id|cfq_put_request
comma
dot
id|elevator_may_queue_fn
op_assign
id|cfq_may_queue
comma
dot
id|elevator_init_fn
op_assign
id|cfq_init
comma
dot
id|elevator_exit_fn
op_assign
id|cfq_exit
comma
)brace
suffix:semicolon
DECL|variable|iosched_cfq
id|EXPORT_SYMBOL
c_func
(paren
id|iosched_cfq
)paren
suffix:semicolon
eof
