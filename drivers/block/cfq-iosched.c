multiline_comment|/*&n; *  linux/drivers/block/cfq-iosched.c&n; *&n; *  CFQ, or complete fairness queueing, disk scheduler.&n; *&n; *  Based on ideas from a previously unfinished io&n; *  scheduler (round robin per-process disk scheduling) and Andrea Arcangeli.&n; *&n; *  Copyright (C) 2003 Jens Axboe &lt;axboe@suse.de&gt;&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/elevator.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/hash.h&gt;
macro_line|#include &lt;linux/rbtree.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
DECL|variable|max_elapsed_crq
r_static
r_int
r_int
id|max_elapsed_crq
suffix:semicolon
DECL|variable|max_elapsed_dispatch
r_static
r_int
r_int
id|max_elapsed_dispatch
suffix:semicolon
multiline_comment|/*&n; * tunables&n; */
DECL|variable|cfq_quantum
r_static
r_int
id|cfq_quantum
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* max queue in one round of service */
DECL|variable|cfq_queued
r_static
r_int
id|cfq_queued
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* minimum rq allocate limit per-queue*/
DECL|variable|cfq_service
r_static
r_int
id|cfq_service
op_assign
id|HZ
suffix:semicolon
multiline_comment|/* period over which service is avg */
DECL|variable|cfq_fifo_expire_r
r_static
r_int
id|cfq_fifo_expire_r
op_assign
id|HZ
op_div
l_int|2
suffix:semicolon
multiline_comment|/* fifo timeout for sync requests */
DECL|variable|cfq_fifo_expire_w
r_static
r_int
id|cfq_fifo_expire_w
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
multiline_comment|/* fifo timeout for async requests */
DECL|variable|cfq_fifo_rate
r_static
r_int
id|cfq_fifo_rate
op_assign
id|HZ
op_div
l_int|8
suffix:semicolon
multiline_comment|/* fifo expiry rate */
DECL|variable|cfq_back_max
r_static
r_int
id|cfq_back_max
op_assign
l_int|16
op_star
l_int|1024
suffix:semicolon
multiline_comment|/* maximum backwards seek, in KiB */
DECL|variable|cfq_back_penalty
r_static
r_int
id|cfq_back_penalty
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* penalty of a backwards seek */
multiline_comment|/*&n; * for the hash of cfqq inside the cfqd&n; */
DECL|macro|CFQ_QHASH_SHIFT
mdefine_line|#define CFQ_QHASH_SHIFT&t;&t;6
DECL|macro|CFQ_QHASH_ENTRIES
mdefine_line|#define CFQ_QHASH_ENTRIES&t;(1 &lt;&lt; CFQ_QHASH_SHIFT)
DECL|macro|list_entry_qhash
mdefine_line|#define list_entry_qhash(entry)&t;hlist_entry((entry), struct cfq_queue, cfq_hash)
multiline_comment|/*&n; * for the hash of crq inside the cfqq&n; */
DECL|macro|CFQ_MHASH_SHIFT
mdefine_line|#define CFQ_MHASH_SHIFT&t;&t;6
DECL|macro|CFQ_MHASH_BLOCK
mdefine_line|#define CFQ_MHASH_BLOCK(sec)&t;((sec) &gt;&gt; 3)
DECL|macro|CFQ_MHASH_ENTRIES
mdefine_line|#define CFQ_MHASH_ENTRIES&t;(1 &lt;&lt; CFQ_MHASH_SHIFT)
DECL|macro|CFQ_MHASH_FN
mdefine_line|#define CFQ_MHASH_FN(sec)&t;hash_long(CFQ_MHASH_BLOCK(sec), CFQ_MHASH_SHIFT)
DECL|macro|rq_hash_key
mdefine_line|#define rq_hash_key(rq)&t;&t;((rq)-&gt;sector + (rq)-&gt;nr_sectors)
DECL|macro|list_entry_hash
mdefine_line|#define list_entry_hash(ptr)&t;hlist_entry((ptr), struct cfq_rq, hash)
DECL|macro|list_entry_cfqq
mdefine_line|#define list_entry_cfqq(ptr)&t;list_entry((ptr), struct cfq_queue, cfq_list)
DECL|macro|RQ_DATA
mdefine_line|#define RQ_DATA(rq)&t;&t;(rq)-&gt;elevator_private
multiline_comment|/*&n; * rb-tree defines&n; */
DECL|macro|RB_NONE
mdefine_line|#define RB_NONE&t;&t;&t;(2)
DECL|macro|RB_EMPTY
mdefine_line|#define RB_EMPTY(node)&t;&t;((node)-&gt;rb_node == NULL)
DECL|macro|RB_CLEAR_COLOR
mdefine_line|#define RB_CLEAR_COLOR(node)&t;(node)-&gt;rb_color = RB_NONE
DECL|macro|RB_CLEAR
mdefine_line|#define RB_CLEAR(node)&t;&t;do {&t;&bslash;&n;&t;(node)-&gt;rb_parent = NULL;&t;&bslash;&n;&t;RB_CLEAR_COLOR((node));&t;&t;&bslash;&n;&t;(node)-&gt;rb_right = NULL;&t;&bslash;&n;&t;(node)-&gt;rb_left = NULL;&t;&t;&bslash;&n;} while (0)
DECL|macro|RB_CLEAR_ROOT
mdefine_line|#define RB_CLEAR_ROOT(root)&t;((root)-&gt;rb_node = NULL)
DECL|macro|ON_RB
mdefine_line|#define ON_RB(node)&t;&t;((node)-&gt;rb_color != RB_NONE)
DECL|macro|rb_entry_crq
mdefine_line|#define rb_entry_crq(node)&t;rb_entry((node), struct cfq_rq, rb_node)
DECL|macro|rq_rb_key
mdefine_line|#define rq_rb_key(rq)&t;&t;(rq)-&gt;sector
multiline_comment|/*&n; * threshold for switching off non-tag accounting&n; */
DECL|macro|CFQ_MAX_TAG
mdefine_line|#define CFQ_MAX_TAG&t;&t;(4)
multiline_comment|/*&n; * sort key types and names&n; */
r_enum
(brace
DECL|enumerator|CFQ_KEY_PGID
id|CFQ_KEY_PGID
comma
DECL|enumerator|CFQ_KEY_TGID
id|CFQ_KEY_TGID
comma
DECL|enumerator|CFQ_KEY_UID
id|CFQ_KEY_UID
comma
DECL|enumerator|CFQ_KEY_GID
id|CFQ_KEY_GID
comma
DECL|enumerator|CFQ_KEY_LAST
id|CFQ_KEY_LAST
comma
)brace
suffix:semicolon
DECL|variable|cfq_key_types
r_static
r_char
op_star
id|cfq_key_types
(braket
)braket
op_assign
(brace
l_string|&quot;pgid&quot;
comma
l_string|&quot;tgid&quot;
comma
l_string|&quot;uid&quot;
comma
l_string|&quot;gid&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|crq_pool
r_static
id|kmem_cache_t
op_star
id|crq_pool
suffix:semicolon
DECL|variable|cfq_pool
r_static
id|kmem_cache_t
op_star
id|cfq_pool
suffix:semicolon
DECL|variable|cfq_ioc_pool
r_static
id|kmem_cache_t
op_star
id|cfq_ioc_pool
suffix:semicolon
DECL|struct|cfq_data
r_struct
id|cfq_data
(brace
DECL|member|rr_list
r_struct
id|list_head
id|rr_list
suffix:semicolon
DECL|member|empty_list
r_struct
id|list_head
id|empty_list
suffix:semicolon
DECL|member|cfq_hash
r_struct
id|hlist_head
op_star
id|cfq_hash
suffix:semicolon
DECL|member|crq_hash
r_struct
id|hlist_head
op_star
id|crq_hash
suffix:semicolon
multiline_comment|/* queues on rr_list (ie they have pending requests */
DECL|member|busy_queues
r_int
r_int
id|busy_queues
suffix:semicolon
DECL|member|max_queued
r_int
r_int
id|max_queued
suffix:semicolon
DECL|member|ref
id|atomic_t
id|ref
suffix:semicolon
DECL|member|key_type
r_int
id|key_type
suffix:semicolon
DECL|member|crq_pool
id|mempool_t
op_star
id|crq_pool
suffix:semicolon
DECL|member|queue
id|request_queue_t
op_star
id|queue
suffix:semicolon
DECL|member|last_sector
id|sector_t
id|last_sector
suffix:semicolon
DECL|member|rq_in_driver
r_int
id|rq_in_driver
suffix:semicolon
multiline_comment|/*&n;&t; * tunables, see top of file&n;&t; */
DECL|member|cfq_quantum
r_int
r_int
id|cfq_quantum
suffix:semicolon
DECL|member|cfq_queued
r_int
r_int
id|cfq_queued
suffix:semicolon
DECL|member|cfq_fifo_expire_r
r_int
r_int
id|cfq_fifo_expire_r
suffix:semicolon
DECL|member|cfq_fifo_expire_w
r_int
r_int
id|cfq_fifo_expire_w
suffix:semicolon
DECL|member|cfq_fifo_batch_expire
r_int
r_int
id|cfq_fifo_batch_expire
suffix:semicolon
DECL|member|cfq_back_penalty
r_int
r_int
id|cfq_back_penalty
suffix:semicolon
DECL|member|cfq_back_max
r_int
r_int
id|cfq_back_max
suffix:semicolon
DECL|member|find_best_crq
r_int
r_int
id|find_best_crq
suffix:semicolon
DECL|member|cfq_tagged
r_int
r_int
id|cfq_tagged
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|cfq_queue
r_struct
id|cfq_queue
(brace
multiline_comment|/* reference count */
DECL|member|ref
id|atomic_t
id|ref
suffix:semicolon
multiline_comment|/* parent cfq_data */
DECL|member|cfqd
r_struct
id|cfq_data
op_star
id|cfqd
suffix:semicolon
multiline_comment|/* hash of mergeable requests */
DECL|member|cfq_hash
r_struct
id|hlist_node
id|cfq_hash
suffix:semicolon
multiline_comment|/* hash key */
DECL|member|key
r_int
r_int
id|key
suffix:semicolon
multiline_comment|/* whether queue is on rr (or empty) list */
DECL|member|on_rr
r_int
id|on_rr
suffix:semicolon
multiline_comment|/* on either rr or empty list of cfqd */
DECL|member|cfq_list
r_struct
id|list_head
id|cfq_list
suffix:semicolon
multiline_comment|/* sorted list of pending requests */
DECL|member|sort_list
r_struct
id|rb_root
id|sort_list
suffix:semicolon
multiline_comment|/* if fifo isn&squot;t expired, next request to serve */
DECL|member|next_crq
r_struct
id|cfq_rq
op_star
id|next_crq
suffix:semicolon
multiline_comment|/* requests queued in sort_list */
DECL|member|queued
r_int
id|queued
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* currently allocated requests */
DECL|member|allocated
r_int
id|allocated
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* fifo list of requests in sort_list */
DECL|member|fifo
r_struct
id|list_head
id|fifo
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* last time fifo expired */
DECL|member|last_fifo_expire
r_int
r_int
id|last_fifo_expire
suffix:semicolon
DECL|member|key_type
r_int
id|key_type
suffix:semicolon
DECL|member|service_start
r_int
r_int
id|service_start
suffix:semicolon
DECL|member|service_used
r_int
r_int
id|service_used
suffix:semicolon
DECL|member|max_rate
r_int
r_int
id|max_rate
suffix:semicolon
multiline_comment|/* number of requests that have been handed to the driver */
DECL|member|in_flight
r_int
id|in_flight
suffix:semicolon
multiline_comment|/* number of currently allocated requests */
DECL|member|alloc_limit
r_int
id|alloc_limit
(braket
l_int|2
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|cfq_rq
r_struct
id|cfq_rq
(brace
DECL|member|rb_node
r_struct
id|rb_node
id|rb_node
suffix:semicolon
DECL|member|rb_key
id|sector_t
id|rb_key
suffix:semicolon
DECL|member|request
r_struct
id|request
op_star
id|request
suffix:semicolon
DECL|member|hash
r_struct
id|hlist_node
id|hash
suffix:semicolon
DECL|member|cfq_queue
r_struct
id|cfq_queue
op_star
id|cfq_queue
suffix:semicolon
DECL|member|io_context
r_struct
id|cfq_io_context
op_star
id|io_context
suffix:semicolon
DECL|member|service_start
r_int
r_int
id|service_start
suffix:semicolon
DECL|member|queue_start
r_int
r_int
id|queue_start
suffix:semicolon
DECL|member|in_flight
r_int
r_int
id|in_flight
suffix:colon
l_int|1
suffix:semicolon
DECL|member|accounted
r_int
r_int
id|accounted
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_sync
r_int
r_int
id|is_sync
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_write
r_int
r_int
id|is_write
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
r_static
r_struct
id|cfq_queue
op_star
id|cfq_find_cfq_hash
c_func
(paren
r_struct
id|cfq_data
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|cfq_dispatch_sort
c_func
(paren
id|request_queue_t
op_star
comma
r_struct
id|cfq_rq
op_star
)paren
suffix:semicolon
r_static
r_void
id|cfq_update_next_crq
c_func
(paren
r_struct
id|cfq_rq
op_star
)paren
suffix:semicolon
r_static
r_void
id|cfq_put_cfqd
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
)paren
suffix:semicolon
multiline_comment|/*&n; * what the fairness is based on (ie how processes are grouped and&n; * differentiated)&n; */
r_static
r_inline
r_int
r_int
DECL|function|cfq_hash_key
id|cfq_hash_key
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
multiline_comment|/*&n;&t; * optimize this so that -&gt;key_type is the offset into the struct&n;&t; */
r_switch
c_cond
(paren
id|cfqd-&gt;key_type
)paren
(brace
r_case
id|CFQ_KEY_PGID
suffix:colon
r_return
id|process_group
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_default
suffix:colon
r_case
id|CFQ_KEY_TGID
suffix:colon
r_return
id|tsk-&gt;tgid
suffix:semicolon
r_case
id|CFQ_KEY_UID
suffix:colon
r_return
id|tsk-&gt;uid
suffix:semicolon
r_case
id|CFQ_KEY_GID
suffix:colon
r_return
id|tsk-&gt;gid
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * lots of deadline iosched dupes, can be abstracted later...&n; */
DECL|function|cfq_del_crq_hash
r_static
r_inline
r_void
id|cfq_del_crq_hash
c_func
(paren
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
id|hlist_del_init
c_func
(paren
op_amp
id|crq-&gt;hash
)paren
suffix:semicolon
)brace
DECL|function|cfq_remove_merge_hints
r_static
r_void
id|cfq_remove_merge_hints
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
id|cfq_del_crq_hash
c_func
(paren
id|crq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;last_merge
op_eq
id|crq-&gt;request
)paren
id|q-&gt;last_merge
op_assign
l_int|NULL
suffix:semicolon
id|cfq_update_next_crq
c_func
(paren
id|crq
)paren
suffix:semicolon
)brace
DECL|function|cfq_add_crq_hash
r_static
r_inline
r_void
id|cfq_add_crq_hash
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_const
r_int
id|hash_idx
op_assign
id|CFQ_MHASH_FN
c_func
(paren
id|rq_hash_key
c_func
(paren
id|crq-&gt;request
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|hlist_unhashed
c_func
(paren
op_amp
id|crq-&gt;hash
)paren
)paren
suffix:semicolon
id|hlist_add_head
c_func
(paren
op_amp
id|crq-&gt;hash
comma
op_amp
id|cfqd-&gt;crq_hash
(braket
id|hash_idx
)braket
)paren
suffix:semicolon
)brace
DECL|function|cfq_find_rq_hash
r_static
r_struct
id|request
op_star
id|cfq_find_rq_hash
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
id|sector_t
id|offset
)paren
(brace
r_struct
id|hlist_head
op_star
id|hash_list
op_assign
op_amp
id|cfqd-&gt;crq_hash
(braket
id|CFQ_MHASH_FN
c_func
(paren
id|offset
)paren
)braket
suffix:semicolon
r_struct
id|hlist_node
op_star
id|entry
comma
op_star
id|next
suffix:semicolon
id|hlist_for_each_safe
c_func
(paren
id|entry
comma
id|next
comma
id|hash_list
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|list_entry_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
r_struct
id|request
op_star
id|__rq
op_assign
id|crq-&gt;request
suffix:semicolon
id|BUG_ON
c_func
(paren
id|hlist_unhashed
c_func
(paren
op_amp
id|crq-&gt;hash
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq_mergeable
c_func
(paren
id|__rq
)paren
)paren
(brace
id|cfq_del_crq_hash
c_func
(paren
id|crq
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq_hash_key
c_func
(paren
id|__rq
)paren
op_eq
id|offset
)paren
r_return
id|__rq
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Lifted from AS - choose which of crq1 and crq2 that is best served now.&n; * We choose the request that is closest to the head right now. Distance&n; * behind the head are penalized and only allowed to a certain extent.&n; */
r_static
r_struct
id|cfq_rq
op_star
DECL|function|cfq_choose_req
id|cfq_choose_req
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_rq
op_star
id|crq1
comma
r_struct
id|cfq_rq
op_star
id|crq2
)paren
(brace
id|sector_t
id|last
comma
id|s1
comma
id|s2
comma
id|d1
op_assign
l_int|0
comma
id|d2
op_assign
l_int|0
suffix:semicolon
r_int
id|r1_wrap
op_assign
l_int|0
comma
id|r2_wrap
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* requests are behind the disk head */
r_int
r_int
id|back_max
suffix:semicolon
r_if
c_cond
(paren
id|crq1
op_eq
l_int|NULL
op_logical_or
id|crq1
op_eq
id|crq2
)paren
r_return
id|crq2
suffix:semicolon
r_if
c_cond
(paren
id|crq2
op_eq
l_int|NULL
)paren
r_return
id|crq1
suffix:semicolon
id|s1
op_assign
id|crq1-&gt;request-&gt;sector
suffix:semicolon
id|s2
op_assign
id|crq2-&gt;request-&gt;sector
suffix:semicolon
id|last
op_assign
id|cfqd-&gt;last_sector
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|cfqd-&gt;queue-&gt;queue_head
)paren
)paren
(brace
r_struct
id|list_head
op_star
id|entry
op_assign
op_amp
id|cfqd-&gt;queue-&gt;queue_head
suffix:semicolon
r_int
r_int
id|distance
op_assign
op_complement
l_int|0UL
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
id|entry-&gt;prev
)paren
op_ne
op_amp
id|cfqd-&gt;queue-&gt;queue_head
)paren
(brace
id|rq
op_assign
id|list_entry_rq
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_barrier_rq
c_func
(paren
id|rq
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|distance
OL
id|abs
c_func
(paren
id|s1
op_minus
id|rq-&gt;sector
op_plus
id|rq-&gt;nr_sectors
)paren
)paren
(brace
id|distance
op_assign
id|abs
c_func
(paren
id|s1
op_minus
id|rq-&gt;sector
op_plus
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
id|last
op_assign
id|rq-&gt;sector
op_plus
id|rq-&gt;nr_sectors
suffix:semicolon
)brace
r_if
c_cond
(paren
id|distance
OL
id|abs
c_func
(paren
id|s2
op_minus
id|rq-&gt;sector
op_plus
id|rq-&gt;nr_sectors
)paren
)paren
(brace
id|distance
op_assign
id|abs
c_func
(paren
id|s2
op_minus
id|rq-&gt;sector
op_plus
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
id|last
op_assign
id|rq-&gt;sector
op_plus
id|rq-&gt;nr_sectors
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * by definition, 1KiB is 2 sectors&n;&t; */
id|back_max
op_assign
id|cfqd-&gt;cfq_back_max
op_star
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * Strict one way elevator _except_ in the case where we allow&n;&t; * short backward seeks which are biased as twice the cost of a&n;&t; * similar forward seek.&n;&t; */
r_if
c_cond
(paren
id|s1
op_ge
id|last
)paren
id|d1
op_assign
id|s1
op_minus
id|last
suffix:semicolon
r_else
r_if
c_cond
(paren
id|s1
op_plus
id|back_max
op_ge
id|last
)paren
id|d1
op_assign
(paren
id|last
op_minus
id|s1
)paren
op_star
id|cfqd-&gt;cfq_back_penalty
suffix:semicolon
r_else
id|r1_wrap
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|s2
op_ge
id|last
)paren
id|d2
op_assign
id|s2
op_minus
id|last
suffix:semicolon
r_else
r_if
c_cond
(paren
id|s2
op_plus
id|back_max
op_ge
id|last
)paren
id|d2
op_assign
(paren
id|last
op_minus
id|s2
)paren
op_star
id|cfqd-&gt;cfq_back_penalty
suffix:semicolon
r_else
id|r2_wrap
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Found required data */
r_if
c_cond
(paren
op_logical_neg
id|r1_wrap
op_logical_and
id|r2_wrap
)paren
r_return
id|crq1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|r2_wrap
op_logical_and
id|r1_wrap
)paren
r_return
id|crq2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r1_wrap
op_logical_and
id|r2_wrap
)paren
(brace
multiline_comment|/* both behind the head */
r_if
c_cond
(paren
id|s1
op_le
id|s2
)paren
r_return
id|crq1
suffix:semicolon
r_else
r_return
id|crq2
suffix:semicolon
)brace
multiline_comment|/* Both requests in front of the head */
r_if
c_cond
(paren
id|d1
OL
id|d2
)paren
r_return
id|crq1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|d2
OL
id|d1
)paren
r_return
id|crq2
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|s1
op_ge
id|s2
)paren
r_return
id|crq1
suffix:semicolon
r_else
r_return
id|crq2
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * would be nice to take fifo expire time into account as well&n; */
r_static
r_struct
id|cfq_rq
op_star
DECL|function|cfq_find_next_crq
id|cfq_find_next_crq
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_queue
op_star
id|cfqq
comma
r_struct
id|cfq_rq
op_star
id|last
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq_next
op_assign
l_int|NULL
comma
op_star
id|crq_prev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rb_node
op_star
id|rbnext
comma
op_star
id|rbprev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ON_RB
c_func
(paren
op_amp
id|last-&gt;rb_node
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rbnext
op_assign
id|rb_next
c_func
(paren
op_amp
id|last-&gt;rb_node
)paren
)paren
op_eq
l_int|NULL
)paren
id|rbnext
op_assign
id|rb_first
c_func
(paren
op_amp
id|cfqq-&gt;sort_list
)paren
suffix:semicolon
id|rbprev
op_assign
id|rb_prev
c_func
(paren
op_amp
id|last-&gt;rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbprev
)paren
id|crq_prev
op_assign
id|rb_entry_crq
c_func
(paren
id|rbprev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbnext
)paren
id|crq_next
op_assign
id|rb_entry_crq
c_func
(paren
id|rbnext
)paren
suffix:semicolon
r_return
id|cfq_choose_req
c_func
(paren
id|cfqd
comma
id|crq_next
comma
id|crq_prev
)paren
suffix:semicolon
)brace
DECL|function|cfq_update_next_crq
r_static
r_void
id|cfq_update_next_crq
c_func
(paren
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|crq-&gt;cfq_queue
suffix:semicolon
r_if
c_cond
(paren
id|cfqq-&gt;next_crq
op_eq
id|crq
)paren
id|cfqq-&gt;next_crq
op_assign
id|cfq_find_next_crq
c_func
(paren
id|cfqq-&gt;cfqd
comma
id|cfqq
comma
id|crq
)paren
suffix:semicolon
)brace
DECL|function|cfq_check_sort_rr_list
r_static
r_int
id|cfq_check_sort_rr_list
c_func
(paren
r_struct
id|cfq_queue
op_star
id|cfqq
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|cfqq-&gt;cfqd-&gt;rr_list
suffix:semicolon
r_struct
id|list_head
op_star
id|next
comma
op_star
id|prev
suffix:semicolon
multiline_comment|/*&n;&t; * list might still be ordered&n;&t; */
id|next
op_assign
id|cfqq-&gt;cfq_list.next
suffix:semicolon
r_if
c_cond
(paren
id|next
op_ne
id|head
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cnext
op_assign
id|list_entry_cfqq
c_func
(paren
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfqq-&gt;service_used
OG
id|cnext-&gt;service_used
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|prev
op_assign
id|cfqq-&gt;cfq_list.prev
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_ne
id|head
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cprev
op_assign
id|list_entry_cfqq
c_func
(paren
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfqq-&gt;service_used
OL
id|cprev-&gt;service_used
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cfq_sort_rr_list
r_static
r_void
id|cfq_sort_rr_list
c_func
(paren
r_struct
id|cfq_queue
op_star
id|cfqq
comma
r_int
id|new_queue
)paren
(brace
r_struct
id|list_head
op_star
id|entry
op_assign
op_amp
id|cfqq-&gt;cfqd-&gt;rr_list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqq-&gt;on_rr
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_queue
op_logical_and
op_logical_neg
id|cfq_check_sort_rr_list
c_func
(paren
id|cfqq
)paren
)paren
r_return
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cfqq-&gt;cfq_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * sort by our mean service_used, sub-sort by in-flight requests&n;&t; */
r_while
c_loop
(paren
(paren
id|entry
op_assign
id|entry-&gt;prev
)paren
op_ne
op_amp
id|cfqq-&gt;cfqd-&gt;rr_list
)paren
(brace
r_struct
id|cfq_queue
op_star
id|__cfqq
op_assign
id|list_entry_cfqq
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfqq-&gt;service_used
OG
id|__cfqq-&gt;service_used
)paren
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cfqq-&gt;service_used
op_eq
id|__cfqq-&gt;service_used
)paren
(brace
r_struct
id|list_head
op_star
id|prv
suffix:semicolon
r_while
c_loop
(paren
(paren
id|prv
op_assign
id|entry-&gt;prev
)paren
op_ne
op_amp
id|cfqq-&gt;cfqd-&gt;rr_list
)paren
(brace
id|__cfqq
op_assign
id|list_entry_cfqq
c_func
(paren
id|prv
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
id|__cfqq-&gt;service_used
OG
id|cfqq-&gt;service_used
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfqq-&gt;service_used
op_ne
id|__cfqq-&gt;service_used
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|cfqq-&gt;in_flight
OG
id|__cfqq-&gt;in_flight
)paren
r_break
suffix:semicolon
id|entry
op_assign
id|prv
suffix:semicolon
)brace
)brace
)brace
id|list_add
c_func
(paren
op_amp
id|cfqq-&gt;cfq_list
comma
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * add to busy list of queues for service, trying to be fair in ordering&n; * the pending list according to requests serviced&n; */
r_static
r_inline
r_void
DECL|function|cfq_add_cfqq_rr
id|cfq_add_cfqq_rr
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_queue
op_star
id|cfqq
)paren
(brace
multiline_comment|/*&n;&t; * it&squot;s currently on the empty list&n;&t; */
id|cfqq-&gt;on_rr
op_assign
l_int|1
suffix:semicolon
id|cfqd-&gt;busy_queues
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|cfqq-&gt;service_start
op_plus
id|cfq_service
)paren
)paren
id|cfqq-&gt;service_used
op_rshift_assign
l_int|3
suffix:semicolon
id|cfq_sort_rr_list
c_func
(paren
id|cfqq
comma
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|cfq_del_cfqq_rr
id|cfq_del_cfqq_rr
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_queue
op_star
id|cfqq
)paren
(brace
id|list_move
c_func
(paren
op_amp
id|cfqq-&gt;cfq_list
comma
op_amp
id|cfqd-&gt;empty_list
)paren
suffix:semicolon
id|cfqq-&gt;on_rr
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|cfqd-&gt;busy_queues
)paren
suffix:semicolon
id|cfqd-&gt;busy_queues
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; * rb tree support functions&n; */
DECL|function|cfq_del_crq_rb
r_static
r_inline
r_void
id|cfq_del_crq_rb
c_func
(paren
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|crq-&gt;cfq_queue
suffix:semicolon
r_if
c_cond
(paren
id|ON_RB
c_func
(paren
op_amp
id|crq-&gt;rb_node
)paren
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|cfqq-&gt;cfqd
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|cfqq-&gt;queued
(braket
id|crq-&gt;is_sync
)braket
)paren
suffix:semicolon
id|cfq_update_next_crq
c_func
(paren
id|crq
)paren
suffix:semicolon
id|cfqq-&gt;queued
(braket
id|crq-&gt;is_sync
)braket
op_decrement
suffix:semicolon
id|rb_erase
c_func
(paren
op_amp
id|crq-&gt;rb_node
comma
op_amp
id|cfqq-&gt;sort_list
)paren
suffix:semicolon
id|RB_CLEAR_COLOR
c_func
(paren
op_amp
id|crq-&gt;rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RB_EMPTY
c_func
(paren
op_amp
id|cfqq-&gt;sort_list
)paren
op_logical_and
id|cfqq-&gt;on_rr
)paren
id|cfq_del_cfqq_rr
c_func
(paren
id|cfqd
comma
id|cfqq
)paren
suffix:semicolon
)brace
)brace
r_static
r_struct
id|cfq_rq
op_star
DECL|function|__cfq_add_crq_rb
id|__cfq_add_crq_rb
c_func
(paren
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_struct
id|rb_node
op_star
op_star
id|p
op_assign
op_amp
id|crq-&gt;cfq_queue-&gt;sort_list.rb_node
suffix:semicolon
r_struct
id|rb_node
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|__crq
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|__crq
op_assign
id|rb_entry_crq
c_func
(paren
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq-&gt;rb_key
OL
id|__crq-&gt;rb_key
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
id|crq-&gt;rb_key
OG
id|__crq-&gt;rb_key
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_right
suffix:semicolon
r_else
r_return
id|__crq
suffix:semicolon
)brace
id|rb_link_node
c_func
(paren
op_amp
id|crq-&gt;rb_node
comma
id|parent
comma
id|p
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|cfq_add_crq_rb
r_static
r_void
id|cfq_add_crq_rb
c_func
(paren
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|crq-&gt;cfq_queue
suffix:semicolon
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|cfqq-&gt;cfqd
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|crq-&gt;request
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|__alias
suffix:semicolon
id|crq-&gt;rb_key
op_assign
id|rq_rb_key
c_func
(paren
id|rq
)paren
suffix:semicolon
id|cfqq-&gt;queued
(braket
id|crq-&gt;is_sync
)braket
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * looks a little odd, but the first insert might return an alias.&n;&t; * if that happens, put the alias on the dispatch list&n;&t; */
r_while
c_loop
(paren
(paren
id|__alias
op_assign
id|__cfq_add_crq_rb
c_func
(paren
id|crq
)paren
)paren
op_ne
l_int|NULL
)paren
id|cfq_dispatch_sort
c_func
(paren
id|cfqd-&gt;queue
comma
id|__alias
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|crq-&gt;rb_node
comma
op_amp
id|cfqq-&gt;sort_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqq-&gt;on_rr
)paren
id|cfq_add_cfqq_rr
c_func
(paren
id|cfqd
comma
id|cfqq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check if this request is a better next-serve candidate&n;&t; */
id|cfqq-&gt;next_crq
op_assign
id|cfq_choose_req
c_func
(paren
id|cfqd
comma
id|cfqq-&gt;next_crq
comma
id|crq
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|cfq_reposition_crq_rb
id|cfq_reposition_crq_rb
c_func
(paren
r_struct
id|cfq_queue
op_star
id|cfqq
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_if
c_cond
(paren
id|ON_RB
c_func
(paren
op_amp
id|crq-&gt;rb_node
)paren
)paren
(brace
id|rb_erase
c_func
(paren
op_amp
id|crq-&gt;rb_node
comma
op_amp
id|cfqq-&gt;sort_list
)paren
suffix:semicolon
id|cfqq-&gt;queued
(braket
id|crq-&gt;is_sync
)braket
op_decrement
suffix:semicolon
)brace
id|cfq_add_crq_rb
c_func
(paren
id|crq
)paren
suffix:semicolon
)brace
r_static
r_struct
id|request
op_star
DECL|function|cfq_find_rq_rb
id|cfq_find_rq_rb
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
id|sector_t
id|sector
)paren
(brace
r_const
r_int
r_int
id|key
op_assign
id|cfq_hash_key
c_func
(paren
id|cfqd
comma
id|current
)paren
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|cfq_find_cfq_hash
c_func
(paren
id|cfqd
comma
id|key
)paren
suffix:semicolon
r_struct
id|rb_node
op_star
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqq
)paren
r_goto
id|out
suffix:semicolon
id|n
op_assign
id|cfqq-&gt;sort_list.rb_node
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|rb_entry_crq
c_func
(paren
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sector
OL
id|crq-&gt;rb_key
)paren
id|n
op_assign
id|n-&gt;rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sector
OG
id|crq-&gt;rb_key
)paren
id|n
op_assign
id|n-&gt;rb_right
suffix:semicolon
r_else
r_return
id|crq-&gt;request
suffix:semicolon
)brace
id|out
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * make sure the service time gets corrected on reissue of this request&n; */
DECL|function|cfq_requeue_request
r_static
r_void
id|cfq_requeue_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|crq-&gt;cfq_queue
suffix:semicolon
r_if
c_cond
(paren
id|cfqq-&gt;cfqd-&gt;cfq_tagged
)paren
(brace
id|cfqq-&gt;service_used
op_decrement
suffix:semicolon
id|cfq_sort_rr_list
c_func
(paren
id|cfqq
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|crq-&gt;accounted
)paren
(brace
id|crq-&gt;accounted
op_assign
l_int|0
suffix:semicolon
id|cfqq-&gt;cfqd-&gt;rq_in_driver
op_decrement
suffix:semicolon
)brace
)brace
id|list_add
c_func
(paren
op_amp
id|rq-&gt;queuelist
comma
op_amp
id|q-&gt;queue_head
)paren
suffix:semicolon
)brace
DECL|function|cfq_remove_request
r_static
r_void
id|cfq_remove_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq
)paren
(brace
id|cfq_remove_merge_hints
c_func
(paren
id|q
comma
id|crq
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|rq-&gt;queuelist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq-&gt;cfq_queue
)paren
id|cfq_del_crq_rb
c_func
(paren
id|crq
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|cfq_merge
id|cfq_merge
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
op_star
id|req
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator-&gt;elevator_data
suffix:semicolon
r_struct
id|request
op_star
id|__rq
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|elv_try_last_merge
c_func
(paren
id|q
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|ELEVATOR_NO_MERGE
)paren
(brace
id|__rq
op_assign
id|q-&gt;last_merge
suffix:semicolon
r_goto
id|out_insert
suffix:semicolon
)brace
id|__rq
op_assign
id|cfq_find_rq_hash
c_func
(paren
id|cfqd
comma
id|bio-&gt;bi_sector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__rq
)paren
(brace
id|BUG_ON
c_func
(paren
id|__rq-&gt;sector
op_plus
id|__rq-&gt;nr_sectors
op_ne
id|bio-&gt;bi_sector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elv_rq_merge_ok
c_func
(paren
id|__rq
comma
id|bio
)paren
)paren
(brace
id|ret
op_assign
id|ELEVATOR_BACK_MERGE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|__rq
op_assign
id|cfq_find_rq_rb
c_func
(paren
id|cfqd
comma
id|bio-&gt;bi_sector
op_plus
id|bio_sectors
c_func
(paren
id|bio
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__rq
)paren
(brace
r_if
c_cond
(paren
id|elv_rq_merge_ok
c_func
(paren
id|__rq
comma
id|bio
)paren
)paren
(brace
id|ret
op_assign
id|ELEVATOR_FRONT_MERGE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_return
id|ELEVATOR_NO_MERGE
suffix:semicolon
id|out
suffix:colon
id|q-&gt;last_merge
op_assign
id|__rq
suffix:semicolon
id|out_insert
suffix:colon
op_star
id|req
op_assign
id|__rq
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cfq_merged_request
r_static
r_void
id|cfq_merged_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator-&gt;elevator_data
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|req
)paren
suffix:semicolon
id|cfq_del_crq_hash
c_func
(paren
id|crq
)paren
suffix:semicolon
id|cfq_add_crq_hash
c_func
(paren
id|cfqd
comma
id|crq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ON_RB
c_func
(paren
op_amp
id|crq-&gt;rb_node
)paren
op_logical_and
(paren
id|rq_rb_key
c_func
(paren
id|req
)paren
op_ne
id|crq-&gt;rb_key
)paren
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|crq-&gt;cfq_queue
suffix:semicolon
id|cfq_update_next_crq
c_func
(paren
id|crq
)paren
suffix:semicolon
id|cfq_reposition_crq_rb
c_func
(paren
id|cfqq
comma
id|crq
)paren
suffix:semicolon
)brace
id|q-&gt;last_merge
op_assign
id|req
suffix:semicolon
)brace
r_static
r_void
DECL|function|cfq_merged_requests
id|cfq_merged_requests
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
comma
r_struct
id|request
op_star
id|next
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|cnext
op_assign
id|RQ_DATA
c_func
(paren
id|next
)paren
suffix:semicolon
id|cfq_merged_request
c_func
(paren
id|q
comma
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|rq-&gt;queuelist
)paren
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|next-&gt;queuelist
)paren
)paren
(brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|cnext-&gt;queue_start
comma
id|crq-&gt;queue_start
)paren
)paren
(brace
id|list_move
c_func
(paren
op_amp
id|rq-&gt;queuelist
comma
op_amp
id|next-&gt;queuelist
)paren
suffix:semicolon
id|crq-&gt;queue_start
op_assign
id|cnext-&gt;queue_start
suffix:semicolon
)brace
)brace
id|cfq_update_next_crq
c_func
(paren
id|cnext
)paren
suffix:semicolon
id|cfq_remove_request
c_func
(paren
id|q
comma
id|next
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * we dispatch cfqd-&gt;cfq_quantum requests in total from the rr_list queues,&n; * this function sector sorts the selected request to minimize seeks. we start&n; * at cfqd-&gt;last_sector, not 0.&n; */
DECL|function|cfq_dispatch_sort
r_static
r_void
id|cfq_dispatch_sort
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator-&gt;elevator_data
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|crq-&gt;cfq_queue
suffix:semicolon
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|q-&gt;queue_head
comma
op_star
id|entry
op_assign
id|head
suffix:semicolon
r_struct
id|request
op_star
id|__rq
suffix:semicolon
id|sector_t
id|last
suffix:semicolon
id|cfq_del_crq_rb
c_func
(paren
id|crq
)paren
suffix:semicolon
id|cfq_remove_merge_hints
c_func
(paren
id|q
comma
id|crq
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|crq-&gt;request-&gt;queuelist
)paren
suffix:semicolon
id|last
op_assign
id|cfqd-&gt;last_sector
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
id|entry-&gt;prev
)paren
op_ne
id|head
)paren
(brace
id|__rq
op_assign
id|list_entry_rq
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_barrier_rq
c_func
(paren
id|crq-&gt;request
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blk_fs_request
c_func
(paren
id|crq-&gt;request
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|crq-&gt;request-&gt;sector
OG
id|__rq-&gt;sector
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|__rq-&gt;sector
OG
id|last
op_logical_and
id|crq-&gt;request-&gt;sector
OL
id|last
)paren
(brace
id|last
op_assign
id|crq-&gt;request-&gt;sector
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|cfqd-&gt;last_sector
op_assign
id|last
suffix:semicolon
id|crq-&gt;in_flight
op_assign
l_int|1
suffix:semicolon
id|cfqq-&gt;in_flight
op_increment
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|crq-&gt;request-&gt;queuelist
comma
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * return expired entry, or NULL to just start from scratch in rbtree&n; */
DECL|function|cfq_check_fifo
r_static
r_inline
r_struct
id|cfq_rq
op_star
id|cfq_check_fifo
c_func
(paren
r_struct
id|cfq_queue
op_star
id|cfqq
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|cfqq-&gt;cfqd
suffix:semicolon
r_const
r_int
id|reads
op_assign
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|cfqq-&gt;fifo
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_const
r_int
id|writes
op_assign
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|cfqq-&gt;fifo
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|crq
suffix:semicolon
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|now
comma
id|cfqq-&gt;last_fifo_expire
op_plus
id|cfqd-&gt;cfq_fifo_batch_expire
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|list_entry
c_func
(paren
id|cfqq-&gt;fifo
(braket
l_int|0
)braket
dot
id|next
comma
r_struct
id|request
comma
id|queuelist
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reads
op_logical_and
id|time_after
c_func
(paren
id|now
comma
id|crq-&gt;queue_start
op_plus
id|cfqd-&gt;cfq_fifo_expire_r
)paren
)paren
(brace
id|cfqq-&gt;last_fifo_expire
op_assign
id|now
suffix:semicolon
r_return
id|crq
suffix:semicolon
)brace
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|list_entry
c_func
(paren
id|cfqq-&gt;fifo
(braket
l_int|1
)braket
dot
id|next
comma
r_struct
id|request
comma
id|queuelist
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writes
op_logical_and
id|time_after
c_func
(paren
id|now
comma
id|crq-&gt;queue_start
op_plus
id|cfqd-&gt;cfq_fifo_expire_w
)paren
)paren
(brace
id|cfqq-&gt;last_fifo_expire
op_assign
id|now
suffix:semicolon
r_return
id|crq
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * dispatch a single request from given queue&n; */
r_static
r_inline
r_void
DECL|function|cfq_dispatch_request
id|cfq_dispatch_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_queue
op_star
id|cfqq
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
suffix:semicolon
multiline_comment|/*&n;&t; * follow expired path, else get first next available&n;&t; */
r_if
c_cond
(paren
(paren
id|crq
op_assign
id|cfq_check_fifo
c_func
(paren
id|cfqq
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cfqd-&gt;find_best_crq
)paren
id|crq
op_assign
id|cfqq-&gt;next_crq
suffix:semicolon
r_else
id|crq
op_assign
id|rb_entry_crq
c_func
(paren
id|rb_first
c_func
(paren
op_amp
id|cfqq-&gt;sort_list
)paren
)paren
suffix:semicolon
)brace
id|cfqd-&gt;last_sector
op_assign
id|crq-&gt;request-&gt;sector
op_plus
id|crq-&gt;request-&gt;nr_sectors
suffix:semicolon
multiline_comment|/*&n;&t; * finally, insert request into driver list&n;&t; */
id|cfq_dispatch_sort
c_func
(paren
id|q
comma
id|crq
)paren
suffix:semicolon
)brace
DECL|function|cfq_dispatch_requests
r_static
r_int
id|cfq_dispatch_requests
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|max_dispatch
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator-&gt;elevator_data
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|cfqq
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|tmp
suffix:semicolon
r_int
id|queued
comma
id|busy_queues
comma
id|first_round
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|cfqd-&gt;rr_list
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|queued
op_assign
l_int|0
suffix:semicolon
id|first_round
op_assign
l_int|1
suffix:semicolon
id|restart
suffix:colon
id|busy_queues
op_assign
l_int|0
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|tmp
comma
op_amp
id|cfqd-&gt;rr_list
)paren
(brace
id|cfqq
op_assign
id|list_entry_cfqq
c_func
(paren
id|entry
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|RB_EMPTY
c_func
(paren
op_amp
id|cfqq-&gt;sort_list
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * first round of queueing, only select from queues that&n;&t;&t; * don&squot;t already have io in-flight&n;&t;&t; */
r_if
c_cond
(paren
id|first_round
op_logical_and
id|cfqq-&gt;in_flight
)paren
r_continue
suffix:semicolon
id|cfq_dispatch_request
c_func
(paren
id|q
comma
id|cfqd
comma
id|cfqq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RB_EMPTY
c_func
(paren
op_amp
id|cfqq-&gt;sort_list
)paren
)paren
id|busy_queues
op_increment
suffix:semicolon
id|queued
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|queued
OL
id|max_dispatch
)paren
op_logical_and
(paren
id|busy_queues
op_logical_or
id|first_round
)paren
)paren
(brace
id|first_round
op_assign
l_int|0
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
r_return
id|queued
suffix:semicolon
)brace
DECL|function|cfq_account_dispatch
r_static
r_inline
r_void
id|cfq_account_dispatch
c_func
(paren
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|crq-&gt;cfq_queue
suffix:semicolon
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|cfqq-&gt;cfqd
suffix:semicolon
r_int
r_int
id|now
comma
id|elapsed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blk_fs_request
c_func
(paren
id|crq-&gt;request
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * accounted bit is necessary since some drivers will call&n;&t; * elv_next_request() many times for the same request (eg ide)&n;&t; */
r_if
c_cond
(paren
id|crq-&gt;accounted
)paren
r_return
suffix:semicolon
id|now
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|cfqq-&gt;service_start
op_eq
op_complement
l_int|0UL
)paren
id|cfqq-&gt;service_start
op_assign
id|now
suffix:semicolon
multiline_comment|/*&n;&t; * on drives with tagged command queueing, command turn-around time&n;&t; * doesn&squot;t necessarily reflect the time spent processing this very&n;&t; * command inside the drive. so do the accounting differently there,&n;&t; * by just sorting on the number of requests&n;&t; */
r_if
c_cond
(paren
id|cfqd-&gt;cfq_tagged
)paren
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|now
comma
id|cfqq-&gt;service_start
op_plus
id|cfq_service
)paren
)paren
(brace
id|cfqq-&gt;service_start
op_assign
id|now
suffix:semicolon
id|cfqq-&gt;service_used
op_div_assign
l_int|10
suffix:semicolon
)brace
id|cfqq-&gt;service_used
op_increment
suffix:semicolon
id|cfq_sort_rr_list
c_func
(paren
id|cfqq
comma
l_int|0
)paren
suffix:semicolon
)brace
id|elapsed
op_assign
id|now
op_minus
id|crq-&gt;queue_start
suffix:semicolon
r_if
c_cond
(paren
id|elapsed
OG
id|max_elapsed_dispatch
)paren
id|max_elapsed_dispatch
op_assign
id|elapsed
suffix:semicolon
id|crq-&gt;accounted
op_assign
l_int|1
suffix:semicolon
id|crq-&gt;service_start
op_assign
id|now
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|cfqd-&gt;rq_in_driver
op_ge
id|CFQ_MAX_TAG
op_logical_and
op_logical_neg
id|cfqd-&gt;cfq_tagged
)paren
(brace
id|cfqq-&gt;cfqd-&gt;cfq_tagged
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cfq: depth %d reached, tagging now on&bslash;n&quot;
comma
id|CFQ_MAX_TAG
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|cfq_account_completion
id|cfq_account_completion
c_func
(paren
r_struct
id|cfq_queue
op_star
id|cfqq
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|cfqq-&gt;cfqd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|crq-&gt;accounted
)paren
r_return
suffix:semicolon
id|WARN_ON
c_func
(paren
op_logical_neg
id|cfqd-&gt;rq_in_driver
)paren
suffix:semicolon
id|cfqd-&gt;rq_in_driver
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqd-&gt;cfq_tagged
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
r_int
id|duration
op_assign
id|now
op_minus
id|crq-&gt;service_start
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|now
comma
id|cfqq-&gt;service_start
op_plus
id|cfq_service
)paren
)paren
(brace
id|cfqq-&gt;service_start
op_assign
id|now
suffix:semicolon
id|cfqq-&gt;service_used
op_rshift_assign
l_int|3
suffix:semicolon
)brace
id|cfqq-&gt;service_used
op_add_assign
id|duration
suffix:semicolon
id|cfq_sort_rr_list
c_func
(paren
id|cfqq
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|duration
OG
id|max_elapsed_crq
)paren
id|max_elapsed_crq
op_assign
id|duration
suffix:semicolon
)brace
)brace
DECL|function|cfq_next_request
r_static
r_struct
id|request
op_star
id|cfq_next_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator-&gt;elevator_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|q-&gt;queue_head
)paren
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
suffix:semicolon
id|dispatch
suffix:colon
id|rq
op_assign
id|list_entry_rq
c_func
(paren
id|q-&gt;queue_head.next
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|cfq_remove_merge_hints
c_func
(paren
id|q
comma
id|crq
)paren
suffix:semicolon
id|cfq_account_dispatch
c_func
(paren
id|crq
)paren
suffix:semicolon
)brace
r_return
id|rq
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cfq_dispatch_requests
c_func
(paren
id|q
comma
id|cfqd-&gt;cfq_quantum
)paren
)paren
r_goto
id|dispatch
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * task holds one reference to the queue, dropped when task exits. each crq&n; * in-flight on this queue also holds a reference, dropped when crq is freed.&n; *&n; * queue lock must be held here.&n; */
DECL|function|cfq_put_queue
r_static
r_void
id|cfq_put_queue
c_func
(paren
r_struct
id|cfq_queue
op_star
id|cfqq
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|cfqq-&gt;ref
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|cfqq-&gt;ref
)paren
)paren
r_return
suffix:semicolon
id|BUG_ON
c_func
(paren
id|rb_first
c_func
(paren
op_amp
id|cfqq-&gt;sort_list
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|cfqq-&gt;on_rr
)paren
suffix:semicolon
id|cfq_put_cfqd
c_func
(paren
id|cfqq-&gt;cfqd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * it&squot;s on the empty list and still hashed&n;&t; */
id|list_del
c_func
(paren
op_amp
id|cfqq-&gt;cfq_list
)paren
suffix:semicolon
id|hlist_del
c_func
(paren
op_amp
id|cfqq-&gt;cfq_hash
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|cfq_pool
comma
id|cfqq
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|cfq_queue
op_star
DECL|function|__cfq_find_cfq_hash
id|__cfq_find_cfq_hash
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_int
r_int
id|key
comma
r_const
r_int
id|hashval
)paren
(brace
r_struct
id|hlist_head
op_star
id|hash_list
op_assign
op_amp
id|cfqd-&gt;cfq_hash
(braket
id|hashval
)braket
suffix:semicolon
r_struct
id|hlist_node
op_star
id|entry
comma
op_star
id|next
suffix:semicolon
id|hlist_for_each_safe
c_func
(paren
id|entry
comma
id|next
comma
id|hash_list
)paren
(brace
r_struct
id|cfq_queue
op_star
id|__cfqq
op_assign
id|list_entry_qhash
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__cfqq-&gt;key
op_eq
id|key
)paren
r_return
id|__cfqq
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_struct
id|cfq_queue
op_star
DECL|function|cfq_find_cfq_hash
id|cfq_find_cfq_hash
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_int
r_int
id|key
)paren
(brace
r_return
id|__cfq_find_cfq_hash
c_func
(paren
id|cfqd
comma
id|key
comma
id|hash_long
c_func
(paren
id|key
comma
id|CFQ_QHASH_SHIFT
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|cfq_rehash_cfqq
id|cfq_rehash_cfqq
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_queue
op_star
op_star
id|cfqq
comma
r_struct
id|cfq_io_context
op_star
id|cic
)paren
(brace
r_int
r_int
id|hashkey
op_assign
id|cfq_hash_key
c_func
(paren
id|cfqd
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|hashval
op_assign
id|hash_long
c_func
(paren
id|hashkey
comma
id|CFQ_QHASH_SHIFT
)paren
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|__cfqq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|cfqd-&gt;queue-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|hlist_del
c_func
(paren
op_amp
(paren
op_star
id|cfqq
)paren
op_member_access_from_pointer
id|cfq_hash
)paren
suffix:semicolon
id|__cfqq
op_assign
id|__cfq_find_cfq_hash
c_func
(paren
id|cfqd
comma
id|hashkey
comma
id|hashval
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__cfqq
op_logical_or
id|__cfqq
op_eq
op_star
id|cfqq
)paren
(brace
id|__cfqq
op_assign
op_star
id|cfqq
suffix:semicolon
id|hlist_add_head
c_func
(paren
op_amp
id|__cfqq-&gt;cfq_hash
comma
op_amp
id|cfqd-&gt;cfq_hash
(braket
id|hashval
)braket
)paren
suffix:semicolon
id|__cfqq-&gt;key_type
op_assign
id|cfqd-&gt;key_type
suffix:semicolon
)brace
r_else
(brace
id|atomic_inc
c_func
(paren
op_amp
id|__cfqq-&gt;ref
)paren
suffix:semicolon
id|cic-&gt;cfqq
op_assign
id|__cfqq
suffix:semicolon
id|cfq_put_queue
c_func
(paren
op_star
id|cfqq
)paren
suffix:semicolon
op_star
id|cfqq
op_assign
id|__cfqq
suffix:semicolon
)brace
id|cic-&gt;cfqq
op_assign
id|__cfqq
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|cfqd-&gt;queue-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|cfq_free_io_context
r_static
r_void
id|cfq_free_io_context
c_func
(paren
r_struct
id|cfq_io_context
op_star
id|cic
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|cfq_ioc_pool
comma
id|cic
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * locking hierarchy is: io_context lock -&gt; queue locks&n; */
DECL|function|cfq_exit_io_context
r_static
r_void
id|cfq_exit_io_context
c_func
(paren
r_struct
id|cfq_io_context
op_star
id|cic
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|cic-&gt;cfqq
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
op_assign
op_amp
id|cic-&gt;list
suffix:semicolon
id|request_queue_t
op_star
id|q
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * put the reference this task is holding to the various queues&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cic-&gt;ioc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|entry
op_assign
id|cic-&gt;list.next
)paren
op_ne
op_amp
id|cic-&gt;list
)paren
(brace
r_struct
id|cfq_io_context
op_star
id|__cic
suffix:semicolon
id|__cic
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|cfq_io_context
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|q
op_assign
id|__cic-&gt;cfqq-&gt;cfqd-&gt;queue
suffix:semicolon
id|spin_lock
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
id|cfq_put_queue
c_func
(paren
id|__cic-&gt;cfqq
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
)brace
id|q
op_assign
id|cfqq-&gt;cfqd-&gt;queue
suffix:semicolon
id|spin_lock
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
id|cfq_put_queue
c_func
(paren
id|cfqq
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
id|cic-&gt;cfqq
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cic-&gt;ioc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|cfq_alloc_io_context
r_static
r_struct
id|cfq_io_context
op_star
id|cfq_alloc_io_context
c_func
(paren
r_int
id|gfp_flags
)paren
(brace
r_struct
id|cfq_io_context
op_star
id|cic
op_assign
id|kmem_cache_alloc
c_func
(paren
id|cfq_ioc_pool
comma
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cic
)paren
(brace
id|cic-&gt;dtor
op_assign
id|cfq_free_io_context
suffix:semicolon
id|cic
op_member_access_from_pointer
m_exit
op_assign
id|cfq_exit_io_context
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cic-&gt;list
)paren
suffix:semicolon
id|cic-&gt;cfqq
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|cic
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup general io context and cfq io context. There can be several cfq&n; * io contexts per general io context, if this process is doing io to more&n; * than one device managed by cfq. Note that caller is holding a reference to&n; * cfqq, so we don&squot;t need to worry about it disappearing&n; */
r_static
r_struct
id|cfq_io_context
op_star
DECL|function|cfq_get_io_context
id|cfq_get_io_context
c_func
(paren
r_struct
id|cfq_queue
op_star
op_star
id|cfqq
comma
r_int
id|gfp_flags
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
(paren
op_star
id|cfqq
)paren
op_member_access_from_pointer
id|cfqd
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|__cfqq
op_assign
op_star
id|cfqq
suffix:semicolon
r_struct
id|cfq_io_context
op_star
id|cic
suffix:semicolon
r_struct
id|io_context
op_star
id|ioc
suffix:semicolon
id|might_sleep_if
c_func
(paren
id|gfp_flags
op_amp
id|__GFP_WAIT
)paren
suffix:semicolon
id|ioc
op_assign
id|get_io_context
c_func
(paren
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioc
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cic
op_assign
id|ioc-&gt;cic
)paren
op_eq
l_int|NULL
)paren
(brace
id|cic
op_assign
id|cfq_alloc_io_context
c_func
(paren
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cic
op_eq
l_int|NULL
)paren
r_goto
id|err
suffix:semicolon
id|ioc-&gt;cic
op_assign
id|cic
suffix:semicolon
id|cic-&gt;ioc
op_assign
id|ioc
suffix:semicolon
id|cic-&gt;cfqq
op_assign
id|__cfqq
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|__cfqq-&gt;ref
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|cfq_io_context
op_star
id|__cic
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t;&t; * since the first cic on the list is actually the head&n;&t;&t; * itself, need to check this here or we&squot;ll duplicate an&n;&t;&t; * cic per ioc for no reason&n;&t;&t; */
r_if
c_cond
(paren
id|cic-&gt;cfqq
op_eq
id|__cfqq
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;&t; * cic exists, check if we already are there. linear search&n;&t;&t; * should be ok here, the list will usually not be more than&n;&t;&t; * 1 or a few entries long&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|__cic
comma
op_amp
id|cic-&gt;list
comma
id|list
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * this process is already holding a reference to&n;&t;&t;&t; * this queue, so no need to get one more&n;&t;&t;&t; */
r_if
c_cond
(paren
id|__cic-&gt;cfqq
op_eq
id|__cfqq
)paren
(brace
id|cic
op_assign
id|__cic
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * nope, process doesn&squot;t have a cic assoicated with this&n;&t;&t; * cfqq yet. get a new one and add to list&n;&t;&t; */
id|__cic
op_assign
id|cfq_alloc_io_context
c_func
(paren
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__cic
op_eq
l_int|NULL
)paren
r_goto
id|err
suffix:semicolon
id|__cic-&gt;ioc
op_assign
id|ioc
suffix:semicolon
id|__cic-&gt;cfqq
op_assign
id|__cfqq
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|__cfqq-&gt;ref
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|__cic-&gt;list
comma
op_amp
id|cic-&gt;list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cic
op_assign
id|__cic
suffix:semicolon
op_star
id|cfqq
op_assign
id|__cfqq
suffix:semicolon
)brace
id|out
suffix:colon
multiline_comment|/*&n;&t; * if key_type has been changed on the fly, we lazily rehash&n;&t; * each queue at lookup time&n;&t; */
r_if
c_cond
(paren
(paren
op_star
id|cfqq
)paren
op_member_access_from_pointer
id|key_type
op_ne
id|cfqd-&gt;key_type
)paren
id|cfq_rehash_cfqq
c_func
(paren
id|cfqd
comma
id|cfqq
comma
id|cic
)paren
suffix:semicolon
r_return
id|cic
suffix:semicolon
id|err
suffix:colon
id|put_io_context
c_func
(paren
id|ioc
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_struct
id|cfq_queue
op_star
DECL|function|__cfq_get_queue
id|__cfq_get_queue
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_int
r_int
id|key
comma
r_int
id|gfp_mask
)paren
(brace
r_const
r_int
id|hashval
op_assign
id|hash_long
c_func
(paren
id|key
comma
id|CFQ_QHASH_SHIFT
)paren
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|cfqq
comma
op_star
id|new_cfqq
op_assign
l_int|NULL
suffix:semicolon
id|retry
suffix:colon
id|cfqq
op_assign
id|__cfq_find_cfq_hash
c_func
(paren
id|cfqd
comma
id|key
comma
id|hashval
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqq
)paren
(brace
r_if
c_cond
(paren
id|new_cfqq
)paren
(brace
id|cfqq
op_assign
id|new_cfqq
suffix:semicolon
id|new_cfqq
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|gfp_mask
op_amp
id|__GFP_WAIT
)paren
(brace
id|spin_unlock_irq
c_func
(paren
id|cfqd-&gt;queue-&gt;queue_lock
)paren
suffix:semicolon
id|new_cfqq
op_assign
id|kmem_cache_alloc
c_func
(paren
id|cfq_pool
comma
id|gfp_mask
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|cfqd-&gt;queue-&gt;queue_lock
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
r_else
r_goto
id|out
suffix:semicolon
id|memset
c_func
(paren
id|cfqq
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cfqq
)paren
)paren
suffix:semicolon
id|INIT_HLIST_NODE
c_func
(paren
op_amp
id|cfqq-&gt;cfq_hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cfqq-&gt;cfq_list
)paren
suffix:semicolon
id|RB_CLEAR_ROOT
c_func
(paren
op_amp
id|cfqq-&gt;sort_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cfqq-&gt;fifo
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cfqq-&gt;fifo
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|cfqq-&gt;key
op_assign
id|key
suffix:semicolon
id|hlist_add_head
c_func
(paren
op_amp
id|cfqq-&gt;cfq_hash
comma
op_amp
id|cfqd-&gt;cfq_hash
(braket
id|hashval
)braket
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|cfqq-&gt;ref
comma
l_int|0
)paren
suffix:semicolon
id|cfqq-&gt;cfqd
op_assign
id|cfqd
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|cfqd-&gt;ref
)paren
suffix:semicolon
id|cfqq-&gt;key_type
op_assign
id|cfqd-&gt;key_type
suffix:semicolon
id|cfqq-&gt;service_start
op_assign
op_complement
l_int|0UL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_cfqq
)paren
id|kmem_cache_free
c_func
(paren
id|cfq_pool
comma
id|new_cfqq
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|cfqq-&gt;ref
)paren
suffix:semicolon
id|out
suffix:colon
id|WARN_ON
c_func
(paren
(paren
id|gfp_mask
op_amp
id|__GFP_WAIT
)paren
op_logical_and
op_logical_neg
id|cfqq
)paren
suffix:semicolon
r_return
id|cfqq
suffix:semicolon
)brace
DECL|function|cfq_enqueue
r_static
r_void
id|cfq_enqueue
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_struct
id|cfq_rq
op_star
id|crq
)paren
(brace
id|crq-&gt;is_sync
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|crq-&gt;request
)paren
op_eq
id|READ
op_logical_or
id|current-&gt;flags
op_amp
id|PF_SYNCWRITE
)paren
id|crq-&gt;is_sync
op_assign
l_int|1
suffix:semicolon
id|cfq_add_crq_rb
c_func
(paren
id|crq
)paren
suffix:semicolon
id|crq-&gt;queue_start
op_assign
id|jiffies
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|crq-&gt;request-&gt;queuelist
comma
op_amp
id|crq-&gt;cfq_queue-&gt;fifo
(braket
id|crq-&gt;is_sync
)braket
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|cfq_insert_request
id|cfq_insert_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
comma
r_int
id|where
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator-&gt;elevator_data
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|where
)paren
(brace
r_case
id|ELEVATOR_INSERT_BACK
suffix:colon
r_while
c_loop
(paren
id|cfq_dispatch_requests
c_func
(paren
id|q
comma
id|cfqd-&gt;cfq_quantum
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|rq-&gt;queuelist
comma
op_amp
id|q-&gt;queue_head
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ELEVATOR_INSERT_FRONT
suffix:colon
id|list_add
c_func
(paren
op_amp
id|rq-&gt;queuelist
comma
op_amp
id|q-&gt;queue_head
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ELEVATOR_INSERT_SORT
suffix:colon
id|BUG_ON
c_func
(paren
op_logical_neg
id|blk_fs_request
c_func
(paren
id|rq
)paren
)paren
suffix:semicolon
id|cfq_enqueue
c_func
(paren
id|cfqd
comma
id|crq
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: bad insert point %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|where
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq_mergeable
c_func
(paren
id|rq
)paren
)paren
(brace
id|cfq_add_crq_hash
c_func
(paren
id|cfqd
comma
id|crq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;last_merge
)paren
id|q-&gt;last_merge
op_assign
id|rq
suffix:semicolon
)brace
)brace
DECL|function|cfq_queue_empty
r_static
r_int
id|cfq_queue_empty
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator-&gt;elevator_data
suffix:semicolon
r_return
id|list_empty
c_func
(paren
op_amp
id|q-&gt;queue_head
)paren
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|cfqd-&gt;rr_list
)paren
suffix:semicolon
)brace
DECL|function|cfq_completed_request
r_static
r_void
id|cfq_completed_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|cfqq
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|blk_fs_request
c_func
(paren
id|rq
)paren
)paren
)paren
r_return
suffix:semicolon
id|cfqq
op_assign
id|crq-&gt;cfq_queue
suffix:semicolon
r_if
c_cond
(paren
id|crq-&gt;in_flight
)paren
(brace
id|WARN_ON
c_func
(paren
op_logical_neg
id|cfqq-&gt;in_flight
)paren
suffix:semicolon
id|cfqq-&gt;in_flight
op_decrement
suffix:semicolon
)brace
id|cfq_account_completion
c_func
(paren
id|cfqq
comma
id|crq
)paren
suffix:semicolon
)brace
r_static
r_struct
id|request
op_star
DECL|function|cfq_former_request
id|cfq_former_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_struct
id|rb_node
op_star
id|rbprev
op_assign
id|rb_prev
c_func
(paren
op_amp
id|crq-&gt;rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbprev
)paren
r_return
id|rb_entry_crq
c_func
(paren
id|rbprev
)paren
op_member_access_from_pointer
id|request
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_struct
id|request
op_star
DECL|function|cfq_latter_request
id|cfq_latter_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_struct
id|rb_node
op_star
id|rbnext
op_assign
id|rb_next
c_func
(paren
op_amp
id|crq-&gt;rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbnext
)paren
r_return
id|rb_entry_crq
c_func
(paren
id|rbnext
)paren
op_member_access_from_pointer
id|request
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|cfq_may_queue
r_static
r_int
id|cfq_may_queue
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator-&gt;elevator_data
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|cfqq
suffix:semicolon
r_int
id|ret
op_assign
id|ELV_MQUEUE_MAY
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_MEMALLOC
)paren
r_return
id|ELV_MQUEUE_MAY
suffix:semicolon
id|cfqq
op_assign
id|cfq_find_cfq_hash
c_func
(paren
id|cfqd
comma
id|cfq_hash_key
c_func
(paren
id|cfqd
comma
id|current
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfqq
)paren
(brace
r_int
id|limit
op_assign
id|cfqd-&gt;max_queued
suffix:semicolon
r_if
c_cond
(paren
id|cfqq-&gt;allocated
(braket
id|rw
)braket
OL
id|cfqd-&gt;cfq_queued
)paren
r_return
id|ELV_MQUEUE_MUST
suffix:semicolon
r_if
c_cond
(paren
id|cfqd-&gt;busy_queues
)paren
id|limit
op_assign
id|q-&gt;nr_requests
op_div
id|cfqd-&gt;busy_queues
suffix:semicolon
r_if
c_cond
(paren
id|limit
OL
id|cfqd-&gt;cfq_queued
)paren
id|limit
op_assign
id|cfqd-&gt;cfq_queued
suffix:semicolon
r_else
r_if
c_cond
(paren
id|limit
OG
id|cfqd-&gt;max_queued
)paren
id|limit
op_assign
id|cfqd-&gt;max_queued
suffix:semicolon
r_if
c_cond
(paren
id|cfqq-&gt;allocated
(braket
id|rw
)braket
op_ge
id|limit
)paren
(brace
r_if
c_cond
(paren
id|limit
OG
id|cfqq-&gt;alloc_limit
(braket
id|rw
)braket
)paren
id|cfqq-&gt;alloc_limit
(braket
id|rw
)braket
op_assign
id|limit
suffix:semicolon
id|ret
op_assign
id|ELV_MQUEUE_NO
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cfq_check_waiters
r_static
r_void
id|cfq_check_waiters
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|cfq_queue
op_star
id|cfqq
)paren
(brace
r_struct
id|request_list
op_star
id|rl
op_assign
op_amp
id|q-&gt;rq
suffix:semicolon
r_const
r_int
id|write
op_assign
id|waitqueue_active
c_func
(paren
op_amp
id|rl-&gt;wait
(braket
id|WRITE
)braket
)paren
suffix:semicolon
r_const
r_int
id|read
op_assign
id|waitqueue_active
c_func
(paren
op_amp
id|rl-&gt;wait
(braket
id|READ
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read
op_logical_and
id|cfqq-&gt;allocated
(braket
id|READ
)braket
OL
id|cfqq-&gt;alloc_limit
(braket
id|READ
)braket
)paren
id|wake_up
c_func
(paren
op_amp
id|rl-&gt;wait
(braket
id|READ
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write
op_logical_and
id|cfqq-&gt;allocated
(braket
id|WRITE
)braket
OL
id|cfqq-&gt;alloc_limit
(braket
id|WRITE
)braket
)paren
id|wake_up
c_func
(paren
op_amp
id|rl-&gt;wait
(braket
id|WRITE
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * queue lock held here&n; */
DECL|function|cfq_put_request
r_static
r_void
id|cfq_put_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator-&gt;elevator_data
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|crq
op_assign
id|RQ_DATA
c_func
(paren
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq
)paren
(brace
r_struct
id|cfq_queue
op_star
id|cfqq
op_assign
id|crq-&gt;cfq_queue
suffix:semicolon
id|BUG_ON
c_func
(paren
id|q-&gt;last_merge
op_eq
id|rq
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|hlist_unhashed
c_func
(paren
op_amp
id|crq-&gt;hash
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq-&gt;io_context
)paren
id|put_io_context
c_func
(paren
id|crq-&gt;io_context-&gt;ioc
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|cfqq-&gt;allocated
(braket
id|crq-&gt;is_write
)braket
)paren
suffix:semicolon
id|cfqq-&gt;allocated
(braket
id|crq-&gt;is_write
)braket
op_decrement
suffix:semicolon
id|mempool_free
c_func
(paren
id|crq
comma
id|cfqd-&gt;crq_pool
)paren
suffix:semicolon
id|rq-&gt;elevator_private
op_assign
l_int|NULL
suffix:semicolon
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
id|cfq_check_waiters
c_func
(paren
id|q
comma
id|cfqq
)paren
suffix:semicolon
id|cfq_put_queue
c_func
(paren
id|cfqq
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Allocate cfq data structures associated with this request. A queue and&n; */
DECL|function|cfq_set_request
r_static
r_int
id|cfq_set_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|rq
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
op_assign
id|q-&gt;elevator-&gt;elevator_data
suffix:semicolon
r_struct
id|cfq_io_context
op_star
id|cic
suffix:semicolon
r_const
r_int
id|rw
op_assign
id|rq_data_dir
c_func
(paren
id|rq
)paren
suffix:semicolon
r_struct
id|cfq_queue
op_star
id|cfqq
comma
op_star
id|saved_cfqq
suffix:semicolon
r_struct
id|cfq_rq
op_star
id|crq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|might_sleep_if
c_func
(paren
id|gfp_mask
op_amp
id|__GFP_WAIT
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|cfqq
op_assign
id|__cfq_get_queue
c_func
(paren
id|cfqd
comma
id|cfq_hash_key
c_func
(paren
id|cfqd
comma
id|current
)paren
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqq
)paren
r_goto
id|out_lock
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|cfqq-&gt;allocated
(braket
id|rw
)braket
op_ge
id|cfqd-&gt;max_queued
)paren
r_goto
id|out_lock
suffix:semicolon
id|cfqq-&gt;allocated
(braket
id|rw
)braket
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if hashing type has changed, the cfq_queue might change here.&n;&t; */
id|saved_cfqq
op_assign
id|cfqq
suffix:semicolon
id|cic
op_assign
id|cfq_get_io_context
c_func
(paren
op_amp
id|cfqq
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cic
)paren
r_goto
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * repeat allocation checks on queue change&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|saved_cfqq
op_ne
id|cfqq
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|saved_cfqq-&gt;allocated
(braket
id|rw
)braket
op_decrement
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|crq
op_assign
id|mempool_alloc
c_func
(paren
id|cfqd-&gt;crq_pool
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crq
)paren
(brace
id|RB_CLEAR
c_func
(paren
op_amp
id|crq-&gt;rb_node
)paren
suffix:semicolon
id|crq-&gt;rb_key
op_assign
l_int|0
suffix:semicolon
id|crq-&gt;request
op_assign
id|rq
suffix:semicolon
id|INIT_HLIST_NODE
c_func
(paren
op_amp
id|crq-&gt;hash
)paren
suffix:semicolon
id|crq-&gt;cfq_queue
op_assign
id|cfqq
suffix:semicolon
id|crq-&gt;io_context
op_assign
id|cic
suffix:semicolon
id|crq-&gt;service_start
op_assign
id|crq-&gt;queue_start
op_assign
l_int|0
suffix:semicolon
id|crq-&gt;in_flight
op_assign
id|crq-&gt;accounted
op_assign
id|crq-&gt;is_sync
op_assign
l_int|0
suffix:semicolon
id|crq-&gt;is_write
op_assign
id|rw
suffix:semicolon
id|rq-&gt;elevator_private
op_assign
id|crq
suffix:semicolon
id|cfqq-&gt;alloc_limit
(braket
id|rw
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|put_io_context
c_func
(paren
id|cic-&gt;ioc
)paren
suffix:semicolon
id|err
suffix:colon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|cfqq-&gt;allocated
(braket
id|rw
)braket
op_decrement
suffix:semicolon
id|cfq_put_queue
c_func
(paren
id|cfqq
)paren
suffix:semicolon
id|out_lock
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cfq_put_cfqd
r_static
r_void
id|cfq_put_cfqd
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
id|cfqd-&gt;queue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|cfqd-&gt;ref
)paren
)paren
r_return
suffix:semicolon
id|blk_put_queue
c_func
(paren
id|q
)paren
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|cfqd-&gt;crq_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cfqd-&gt;crq_hash
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cfqd-&gt;cfq_hash
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cfqd
)paren
suffix:semicolon
)brace
DECL|function|cfq_exit_queue
r_static
r_void
id|cfq_exit_queue
c_func
(paren
id|elevator_t
op_star
id|e
)paren
(brace
id|cfq_put_cfqd
c_func
(paren
id|e-&gt;elevator_data
)paren
suffix:semicolon
)brace
DECL|function|cfq_init_queue
r_static
r_int
id|cfq_init_queue
c_func
(paren
id|request_queue_t
op_star
id|q
comma
id|elevator_t
op_star
id|e
)paren
(brace
r_struct
id|cfq_data
op_star
id|cfqd
suffix:semicolon
r_int
id|i
suffix:semicolon
id|cfqd
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|cfqd
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqd
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|cfqd
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cfqd
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cfqd-&gt;rr_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cfqd-&gt;empty_list
)paren
suffix:semicolon
id|cfqd-&gt;crq_hash
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|hlist_head
)paren
op_star
id|CFQ_MHASH_ENTRIES
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqd-&gt;crq_hash
)paren
r_goto
id|out_crqhash
suffix:semicolon
id|cfqd-&gt;cfq_hash
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|hlist_head
)paren
op_star
id|CFQ_QHASH_ENTRIES
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqd-&gt;cfq_hash
)paren
r_goto
id|out_cfqhash
suffix:semicolon
id|cfqd-&gt;crq_pool
op_assign
id|mempool_create
c_func
(paren
id|BLKDEV_MIN_RQ
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|crq_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfqd-&gt;crq_pool
)paren
r_goto
id|out_crqpool
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CFQ_MHASH_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|INIT_HLIST_HEAD
c_func
(paren
op_amp
id|cfqd-&gt;crq_hash
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CFQ_QHASH_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
id|INIT_HLIST_HEAD
c_func
(paren
op_amp
id|cfqd-&gt;cfq_hash
(braket
id|i
)braket
)paren
suffix:semicolon
id|e-&gt;elevator_data
op_assign
id|cfqd
suffix:semicolon
id|cfqd-&gt;queue
op_assign
id|q
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|q-&gt;refcnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * just set it to some high value, we want anyone to be able to queue&n;&t; * some requests. fairness is handled differently&n;&t; */
id|q-&gt;nr_requests
op_assign
l_int|1024
suffix:semicolon
id|cfqd-&gt;max_queued
op_assign
id|q-&gt;nr_requests
op_div
l_int|16
suffix:semicolon
id|q-&gt;nr_batching
op_assign
id|cfq_queued
suffix:semicolon
id|cfqd-&gt;key_type
op_assign
id|CFQ_KEY_TGID
suffix:semicolon
id|cfqd-&gt;find_best_crq
op_assign
l_int|1
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|cfqd-&gt;ref
comma
l_int|1
)paren
suffix:semicolon
id|cfqd-&gt;cfq_queued
op_assign
id|cfq_queued
suffix:semicolon
id|cfqd-&gt;cfq_quantum
op_assign
id|cfq_quantum
suffix:semicolon
id|cfqd-&gt;cfq_fifo_expire_r
op_assign
id|cfq_fifo_expire_r
suffix:semicolon
id|cfqd-&gt;cfq_fifo_expire_w
op_assign
id|cfq_fifo_expire_w
suffix:semicolon
id|cfqd-&gt;cfq_fifo_batch_expire
op_assign
id|cfq_fifo_rate
suffix:semicolon
id|cfqd-&gt;cfq_back_max
op_assign
id|cfq_back_max
suffix:semicolon
id|cfqd-&gt;cfq_back_penalty
op_assign
id|cfq_back_penalty
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_crqpool
suffix:colon
id|kfree
c_func
(paren
id|cfqd-&gt;cfq_hash
)paren
suffix:semicolon
id|out_cfqhash
suffix:colon
id|kfree
c_func
(paren
id|cfqd-&gt;crq_hash
)paren
suffix:semicolon
id|out_crqhash
suffix:colon
id|kfree
c_func
(paren
id|cfqd
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|cfq_slab_kill
r_static
r_void
id|cfq_slab_kill
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|crq_pool
)paren
id|kmem_cache_destroy
c_func
(paren
id|crq_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfq_pool
)paren
id|kmem_cache_destroy
c_func
(paren
id|cfq_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfq_ioc_pool
)paren
id|kmem_cache_destroy
c_func
(paren
id|cfq_ioc_pool
)paren
suffix:semicolon
)brace
DECL|function|cfq_slab_setup
r_static
r_int
id|__init
id|cfq_slab_setup
c_func
(paren
r_void
)paren
(brace
id|crq_pool
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;crq_pool&quot;
comma
r_sizeof
(paren
r_struct
id|cfq_rq
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|crq_pool
)paren
r_goto
id|fail
suffix:semicolon
id|cfq_pool
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;cfq_pool&quot;
comma
r_sizeof
(paren
r_struct
id|cfq_queue
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfq_pool
)paren
r_goto
id|fail
suffix:semicolon
id|cfq_ioc_pool
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;cfq_ioc_pool&quot;
comma
r_sizeof
(paren
r_struct
id|cfq_io_context
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfq_ioc_pool
)paren
r_goto
id|fail
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|cfq_slab_kill
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * sysfs parts below --&gt;&n; */
DECL|struct|cfq_fs_entry
r_struct
id|cfq_fs_entry
(brace
DECL|member|attr
r_struct
id|attribute
id|attr
suffix:semicolon
DECL|member|show
id|ssize_t
(paren
op_star
id|show
)paren
(paren
r_struct
id|cfq_data
op_star
comma
r_char
op_star
)paren
suffix:semicolon
DECL|member|store
id|ssize_t
(paren
op_star
id|store
)paren
(paren
r_struct
id|cfq_data
op_star
comma
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
)brace
suffix:semicolon
r_static
id|ssize_t
DECL|function|cfq_var_show
id|cfq_var_show
c_func
(paren
r_int
r_int
id|var
comma
r_char
op_star
id|page
)paren
(brace
r_return
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|var
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|cfq_var_store
id|cfq_var_store
c_func
(paren
r_int
r_int
op_star
id|var
comma
r_const
r_char
op_star
id|page
comma
r_int
id|count
)paren
(brace
r_char
op_star
id|p
op_assign
(paren
r_char
op_star
)paren
id|page
suffix:semicolon
op_star
id|var
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|10
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|cfq_clear_elapsed
id|cfq_clear_elapsed
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_const
r_char
op_star
id|page
comma
r_int
id|count
)paren
(brace
id|max_elapsed_dispatch
op_assign
id|max_elapsed_crq
op_assign
l_int|0
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|cfq_set_key_type
id|cfq_set_key_type
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_const
r_char
op_star
id|page
comma
r_int
id|count
)paren
(brace
id|spin_lock_irq
c_func
(paren
id|cfqd-&gt;queue-&gt;queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|page
comma
l_string|&quot;pgid&quot;
comma
l_int|4
)paren
)paren
id|cfqd-&gt;key_type
op_assign
id|CFQ_KEY_PGID
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|page
comma
l_string|&quot;tgid&quot;
comma
l_int|4
)paren
)paren
id|cfqd-&gt;key_type
op_assign
id|CFQ_KEY_TGID
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|page
comma
l_string|&quot;uid&quot;
comma
l_int|3
)paren
)paren
id|cfqd-&gt;key_type
op_assign
id|CFQ_KEY_UID
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|page
comma
l_string|&quot;gid&quot;
comma
l_int|3
)paren
)paren
id|cfqd-&gt;key_type
op_assign
id|CFQ_KEY_GID
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|cfqd-&gt;queue-&gt;queue_lock
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|cfq_read_key_type
id|cfq_read_key_type
c_func
(paren
r_struct
id|cfq_data
op_star
id|cfqd
comma
r_char
op_star
id|page
)paren
(brace
id|ssize_t
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|CFQ_KEY_PGID
suffix:semicolon
id|i
OL
id|CFQ_KEY_LAST
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cfqd-&gt;key_type
op_eq
id|i
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;[%s] &quot;
comma
id|cfq_key_types
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%s &quot;
comma
id|cfq_key_types
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|macro|SHOW_FUNCTION
mdefine_line|#define SHOW_FUNCTION(__FUNC, __VAR, __CONV)&t;&t;&t;&t;&bslash;&n;static ssize_t __FUNC(struct cfq_data *cfqd, char *page)&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;unsigned int __data = __VAR;&t;&t;&t;&t;&t;&bslash;&n;&t;if (__CONV)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__data = jiffies_to_msecs(__data);&t;&t;&t;&bslash;&n;&t;return cfq_var_show(__data, (page));&t;&t;&t;&t;&bslash;&n;}
id|SHOW_FUNCTION
c_func
(paren
id|cfq_quantum_show
comma
id|cfqd-&gt;cfq_quantum
comma
l_int|0
)paren
suffix:semicolon
id|SHOW_FUNCTION
c_func
(paren
id|cfq_queued_show
comma
id|cfqd-&gt;cfq_queued
comma
l_int|0
)paren
suffix:semicolon
id|SHOW_FUNCTION
c_func
(paren
id|cfq_fifo_expire_r_show
comma
id|cfqd-&gt;cfq_fifo_expire_r
comma
l_int|1
)paren
suffix:semicolon
id|SHOW_FUNCTION
c_func
(paren
id|cfq_fifo_expire_w_show
comma
id|cfqd-&gt;cfq_fifo_expire_w
comma
l_int|1
)paren
suffix:semicolon
id|SHOW_FUNCTION
c_func
(paren
id|cfq_fifo_batch_expire_show
comma
id|cfqd-&gt;cfq_fifo_batch_expire
comma
l_int|1
)paren
suffix:semicolon
id|SHOW_FUNCTION
c_func
(paren
id|cfq_find_best_show
comma
id|cfqd-&gt;find_best_crq
comma
l_int|0
)paren
suffix:semicolon
id|SHOW_FUNCTION
c_func
(paren
id|cfq_back_max_show
comma
id|cfqd-&gt;cfq_back_max
comma
l_int|0
)paren
suffix:semicolon
id|SHOW_FUNCTION
c_func
(paren
id|cfq_back_penalty_show
comma
id|cfqd-&gt;cfq_back_penalty
comma
l_int|0
)paren
suffix:semicolon
DECL|macro|SHOW_FUNCTION
macro_line|#undef SHOW_FUNCTION
DECL|macro|STORE_FUNCTION
mdefine_line|#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX, __CONV)&t;&t;&t;&bslash;&n;static ssize_t __FUNC(struct cfq_data *cfqd, const char *page, size_t count)&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;unsigned int __data;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int ret = cfq_var_store(&amp;__data, (page), count);&t;&t;&bslash;&n;&t;if (__data &lt; (MIN))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__data = (MIN);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (__data &gt; (MAX))&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__data = (MAX);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (__CONV)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;*(__PTR) = msecs_to_jiffies(__data);&t;&t;&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;*(__PTR) = __data;&t;&t;&t;&t;&t;&bslash;&n;&t;return ret;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
id|STORE_FUNCTION
c_func
(paren
id|cfq_quantum_store
comma
op_amp
id|cfqd-&gt;cfq_quantum
comma
l_int|1
comma
id|UINT_MAX
comma
l_int|0
)paren
suffix:semicolon
id|STORE_FUNCTION
c_func
(paren
id|cfq_queued_store
comma
op_amp
id|cfqd-&gt;cfq_queued
comma
l_int|1
comma
id|UINT_MAX
comma
l_int|0
)paren
suffix:semicolon
id|STORE_FUNCTION
c_func
(paren
id|cfq_fifo_expire_r_store
comma
op_amp
id|cfqd-&gt;cfq_fifo_expire_r
comma
l_int|1
comma
id|UINT_MAX
comma
l_int|1
)paren
suffix:semicolon
id|STORE_FUNCTION
c_func
(paren
id|cfq_fifo_expire_w_store
comma
op_amp
id|cfqd-&gt;cfq_fifo_expire_w
comma
l_int|1
comma
id|UINT_MAX
comma
l_int|1
)paren
suffix:semicolon
id|STORE_FUNCTION
c_func
(paren
id|cfq_fifo_batch_expire_store
comma
op_amp
id|cfqd-&gt;cfq_fifo_batch_expire
comma
l_int|0
comma
id|UINT_MAX
comma
l_int|1
)paren
suffix:semicolon
id|STORE_FUNCTION
c_func
(paren
id|cfq_find_best_store
comma
op_amp
id|cfqd-&gt;find_best_crq
comma
l_int|0
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|STORE_FUNCTION
c_func
(paren
id|cfq_back_max_store
comma
op_amp
id|cfqd-&gt;cfq_back_max
comma
l_int|0
comma
id|UINT_MAX
comma
l_int|0
)paren
suffix:semicolon
id|STORE_FUNCTION
c_func
(paren
id|cfq_back_penalty_store
comma
op_amp
id|cfqd-&gt;cfq_back_penalty
comma
l_int|1
comma
id|UINT_MAX
comma
l_int|0
)paren
suffix:semicolon
DECL|macro|STORE_FUNCTION
macro_line|#undef STORE_FUNCTION
DECL|variable|cfq_quantum_entry
r_static
r_struct
id|cfq_fs_entry
id|cfq_quantum_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;quantum&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|cfq_quantum_show
comma
dot
id|store
op_assign
id|cfq_quantum_store
comma
)brace
suffix:semicolon
DECL|variable|cfq_queued_entry
r_static
r_struct
id|cfq_fs_entry
id|cfq_queued_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;queued&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|cfq_queued_show
comma
dot
id|store
op_assign
id|cfq_queued_store
comma
)brace
suffix:semicolon
DECL|variable|cfq_fifo_expire_r_entry
r_static
r_struct
id|cfq_fs_entry
id|cfq_fifo_expire_r_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;fifo_expire_sync&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|cfq_fifo_expire_r_show
comma
dot
id|store
op_assign
id|cfq_fifo_expire_r_store
comma
)brace
suffix:semicolon
DECL|variable|cfq_fifo_expire_w_entry
r_static
r_struct
id|cfq_fs_entry
id|cfq_fifo_expire_w_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;fifo_expire_async&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|cfq_fifo_expire_w_show
comma
dot
id|store
op_assign
id|cfq_fifo_expire_w_store
comma
)brace
suffix:semicolon
DECL|variable|cfq_fifo_batch_expire_entry
r_static
r_struct
id|cfq_fs_entry
id|cfq_fifo_batch_expire_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;fifo_batch_expire&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|cfq_fifo_batch_expire_show
comma
dot
id|store
op_assign
id|cfq_fifo_batch_expire_store
comma
)brace
suffix:semicolon
DECL|variable|cfq_find_best_entry
r_static
r_struct
id|cfq_fs_entry
id|cfq_find_best_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;find_best_crq&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|cfq_find_best_show
comma
dot
id|store
op_assign
id|cfq_find_best_store
comma
)brace
suffix:semicolon
DECL|variable|cfq_back_max_entry
r_static
r_struct
id|cfq_fs_entry
id|cfq_back_max_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;back_seek_max&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|cfq_back_max_show
comma
dot
id|store
op_assign
id|cfq_back_max_store
comma
)brace
suffix:semicolon
DECL|variable|cfq_back_penalty_entry
r_static
r_struct
id|cfq_fs_entry
id|cfq_back_penalty_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;back_seek_penalty&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|cfq_back_penalty_show
comma
dot
id|store
op_assign
id|cfq_back_penalty_store
comma
)brace
suffix:semicolon
DECL|variable|cfq_clear_elapsed_entry
r_static
r_struct
id|cfq_fs_entry
id|cfq_clear_elapsed_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;clear_elapsed&quot;
comma
dot
id|mode
op_assign
id|S_IWUSR
)brace
comma
dot
id|store
op_assign
id|cfq_clear_elapsed
comma
)brace
suffix:semicolon
DECL|variable|cfq_key_type_entry
r_static
r_struct
id|cfq_fs_entry
id|cfq_key_type_entry
op_assign
(brace
dot
id|attr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;key_type&quot;
comma
dot
id|mode
op_assign
id|S_IRUGO
op_or
id|S_IWUSR
)brace
comma
dot
id|show
op_assign
id|cfq_read_key_type
comma
dot
id|store
op_assign
id|cfq_set_key_type
comma
)brace
suffix:semicolon
DECL|variable|default_attrs
r_static
r_struct
id|attribute
op_star
id|default_attrs
(braket
)braket
op_assign
(brace
op_amp
id|cfq_quantum_entry.attr
comma
op_amp
id|cfq_queued_entry.attr
comma
op_amp
id|cfq_fifo_expire_r_entry.attr
comma
op_amp
id|cfq_fifo_expire_w_entry.attr
comma
op_amp
id|cfq_fifo_batch_expire_entry.attr
comma
op_amp
id|cfq_key_type_entry.attr
comma
op_amp
id|cfq_find_best_entry.attr
comma
op_amp
id|cfq_back_max_entry.attr
comma
op_amp
id|cfq_back_penalty_entry.attr
comma
op_amp
id|cfq_clear_elapsed_entry.attr
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|macro|to_cfq
mdefine_line|#define to_cfq(atr) container_of((atr), struct cfq_fs_entry, attr)
r_static
id|ssize_t
DECL|function|cfq_attr_show
id|cfq_attr_show
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
comma
r_struct
id|attribute
op_star
id|attr
comma
r_char
op_star
id|page
)paren
(brace
id|elevator_t
op_star
id|e
op_assign
id|container_of
c_func
(paren
id|kobj
comma
id|elevator_t
comma
id|kobj
)paren
suffix:semicolon
r_struct
id|cfq_fs_entry
op_star
id|entry
op_assign
id|to_cfq
c_func
(paren
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;show
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|entry
op_member_access_from_pointer
id|show
c_func
(paren
id|e-&gt;elevator_data
comma
id|page
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|cfq_attr_store
id|cfq_attr_store
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
comma
r_struct
id|attribute
op_star
id|attr
comma
r_const
r_char
op_star
id|page
comma
r_int
id|length
)paren
(brace
id|elevator_t
op_star
id|e
op_assign
id|container_of
c_func
(paren
id|kobj
comma
id|elevator_t
comma
id|kobj
)paren
suffix:semicolon
r_struct
id|cfq_fs_entry
op_star
id|entry
op_assign
id|to_cfq
c_func
(paren
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;store
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|entry
op_member_access_from_pointer
id|store
c_func
(paren
id|e-&gt;elevator_data
comma
id|page
comma
id|length
)paren
suffix:semicolon
)brace
DECL|variable|cfq_sysfs_ops
r_static
r_struct
id|sysfs_ops
id|cfq_sysfs_ops
op_assign
(brace
dot
id|show
op_assign
id|cfq_attr_show
comma
dot
id|store
op_assign
id|cfq_attr_store
comma
)brace
suffix:semicolon
DECL|variable|cfq_ktype
r_struct
id|kobj_type
id|cfq_ktype
op_assign
(brace
dot
id|sysfs_ops
op_assign
op_amp
id|cfq_sysfs_ops
comma
dot
id|default_attrs
op_assign
id|default_attrs
comma
)brace
suffix:semicolon
DECL|variable|iosched_cfq
r_static
r_struct
id|elevator_type
id|iosched_cfq
op_assign
(brace
dot
id|ops
op_assign
(brace
dot
id|elevator_merge_fn
op_assign
id|cfq_merge
comma
dot
id|elevator_merged_fn
op_assign
id|cfq_merged_request
comma
dot
id|elevator_merge_req_fn
op_assign
id|cfq_merged_requests
comma
dot
id|elevator_next_req_fn
op_assign
id|cfq_next_request
comma
dot
id|elevator_add_req_fn
op_assign
id|cfq_insert_request
comma
dot
id|elevator_remove_req_fn
op_assign
id|cfq_remove_request
comma
dot
id|elevator_requeue_req_fn
op_assign
id|cfq_requeue_request
comma
dot
id|elevator_queue_empty_fn
op_assign
id|cfq_queue_empty
comma
dot
id|elevator_completed_req_fn
op_assign
id|cfq_completed_request
comma
dot
id|elevator_former_req_fn
op_assign
id|cfq_former_request
comma
dot
id|elevator_latter_req_fn
op_assign
id|cfq_latter_request
comma
dot
id|elevator_set_req_fn
op_assign
id|cfq_set_request
comma
dot
id|elevator_put_req_fn
op_assign
id|cfq_put_request
comma
dot
id|elevator_may_queue_fn
op_assign
id|cfq_may_queue
comma
dot
id|elevator_init_fn
op_assign
id|cfq_init_queue
comma
dot
id|elevator_exit_fn
op_assign
id|cfq_exit_queue
comma
)brace
comma
dot
id|elevator_ktype
op_assign
op_amp
id|cfq_ktype
comma
dot
id|elevator_name
op_assign
l_string|&quot;cfq&quot;
comma
dot
id|elevator_owner
op_assign
id|THIS_MODULE
comma
)brace
suffix:semicolon
DECL|function|cfq_init
r_int
id|cfq_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|cfq_slab_setup
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ret
op_assign
id|elv_register
c_func
(paren
op_amp
id|iosched_cfq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|__module_get
c_func
(paren
id|THIS_MODULE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cfq_slab_kill
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cfq_exit
r_static
r_void
id|__exit
id|cfq_exit
c_func
(paren
r_void
)paren
(brace
id|cfq_slab_kill
c_func
(paren
)paren
suffix:semicolon
id|elv_unregister
c_func
(paren
op_amp
id|iosched_cfq
)paren
suffix:semicolon
)brace
DECL|variable|cfq_init
id|module_init
c_func
(paren
id|cfq_init
)paren
suffix:semicolon
DECL|variable|cfq_exit
id|module_exit
c_func
(paren
id|cfq_exit
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Jens Axboe&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Completely Fair Queueing IO scheduler&quot;
)paren
suffix:semicolon
eof
