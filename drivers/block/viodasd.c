multiline_comment|/* -*- linux-c -*-&n; * viodasd.c&n; *  Authors: Dave Boutcher &lt;boutcher@us.ibm.com&gt;&n; *           Ryan Arnold &lt;ryanarn@us.ibm.com&gt;&n; *           Colin Devilbiss &lt;devilbis@us.ibm.com&gt;&n; *           Stephen Rothwell &lt;sfr@au1.ibm.com&gt;&n; *&n; * (C) Copyright 2000-2004 IBM Corporation&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as&n; * published by the Free Software Foundation; either version 2 of the&n; * License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; *&n; * This routine provides access to disk space (termed &quot;DASD&quot; in historical&n; * IBM terms) owned and managed by an OS/400 partition running on the&n; * same box as this Linux partition.&n; *&n; * All disk operations are performed by sending messages back and forth to&n; * the OS/400 partition.&n; */
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/dma-mapping.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/vio.h&gt;
macro_line|#include &lt;asm/iSeries/HvTypes.h&gt;
macro_line|#include &lt;asm/iSeries/HvLpEvent.h&gt;
macro_line|#include &lt;asm/iSeries/HvLpConfig.h&gt;
macro_line|#include &lt;asm/iSeries/vio.h&gt;
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;iSeries Virtual DASD&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Dave Boutcher&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * We only support 7 partitions per physical disk....so with minor&n; * numbers 0-255 we get a maximum of 32 disks.&n; */
DECL|macro|VIOD_GENHD_NAME
mdefine_line|#define VIOD_GENHD_NAME&t;&t;&quot;iseries/vd&quot;
DECL|macro|VIOD_GENHD_DEVFS_NAME
mdefine_line|#define VIOD_GENHD_DEVFS_NAME&t;&quot;iseries/disc&quot;
DECL|macro|VIOD_VERS
mdefine_line|#define VIOD_VERS&t;&t;&quot;1.64&quot;
DECL|macro|VIOD_KERN_WARNING
mdefine_line|#define VIOD_KERN_WARNING&t;KERN_WARNING &quot;viod: &quot;
DECL|macro|VIOD_KERN_INFO
mdefine_line|#define VIOD_KERN_INFO&t;&t;KERN_INFO &quot;viod: &quot;
r_enum
(brace
DECL|enumerator|PARTITION_SHIFT
id|PARTITION_SHIFT
op_assign
l_int|3
comma
DECL|enumerator|MAX_DISKNO
id|MAX_DISKNO
op_assign
id|HVMAXARCHITECTEDVIRTUALDISKS
comma
DECL|enumerator|MAX_DISK_NAME
id|MAX_DISK_NAME
op_assign
r_sizeof
(paren
(paren
(paren
r_struct
id|gendisk
op_star
)paren
l_int|0
)paren
op_member_access_from_pointer
id|disk_name
)paren
)brace
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|viodasd_spinlock
)paren
suffix:semicolon
DECL|macro|VIOMAXREQ
mdefine_line|#define VIOMAXREQ&t;&t;16
DECL|macro|VIOMAXBLOCKDMA
mdefine_line|#define VIOMAXBLOCKDMA&t;&t;12
DECL|macro|DEVICE_NO
mdefine_line|#define DEVICE_NO(cell)&t;((struct viodasd_device *)(cell) - &amp;viodasd_devices[0])
DECL|struct|open_data
r_struct
id|open_data
(brace
DECL|member|disk_size
id|u64
id|disk_size
suffix:semicolon
DECL|member|max_disk
id|u16
id|max_disk
suffix:semicolon
DECL|member|cylinders
id|u16
id|cylinders
suffix:semicolon
DECL|member|tracks
id|u16
id|tracks
suffix:semicolon
DECL|member|sectors
id|u16
id|sectors
suffix:semicolon
DECL|member|bytes_per_sector
id|u16
id|bytes_per_sector
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|rw_data
r_struct
id|rw_data
(brace
DECL|member|offset
id|u64
id|offset
suffix:semicolon
r_struct
(brace
DECL|member|token
id|u32
id|token
suffix:semicolon
DECL|member|reserved
id|u32
id|reserved
suffix:semicolon
DECL|member|len
id|u64
id|len
suffix:semicolon
DECL|member|dma_info
)brace
id|dma_info
(braket
id|VIOMAXBLOCKDMA
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|vioblocklpevent
r_struct
id|vioblocklpevent
(brace
DECL|member|event
r_struct
id|HvLpEvent
id|event
suffix:semicolon
DECL|member|reserved
id|u32
id|reserved
suffix:semicolon
DECL|member|version
id|u16
id|version
suffix:semicolon
DECL|member|sub_result
id|u16
id|sub_result
suffix:semicolon
DECL|member|disk
id|u16
id|disk
suffix:semicolon
DECL|member|flags
id|u16
id|flags
suffix:semicolon
r_union
(brace
DECL|member|open_data
r_struct
id|open_data
id|open_data
suffix:semicolon
DECL|member|rw_data
r_struct
id|rw_data
id|rw_data
suffix:semicolon
DECL|member|changed
id|u64
id|changed
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|vioblockflags_ro
mdefine_line|#define vioblockflags_ro   0x0001
DECL|enum|vioblocksubtype
r_enum
id|vioblocksubtype
(brace
DECL|enumerator|vioblockopen
id|vioblockopen
op_assign
l_int|0x0001
comma
DECL|enumerator|vioblockclose
id|vioblockclose
op_assign
l_int|0x0002
comma
DECL|enumerator|vioblockread
id|vioblockread
op_assign
l_int|0x0003
comma
DECL|enumerator|vioblockwrite
id|vioblockwrite
op_assign
l_int|0x0004
comma
DECL|enumerator|vioblockflush
id|vioblockflush
op_assign
l_int|0x0005
comma
DECL|enumerator|vioblockcheck
id|vioblockcheck
op_assign
l_int|0x0007
)brace
suffix:semicolon
DECL|struct|viodasd_waitevent
r_struct
id|viodasd_waitevent
(brace
DECL|member|com
r_struct
id|completion
id|com
suffix:semicolon
DECL|member|rc
r_int
id|rc
suffix:semicolon
DECL|member|sub_result
id|u16
id|sub_result
suffix:semicolon
DECL|member|max_disk
r_int
id|max_disk
suffix:semicolon
multiline_comment|/* open */
)brace
suffix:semicolon
DECL|variable|viodasd_err_table
r_static
r_const
r_struct
id|vio_error_entry
id|viodasd_err_table
(braket
)braket
op_assign
(brace
(brace
l_int|0x0201
comma
id|EINVAL
comma
l_string|&quot;Invalid Range&quot;
)brace
comma
(brace
l_int|0x0202
comma
id|EINVAL
comma
l_string|&quot;Invalid Token&quot;
)brace
comma
(brace
l_int|0x0203
comma
id|EIO
comma
l_string|&quot;DMA Error&quot;
)brace
comma
(brace
l_int|0x0204
comma
id|EIO
comma
l_string|&quot;Use Error&quot;
)brace
comma
(brace
l_int|0x0205
comma
id|EIO
comma
l_string|&quot;Release Error&quot;
)brace
comma
(brace
l_int|0x0206
comma
id|EINVAL
comma
l_string|&quot;Invalid Disk&quot;
)brace
comma
(brace
l_int|0x0207
comma
id|EBUSY
comma
l_string|&quot;Cant Lock&quot;
)brace
comma
(brace
l_int|0x0208
comma
id|EIO
comma
l_string|&quot;Already Locked&quot;
)brace
comma
(brace
l_int|0x0209
comma
id|EIO
comma
l_string|&quot;Already Unlocked&quot;
)brace
comma
(brace
l_int|0x020A
comma
id|EIO
comma
l_string|&quot;Invalid Arg&quot;
)brace
comma
(brace
l_int|0x020B
comma
id|EIO
comma
l_string|&quot;Bad IFS File&quot;
)brace
comma
(brace
l_int|0x020C
comma
id|EROFS
comma
l_string|&quot;Read Only Device&quot;
)brace
comma
(brace
l_int|0x02FF
comma
id|EIO
comma
l_string|&quot;Internal Error&quot;
)brace
comma
(brace
l_int|0x0000
comma
l_int|0
comma
l_int|NULL
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Figure out the biggest I/O request (in sectors) we can accept&n; */
DECL|macro|VIODASD_MAXSECTORS
mdefine_line|#define VIODASD_MAXSECTORS (4096 / 512 * VIOMAXBLOCKDMA)
multiline_comment|/*&n; * Number of disk I/O requests we&squot;ve sent to OS/400&n; */
DECL|variable|num_req_outstanding
r_static
r_int
id|num_req_outstanding
suffix:semicolon
multiline_comment|/*&n; * This is our internal structure for keeping track of disk devices&n; */
DECL|struct|viodasd_device
r_struct
id|viodasd_device
(brace
DECL|member|cylinders
id|u16
id|cylinders
suffix:semicolon
DECL|member|tracks
id|u16
id|tracks
suffix:semicolon
DECL|member|sectors
id|u16
id|sectors
suffix:semicolon
DECL|member|bytes_per_sector
id|u16
id|bytes_per_sector
suffix:semicolon
DECL|member|size
id|u64
id|size
suffix:semicolon
DECL|member|read_only
r_int
id|read_only
suffix:semicolon
DECL|member|q_lock
id|spinlock_t
id|q_lock
suffix:semicolon
DECL|member|disk
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
DECL|member|dev
r_struct
id|device
op_star
id|dev
suffix:semicolon
DECL|variable|viodasd_devices
)brace
id|viodasd_devices
(braket
id|MAX_DISKNO
)braket
suffix:semicolon
multiline_comment|/*&n; * External open entry point.&n; */
DECL|function|viodasd_open
r_static
r_int
id|viodasd_open
c_func
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|fil
)paren
(brace
r_struct
id|viodasd_device
op_star
id|d
op_assign
id|ino-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
id|HvLpEvent_Rc
id|hvrc
suffix:semicolon
r_struct
id|viodasd_waitevent
id|we
suffix:semicolon
id|u16
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;read_only
)paren
(brace
r_if
c_cond
(paren
(paren
id|fil
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|fil-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
id|flags
op_assign
id|vioblockflags_ro
suffix:semicolon
)brace
id|init_completion
c_func
(paren
op_amp
id|we.com
)paren
suffix:semicolon
multiline_comment|/* Send the open event to OS/400 */
id|hvrc
op_assign
id|HvCallEvent_signalLpEventFast
c_func
(paren
id|viopath_hostLp
comma
id|HvLpEvent_Type_VirtualIo
comma
id|viomajorsubtype_blockio
op_or
id|vioblockopen
comma
id|HvLpEvent_AckInd_DoAck
comma
id|HvLpEvent_AckType_ImmediateAck
comma
id|viopath_sourceinst
c_func
(paren
id|viopath_hostLp
)paren
comma
id|viopath_targetinst
c_func
(paren
id|viopath_hostLp
)paren
comma
(paren
id|u64
)paren
(paren
r_int
r_int
)paren
op_amp
id|we
comma
id|VIOVERSION
op_lshift
l_int|16
comma
(paren
(paren
id|u64
)paren
id|DEVICE_NO
c_func
(paren
id|d
)paren
op_lshift
l_int|48
)paren
op_or
(paren
(paren
id|u64
)paren
id|flags
op_lshift
l_int|32
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvrc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;HV open failed %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|hvrc
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|wait_for_completion
c_func
(paren
op_amp
id|we.com
)paren
suffix:semicolon
multiline_comment|/* Check the return code */
r_if
c_cond
(paren
id|we.rc
op_ne
l_int|0
)paren
(brace
r_const
r_struct
id|vio_error_entry
op_star
id|err
op_assign
id|vio_lookup_rc
c_func
(paren
id|viodasd_err_table
comma
id|we.sub_result
)paren
suffix:semicolon
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;bad rc opening disk: %d:0x%04x (%s)&bslash;n&quot;
comma
(paren
r_int
)paren
id|we.rc
comma
id|we.sub_result
comma
id|err-&gt;msg
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * External release entry point.&n; */
DECL|function|viodasd_release
r_static
r_int
id|viodasd_release
c_func
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|fil
)paren
(brace
r_struct
id|viodasd_device
op_star
id|d
op_assign
id|ino-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
id|HvLpEvent_Rc
id|hvrc
suffix:semicolon
multiline_comment|/* Send the event to OS/400.  We DON&squot;T expect a response */
id|hvrc
op_assign
id|HvCallEvent_signalLpEventFast
c_func
(paren
id|viopath_hostLp
comma
id|HvLpEvent_Type_VirtualIo
comma
id|viomajorsubtype_blockio
op_or
id|vioblockclose
comma
id|HvLpEvent_AckInd_NoAck
comma
id|HvLpEvent_AckType_ImmediateAck
comma
id|viopath_sourceinst
c_func
(paren
id|viopath_hostLp
)paren
comma
id|viopath_targetinst
c_func
(paren
id|viopath_hostLp
)paren
comma
l_int|0
comma
id|VIOVERSION
op_lshift
l_int|16
comma
(paren
(paren
id|u64
)paren
id|DEVICE_NO
c_func
(paren
id|d
)paren
op_lshift
l_int|48
)paren
multiline_comment|/* | ((u64)flags &lt;&lt; 32) */
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvrc
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;HV close call failed %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|hvrc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* External ioctl entry point.&n; */
DECL|function|viodasd_ioctl
r_static
r_int
id|viodasd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|fil
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_char
id|sectors
suffix:semicolon
r_int
r_char
id|heads
suffix:semicolon
r_int
r_int
id|cylinders
suffix:semicolon
r_struct
id|hd_geometry
op_star
id|geo
suffix:semicolon
r_struct
id|gendisk
op_star
id|gendisk
suffix:semicolon
r_struct
id|viodasd_device
op_star
id|d
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
id|geo
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|geo
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|geo
comma
r_sizeof
(paren
op_star
id|geo
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|gendisk
op_assign
id|ino-&gt;i_bdev-&gt;bd_disk
suffix:semicolon
id|d
op_assign
id|gendisk-&gt;private_data
suffix:semicolon
id|sectors
op_assign
id|d-&gt;sectors
suffix:semicolon
r_if
c_cond
(paren
id|sectors
op_eq
l_int|0
)paren
id|sectors
op_assign
l_int|32
suffix:semicolon
id|heads
op_assign
id|d-&gt;tracks
suffix:semicolon
r_if
c_cond
(paren
id|heads
op_eq
l_int|0
)paren
id|heads
op_assign
l_int|64
suffix:semicolon
id|cylinders
op_assign
id|d-&gt;cylinders
suffix:semicolon
r_if
c_cond
(paren
id|cylinders
op_eq
l_int|0
)paren
id|cylinders
op_assign
id|get_capacity
c_func
(paren
id|gendisk
)paren
op_div
(paren
id|sectors
op_star
id|heads
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|sectors
comma
op_amp
id|geo-&gt;sectors
)paren
op_logical_or
id|__put_user
c_func
(paren
id|heads
comma
op_amp
id|geo-&gt;heads
)paren
op_logical_or
id|__put_user
c_func
(paren
id|cylinders
comma
op_amp
id|geo-&gt;cylinders
)paren
op_logical_or
id|__put_user
c_func
(paren
id|get_start_sect
c_func
(paren
id|ino-&gt;i_bdev
)paren
comma
op_amp
id|geo-&gt;start
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * Our file operations table&n; */
DECL|variable|viodasd_fops
r_static
r_struct
id|block_device_operations
id|viodasd_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|viodasd_open
comma
dot
id|release
op_assign
id|viodasd_release
comma
dot
id|ioctl
op_assign
id|viodasd_ioctl
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * End a request&n; */
DECL|function|viodasd_end_request
r_static
r_void
id|viodasd_end_request
c_func
(paren
r_struct
id|request
op_star
id|req
comma
r_int
id|uptodate
comma
r_int
id|num_sectors
)paren
(brace
r_if
c_cond
(paren
id|end_that_request_first
c_func
(paren
id|req
comma
id|uptodate
comma
id|num_sectors
)paren
)paren
r_return
suffix:semicolon
id|add_disk_randomness
c_func
(paren
id|req-&gt;rq_disk
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send an actual I/O request to OS/400&n; */
DECL|function|send_request
r_static
r_int
id|send_request
c_func
(paren
r_struct
id|request
op_star
id|req
)paren
(brace
id|u64
id|start
suffix:semicolon
r_int
id|direction
suffix:semicolon
r_int
id|nsg
suffix:semicolon
id|u16
id|viocmd
suffix:semicolon
id|HvLpEvent_Rc
id|hvrc
suffix:semicolon
r_struct
id|vioblocklpevent
op_star
id|bevent
suffix:semicolon
r_struct
id|scatterlist
id|sg
(braket
id|VIOMAXBLOCKDMA
)braket
suffix:semicolon
r_int
id|sgindex
suffix:semicolon
r_int
id|statindex
suffix:semicolon
r_struct
id|viodasd_device
op_star
id|d
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|start
op_assign
(paren
id|u64
)paren
id|req-&gt;sector
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|req
)paren
op_eq
id|READ
)paren
(brace
id|direction
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
id|viocmd
op_assign
id|viomajorsubtype_blockio
op_or
id|vioblockread
suffix:semicolon
id|statindex
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|direction
op_assign
id|DMA_TO_DEVICE
suffix:semicolon
id|viocmd
op_assign
id|viomajorsubtype_blockio
op_or
id|vioblockwrite
suffix:semicolon
id|statindex
op_assign
l_int|1
suffix:semicolon
)brace
id|d
op_assign
id|req-&gt;rq_disk-&gt;private_data
suffix:semicolon
multiline_comment|/* Now build the scatter-gather list */
id|nsg
op_assign
id|blk_rq_map_sg
c_func
(paren
id|req-&gt;q
comma
id|req
comma
id|sg
)paren
suffix:semicolon
id|nsg
op_assign
id|dma_map_sg
c_func
(paren
id|d-&gt;dev
comma
id|sg
comma
id|nsg
comma
id|direction
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|viodasd_spinlock
comma
id|flags
)paren
suffix:semicolon
id|num_req_outstanding
op_increment
suffix:semicolon
multiline_comment|/* This optimization handles a single DMA block */
r_if
c_cond
(paren
id|nsg
op_eq
l_int|1
)paren
id|hvrc
op_assign
id|HvCallEvent_signalLpEventFast
c_func
(paren
id|viopath_hostLp
comma
id|HvLpEvent_Type_VirtualIo
comma
id|viocmd
comma
id|HvLpEvent_AckInd_DoAck
comma
id|HvLpEvent_AckType_ImmediateAck
comma
id|viopath_sourceinst
c_func
(paren
id|viopath_hostLp
)paren
comma
id|viopath_targetinst
c_func
(paren
id|viopath_hostLp
)paren
comma
(paren
id|u64
)paren
(paren
r_int
r_int
)paren
id|req
comma
id|VIOVERSION
op_lshift
l_int|16
comma
(paren
(paren
id|u64
)paren
id|DEVICE_NO
c_func
(paren
id|d
)paren
op_lshift
l_int|48
)paren
comma
id|start
comma
(paren
(paren
id|u64
)paren
id|sg_dma_address
c_func
(paren
op_amp
id|sg
(braket
l_int|0
)braket
)paren
)paren
op_lshift
l_int|32
comma
id|sg_dma_len
c_func
(paren
op_amp
id|sg
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_else
(brace
id|bevent
op_assign
(paren
r_struct
id|vioblocklpevent
op_star
)paren
id|vio_get_event_buffer
c_func
(paren
id|viomajorsubtype_blockio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bevent
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;error allocating disk event buffer&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|error_ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now build up the actual request.  Note that we store&n;&t;&t; * the pointer to the request in the correlation&n;&t;&t; * token so we can match the response up later&n;&t;&t; */
id|memset
c_func
(paren
id|bevent
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|vioblocklpevent
)paren
)paren
suffix:semicolon
id|bevent-&gt;event.xFlags.xValid
op_assign
l_int|1
suffix:semicolon
id|bevent-&gt;event.xFlags.xFunction
op_assign
id|HvLpEvent_Function_Int
suffix:semicolon
id|bevent-&gt;event.xFlags.xAckInd
op_assign
id|HvLpEvent_AckInd_DoAck
suffix:semicolon
id|bevent-&gt;event.xFlags.xAckType
op_assign
id|HvLpEvent_AckType_ImmediateAck
suffix:semicolon
id|bevent-&gt;event.xType
op_assign
id|HvLpEvent_Type_VirtualIo
suffix:semicolon
id|bevent-&gt;event.xSubtype
op_assign
id|viocmd
suffix:semicolon
id|bevent-&gt;event.xSourceLp
op_assign
id|HvLpConfig_getLpIndex
c_func
(paren
)paren
suffix:semicolon
id|bevent-&gt;event.xTargetLp
op_assign
id|viopath_hostLp
suffix:semicolon
id|bevent-&gt;event.xSizeMinus1
op_assign
m_offsetof
(paren
r_struct
id|vioblocklpevent
comma
id|u.rw_data.dma_info
)paren
op_plus
(paren
r_sizeof
(paren
id|bevent-&gt;u.rw_data.dma_info
(braket
l_int|0
)braket
)paren
op_star
id|nsg
)paren
op_minus
l_int|1
suffix:semicolon
id|bevent-&gt;event.xSourceInstanceId
op_assign
id|viopath_sourceinst
c_func
(paren
id|viopath_hostLp
)paren
suffix:semicolon
id|bevent-&gt;event.xTargetInstanceId
op_assign
id|viopath_targetinst
c_func
(paren
id|viopath_hostLp
)paren
suffix:semicolon
id|bevent-&gt;event.xCorrelationToken
op_assign
(paren
id|u64
)paren
id|req
suffix:semicolon
id|bevent-&gt;version
op_assign
id|VIOVERSION
suffix:semicolon
id|bevent-&gt;disk
op_assign
id|DEVICE_NO
c_func
(paren
id|d
)paren
suffix:semicolon
id|bevent-&gt;u.rw_data.offset
op_assign
id|start
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Copy just the dma information from the sg list&n;&t;&t; * into the request&n;&t;&t; */
r_for
c_loop
(paren
id|sgindex
op_assign
l_int|0
suffix:semicolon
id|sgindex
OL
id|nsg
suffix:semicolon
id|sgindex
op_increment
)paren
(brace
id|bevent-&gt;u.rw_data.dma_info
(braket
id|sgindex
)braket
dot
id|token
op_assign
id|sg_dma_address
c_func
(paren
op_amp
id|sg
(braket
id|sgindex
)braket
)paren
suffix:semicolon
id|bevent-&gt;u.rw_data.dma_info
(braket
id|sgindex
)braket
dot
id|len
op_assign
id|sg_dma_len
c_func
(paren
op_amp
id|sg
(braket
id|sgindex
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Send the request */
id|hvrc
op_assign
id|HvCallEvent_signalLpEvent
c_func
(paren
op_amp
id|bevent-&gt;event
)paren
suffix:semicolon
id|vio_free_event_buffer
c_func
(paren
id|viomajorsubtype_blockio
comma
id|bevent
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hvrc
op_ne
id|HvLpEvent_Rc_Good
)paren
(brace
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;error sending disk event to OS/400 (rc %d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|hvrc
)paren
suffix:semicolon
r_goto
id|error_ret
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|viodasd_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error_ret
suffix:colon
id|num_req_outstanding
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|viodasd_spinlock
comma
id|flags
)paren
suffix:semicolon
id|dma_unmap_sg
c_func
(paren
id|d-&gt;dev
comma
id|sg
comma
id|nsg
comma
id|direction
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the external request processing routine&n; */
DECL|function|do_viodasd_request
r_static
r_void
id|do_viodasd_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
multiline_comment|/*&n;&t; * If we already have the maximum number of requests&n;&t; * outstanding to OS/400 just bail out. We&squot;ll come&n;&t; * back later.&n;&t; */
r_while
c_loop
(paren
id|num_req_outstanding
OL
id|VIOMAXREQ
)paren
(brace
id|req
op_assign
id|elv_next_request
c_func
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* dequeue the current request from the queue */
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* check that request contains a valid command */
r_if
c_cond
(paren
op_logical_neg
id|blk_fs_request
c_func
(paren
id|req
)paren
)paren
(brace
id|viodasd_end_request
c_func
(paren
id|req
comma
l_int|0
comma
id|req-&gt;hard_nr_sectors
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Try sending the request */
r_if
c_cond
(paren
id|send_request
c_func
(paren
id|req
)paren
op_ne
l_int|0
)paren
id|viodasd_end_request
c_func
(paren
id|req
comma
l_int|0
comma
id|req-&gt;hard_nr_sectors
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Probe a single disk and fill in the viodasd_device structure&n; * for it.&n; */
DECL|function|probe_disk
r_static
r_void
id|probe_disk
c_func
(paren
r_struct
id|viodasd_device
op_star
id|d
)paren
(brace
id|HvLpEvent_Rc
id|hvrc
suffix:semicolon
r_struct
id|viodasd_waitevent
id|we
suffix:semicolon
r_int
id|dev_no
op_assign
id|DEVICE_NO
c_func
(paren
id|d
)paren
suffix:semicolon
r_struct
id|gendisk
op_star
id|g
suffix:semicolon
r_struct
id|request_queue
op_star
id|q
suffix:semicolon
id|u16
id|flags
op_assign
l_int|0
suffix:semicolon
id|retry
suffix:colon
id|init_completion
c_func
(paren
op_amp
id|we.com
)paren
suffix:semicolon
multiline_comment|/* Send the open event to OS/400 */
id|hvrc
op_assign
id|HvCallEvent_signalLpEventFast
c_func
(paren
id|viopath_hostLp
comma
id|HvLpEvent_Type_VirtualIo
comma
id|viomajorsubtype_blockio
op_or
id|vioblockopen
comma
id|HvLpEvent_AckInd_DoAck
comma
id|HvLpEvent_AckType_ImmediateAck
comma
id|viopath_sourceinst
c_func
(paren
id|viopath_hostLp
)paren
comma
id|viopath_targetinst
c_func
(paren
id|viopath_hostLp
)paren
comma
(paren
id|u64
)paren
(paren
r_int
r_int
)paren
op_amp
id|we
comma
id|VIOVERSION
op_lshift
l_int|16
comma
(paren
(paren
id|u64
)paren
id|dev_no
op_lshift
l_int|48
)paren
op_or
(paren
(paren
id|u64
)paren
id|flags
op_lshift
l_int|32
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvrc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;bad rc on HV open %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|hvrc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|wait_for_completion
c_func
(paren
op_amp
id|we.com
)paren
suffix:semicolon
r_if
c_cond
(paren
id|we.rc
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|flags
op_ne
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* try again with read only flag set */
id|flags
op_assign
id|vioblockflags_ro
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|we.max_disk
OG
(paren
id|MAX_DISKNO
op_minus
l_int|1
)paren
)paren
(brace
r_static
r_int
id|warned
suffix:semicolon
r_if
c_cond
(paren
id|warned
op_eq
l_int|0
)paren
(brace
id|warned
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|VIOD_KERN_INFO
l_string|&quot;Only examining the first %d &quot;
l_string|&quot;of %d disks connected&bslash;n&quot;
comma
id|MAX_DISKNO
comma
id|we.max_disk
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Send the close event to OS/400.  We DON&squot;T expect a response */
id|hvrc
op_assign
id|HvCallEvent_signalLpEventFast
c_func
(paren
id|viopath_hostLp
comma
id|HvLpEvent_Type_VirtualIo
comma
id|viomajorsubtype_blockio
op_or
id|vioblockclose
comma
id|HvLpEvent_AckInd_NoAck
comma
id|HvLpEvent_AckType_ImmediateAck
comma
id|viopath_sourceinst
c_func
(paren
id|viopath_hostLp
)paren
comma
id|viopath_targetinst
c_func
(paren
id|viopath_hostLp
)paren
comma
l_int|0
comma
id|VIOVERSION
op_lshift
l_int|16
comma
(paren
(paren
id|u64
)paren
id|dev_no
op_lshift
l_int|48
)paren
op_or
(paren
(paren
id|u64
)paren
id|flags
op_lshift
l_int|32
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvrc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;bad rc sending event to OS/400 %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|hvrc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* create the request queue for the disk */
id|spin_lock_init
c_func
(paren
op_amp
id|d-&gt;q_lock
)paren
suffix:semicolon
id|q
op_assign
id|blk_init_queue
c_func
(paren
id|do_viodasd_request
comma
op_amp
id|d-&gt;q_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;cannot allocate queue for disk %d&bslash;n&quot;
comma
id|dev_no
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|g
op_assign
id|alloc_disk
c_func
(paren
l_int|1
op_lshift
id|PARTITION_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|g
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;cannot allocate disk structure for disk %d&bslash;n&quot;
comma
id|dev_no
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|d-&gt;disk
op_assign
id|g
suffix:semicolon
id|blk_queue_max_hw_segments
c_func
(paren
id|q
comma
id|VIOMAXBLOCKDMA
)paren
suffix:semicolon
id|blk_queue_max_phys_segments
c_func
(paren
id|q
comma
id|VIOMAXBLOCKDMA
)paren
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|q
comma
id|VIODASD_MAXSECTORS
)paren
suffix:semicolon
id|g-&gt;major
op_assign
id|VIODASD_MAJOR
suffix:semicolon
id|g-&gt;first_minor
op_assign
id|dev_no
op_lshift
id|PARTITION_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|dev_no
op_ge
l_int|26
)paren
id|snprintf
c_func
(paren
id|g-&gt;disk_name
comma
r_sizeof
(paren
id|g-&gt;disk_name
)paren
comma
id|VIOD_GENHD_NAME
l_string|&quot;%c%c&quot;
comma
l_char|&squot;a&squot;
op_plus
(paren
id|dev_no
op_div
l_int|26
)paren
op_minus
l_int|1
comma
l_char|&squot;a&squot;
op_plus
(paren
id|dev_no
op_mod
l_int|26
)paren
)paren
suffix:semicolon
r_else
id|snprintf
c_func
(paren
id|g-&gt;disk_name
comma
r_sizeof
(paren
id|g-&gt;disk_name
)paren
comma
id|VIOD_GENHD_NAME
l_string|&quot;%c&quot;
comma
l_char|&squot;a&squot;
op_plus
(paren
id|dev_no
op_mod
l_int|26
)paren
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|g-&gt;devfs_name
comma
r_sizeof
(paren
id|g-&gt;devfs_name
)paren
comma
l_string|&quot;%s%d&quot;
comma
id|VIOD_GENHD_DEVFS_NAME
comma
id|dev_no
)paren
suffix:semicolon
id|g-&gt;fops
op_assign
op_amp
id|viodasd_fops
suffix:semicolon
id|g-&gt;queue
op_assign
id|q
suffix:semicolon
id|g-&gt;private_data
op_assign
id|d
suffix:semicolon
id|g-&gt;driverfs_dev
op_assign
id|d-&gt;dev
suffix:semicolon
id|set_capacity
c_func
(paren
id|g
comma
id|d-&gt;size
op_rshift
l_int|9
)paren
suffix:semicolon
id|printk
c_func
(paren
id|VIOD_KERN_INFO
l_string|&quot;disk %d: %lu sectors (%lu MB) &quot;
l_string|&quot;CHS=%d/%d/%d sector size %d%s&bslash;n&quot;
comma
id|dev_no
comma
(paren
r_int
r_int
)paren
(paren
id|d-&gt;size
op_rshift
l_int|9
)paren
comma
(paren
r_int
r_int
)paren
(paren
id|d-&gt;size
op_rshift
l_int|20
)paren
comma
(paren
r_int
)paren
id|d-&gt;cylinders
comma
(paren
r_int
)paren
id|d-&gt;tracks
comma
(paren
r_int
)paren
id|d-&gt;sectors
comma
(paren
r_int
)paren
id|d-&gt;bytes_per_sector
comma
id|d-&gt;read_only
ques
c_cond
l_string|&quot; (RO)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/* register us in the global list */
id|add_disk
c_func
(paren
id|g
)paren
suffix:semicolon
)brace
multiline_comment|/* returns the total number of scatterlist elements converted */
DECL|function|block_event_to_scatterlist
r_static
r_int
id|block_event_to_scatterlist
c_func
(paren
r_const
r_struct
id|vioblocklpevent
op_star
id|bevent
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
op_star
id|total_len
)paren
(brace
r_int
id|i
comma
id|numsg
suffix:semicolon
r_const
r_struct
id|rw_data
op_star
id|rw_data
op_assign
op_amp
id|bevent-&gt;u.rw_data
suffix:semicolon
r_static
r_const
r_int
id|offset
op_assign
m_offsetof
(paren
r_struct
id|vioblocklpevent
comma
id|u.rw_data.dma_info
)paren
suffix:semicolon
r_static
r_const
r_int
id|element_size
op_assign
r_sizeof
(paren
id|rw_data-&gt;dma_info
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|numsg
op_assign
(paren
(paren
id|bevent-&gt;event.xSizeMinus1
op_plus
l_int|1
)paren
op_minus
id|offset
)paren
op_div
id|element_size
suffix:semicolon
r_if
c_cond
(paren
id|numsg
OG
id|VIOMAXBLOCKDMA
)paren
id|numsg
op_assign
id|VIOMAXBLOCKDMA
suffix:semicolon
op_star
id|total_len
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|sg
comma
l_int|0
comma
r_sizeof
(paren
id|sg
(braket
l_int|0
)braket
)paren
op_star
id|VIOMAXBLOCKDMA
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|numsg
)paren
op_logical_and
(paren
id|rw_data-&gt;dma_info
(braket
id|i
)braket
dot
id|len
OG
l_int|0
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|sg_dma_address
c_func
(paren
op_amp
id|sg
(braket
id|i
)braket
)paren
op_assign
id|rw_data-&gt;dma_info
(braket
id|i
)braket
dot
id|token
suffix:semicolon
id|sg_dma_len
c_func
(paren
op_amp
id|sg
(braket
id|i
)braket
)paren
op_assign
id|rw_data-&gt;dma_info
(braket
id|i
)braket
dot
id|len
suffix:semicolon
op_star
id|total_len
op_add_assign
id|rw_data-&gt;dma_info
(braket
id|i
)braket
dot
id|len
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * Restart all queues, starting with the one _after_ the disk given,&n; * thus reducing the chance of starvation of higher numbered disks.&n; */
DECL|function|viodasd_restart_all_queues_starting_from
r_static
r_void
id|viodasd_restart_all_queues_starting_from
c_func
(paren
r_int
id|first_index
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|first_index
op_plus
l_int|1
suffix:semicolon
id|i
OL
id|MAX_DISKNO
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|viodasd_devices
(braket
id|i
)braket
dot
id|disk
)paren
id|blk_run_queue
c_func
(paren
id|viodasd_devices
(braket
id|i
)braket
dot
id|disk-&gt;queue
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|first_index
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|viodasd_devices
(braket
id|i
)braket
dot
id|disk
)paren
id|blk_run_queue
c_func
(paren
id|viodasd_devices
(braket
id|i
)braket
dot
id|disk-&gt;queue
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For read and write requests, decrement the number of outstanding requests,&n; * Free the DMA buffers we allocated.&n; */
DECL|function|viodasd_handle_read_write
r_static
r_int
id|viodasd_handle_read_write
c_func
(paren
r_struct
id|vioblocklpevent
op_star
id|bevent
)paren
(brace
r_int
id|num_sg
comma
id|num_sect
comma
id|pci_direction
comma
id|total_len
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
r_struct
id|scatterlist
id|sg
(braket
id|VIOMAXBLOCKDMA
)braket
suffix:semicolon
r_struct
id|HvLpEvent
op_star
id|event
op_assign
op_amp
id|bevent-&gt;event
suffix:semicolon
r_int
r_int
id|irq_flags
suffix:semicolon
r_struct
id|viodasd_device
op_star
id|d
suffix:semicolon
r_int
id|error
suffix:semicolon
id|spinlock_t
op_star
id|qlock
suffix:semicolon
id|num_sg
op_assign
id|block_event_to_scatterlist
c_func
(paren
id|bevent
comma
id|sg
comma
op_amp
id|total_len
)paren
suffix:semicolon
id|num_sect
op_assign
id|total_len
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|event-&gt;xSubtype
op_eq
(paren
id|viomajorsubtype_blockio
op_or
id|vioblockread
)paren
)paren
id|pci_direction
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
r_else
id|pci_direction
op_assign
id|DMA_TO_DEVICE
suffix:semicolon
id|req
op_assign
(paren
r_struct
id|request
op_star
)paren
id|bevent-&gt;event.xCorrelationToken
suffix:semicolon
id|d
op_assign
id|req-&gt;rq_disk-&gt;private_data
suffix:semicolon
id|dma_unmap_sg
c_func
(paren
id|d-&gt;dev
comma
id|sg
comma
id|num_sg
comma
id|pci_direction
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since this is running in interrupt mode, we need to make sure&n;&t; * we&squot;re not stepping on any global I/O operations&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|viodasd_spinlock
comma
id|irq_flags
)paren
suffix:semicolon
id|num_req_outstanding
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|viodasd_spinlock
comma
id|irq_flags
)paren
suffix:semicolon
id|error
op_assign
id|event-&gt;xRc
op_ne
id|HvLpEvent_Rc_Good
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_const
r_struct
id|vio_error_entry
op_star
id|err
suffix:semicolon
id|err
op_assign
id|vio_lookup_rc
c_func
(paren
id|viodasd_err_table
comma
id|bevent-&gt;sub_result
)paren
suffix:semicolon
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;read/write error %d:0x%04x (%s)&bslash;n&quot;
comma
id|event-&gt;xRc
comma
id|bevent-&gt;sub_result
comma
id|err-&gt;msg
)paren
suffix:semicolon
id|num_sect
op_assign
id|req-&gt;hard_nr_sectors
suffix:semicolon
)brace
id|qlock
op_assign
id|req-&gt;q-&gt;queue_lock
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|qlock
comma
id|irq_flags
)paren
suffix:semicolon
id|viodasd_end_request
c_func
(paren
id|req
comma
op_logical_neg
id|error
comma
id|num_sect
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|qlock
comma
id|irq_flags
)paren
suffix:semicolon
multiline_comment|/* Finally, try to get more requests off of this device&squot;s queue */
id|viodasd_restart_all_queues_starting_from
c_func
(paren
id|DEVICE_NO
c_func
(paren
id|d
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This routine handles incoming block LP events */
DECL|function|handle_block_event
r_static
r_void
id|handle_block_event
c_func
(paren
r_struct
id|HvLpEvent
op_star
id|event
)paren
(brace
r_struct
id|vioblocklpevent
op_star
id|bevent
op_assign
(paren
r_struct
id|vioblocklpevent
op_star
)paren
id|event
suffix:semicolon
r_struct
id|viodasd_waitevent
op_star
id|pwe
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
l_int|NULL
)paren
multiline_comment|/* Notification that a partition went away! */
r_return
suffix:semicolon
multiline_comment|/* First, we should NEVER get an int here...only acks */
r_if
c_cond
(paren
id|event-&gt;xFlags.xFunction
op_eq
id|HvLpEvent_Function_Int
)paren
(brace
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;Yikes! got an int in viodasd event handler!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event-&gt;xFlags.xAckInd
op_eq
id|HvLpEvent_AckInd_DoAck
)paren
(brace
id|event-&gt;xRc
op_assign
id|HvLpEvent_Rc_InvalidSubtype
suffix:semicolon
id|HvCallEvent_ackLpEvent
c_func
(paren
id|event
)paren
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|event-&gt;xSubtype
op_amp
id|VIOMINOR_SUBTYPE_MASK
)paren
(brace
r_case
id|vioblockopen
suffix:colon
multiline_comment|/*&n;&t;&t; * Handle a response to an open request.  We get all the&n;&t;&t; * disk information in the response, so update it.  The&n;&t;&t; * correlation token contains a pointer to a waitevent&n;&t;&t; * structure that has a completion in it.  update the&n;&t;&t; * return code in the waitevent structure and post the&n;&t;&t; * completion to wake up the guy who sent the request&n;&t;&t; */
id|pwe
op_assign
(paren
r_struct
id|viodasd_waitevent
op_star
)paren
id|event-&gt;xCorrelationToken
suffix:semicolon
id|pwe-&gt;rc
op_assign
id|event-&gt;xRc
suffix:semicolon
id|pwe-&gt;sub_result
op_assign
id|bevent-&gt;sub_result
suffix:semicolon
r_if
c_cond
(paren
id|event-&gt;xRc
op_eq
id|HvLpEvent_Rc_Good
)paren
(brace
r_const
r_struct
id|open_data
op_star
id|data
op_assign
op_amp
id|bevent-&gt;u.open_data
suffix:semicolon
r_struct
id|viodasd_device
op_star
id|device
op_assign
op_amp
id|viodasd_devices
(braket
id|bevent-&gt;disk
)braket
suffix:semicolon
id|device-&gt;read_only
op_assign
id|bevent-&gt;flags
op_amp
id|vioblockflags_ro
suffix:semicolon
id|device-&gt;size
op_assign
id|data-&gt;disk_size
suffix:semicolon
id|device-&gt;cylinders
op_assign
id|data-&gt;cylinders
suffix:semicolon
id|device-&gt;tracks
op_assign
id|data-&gt;tracks
suffix:semicolon
id|device-&gt;sectors
op_assign
id|data-&gt;sectors
suffix:semicolon
id|device-&gt;bytes_per_sector
op_assign
id|data-&gt;bytes_per_sector
suffix:semicolon
id|pwe-&gt;max_disk
op_assign
id|data-&gt;max_disk
suffix:semicolon
)brace
id|complete
c_func
(paren
op_amp
id|pwe-&gt;com
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|vioblockclose
suffix:colon
r_break
suffix:semicolon
r_case
id|vioblockread
suffix:colon
r_case
id|vioblockwrite
suffix:colon
id|viodasd_handle_read_write
c_func
(paren
id|bevent
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;invalid subtype!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event-&gt;xFlags.xAckInd
op_eq
id|HvLpEvent_AckInd_DoAck
)paren
(brace
id|event-&gt;xRc
op_assign
id|HvLpEvent_Rc_InvalidSubtype
suffix:semicolon
id|HvCallEvent_ackLpEvent
c_func
(paren
id|event
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Get the driver to reprobe for more disks.&n; */
DECL|function|probe_disks
r_static
id|ssize_t
id|probe_disks
c_func
(paren
r_struct
id|device_driver
op_star
id|drv
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|viodasd_device
op_star
id|d
suffix:semicolon
r_for
c_loop
(paren
id|d
op_assign
id|viodasd_devices
suffix:semicolon
id|d
OL
op_amp
id|viodasd_devices
(braket
id|MAX_DISKNO
)braket
suffix:semicolon
id|d
op_increment
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;disk
op_eq
l_int|NULL
)paren
id|probe_disk
c_func
(paren
id|d
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
r_static
id|DRIVER_ATTR
c_func
(paren
id|probe
comma
id|S_IWUSR
comma
l_int|NULL
comma
id|probe_disks
)paren
suffix:semicolon
DECL|function|viodasd_probe
r_static
r_int
id|viodasd_probe
c_func
(paren
r_struct
id|vio_dev
op_star
id|vdev
comma
r_const
r_struct
id|vio_device_id
op_star
id|id
)paren
(brace
r_struct
id|viodasd_device
op_star
id|d
op_assign
op_amp
id|viodasd_devices
(braket
id|vdev-&gt;unit_address
)braket
suffix:semicolon
id|d-&gt;dev
op_assign
op_amp
id|vdev-&gt;dev
suffix:semicolon
id|probe_disk
c_func
(paren
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;disk
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|viodasd_remove
r_static
r_int
id|viodasd_remove
c_func
(paren
r_struct
id|vio_dev
op_star
id|vdev
)paren
(brace
r_struct
id|viodasd_device
op_star
id|d
suffix:semicolon
id|d
op_assign
op_amp
id|viodasd_devices
(braket
id|vdev-&gt;unit_address
)braket
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;disk
)paren
(brace
id|del_gendisk
c_func
(paren
id|d-&gt;disk
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|d-&gt;disk-&gt;queue
)paren
suffix:semicolon
id|put_disk
c_func
(paren
id|d-&gt;disk
)paren
suffix:semicolon
id|d-&gt;disk
op_assign
l_int|NULL
suffix:semicolon
)brace
id|d-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * viodasd_device_table: Used by vio.c to match devices that we&n; * support.&n; */
DECL|variable|__devinitdata
r_static
r_struct
id|vio_device_id
id|viodasd_device_table
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
l_string|&quot;viodasd&quot;
comma
l_string|&quot;&quot;
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|vio
comma
id|viodasd_device_table
)paren
suffix:semicolon
DECL|variable|viodasd_driver
r_static
r_struct
id|vio_driver
id|viodasd_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;viodasd&quot;
comma
dot
id|id_table
op_assign
id|viodasd_device_table
comma
dot
id|probe
op_assign
id|viodasd_probe
comma
dot
id|remove
op_assign
id|viodasd_remove
)brace
suffix:semicolon
multiline_comment|/*&n; * Initialize the whole device driver.  Handle module and non-module&n; * versions&n; */
DECL|function|viodasd_init
r_static
r_int
id|__init
id|viodasd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* Try to open to our host lp */
r_if
c_cond
(paren
id|viopath_hostLp
op_eq
id|HvLpIndexInvalid
)paren
id|vio_set_hostlp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|viopath_hostLp
op_eq
id|HvLpIndexInvalid
)paren
(brace
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;invalid hosting partition&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
id|VIOD_KERN_INFO
l_string|&quot;vers &quot;
id|VIOD_VERS
l_string|&quot;, hosting partition %d&bslash;n&quot;
comma
id|viopath_hostLp
)paren
suffix:semicolon
multiline_comment|/* register the block device */
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|VIODASD_MAJOR
comma
id|VIOD_GENHD_NAME
)paren
)paren
(brace
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;Unable to get major number %d for %s&bslash;n&quot;
comma
id|VIODASD_MAJOR
comma
id|VIOD_GENHD_NAME
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Actually open the path to the hosting partition */
r_if
c_cond
(paren
id|viopath_open
c_func
(paren
id|viopath_hostLp
comma
id|viomajorsubtype_blockio
comma
id|VIOMAXREQ
op_plus
l_int|2
)paren
)paren
(brace
id|printk
c_func
(paren
id|VIOD_KERN_WARNING
l_string|&quot;error opening path to host partition %d&bslash;n&quot;
comma
id|viopath_hostLp
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|VIODASD_MAJOR
comma
id|VIOD_GENHD_NAME
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Initialize our request handler */
id|vio_setHandler
c_func
(paren
id|viomajorsubtype_blockio
comma
id|handle_block_event
)paren
suffix:semicolon
id|rc
op_assign
id|vio_register_driver
c_func
(paren
op_amp
id|viodasd_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|driver_create_file
c_func
(paren
op_amp
id|viodasd_driver.driver
comma
op_amp
id|driver_attr_probe
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|variable|viodasd_init
id|module_init
c_func
(paren
id|viodasd_init
)paren
suffix:semicolon
DECL|function|viodasd_exit
r_void
id|viodasd_exit
c_func
(paren
r_void
)paren
(brace
id|driver_remove_file
c_func
(paren
op_amp
id|viodasd_driver.driver
comma
op_amp
id|driver_attr_probe
)paren
suffix:semicolon
id|vio_unregister_driver
c_func
(paren
op_amp
id|viodasd_driver
)paren
suffix:semicolon
id|vio_clearHandler
c_func
(paren
id|viomajorsubtype_blockio
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|VIODASD_MAJOR
comma
id|VIOD_GENHD_NAME
)paren
suffix:semicolon
id|viopath_close
c_func
(paren
id|viopath_hostLp
comma
id|viomajorsubtype_blockio
comma
id|VIOMAXREQ
op_plus
l_int|2
)paren
suffix:semicolon
)brace
DECL|variable|viodasd_exit
id|module_exit
c_func
(paren
id|viodasd_exit
)paren
suffix:semicolon
eof
