multiline_comment|/*&n; * The low performance USB storage driver (ub).&n; *&n; * Copyright (c) 1999, 2000 Matthew Dharm (mdharm-usb@one-eyed-alien.net)&n; * Copyright (C) 2004 Pete Zaitcev (zaitcev@yahoo.com)&n; *&n; * This work is a part of Linux kernel, is derived from it,&n; * and is not licensed separately. See file COPYING for details.&n; *&n; * TODO (sorted by decreasing priority)&n; *  -- Do resets with usb_device_reset (needs a thread context, use khubd)&n; *  -- set readonly flag for CDs, set removable flag for CF readers&n; *  -- do inquiry and verify we got a disk and not a tape (for LUN mismatch)&n; *  -- support pphaneuf&squot;s SDDR-75 with two LUNs (also broken capacity...)&n; *  -- special case some senses, e.g. 3a/0 -&gt; no media present, reduce retries&n; *  -- verify the 13 conditions and do bulk resets&n; *  -- normal pool of commands instead of cmdv[]?&n; *  -- kill last_pipe and simply do two-state clearing on both pipes&n; *  -- verify protocol (bulk) from USB descriptors (maybe...)&n; *  -- highmem and sg&n; *  -- move top_sense and work_bcs into separate allocations (if they survive)&n; *     for cache purists and esoteric architectures.&n; *  -- prune comments, they are too volumnous&n; *  -- Exterminate P3 printks&n; *  -- Resove XXX&squot;s&n; *  -- Redo &quot;benh&squot;s retries&quot;, perhaps have spin-up code to handle them. V:D=?&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
DECL|macro|DRV_NAME
mdefine_line|#define DRV_NAME &quot;ub&quot;
DECL|macro|DEVFS_NAME
mdefine_line|#define DEVFS_NAME DRV_NAME
DECL|macro|UB_MAJOR
mdefine_line|#define UB_MAJOR 125&t;/* Stolen from Experimental range for a week - XXX */
multiline_comment|/*&n; * Definitions which have to be scattered once we understand the layout better.&n; */
multiline_comment|/* Transport (despite PR in the name) */
DECL|macro|US_PR_BULK
mdefine_line|#define US_PR_BULK&t;0x50&t;&t;/* bulk only */
multiline_comment|/* Protocol */
DECL|macro|US_SC_SCSI
mdefine_line|#define US_SC_SCSI&t;0x06&t;&t;/* Transparent */
multiline_comment|/*&n; */
DECL|macro|UB_MINORS_PER_MAJOR
mdefine_line|#define UB_MINORS_PER_MAJOR&t;8
DECL|macro|UB_MAX_CDB_SIZE
mdefine_line|#define UB_MAX_CDB_SIZE      16&t;&t;/* Corresponds to Bulk */
DECL|macro|UB_SENSE_SIZE
mdefine_line|#define UB_SENSE_SIZE  18
multiline_comment|/*&n; */
multiline_comment|/* command block wrapper */
DECL|struct|bulk_cb_wrap
r_struct
id|bulk_cb_wrap
(brace
DECL|member|Signature
id|__le32
id|Signature
suffix:semicolon
multiline_comment|/* contains &squot;USBC&squot; */
DECL|member|Tag
id|u32
id|Tag
suffix:semicolon
multiline_comment|/* unique per command id */
DECL|member|DataTransferLength
id|__le32
id|DataTransferLength
suffix:semicolon
multiline_comment|/* size of data */
DECL|member|Flags
id|u8
id|Flags
suffix:semicolon
multiline_comment|/* direction in bit 0 */
DECL|member|Lun
id|u8
id|Lun
suffix:semicolon
multiline_comment|/* LUN normally 0 */
DECL|member|Length
id|u8
id|Length
suffix:semicolon
multiline_comment|/* of of the CDB */
DECL|member|CDB
id|u8
id|CDB
(braket
id|UB_MAX_CDB_SIZE
)braket
suffix:semicolon
multiline_comment|/* max command */
)brace
suffix:semicolon
DECL|macro|US_BULK_CB_WRAP_LEN
mdefine_line|#define US_BULK_CB_WRAP_LEN&t;31
DECL|macro|US_BULK_CB_SIGN
mdefine_line|#define US_BULK_CB_SIGN&t;&t;0x43425355&t;/*spells out USBC */
DECL|macro|US_BULK_FLAG_IN
mdefine_line|#define US_BULK_FLAG_IN&t;&t;1
DECL|macro|US_BULK_FLAG_OUT
mdefine_line|#define US_BULK_FLAG_OUT&t;0
multiline_comment|/* command status wrapper */
DECL|struct|bulk_cs_wrap
r_struct
id|bulk_cs_wrap
(brace
DECL|member|Signature
id|__le32
id|Signature
suffix:semicolon
multiline_comment|/* should = &squot;USBS&squot; */
DECL|member|Tag
id|u32
id|Tag
suffix:semicolon
multiline_comment|/* same as original command */
DECL|member|Residue
id|__le32
id|Residue
suffix:semicolon
multiline_comment|/* amount not transferred */
DECL|member|Status
id|u8
id|Status
suffix:semicolon
multiline_comment|/* see below */
)brace
suffix:semicolon
DECL|macro|US_BULK_CS_WRAP_LEN
mdefine_line|#define US_BULK_CS_WRAP_LEN&t;13
DECL|macro|US_BULK_CS_SIGN
mdefine_line|#define US_BULK_CS_SIGN&t;&t;0x53425355&t;/* spells out &squot;USBS&squot; */
multiline_comment|/* This is for Olympus Camedia digital cameras */
DECL|macro|US_BULK_CS_OLYMPUS_SIGN
mdefine_line|#define US_BULK_CS_OLYMPUS_SIGN&t;0x55425355&t;/* spells out &squot;USBU&squot; */
DECL|macro|US_BULK_STAT_OK
mdefine_line|#define US_BULK_STAT_OK&t;&t;0
DECL|macro|US_BULK_STAT_FAIL
mdefine_line|#define US_BULK_STAT_FAIL&t;1
DECL|macro|US_BULK_STAT_PHASE
mdefine_line|#define US_BULK_STAT_PHASE&t;2
multiline_comment|/* bulk-only class specific requests */
DECL|macro|US_BULK_RESET_REQUEST
mdefine_line|#define US_BULK_RESET_REQUEST&t;0xff
DECL|macro|US_BULK_GET_MAX_LUN
mdefine_line|#define US_BULK_GET_MAX_LUN&t;0xfe
multiline_comment|/*&n; */
r_struct
id|ub_dev
suffix:semicolon
DECL|macro|UB_MAX_REQ_SG
mdefine_line|#define UB_MAX_REQ_SG&t;1
DECL|macro|UB_MAX_SECTORS
mdefine_line|#define UB_MAX_SECTORS 64
multiline_comment|/*&n; * A second is more than enough for a 32K transfer (UB_MAX_SECTORS)&n; * even if a webcam hogs the bus, but some devices need time to spin up.&n; */
DECL|macro|UB_URB_TIMEOUT
mdefine_line|#define UB_URB_TIMEOUT&t;(HZ*2)
DECL|macro|UB_DATA_TIMEOUT
mdefine_line|#define UB_DATA_TIMEOUT&t;(HZ*5)&t;/* ZIP does spin-ups in the data phase */
DECL|macro|UB_CTRL_TIMEOUT
mdefine_line|#define UB_CTRL_TIMEOUT&t;(HZ/2) /* 500ms ought to be enough to clear a stall */
multiline_comment|/*&n; * An instance of a SCSI command in transit.&n; */
DECL|macro|UB_DIR_NONE
mdefine_line|#define UB_DIR_NONE&t;0
DECL|macro|UB_DIR_READ
mdefine_line|#define UB_DIR_READ&t;1
DECL|macro|UB_DIR_ILLEGAL2
mdefine_line|#define UB_DIR_ILLEGAL2&t;2
DECL|macro|UB_DIR_WRITE
mdefine_line|#define UB_DIR_WRITE&t;3
DECL|macro|UB_DIR_CHAR
mdefine_line|#define UB_DIR_CHAR(c)  (((c)==UB_DIR_WRITE)? &squot;w&squot;: &bslash;&n;&t;&t;&t; (((c)==UB_DIR_READ)? &squot;r&squot;: &squot;n&squot;))
DECL|enum|ub_scsi_cmd_state
r_enum
id|ub_scsi_cmd_state
(brace
DECL|enumerator|UB_CMDST_INIT
id|UB_CMDST_INIT
comma
multiline_comment|/* Initial state */
DECL|enumerator|UB_CMDST_CMD
id|UB_CMDST_CMD
comma
multiline_comment|/* Command submitted */
DECL|enumerator|UB_CMDST_DATA
id|UB_CMDST_DATA
comma
multiline_comment|/* Data phase */
DECL|enumerator|UB_CMDST_CLR2STS
id|UB_CMDST_CLR2STS
comma
multiline_comment|/* Clearing before requesting status */
DECL|enumerator|UB_CMDST_STAT
id|UB_CMDST_STAT
comma
multiline_comment|/* Status phase */
DECL|enumerator|UB_CMDST_CLEAR
id|UB_CMDST_CLEAR
comma
multiline_comment|/* Clearing a stall (halt, actually) */
DECL|enumerator|UB_CMDST_SENSE
id|UB_CMDST_SENSE
comma
multiline_comment|/* Sending Request Sense */
DECL|enumerator|UB_CMDST_DONE
id|UB_CMDST_DONE
multiline_comment|/* Final state */
)brace
suffix:semicolon
DECL|variable|ub_scsi_cmd_stname
r_static
r_char
op_star
id|ub_scsi_cmd_stname
(braket
)braket
op_assign
(brace
l_string|&quot;.  &quot;
comma
l_string|&quot;Cmd&quot;
comma
l_string|&quot;dat&quot;
comma
l_string|&quot;c2s&quot;
comma
l_string|&quot;sts&quot;
comma
l_string|&quot;clr&quot;
comma
l_string|&quot;Sen&quot;
comma
l_string|&quot;fin&quot;
)brace
suffix:semicolon
DECL|struct|ub_scsi_cmd
r_struct
id|ub_scsi_cmd
(brace
DECL|member|cdb
r_int
r_char
id|cdb
(braket
id|UB_MAX_CDB_SIZE
)braket
suffix:semicolon
DECL|member|cdb_len
r_int
r_char
id|cdb_len
suffix:semicolon
DECL|member|dir
r_int
r_char
id|dir
suffix:semicolon
multiline_comment|/* 0 - none, 1 - read, 3 - write. */
DECL|member|trace_index
r_int
r_char
id|trace_index
suffix:semicolon
DECL|member|state
r_enum
id|ub_scsi_cmd_state
id|state
suffix:semicolon
DECL|member|tag
r_int
r_int
id|tag
suffix:semicolon
DECL|member|next
r_struct
id|ub_scsi_cmd
op_star
id|next
suffix:semicolon
DECL|member|error
r_int
id|error
suffix:semicolon
multiline_comment|/* Return code - valid upon done */
DECL|member|act_len
r_int
r_int
id|act_len
suffix:semicolon
multiline_comment|/* Return size */
DECL|member|key
DECL|member|asc
DECL|member|ascq
r_int
r_char
id|key
comma
id|asc
comma
id|ascq
suffix:semicolon
multiline_comment|/* May be valid if error==-EIO */
DECL|member|stat_count
r_int
id|stat_count
suffix:semicolon
multiline_comment|/* Retries getting status. */
multiline_comment|/*&n;&t; * We do not support transfers from highmem pages&n;&t; * because the underlying USB framework does not do what we need.&n;&t; */
DECL|member|data
r_char
op_star
id|data
suffix:semicolon
multiline_comment|/* Requested buffer */
DECL|member|len
r_int
r_int
id|len
suffix:semicolon
multiline_comment|/* Requested length */
singleline_comment|// struct scatterlist sgv[UB_MAX_REQ_SG];
DECL|member|done
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|ub_dev
op_star
comma
r_struct
id|ub_scsi_cmd
op_star
)paren
suffix:semicolon
DECL|member|back
r_void
op_star
id|back
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; */
DECL|struct|ub_capacity
r_struct
id|ub_capacity
(brace
DECL|member|nsec
r_int
r_int
id|nsec
suffix:semicolon
multiline_comment|/* Linux size - 512 byte sectors */
DECL|member|bsize
r_int
r_int
id|bsize
suffix:semicolon
multiline_comment|/* Linux hardsect_size */
DECL|member|bshift
r_int
r_int
id|bshift
suffix:semicolon
multiline_comment|/* Shift between 512 and hard sects */
)brace
suffix:semicolon
multiline_comment|/*&n; * The SCSI command tracing structure.&n; */
DECL|macro|SCMD_ST_HIST_SZ
mdefine_line|#define SCMD_ST_HIST_SZ   8
DECL|macro|SCMD_TRACE_SZ
mdefine_line|#define SCMD_TRACE_SZ    63&t;&t;/* Less than 4KB of 61-byte lines */
DECL|struct|ub_scsi_cmd_trace
r_struct
id|ub_scsi_cmd_trace
(brace
DECL|member|hcur
r_int
id|hcur
suffix:semicolon
DECL|member|tag
r_int
r_int
id|tag
suffix:semicolon
DECL|member|req_size
DECL|member|act_size
r_int
r_int
id|req_size
comma
id|act_size
suffix:semicolon
DECL|member|op
r_int
r_char
id|op
suffix:semicolon
DECL|member|dir
r_int
r_char
id|dir
suffix:semicolon
DECL|member|key
DECL|member|asc
DECL|member|ascq
r_int
r_char
id|key
comma
id|asc
comma
id|ascq
suffix:semicolon
DECL|member|st_hst
r_char
id|st_hst
(braket
id|SCMD_ST_HIST_SZ
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|ub_scsi_trace
r_struct
id|ub_scsi_trace
(brace
DECL|member|cur
r_int
id|cur
suffix:semicolon
DECL|member|vec
r_struct
id|ub_scsi_cmd_trace
id|vec
(braket
id|SCMD_TRACE_SZ
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * This is a direct take-off from linux/include/completion.h&n; * The difference is that I do not wait on this thing, just poll.&n; * When I want to wait (ub_probe), I just use the stock completion.&n; *&n; * Note that INIT_COMPLETION takes no lock. It is correct. But why&n; * in the bloody hell that thing takes struct instead of pointer to struct&n; * is quite beyond me. I just copied it from the stock completion.&n; */
DECL|struct|ub_completion
r_struct
id|ub_completion
(brace
DECL|member|done
r_int
r_int
id|done
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
)brace
suffix:semicolon
DECL|function|ub_init_completion
r_static
r_inline
r_void
id|ub_init_completion
c_func
(paren
r_struct
id|ub_completion
op_star
id|x
)paren
(brace
id|x-&gt;done
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|x-&gt;lock
)paren
suffix:semicolon
)brace
DECL|macro|UB_INIT_COMPLETION
mdefine_line|#define UB_INIT_COMPLETION(x)&t;((x).done = 0)
DECL|function|ub_complete
r_static
r_void
id|ub_complete
c_func
(paren
r_struct
id|ub_completion
op_star
id|x
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|x-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|x-&gt;done
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|x-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|ub_is_completed
r_static
r_int
id|ub_is_completed
c_func
(paren
r_struct
id|ub_completion
op_star
id|x
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|x-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|x-&gt;done
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|x-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|struct|ub_scsi_cmd_queue
r_struct
id|ub_scsi_cmd_queue
(brace
DECL|member|qlen
DECL|member|qmax
r_int
id|qlen
comma
id|qmax
suffix:semicolon
DECL|member|head
DECL|member|tail
r_struct
id|ub_scsi_cmd
op_star
id|head
comma
op_star
id|tail
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * The UB device instance.&n; */
DECL|struct|ub_dev
r_struct
id|ub_dev
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|id
r_int
id|id
suffix:semicolon
multiline_comment|/* Number among ub&squot;s */
DECL|member|poison
id|atomic_t
id|poison
suffix:semicolon
multiline_comment|/* The USB device is disconnected */
DECL|member|openc
r_int
id|openc
suffix:semicolon
multiline_comment|/* protected by ub_lock! */
multiline_comment|/* kref is too implicit for our taste */
DECL|member|tagcnt
r_int
r_int
id|tagcnt
suffix:semicolon
DECL|member|changed
r_int
id|changed
suffix:semicolon
multiline_comment|/* Media was changed */
DECL|member|removable
r_int
id|removable
suffix:semicolon
DECL|member|readonly
r_int
id|readonly
suffix:semicolon
DECL|member|first_open
r_int
id|first_open
suffix:semicolon
multiline_comment|/* Kludge. See ub_bd_open. */
DECL|member|name
r_char
id|name
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|dev
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
DECL|member|intf
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
DECL|member|capacity
r_struct
id|ub_capacity
id|capacity
suffix:semicolon
DECL|member|disk
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
DECL|member|send_bulk_pipe
r_int
r_int
id|send_bulk_pipe
suffix:semicolon
multiline_comment|/* cached pipe values */
DECL|member|recv_bulk_pipe
r_int
r_int
id|recv_bulk_pipe
suffix:semicolon
DECL|member|send_ctrl_pipe
r_int
r_int
id|send_ctrl_pipe
suffix:semicolon
DECL|member|recv_ctrl_pipe
r_int
r_int
id|recv_ctrl_pipe
suffix:semicolon
DECL|member|tasklet
r_struct
id|tasklet_struct
id|tasklet
suffix:semicolon
multiline_comment|/* XXX Use Ingo&squot;s mempool (once we have more than one) */
DECL|member|cmda
r_int
id|cmda
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|cmdv
r_struct
id|ub_scsi_cmd
id|cmdv
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|cmd_queue
r_struct
id|ub_scsi_cmd_queue
id|cmd_queue
suffix:semicolon
DECL|member|top_rqs_cmd
r_struct
id|ub_scsi_cmd
id|top_rqs_cmd
suffix:semicolon
multiline_comment|/* REQUEST SENSE */
DECL|member|top_sense
r_int
r_char
id|top_sense
(braket
id|UB_SENSE_SIZE
)braket
suffix:semicolon
DECL|member|work_done
r_struct
id|ub_completion
id|work_done
suffix:semicolon
DECL|member|work_urb
r_struct
id|urb
id|work_urb
suffix:semicolon
DECL|member|work_timer
r_struct
id|timer_list
id|work_timer
suffix:semicolon
DECL|member|last_pipe
r_int
id|last_pipe
suffix:semicolon
multiline_comment|/* What might need clearing */
DECL|member|work_bcb
r_struct
id|bulk_cb_wrap
id|work_bcb
suffix:semicolon
DECL|member|work_bcs
r_struct
id|bulk_cs_wrap
id|work_bcs
suffix:semicolon
DECL|member|work_cr
r_struct
id|usb_ctrlrequest
id|work_cr
suffix:semicolon
DECL|member|tr
r_struct
id|ub_scsi_trace
id|tr
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; */
r_static
r_void
id|ub_rw_cmd_done
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ub_end_rq
c_func
(paren
r_struct
id|request
op_star
id|rq
comma
r_int
id|uptodate
)paren
suffix:semicolon
r_static
r_int
id|ub_submit_scsi
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ub_urb_complete
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|pt
)paren
suffix:semicolon
r_static
r_void
id|ub_scsi_action
c_func
(paren
r_int
r_int
id|_dev
)paren
suffix:semicolon
r_static
r_void
id|ub_scsi_dispatch
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
)paren
suffix:semicolon
r_static
r_void
id|ub_scsi_urb_compl
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ub_state_done
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
comma
r_int
id|rc
)paren
suffix:semicolon
r_static
r_void
id|ub_state_stat
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ub_state_sense
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|ub_submit_clear_stall
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
comma
r_int
id|stalled_pipe
)paren
suffix:semicolon
r_static
r_void
id|ub_top_sense_done
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|scmd
)paren
suffix:semicolon
r_static
r_int
id|ub_sync_tur
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
)paren
suffix:semicolon
r_static
r_int
id|ub_sync_read_cap
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_capacity
op_star
id|ret
)paren
suffix:semicolon
multiline_comment|/*&n; */
DECL|variable|ub_usb_ids
r_static
r_struct
id|usb_device_id
id|ub_usb_ids
(braket
)braket
op_assign
(brace
singleline_comment|// { USB_DEVICE_VER(0x0781, 0x0002, 0x0009, 0x0009) },&t;/* SDDR-31 */
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|usb
comma
id|ub_usb_ids
)paren
suffix:semicolon
multiline_comment|/*&n; * Find me a way to identify &quot;next free minor&quot; for add_disk(),&n; * and the array disappears the next day. However, the number of&n; * hosts has something to do with the naming and /proc/partitions.&n; * This has to be thought out in detail before changing.&n; * If UB_MAX_HOST was 1000, we&squot;d use a bitmap. Or a better data structure.&n; */
DECL|macro|UB_MAX_HOSTS
mdefine_line|#define UB_MAX_HOSTS  26
DECL|variable|ub_hostv
r_static
r_char
id|ub_hostv
(braket
id|UB_MAX_HOSTS
)braket
suffix:semicolon
DECL|variable|ub_lock
r_static
id|spinlock_t
id|ub_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Locks globals and -&gt;openc */
multiline_comment|/*&n; * The SCSI command tracing procedures.&n; */
DECL|function|ub_cmdtr_new
r_static
r_void
id|ub_cmdtr_new
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_int
id|n
suffix:semicolon
r_struct
id|ub_scsi_cmd_trace
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n
op_assign
id|sc-&gt;tr.cur
op_plus
l_int|1
)paren
op_eq
id|SCMD_TRACE_SZ
)paren
id|n
op_assign
l_int|0
suffix:semicolon
id|t
op_assign
op_amp
id|sc-&gt;tr.vec
(braket
id|n
)braket
suffix:semicolon
id|memset
c_func
(paren
id|t
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ub_scsi_cmd_trace
)paren
)paren
suffix:semicolon
id|t-&gt;tag
op_assign
id|cmd-&gt;tag
suffix:semicolon
id|t-&gt;op
op_assign
id|cmd-&gt;cdb
(braket
l_int|0
)braket
suffix:semicolon
id|t-&gt;dir
op_assign
id|cmd-&gt;dir
suffix:semicolon
id|t-&gt;req_size
op_assign
id|cmd-&gt;len
suffix:semicolon
id|t-&gt;st_hst
(braket
l_int|0
)braket
op_assign
id|cmd-&gt;state
suffix:semicolon
id|sc-&gt;tr.cur
op_assign
id|n
suffix:semicolon
id|cmd-&gt;trace_index
op_assign
id|n
suffix:semicolon
)brace
DECL|function|ub_cmdtr_state
r_static
r_void
id|ub_cmdtr_state
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_int
id|n
suffix:semicolon
r_struct
id|ub_scsi_cmd_trace
op_star
id|t
suffix:semicolon
id|t
op_assign
op_amp
id|sc-&gt;tr.vec
(braket
id|cmd-&gt;trace_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;tag
op_eq
id|cmd-&gt;tag
)paren
(brace
r_if
c_cond
(paren
(paren
id|n
op_assign
id|t-&gt;hcur
op_plus
l_int|1
)paren
op_eq
id|SCMD_ST_HIST_SZ
)paren
id|n
op_assign
l_int|0
suffix:semicolon
id|t-&gt;st_hst
(braket
id|n
)braket
op_assign
id|cmd-&gt;state
suffix:semicolon
id|t-&gt;hcur
op_assign
id|n
suffix:semicolon
)brace
)brace
DECL|function|ub_cmdtr_act_len
r_static
r_void
id|ub_cmdtr_act_len
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_struct
id|ub_scsi_cmd_trace
op_star
id|t
suffix:semicolon
id|t
op_assign
op_amp
id|sc-&gt;tr.vec
(braket
id|cmd-&gt;trace_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;tag
op_eq
id|cmd-&gt;tag
)paren
id|t-&gt;act_size
op_assign
id|cmd-&gt;act_len
suffix:semicolon
)brace
DECL|function|ub_cmdtr_sense
r_static
r_void
id|ub_cmdtr_sense
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
comma
r_int
r_char
op_star
id|sense
)paren
(brace
r_struct
id|ub_scsi_cmd_trace
op_star
id|t
suffix:semicolon
id|t
op_assign
op_amp
id|sc-&gt;tr.vec
(braket
id|cmd-&gt;trace_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;tag
op_eq
id|cmd-&gt;tag
)paren
(brace
id|t-&gt;key
op_assign
id|sense
(braket
l_int|2
)braket
op_amp
l_int|0x0F
suffix:semicolon
id|t-&gt;asc
op_assign
id|sense
(braket
l_int|12
)braket
suffix:semicolon
id|t-&gt;ascq
op_assign
id|sense
(braket
l_int|13
)braket
suffix:semicolon
)brace
)brace
DECL|function|ub_diag_show
r_static
id|ssize_t
id|ub_diag_show
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|page
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
r_struct
id|ub_dev
op_star
id|sc
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|nc
comma
id|nh
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|ub_scsi_cmd_trace
op_star
id|t
suffix:semicolon
id|intf
op_assign
id|to_usb_interface
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sc
op_assign
id|usb_get_intfdata
c_func
(paren
id|intf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|cnt
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cnt
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|cnt
comma
l_string|&quot;qlen %d qmax %d changed %d removable %d readonly %d&bslash;n&quot;
comma
id|sc-&gt;cmd_queue.qlen
comma
id|sc-&gt;cmd_queue.qmax
comma
id|sc-&gt;changed
comma
id|sc-&gt;removable
comma
id|sc-&gt;readonly
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nc
op_assign
id|sc-&gt;tr.cur
op_plus
l_int|1
)paren
op_eq
id|SCMD_TRACE_SZ
)paren
id|nc
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|SCMD_TRACE_SZ
suffix:semicolon
id|j
op_increment
)paren
(brace
id|t
op_assign
op_amp
id|sc-&gt;tr.vec
(braket
id|nc
)braket
suffix:semicolon
id|cnt
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|cnt
comma
l_string|&quot;%08x %02x&quot;
comma
id|t-&gt;tag
comma
id|t-&gt;op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;op
op_eq
id|REQUEST_SENSE
)paren
(brace
id|cnt
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|cnt
comma
l_string|&quot; [sense %x %02x %02x]&quot;
comma
id|t-&gt;key
comma
id|t-&gt;asc
comma
id|t-&gt;ascq
)paren
suffix:semicolon
)brace
r_else
(brace
id|cnt
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|cnt
comma
l_string|&quot; %c&quot;
comma
id|UB_DIR_CHAR
c_func
(paren
id|t-&gt;dir
)paren
)paren
suffix:semicolon
id|cnt
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|cnt
comma
l_string|&quot; [%5d %5d]&quot;
comma
id|t-&gt;req_size
comma
id|t-&gt;act_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|nh
op_assign
id|t-&gt;hcur
op_plus
l_int|1
)paren
op_eq
id|SCMD_ST_HIST_SZ
)paren
id|nh
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCMD_ST_HIST_SZ
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cnt
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|cnt
comma
l_string|&quot; %s&quot;
comma
id|ub_scsi_cmd_stname
(braket
(paren
r_int
)paren
id|t-&gt;st_hst
(braket
id|nh
)braket
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|nh
op_eq
id|SCMD_ST_HIST_SZ
)paren
id|nh
op_assign
l_int|0
suffix:semicolon
)brace
id|cnt
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|cnt
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|nc
op_eq
id|SCMD_TRACE_SZ
)paren
id|nc
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|cnt
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|diag
comma
id|S_IRUGO
comma
id|ub_diag_show
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* N.B. World readable */
multiline_comment|/*&n; * The id allocator.&n; *&n; * This also stores the host for indexing by minor, which is somewhat dirty.&n; */
DECL|function|ub_id_get
r_static
r_int
id|ub_id_get
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ub_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UB_MAX_HOSTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ub_hostv
(braket
id|i
)braket
op_eq
l_int|0
)paren
(brace
id|ub_hostv
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ub_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ub_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|ub_id_put
r_static
r_void
id|ub_id_put
c_func
(paren
r_int
id|id
)paren
(brace
r_if
c_cond
(paren
id|id
OL
l_int|0
op_logical_or
id|id
op_ge
id|UB_MAX_HOSTS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: bad host ID %d&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ub_hostv
(braket
id|id
)braket
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: freeing free host ID %d&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ub_hostv
(braket
id|id
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Final cleanup and deallocation.&n; * This must be called with ub_lock taken.&n; */
DECL|function|ub_cleanup
r_static
r_void
id|ub_cleanup
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
)paren
(brace
multiline_comment|/*&n;&t; * If we zero disk-&gt;private_data BEFORE put_disk, we have to check&n;&t; * for NULL all over the place in open, release, check_media and&n;&t; * revalidate, because the block level semaphore is well inside the&n;&t; * put_disk. But we cannot zero after the call, because *disk is gone.&n;&t; * The sd.c is blatantly racy in this area.&n;&t; */
multiline_comment|/* disk-&gt;private_data = NULL; */
id|put_disk
c_func
(paren
id|sc-&gt;disk
)paren
suffix:semicolon
id|sc-&gt;disk
op_assign
l_int|NULL
suffix:semicolon
id|ub_id_put
c_func
(paren
id|sc-&gt;id
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The &quot;command allocator&quot;.&n; */
DECL|function|ub_get_cmd
r_static
r_struct
id|ub_scsi_cmd
op_star
id|ub_get_cmd
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
)paren
(brace
r_struct
id|ub_scsi_cmd
op_star
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;cmda
(braket
l_int|0
)braket
)paren
r_return
l_int|NULL
suffix:semicolon
id|ret
op_assign
op_amp
id|sc-&gt;cmdv
(braket
l_int|0
)braket
suffix:semicolon
id|sc-&gt;cmda
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ub_put_cmd
r_static
r_void
id|ub_put_cmd
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_ne
op_amp
id|sc-&gt;cmdv
(braket
l_int|0
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: releasing a foreign cmd %p&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sc-&gt;cmda
(braket
l_int|0
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: releasing a free cmd&bslash;n&quot;
comma
id|sc-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sc-&gt;cmda
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The command queue.&n; */
DECL|function|ub_cmdq_add
r_static
r_void
id|ub_cmdq_add
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_struct
id|ub_scsi_cmd_queue
op_star
id|t
op_assign
op_amp
id|sc-&gt;cmd_queue
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;qlen
op_increment
op_eq
l_int|0
)paren
(brace
id|t-&gt;head
op_assign
id|cmd
suffix:semicolon
id|t-&gt;tail
op_assign
id|cmd
suffix:semicolon
)brace
r_else
(brace
id|t-&gt;tail-&gt;next
op_assign
id|cmd
suffix:semicolon
id|t-&gt;tail
op_assign
id|cmd
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t-&gt;qlen
OG
id|t-&gt;qmax
)paren
id|t-&gt;qmax
op_assign
id|t-&gt;qlen
suffix:semicolon
)brace
DECL|function|ub_cmdq_insert
r_static
r_void
id|ub_cmdq_insert
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_struct
id|ub_scsi_cmd_queue
op_star
id|t
op_assign
op_amp
id|sc-&gt;cmd_queue
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;qlen
op_increment
op_eq
l_int|0
)paren
(brace
id|t-&gt;head
op_assign
id|cmd
suffix:semicolon
id|t-&gt;tail
op_assign
id|cmd
suffix:semicolon
)brace
r_else
(brace
id|cmd-&gt;next
op_assign
id|t-&gt;head
suffix:semicolon
id|t-&gt;head
op_assign
id|cmd
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t-&gt;qlen
OG
id|t-&gt;qmax
)paren
id|t-&gt;qmax
op_assign
id|t-&gt;qlen
suffix:semicolon
)brace
DECL|function|ub_cmdq_pop
r_static
r_struct
id|ub_scsi_cmd
op_star
id|ub_cmdq_pop
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
)paren
(brace
r_struct
id|ub_scsi_cmd_queue
op_star
id|t
op_assign
op_amp
id|sc-&gt;cmd_queue
suffix:semicolon
r_struct
id|ub_scsi_cmd
op_star
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;qlen
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|t-&gt;qlen
op_eq
l_int|0
)paren
id|t-&gt;tail
op_assign
l_int|NULL
suffix:semicolon
id|cmd
op_assign
id|t-&gt;head
suffix:semicolon
id|t-&gt;head
op_assign
id|cmd-&gt;next
suffix:semicolon
id|cmd-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|cmd
suffix:semicolon
)brace
DECL|macro|ub_cmdq_peek
mdefine_line|#define ub_cmdq_peek(sc)  ((sc)-&gt;cmd_queue.head)
multiline_comment|/*&n; * The request function is our main entry point&n; */
DECL|function|ub_bd_rq_fn_1
r_static
r_inline
r_int
id|ub_bd_rq_fn_1
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
macro_line|#if 0
r_int
id|writing
op_assign
l_int|0
comma
id|pci_dir
comma
id|i
comma
id|n_elem
suffix:semicolon
id|u32
id|tmp
suffix:semicolon
r_int
r_int
id|msg_size
suffix:semicolon
macro_line|#endif
r_struct
id|ub_dev
op_star
id|sc
op_assign
id|q-&gt;queuedata
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
macro_line|#if 0 /* We use rq-&gt;buffer for now */
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_int
id|n_elem
suffix:semicolon
macro_line|#endif
r_struct
id|ub_scsi_cmd
op_star
id|cmd
suffix:semicolon
r_int
id|ub_dir
suffix:semicolon
r_int
r_int
id|block
comma
id|nblks
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq
op_assign
id|elv_next_request
c_func
(paren
id|q
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sc-&gt;poison
)paren
op_logical_or
id|sc-&gt;changed
)paren
(brace
id|blkdev_dequeue_request
c_func
(paren
id|rq
)paren
suffix:semicolon
id|ub_end_rq
c_func
(paren
id|rq
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cmd
op_assign
id|ub_get_cmd
c_func
(paren
id|sc
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|blk_stop_queue
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|blkdev_dequeue_request
c_func
(paren
id|rq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|WRITE
)paren
id|ub_dir
op_assign
id|UB_DIR_WRITE
suffix:semicolon
r_else
id|ub_dir
op_assign
id|UB_DIR_READ
suffix:semicolon
multiline_comment|/*&n;&t; * get scatterlist from block layer&n;&t; */
macro_line|#if 0 /* We use rq-&gt;buffer for now */
id|sg
op_assign
op_amp
id|cmd-&gt;sgv
(braket
l_int|0
)braket
suffix:semicolon
id|n_elem
op_assign
id|blk_rq_map_sg
c_func
(paren
id|q
comma
id|rq
comma
id|sg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_elem
op_le
l_int|0
)paren
(brace
id|ub_put_cmd
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|ub_end_rq
c_func
(paren
id|rq
comma
l_int|0
)paren
suffix:semicolon
id|blk_start_queue
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* request with no s/g entries? */
)brace
r_if
c_cond
(paren
id|n_elem
op_ne
l_int|1
)paren
(brace
multiline_comment|/* Paranoia */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: request with %d segments&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|n_elem
)paren
suffix:semicolon
id|ub_put_cmd
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|ub_end_rq
c_func
(paren
id|rq
comma
l_int|0
)paren
suffix:semicolon
id|blk_start_queue
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * XXX Unfortunately, this check does not work. It is quite possible&n;&t; * to get bogus non-null rq-&gt;buffer if you allow sg by mistake.&n;&t; */
r_if
c_cond
(paren
id|rq-&gt;buffer
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * This must not happen if we set the queue right.&n;&t;&t; * The block level must create bounce buffers for us.&n;&t;&t; */
r_static
r_int
id|do_print
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|do_print
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: unmapped request&bslash;n&quot;
comma
id|sc-&gt;name
)paren
suffix:semicolon
id|do_print
op_assign
l_int|0
suffix:semicolon
)brace
id|ub_put_cmd
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|ub_end_rq
c_func
(paren
id|rq
comma
l_int|0
)paren
suffix:semicolon
id|blk_start_queue
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * build the command&n;&t; *&n;&t; * The call to blk_queue_hardsect_size() guarantees that request&n;&t; * is aligned, but it is given in terms of 512 byte units, always.&n;&t; */
id|block
op_assign
id|rq-&gt;sector
op_rshift
id|sc-&gt;capacity.bshift
suffix:semicolon
id|nblks
op_assign
id|rq-&gt;nr_sectors
op_rshift
id|sc-&gt;capacity.bshift
suffix:semicolon
id|memset
c_func
(paren
id|cmd
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ub_scsi_cmd
)paren
)paren
suffix:semicolon
id|cmd-&gt;cdb
(braket
l_int|0
)braket
op_assign
(paren
id|ub_dir
op_eq
id|UB_DIR_READ
)paren
ques
c_cond
id|READ_10
suffix:colon
id|WRITE_10
suffix:semicolon
multiline_comment|/* 10-byte uses 4 bytes of LBA: 2147483648KB, 2097152MB, 2048GB */
id|cmd-&gt;cdb
(braket
l_int|2
)braket
op_assign
id|block
op_rshift
l_int|24
suffix:semicolon
id|cmd-&gt;cdb
(braket
l_int|3
)braket
op_assign
id|block
op_rshift
l_int|16
suffix:semicolon
id|cmd-&gt;cdb
(braket
l_int|4
)braket
op_assign
id|block
op_rshift
l_int|8
suffix:semicolon
id|cmd-&gt;cdb
(braket
l_int|5
)braket
op_assign
id|block
suffix:semicolon
id|cmd-&gt;cdb
(braket
l_int|7
)braket
op_assign
id|nblks
op_rshift
l_int|8
suffix:semicolon
id|cmd-&gt;cdb
(braket
l_int|8
)braket
op_assign
id|nblks
suffix:semicolon
id|cmd-&gt;cdb_len
op_assign
l_int|10
suffix:semicolon
id|cmd-&gt;dir
op_assign
id|ub_dir
suffix:semicolon
id|cmd-&gt;state
op_assign
id|UB_CMDST_INIT
suffix:semicolon
id|cmd-&gt;data
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|cmd-&gt;len
op_assign
id|rq-&gt;nr_sectors
op_star
l_int|512
suffix:semicolon
id|cmd-&gt;done
op_assign
id|ub_rw_cmd_done
suffix:semicolon
id|cmd-&gt;back
op_assign
id|rq
suffix:semicolon
id|cmd-&gt;tag
op_assign
id|sc-&gt;tagcnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|ub_submit_scsi
c_func
(paren
id|sc
comma
id|cmd
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ub_put_cmd
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|ub_end_rq
c_func
(paren
id|rq
comma
l_int|0
)paren
suffix:semicolon
id|blk_start_queue
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ub_bd_rq_fn
r_static
r_void
id|ub_bd_rq_fn
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_do
(brace
)brace
r_while
c_loop
(paren
id|ub_bd_rq_fn_1
c_func
(paren
id|q
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|ub_rw_cmd_done
r_static
r_void
id|ub_rw_cmd_done
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|cmd-&gt;back
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
op_assign
id|sc-&gt;disk
suffix:semicolon
id|request_queue_t
op_star
id|q
op_assign
id|disk-&gt;queue
suffix:semicolon
r_int
id|uptodate
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;error
op_eq
l_int|0
)paren
id|uptodate
op_assign
l_int|1
suffix:semicolon
r_else
id|uptodate
op_assign
l_int|0
suffix:semicolon
id|ub_put_cmd
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|ub_end_rq
c_func
(paren
id|rq
comma
id|uptodate
)paren
suffix:semicolon
id|blk_start_queue
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
DECL|function|ub_end_rq
r_static
r_void
id|ub_end_rq
c_func
(paren
r_struct
id|request
op_star
id|rq
comma
r_int
id|uptodate
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|end_that_request_first
c_func
(paren
id|rq
comma
id|uptodate
comma
id|rq-&gt;hard_nr_sectors
)paren
suffix:semicolon
singleline_comment|// assert(rc == 0);
id|end_that_request_last
c_func
(paren
id|rq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Submit a regular SCSI operation (not an auto-sense).&n; *&n; * The Iron Law of Good Submit Routine is:&n; * Zero return - callback is done, Nonzero return - callback is not done.&n; * No exceptions.&n; *&n; * Host is assumed locked.&n; *&n; * XXX We only support Bulk for the moment.&n; */
DECL|function|ub_submit_scsi
r_static
r_int
id|ub_submit_scsi
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;state
op_ne
id|UB_CMDST_INIT
op_logical_or
(paren
id|cmd-&gt;dir
op_ne
id|UB_DIR_NONE
op_logical_and
id|cmd-&gt;len
op_eq
l_int|0
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ub_cmdq_add
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We can call ub_scsi_dispatch(sc) right away here, but it&squot;s a little&n;&t; * safer to jump to a tasklet, in case upper layers do something silly.&n;&t; */
id|tasklet_schedule
c_func
(paren
op_amp
id|sc-&gt;tasklet
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Submit the first URB for the queued command.&n; * This function does not deal with queueing in any way.&n; */
DECL|function|ub_scsi_cmd_start
r_static
r_int
id|ub_scsi_cmd_start
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_struct
id|bulk_cb_wrap
op_star
id|bcb
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|bcb
op_assign
op_amp
id|sc-&gt;work_bcb
suffix:semicolon
multiline_comment|/* set up the command wrapper */
id|bcb-&gt;Signature
op_assign
id|cpu_to_le32
c_func
(paren
id|US_BULK_CB_SIGN
)paren
suffix:semicolon
id|bcb-&gt;Tag
op_assign
id|cmd-&gt;tag
suffix:semicolon
multiline_comment|/* Endianness is not important */
id|bcb-&gt;DataTransferLength
op_assign
id|cpu_to_le32
c_func
(paren
id|cmd-&gt;len
)paren
suffix:semicolon
id|bcb-&gt;Flags
op_assign
(paren
id|cmd-&gt;dir
op_eq
id|UB_DIR_READ
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
suffix:semicolon
id|bcb-&gt;Lun
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No multi-LUN yet */
id|bcb-&gt;Length
op_assign
id|cmd-&gt;cdb_len
suffix:semicolon
multiline_comment|/* copy the command payload */
id|memcpy
c_func
(paren
id|bcb-&gt;CDB
comma
id|cmd-&gt;cdb
comma
id|UB_MAX_CDB_SIZE
)paren
suffix:semicolon
id|UB_INIT_COMPLETION
c_func
(paren
id|sc-&gt;work_done
)paren
suffix:semicolon
id|sc-&gt;last_pipe
op_assign
id|sc-&gt;send_bulk_pipe
suffix:semicolon
id|usb_fill_bulk_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
comma
id|sc-&gt;dev
comma
id|sc-&gt;send_bulk_pipe
comma
id|bcb
comma
id|US_BULK_CB_WRAP_LEN
comma
id|ub_urb_complete
comma
id|sc
)paren
suffix:semicolon
id|sc-&gt;work_urb.transfer_flags
op_assign
id|URB_ASYNC_UNLINK
suffix:semicolon
multiline_comment|/* Fill what we shouldn&squot;t be filling, because usb-storage did so. */
id|sc-&gt;work_urb.actual_length
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.error_count
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|usb_submit_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
comma
id|GFP_ATOMIC
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* XXX Clear stalls */
id|printk
c_func
(paren
l_string|&quot;ub: cmd #%d start failed (%d)&bslash;n&quot;
comma
id|cmd-&gt;tag
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/* P3 */
id|ub_complete
c_func
(paren
op_amp
id|sc-&gt;work_done
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|sc-&gt;work_timer.expires
op_assign
id|jiffies
op_plus
id|UB_URB_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sc-&gt;work_timer
)paren
suffix:semicolon
id|cmd-&gt;state
op_assign
id|UB_CMDST_CMD
suffix:semicolon
id|ub_cmdtr_state
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Timeout handler.&n; */
DECL|function|ub_urb_timeout
r_static
r_void
id|ub_urb_timeout
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|ub_dev
op_star
id|sc
op_assign
(paren
r_struct
id|ub_dev
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Completion routine for the work URB.&n; *&n; * This can be called directly from usb_submit_urb (while we have&n; * the sc-&gt;lock taken) and from an interrupt (while we do NOT have&n; * the sc-&gt;lock taken). Therefore, bounce this off to a tasklet.&n; */
DECL|function|ub_urb_complete
r_static
r_void
id|ub_urb_complete
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|pt
)paren
(brace
r_struct
id|ub_dev
op_star
id|sc
op_assign
id|urb-&gt;context
suffix:semicolon
id|ub_complete
c_func
(paren
op_amp
id|sc-&gt;work_done
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|sc-&gt;tasklet
)paren
suffix:semicolon
)brace
DECL|function|ub_scsi_action
r_static
r_void
id|ub_scsi_action
c_func
(paren
r_int
r_int
id|_dev
)paren
(brace
r_struct
id|ub_dev
op_star
id|sc
op_assign
(paren
r_struct
id|ub_dev
op_star
)paren
id|_dev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sc-&gt;work_timer
)paren
suffix:semicolon
id|ub_scsi_dispatch
c_func
(paren
id|sc
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|ub_scsi_dispatch
r_static
r_void
id|ub_scsi_dispatch
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
)paren
(brace
r_struct
id|ub_scsi_cmd
op_star
id|cmd
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cmd
op_assign
id|ub_cmdq_peek
c_func
(paren
id|sc
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;state
op_eq
id|UB_CMDST_DONE
)paren
(brace
id|ub_cmdq_pop
c_func
(paren
id|sc
)paren
suffix:semicolon
(paren
op_star
id|cmd-&gt;done
)paren
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;state
op_eq
id|UB_CMDST_INIT
)paren
(brace
id|ub_cmdtr_new
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|ub_scsi_cmd_start
c_func
(paren
id|sc
comma
id|cmd
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|cmd-&gt;error
op_assign
id|rc
suffix:semicolon
id|cmd-&gt;state
op_assign
id|UB_CMDST_DONE
suffix:semicolon
id|ub_cmdtr_state
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|ub_is_completed
c_func
(paren
op_amp
id|sc-&gt;work_done
)paren
)paren
r_break
suffix:semicolon
id|ub_scsi_urb_compl
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|ub_scsi_urb_compl
r_static
r_void
id|ub_scsi_urb_compl
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
op_amp
id|sc-&gt;work_urb
suffix:semicolon
r_struct
id|bulk_cs_wrap
op_star
id|bcs
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sc-&gt;poison
)paren
)paren
(brace
multiline_comment|/* A little too simplistic, I feel... */
r_goto
id|Bad_End
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd-&gt;state
op_eq
id|UB_CMDST_CLEAR
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EPIPE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * STALL while clearning STALL.&n;&t;&t;&t; * A STALL is illegal on a control pipe!&n;&t;&t;&t; * XXX Might try to reset the device here and retry.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: &quot;
l_string|&quot;stall on control pipe for device %u&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|sc-&gt;dev-&gt;devnum
)paren
suffix:semicolon
r_goto
id|Bad_End
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We ignore the result for the halt clear.&n;&t;&t; */
multiline_comment|/* reset the endpoint toggle */
id|usb_settoggle
c_func
(paren
id|sc-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|sc-&gt;last_pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|sc-&gt;last_pipe
)paren
comma
l_int|0
)paren
suffix:semicolon
id|ub_state_sense
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;state
op_eq
id|UB_CMDST_CLR2STS
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EPIPE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * STALL while clearning STALL.&n;&t;&t;&t; * A STALL is illegal on a control pipe!&n;&t;&t;&t; * XXX Might try to reset the device here and retry.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: &quot;
l_string|&quot;stall on control pipe for device %u&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|sc-&gt;dev-&gt;devnum
)paren
suffix:semicolon
r_goto
id|Bad_End
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We ignore the result for the halt clear.&n;&t;&t; */
multiline_comment|/* reset the endpoint toggle */
id|usb_settoggle
c_func
(paren
id|sc-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|sc-&gt;last_pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|sc-&gt;last_pipe
)paren
comma
l_int|0
)paren
suffix:semicolon
id|ub_state_stat
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;state
op_eq
id|UB_CMDST_CMD
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EPIPE
)paren
(brace
id|rc
op_assign
id|ub_submit_clear_stall
c_func
(paren
id|sc
comma
id|cmd
comma
id|sc-&gt;last_pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: &quot;
l_string|&quot;unable to submit clear for device %u (%d)&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|sc-&gt;dev-&gt;devnum
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * This is typically ENOMEM or some other such shit.&n;&t;&t;&t;&t; * Retrying is pointless. Just do Bad End on it...&n;&t;&t;&t;&t; */
r_goto
id|Bad_End
suffix:semicolon
)brace
id|cmd-&gt;state
op_assign
id|UB_CMDST_CLEAR
suffix:semicolon
id|ub_cmdtr_state
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ub: cmd #%d cmd status (%d)&bslash;n&quot;
comma
id|cmd-&gt;tag
comma
id|urb-&gt;status
)paren
suffix:semicolon
multiline_comment|/* P3 */
r_goto
id|Bad_End
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;actual_length
op_ne
id|US_BULK_CB_WRAP_LEN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ub: cmd #%d xferred %d&bslash;n&quot;
comma
id|cmd-&gt;tag
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
multiline_comment|/* P3 */
multiline_comment|/* XXX Must do reset here to unconfuse the device */
r_goto
id|Bad_End
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd-&gt;dir
op_eq
id|UB_DIR_NONE
)paren
(brace
id|ub_state_stat
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|UB_INIT_COMPLETION
c_func
(paren
id|sc-&gt;work_done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;dir
op_eq
id|UB_DIR_READ
)paren
id|pipe
op_assign
id|sc-&gt;recv_bulk_pipe
suffix:semicolon
r_else
id|pipe
op_assign
id|sc-&gt;send_bulk_pipe
suffix:semicolon
id|sc-&gt;last_pipe
op_assign
id|pipe
suffix:semicolon
id|usb_fill_bulk_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
comma
id|sc-&gt;dev
comma
id|pipe
comma
id|cmd-&gt;data
comma
id|cmd-&gt;len
comma
id|ub_urb_complete
comma
id|sc
)paren
suffix:semicolon
id|sc-&gt;work_urb.transfer_flags
op_assign
id|URB_ASYNC_UNLINK
suffix:semicolon
id|sc-&gt;work_urb.actual_length
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.error_count
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|usb_submit_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
comma
id|GFP_ATOMIC
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* XXX Clear stalls */
id|printk
c_func
(paren
l_string|&quot;ub: data #%d submit failed (%d)&bslash;n&quot;
comma
id|cmd-&gt;tag
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/* P3 */
id|ub_complete
c_func
(paren
op_amp
id|sc-&gt;work_done
)paren
suffix:semicolon
id|ub_state_done
c_func
(paren
id|sc
comma
id|cmd
comma
id|rc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sc-&gt;work_timer.expires
op_assign
id|jiffies
op_plus
id|UB_DATA_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sc-&gt;work_timer
)paren
suffix:semicolon
id|cmd-&gt;state
op_assign
id|UB_CMDST_DATA
suffix:semicolon
id|ub_cmdtr_state
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;state
op_eq
id|UB_CMDST_DATA
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EPIPE
)paren
(brace
id|rc
op_assign
id|ub_submit_clear_stall
c_func
(paren
id|sc
comma
id|cmd
comma
id|sc-&gt;last_pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: &quot;
l_string|&quot;unable to submit clear for device %u (%d)&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|sc-&gt;dev-&gt;devnum
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * This is typically ENOMEM or some other such shit.&n;&t;&t;&t;&t; * Retrying is pointless. Just do Bad End on it...&n;&t;&t;&t;&t; */
r_goto
id|Bad_End
suffix:semicolon
)brace
id|cmd-&gt;state
op_assign
id|UB_CMDST_CLR2STS
suffix:semicolon
id|ub_cmdtr_state
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EOVERFLOW
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * A babble? Failure, but we must transfer CSW now.&n;&t;&t;&t; */
id|cmd-&gt;error
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
multiline_comment|/* A cheap trick... */
)brace
r_else
(brace
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
l_int|0
)paren
r_goto
id|Bad_End
suffix:semicolon
)brace
id|cmd-&gt;act_len
op_assign
id|urb-&gt;actual_length
suffix:semicolon
id|ub_cmdtr_act_len
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|ub_state_stat
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;state
op_eq
id|UB_CMDST_STAT
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EPIPE
)paren
(brace
id|rc
op_assign
id|ub_submit_clear_stall
c_func
(paren
id|sc
comma
id|cmd
comma
id|sc-&gt;last_pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: &quot;
l_string|&quot;unable to submit clear for device %u (%d)&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|sc-&gt;dev-&gt;devnum
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * This is typically ENOMEM or some other such shit.&n;&t;&t;&t;&t; * Retrying is pointless. Just do Bad End on it...&n;&t;&t;&t;&t; */
r_goto
id|Bad_End
suffix:semicolon
)brace
id|cmd-&gt;state
op_assign
id|UB_CMDST_CLEAR
suffix:semicolon
id|ub_cmdtr_state
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
l_int|0
)paren
r_goto
id|Bad_End
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;actual_length
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Some broken devices add unnecessary zero-length&n;&t;&t;&t; * packets to the end of their data transfers.&n;&t;&t;&t; * Such packets show up as 0-length CSWs. If we&n;&t;&t;&t; * encounter such a thing, try to read the CSW again.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_increment
id|cmd-&gt;stat_count
op_ge
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: &quot;
l_string|&quot;unable to get CSW on device %u&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|sc-&gt;dev-&gt;devnum
)paren
suffix:semicolon
r_goto
id|Bad_End
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * ub_state_stat only not dropping the count...&n;&t;&t;&t; */
id|UB_INIT_COMPLETION
c_func
(paren
id|sc-&gt;work_done
)paren
suffix:semicolon
id|sc-&gt;last_pipe
op_assign
id|sc-&gt;recv_bulk_pipe
suffix:semicolon
id|usb_fill_bulk_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
comma
id|sc-&gt;dev
comma
id|sc-&gt;recv_bulk_pipe
comma
op_amp
id|sc-&gt;work_bcs
comma
id|US_BULK_CS_WRAP_LEN
comma
id|ub_urb_complete
comma
id|sc
)paren
suffix:semicolon
id|sc-&gt;work_urb.transfer_flags
op_assign
id|URB_ASYNC_UNLINK
suffix:semicolon
id|sc-&gt;work_urb.actual_length
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.error_count
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.status
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|usb_submit_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
multiline_comment|/* XXX Clear stalls */
id|printk
c_func
(paren
l_string|&quot;%s: CSW #%d submit failed (%d)&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|cmd-&gt;tag
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/* P3 */
id|ub_complete
c_func
(paren
op_amp
id|sc-&gt;work_done
)paren
suffix:semicolon
id|ub_state_done
c_func
(paren
id|sc
comma
id|cmd
comma
id|rc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sc-&gt;work_timer.expires
op_assign
id|jiffies
op_plus
id|UB_URB_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sc-&gt;work_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check the returned Bulk protocol status.&n;&t;&t; */
id|bcs
op_assign
op_amp
id|sc-&gt;work_bcs
suffix:semicolon
id|rc
op_assign
id|le32_to_cpu
c_func
(paren
id|bcs-&gt;Residue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|cmd-&gt;len
op_minus
id|cmd-&gt;act_len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * It is all right to transfer less, the caller has&n;&t;&t;&t; * to check. But it&squot;s not all right if the device&n;&t;&t;&t; * counts disagree with our counts.&n;&t;&t;&t; */
multiline_comment|/* P3 */
id|printk
c_func
(paren
l_string|&quot;%s: resid %d len %d act %d&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|rc
comma
id|cmd-&gt;len
comma
id|cmd-&gt;act_len
)paren
suffix:semicolon
r_goto
id|Bad_End
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bcs-&gt;Signature
op_ne
id|cpu_to_le32
c_func
(paren
id|US_BULK_CS_SIGN
)paren
op_logical_and
id|bcs-&gt;Signature
op_ne
id|cpu_to_le32
c_func
(paren
id|US_BULK_CS_OLYMPUS_SIGN
)paren
)paren
(brace
multiline_comment|/* XXX Rate-limit, even for P3 tagged */
multiline_comment|/* P3 */
id|printk
c_func
(paren
l_string|&quot;ub: signature 0x%x&bslash;n&quot;
comma
id|bcs-&gt;Signature
)paren
suffix:semicolon
multiline_comment|/* Windows ignores signatures, so do we. */
)brace
r_if
c_cond
(paren
id|bcs-&gt;Tag
op_ne
id|cmd-&gt;tag
)paren
(brace
multiline_comment|/* P3 */
id|printk
c_func
(paren
l_string|&quot;%s: tag orig 0x%x reply 0x%x&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|cmd-&gt;tag
comma
id|bcs-&gt;Tag
)paren
suffix:semicolon
r_goto
id|Bad_End
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|bcs-&gt;Status
)paren
(brace
r_case
id|US_BULK_STAT_OK
suffix:colon
r_break
suffix:semicolon
r_case
id|US_BULK_STAT_FAIL
suffix:colon
id|ub_state_sense
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|US_BULK_STAT_PHASE
suffix:colon
multiline_comment|/* XXX We must reset the transport here */
multiline_comment|/* P3 */
id|printk
c_func
(paren
l_string|&quot;%s: status PHASE&bslash;n&quot;
comma
id|sc-&gt;name
)paren
suffix:semicolon
r_goto
id|Bad_End
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: unknown CSW status 0x%x&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|bcs-&gt;Status
)paren
suffix:semicolon
r_goto
id|Bad_End
suffix:semicolon
)brace
multiline_comment|/* Not zeroing error to preserve a babble indicator */
id|cmd-&gt;state
op_assign
id|UB_CMDST_DONE
suffix:semicolon
id|ub_cmdtr_state
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|ub_cmdq_pop
c_func
(paren
id|sc
)paren
suffix:semicolon
(paren
op_star
id|cmd-&gt;done
)paren
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;state
op_eq
id|UB_CMDST_SENSE
)paren
(brace
id|ub_state_done
c_func
(paren
id|sc
comma
id|cmd
comma
op_minus
id|EIO
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: &quot;
l_string|&quot;wrong command state %d on device %u&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|cmd-&gt;state
comma
id|sc-&gt;dev-&gt;devnum
)paren
suffix:semicolon
r_goto
id|Bad_End
suffix:semicolon
)brace
r_return
suffix:semicolon
id|Bad_End
suffix:colon
multiline_comment|/* Little Excel is dead */
id|ub_state_done
c_func
(paren
id|sc
comma
id|cmd
comma
op_minus
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Factorization helper for the command state machine:&n; * Finish the command.&n; */
DECL|function|ub_state_done
r_static
r_void
id|ub_state_done
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
comma
r_int
id|rc
)paren
(brace
id|cmd-&gt;error
op_assign
id|rc
suffix:semicolon
id|cmd-&gt;state
op_assign
id|UB_CMDST_DONE
suffix:semicolon
id|ub_cmdtr_state
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|ub_cmdq_pop
c_func
(paren
id|sc
)paren
suffix:semicolon
(paren
op_star
id|cmd-&gt;done
)paren
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Factorization helper for the command state machine:&n; * Submit a CSW read and go to STAT state.&n; */
DECL|function|ub_state_stat
r_static
r_void
id|ub_state_stat
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_int
id|rc
suffix:semicolon
id|UB_INIT_COMPLETION
c_func
(paren
id|sc-&gt;work_done
)paren
suffix:semicolon
id|sc-&gt;last_pipe
op_assign
id|sc-&gt;recv_bulk_pipe
suffix:semicolon
id|usb_fill_bulk_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
comma
id|sc-&gt;dev
comma
id|sc-&gt;recv_bulk_pipe
comma
op_amp
id|sc-&gt;work_bcs
comma
id|US_BULK_CS_WRAP_LEN
comma
id|ub_urb_complete
comma
id|sc
)paren
suffix:semicolon
id|sc-&gt;work_urb.transfer_flags
op_assign
id|URB_ASYNC_UNLINK
suffix:semicolon
id|sc-&gt;work_urb.actual_length
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.error_count
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|usb_submit_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
comma
id|GFP_ATOMIC
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* XXX Clear stalls */
id|printk
c_func
(paren
l_string|&quot;ub: CSW #%d submit failed (%d)&bslash;n&quot;
comma
id|cmd-&gt;tag
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/* P3 */
id|ub_complete
c_func
(paren
op_amp
id|sc-&gt;work_done
)paren
suffix:semicolon
id|ub_state_done
c_func
(paren
id|sc
comma
id|cmd
comma
id|rc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sc-&gt;work_timer.expires
op_assign
id|jiffies
op_plus
id|UB_URB_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sc-&gt;work_timer
)paren
suffix:semicolon
id|cmd-&gt;stat_count
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;state
op_assign
id|UB_CMDST_STAT
suffix:semicolon
id|ub_cmdtr_state
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Factorization helper for the command state machine:&n; * Submit a REQUEST SENSE and go to SENSE state.&n; */
DECL|function|ub_state_sense
r_static
r_void
id|ub_state_sense
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_struct
id|ub_scsi_cmd
op_star
id|scmd
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cdb
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|rc
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ``If the allocation length is eighteen or greater, and a device&n;&t; * server returns less than eithteen bytes of data, the application&n;&t; * client should assume that the bytes not transferred would have been&n;&t; * zeroes had the device server returned those bytes.&squot;&squot;&n;&t; */
id|memset
c_func
(paren
op_amp
id|sc-&gt;top_sense
comma
l_int|0
comma
id|UB_SENSE_SIZE
)paren
suffix:semicolon
id|scmd
op_assign
op_amp
id|sc-&gt;top_rqs_cmd
suffix:semicolon
id|scmd-&gt;cdb
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|scmd-&gt;cdb
(braket
l_int|4
)braket
op_assign
id|UB_SENSE_SIZE
suffix:semicolon
id|scmd-&gt;cdb_len
op_assign
l_int|6
suffix:semicolon
id|scmd-&gt;dir
op_assign
id|UB_DIR_READ
suffix:semicolon
id|scmd-&gt;state
op_assign
id|UB_CMDST_INIT
suffix:semicolon
id|scmd-&gt;data
op_assign
id|sc-&gt;top_sense
suffix:semicolon
id|scmd-&gt;len
op_assign
id|UB_SENSE_SIZE
suffix:semicolon
id|scmd-&gt;done
op_assign
id|ub_top_sense_done
suffix:semicolon
id|scmd-&gt;back
op_assign
id|cmd
suffix:semicolon
id|scmd-&gt;tag
op_assign
id|sc-&gt;tagcnt
op_increment
suffix:semicolon
id|cmd-&gt;state
op_assign
id|UB_CMDST_SENSE
suffix:semicolon
id|ub_cmdtr_state
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|ub_cmdq_insert
c_func
(paren
id|sc
comma
id|scmd
)paren
suffix:semicolon
r_return
suffix:semicolon
id|error
suffix:colon
id|ub_state_done
c_func
(paren
id|sc
comma
id|cmd
comma
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * A helper for the command&squot;s state machine:&n; * Submit a stall clear.&n; */
DECL|function|ub_submit_clear_stall
r_static
r_int
id|ub_submit_clear_stall
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
comma
r_int
id|stalled_pipe
)paren
(brace
r_int
id|endp
suffix:semicolon
r_struct
id|usb_ctrlrequest
op_star
id|cr
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|endp
op_assign
id|usb_pipeendpoint
c_func
(paren
id|stalled_pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|stalled_pipe
)paren
)paren
id|endp
op_or_assign
id|USB_DIR_IN
suffix:semicolon
id|cr
op_assign
op_amp
id|sc-&gt;work_cr
suffix:semicolon
id|cr-&gt;bRequestType
op_assign
id|USB_RECIP_ENDPOINT
suffix:semicolon
id|cr-&gt;bRequest
op_assign
id|USB_REQ_CLEAR_FEATURE
suffix:semicolon
id|cr-&gt;wValue
op_assign
id|cpu_to_le16
c_func
(paren
id|USB_ENDPOINT_HALT
)paren
suffix:semicolon
id|cr-&gt;wIndex
op_assign
id|cpu_to_le16
c_func
(paren
id|endp
)paren
suffix:semicolon
id|cr-&gt;wLength
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|UB_INIT_COMPLETION
c_func
(paren
id|sc-&gt;work_done
)paren
suffix:semicolon
id|usb_fill_control_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
comma
id|sc-&gt;dev
comma
id|sc-&gt;send_ctrl_pipe
comma
(paren
r_int
r_char
op_star
)paren
id|cr
comma
l_int|NULL
comma
l_int|0
comma
id|ub_urb_complete
comma
id|sc
)paren
suffix:semicolon
id|sc-&gt;work_urb.transfer_flags
op_assign
id|URB_ASYNC_UNLINK
suffix:semicolon
id|sc-&gt;work_urb.actual_length
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.error_count
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|usb_submit_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
comma
id|GFP_ATOMIC
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ub_complete
c_func
(paren
op_amp
id|sc-&gt;work_done
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|sc-&gt;work_timer.expires
op_assign
id|jiffies
op_plus
id|UB_CTRL_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sc-&gt;work_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|function|ub_top_sense_done
r_static
r_void
id|ub_top_sense_done
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|scmd
)paren
(brace
r_int
r_char
op_star
id|sense
op_assign
id|scmd-&gt;data
suffix:semicolon
r_struct
id|ub_scsi_cmd
op_star
id|cmd
suffix:semicolon
multiline_comment|/*&n;&t; * Ignoring scmd-&gt;act_len, because the buffer was pre-zeroed.&n;&t; */
id|ub_cmdtr_sense
c_func
(paren
id|sc
comma
id|scmd
comma
id|sense
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the command which triggered the unit attention or a check,&n;&t; * save the sense into it, and advance its state machine.&n;&t; */
r_if
c_cond
(paren
(paren
id|cmd
op_assign
id|ub_cmdq_peek
c_func
(paren
id|sc
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: sense done while idle&bslash;n&quot;
comma
id|sc-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_ne
id|scmd-&gt;back
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: &quot;
l_string|&quot;sense done for wrong command 0x%x on device %u&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|cmd-&gt;tag
comma
id|sc-&gt;dev-&gt;devnum
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd-&gt;state
op_ne
id|UB_CMDST_SENSE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: &quot;
l_string|&quot;sense done with bad cmd state %d on device %u&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|cmd-&gt;state
comma
id|sc-&gt;dev-&gt;devnum
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cmd-&gt;key
op_assign
id|sense
(braket
l_int|2
)braket
op_amp
l_int|0x0F
suffix:semicolon
id|cmd-&gt;asc
op_assign
id|sense
(braket
l_int|12
)braket
suffix:semicolon
id|cmd-&gt;ascq
op_assign
id|sense
(braket
l_int|13
)braket
suffix:semicolon
id|ub_scsi_urb_compl
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* Determine what the maximum LUN supported is */
r_int
id|usb_stor_Bulk_max_lun
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* issue the command */
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|us-&gt;recv_ctrl_pipe
comma
id|US_BULK_GET_MAX_LUN
comma
id|USB_DIR_IN
op_or
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|us-&gt;iobuf
comma
l_int|1
comma
id|HZ
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Some devices (i.e. Iomega Zip100) need this -- apparently&n;&t; * the bulk pipes get STALLed when the GetMaxLUN request is&n;&t; * processed.   This is, in theory, harmless to all other devices&n;&t; * (regardless of if they stall or not).&n;&t; */
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|usb_stor_clear_halt
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
)paren
suffix:semicolon
id|usb_stor_clear_halt
c_func
(paren
id|us
comma
id|us-&gt;send_bulk_pipe
)paren
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;GetMaxLUN command result is %d, data is %d&bslash;n&quot;
comma
id|result
comma
id|us-&gt;iobuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* if we have a successful request, return the result */
r_if
c_cond
(paren
id|result
op_eq
l_int|1
)paren
r_return
id|us-&gt;iobuf
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* return the default -- no LUNs */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * This is called from a process context.&n; */
DECL|function|ub_revalidate
r_static
r_void
id|ub_revalidate
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
)paren
(brace
id|sc-&gt;readonly
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* XXX Query this from the device */
id|sc-&gt;capacity.nsec
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;capacity.bsize
op_assign
l_int|512
suffix:semicolon
id|sc-&gt;capacity.bshift
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ub_sync_tur
c_func
(paren
id|sc
)paren
op_ne
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Not ready */
id|sc-&gt;changed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ub_sync_read_cap
c_func
(paren
id|sc
comma
op_amp
id|sc-&gt;capacity
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The retry here means something is wrong, either with the&n;&t;&t; * device, with the transport, or with our code.&n;&t;&t; * We keep this because sd.c has retries for capacity.&n;&t;&t; */
r_if
c_cond
(paren
id|ub_sync_read_cap
c_func
(paren
id|sc
comma
op_amp
id|sc-&gt;capacity
)paren
op_ne
l_int|0
)paren
(brace
id|sc-&gt;capacity.nsec
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;capacity.bsize
op_assign
l_int|512
suffix:semicolon
id|sc-&gt;capacity.bshift
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * The open funcion.&n; * This is mostly needed to keep refcounting, but also to support&n; * media checks on removable media drives.&n; */
DECL|function|ub_bd_open
r_static
r_int
id|ub_bd_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk
suffix:semicolon
r_struct
id|ub_dev
op_star
id|sc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sc
op_assign
id|disk-&gt;private_data
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ub_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sc-&gt;poison
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ub_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|sc-&gt;openc
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ub_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is a workaround for a specific problem in our block layer.&n;&t; * In 2.6.9, register_disk duplicates the code from rescan_partitions.&n;&t; * However, if we do add_disk with a device which persistently reports&n;&t; * a changed media, add_disk calls register_disk, which does do_open,&n;&t; * which will call rescan_paritions for changed media. After that,&n;&t; * register_disk attempts to do it all again and causes double kobject&n;&t; * registration and a eventually an oops on module removal.&n;&t; *&n;&t; * The bottom line is, Al Viro says that we should not allow&n;&t; * bdev-&gt;bd_invalidated to be set when doing add_disk no matter what.&n;&t; */
r_if
c_cond
(paren
id|sc-&gt;first_open
)paren
(brace
r_if
c_cond
(paren
id|sc-&gt;changed
)paren
(brace
id|sc-&gt;first_open
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_goto
id|err_open
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sc-&gt;removable
op_logical_or
id|sc-&gt;readonly
)paren
id|check_disk_change
c_func
(paren
id|inode-&gt;i_bdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The sd.c considers -&gt;media_present and -&gt;changed not equivalent,&n;&t; * under some pretty murky conditions (a failure of READ CAPACITY).&n;&t; * We may need it one day.&n;&t; */
r_if
c_cond
(paren
id|sc-&gt;removable
op_logical_and
id|sc-&gt;changed
op_logical_and
op_logical_neg
(paren
id|filp-&gt;f_flags
op_amp
id|O_NDELAY
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEDIUM
suffix:semicolon
r_goto
id|err_open
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sc-&gt;readonly
op_logical_and
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|err_open
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|err_open
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ub_lock
comma
id|flags
)paren
suffix:semicolon
op_decrement
id|sc-&gt;openc
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;openc
op_eq
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|sc-&gt;poison
)paren
)paren
id|ub_cleanup
c_func
(paren
id|sc
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ub_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|function|ub_bd_release
r_static
r_int
id|ub_bd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk
suffix:semicolon
r_struct
id|ub_dev
op_star
id|sc
op_assign
id|disk-&gt;private_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ub_lock
comma
id|flags
)paren
suffix:semicolon
op_decrement
id|sc-&gt;openc
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;openc
op_eq
l_int|0
)paren
id|sc-&gt;first_open
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;openc
op_eq
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|sc-&gt;poison
)paren
)paren
id|ub_cleanup
c_func
(paren
id|sc
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ub_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The ioctl interface.&n; */
DECL|function|ub_bd_ioctl
r_static
r_int
id|ub_bd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
singleline_comment|// void __user *usermem = (void *) arg;
singleline_comment|// struct carm_port *port = ino-&gt;i_bdev-&gt;bd_disk-&gt;private_data;
singleline_comment|// struct hd_geometry geom;
macro_line|#if 0
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
r_if
c_cond
(paren
id|usermem
op_eq
l_int|NULL
)paren
singleline_comment|// XXX Bizzare. Why?
r_return
op_minus
id|EINVAL
suffix:semicolon
id|geom.heads
op_assign
(paren
id|u8
)paren
id|port-&gt;dev_geom_head
suffix:semicolon
id|geom.sectors
op_assign
(paren
id|u8
)paren
id|port-&gt;dev_geom_sect
suffix:semicolon
id|geom.cylinders
op_assign
id|port-&gt;dev_geom_cyl
suffix:semicolon
id|geom.start
op_assign
id|get_start_sect
c_func
(paren
id|ino-&gt;i_bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|usermem
comma
op_amp
id|geom
comma
r_sizeof
(paren
id|geom
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
)brace
macro_line|#endif
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called once a new disk was seen by the block layer or by ub_probe().&n; * The main onjective here is to discover the features of the media such as&n; * the capacity, read-only status, etc. USB storage generally does not&n; * need to be spun up, but if we needed it, this would be the place.&n; *&n; * This call can sleep.&n; *&n; * The return code is not used.&n; */
DECL|function|ub_bd_revalidate
r_static
r_int
id|ub_bd_revalidate
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_struct
id|ub_dev
op_star
id|sc
op_assign
id|disk-&gt;private_data
suffix:semicolon
id|ub_revalidate
c_func
(paren
id|sc
)paren
suffix:semicolon
multiline_comment|/* This is pretty much a long term P3 */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: device %u capacity nsec %ld bsize %u&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|sc-&gt;dev-&gt;devnum
comma
id|sc-&gt;capacity.nsec
comma
id|sc-&gt;capacity.bsize
)paren
suffix:semicolon
multiline_comment|/* XXX Support sector size switching like in sr.c */
id|blk_queue_hardsect_size
c_func
(paren
id|disk-&gt;queue
comma
id|sc-&gt;capacity.bsize
)paren
suffix:semicolon
id|set_capacity
c_func
(paren
id|disk
comma
id|sc-&gt;capacity.nsec
)paren
suffix:semicolon
singleline_comment|// set_disk_ro(sdkp-&gt;disk, sc-&gt;readonly);
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The check is called by the block layer to verify if the media&n; * is still available. It is supposed to be harmless, lightweight and&n; * non-intrusive in case the media was not changed.&n; *&n; * This call can sleep.&n; *&n; * The return code is bool!&n; */
DECL|function|ub_bd_media_changed
r_static
r_int
id|ub_bd_media_changed
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_struct
id|ub_dev
op_star
id|sc
op_assign
id|disk-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sc-&gt;removable
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We clean checks always after every command, so this is not&n;&t; * as dangerous as it looks. If the TEST_UNIT_READY fails here,&n;&t; * the device is actually not ready with operator or software&n;&t; * intervention required. One dangerous item might be a drive which&n;&t; * spins itself down, and come the time to write dirty pages, this&n;&t; * will fail, then block layer discards the data. Since we never&n;&t; * spin drives up, such devices simply cannot be used with ub anyway.&n;&t; */
r_if
c_cond
(paren
id|ub_sync_tur
c_func
(paren
id|sc
)paren
op_ne
l_int|0
)paren
(brace
id|sc-&gt;changed
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|sc-&gt;changed
suffix:semicolon
)brace
DECL|variable|ub_bd_fops
r_static
r_struct
id|block_device_operations
id|ub_bd_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|ub_bd_open
comma
dot
id|release
op_assign
id|ub_bd_release
comma
dot
id|ioctl
op_assign
id|ub_bd_ioctl
comma
dot
id|media_changed
op_assign
id|ub_bd_media_changed
comma
dot
id|revalidate_disk
op_assign
id|ub_bd_revalidate
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Common -&gt;done routine for commands executed synchronously.&n; */
DECL|function|ub_probe_done
r_static
r_void
id|ub_probe_done
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_scsi_cmd
op_star
id|cmd
)paren
(brace
r_struct
id|completion
op_star
id|cop
op_assign
id|cmd-&gt;back
suffix:semicolon
id|complete
c_func
(paren
id|cop
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Test if the device has a check condition on it, synchronously.&n; */
DECL|function|ub_sync_tur
r_static
r_int
id|ub_sync_tur
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
)paren
(brace
r_struct
id|ub_scsi_cmd
op_star
id|cmd
suffix:semicolon
r_enum
(brace
id|ALLOC_SIZE
op_assign
r_sizeof
(paren
r_struct
id|ub_scsi_cmd
)paren
)brace
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|completion
op_complement
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
op_complement
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_assign
id|kmalloc
c_func
(paren
id|ALLOC_SIZE
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|err_alloc
suffix:semicolon
id|memset
c_func
(paren
id|cmd
comma
l_int|0
comma
id|ALLOC_SIZE
)paren
suffix:semicolon
id|cmd-&gt;cdb
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
id|cmd-&gt;cdb_len
op_assign
l_int|6
suffix:semicolon
id|cmd-&gt;dir
op_assign
id|UB_DIR_NONE
suffix:semicolon
id|cmd-&gt;state
op_assign
id|UB_CMDST_INIT
suffix:semicolon
id|cmd-&gt;done
op_assign
id|ub_probe_done
suffix:semicolon
id|cmd-&gt;back
op_assign
op_amp
op_complement
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cmd-&gt;tag
op_assign
id|sc-&gt;tagcnt
op_increment
suffix:semicolon
id|rc
op_assign
id|ub_submit_scsi
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ub: testing ready: submit error (%d)&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/* P3 */
r_goto
id|err_submit
suffix:semicolon
)brace
id|wait_for_completion
c_func
(paren
op_amp
op_complement
)paren
suffix:semicolon
id|rc
op_assign
id|cmd-&gt;error
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EIO
op_logical_and
id|cmd-&gt;key
op_ne
l_int|0
)paren
multiline_comment|/* Retries for benh&squot;s key */
id|rc
op_assign
id|cmd-&gt;key
suffix:semicolon
id|err_submit
suffix:colon
id|kfree
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|err_alloc
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the SCSI capacity synchronously (for probing).&n; */
DECL|function|ub_sync_read_cap
r_static
r_int
id|ub_sync_read_cap
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|ub_capacity
op_star
id|ret
)paren
(brace
r_struct
id|ub_scsi_cmd
op_star
id|cmd
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_enum
(brace
id|ALLOC_SIZE
op_assign
r_sizeof
(paren
r_struct
id|ub_scsi_cmd
)paren
op_plus
l_int|8
)brace
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|bsize
comma
id|shift
suffix:semicolon
r_int
r_int
id|nsec
suffix:semicolon
r_struct
id|completion
op_complement
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
op_complement
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_assign
id|kmalloc
c_func
(paren
id|ALLOC_SIZE
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|err_alloc
suffix:semicolon
id|memset
c_func
(paren
id|cmd
comma
l_int|0
comma
id|ALLOC_SIZE
)paren
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|cmd
op_plus
r_sizeof
(paren
r_struct
id|ub_scsi_cmd
)paren
suffix:semicolon
id|cmd-&gt;cdb
(braket
l_int|0
)braket
op_assign
l_int|0x25
suffix:semicolon
id|cmd-&gt;cdb_len
op_assign
l_int|10
suffix:semicolon
id|cmd-&gt;dir
op_assign
id|UB_DIR_READ
suffix:semicolon
id|cmd-&gt;state
op_assign
id|UB_CMDST_INIT
suffix:semicolon
id|cmd-&gt;data
op_assign
id|p
suffix:semicolon
id|cmd-&gt;len
op_assign
l_int|8
suffix:semicolon
id|cmd-&gt;done
op_assign
id|ub_probe_done
suffix:semicolon
id|cmd-&gt;back
op_assign
op_amp
op_complement
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cmd-&gt;tag
op_assign
id|sc-&gt;tagcnt
op_increment
suffix:semicolon
id|rc
op_assign
id|ub_submit_scsi
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ub: reading capacity: submit error (%d)&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/* P3 */
r_goto
id|err_submit
suffix:semicolon
)brace
id|wait_for_completion
c_func
(paren
op_amp
op_complement
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;error
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ub: reading capacity: error %d&bslash;n&quot;
comma
id|cmd-&gt;error
)paren
suffix:semicolon
multiline_comment|/* P3 */
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_read
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd-&gt;act_len
op_ne
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ub: reading capacity: size %d&bslash;n&quot;
comma
id|cmd-&gt;act_len
)paren
suffix:semicolon
multiline_comment|/* P3 */
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_read
suffix:semicolon
)brace
multiline_comment|/* sd.c special-cases sector size of 0 to mean 512. Needed? Safe? */
id|nsec
op_assign
id|be32_to_cpu
c_func
(paren
op_star
(paren
id|__be32
op_star
)paren
id|p
)paren
op_plus
l_int|1
suffix:semicolon
id|bsize
op_assign
id|be32_to_cpu
c_func
(paren
op_star
(paren
id|__be32
op_star
)paren
(paren
id|p
op_plus
l_int|4
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bsize
)paren
(brace
r_case
l_int|512
suffix:colon
id|shift
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1024
suffix:colon
id|shift
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2048
suffix:colon
id|shift
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4096
suffix:colon
id|shift
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ub: Bad sector size %u&bslash;n&quot;
comma
id|bsize
)paren
suffix:semicolon
multiline_comment|/* P3 */
id|rc
op_assign
op_minus
id|EDOM
suffix:semicolon
r_goto
id|err_inv_bsize
suffix:semicolon
)brace
id|ret-&gt;bsize
op_assign
id|bsize
suffix:semicolon
id|ret-&gt;bshift
op_assign
id|shift
suffix:semicolon
id|ret-&gt;nsec
op_assign
id|nsec
op_lshift
id|shift
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
id|err_inv_bsize
suffix:colon
id|err_read
suffix:colon
id|err_submit
suffix:colon
id|kfree
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|err_alloc
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|function|ub_probe_urb_complete
r_static
r_void
id|ub_probe_urb_complete
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|pt
)paren
(brace
r_struct
id|completion
op_star
id|cop
op_assign
id|urb-&gt;context
suffix:semicolon
id|complete
c_func
(paren
id|cop
)paren
suffix:semicolon
)brace
DECL|function|ub_probe_timeout
r_static
r_void
id|ub_probe_timeout
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|completion
op_star
id|cop
op_assign
(paren
r_struct
id|completion
op_star
)paren
id|arg
suffix:semicolon
id|complete
c_func
(paren
id|cop
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Clear initial stalls.&n; */
DECL|function|ub_probe_clear_stall
r_static
r_int
id|ub_probe_clear_stall
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_int
id|stalled_pipe
)paren
(brace
r_int
id|endp
suffix:semicolon
r_struct
id|usb_ctrlrequest
op_star
id|cr
suffix:semicolon
r_struct
id|completion
op_complement
suffix:semicolon
r_struct
id|timer_list
id|timer
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
op_complement
)paren
suffix:semicolon
id|endp
op_assign
id|usb_pipeendpoint
c_func
(paren
id|stalled_pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|stalled_pipe
)paren
)paren
id|endp
op_or_assign
id|USB_DIR_IN
suffix:semicolon
id|cr
op_assign
op_amp
id|sc-&gt;work_cr
suffix:semicolon
id|cr-&gt;bRequestType
op_assign
id|USB_RECIP_ENDPOINT
suffix:semicolon
id|cr-&gt;bRequest
op_assign
id|USB_REQ_CLEAR_FEATURE
suffix:semicolon
id|cr-&gt;wValue
op_assign
id|cpu_to_le16
c_func
(paren
id|USB_ENDPOINT_HALT
)paren
suffix:semicolon
id|cr-&gt;wIndex
op_assign
id|cpu_to_le16
c_func
(paren
id|endp
)paren
suffix:semicolon
id|cr-&gt;wLength
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|usb_fill_control_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
comma
id|sc-&gt;dev
comma
id|sc-&gt;send_ctrl_pipe
comma
(paren
r_int
r_char
op_star
)paren
id|cr
comma
l_int|NULL
comma
l_int|0
comma
id|ub_probe_urb_complete
comma
op_amp
op_complement
)paren
suffix:semicolon
id|sc-&gt;work_urb.transfer_flags
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.actual_length
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.error_count
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;work_urb.status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|usb_submit_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
comma
id|GFP_KERNEL
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Unable to submit a probe clear (%d)&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|init_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.function
op_assign
id|ub_probe_timeout
suffix:semicolon
id|timer.data
op_assign
(paren
r_int
r_int
)paren
op_amp
op_complement
suffix:semicolon
id|timer.expires
op_assign
id|jiffies
op_plus
id|UB_CTRL_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
op_complement
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|usb_kill_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
)paren
suffix:semicolon
multiline_comment|/* reset the endpoint toggle */
id|usb_settoggle
c_func
(paren
id|sc-&gt;dev
comma
id|endp
comma
id|usb_pipeout
c_func
(paren
id|sc-&gt;last_pipe
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the pipe settings.&n; */
DECL|function|ub_get_pipes
r_static
r_int
id|ub_get_pipes
c_func
(paren
r_struct
id|ub_dev
op_star
id|sc
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|altsetting
op_assign
id|intf-&gt;cur_altsetting
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_in
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_out
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Find the endpoints we need.&n;&t; * We are expecting a minimum of 2 endpoints - in and out (bulk).&n;&t; * We will ignore any others.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|altsetting-&gt;desc.bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ep
op_assign
op_amp
id|altsetting-&gt;endpoint
(braket
id|i
)braket
dot
id|desc
suffix:semicolon
multiline_comment|/* Is it a BULK endpoint? */
r_if
c_cond
(paren
(paren
id|ep-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_BULK
)paren
(brace
multiline_comment|/* BULK in or out? */
r_if
c_cond
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
id|ep_in
op_assign
id|ep
suffix:semicolon
r_else
id|ep_out
op_assign
id|ep
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ep_in
op_eq
l_int|NULL
op_logical_or
id|ep_out
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: device %u failed endpoint check&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|sc-&gt;dev-&gt;devnum
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Calculate and store the pipe values */
id|sc-&gt;send_ctrl_pipe
op_assign
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|sc-&gt;recv_ctrl_pipe
op_assign
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|sc-&gt;send_bulk_pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|dev
comma
id|ep_out-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
id|sc-&gt;recv_bulk_pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|dev
comma
id|ep_in-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Probing is done in the process context, which allows us to cheat&n; * and not to build a state machine for the discovery.&n; */
DECL|function|ub_probe
r_static
r_int
id|ub_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|dev_id
)paren
(brace
r_struct
id|ub_dev
op_star
id|sc
suffix:semicolon
id|request_queue_t
op_star
id|q
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|i
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ub_dev
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|err_core
suffix:semicolon
id|memset
c_func
(paren
id|sc
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ub_dev
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sc-&gt;lock
)paren
suffix:semicolon
id|usb_init_urb
c_func
(paren
op_amp
id|sc-&gt;work_urb
)paren
suffix:semicolon
id|tasklet_init
c_func
(paren
op_amp
id|sc-&gt;tasklet
comma
id|ub_scsi_action
comma
(paren
r_int
r_int
)paren
id|sc
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sc-&gt;poison
comma
l_int|0
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sc-&gt;work_timer
)paren
suffix:semicolon
id|sc-&gt;work_timer.data
op_assign
(paren
r_int
r_int
)paren
id|sc
suffix:semicolon
id|sc-&gt;work_timer.function
op_assign
id|ub_urb_timeout
suffix:semicolon
id|ub_init_completion
c_func
(paren
op_amp
id|sc-&gt;work_done
)paren
suffix:semicolon
id|sc-&gt;work_done.done
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* A little yuk, but oh well... */
id|rc
op_assign
op_minus
id|ENOSR
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sc-&gt;id
op_assign
id|ub_id_get
c_func
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
r_goto
id|err_id
suffix:semicolon
id|snprintf
c_func
(paren
id|sc-&gt;name
comma
l_int|8
comma
id|DRV_NAME
l_string|&quot;%c&quot;
comma
id|sc-&gt;id
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
id|sc-&gt;dev
op_assign
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
suffix:semicolon
id|sc-&gt;intf
op_assign
id|intf
suffix:semicolon
singleline_comment|// sc-&gt;ifnum = intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber;
id|usb_set_intfdata
c_func
(paren
id|intf
comma
id|sc
)paren
suffix:semicolon
id|usb_get_dev
c_func
(paren
id|sc-&gt;dev
)paren
suffix:semicolon
singleline_comment|// usb_get_intf(sc-&gt;intf);&t;/* Do we need this? */
multiline_comment|/* XXX Verify that we can handle the device (from descriptors) */
id|ub_get_pipes
c_func
(paren
id|sc
comma
id|sc-&gt;dev
comma
id|intf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device_create_file
c_func
(paren
op_amp
id|sc-&gt;intf-&gt;dev
comma
op_amp
id|dev_attr_diag
)paren
op_ne
l_int|0
)paren
r_goto
id|err_diag
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, all USB initialization is done, do upper layer.&n;&t; * We really hate halfway initialized structures, so from the&n;&t; * invariants perspective, this ub_dev is fully constructed at&n;&t; * this point.&n;&t; */
multiline_comment|/*&n;&t; * This is needed to clear toggles. It is a problem only if we do&n;&t; * `rmmod ub &amp;&amp; modprobe ub` without disconnects, but we like that.&n;&t; */
id|ub_probe_clear_stall
c_func
(paren
id|sc
comma
id|sc-&gt;recv_bulk_pipe
)paren
suffix:semicolon
id|ub_probe_clear_stall
c_func
(paren
id|sc
comma
id|sc-&gt;send_bulk_pipe
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The way this is used by the startup code is a little specific.&n;&t; * A SCSI check causes a USB stall. Our common case code sees it&n;&t; * and clears the check, after which the device is ready for use.&n;&t; * But if a check was not present, any command other than&n;&t; * TEST_UNIT_READY ends with a lockup (including REQUEST_SENSE).&n;&t; *&n;&t; * If we neglect to clear the SCSI check, the first real command fails&n;&t; * (which is the capacity readout). We clear that and retry, but why&n;&t; * causing spurious retries for no reason.&n;&t; *&n;&t; * Revalidation may start with its own TEST_UNIT_READY, but that one&n;&t; * has to succeed, so we clear checks with an additional one here.&n;&t; * In any case it&squot;s not our business how revaliadation is implemented.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Retries for benh&squot;s key */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|ub_sync_tur
c_func
(paren
id|sc
)paren
)paren
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0x6
)paren
r_break
suffix:semicolon
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
id|sc-&gt;removable
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* XXX Query this from the device */
id|sc-&gt;changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ub_revalidate clears only */
id|sc-&gt;first_open
op_assign
l_int|1
suffix:semicolon
id|ub_revalidate
c_func
(paren
id|sc
)paren
suffix:semicolon
multiline_comment|/* This is pretty much a long term P3 */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: device %u capacity nsec %ld bsize %u&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|sc-&gt;dev-&gt;devnum
comma
id|sc-&gt;capacity.nsec
comma
id|sc-&gt;capacity.bsize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Just one disk per sc currently, but maybe more.&n;&t; */
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|disk
op_assign
id|alloc_disk
c_func
(paren
id|UB_MINORS_PER_MAJOR
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|err_diskalloc
suffix:semicolon
id|sc-&gt;disk
op_assign
id|disk
suffix:semicolon
id|sprintf
c_func
(paren
id|disk-&gt;disk_name
comma
id|DRV_NAME
l_string|&quot;%c&quot;
comma
id|sc-&gt;id
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|disk-&gt;devfs_name
comma
id|DEVFS_NAME
l_string|&quot;/%c&quot;
comma
id|sc-&gt;id
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
id|disk-&gt;major
op_assign
id|UB_MAJOR
suffix:semicolon
id|disk-&gt;first_minor
op_assign
id|sc-&gt;id
op_star
id|UB_MINORS_PER_MAJOR
suffix:semicolon
id|disk-&gt;fops
op_assign
op_amp
id|ub_bd_fops
suffix:semicolon
id|disk-&gt;private_data
op_assign
id|sc
suffix:semicolon
id|disk-&gt;driverfs_dev
op_assign
op_amp
id|intf-&gt;dev
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_assign
id|blk_init_queue
c_func
(paren
id|ub_bd_rq_fn
comma
op_amp
id|sc-&gt;lock
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|err_blkqinit
suffix:semicolon
id|disk-&gt;queue
op_assign
id|q
suffix:semicolon
singleline_comment|// blk_queue_bounce_limit(q, hba[i]-&gt;pdev-&gt;dma_mask);
id|blk_queue_max_hw_segments
c_func
(paren
id|q
comma
id|UB_MAX_REQ_SG
)paren
suffix:semicolon
id|blk_queue_max_phys_segments
c_func
(paren
id|q
comma
id|UB_MAX_REQ_SG
)paren
suffix:semicolon
singleline_comment|// blk_queue_segment_boundary(q, CARM_SG_BOUNDARY);
id|blk_queue_max_sectors
c_func
(paren
id|q
comma
id|UB_MAX_SECTORS
)paren
suffix:semicolon
id|blk_queue_hardsect_size
c_func
(paren
id|q
comma
id|sc-&gt;capacity.bsize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is a serious infraction, caused by a deficiency in the&n;&t; * USB sg interface (usb_sg_wait()). We plan to remove this once&n;&t; * we get mileage on the driver and can justify a change to USB API.&n;&t; * See blk_queue_bounce_limit() to understand this part.&n;&t; *&n;&t; * XXX And I still need to be aware of the DMA mask in the HC.&n;&t; */
id|q-&gt;bounce_pfn
op_assign
id|blk_max_low_pfn
suffix:semicolon
id|q-&gt;bounce_gfp
op_assign
id|GFP_NOIO
suffix:semicolon
id|q-&gt;queuedata
op_assign
id|sc
suffix:semicolon
id|set_capacity
c_func
(paren
id|disk
comma
id|sc-&gt;capacity.nsec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;removable
)paren
id|disk-&gt;flags
op_or_assign
id|GENHD_FL_REMOVABLE
suffix:semicolon
id|add_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_blkqinit
suffix:colon
id|put_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
id|err_diskalloc
suffix:colon
id|device_remove_file
c_func
(paren
op_amp
id|sc-&gt;intf-&gt;dev
comma
op_amp
id|dev_attr_diag
)paren
suffix:semicolon
id|err_diag
suffix:colon
id|usb_set_intfdata
c_func
(paren
id|intf
comma
l_int|NULL
)paren
suffix:semicolon
singleline_comment|// usb_put_intf(sc-&gt;intf);
id|usb_put_dev
c_func
(paren
id|sc-&gt;dev
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ub_lock
)paren
suffix:semicolon
id|ub_id_put
c_func
(paren
id|sc-&gt;id
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ub_lock
)paren
suffix:semicolon
id|err_id
suffix:colon
id|kfree
c_func
(paren
id|sc
)paren
suffix:semicolon
id|err_core
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|ub_disconnect
r_static
r_void
id|ub_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|ub_dev
op_star
id|sc
op_assign
id|usb_get_intfdata
c_func
(paren
id|intf
)paren
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
op_assign
id|sc-&gt;disk
suffix:semicolon
id|request_queue_t
op_star
id|q
op_assign
id|disk-&gt;queue
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Fence stall clearnings, operations triggered by unlinkings and so on.&n;&t; * We do not attempt to unlink any URBs, because we do not trust the&n;&t; * unlink paths in HC drivers. Also, we get -84 upon disconnect anyway.&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|sc-&gt;poison
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Blow away queued commands.&n;&t; *&n;&t; * Actually, this never works, because before we get here&n;&t; * the HCD terminates outstanding URB(s). It causes our&n;&t; * SCSI command queue to advance, commands fail to submit,&n;&t; * and the whole queue drains. So, we just use this code to&n;&t; * print warnings.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
(brace
r_struct
id|ub_scsi_cmd
op_star
id|cmd
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cmd
op_assign
id|ub_cmdq_pop
c_func
(paren
id|sc
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|cmd-&gt;error
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
id|cmd-&gt;state
op_assign
id|UB_CMDST_DONE
suffix:semicolon
id|ub_cmdtr_state
c_func
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|ub_cmdq_pop
c_func
(paren
id|sc
)paren
suffix:semicolon
(paren
op_star
id|cmd-&gt;done
)paren
(paren
id|sc
comma
id|cmd
)paren
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: &quot;
l_string|&quot;%d was queued after shutdown&bslash;n&quot;
comma
id|sc-&gt;name
comma
id|cnt
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Unregister the upper layer, this waits for all commands to end.&n;&t; */
r_if
c_cond
(paren
id|disk-&gt;flags
op_amp
id|GENHD_FL_UP
)paren
id|del_gendisk
c_func
(paren
id|disk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
id|blk_cleanup_queue
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We really expect blk_cleanup_queue() to wait, so no amount&n;&t; * of paranoya is too much.&n;&t; *&n;&t; * Taking a lock on a structure which is about to be freed&n;&t; * is very nonsensual. Here it is largely a way to do a debug freeze,&n;&t; * and a bracket which shows where the nonsensual code segment ends.&n;&t; *&n;&t; * Testing for -EINPROGRESS is always a bug, so we are bending&n;&t; * the rules a little.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;work_urb.status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
multiline_comment|/* janitors: ignore */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: &quot;
l_string|&quot;URB is active after disconnect&bslash;n&quot;
comma
id|sc-&gt;name
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There is virtually no chance that other CPU runs times so long&n;&t; * after ub_urb_complete should have called del_timer, but only if HCD&n;&t; * didn&squot;t forget to deliver a callback on unlink.&n;&t; */
id|del_timer_sync
c_func
(paren
op_amp
id|sc-&gt;work_timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point there must be no commands coming from anyone&n;&t; * and no URBs left in transit.&n;&t; */
id|device_remove_file
c_func
(paren
op_amp
id|sc-&gt;intf-&gt;dev
comma
op_amp
id|dev_attr_diag
)paren
suffix:semicolon
id|usb_set_intfdata
c_func
(paren
id|intf
comma
l_int|NULL
)paren
suffix:semicolon
singleline_comment|// usb_put_intf(sc-&gt;intf);
id|sc-&gt;intf
op_assign
l_int|NULL
suffix:semicolon
id|usb_put_dev
c_func
(paren
id|sc-&gt;dev
)paren
suffix:semicolon
id|sc-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ub_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;openc
op_eq
l_int|0
)paren
id|ub_cleanup
c_func
(paren
id|sc
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ub_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|ub_driver
r_struct
id|usb_driver
id|ub_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;ub&quot;
comma
dot
id|probe
op_assign
id|ub_probe
comma
dot
id|disconnect
op_assign
id|ub_disconnect
comma
dot
id|id_table
op_assign
id|ub_usb_ids
comma
)brace
suffix:semicolon
DECL|function|ub_init
r_static
r_int
id|__init
id|ub_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* P3 */
id|printk
c_func
(paren
l_string|&quot;ub: sizeof ub_scsi_cmd %zu ub_dev %zu&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|ub_scsi_cmd
)paren
comma
r_sizeof
(paren
r_struct
id|ub_dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|register_blkdev
c_func
(paren
id|UB_MAJOR
comma
id|DRV_NAME
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|err_regblkdev
suffix:semicolon
id|devfs_mk_dir
c_func
(paren
id|DEVFS_NAME
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|usb_register
c_func
(paren
op_amp
id|ub_driver
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|err_register
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_register
suffix:colon
id|devfs_remove
c_func
(paren
id|DEVFS_NAME
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|UB_MAJOR
comma
id|DRV_NAME
)paren
suffix:semicolon
id|err_regblkdev
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|ub_exit
r_static
r_void
id|__exit
id|ub_exit
c_func
(paren
r_void
)paren
(brace
id|usb_deregister
c_func
(paren
op_amp
id|ub_driver
)paren
suffix:semicolon
id|devfs_remove
c_func
(paren
id|DEVFS_NAME
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|UB_MAJOR
comma
id|DRV_NAME
)paren
suffix:semicolon
)brace
DECL|variable|ub_init
id|module_init
c_func
(paren
id|ub_init
)paren
suffix:semicolon
DECL|variable|ub_exit
id|module_exit
c_func
(paren
id|ub_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
