multiline_comment|/*&n; *    Disk Array driver for Compaq SA53xx Controllers, SCSI Tape module&n; *    Copyright 2001 Compaq Computer Corporation&n; *&n; *    This program is free software; you can redistribute it and/or modify&n; *    it under the terms of the GNU General Public License as published by&n; *    the Free Software Foundation; either version 2 of the License, or&n; *    (at your option) any later version.&n; *&n; *    This program is distributed in the hope that it will be useful,&n; *    but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or&n; *    NON INFRINGEMENT.  See the GNU General Public License for more details.&n; *&n; *    You should have received a copy of the GNU General Public License&n; *    along with this program; if not, write to the Free Software&n; *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *    Questions/Comments/Bugfixes to iss_storagedev@hp.com&n; *    &n; *    Author: Stephen M. Cameron&n; */
macro_line|#ifdef CONFIG_CISS_SCSI_TAPE
multiline_comment|/* Here we have code to present the driver as a scsi driver &n;   as it is simultaneously presented as a block driver.  The &n;   reason for doing this is to allow access to SCSI tape drives&n;   through the array controller.  Note in particular, neither &n;   physical nor logical disks are presented through the scsi layer. */
macro_line|#include &lt;scsi/scsi.h&gt; 
macro_line|#include &lt;scsi/scsi_cmnd.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &lt;scsi/scsi_host.h&gt; 
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &quot;cciss_scsi.h&quot;
multiline_comment|/* some prototypes... */
r_static
r_int
id|sendcmd
c_func
(paren
id|__u8
id|cmd
comma
r_int
id|ctlr
comma
r_void
op_star
id|buff
comma
r_int
id|size
comma
r_int
r_int
id|use_unit_num
comma
multiline_comment|/* 0: address the controller,&n;&t;&t;&t;&t;      1: address logical volume log_unit, &n;&t;&t;&t;&t;      2: address is in scsi3addr */
r_int
r_int
id|log_unit
comma
id|__u8
id|page_code
comma
r_int
r_char
op_star
id|scsi3addr
comma
r_int
id|cmd_type
)paren
suffix:semicolon
r_const
r_char
op_star
id|cciss_scsi_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|sa
)paren
suffix:semicolon
r_int
id|cciss_scsi_proc_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|sh
comma
r_char
op_star
id|buffer
comma
multiline_comment|/* data buffer */
r_char
op_star
op_star
id|start
comma
multiline_comment|/* where data in buffer starts */
id|off_t
id|offset
comma
multiline_comment|/* offset from start of imaginary file */
r_int
id|length
comma
multiline_comment|/* length of data in buffer */
r_int
id|func
)paren
suffix:semicolon
multiline_comment|/* 0 == read, 1 == write */
r_int
id|cciss_scsi_queue_command
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
suffix:semicolon
DECL|variable|ccissscsi
r_static
r_struct
id|cciss_scsi_hba_t
id|ccissscsi
(braket
id|MAX_CTLR
)braket
op_assign
(brace
(brace
dot
id|name
op_assign
l_string|&quot;cciss0&quot;
comma
dot
id|ndevices
op_assign
l_int|0
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;cciss1&quot;
comma
dot
id|ndevices
op_assign
l_int|0
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;cciss2&quot;
comma
dot
id|ndevices
op_assign
l_int|0
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;cciss3&quot;
comma
dot
id|ndevices
op_assign
l_int|0
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;cciss4&quot;
comma
dot
id|ndevices
op_assign
l_int|0
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;cciss5&quot;
comma
dot
id|ndevices
op_assign
l_int|0
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;cciss6&quot;
comma
dot
id|ndevices
op_assign
l_int|0
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;cciss7&quot;
comma
dot
id|ndevices
op_assign
l_int|0
)brace
comma
)brace
suffix:semicolon
DECL|variable|cciss_driver_template
r_static
r_struct
id|scsi_host_template
id|cciss_driver_template
op_assign
(brace
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;cciss&quot;
comma
dot
id|proc_name
op_assign
l_string|&quot;cciss&quot;
comma
dot
id|proc_info
op_assign
id|cciss_scsi_proc_info
comma
dot
id|queuecommand
op_assign
id|cciss_scsi_queue_command
comma
dot
id|can_queue
op_assign
id|SCSI_CCISS_CAN_QUEUE
comma
dot
id|this_id
op_assign
l_int|7
comma
dot
id|sg_tablesize
op_assign
id|MAXSGENTRIES
comma
dot
id|cmd_per_lun
op_assign
l_int|1
comma
dot
id|use_clustering
op_assign
id|DISABLE_CLUSTERING
comma
)brace
suffix:semicolon
macro_line|#pragma pack(1)
DECL|struct|cciss_scsi_cmd_stack_elem_t
r_struct
id|cciss_scsi_cmd_stack_elem_t
(brace
DECL|member|cmd
id|CommandList_struct
id|cmd
suffix:semicolon
DECL|member|Err
id|ErrorInfo_struct
id|Err
suffix:semicolon
DECL|member|busaddr
id|__u32
id|busaddr
suffix:semicolon
)brace
suffix:semicolon
macro_line|#pragma pack()
DECL|macro|CMD_STACK_SIZE
mdefine_line|#define CMD_STACK_SIZE (SCSI_CCISS_CAN_QUEUE * &bslash;&n;&t;&t;CCISS_MAX_SCSI_DEVS_PER_HBA + 2)
singleline_comment|// plus two for init time usage
macro_line|#pragma pack(1)
DECL|struct|cciss_scsi_cmd_stack_t
r_struct
id|cciss_scsi_cmd_stack_t
(brace
DECL|member|pool
r_struct
id|cciss_scsi_cmd_stack_elem_t
op_star
id|pool
suffix:semicolon
DECL|member|elem
r_struct
id|cciss_scsi_cmd_stack_elem_t
op_star
id|elem
(braket
id|CMD_STACK_SIZE
)braket
suffix:semicolon
DECL|member|cmd_pool_handle
id|dma_addr_t
id|cmd_pool_handle
suffix:semicolon
DECL|member|top
r_int
id|top
suffix:semicolon
)brace
suffix:semicolon
macro_line|#pragma pack()
DECL|struct|cciss_scsi_adapter_data_t
r_struct
id|cciss_scsi_adapter_data_t
(brace
DECL|member|scsi_host
r_struct
id|Scsi_Host
op_star
id|scsi_host
suffix:semicolon
DECL|member|cmd_stack
r_struct
id|cciss_scsi_cmd_stack_t
id|cmd_stack
suffix:semicolon
DECL|member|registered
r_int
id|registered
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
singleline_comment|// to protect ccissscsi[ctlr]; 
)brace
suffix:semicolon
DECL|macro|CPQ_TAPE_LOCK
mdefine_line|#define CPQ_TAPE_LOCK(ctlr, flags) spin_lock_irqsave( &bslash;&n;&t;&amp;(((struct cciss_scsi_adapter_data_t *) &bslash;&n;&t;hba[ctlr]-&gt;scsi_ctlr)-&gt;lock), flags);
DECL|macro|CPQ_TAPE_UNLOCK
mdefine_line|#define CPQ_TAPE_UNLOCK(ctlr, flags) spin_unlock_irqrestore( &bslash;&n;&t;&amp;(((struct cciss_scsi_adapter_data_t *) &bslash;&n;&t;hba[ctlr]-&gt;scsi_ctlr)-&gt;lock), flags);
r_static
id|CommandList_struct
op_star
DECL|function|scsi_cmd_alloc
id|scsi_cmd_alloc
c_func
(paren
id|ctlr_info_t
op_star
id|h
)paren
(brace
multiline_comment|/* assume only one process in here at a time, locking done by caller. */
multiline_comment|/* use CCISS_LOCK(ctlr) */
multiline_comment|/* might be better to rewrite how we allocate scsi commands in a way that */
multiline_comment|/* needs no locking at all. */
multiline_comment|/* take the top memory chunk off the stack and return it, if any. */
r_struct
id|cciss_scsi_cmd_stack_elem_t
op_star
id|c
suffix:semicolon
r_struct
id|cciss_scsi_adapter_data_t
op_star
id|sa
suffix:semicolon
r_struct
id|cciss_scsi_cmd_stack_t
op_star
id|stk
suffix:semicolon
id|u64bit
id|temp64
suffix:semicolon
id|sa
op_assign
(paren
r_struct
id|cciss_scsi_adapter_data_t
op_star
)paren
id|h-&gt;scsi_ctlr
suffix:semicolon
id|stk
op_assign
op_amp
id|sa-&gt;cmd_stack
suffix:semicolon
r_if
c_cond
(paren
id|stk-&gt;top
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|c
op_assign
id|stk-&gt;elem
(braket
id|stk-&gt;top
)braket
suffix:semicolon
multiline_comment|/* memset(c, 0, sizeof(*c)); */
id|memset
c_func
(paren
op_amp
id|c-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|c-&gt;cmd
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|c-&gt;Err
comma
l_int|0
comma
r_sizeof
(paren
id|c-&gt;Err
)paren
)paren
suffix:semicolon
multiline_comment|/* set physical addr of cmd and addr of scsi parameters */
id|c-&gt;cmd.busaddr
op_assign
id|c-&gt;busaddr
suffix:semicolon
multiline_comment|/* (__u32) (stk-&gt;cmd_pool_handle + &n;&t;&t;(sizeof(struct cciss_scsi_cmd_stack_elem_t)*stk-&gt;top)); */
id|temp64.val
op_assign
(paren
id|__u64
)paren
(paren
id|c-&gt;busaddr
op_plus
r_sizeof
(paren
id|CommandList_struct
)paren
)paren
suffix:semicolon
multiline_comment|/* (__u64) (stk-&gt;cmd_pool_handle + &n;&t;&t;(sizeof(struct cciss_scsi_cmd_stack_elem_t)*stk-&gt;top) +&n;&t;&t; sizeof(CommandList_struct)); */
id|stk-&gt;top
op_decrement
suffix:semicolon
id|c-&gt;cmd.ErrDesc.Addr.lower
op_assign
id|temp64.val32.lower
suffix:semicolon
id|c-&gt;cmd.ErrDesc.Addr.upper
op_assign
id|temp64.val32.upper
suffix:semicolon
id|c-&gt;cmd.ErrDesc.Len
op_assign
r_sizeof
(paren
id|ErrorInfo_struct
)paren
suffix:semicolon
id|c-&gt;cmd.ctlr
op_assign
id|h-&gt;ctlr
suffix:semicolon
id|c-&gt;cmd.err_info
op_assign
op_amp
id|c-&gt;Err
suffix:semicolon
r_return
(paren
id|CommandList_struct
op_star
)paren
id|c
suffix:semicolon
)brace
r_static
r_void
DECL|function|scsi_cmd_free
id|scsi_cmd_free
c_func
(paren
id|ctlr_info_t
op_star
id|h
comma
id|CommandList_struct
op_star
id|cmd
)paren
(brace
multiline_comment|/* assume only one process in here at a time, locking done by caller. */
multiline_comment|/* use CCISS_LOCK(ctlr) */
multiline_comment|/* drop the free memory chunk on top of the stack. */
r_struct
id|cciss_scsi_adapter_data_t
op_star
id|sa
suffix:semicolon
r_struct
id|cciss_scsi_cmd_stack_t
op_star
id|stk
suffix:semicolon
id|sa
op_assign
(paren
r_struct
id|cciss_scsi_adapter_data_t
op_star
)paren
id|h-&gt;scsi_ctlr
suffix:semicolon
id|stk
op_assign
op_amp
id|sa-&gt;cmd_stack
suffix:semicolon
r_if
c_cond
(paren
id|stk-&gt;top
op_ge
id|CMD_STACK_SIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cciss: scsi_cmd_free called too many times.&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|stk-&gt;top
op_increment
suffix:semicolon
id|stk-&gt;elem
(braket
id|stk-&gt;top
)braket
op_assign
(paren
r_struct
id|cciss_scsi_cmd_stack_elem_t
op_star
)paren
id|cmd
suffix:semicolon
)brace
r_static
r_int
DECL|function|scsi_cmd_stack_setup
id|scsi_cmd_stack_setup
c_func
(paren
r_int
id|ctlr
comma
r_struct
id|cciss_scsi_adapter_data_t
op_star
id|sa
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|cciss_scsi_cmd_stack_t
op_star
id|stk
suffix:semicolon
r_int
id|size
suffix:semicolon
id|stk
op_assign
op_amp
id|sa-&gt;cmd_stack
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
r_struct
id|cciss_scsi_cmd_stack_elem_t
)paren
op_star
id|CMD_STACK_SIZE
suffix:semicolon
singleline_comment|// pci_alloc_consistent guarantees 32-bit DMA address will
singleline_comment|// be used
id|stk-&gt;pool
op_assign
(paren
r_struct
id|cciss_scsi_cmd_stack_elem_t
op_star
)paren
id|pci_alloc_consistent
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|pdev
comma
id|size
comma
op_amp
id|stk-&gt;cmd_pool_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stk-&gt;pool
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;stk-&gt;pool is null&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CMD_STACK_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|stk-&gt;elem
(braket
id|i
)braket
op_assign
op_amp
id|stk-&gt;pool
(braket
id|i
)braket
suffix:semicolon
id|stk-&gt;elem
(braket
id|i
)braket
op_member_access_from_pointer
id|busaddr
op_assign
(paren
id|__u32
)paren
(paren
id|stk-&gt;cmd_pool_handle
op_plus
(paren
r_sizeof
(paren
r_struct
id|cciss_scsi_cmd_stack_elem_t
)paren
op_star
id|i
)paren
)paren
suffix:semicolon
)brace
id|stk-&gt;top
op_assign
id|CMD_STACK_SIZE
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|scsi_cmd_stack_free
id|scsi_cmd_stack_free
c_func
(paren
r_int
id|ctlr
)paren
(brace
r_struct
id|cciss_scsi_adapter_data_t
op_star
id|sa
suffix:semicolon
r_struct
id|cciss_scsi_cmd_stack_t
op_star
id|stk
suffix:semicolon
r_int
id|size
suffix:semicolon
id|sa
op_assign
(paren
r_struct
id|cciss_scsi_adapter_data_t
op_star
)paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|scsi_ctlr
suffix:semicolon
id|stk
op_assign
op_amp
id|sa-&gt;cmd_stack
suffix:semicolon
r_if
c_cond
(paren
id|stk-&gt;top
op_ne
id|CMD_STACK_SIZE
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cciss: %d scsi commands are still outstanding.&bslash;n&quot;
comma
id|CMD_STACK_SIZE
op_minus
id|stk-&gt;top
)paren
suffix:semicolon
singleline_comment|// BUG();
id|printk
c_func
(paren
l_string|&quot;WE HAVE A BUG HERE!!! stk=0x%p&bslash;n&quot;
comma
id|stk
)paren
suffix:semicolon
)brace
id|size
op_assign
r_sizeof
(paren
r_struct
id|cciss_scsi_cmd_stack_elem_t
)paren
op_star
id|CMD_STACK_SIZE
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|pdev
comma
id|size
comma
id|stk-&gt;pool
comma
id|stk-&gt;cmd_pool_handle
)paren
suffix:semicolon
id|stk-&gt;pool
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* scsi_device_types comes from scsi.h */
DECL|macro|DEVICETYPE
mdefine_line|#define DEVICETYPE(n) (n&lt;0 || n&gt;MAX_SCSI_DEVICE_CODE) ? &bslash;&n;&t;&quot;Unknown&quot; : scsi_device_types[n]
macro_line|#if 0
r_static
r_int
id|xmargin
op_assign
l_int|8
suffix:semicolon
r_static
r_int
id|amargin
op_assign
l_int|60
suffix:semicolon
r_static
r_void
id|print_bytes
(paren
r_int
r_char
op_star
id|c
comma
r_int
id|len
comma
r_int
id|hex
comma
r_int
id|ascii
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|x
suffix:semicolon
r_if
c_cond
(paren
id|hex
)paren
(brace
id|x
op_assign
id|c
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
id|xmargin
)paren
op_eq
l_int|0
op_logical_and
id|i
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
id|xmargin
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;0x%04x:&quot;
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
op_star
id|x
)paren
suffix:semicolon
id|x
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ascii
)paren
(brace
id|x
op_assign
id|c
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
id|amargin
)paren
op_eq
l_int|0
op_logical_and
id|i
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
id|amargin
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;0x%04x:&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|x
OG
l_int|26
op_logical_and
op_star
id|x
OL
l_int|128
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
op_star
id|x
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|x
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
id|print_cmd
c_func
(paren
id|CommandList_struct
op_star
id|cp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;queue:%d&bslash;n&quot;
comma
id|cp-&gt;Header.ReplyQueue
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sglist:%d&bslash;n&quot;
comma
id|cp-&gt;Header.SGList
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sgtot:%d&bslash;n&quot;
comma
id|cp-&gt;Header.SGTotal
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Tag:0x%08x/0x%08x&bslash;n&quot;
comma
id|cp-&gt;Header.Tag.upper
comma
id|cp-&gt;Header.Tag.lower
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;LUN:0x%02x%02x%02x%02x%02x%02x%02x%02x&bslash;n&quot;
comma
id|cp-&gt;Header.LUN.LunAddrBytes
(braket
l_int|0
)braket
comma
id|cp-&gt;Header.LUN.LunAddrBytes
(braket
l_int|1
)braket
comma
id|cp-&gt;Header.LUN.LunAddrBytes
(braket
l_int|2
)braket
comma
id|cp-&gt;Header.LUN.LunAddrBytes
(braket
l_int|3
)braket
comma
id|cp-&gt;Header.LUN.LunAddrBytes
(braket
l_int|4
)braket
comma
id|cp-&gt;Header.LUN.LunAddrBytes
(braket
l_int|5
)braket
comma
id|cp-&gt;Header.LUN.LunAddrBytes
(braket
l_int|6
)braket
comma
id|cp-&gt;Header.LUN.LunAddrBytes
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CDBLen:%d&bslash;n&quot;
comma
id|cp-&gt;Request.CDBLen
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Type:%d&bslash;n&quot;
comma
id|cp-&gt;Request.Type.Type
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Attr:%d&bslash;n&quot;
comma
id|cp-&gt;Request.Type.Attribute
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; Dir:%d&bslash;n&quot;
comma
id|cp-&gt;Request.Type.Direction
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Timeout:%d&bslash;n&quot;
comma
id|cp-&gt;Request.Timeout
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CDB: %02x %02x %02x %02x %02x %02x %02x %02x&quot;
l_string|&quot; %02x %02x %02x %02x %02x %02x %02x %02x&bslash;n&quot;
comma
id|cp-&gt;Request.CDB
(braket
l_int|0
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|1
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|2
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|3
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|4
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|5
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|6
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|7
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|8
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|9
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|10
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|11
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|12
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|13
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|14
)braket
comma
id|cp-&gt;Request.CDB
(braket
l_int|15
)braket
)paren
comma
id|printk
c_func
(paren
l_string|&quot;edesc.Addr: 0x%08x/0%08x, Len  = %d&bslash;n&quot;
comma
id|cp-&gt;ErrDesc.Addr.upper
comma
id|cp-&gt;ErrDesc.Addr.lower
comma
id|cp-&gt;ErrDesc.Len
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sgs..........Errorinfo:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsistatus:%d&bslash;n&quot;
comma
id|cp-&gt;err_info-&gt;ScsiStatus
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;senselen:%d&bslash;n&quot;
comma
id|cp-&gt;err_info-&gt;SenseLen
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cmd status:%d&bslash;n&quot;
comma
id|cp-&gt;err_info-&gt;CommandStatus
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;resid cnt:%d&bslash;n&quot;
comma
id|cp-&gt;err_info-&gt;ResidualCnt
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;offense size:%d&bslash;n&quot;
comma
id|cp-&gt;err_info-&gt;MoreErrInfo.Invalid_Cmd.offense_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;offense byte:%d&bslash;n&quot;
comma
id|cp-&gt;err_info-&gt;MoreErrInfo.Invalid_Cmd.offense_num
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;offense value:%d&bslash;n&quot;
comma
id|cp-&gt;err_info-&gt;MoreErrInfo.Invalid_Cmd.offense_value
)paren
suffix:semicolon
)brace
macro_line|#endif
r_static
r_int
DECL|function|find_bus_target_lun
id|find_bus_target_lun
c_func
(paren
r_int
id|ctlr
comma
r_int
op_star
id|bus
comma
r_int
op_star
id|target
comma
r_int
op_star
id|lun
)paren
(brace
multiline_comment|/* finds an unused bus, target, lun for a new device */
multiline_comment|/* assumes hba[ctlr]-&gt;scsi_ctlr-&gt;lock is held */
r_int
id|i
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|target_taken
(braket
id|CCISS_MAX_SCSI_DEVS_PER_HBA
)braket
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|target_taken
(braket
l_int|0
)braket
comma
l_int|0
comma
id|CCISS_MAX_SCSI_DEVS_PER_HBA
)paren
suffix:semicolon
id|target_taken
(braket
id|SELF_SCSI_ID
)braket
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|ndevices
suffix:semicolon
id|i
op_increment
)paren
id|target_taken
(braket
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|dev
(braket
id|i
)braket
dot
id|target
)braket
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CCISS_MAX_SCSI_DEVS_PER_HBA
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|target_taken
(braket
id|i
)braket
)paren
(brace
op_star
id|bus
op_assign
l_int|0
suffix:semicolon
op_star
id|target
op_assign
id|i
suffix:semicolon
op_star
id|lun
op_assign
l_int|0
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
(paren
op_logical_neg
id|found
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cciss_scsi_add_entry
id|cciss_scsi_add_entry
c_func
(paren
r_int
id|ctlr
comma
r_int
id|hostno
comma
r_int
r_char
op_star
id|scsi3addr
comma
r_int
id|devtype
)paren
(brace
multiline_comment|/* assumes hba[ctlr]-&gt;scsi_ctlr-&gt;lock is held */
r_int
id|n
op_assign
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|ndevices
suffix:semicolon
r_struct
id|cciss_scsi_dev_t
op_star
id|sd
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
id|CCISS_MAX_SCSI_DEVS_PER_HBA
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cciss%d: Too many devices, &quot;
l_string|&quot;some will be inaccessible.&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sd
op_assign
op_amp
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|dev
(braket
id|n
)braket
suffix:semicolon
r_if
c_cond
(paren
id|find_bus_target_lun
c_func
(paren
id|ctlr
comma
op_amp
id|sd-&gt;bus
comma
op_amp
id|sd-&gt;target
comma
op_amp
id|sd-&gt;lun
)paren
op_ne
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sd-&gt;scsi3addr
(braket
l_int|0
)braket
comma
id|scsi3addr
comma
l_int|8
)paren
suffix:semicolon
id|sd-&gt;devtype
op_assign
id|devtype
suffix:semicolon
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|ndevices
op_increment
suffix:semicolon
multiline_comment|/* initially, (before registering with scsi layer) we don&squot;t &n;&t;   know our hostno and we don&squot;t want to print anything first &n;&t;   time anyway (the scsi layer&squot;s inquiries will show that info) */
r_if
c_cond
(paren
id|hostno
op_ne
op_minus
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;cciss%d: %s device c%db%dt%dl%d added.&bslash;n&quot;
comma
id|ctlr
comma
id|DEVICETYPE
c_func
(paren
id|sd-&gt;devtype
)paren
comma
id|hostno
comma
id|sd-&gt;bus
comma
id|sd-&gt;target
comma
id|sd-&gt;lun
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|cciss_scsi_remove_entry
id|cciss_scsi_remove_entry
c_func
(paren
r_int
id|ctlr
comma
r_int
id|hostno
comma
r_int
id|entry
)paren
(brace
multiline_comment|/* assumes hba[ctlr]-&gt;scsi_ctlr-&gt;lock is held */
r_int
id|i
suffix:semicolon
r_struct
id|cciss_scsi_dev_t
id|sd
suffix:semicolon
r_if
c_cond
(paren
id|entry
OL
l_int|0
op_logical_or
id|entry
op_ge
id|CCISS_MAX_SCSI_DEVS_PER_HBA
)paren
r_return
suffix:semicolon
id|sd
op_assign
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|dev
(braket
id|entry
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|entry
suffix:semicolon
id|i
OL
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|ndevices
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|dev
(braket
id|i
)braket
op_assign
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|dev
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|ndevices
op_decrement
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cciss%d: %s device c%db%dt%dl%d removed.&bslash;n&quot;
comma
id|ctlr
comma
id|DEVICETYPE
c_func
(paren
id|sd.devtype
)paren
comma
id|hostno
comma
id|sd.bus
comma
id|sd.target
comma
id|sd.lun
)paren
suffix:semicolon
)brace
DECL|macro|SCSI3ADDR_EQ
mdefine_line|#define SCSI3ADDR_EQ(a,b) ( &bslash;&n;&t;(a)[7] == (b)[7] &amp;&amp; &bslash;&n;&t;(a)[6] == (b)[6] &amp;&amp; &bslash;&n;&t;(a)[5] == (b)[5] &amp;&amp; &bslash;&n;&t;(a)[4] == (b)[4] &amp;&amp; &bslash;&n;&t;(a)[3] == (b)[3] &amp;&amp; &bslash;&n;&t;(a)[2] == (b)[2] &amp;&amp; &bslash;&n;&t;(a)[1] == (b)[1] &amp;&amp; &bslash;&n;&t;(a)[0] == (b)[0])
r_static
r_int
DECL|function|adjust_cciss_scsi_table
id|adjust_cciss_scsi_table
c_func
(paren
r_int
id|ctlr
comma
r_int
id|hostno
comma
r_struct
id|cciss_scsi_dev_t
id|sd
(braket
)braket
comma
r_int
id|nsds
)paren
(brace
multiline_comment|/* sd contains scsi3 addresses and devtypes, but&n;&t;   bus target and lun are not filled in.  This funciton&n;&t;   takes what&squot;s in sd to be the current and adjusts&n;&t;   ccissscsi[] to be in line with what&squot;s in sd. */
r_int
id|i
comma
id|j
comma
id|found
comma
id|changes
op_assign
l_int|0
suffix:semicolon
r_struct
id|cciss_scsi_dev_t
op_star
id|csd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|CPQ_TAPE_LOCK
c_func
(paren
id|ctlr
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* find any devices in ccissscsi[] that are not in &n;&t;   sd[] and remove them from ccissscsi[] */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|ndevices
)paren
(brace
id|csd
op_assign
op_amp
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|dev
(braket
id|i
)braket
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nsds
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|SCSI3ADDR_EQ
c_func
(paren
id|sd
(braket
id|j
)braket
dot
id|scsi3addr
comma
id|csd-&gt;scsi3addr
)paren
)paren
(brace
r_if
c_cond
(paren
id|sd
(braket
id|j
)braket
dot
id|devtype
op_eq
id|csd-&gt;devtype
)paren
id|found
op_assign
l_int|2
suffix:semicolon
r_else
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
op_eq
l_int|0
)paren
(brace
multiline_comment|/* device no longer present. */
id|changes
op_increment
suffix:semicolon
multiline_comment|/* printk(&quot;cciss%d: %s device c%db%dt%dl%d removed.&bslash;n&quot;,&n;&t;&t;&t;&t;ctlr, DEVICETYPE(csd-&gt;devtype), hostno, &n;&t;&t;&t;&t;&t;csd-&gt;bus, csd-&gt;target, csd-&gt;lun); */
id|cciss_scsi_remove_entry
c_func
(paren
id|ctlr
comma
id|hostno
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* note, i not incremented */
)brace
r_else
r_if
c_cond
(paren
id|found
op_eq
l_int|1
)paren
(brace
multiline_comment|/* device is different kind */
id|changes
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cciss%d: device c%db%dt%dl%d type changed &quot;
l_string|&quot;(device type now %s).&bslash;n&quot;
comma
id|ctlr
comma
id|hostno
comma
id|csd-&gt;bus
comma
id|csd-&gt;target
comma
id|csd-&gt;lun
comma
id|DEVICETYPE
c_func
(paren
id|csd-&gt;devtype
)paren
)paren
suffix:semicolon
id|csd-&gt;devtype
op_assign
id|sd
(braket
id|j
)braket
dot
id|devtype
suffix:semicolon
id|i
op_increment
suffix:semicolon
multiline_comment|/* so just move along. */
)brace
r_else
multiline_comment|/* device is same as it ever was, */
id|i
op_increment
suffix:semicolon
multiline_comment|/* so just move along. */
)brace
multiline_comment|/* Now, make sure every device listed in sd[] is also&n; &t;   listed in ccissscsi[], adding them if they aren&squot;t found */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nsds
suffix:semicolon
id|i
op_increment
)paren
(brace
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|ndevices
suffix:semicolon
id|j
op_increment
)paren
(brace
id|csd
op_assign
op_amp
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|dev
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|SCSI3ADDR_EQ
c_func
(paren
id|sd
(braket
id|i
)braket
dot
id|scsi3addr
comma
id|csd-&gt;scsi3addr
)paren
)paren
(brace
r_if
c_cond
(paren
id|sd
(braket
id|i
)braket
dot
id|devtype
op_eq
id|csd-&gt;devtype
)paren
id|found
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* found device */
r_else
id|found
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* found a bug. */
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|changes
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cciss_scsi_add_entry
c_func
(paren
id|ctlr
comma
id|hostno
comma
op_amp
id|sd
(braket
id|i
)braket
dot
id|scsi3addr
(braket
l_int|0
)braket
comma
id|sd
(braket
id|i
)braket
dot
id|devtype
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|found
op_eq
l_int|1
)paren
(brace
multiline_comment|/* should never happen... */
id|changes
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cciss%d: device unexpectedly changed type&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
multiline_comment|/* but if it does happen, we just ignore that device */
)brace
)brace
id|CPQ_TAPE_UNLOCK
c_func
(paren
id|ctlr
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|changes
)paren
id|printk
c_func
(paren
l_string|&quot;cciss%d: No device changes detected.&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|lookup_scsi3addr
id|lookup_scsi3addr
c_func
(paren
r_int
id|ctlr
comma
r_int
id|bus
comma
r_int
id|target
comma
r_int
id|lun
comma
r_char
op_star
id|scsi3addr
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|cciss_scsi_dev_t
op_star
id|sd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|CPQ_TAPE_LOCK
c_func
(paren
id|ctlr
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|ndevices
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sd
op_assign
op_amp
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|dev
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sd-&gt;bus
op_eq
id|bus
op_logical_and
id|sd-&gt;target
op_eq
id|target
op_logical_and
id|sd-&gt;lun
op_eq
id|lun
)paren
(brace
id|memcpy
c_func
(paren
id|scsi3addr
comma
op_amp
id|sd-&gt;scsi3addr
(braket
l_int|0
)braket
comma
l_int|8
)paren
suffix:semicolon
id|CPQ_TAPE_UNLOCK
c_func
(paren
id|ctlr
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|CPQ_TAPE_UNLOCK
c_func
(paren
id|ctlr
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|cciss_scsi_setup
id|cciss_scsi_setup
c_func
(paren
r_int
id|cntl_num
)paren
(brace
r_struct
id|cciss_scsi_adapter_data_t
op_star
id|shba
suffix:semicolon
id|ccissscsi
(braket
id|cntl_num
)braket
dot
id|ndevices
op_assign
l_int|0
suffix:semicolon
id|shba
op_assign
(paren
r_struct
id|cciss_scsi_adapter_data_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|shba
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shba
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|shba-&gt;scsi_host
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|shba-&gt;lock
)paren
suffix:semicolon
id|shba-&gt;registered
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scsi_cmd_stack_setup
c_func
(paren
id|cntl_num
comma
id|shba
)paren
op_ne
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|shba
)paren
suffix:semicolon
id|shba
op_assign
l_int|NULL
suffix:semicolon
)brace
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|scsi_ctlr
op_assign
(paren
r_void
op_star
)paren
id|shba
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|complete_scsi_command
id|complete_scsi_command
c_func
(paren
id|CommandList_struct
op_star
id|cp
comma
r_int
id|timeout
comma
id|__u32
id|tag
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
id|ctlr_info_t
op_star
id|ctlr
suffix:semicolon
id|u64bit
id|addr64
suffix:semicolon
id|ErrorInfo_struct
op_star
id|ei
suffix:semicolon
id|ei
op_assign
id|cp-&gt;err_info
suffix:semicolon
multiline_comment|/* First, see if it was a message rather than a command */
r_if
c_cond
(paren
id|cp-&gt;Request.Type.Type
op_eq
id|TYPE_MSG
)paren
(brace
id|cp-&gt;cmd_type
op_assign
id|CMD_MSG_DONE
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cmd
op_assign
(paren
r_struct
id|scsi_cmnd
op_star
)paren
id|cp-&gt;scsi_cmd
suffix:semicolon
id|ctlr
op_assign
id|hba
(braket
id|cp-&gt;ctlr
)braket
suffix:semicolon
multiline_comment|/* undo the DMA mappings */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
id|pci_unmap_sg
c_func
(paren
id|ctlr-&gt;pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
(brace
id|addr64.val32.lower
op_assign
id|cp-&gt;SG
(braket
l_int|0
)braket
dot
id|Addr.lower
suffix:semicolon
id|addr64.val32.upper
op_assign
id|cp-&gt;SG
(braket
l_int|0
)braket
dot
id|Addr.upper
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|ctlr-&gt;pdev
comma
(paren
id|dma_addr_t
)paren
id|addr64.val
comma
id|cmd-&gt;request_bufflen
comma
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* host byte */
id|cmd-&gt;result
op_or_assign
(paren
id|COMMAND_COMPLETE
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* msg byte */
multiline_comment|/* cmd-&gt;result |= (GOOD &lt; 1); */
multiline_comment|/* status byte */
id|cmd-&gt;result
op_or_assign
(paren
id|ei-&gt;ScsiStatus
)paren
suffix:semicolon
multiline_comment|/* printk(&quot;Scsistatus is 0x%02x&bslash;n&quot;, ei-&gt;ScsiStatus);  */
multiline_comment|/* copy the sense data whether we need to or not. */
id|memcpy
c_func
(paren
id|cmd-&gt;sense_buffer
comma
id|ei-&gt;SenseInfo
comma
id|ei-&gt;SenseLen
OG
id|SCSI_SENSE_BUFFERSIZE
ques
c_cond
id|SCSI_SENSE_BUFFERSIZE
suffix:colon
id|ei-&gt;SenseLen
)paren
suffix:semicolon
id|cmd-&gt;resid
op_assign
id|ei-&gt;ResidualCnt
suffix:semicolon
r_if
c_cond
(paren
id|ei-&gt;CommandStatus
op_ne
l_int|0
)paren
(brace
multiline_comment|/* an error has occurred */
r_switch
c_cond
(paren
id|ei-&gt;CommandStatus
)paren
(brace
r_case
id|CMD_TARGET_STATUS
suffix:colon
multiline_comment|/* Pass it up to the upper layers... */
r_if
c_cond
(paren
id|ei-&gt;ScsiStatus
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p &quot;
l_string|&quot;has SCSI Status = %x&bslash;n&quot;
comma
id|cp
comma
id|ei-&gt;ScsiStatus
)paren
suffix:semicolon
macro_line|#endif
id|cmd-&gt;result
op_or_assign
(paren
id|ei-&gt;ScsiStatus
OL
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* scsi status is zero??? How??? */
multiline_comment|/* Ordinarily, this case should never happen, but there is a bug&n;&t;   in some released firmware revisions that allows it to happen&n;&t;   if, for example, a 4100 backplane loses power and the tape&n;&t;   drive is in it.  We assume that it&squot;s a fatal error of some&n;&t;   kind because we can&squot;t show that it wasn&squot;t. We will make it&n;&t;   look like selection timeout since that is the most common&n;&t;   reason for this to occur, and it&squot;s severe enough. */
id|cmd-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CMD_DATA_UNDERRUN
suffix:colon
multiline_comment|/* let mid layer handle it. */
r_break
suffix:semicolon
r_case
id|CMD_DATA_OVERRUN
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p has&quot;
l_string|&quot; completed with data overrun &quot;
l_string|&quot;reported&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_INVALID
suffix:colon
(brace
multiline_comment|/* print_bytes(cp, sizeof(*cp), 1, 0);&n;&t;&t;&t;&t;print_cmd(cp); */
multiline_comment|/* We get CMD_INVALID if you address a non-existent tape drive instead&n;&t;of a selection timeout (no response).  You will see this if you yank &n;&t;out a tape drive, then try to access it. This is kind of a shame&n;&t;because it means that any other CMD_INVALID (e.g. driver bug) will&n;&t;get interpreted as a missing target. */
id|cmd-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CMD_PROTOCOL_ERR
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p has &quot;
l_string|&quot;protocol error &bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_HARDWARE_ERR
suffix:colon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p had &quot;
l_string|&quot; hardware error&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_CONNECTION_LOST
suffix:colon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p had &quot;
l_string|&quot;connection lost&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_ABORTED
suffix:colon
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p was &quot;
l_string|&quot;aborted&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_ABORT_FAILED
suffix:colon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p reports &quot;
l_string|&quot;abort failed&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_UNSOLICITED_ABORT
suffix:colon
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p aborted &quot;
l_string|&quot;do to an unsolicited abort&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_TIMEOUT
suffix:colon
id|cmd-&gt;result
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p timedout&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p returned &quot;
l_string|&quot;unknown status %x&bslash;n&quot;
comma
id|cp
comma
id|ei-&gt;CommandStatus
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// printk(&quot;c:%p:c%db%dt%dl%d &quot;, cmd, ctlr-&gt;ctlr, cmd-&gt;channel, 
singleline_comment|//&t;cmd-&gt;target, cmd-&gt;lun);
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|scsi_cmd_free
c_func
(paren
id|ctlr
comma
id|cp
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cciss_scsi_detect
id|cciss_scsi_detect
c_func
(paren
r_int
id|ctlr
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|sh
suffix:semicolon
r_int
id|error
suffix:semicolon
id|sh
op_assign
id|scsi_host_alloc
c_func
(paren
op_amp
id|cciss_driver_template
comma
r_sizeof
(paren
r_struct
id|ctlr_info
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
op_eq
l_int|NULL
)paren
r_goto
id|fail
suffix:semicolon
id|sh-&gt;io_port
op_assign
l_int|0
suffix:semicolon
singleline_comment|// good enough?  FIXME, 
id|sh-&gt;n_io_port
op_assign
l_int|0
suffix:semicolon
singleline_comment|// I don&squot;t think we use these two...
id|sh-&gt;this_id
op_assign
id|SELF_SCSI_ID
suffix:semicolon
(paren
(paren
r_struct
id|cciss_scsi_adapter_data_t
op_star
)paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|scsi_ctlr
)paren
op_member_access_from_pointer
id|scsi_host
op_assign
(paren
r_void
op_star
)paren
id|sh
suffix:semicolon
id|sh-&gt;hostdata
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
id|sh-&gt;irq
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|intr
suffix:semicolon
id|sh-&gt;unique_id
op_assign
id|sh-&gt;irq
suffix:semicolon
id|error
op_assign
id|scsi_add_host
c_func
(paren
id|sh
comma
op_amp
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|pdev-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|fail_host_put
suffix:semicolon
id|scsi_scan_host
c_func
(paren
id|sh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|fail_host_put
suffix:colon
id|scsi_host_put
c_func
(paren
id|sh
)paren
suffix:semicolon
id|fail
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|__exit
id|cleanup_cciss_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
DECL|function|cciss_unmap_one
id|cciss_unmap_one
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
id|CommandList_struct
op_star
id|cp
comma
r_int
id|buflen
comma
r_int
id|data_direction
)paren
(brace
id|u64bit
id|addr64
suffix:semicolon
id|addr64.val32.lower
op_assign
id|cp-&gt;SG
(braket
l_int|0
)braket
dot
id|Addr.lower
suffix:semicolon
id|addr64.val32.upper
op_assign
id|cp-&gt;SG
(braket
l_int|0
)braket
dot
id|Addr.upper
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|pdev
comma
(paren
id|dma_addr_t
)paren
id|addr64.val
comma
id|buflen
comma
id|data_direction
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|cciss_map_one
id|cciss_map_one
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
id|CommandList_struct
op_star
id|cp
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_int
id|data_direction
)paren
(brace
id|__u64
id|addr64
suffix:semicolon
id|addr64
op_assign
(paren
id|__u64
)paren
id|pci_map_single
c_func
(paren
id|pdev
comma
id|buf
comma
id|buflen
comma
id|data_direction
)paren
suffix:semicolon
id|cp-&gt;SG
(braket
l_int|0
)braket
dot
id|Addr.lower
op_assign
(paren
id|__u32
)paren
(paren
id|addr64
op_amp
(paren
id|__u64
)paren
l_int|0x00000000FFFFFFFF
)paren
suffix:semicolon
id|cp-&gt;SG
(braket
l_int|0
)braket
dot
id|Addr.upper
op_assign
(paren
id|__u32
)paren
(paren
(paren
id|addr64
op_rshift
l_int|32
)paren
op_amp
(paren
id|__u64
)paren
l_int|0x00000000FFFFFFFF
)paren
suffix:semicolon
id|cp-&gt;SG
(braket
l_int|0
)braket
dot
id|Len
op_assign
id|buflen
suffix:semicolon
id|cp-&gt;Header.SGList
op_assign
(paren
id|__u8
)paren
l_int|1
suffix:semicolon
multiline_comment|/* no. SGs contig in this cmd */
id|cp-&gt;Header.SGTotal
op_assign
(paren
id|__u16
)paren
l_int|1
suffix:semicolon
multiline_comment|/* total sgs in this cmd list */
)brace
r_static
r_int
DECL|function|cciss_scsi_do_simple_cmd
id|cciss_scsi_do_simple_cmd
c_func
(paren
id|ctlr_info_t
op_star
id|c
comma
id|CommandList_struct
op_star
id|cp
comma
r_int
r_char
op_star
id|scsi3addr
comma
r_int
r_char
op_star
id|cdb
comma
r_int
r_char
id|cdblen
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
id|direction
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DECLARE_COMPLETION
c_func
(paren
id|wait
)paren
suffix:semicolon
id|cp-&gt;cmd_type
op_assign
id|CMD_IOCTL_PEND
suffix:semicolon
singleline_comment|// treat this like an ioctl 
id|cp-&gt;scsi_cmd
op_assign
l_int|NULL
suffix:semicolon
id|cp-&gt;Header.ReplyQueue
op_assign
l_int|0
suffix:semicolon
singleline_comment|// unused in simple mode
id|memcpy
c_func
(paren
op_amp
id|cp-&gt;Header.LUN
comma
id|scsi3addr
comma
r_sizeof
(paren
id|cp-&gt;Header.LUN
)paren
)paren
suffix:semicolon
id|cp-&gt;Header.Tag.lower
op_assign
id|cp-&gt;busaddr
suffix:semicolon
singleline_comment|// Use k. address of cmd as tag
singleline_comment|// Fill in the request block...
multiline_comment|/* printk(&quot;Using scsi3addr 0x%02x%0x2%0x2%0x2%0x2%0x2%0x2%0x2&bslash;n&quot;, &n;&t;&t;scsi3addr[0], scsi3addr[1], scsi3addr[2], scsi3addr[3],&n;&t;&t;scsi3addr[4], scsi3addr[5], scsi3addr[6], scsi3addr[7]); */
id|memset
c_func
(paren
id|cp-&gt;Request.CDB
comma
l_int|0
comma
r_sizeof
(paren
id|cp-&gt;Request.CDB
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|cp-&gt;Request.CDB
comma
id|cdb
comma
id|cdblen
)paren
suffix:semicolon
id|cp-&gt;Request.Timeout
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;Request.CDBLen
op_assign
id|cdblen
suffix:semicolon
id|cp-&gt;Request.Type.Type
op_assign
id|TYPE_CMD
suffix:semicolon
id|cp-&gt;Request.Type.Attribute
op_assign
id|ATTR_SIMPLE
suffix:semicolon
id|cp-&gt;Request.Type.Direction
op_assign
id|direction
suffix:semicolon
multiline_comment|/* Fill in the SG list and do dma mapping */
id|cciss_map_one
c_func
(paren
id|c-&gt;pdev
comma
id|cp
comma
(paren
r_int
r_char
op_star
)paren
id|buf
comma
id|bufsize
comma
id|DMA_FROM_DEVICE
)paren
suffix:semicolon
id|cp-&gt;waiting
op_assign
op_amp
id|wait
suffix:semicolon
multiline_comment|/* Put the request on the tail of the request queue */
id|spin_lock_irqsave
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|c-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|addQ
c_func
(paren
op_amp
id|c-&gt;reqQ
comma
id|cp
)paren
suffix:semicolon
id|c-&gt;Qdepth
op_increment
suffix:semicolon
id|start_io
c_func
(paren
id|c
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|c-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* undo the dma mapping */
id|cciss_unmap_one
c_func
(paren
id|c-&gt;pdev
comma
id|cp
comma
id|bufsize
comma
id|DMA_FROM_DEVICE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|cciss_scsi_interpret_error
id|cciss_scsi_interpret_error
c_func
(paren
id|CommandList_struct
op_star
id|cp
)paren
(brace
id|ErrorInfo_struct
op_star
id|ei
suffix:semicolon
id|ei
op_assign
id|cp-&gt;err_info
suffix:semicolon
r_switch
c_cond
(paren
id|ei-&gt;CommandStatus
)paren
(brace
r_case
id|CMD_TARGET_STATUS
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p has &quot;
l_string|&quot;completed with errors&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p &quot;
l_string|&quot;has SCSI Status = %x&bslash;n&quot;
comma
id|cp
comma
id|ei-&gt;ScsiStatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei-&gt;ScsiStatus
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss:SCSI status is abnormally zero.  &quot;
l_string|&quot;(probably indicates selection timeout &quot;
l_string|&quot;reported incorrectly due to a known &quot;
l_string|&quot;firmware bug, circa July, 2001.)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_DATA_UNDERRUN
suffix:colon
multiline_comment|/* let mid layer handle it. */
id|printk
c_func
(paren
l_string|&quot;UNDERRUN&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_DATA_OVERRUN
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p has&quot;
l_string|&quot; completed with data overrun &quot;
l_string|&quot;reported&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_INVALID
suffix:colon
(brace
multiline_comment|/* controller unfortunately reports SCSI passthru&squot;s */
multiline_comment|/* to non-existent targets as invalid commands. */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p is &quot;
l_string|&quot;reported invalid (probably means &quot;
l_string|&quot;target device no longer present)&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/* print_bytes((unsigned char *) cp, sizeof(*cp), 1, 0);&n;&t;&t;&t;print_cmd(cp);  */
)brace
r_break
suffix:semicolon
r_case
id|CMD_PROTOCOL_ERR
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p has &quot;
l_string|&quot;protocol error &bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_HARDWARE_ERR
suffix:colon
multiline_comment|/* cmd-&gt;result = DID_ERROR &lt;&lt; 16; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p had &quot;
l_string|&quot; hardware error&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_CONNECTION_LOST
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p had &quot;
l_string|&quot;connection lost&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_ABORTED
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p was &quot;
l_string|&quot;aborted&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_ABORT_FAILED
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p reports &quot;
l_string|&quot;abort failed&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_UNSOLICITED_ABORT
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p aborted &quot;
l_string|&quot;do to an unsolicited abort&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_TIMEOUT
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p timedout&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cp %p returned &quot;
l_string|&quot;unknown status %x&bslash;n&quot;
comma
id|cp
comma
id|ei-&gt;CommandStatus
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|cciss_scsi_do_inquiry
id|cciss_scsi_do_inquiry
c_func
(paren
id|ctlr_info_t
op_star
id|c
comma
r_int
r_char
op_star
id|scsi3addr
comma
id|InquiryData_struct
op_star
id|buf
)paren
(brace
r_int
id|rc
suffix:semicolon
id|CommandList_struct
op_star
id|cp
suffix:semicolon
r_char
id|cdb
(braket
l_int|6
)braket
suffix:semicolon
id|ErrorInfo_struct
op_star
id|ei
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|c-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|cp
op_assign
id|scsi_cmd_alloc
c_func
(paren
id|c
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|c-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* trouble... */
id|printk
c_func
(paren
l_string|&quot;cmd_alloc returned NULL!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ei
op_assign
id|cp-&gt;err_info
suffix:semicolon
id|cdb
(braket
l_int|0
)braket
op_assign
id|CISS_INQUIRY
suffix:semicolon
id|cdb
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|cdb
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|cdb
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|cdb
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
op_star
id|buf
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cdb
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|cciss_scsi_do_simple_cmd
c_func
(paren
id|c
comma
id|cp
comma
id|scsi3addr
comma
id|cdb
comma
l_int|6
comma
(paren
r_int
r_char
op_star
)paren
id|buf
comma
r_sizeof
(paren
op_star
id|buf
)paren
comma
id|XFER_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* something went wrong */
r_if
c_cond
(paren
id|ei-&gt;CommandStatus
op_ne
l_int|0
op_logical_and
id|ei-&gt;CommandStatus
op_ne
id|CMD_DATA_UNDERRUN
)paren
(brace
id|cciss_scsi_interpret_error
c_func
(paren
id|cp
)paren
suffix:semicolon
id|rc
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|c-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|scsi_cmd_free
c_func
(paren
id|c
comma
id|cp
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|c-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|cciss_scsi_do_report_phys_luns
id|cciss_scsi_do_report_phys_luns
c_func
(paren
id|ctlr_info_t
op_star
id|c
comma
id|ReportLunData_struct
op_star
id|buf
comma
r_int
id|bufsize
)paren
(brace
r_int
id|rc
suffix:semicolon
id|CommandList_struct
op_star
id|cp
suffix:semicolon
r_int
r_char
id|cdb
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_char
id|scsi3addr
(braket
l_int|8
)braket
suffix:semicolon
id|ErrorInfo_struct
op_star
id|ei
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|c-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|cp
op_assign
id|scsi_cmd_alloc
c_func
(paren
id|c
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|c-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* trouble... */
id|printk
c_func
(paren
l_string|&quot;cmd_alloc returned NULL!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|scsi3addr
(braket
l_int|0
)braket
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* address the controller */
id|cdb
(braket
l_int|0
)braket
op_assign
id|CISS_REPORT_PHYS
suffix:semicolon
id|cdb
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|cdb
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|cdb
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|cdb
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|cdb
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|cdb
(braket
l_int|6
)braket
op_assign
(paren
id|bufsize
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|//MSB
id|cdb
(braket
l_int|7
)braket
op_assign
(paren
id|bufsize
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|cdb
(braket
l_int|8
)braket
op_assign
(paren
id|bufsize
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|cdb
(braket
l_int|9
)braket
op_assign
id|bufsize
op_amp
l_int|0xFF
suffix:semicolon
id|cdb
(braket
l_int|10
)braket
op_assign
l_int|0
suffix:semicolon
id|cdb
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|cciss_scsi_do_simple_cmd
c_func
(paren
id|c
comma
id|cp
comma
id|scsi3addr
comma
id|cdb
comma
l_int|12
comma
(paren
r_int
r_char
op_star
)paren
id|buf
comma
id|bufsize
comma
id|XFER_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* something went wrong */
id|ei
op_assign
id|cp-&gt;err_info
suffix:semicolon
r_if
c_cond
(paren
id|ei-&gt;CommandStatus
op_ne
l_int|0
op_logical_and
id|ei-&gt;CommandStatus
op_ne
id|CMD_DATA_UNDERRUN
)paren
(brace
id|cciss_scsi_interpret_error
c_func
(paren
id|cp
)paren
suffix:semicolon
id|rc
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|c-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|scsi_cmd_free
c_func
(paren
id|c
comma
id|cp
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|c-&gt;ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_void
DECL|function|cciss_update_non_disk_devices
id|cciss_update_non_disk_devices
c_func
(paren
r_int
id|cntl_num
comma
r_int
id|hostno
)paren
(brace
multiline_comment|/* the idea here is we could get notified from /proc&n;&t;   that some devices have changed, so we do a report &n;&t;   physical luns cmd, and adjust our list of devices &n;&t;   accordingly.  (We can&squot;t rely on the scsi-mid layer just&n;&t;   doing inquiries, because the &quot;busses&quot; that the scsi &n;&t;   mid-layer probes are totally fabricated by this driver,&n;&t;   so new devices wouldn&squot;t show up.&n;&n;&t;   the scsi3addr&squot;s of devices won&squot;t change so long as the &n;&t;   adapter is not reset.  That means we can rescan and &n;&t;   tell which devices we already know about, vs. new &n;&t;   devices, vs.  disappearing devices.&n;&n;&t;   Also, if you yank out a tape drive, then put in a disk&n;&t;   in it&squot;s place, (say, a configured volume from another &n;&t;   array controller for instance)  _don&squot;t_ poke this driver &n;           (so it thinks it&squot;s still a tape, but _do_ poke the scsi &n;           mid layer, so it does an inquiry... the scsi mid layer &n;           will see the physical disk.  This would be bad.  Need to&n;&t;   think about how to prevent that.  One idea would be to &n;&t;   snoop all scsi responses and if an inquiry repsonse comes&n;&t;   back that reports a disk, chuck it an return selection&n;&t;   timeout instead and adjust our table...  Not sure i like&n;&t;   that though.  &n;&n;&t; */
id|ReportLunData_struct
op_star
id|ld_buff
suffix:semicolon
id|InquiryData_struct
op_star
id|inq_buff
suffix:semicolon
r_int
r_char
id|scsi3addr
(braket
l_int|8
)braket
suffix:semicolon
id|ctlr_info_t
op_star
id|c
suffix:semicolon
id|__u32
id|num_luns
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|ch
suffix:semicolon
multiline_comment|/* unsigned char found[CCISS_MAX_SCSI_DEVS_PER_HBA]; */
r_struct
id|cciss_scsi_dev_t
id|currentsd
(braket
id|CCISS_MAX_SCSI_DEVS_PER_HBA
)braket
suffix:semicolon
r_int
id|ncurrent
op_assign
l_int|0
suffix:semicolon
r_int
id|reportlunsize
op_assign
r_sizeof
(paren
op_star
id|ld_buff
)paren
op_plus
id|CISS_MAX_PHYS_LUN
op_star
l_int|8
suffix:semicolon
r_int
id|i
suffix:semicolon
id|c
op_assign
(paren
id|ctlr_info_t
op_star
)paren
id|hba
(braket
id|cntl_num
)braket
suffix:semicolon
id|ld_buff
op_assign
id|kmalloc
c_func
(paren
id|reportlunsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ld_buff
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cciss: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ld_buff
comma
l_int|0
comma
id|reportlunsize
)paren
suffix:semicolon
id|inq_buff
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|InquiryData_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inq_buff
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cciss: out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ld_buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cciss_scsi_do_report_phys_luns
c_func
(paren
id|c
comma
id|ld_buff
comma
id|reportlunsize
)paren
op_eq
l_int|0
)paren
(brace
id|ch
op_assign
op_amp
id|ld_buff-&gt;LUNListLength
(braket
l_int|0
)braket
suffix:semicolon
id|num_luns
op_assign
(paren
(paren
id|ch
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|ch
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|ch
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|ch
(braket
l_int|3
)braket
)paren
op_div
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|num_luns
OG
id|CISS_MAX_PHYS_LUN
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: Maximum physical LUNs (%d) exceeded.  &quot;
l_string|&quot;%d LUNs ignored.&bslash;n&quot;
comma
id|CISS_MAX_PHYS_LUN
comma
id|num_luns
op_minus
id|CISS_MAX_PHYS_LUN
)paren
suffix:semicolon
id|num_luns
op_assign
id|CISS_MAX_PHYS_LUN
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cciss: Report physical LUNs failed.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* adjust our table of devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_luns
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|devtype
suffix:semicolon
multiline_comment|/* for each physical lun, do an inquiry */
r_if
c_cond
(paren
id|ld_buff-&gt;LUN
(braket
id|i
)braket
(braket
l_int|3
)braket
op_amp
l_int|0xC0
)paren
r_continue
suffix:semicolon
id|memset
c_func
(paren
id|inq_buff
comma
l_int|0
comma
r_sizeof
(paren
id|InquiryData_struct
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|scsi3addr
(braket
l_int|0
)braket
comma
op_amp
id|ld_buff-&gt;LUN
(braket
id|i
)braket
(braket
l_int|0
)braket
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cciss_scsi_do_inquiry
c_func
(paren
id|hba
(braket
id|cntl_num
)braket
comma
id|scsi3addr
comma
id|inq_buff
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Inquiry failed (msg printed already) */
id|devtype
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* so we will skip this device. */
)brace
r_else
multiline_comment|/* what kind of device is this? */
id|devtype
op_assign
(paren
id|inq_buff-&gt;data_byte
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|devtype
)paren
(brace
r_case
l_int|0x01
suffix:colon
multiline_comment|/* sequential access, (tape) */
r_case
l_int|0x08
suffix:colon
multiline_comment|/* medium changer */
r_if
c_cond
(paren
id|ncurrent
op_ge
id|CCISS_MAX_SCSI_DEVS_PER_HBA
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cciss%d: %s ignored, &quot;
l_string|&quot;too many devices.&bslash;n&quot;
comma
id|cntl_num
comma
id|DEVICETYPE
c_func
(paren
id|devtype
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|currentsd
(braket
id|ncurrent
)braket
dot
id|scsi3addr
(braket
l_int|0
)braket
comma
op_amp
id|scsi3addr
(braket
l_int|0
)braket
comma
l_int|8
)paren
suffix:semicolon
id|currentsd
(braket
id|ncurrent
)braket
dot
id|devtype
op_assign
id|devtype
suffix:semicolon
id|currentsd
(braket
id|ncurrent
)braket
dot
id|bus
op_assign
op_minus
l_int|1
suffix:semicolon
id|currentsd
(braket
id|ncurrent
)braket
dot
id|target
op_assign
op_minus
l_int|1
suffix:semicolon
id|currentsd
(braket
id|ncurrent
)braket
dot
id|lun
op_assign
op_minus
l_int|1
suffix:semicolon
id|ncurrent
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
id|adjust_cciss_scsi_table
c_func
(paren
id|cntl_num
comma
id|hostno
comma
id|currentsd
comma
id|ncurrent
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|inq_buff
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ld_buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|is_keyword
id|is_keyword
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
r_char
op_star
id|verb
)paren
singleline_comment|// Thanks to ncr53c8xx.c
(brace
r_int
id|verb_len
op_assign
id|strlen
c_func
(paren
id|verb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|verb_len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|verb
comma
id|ptr
comma
id|verb_len
)paren
)paren
r_return
id|verb_len
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|cciss_scsi_user_command
id|cciss_scsi_user_command
c_func
(paren
r_int
id|ctlr
comma
r_int
id|hostno
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
id|arg_len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|buffer
comma
id|length
comma
l_string|&quot;rescan&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|cciss_update_non_disk_devices
c_func
(paren
id|ctlr
comma
id|hostno
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
r_int
DECL|function|cciss_scsi_proc_info
id|cciss_scsi_proc_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|sh
comma
r_char
op_star
id|buffer
comma
multiline_comment|/* data buffer */
r_char
op_star
op_star
id|start
comma
multiline_comment|/* where data in buffer starts */
id|off_t
id|offset
comma
multiline_comment|/* offset from start of imaginary file */
r_int
id|length
comma
multiline_comment|/* length of data in buffer */
r_int
id|func
)paren
multiline_comment|/* 0 == read, 1 == write */
(brace
r_int
id|buflen
comma
id|datalen
suffix:semicolon
id|ctlr_info_t
op_star
id|ci
suffix:semicolon
r_int
id|cntl_num
suffix:semicolon
id|ci
op_assign
(paren
id|ctlr_info_t
op_star
)paren
id|sh-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ci
op_eq
l_int|NULL
)paren
multiline_comment|/* This really shouldn&squot;t ever happen. */
r_return
op_minus
id|EINVAL
suffix:semicolon
id|cntl_num
op_assign
id|ci-&gt;ctlr
suffix:semicolon
multiline_comment|/* Get our index into the hba[] array */
r_if
c_cond
(paren
id|func
op_eq
l_int|0
)paren
(brace
multiline_comment|/* User is reading from /proc/scsi/ciss*?/?*  */
id|buflen
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;hostnum=%d&bslash;n&quot;
comma
id|sh-&gt;host_no
)paren
suffix:semicolon
id|datalen
op_assign
id|buflen
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|datalen
OL
l_int|0
)paren
(brace
multiline_comment|/* they&squot;re reading past EOF. */
id|datalen
op_assign
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|buflen
suffix:semicolon
)brace
r_else
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
r_return
id|datalen
suffix:semicolon
)brace
r_else
multiline_comment|/* User is writing to /proc/scsi/cciss*?/?*  ... */
r_return
id|cciss_scsi_user_command
c_func
(paren
id|cntl_num
comma
id|sh-&gt;host_no
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
)brace
multiline_comment|/* this is via the generic proc support */
r_const
r_char
op_star
DECL|function|cciss_scsi_info
id|cciss_scsi_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|sa
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|300
)braket
suffix:semicolon
id|ctlr_info_t
op_star
id|ci
suffix:semicolon
multiline_comment|/* probably need to work on putting a bit more info in here... */
multiline_comment|/* this is output via the /proc filesystem. */
id|ci
op_assign
(paren
id|ctlr_info_t
op_star
)paren
id|sa-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s %c%c%c%c&bslash;n&quot;
comma
id|ci-&gt;product_name
comma
id|ci-&gt;firm_ver
(braket
l_int|0
)braket
comma
id|ci-&gt;firm_ver
(braket
l_int|1
)braket
comma
id|ci-&gt;firm_ver
(braket
l_int|2
)braket
comma
id|ci-&gt;firm_ver
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
multiline_comment|/* cciss_scatter_gather takes a struct scsi_cmnd, (cmd), and does the pci &n;   dma mapping  and fills in the scatter gather entries of the &n;   cciss command, cp. */
r_static
r_void
DECL|function|cciss_scatter_gather
id|cciss_scatter_gather
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
id|CommandList_struct
op_star
id|cp
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
r_int
id|use_sg
comma
id|nsegs
op_assign
l_int|0
comma
id|len
suffix:semicolon
r_struct
id|scatterlist
op_star
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
id|__u64
id|addr64
suffix:semicolon
multiline_comment|/* is it just one virtual address? */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;use_sg
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
(brace
multiline_comment|/* anything to xfer? */
id|addr64
op_assign
(paren
id|__u64
)paren
id|pci_map_single
c_func
(paren
id|pdev
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
comma
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
id|cp-&gt;SG
(braket
l_int|0
)braket
dot
id|Addr.lower
op_assign
(paren
id|__u32
)paren
(paren
id|addr64
op_amp
(paren
id|__u64
)paren
l_int|0x00000000FFFFFFFF
)paren
suffix:semicolon
id|cp-&gt;SG
(braket
l_int|0
)braket
dot
id|Addr.upper
op_assign
(paren
id|__u32
)paren
(paren
(paren
id|addr64
op_rshift
l_int|32
)paren
op_amp
(paren
id|__u64
)paren
l_int|0x00000000FFFFFFFF
)paren
suffix:semicolon
id|cp-&gt;SG
(braket
l_int|0
)braket
dot
id|Len
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|nsegs
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* else, must be a list of virtual addresses.... */
r_else
r_if
c_cond
(paren
id|cmd-&gt;use_sg
op_le
id|MAXSGENTRIES
)paren
(brace
multiline_comment|/* not too many addrs? */
id|use_sg
op_assign
id|pci_map_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nsegs
op_assign
l_int|0
suffix:semicolon
id|nsegs
OL
id|use_sg
suffix:semicolon
id|nsegs
op_increment
)paren
(brace
id|addr64
op_assign
(paren
id|__u64
)paren
id|sg_dma_address
c_func
(paren
op_amp
id|scatter
(braket
id|nsegs
)braket
)paren
suffix:semicolon
id|len
op_assign
id|sg_dma_len
c_func
(paren
op_amp
id|scatter
(braket
id|nsegs
)braket
)paren
suffix:semicolon
id|cp-&gt;SG
(braket
id|nsegs
)braket
dot
id|Addr.lower
op_assign
(paren
id|__u32
)paren
(paren
id|addr64
op_amp
(paren
id|__u64
)paren
l_int|0x00000000FFFFFFFF
)paren
suffix:semicolon
id|cp-&gt;SG
(braket
id|nsegs
)braket
dot
id|Addr.upper
op_assign
(paren
id|__u32
)paren
(paren
(paren
id|addr64
op_rshift
l_int|32
)paren
op_amp
(paren
id|__u64
)paren
l_int|0x00000000FFFFFFFF
)paren
suffix:semicolon
id|cp-&gt;SG
(braket
id|nsegs
)braket
dot
id|Len
op_assign
id|len
suffix:semicolon
id|cp-&gt;SG
(braket
id|nsegs
)braket
dot
id|Ext
op_assign
l_int|0
suffix:semicolon
singleline_comment|// we are not chaining
)brace
)brace
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|cp-&gt;Header.SGList
op_assign
(paren
id|__u8
)paren
id|nsegs
suffix:semicolon
multiline_comment|/* no. SGs contig in this cmd */
id|cp-&gt;Header.SGTotal
op_assign
(paren
id|__u16
)paren
id|nsegs
suffix:semicolon
multiline_comment|/* total sgs in this cmd list */
r_return
suffix:semicolon
)brace
r_int
DECL|function|cciss_scsi_queue_command
id|cciss_scsi_queue_command
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
(brace
id|ctlr_info_t
op_star
op_star
id|c
suffix:semicolon
r_int
id|ctlr
comma
id|rc
suffix:semicolon
r_int
r_char
id|scsi3addr
(braket
l_int|8
)braket
suffix:semicolon
id|CommandList_struct
op_star
id|cp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
singleline_comment|// Get the ptr to our adapter structure (hba[i]) out of cmd-&gt;host.
singleline_comment|// We violate cmd-&gt;host privacy here.  (Is there another way?)
id|c
op_assign
(paren
id|ctlr_info_t
op_star
op_star
)paren
op_amp
id|cmd-&gt;device-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|ctlr
op_assign
(paren
op_star
id|c
)paren
op_member_access_from_pointer
id|ctlr
suffix:semicolon
id|rc
op_assign
id|lookup_scsi3addr
c_func
(paren
id|ctlr
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
comma
id|scsi3addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
multiline_comment|/* the scsi nexus does not match any that we presented... */
multiline_comment|/* pretend to mid layer that we got selection timeout */
id|cmd-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* we might want to think about registering controller itself&n;&t;&t;   as a processor device on the bus so sg binds to it. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* printk(&quot;cciss_queue_command, p=%p, cmd=0x%02x, c%db%dt%dl%d&bslash;n&quot;, &n;&t;&t;cmd, cmd-&gt;cmnd[0], ctlr, cmd-&gt;channel, cmd-&gt;target, cmd-&gt;lun);*/
singleline_comment|// printk(&quot;q:%p:c%db%dt%dl%d &quot;, cmd, ctlr, cmd-&gt;channel, 
singleline_comment|//&t;cmd-&gt;target, cmd-&gt;lun);
multiline_comment|/* Ok, we have a reasonable scsi nexus, so send the cmd down, and&n;           see what the device thinks of it. */
id|spin_lock_irqsave
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|cp
op_assign
id|scsi_cmd_alloc
c_func
(paren
op_star
id|c
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* trouble... */
id|printk
c_func
(paren
l_string|&quot;scsi_cmd_alloc returned NULL!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: next 3 lines are -&gt; BAD! &lt;- */
id|cmd-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// Fill in the command list header
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
singleline_comment|// save this for use by completion code 
singleline_comment|// save cp in case we have to abort it 
id|cmd-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|cp
suffix:semicolon
id|cp-&gt;cmd_type
op_assign
id|CMD_SCSI
suffix:semicolon
id|cp-&gt;scsi_cmd
op_assign
id|cmd
suffix:semicolon
id|cp-&gt;Header.ReplyQueue
op_assign
l_int|0
suffix:semicolon
singleline_comment|// unused in simple mode
id|memcpy
c_func
(paren
op_amp
id|cp-&gt;Header.LUN.LunAddrBytes
(braket
l_int|0
)braket
comma
op_amp
id|scsi3addr
(braket
l_int|0
)braket
comma
l_int|8
)paren
suffix:semicolon
id|cp-&gt;Header.Tag.lower
op_assign
id|cp-&gt;busaddr
suffix:semicolon
singleline_comment|// Use k. address of cmd as tag
singleline_comment|// Fill in the request block...
id|cp-&gt;Request.Timeout
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|cp-&gt;Request.CDB
comma
l_int|0
comma
r_sizeof
(paren
id|cp-&gt;Request.CDB
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmd_len
OG
r_sizeof
(paren
id|cp-&gt;Request.CDB
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|cp-&gt;Request.CDBLen
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|memcpy
c_func
(paren
id|cp-&gt;Request.CDB
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
id|cp-&gt;Request.Type.Type
op_assign
id|TYPE_CMD
suffix:semicolon
id|cp-&gt;Request.Type.Attribute
op_assign
id|ATTR_SIMPLE
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;sc_data_direction
)paren
(brace
r_case
id|DMA_TO_DEVICE
suffix:colon
id|cp-&gt;Request.Type.Direction
op_assign
id|XFER_WRITE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMA_FROM_DEVICE
suffix:colon
id|cp-&gt;Request.Type.Direction
op_assign
id|XFER_READ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMA_NONE
suffix:colon
id|cp-&gt;Request.Type.Direction
op_assign
id|XFER_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMA_BIDIRECTIONAL
suffix:colon
singleline_comment|// This can happen if a buggy application does a scsi passthru
singleline_comment|// and sets both inlen and outlen to non-zero. ( see
singleline_comment|// ../scsi/scsi_ioctl.c:scsi_ioctl_send_command() )
id|cp-&gt;Request.Type.Direction
op_assign
id|XFER_RSVD
suffix:semicolon
singleline_comment|// This is technically wrong, and cciss controllers should
singleline_comment|// reject it with CMD_INVALID, which is the most correct 
singleline_comment|// response, but non-fibre backends appear to let it 
singleline_comment|// slide by, and give the same results as if this field
singleline_comment|// were set correctly.  Either way is acceptable for
singleline_comment|// our purposes here.
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;cciss: unknown data direction: %d&bslash;n&quot;
comma
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cciss_scatter_gather
c_func
(paren
(paren
op_star
id|c
)paren
op_member_access_from_pointer
id|pdev
comma
id|cp
comma
id|cmd
)paren
suffix:semicolon
singleline_comment|// Fill the SG list
multiline_comment|/* Put the request on the tail of the request queue */
id|spin_lock_irqsave
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|addQ
c_func
(paren
op_amp
(paren
op_star
id|c
)paren
op_member_access_from_pointer
id|reqQ
comma
id|cp
)paren
suffix:semicolon
(paren
op_star
id|c
)paren
op_member_access_from_pointer
id|Qdepth
op_increment
suffix:semicolon
id|start_io
c_func
(paren
op_star
id|c
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* the cmd&squot;ll come back via intr handler in complete_scsi_command()  */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|cciss_unregister_scsi
id|cciss_unregister_scsi
c_func
(paren
r_int
id|ctlr
)paren
(brace
r_struct
id|cciss_scsi_adapter_data_t
op_star
id|sa
suffix:semicolon
r_struct
id|cciss_scsi_cmd_stack_t
op_star
id|stk
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* we are being forcibly unloaded, and may not refuse. */
id|spin_lock_irqsave
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|sa
op_assign
(paren
r_struct
id|cciss_scsi_adapter_data_t
op_star
)paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|scsi_ctlr
suffix:semicolon
id|stk
op_assign
op_amp
id|sa-&gt;cmd_stack
suffix:semicolon
multiline_comment|/* if we weren&squot;t ever actually registered, don&squot;t unregister */
r_if
c_cond
(paren
id|sa-&gt;registered
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|scsi_remove_host
c_func
(paren
id|sa-&gt;scsi_host
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|sa-&gt;scsi_host
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* set scsi_host to NULL so our detect routine will &n;&t;   find us on register */
id|sa-&gt;scsi_host
op_assign
l_int|NULL
suffix:semicolon
id|scsi_cmd_stack_free
c_func
(paren
id|ctlr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sa
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cciss_register_scsi
id|cciss_register_scsi
c_func
(paren
r_int
id|ctlr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|CPQ_TAPE_LOCK
c_func
(paren
id|ctlr
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Since this is really a block driver, the SCSI core may not be &n;&t;   initialized at init time, in which case, calling scsi_register_host&n;&t;   would hang.  Instead, we do it later, via /proc filesystem&n;&t;   and rc scripts, when we know SCSI core is good to go. */
multiline_comment|/* Only register if SCSI devices are detected. */
r_if
c_cond
(paren
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|ndevices
op_ne
l_int|0
)paren
(brace
(paren
(paren
r_struct
id|cciss_scsi_adapter_data_t
op_star
)paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|scsi_ctlr
)paren
op_member_access_from_pointer
id|registered
op_assign
l_int|1
suffix:semicolon
id|CPQ_TAPE_UNLOCK
c_func
(paren
id|ctlr
comma
id|flags
)paren
suffix:semicolon
r_return
id|cciss_scsi_detect
c_func
(paren
id|ctlr
)paren
suffix:semicolon
)brace
id|CPQ_TAPE_UNLOCK
c_func
(paren
id|ctlr
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cciss%d: No appropriate SCSI device detected, &quot;
l_string|&quot;SCSI subsystem not engaged.&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|cciss_engage_scsi
id|cciss_engage_scsi
c_func
(paren
r_int
id|ctlr
)paren
(brace
r_struct
id|cciss_scsi_adapter_data_t
op_star
id|sa
suffix:semicolon
r_struct
id|cciss_scsi_cmd_stack_t
op_star
id|stk
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|sa
op_assign
(paren
r_struct
id|cciss_scsi_adapter_data_t
op_star
)paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|scsi_ctlr
suffix:semicolon
id|stk
op_assign
op_amp
id|sa-&gt;cmd_stack
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_struct
id|cciss_scsi_adapter_data_t
op_star
)paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|scsi_ctlr
)paren
op_member_access_from_pointer
id|registered
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cciss%d: SCSI subsystem already engaged.&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|ENXIO
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|CCISS_LOCK
c_func
(paren
id|ctlr
)paren
comma
id|flags
)paren
suffix:semicolon
id|cciss_update_non_disk_devices
c_func
(paren
id|ctlr
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|cciss_register_scsi
c_func
(paren
id|ctlr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|cciss_proc_tape_report
id|cciss_proc_tape_report
c_func
(paren
r_int
id|ctlr
comma
r_int
r_char
op_star
id|buffer
comma
id|off_t
op_star
id|pos
comma
id|off_t
op_star
id|len
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|size
suffix:semicolon
op_star
id|pos
op_assign
op_star
id|pos
op_minus
l_int|1
suffix:semicolon
op_star
id|len
op_assign
op_star
id|len
op_minus
l_int|1
suffix:semicolon
singleline_comment|// cut off the last trailing newline
id|CPQ_TAPE_LOCK
c_func
(paren
id|ctlr
comma
id|flags
)paren
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
op_star
id|len
comma
l_string|&quot;       Sequential access devices: %d&bslash;n&bslash;n&quot;
comma
id|ccissscsi
(braket
id|ctlr
)braket
dot
id|ndevices
)paren
suffix:semicolon
id|CPQ_TAPE_UNLOCK
c_func
(paren
id|ctlr
comma
id|flags
)paren
suffix:semicolon
op_star
id|pos
op_add_assign
id|size
suffix:semicolon
op_star
id|len
op_add_assign
id|size
suffix:semicolon
)brace
macro_line|#else /* no CONFIG_CISS_SCSI_TAPE */
multiline_comment|/* If no tape support, then these become defined out of existence */
DECL|macro|cciss_scsi_setup
mdefine_line|#define cciss_scsi_setup(cntl_num)
DECL|macro|cciss_unregister_scsi
mdefine_line|#define cciss_unregister_scsi(ctlr)
DECL|macro|cciss_register_scsi
mdefine_line|#define cciss_register_scsi(ctlr)
DECL|macro|cciss_proc_tape_report
mdefine_line|#define cciss_proc_tape_report(ctlr, buffer, pos, len)
macro_line|#endif /* CONFIG_CISS_SCSI_TAPE */
eof
