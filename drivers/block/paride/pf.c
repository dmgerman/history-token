multiline_comment|/* &n;        pf.c    (c) 1997-8  Grant R. Guenther &lt;grant@torque.net&gt;&n;                            Under the terms of the GNU General Public License.&n;&n;        This is the high-level driver for parallel port ATAPI disk&n;        drives based on chips supported by the paride module.&n;&n;        By default, the driver will autoprobe for a single parallel&n;        port ATAPI disk drive, but if their individual parameters are&n;        specified, the driver can handle up to 4 drives.&n;&n;        The behaviour of the pf driver can be altered by setting&n;        some parameters from the insmod command line.  The following&n;        parameters are adjustable:&n;&n;            drive0      These four arguments can be arrays of       &n;            drive1      1-7 integers as follows:&n;            drive2&n;            drive3      &lt;prt&gt;,&lt;pro&gt;,&lt;uni&gt;,&lt;mod&gt;,&lt;slv&gt;,&lt;lun&gt;,&lt;dly&gt;&n;&n;                        Where,&n;&n;                &lt;prt&gt;   is the base of the parallel port address for&n;                        the corresponding drive.  (required)&n;&n;                &lt;pro&gt;   is the protocol number for the adapter that&n;                        supports this drive.  These numbers are&n;                        logged by &squot;paride&squot; when the protocol modules&n;                        are initialised.  (0 if not given)&n;&n;                &lt;uni&gt;   for those adapters that support chained&n;                        devices, this is the unit selector for the&n;                        chain of devices on the given port.  It should&n;                        be zero for devices that don&squot;t support chaining.&n;                        (0 if not given)&n;&n;                &lt;mod&gt;   this can be -1 to choose the best mode, or one&n;                        of the mode numbers supported by the adapter.&n;                        (-1 if not given)&n;&n;                &lt;slv&gt;   ATAPI CDroms can be jumpered to master or slave.&n;                        Set this to 0 to choose the master drive, 1 to&n;                        choose the slave, -1 (the default) to choose the&n;                        first drive found.&n;&n;&t;&t;&lt;lun&gt;   Some ATAPI devices support multiple LUNs.&n;                        One example is the ATAPI PD/CD drive from&n;                        Matshita/Panasonic.  This device has a &n;                        CD drive on LUN 0 and a PD drive on LUN 1.&n;                        By default, the driver will search for the&n;                        first LUN with a supported device.  Set &n;                        this parameter to force it to use a specific&n;                        LUN.  (default -1)&n;&n;                &lt;dly&gt;   some parallel ports require the driver to &n;                        go more slowly.  -1 sets a default value that&n;                        should work with the chosen protocol.  Otherwise,&n;                        set this to a small integer, the larger it is&n;                        the slower the port i/o.  In some cases, setting&n;                        this to zero will speed up the device. (default -1)&n;&n;&t;    major&t;You may use this parameter to overide the&n;&t;&t;&t;default major number (47) that this driver&n;&t;&t;&t;will use.  Be sure to change the device&n;&t;&t;&t;name as well.&n;&n;&t;    name&t;This parameter is a character string that&n;&t;&t;&t;contains the name the kernel will use for this&n;&t;&t;&t;device (in /proc output, for instance).&n;&t;&t;&t;(default &quot;pf&quot;).&n;&n;            cluster     The driver will attempt to aggregate requests&n;                        for adjacent blocks into larger multi-block&n;                        clusters.  The maximum cluster size (in 512&n;                        byte sectors) is set with this parameter.&n;                        (default 64)&n;&n;            verbose     This parameter controls the amount of logging&n;                        that the driver will do.  Set it to 0 for&n;                        normal operation, 1 to see autoprobe progress&n;                        messages, or 2 to see additional debugging&n;                        output.  (default 0)&n; &n;&t;    nice        This parameter controls the driver&squot;s use of&n;&t;&t;&t;idle CPU time, at the expense of some speed.&n;&n;        If this driver is built into the kernel, you can use the&n;        following command line parameters, with the same values&n;        as the corresponding module parameters listed above:&n;&n;            pf.drive0&n;            pf.drive1&n;            pf.drive2&n;            pf.drive3&n;&t;    pf.cluster&n;            pf.nice&n;&n;        In addition, you can use the parameter pf.disable to disable&n;        the driver entirely.&n;&n;*/
multiline_comment|/* Changes:&n;&n;&t;1.01&t;GRG 1998.05.03  Changes for SMP.  Eliminate sti().&n;&t;&t;&t;&t;Fix for drives that don&squot;t clear STAT_ERR&n;&t;&t;&t;        until after next CDB delivered.&n;&t;&t;&t;&t;Small change in pf_completion to round&n;&t;&t;&t;&t;up transfer size.&n;&t;1.02    GRG 1998.06.16  Eliminated an Ugh&n;&t;1.03    GRG 1998.08.16  Use HZ in loop timings, extra debugging&n;&t;1.04    GRG 1998.09.24  Added jumbo support&n;&n;*/
DECL|macro|PF_VERSION
mdefine_line|#define PF_VERSION      &quot;1.04&quot;
DECL|macro|PF_MAJOR
mdefine_line|#define PF_MAJOR&t;47
DECL|macro|PF_NAME
mdefine_line|#define PF_NAME&t;&t;&quot;pf&quot;
DECL|macro|PF_UNITS
mdefine_line|#define PF_UNITS&t;4
multiline_comment|/* Here are things one can override from the insmod command.&n;   Most are autoprobed by paride unless set here.  Verbose is off&n;   by default.&n;&n;*/
DECL|variable|verbose
r_static
r_int
id|verbose
op_assign
l_int|0
suffix:semicolon
DECL|variable|major
r_static
r_int
id|major
op_assign
id|PF_MAJOR
suffix:semicolon
DECL|variable|name
r_static
r_char
op_star
id|name
op_assign
id|PF_NAME
suffix:semicolon
DECL|variable|cluster
r_static
r_int
id|cluster
op_assign
l_int|64
suffix:semicolon
DECL|variable|nice
r_static
r_int
id|nice
op_assign
l_int|0
suffix:semicolon
DECL|variable|disable
r_static
r_int
id|disable
op_assign
l_int|0
suffix:semicolon
DECL|variable|drive0
r_static
r_int
id|drive0
(braket
l_int|7
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|drive1
r_static
r_int
id|drive1
(braket
l_int|7
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|drive2
r_static
r_int
id|drive2
(braket
l_int|7
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|drive3
r_static
r_int
id|drive3
(braket
l_int|7
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|drives
r_static
r_int
(paren
op_star
id|drives
(braket
l_int|4
)braket
)paren
(braket
l_int|7
)braket
op_assign
(brace
op_amp
id|drive0
comma
op_amp
id|drive1
comma
op_amp
id|drive2
comma
op_amp
id|drive3
)brace
suffix:semicolon
DECL|variable|pf_drive_count
r_static
r_int
id|pf_drive_count
suffix:semicolon
DECL|enumerator|D_PRT
DECL|enumerator|D_PRO
DECL|enumerator|D_UNI
DECL|enumerator|D_MOD
DECL|enumerator|D_SLV
DECL|enumerator|D_LUN
DECL|enumerator|D_DLY
r_enum
(brace
id|D_PRT
comma
id|D_PRO
comma
id|D_UNI
comma
id|D_MOD
comma
id|D_SLV
comma
id|D_LUN
comma
id|D_DLY
)brace
suffix:semicolon
multiline_comment|/* end of parameters */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|variable|pf_spin_lock
r_static
id|spinlock_t
id|pf_spin_lock
suffix:semicolon
macro_line|#ifndef MODULE
macro_line|#include &quot;setup.h&quot;
DECL|variable|pf_stt
r_static
id|STT
id|pf_stt
(braket
l_int|7
)braket
op_assign
(brace
(brace
l_string|&quot;drive0&quot;
comma
l_int|7
comma
id|drive0
)brace
comma
(brace
l_string|&quot;drive1&quot;
comma
l_int|7
comma
id|drive1
)brace
comma
(brace
l_string|&quot;drive2&quot;
comma
l_int|7
comma
id|drive2
)brace
comma
(brace
l_string|&quot;drive3&quot;
comma
l_int|7
comma
id|drive3
)brace
comma
(brace
l_string|&quot;disable&quot;
comma
l_int|1
comma
op_amp
id|disable
)brace
comma
(brace
l_string|&quot;cluster&quot;
comma
l_int|1
comma
op_amp
id|cluster
)brace
comma
(brace
l_string|&quot;nice&quot;
comma
l_int|1
comma
op_amp
id|nice
)brace
)brace
suffix:semicolon
DECL|function|pf_setup
r_void
id|pf_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|generic_setup
c_func
(paren
id|pf_stt
comma
l_int|7
comma
id|str
)paren
suffix:semicolon
)brace
macro_line|#endif
id|module_param
c_func
(paren
id|verbose
comma
r_bool
comma
l_int|0644
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|major
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|name
comma
id|charp
comma
l_int|0
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|cluster
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|nice
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|drive0
comma
r_int
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|drive1
comma
r_int
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|drive2
comma
r_int
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|drive3
comma
r_int
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
macro_line|#include &quot;paride.h&quot;
macro_line|#include &quot;pseudo.h&quot;
multiline_comment|/* constants for faking geometry numbers */
DECL|macro|PF_FD_MAX
mdefine_line|#define PF_FD_MAX&t;8192&t;/* use FD geometry under this size */
DECL|macro|PF_FD_HDS
mdefine_line|#define PF_FD_HDS&t;2
DECL|macro|PF_FD_SPT
mdefine_line|#define PF_FD_SPT&t;18
DECL|macro|PF_HD_HDS
mdefine_line|#define PF_HD_HDS&t;64
DECL|macro|PF_HD_SPT
mdefine_line|#define PF_HD_SPT&t;32
DECL|macro|PF_MAX_RETRIES
mdefine_line|#define PF_MAX_RETRIES  5
DECL|macro|PF_TMO
mdefine_line|#define PF_TMO          800&t;/* interrupt timeout in jiffies */
DECL|macro|PF_SPIN_DEL
mdefine_line|#define PF_SPIN_DEL     50&t;/* spin delay in micro-seconds  */
DECL|macro|PF_SPIN
mdefine_line|#define PF_SPIN         (1000000*PF_TMO)/(HZ*PF_SPIN_DEL)
DECL|macro|STAT_ERR
mdefine_line|#define STAT_ERR        0x00001
DECL|macro|STAT_INDEX
mdefine_line|#define STAT_INDEX      0x00002
DECL|macro|STAT_ECC
mdefine_line|#define STAT_ECC        0x00004
DECL|macro|STAT_DRQ
mdefine_line|#define STAT_DRQ        0x00008
DECL|macro|STAT_SEEK
mdefine_line|#define STAT_SEEK       0x00010
DECL|macro|STAT_WRERR
mdefine_line|#define STAT_WRERR      0x00020
DECL|macro|STAT_READY
mdefine_line|#define STAT_READY      0x00040
DECL|macro|STAT_BUSY
mdefine_line|#define STAT_BUSY       0x00080
DECL|macro|ATAPI_REQ_SENSE
mdefine_line|#define ATAPI_REQ_SENSE&t;&t;0x03
DECL|macro|ATAPI_LOCK
mdefine_line|#define ATAPI_LOCK&t;&t;0x1e
DECL|macro|ATAPI_DOOR
mdefine_line|#define ATAPI_DOOR&t;&t;0x1b
DECL|macro|ATAPI_MODE_SENSE
mdefine_line|#define ATAPI_MODE_SENSE&t;0x5a
DECL|macro|ATAPI_CAPACITY
mdefine_line|#define ATAPI_CAPACITY&t;&t;0x25
DECL|macro|ATAPI_IDENTIFY
mdefine_line|#define ATAPI_IDENTIFY&t;&t;0x12
DECL|macro|ATAPI_READ_10
mdefine_line|#define ATAPI_READ_10&t;&t;0x28
DECL|macro|ATAPI_WRITE_10
mdefine_line|#define ATAPI_WRITE_10&t;&t;0x2a
r_static
r_int
id|pf_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_void
id|do_pf_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
suffix:semicolon
r_static
r_int
id|pf_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|pf_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|pf_detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_pf_read
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_pf_read_start
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_pf_write
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_pf_write_start
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_pf_read_drq
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_pf_write_done
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|PF_NM
mdefine_line|#define PF_NM           0
DECL|macro|PF_RO
mdefine_line|#define PF_RO           1
DECL|macro|PF_RW
mdefine_line|#define PF_RW           2
DECL|macro|PF_NAMELEN
mdefine_line|#define PF_NAMELEN      8
DECL|struct|pf_unit
r_struct
id|pf_unit
(brace
DECL|member|pia
r_struct
id|pi_adapter
id|pia
suffix:semicolon
multiline_comment|/* interface to paride layer */
DECL|member|pi
r_struct
id|pi_adapter
op_star
id|pi
suffix:semicolon
DECL|member|removable
r_int
id|removable
suffix:semicolon
multiline_comment|/* removable media device  ?  */
DECL|member|media_status
r_int
id|media_status
suffix:semicolon
multiline_comment|/* media present ?  WP ? */
DECL|member|drive
r_int
id|drive
suffix:semicolon
multiline_comment|/* drive */
DECL|member|lun
r_int
id|lun
suffix:semicolon
DECL|member|access
r_int
id|access
suffix:semicolon
multiline_comment|/* count of active opens ... */
DECL|member|present
r_int
id|present
suffix:semicolon
multiline_comment|/* device present ? */
DECL|member|name
r_char
id|name
(braket
id|PF_NAMELEN
)braket
suffix:semicolon
multiline_comment|/* pf0, pf1, ... */
DECL|member|disk
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|units
r_struct
id|pf_unit
id|units
(braket
id|PF_UNITS
)braket
suffix:semicolon
r_static
r_int
id|pf_identify
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
)paren
suffix:semicolon
r_static
r_void
id|pf_lock
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
comma
r_int
id|func
)paren
suffix:semicolon
r_static
r_void
id|pf_eject
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
)paren
suffix:semicolon
r_static
r_int
id|pf_check_media
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
suffix:semicolon
DECL|variable|pf_scratch
r_static
r_char
id|pf_scratch
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* scratch block buffer */
multiline_comment|/* the variables below are used mainly in the I/O request engine, which&n;   processes only one request at a time.&n;*/
DECL|variable|pf_retries
r_static
r_int
id|pf_retries
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* i/o error retry count */
DECL|variable|pf_busy
r_static
r_int
id|pf_busy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* request being processed ? */
DECL|variable|pf_req
r_static
r_struct
id|request
op_star
id|pf_req
suffix:semicolon
multiline_comment|/* current request */
DECL|variable|pf_block
r_static
r_int
id|pf_block
suffix:semicolon
multiline_comment|/* address of next requested block */
DECL|variable|pf_count
r_static
r_int
id|pf_count
suffix:semicolon
multiline_comment|/* number of blocks still to do */
DECL|variable|pf_run
r_static
r_int
id|pf_run
suffix:semicolon
multiline_comment|/* sectors in current cluster */
DECL|variable|pf_cmd
r_static
r_int
id|pf_cmd
suffix:semicolon
multiline_comment|/* current command READ/WRITE */
DECL|variable|pf_current
r_static
r_struct
id|pf_unit
op_star
id|pf_current
suffix:semicolon
multiline_comment|/* unit of current request */
DECL|variable|pf_mask
r_static
r_int
id|pf_mask
suffix:semicolon
multiline_comment|/* stopper for pseudo-int */
DECL|variable|pf_buf
r_static
r_char
op_star
id|pf_buf
suffix:semicolon
multiline_comment|/* buffer for request in progress */
multiline_comment|/* kernel glue structures */
DECL|variable|pf_fops
r_static
r_struct
id|block_device_operations
id|pf_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|pf_open
comma
dot
id|release
op_assign
id|pf_release
comma
dot
id|ioctl
op_assign
id|pf_ioctl
comma
dot
id|media_changed
op_assign
id|pf_check_media
comma
)brace
suffix:semicolon
DECL|function|pf_init_units
r_void
id|pf_init_units
c_func
(paren
r_void
)paren
(brace
r_struct
id|pf_unit
op_star
id|pf
suffix:semicolon
r_int
id|unit
suffix:semicolon
id|pf_drive_count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
comma
id|pf
op_assign
id|units
suffix:semicolon
id|unit
OL
id|PF_UNITS
suffix:semicolon
id|unit
op_increment
comma
id|pf
op_increment
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|alloc_disk
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk
)paren
r_continue
suffix:semicolon
id|pf-&gt;disk
op_assign
id|disk
suffix:semicolon
id|pf-&gt;pi
op_assign
op_amp
id|pf-&gt;pia
suffix:semicolon
id|pf-&gt;media_status
op_assign
id|PF_NM
suffix:semicolon
id|pf-&gt;drive
op_assign
(paren
op_star
id|drives
(braket
id|unit
)braket
)paren
(braket
id|D_SLV
)braket
suffix:semicolon
id|pf-&gt;lun
op_assign
(paren
op_star
id|drives
(braket
id|unit
)braket
)paren
(braket
id|D_LUN
)braket
suffix:semicolon
id|snprintf
c_func
(paren
id|pf-&gt;name
comma
id|PF_NAMELEN
comma
l_string|&quot;%s%d&quot;
comma
id|name
comma
id|unit
)paren
suffix:semicolon
id|disk-&gt;major
op_assign
id|major
suffix:semicolon
id|disk-&gt;first_minor
op_assign
id|unit
suffix:semicolon
id|strcpy
c_func
(paren
id|disk-&gt;disk_name
comma
id|pf-&gt;name
)paren
suffix:semicolon
id|disk-&gt;fops
op_assign
op_amp
id|pf_fops
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|drives
(braket
id|unit
)braket
)paren
(braket
id|D_PRT
)braket
)paren
id|pf_drive_count
op_increment
suffix:semicolon
)brace
)brace
DECL|function|pf_open
r_static
r_int
id|pf_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|pf_unit
op_star
id|pf
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
id|pf_identify
c_func
(paren
id|pf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf-&gt;media_status
op_eq
id|PF_NM
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pf-&gt;media_status
op_eq
id|PF_RO
)paren
op_logical_and
(paren
id|file-&gt;f_mode
op_amp
l_int|2
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
id|pf-&gt;access
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pf-&gt;removable
)paren
id|pf_lock
c_func
(paren
id|pf
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_ioctl
r_static
r_int
id|pf_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|pf_unit
op_star
id|pf
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
r_struct
id|hd_geometry
id|__user
op_star
id|geo
op_assign
(paren
r_struct
id|hd_geometry
id|__user
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|hd_geometry
id|g
suffix:semicolon
id|sector_t
id|capacity
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|CDROMEJECT
)paren
(brace
r_if
c_cond
(paren
id|pf-&gt;access
op_eq
l_int|1
)paren
(brace
id|pf_eject
c_func
(paren
id|pf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_ne
id|HDIO_GETGEO
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|capacity
op_assign
id|get_capacity
c_func
(paren
id|pf-&gt;disk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|capacity
OL
id|PF_FD_MAX
)paren
(brace
id|g.cylinders
op_assign
id|sector_div
c_func
(paren
id|capacity
comma
id|PF_FD_HDS
op_star
id|PF_FD_SPT
)paren
suffix:semicolon
id|g.heads
op_assign
id|PF_FD_HDS
suffix:semicolon
id|g.sectors
op_assign
id|PF_FD_SPT
suffix:semicolon
)brace
r_else
(brace
id|g.cylinders
op_assign
id|sector_div
c_func
(paren
id|capacity
comma
id|PF_HD_HDS
op_star
id|PF_HD_SPT
)paren
suffix:semicolon
id|g.heads
op_assign
id|PF_HD_HDS
suffix:semicolon
id|g.sectors
op_assign
id|PF_HD_SPT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|geo
comma
op_amp
id|g
comma
r_sizeof
(paren
id|g
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_release
r_static
r_int
id|pf_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|pf_unit
op_star
id|pf
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|pf-&gt;access
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pf-&gt;access
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pf-&gt;access
op_logical_and
id|pf-&gt;removable
)paren
id|pf_lock
c_func
(paren
id|pf
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_check_media
r_static
r_int
id|pf_check_media
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|status_reg
r_static
r_inline
r_int
id|status_reg
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
)paren
(brace
r_return
id|pi_read_regr
c_func
(paren
id|pf-&gt;pi
comma
l_int|1
comma
l_int|6
)paren
suffix:semicolon
)brace
DECL|function|read_reg
r_static
r_inline
r_int
id|read_reg
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
comma
r_int
id|reg
)paren
(brace
r_return
id|pi_read_regr
c_func
(paren
id|pf-&gt;pi
comma
l_int|0
comma
id|reg
)paren
suffix:semicolon
)brace
DECL|function|write_reg
r_static
r_inline
r_void
id|write_reg
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
comma
r_int
id|reg
comma
r_int
id|val
)paren
(brace
id|pi_write_regr
c_func
(paren
id|pf-&gt;pi
comma
l_int|0
comma
id|reg
comma
id|val
)paren
suffix:semicolon
)brace
DECL|function|pf_wait
r_static
r_int
id|pf_wait
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
comma
r_int
id|go
comma
r_int
id|stop
comma
r_char
op_star
id|fun
comma
r_char
op_star
id|msg
)paren
(brace
r_int
id|j
comma
id|r
comma
id|e
comma
id|s
comma
id|p
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
(paren
id|r
op_assign
id|status_reg
c_func
(paren
id|pf
)paren
)paren
op_amp
id|go
)paren
op_logical_or
(paren
id|stop
op_logical_and
(paren
op_logical_neg
(paren
id|r
op_amp
id|stop
)paren
)paren
)paren
)paren
op_logical_and
(paren
id|j
op_increment
OL
id|PF_SPIN
)paren
)paren
id|udelay
c_func
(paren
id|PF_SPIN_DEL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
(paren
id|STAT_ERR
op_amp
id|stop
)paren
)paren
op_logical_or
(paren
id|j
op_ge
id|PF_SPIN
)paren
)paren
(brace
id|s
op_assign
id|read_reg
c_func
(paren
id|pf
comma
l_int|7
)paren
suffix:semicolon
id|e
op_assign
id|read_reg
c_func
(paren
id|pf
comma
l_int|1
)paren
suffix:semicolon
id|p
op_assign
id|read_reg
c_func
(paren
id|pf
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
op_ge
id|PF_SPIN
)paren
id|e
op_or_assign
l_int|0x100
suffix:semicolon
r_if
c_cond
(paren
id|fun
)paren
id|printk
c_func
(paren
l_string|&quot;%s: %s %s: alt=0x%x stat=0x%x err=0x%x&quot;
l_string|&quot; loop=%d phase=%d&bslash;n&quot;
comma
id|pf-&gt;name
comma
id|fun
comma
id|msg
comma
id|r
comma
id|s
comma
id|e
comma
id|j
comma
id|p
)paren
suffix:semicolon
r_return
(paren
id|e
op_lshift
l_int|8
)paren
op_plus
id|s
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_command
r_static
r_int
id|pf_command
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
comma
r_char
op_star
id|cmd
comma
r_int
id|dlen
comma
r_char
op_star
id|fun
)paren
(brace
id|pi_connect
c_func
(paren
id|pf-&gt;pi
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|pf
comma
l_int|6
comma
l_int|0xa0
op_plus
l_int|0x10
op_star
id|pf-&gt;drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_wait
c_func
(paren
id|pf
comma
id|STAT_BUSY
op_or
id|STAT_DRQ
comma
l_int|0
comma
id|fun
comma
l_string|&quot;before command&quot;
)paren
)paren
(brace
id|pi_disconnect
c_func
(paren
id|pf-&gt;pi
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|write_reg
c_func
(paren
id|pf
comma
l_int|4
comma
id|dlen
op_mod
l_int|256
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|pf
comma
l_int|5
comma
id|dlen
op_div
l_int|256
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|pf
comma
l_int|7
comma
l_int|0xa0
)paren
suffix:semicolon
multiline_comment|/* ATAPI packet command */
r_if
c_cond
(paren
id|pf_wait
c_func
(paren
id|pf
comma
id|STAT_BUSY
comma
id|STAT_DRQ
comma
id|fun
comma
l_string|&quot;command DRQ&quot;
)paren
)paren
(brace
id|pi_disconnect
c_func
(paren
id|pf-&gt;pi
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_reg
c_func
(paren
id|pf
comma
l_int|2
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s: command phase error&bslash;n&quot;
comma
id|pf-&gt;name
comma
id|fun
)paren
suffix:semicolon
id|pi_disconnect
c_func
(paren
id|pf-&gt;pi
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pi_write_block
c_func
(paren
id|pf-&gt;pi
comma
id|cmd
comma
l_int|12
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_completion
r_static
r_int
id|pf_completion
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
comma
r_char
op_star
id|buf
comma
r_char
op_star
id|fun
)paren
(brace
r_int
id|r
comma
id|s
comma
id|n
suffix:semicolon
id|r
op_assign
id|pf_wait
c_func
(paren
id|pf
comma
id|STAT_BUSY
comma
id|STAT_DRQ
op_or
id|STAT_READY
op_or
id|STAT_ERR
comma
id|fun
comma
l_string|&quot;completion&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|read_reg
c_func
(paren
id|pf
comma
l_int|2
)paren
op_amp
l_int|2
)paren
op_logical_and
(paren
id|read_reg
c_func
(paren
id|pf
comma
l_int|7
)paren
op_amp
id|STAT_DRQ
)paren
)paren
(brace
id|n
op_assign
(paren
(paren
(paren
id|read_reg
c_func
(paren
id|pf
comma
l_int|4
)paren
op_plus
l_int|256
op_star
id|read_reg
c_func
(paren
id|pf
comma
l_int|5
)paren
)paren
op_plus
l_int|3
)paren
op_amp
l_int|0xfffc
)paren
suffix:semicolon
id|pi_read_block
c_func
(paren
id|pf-&gt;pi
comma
id|buf
comma
id|n
)paren
suffix:semicolon
)brace
id|s
op_assign
id|pf_wait
c_func
(paren
id|pf
comma
id|STAT_BUSY
comma
id|STAT_READY
op_or
id|STAT_ERR
comma
id|fun
comma
l_string|&quot;data done&quot;
)paren
suffix:semicolon
id|pi_disconnect
c_func
(paren
id|pf-&gt;pi
)paren
suffix:semicolon
r_return
(paren
id|r
ques
c_cond
id|r
suffix:colon
id|s
)paren
suffix:semicolon
)brace
DECL|function|pf_req_sense
r_static
r_void
id|pf_req_sense
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
comma
r_int
id|quiet
)paren
(brace
r_char
id|rs_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_REQ_SENSE
comma
id|pf-&gt;lun
op_lshift
l_int|5
comma
l_int|0
comma
l_int|0
comma
l_int|16
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|buf
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|r
suffix:semicolon
id|r
op_assign
id|pf_command
c_func
(paren
id|pf
comma
id|rs_cmd
comma
l_int|16
comma
l_string|&quot;Request sense&quot;
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
id|pf_completion
c_func
(paren
id|pf
comma
id|buf
comma
l_string|&quot;Request sense&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|r
)paren
op_logical_and
(paren
op_logical_neg
id|quiet
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Sense key: %x, ASC: %x, ASQ: %x&bslash;n&quot;
comma
id|pf-&gt;name
comma
id|buf
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
id|buf
(braket
l_int|12
)braket
comma
id|buf
(braket
l_int|13
)braket
)paren
suffix:semicolon
)brace
DECL|function|pf_atapi
r_static
r_int
id|pf_atapi
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
comma
r_char
op_star
id|cmd
comma
r_int
id|dlen
comma
r_char
op_star
id|buf
comma
r_char
op_star
id|fun
)paren
(brace
r_int
id|r
suffix:semicolon
id|r
op_assign
id|pf_command
c_func
(paren
id|pf
comma
id|cmd
comma
id|dlen
comma
id|fun
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
id|r
op_assign
id|pf_completion
c_func
(paren
id|pf
comma
id|buf
comma
id|fun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|pf_req_sense
c_func
(paren
id|pf
comma
op_logical_neg
id|fun
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|macro|DBMSG
mdefine_line|#define DBMSG(msg)      ((verbose&gt;1)?(msg):NULL)
DECL|function|pf_lock
r_static
r_void
id|pf_lock
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
comma
r_int
id|func
)paren
(brace
r_char
id|lo_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_LOCK
comma
id|pf-&gt;lun
op_lshift
l_int|5
comma
l_int|0
comma
l_int|0
comma
id|func
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|pf_atapi
c_func
(paren
id|pf
comma
id|lo_cmd
comma
l_int|0
comma
id|pf_scratch
comma
id|func
ques
c_cond
l_string|&quot;unlock&quot;
suffix:colon
l_string|&quot;lock&quot;
)paren
suffix:semicolon
)brace
DECL|function|pf_eject
r_static
r_void
id|pf_eject
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
)paren
(brace
r_char
id|ej_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_DOOR
comma
id|pf-&gt;lun
op_lshift
l_int|5
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|pf_lock
c_func
(paren
id|pf
comma
l_int|0
)paren
suffix:semicolon
id|pf_atapi
c_func
(paren
id|pf
comma
id|ej_cmd
comma
l_int|0
comma
id|pf_scratch
comma
l_string|&quot;eject&quot;
)paren
suffix:semicolon
)brace
DECL|macro|PF_RESET_TMO
mdefine_line|#define PF_RESET_TMO   30&t;/* in tenths of a second */
DECL|function|pf_sleep
r_static
r_void
id|pf_sleep
c_func
(paren
r_int
id|cs
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|cs
)paren
suffix:semicolon
)brace
multiline_comment|/* the ATAPI standard actually specifies the contents of all 7 registers&n;   after a reset, but the specification is ambiguous concerning the last&n;   two bytes, and different drives interpret the standard differently.&n; */
DECL|function|pf_reset
r_static
r_int
id|pf_reset
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
)paren
(brace
r_int
id|i
comma
id|k
comma
id|flg
suffix:semicolon
r_int
id|expect
(braket
l_int|5
)braket
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0x14
comma
l_int|0xeb
)brace
suffix:semicolon
id|pi_connect
c_func
(paren
id|pf-&gt;pi
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|pf
comma
l_int|6
comma
l_int|0xa0
op_plus
l_int|0x10
op_star
id|pf-&gt;drive
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|pf
comma
l_int|7
comma
l_int|8
)paren
suffix:semicolon
id|pf_sleep
c_func
(paren
l_int|20
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|k
op_increment
OL
id|PF_RESET_TMO
)paren
op_logical_and
(paren
id|status_reg
c_func
(paren
id|pf
)paren
op_amp
id|STAT_BUSY
)paren
)paren
id|pf_sleep
c_func
(paren
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
id|flg
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|flg
op_and_assign
(paren
id|read_reg
c_func
(paren
id|pf
comma
id|i
op_plus
l_int|1
)paren
op_eq
id|expect
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Reset (%d) signature = &quot;
comma
id|pf-&gt;name
comma
id|k
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%3x&quot;
comma
id|read_reg
c_func
(paren
id|pf
comma
id|i
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flg
)paren
id|printk
c_func
(paren
l_string|&quot; (incorrect)&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|pi_disconnect
c_func
(paren
id|pf-&gt;pi
)paren
suffix:semicolon
r_return
id|flg
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|pf_mode_sense
r_static
r_void
id|pf_mode_sense
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
)paren
(brace
r_char
id|ms_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_MODE_SENSE
comma
id|pf-&gt;lun
op_lshift
l_int|5
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|8
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
id|pf_atapi
c_func
(paren
id|pf
comma
id|ms_cmd
comma
l_int|8
comma
id|buf
comma
id|DBMSG
c_func
(paren
l_string|&quot;mode sense&quot;
)paren
)paren
suffix:semicolon
id|pf-&gt;media_status
op_assign
id|PF_RW
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
l_int|3
)braket
op_amp
l_int|0x80
)paren
id|pf-&gt;media_status
op_assign
id|PF_RO
suffix:semicolon
)brace
DECL|function|xs
r_static
r_void
id|xs
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|targ
comma
r_int
id|offs
comma
r_int
id|len
)paren
(brace
r_int
id|j
comma
id|k
comma
id|l
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|l
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|len
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
(paren
id|buf
(braket
id|k
op_plus
id|offs
)braket
op_ne
l_int|0x20
)paren
op_logical_or
(paren
id|buf
(braket
id|k
op_plus
id|offs
)braket
op_ne
id|l
)paren
)paren
id|l
op_assign
id|targ
(braket
id|j
op_increment
)braket
op_assign
id|buf
(braket
id|k
op_plus
id|offs
)braket
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
l_int|0x20
)paren
id|j
op_decrement
suffix:semicolon
id|targ
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|xl
r_static
r_int
id|xl
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|offs
)paren
(brace
r_int
id|v
comma
id|k
suffix:semicolon
id|v
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|4
suffix:semicolon
id|k
op_increment
)paren
id|v
op_assign
id|v
op_star
l_int|256
op_plus
(paren
id|buf
(braket
id|k
op_plus
id|offs
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|v
suffix:semicolon
)brace
DECL|function|pf_get_capacity
r_static
r_void
id|pf_get_capacity
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
)paren
(brace
r_char
id|rc_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_CAPACITY
comma
id|pf-&gt;lun
op_lshift
l_int|5
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|bs
suffix:semicolon
r_if
c_cond
(paren
id|pf_atapi
c_func
(paren
id|pf
comma
id|rc_cmd
comma
l_int|8
comma
id|buf
comma
id|DBMSG
c_func
(paren
l_string|&quot;get capacity&quot;
)paren
)paren
)paren
(brace
id|pf-&gt;media_status
op_assign
id|PF_NM
suffix:semicolon
r_return
suffix:semicolon
)brace
id|set_capacity
c_func
(paren
id|pf-&gt;disk
comma
id|xl
c_func
(paren
id|buf
comma
l_int|0
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|bs
op_assign
id|xl
c_func
(paren
id|buf
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bs
op_ne
l_int|512
)paren
(brace
id|set_capacity
c_func
(paren
id|pf-&gt;disk
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Drive %d, LUN %d,&quot;
l_string|&quot; unsupported block size %d&bslash;n&quot;
comma
id|pf-&gt;name
comma
id|pf-&gt;drive
comma
id|pf-&gt;lun
comma
id|bs
)paren
suffix:semicolon
)brace
)brace
DECL|function|pf_identify
r_static
r_int
id|pf_identify
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
)paren
(brace
r_int
id|dt
comma
id|s
suffix:semicolon
r_char
op_star
id|ms
(braket
l_int|2
)braket
op_assign
(brace
l_string|&quot;master&quot;
comma
l_string|&quot;slave&quot;
)brace
suffix:semicolon
r_char
id|mf
(braket
l_int|10
)braket
comma
id|id
(braket
l_int|18
)braket
suffix:semicolon
r_char
id|id_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_IDENTIFY
comma
id|pf-&gt;lun
op_lshift
l_int|5
comma
l_int|0
comma
l_int|0
comma
l_int|36
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|buf
(braket
l_int|36
)braket
suffix:semicolon
id|s
op_assign
id|pf_atapi
c_func
(paren
id|pf
comma
id|id_cmd
comma
l_int|36
comma
id|buf
comma
l_string|&quot;identify&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|dt
op_assign
id|buf
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dt
op_ne
l_int|0
)paren
op_logical_and
(paren
id|dt
op_ne
l_int|7
)paren
)paren
(brace
r_if
c_cond
(paren
id|verbose
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Drive %d, LUN %d, unsupported type %d&bslash;n&quot;
comma
id|pf-&gt;name
comma
id|pf-&gt;drive
comma
id|pf-&gt;lun
comma
id|dt
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|xs
c_func
(paren
id|buf
comma
id|mf
comma
l_int|8
comma
l_int|8
)paren
suffix:semicolon
id|xs
c_func
(paren
id|buf
comma
id|id
comma
l_int|16
comma
l_int|16
)paren
suffix:semicolon
id|pf-&gt;removable
op_assign
(paren
id|buf
(braket
l_int|1
)braket
op_amp
l_int|0x80
)paren
suffix:semicolon
id|pf_mode_sense
c_func
(paren
id|pf
)paren
suffix:semicolon
id|pf_mode_sense
c_func
(paren
id|pf
)paren
suffix:semicolon
id|pf_mode_sense
c_func
(paren
id|pf
)paren
suffix:semicolon
id|pf_get_capacity
c_func
(paren
id|pf
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s %s, %s LUN %d, type %d&quot;
comma
id|pf-&gt;name
comma
id|mf
comma
id|id
comma
id|ms
(braket
id|pf-&gt;drive
)braket
comma
id|pf-&gt;lun
comma
id|dt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf-&gt;removable
)paren
id|printk
c_func
(paren
l_string|&quot;, removable&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf-&gt;media_status
op_eq
id|PF_NM
)paren
id|printk
c_func
(paren
l_string|&quot;, no media&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|pf-&gt;media_status
op_eq
id|PF_RO
)paren
id|printk
c_func
(paren
l_string|&quot;, RO&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, %llu blocks&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|get_capacity
c_func
(paren
id|pf-&gt;disk
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;returns  0, with id set if drive is detected&n;&t;        -1, if drive detection failed&n;*/
DECL|function|pf_probe
r_static
r_int
id|pf_probe
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
)paren
(brace
r_if
c_cond
(paren
id|pf-&gt;drive
op_eq
op_minus
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|pf-&gt;drive
op_assign
l_int|0
suffix:semicolon
id|pf-&gt;drive
op_le
l_int|1
suffix:semicolon
id|pf-&gt;drive
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|pf_reset
c_func
(paren
id|pf
)paren
)paren
(brace
r_if
c_cond
(paren
id|pf-&gt;lun
op_ne
op_minus
l_int|1
)paren
r_return
id|pf_identify
c_func
(paren
id|pf
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
id|pf-&gt;lun
op_assign
l_int|0
suffix:semicolon
id|pf-&gt;lun
OL
l_int|8
suffix:semicolon
id|pf-&gt;lun
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|pf_identify
c_func
(paren
id|pf
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|pf_reset
c_func
(paren
id|pf
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pf-&gt;lun
op_ne
op_minus
l_int|1
)paren
r_return
id|pf_identify
c_func
(paren
id|pf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pf-&gt;lun
op_assign
l_int|0
suffix:semicolon
id|pf-&gt;lun
OL
l_int|8
suffix:semicolon
id|pf-&gt;lun
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|pf_identify
c_func
(paren
id|pf
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|pf_detect
r_static
r_int
id|pf_detect
c_func
(paren
r_void
)paren
(brace
r_struct
id|pf_unit
op_star
id|pf
op_assign
id|units
suffix:semicolon
r_int
id|k
comma
id|unit
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s version %s, major %d, cluster %d, nice %d&bslash;n&quot;
comma
id|name
comma
id|name
comma
id|PF_VERSION
comma
id|major
comma
id|cluster
comma
id|nice
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pf_drive_count
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pi_init
c_func
(paren
id|pf-&gt;pi
comma
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|pf_scratch
comma
id|PI_PF
comma
id|verbose
comma
id|pf-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pf_probe
c_func
(paren
id|pf
)paren
op_logical_and
id|pf-&gt;disk
)paren
(brace
id|pf-&gt;present
op_assign
l_int|1
suffix:semicolon
id|k
op_increment
suffix:semicolon
)brace
r_else
id|pi_release
c_func
(paren
id|pf-&gt;pi
)paren
suffix:semicolon
)brace
)brace
r_else
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PF_UNITS
suffix:semicolon
id|unit
op_increment
comma
id|pf
op_increment
)paren
(brace
r_int
op_star
id|conf
op_assign
op_star
id|drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|conf
(braket
id|D_PRT
)braket
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pi_init
c_func
(paren
id|pf-&gt;pi
comma
l_int|0
comma
id|conf
(braket
id|D_PRT
)braket
comma
id|conf
(braket
id|D_MOD
)braket
comma
id|conf
(braket
id|D_UNI
)braket
comma
id|conf
(braket
id|D_PRO
)braket
comma
id|conf
(braket
id|D_DLY
)braket
comma
id|pf_scratch
comma
id|PI_PF
comma
id|verbose
comma
id|pf-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pf_probe
c_func
(paren
id|pf
)paren
op_logical_and
id|pf-&gt;disk
)paren
(brace
id|pf-&gt;present
op_assign
l_int|1
suffix:semicolon
id|k
op_increment
suffix:semicolon
)brace
r_else
id|pi_release
c_func
(paren
id|pf-&gt;pi
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|k
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: No ATAPI disk detected&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pf
op_assign
id|units
comma
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PF_UNITS
suffix:semicolon
id|pf
op_increment
comma
id|unit
op_increment
)paren
id|put_disk
c_func
(paren
id|pf-&gt;disk
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* The i/o request engine */
DECL|function|pf_start
r_static
r_int
id|pf_start
c_func
(paren
r_struct
id|pf_unit
op_star
id|pf
comma
r_int
id|cmd
comma
r_int
id|b
comma
r_int
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|io_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|cmd
comma
id|pf-&gt;lun
op_lshift
l_int|5
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|io_cmd
(braket
l_int|5
op_minus
id|i
)braket
op_assign
id|b
op_amp
l_int|0xff
suffix:semicolon
id|b
op_assign
id|b
op_rshift
l_int|8
suffix:semicolon
)brace
id|io_cmd
(braket
l_int|8
)braket
op_assign
id|c
op_amp
l_int|0xff
suffix:semicolon
id|io_cmd
(braket
l_int|7
)braket
op_assign
(paren
id|c
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|i
op_assign
id|pf_command
c_func
(paren
id|pf
comma
id|io_cmd
comma
id|c
op_star
l_int|512
comma
l_string|&quot;start i/o&quot;
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|pf_ready
r_static
r_int
id|pf_ready
c_func
(paren
r_void
)paren
(brace
r_return
(paren
(paren
(paren
id|status_reg
c_func
(paren
id|pf_current
)paren
op_amp
(paren
id|STAT_BUSY
op_or
id|pf_mask
)paren
)paren
op_eq
id|pf_mask
)paren
)paren
suffix:semicolon
)brace
DECL|variable|pf_queue
r_static
r_struct
id|request_queue
op_star
id|pf_queue
suffix:semicolon
DECL|function|do_pf_request
r_static
r_void
id|do_pf_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_if
c_cond
(paren
id|pf_busy
)paren
r_return
suffix:semicolon
id|repeat
suffix:colon
id|pf_req
op_assign
id|elv_next_request
c_func
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pf_req
)paren
r_return
suffix:semicolon
id|pf_current
op_assign
id|pf_req-&gt;rq_disk-&gt;private_data
suffix:semicolon
id|pf_block
op_assign
id|pf_req-&gt;sector
suffix:semicolon
id|pf_run
op_assign
id|pf_req-&gt;nr_sectors
suffix:semicolon
id|pf_count
op_assign
id|pf_req-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|pf_block
op_plus
id|pf_count
OG
id|get_capacity
c_func
(paren
id|pf_req-&gt;rq_disk
)paren
)paren
(brace
id|end_request
c_func
(paren
id|pf_req
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|pf_cmd
op_assign
id|rq_data_dir
c_func
(paren
id|pf_req
)paren
suffix:semicolon
id|pf_buf
op_assign
id|pf_req-&gt;buffer
suffix:semicolon
id|pf_retries
op_assign
l_int|0
suffix:semicolon
id|pf_busy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pf_cmd
op_eq
id|READ
)paren
id|pi_do_claimed
c_func
(paren
id|pf_current-&gt;pi
comma
id|do_pf_read
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pf_cmd
op_eq
id|WRITE
)paren
id|pi_do_claimed
c_func
(paren
id|pf_current-&gt;pi
comma
id|do_pf_write
)paren
suffix:semicolon
r_else
(brace
id|pf_busy
op_assign
l_int|0
suffix:semicolon
id|end_request
c_func
(paren
id|pf_req
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
DECL|function|pf_next_buf
r_static
r_int
id|pf_next_buf
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|saved_flags
suffix:semicolon
id|pf_count
op_decrement
suffix:semicolon
id|pf_run
op_decrement
suffix:semicolon
id|pf_buf
op_add_assign
l_int|512
suffix:semicolon
id|pf_block
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pf_run
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pf_count
)paren
r_return
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pf_spin_lock
comma
id|saved_flags
)paren
suffix:semicolon
id|end_request
c_func
(paren
id|pf_req
comma
l_int|1
)paren
suffix:semicolon
id|pf_count
op_assign
id|pf_req-&gt;current_nr_sectors
suffix:semicolon
id|pf_buf
op_assign
id|pf_req-&gt;buffer
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pf_spin_lock
comma
id|saved_flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|next_request
r_static
r_inline
r_void
id|next_request
c_func
(paren
r_int
id|success
)paren
(brace
r_int
r_int
id|saved_flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pf_spin_lock
comma
id|saved_flags
)paren
suffix:semicolon
id|end_request
c_func
(paren
id|pf_req
comma
id|success
)paren
suffix:semicolon
id|pf_busy
op_assign
l_int|0
suffix:semicolon
id|do_pf_request
c_func
(paren
id|pf_queue
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pf_spin_lock
comma
id|saved_flags
)paren
suffix:semicolon
)brace
multiline_comment|/* detach from the calling context - in case the spinlock is held */
DECL|function|do_pf_read
r_static
r_void
id|do_pf_read
c_func
(paren
r_void
)paren
(brace
id|ps_set_intr
c_func
(paren
id|do_pf_read_start
comma
l_int|NULL
comma
l_int|0
comma
id|nice
)paren
suffix:semicolon
)brace
DECL|function|do_pf_read_start
r_static
r_void
id|do_pf_read_start
c_func
(paren
r_void
)paren
(brace
id|pf_busy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pf_start
c_func
(paren
id|pf_current
comma
id|ATAPI_READ_10
comma
id|pf_block
comma
id|pf_run
)paren
)paren
(brace
id|pi_disconnect
c_func
(paren
id|pf_current-&gt;pi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_retries
OL
id|PF_MAX_RETRIES
)paren
(brace
id|pf_retries
op_increment
suffix:semicolon
id|pi_do_claimed
c_func
(paren
id|pf_current-&gt;pi
comma
id|do_pf_read_start
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|next_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pf_mask
op_assign
id|STAT_DRQ
suffix:semicolon
id|ps_set_intr
c_func
(paren
id|do_pf_read_drq
comma
id|pf_ready
comma
id|PF_TMO
comma
id|nice
)paren
suffix:semicolon
)brace
DECL|function|do_pf_read_drq
r_static
r_void
id|do_pf_read_drq
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|pf_wait
c_func
(paren
id|pf_current
comma
id|STAT_BUSY
comma
id|STAT_DRQ
op_or
id|STAT_ERR
comma
l_string|&quot;read block&quot;
comma
l_string|&quot;completion&quot;
)paren
op_amp
id|STAT_ERR
)paren
(brace
id|pi_disconnect
c_func
(paren
id|pf_current-&gt;pi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_retries
OL
id|PF_MAX_RETRIES
)paren
(brace
id|pf_req_sense
c_func
(paren
id|pf_current
comma
l_int|0
)paren
suffix:semicolon
id|pf_retries
op_increment
suffix:semicolon
id|pi_do_claimed
c_func
(paren
id|pf_current-&gt;pi
comma
id|do_pf_read_start
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|next_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pi_read_block
c_func
(paren
id|pf_current-&gt;pi
comma
id|pf_buf
comma
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_next_buf
c_func
(paren
)paren
)paren
r_break
suffix:semicolon
)brace
id|pi_disconnect
c_func
(paren
id|pf_current-&gt;pi
)paren
suffix:semicolon
id|next_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|do_pf_write
r_static
r_void
id|do_pf_write
c_func
(paren
r_void
)paren
(brace
id|ps_set_intr
c_func
(paren
id|do_pf_write_start
comma
l_int|NULL
comma
l_int|0
comma
id|nice
)paren
suffix:semicolon
)brace
DECL|function|do_pf_write_start
r_static
r_void
id|do_pf_write_start
c_func
(paren
r_void
)paren
(brace
id|pf_busy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pf_start
c_func
(paren
id|pf_current
comma
id|ATAPI_WRITE_10
comma
id|pf_block
comma
id|pf_run
)paren
)paren
(brace
id|pi_disconnect
c_func
(paren
id|pf_current-&gt;pi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_retries
OL
id|PF_MAX_RETRIES
)paren
(brace
id|pf_retries
op_increment
suffix:semicolon
id|pi_do_claimed
c_func
(paren
id|pf_current-&gt;pi
comma
id|do_pf_write_start
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|next_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|pf_wait
c_func
(paren
id|pf_current
comma
id|STAT_BUSY
comma
id|STAT_DRQ
op_or
id|STAT_ERR
comma
l_string|&quot;write block&quot;
comma
l_string|&quot;data wait&quot;
)paren
op_amp
id|STAT_ERR
)paren
(brace
id|pi_disconnect
c_func
(paren
id|pf_current-&gt;pi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_retries
OL
id|PF_MAX_RETRIES
)paren
(brace
id|pf_retries
op_increment
suffix:semicolon
id|pi_do_claimed
c_func
(paren
id|pf_current-&gt;pi
comma
id|do_pf_write_start
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|next_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pi_write_block
c_func
(paren
id|pf_current-&gt;pi
comma
id|pf_buf
comma
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_next_buf
c_func
(paren
)paren
)paren
r_break
suffix:semicolon
)brace
id|pf_mask
op_assign
l_int|0
suffix:semicolon
id|ps_set_intr
c_func
(paren
id|do_pf_write_done
comma
id|pf_ready
comma
id|PF_TMO
comma
id|nice
)paren
suffix:semicolon
)brace
DECL|function|do_pf_write_done
r_static
r_void
id|do_pf_write_done
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|pf_wait
c_func
(paren
id|pf_current
comma
id|STAT_BUSY
comma
l_int|0
comma
l_string|&quot;write block&quot;
comma
l_string|&quot;done&quot;
)paren
op_amp
id|STAT_ERR
)paren
(brace
id|pi_disconnect
c_func
(paren
id|pf_current-&gt;pi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_retries
OL
id|PF_MAX_RETRIES
)paren
(brace
id|pf_retries
op_increment
suffix:semicolon
id|pi_do_claimed
c_func
(paren
id|pf_current-&gt;pi
comma
id|do_pf_write_start
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|next_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pi_disconnect
c_func
(paren
id|pf_current-&gt;pi
)paren
suffix:semicolon
id|next_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pf_init
r_static
r_int
id|__init
id|pf_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* preliminary initialisation */
r_struct
id|pf_unit
op_star
id|pf
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_if
c_cond
(paren
id|disable
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|pf_init_units
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_detect
c_func
(paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|pf_busy
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|major
comma
id|name
)paren
)paren
(brace
r_for
c_loop
(paren
id|pf
op_assign
id|units
comma
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PF_UNITS
suffix:semicolon
id|pf
op_increment
comma
id|unit
op_increment
)paren
id|put_disk
c_func
(paren
id|pf-&gt;disk
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pf_queue
op_assign
id|blk_init_queue
c_func
(paren
id|do_pf_request
comma
op_amp
id|pf_spin_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pf_queue
)paren
(brace
id|unregister_blkdev
c_func
(paren
id|major
comma
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pf
op_assign
id|units
comma
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PF_UNITS
suffix:semicolon
id|pf
op_increment
comma
id|unit
op_increment
)paren
id|put_disk
c_func
(paren
id|pf-&gt;disk
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|blk_queue_max_phys_segments
c_func
(paren
id|pf_queue
comma
id|cluster
)paren
suffix:semicolon
id|blk_queue_max_hw_segments
c_func
(paren
id|pf_queue
comma
id|cluster
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pf
op_assign
id|units
comma
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PF_UNITS
suffix:semicolon
id|pf
op_increment
comma
id|unit
op_increment
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|pf-&gt;disk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pf-&gt;present
)paren
r_continue
suffix:semicolon
id|disk-&gt;private_data
op_assign
id|pf
suffix:semicolon
id|disk-&gt;queue
op_assign
id|pf_queue
suffix:semicolon
id|add_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_exit
r_static
r_void
id|__exit
id|pf_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|pf_unit
op_star
id|pf
suffix:semicolon
r_int
id|unit
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|major
comma
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pf
op_assign
id|units
comma
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PF_UNITS
suffix:semicolon
id|pf
op_increment
comma
id|unit
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pf-&gt;present
)paren
r_continue
suffix:semicolon
id|del_gendisk
c_func
(paren
id|pf-&gt;disk
)paren
suffix:semicolon
id|put_disk
c_func
(paren
id|pf-&gt;disk
)paren
suffix:semicolon
id|pi_release
c_func
(paren
id|pf-&gt;pi
)paren
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
id|pf_queue
)paren
suffix:semicolon
)brace
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|module_init
c_func
(paren
id|pf_init
)paren
id|module_exit
c_func
(paren
id|pf_exit
)paren
eof
