multiline_comment|/*&n; * Copyright (C) 2000 Jens Axboe &lt;axboe@suse.de&gt;&n; * Copyright (C) 2001-2004 Peter Osterlund &lt;petero2@telia.com&gt;&n; *&n; * May be copied or modified under the terms of the GNU General Public&n; * License.  See linux/COPYING for more information.&n; *&n; * Packet writing layer for ATAPI and SCSI CD-R, CD-RW, DVD-R, and&n; * DVD-RW devices (aka an exercise in block layer masturbation)&n; *&n; *&n; * TODO: (circa order of when I will fix it)&n; * - Only able to write on CD-RW media right now.&n; * - check host application code on media and set it in write page&n; * - interface for UDF &lt;-&gt; packet to negotiate a new location when a write&n; *   fails.&n; * - handle OPC, especially for -RW media&n; *&n; * Theory of operation:&n; *&n; * We use a custom make_request_fn function that forwards reads directly to&n; * the underlying CD device. Write requests are either attached directly to&n; * a live packet_data object, or simply stored sequentially in a list for&n; * later processing by the kcdrwd kernel thread. This driver doesn&squot;t use&n; * any elevator functionally as defined by the elevator_s struct, but the&n; * underlying CD device uses a standard elevator.&n; *&n; * This strategy makes it possible to do very late merging of IO requests.&n; * A new bio sent to pkt_make_request can be merged with a live packet_data&n; * object even if the object is in the data gathering state.&n; *&n; *************************************************************************/
DECL|macro|VERSION_CODE
mdefine_line|#define VERSION_CODE&t;&quot;v0.2.0a 2004-07-14 Jens Axboe (axboe@suse.de) and petero2@telia.com&quot;
macro_line|#include &lt;linux/pktcdvd.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kthread.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;scsi/scsi_cmnd.h&gt;
macro_line|#include &lt;scsi/scsi_ioctl.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#if PACKET_DEBUG
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(fmt, args...) printk(KERN_NOTICE fmt, ##args)
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(fmt, args...)
macro_line|#endif
macro_line|#if PACKET_DEBUG &gt; 1
DECL|macro|VPRINTK
mdefine_line|#define VPRINTK(fmt, args...) printk(KERN_NOTICE fmt, ##args)
macro_line|#else
DECL|macro|VPRINTK
mdefine_line|#define VPRINTK(fmt, args...)
macro_line|#endif
DECL|macro|MAX_SPEED
mdefine_line|#define MAX_SPEED 0xffff
DECL|macro|ZONE
mdefine_line|#define ZONE(sector, pd) (((sector) + (pd)-&gt;offset) &amp; ~((pd)-&gt;settings.size - 1))
DECL|variable|pkt_devs
r_static
r_struct
id|pktcdvd_device
op_star
id|pkt_devs
(braket
id|MAX_WRITERS
)braket
suffix:semicolon
DECL|variable|pkt_proc
r_static
r_struct
id|proc_dir_entry
op_star
id|pkt_proc
suffix:semicolon
DECL|variable|pkt_major
r_static
r_int
id|pkt_major
suffix:semicolon
DECL|variable|ctl_mutex
r_static
r_struct
id|semaphore
id|ctl_mutex
suffix:semicolon
multiline_comment|/* Serialize open/close/setup/teardown */
DECL|variable|psd_pool
r_static
id|mempool_t
op_star
id|psd_pool
suffix:semicolon
DECL|function|pkt_bio_finished
r_static
r_void
id|pkt_bio_finished
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
)paren
(brace
id|BUG_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|pd-&gt;cdrw.pending_bios
)paren
op_le
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pd-&gt;cdrw.pending_bios
)paren
)paren
(brace
id|VPRINTK
c_func
(paren
l_string|&quot;pktcdvd: queue empty&bslash;n&quot;
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pd-&gt;iosched.attention
comma
l_int|1
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|pd-&gt;wqueue
)paren
suffix:semicolon
)brace
)brace
DECL|function|pkt_bio_destructor
r_static
r_void
id|pkt_bio_destructor
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|kfree
c_func
(paren
id|bio-&gt;bi_io_vec
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
DECL|function|pkt_bio_alloc
r_static
r_struct
id|bio
op_star
id|pkt_bio_alloc
c_func
(paren
r_int
id|nr_iovecs
)paren
(brace
r_struct
id|bio_vec
op_star
id|bvl
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|bio
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|bio
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
r_goto
id|no_bio
suffix:semicolon
id|bio_init
c_func
(paren
id|bio
)paren
suffix:semicolon
id|bvl
op_assign
id|kmalloc
c_func
(paren
id|nr_iovecs
op_star
r_sizeof
(paren
r_struct
id|bio_vec
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bvl
)paren
r_goto
id|no_bvl
suffix:semicolon
id|memset
c_func
(paren
id|bvl
comma
l_int|0
comma
id|nr_iovecs
op_star
r_sizeof
(paren
r_struct
id|bio_vec
)paren
)paren
suffix:semicolon
id|bio-&gt;bi_max_vecs
op_assign
id|nr_iovecs
suffix:semicolon
id|bio-&gt;bi_io_vec
op_assign
id|bvl
suffix:semicolon
id|bio-&gt;bi_destructor
op_assign
id|pkt_bio_destructor
suffix:semicolon
r_return
id|bio
suffix:semicolon
id|no_bvl
suffix:colon
id|kfree
c_func
(paren
id|bio
)paren
suffix:semicolon
id|no_bio
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a packet_data struct&n; */
DECL|function|pkt_alloc_packet_data
r_static
r_struct
id|packet_data
op_star
id|pkt_alloc_packet_data
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|packet_data
op_star
id|pkt
suffix:semicolon
id|pkt
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|packet_data
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
)paren
r_goto
id|no_pkt
suffix:semicolon
id|memset
c_func
(paren
id|pkt
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|packet_data
)paren
)paren
suffix:semicolon
id|pkt-&gt;w_bio
op_assign
id|pkt_bio_alloc
c_func
(paren
id|PACKET_MAX_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt-&gt;w_bio
)paren
r_goto
id|no_bio
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PAGES_PER_PACKET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pkt-&gt;pages
(braket
id|i
)braket
op_assign
id|alloc_page
c_func
(paren
id|GFP_KERNEL
op_or
id|__GFP_ZERO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt-&gt;pages
(braket
id|i
)braket
)paren
r_goto
id|no_page
suffix:semicolon
)brace
id|spin_lock_init
c_func
(paren
op_amp
id|pkt-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PACKET_MAX_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|pkt_bio_alloc
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
r_goto
id|no_rd_bio
suffix:semicolon
id|pkt-&gt;r_bios
(braket
id|i
)braket
op_assign
id|bio
suffix:semicolon
)brace
r_return
id|pkt
suffix:semicolon
id|no_rd_bio
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PACKET_MAX_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|pkt-&gt;r_bios
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bio
)paren
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
id|no_page
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PAGES_PER_PACKET
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|pkt-&gt;pages
(braket
id|i
)braket
)paren
id|__free_page
c_func
(paren
id|pkt-&gt;pages
(braket
id|i
)braket
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|pkt-&gt;w_bio
)paren
suffix:semicolon
id|no_bio
suffix:colon
id|kfree
c_func
(paren
id|pkt
)paren
suffix:semicolon
id|no_pkt
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Free a packet_data struct&n; */
DECL|function|pkt_free_packet_data
r_static
r_void
id|pkt_free_packet_data
c_func
(paren
r_struct
id|packet_data
op_star
id|pkt
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PACKET_MAX_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|bio
op_star
id|bio
op_assign
id|pkt-&gt;r_bios
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bio
)paren
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PAGES_PER_PACKET
suffix:semicolon
id|i
op_increment
)paren
id|__free_page
c_func
(paren
id|pkt-&gt;pages
(braket
id|i
)braket
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|pkt-&gt;w_bio
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pkt
)paren
suffix:semicolon
)brace
DECL|function|pkt_shrink_pktlist
r_static
r_void
id|pkt_shrink_pktlist
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
)paren
(brace
r_struct
id|packet_data
op_star
id|pkt
comma
op_star
id|next
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|pd-&gt;cdrw.pkt_active_list
)paren
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|pkt
comma
id|next
comma
op_amp
id|pd-&gt;cdrw.pkt_free_list
comma
id|list
)paren
(brace
id|pkt_free_packet_data
c_func
(paren
id|pkt
)paren
suffix:semicolon
)brace
)brace
DECL|function|pkt_grow_pktlist
r_static
r_int
id|pkt_grow_pktlist
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_int
id|nr_packets
)paren
(brace
r_struct
id|packet_data
op_star
id|pkt
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pd-&gt;cdrw.pkt_free_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pd-&gt;cdrw.pkt_active_list
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pd-&gt;cdrw.active_list_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nr_packets
OG
l_int|0
)paren
(brace
id|pkt
op_assign
id|pkt_alloc_packet_data
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
)paren
(brace
id|pkt_shrink_pktlist
c_func
(paren
id|pd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pkt-&gt;id
op_assign
id|nr_packets
suffix:semicolon
id|pkt-&gt;pd
op_assign
id|pd
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|pkt-&gt;list
comma
op_amp
id|pd-&gt;cdrw.pkt_free_list
)paren
suffix:semicolon
id|nr_packets
op_decrement
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|pkt_rb_alloc
r_static
r_void
op_star
id|pkt_rb_alloc
c_func
(paren
r_int
id|gfp_mask
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pkt_rb_node
)paren
comma
id|gfp_mask
)paren
suffix:semicolon
)brace
DECL|function|pkt_rb_free
r_static
r_void
id|pkt_rb_free
c_func
(paren
r_void
op_star
id|ptr
comma
r_void
op_star
id|data
)paren
(brace
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
DECL|function|pkt_rbtree_next
r_static
r_inline
r_struct
id|pkt_rb_node
op_star
id|pkt_rbtree_next
c_func
(paren
r_struct
id|pkt_rb_node
op_star
id|node
)paren
(brace
r_struct
id|rb_node
op_star
id|n
op_assign
id|rb_next
c_func
(paren
op_amp
id|node-&gt;rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|pkt_rb_node
comma
id|rb_node
)paren
suffix:semicolon
)brace
DECL|function|pkt_rbtree_erase
r_static
r_inline
r_void
id|pkt_rbtree_erase
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_struct
id|pkt_rb_node
op_star
id|node
)paren
(brace
id|rb_erase
c_func
(paren
op_amp
id|node-&gt;rb_node
comma
op_amp
id|pd-&gt;bio_queue
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|node
comma
id|pd-&gt;rb_pool
)paren
suffix:semicolon
id|pd-&gt;bio_queue_size
op_decrement
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pd-&gt;bio_queue_size
OL
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the first node in the pd-&gt;bio_queue rb tree with a starting sector &gt;= s.&n; */
DECL|function|pkt_rbtree_find
r_static
r_struct
id|pkt_rb_node
op_star
id|pkt_rbtree_find
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
id|sector_t
id|s
)paren
(brace
r_struct
id|rb_node
op_star
id|n
op_assign
id|pd-&gt;bio_queue.rb_node
suffix:semicolon
r_struct
id|rb_node
op_star
id|next
suffix:semicolon
r_struct
id|pkt_rb_node
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
(brace
id|BUG_ON
c_func
(paren
id|pd-&gt;bio_queue_size
OG
l_int|0
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|tmp
op_assign
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|pkt_rb_node
comma
id|rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_le
id|tmp-&gt;bio-&gt;bi_sector
)paren
id|next
op_assign
id|n-&gt;rb_left
suffix:semicolon
r_else
id|next
op_assign
id|n-&gt;rb_right
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next
)paren
r_break
suffix:semicolon
id|n
op_assign
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
OG
id|tmp-&gt;bio-&gt;bi_sector
)paren
(brace
id|tmp
op_assign
id|pkt_rbtree_next
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|s
OG
id|tmp-&gt;bio-&gt;bi_sector
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a node into the pd-&gt;bio_queue rb tree.&n; */
DECL|function|pkt_rbtree_insert
r_static
r_void
id|pkt_rbtree_insert
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_struct
id|pkt_rb_node
op_star
id|node
)paren
(brace
r_struct
id|rb_node
op_star
op_star
id|p
op_assign
op_amp
id|pd-&gt;bio_queue.rb_node
suffix:semicolon
r_struct
id|rb_node
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
id|sector_t
id|s
op_assign
id|node-&gt;bio-&gt;bi_sector
suffix:semicolon
r_struct
id|pkt_rb_node
op_star
id|tmp
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|tmp
op_assign
id|rb_entry
c_func
(paren
id|parent
comma
r_struct
id|pkt_rb_node
comma
id|rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
id|tmp-&gt;bio-&gt;bi_sector
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_left
suffix:semicolon
r_else
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_right
suffix:semicolon
)brace
id|rb_link_node
c_func
(paren
op_amp
id|node-&gt;rb_node
comma
id|parent
comma
id|p
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|node-&gt;rb_node
comma
op_amp
id|pd-&gt;bio_queue
)paren
suffix:semicolon
id|pd-&gt;bio_queue_size
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a bio to a single linked list defined by its head and tail pointers.&n; */
DECL|function|pkt_add_list_last
r_static
r_inline
r_void
id|pkt_add_list_last
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_struct
id|bio
op_star
op_star
id|list_head
comma
r_struct
id|bio
op_star
op_star
id|list_tail
)paren
(brace
id|bio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_star
id|list_tail
)paren
(brace
id|BUG_ON
c_func
(paren
(paren
op_star
id|list_head
)paren
op_eq
l_int|NULL
)paren
suffix:semicolon
(paren
op_star
id|list_tail
)paren
op_member_access_from_pointer
id|bi_next
op_assign
id|bio
suffix:semicolon
(paren
op_star
id|list_tail
)paren
op_assign
id|bio
suffix:semicolon
)brace
r_else
(brace
id|BUG_ON
c_func
(paren
(paren
op_star
id|list_head
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
(paren
op_star
id|list_head
)paren
op_assign
id|bio
suffix:semicolon
(paren
op_star
id|list_tail
)paren
op_assign
id|bio
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove and return the first bio from a single linked list defined by its&n; * head and tail pointers.&n; */
DECL|function|pkt_get_list_first
r_static
r_inline
r_struct
id|bio
op_star
id|pkt_get_list_first
c_func
(paren
r_struct
id|bio
op_star
op_star
id|list_head
comma
r_struct
id|bio
op_star
op_star
id|list_tail
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_if
c_cond
(paren
op_star
id|list_head
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|bio
op_assign
op_star
id|list_head
suffix:semicolon
op_star
id|list_head
op_assign
id|bio-&gt;bi_next
suffix:semicolon
r_if
c_cond
(paren
op_star
id|list_head
op_eq
l_int|NULL
)paren
op_star
id|list_tail
op_assign
l_int|NULL
suffix:semicolon
id|bio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|bio
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a packet_command to the underlying block device and&n; * wait for completion.&n; */
DECL|function|pkt_generic_packet
r_static
r_int
id|pkt_generic_packet
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_struct
id|packet_command
op_star
id|cgc
)paren
(brace
r_char
id|sense
(braket
id|SCSI_SENSE_BUFFERSIZE
)braket
suffix:semicolon
id|request_queue_t
op_star
id|q
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|DECLARE_COMPLETION
c_func
(paren
id|wait
)paren
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|q
op_assign
id|bdev_get_queue
c_func
(paren
id|pd-&gt;bdev
)paren
suffix:semicolon
id|rq
op_assign
id|blk_get_request
c_func
(paren
id|q
comma
(paren
id|cgc-&gt;data_direction
op_eq
id|CGC_DATA_WRITE
)paren
ques
c_cond
id|WRITE
suffix:colon
id|READ
comma
id|__GFP_WAIT
)paren
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;rq_disk
op_assign
id|pd-&gt;bdev-&gt;bd_disk
suffix:semicolon
id|rq-&gt;bio
op_assign
l_int|NULL
suffix:semicolon
id|rq-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|rq-&gt;timeout
op_assign
l_int|60
op_star
id|HZ
suffix:semicolon
id|rq-&gt;data
op_assign
id|cgc-&gt;buffer
suffix:semicolon
id|rq-&gt;data_len
op_assign
id|cgc-&gt;buflen
suffix:semicolon
id|rq-&gt;sense
op_assign
id|sense
suffix:semicolon
id|memset
c_func
(paren
id|sense
comma
l_int|0
comma
r_sizeof
(paren
id|sense
)paren
)paren
suffix:semicolon
id|rq-&gt;sense_len
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;flags
op_or_assign
id|REQ_BLOCK_PC
op_or
id|REQ_HARDBARRIER
suffix:semicolon
r_if
c_cond
(paren
id|cgc-&gt;quiet
)paren
id|rq-&gt;flags
op_or_assign
id|REQ_QUIET
suffix:semicolon
id|memcpy
c_func
(paren
id|rq-&gt;cmd
comma
id|cgc-&gt;cmd
comma
id|CDROM_PACKET_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
id|rq-&gt;cmd
)paren
OG
id|CDROM_PACKET_SIZE
)paren
id|memset
c_func
(paren
id|rq-&gt;cmd
op_plus
id|CDROM_PACKET_SIZE
comma
l_int|0
comma
r_sizeof
(paren
id|rq-&gt;cmd
)paren
op_minus
id|CDROM_PACKET_SIZE
)paren
suffix:semicolon
id|rq-&gt;ref_count
op_increment
suffix:semicolon
id|rq-&gt;flags
op_or_assign
id|REQ_NOMERGE
suffix:semicolon
id|rq-&gt;waiting
op_assign
op_amp
id|wait
suffix:semicolon
id|elv_add_request
c_func
(paren
id|q
comma
id|rq
comma
id|ELEVATOR_INSERT_BACK
comma
l_int|1
)paren
suffix:semicolon
id|generic_unplug_device
c_func
(paren
id|q
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;errors
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|blk_put_request
c_func
(paren
id|rq
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * A generic sense dump / resolve mechanism should be implemented across&n; * all ATAPI + SCSI devices.&n; */
DECL|function|pkt_dump_sense
r_static
r_void
id|pkt_dump_sense
c_func
(paren
r_struct
id|packet_command
op_star
id|cgc
)paren
(brace
r_static
r_char
op_star
id|info
(braket
l_int|9
)braket
op_assign
(brace
l_string|&quot;No sense&quot;
comma
l_string|&quot;Recovered error&quot;
comma
l_string|&quot;Not ready&quot;
comma
l_string|&quot;Medium error&quot;
comma
l_string|&quot;Hardware error&quot;
comma
l_string|&quot;Illegal request&quot;
comma
l_string|&quot;Unit attention&quot;
comma
l_string|&quot;Data protect&quot;
comma
l_string|&quot;Blank check&quot;
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|request_sense
op_star
id|sense
op_assign
id|cgc-&gt;sense
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pktcdvd:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CDROM_PACKET_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|cgc-&gt;cmd
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; - &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sense
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;no sense&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;sense %02x.%02x.%02x&quot;
comma
id|sense-&gt;sense_key
comma
id|sense-&gt;asc
comma
id|sense-&gt;ascq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sense-&gt;sense_key
OG
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; (INVALID)&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; (%s)&bslash;n&quot;
comma
id|info
(braket
id|sense-&gt;sense_key
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * flush the drive cache to media&n; */
DECL|function|pkt_flush_cache
r_static
r_int
id|pkt_flush_cache
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
)paren
(brace
r_struct
id|packet_command
id|cgc
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
l_int|NULL
comma
l_int|0
comma
id|CGC_DATA_NONE
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_FLUSH_CACHE
suffix:semicolon
id|cgc.quiet
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * the IMMED bit -- we default to not setting it, although that&n;&t; * would allow a much faster close, this is safer&n;&t; */
macro_line|#if 0
id|cgc.cmd
(braket
l_int|1
)braket
op_assign
l_int|1
op_lshift
l_int|1
suffix:semicolon
macro_line|#endif
r_return
id|pkt_generic_packet
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * speed is given as the normal factor, e.g. 4 for 4x&n; */
DECL|function|pkt_set_speed
r_static
r_int
id|pkt_set_speed
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_int
id|write_speed
comma
r_int
id|read_speed
)paren
(brace
r_struct
id|packet_command
id|cgc
suffix:semicolon
r_struct
id|request_sense
id|sense
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
l_int|NULL
comma
l_int|0
comma
id|CGC_DATA_NONE
)paren
suffix:semicolon
id|cgc.sense
op_assign
op_amp
id|sense
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_SET_SPEED
suffix:semicolon
id|cgc.cmd
(braket
l_int|2
)braket
op_assign
(paren
id|read_speed
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc.cmd
(braket
l_int|3
)braket
op_assign
id|read_speed
op_amp
l_int|0xff
suffix:semicolon
id|cgc.cmd
(braket
l_int|4
)braket
op_assign
(paren
id|write_speed
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cgc.cmd
(braket
l_int|5
)braket
op_assign
id|write_speed
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_generic_packet
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
)paren
)paren
id|pkt_dump_sense
c_func
(paren
op_amp
id|cgc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue a bio for processing by the low-level CD device. Must be called&n; * from process context.&n; */
DECL|function|pkt_queue_bio
r_static
r_void
id|pkt_queue_bio
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_struct
id|bio
op_star
id|bio
comma
r_int
id|high_prio_read
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|pd-&gt;iosched.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio_data_dir
c_func
(paren
id|bio
)paren
op_eq
id|READ
)paren
(brace
id|pkt_add_list_last
c_func
(paren
id|bio
comma
op_amp
id|pd-&gt;iosched.read_queue
comma
op_amp
id|pd-&gt;iosched.read_queue_tail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|high_prio_read
)paren
id|pd-&gt;iosched.high_prio_read
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pkt_add_list_last
c_func
(paren
id|bio
comma
op_amp
id|pd-&gt;iosched.write_queue
comma
op_amp
id|pd-&gt;iosched.write_queue_tail
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pd-&gt;iosched.lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pd-&gt;iosched.attention
comma
l_int|1
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|pd-&gt;wqueue
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process the queued read/write requests. This function handles special&n; * requirements for CDRW drives:&n; * - A cache flush command must be inserted before a read request if the&n; *   previous request was a write.&n; * - Switching between reading and writing is slow, so don&squot;t it more often&n; *   than necessary.&n; * - Set the read speed according to current usage pattern. When only reading&n; *   from the device, it&squot;s best to use the highest possible read speed, but&n; *   when switching often between reading and writing, it&squot;s better to have the&n; *   same read and write speeds.&n; * - Reads originating from user space should have higher priority than reads&n; *   originating from pkt_gather_data, because some process is usually waiting&n; *   on reads of the first kind.&n; */
DECL|function|pkt_iosched_process_queue
r_static
r_void
id|pkt_iosched_process_queue
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
)paren
(brace
id|request_queue_t
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pd-&gt;iosched.attention
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pd-&gt;iosched.attention
comma
l_int|0
)paren
suffix:semicolon
id|q
op_assign
id|bdev_get_queue
c_func
(paren
id|pd-&gt;bdev
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
id|reads_queued
comma
id|writes_queued
comma
id|high_prio_read
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pd-&gt;iosched.lock
)paren
suffix:semicolon
id|reads_queued
op_assign
(paren
id|pd-&gt;iosched.read_queue
op_ne
l_int|NULL
)paren
suffix:semicolon
id|writes_queued
op_assign
(paren
id|pd-&gt;iosched.write_queue
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reads_queued
)paren
id|pd-&gt;iosched.high_prio_read
op_assign
l_int|0
suffix:semicolon
id|high_prio_read
op_assign
id|pd-&gt;iosched.high_prio_read
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pd-&gt;iosched.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reads_queued
op_logical_and
op_logical_neg
id|writes_queued
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;iosched.writing
)paren
(brace
r_if
c_cond
(paren
id|high_prio_read
op_logical_or
(paren
op_logical_neg
id|writes_queued
op_logical_and
id|reads_queued
)paren
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pd-&gt;cdrw.pending_bios
)paren
OG
l_int|0
)paren
(brace
id|VPRINTK
c_func
(paren
l_string|&quot;pktcdvd: write, waiting&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pkt_flush_cache
c_func
(paren
id|pd
)paren
suffix:semicolon
id|pd-&gt;iosched.writing
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|reads_queued
op_logical_and
id|writes_queued
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pd-&gt;cdrw.pending_bios
)paren
OG
l_int|0
)paren
(brace
id|VPRINTK
c_func
(paren
l_string|&quot;pktcdvd: read, waiting&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pd-&gt;iosched.writing
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|spin_lock
c_func
(paren
op_amp
id|pd-&gt;iosched.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;iosched.writing
)paren
(brace
id|bio
op_assign
id|pkt_get_list_first
c_func
(paren
op_amp
id|pd-&gt;iosched.write_queue
comma
op_amp
id|pd-&gt;iosched.write_queue_tail
)paren
suffix:semicolon
)brace
r_else
(brace
id|bio
op_assign
id|pkt_get_list_first
c_func
(paren
op_amp
id|pd-&gt;iosched.read_queue
comma
op_amp
id|pd-&gt;iosched.read_queue_tail
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pd-&gt;iosched.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|bio_data_dir
c_func
(paren
id|bio
)paren
op_eq
id|READ
)paren
id|pd-&gt;iosched.successive_reads
op_add_assign
id|bio-&gt;bi_size
op_rshift
l_int|10
suffix:semicolon
r_else
id|pd-&gt;iosched.successive_reads
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;iosched.successive_reads
op_ge
id|HI_SPEED_SWITCH
)paren
(brace
r_if
c_cond
(paren
id|pd-&gt;read_speed
op_eq
id|pd-&gt;write_speed
)paren
(brace
id|pd-&gt;read_speed
op_assign
id|MAX_SPEED
suffix:semicolon
id|pkt_set_speed
c_func
(paren
id|pd
comma
id|pd-&gt;write_speed
comma
id|pd-&gt;read_speed
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|pd-&gt;read_speed
op_ne
id|pd-&gt;write_speed
)paren
(brace
id|pd-&gt;read_speed
op_assign
id|pd-&gt;write_speed
suffix:semicolon
id|pkt_set_speed
c_func
(paren
id|pd
comma
id|pd-&gt;write_speed
comma
id|pd-&gt;read_speed
)paren
suffix:semicolon
)brace
)brace
id|atomic_inc
c_func
(paren
op_amp
id|pd-&gt;cdrw.pending_bios
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Special care is needed if the underlying block device has a small&n; * max_phys_segments value.&n; */
DECL|function|pkt_set_segment_merging
r_static
r_int
id|pkt_set_segment_merging
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
id|request_queue_t
op_star
id|q
)paren
(brace
r_if
c_cond
(paren
(paren
id|pd-&gt;settings.size
op_lshift
l_int|9
)paren
op_div
id|CD_FRAMESIZE
op_le
id|q-&gt;max_phys_segments
)paren
(brace
multiline_comment|/*&n;&t;&t; * The cdrom device can handle one segment/frame&n;&t;&t; */
id|clear_bit
c_func
(paren
id|PACKET_MERGE_SEGS
comma
op_amp
id|pd-&gt;flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|pd-&gt;settings.size
op_lshift
l_int|9
)paren
op_div
id|PAGE_SIZE
op_le
id|q-&gt;max_phys_segments
)paren
(brace
multiline_comment|/*&n;&t;&t; * We can handle this case at the expense of some extra memory&n;&t;&t; * copies during write operations&n;&t;&t; */
id|set_bit
c_func
(paren
id|PACKET_MERGE_SEGS
comma
op_amp
id|pd-&gt;flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: cdrom max_phys_segments too small&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Copy CD_FRAMESIZE bytes from src_bio into a destination page&n; */
DECL|function|pkt_copy_bio_data
r_static
r_void
id|pkt_copy_bio_data
c_func
(paren
r_struct
id|bio
op_star
id|src_bio
comma
r_int
id|seg
comma
r_int
id|offs
comma
r_struct
id|page
op_star
id|dst_page
comma
r_int
id|dst_offs
)paren
(brace
r_int
r_int
id|copy_size
op_assign
id|CD_FRAMESIZE
suffix:semicolon
r_while
c_loop
(paren
id|copy_size
OG
l_int|0
)paren
(brace
r_struct
id|bio_vec
op_star
id|src_bvl
op_assign
id|bio_iovec_idx
c_func
(paren
id|src_bio
comma
id|seg
)paren
suffix:semicolon
r_void
op_star
id|vfrom
op_assign
id|kmap_atomic
c_func
(paren
id|src_bvl-&gt;bv_page
comma
id|KM_USER0
)paren
op_plus
id|src_bvl-&gt;bv_offset
op_plus
id|offs
suffix:semicolon
r_void
op_star
id|vto
op_assign
id|page_address
c_func
(paren
id|dst_page
)paren
op_plus
id|dst_offs
suffix:semicolon
r_int
id|len
op_assign
id|min_t
c_func
(paren
r_int
comma
id|copy_size
comma
id|src_bvl-&gt;bv_len
op_minus
id|offs
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|len
OL
l_int|0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|vto
comma
id|vfrom
comma
id|len
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|vfrom
comma
id|KM_USER0
)paren
suffix:semicolon
id|seg
op_increment
suffix:semicolon
id|offs
op_assign
l_int|0
suffix:semicolon
id|dst_offs
op_add_assign
id|len
suffix:semicolon
id|copy_size
op_sub_assign
id|len
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Copy all data for this packet to pkt-&gt;pages[], so that&n; * a) The number of required segments for the write bio is minimized, which&n; *    is necessary for some scsi controllers.&n; * b) The data can be used as cache to avoid read requests if we receive a&n; *    new write request for the same zone.&n; */
DECL|function|pkt_make_local_copy
r_static
r_void
id|pkt_make_local_copy
c_func
(paren
r_struct
id|packet_data
op_star
id|pkt
comma
r_struct
id|page
op_star
op_star
id|pages
comma
r_int
op_star
id|offsets
)paren
(brace
r_int
id|f
comma
id|p
comma
id|offs
suffix:semicolon
multiline_comment|/* Copy all data to pkt-&gt;pages[] */
id|p
op_assign
l_int|0
suffix:semicolon
id|offs
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
l_int|0
suffix:semicolon
id|f
OL
id|pkt-&gt;frames
suffix:semicolon
id|f
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pages
(braket
id|f
)braket
op_ne
id|pkt-&gt;pages
(braket
id|p
)braket
)paren
(brace
r_void
op_star
id|vfrom
op_assign
id|kmap_atomic
c_func
(paren
id|pages
(braket
id|f
)braket
comma
id|KM_USER0
)paren
op_plus
id|offsets
(braket
id|f
)braket
suffix:semicolon
r_void
op_star
id|vto
op_assign
id|page_address
c_func
(paren
id|pkt-&gt;pages
(braket
id|p
)braket
)paren
op_plus
id|offs
suffix:semicolon
id|memcpy
c_func
(paren
id|vto
comma
id|vfrom
comma
id|CD_FRAMESIZE
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|vfrom
comma
id|KM_USER0
)paren
suffix:semicolon
id|pages
(braket
id|f
)braket
op_assign
id|pkt-&gt;pages
(braket
id|p
)braket
suffix:semicolon
id|offsets
(braket
id|f
)braket
op_assign
id|offs
suffix:semicolon
)brace
r_else
(brace
id|BUG_ON
c_func
(paren
id|offsets
(braket
id|f
)braket
op_ne
id|offs
)paren
suffix:semicolon
)brace
id|offs
op_add_assign
id|CD_FRAMESIZE
suffix:semicolon
r_if
c_cond
(paren
id|offs
op_ge
id|PAGE_SIZE
)paren
(brace
id|BUG_ON
c_func
(paren
id|offs
OG
id|PAGE_SIZE
)paren
suffix:semicolon
id|offs
op_assign
l_int|0
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
)brace
)brace
DECL|function|pkt_end_io_read
r_static
r_int
id|pkt_end_io_read
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|err
)paren
(brace
r_struct
id|packet_data
op_star
id|pkt
op_assign
id|bio-&gt;bi_private
suffix:semicolon
r_struct
id|pktcdvd_device
op_star
id|pd
op_assign
id|pkt-&gt;pd
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|pd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;pkt_end_io_read: bio=%p sec0=%llx sec=%llx err=%d&bslash;n&quot;
comma
id|bio
comma
(paren
r_int
r_int
r_int
)paren
id|pkt-&gt;sector
comma
(paren
r_int
r_int
r_int
)paren
id|bio-&gt;bi_sector
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|atomic_inc
c_func
(paren
op_amp
id|pkt-&gt;io_errors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pkt-&gt;io_wait
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|pkt-&gt;run_sm
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|pd-&gt;wqueue
)paren
suffix:semicolon
)brace
id|pkt_bio_finished
c_func
(paren
id|pd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pkt_end_io_packet_write
r_static
r_int
id|pkt_end_io_packet_write
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|err
)paren
(brace
r_struct
id|packet_data
op_star
id|pkt
op_assign
id|bio-&gt;bi_private
suffix:semicolon
r_struct
id|pktcdvd_device
op_star
id|pd
op_assign
id|pkt-&gt;pd
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|pd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;pkt_end_io_packet_write: id=%d, err=%d&bslash;n&quot;
comma
id|pkt-&gt;id
comma
id|err
)paren
suffix:semicolon
id|pd-&gt;stats.pkt_ended
op_increment
suffix:semicolon
id|pkt_bio_finished
c_func
(paren
id|pd
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|pkt-&gt;io_wait
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|pkt-&gt;run_sm
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|pd-&gt;wqueue
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Schedule reads for the holes in a packet&n; */
DECL|function|pkt_gather_data
r_static
r_void
id|pkt_gather_data
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_struct
id|packet_data
op_star
id|pkt
)paren
(brace
r_int
id|frames_read
op_assign
l_int|0
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
id|f
suffix:semicolon
r_char
id|written
(braket
id|PACKET_MAX_SIZE
)braket
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|pkt-&gt;orig_bios
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pkt-&gt;io_wait
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pkt-&gt;io_errors
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt-&gt;cache_valid
)paren
(brace
id|VPRINTK
c_func
(paren
l_string|&quot;pkt_gather_data: zone %llx cached&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|pkt-&gt;sector
)paren
suffix:semicolon
r_goto
id|out_account
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Figure out which frames we need to read before we can write.&n;&t; */
id|memset
c_func
(paren
id|written
comma
l_int|0
comma
r_sizeof
(paren
id|written
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pkt-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bio
op_assign
id|pkt-&gt;orig_bios
suffix:semicolon
id|bio
suffix:semicolon
id|bio
op_assign
id|bio-&gt;bi_next
)paren
(brace
r_int
id|first_frame
op_assign
(paren
id|bio-&gt;bi_sector
op_minus
id|pkt-&gt;sector
)paren
op_div
(paren
id|CD_FRAMESIZE
op_rshift
l_int|9
)paren
suffix:semicolon
r_int
id|num_frames
op_assign
id|bio-&gt;bi_size
op_div
id|CD_FRAMESIZE
suffix:semicolon
id|BUG_ON
c_func
(paren
id|first_frame
OL
l_int|0
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|first_frame
op_plus
id|num_frames
OG
id|pkt-&gt;frames
)paren
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
id|first_frame
suffix:semicolon
id|f
OL
id|first_frame
op_plus
id|num_frames
suffix:semicolon
id|f
op_increment
)paren
id|written
(braket
id|f
)braket
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pkt-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Schedule reads for missing parts of the packet.&n;&t; */
r_for
c_loop
(paren
id|f
op_assign
l_int|0
suffix:semicolon
id|f
OL
id|pkt-&gt;frames
suffix:semicolon
id|f
op_increment
)paren
(brace
r_int
id|p
comma
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|written
(braket
id|f
)braket
)paren
r_continue
suffix:semicolon
id|bio
op_assign
id|pkt-&gt;r_bios
(braket
id|f
)braket
suffix:semicolon
id|bio_init
c_func
(paren
id|bio
)paren
suffix:semicolon
id|bio-&gt;bi_max_vecs
op_assign
l_int|1
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|pkt-&gt;sector
op_plus
id|f
op_star
(paren
id|CD_FRAMESIZE
op_rshift
l_int|9
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|pd-&gt;bdev
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|pkt_end_io_read
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|pkt
suffix:semicolon
id|p
op_assign
(paren
id|f
op_star
id|CD_FRAMESIZE
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
id|offset
op_assign
(paren
id|f
op_star
id|CD_FRAMESIZE
)paren
op_mod
id|PAGE_SIZE
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;pkt_gather_data: Adding frame %d, page:%p offs:%d&bslash;n&quot;
comma
id|f
comma
id|pkt-&gt;pages
(braket
id|p
)braket
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio_add_page
c_func
(paren
id|bio
comma
id|pkt-&gt;pages
(braket
id|p
)braket
comma
id|CD_FRAMESIZE
comma
id|offset
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|pkt-&gt;io_wait
)paren
suffix:semicolon
id|bio-&gt;bi_rw
op_assign
id|READ
suffix:semicolon
id|pkt_queue_bio
c_func
(paren
id|pd
comma
id|bio
comma
l_int|0
)paren
suffix:semicolon
id|frames_read
op_increment
suffix:semicolon
)brace
id|out_account
suffix:colon
id|VPRINTK
c_func
(paren
l_string|&quot;pkt_gather_data: need %d frames for zone %llx&bslash;n&quot;
comma
id|frames_read
comma
(paren
r_int
r_int
r_int
)paren
id|pkt-&gt;sector
)paren
suffix:semicolon
id|pd-&gt;stats.pkt_started
op_increment
suffix:semicolon
id|pd-&gt;stats.secs_rg
op_add_assign
id|frames_read
op_star
(paren
id|CD_FRAMESIZE
op_rshift
l_int|9
)paren
suffix:semicolon
id|pd-&gt;stats.secs_w
op_add_assign
id|pd-&gt;settings.size
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a packet matching zone, or the least recently used packet if&n; * there is no match.&n; */
DECL|function|pkt_get_packet_data
r_static
r_struct
id|packet_data
op_star
id|pkt_get_packet_data
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_int
id|zone
)paren
(brace
r_struct
id|packet_data
op_star
id|pkt
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|pkt
comma
op_amp
id|pd-&gt;cdrw.pkt_free_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|pkt-&gt;sector
op_eq
id|zone
op_logical_or
id|pkt-&gt;list.next
op_eq
op_amp
id|pd-&gt;cdrw.pkt_free_list
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|pkt-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt-&gt;sector
op_ne
id|zone
)paren
id|pkt-&gt;cache_valid
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|pkt
suffix:semicolon
)brace
DECL|function|pkt_put_packet_data
r_static
r_void
id|pkt_put_packet_data
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_struct
id|packet_data
op_star
id|pkt
)paren
(brace
r_if
c_cond
(paren
id|pkt-&gt;cache_valid
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|pkt-&gt;list
comma
op_amp
id|pd-&gt;cdrw.pkt_free_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add_tail
c_func
(paren
op_amp
id|pkt-&gt;list
comma
op_amp
id|pd-&gt;cdrw.pkt_free_list
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * recover a failed write, query for relocation if possible&n; *&n; * returns 1 if recovery is possible, or 0 if not&n; *&n; */
DECL|function|pkt_start_recovery
r_static
r_int
id|pkt_start_recovery
c_func
(paren
r_struct
id|packet_data
op_star
id|pkt
)paren
(brace
multiline_comment|/*&n;&t; * FIXME. We need help from the file system to implement&n;&t; * recovery handling.&n;&t; */
r_return
l_int|0
suffix:semicolon
macro_line|#if 0
r_struct
id|request
op_star
id|rq
op_assign
id|pkt-&gt;rq
suffix:semicolon
r_struct
id|pktcdvd_device
op_star
id|pd
op_assign
id|rq-&gt;rq_disk-&gt;private_data
suffix:semicolon
r_struct
id|block_device
op_star
id|pkt_bdev
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|old_block
comma
id|new_block
suffix:semicolon
id|sector_t
id|new_sector
suffix:semicolon
id|pkt_bdev
op_assign
id|bdget
c_func
(paren
id|kdev_t_to_nr
c_func
(paren
id|pd-&gt;pkt_dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_bdev
)paren
(brace
id|sb
op_assign
id|get_super
c_func
(paren
id|pkt_bdev
)paren
suffix:semicolon
id|bdput
c_func
(paren
id|pkt_bdev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;s_op
op_logical_or
op_logical_neg
id|sb-&gt;s_op-&gt;relocate_blocks
)paren
r_goto
id|out
suffix:semicolon
id|old_block
op_assign
id|pkt-&gt;sector
op_div
(paren
id|CD_FRAMESIZE
op_rshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_op
op_member_access_from_pointer
id|relocate_blocks
c_func
(paren
id|sb
comma
id|old_block
comma
op_amp
id|new_block
)paren
)paren
r_goto
id|out
suffix:semicolon
id|new_sector
op_assign
id|new_block
op_star
(paren
id|CD_FRAMESIZE
op_rshift
l_int|9
)paren
suffix:semicolon
id|pkt-&gt;sector
op_assign
id|new_sector
suffix:semicolon
id|pkt-&gt;bio-&gt;bi_sector
op_assign
id|new_sector
suffix:semicolon
id|pkt-&gt;bio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
id|pkt-&gt;bio-&gt;bi_flags
op_assign
l_int|1
op_lshift
id|BIO_UPTODATE
suffix:semicolon
id|pkt-&gt;bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pkt-&gt;bio-&gt;bi_rw
op_ne
(paren
l_int|1
op_lshift
id|BIO_RW
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pkt-&gt;bio-&gt;bi_vcnt
op_ne
id|pkt-&gt;frames
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pkt-&gt;bio-&gt;bi_size
op_ne
id|pkt-&gt;frames
op_star
id|CD_FRAMESIZE
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pkt-&gt;bio-&gt;bi_end_io
op_ne
id|pkt_end_io_packet_write
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pkt-&gt;bio-&gt;bi_private
op_ne
id|pkt
)paren
suffix:semicolon
id|drop_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|out
suffix:colon
id|drop_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
DECL|function|pkt_set_state
r_static
r_inline
r_void
id|pkt_set_state
c_func
(paren
r_struct
id|packet_data
op_star
id|pkt
comma
r_enum
id|packet_data_state
id|state
)paren
(brace
macro_line|#if PACKET_DEBUG &gt; 1
r_static
r_const
r_char
op_star
id|state_name
(braket
)braket
op_assign
(brace
l_string|&quot;IDLE&quot;
comma
l_string|&quot;WAITING&quot;
comma
l_string|&quot;READ_WAIT&quot;
comma
l_string|&quot;WRITE_WAIT&quot;
comma
l_string|&quot;RECOVERY&quot;
comma
l_string|&quot;FINISHED&quot;
)brace
suffix:semicolon
r_enum
id|packet_data_state
id|old_state
op_assign
id|pkt-&gt;state
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;pkt %2d : s=%6llx %s -&gt; %s&bslash;n&quot;
comma
id|pkt-&gt;id
comma
(paren
r_int
r_int
r_int
)paren
id|pkt-&gt;sector
comma
id|state_name
(braket
id|old_state
)braket
comma
id|state_name
(braket
id|state
)braket
)paren
suffix:semicolon
macro_line|#endif
id|pkt-&gt;state
op_assign
id|state
suffix:semicolon
)brace
multiline_comment|/*&n; * Scan the work queue to see if we can start a new packet.&n; * returns non-zero if any work was done.&n; */
DECL|function|pkt_handle_queue
r_static
r_int
id|pkt_handle_queue
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
)paren
(brace
r_struct
id|packet_data
op_star
id|pkt
comma
op_star
id|p
suffix:semicolon
r_struct
id|bio
op_star
id|bio
op_assign
l_int|NULL
suffix:semicolon
id|sector_t
id|zone
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Suppress gcc warning */
r_struct
id|pkt_rb_node
op_star
id|node
comma
op_star
id|first_node
suffix:semicolon
r_struct
id|rb_node
op_star
id|n
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;handle_queue&bslash;n&quot;
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pd-&gt;scan_queue
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|pd-&gt;cdrw.pkt_free_list
)paren
)paren
(brace
id|VPRINTK
c_func
(paren
l_string|&quot;handle_queue: no pkt&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Try to find a zone we are not already working on.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pd-&gt;lock
)paren
suffix:semicolon
id|first_node
op_assign
id|pkt_rbtree_find
c_func
(paren
id|pd
comma
id|pd-&gt;current_sector
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first_node
)paren
(brace
id|n
op_assign
id|rb_first
c_func
(paren
op_amp
id|pd-&gt;bio_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
id|first_node
op_assign
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|pkt_rb_node
comma
id|rb_node
)paren
suffix:semicolon
)brace
id|node
op_assign
id|first_node
suffix:semicolon
r_while
c_loop
(paren
id|node
)paren
(brace
id|bio
op_assign
id|node-&gt;bio
suffix:semicolon
id|zone
op_assign
id|ZONE
c_func
(paren
id|bio-&gt;bi_sector
comma
id|pd
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|p
comma
op_amp
id|pd-&gt;cdrw.pkt_active_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;sector
op_eq
id|zone
)paren
r_goto
id|try_next_bio
suffix:semicolon
)brace
r_break
suffix:semicolon
id|try_next_bio
suffix:colon
id|node
op_assign
id|pkt_rbtree_next
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
(brace
id|n
op_assign
id|rb_first
c_func
(paren
op_amp
id|pd-&gt;bio_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
id|node
op_assign
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|pkt_rb_node
comma
id|rb_node
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node
op_eq
id|first_node
)paren
id|node
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pd-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
id|VPRINTK
c_func
(paren
l_string|&quot;handle_queue: no bio&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pkt
op_assign
id|pkt_get_packet_data
c_func
(paren
id|pd
comma
id|zone
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|pkt
)paren
suffix:semicolon
id|pd-&gt;current_sector
op_assign
id|zone
op_plus
id|pd-&gt;settings.size
suffix:semicolon
id|pkt-&gt;sector
op_assign
id|zone
suffix:semicolon
id|pkt-&gt;frames
op_assign
id|pd-&gt;settings.size
op_rshift
l_int|2
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pkt-&gt;frames
OG
id|PACKET_MAX_SIZE
)paren
suffix:semicolon
id|pkt-&gt;write_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Scan work queue for bios in the same zone and link them&n;&t; * to this packet.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pd-&gt;lock
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;pkt_handle_queue: looking for zone %llx&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|zone
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|node
op_assign
id|pkt_rbtree_find
c_func
(paren
id|pd
comma
id|zone
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|bio
op_assign
id|node-&gt;bio
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;pkt_handle_queue: found zone=%llx&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ZONE
c_func
(paren
id|bio-&gt;bi_sector
comma
id|pd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ZONE
c_func
(paren
id|bio-&gt;bi_sector
comma
id|pd
)paren
op_ne
id|zone
)paren
r_break
suffix:semicolon
id|pkt_rbtree_erase
c_func
(paren
id|pd
comma
id|node
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pkt-&gt;lock
)paren
suffix:semicolon
id|pkt_add_list_last
c_func
(paren
id|bio
comma
op_amp
id|pkt-&gt;orig_bios
comma
op_amp
id|pkt-&gt;orig_bios_tail
)paren
suffix:semicolon
id|pkt-&gt;write_size
op_add_assign
id|bio-&gt;bi_size
op_div
id|CD_FRAMESIZE
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pkt-&gt;lock
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pd-&gt;lock
)paren
suffix:semicolon
id|pkt-&gt;sleep_time
op_assign
id|max
c_func
(paren
id|PACKET_WAIT_TIME
comma
l_int|1
)paren
suffix:semicolon
id|pkt_set_state
c_func
(paren
id|pkt
comma
id|PACKET_WAITING_STATE
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pkt-&gt;run_sm
comma
l_int|1
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pd-&gt;cdrw.active_list_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|pkt-&gt;list
comma
op_amp
id|pd-&gt;cdrw.pkt_active_list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pd-&gt;cdrw.active_list_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Assemble a bio to write one packet and queue the bio for processing&n; * by the underlying block device.&n; */
DECL|function|pkt_start_write
r_static
r_void
id|pkt_start_write
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_struct
id|packet_data
op_star
id|pkt
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_struct
id|page
op_star
id|pages
(braket
id|PACKET_MAX_SIZE
)braket
suffix:semicolon
r_int
id|offsets
(braket
id|PACKET_MAX_SIZE
)braket
suffix:semicolon
r_int
id|f
suffix:semicolon
r_int
id|frames_write
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
l_int|0
suffix:semicolon
id|f
OL
id|pkt-&gt;frames
suffix:semicolon
id|f
op_increment
)paren
(brace
id|pages
(braket
id|f
)braket
op_assign
id|pkt-&gt;pages
(braket
(paren
id|f
op_star
id|CD_FRAMESIZE
)paren
op_div
id|PAGE_SIZE
)braket
suffix:semicolon
id|offsets
(braket
id|f
)braket
op_assign
(paren
id|f
op_star
id|CD_FRAMESIZE
)paren
op_mod
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill-in pages[] and offsets[] with data from orig_bios.&n;&t; */
id|frames_write
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pkt-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bio
op_assign
id|pkt-&gt;orig_bios
suffix:semicolon
id|bio
suffix:semicolon
id|bio
op_assign
id|bio-&gt;bi_next
)paren
(brace
r_int
id|segment
op_assign
id|bio-&gt;bi_idx
suffix:semicolon
r_int
id|src_offs
op_assign
l_int|0
suffix:semicolon
r_int
id|first_frame
op_assign
(paren
id|bio-&gt;bi_sector
op_minus
id|pkt-&gt;sector
)paren
op_div
(paren
id|CD_FRAMESIZE
op_rshift
l_int|9
)paren
suffix:semicolon
r_int
id|num_frames
op_assign
id|bio-&gt;bi_size
op_div
id|CD_FRAMESIZE
suffix:semicolon
id|BUG_ON
c_func
(paren
id|first_frame
OL
l_int|0
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|first_frame
op_plus
id|num_frames
OG
id|pkt-&gt;frames
)paren
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
id|first_frame
suffix:semicolon
id|f
OL
id|first_frame
op_plus
id|num_frames
suffix:semicolon
id|f
op_increment
)paren
(brace
r_struct
id|bio_vec
op_star
id|src_bvl
op_assign
id|bio_iovec_idx
c_func
(paren
id|bio
comma
id|segment
)paren
suffix:semicolon
r_while
c_loop
(paren
id|src_offs
op_ge
id|src_bvl-&gt;bv_len
)paren
(brace
id|src_offs
op_sub_assign
id|src_bvl-&gt;bv_len
suffix:semicolon
id|segment
op_increment
suffix:semicolon
id|BUG_ON
c_func
(paren
id|segment
op_ge
id|bio-&gt;bi_vcnt
)paren
suffix:semicolon
id|src_bvl
op_assign
id|bio_iovec_idx
c_func
(paren
id|bio
comma
id|segment
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|src_bvl-&gt;bv_len
op_minus
id|src_offs
op_ge
id|CD_FRAMESIZE
)paren
(brace
id|pages
(braket
id|f
)braket
op_assign
id|src_bvl-&gt;bv_page
suffix:semicolon
id|offsets
(braket
id|f
)braket
op_assign
id|src_bvl-&gt;bv_offset
op_plus
id|src_offs
suffix:semicolon
)brace
r_else
(brace
id|pkt_copy_bio_data
c_func
(paren
id|bio
comma
id|segment
comma
id|src_offs
comma
id|pages
(braket
id|f
)braket
comma
id|offsets
(braket
id|f
)braket
)paren
suffix:semicolon
)brace
id|src_offs
op_add_assign
id|CD_FRAMESIZE
suffix:semicolon
id|frames_write
op_increment
suffix:semicolon
)brace
)brace
id|pkt_set_state
c_func
(paren
id|pkt
comma
id|PACKET_WRITE_WAIT_STATE
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pkt-&gt;lock
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;pkt_start_write: Writing %d frames for zone %llx&bslash;n&quot;
comma
id|frames_write
comma
(paren
r_int
r_int
r_int
)paren
id|pkt-&gt;sector
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|frames_write
op_ne
id|pkt-&gt;write_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|PACKET_MERGE_SEGS
comma
op_amp
id|pd-&gt;flags
)paren
op_logical_or
(paren
id|pkt-&gt;write_size
OL
id|pkt-&gt;frames
)paren
)paren
(brace
id|pkt_make_local_copy
c_func
(paren
id|pkt
comma
id|pages
comma
id|offsets
)paren
suffix:semicolon
id|pkt-&gt;cache_valid
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pkt-&gt;cache_valid
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Start the write request */
id|bio_init
c_func
(paren
id|pkt-&gt;w_bio
)paren
suffix:semicolon
id|pkt-&gt;w_bio-&gt;bi_max_vecs
op_assign
id|PACKET_MAX_SIZE
suffix:semicolon
id|pkt-&gt;w_bio-&gt;bi_sector
op_assign
id|pkt-&gt;sector
suffix:semicolon
id|pkt-&gt;w_bio-&gt;bi_bdev
op_assign
id|pd-&gt;bdev
suffix:semicolon
id|pkt-&gt;w_bio-&gt;bi_end_io
op_assign
id|pkt_end_io_packet_write
suffix:semicolon
id|pkt-&gt;w_bio-&gt;bi_private
op_assign
id|pkt
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
l_int|0
suffix:semicolon
id|f
OL
id|pkt-&gt;frames
suffix:semicolon
id|f
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|f
op_plus
l_int|1
OL
id|pkt-&gt;frames
)paren
op_logical_and
(paren
id|pages
(braket
id|f
op_plus
l_int|1
)braket
op_eq
id|pages
(braket
id|f
)braket
)paren
op_logical_and
(paren
id|offsets
(braket
id|f
op_plus
l_int|1
)braket
op_assign
id|offsets
(braket
id|f
)braket
op_plus
id|CD_FRAMESIZE
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bio_add_page
c_func
(paren
id|pkt-&gt;w_bio
comma
id|pages
(braket
id|f
)braket
comma
id|CD_FRAMESIZE
op_star
l_int|2
comma
id|offsets
(braket
id|f
)braket
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|f
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|bio_add_page
c_func
(paren
id|pkt-&gt;w_bio
comma
id|pages
(braket
id|f
)braket
comma
id|CD_FRAMESIZE
comma
id|offsets
(braket
id|f
)braket
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|VPRINTK
c_func
(paren
l_string|&quot;pktcdvd: vcnt=%d&bslash;n&quot;
comma
id|pkt-&gt;w_bio-&gt;bi_vcnt
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pkt-&gt;io_wait
comma
l_int|1
)paren
suffix:semicolon
id|pkt-&gt;w_bio-&gt;bi_rw
op_assign
id|WRITE
suffix:semicolon
id|pkt_queue_bio
c_func
(paren
id|pd
comma
id|pkt-&gt;w_bio
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|pkt_finish_packet
r_static
r_void
id|pkt_finish_packet
c_func
(paren
r_struct
id|packet_data
op_star
id|pkt
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|bio
op_star
id|bio
comma
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|pkt-&gt;cache_valid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Finish all bios corresponding to this packet */
id|bio
op_assign
id|pkt-&gt;orig_bios
suffix:semicolon
r_while
c_loop
(paren
id|bio
)paren
(brace
id|next
op_assign
id|bio-&gt;bi_next
suffix:semicolon
id|bio-&gt;bi_next
op_assign
l_int|NULL
suffix:semicolon
id|bio_endio
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
comma
id|uptodate
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
)paren
suffix:semicolon
id|bio
op_assign
id|next
suffix:semicolon
)brace
id|pkt-&gt;orig_bios
op_assign
id|pkt-&gt;orig_bios_tail
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|pkt_run_state_machine
r_static
r_void
id|pkt_run_state_machine
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_struct
id|packet_data
op_star
id|pkt
)paren
(brace
r_int
id|uptodate
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;run_state_machine: pkt %d&bslash;n&quot;
comma
id|pkt-&gt;id
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_switch
c_cond
(paren
id|pkt-&gt;state
)paren
(brace
r_case
id|PACKET_WAITING_STATE
suffix:colon
r_if
c_cond
(paren
(paren
id|pkt-&gt;write_size
OL
id|pkt-&gt;frames
)paren
op_logical_and
(paren
id|pkt-&gt;sleep_time
OG
l_int|0
)paren
)paren
r_return
suffix:semicolon
id|pkt-&gt;sleep_time
op_assign
l_int|0
suffix:semicolon
id|pkt_gather_data
c_func
(paren
id|pd
comma
id|pkt
)paren
suffix:semicolon
id|pkt_set_state
c_func
(paren
id|pkt
comma
id|PACKET_READ_WAIT_STATE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PACKET_READ_WAIT_STATE
suffix:colon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pkt-&gt;io_wait
)paren
OG
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pkt-&gt;io_errors
)paren
OG
l_int|0
)paren
(brace
id|pkt_set_state
c_func
(paren
id|pkt
comma
id|PACKET_RECOVERY_STATE
)paren
suffix:semicolon
)brace
r_else
(brace
id|pkt_start_write
c_func
(paren
id|pd
comma
id|pkt
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PACKET_WRITE_WAIT_STATE
suffix:colon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pkt-&gt;io_wait
)paren
OG
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|pkt-&gt;w_bio-&gt;bi_flags
)paren
)paren
(brace
id|pkt_set_state
c_func
(paren
id|pkt
comma
id|PACKET_FINISHED_STATE
)paren
suffix:semicolon
)brace
r_else
(brace
id|pkt_set_state
c_func
(paren
id|pkt
comma
id|PACKET_RECOVERY_STATE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PACKET_RECOVERY_STATE
suffix:colon
r_if
c_cond
(paren
id|pkt_start_recovery
c_func
(paren
id|pkt
)paren
)paren
(brace
id|pkt_start_write
c_func
(paren
id|pd
comma
id|pkt
)paren
suffix:semicolon
)brace
r_else
(brace
id|VPRINTK
c_func
(paren
l_string|&quot;No recovery possible&bslash;n&quot;
)paren
suffix:semicolon
id|pkt_set_state
c_func
(paren
id|pkt
comma
id|PACKET_FINISHED_STATE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PACKET_FINISHED_STATE
suffix:colon
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|pkt-&gt;w_bio-&gt;bi_flags
)paren
suffix:semicolon
id|pkt_finish_packet
c_func
(paren
id|pkt
comma
id|uptodate
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|function|pkt_handle_packets
r_static
r_void
id|pkt_handle_packets
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
)paren
(brace
r_struct
id|packet_data
op_star
id|pkt
comma
op_star
id|next
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;pkt_handle_packets&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Run state machine for active packets&n;&t; */
id|list_for_each_entry
c_func
(paren
id|pkt
comma
op_amp
id|pd-&gt;cdrw.pkt_active_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pkt-&gt;run_sm
)paren
OG
l_int|0
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|pkt-&gt;run_sm
comma
l_int|0
)paren
suffix:semicolon
id|pkt_run_state_machine
c_func
(paren
id|pd
comma
id|pkt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Move no longer active packets to the free list&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pd-&gt;cdrw.active_list_lock
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|pkt
comma
id|next
comma
op_amp
id|pd-&gt;cdrw.pkt_active_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|pkt-&gt;state
op_eq
id|PACKET_FINISHED_STATE
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|pkt-&gt;list
)paren
suffix:semicolon
id|pkt_put_packet_data
c_func
(paren
id|pd
comma
id|pkt
)paren
suffix:semicolon
id|pkt_set_state
c_func
(paren
id|pkt
comma
id|PACKET_IDLE_STATE
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pd-&gt;scan_queue
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pd-&gt;cdrw.active_list_lock
)paren
suffix:semicolon
)brace
DECL|function|pkt_count_states
r_static
r_void
id|pkt_count_states
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_int
op_star
id|states
)paren
(brace
r_struct
id|packet_data
op_star
id|pkt
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|PACKET_NUM_STATES
suffix:semicolon
id|i
op_increment
)paren
id|states
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pd-&gt;cdrw.active_list_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|pkt
comma
op_amp
id|pd-&gt;cdrw.pkt_active_list
comma
id|list
)paren
(brace
id|states
(braket
id|pkt-&gt;state
)braket
op_increment
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pd-&gt;cdrw.active_list_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * kcdrwd is woken up when writes have been queued for one of our&n; * registered devices&n; */
DECL|function|kcdrwd
r_static
r_int
id|kcdrwd
c_func
(paren
r_void
op_star
id|foobar
)paren
(brace
r_struct
id|pktcdvd_device
op_star
id|pd
op_assign
id|foobar
suffix:semicolon
r_struct
id|packet_data
op_star
id|pkt
suffix:semicolon
r_int
id|min_sleep_time
comma
id|residue
suffix:semicolon
id|set_user_nice
c_func
(paren
id|current
comma
op_minus
l_int|20
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait until there is something to do&n;&t;&t; */
id|add_wait_queue
c_func
(paren
op_amp
id|pd-&gt;wqueue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/* Check if we need to run pkt_handle_queue */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pd-&gt;scan_queue
)paren
OG
l_int|0
)paren
r_goto
id|work_to_do
suffix:semicolon
multiline_comment|/* Check if we need to run the state machine for some packet */
id|list_for_each_entry
c_func
(paren
id|pkt
comma
op_amp
id|pd-&gt;cdrw.pkt_active_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pkt-&gt;run_sm
)paren
OG
l_int|0
)paren
r_goto
id|work_to_do
suffix:semicolon
)brace
multiline_comment|/* Check if we need to process the iosched queues */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pd-&gt;iosched.attention
)paren
op_ne
l_int|0
)paren
r_goto
id|work_to_do
suffix:semicolon
multiline_comment|/* Otherwise, go to sleep */
r_if
c_cond
(paren
id|PACKET_DEBUG
OG
l_int|1
)paren
(brace
r_int
id|states
(braket
id|PACKET_NUM_STATES
)braket
suffix:semicolon
id|pkt_count_states
c_func
(paren
id|pd
comma
id|states
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;kcdrwd: i:%d ow:%d rw:%d ww:%d rec:%d fin:%d&bslash;n&quot;
comma
id|states
(braket
l_int|0
)braket
comma
id|states
(braket
l_int|1
)braket
comma
id|states
(braket
l_int|2
)braket
comma
id|states
(braket
l_int|3
)braket
comma
id|states
(braket
l_int|4
)braket
comma
id|states
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
id|min_sleep_time
op_assign
id|MAX_SCHEDULE_TIMEOUT
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|pkt
comma
op_amp
id|pd-&gt;cdrw.pkt_active_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|pkt-&gt;sleep_time
op_logical_and
id|pkt-&gt;sleep_time
OL
id|min_sleep_time
)paren
id|min_sleep_time
op_assign
id|pkt-&gt;sleep_time
suffix:semicolon
)brace
id|generic_unplug_device
c_func
(paren
id|bdev_get_queue
c_func
(paren
id|pd-&gt;bdev
)paren
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;kcdrwd: sleeping&bslash;n&quot;
)paren
suffix:semicolon
id|residue
op_assign
id|schedule_timeout
c_func
(paren
id|min_sleep_time
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;kcdrwd: wake up&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* make swsusp happy with our thread */
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
id|refrigerator
c_func
(paren
id|PF_FREEZE
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|pkt
comma
op_amp
id|pd-&gt;cdrw.pkt_active_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pkt-&gt;sleep_time
)paren
r_continue
suffix:semicolon
id|pkt-&gt;sleep_time
op_sub_assign
id|min_sleep_time
op_minus
id|residue
suffix:semicolon
r_if
c_cond
(paren
id|pkt-&gt;sleep_time
op_le
l_int|0
)paren
(brace
id|pkt-&gt;sleep_time
op_assign
l_int|0
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|pkt-&gt;run_sm
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kthread_should_stop
c_func
(paren
)paren
)paren
r_break
suffix:semicolon
)brace
id|work_to_do
suffix:colon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|pd-&gt;wqueue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kthread_should_stop
c_func
(paren
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if pkt_handle_queue returns true, we can queue&n;&t;&t; * another request.&n;&t;&t; */
r_while
c_loop
(paren
id|pkt_handle_queue
c_func
(paren
id|pd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Handle packet state machine&n;&t;&t; */
id|pkt_handle_packets
c_func
(paren
id|pd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Handle iosched queues&n;&t;&t; */
id|pkt_iosched_process_queue
c_func
(paren
id|pd
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pkt_print_settings
r_static
r_void
id|pkt_print_settings
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: %s packets, &quot;
comma
id|pd-&gt;settings.fp
ques
c_cond
l_string|&quot;Fixed&quot;
suffix:colon
l_string|&quot;Variable&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%u blocks, &quot;
comma
id|pd-&gt;settings.size
op_rshift
l_int|2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mode-%c disc&bslash;n&quot;
comma
id|pd-&gt;settings.block_mode
op_eq
l_int|8
ques
c_cond
l_char|&squot;1&squot;
suffix:colon
l_char|&squot;2&squot;
)paren
suffix:semicolon
)brace
DECL|function|pkt_mode_sense
r_static
r_int
id|pkt_mode_sense
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_struct
id|packet_command
op_star
id|cgc
comma
r_int
id|page_code
comma
r_int
id|page_control
)paren
(brace
id|memset
c_func
(paren
id|cgc-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|cgc-&gt;cmd
)paren
)paren
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_MODE_SENSE_10
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|2
)braket
op_assign
id|page_code
op_or
(paren
id|page_control
op_lshift
l_int|6
)paren
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|7
)braket
op_assign
id|cgc-&gt;buflen
op_rshift
l_int|8
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|8
)braket
op_assign
id|cgc-&gt;buflen
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;data_direction
op_assign
id|CGC_DATA_READ
suffix:semicolon
r_return
id|pkt_generic_packet
c_func
(paren
id|pd
comma
id|cgc
)paren
suffix:semicolon
)brace
DECL|function|pkt_mode_select
r_static
r_int
id|pkt_mode_select
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_struct
id|packet_command
op_star
id|cgc
)paren
(brace
id|memset
c_func
(paren
id|cgc-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|cgc-&gt;cmd
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cgc-&gt;buffer
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_MODE_SELECT_10
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* PF */
id|cgc-&gt;cmd
(braket
l_int|7
)braket
op_assign
id|cgc-&gt;buflen
op_rshift
l_int|8
suffix:semicolon
id|cgc-&gt;cmd
(braket
l_int|8
)braket
op_assign
id|cgc-&gt;buflen
op_amp
l_int|0xff
suffix:semicolon
id|cgc-&gt;data_direction
op_assign
id|CGC_DATA_WRITE
suffix:semicolon
r_return
id|pkt_generic_packet
c_func
(paren
id|pd
comma
id|cgc
)paren
suffix:semicolon
)brace
DECL|function|pkt_get_disc_info
r_static
r_int
id|pkt_get_disc_info
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
id|disc_information
op_star
id|di
)paren
(brace
r_struct
id|packet_command
id|cgc
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* set up command and get the disc info */
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|di
comma
r_sizeof
(paren
op_star
id|di
)paren
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_DISC_INFO
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|cgc.buflen
op_assign
l_int|2
suffix:semicolon
id|cgc.quiet
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_generic_packet
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* not all drives have the same disc_info length, so requeue&n;&t; * packet with the length the drive tells us it can supply&n;&t; */
id|cgc.buflen
op_assign
id|be16_to_cpu
c_func
(paren
id|di-&gt;disc_information_length
)paren
op_plus
r_sizeof
(paren
id|di-&gt;disc_information_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cgc.buflen
OG
r_sizeof
(paren
id|disc_information
)paren
)paren
id|cgc.buflen
op_assign
r_sizeof
(paren
id|disc_information
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|cgc.buflen
suffix:semicolon
r_return
id|pkt_generic_packet
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
DECL|function|pkt_get_track_info
r_static
r_int
id|pkt_get_track_info
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
id|__u16
id|track
comma
id|__u8
id|type
comma
id|track_information
op_star
id|ti
)paren
(brace
r_struct
id|packet_command
id|cgc
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|ti
comma
l_int|8
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_TRACK_RZONE_INFO
suffix:semicolon
id|cgc.cmd
(braket
l_int|1
)braket
op_assign
id|type
op_amp
l_int|3
suffix:semicolon
id|cgc.cmd
(braket
l_int|4
)braket
op_assign
(paren
id|track
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
suffix:semicolon
id|cgc.cmd
(braket
l_int|5
)braket
op_assign
id|track
op_amp
l_int|0xff
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
l_int|8
suffix:semicolon
id|cgc.quiet
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_generic_packet
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|cgc.buflen
op_assign
id|be16_to_cpu
c_func
(paren
id|ti-&gt;track_information_length
)paren
op_plus
r_sizeof
(paren
id|ti-&gt;track_information_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cgc.buflen
OG
r_sizeof
(paren
id|track_information
)paren
)paren
id|cgc.buflen
op_assign
r_sizeof
(paren
id|track_information
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|cgc.buflen
suffix:semicolon
r_return
id|pkt_generic_packet
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
DECL|function|pkt_get_last_written
r_static
r_int
id|pkt_get_last_written
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_int
op_star
id|last_written
)paren
(brace
id|disc_information
id|di
suffix:semicolon
id|track_information
id|ti
suffix:semicolon
id|__u32
id|last_track
suffix:semicolon
r_int
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_get_disc_info
c_func
(paren
id|pd
comma
op_amp
id|di
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|last_track
op_assign
(paren
id|di.last_track_msb
op_lshift
l_int|8
)paren
op_or
id|di.last_track_lsb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_get_track_info
c_func
(paren
id|pd
comma
id|last_track
comma
l_int|1
comma
op_amp
id|ti
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* if this track is blank, try the previous. */
r_if
c_cond
(paren
id|ti.blank
)paren
(brace
id|last_track
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_get_track_info
c_func
(paren
id|pd
comma
id|last_track
comma
l_int|1
comma
op_amp
id|ti
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* if last recorded field is valid, return it. */
r_if
c_cond
(paren
id|ti.lra_v
)paren
(brace
op_star
id|last_written
op_assign
id|be32_to_cpu
c_func
(paren
id|ti.last_rec_address
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* make it up instead */
op_star
id|last_written
op_assign
id|be32_to_cpu
c_func
(paren
id|ti.track_start
)paren
op_plus
id|be32_to_cpu
c_func
(paren
id|ti.track_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti.free_blocks
)paren
op_star
id|last_written
op_sub_assign
(paren
id|be32_to_cpu
c_func
(paren
id|ti.free_blocks
)paren
op_plus
l_int|7
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * write mode select package based on pd-&gt;settings&n; */
DECL|function|pkt_set_write_settings
r_static
r_int
id|pkt_set_write_settings
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
)paren
(brace
r_struct
id|packet_command
id|cgc
suffix:semicolon
r_struct
id|request_sense
id|sense
suffix:semicolon
id|write_param_page
op_star
id|wp
suffix:semicolon
r_char
id|buffer
(braket
l_int|128
)braket
suffix:semicolon
r_int
id|ret
comma
id|size
suffix:semicolon
multiline_comment|/* doesn&squot;t apply to DVD+RW */
r_if
c_cond
(paren
id|pd-&gt;mmc3_profile
op_eq
l_int|0x1a
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
r_sizeof
(paren
id|buffer
)paren
)paren
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buffer
comma
r_sizeof
(paren
op_star
id|wp
)paren
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.sense
op_assign
op_amp
id|sense
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_mode_sense
c_func
(paren
id|pd
comma
op_amp
id|cgc
comma
id|GPMODE_WRITE_PARMS_PAGE
comma
l_int|0
)paren
)paren
)paren
(brace
id|pkt_dump_sense
c_func
(paren
op_amp
id|cgc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|size
op_assign
l_int|2
op_plus
(paren
(paren
id|buffer
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|buffer
(braket
l_int|1
)braket
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|pd-&gt;mode_offset
op_assign
(paren
id|buffer
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|buffer
(braket
l_int|7
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
r_sizeof
(paren
id|buffer
)paren
)paren
id|size
op_assign
r_sizeof
(paren
id|buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now get it all&n;&t; */
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buffer
comma
id|size
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.sense
op_assign
op_amp
id|sense
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_mode_sense
c_func
(paren
id|pd
comma
op_amp
id|cgc
comma
id|GPMODE_WRITE_PARMS_PAGE
comma
l_int|0
)paren
)paren
)paren
(brace
id|pkt_dump_sense
c_func
(paren
op_amp
id|cgc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * write page is offset header + block descriptor length&n;&t; */
id|wp
op_assign
(paren
id|write_param_page
op_star
)paren
op_amp
id|buffer
(braket
r_sizeof
(paren
r_struct
id|mode_page_header
)paren
op_plus
id|pd-&gt;mode_offset
)braket
suffix:semicolon
id|wp-&gt;fp
op_assign
id|pd-&gt;settings.fp
suffix:semicolon
id|wp-&gt;track_mode
op_assign
id|pd-&gt;settings.track_mode
suffix:semicolon
id|wp-&gt;write_type
op_assign
id|pd-&gt;settings.write_type
suffix:semicolon
id|wp-&gt;data_block_type
op_assign
id|pd-&gt;settings.block_mode
suffix:semicolon
id|wp-&gt;multi_session
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef PACKET_USE_LS
id|wp-&gt;link_size
op_assign
l_int|7
suffix:semicolon
id|wp-&gt;ls_v
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|wp-&gt;data_block_type
op_eq
id|PACKET_BLOCK_MODE1
)paren
(brace
id|wp-&gt;session_format
op_assign
l_int|0
suffix:semicolon
id|wp-&gt;subhdr2
op_assign
l_int|0x20
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|wp-&gt;data_block_type
op_eq
id|PACKET_BLOCK_MODE2
)paren
(brace
id|wp-&gt;session_format
op_assign
l_int|0x20
suffix:semicolon
id|wp-&gt;subhdr2
op_assign
l_int|8
suffix:semicolon
macro_line|#if 0
id|wp-&gt;mcn
(braket
l_int|0
)braket
op_assign
l_int|0x80
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|wp-&gt;mcn
(braket
l_int|1
)braket
comma
id|PACKET_MCN
comma
r_sizeof
(paren
id|wp-&gt;mcn
)paren
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * paranoia&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;pktcdvd: write mode wrong %d&bslash;n&quot;
comma
id|wp-&gt;data_block_type
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|wp-&gt;packet_size
op_assign
id|cpu_to_be32
c_func
(paren
id|pd-&gt;settings.size
op_rshift
l_int|2
)paren
suffix:semicolon
id|cgc.buflen
op_assign
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_mode_select
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
)paren
)paren
(brace
id|pkt_dump_sense
c_func
(paren
op_amp
id|cgc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|pkt_print_settings
c_func
(paren
id|pd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * 0 -- we can write to this track, 1 -- we can&squot;t&n; */
DECL|function|pkt_good_track
r_static
r_int
id|pkt_good_track
c_func
(paren
id|track_information
op_star
id|ti
)paren
(brace
multiline_comment|/*&n;&t; * only good for CD-RW at the moment, not DVD-RW&n;&t; */
multiline_comment|/*&n;&t; * FIXME: only for FP&n;&t; */
r_if
c_cond
(paren
id|ti-&gt;fp
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;good&quot; settings as per Mt Fuji.&n;&t; */
r_if
c_cond
(paren
id|ti-&gt;rt
op_eq
l_int|0
op_logical_and
id|ti-&gt;blank
op_eq
l_int|0
op_logical_and
id|ti-&gt;packet
op_eq
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ti-&gt;rt
op_eq
l_int|0
op_logical_and
id|ti-&gt;blank
op_eq
l_int|1
op_logical_and
id|ti-&gt;packet
op_eq
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ti-&gt;rt
op_eq
l_int|1
op_logical_and
id|ti-&gt;blank
op_eq
l_int|0
op_logical_and
id|ti-&gt;packet
op_eq
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pktcdvd: bad state %d-%d-%d&bslash;n&quot;
comma
id|ti-&gt;rt
comma
id|ti-&gt;blank
comma
id|ti-&gt;packet
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * 0 -- we can write to this disc, 1 -- we can&squot;t&n; */
DECL|function|pkt_good_disc
r_static
r_int
id|pkt_good_disc
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
id|disc_information
op_star
id|di
)paren
(brace
r_switch
c_cond
(paren
id|pd-&gt;mmc3_profile
)paren
(brace
r_case
l_int|0x0a
suffix:colon
multiline_comment|/* CD-RW */
r_case
l_int|0xffff
suffix:colon
multiline_comment|/* MMC3 not supported */
r_break
suffix:semicolon
r_case
l_int|0x1a
suffix:colon
multiline_comment|/* DVD+RW */
r_case
l_int|0x13
suffix:colon
multiline_comment|/* DVD-RW */
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Wrong disc profile (%x)&bslash;n&quot;
comma
id|pd-&gt;mmc3_profile
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * for disc type 0xff we should probably reserve a new track.&n;&t; * but i&squot;m not sure, should we leave this to user apps? probably.&n;&t; */
r_if
c_cond
(paren
id|di-&gt;disc_type
op_eq
l_int|0xff
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Unknown disc. No track?&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|di-&gt;disc_type
op_ne
l_int|0x20
op_logical_and
id|di-&gt;disc_type
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Wrong disc type (%x)&bslash;n&quot;
comma
id|di-&gt;disc_type
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|di-&gt;erasable
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Disc not erasable&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|di-&gt;border_status
op_eq
id|PACKET_SESSION_RESERVED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Can&squot;t write to last track (reserved)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pkt_probe_settings
r_static
r_int
id|pkt_probe_settings
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
)paren
(brace
r_struct
id|packet_command
id|cgc
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|12
)braket
suffix:semicolon
id|disc_information
id|di
suffix:semicolon
id|track_information
id|ti
suffix:semicolon
r_int
id|ret
comma
id|track
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_GET_CONFIGURATION
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
l_int|8
suffix:semicolon
id|ret
op_assign
id|pkt_generic_packet
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
suffix:semicolon
id|pd-&gt;mmc3_profile
op_assign
id|ret
ques
c_cond
l_int|0xffff
suffix:colon
id|buf
(braket
l_int|6
)braket
op_lshift
l_int|8
op_or
id|buf
(braket
l_int|7
)braket
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|di
comma
l_int|0
comma
r_sizeof
(paren
id|disc_information
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ti
comma
l_int|0
comma
r_sizeof
(paren
id|track_information
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_get_disc_info
c_func
(paren
id|pd
comma
op_amp
id|di
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;failed get_disc&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pkt_good_disc
c_func
(paren
id|pd
comma
op_amp
id|di
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_switch
c_cond
(paren
id|pd-&gt;mmc3_profile
)paren
(brace
r_case
l_int|0x1a
suffix:colon
multiline_comment|/* DVD+RW */
id|printk
c_func
(paren
l_string|&quot;pktcdvd: inserted media is DVD+RW&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x13
suffix:colon
multiline_comment|/* DVD-RW */
id|printk
c_func
(paren
l_string|&quot;pktcdvd: inserted media is DVD-RW&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;pktcdvd: inserted media is CD-R%s&bslash;n&quot;
comma
id|di.erasable
ques
c_cond
l_string|&quot;W&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pd-&gt;type
op_assign
id|di.erasable
ques
c_cond
id|PACKET_CDRW
suffix:colon
id|PACKET_CDR
suffix:semicolon
id|track
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* (di.last_track_msb &lt;&lt; 8) | di.last_track_lsb; */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_get_track_info
c_func
(paren
id|pd
comma
id|track
comma
l_int|1
comma
op_amp
id|ti
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: failed get_track&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pkt_good_track
c_func
(paren
op_amp
id|ti
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: can&squot;t write to this track&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we keep packet size in 512 byte units, makes it easier to&n;&t; * deal with request calculations.&n;&t; */
id|pd-&gt;settings.size
op_assign
id|be32_to_cpu
c_func
(paren
id|ti.fixed_packet_size
)paren
op_lshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;settings.size
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: detected zero packet size!&bslash;n&quot;
)paren
suffix:semicolon
id|pd-&gt;settings.size
op_assign
l_int|128
suffix:semicolon
)brace
id|pd-&gt;settings.fp
op_assign
id|ti.fp
suffix:semicolon
id|pd-&gt;offset
op_assign
(paren
id|be32_to_cpu
c_func
(paren
id|ti.track_start
)paren
op_lshift
l_int|2
)paren
op_amp
(paren
id|pd-&gt;settings.size
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti.nwa_v
)paren
(brace
id|pd-&gt;nwa
op_assign
id|be32_to_cpu
c_func
(paren
id|ti.next_writable
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PACKET_NWA_VALID
comma
op_amp
id|pd-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * in theory we could use lra on -RW media as well and just zero&n;&t; * blocks that haven&squot;t been written yet, but in practice that&n;&t; * is just a no-go. we&squot;ll use that for -R, naturally.&n;&t; */
r_if
c_cond
(paren
id|ti.lra_v
)paren
(brace
id|pd-&gt;lra
op_assign
id|be32_to_cpu
c_func
(paren
id|ti.last_rec_address
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PACKET_LRA_VALID
comma
op_amp
id|pd-&gt;flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|pd-&gt;lra
op_assign
l_int|0xffffffff
suffix:semicolon
id|set_bit
c_func
(paren
id|PACKET_LRA_VALID
comma
op_amp
id|pd-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * fine for now&n;&t; */
id|pd-&gt;settings.link_loss
op_assign
l_int|7
suffix:semicolon
id|pd-&gt;settings.write_type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* packet */
id|pd-&gt;settings.track_mode
op_assign
id|ti.track_mode
suffix:semicolon
multiline_comment|/*&n;&t; * mode1 or mode2 disc&n;&t; */
r_switch
c_cond
(paren
id|ti.data_mode
)paren
(brace
r_case
id|PACKET_MODE1
suffix:colon
id|pd-&gt;settings.block_mode
op_assign
id|PACKET_BLOCK_MODE1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PACKET_MODE2
suffix:colon
id|pd-&gt;settings.block_mode
op_assign
id|PACKET_BLOCK_MODE2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;pktcdvd: unknown data mode&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * enable/disable write caching on drive&n; */
DECL|function|pkt_write_caching
r_static
r_int
id|pkt_write_caching
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_int
id|set
)paren
(brace
r_struct
id|packet_command
id|cgc
suffix:semicolon
r_struct
id|request_sense
id|sense
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.sense
op_assign
op_amp
id|sense
suffix:semicolon
id|cgc.buflen
op_assign
id|pd-&gt;mode_offset
op_plus
l_int|12
suffix:semicolon
multiline_comment|/*&n;&t; * caching mode page might not be there, so quiet this command&n;&t; */
id|cgc.quiet
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_mode_sense
c_func
(paren
id|pd
comma
op_amp
id|cgc
comma
id|GPMODE_WCACHING_PAGE
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|buf
(braket
id|pd-&gt;mode_offset
op_plus
l_int|10
)braket
op_or_assign
(paren
op_logical_neg
op_logical_neg
id|set
op_lshift
l_int|2
)paren
suffix:semicolon
id|cgc.buflen
op_assign
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
l_int|2
op_plus
(paren
(paren
id|buf
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|buf
(braket
l_int|1
)braket
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|pkt_mode_select
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: write caching control failed&bslash;n&quot;
)paren
suffix:semicolon
id|pkt_dump_sense
c_func
(paren
op_amp
id|cgc
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|set
)paren
id|printk
c_func
(paren
l_string|&quot;pktcdvd: enabled write caching on %s&bslash;n&quot;
comma
id|pd-&gt;name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|pkt_lock_door
r_static
r_int
id|pkt_lock_door
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_int
id|lockflag
)paren
(brace
r_struct
id|packet_command
id|cgc
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
l_int|NULL
comma
l_int|0
comma
id|CGC_DATA_NONE
)paren
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL
suffix:semicolon
id|cgc.cmd
(braket
l_int|4
)braket
op_assign
id|lockflag
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_return
id|pkt_generic_packet
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns drive maximum write speed&n; */
DECL|function|pkt_get_max_speed
r_static
r_int
id|pkt_get_max_speed
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_int
op_star
id|write_speed
)paren
(brace
r_struct
id|packet_command
id|cgc
suffix:semicolon
r_struct
id|request_sense
id|sense
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|256
op_plus
l_int|18
)braket
suffix:semicolon
r_int
r_char
op_star
id|cap_buf
suffix:semicolon
r_int
id|ret
comma
id|offset
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
id|cap_buf
op_assign
op_amp
id|buf
(braket
r_sizeof
(paren
r_struct
id|mode_page_header
)paren
op_plus
id|pd-&gt;mode_offset
)braket
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|CGC_DATA_UNKNOWN
)paren
suffix:semicolon
id|cgc.sense
op_assign
op_amp
id|sense
suffix:semicolon
id|ret
op_assign
id|pkt_mode_sense
c_func
(paren
id|pd
comma
op_amp
id|cgc
comma
id|GPMODE_CAPABILITIES_PAGE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|cgc.buflen
op_assign
id|pd-&gt;mode_offset
op_plus
id|cap_buf
(braket
l_int|1
)braket
op_plus
l_int|2
op_plus
r_sizeof
(paren
r_struct
id|mode_page_header
)paren
suffix:semicolon
id|ret
op_assign
id|pkt_mode_sense
c_func
(paren
id|pd
comma
op_amp
id|cgc
comma
id|GPMODE_CAPABILITIES_PAGE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|pkt_dump_sense
c_func
(paren
op_amp
id|cgc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
id|offset
op_assign
l_int|20
suffix:semicolon
multiline_comment|/* Obsoleted field, used by older drives */
r_if
c_cond
(paren
id|cap_buf
(braket
l_int|1
)braket
op_ge
l_int|28
)paren
id|offset
op_assign
l_int|28
suffix:semicolon
multiline_comment|/* Current write speed selected */
r_if
c_cond
(paren
id|cap_buf
(braket
l_int|1
)braket
op_ge
l_int|30
)paren
(brace
multiline_comment|/* If the drive reports at least one &quot;Logical Unit Write&n;&t;&t; * Speed Performance Descriptor Block&quot;, use the information&n;&t;&t; * in the first block. (contains the highest speed)&n;&t;&t; */
r_int
id|num_spdb
op_assign
(paren
id|cap_buf
(braket
l_int|30
)braket
op_lshift
l_int|8
)paren
op_plus
id|cap_buf
(braket
l_int|31
)braket
suffix:semicolon
r_if
c_cond
(paren
id|num_spdb
OG
l_int|0
)paren
id|offset
op_assign
l_int|34
suffix:semicolon
)brace
op_star
id|write_speed
op_assign
(paren
id|cap_buf
(braket
id|offset
)braket
op_lshift
l_int|8
)paren
op_or
id|cap_buf
(braket
id|offset
op_plus
l_int|1
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* These tables from cdrecord - I don&squot;t have orange book */
multiline_comment|/* standard speed CD-RW (1-4x) */
DECL|variable|clv_to_speed
r_static
r_char
id|clv_to_speed
(braket
l_int|16
)braket
op_assign
(brace
multiline_comment|/* 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 */
l_int|0
comma
l_int|2
comma
l_int|4
comma
l_int|6
comma
l_int|8
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* high speed CD-RW (-10x) */
DECL|variable|hs_clv_to_speed
r_static
r_char
id|hs_clv_to_speed
(braket
l_int|16
)braket
op_assign
(brace
multiline_comment|/* 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 */
l_int|0
comma
l_int|2
comma
l_int|4
comma
l_int|6
comma
l_int|10
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* ultra high speed CD-RW */
DECL|variable|us_clv_to_speed
r_static
r_char
id|us_clv_to_speed
(braket
l_int|16
)braket
op_assign
(brace
multiline_comment|/* 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 */
l_int|0
comma
l_int|2
comma
l_int|4
comma
l_int|8
comma
l_int|0
comma
l_int|0
comma
l_int|16
comma
l_int|0
comma
l_int|24
comma
l_int|32
comma
l_int|40
comma
l_int|48
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * reads the maximum media speed from ATIP&n; */
DECL|function|pkt_media_speed
r_static
r_int
id|pkt_media_speed
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_int
op_star
id|speed
)paren
(brace
r_struct
id|packet_command
id|cgc
suffix:semicolon
r_struct
id|request_sense
id|sense
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_int
id|size
comma
id|st
comma
id|sp
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buf
comma
l_int|2
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.sense
op_assign
op_amp
id|sense
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_TOC_PMA_ATIP
suffix:semicolon
id|cgc.cmd
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|cgc.cmd
(braket
l_int|2
)braket
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* READ ATIP */
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
l_int|2
suffix:semicolon
id|ret
op_assign
id|pkt_generic_packet
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|pkt_dump_sense
c_func
(paren
op_amp
id|cgc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|size
op_assign
(paren
(paren
r_int
r_int
)paren
id|buf
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|buf
(braket
l_int|1
)braket
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
r_sizeof
(paren
id|buf
)paren
)paren
id|size
op_assign
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buf
comma
id|size
comma
id|CGC_DATA_READ
)paren
suffix:semicolon
id|cgc.sense
op_assign
op_amp
id|sense
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_TOC_PMA_ATIP
suffix:semicolon
id|cgc.cmd
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|cgc.cmd
(braket
l_int|2
)braket
op_assign
l_int|4
suffix:semicolon
id|cgc.cmd
(braket
l_int|8
)braket
op_assign
id|size
suffix:semicolon
id|ret
op_assign
id|pkt_generic_packet
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|pkt_dump_sense
c_func
(paren
op_amp
id|cgc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buf
(braket
l_int|6
)braket
op_amp
l_int|0x40
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Disc type is not CD-RW&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buf
(braket
l_int|6
)braket
op_amp
l_int|0x4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: A1 values on media are not valid, maybe not CDRW?&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|st
op_assign
(paren
id|buf
(braket
l_int|6
)braket
op_rshift
l_int|3
)paren
op_amp
l_int|0x7
suffix:semicolon
multiline_comment|/* disc sub-type */
id|sp
op_assign
id|buf
(braket
l_int|16
)braket
op_amp
l_int|0xf
suffix:semicolon
multiline_comment|/* max speed from ATIP A1 field */
multiline_comment|/* Info from cdrecord */
r_switch
c_cond
(paren
id|st
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* standard speed */
op_star
id|speed
op_assign
id|clv_to_speed
(braket
id|sp
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* high speed */
op_star
id|speed
op_assign
id|hs_clv_to_speed
(braket
id|sp
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* ultra high speed */
op_star
id|speed
op_assign
id|us_clv_to_speed
(braket
id|sp
)braket
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Unknown disc sub-type %d&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|speed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Max. media speed: %d&bslash;n&quot;
comma
op_star
id|speed
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Unknown speed %d for sub-type %d&bslash;n&quot;
comma
id|sp
comma
id|st
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|pkt_perform_opc
r_static
r_int
id|pkt_perform_opc
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
)paren
(brace
r_struct
id|packet_command
id|cgc
suffix:semicolon
r_struct
id|request_sense
id|sense
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;pktcdvd: Performing OPC&bslash;n&quot;
)paren
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
l_int|NULL
comma
l_int|0
comma
id|CGC_DATA_NONE
)paren
suffix:semicolon
id|cgc.sense
op_assign
op_amp
id|sense
suffix:semicolon
id|cgc.timeout
op_assign
l_int|60
op_star
id|HZ
suffix:semicolon
id|cgc.cmd
(braket
l_int|0
)braket
op_assign
id|GPCMD_SEND_OPC
suffix:semicolon
id|cgc.cmd
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_generic_packet
c_func
(paren
id|pd
comma
op_amp
id|cgc
)paren
)paren
)paren
id|pkt_dump_sense
c_func
(paren
op_amp
id|cgc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|pkt_open_write
r_static
r_int
id|pkt_open_write
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_int
id|write_speed
comma
id|media_write_speed
comma
id|read_speed
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_probe_settings
c_func
(paren
id|pd
)paren
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;pktcdvd: %s failed probe&bslash;n&quot;
comma
id|pd-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_set_write_settings
c_func
(paren
id|pd
)paren
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;pktcdvd: %s failed saving write settings&bslash;n&quot;
comma
id|pd-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|pkt_write_caching
c_func
(paren
id|pd
comma
id|USE_WCACHING
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_get_max_speed
c_func
(paren
id|pd
comma
op_amp
id|write_speed
)paren
)paren
)paren
id|write_speed
op_assign
l_int|16
op_star
l_int|177
suffix:semicolon
r_switch
c_cond
(paren
id|pd-&gt;mmc3_profile
)paren
(brace
r_case
l_int|0x13
suffix:colon
multiline_comment|/* DVD-RW */
r_case
l_int|0x1a
suffix:colon
multiline_comment|/* DVD+RW */
id|DPRINTK
c_func
(paren
l_string|&quot;pktcdvd: write speed %ukB/s&bslash;n&quot;
comma
id|write_speed
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_media_speed
c_func
(paren
id|pd
comma
op_amp
id|media_write_speed
)paren
)paren
)paren
id|media_write_speed
op_assign
l_int|16
suffix:semicolon
id|write_speed
op_assign
id|min
c_func
(paren
id|write_speed
comma
id|media_write_speed
op_star
l_int|177
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;pktcdvd: write speed %ux&bslash;n&quot;
comma
id|write_speed
op_div
l_int|176
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|read_speed
op_assign
id|write_speed
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_set_speed
c_func
(paren
id|pd
comma
id|write_speed
comma
id|read_speed
)paren
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;pktcdvd: %s couldn&squot;t set write speed&bslash;n&quot;
comma
id|pd-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|pd-&gt;write_speed
op_assign
id|write_speed
suffix:semicolon
id|pd-&gt;read_speed
op_assign
id|read_speed
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_perform_opc
c_func
(paren
id|pd
)paren
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;pktcdvd: %s Optimum Power Calibration failed&bslash;n&quot;
comma
id|pd-&gt;name
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * called at open time.&n; */
DECL|function|pkt_open_dev
r_static
r_int
id|pkt_open_dev
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_int
id|write
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|lba
suffix:semicolon
id|request_queue_t
op_star
id|q
suffix:semicolon
multiline_comment|/*&n;&t; * We need to re-open the cdrom device without O_NONBLOCK to be able&n;&t; * to read/write from/to it. It is already opened in O_NONBLOCK mode&n;&t; * so bdget() can&squot;t fail.&n;&t; */
id|bdget
c_func
(paren
id|pd-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|blkdev_get
c_func
(paren
id|pd-&gt;bdev
comma
id|FMODE_READ
comma
id|O_RDONLY
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_get_last_written
c_func
(paren
id|pd
comma
op_amp
id|lba
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: pkt_get_last_written failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_putdev
suffix:semicolon
)brace
id|set_capacity
c_func
(paren
id|pd-&gt;disk
comma
id|lba
op_lshift
l_int|2
)paren
suffix:semicolon
id|set_capacity
c_func
(paren
id|pd-&gt;bdev-&gt;bd_disk
comma
id|lba
op_lshift
l_int|2
)paren
suffix:semicolon
id|bd_set_size
c_func
(paren
id|pd-&gt;bdev
comma
(paren
id|loff_t
)paren
id|lba
op_lshift
l_int|11
)paren
suffix:semicolon
id|q
op_assign
id|bdev_get_queue
c_func
(paren
id|pd-&gt;bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_open_write
c_func
(paren
id|pd
)paren
)paren
)paren
r_goto
id|out_putdev
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Some CDRW drives can not handle writes larger than one packet,&n;&t;&t; * even if the size is a multiple of the packet size.&n;&t;&t; */
id|spin_lock_irq
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|q
comma
id|pd-&gt;settings.size
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PACKET_WRITABLE
comma
op_amp
id|pd-&gt;flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|pkt_set_speed
c_func
(paren
id|pd
comma
id|MAX_SPEED
comma
id|MAX_SPEED
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|PACKET_WRITABLE
comma
op_amp
id|pd-&gt;flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|pkt_set_segment_merging
c_func
(paren
id|pd
comma
id|q
)paren
)paren
)paren
r_goto
id|out_putdev
suffix:semicolon
r_if
c_cond
(paren
id|write
)paren
id|printk
c_func
(paren
l_string|&quot;pktcdvd: %lukB available on disc&bslash;n&quot;
comma
id|lba
op_lshift
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_putdev
suffix:colon
id|blkdev_put
c_func
(paren
id|pd-&gt;bdev
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * called when the device is closed. makes sure that the device flushes&n; * the internal cache before we close.&n; */
DECL|function|pkt_release_dev
r_static
r_void
id|pkt_release_dev
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
r_int
id|flush
)paren
(brace
r_if
c_cond
(paren
id|flush
op_logical_and
id|pkt_flush_cache
c_func
(paren
id|pd
)paren
)paren
id|DPRINTK
c_func
(paren
l_string|&quot;pktcdvd: %s not flushing cache&bslash;n&quot;
comma
id|pd-&gt;name
)paren
suffix:semicolon
id|pkt_lock_door
c_func
(paren
id|pd
comma
l_int|0
)paren
suffix:semicolon
id|pkt_set_speed
c_func
(paren
id|pd
comma
id|MAX_SPEED
comma
id|MAX_SPEED
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|pd-&gt;bdev
)paren
suffix:semicolon
)brace
DECL|function|pkt_find_dev_from_minor
r_static
r_struct
id|pktcdvd_device
op_star
id|pkt_find_dev_from_minor
c_func
(paren
r_int
id|dev_minor
)paren
(brace
r_if
c_cond
(paren
id|dev_minor
op_ge
id|MAX_WRITERS
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|pkt_devs
(braket
id|dev_minor
)braket
suffix:semicolon
)brace
DECL|function|pkt_open
r_static
r_int
id|pkt_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|pktcdvd_device
op_star
id|pd
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;pktcdvd: entering open&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ctl_mutex
)paren
suffix:semicolon
id|pd
op_assign
id|pkt_find_dev_from_minor
c_func
(paren
id|iminor
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pd
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|pd-&gt;refcnt
OL
l_int|0
)paren
suffix:semicolon
id|pd-&gt;refcnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;refcnt
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|pkt_open_dev
c_func
(paren
id|pd
comma
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out_dec
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * needed here as well, since ext2 (among others) may change&n;&t;&t; * the blocksize at mount time&n;&t;&t; */
id|set_blocksize
c_func
(paren
id|inode-&gt;i_bdev
comma
id|CD_FRAMESIZE
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ctl_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_dec
suffix:colon
id|pd-&gt;refcnt
op_decrement
suffix:semicolon
id|out
suffix:colon
id|VPRINTK
c_func
(paren
l_string|&quot;pktcdvd: failed open (%d)&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctl_mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|pkt_close
r_static
r_int
id|pkt_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|pktcdvd_device
op_star
id|pd
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ctl_mutex
)paren
suffix:semicolon
id|pd-&gt;refcnt
op_decrement
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pd-&gt;refcnt
OL
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;refcnt
op_eq
l_int|0
)paren
(brace
r_int
id|flush
op_assign
id|test_bit
c_func
(paren
id|PACKET_WRITABLE
comma
op_amp
id|pd-&gt;flags
)paren
suffix:semicolon
id|pkt_release_dev
c_func
(paren
id|pd
comma
id|flush
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ctl_mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|psd_pool_alloc
r_static
r_void
op_star
id|psd_pool_alloc
c_func
(paren
r_int
id|gfp_mask
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|packet_stacked_data
)paren
comma
id|gfp_mask
)paren
suffix:semicolon
)brace
DECL|function|psd_pool_free
r_static
r_void
id|psd_pool_free
c_func
(paren
r_void
op_star
id|ptr
comma
r_void
op_star
id|data
)paren
(brace
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
DECL|function|pkt_end_io_read_cloned
r_static
r_int
id|pkt_end_io_read_cloned
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|err
)paren
(brace
r_struct
id|packet_stacked_data
op_star
id|psd
op_assign
id|bio-&gt;bi_private
suffix:semicolon
r_struct
id|pktcdvd_device
op_star
id|pd
op_assign
id|psd-&gt;pd
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
id|bio_endio
c_func
(paren
id|psd-&gt;bio
comma
id|psd-&gt;bio-&gt;bi_size
comma
id|err
)paren
suffix:semicolon
id|mempool_free
c_func
(paren
id|psd
comma
id|psd_pool
)paren
suffix:semicolon
id|pkt_bio_finished
c_func
(paren
id|pd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pkt_make_request
r_static
r_int
id|pkt_make_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|pktcdvd_device
op_star
id|pd
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|sector_t
id|zone
suffix:semicolon
r_struct
id|packet_data
op_star
id|pkt
suffix:semicolon
r_int
id|was_empty
comma
id|blocked_bio
suffix:semicolon
r_struct
id|pkt_rb_node
op_star
id|node
suffix:semicolon
id|pd
op_assign
id|q-&gt;queuedata
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: %s incorrect request queue&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|bio-&gt;bi_bdev
comma
id|b
)paren
)paren
suffix:semicolon
r_goto
id|end_io
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clone READ bios so we can have our own bi_end_io callback.&n;&t; */
r_if
c_cond
(paren
id|bio_data_dir
c_func
(paren
id|bio
)paren
op_eq
id|READ
)paren
(brace
r_struct
id|bio
op_star
id|cloned_bio
op_assign
id|bio_clone
c_func
(paren
id|bio
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_struct
id|packet_stacked_data
op_star
id|psd
op_assign
id|mempool_alloc
c_func
(paren
id|psd_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|psd-&gt;pd
op_assign
id|pd
suffix:semicolon
id|psd-&gt;bio
op_assign
id|bio
suffix:semicolon
id|cloned_bio-&gt;bi_bdev
op_assign
id|pd-&gt;bdev
suffix:semicolon
id|cloned_bio-&gt;bi_private
op_assign
id|psd
suffix:semicolon
id|cloned_bio-&gt;bi_end_io
op_assign
id|pkt_end_io_read_cloned
suffix:semicolon
id|pd-&gt;stats.secs_r
op_add_assign
id|bio-&gt;bi_size
op_rshift
l_int|9
suffix:semicolon
id|pkt_queue_bio
c_func
(paren
id|pd
comma
id|cloned_bio
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|PACKET_WRITABLE
comma
op_amp
id|pd-&gt;flags
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: WRITE for ro device %s (%llu)&bslash;n&quot;
comma
id|pd-&gt;name
comma
(paren
r_int
r_int
r_int
)paren
id|bio-&gt;bi_sector
)paren
suffix:semicolon
r_goto
id|end_io
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bio-&gt;bi_size
op_logical_or
(paren
id|bio-&gt;bi_size
op_mod
id|CD_FRAMESIZE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: wrong bio size&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|end_io
suffix:semicolon
)brace
id|blk_queue_bounce
c_func
(paren
id|q
comma
op_amp
id|bio
)paren
suffix:semicolon
id|zone
op_assign
id|ZONE
c_func
(paren
id|bio-&gt;bi_sector
comma
id|pd
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;pkt_make_request: start = %6llx stop = %6llx&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|bio-&gt;bi_sector
comma
(paren
r_int
r_int
r_int
)paren
(paren
id|bio-&gt;bi_sector
op_plus
id|bio_sectors
c_func
(paren
id|bio
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Check if we have to split the bio */
(brace
r_struct
id|bio_pair
op_star
id|bp
suffix:semicolon
id|sector_t
id|last_zone
suffix:semicolon
r_int
id|first_sectors
suffix:semicolon
id|last_zone
op_assign
id|ZONE
c_func
(paren
id|bio-&gt;bi_sector
op_plus
id|bio_sectors
c_func
(paren
id|bio
)paren
op_minus
l_int|1
comma
id|pd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_zone
op_ne
id|zone
)paren
(brace
id|BUG_ON
c_func
(paren
id|last_zone
op_ne
id|zone
op_plus
id|pd-&gt;settings.size
)paren
suffix:semicolon
id|first_sectors
op_assign
id|last_zone
op_minus
id|bio-&gt;bi_sector
suffix:semicolon
id|bp
op_assign
id|bio_split
c_func
(paren
id|bio
comma
id|bio_split_pool
comma
id|first_sectors
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bp
)paren
suffix:semicolon
id|pkt_make_request
c_func
(paren
id|q
comma
op_amp
id|bp-&gt;bio1
)paren
suffix:semicolon
id|pkt_make_request
c_func
(paren
id|q
comma
op_amp
id|bp-&gt;bio2
)paren
suffix:semicolon
id|bio_pair_release
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we find a matching packet in state WAITING or READ_WAIT, we can&n;&t; * just append this bio to that packet.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pd-&gt;cdrw.active_list_lock
)paren
suffix:semicolon
id|blocked_bio
op_assign
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|pkt
comma
op_amp
id|pd-&gt;cdrw.pkt_active_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|pkt-&gt;sector
op_eq
id|zone
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|pkt-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pkt-&gt;state
op_eq
id|PACKET_WAITING_STATE
)paren
op_logical_or
(paren
id|pkt-&gt;state
op_eq
id|PACKET_READ_WAIT_STATE
)paren
)paren
(brace
id|pkt_add_list_last
c_func
(paren
id|bio
comma
op_amp
id|pkt-&gt;orig_bios
comma
op_amp
id|pkt-&gt;orig_bios_tail
)paren
suffix:semicolon
id|pkt-&gt;write_size
op_add_assign
id|bio-&gt;bi_size
op_div
id|CD_FRAMESIZE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pkt-&gt;write_size
op_ge
id|pkt-&gt;frames
)paren
op_logical_and
(paren
id|pkt-&gt;state
op_eq
id|PACKET_WAITING_STATE
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|pkt-&gt;run_sm
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|pd-&gt;wqueue
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pkt-&gt;lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pd-&gt;cdrw.active_list_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|blocked_bio
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pkt-&gt;lock
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pd-&gt;cdrw.active_list_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * No matching packet found. Store the bio in the work queue.&n;&t; */
id|node
op_assign
id|mempool_alloc
c_func
(paren
id|pd-&gt;rb_pool
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|node
)paren
suffix:semicolon
id|node-&gt;bio
op_assign
id|bio
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pd-&gt;lock
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pd-&gt;bio_queue_size
OL
l_int|0
)paren
suffix:semicolon
id|was_empty
op_assign
(paren
id|pd-&gt;bio_queue_size
op_eq
l_int|0
)paren
suffix:semicolon
id|pkt_rbtree_insert
c_func
(paren
id|pd
comma
id|node
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pd-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wake up the worker thread.&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|pd-&gt;scan_queue
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|was_empty
)paren
(brace
multiline_comment|/* This wake_up is required for correct operation */
id|wake_up
c_func
(paren
op_amp
id|pd-&gt;wqueue
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|pd-&gt;cdrw.pkt_free_list
)paren
op_logical_and
op_logical_neg
id|blocked_bio
)paren
(brace
multiline_comment|/*&n;&t;&t; * This wake up is not required for correct operation,&n;&t;&t; * but improves performance in some cases.&n;&t;&t; */
id|wake_up
c_func
(paren
op_amp
id|pd-&gt;wqueue
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|end_io
suffix:colon
id|bio_io_error
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pkt_merge_bvec
r_static
r_int
id|pkt_merge_bvec
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|bio
op_star
id|bio
comma
r_struct
id|bio_vec
op_star
id|bvec
)paren
(brace
r_struct
id|pktcdvd_device
op_star
id|pd
op_assign
id|q-&gt;queuedata
suffix:semicolon
id|sector_t
id|zone
op_assign
id|ZONE
c_func
(paren
id|bio-&gt;bi_sector
comma
id|pd
)paren
suffix:semicolon
r_int
id|used
op_assign
(paren
(paren
id|bio-&gt;bi_sector
op_minus
id|zone
)paren
op_lshift
l_int|9
)paren
op_plus
id|bio-&gt;bi_size
suffix:semicolon
r_int
id|remaining
op_assign
(paren
id|pd-&gt;settings.size
op_lshift
l_int|9
)paren
op_minus
id|used
suffix:semicolon
r_int
id|remaining2
suffix:semicolon
multiline_comment|/*&n;&t; * A bio &lt;= PAGE_SIZE must be allowed. If it crosses a packet&n;&t; * boundary, pkt_make_request() will split the bio.&n;&t; */
id|remaining2
op_assign
id|PAGE_SIZE
op_minus
id|bio-&gt;bi_size
suffix:semicolon
id|remaining
op_assign
id|max
c_func
(paren
id|remaining
comma
id|remaining2
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|remaining
OL
l_int|0
)paren
suffix:semicolon
r_return
id|remaining
suffix:semicolon
)brace
DECL|function|pkt_init_queue
r_static
r_void
id|pkt_init_queue
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
id|pd-&gt;disk-&gt;queue
suffix:semicolon
id|blk_queue_make_request
c_func
(paren
id|q
comma
id|pkt_make_request
)paren
suffix:semicolon
id|blk_queue_hardsect_size
c_func
(paren
id|q
comma
id|CD_FRAMESIZE
)paren
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|q
comma
id|PACKET_MAX_SECTORS
)paren
suffix:semicolon
id|blk_queue_merge_bvec
c_func
(paren
id|q
comma
id|pkt_merge_bvec
)paren
suffix:semicolon
id|q-&gt;queuedata
op_assign
id|pd
suffix:semicolon
)brace
DECL|function|pkt_seq_show
r_static
r_int
id|pkt_seq_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|pktcdvd_device
op_star
id|pd
op_assign
id|m
op_member_access_from_pointer
r_private
suffix:semicolon
r_char
op_star
id|msg
suffix:semicolon
r_char
id|bdev_buf
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_int
id|states
(braket
id|PACKET_NUM_STATES
)braket
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;Writer %s mapped to %s:&bslash;n&quot;
comma
id|pd-&gt;name
comma
id|bdevname
c_func
(paren
id|pd-&gt;bdev
comma
id|bdev_buf
)paren
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;nSettings:&bslash;n&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tpacket size:&bslash;t&bslash;t%dkB&bslash;n&quot;
comma
id|pd-&gt;settings.size
op_div
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;settings.write_type
op_eq
l_int|0
)paren
id|msg
op_assign
l_string|&quot;Packet&quot;
suffix:semicolon
r_else
id|msg
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;twrite type:&bslash;t&bslash;t%s&bslash;n&quot;
comma
id|msg
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tpacket type:&bslash;t&bslash;t%s&bslash;n&quot;
comma
id|pd-&gt;settings.fp
ques
c_cond
l_string|&quot;Fixed&quot;
suffix:colon
l_string|&quot;Variable&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tlink loss:&bslash;t&bslash;t%d&bslash;n&quot;
comma
id|pd-&gt;settings.link_loss
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;ttrack mode:&bslash;t&bslash;t%d&bslash;n&quot;
comma
id|pd-&gt;settings.track_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;settings.block_mode
op_eq
id|PACKET_BLOCK_MODE1
)paren
id|msg
op_assign
l_string|&quot;Mode 1&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pd-&gt;settings.block_mode
op_eq
id|PACKET_BLOCK_MODE2
)paren
id|msg
op_assign
l_string|&quot;Mode 2&quot;
suffix:semicolon
r_else
id|msg
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tblock mode:&bslash;t&bslash;t%s&bslash;n&quot;
comma
id|msg
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;nStatistics:&bslash;n&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tpackets started:&bslash;t%lu&bslash;n&quot;
comma
id|pd-&gt;stats.pkt_started
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tpackets ended:&bslash;t&bslash;t%lu&bslash;n&quot;
comma
id|pd-&gt;stats.pkt_ended
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;twritten:&bslash;t&bslash;t%lukB&bslash;n&quot;
comma
id|pd-&gt;stats.secs_w
op_rshift
l_int|1
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tread gather:&bslash;t&bslash;t%lukB&bslash;n&quot;
comma
id|pd-&gt;stats.secs_rg
op_rshift
l_int|1
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tread:&bslash;t&bslash;t&bslash;t%lukB&bslash;n&quot;
comma
id|pd-&gt;stats.secs_r
op_rshift
l_int|1
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;nMisc:&bslash;n&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;treference count:&bslash;t%d&bslash;n&quot;
comma
id|pd-&gt;refcnt
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tflags:&bslash;t&bslash;t&bslash;t0x%lx&bslash;n&quot;
comma
id|pd-&gt;flags
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tread speed:&bslash;t&bslash;t%ukB/s&bslash;n&quot;
comma
id|pd-&gt;read_speed
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;twrite speed:&bslash;t&bslash;t%ukB/s&bslash;n&quot;
comma
id|pd-&gt;write_speed
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tstart offset:&bslash;t&bslash;t%lu&bslash;n&quot;
comma
id|pd-&gt;offset
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tmode page offset:&bslash;t%u&bslash;n&quot;
comma
id|pd-&gt;mode_offset
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;nQueue state:&bslash;n&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tbios queued:&bslash;t&bslash;t%d&bslash;n&quot;
comma
id|pd-&gt;bio_queue_size
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tbios pending:&bslash;t&bslash;t%d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|pd-&gt;cdrw.pending_bios
)paren
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tcurrent sector:&bslash;t&bslash;t0x%llx&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|pd-&gt;current_sector
)paren
suffix:semicolon
id|pkt_count_states
c_func
(paren
id|pd
comma
id|states
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;tstate:&bslash;t&bslash;t&bslash;ti:%d ow:%d rw:%d ww:%d rec:%d fin:%d&bslash;n&quot;
comma
id|states
(braket
l_int|0
)braket
comma
id|states
(braket
l_int|1
)braket
comma
id|states
(braket
l_int|2
)braket
comma
id|states
(braket
l_int|3
)braket
comma
id|states
(braket
l_int|4
)braket
comma
id|states
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pkt_seq_open
r_static
r_int
id|pkt_seq_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|single_open
c_func
(paren
id|file
comma
id|pkt_seq_show
comma
id|PDE
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|data
)paren
suffix:semicolon
)brace
DECL|variable|pkt_proc_fops
r_static
r_struct
id|file_operations
id|pkt_proc_fops
op_assign
(brace
dot
id|open
op_assign
id|pkt_seq_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|single_release
)brace
suffix:semicolon
DECL|function|pkt_new_dev
r_static
r_int
id|pkt_new_dev
c_func
(paren
r_struct
id|pktcdvd_device
op_star
id|pd
comma
id|dev_t
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|proc
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_if
c_cond
(paren
id|pd-&gt;pkt_dev
op_eq
id|dev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Recursive setup not allowed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_WRITERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|pktcdvd_device
op_star
id|pd2
op_assign
id|pkt_devs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pd2
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pd2-&gt;bdev-&gt;bd_dev
op_eq
id|dev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: %s already setup&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|pd2-&gt;bdev
comma
id|b
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pd2-&gt;pkt_dev
op_eq
id|dev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Can&squot;t chain pktcdvd devices&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
id|bdev
op_assign
id|bdget
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ret
op_assign
id|blkdev_get
c_func
(paren
id|bdev
comma
id|FMODE_READ
comma
id|O_RDONLY
op_or
id|O_NONBLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* This is safe, since we have a reference from open(). */
id|__module_get
c_func
(paren
id|THIS_MODULE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt_grow_pktlist
c_func
(paren
id|pd
comma
id|CONFIG_CDROM_PKTCDVD_BUFFERS
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: not enough memory for buffers&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_mem
suffix:semicolon
)brace
id|pd-&gt;bdev
op_assign
id|bdev
suffix:semicolon
id|set_blocksize
c_func
(paren
id|bdev
comma
id|CD_FRAMESIZE
)paren
suffix:semicolon
id|pkt_init_queue
c_func
(paren
id|pd
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pd-&gt;cdrw.pending_bios
comma
l_int|0
)paren
suffix:semicolon
id|pd-&gt;cdrw.thread
op_assign
id|kthread_run
c_func
(paren
id|kcdrwd
comma
id|pd
comma
l_string|&quot;%s&quot;
comma
id|pd-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|pd-&gt;cdrw.thread
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: can&squot;t start kernel thread&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_thread
suffix:semicolon
)brace
id|proc
op_assign
id|create_proc_entry
c_func
(paren
id|pd-&gt;name
comma
l_int|0
comma
id|pkt_proc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc
)paren
(brace
id|proc-&gt;data
op_assign
id|pd
suffix:semicolon
id|proc-&gt;proc_fops
op_assign
op_amp
id|pkt_proc_fops
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;pktcdvd: writer %s mapped to %s&bslash;n&quot;
comma
id|pd-&gt;name
comma
id|bdevname
c_func
(paren
id|bdev
comma
id|b
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_thread
suffix:colon
id|pkt_shrink_pktlist
c_func
(paren
id|pd
)paren
suffix:semicolon
id|out_mem
suffix:colon
id|blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
multiline_comment|/* This is safe: open() is still holding a reference. */
id|module_put
c_func
(paren
id|THIS_MODULE
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|pkt_ioctl
r_static
r_int
id|pkt_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|pktcdvd_device
op_star
id|pd
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;pkt_ioctl: cmd %x, dev %d:%d&bslash;n&quot;
comma
id|cmd
comma
id|imajor
c_func
(paren
id|inode
)paren
comma
id|iminor
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|pd
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/*&n;&t; * forward selected CDROM ioctls to CD-ROM, for UDF&n;&t; */
r_case
id|CDROMMULTISESSION
suffix:colon
r_case
id|CDROMREADTOCENTRY
suffix:colon
r_case
id|CDROM_LAST_WRITTEN
suffix:colon
r_case
id|CDROM_SEND_PACKET
suffix:colon
r_case
id|SCSI_IOCTL_SEND_COMMAND
suffix:colon
r_return
id|ioctl_by_bdev
c_func
(paren
id|pd-&gt;bdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_case
id|CDROMEJECT
suffix:colon
multiline_comment|/*&n;&t;&t; * The door gets locked when the device is opened, so we&n;&t;&t; * have to unlock it or else the eject command fails.&n;&t;&t; */
id|pkt_lock_door
c_func
(paren
id|pd
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ioctl_by_bdev
c_func
(paren
id|pd-&gt;bdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Unknown ioctl for %s (%x)&bslash;n&quot;
comma
id|pd-&gt;name
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pkt_media_changed
r_static
r_int
id|pkt_media_changed
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_struct
id|pktcdvd_device
op_star
id|pd
op_assign
id|disk-&gt;private_data
suffix:semicolon
r_struct
id|gendisk
op_star
id|attached_disk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pd
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pd-&gt;bdev
)paren
r_return
l_int|0
suffix:semicolon
id|attached_disk
op_assign
id|pd-&gt;bdev-&gt;bd_disk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attached_disk
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|attached_disk-&gt;fops
op_member_access_from_pointer
id|media_changed
c_func
(paren
id|attached_disk
)paren
suffix:semicolon
)brace
DECL|variable|pktcdvd_ops
r_static
r_struct
id|block_device_operations
id|pktcdvd_ops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|pkt_open
comma
dot
id|release
op_assign
id|pkt_close
comma
dot
id|ioctl
op_assign
id|pkt_ioctl
comma
dot
id|media_changed
op_assign
id|pkt_media_changed
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Set up mapping from pktcdvd device to CD-ROM device.&n; */
DECL|function|pkt_setup_dev
r_static
r_int
id|pkt_setup_dev
c_func
(paren
r_struct
id|pkt_ctrl_command
op_star
id|ctrl_cmd
)paren
(brace
r_int
id|idx
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_struct
id|pktcdvd_device
op_star
id|pd
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
id|dev_t
id|dev
op_assign
id|new_decode_dev
c_func
(paren
id|ctrl_cmd-&gt;dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|MAX_WRITERS
suffix:semicolon
id|idx
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|pkt_devs
(braket
id|idx
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_eq
id|MAX_WRITERS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: max %d writers supported&bslash;n&quot;
comma
id|MAX_WRITERS
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|pd
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pktcdvd_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pd
)paren
r_return
id|ret
suffix:semicolon
id|memset
c_func
(paren
id|pd
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pktcdvd_device
)paren
)paren
suffix:semicolon
id|pd-&gt;rb_pool
op_assign
id|mempool_create
c_func
(paren
id|PKT_RB_POOL_SIZE
comma
id|pkt_rb_alloc
comma
id|pkt_rb_free
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pd-&gt;rb_pool
)paren
r_goto
id|out_mem
suffix:semicolon
id|disk
op_assign
id|alloc_disk
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk
)paren
r_goto
id|out_mem
suffix:semicolon
id|pd-&gt;disk
op_assign
id|disk
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pd-&gt;lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pd-&gt;iosched.lock
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|pd-&gt;name
comma
l_string|&quot;pktcdvd%d&quot;
comma
id|idx
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pd-&gt;wqueue
)paren
suffix:semicolon
id|pd-&gt;bio_queue
op_assign
id|RB_ROOT
suffix:semicolon
id|disk-&gt;major
op_assign
id|pkt_major
suffix:semicolon
id|disk-&gt;first_minor
op_assign
id|idx
suffix:semicolon
id|disk-&gt;fops
op_assign
op_amp
id|pktcdvd_ops
suffix:semicolon
id|disk-&gt;flags
op_assign
id|GENHD_FL_REMOVABLE
suffix:semicolon
id|sprintf
c_func
(paren
id|disk-&gt;disk_name
comma
l_string|&quot;pktcdvd%d&quot;
comma
id|idx
)paren
suffix:semicolon
id|disk-&gt;private_data
op_assign
id|pd
suffix:semicolon
id|disk-&gt;queue
op_assign
id|blk_alloc_queue
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk-&gt;queue
)paren
r_goto
id|out_mem2
suffix:semicolon
id|pd-&gt;pkt_dev
op_assign
id|MKDEV
c_func
(paren
id|disk-&gt;major
comma
id|disk-&gt;first_minor
)paren
suffix:semicolon
id|ret
op_assign
id|pkt_new_dev
c_func
(paren
id|pd
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_new_dev
suffix:semicolon
id|add_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
id|pkt_devs
(braket
id|idx
)braket
op_assign
id|pd
suffix:semicolon
id|ctrl_cmd-&gt;pkt_dev
op_assign
id|new_encode_dev
c_func
(paren
id|pd-&gt;pkt_dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_new_dev
suffix:colon
id|blk_put_queue
c_func
(paren
id|disk-&gt;queue
)paren
suffix:semicolon
id|out_mem2
suffix:colon
id|put_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
id|out_mem
suffix:colon
r_if
c_cond
(paren
id|pd-&gt;rb_pool
)paren
id|mempool_destroy
c_func
(paren
id|pd-&gt;rb_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pd
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Tear down mapping from pktcdvd device to CD-ROM device.&n; */
DECL|function|pkt_remove_dev
r_static
r_int
id|pkt_remove_dev
c_func
(paren
r_struct
id|pkt_ctrl_command
op_star
id|ctrl_cmd
)paren
(brace
r_struct
id|pktcdvd_device
op_star
id|pd
suffix:semicolon
r_int
id|idx
suffix:semicolon
id|dev_t
id|pkt_dev
op_assign
id|new_decode_dev
c_func
(paren
id|ctrl_cmd-&gt;pkt_dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|MAX_WRITERS
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|pd
op_assign
id|pkt_devs
(braket
id|idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pd
op_logical_and
(paren
id|pd-&gt;pkt_dev
op_eq
id|pkt_dev
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|idx
op_eq
id|MAX_WRITERS
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;pktcdvd: dev not setup&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pd-&gt;refcnt
OG
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|pd-&gt;cdrw.thread
)paren
)paren
id|kthread_stop
c_func
(paren
id|pd-&gt;cdrw.thread
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|pd-&gt;bdev
)paren
suffix:semicolon
id|pkt_shrink_pktlist
c_func
(paren
id|pd
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|pd-&gt;name
comma
id|pkt_proc
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;pktcdvd: writer %s unmapped&bslash;n&quot;
comma
id|pd-&gt;name
)paren
suffix:semicolon
id|del_gendisk
c_func
(paren
id|pd-&gt;disk
)paren
suffix:semicolon
id|blk_put_queue
c_func
(paren
id|pd-&gt;disk-&gt;queue
)paren
suffix:semicolon
id|put_disk
c_func
(paren
id|pd-&gt;disk
)paren
suffix:semicolon
id|pkt_devs
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|pd-&gt;rb_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pd
)paren
suffix:semicolon
multiline_comment|/* This is safe: open() is still holding a reference. */
id|module_put
c_func
(paren
id|THIS_MODULE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pkt_get_status
r_static
r_void
id|pkt_get_status
c_func
(paren
r_struct
id|pkt_ctrl_command
op_star
id|ctrl_cmd
)paren
(brace
r_struct
id|pktcdvd_device
op_star
id|pd
op_assign
id|pkt_find_dev_from_minor
c_func
(paren
id|ctrl_cmd-&gt;dev_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pd
)paren
(brace
id|ctrl_cmd-&gt;dev
op_assign
id|new_encode_dev
c_func
(paren
id|pd-&gt;bdev-&gt;bd_dev
)paren
suffix:semicolon
id|ctrl_cmd-&gt;pkt_dev
op_assign
id|new_encode_dev
c_func
(paren
id|pd-&gt;pkt_dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|ctrl_cmd-&gt;dev
op_assign
l_int|0
suffix:semicolon
id|ctrl_cmd-&gt;pkt_dev
op_assign
l_int|0
suffix:semicolon
)brace
id|ctrl_cmd-&gt;num_devices
op_assign
id|MAX_WRITERS
suffix:semicolon
)brace
DECL|function|pkt_ctl_ioctl
r_static
r_int
id|pkt_ctl_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_void
id|__user
op_star
id|argp
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|pkt_ctrl_command
id|ctrl_cmd
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|PACKET_CTRL_CMD
)paren
r_return
op_minus
id|ENOTTY
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ctrl_cmd
comma
id|argp
comma
r_sizeof
(paren
r_struct
id|pkt_ctrl_command
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|ctrl_cmd.command
)paren
(brace
r_case
id|PKT_CTRL_CMD_SETUP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ctl_mutex
)paren
suffix:semicolon
id|ret
op_assign
id|pkt_setup_dev
c_func
(paren
op_amp
id|ctrl_cmd
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctl_mutex
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PKT_CTRL_CMD_TEARDOWN
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ctl_mutex
)paren
suffix:semicolon
id|ret
op_assign
id|pkt_remove_dev
c_func
(paren
op_amp
id|ctrl_cmd
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctl_mutex
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PKT_CTRL_CMD_STATUS
suffix:colon
id|down
c_func
(paren
op_amp
id|ctl_mutex
)paren
suffix:semicolon
id|pkt_get_status
c_func
(paren
op_amp
id|ctrl_cmd
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctl_mutex
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|argp
comma
op_amp
id|ctrl_cmd
comma
r_sizeof
(paren
r_struct
id|pkt_ctrl_command
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|pkt_ctl_fops
r_static
r_struct
id|file_operations
id|pkt_ctl_fops
op_assign
(brace
dot
id|ioctl
op_assign
id|pkt_ctl_ioctl
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
)brace
suffix:semicolon
DECL|variable|pkt_misc
r_static
r_struct
id|miscdevice
id|pkt_misc
op_assign
(brace
dot
id|minor
op_assign
id|MISC_DYNAMIC_MINOR
comma
dot
id|name
op_assign
l_string|&quot;pktcdvd&quot;
comma
dot
id|devfs_name
op_assign
l_string|&quot;pktcdvd/control&quot;
comma
dot
id|fops
op_assign
op_amp
id|pkt_ctl_fops
)brace
suffix:semicolon
DECL|function|pkt_init
r_static
r_int
id|pkt_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
id|psd_pool
op_assign
id|mempool_create
c_func
(paren
id|PSD_POOL_SIZE
comma
id|psd_pool_alloc
comma
id|psd_pool_free
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|psd_pool
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ret
op_assign
id|register_blkdev
c_func
(paren
id|pkt_major
comma
l_string|&quot;pktcdvd&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Unable to register block device&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out2
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pkt_major
)paren
id|pkt_major
op_assign
id|ret
suffix:semicolon
id|ret
op_assign
id|misc_register
c_func
(paren
op_amp
id|pkt_misc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pktcdvd: Unable to register misc device&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|init_MUTEX
c_func
(paren
op_amp
id|ctl_mutex
)paren
suffix:semicolon
id|pkt_proc
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;pktcdvd&quot;
comma
id|proc_root_driver
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;pktcdvd: %s&bslash;n&quot;
comma
id|VERSION_CODE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unregister_blkdev
c_func
(paren
id|pkt_major
comma
l_string|&quot;pktcdvd&quot;
)paren
suffix:semicolon
id|out2
suffix:colon
id|mempool_destroy
c_func
(paren
id|psd_pool
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|pkt_exit
r_static
r_void
id|pkt_exit
c_func
(paren
r_void
)paren
(brace
id|remove_proc_entry
c_func
(paren
l_string|&quot;pktcdvd&quot;
comma
id|proc_root_driver
)paren
suffix:semicolon
id|misc_deregister
c_func
(paren
op_amp
id|pkt_misc
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|pkt_major
comma
l_string|&quot;pktcdvd&quot;
)paren
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|psd_pool
)paren
suffix:semicolon
)brace
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Packet writing layer for CD/DVD drives&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Jens Axboe &lt;axboe@suse.de&gt;&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|pkt_init
id|module_init
c_func
(paren
id|pkt_init
)paren
suffix:semicolon
DECL|variable|pkt_exit
id|module_exit
c_func
(paren
id|pkt_exit
)paren
suffix:semicolon
eof
