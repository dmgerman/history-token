multiline_comment|/*&n; * ramdisk.c - Multiple RAM disk driver - gzip-loading version - v. 0.8 beta.&n; *&n; * (C) Chad Page, Theodore Ts&squot;o, et. al, 1995.&n; *&n; * This RAM disk is designed to have filesystems created on it and mounted&n; * just like a regular floppy disk.&n; *&n; * It also does something suggested by Linus: use the buffer cache as the&n; * RAM disk data.  This makes it possible to dynamically allocate the RAM disk&n; * buffer - with some consequences I have to deal with as I write this.&n; *&n; * This code is based on the original ramdisk.c, written mostly by&n; * Theodore Ts&squot;o (TYT) in 1991.  The code was largely rewritten by&n; * Chad Page to use the buffer cache to store the RAM disk data in&n; * 1995; Theodore then took over the driver again, and cleaned it up&n; * for inclusion in the mainline kernel.&n; *&n; * The original CRAMDISK code was written by Richard Lyons, and&n; * adapted by Chad Page to use the new RAM disk interface.  Theodore&n; * Ts&squot;o rewrote it so that both the compressed RAM disk loader and the&n; * kernel decompressor uses the same inflate.c codebase.  The RAM disk&n; * loader now also loads into a dynamic (buffer cache based) RAM disk,&n; * not the old static RAM disk.  Support for the old static RAM disk has&n; * been completely removed.&n; *&n; * Loadable module support added by Tom Dyas.&n; *&n; * Further cleanups by Chad Page (page0588@sundance.sjsu.edu):&n; *&t;Cosmetic changes in #ifdef MODULE, code movement, etc.&n; * &t;When the RAM disk module is removed, free the protected buffers&n; * &t;Default RAM disk size changed to 2.88 MB&n; *&n; *  Added initrd: Werner Almesberger &amp; Hans Lermen, Feb &squot;96&n; *&n; * 4/25/96 : Made RAM disk size a parameter (default is now 4 MB)&n; *&t;&t;- Chad Page&n; *&n; * Add support for fs images split across &gt;1 disk, Paul Gortmaker, Mar &squot;98&n; *&n; * Make block size and block size shift for RAM disks a global macro&n; * and set blk_size for -ENOSPC,     Werner Fink &lt;werner@suse.de&gt;, Apr &squot;99&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;&t;&t;/* for invalidate_bdev() */
macro_line|#include &lt;linux/backing-dev.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* The RAM disk size is now a parameter */
DECL|macro|NUM_RAMDISKS
mdefine_line|#define NUM_RAMDISKS 16&t;&t;/* This cannot be overridden (yet) */
multiline_comment|/* Various static variables go here.  Most are used only in the RAM disk code.&n; */
DECL|variable|rd_disks
r_static
r_struct
id|gendisk
op_star
id|rd_disks
(braket
id|NUM_RAMDISKS
)braket
suffix:semicolon
DECL|variable|rd_bdev
r_static
r_struct
id|block_device
op_star
id|rd_bdev
(braket
id|NUM_RAMDISKS
)braket
suffix:semicolon
multiline_comment|/* Protected device data */
DECL|variable|rd_queue
r_static
r_struct
id|request_queue
op_star
id|rd_queue
(braket
id|NUM_RAMDISKS
)braket
suffix:semicolon
multiline_comment|/*&n; * Parameters for the boot-loading of the RAM disk.  These are set by&n; * init/main.c (from arguments to the kernel command line) or from the&n; * architecture-specific setup routine (from the stored boot sector&n; * information).&n; */
DECL|variable|rd_size
r_int
id|rd_size
op_assign
id|CONFIG_BLK_DEV_RAM_SIZE
suffix:semicolon
multiline_comment|/* Size of the RAM disks */
multiline_comment|/*&n; * It would be very desirable to have a soft-blocksize (that in the case&n; * of the ramdisk driver is also the hardblocksize ;) of PAGE_SIZE because&n; * doing that we&squot;ll achieve a far better MM footprint. Using a rd_blocksize of&n; * BLOCK_SIZE in the worst case we&squot;ll make PAGE_SIZE/BLOCK_SIZE buffer-pages&n; * unfreeable. With a rd_blocksize of PAGE_SIZE instead we are sure that only&n; * 1 page will be protected. Depending on the size of the ramdisk you&n; * may want to change the ramdisk blocksize to achieve a better or worse MM&n; * behaviour. The default is still BLOCK_SIZE (needed by rd_load_image that&n; * supposes the filesystem in the image uses a BLOCK_SIZE blocksize).&n; */
DECL|variable|rd_blocksize
r_int
id|rd_blocksize
op_assign
id|BLOCK_SIZE
suffix:semicolon
multiline_comment|/* blocksize of the RAM disks */
multiline_comment|/*&n; * Copyright (C) 2000 Linus Torvalds.&n; *               2000 Transmeta Corp.&n; * aops copied from ramfs.&n; */
multiline_comment|/*&n; * If a ramdisk page has buffers, some may be uptodate and some may be not.&n; * To bring the page uptodate we zero out the non-uptodate buffers.  The&n; * page must be locked.&n; */
DECL|function|make_page_uptodate
r_static
r_void
id|make_page_uptodate
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|head
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|memset
c_func
(paren
id|bh-&gt;b_data
comma
l_int|0
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * akpm: I&squot;m totally undecided about this.  The&n;&t;&t;&t;&t; * buffer has just been magically brought &quot;up to&n;&t;&t;&t;&t; * date&quot;, but nobody should want to be reading&n;&t;&t;&t;&t; * it anyway, because it hasn&squot;t been used for&n;&t;&t;&t;&t; * anything yet.  It is still in a &quot;not read&n;&t;&t;&t;&t; * from disk yet&quot; state.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * But non-uptodate buffers against an uptodate&n;&t;&t;&t;&t; * page are against the rules.  So do it anyway.&n;&t;&t;&t;&t; */
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
)brace
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|ramdisk_readpage
r_static
r_int
id|ramdisk_readpage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|make_page_uptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ramdisk_prepare_write
r_static
r_int
id|ramdisk_prepare_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|to
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|make_page_uptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ramdisk_commit_write
r_static
r_int
id|ramdisk_commit_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|to
)paren
(brace
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * -&gt;writepage to the the blockdev&squot;s mapping has to redirty the page so that the&n; * VM doesn&squot;t go and steal it.  We return WRITEPAGE_ACTIVATE so that the VM&n; * won&squot;t try to (pointlessly) write the page again for a while.&n; *&n; * Really, these pages should not be on the LRU at all.&n; */
DECL|function|ramdisk_writepage
r_static
r_int
id|ramdisk_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|make_page_uptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wbc-&gt;for_reclaim
)paren
r_return
id|WRITEPAGE_ACTIVATE
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a little speedup thing: short-circuit attempts to write back the&n; * ramdisk blockdev inode to its non-existent backing store.&n; */
DECL|function|ramdisk_writepages
r_static
r_int
id|ramdisk_writepages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ramdisk blockdev pages have their own -&gt;set_page_dirty() because we don&squot;t&n; * want them to contribute to dirty memory accounting.&n; */
DECL|function|ramdisk_set_page_dirty
r_static
r_int
id|ramdisk_set_page_dirty
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ramdisk_aops
r_static
r_struct
id|address_space_operations
id|ramdisk_aops
op_assign
(brace
dot
id|readpage
op_assign
id|ramdisk_readpage
comma
dot
id|prepare_write
op_assign
id|ramdisk_prepare_write
comma
dot
id|commit_write
op_assign
id|ramdisk_commit_write
comma
dot
id|writepage
op_assign
id|ramdisk_writepage
comma
dot
id|set_page_dirty
op_assign
id|ramdisk_set_page_dirty
comma
dot
id|writepages
op_assign
id|ramdisk_writepages
comma
)brace
suffix:semicolon
DECL|function|rd_blkdev_pagecache_IO
r_static
r_int
id|rd_blkdev_pagecache_IO
c_func
(paren
r_int
id|rw
comma
r_struct
id|bio_vec
op_star
id|vec
comma
id|sector_t
id|sector
comma
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
id|pgoff_t
id|index
op_assign
id|sector
op_rshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
l_int|9
)paren
suffix:semicolon
r_int
r_int
id|vec_offset
op_assign
id|vec-&gt;bv_offset
suffix:semicolon
r_int
id|offset
op_assign
(paren
id|sector
op_lshift
l_int|9
)paren
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_int
id|size
op_assign
id|vec-&gt;bv_len
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_int
id|count
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_char
op_star
id|src
suffix:semicolon
r_char
op_star
id|dst
suffix:semicolon
id|count
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|size
)paren
id|count
op_assign
id|size
suffix:semicolon
id|size
op_sub_assign
id|count
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|make_page_uptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|index
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
(brace
id|src
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
op_plus
id|offset
suffix:semicolon
id|dst
op_assign
id|kmap_atomic
c_func
(paren
id|vec-&gt;bv_page
comma
id|KM_USER1
)paren
op_plus
id|vec_offset
suffix:semicolon
)brace
r_else
(brace
id|src
op_assign
id|kmap_atomic
c_func
(paren
id|vec-&gt;bv_page
comma
id|KM_USER0
)paren
op_plus
id|vec_offset
suffix:semicolon
id|dst
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER1
)paren
op_plus
id|offset
suffix:semicolon
)brace
id|offset
op_assign
l_int|0
suffix:semicolon
id|vec_offset
op_add_assign
id|count
suffix:semicolon
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|count
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|src
comma
id|KM_USER0
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|dst
comma
id|KM_USER1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
id|flush_dcache_page
c_func
(paren
id|vec-&gt;bv_page
)paren
suffix:semicolon
r_else
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|put_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *  Basically, my strategy here is to set up a buffer-head which can&squot;t be&n; *  deleted, and make that my Ramdisk.  If the request is outside of the&n; *  allocated size, we must get rid of it...&n; *&n; * 19-JAN-1998  Richard Gooch &lt;rgooch@atnf.csiro.au&gt;  Added devfs support&n; *&n; */
DECL|function|rd_make_request
r_static
r_int
id|rd_make_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
op_assign
id|bio-&gt;bi_bdev
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|bdev-&gt;bd_inode-&gt;i_mapping
suffix:semicolon
id|sector_t
id|sector
op_assign
id|bio-&gt;bi_sector
suffix:semicolon
r_int
r_int
id|len
op_assign
id|bio-&gt;bi_size
op_rshift
l_int|9
suffix:semicolon
r_int
id|rw
op_assign
id|bio_data_dir
c_func
(paren
id|bio
)paren
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sector
op_plus
id|len
OG
id|get_capacity
c_func
(paren
id|bdev-&gt;bd_disk
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READA
)paren
id|rw
op_assign
id|READ
suffix:semicolon
id|bio_for_each_segment
c_func
(paren
id|bvec
comma
id|bio
comma
id|i
)paren
(brace
id|ret
op_or_assign
id|rd_blkdev_pagecache_IO
c_func
(paren
id|rw
comma
id|bvec
comma
id|sector
comma
id|mapping
)paren
suffix:semicolon
id|sector
op_add_assign
id|bvec-&gt;bv_len
op_rshift
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|fail
suffix:semicolon
id|bio_endio
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|bio_io_error
c_func
(paren
id|bio
comma
id|bio-&gt;bi_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rd_ioctl
r_static
r_int
id|rd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
op_assign
id|inode-&gt;i_bdev
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|BLKFLSBUF
)paren
r_return
op_minus
id|ENOTTY
suffix:semicolon
multiline_comment|/*&n;&t; * special: we want to release the ramdisk memory, it&squot;s not like with&n;&t; * the other blockdevices where this ioctl only flushes away the buffer&n;&t; * cache&n;&t; */
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|down
c_func
(paren
op_amp
id|bdev-&gt;bd_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdev-&gt;bd_openers
op_le
l_int|2
)paren
(brace
id|truncate_inode_pages
c_func
(paren
id|bdev-&gt;bd_inode-&gt;i_mapping
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|bdev-&gt;bd_sem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the backing_dev_info for the blockdev inode itself.  It doesn&squot;t need&n; * writeback and it does not contribute to dirty memory accounting.&n; */
DECL|variable|rd_backing_dev_info
r_static
r_struct
id|backing_dev_info
id|rd_backing_dev_info
op_assign
(brace
dot
id|ra_pages
op_assign
l_int|0
comma
multiline_comment|/* No readahead */
dot
id|memory_backed
op_assign
l_int|1
comma
multiline_comment|/* Does not contribute to dirty memory */
dot
id|unplug_io_fn
op_assign
id|default_unplug_io_fn
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * This is the backing_dev_info for the files which live atop the ramdisk&n; * &quot;device&quot;.  These files do need writeback and they do contribute to dirty&n; * memory accounting.&n; */
DECL|variable|rd_file_backing_dev_info
r_static
r_struct
id|backing_dev_info
id|rd_file_backing_dev_info
op_assign
(brace
dot
id|ra_pages
op_assign
l_int|0
comma
multiline_comment|/* No readahead */
dot
id|memory_backed
op_assign
l_int|0
comma
multiline_comment|/* Does contribute to dirty memory */
dot
id|unplug_io_fn
op_assign
id|default_unplug_io_fn
comma
)brace
suffix:semicolon
DECL|function|rd_open
r_static
r_int
id|rd_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|unit
op_assign
id|iminor
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rd_bdev
(braket
id|unit
)braket
op_eq
l_int|NULL
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
op_assign
id|inode-&gt;i_bdev
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_int
id|bsize
suffix:semicolon
r_int
id|gfp_mask
suffix:semicolon
id|inode
op_assign
id|igrab
c_func
(paren
id|bdev-&gt;bd_inode
)paren
suffix:semicolon
id|rd_bdev
(braket
id|unit
)braket
op_assign
id|bdev
suffix:semicolon
id|bdev-&gt;bd_openers
op_increment
suffix:semicolon
id|bsize
op_assign
id|bdev_hardsect_size
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|bdev-&gt;bd_block_size
op_assign
id|bsize
suffix:semicolon
id|inode-&gt;i_blkbits
op_assign
id|blksize_bits
c_func
(paren
id|bsize
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|get_capacity
c_func
(paren
id|bdev-&gt;bd_disk
)paren
op_lshift
l_int|9
suffix:semicolon
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
id|mapping-&gt;a_ops
op_assign
op_amp
id|ramdisk_aops
suffix:semicolon
id|mapping-&gt;backing_dev_info
op_assign
op_amp
id|rd_backing_dev_info
suffix:semicolon
id|bdev-&gt;bd_inode_backing_dev_info
op_assign
op_amp
id|rd_file_backing_dev_info
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Deep badness.  rd_blkdev_pagecache_IO() needs to allocate&n;&t;&t; * pagecache pages within a request_fn.  We cannot recur back&n;&t;&t; * into the filesytem which is mounted atop the ramdisk, because&n;&t;&t; * that would deadlock on fs locks.  And we really don&squot;t want&n;&t;&t; * to reenter rd_blkdev_pagecache_IO when we&squot;re already within&n;&t;&t; * that function.&n;&t;&t; *&n;&t;&t; * So we turn off __GFP_FS and __GFP_IO.&n;&t;&t; *&n;&t;&t; * And to give this thing a hope of working, turn on __GFP_HIGH.&n;&t;&t; * Hopefully, there&squot;s enough regular memory allocation going on&n;&t;&t; * for the page allocator emergency pools to keep the ramdisk&n;&t;&t; * driver happy.&n;&t;&t; */
id|gfp_mask
op_assign
id|mapping_gfp_mask
c_func
(paren
id|mapping
)paren
suffix:semicolon
id|gfp_mask
op_and_assign
op_complement
(paren
id|__GFP_FS
op_or
id|__GFP_IO
)paren
suffix:semicolon
id|gfp_mask
op_or_assign
id|__GFP_HIGH
suffix:semicolon
id|mapping_set_gfp_mask
c_func
(paren
id|mapping
comma
id|gfp_mask
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|rd_bd_op
r_static
r_struct
id|block_device_operations
id|rd_bd_op
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|rd_open
comma
dot
id|ioctl
op_assign
id|rd_ioctl
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Before freeing the module, invalidate all of the protected buffers!&n; */
DECL|function|rd_cleanup
r_static
r_void
id|__exit
id|rd_cleanup
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RAMDISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
op_assign
id|rd_bdev
(braket
id|i
)braket
suffix:semicolon
id|rd_bdev
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|bdev
)paren
(brace
id|invalidate_bdev
c_func
(paren
id|bdev
comma
l_int|1
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
id|del_gendisk
c_func
(paren
id|rd_disks
(braket
id|i
)braket
)paren
suffix:semicolon
id|put_disk
c_func
(paren
id|rd_disks
(braket
id|i
)braket
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|rd_queue
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|devfs_remove
c_func
(paren
l_string|&quot;rd&quot;
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|RAMDISK_MAJOR
comma
l_string|&quot;ramdisk&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the registration and initialization section of the RAM disk driver&n; */
DECL|function|rd_init
r_static
r_int
id|__init
id|rd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|rd_blocksize
OG
id|PAGE_SIZE
op_logical_or
id|rd_blocksize
OL
l_int|512
op_logical_or
(paren
id|rd_blocksize
op_amp
(paren
id|rd_blocksize
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RAMDISK: wrong blocksize %d, reverting to defaults&bslash;n&quot;
comma
id|rd_blocksize
)paren
suffix:semicolon
id|rd_blocksize
op_assign
id|BLOCK_SIZE
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RAMDISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rd_disks
(braket
id|i
)braket
op_assign
id|alloc_disk
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rd_disks
(braket
id|i
)braket
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|RAMDISK_MAJOR
comma
l_string|&quot;ramdisk&quot;
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|devfs_mk_dir
c_func
(paren
l_string|&quot;rd&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RAMDISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|rd_disks
(braket
id|i
)braket
suffix:semicolon
id|rd_queue
(braket
id|i
)braket
op_assign
id|blk_alloc_queue
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rd_queue
(braket
id|i
)braket
)paren
r_goto
id|out_queue
suffix:semicolon
id|blk_queue_make_request
c_func
(paren
id|rd_queue
(braket
id|i
)braket
comma
op_amp
id|rd_make_request
)paren
suffix:semicolon
id|blk_queue_hardsect_size
c_func
(paren
id|rd_queue
(braket
id|i
)braket
comma
id|rd_blocksize
)paren
suffix:semicolon
multiline_comment|/* rd_size is given in kB */
id|disk-&gt;major
op_assign
id|RAMDISK_MAJOR
suffix:semicolon
id|disk-&gt;first_minor
op_assign
id|i
suffix:semicolon
id|disk-&gt;fops
op_assign
op_amp
id|rd_bd_op
suffix:semicolon
id|disk-&gt;queue
op_assign
id|rd_queue
(braket
id|i
)braket
suffix:semicolon
id|disk-&gt;flags
op_or_assign
id|GENHD_FL_SUPPRESS_PARTITION_INFO
suffix:semicolon
id|sprintf
c_func
(paren
id|disk-&gt;disk_name
comma
l_string|&quot;ram%d&quot;
comma
id|i
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|disk-&gt;devfs_name
comma
l_string|&quot;rd/%d&quot;
comma
id|i
)paren
suffix:semicolon
id|set_capacity
c_func
(paren
id|disk
comma
id|rd_size
op_star
l_int|2
)paren
suffix:semicolon
id|add_disk
c_func
(paren
id|rd_disks
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* rd_size is given in kB */
id|printk
c_func
(paren
l_string|&quot;RAMDISK driver initialized: &quot;
l_string|&quot;%d RAM disks of %dK size %d blocksize&bslash;n&quot;
comma
id|NUM_RAMDISKS
comma
id|rd_size
comma
id|rd_blocksize
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_queue
suffix:colon
id|unregister_blkdev
c_func
(paren
id|RAMDISK_MAJOR
comma
l_string|&quot;ramdisk&quot;
)paren
suffix:semicolon
id|out
suffix:colon
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
id|put_disk
c_func
(paren
id|rd_disks
(braket
id|i
)braket
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|rd_queue
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|variable|rd_init
id|module_init
c_func
(paren
id|rd_init
)paren
suffix:semicolon
DECL|variable|rd_cleanup
id|module_exit
c_func
(paren
id|rd_cleanup
)paren
suffix:semicolon
multiline_comment|/* options - nonmodular */
macro_line|#ifndef MODULE
DECL|function|ramdisk_size
r_static
r_int
id|__init
id|ramdisk_size
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|rd_size
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ramdisk_size2
r_static
r_int
id|__init
id|ramdisk_size2
c_func
(paren
r_char
op_star
id|str
)paren
multiline_comment|/* kludge */
(brace
r_return
id|ramdisk_size
c_func
(paren
id|str
)paren
suffix:semicolon
)brace
DECL|function|ramdisk_blocksize
r_static
r_int
id|__init
id|ramdisk_blocksize
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|rd_blocksize
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;ramdisk=&quot;
comma
id|ramdisk_size
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;ramdisk_size=&quot;
comma
id|ramdisk_size2
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;ramdisk_blocksize=&quot;
comma
id|ramdisk_blocksize
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* options - modular */
id|module_param
c_func
(paren
id|rd_size
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|rd_size
comma
l_string|&quot;Size of each RAM disk in kbytes.&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|rd_blocksize
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|rd_blocksize
comma
l_string|&quot;Blocksize of each RAM disk in bytes.&quot;
)paren
suffix:semicolon
DECL|variable|RAMDISK_MAJOR
id|MODULE_ALIAS_BLOCKDEV_MAJOR
c_func
(paren
id|RAMDISK_MAJOR
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
