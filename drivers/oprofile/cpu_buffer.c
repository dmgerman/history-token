multiline_comment|/**&n; * @file cpu_buffer.c&n; *&n; * @remark Copyright 2002 OProfile authors&n; * @remark Read the file COPYING&n; *&n; * @author John Levon &lt;levon@movementarian.org&gt;&n; *&n; * Each CPU has a local buffer that stores PC value/event&n; * pairs. We also log context switches when we notice them.&n; * Eventually each CPU&squot;s buffer is processed into the global&n; * event buffer by sync_cpu_buffers().&n; *&n; * We use a local buffer for two reasons: an NMI or similar&n; * interrupt cannot synchronise, and high sampling rates&n; * would lead to catastrophic global synchronisation if&n; * a global buffer was used.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &quot;cpu_buffer.h&quot;
macro_line|#include &quot;oprof.h&quot;
macro_line|#include &quot;oprofile_stats.h&quot;
DECL|variable|__cacheline_aligned
r_struct
id|oprofile_cpu_buffer
id|cpu_buffer
(braket
id|NR_CPUS
)braket
id|__cacheline_aligned
suffix:semicolon
DECL|variable|buffer_size
r_static
r_int
r_int
id|buffer_size
suffix:semicolon
DECL|function|__free_cpu_buffers
r_static
r_void
id|__free_cpu_buffers
c_func
(paren
r_int
id|num
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|oprofile_cpu_buffer
op_star
id|b
op_assign
op_amp
id|cpu_buffer
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_possible
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|vfree
c_func
(paren
id|b-&gt;buffer
)paren
suffix:semicolon
)brace
)brace
DECL|function|alloc_cpu_buffers
r_int
id|alloc_cpu_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|buffer_size
op_assign
id|fs_cpu_buffer_size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|oprofile_cpu_buffer
op_star
id|b
op_assign
op_amp
id|cpu_buffer
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_possible
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|b-&gt;buffer
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|op_sample
)paren
op_star
id|buffer_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|b-&gt;buffer
)paren
r_goto
id|fail
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|b-&gt;int_lock
)paren
suffix:semicolon
id|b-&gt;pos
op_assign
l_int|0
suffix:semicolon
id|b-&gt;last_task
op_assign
l_int|0
suffix:semicolon
id|b-&gt;sample_received
op_assign
l_int|0
suffix:semicolon
id|b-&gt;sample_lost_locked
op_assign
l_int|0
suffix:semicolon
id|b-&gt;sample_lost_overflow
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|__free_cpu_buffers
c_func
(paren
id|i
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|free_cpu_buffers
r_void
id|free_cpu_buffers
c_func
(paren
r_void
)paren
(brace
id|__free_cpu_buffers
c_func
(paren
id|NR_CPUS
)paren
suffix:semicolon
)brace
multiline_comment|/* Note we can&squot;t use a semaphore here as this is supposed to&n; * be safe from any context. Instead we trylock the CPU&squot;s int_lock.&n; * int_lock is taken by the processing code in sync_cpu_buffers()&n; * so we avoid disturbing that.&n; */
DECL|function|oprofile_add_sample
r_void
id|oprofile_add_sample
c_func
(paren
r_int
r_int
id|eip
comma
r_int
r_int
id|event
comma
r_int
id|cpu
)paren
(brace
r_struct
id|oprofile_cpu_buffer
op_star
id|cpu_buf
op_assign
op_amp
id|cpu_buffer
(braket
id|cpu
)braket
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
multiline_comment|/* temporary ? */
id|BUG_ON
c_func
(paren
op_logical_neg
id|oprofile_started
)paren
suffix:semicolon
id|cpu_buf-&gt;sample_received
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|cpu_buf-&gt;int_lock
)paren
)paren
(brace
id|cpu_buf-&gt;sample_lost_locked
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpu_buf-&gt;pos
OG
id|buffer_size
op_minus
l_int|2
)paren
(brace
id|cpu_buf-&gt;sample_lost_overflow
op_increment
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|task
op_assign
id|current
suffix:semicolon
multiline_comment|/* notice a task switch */
r_if
c_cond
(paren
id|cpu_buf-&gt;last_task
op_ne
id|task
)paren
(brace
id|cpu_buf-&gt;last_task
op_assign
id|task
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|task-&gt;flags
op_amp
id|PF_EXITING
)paren
)paren
(brace
id|cpu_buf-&gt;buffer
(braket
id|cpu_buf-&gt;pos
)braket
dot
id|eip
op_assign
op_complement
l_int|0UL
suffix:semicolon
id|cpu_buf-&gt;buffer
(braket
id|cpu_buf-&gt;pos
)braket
dot
id|event
op_assign
(paren
r_int
r_int
)paren
id|task
suffix:semicolon
id|cpu_buf-&gt;pos
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* If the task is exiting it&squot;s not safe to take a sample&n;&t; * as the task_struct is about to be freed. We can&squot;t just&n;&t; * notify at release_task() time because of CLONE_DETACHED&n;&t; * tasks that release_task() themselves.&n;&t; */
r_if
c_cond
(paren
id|task-&gt;flags
op_amp
id|PF_EXITING
)paren
(brace
id|cpu_buf-&gt;sample_lost_task_exit
op_increment
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|cpu_buf-&gt;buffer
(braket
id|cpu_buf-&gt;pos
)braket
dot
id|eip
op_assign
id|eip
suffix:semicolon
id|cpu_buf-&gt;buffer
(braket
id|cpu_buf-&gt;pos
)braket
dot
id|event
op_assign
id|event
suffix:semicolon
id|cpu_buf-&gt;pos
op_increment
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|cpu_buf-&gt;int_lock
)paren
suffix:semicolon
)brace
eof
