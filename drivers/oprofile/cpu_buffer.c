multiline_comment|/**&n; * @file cpu_buffer.c&n; *&n; * @remark Copyright 2002 OProfile authors&n; * @remark Read the file COPYING&n; *&n; * @author John Levon &lt;levon@movementarian.org&gt;&n; *&n; * Each CPU has a local buffer that stores PC value/event&n; * pairs. We also log context switches when we notice them.&n; * Eventually each CPU&squot;s buffer is processed into the global&n; * event buffer by sync_cpu_buffers().&n; *&n; * We use a local buffer for two reasons: an NMI or similar&n; * interrupt cannot synchronise, and high sampling rates&n; * would lead to catastrophic global synchronisation if&n; * a global buffer was used.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &quot;cpu_buffer.h&quot;
macro_line|#include &quot;oprof.h&quot;
DECL|variable|__cacheline_aligned
r_struct
id|oprofile_cpu_buffer
id|cpu_buffer
(braket
id|NR_CPUS
)braket
id|__cacheline_aligned
suffix:semicolon
DECL|function|__free_cpu_buffers
r_static
r_void
id|__free_cpu_buffers
c_func
(paren
r_int
id|num
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|oprofile_cpu_buffer
op_star
id|b
op_assign
op_amp
id|cpu_buffer
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_possible
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|vfree
c_func
(paren
id|b-&gt;buffer
)paren
suffix:semicolon
)brace
)brace
DECL|function|alloc_cpu_buffers
r_int
id|alloc_cpu_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|buffer_size
op_assign
id|fs_cpu_buffer_size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|oprofile_cpu_buffer
op_star
id|b
op_assign
op_amp
id|cpu_buffer
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_possible
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|b-&gt;buffer
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|op_sample
)paren
op_star
id|buffer_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|b-&gt;buffer
)paren
r_goto
id|fail
suffix:semicolon
id|b-&gt;last_task
op_assign
l_int|0
suffix:semicolon
id|b-&gt;last_is_kernel
op_assign
op_minus
l_int|1
suffix:semicolon
id|b-&gt;buffer_size
op_assign
id|buffer_size
suffix:semicolon
id|b-&gt;tail_pos
op_assign
l_int|0
suffix:semicolon
id|b-&gt;head_pos
op_assign
l_int|0
suffix:semicolon
id|b-&gt;sample_received
op_assign
l_int|0
suffix:semicolon
id|b-&gt;sample_lost_overflow
op_assign
l_int|0
suffix:semicolon
id|b-&gt;sample_lost_task_exit
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|__free_cpu_buffers
c_func
(paren
id|i
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|free_cpu_buffers
r_void
id|free_cpu_buffers
c_func
(paren
r_void
)paren
(brace
id|__free_cpu_buffers
c_func
(paren
id|NR_CPUS
)paren
suffix:semicolon
)brace
multiline_comment|/* compute number of available slots in cpu_buffer queue */
DECL|function|nr_available_slots
r_static
r_int
r_int
id|nr_available_slots
c_func
(paren
r_struct
id|oprofile_cpu_buffer
r_const
op_star
id|b
)paren
(brace
r_int
r_int
id|head
op_assign
id|b-&gt;head_pos
suffix:semicolon
r_int
r_int
id|tail
op_assign
id|b-&gt;tail_pos
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_eq
id|head
)paren
r_return
id|b-&gt;buffer_size
suffix:semicolon
r_if
c_cond
(paren
id|tail
OG
id|head
)paren
r_return
id|tail
op_minus
id|head
suffix:semicolon
r_return
id|tail
op_plus
(paren
id|b-&gt;buffer_size
op_minus
id|head
)paren
suffix:semicolon
)brace
DECL|function|increment_head
r_static
r_void
id|increment_head
c_func
(paren
r_struct
id|oprofile_cpu_buffer
op_star
id|b
)paren
(brace
r_int
r_int
id|new_head
op_assign
id|b-&gt;head_pos
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Ensure anything written to the slot before we&n;&t; * increment is visible */
id|wmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_head
OL
(paren
id|b-&gt;buffer_size
)paren
)paren
id|b-&gt;head_pos
op_assign
id|new_head
suffix:semicolon
r_else
id|b-&gt;head_pos
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This must be safe from any context. It&squot;s safe writing here&n; * because of the head/tail separation of the writer and reader&n; * of the CPU buffer.&n; *&n; * is_kernel is needed because on some architectures you cannot&n; * tell if you are in kernel or user space simply by looking at&n; * eip. We tag this in the buffer by generating kernel enter/exit&n; * events whenever is_kernel changes&n; */
DECL|function|oprofile_add_sample
r_void
id|oprofile_add_sample
c_func
(paren
r_int
r_int
id|eip
comma
r_int
r_int
id|is_kernel
comma
r_int
r_int
id|event
comma
r_int
id|cpu
)paren
(brace
r_struct
id|oprofile_cpu_buffer
op_star
id|cpu_buf
op_assign
op_amp
id|cpu_buffer
(braket
id|cpu
)braket
suffix:semicolon
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|is_kernel
op_assign
op_logical_neg
op_logical_neg
id|is_kernel
suffix:semicolon
id|cpu_buf-&gt;sample_received
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|nr_available_slots
c_func
(paren
id|cpu_buf
)paren
OL
l_int|3
)paren
(brace
id|cpu_buf-&gt;sample_lost_overflow
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|task
op_assign
id|current
suffix:semicolon
multiline_comment|/* notice a switch from user-&gt;kernel or vice versa */
r_if
c_cond
(paren
id|cpu_buf-&gt;last_is_kernel
op_ne
id|is_kernel
)paren
(brace
id|cpu_buf-&gt;last_is_kernel
op_assign
id|is_kernel
suffix:semicolon
id|cpu_buf-&gt;buffer
(braket
id|cpu_buf-&gt;head_pos
)braket
dot
id|eip
op_assign
op_complement
l_int|0UL
suffix:semicolon
id|cpu_buf-&gt;buffer
(braket
id|cpu_buf-&gt;head_pos
)braket
dot
id|event
op_assign
id|is_kernel
suffix:semicolon
id|increment_head
c_func
(paren
id|cpu_buf
)paren
suffix:semicolon
)brace
multiline_comment|/* notice a task switch */
r_if
c_cond
(paren
id|cpu_buf-&gt;last_task
op_ne
id|task
)paren
(brace
id|cpu_buf-&gt;last_task
op_assign
id|task
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|task-&gt;flags
op_amp
id|PF_EXITING
)paren
)paren
(brace
id|cpu_buf-&gt;buffer
(braket
id|cpu_buf-&gt;head_pos
)braket
dot
id|eip
op_assign
op_complement
l_int|0UL
suffix:semicolon
id|cpu_buf-&gt;buffer
(braket
id|cpu_buf-&gt;head_pos
)braket
dot
id|event
op_assign
(paren
r_int
r_int
)paren
id|task
suffix:semicolon
id|increment_head
c_func
(paren
id|cpu_buf
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If the task is exiting it&squot;s not safe to take a sample&n;&t; * as the task_struct is about to be freed. We can&squot;t just&n;&t; * notify at release_task() time because of CLONE_DETACHED&n;&t; * tasks that release_task() themselves.&n;&t; */
r_if
c_cond
(paren
id|task-&gt;flags
op_amp
id|PF_EXITING
)paren
(brace
id|cpu_buf-&gt;sample_lost_task_exit
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cpu_buf-&gt;buffer
(braket
id|cpu_buf-&gt;head_pos
)braket
dot
id|eip
op_assign
id|eip
suffix:semicolon
id|cpu_buf-&gt;buffer
(braket
id|cpu_buf-&gt;head_pos
)braket
dot
id|event
op_assign
id|event
suffix:semicolon
id|increment_head
c_func
(paren
id|cpu_buf
)paren
suffix:semicolon
)brace
multiline_comment|/* resets the cpu buffer to a sane state - should be called with &n; * cpu_buf-&gt;int_lock held&n; */
DECL|function|cpu_buffer_reset
r_void
id|cpu_buffer_reset
c_func
(paren
r_struct
id|oprofile_cpu_buffer
op_star
id|cpu_buf
)paren
(brace
multiline_comment|/* reset these to invalid values; the next sample&n;&t; * collected will populate the buffer with proper&n;&t; * values to initialize the buffer&n;&t; */
id|cpu_buf-&gt;last_is_kernel
op_assign
op_minus
l_int|1
suffix:semicolon
id|cpu_buf-&gt;last_task
op_assign
l_int|0
suffix:semicolon
)brace
eof
