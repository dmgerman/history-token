multiline_comment|/**&n; * @file buffer_sync.c&n; *&n; * @remark Copyright 2002 OProfile authors&n; * @remark Read the file COPYING&n; *&n; * @author John Levon &lt;levon@movementarian.org&gt;&n; *&n; * This is the core of the buffer management. Each&n; * CPU buffer is processed and entered into the&n; * global event buffer. Such processing is necessary&n; * in several circumstances, mentioned below.&n; *&n; * The processing does the job of converting the&n; * transitory EIP value into a persistent dentry/offset&n; * value that the profiler can record at its leisure.&n; *&n; * See fs/dcookies.c for a description of the dentry/offset&n; * objects.&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/dcookies.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/profile.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &quot;event_buffer.h&quot;
macro_line|#include &quot;cpu_buffer.h&quot;
macro_line|#include &quot;oprofile_stats.h&quot;
DECL|macro|DEFAULT_EXPIRE
mdefine_line|#define DEFAULT_EXPIRE (HZ / 4)
r_static
r_void
id|wq_sync_buffers
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_static
id|DECLARE_WORK
c_func
(paren
id|sync_wq
comma
id|wq_sync_buffers
comma
l_int|0
)paren
suffix:semicolon
DECL|variable|sync_timer
r_static
r_struct
id|timer_list
id|sync_timer
suffix:semicolon
r_static
r_void
id|timer_ping
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|sync_cpu_buffers
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* We must make sure to process every entry in the CPU buffers&n; * before a task got the PF_EXITING flag, otherwise we will hold&n; * references to a possibly freed task_struct. We are safe with&n; * samples past the PF_EXITING point in do_exit(), because we&n; * explicitly check for that in cpu_buffer.c &n; */
DECL|function|exit_task_notify
r_static
r_int
id|exit_task_notify
c_func
(paren
r_struct
id|notifier_block
op_star
id|self
comma
r_int
r_int
id|val
comma
r_void
op_star
id|data
)paren
(brace
id|sync_cpu_buffers
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* There are two cases of tasks modifying task-&gt;mm-&gt;mmap list we&n; * must concern ourselves with. First, when a task is about to&n; * exit (exit_mmap()), we should process the buffer to deal with&n; * any samples in the CPU buffer, before we lose the -&gt;mmap information&n; * we need. Second, a task may unmap (part of) an executable mmap,&n; * so we want to process samples before that happens too&n; */
DECL|function|mm_notify
r_static
r_int
id|mm_notify
c_func
(paren
r_struct
id|notifier_block
op_star
id|self
comma
r_int
r_int
id|val
comma
r_void
op_star
id|data
)paren
(brace
id|sync_cpu_buffers
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|exit_task_nb
r_static
r_struct
id|notifier_block
id|exit_task_nb
op_assign
(brace
dot
id|notifier_call
op_assign
id|exit_task_notify
comma
)brace
suffix:semicolon
DECL|variable|exec_unmap_nb
r_static
r_struct
id|notifier_block
id|exec_unmap_nb
op_assign
(brace
dot
id|notifier_call
op_assign
id|mm_notify
comma
)brace
suffix:semicolon
DECL|variable|exit_mmap_nb
r_static
r_struct
id|notifier_block
id|exit_mmap_nb
op_assign
(brace
dot
id|notifier_call
op_assign
id|mm_notify
comma
)brace
suffix:semicolon
DECL|function|sync_start
r_int
id|sync_start
c_func
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
id|profile_event_register
c_func
(paren
id|EXIT_TASK
comma
op_amp
id|exit_task_nb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|profile_event_register
c_func
(paren
id|EXIT_MMAP
comma
op_amp
id|exit_mmap_nb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out2
suffix:semicolon
id|err
op_assign
id|profile_event_register
c_func
(paren
id|EXEC_UNMAP
comma
op_amp
id|exec_unmap_nb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out3
suffix:semicolon
id|sync_timer.function
op_assign
id|timer_ping
suffix:semicolon
id|sync_timer.expires
op_assign
id|jiffies
op_plus
id|DEFAULT_EXPIRE
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sync_timer
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out3
suffix:colon
id|profile_event_unregister
c_func
(paren
id|EXIT_MMAP
comma
op_amp
id|exit_mmap_nb
)paren
suffix:semicolon
id|out2
suffix:colon
id|profile_event_unregister
c_func
(paren
id|EXIT_TASK
comma
op_amp
id|exit_task_nb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|sync_stop
r_void
id|sync_stop
c_func
(paren
r_void
)paren
(brace
id|profile_event_unregister
c_func
(paren
id|EXIT_TASK
comma
op_amp
id|exit_task_nb
)paren
suffix:semicolon
id|profile_event_unregister
c_func
(paren
id|EXIT_MMAP
comma
op_amp
id|exit_mmap_nb
)paren
suffix:semicolon
id|profile_event_unregister
c_func
(paren
id|EXEC_UNMAP
comma
op_amp
id|exec_unmap_nb
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|sync_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* Optimisation. We can manage without taking the dcookie sem&n; * because we cannot reach this code without at least one&n; * dcookie user still being registered (namely, the reader&n; * of the event buffer). */
DECL|function|fast_get_dcookie
r_static
r_inline
id|u32
id|fast_get_dcookie
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|vfsmount
op_star
id|vfsmnt
)paren
(brace
id|u32
id|cookie
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_cookie
)paren
r_return
(paren
id|u32
)paren
id|dentry
suffix:semicolon
id|get_dcookie
c_func
(paren
id|dentry
comma
id|vfsmnt
comma
op_amp
id|cookie
)paren
suffix:semicolon
r_return
id|cookie
suffix:semicolon
)brace
multiline_comment|/* Look up the dcookie for the task&squot;s first VM_EXECUTABLE mapping,&n; * which corresponds loosely to &quot;application name&quot;. This is&n; * not strictly necessary but allows oprofile to associate&n; * shared-library samples with particular applications&n; */
DECL|function|get_exec_dcookie
r_static
id|u32
id|get_exec_dcookie
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|u32
id|cookie
op_assign
l_int|0
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
r_goto
id|out
suffix:semicolon
r_for
c_loop
(paren
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|vma
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;vm_file
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;vm_flags
op_amp
id|VM_EXECUTABLE
)paren
r_continue
suffix:semicolon
id|cookie
op_assign
id|fast_get_dcookie
c_func
(paren
id|vma-&gt;vm_file-&gt;f_dentry
comma
id|vma-&gt;vm_file-&gt;f_vfsmnt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|cookie
suffix:semicolon
)brace
multiline_comment|/* Convert the EIP value of a sample into a persistent dentry/offset&n; * pair that can then be added to the global event buffer. We make&n; * sure to do this lookup before a mm-&gt;mmap modification happens so&n; * we don&squot;t lose track.&n; */
DECL|function|lookup_dcookie
r_static
id|u32
id|lookup_dcookie
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
comma
id|off_t
op_star
id|offset
)paren
(brace
id|u32
id|cookie
op_assign
l_int|0
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_for
c_loop
(paren
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|addr
)paren
suffix:semicolon
id|vma
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;vm_file
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|addr
OL
id|vma-&gt;vm_start
op_logical_or
id|addr
op_ge
id|vma-&gt;vm_end
)paren
r_continue
suffix:semicolon
id|cookie
op_assign
id|fast_get_dcookie
c_func
(paren
id|vma-&gt;vm_file-&gt;f_dentry
comma
id|vma-&gt;vm_file-&gt;f_vfsmnt
)paren
suffix:semicolon
op_star
id|offset
op_assign
(paren
id|vma-&gt;vm_pgoff
op_lshift
id|PAGE_SHIFT
)paren
op_plus
id|addr
op_minus
id|vma-&gt;vm_start
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|cookie
suffix:semicolon
)brace
DECL|variable|last_cookie
r_static
id|u32
id|last_cookie
op_assign
op_complement
l_int|0UL
suffix:semicolon
DECL|function|add_cpu_switch
r_static
r_void
id|add_cpu_switch
c_func
(paren
r_int
id|i
)paren
(brace
id|add_event_entry
c_func
(paren
id|ESCAPE_CODE
)paren
suffix:semicolon
id|add_event_entry
c_func
(paren
id|CPU_SWITCH_CODE
)paren
suffix:semicolon
id|add_event_entry
c_func
(paren
id|i
)paren
suffix:semicolon
id|last_cookie
op_assign
op_complement
l_int|0UL
suffix:semicolon
)brace
DECL|function|add_ctx_switch
r_static
r_void
id|add_ctx_switch
c_func
(paren
id|pid_t
id|pid
comma
id|u32
id|cookie
)paren
(brace
id|add_event_entry
c_func
(paren
id|ESCAPE_CODE
)paren
suffix:semicolon
id|add_event_entry
c_func
(paren
id|CTX_SWITCH_CODE
)paren
suffix:semicolon
id|add_event_entry
c_func
(paren
id|pid
)paren
suffix:semicolon
id|add_event_entry
c_func
(paren
id|cookie
)paren
suffix:semicolon
)brace
DECL|function|add_cookie_switch
r_static
r_void
id|add_cookie_switch
c_func
(paren
id|u32
id|cookie
)paren
(brace
id|add_event_entry
c_func
(paren
id|ESCAPE_CODE
)paren
suffix:semicolon
id|add_event_entry
c_func
(paren
id|COOKIE_SWITCH_CODE
)paren
suffix:semicolon
id|add_event_entry
c_func
(paren
id|cookie
)paren
suffix:semicolon
)brace
DECL|function|add_sample_entry
r_static
r_void
id|add_sample_entry
c_func
(paren
r_int
r_int
id|offset
comma
r_int
r_int
id|event
)paren
(brace
id|add_event_entry
c_func
(paren
id|offset
)paren
suffix:semicolon
id|add_event_entry
c_func
(paren
id|event
)paren
suffix:semicolon
)brace
DECL|function|add_us_sample
r_static
r_void
id|add_us_sample
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|op_sample
op_star
id|s
)paren
(brace
id|u32
id|cookie
suffix:semicolon
id|off_t
id|offset
suffix:semicolon
id|cookie
op_assign
id|lookup_dcookie
c_func
(paren
id|mm
comma
id|s-&gt;eip
comma
op_amp
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cookie
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|cookie
op_ne
id|last_cookie
)paren
(brace
id|add_cookie_switch
c_func
(paren
id|cookie
)paren
suffix:semicolon
id|last_cookie
op_assign
id|cookie
suffix:semicolon
)brace
id|add_sample_entry
c_func
(paren
id|offset
comma
id|s-&gt;event
)paren
suffix:semicolon
)brace
DECL|function|is_kernel
r_static
r_inline
r_int
id|is_kernel
c_func
(paren
r_int
r_int
id|val
)paren
(brace
r_return
id|val
OG
id|__PAGE_OFFSET
suffix:semicolon
)brace
multiline_comment|/* Add a sample to the global event buffer. If possible the&n; * sample is converted into a persistent dentry/offset pair&n; * for later lookup from userspace.&n; */
DECL|function|add_sample
r_static
r_void
id|add_sample
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|op_sample
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
id|is_kernel
c_func
(paren
id|s-&gt;eip
)paren
)paren
(brace
id|add_sample_entry
c_func
(paren
id|s-&gt;eip
comma
id|s-&gt;event
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mm
)paren
(brace
id|add_us_sample
c_func
(paren
id|mm
comma
id|s
)paren
suffix:semicolon
)brace
)brace
DECL|function|release_mm
r_static
r_void
id|release_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm
)paren
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* Take the task&squot;s mmap_sem to protect ourselves from&n; * races when we do lookup_dcookie().&n; */
DECL|function|take_task_mm
r_static
r_struct
id|mm_struct
op_star
id|take_task_mm
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
id|task_lock
c_func
(paren
id|task
)paren
suffix:semicolon
id|mm
op_assign
id|task-&gt;mm
suffix:semicolon
id|task_unlock
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* if task-&gt;mm !NULL, mm_count must be at least 1. It cannot&n;&t; * drop to 0 without the task exiting, which will have to sleep&n;&t; * on buffer_sem first. So we do not need to mark mm_count&n;&t; * ourselves.&n;&t; */
r_if
c_cond
(paren
id|mm
)paren
(brace
multiline_comment|/* More ugliness. If a task took its mmap&n;&t;&t; * sem then came to sleep on buffer_sem we&n;&t;&t; * will deadlock waiting for it. So we can&n;&t;&t; * but try. This will lose samples :/&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|down_read_trylock
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
)paren
(brace
multiline_comment|/* FIXME: this underestimates samples lost */
id|atomic_inc
c_func
(paren
op_amp
id|oprofile_stats.sample_lost_mmap_sem
)paren
suffix:semicolon
id|mm
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|mm
suffix:semicolon
)brace
DECL|function|is_ctx_switch
r_static
r_inline
r_int
id|is_ctx_switch
c_func
(paren
r_int
r_int
id|val
)paren
(brace
r_return
id|val
op_eq
op_complement
l_int|0UL
suffix:semicolon
)brace
multiline_comment|/* Sync one of the CPU&squot;s buffers into the global event buffer.&n; * Here we need to go through each batch of samples punctuated&n; * by context switch notes, taking the task&squot;s mmap_sem and doing&n; * lookup in task-&gt;mm-&gt;mmap to convert EIP into dcookie/offset&n; * value.&n; */
DECL|function|sync_buffer
r_static
r_void
id|sync_buffer
c_func
(paren
r_struct
id|oprofile_cpu_buffer
op_star
id|cpu_buf
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
r_new
suffix:semicolon
id|u32
id|cookie
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cpu_buf-&gt;pos
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|op_sample
op_star
id|s
op_assign
op_amp
id|cpu_buf-&gt;buffer
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|is_ctx_switch
c_func
(paren
id|s-&gt;eip
)paren
)paren
(brace
r_new
op_assign
(paren
r_struct
id|task_struct
op_star
)paren
id|s-&gt;event
suffix:semicolon
id|release_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
id|mm
op_assign
id|take_task_mm
c_func
(paren
r_new
)paren
suffix:semicolon
id|cookie
op_assign
id|get_exec_dcookie
c_func
(paren
id|mm
)paren
suffix:semicolon
id|add_ctx_switch
c_func
(paren
r_new
op_member_access_from_pointer
id|pid
comma
id|cookie
)paren
suffix:semicolon
)brace
r_else
(brace
id|add_sample
c_func
(paren
id|mm
comma
id|s
)paren
suffix:semicolon
)brace
)brace
id|release_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
id|cpu_buf-&gt;pos
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Process each CPU&squot;s local buffer into the global&n; * event buffer.&n; */
DECL|function|sync_cpu_buffers
r_static
r_void
id|sync_cpu_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|down
c_func
(paren
op_amp
id|buffer_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|oprofile_cpu_buffer
op_star
id|cpu_buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_possible
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|cpu_buf
op_assign
op_amp
id|cpu_buffer
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* We take a spin lock even though we might&n;&t;&t; * sleep. It&squot;s OK because other users are try&n;&t;&t; * lockers only, and this region is already&n;&t;&t; * protected by buffer_sem. It&squot;s raw to prevent&n;&t;&t; * the preempt bogometer firing. Fruity, huh ? */
id|_raw_spin_lock
c_func
(paren
op_amp
id|cpu_buf-&gt;int_lock
)paren
suffix:semicolon
id|add_cpu_switch
c_func
(paren
id|i
)paren
suffix:semicolon
id|sync_buffer
c_func
(paren
id|cpu_buf
)paren
suffix:semicolon
id|_raw_spin_unlock
c_func
(paren
op_amp
id|cpu_buf-&gt;int_lock
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|buffer_sem
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|sync_timer
comma
id|jiffies
op_plus
id|DEFAULT_EXPIRE
)paren
suffix:semicolon
)brace
DECL|function|wq_sync_buffers
r_static
r_void
id|wq_sync_buffers
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|sync_cpu_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* It is possible that we could have no munmap() or&n; * other events for a period of time. This will lead&n; * the CPU buffers to overflow and lose samples and&n; * context switches. We try to reduce the problem&n; * by timing out when nothing happens for a while.&n; */
DECL|function|timer_ping
r_static
r_void
id|timer_ping
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|schedule_work
c_func
(paren
op_amp
id|sync_wq
)paren
suffix:semicolon
multiline_comment|/* timer is re-added by the scheduled task */
)brace
eof
