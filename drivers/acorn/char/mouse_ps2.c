multiline_comment|/* &n; * Driver for PS/2 mouse on IOMD interface&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/kbd_ll.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/hardware/iomd.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*&n; *&t;PS/2 Auxiliary Device&n; */
DECL|variable|queue
r_static
r_struct
id|aux_queue
op_star
id|queue
suffix:semicolon
multiline_comment|/* Mouse data buffer. */
DECL|variable|aux_count
r_static
r_int
id|aux_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used when we send commands to the mouse that expect an ACK. */
DECL|variable|mouse_reply_expected
r_static
r_int
r_char
id|mouse_reply_expected
op_assign
l_int|0
suffix:semicolon
DECL|macro|MAX_RETRIES
mdefine_line|#define MAX_RETRIES&t;60&t;&t;/* some aux operations take long time*/
multiline_comment|/*&n; *&t;Mouse Commands&n; */
DECL|macro|AUX_SET_RES
mdefine_line|#define AUX_SET_RES&t;&t;0xE8&t;/* Set resolution */
DECL|macro|AUX_SET_SCALE11
mdefine_line|#define AUX_SET_SCALE11&t;&t;0xE6&t;/* Set 1:1 scaling */
DECL|macro|AUX_SET_SCALE21
mdefine_line|#define AUX_SET_SCALE21&t;&t;0xE7&t;/* Set 2:1 scaling */
DECL|macro|AUX_GET_SCALE
mdefine_line|#define AUX_GET_SCALE&t;&t;0xE9&t;/* Get scaling factor */
DECL|macro|AUX_SET_STREAM
mdefine_line|#define AUX_SET_STREAM&t;&t;0xEA&t;/* Set stream mode */
DECL|macro|AUX_SET_SAMPLE
mdefine_line|#define AUX_SET_SAMPLE&t;&t;0xF3&t;/* Set sample rate */
DECL|macro|AUX_ENABLE_DEV
mdefine_line|#define AUX_ENABLE_DEV&t;&t;0xF4&t;/* Enable aux device */
DECL|macro|AUX_DISABLE_DEV
mdefine_line|#define AUX_DISABLE_DEV&t;&t;0xF5&t;/* Disable aux device */
DECL|macro|AUX_RESET
mdefine_line|#define AUX_RESET&t;&t;0xFF&t;/* Reset aux device */
DECL|macro|AUX_ACK
mdefine_line|#define AUX_ACK&t;&t;&t;0xFA&t;/* Command byte ACK. */
DECL|macro|AUX_BUF_SIZE
mdefine_line|#define AUX_BUF_SIZE&t;&t;2048&t;/* This might be better divisible by&n;&t;&t;&t;&t;&t;   three to make overruns stay in sync&n;&t;&t;&t;&t;&t;   but then the read function would &n;&t;&t;&t;&t;&t;   need a lock etc - ick */
DECL|struct|aux_queue
r_struct
id|aux_queue
(brace
DECL|member|head
r_int
r_int
id|head
suffix:semicolon
DECL|member|tail
r_int
r_int
id|tail
suffix:semicolon
DECL|member|proc_list
id|wait_queue_head_t
id|proc_list
suffix:semicolon
DECL|member|fasync
r_struct
id|fasync_struct
op_star
id|fasync
suffix:semicolon
DECL|member|buf
r_int
r_char
id|buf
(braket
id|AUX_BUF_SIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Send a byte to the mouse.&n; */
DECL|function|aux_write_dev
r_static
r_void
id|aux_write_dev
c_func
(paren
r_int
id|val
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|iomd_readb
c_func
(paren
id|IOMD_MSECTL
)paren
op_amp
l_int|0x80
)paren
)paren
suffix:semicolon
id|iomd_writeb
c_func
(paren
id|val
comma
id|IOMD_MSEDAT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a byte to the mouse &amp; handle returned ack&n; */
DECL|function|aux_write_ack
r_static
r_void
id|aux_write_ack
c_func
(paren
r_int
id|val
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|iomd_readb
c_func
(paren
id|IOMD_MSECTL
)paren
op_amp
l_int|0x80
)paren
)paren
suffix:semicolon
id|iomd_writeb
c_func
(paren
id|val
comma
id|IOMD_MSEDAT
)paren
suffix:semicolon
multiline_comment|/* we expect an ACK in response. */
id|mouse_reply_expected
op_increment
suffix:semicolon
)brace
DECL|function|get_from_queue
r_static
r_int
r_char
id|get_from_queue
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|result
suffix:semicolon
id|result
op_assign
id|queue-&gt;buf
(braket
id|queue-&gt;tail
)braket
suffix:semicolon
id|queue-&gt;tail
op_assign
(paren
id|queue-&gt;tail
op_plus
l_int|1
)paren
op_amp
(paren
id|AUX_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|psaux_interrupt
r_static
r_void
id|psaux_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|val
op_assign
id|iomd_readb
c_func
(paren
id|IOMD_MSEDAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mouse_reply_expected
)paren
(brace
r_if
c_cond
(paren
id|val
op_eq
id|AUX_ACK
)paren
(brace
id|mouse_reply_expected
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mouse_reply_expected
op_assign
l_int|0
suffix:semicolon
)brace
id|add_mouse_randomness
c_func
(paren
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aux_count
)paren
(brace
r_int
id|head
op_assign
id|queue-&gt;head
suffix:semicolon
id|queue-&gt;buf
(braket
id|head
)braket
op_assign
id|val
suffix:semicolon
id|head
op_assign
(paren
id|head
op_plus
l_int|1
)paren
op_amp
(paren
id|AUX_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ne
id|queue-&gt;tail
)paren
(brace
id|queue-&gt;head
op_assign
id|head
suffix:semicolon
id|kill_fasync
c_func
(paren
op_amp
id|queue-&gt;fasync
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|queue-&gt;proc_list
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|queue_empty
r_static
r_inline
r_int
id|queue_empty
c_func
(paren
r_void
)paren
(brace
r_return
id|queue-&gt;head
op_eq
id|queue-&gt;tail
suffix:semicolon
)brace
DECL|function|fasync_aux
r_static
r_int
id|fasync_aux
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|fasync_helper
c_func
(paren
id|fd
comma
id|filp
comma
id|on
comma
op_amp
id|queue-&gt;fasync
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Random magic cookie for the aux device&n; */
DECL|macro|AUX_DEV
mdefine_line|#define AUX_DEV ((void *)queue)
DECL|function|release_aux
r_static
r_int
id|release_aux
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|fasync_aux
c_func
(paren
op_minus
l_int|1
comma
id|file
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|aux_count
)paren
r_return
l_int|0
suffix:semicolon
id|free_irq
c_func
(paren
id|IRQ_MOUSERX
comma
id|AUX_DEV
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Install interrupt handler.&n; * Enable auxiliary device.&n; */
DECL|function|open_aux
r_static
r_int
id|open_aux
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
id|aux_count
op_increment
)paren
r_return
l_int|0
suffix:semicolon
id|queue-&gt;head
op_assign
id|queue-&gt;tail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Flush input queue */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|IRQ_MOUSERX
comma
id|psaux_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;ps/2 mouse&quot;
comma
id|AUX_DEV
)paren
)paren
(brace
id|aux_count
op_decrement
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|aux_write_ack
c_func
(paren
id|AUX_ENABLE_DEV
)paren
suffix:semicolon
multiline_comment|/* Enable aux device */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Put bytes from input queue to buffer.&n; */
DECL|function|read_aux
r_static
id|ssize_t
id|read_aux
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|ssize_t
id|i
op_assign
id|count
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|queue_empty
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|queue-&gt;proc_list
comma
op_amp
id|wait
)paren
suffix:semicolon
id|repeat
suffix:colon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
id|queue_empty
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|queue-&gt;proc_list
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OG
l_int|0
op_logical_and
op_logical_neg
id|queue_empty
c_func
(paren
)paren
)paren
(brace
id|c
op_assign
id|get_from_queue
c_func
(paren
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|c
comma
id|buffer
op_increment
)paren
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_minus
id|i
)paren
(brace
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_return
id|count
op_minus
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Write to the aux device.&n; */
DECL|function|write_aux
r_static
id|ssize_t
id|write_aux
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ssize_t
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|ssize_t
id|written
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|32
)paren
id|count
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* Limit to 32 bytes. */
r_do
(brace
r_char
id|c
suffix:semicolon
id|get_user
c_func
(paren
id|c
comma
id|buffer
op_increment
)paren
suffix:semicolon
id|aux_write_dev
c_func
(paren
id|c
)paren
suffix:semicolon
id|written
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|written
)paren
(brace
id|retval
op_assign
id|written
suffix:semicolon
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|aux_poll
r_static
r_int
r_int
id|aux_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|queue-&gt;proc_list
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|queue_empty
c_func
(paren
)paren
)paren
r_return
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|psaux_fops
r_struct
id|file_operations
id|psaux_fops
op_assign
(brace
id|read
suffix:colon
id|read_aux
comma
id|write
suffix:colon
id|write_aux
comma
id|poll
suffix:colon
id|aux_poll
comma
id|open
suffix:colon
id|open_aux
comma
id|release
suffix:colon
id|release_aux
comma
id|fasync
suffix:colon
id|fasync_aux
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Initialize driver.&n; */
DECL|variable|psaux_mouse
r_static
r_struct
id|miscdevice
id|psaux_mouse
op_assign
(brace
id|PSMOUSE_MINOR
comma
l_string|&quot;psaux&quot;
comma
op_amp
id|psaux_fops
)brace
suffix:semicolon
DECL|function|psaux_init
r_int
id|__init
id|psaux_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Reset the mouse state machine. */
id|iomd_writeb
c_func
(paren
l_int|0
comma
id|IOMD_MSECTL
)paren
suffix:semicolon
id|iomd_writeb
c_func
(paren
l_int|8
comma
id|IOMD_MSECTL
)paren
suffix:semicolon
id|misc_register
c_func
(paren
op_amp
id|psaux_mouse
)paren
suffix:semicolon
id|queue
op_assign
(paren
r_struct
id|aux_queue
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|queue
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|queue
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|queue
)paren
)paren
suffix:semicolon
id|queue-&gt;head
op_assign
id|queue-&gt;tail
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|queue-&gt;proc_list
)paren
suffix:semicolon
id|aux_write_ack
c_func
(paren
id|AUX_SET_SAMPLE
)paren
suffix:semicolon
id|aux_write_ack
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* 100 samples/sec */
id|aux_write_ack
c_func
(paren
id|AUX_SET_RES
)paren
suffix:semicolon
id|aux_write_ack
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* 8 counts per mm */
id|aux_write_ack
c_func
(paren
id|AUX_SET_SCALE21
)paren
suffix:semicolon
multiline_comment|/* 2:1 scaling */
r_return
l_int|0
suffix:semicolon
)brace
eof
