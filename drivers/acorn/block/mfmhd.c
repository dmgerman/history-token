multiline_comment|/*&n; * linux/arch/arm/drivers/block/mfmhd.c&n; *&n; * Copyright (C) 1995, 1996 Russell King, Dave Alan Gilbert (gilbertd@cs.man.ac.uk)&n; *&n; * MFM hard drive code [experimental]&n; */
multiline_comment|/*&n; * Change list:&n; *&n; *  3/2/96:DAG: Started a change list :-)&n; *              Set the hardsect_size pointers up since we are running 256 byte&n; *                sectors&n; *              Added DMA code, put it into the rw_intr&n; *              Moved RCAL out of generic interrupt code - don&squot;t want to do it&n; *                while DMA&squot;ing - its now in individual handlers.&n; *              Took interrupt handlers off task queue lists and called&n; *                directly - not sure of implications.&n; *&n; * 18/2/96:DAG: Well its reading OK I think, well enough for image file code&n; *              to find the image file; but now I&squot;ve discovered that I actually&n; *              have to put some code in for image files.&n; *&n; *              Added stuff for image files; seems to work, but I&squot;ve not&n; *              got a multisegment image file (I don&squot;t think!).&n; *              Put in a hack (yep a real hack) for multiple cylinder reads.&n; *              Not convinced its working.&n; *&n; *  5/4/96:DAG: Added asm/hardware.h and use IOC_ macros&n; *              Rewrote dma code in mfm.S (again!) - now takes a word at a time&n; *              from main RAM for speed; still doesn&squot;t feel speedy!&n; *&n; * 20/4/96:DAG: After rewriting mfm.S a heck of a lot of times and speeding&n; *              things up, I&squot;ve finally figured out why its so damn slow.&n; *              Linux is only reading a block at a time, and so you never&n; *              get more than 1K per disc revoloution ~=60K/second.&n; *&n; * 27/4/96:DAG: On Russell&squot;s advice I change ll_rw_blk.c to ask it to&n; *              join adjacent blocks together. Everything falls flat on its&n; *              face.&n; *              Four hours of debugging later; I hadn&squot;t realised that&n; *              ll_rw_blk would be so generous as to join blocks whose&n; *              results aren&squot;t going into consecutive buffers.&n; * &n; *              OK; severe rehacking of mfm_rw_interrupt; now end_request&squot;s&n; *              as soon as its DMA&squot;d each request.  Odd thing is that&n; *              we are sometimes getting interrupts where we are not transferring&n; *              any data; why? Is that what happens when you miss? I doubt&n; *              it; are we too fast? No - its just at command ends. Got 240K/s&n; *              better than before, but RiscOS hits 480K/s&n; *&n; * 25/6/96:RMK: Fixed init code to allow the MFM podule to work.  Increased the&n; *              number of errors for my Miniscribe drive (8425).&n; *&n; * 30/6/96:DAG: Russell suggested that a check drive 0 might turn the LEDs off&n; *              - so in request_done just before it clears Busy it sends a&n; *              check drive 0 - and the LEDs go off!!!!&n; *&n; *              Added test for mainboard controller. - Removes need for separate&n; *              define.&n; *&n; * 13/7/96:DAG: Changed hardware sectore size to 512 in attempt to make&n; *              IM drivers work.&n; * 21/7/96:DAG: Took out old image file stuff (accessing it now produces an IO&n; *              error.)&n; *&n; * 17/8/96:DAG: Ran through indent -kr -i8; evil - all my nice 2 character indents&n; *              gone :-( Hand modified afterwards.&n; *&t;&t;Took out last remains of the older image map system.&n; *&n; * 22/9/96:DAG:&t;Changed mfm.S so it will carry on DMA&squot;ing til; BSY is dropped&n; *&t;&t;Changed mfm_rw_intr so that it doesn&squot;t follow the error&n; *&t;&t;code until BSY is dropped. Nope - still broke. Problem&n; *&t;&t;may revolve around when it reads the results for the error&n; *&t;&t;number?&n; *&n; *16/11/96:DAG:&t;Modified for 2.0.18; request_irq changed&n; *&n; *17/12/96:RMK: Various cleanups, reorganisation, and the changes for new IO system.&n; *&t;&t;Improved probe for onboard MFM chip - it was hanging on my A5k.&n; *&t;&t;Added autodetect CHS code such that we don&squot;t rely on the presence&n; *&t;&t;of an ADFS boot block.  Added ioport resource manager calls so&n; *&t;&t;that we don&squot;t clash with already-running hardware (eg. RiscPC Ether&n; *&t;&t;card slots if someone tries this)!&n; *&n; * 17/1/97:RMK:&t;Upgraded to 2.1 kernels.&n; *&n; *  4/3/98:RMK:&t;Changed major number to 21.&n; *&n; * 27/6/98:RMK:&t;Changed asm/delay.h to linux/delay.h for mdelay().&n; */
multiline_comment|/*&n; * Possible enhancements:&n; *  Multi-thread the code so that it is possible that while one drive&n; *  is seeking, the other one can be reading data/seeking as well.&n; *  This would be a performance boost with dual drive systems.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/ecard.h&gt;
macro_line|#include &lt;asm/hardware/ioc.h&gt;
DECL|variable|do_mfm
r_static
r_void
(paren
op_star
id|do_mfm
)paren
(paren
r_void
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|mfm_queue
r_static
r_struct
id|request_queue
op_star
id|mfm_queue
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|mfm_lock
)paren
suffix:semicolon
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR&t;MFM_ACORN_MAJOR
DECL|macro|QUEUE
mdefine_line|#define QUEUE (mfm_queue)
DECL|macro|CURRENT
mdefine_line|#define CURRENT elv_next_request(mfm_queue)
multiline_comment|/*&n; * This sort of stuff should be in a header file shared with ide.c, hd.c, xd.c etc&n; */
macro_line|#ifndef HDIO_GETGEO
DECL|macro|HDIO_GETGEO
mdefine_line|#define HDIO_GETGEO 0x301
DECL|struct|hd_geometry
r_struct
id|hd_geometry
(brace
DECL|member|heads
r_int
r_char
id|heads
suffix:semicolon
DECL|member|sectors
r_int
r_char
id|sectors
suffix:semicolon
DECL|member|cylinders
r_int
r_int
id|cylinders
suffix:semicolon
DECL|member|start
r_int
r_int
id|start
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Configuration section&n; *&n; * This is the maximum number of drives that we accept&n; */
DECL|macro|MFM_MAXDRIVES
mdefine_line|#define MFM_MAXDRIVES 2
multiline_comment|/*&n; * Linux I/O address of onboard MFM controller or 0 to disable this&n; */
DECL|macro|ONBOARD_MFM_ADDRESS
mdefine_line|#define ONBOARD_MFM_ADDRESS ((0x002d0000 &gt;&gt; 2) | 0x80000000)
multiline_comment|/*&n; * Uncomment this to enable debugging in the MFM driver...&n; */
macro_line|#ifndef DEBUG
multiline_comment|/*#define DEBUG */
macro_line|#endif
multiline_comment|/*&n; * End of configuration&n; */
multiline_comment|/*&n; * This structure contains all information to do with a particular physical&n; * device.&n; */
DECL|struct|mfm_info
r_struct
id|mfm_info
(brace
DECL|member|sectors
r_int
r_char
id|sectors
suffix:semicolon
DECL|member|heads
r_int
r_char
id|heads
suffix:semicolon
DECL|member|cylinders
r_int
r_int
id|cylinders
suffix:semicolon
DECL|member|lowcurrent
r_int
r_int
id|lowcurrent
suffix:semicolon
DECL|member|precomp
r_int
r_int
id|precomp
suffix:semicolon
DECL|macro|NO_TRACK
mdefine_line|#define NO_TRACK -1
DECL|macro|NEED_1_RECAL
mdefine_line|#define NEED_1_RECAL -2
DECL|macro|NEED_2_RECAL
mdefine_line|#define NEED_2_RECAL -3
DECL|member|cylinder
r_int
id|cylinder
suffix:semicolon
r_struct
(brace
DECL|member|recal
r_char
id|recal
suffix:semicolon
DECL|member|report
r_char
id|report
suffix:semicolon
DECL|member|abort
r_char
m_abort
suffix:semicolon
DECL|member|errors
)brace
id|errors
suffix:semicolon
DECL|variable|mfm_info
)brace
id|mfm_info
(braket
id|MFM_MAXDRIVES
)braket
suffix:semicolon
DECL|macro|MFM_DRV_INFO
mdefine_line|#define MFM_DRV_INFO mfm_info[raw_cmd.dev]
multiline_comment|/* Stuff from the assembly routines */
r_extern
r_int
r_int
id|hdc63463_baseaddress
suffix:semicolon
multiline_comment|/* Controller base address */
r_extern
r_int
r_int
id|hdc63463_irqpolladdress
suffix:semicolon
multiline_comment|/* Address to read to test for int */
r_extern
r_int
r_int
id|hdc63463_irqpollmask
suffix:semicolon
multiline_comment|/* Mask for irq register */
r_extern
r_int
r_int
id|hdc63463_dataptr
suffix:semicolon
multiline_comment|/* Pointer to kernel data space to DMA */
r_extern
r_int
id|hdc63463_dataleft
suffix:semicolon
multiline_comment|/* Number of bytes left to transfer */
DECL|variable|lastspecifieddrive
r_static
r_int
id|lastspecifieddrive
suffix:semicolon
DECL|variable|Busy
r_static
r_int
id|Busy
suffix:semicolon
DECL|variable|PartFragRead
r_static
r_int
r_int
id|PartFragRead
suffix:semicolon
multiline_comment|/* The number of sectors which have been read&n;&t;&t;&t;&t;&t;   during a partial read split over two&n;&t;&t;&t;&t;&t;   cylinders.  If 0 it means a partial&n;&t;&t;&t;&t;&t;   read did not occur. */
DECL|variable|PartFragRead_RestartBlock
r_static
r_int
r_int
id|PartFragRead_RestartBlock
suffix:semicolon
multiline_comment|/* Where to restart on a split access */
DECL|variable|PartFragRead_SectorsLeft
r_static
r_int
r_int
id|PartFragRead_SectorsLeft
suffix:semicolon
multiline_comment|/* Where to restart on a split access */
DECL|variable|Sectors256LeftInCurrent
r_static
r_int
id|Sectors256LeftInCurrent
suffix:semicolon
multiline_comment|/* i.e. 256 byte sectors left in current */
DECL|variable|SectorsLeftInRequest
r_static
r_int
id|SectorsLeftInRequest
suffix:semicolon
multiline_comment|/* i.e. blocks left in the thing mfm_request was called for */
DECL|variable|Copy_Sector
r_static
r_int
id|Copy_Sector
suffix:semicolon
multiline_comment|/* The 256 byte sector we are currently at - fragments need to know &n;&t;&t;&t;&t;   where to take over */
DECL|variable|Copy_buffer
r_static
r_char
op_star
id|Copy_buffer
suffix:semicolon
r_static
r_void
id|mfm_seek
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mfm_rerequest
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mfm_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mfm_specify
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|issue_request
c_func
(paren
r_int
r_int
id|block
comma
r_int
r_int
id|nsect
comma
r_struct
id|request
op_star
id|req
)paren
suffix:semicolon
DECL|variable|mfm_addr
r_static
r_int
r_int
id|mfm_addr
suffix:semicolon
multiline_comment|/* Controller address */
DECL|variable|mfm_IRQPollLoc
r_static
r_int
r_int
id|mfm_IRQPollLoc
suffix:semicolon
multiline_comment|/* Address to read for IRQ information */
DECL|variable|mfm_irqenable
r_static
r_int
r_int
id|mfm_irqenable
suffix:semicolon
multiline_comment|/* Podule IRQ enable location */
DECL|variable|mfm_irq
r_static
r_int
r_char
id|mfm_irq
suffix:semicolon
multiline_comment|/* Interrupt number */
DECL|variable|mfm_drives
r_static
r_int
id|mfm_drives
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* drives available */
DECL|variable|mfm_status
r_static
r_int
id|mfm_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* interrupt status */
DECL|variable|errors
r_static
r_int
op_star
id|errors
suffix:semicolon
DECL|struct|rawcmd
r_static
r_struct
id|rawcmd
(brace
DECL|member|dev
r_int
r_int
id|dev
suffix:semicolon
DECL|member|cylinder
r_int
r_int
id|cylinder
suffix:semicolon
DECL|member|head
r_int
r_int
id|head
suffix:semicolon
DECL|member|sector
r_int
r_int
id|sector
suffix:semicolon
DECL|member|cmdtype
r_int
r_int
id|cmdtype
suffix:semicolon
DECL|member|cmdcode
r_int
r_int
id|cmdcode
suffix:semicolon
DECL|member|cmddata
r_int
r_char
id|cmddata
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|cmdlen
r_int
r_int
id|cmdlen
suffix:semicolon
DECL|variable|raw_cmd
)brace
id|raw_cmd
suffix:semicolon
DECL|variable|result
r_static
r_int
r_char
id|result
(braket
l_int|16
)braket
suffix:semicolon
DECL|struct|cont
r_static
r_struct
id|cont
(brace
DECL|member|interrupt
r_void
(paren
op_star
id|interrupt
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* interrupt handler */
DECL|member|error
r_void
(paren
op_star
id|error
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* error handler */
DECL|member|redo
r_void
(paren
op_star
id|redo
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* redo handler */
DECL|member|done
r_void
(paren
op_star
id|done
)paren
(paren
r_int
id|st
)paren
suffix:semicolon
multiline_comment|/* done handler */
DECL|variable|cont
)brace
op_star
id|cont
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if 0
r_static
r_struct
id|tq_struct
id|mfm_tq
op_assign
(brace
l_int|0
comma
l_int|0
comma
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|number_mfm_drives
r_int
id|number_mfm_drives
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------------------------------ */
multiline_comment|/*&n; * From the HD63463 data sheet from Hitachi Ltd.&n; */
DECL|macro|MFM_COMMAND
mdefine_line|#define MFM_COMMAND (mfm_addr + 0)
DECL|macro|MFM_DATAOUT
mdefine_line|#define MFM_DATAOUT (mfm_addr + 1)
DECL|macro|MFM_STATUS
mdefine_line|#define MFM_STATUS  (mfm_addr + 8)
DECL|macro|MFM_DATAIN
mdefine_line|#define MFM_DATAIN  (mfm_addr + 9)
DECL|macro|CMD_ABT
mdefine_line|#define CMD_ABT&t;&t;0xF0&t;/* Abort */
DECL|macro|CMD_SPC
mdefine_line|#define CMD_SPC&t;&t;0xE8&t;/* Specify */
DECL|macro|CMD_TST
mdefine_line|#define CMD_TST&t;&t;0xE0&t;/* Test */
DECL|macro|CMD_RCLB
mdefine_line|#define CMD_RCLB&t;0xC8&t;/* Recalibrate */
DECL|macro|CMD_SEK
mdefine_line|#define CMD_SEK&t;&t;0xC0&t;/* Seek */
DECL|macro|CMD_WFS
mdefine_line|#define CMD_WFS&t;&t;0xAB&t;/* Write Format Skew */
DECL|macro|CMD_WFM
mdefine_line|#define CMD_WFM&t;&t;0xA3&t;/* Write Format */
DECL|macro|CMD_MTB
mdefine_line|#define CMD_MTB&t;&t;0x90&t;/* Memory to buffer */
DECL|macro|CMD_CMPD
mdefine_line|#define CMD_CMPD&t;0x88&t;/* Compare data */
DECL|macro|CMD_WD
mdefine_line|#define CMD_WD&t;&t;0x87&t;/* Write data */
DECL|macro|CMD_RED
mdefine_line|#define CMD_RED&t;&t;0x70&t;/* Read erroneous data */
DECL|macro|CMD_RIS
mdefine_line|#define CMD_RIS&t;&t;0x68&t;/* Read ID skew */
DECL|macro|CMD_FID
mdefine_line|#define CMD_FID&t;&t;0x61&t;/* Find ID */
DECL|macro|CMD_RID
mdefine_line|#define CMD_RID&t;&t;0x60&t;/* Read ID */
DECL|macro|CMD_BTM
mdefine_line|#define CMD_BTM&t;&t;0x50&t;/* Buffer to memory */
DECL|macro|CMD_CKD
mdefine_line|#define CMD_CKD&t;&t;0x48&t;/* Check data */
DECL|macro|CMD_RD
mdefine_line|#define CMD_RD&t;&t;0x40&t;/* Read data */
DECL|macro|CMD_OPBW
mdefine_line|#define CMD_OPBW&t;0x38&t;/* Open buffer write */
DECL|macro|CMD_OPBR
mdefine_line|#define CMD_OPBR&t;0x30&t;/* Open buffer read */
DECL|macro|CMD_CKV
mdefine_line|#define CMD_CKV&t;&t;0x28&t;/* Check drive */
DECL|macro|CMD_CKE
mdefine_line|#define CMD_CKE&t;&t;0x20&t;/* Check ECC */
DECL|macro|CMD_POD
mdefine_line|#define CMD_POD&t;&t;0x18&t;/* Polling disable */
DECL|macro|CMD_POL
mdefine_line|#define CMD_POL&t;&t;0x10&t;/* Polling enable */
DECL|macro|CMD_RCAL
mdefine_line|#define CMD_RCAL&t;0x08&t;/* Recall */
DECL|macro|STAT_BSY
mdefine_line|#define STAT_BSY&t;0x8000&t;/* Busy */
DECL|macro|STAT_CPR
mdefine_line|#define STAT_CPR&t;0x4000&t;/* Command Parameter Rejection */
DECL|macro|STAT_CED
mdefine_line|#define STAT_CED&t;0x2000&t;/* Command end */
DECL|macro|STAT_SED
mdefine_line|#define STAT_SED&t;0x1000&t;/* Seek end */
DECL|macro|STAT_DER
mdefine_line|#define STAT_DER&t;0x0800&t;/* Drive error */
DECL|macro|STAT_ABN
mdefine_line|#define STAT_ABN&t;0x0400&t;/* Abnormal end */
DECL|macro|STAT_POL
mdefine_line|#define STAT_POL&t;0x0200&t;/* Polling */
multiline_comment|/* ------------------------------------------------------------------------------------------ */
macro_line|#ifdef DEBUG
DECL|function|console_printf
r_static
r_void
id|console_printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_static
r_char
id|buffer
(braket
l_int|2048
)braket
suffix:semicolon
multiline_comment|/* Arbitary! */
r_extern
r_void
id|console_print
c_func
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|va_list
id|ap
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
c_func
(paren
id|buffer
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|console_print
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|fmt
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* console_printf */
DECL|macro|DBG
mdefine_line|#define DBG(x...) console_printf(x)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(x...)
macro_line|#endif
DECL|function|print_status
r_static
r_void
id|print_status
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|error
suffix:semicolon
r_static
r_char
op_star
id|errors
(braket
)braket
op_assign
(brace
l_string|&quot;no error&quot;
comma
l_string|&quot;command aborted&quot;
comma
l_string|&quot;invalid command&quot;
comma
l_string|&quot;parameter error&quot;
comma
l_string|&quot;not initialised&quot;
comma
l_string|&quot;rejected TEST&quot;
comma
l_string|&quot;no useld&quot;
comma
l_string|&quot;write fault&quot;
comma
l_string|&quot;not ready&quot;
comma
l_string|&quot;no scp&quot;
comma
l_string|&quot;in seek&quot;
comma
l_string|&quot;invalid NCA&quot;
comma
l_string|&quot;invalid step rate&quot;
comma
l_string|&quot;seek error&quot;
comma
l_string|&quot;over run&quot;
comma
l_string|&quot;invalid PHA&quot;
comma
l_string|&quot;data field EEC error&quot;
comma
l_string|&quot;data field CRC error&quot;
comma
l_string|&quot;error corrected&quot;
comma
l_string|&quot;data field fatal error&quot;
comma
l_string|&quot;no data am&quot;
comma
l_string|&quot;not hit&quot;
comma
l_string|&quot;ID field CRC error&quot;
comma
l_string|&quot;time over&quot;
comma
l_string|&quot;no ID am&quot;
comma
l_string|&quot;not writable&quot;
)brace
suffix:semicolon
r_if
c_cond
(paren
id|result
(braket
l_int|1
)braket
OL
l_int|0x65
)paren
id|error
op_assign
id|errors
(braket
id|result
(braket
l_int|1
)braket
op_rshift
l_int|2
)braket
suffix:semicolon
r_else
id|error
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfm_status
op_amp
id|STAT_BSY
)paren
id|printk
c_func
(paren
l_string|&quot;BSY &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfm_status
op_amp
id|STAT_CPR
)paren
id|printk
c_func
(paren
l_string|&quot;CPR &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfm_status
op_amp
id|STAT_CED
)paren
id|printk
c_func
(paren
l_string|&quot;CED &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfm_status
op_amp
id|STAT_SED
)paren
id|printk
c_func
(paren
l_string|&quot;SED &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfm_status
op_amp
id|STAT_DER
)paren
id|printk
c_func
(paren
l_string|&quot;DER &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfm_status
op_amp
id|STAT_ABN
)paren
id|printk
c_func
(paren
l_string|&quot;ABN &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfm_status
op_amp
id|STAT_POL
)paren
id|printk
c_func
(paren
l_string|&quot;POL &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;) SSB = %X (%s)&bslash;n&quot;
comma
id|result
(braket
l_int|1
)braket
comma
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------------------- */
DECL|function|issue_command
r_static
r_void
id|issue_command
c_func
(paren
r_int
id|command
comma
r_int
r_char
op_star
id|cmdb
comma
r_int
id|len
)paren
(brace
r_int
id|status
suffix:semicolon
macro_line|#ifdef DEBUG
r_int
id|i
suffix:semicolon
id|console_printf
c_func
(paren
l_string|&quot;issue_command: %02X: &quot;
comma
id|command
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|console_printf
c_func
(paren
l_string|&quot;%02X &quot;
comma
id|cmdb
(braket
id|i
)braket
)paren
suffix:semicolon
id|console_printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_do
(brace
id|status
op_assign
id|inw
c_func
(paren
id|MFM_STATUS
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|status
op_amp
(paren
id|STAT_BSY
op_or
id|STAT_POL
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;issue_command: status after pol/bsy loop: %02X:&bslash;n &quot;
comma
id|status
op_rshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|STAT_CPR
op_or
id|STAT_CED
op_or
id|STAT_SED
op_or
id|STAT_DER
op_or
id|STAT_ABN
)paren
)paren
(brace
id|outw
c_func
(paren
id|CMD_RCAL
comma
id|MFM_COMMAND
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inw
c_func
(paren
id|MFM_STATUS
)paren
op_amp
id|STAT_BSY
)paren
suffix:semicolon
)brace
id|status
op_assign
id|inw
c_func
(paren
id|MFM_STATUS
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;issue_command: status before parameter issue: %02X:&bslash;n &quot;
comma
id|status
op_rshift
l_int|8
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|outw
c_func
(paren
id|cmdb
(braket
l_int|1
)braket
op_or
(paren
id|cmdb
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
comma
id|MFM_DATAOUT
)paren
suffix:semicolon
id|len
op_sub_assign
l_int|2
suffix:semicolon
id|cmdb
op_add_assign
l_int|2
suffix:semicolon
)brace
id|status
op_assign
id|inw
c_func
(paren
id|MFM_STATUS
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;issue_command: status before command issue: %02X:&bslash;n &quot;
comma
id|status
op_rshift
l_int|8
)paren
suffix:semicolon
id|outw
c_func
(paren
id|command
comma
id|MFM_COMMAND
)paren
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|MFM_STATUS
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;issue_command: status immediately after command issue: %02X:&bslash;n &quot;
comma
id|status
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
DECL|function|wait_for_completion
r_static
r_void
id|wait_for_completion
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
(paren
id|mfm_status
op_assign
id|inw
c_func
(paren
id|MFM_STATUS
)paren
)paren
op_amp
id|STAT_BSY
)paren
suffix:semicolon
)brace
DECL|function|wait_for_command_end
r_static
r_void
id|wait_for_command_end
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|mfm_status
op_assign
id|inw
c_func
(paren
id|MFM_STATUS
)paren
)paren
op_amp
id|STAT_CED
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
)paren
(brace
r_int
id|in
suffix:semicolon
id|in
op_assign
id|inw
c_func
(paren
id|MFM_DATAIN
)paren
suffix:semicolon
id|result
(braket
id|i
op_increment
)braket
op_assign
id|in
op_rshift
l_int|8
suffix:semicolon
id|result
(braket
id|i
op_increment
)braket
op_assign
id|in
suffix:semicolon
)brace
id|outw
(paren
id|CMD_RCAL
comma
id|MFM_COMMAND
)paren
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------------------- */
DECL|function|mfm_rw_intr
r_static
r_void
id|mfm_rw_intr
c_func
(paren
r_void
)paren
(brace
r_int
id|old_status
suffix:semicolon
multiline_comment|/* Holds status on entry, we read to see if the command just finished */
macro_line|#ifdef DEBUG
id|console_printf
c_func
(paren
l_string|&quot;mfm_rw_intr...dataleft=%d&bslash;n&quot;
comma
id|hdc63463_dataleft
)paren
suffix:semicolon
id|print_status
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Now don&squot;t handle the error until BSY drops */
r_if
c_cond
(paren
(paren
id|mfm_status
op_amp
(paren
id|STAT_DER
op_or
id|STAT_ABN
)paren
)paren
op_logical_and
(paren
(paren
id|mfm_status
op_amp
id|STAT_BSY
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Something has gone wrong - let&squot;s try that again */
id|outw
c_func
(paren
id|CMD_RCAL
comma
id|MFM_COMMAND
)paren
suffix:semicolon
multiline_comment|/* Clear interrupt condition */
r_if
c_cond
(paren
id|cont
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;mfm_rw_intr: DER/ABN err&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* OK so what ever happened it&squot;s not an error, now I reckon we are left between&n;&t;   a choice of command end or some data which is ready to be collected */
multiline_comment|/* I think we have to transfer data while the interrupt line is on and its&n;&t;   not any other type of interrupt */
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|WRITE
)paren
(brace
r_extern
r_void
id|hdc63463_writedma
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hdc63463_dataleft
op_le
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|mfm_status
op_amp
id|STAT_CED
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mfm_rw_intr: Apparent DMA write request when no more to DMA&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cont
)paren
(brace
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|hdc63463_writedma
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_extern
r_void
id|hdc63463_readdma
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hdc63463_dataleft
op_le
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|mfm_status
op_amp
id|STAT_CED
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mfm_rw_intr: Apparent DMA read request when no more to DMA&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cont
)paren
(brace
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;Going to try read dma..............status=0x%x, buffer=%p&bslash;n&quot;
comma
id|mfm_status
comma
id|hdc63463_dataptr
)paren
suffix:semicolon
id|hdc63463_readdma
c_func
(paren
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Read */
r_if
c_cond
(paren
id|hdc63463_dataptr
op_ne
(paren
(paren
r_int
r_int
)paren
id|Copy_buffer
op_plus
l_int|256
)paren
)paren
(brace
multiline_comment|/* If we didn&squot;t actually manage to get any data on this interrupt - but why? We got the interrupt */
multiline_comment|/* Ah - well looking at the status its just when we get command end; so no problem */
multiline_comment|/*console_printf(&quot;mfm: dataptr mismatch. dataptr=0x%08x Copy_buffer+256=0x%08p&bslash;n&quot;,&n;&t;&t;   hdc63463_dataptr,Copy_buffer+256);&n;&t;&t;   print_status(); */
)brace
r_else
(brace
id|Sectors256LeftInCurrent
op_decrement
suffix:semicolon
id|Copy_buffer
op_add_assign
l_int|256
suffix:semicolon
id|Copy_Sector
op_increment
suffix:semicolon
multiline_comment|/* We have come to the end of this request */
r_if
c_cond
(paren
op_logical_neg
id|Sectors256LeftInCurrent
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;mfm: end_request for CURRENT=0x%p CURRENT(sector=%d current_nr_sectors=%d nr_sectors=%d)&bslash;n&quot;
comma
id|CURRENT
comma
id|CURRENT-&gt;sector
comma
id|CURRENT-&gt;current_nr_sectors
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|SectorsLeftInRequest
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|end_request
c_func
(paren
id|CURRENT
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SectorsLeftInRequest
)paren
(brace
id|hdc63463_dataptr
op_assign
(paren
r_int
r_int
)paren
id|CURRENT-&gt;buffer
suffix:semicolon
id|Copy_buffer
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|Sectors256LeftInCurrent
op_assign
id|CURRENT-&gt;current_nr_sectors
op_star
l_int|2
suffix:semicolon
id|errors
op_assign
op_amp
(paren
id|CURRENT-&gt;errors
)paren
suffix:semicolon
multiline_comment|/* These should match the present calculations of the next logical sector&n;&t;&t;&t;&t;   on the device&n;&t;&t;&t;&t;   Copy_Sector=CURRENT-&gt;sector*2; */
r_if
c_cond
(paren
id|Copy_Sector
op_ne
id|CURRENT-&gt;sector
op_star
l_int|2
)paren
macro_line|#ifdef DEBUG
multiline_comment|/*console_printf*/
id|printk
c_func
(paren
l_string|&quot;mfm: Copy_Sector mismatch. Copy_Sector=%d CURRENT-&gt;sector*2=%d&bslash;n&quot;
comma
id|Copy_Sector
comma
id|CURRENT-&gt;sector
op_star
l_int|2
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;mfm: Copy_Sector mismatch! Eek!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* CURRENT */
)brace
suffix:semicolon
multiline_comment|/* Sectors256LeftInCurrent */
)brace
suffix:semicolon
id|old_status
op_assign
id|mfm_status
suffix:semicolon
id|mfm_status
op_assign
id|inw
c_func
(paren
id|MFM_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfm_status
op_amp
(paren
id|STAT_DER
op_or
id|STAT_ABN
)paren
)paren
(brace
multiline_comment|/* Something has gone wrong - let&squot;s try that again */
r_if
c_cond
(paren
id|cont
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;mfm_rw_intr: DER/ABN error&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* If this code wasn&squot;t entered due to command_end but there is&n;&t;   now a command end we must read the command results out. If it was&n;&t;   entered like this then mfm_interrupt_handler would have done the&n;&t;   job. */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
(paren
id|old_status
op_amp
(paren
id|STAT_CPR
op_or
id|STAT_BSY
)paren
)paren
op_eq
id|STAT_CPR
)paren
)paren
op_logical_and
(paren
(paren
id|mfm_status
op_amp
(paren
id|STAT_CPR
op_or
id|STAT_BSY
)paren
)paren
op_eq
id|STAT_CPR
)paren
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|len
OL
l_int|16
)paren
(brace
r_int
id|in
suffix:semicolon
id|in
op_assign
id|inw
c_func
(paren
id|MFM_DATAIN
)paren
suffix:semicolon
id|result
(braket
id|len
op_increment
)braket
op_assign
id|in
op_rshift
l_int|8
suffix:semicolon
id|result
(braket
id|len
op_increment
)braket
op_assign
id|in
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Result read */
multiline_comment|/*console_printf (&quot;mfm_rw_intr nearexit [%02X]&bslash;n&quot;, __raw_readb(mfm_IRQPollLoc)); */
multiline_comment|/* If end of command move on */
r_if
c_cond
(paren
id|mfm_status
op_amp
(paren
id|STAT_CED
)paren
)paren
(brace
id|outw
c_func
(paren
id|CMD_RCAL
comma
id|MFM_COMMAND
)paren
suffix:semicolon
multiline_comment|/* Clear interrupt condition */
multiline_comment|/* End of command - trigger the next command */
r_if
c_cond
(paren
id|cont
)paren
(brace
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|DBG
c_func
(paren
l_string|&quot;mfm_rw_intr: returned from cont-&gt;done&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Its going to generate another interrupt */
id|do_mfm
op_assign
id|mfm_rw_intr
suffix:semicolon
)brace
suffix:semicolon
)brace
DECL|function|mfm_setup_rw
r_static
r_void
id|mfm_setup_rw
c_func
(paren
r_void
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;setting up for rw...&bslash;n&quot;
)paren
suffix:semicolon
id|do_mfm
op_assign
id|mfm_rw_intr
suffix:semicolon
id|issue_command
c_func
(paren
id|raw_cmd.cmdcode
comma
id|raw_cmd.cmddata
comma
id|raw_cmd.cmdlen
)paren
suffix:semicolon
)brace
DECL|function|mfm_recal_intr
r_static
r_void
id|mfm_recal_intr
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUG
id|console_printf
c_func
(paren
l_string|&quot;recal intr - status = &quot;
)paren
suffix:semicolon
id|print_status
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|outw
c_func
(paren
id|CMD_RCAL
comma
id|MFM_COMMAND
)paren
suffix:semicolon
multiline_comment|/* Clear interrupt condition */
r_if
c_cond
(paren
id|mfm_status
op_amp
(paren
id|STAT_DER
op_or
id|STAT_ABN
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;recal failed&bslash;n&quot;
)paren
suffix:semicolon
id|MFM_DRV_INFO.cylinder
op_assign
id|NEED_2_RECAL
suffix:semicolon
r_if
c_cond
(paren
id|cont
)paren
(brace
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Thats seek end - we are finished */
r_if
c_cond
(paren
id|mfm_status
op_amp
id|STAT_SED
)paren
(brace
id|issue_command
c_func
(paren
id|CMD_POD
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|MFM_DRV_INFO.cylinder
op_assign
l_int|0
suffix:semicolon
id|mfm_seek
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Command end without seek end (see data sheet p.20) for parallel seek&n;&t;   - we have to send a POL command to wait for the seek */
r_if
c_cond
(paren
id|mfm_status
op_amp
id|STAT_CED
)paren
(brace
id|do_mfm
op_assign
id|mfm_recal_intr
suffix:semicolon
id|issue_command
c_func
(paren
id|CMD_POL
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;recal: unknown status&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|mfm_seek_intr
r_static
r_void
id|mfm_seek_intr
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUG
id|console_printf
c_func
(paren
l_string|&quot;seek intr - status = &quot;
)paren
suffix:semicolon
id|print_status
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|outw
c_func
(paren
id|CMD_RCAL
comma
id|MFM_COMMAND
)paren
suffix:semicolon
multiline_comment|/* Clear interrupt condition */
r_if
c_cond
(paren
id|mfm_status
op_amp
(paren
id|STAT_DER
op_or
id|STAT_ABN
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;seek failed&bslash;n&quot;
)paren
suffix:semicolon
id|MFM_DRV_INFO.cylinder
op_assign
id|NEED_2_RECAL
suffix:semicolon
r_if
c_cond
(paren
id|cont
)paren
(brace
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mfm_status
op_amp
id|STAT_SED
)paren
(brace
id|issue_command
c_func
(paren
id|CMD_POD
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|MFM_DRV_INFO.cylinder
op_assign
id|raw_cmd.cylinder
suffix:semicolon
id|mfm_seek
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mfm_status
op_amp
id|STAT_CED
)paren
(brace
id|do_mfm
op_assign
id|mfm_seek_intr
suffix:semicolon
id|issue_command
c_func
(paren
id|CMD_POL
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;seek: unknown status&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* IDEA2 seems to work better - its what RiscOS sets my&n; * disc to - on its SECOND call to specify!&n; */
DECL|macro|IDEA2
mdefine_line|#define IDEA2
macro_line|#ifndef IDEA2
DECL|macro|SPEC_SL
mdefine_line|#define SPEC_SL 0x16
DECL|macro|SPEC_SH
mdefine_line|#define SPEC_SH 0xa9&t;&t;/* Step pulse high=21, Record Length=001 (256 bytes) */
macro_line|#else
DECL|macro|SPEC_SL
mdefine_line|#define SPEC_SL 0x00&t;&t;/* OM2 - SL - step pulse low */
DECL|macro|SPEC_SH
mdefine_line|#define SPEC_SH 0x21&t;&t;/* Step pulse high=4, Record Length=001 (256 bytes) */
macro_line|#endif
DECL|function|mfm_setupspecify
r_static
r_void
id|mfm_setupspecify
(paren
r_int
id|drive
comma
r_int
r_char
op_star
id|cmdb
)paren
(brace
id|cmdb
(braket
l_int|0
)braket
op_assign
l_int|0x1f
suffix:semicolon
multiline_comment|/* OM0 - !SECT,!MOD,!DIF,PADP,ECD,CRCP,CRCI,ACOR */
id|cmdb
(braket
l_int|1
)braket
op_assign
l_int|0xc3
suffix:semicolon
multiline_comment|/* OM1 - DTM,BRST,!CEDM,!SEDM,!DERM,0,AMEX,PSK */
id|cmdb
(braket
l_int|2
)braket
op_assign
id|SPEC_SL
suffix:semicolon
multiline_comment|/* OM2 - SL - step pulse low */
id|cmdb
(braket
l_int|3
)braket
op_assign
(paren
id|number_mfm_drives
op_eq
l_int|1
)paren
ques
c_cond
l_int|0x02
suffix:colon
l_int|0x06
suffix:semicolon
multiline_comment|/* 1 or 2 drives */
id|cmdb
(braket
l_int|4
)braket
op_assign
l_int|0xfc
op_or
(paren
(paren
id|mfm_info
(braket
id|drive
)braket
dot
id|cylinders
op_minus
l_int|1
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* RW time over/high part of number of cylinders */
id|cmdb
(braket
l_int|5
)braket
op_assign
id|mfm_info
(braket
id|drive
)braket
dot
id|cylinders
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* low part of number of cylinders */
id|cmdb
(braket
l_int|6
)braket
op_assign
id|mfm_info
(braket
id|drive
)braket
dot
id|heads
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Number of heads */
id|cmdb
(braket
l_int|7
)braket
op_assign
id|mfm_info
(braket
id|drive
)braket
dot
id|sectors
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Number of sectors */
id|cmdb
(braket
l_int|8
)braket
op_assign
id|SPEC_SH
suffix:semicolon
id|cmdb
(braket
l_int|9
)braket
op_assign
l_int|0x0a
suffix:semicolon
multiline_comment|/* gap length 1 */
id|cmdb
(braket
l_int|10
)braket
op_assign
l_int|0x0d
suffix:semicolon
multiline_comment|/* gap length 2 */
id|cmdb
(braket
l_int|11
)braket
op_assign
l_int|0x0c
suffix:semicolon
multiline_comment|/* gap length 3 */
id|cmdb
(braket
l_int|12
)braket
op_assign
(paren
id|mfm_info
(braket
id|drive
)braket
dot
id|precomp
op_minus
l_int|1
)paren
op_rshift
l_int|8
suffix:semicolon
multiline_comment|/* pre comp cylinder */
id|cmdb
(braket
l_int|13
)braket
op_assign
id|mfm_info
(braket
id|drive
)braket
dot
id|precomp
op_minus
l_int|1
suffix:semicolon
id|cmdb
(braket
l_int|14
)braket
op_assign
(paren
id|mfm_info
(braket
id|drive
)braket
dot
id|lowcurrent
op_minus
l_int|1
)paren
op_rshift
l_int|8
suffix:semicolon
multiline_comment|/* Low current cylinder */
id|cmdb
(braket
l_int|15
)braket
op_assign
id|mfm_info
(braket
id|drive
)braket
dot
id|lowcurrent
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|mfm_specify
r_static
r_void
id|mfm_specify
(paren
r_void
)paren
(brace
r_int
r_char
id|cmdb
(braket
l_int|16
)braket
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;specify...dev=%d lastspecified=%d&bslash;n&quot;
comma
id|raw_cmd.dev
comma
id|lastspecifieddrive
)paren
suffix:semicolon
id|mfm_setupspecify
(paren
id|raw_cmd.dev
comma
id|cmdb
)paren
suffix:semicolon
id|issue_command
(paren
id|CMD_SPC
comma
id|cmdb
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Ensure that we will do another specify if we move to the other drive */
id|lastspecifieddrive
op_assign
id|raw_cmd.dev
suffix:semicolon
id|wait_for_completion
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|mfm_seek
r_static
r_void
id|mfm_seek
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|cmdb
(braket
l_int|4
)braket
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;seeking...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MFM_DRV_INFO.cylinder
OL
l_int|0
)paren
(brace
id|do_mfm
op_assign
id|mfm_recal_intr
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;mfm_seek: about to call specify&bslash;n&quot;
)paren
suffix:semicolon
id|mfm_specify
(paren
)paren
suffix:semicolon
multiline_comment|/* DAG added this */
id|cmdb
(braket
l_int|0
)braket
op_assign
id|raw_cmd.dev
op_plus
l_int|1
suffix:semicolon
id|cmdb
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|issue_command
c_func
(paren
id|CMD_RCLB
comma
id|cmdb
comma
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MFM_DRV_INFO.cylinder
op_ne
id|raw_cmd.cylinder
)paren
(brace
id|cmdb
(braket
l_int|0
)braket
op_assign
id|raw_cmd.dev
op_plus
l_int|1
suffix:semicolon
id|cmdb
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* raw_cmd.head; DAG: My data sheet says this should be 0 */
id|cmdb
(braket
l_int|2
)braket
op_assign
id|raw_cmd.cylinder
op_rshift
l_int|8
suffix:semicolon
id|cmdb
(braket
l_int|3
)braket
op_assign
id|raw_cmd.cylinder
suffix:semicolon
id|do_mfm
op_assign
id|mfm_seek_intr
suffix:semicolon
id|issue_command
c_func
(paren
id|CMD_SEK
comma
id|cmdb
comma
l_int|4
)paren
suffix:semicolon
)brace
r_else
id|mfm_setup_rw
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|mfm_initialise
r_static
r_void
id|mfm_initialise
c_func
(paren
r_void
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;init...&bslash;n&quot;
)paren
suffix:semicolon
id|mfm_seek
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|request_done
r_static
r_void
id|request_done
c_func
(paren
r_int
id|uptodate
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;mfm:request_done&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
)paren
(brace
r_int
r_char
id|block
(braket
l_int|2
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* Apparently worked - let&squot;s check bytes left to DMA */
r_if
c_cond
(paren
id|hdc63463_dataleft
op_ne
(paren
id|PartFragRead_SectorsLeft
op_star
l_int|256
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mfm: request_done - dataleft=%d - should be %d - Eek!&bslash;n&quot;
comma
id|hdc63463_dataleft
comma
id|PartFragRead_SectorsLeft
op_star
l_int|256
)paren
suffix:semicolon
id|end_request
c_func
(paren
id|CURRENT
comma
l_int|0
)paren
suffix:semicolon
id|Busy
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Potentially this means that we&squot;ve done; but we might be doing&n;&t;&t;   a partial access, (over two cylinders) or we may have a number&n;&t;&t;   of fragments in an image file.  First let&squot;s deal with partial accesss&n;&t;&t; */
r_if
c_cond
(paren
id|PartFragRead
)paren
(brace
multiline_comment|/* Yep - a partial access */
multiline_comment|/* and issue the remainder */
id|issue_request
c_func
(paren
id|PartFragRead_RestartBlock
comma
id|PartFragRead_SectorsLeft
comma
id|CURRENT
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* ah well - perhaps there is another fragment to go */
multiline_comment|/* Increment pointers/counts to start of next fragment */
r_if
c_cond
(paren
id|SectorsLeftInRequest
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;mfm: SectorsLeftInRequest&gt;0 - Eek! Shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* No - its the end of the line */
multiline_comment|/* end_request&squot;s should have happened at the end of sector DMAs */
multiline_comment|/* Turns Drive LEDs off - may slow it down? */
r_if
c_cond
(paren
op_logical_neg
id|elv_next_request
c_func
(paren
id|QUEUE
)paren
)paren
id|issue_command
c_func
(paren
id|CMD_CKV
comma
id|block
comma
l_int|2
)paren
suffix:semicolon
id|Busy
op_assign
l_int|0
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;request_done: About to mfm_request&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Next one please */
id|mfm_request
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Moved from mfm_rw_intr */
id|DBG
c_func
(paren
l_string|&quot;request_done: returned from mfm_request&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;mfm:request_done: update=0&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
id|CURRENT
comma
l_int|0
)paren
suffix:semicolon
id|Busy
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|error_handler
r_static
r_void
id|error_handler
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;error detected... status = &quot;
)paren
suffix:semicolon
id|print_status
c_func
(paren
)paren
suffix:semicolon
(paren
op_star
id|errors
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|errors
OG
id|MFM_DRV_INFO.errors
dot
m_abort
)paren
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|errors
OG
id|MFM_DRV_INFO.errors.recal
)paren
id|MFM_DRV_INFO.cylinder
op_assign
id|NEED_2_RECAL
suffix:semicolon
)brace
DECL|function|rw_interrupt
r_static
r_void
id|rw_interrupt
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rw_interrupt&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|rw_cont
r_static
r_struct
id|cont
id|rw_cont
op_assign
(brace
id|rw_interrupt
comma
id|error_handler
comma
id|mfm_rerequest
comma
id|request_done
)brace
suffix:semicolon
multiline_comment|/*&n; * Actually gets round to issuing the request - note everything at this&n; * point is in 256 byte sectors not Linux 512 byte blocks&n; */
DECL|function|issue_request
r_static
r_void
id|issue_request
c_func
(paren
r_int
r_int
id|block
comma
r_int
r_int
id|nsect
comma
r_struct
id|request
op_star
id|req
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|req-&gt;rq_disk
suffix:semicolon
r_struct
id|mfm_info
op_star
id|p
op_assign
id|disk-&gt;private_data
suffix:semicolon
r_int
id|track
comma
id|start_head
comma
id|start_sector
suffix:semicolon
r_int
id|sectors_to_next_cyl
suffix:semicolon
id|dev
op_assign
id|p
op_minus
id|mfm_info
suffix:semicolon
id|track
op_assign
id|block
op_div
id|p-&gt;sectors
suffix:semicolon
id|start_sector
op_assign
id|block
op_mod
id|p-&gt;sectors
suffix:semicolon
id|start_head
op_assign
id|track
op_mod
id|p-&gt;heads
suffix:semicolon
multiline_comment|/* First get the number of whole tracks which are free before the next&n;&t;   track */
id|sectors_to_next_cyl
op_assign
(paren
id|p-&gt;heads
op_minus
(paren
id|start_head
op_plus
l_int|1
)paren
)paren
op_star
id|p-&gt;sectors
suffix:semicolon
multiline_comment|/* Then add in the number of sectors left on this track */
id|sectors_to_next_cyl
op_add_assign
(paren
id|p-&gt;sectors
op_minus
id|start_sector
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;issue_request: mfm_info[dev].sectors=%d track=%d&bslash;n&quot;
comma
id|p-&gt;sectors
comma
id|track
)paren
suffix:semicolon
id|raw_cmd.dev
op_assign
id|dev
suffix:semicolon
id|raw_cmd.sector
op_assign
id|start_sector
suffix:semicolon
id|raw_cmd.head
op_assign
id|start_head
suffix:semicolon
id|raw_cmd.cylinder
op_assign
id|track
op_div
id|p-&gt;heads
suffix:semicolon
id|raw_cmd.cmdtype
op_assign
id|CURRENT-&gt;cmd
suffix:semicolon
id|raw_cmd.cmdcode
op_assign
id|CURRENT-&gt;cmd
op_eq
id|WRITE
ques
c_cond
id|CMD_WD
suffix:colon
id|CMD_RD
suffix:semicolon
id|raw_cmd.cmddata
(braket
l_int|0
)braket
op_assign
id|dev
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* DAG: +1 to get US */
id|raw_cmd.cmddata
(braket
l_int|1
)braket
op_assign
id|raw_cmd.head
suffix:semicolon
id|raw_cmd.cmddata
(braket
l_int|2
)braket
op_assign
id|raw_cmd.cylinder
op_rshift
l_int|8
suffix:semicolon
id|raw_cmd.cmddata
(braket
l_int|3
)braket
op_assign
id|raw_cmd.cylinder
suffix:semicolon
id|raw_cmd.cmddata
(braket
l_int|4
)braket
op_assign
id|raw_cmd.head
suffix:semicolon
id|raw_cmd.cmddata
(braket
l_int|5
)braket
op_assign
id|raw_cmd.sector
suffix:semicolon
multiline_comment|/* Was == and worked - how the heck??? */
r_if
c_cond
(paren
id|lastspecifieddrive
op_ne
id|raw_cmd.dev
)paren
id|mfm_specify
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nsect
op_le
id|sectors_to_next_cyl
)paren
(brace
id|raw_cmd.cmddata
(braket
l_int|6
)braket
op_assign
id|nsect
op_rshift
l_int|8
suffix:semicolon
id|raw_cmd.cmddata
(braket
l_int|7
)braket
op_assign
id|nsect
suffix:semicolon
id|PartFragRead
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* All in one */
id|PartFragRead_SectorsLeft
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Must set this - used in DMA calcs */
)brace
r_else
(brace
id|raw_cmd.cmddata
(braket
l_int|6
)braket
op_assign
id|sectors_to_next_cyl
op_rshift
l_int|8
suffix:semicolon
id|raw_cmd.cmddata
(braket
l_int|7
)braket
op_assign
id|sectors_to_next_cyl
suffix:semicolon
id|PartFragRead
op_assign
id|sectors_to_next_cyl
suffix:semicolon
multiline_comment|/* only do this many this time */
id|PartFragRead_RestartBlock
op_assign
id|block
op_plus
id|sectors_to_next_cyl
suffix:semicolon
multiline_comment|/* Where to restart from */
id|PartFragRead_SectorsLeft
op_assign
id|nsect
op_minus
id|sectors_to_next_cyl
suffix:semicolon
)brace
id|raw_cmd.cmdlen
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* Setup DMA pointers */
id|hdc63463_dataptr
op_assign
(paren
r_int
r_int
)paren
id|Copy_buffer
suffix:semicolon
id|hdc63463_dataleft
op_assign
id|nsect
op_star
l_int|256
suffix:semicolon
multiline_comment|/* Better way? */
id|DBG
c_func
(paren
l_string|&quot;mfm%c: %sing: CHS=%d/%d/%d, sectors=%d, buffer=0x%08lx (%p)&bslash;n&quot;
comma
id|raw_cmd.dev
op_plus
l_char|&squot;a&squot;
comma
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
comma
id|raw_cmd.cylinder
comma
id|raw_cmd.head
comma
id|raw_cmd.sector
comma
id|nsect
comma
(paren
r_int
r_int
)paren
id|Copy_buffer
comma
id|CURRENT
)paren
suffix:semicolon
id|cont
op_assign
op_amp
id|rw_cont
suffix:semicolon
id|errors
op_assign
op_amp
(paren
id|CURRENT-&gt;errors
)paren
suffix:semicolon
macro_line|#if 0
id|mfm_tq.routine
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|mfm_initialise
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|mfm_tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
macro_line|#else
id|mfm_initialise
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* issue_request */
multiline_comment|/*&n; * Called when an error has just happened - need to trick mfm_request&n; * into thinking we weren&squot;t busy&n; *&n; * Turn off ints - mfm_request expects them this way&n; */
DECL|function|mfm_rerequest
r_static
r_void
id|mfm_rerequest
c_func
(paren
r_void
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;mfm_rerequest&bslash;n&quot;
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|Busy
op_assign
l_int|0
suffix:semicolon
id|mfm_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|mfm_gendisk
r_static
r_struct
id|gendisk
op_star
id|mfm_gendisk
(braket
l_int|2
)braket
suffix:semicolon
DECL|function|mfm_request
r_static
r_void
id|mfm_request
c_func
(paren
r_void
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;mfm_request CURRENT=%p Busy=%d&bslash;n&quot;
comma
id|CURRENT
comma
id|Busy
)paren
suffix:semicolon
multiline_comment|/* If we are still processing then return; we will get called again */
r_if
c_cond
(paren
id|Busy
)paren
(brace
multiline_comment|/* Again seems to be common in 1.3.45 */
multiline_comment|/*DBG*/
id|printk
c_func
(paren
l_string|&quot;mfm_request: Exiting due to busy&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|Busy
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
r_int
id|block
comma
id|nsect
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;mfm_request: loop start&bslash;n&quot;
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;mfm_request: before !CURRENT&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mfm_request: Exiting due to empty queue (pre)&bslash;n&quot;
)paren
suffix:semicolon
id|do_mfm
op_assign
l_int|NULL
suffix:semicolon
id|Busy
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DBG
c_func
(paren
l_string|&quot;mfm_request:                 before arg extraction&bslash;n&quot;
)paren
suffix:semicolon
id|disk
op_assign
id|CURRENT-&gt;rq_disk
suffix:semicolon
id|block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|nsect
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|block
op_ge
id|get_capacity
c_func
(paren
id|disk
)paren
op_logical_or
id|block
op_plus
id|nsect
OG
id|get_capacity
c_func
(paren
id|disk
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: bad access: block=%d, count=%d, nr_sects=%ld&bslash;n&quot;
comma
id|disk-&gt;disk_name
comma
id|block
comma
id|nsect
comma
id|get_capacity
c_func
(paren
id|disk
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mfm: continue 1&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
id|CURRENT
comma
l_int|0
)paren
suffix:semicolon
id|Busy
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* DAG: Linux doesn&squot;t cope with this - even though it has an array telling&n;&t;&t;   it the hardware block size - silly */
id|block
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Now in 256 byte sectors */
id|nsect
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Ditto */
id|SectorsLeftInRequest
op_assign
id|nsect
op_rshift
l_int|1
suffix:semicolon
id|Sectors256LeftInCurrent
op_assign
id|CURRENT-&gt;current_nr_sectors
op_star
l_int|2
suffix:semicolon
id|Copy_buffer
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|Copy_Sector
op_assign
id|CURRENT-&gt;sector
op_lshift
l_int|1
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;mfm_request: block after offset=%d&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_ne
id|READ
op_logical_and
id|CURRENT-&gt;cmd
op_ne
id|WRITE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unknown mfm-command %d&bslash;n&quot;
comma
id|CURRENT-&gt;cmd
)paren
suffix:semicolon
id|end_request
c_func
(paren
id|CURRENT
comma
l_int|0
)paren
suffix:semicolon
id|Busy
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mfm: continue 4&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|issue_request
c_func
(paren
id|block
comma
id|nsect
comma
id|CURRENT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DBG
c_func
(paren
l_string|&quot;mfm_request: Dropping out bottom&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|do_mfm_request
r_static
r_void
id|do_mfm_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;do_mfm_request: about to mfm_request&bslash;n&quot;
)paren
suffix:semicolon
id|mfm_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|mfm_interrupt_handler
r_static
r_void
id|mfm_interrupt_handler
c_func
(paren
r_int
id|unused
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
)paren
op_assign
id|do_mfm
suffix:semicolon
id|do_mfm
op_assign
l_int|NULL
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;mfm_interrupt_handler (handler=0x%p)&bslash;n&quot;
comma
id|handler
)paren
suffix:semicolon
id|mfm_status
op_assign
id|inw
c_func
(paren
id|MFM_STATUS
)paren
suffix:semicolon
multiline_comment|/* If CPR (Command Parameter Reject) and not busy it means that the command&n;&t;   has some return message to give us */
r_if
c_cond
(paren
(paren
id|mfm_status
op_amp
(paren
id|STAT_CPR
op_or
id|STAT_BSY
)paren
)paren
op_eq
id|STAT_CPR
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|len
OL
l_int|16
)paren
(brace
r_int
id|in
suffix:semicolon
id|in
op_assign
id|inw
c_func
(paren
id|MFM_DATAIN
)paren
suffix:semicolon
id|result
(braket
id|len
op_increment
)braket
op_assign
id|in
op_rshift
l_int|8
suffix:semicolon
id|result
(braket
id|len
op_increment
)braket
op_assign
id|in
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|handler
)paren
(brace
id|handler
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|outw
(paren
id|CMD_RCAL
comma
id|MFM_COMMAND
)paren
suffix:semicolon
multiline_comment|/* Clear interrupt condition */
id|printk
(paren
l_string|&quot;mfm: unexpected interrupt - status = &quot;
)paren
suffix:semicolon
id|print_status
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Tell the user about the drive if we decided it exists.&n; */
DECL|function|mfm_geometry
r_static
r_void
id|mfm_geometry
c_func
(paren
r_int
id|drive
)paren
(brace
r_struct
id|mfm_info
op_star
id|p
op_assign
id|mfm_info
op_plus
id|drive
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
op_assign
id|mfm_gendisk
(braket
id|drive
)braket
suffix:semicolon
id|disk-&gt;private_data
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;cylinders
)paren
id|printk
(paren
l_string|&quot;%s: %dMB CHS=%d/%d/%d LCC=%d RECOMP=%d&bslash;n&quot;
comma
id|disk-&gt;disk_name
comma
id|p-&gt;cylinders
op_star
id|p-&gt;heads
op_star
id|p-&gt;sectors
op_div
l_int|4096
comma
id|p-&gt;cylinders
comma
id|p-&gt;heads
comma
id|p-&gt;sectors
comma
id|p-&gt;lowcurrent
comma
id|p-&gt;precomp
)paren
suffix:semicolon
id|set_capacity
c_func
(paren
id|disk
comma
id|p-&gt;cylinders
op_star
id|p-&gt;heads
op_star
id|p-&gt;sectors
op_div
l_int|2
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_MFM_AUTODETECT
multiline_comment|/*&n; * Attempt to detect a drive and find its geometry.  The drive has already been&n; * specified...&n; *&n; * We first recalibrate the disk, then try to probe sectors, heads and then&n; * cylinders.  NOTE! the cylinder probe may break drives.  The xd disk driver&n; * does something along these lines, so I assume that most drives are up to&n; * this mistreatment...&n; */
DECL|function|mfm_detectdrive
r_static
r_int
id|mfm_detectdrive
(paren
r_int
id|drive
)paren
(brace
r_int
r_int
id|mingeo
(braket
l_int|3
)braket
comma
id|maxgeo
(braket
l_int|3
)braket
suffix:semicolon
r_int
r_int
id|attribute
comma
id|need_recal
op_assign
l_int|1
suffix:semicolon
r_int
r_char
id|cmdb
(braket
l_int|8
)braket
suffix:semicolon
id|memset
(paren
id|mingeo
comma
l_int|0
comma
r_sizeof
(paren
id|mingeo
)paren
)paren
suffix:semicolon
id|maxgeo
(braket
l_int|0
)braket
op_assign
id|mfm_info
(braket
id|drive
)braket
dot
id|sectors
suffix:semicolon
id|maxgeo
(braket
l_int|1
)braket
op_assign
id|mfm_info
(braket
id|drive
)braket
dot
id|heads
suffix:semicolon
id|maxgeo
(braket
l_int|2
)braket
op_assign
id|mfm_info
(braket
id|drive
)braket
dot
id|cylinders
suffix:semicolon
id|cmdb
(braket
l_int|0
)braket
op_assign
id|drive
op_plus
l_int|1
suffix:semicolon
id|cmdb
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|cmdb
(braket
l_int|7
)braket
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|attribute
op_assign
l_int|0
suffix:semicolon
id|attribute
OL
l_int|3
suffix:semicolon
id|attribute
op_increment
)paren
(brace
r_while
c_loop
(paren
id|mingeo
(braket
id|attribute
)braket
op_ne
id|maxgeo
(braket
id|attribute
)braket
)paren
(brace
r_int
r_int
id|variable
suffix:semicolon
id|variable
op_assign
(paren
id|maxgeo
(braket
id|attribute
)braket
op_plus
id|mingeo
(braket
id|attribute
)braket
)paren
op_rshift
l_int|1
suffix:semicolon
id|cmdb
(braket
l_int|1
)braket
op_assign
id|cmdb
(braket
l_int|2
)braket
op_assign
id|cmdb
(braket
l_int|3
)braket
op_assign
id|cmdb
(braket
l_int|4
)braket
op_assign
id|cmdb
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|need_recal
)paren
(brace
r_int
id|tries
op_assign
l_int|5
suffix:semicolon
r_do
(brace
id|issue_command
(paren
id|CMD_RCLB
comma
id|cmdb
comma
l_int|2
)paren
suffix:semicolon
id|wait_for_completion
(paren
)paren
suffix:semicolon
id|wait_for_command_end
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
(braket
l_int|1
)braket
op_eq
l_int|0x20
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|result
(braket
l_int|1
)braket
op_logical_and
op_decrement
id|tries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
(braket
l_int|1
)braket
)paren
(brace
id|outw
(paren
id|CMD_RCAL
comma
id|MFM_COMMAND
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|need_recal
op_assign
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|attribute
)paren
(brace
r_case
l_int|0
suffix:colon
id|cmdb
(braket
l_int|5
)braket
op_assign
id|variable
suffix:semicolon
id|issue_command
(paren
id|CMD_CMPD
comma
id|cmdb
comma
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|cmdb
(braket
l_int|1
)braket
op_assign
id|variable
suffix:semicolon
id|cmdb
(braket
l_int|4
)braket
op_assign
id|variable
suffix:semicolon
id|issue_command
(paren
id|CMD_CMPD
comma
id|cmdb
comma
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|cmdb
(braket
l_int|2
)braket
op_assign
id|variable
op_rshift
l_int|8
suffix:semicolon
id|cmdb
(braket
l_int|3
)braket
op_assign
id|variable
suffix:semicolon
id|issue_command
(paren
id|CMD_SEK
comma
id|cmdb
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|wait_for_completion
(paren
)paren
suffix:semicolon
id|wait_for_command_end
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result
(braket
l_int|1
)braket
)paren
(brace
r_case
l_int|0x00
suffix:colon
r_case
l_int|0x50
suffix:colon
id|mingeo
(braket
id|attribute
)braket
op_assign
id|variable
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
id|outw
(paren
id|CMD_RCAL
comma
id|MFM_COMMAND
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
l_int|0x24
suffix:colon
id|need_recal
op_assign
l_int|1
suffix:semicolon
r_default
suffix:colon
id|maxgeo
(braket
id|attribute
)braket
op_assign
id|variable
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|mfm_info
(braket
id|drive
)braket
dot
id|cylinders
op_assign
id|mingeo
(braket
l_int|2
)braket
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|lowcurrent
op_assign
id|mingeo
(braket
l_int|2
)braket
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|precomp
op_assign
id|mingeo
(braket
l_int|2
)braket
op_div
l_int|2
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|heads
op_assign
id|mingeo
(braket
l_int|1
)braket
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|sectors
op_assign
id|mingeo
(braket
l_int|0
)braket
suffix:semicolon
id|outw
(paren
id|CMD_RCAL
comma
id|MFM_COMMAND
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Initialise all drive information for this controller.&n; */
DECL|function|mfm_initdrives
r_static
r_int
id|mfm_initdrives
c_func
(paren
r_void
)paren
(brace
r_int
id|drive
suffix:semicolon
r_if
c_cond
(paren
id|number_mfm_drives
OG
id|MFM_MAXDRIVES
)paren
(brace
id|number_mfm_drives
op_assign
id|MFM_MAXDRIVES
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;No. of ADFS MFM drives is greater than MFM_MAXDRIVES - you can&squot;t have that many!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|number_mfm_drives
suffix:semicolon
id|drive
op_increment
)paren
(brace
id|mfm_info
(braket
id|drive
)braket
dot
id|lowcurrent
op_assign
l_int|1
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|precomp
op_assign
l_int|1
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|cylinder
op_assign
op_minus
l_int|1
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|errors.recal
op_assign
l_int|0
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|errors.report
op_assign
l_int|0
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|errors
dot
m_abort
op_assign
l_int|4
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_MFM_AUTODETECT
id|mfm_info
(braket
id|drive
)braket
dot
id|cylinders
op_assign
l_int|1024
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|heads
op_assign
l_int|8
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|sectors
op_assign
l_int|64
suffix:semicolon
(brace
r_int
r_char
id|cmdb
(braket
l_int|16
)braket
suffix:semicolon
id|mfm_setupspecify
(paren
id|drive
comma
id|cmdb
)paren
suffix:semicolon
id|cmdb
(braket
l_int|1
)braket
op_and_assign
op_complement
l_int|0x81
suffix:semicolon
id|issue_command
(paren
id|CMD_SPC
comma
id|cmdb
comma
l_int|16
)paren
suffix:semicolon
id|wait_for_completion
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mfm_detectdrive
(paren
id|drive
)paren
)paren
(brace
id|mfm_info
(braket
id|drive
)braket
dot
id|cylinders
op_assign
l_int|0
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|heads
op_assign
l_int|0
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|sectors
op_assign
l_int|0
suffix:semicolon
)brace
id|cmdb
(braket
l_int|0
)braket
op_assign
id|cmdb
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|issue_command
(paren
id|CMD_CKV
comma
id|cmdb
comma
l_int|2
)paren
suffix:semicolon
)brace
macro_line|#else
id|mfm_info
(braket
id|drive
)braket
dot
id|cylinders
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* its going to have to figure it out from the partition info */
id|mfm_info
(braket
id|drive
)braket
dot
id|heads
op_assign
l_int|4
suffix:semicolon
id|mfm_info
(braket
id|drive
)braket
dot
id|sectors
op_assign
l_int|32
suffix:semicolon
macro_line|#endif
)brace
r_return
id|number_mfm_drives
suffix:semicolon
)brace
multiline_comment|/*&n; * The &squot;front&squot; end of the mfm driver follows...&n; */
DECL|function|mfm_ioctl
r_static
r_int
id|mfm_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|u_int
id|cmd
comma
id|u_long
id|arg
)paren
(brace
r_struct
id|mfm_info
op_star
id|p
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
r_struct
id|hd_geometry
op_star
id|geo
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|HDIO_GETGEO
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|put_user
(paren
id|p-&gt;heads
comma
op_amp
id|geo-&gt;heads
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
(paren
id|p-&gt;sectors
comma
op_amp
id|geo-&gt;sectors
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
(paren
id|p-&gt;cylinders
comma
op_amp
id|geo-&gt;cylinders
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
(paren
id|get_start_sect
c_func
(paren
id|inode-&gt;i_bdev
)paren
comma
op_amp
id|geo-&gt;start
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is to handle various kernel command line parameters&n; * specific to this driver.&n; */
DECL|function|mfm_setup
r_void
id|mfm_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the CHS from the ADFS boot block if it is present.  This is not ideal&n; * since if there are any non-ADFS partitions on the disk, this won&squot;t work!&n; * Hence, I want to get rid of this...&n; */
DECL|function|xd_set_geometry
r_void
id|xd_set_geometry
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_int
r_char
id|secsptrack
comma
r_int
r_char
id|heads
comma
r_int
r_int
id|secsize
)paren
(brace
r_struct
id|mfm_info
op_star
id|p
op_assign
id|bdev-&gt;bd_disk-&gt;private_data
suffix:semicolon
r_int
id|drive
op_assign
id|p
op_minus
id|mfm_info
suffix:semicolon
r_int
r_int
id|disksize
op_assign
id|bdev-&gt;bd_inode-&gt;i_size
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;cylinders
op_eq
l_int|1
)paren
(brace
id|p-&gt;sectors
op_assign
id|secsptrack
suffix:semicolon
id|p-&gt;heads
op_assign
id|heads
suffix:semicolon
id|p-&gt;cylinders
op_assign
id|discsize
op_div
(paren
id|secsptrack
op_star
id|heads
op_star
id|secsize
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|heads
OL
l_int|1
)paren
op_logical_or
(paren
id|p-&gt;cylinders
OG
l_int|1024
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Insane disc shape! Setting to 512/4/32&bslash;n&quot;
comma
id|bdev-&gt;bd_disk-&gt;disk_name
)paren
suffix:semicolon
multiline_comment|/* These values are fairly arbitary, but are there so that if your&n;&t;&t;&t; * lucky you can pick apart your disc to find out what is going on -&n;&t;&t;&t; * I reckon these figures won&squot;t hurt MOST drives&n;&t;&t;&t; */
id|p-&gt;sectors
op_assign
l_int|32
suffix:semicolon
id|p-&gt;heads
op_assign
l_int|4
suffix:semicolon
id|p-&gt;cylinders
op_assign
l_int|512
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_cmd.dev
op_eq
id|drive
)paren
id|mfm_specify
(paren
)paren
suffix:semicolon
id|mfm_geometry
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
DECL|variable|mfm_fops
r_static
r_struct
id|block_device_operations
id|mfm_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|ioctl
op_assign
id|mfm_ioctl
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * See if there is a controller at the address presently at mfm_addr&n; *&n; * We check to see if the controller is busy - if it is, we abort it first,&n; * and check that the chip is no longer busy after at least 180 clock cycles.&n; * We then issue a command and check that the BSY or CPR bits are set.&n; */
DECL|function|mfm_probecontroller
r_static
r_int
id|mfm_probecontroller
(paren
r_int
r_int
id|mfm_addr
)paren
(brace
r_if
c_cond
(paren
id|inw
(paren
id|MFM_STATUS
)paren
op_amp
id|STAT_BSY
)paren
(brace
id|outw
(paren
id|CMD_ABT
comma
id|MFM_COMMAND
)paren
suffix:semicolon
id|udelay
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inw
(paren
id|MFM_STATUS
)paren
op_amp
id|STAT_BSY
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inw
(paren
id|MFM_STATUS
)paren
op_amp
id|STAT_CED
)paren
id|outw
(paren
id|CMD_RCAL
comma
id|MFM_COMMAND
)paren
suffix:semicolon
id|outw
(paren
id|CMD_SEK
comma
id|MFM_COMMAND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inw
(paren
id|MFM_STATUS
)paren
op_amp
(paren
id|STAT_BSY
op_or
id|STAT_CPR
)paren
)paren
(brace
r_int
r_int
id|count
op_assign
l_int|2000
suffix:semicolon
r_while
c_loop
(paren
id|inw
(paren
id|MFM_STATUS
)paren
op_amp
id|STAT_BSY
)paren
(brace
id|udelay
(paren
l_int|500
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|count
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|outw
(paren
id|CMD_RCAL
comma
id|MFM_COMMAND
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|mfm_do_init
r_static
r_int
id|mfm_do_init
c_func
(paren
r_int
r_char
id|irqmask
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mfm: found at address %08X, interrupt %d&bslash;n&quot;
comma
id|mfm_addr
comma
id|mfm_irq
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
(paren
id|mfm_addr
comma
l_int|10
comma
l_string|&quot;mfm&quot;
)paren
)paren
r_goto
id|out1
suffix:semicolon
id|ret
op_assign
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;mfm&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out2
suffix:semicolon
multiline_comment|/* Stuff for the assembler routines to get to */
id|hdc63463_baseaddress
op_assign
id|ioaddr
c_func
(paren
id|mfm_addr
)paren
suffix:semicolon
id|hdc63463_irqpolladdress
op_assign
id|mfm_IRQPollLoc
suffix:semicolon
id|hdc63463_irqpollmask
op_assign
id|irqmask
suffix:semicolon
id|mfm_queue
op_assign
id|blk_init_queue
c_func
(paren
id|do_mfm_request
comma
op_amp
id|mfm_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mfm_queue
)paren
r_goto
id|out2a
suffix:semicolon
id|Busy
op_assign
l_int|0
suffix:semicolon
id|lastspecifieddrive
op_assign
op_minus
l_int|1
suffix:semicolon
id|mfm_drives
op_assign
id|mfm_initdrives
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mfm_drives
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out3
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mfm_drives
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|alloc_disk
c_func
(paren
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk
)paren
r_goto
id|Enomem
suffix:semicolon
id|disk-&gt;major
op_assign
id|MAJOR_NR
suffix:semicolon
id|disk-&gt;first_minor
op_assign
id|i
op_lshift
l_int|6
suffix:semicolon
id|disk-&gt;fops
op_assign
op_amp
id|mfm_fops
suffix:semicolon
id|sprintf
c_func
(paren
id|disk-&gt;disk_name
comma
l_string|&quot;mfm%c&quot;
comma
l_char|&squot;a&squot;
op_plus
id|i
)paren
suffix:semicolon
id|mfm_gendisk
(braket
id|i
)braket
op_assign
id|disk
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;mfm: detected %d hard drive%s&bslash;n&quot;
comma
id|mfm_drives
comma
id|mfm_drives
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|request_irq
c_func
(paren
id|mfm_irq
comma
id|mfm_interrupt_handler
comma
id|SA_INTERRUPT
comma
l_string|&quot;MFM harddisk&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mfm: unable to get IRQ%d&bslash;n&quot;
comma
id|mfm_irq
)paren
suffix:semicolon
r_goto
id|out4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mfm_irqenable
)paren
id|outw
c_func
(paren
l_int|0x80
comma
id|mfm_irqenable
)paren
suffix:semicolon
multiline_comment|/* Required to enable IRQs from MFM podule */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mfm_drives
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mfm_geometry
c_func
(paren
id|i
)paren
suffix:semicolon
id|mfm_gendisk
(braket
id|i
)braket
op_member_access_from_pointer
id|queue
op_assign
id|mfm_queue
suffix:semicolon
id|add_disk
c_func
(paren
id|mfm_gendisk
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out4
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mfm_drives
suffix:semicolon
id|i
op_increment
)paren
id|put_disk
c_func
(paren
id|mfm_gendisk
(braket
id|i
)braket
)paren
suffix:semicolon
id|out3
suffix:colon
id|blk_cleanup_queue
c_func
(paren
id|mfm_queue
)paren
suffix:semicolon
id|out2a
suffix:colon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;mfm&quot;
)paren
suffix:semicolon
id|out2
suffix:colon
id|release_region
c_func
(paren
id|mfm_addr
comma
l_int|10
)paren
suffix:semicolon
id|out1
suffix:colon
r_return
id|ret
suffix:semicolon
id|Enomem
suffix:colon
r_while
c_loop
(paren
id|i
op_decrement
)paren
id|put_disk
c_func
(paren
id|mfm_gendisk
(braket
id|i
)braket
)paren
suffix:semicolon
r_goto
id|out3
suffix:semicolon
)brace
DECL|function|mfm_do_exit
r_static
r_void
id|mfm_do_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|free_irq
c_func
(paren
id|mfm_irq
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mfm_drives
suffix:semicolon
id|i
op_increment
)paren
(brace
id|del_gendisk
c_func
(paren
id|mfm_gendisk
(braket
id|i
)braket
)paren
suffix:semicolon
id|put_disk
c_func
(paren
id|mfm_gendisk
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
id|mfm_queue
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;mfm&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfm_addr
)paren
id|release_region
c_func
(paren
id|mfm_addr
comma
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|mfm_probe
r_static
r_int
id|__devinit
id|mfm_probe
c_func
(paren
r_struct
id|expansion_card
op_star
id|ec
comma
r_struct
id|ecard_id
op_star
id|id
)paren
(brace
r_if
c_cond
(paren
id|mfm_addr
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|mfm_addr
op_assign
id|ecard_address
c_func
(paren
id|ec
comma
id|ECARD_IOC
comma
id|ECARD_MEDIUM
)paren
op_plus
l_int|0x800
suffix:semicolon
id|mfm_IRQPollLoc
op_assign
id|ioaddr
c_func
(paren
id|mfm_addr
op_plus
l_int|0x400
)paren
suffix:semicolon
id|mfm_irqenable
op_assign
id|mfm_IRQPollLoc
suffix:semicolon
id|mfm_irq
op_assign
id|ec-&gt;irq
suffix:semicolon
r_return
id|mfm_do_init
c_func
(paren
l_int|0x08
)paren
suffix:semicolon
)brace
DECL|function|mfm_remove
r_static
r_void
id|__devexit
id|mfm_remove
c_func
(paren
r_struct
id|expansion_card
op_star
id|ec
)paren
(brace
id|outw
(paren
l_int|0
comma
id|mfm_irqenable
)paren
suffix:semicolon
multiline_comment|/* Required to enable IRQs from MFM podule */
id|mfm_do_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|mfm_cids
r_static
r_const
r_struct
id|ecard_id
id|mfm_cids
(braket
)braket
op_assign
(brace
(brace
id|MANU_ACORN
comma
id|PROD_ACORN_MFM
)brace
comma
(brace
l_int|0xffff
comma
l_int|0xffff
)brace
comma
)brace
suffix:semicolon
DECL|variable|mfm_driver
r_static
r_struct
id|ecard_driver
id|mfm_driver
op_assign
(brace
dot
id|probe
op_assign
id|mfm_probe
comma
dot
id|remove
op_assign
id|__devexit
c_func
(paren
id|mfm_remove
)paren
comma
dot
id|id_table
op_assign
id|mfm_cids
comma
dot
id|drv
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;mfm&quot;
comma
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Look for a MFM controller - first check the motherboard, then the podules&n; * The podules have an extra interrupt enable that needs to be played with&n; *&n; * The HDC is accessed at MEDIUM IOC speeds.&n; */
DECL|function|mfm_init
r_static
r_int
id|__init
id|mfm_init
(paren
r_void
)paren
(brace
r_int
r_char
id|irqmask
suffix:semicolon
r_if
c_cond
(paren
id|mfm_probecontroller
c_func
(paren
id|ONBOARD_MFM_ADDRESS
)paren
)paren
(brace
id|mfm_addr
op_assign
id|ONBOARD_MFM_ADDRESS
suffix:semicolon
id|mfm_IRQPollLoc
op_assign
id|IOC_IRQSTATB
suffix:semicolon
id|mfm_irqenable
op_assign
l_int|0
suffix:semicolon
id|mfm_irq
op_assign
id|IRQ_HARDDISK
suffix:semicolon
r_return
id|mfm_do_init
c_func
(paren
l_int|0x08
)paren
suffix:semicolon
multiline_comment|/* IL3 pin */
)brace
r_else
(brace
r_return
id|ecard_register_driver
c_func
(paren
op_amp
id|mfm_driver
)paren
suffix:semicolon
)brace
)brace
DECL|function|mfm_exit
r_static
r_void
id|__exit
id|mfm_exit
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|mfm_addr
op_eq
id|ONBOARD_MFM_ADDRESS
)paren
id|mfm_do_exit
c_func
(paren
)paren
suffix:semicolon
r_else
id|ecard_unregister_driver
c_func
(paren
op_amp
id|mfm_driver
)paren
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|mfm_init
)paren
id|module_exit
c_func
(paren
id|mfm_exit
)paren
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
