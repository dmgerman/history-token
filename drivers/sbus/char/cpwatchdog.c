multiline_comment|/* cpwatchdog.c - driver implementation for hardware watchdog&n; * timers found on Sun Microsystems CP1400 and CP1500 boards.&n; *&n; * This device supports both the generic Linux watchdog &n; * interface and Solaris-compatible ioctls as best it is&n; * able.&n; *&n; * NOTE: &t;CP1400 systems appear to have a defective intr_mask&n; * &t;&t;&t;register on the PLD, preventing the disabling of&n; * &t;&t;&t;timer interrupts.  We use a timer to periodically &n; * &t;&t;&t;reset &squot;stopped&squot; watchdogs on affected platforms.&n; *&n; * TODO:&t;DevFS support (/dev/watchdogs/0 ... /dev/watchdogs/2)&n; *&n; * Copyright (c) 2000 Eric Brower (ebrower@usa.net)&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/ebus.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/watchdog.h&gt;
DECL|macro|WD_OBPNAME
mdefine_line|#define WD_OBPNAME&t;&quot;watchdog&quot;
DECL|macro|WD_BADMODEL
mdefine_line|#define WD_BADMODEL &quot;SUNW,501-5336&quot;
DECL|macro|WD_BTIMEOUT
mdefine_line|#define WD_BTIMEOUT&t;(jiffies + (HZ * 1000))
DECL|macro|WD_BLIMIT
mdefine_line|#define WD_BLIMIT&t;0xFFFF
DECL|macro|WD0_DEVNAME
mdefine_line|#define WD0_DEVNAME &quot;watchdog0&quot;
DECL|macro|WD1_DEVNAME
mdefine_line|#define WD1_DEVNAME &quot;watchdog1&quot;
DECL|macro|WD2_DEVNAME
mdefine_line|#define WD2_DEVNAME &quot;watchdog2&quot;
DECL|macro|WD0_MINOR
mdefine_line|#define WD0_MINOR&t;212
DECL|macro|WD1_MINOR
mdefine_line|#define WD1_MINOR&t;213&t;
DECL|macro|WD2_MINOR
mdefine_line|#define WD2_MINOR&t;214&t;
multiline_comment|/* Internal driver definitions&n; */
DECL|macro|WD0_ID
mdefine_line|#define WD0_ID&t;&t;&t;0&t;&t;/* Watchdog0&t;&t;&t;&t;&t;&t;*/
DECL|macro|WD1_ID
mdefine_line|#define WD1_ID&t;&t;&t;1&t;&t;/* Watchdog1&t;&t;&t;&t;&t;&t;*/
DECL|macro|WD2_ID
mdefine_line|#define WD2_ID&t;&t;&t;2&t;&t;/* Watchdog2&t;&t;&t;&t;&t;&t;*/
DECL|macro|WD_NUMDEVS
mdefine_line|#define WD_NUMDEVS&t;&t;3&t;&t;/* Device contains 3 timers&t;&t;&t;*/
DECL|macro|WD_INTR_OFF
mdefine_line|#define WD_INTR_OFF&t;&t;0&t;&t;/* Interrupt disable value&t;&t;&t;*/
DECL|macro|WD_INTR_ON
mdefine_line|#define WD_INTR_ON&t;&t;1&t;&t;/* Interrupt enable value&t;&t;&t;*/
DECL|macro|WD_STAT_INIT
mdefine_line|#define WD_STAT_INIT&t;0x01&t;/* Watchdog timer is initialized&t;*/
DECL|macro|WD_STAT_BSTOP
mdefine_line|#define WD_STAT_BSTOP&t;0x02&t;/* Watchdog timer is brokenstopped&t;*/
DECL|macro|WD_STAT_SVCD
mdefine_line|#define WD_STAT_SVCD&t;0x04&t;/* Watchdog interrupt occurred&t;&t;*/
multiline_comment|/* Register value definitions&n; */
DECL|macro|WD0_INTR_MASK
mdefine_line|#define WD0_INTR_MASK&t;0x01&t;/* Watchdog device interrupt masks&t;*/
DECL|macro|WD1_INTR_MASK
mdefine_line|#define WD1_INTR_MASK&t;0x02
DECL|macro|WD2_INTR_MASK
mdefine_line|#define WD2_INTR_MASK&t;0x04
DECL|macro|WD_S_RUNNING
mdefine_line|#define WD_S_RUNNING&t;0x01&t;/* Watchdog device status running&t;*/
DECL|macro|WD_S_EXPIRED
mdefine_line|#define WD_S_EXPIRED&t;0x02&t;/* Watchdog device status expired&t;*/
multiline_comment|/* Sun uses Altera PLD EPF8820ATC144-4 &n; * providing three hardware watchdogs:&n; *&n; * &t;1) RIC - sends an interrupt when triggered&n; * &t;2) XIR - asserts XIR_B_RESET when triggered, resets CPU&n; * &t;3) POR - asserts POR_B_RESET when triggered, resets CPU, backplane, board&n; *&n; *** Timer register block definition (struct wd_timer_regblk)&n; *&n; * dcntr and limit registers (halfword access):      &n; * -------------------&n; * | 15 | ...| 1 | 0 |&n; * -------------------&n; * |-  counter val  -|&n; * -------------------&n; * dcntr - &t;Current 16-bit downcounter value.&n; * &t;&t;&t;When downcounter reaches &squot;0&squot; watchdog expires.&n; * &t;&t;&t;Reading this register resets downcounter with &squot;limit&squot; value.&n; * limit - &t;16-bit countdown value in 1/10th second increments.&n; * &t;&t;&t;Writing this register begins countdown with input value.&n; * &t;&t;&t;Reading from this register does not affect counter.&n; * NOTES:&t;After watchdog reset, dcntr and limit contain &squot;1&squot;&n; *&n; * status register (byte access):&n; * ---------------------------&n; * | 7 | ... | 2 |  1  |  0  |&n; * --------------+------------&n; * |-   UNUSED  -| EXP | RUN |&n; * ---------------------------&n; * status-&t;Bit 0 - Watchdog is running&n; * &t;&t;&t;Bit 1 - Watchdog has expired&n; *&n; *** PLD register block definition (struct wd_pld_regblk)&n; *&n; * intr_mask register (byte access):&n; * ---------------------------------&n; * | 7 | ... | 3 |  2  |  1  |  0  |&n; * +-------------+------------------&n; * |-   UNUSED  -| WD3 | WD2 | WD1 |&n; * ---------------------------------&n; * WD3 -  1 == Interrupt disabled for watchdog 3&n; * WD2 -  1 == Interrupt disabled for watchdog 2&n; * WD1 -  1 == Interrupt disabled for watchdog 1&n; *&n; * pld_status register (byte access):&n; * UNKNOWN, MAGICAL MYSTERY REGISTER&n; *&n; */
DECL|struct|wd_timer_regblk
r_struct
id|wd_timer_regblk
(brace
DECL|member|dcntr
r_volatile
id|__u16
id|dcntr
suffix:semicolon
multiline_comment|/* down counter&t;&t;- hw&t;*/
DECL|member|dcntr_pad
r_volatile
id|__u16
id|dcntr_pad
suffix:semicolon
DECL|member|limit
r_volatile
id|__u16
id|limit
suffix:semicolon
multiline_comment|/* limit register&t;- hw&t;*/
DECL|member|limit_pad
r_volatile
id|__u16
id|limit_pad
suffix:semicolon
DECL|member|status
r_volatile
id|__u8
id|status
suffix:semicolon
multiline_comment|/* status register&t;- b&t;&t;*/
DECL|member|status_pad
r_volatile
id|__u8
id|status_pad
suffix:semicolon
DECL|member|status_pad2
r_volatile
id|__u16
id|status_pad2
suffix:semicolon
DECL|member|pad32
r_volatile
id|__u32
id|pad32
suffix:semicolon
multiline_comment|/* yet more padding&t;&t;&t;*/
)brace
suffix:semicolon
DECL|struct|wd_pld_regblk
r_struct
id|wd_pld_regblk
(brace
DECL|member|intr_mask
r_volatile
id|__u8
id|intr_mask
suffix:semicolon
multiline_comment|/* interrupt mask&t;- b&t;&t;*/
DECL|member|intr_mask_pad
r_volatile
id|__u8
id|intr_mask_pad
suffix:semicolon
DECL|member|intr_mask_pad2
r_volatile
id|__u16
id|intr_mask_pad2
suffix:semicolon
DECL|member|status
r_volatile
id|__u8
id|status
suffix:semicolon
multiline_comment|/* device status&t;- b&t;&t;*/
DECL|member|status_pad
r_volatile
id|__u8
id|status_pad
suffix:semicolon
DECL|member|status_pad2
r_volatile
id|__u16
id|status_pad2
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|wd_regblk
r_struct
id|wd_regblk
(brace
DECL|member|wd0_regs
r_volatile
r_struct
id|wd_timer_regblk
id|wd0_regs
suffix:semicolon
DECL|member|wd1_regs
r_volatile
r_struct
id|wd_timer_regblk
id|wd1_regs
suffix:semicolon
DECL|member|wd2_regs
r_volatile
r_struct
id|wd_timer_regblk
id|wd2_regs
suffix:semicolon
DECL|member|pld_regs
r_volatile
r_struct
id|wd_pld_regblk
id|pld_regs
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Individual timer structure &n; */
DECL|struct|wd_timer
r_struct
id|wd_timer
(brace
DECL|member|timeout
id|__u16
id|timeout
suffix:semicolon
DECL|member|intr_mask
id|__u8
id|intr_mask
suffix:semicolon
DECL|member|runstatus
r_int
r_char
id|runstatus
suffix:semicolon
DECL|member|regs
r_volatile
r_struct
id|wd_timer_regblk
op_star
id|regs
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Device structure&n; */
DECL|struct|wd_device
r_struct
id|wd_device
(brace
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|isbaddoggie
r_int
r_char
id|isbaddoggie
suffix:semicolon
multiline_comment|/* defective PLD */
DECL|member|opt_enable
r_int
r_char
id|opt_enable
suffix:semicolon
DECL|member|opt_reboot
r_int
r_char
id|opt_reboot
suffix:semicolon
DECL|member|opt_timeout
r_int
r_int
id|opt_timeout
suffix:semicolon
DECL|member|initialized
r_int
r_char
id|initialized
suffix:semicolon
DECL|member|watchdog
r_struct
id|wd_timer
id|watchdog
(braket
id|WD_NUMDEVS
)braket
suffix:semicolon
DECL|member|regs
r_volatile
r_struct
id|wd_regblk
op_star
id|regs
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|wd_dev
r_static
r_struct
id|wd_device
id|wd_dev
op_assign
(brace
l_int|0
comma
id|SPIN_LOCK_UNLOCKED
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|wd_timer
r_static
r_struct
id|timer_list
id|wd_timer
suffix:semicolon
DECL|variable|wd0_timeout
r_static
r_int
id|wd0_timeout
op_assign
l_int|0
suffix:semicolon
DECL|variable|wd1_timeout
r_static
r_int
id|wd1_timeout
op_assign
l_int|0
suffix:semicolon
DECL|variable|wd2_timeout
r_static
r_int
id|wd2_timeout
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef MODULE
id|EXPORT_NO_SYMBOLS
suffix:semicolon
id|MODULE_PARM
(paren
id|wd0_timeout
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|wd0_timeout
comma
l_string|&quot;Default watchdog0 timeout in 1/10secs&quot;
)paren
suffix:semicolon
id|MODULE_PARM
(paren
id|wd1_timeout
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|wd1_timeout
comma
l_string|&quot;Default watchdog1 timeout in 1/10secs&quot;
)paren
suffix:semicolon
id|MODULE_PARM
(paren
id|wd2_timeout
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|wd2_timeout
comma
l_string|&quot;Default watchdog2 timeout in 1/10secs&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;Eric Brower &lt;ebrower@usa.net&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;Hardware watchdog driver for Sun Microsystems CP1400/1500&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
(paren
l_string|&quot;watchdog&quot;
)paren
suffix:semicolon
macro_line|#endif /* ifdef MODULE */
multiline_comment|/* Forward declarations of internal methods&n; */
macro_line|#ifdef WD_DEBUG
r_static
r_void
id|wd_dumpregs
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|wd_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|wd_toggleintr
c_func
(paren
r_struct
id|wd_timer
op_star
id|pTimer
comma
r_int
id|enable
)paren
suffix:semicolon
r_static
r_void
id|wd_pingtimer
c_func
(paren
r_struct
id|wd_timer
op_star
id|pTimer
)paren
suffix:semicolon
r_static
r_void
id|wd_starttimer
c_func
(paren
r_struct
id|wd_timer
op_star
id|pTimer
)paren
suffix:semicolon
r_static
r_void
id|wd_resetbrokentimer
c_func
(paren
r_struct
id|wd_timer
op_star
id|pTimer
)paren
suffix:semicolon
r_static
r_void
id|wd_stoptimer
c_func
(paren
r_struct
id|wd_timer
op_star
id|pTimer
)paren
suffix:semicolon
r_static
r_void
id|wd_brokentimer
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_int
id|wd_getstatus
c_func
(paren
r_struct
id|wd_timer
op_star
id|pTimer
)paren
suffix:semicolon
multiline_comment|/* PLD expects words to be written in LSB format,&n; * so we must flip all words prior to writing them to regs&n; */
DECL|function|flip_word
r_static
r_inline
r_int
r_int
id|flip_word
c_func
(paren
r_int
r_int
id|word
)paren
(brace
r_return
(paren
(paren
id|word
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|word
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
DECL|macro|wd_writew
mdefine_line|#define wd_writew(val, addr) &t;(writew(flip_word(val), addr))
DECL|macro|wd_readw
mdefine_line|#define wd_readw(addr) &t;&t;&t;(flip_word(readw(addr)))
DECL|macro|wd_writeb
mdefine_line|#define wd_writeb(val, addr) &t;(writeb(val, addr))
DECL|macro|wd_readb
mdefine_line|#define wd_readb(addr) &t;&t;&t;(readb(addr))
multiline_comment|/* CP1400s seem to have broken PLD implementations--&n; * the interrupt_mask register cannot be written, so&n; * no timer interrupts can be masked within the PLD.&n; */
DECL|function|wd_isbroken
r_static
r_inline
r_int
id|wd_isbroken
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* we could test this by read/write/read/restore&n;&t; * on the interrupt mask register only if OBP&n;&t; * &squot;watchdog-enable?&squot; == FALSE, but it seems &n;&t; * ubiquitous on CP1400s&n;&t; */
r_char
id|val
(braket
l_int|32
)braket
suffix:semicolon
id|prom_getproperty
c_func
(paren
id|prom_root_node
comma
l_string|&quot;model&quot;
comma
id|val
comma
r_sizeof
(paren
id|val
)paren
)paren
suffix:semicolon
r_return
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|val
comma
id|WD_BADMODEL
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Retrieve watchdog-enable? option from OBP&n; * Returns 0 if false, 1 if true&n; */
DECL|function|wd_opt_enable
r_static
r_inline
r_int
id|wd_opt_enable
c_func
(paren
r_void
)paren
(brace
r_int
id|opt_node
suffix:semicolon
id|opt_node
op_assign
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
suffix:semicolon
id|opt_node
op_assign
id|prom_searchsiblings
c_func
(paren
id|opt_node
comma
l_string|&quot;options&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
op_eq
id|prom_getint
c_func
(paren
id|opt_node
comma
l_string|&quot;watchdog-enable?&quot;
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Retrieve watchdog-reboot? option from OBP&n; * Returns 0 if false, 1 if true&n; */
DECL|function|wd_opt_reboot
r_static
r_inline
r_int
id|wd_opt_reboot
c_func
(paren
r_void
)paren
(brace
r_int
id|opt_node
suffix:semicolon
id|opt_node
op_assign
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
suffix:semicolon
id|opt_node
op_assign
id|prom_searchsiblings
c_func
(paren
id|opt_node
comma
l_string|&quot;options&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
op_eq
id|prom_getint
c_func
(paren
id|opt_node
comma
l_string|&quot;watchdog-reboot?&quot;
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Retrieve watchdog-timeout option from OBP&n; * Returns OBP value, or 0 if not located&n; */
DECL|function|wd_opt_timeout
r_static
r_inline
r_int
id|wd_opt_timeout
c_func
(paren
r_void
)paren
(brace
r_int
id|opt_node
suffix:semicolon
r_char
id|value
(braket
l_int|32
)braket
suffix:semicolon
r_char
op_star
id|p
op_assign
id|value
suffix:semicolon
id|opt_node
op_assign
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
suffix:semicolon
id|opt_node
op_assign
id|prom_searchsiblings
c_func
(paren
id|opt_node
comma
l_string|&quot;options&quot;
)paren
suffix:semicolon
id|opt_node
op_assign
id|prom_getproperty
c_func
(paren
id|opt_node
comma
l_string|&quot;watchdog-timeout&quot;
comma
id|value
comma
r_sizeof
(paren
id|value
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_ne
id|opt_node
)paren
(brace
multiline_comment|/* atoi implementation */
r_for
c_loop
(paren
id|opt_node
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* nop */
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_ge
l_char|&squot;0&squot;
op_logical_and
op_star
id|p
op_le
l_char|&squot;9&squot;
)paren
(brace
id|opt_node
op_assign
(paren
l_int|10
op_star
id|opt_node
)paren
op_plus
(paren
op_star
id|p
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
(paren
op_minus
l_int|1
op_eq
id|opt_node
)paren
ques
c_cond
(paren
l_int|0
)paren
suffix:colon
(paren
id|opt_node
)paren
suffix:semicolon
)brace
DECL|function|wd_open
r_static
r_int
id|wd_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|f
)paren
(brace
r_switch
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
(brace
r_case
id|WD0_MINOR
suffix:colon
id|f-&gt;private_data
op_assign
op_amp
id|wd_dev.watchdog
(braket
id|WD0_ID
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WD1_MINOR
suffix:colon
id|f-&gt;private_data
op_assign
op_amp
id|wd_dev.watchdog
(braket
id|WD1_ID
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WD2_MINOR
suffix:colon
id|f-&gt;private_data
op_assign
op_amp
id|wd_dev.watchdog
(braket
id|WD2_ID
)braket
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Register IRQ on first open of device */
r_if
c_cond
(paren
l_int|0
op_eq
id|wd_dev.initialized
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|wd_dev.irq
comma
op_amp
id|wd_interrupt
comma
id|SA_SHIRQ
comma
id|WD_OBPNAME
comma
(paren
r_void
op_star
)paren
id|wd_dev.regs
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Cannot register IRQ %s&bslash;n&quot;
comma
id|WD_OBPNAME
comma
id|__irq_itoa
c_func
(paren
id|wd_dev.irq
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|wd_dev.initialized
op_assign
l_int|1
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wd_release
r_static
r_int
id|wd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wd_ioctl
r_static
r_int
id|wd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|setopt
op_assign
l_int|0
suffix:semicolon
r_struct
id|wd_timer
op_star
id|pTimer
op_assign
(paren
r_struct
id|wd_timer
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|watchdog_info
id|info
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_string|&quot;Altera EPF8820ATC144-4&quot;
)brace
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|pTimer
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* Generic Linux IOCTLs */
r_case
id|WDIOC_GETSUPPORT
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_struct
id|watchdog_info
op_star
)paren
id|arg
comma
(paren
r_struct
id|watchdog_info
op_star
)paren
op_amp
id|info
comma
r_sizeof
(paren
r_struct
id|watchdog_info
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|WDIOC_GETSTATUS
suffix:colon
r_case
id|WDIOC_GETBOOTSTATUS
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
l_int|0
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WDIOC_KEEPALIVE
suffix:colon
id|wd_pingtimer
c_func
(paren
id|pTimer
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WDIOC_SETOPTIONS
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|setopt
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|setopt
op_amp
id|WDIOS_DISABLECARD
)paren
(brace
r_if
c_cond
(paren
id|wd_dev.opt_enable
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: cannot disable watchdog in ENABLED mode&bslash;n&quot;
comma
id|WD_OBPNAME
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|wd_stoptimer
c_func
(paren
id|pTimer
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|setopt
op_amp
id|WDIOS_ENABLECARD
)paren
(brace
id|wd_starttimer
c_func
(paren
id|pTimer
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Solaris-compatible IOCTLs */
r_case
id|WIOCGSTAT
suffix:colon
id|setopt
op_assign
id|wd_getstatus
c_func
(paren
id|pTimer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|setopt
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|WIOCSTART
suffix:colon
id|wd_starttimer
c_func
(paren
id|pTimer
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WIOCSTOP
suffix:colon
r_if
c_cond
(paren
id|wd_dev.opt_enable
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: cannot disable watchdog in ENABLED mode&bslash;n&quot;
comma
id|WD_OBPNAME
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|wd_stoptimer
c_func
(paren
id|pTimer
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wd_write
r_static
id|ssize_t
id|wd_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|wd_timer
op_star
id|pTimer
op_assign
(paren
r_struct
id|wd_timer
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|pTimer
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|wd_pingtimer
c_func
(paren
id|pTimer
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wd_read
r_static
id|ssize_t
id|wd_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
macro_line|#ifdef WD_DEBUG
id|wd_dumpregs
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#else
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif /* ifdef WD_DEBUG */
)brace
DECL|function|wd_interrupt
r_static
r_void
id|wd_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* Only WD0 will interrupt-- others are NMI and we won&squot;t&n;&t; * see them here....&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|wd_dev.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|wd_dev.regs
op_eq
(paren
r_int
r_int
)paren
id|dev_id
)paren
(brace
id|wd_stoptimer
c_func
(paren
op_amp
id|wd_dev.watchdog
(braket
id|WD0_ID
)braket
)paren
suffix:semicolon
id|wd_dev.watchdog
(braket
id|WD0_ID
)braket
dot
id|runstatus
op_or_assign
id|WD_STAT_SVCD
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|wd_dev.lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|wd_fops
r_static
r_struct
id|file_operations
id|wd_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|ioctl
suffix:colon
id|wd_ioctl
comma
id|open
suffix:colon
id|wd_open
comma
id|write
suffix:colon
id|wd_write
comma
id|read
suffix:colon
id|wd_read
comma
id|release
suffix:colon
id|wd_release
comma
)brace
suffix:semicolon
DECL|variable|wd0_miscdev
r_static
r_struct
id|miscdevice
id|wd0_miscdev
op_assign
(brace
id|WD0_MINOR
comma
id|WD0_DEVNAME
comma
op_amp
id|wd_fops
)brace
suffix:semicolon
DECL|variable|wd1_miscdev
r_static
r_struct
id|miscdevice
id|wd1_miscdev
op_assign
(brace
id|WD1_MINOR
comma
id|WD1_DEVNAME
comma
op_amp
id|wd_fops
)brace
suffix:semicolon
DECL|variable|wd2_miscdev
r_static
r_struct
id|miscdevice
id|wd2_miscdev
op_assign
(brace
id|WD2_MINOR
comma
id|WD2_DEVNAME
comma
op_amp
id|wd_fops
)brace
suffix:semicolon
macro_line|#ifdef WD_DEBUG
DECL|function|wd_dumpregs
r_static
r_void
id|wd_dumpregs
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Reading from downcounters initiates watchdog countdown--&n;&t; * Example is included below for illustration purposes.&n;&t; */
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: dumping register values&bslash;n&quot;
comma
id|WD_OBPNAME
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|WD0_ID
suffix:semicolon
id|i
OL
id|WD_NUMDEVS
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/* printk(&quot;&bslash;t%s%i: dcntr  at 0x%lx: 0x%x&bslash;n&quot;, &n;&t;&t;&t; * &t;WD_OBPNAME,&n;&t;&t; &t; *&t;i,&n;&t;&t;&t; *&t;(unsigned long)(&amp;wd_dev.watchdog[i].regs-&gt;dcntr), &n;&t;&t;&t; *&t;readw(&amp;wd_dev.watchdog[i].regs-&gt;dcntr));&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;&bslash;t%s%i: limit  at 0x%lx: 0x%x&bslash;n&quot;
comma
id|WD_OBPNAME
comma
id|i
comma
(paren
r_int
r_int
)paren
(paren
op_amp
id|wd_dev.watchdog
(braket
id|i
)braket
dot
id|regs-&gt;limit
)paren
comma
id|readw
c_func
(paren
op_amp
id|wd_dev.watchdog
(braket
id|i
)braket
dot
id|regs-&gt;limit
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t%s%i: status at 0x%lx: 0x%x&bslash;n&quot;
comma
id|WD_OBPNAME
comma
id|i
comma
(paren
r_int
r_int
)paren
(paren
op_amp
id|wd_dev.watchdog
(braket
id|i
)braket
dot
id|regs-&gt;status
)paren
comma
id|readb
c_func
(paren
op_amp
id|wd_dev.watchdog
(braket
id|i
)braket
dot
id|regs-&gt;status
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t%s%i: driver status: 0x%x&bslash;n&quot;
comma
id|WD_OBPNAME
comma
id|i
comma
id|wd_getstatus
c_func
(paren
op_amp
id|wd_dev.watchdog
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tintr_mask  at 0x%lx: 0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
op_amp
id|wd_dev.regs-&gt;pld_regs.intr_mask
)paren
comma
id|readb
c_func
(paren
op_amp
id|wd_dev.regs-&gt;pld_regs.intr_mask
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tpld_status at 0x%lx: 0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
op_amp
id|wd_dev.regs-&gt;pld_regs.status
)paren
comma
id|readb
c_func
(paren
op_amp
id|wd_dev.regs-&gt;pld_regs.status
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Enable or disable watchdog interrupts&n; * Because of the CP1400 defect this should only be&n; * called during initialzation or by wd_[start|stop]timer()&n; *&n; * pTimer &t;- pointer to timer device, or NULL to indicate all timers &n; * enable&t;- non-zero to enable interrupts, zero to disable&n; */
DECL|function|wd_toggleintr
r_static
r_void
id|wd_toggleintr
c_func
(paren
r_struct
id|wd_timer
op_star
id|pTimer
comma
r_int
id|enable
)paren
(brace
r_int
r_char
id|curregs
op_assign
id|wd_readb
c_func
(paren
op_amp
id|wd_dev.regs-&gt;pld_regs.intr_mask
)paren
suffix:semicolon
r_int
r_char
id|setregs
op_assign
(paren
l_int|NULL
op_eq
id|pTimer
)paren
ques
c_cond
(paren
id|WD0_INTR_MASK
op_or
id|WD1_INTR_MASK
op_or
id|WD2_INTR_MASK
)paren
suffix:colon
(paren
id|pTimer-&gt;intr_mask
)paren
suffix:semicolon
(paren
id|WD_INTR_ON
op_eq
id|enable
)paren
ques
c_cond
(paren
id|curregs
op_and_assign
op_complement
id|setregs
)paren
suffix:colon
(paren
id|curregs
op_or_assign
id|setregs
)paren
suffix:semicolon
id|wd_writeb
c_func
(paren
id|curregs
comma
op_amp
id|wd_dev.regs-&gt;pld_regs.intr_mask
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Reset countdown timer with &squot;limit&squot; value and continue countdown.&n; * This will not start a stopped timer.&n; *&n; * pTimer&t;- pointer to timer device&n; */
DECL|function|wd_pingtimer
r_static
r_void
id|wd_pingtimer
c_func
(paren
r_struct
id|wd_timer
op_star
id|pTimer
)paren
(brace
r_if
c_cond
(paren
id|wd_readb
c_func
(paren
op_amp
id|pTimer-&gt;regs-&gt;status
)paren
op_amp
id|WD_S_RUNNING
)paren
(brace
id|wd_readb
c_func
(paren
op_amp
id|pTimer-&gt;regs-&gt;dcntr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Stop a running watchdog timer-- the timer actually keeps&n; * running, but the interrupt is masked so that no action is&n; * taken upon expiration.&n; *&n; * pTimer&t;- pointer to timer device&n; */
DECL|function|wd_stoptimer
r_static
r_void
id|wd_stoptimer
c_func
(paren
r_struct
id|wd_timer
op_star
id|pTimer
)paren
(brace
r_if
c_cond
(paren
id|wd_readb
c_func
(paren
op_amp
id|pTimer-&gt;regs-&gt;status
)paren
op_amp
id|WD_S_RUNNING
)paren
(brace
id|wd_toggleintr
c_func
(paren
id|pTimer
comma
id|WD_INTR_OFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wd_dev.isbaddoggie
)paren
(brace
id|pTimer-&gt;runstatus
op_or_assign
id|WD_STAT_BSTOP
suffix:semicolon
id|wd_brokentimer
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|wd_dev
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Start a watchdog timer with the specified limit value&n; * If the watchdog is running, it will be restarted with&n; * the provided limit value.&n; *&n; * This function will enable interrupts on the specified&n; * watchdog.&n; *&n; * pTimer&t;- pointer to timer device&n; * limit&t;- limit (countdown) value in 1/10th seconds&n; */
DECL|function|wd_starttimer
r_static
r_void
id|wd_starttimer
c_func
(paren
r_struct
id|wd_timer
op_star
id|pTimer
)paren
(brace
r_if
c_cond
(paren
id|wd_dev.isbaddoggie
)paren
(brace
id|pTimer-&gt;runstatus
op_and_assign
op_complement
id|WD_STAT_BSTOP
suffix:semicolon
)brace
id|pTimer-&gt;runstatus
op_and_assign
op_complement
id|WD_STAT_SVCD
suffix:semicolon
id|wd_writew
c_func
(paren
id|pTimer-&gt;timeout
comma
op_amp
id|pTimer-&gt;regs-&gt;limit
)paren
suffix:semicolon
id|wd_toggleintr
c_func
(paren
id|pTimer
comma
id|WD_INTR_ON
)paren
suffix:semicolon
)brace
multiline_comment|/* Restarts timer with maximum limit value and&n; * does not unset &squot;brokenstop&squot; value.&n; */
DECL|function|wd_resetbrokentimer
r_static
r_void
id|wd_resetbrokentimer
c_func
(paren
r_struct
id|wd_timer
op_star
id|pTimer
)paren
(brace
id|wd_toggleintr
c_func
(paren
id|pTimer
comma
id|WD_INTR_ON
)paren
suffix:semicolon
id|wd_writew
c_func
(paren
id|WD_BLIMIT
comma
op_amp
id|pTimer-&gt;regs-&gt;limit
)paren
suffix:semicolon
)brace
multiline_comment|/* Timer device initialization helper.&n; * Returns 0 on success, other on failure&n; */
DECL|function|wd_inittimer
r_static
r_int
id|wd_inittimer
c_func
(paren
r_int
id|whichdog
)paren
(brace
r_struct
id|miscdevice
op_star
id|whichmisc
suffix:semicolon
r_volatile
r_struct
id|wd_timer_regblk
op_star
id|whichregs
suffix:semicolon
r_char
id|whichident
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|whichmask
suffix:semicolon
id|__u16
id|whichlimit
suffix:semicolon
r_switch
c_cond
(paren
id|whichdog
)paren
(brace
r_case
id|WD0_ID
suffix:colon
id|whichmisc
op_assign
op_amp
id|wd0_miscdev
suffix:semicolon
id|strcpy
c_func
(paren
id|whichident
comma
l_string|&quot;RIC&quot;
)paren
suffix:semicolon
id|whichregs
op_assign
op_amp
id|wd_dev.regs-&gt;wd0_regs
suffix:semicolon
id|whichmask
op_assign
id|WD0_INTR_MASK
suffix:semicolon
id|whichlimit
op_assign
(paren
l_int|0
op_eq
id|wd0_timeout
)paren
ques
c_cond
(paren
id|wd_dev.opt_timeout
)paren
suffix:colon
(paren
id|wd0_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WD1_ID
suffix:colon
id|whichmisc
op_assign
op_amp
id|wd1_miscdev
suffix:semicolon
id|strcpy
c_func
(paren
id|whichident
comma
l_string|&quot;XIR&quot;
)paren
suffix:semicolon
id|whichregs
op_assign
op_amp
id|wd_dev.regs-&gt;wd1_regs
suffix:semicolon
id|whichmask
op_assign
id|WD1_INTR_MASK
suffix:semicolon
id|whichlimit
op_assign
(paren
l_int|0
op_eq
id|wd1_timeout
)paren
ques
c_cond
(paren
id|wd_dev.opt_timeout
)paren
suffix:colon
(paren
id|wd1_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WD2_ID
suffix:colon
id|whichmisc
op_assign
op_amp
id|wd2_miscdev
suffix:semicolon
id|strcpy
c_func
(paren
id|whichident
comma
l_string|&quot;POR&quot;
)paren
suffix:semicolon
id|whichregs
op_assign
op_amp
id|wd_dev.regs-&gt;wd2_regs
suffix:semicolon
id|whichmask
op_assign
id|WD2_INTR_MASK
suffix:semicolon
id|whichlimit
op_assign
(paren
l_int|0
op_eq
id|wd2_timeout
)paren
ques
c_cond
(paren
id|wd_dev.opt_timeout
)paren
suffix:colon
(paren
id|wd2_timeout
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: %s: invalid watchdog id: %i&bslash;n&quot;
comma
id|WD_OBPNAME
comma
id|__FUNCTION__
comma
id|whichdog
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|0
op_ne
id|misc_register
c_func
(paren
id|whichmisc
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|wd_dev.watchdog
(braket
id|whichdog
)braket
dot
id|regs
op_assign
id|whichregs
suffix:semicolon
id|wd_dev.watchdog
(braket
id|whichdog
)braket
dot
id|timeout
op_assign
id|whichlimit
suffix:semicolon
id|wd_dev.watchdog
(braket
id|whichdog
)braket
dot
id|intr_mask
op_assign
id|whichmask
suffix:semicolon
id|wd_dev.watchdog
(braket
id|whichdog
)braket
dot
id|runstatus
op_and_assign
op_complement
id|WD_STAT_BSTOP
suffix:semicolon
id|wd_dev.watchdog
(braket
id|whichdog
)braket
dot
id|runstatus
op_or_assign
id|WD_STAT_INIT
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s%i: %s hardware watchdog [%01i.%i sec] %s&bslash;n&quot;
comma
id|WD_OBPNAME
comma
id|whichdog
comma
id|whichident
comma
id|wd_dev.watchdog
(braket
id|whichdog
)braket
dot
id|timeout
op_div
l_int|10
comma
id|wd_dev.watchdog
(braket
id|whichdog
)braket
dot
id|timeout
op_mod
l_int|10
comma
(paren
l_int|0
op_ne
id|wd_dev.opt_enable
)paren
ques
c_cond
l_string|&quot;in ENABLED mode&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Timer method called to reset stopped watchdogs--&n; * because of the PLD bug on CP1400, we cannot mask&n; * interrupts within the PLD so me must continually&n; * reset the timers ad infinitum.&n; */
DECL|function|wd_brokentimer
r_static
r_void
id|wd_brokentimer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|wd_device
op_star
id|pDev
op_assign
(paren
r_struct
id|wd_device
op_star
)paren
id|data
suffix:semicolon
r_int
id|id
comma
id|tripped
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* kill a running timer instance, in case we&n;&t; * were called directly instead of by kernel timer&n;&t; */
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|wd_timer
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|wd_timer
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|id
op_assign
id|WD0_ID
suffix:semicolon
id|id
OL
id|WD_NUMDEVS
suffix:semicolon
op_increment
id|id
)paren
(brace
r_if
c_cond
(paren
id|pDev-&gt;watchdog
(braket
id|id
)braket
dot
id|runstatus
op_amp
id|WD_STAT_BSTOP
)paren
(brace
op_increment
id|tripped
suffix:semicolon
id|wd_resetbrokentimer
c_func
(paren
op_amp
id|pDev-&gt;watchdog
(braket
id|id
)braket
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tripped
)paren
(brace
multiline_comment|/* there is at least one timer brokenstopped-- reschedule */
id|wd_timer.expires
op_assign
id|WD_BTIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|wd_timer
)paren
suffix:semicolon
)brace
)brace
DECL|function|wd_getstatus
r_static
r_int
id|wd_getstatus
c_func
(paren
r_struct
id|wd_timer
op_star
id|pTimer
)paren
(brace
r_int
r_char
id|stat
op_assign
id|wd_readb
c_func
(paren
op_amp
id|pTimer-&gt;regs-&gt;status
)paren
suffix:semicolon
r_int
r_char
id|intr
op_assign
id|wd_readb
c_func
(paren
op_amp
id|wd_dev.regs-&gt;pld_regs.intr_mask
)paren
suffix:semicolon
r_int
r_char
id|ret
op_assign
id|WD_STOPPED
suffix:semicolon
multiline_comment|/* determine STOPPED */
r_if
c_cond
(paren
l_int|0
op_eq
id|stat
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* determine EXPIRED vs FREERUN vs RUNNING */
r_else
r_if
c_cond
(paren
id|WD_S_EXPIRED
op_amp
id|stat
)paren
(brace
id|ret
op_assign
id|WD_EXPIRED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|WD_S_RUNNING
op_amp
id|stat
)paren
(brace
r_if
c_cond
(paren
id|intr
op_amp
id|pTimer-&gt;intr_mask
)paren
(brace
id|ret
op_assign
id|WD_FREERUN
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Fudge WD_EXPIRED status for defective CP1400--&n;&t;&t;&t; * IF timer is running &n;&t;&t;&t; * &t;AND brokenstop is set &n;&t;&t;&t; * &t;AND an interrupt has been serviced&n;&t;&t;&t; * we are WD_EXPIRED.&n;&t;&t;&t; *&n;&t;&t;&t; * IF timer is running &n;&t;&t;&t; * &t;AND brokenstop is set &n;&t;&t;&t; * &t;AND no interrupt has been serviced&n;&t;&t;&t; * we are WD_FREERUN.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|wd_dev.isbaddoggie
op_logical_and
(paren
id|pTimer-&gt;runstatus
op_amp
id|WD_STAT_BSTOP
)paren
)paren
(brace
r_if
c_cond
(paren
id|pTimer-&gt;runstatus
op_amp
id|WD_STAT_SVCD
)paren
(brace
id|ret
op_assign
id|WD_EXPIRED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we could as well pretend we are expired */
id|ret
op_assign
id|WD_FREERUN
suffix:semicolon
)brace
)brace
r_else
(brace
id|ret
op_assign
id|WD_RUNNING
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* determine SERVICED */
r_if
c_cond
(paren
id|pTimer-&gt;runstatus
op_amp
id|WD_STAT_SVCD
)paren
(brace
id|ret
op_or_assign
id|WD_SERVICED
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|wd_init
r_static
r_int
id|__init
id|wd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|id
suffix:semicolon
r_struct
id|linux_ebus
op_star
id|ebus
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|linux_ebus_device
op_star
id|edev
op_assign
l_int|NULL
suffix:semicolon
id|for_each_ebus
c_func
(paren
id|ebus
)paren
(brace
id|for_each_ebusdev
c_func
(paren
id|edev
comma
id|ebus
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|edev-&gt;prom_name
comma
id|WD_OBPNAME
)paren
)paren
r_goto
id|ebus_done
suffix:semicolon
)brace
)brace
id|ebus_done
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|edev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to locate device&bslash;n&quot;
comma
id|WD_OBPNAME
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|wd_dev.regs
op_assign
id|ioremap
c_func
(paren
id|edev-&gt;resource
(braket
l_int|0
)braket
dot
id|start
comma
r_sizeof
(paren
r_struct
id|wd_regblk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|wd_dev.regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to map registers&bslash;n&quot;
comma
id|WD_OBPNAME
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* initialize device structure from OBP parameters */
id|wd_dev.irq
op_assign
id|edev-&gt;irqs
(braket
l_int|0
)braket
suffix:semicolon
id|wd_dev.opt_enable
op_assign
id|wd_opt_enable
c_func
(paren
)paren
suffix:semicolon
id|wd_dev.opt_reboot
op_assign
id|wd_opt_reboot
c_func
(paren
)paren
suffix:semicolon
id|wd_dev.opt_timeout
op_assign
id|wd_opt_timeout
c_func
(paren
)paren
suffix:semicolon
id|wd_dev.isbaddoggie
op_assign
id|wd_isbroken
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* disable all interrupts unless watchdog-enabled? == true */
r_if
c_cond
(paren
op_logical_neg
id|wd_dev.opt_enable
)paren
(brace
id|wd_toggleintr
c_func
(paren
l_int|NULL
comma
id|WD_INTR_OFF
)paren
suffix:semicolon
)brace
multiline_comment|/* register miscellaneous devices */
r_for
c_loop
(paren
id|id
op_assign
id|WD0_ID
suffix:semicolon
id|id
OL
id|WD_NUMDEVS
suffix:semicolon
op_increment
id|id
)paren
(brace
r_if
c_cond
(paren
l_int|0
op_ne
id|wd_inittimer
c_func
(paren
id|id
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s%i: unable to initialize&bslash;n&quot;
comma
id|WD_OBPNAME
comma
id|id
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* warn about possible defective PLD */
r_if
c_cond
(paren
id|wd_dev.isbaddoggie
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|wd_timer
)paren
suffix:semicolon
id|wd_timer.function
op_assign
id|wd_brokentimer
suffix:semicolon
id|wd_timer.data
op_assign
(paren
r_int
r_int
)paren
op_amp
id|wd_dev
suffix:semicolon
id|wd_timer.expires
op_assign
id|WD_BTIMEOUT
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: PLD defect workaround enabled for model %s&bslash;n&quot;
comma
id|WD_OBPNAME
comma
id|WD_BADMODEL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wd_cleanup
r_static
r_void
id|__exit
id|wd_cleanup
c_func
(paren
r_void
)paren
(brace
r_int
id|id
suffix:semicolon
multiline_comment|/* if &squot;watchdog-enable?&squot; == TRUE, timers are not stopped &n;&t; * when module is unloaded.  All brokenstopped timers will&n;&t; * also now eventually trip. &n;&t; */
r_for
c_loop
(paren
id|id
op_assign
id|WD0_ID
suffix:semicolon
id|id
OL
id|WD_NUMDEVS
suffix:semicolon
op_increment
id|id
)paren
(brace
r_if
c_cond
(paren
id|WD_S_RUNNING
op_eq
id|wd_readb
c_func
(paren
op_amp
id|wd_dev.watchdog
(braket
id|id
)braket
dot
id|regs-&gt;status
)paren
)paren
(brace
r_if
c_cond
(paren
id|wd_dev.opt_enable
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s%i: timer not stopped at release&bslash;n&quot;
comma
id|WD_OBPNAME
comma
id|id
)paren
suffix:semicolon
)brace
r_else
(brace
id|wd_stoptimer
c_func
(paren
op_amp
id|wd_dev.watchdog
(braket
id|id
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wd_dev.watchdog
(braket
id|id
)braket
dot
id|runstatus
op_amp
id|WD_STAT_BSTOP
)paren
(brace
id|wd_resetbrokentimer
c_func
(paren
op_amp
id|wd_dev.watchdog
(braket
id|id
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s%i: defect workaround disabled at release, &quot;
"&bslash;"
l_string|&quot;timer expires in ~%01i sec&bslash;n&quot;
comma
id|WD_OBPNAME
comma
id|id
comma
id|wd_readw
c_func
(paren
op_amp
id|wd_dev.watchdog
(braket
id|id
)braket
dot
id|regs-&gt;limit
)paren
op_div
l_int|10
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|wd_dev.isbaddoggie
op_logical_and
id|timer_pending
c_func
(paren
op_amp
id|wd_timer
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|wd_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|0
op_ne
(paren
id|wd_dev.watchdog
(braket
id|WD0_ID
)braket
dot
id|runstatus
op_amp
id|WD_STAT_INIT
)paren
)paren
(brace
id|misc_deregister
c_func
(paren
op_amp
id|wd0_miscdev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|0
op_ne
(paren
id|wd_dev.watchdog
(braket
id|WD1_ID
)braket
dot
id|runstatus
op_amp
id|WD_STAT_INIT
)paren
)paren
(brace
id|misc_deregister
c_func
(paren
op_amp
id|wd1_miscdev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|0
op_ne
(paren
id|wd_dev.watchdog
(braket
id|WD2_ID
)braket
dot
id|runstatus
op_amp
id|WD_STAT_INIT
)paren
)paren
(brace
id|misc_deregister
c_func
(paren
op_amp
id|wd2_miscdev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|0
op_ne
id|wd_dev.initialized
)paren
(brace
id|free_irq
c_func
(paren
id|wd_dev.irq
comma
(paren
r_void
op_star
)paren
id|wd_dev.regs
)paren
suffix:semicolon
)brace
id|iounmap
c_func
(paren
id|wd_dev.regs
)paren
suffix:semicolon
)brace
DECL|variable|wd_init
id|module_init
c_func
(paren
id|wd_init
)paren
suffix:semicolon
DECL|variable|wd_cleanup
id|module_exit
c_func
(paren
id|wd_cleanup
)paren
suffix:semicolon
eof
