multiline_comment|/*&n; * Interrupt management for most GSC and related devices.&n; *&n; * (c) Copyright 1999 Alex deVries for The Puffin Group&n; * (c) Copyright 1999 Grant Grundler for Hewlett-Packard&n; * (c) Copyright 1999 Matthew Wilcox&n; * (c) Copyright 2000 Helge Deller&n; * (c) Copyright 2001 Matthew Wilcox for Hewlett-Packard&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *      the Free Software Foundation; either version 2 of the License, or&n; *      (at your option) any later version.&n; */
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;gsc.h&quot;
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#ifdef DEBUG
DECL|macro|DEBPRINTK
mdefine_line|#define DEBPRINTK printk
macro_line|#else
DECL|macro|DEBPRINTK
mdefine_line|#define DEBPRINTK(x,...)
macro_line|#endif
DECL|function|gsc_alloc_irq
r_int
id|gsc_alloc_irq
c_func
(paren
r_struct
id|gsc_irq
op_star
id|i
)paren
(brace
r_int
id|irq
op_assign
id|txn_alloc_irq
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot get irq&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
id|i-&gt;txn_addr
op_assign
id|txn_alloc_addr
c_func
(paren
id|irq
)paren
suffix:semicolon
id|i-&gt;txn_data
op_assign
id|txn_alloc_data
c_func
(paren
id|irq
comma
id|GSC_EIM_WIDTH
)paren
suffix:semicolon
id|i-&gt;irq
op_assign
id|irq
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
DECL|function|gsc_claim_irq
r_int
id|gsc_claim_irq
c_func
(paren
r_struct
id|gsc_irq
op_star
id|i
comma
r_int
id|irq
)paren
(brace
r_int
id|c
op_assign
id|irq
suffix:semicolon
id|irq
op_add_assign
id|IRQ_FROM_REGION
c_func
(paren
id|CPU_IRQ_REGION
)paren
suffix:semicolon
multiline_comment|/* virtualize the IRQ first */
id|irq
op_assign
id|txn_claim_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot claim irq %d&bslash;n&quot;
comma
id|c
)paren
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
id|i-&gt;txn_addr
op_assign
id|txn_alloc_addr
c_func
(paren
id|irq
)paren
suffix:semicolon
id|i-&gt;txn_data
op_assign
id|txn_alloc_data
c_func
(paren
id|irq
comma
id|GSC_EIM_WIDTH
)paren
suffix:semicolon
id|i-&gt;irq
op_assign
id|irq
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
DECL|variable|gsc_alloc_irq
id|EXPORT_SYMBOL
c_func
(paren
id|gsc_alloc_irq
)paren
suffix:semicolon
DECL|variable|gsc_claim_irq
id|EXPORT_SYMBOL
c_func
(paren
id|gsc_claim_irq
)paren
suffix:semicolon
multiline_comment|/* IRQ bits must be numbered from Most Significant Bit */
DECL|macro|GSC_FIX_IRQ
mdefine_line|#define GSC_FIX_IRQ(x)&t;(31-(x))
DECL|macro|GSC_MASK_IRQ
mdefine_line|#define GSC_MASK_IRQ(x)&t;(1&lt;&lt;(GSC_FIX_IRQ(x)))
multiline_comment|/* Common interrupt demultiplexer used by Asp, Lasi &amp; Wax.  */
DECL|function|busdev_barked
r_void
id|busdev_barked
c_func
(paren
r_int
id|busdev_irq
comma
r_void
op_star
id|dev
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|irq
suffix:semicolon
r_struct
id|busdevice
op_star
id|busdev
op_assign
(paren
r_struct
id|busdevice
op_star
)paren
id|dev
suffix:semicolon
multiline_comment|/* &n;&t;    Don&squot;t need to protect OFFSET_IRR with spinlock since this is&n;&t;    the only place it&squot;s touched.&n;&t;    Protect busdev_region by disabling this region&squot;s interrupts,&n;&t;    modifying the region, and then re-enabling the region.&n;&t;*/
id|irq
op_assign
id|gsc_readl
c_func
(paren
id|busdev-&gt;hpa
op_plus
id|OFFSET_IRR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: barking without apparent reason.&bslash;n&quot;
comma
id|busdev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBPRINTK
(paren
l_string|&quot;%s (0x%x) barked, mask=0x%x, irq=%d&bslash;n&quot;
comma
id|busdev-&gt;name
comma
id|busdev-&gt;busdev_region-&gt;data.irqbase
comma
id|irq
comma
id|GSC_FIX_IRQ
c_func
(paren
id|ffs
c_func
(paren
id|irq
)paren
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|do_irq_mask
c_func
(paren
id|irq
comma
id|busdev-&gt;busdev_region
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|busdev_disable_irq
id|busdev_disable_irq
c_func
(paren
r_void
op_star
id|irq_dev
comma
r_int
id|irq
)paren
(brace
multiline_comment|/* Disable the IRQ line by clearing the bit in the IMR */
id|u32
id|imr
op_assign
id|gsc_readl
c_func
(paren
id|BUSDEV_DEV
c_func
(paren
id|irq_dev
)paren
op_member_access_from_pointer
id|hpa
op_plus
id|OFFSET_IMR
)paren
suffix:semicolon
id|imr
op_and_assign
op_complement
(paren
id|GSC_MASK_IRQ
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
id|DEBPRINTK
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(%p, %d) %s: IMR 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq_dev
comma
id|irq
comma
id|BUSDEV_DEV
c_func
(paren
id|irq_dev
)paren
op_member_access_from_pointer
id|name
comma
id|imr
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
id|imr
comma
id|BUSDEV_DEV
c_func
(paren
id|irq_dev
)paren
op_member_access_from_pointer
id|hpa
op_plus
id|OFFSET_IMR
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|busdev_enable_irq
id|busdev_enable_irq
c_func
(paren
r_void
op_star
id|irq_dev
comma
r_int
id|irq
)paren
(brace
multiline_comment|/* Enable the IRQ line by setting the bit in the IMR */
r_int
r_int
id|addr
op_assign
id|BUSDEV_DEV
c_func
(paren
id|irq_dev
)paren
op_member_access_from_pointer
id|hpa
op_plus
id|OFFSET_IMR
suffix:semicolon
id|u32
id|imr
op_assign
id|gsc_readl
c_func
(paren
id|addr
)paren
suffix:semicolon
id|imr
op_or_assign
id|GSC_MASK_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|DEBPRINTK
(paren
id|KERN_WARNING
l_string|&quot;%s(%p, %d) %s: IMR 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq_dev
comma
id|irq
comma
id|BUSDEV_DEV
c_func
(paren
id|irq_dev
)paren
op_member_access_from_pointer
id|name
comma
id|imr
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
id|imr
comma
id|addr
)paren
suffix:semicolon
singleline_comment|//&t;gsc_writel(~0L, addr);
multiline_comment|/* FIXME: read IPR to make sure the IRQ isn&squot;t already pending.&n;**   If so, we need to read IRR and manually call do_irq_mask().&n;**   This code should be shared with busdev_unmask_irq().&n;*/
)brace
r_static
r_void
DECL|function|busdev_mask_irq
id|busdev_mask_irq
c_func
(paren
r_void
op_star
id|irq_dev
comma
r_int
id|irq
)paren
(brace
multiline_comment|/* FIXME: Clear the IMR bit in busdev for that IRQ */
)brace
r_static
r_void
DECL|function|busdev_unmask_irq
id|busdev_unmask_irq
c_func
(paren
r_void
op_star
id|irq_dev
comma
r_int
id|irq
)paren
(brace
multiline_comment|/* FIXME: Read IPR. Set the IMR bit in busdev for that IRQ.&n;   call do_irq_mask() if IPR is non-zero&n;*/
)brace
DECL|variable|busdev_irq_ops
r_struct
id|irq_region_ops
id|busdev_irq_ops
op_assign
(brace
id|disable_irq
suffix:colon
id|busdev_disable_irq
comma
id|enable_irq
suffix:colon
id|busdev_enable_irq
comma
id|mask_irq
suffix:colon
id|busdev_mask_irq
comma
id|unmask_irq
suffix:colon
id|busdev_unmask_irq
)brace
suffix:semicolon
DECL|function|gsc_common_irqsetup
r_int
id|gsc_common_irqsetup
c_func
(paren
r_struct
id|parisc_device
op_star
id|parent
comma
r_struct
id|busdevice
op_star
id|busdev
)paren
(brace
r_struct
id|resource
op_star
id|res
suffix:semicolon
id|busdev-&gt;gsc
op_assign
id|parent
suffix:semicolon
multiline_comment|/* the IRQs we simulate */
id|busdev-&gt;busdev_region
op_assign
id|alloc_irq_region
c_func
(paren
l_int|32
comma
op_amp
id|busdev_irq_ops
comma
id|busdev-&gt;name
comma
id|busdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|busdev-&gt;busdev_region
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* allocate resource region */
id|res
op_assign
id|request_mem_region
c_func
(paren
id|busdev-&gt;hpa
comma
l_int|0x100000
comma
id|busdev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
multiline_comment|/* do not mark it busy ! */
)brace
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s IRQ %d EIM 0x%x&quot;
comma
id|busdev-&gt;name
comma
id|busdev-&gt;parent_irq
comma
id|busdev-&gt;eim
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gsc_readl
c_func
(paren
id|busdev-&gt;hpa
op_plus
id|OFFSET_IMR
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;  IMR is non-zero! (0x%x)&quot;
comma
id|gsc_readl
c_func
(paren
id|busdev-&gt;hpa
op_plus
id|OFFSET_IMR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_extern
r_struct
id|parisc_driver
id|lasi_driver
suffix:semicolon
r_extern
r_struct
id|parisc_driver
id|asp_driver
suffix:semicolon
r_extern
r_struct
id|parisc_driver
id|wax_driver
suffix:semicolon
DECL|function|gsc_init
r_void
id|__init
id|gsc_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_GSC_LASI
id|register_parisc_driver
c_func
(paren
op_amp
id|lasi_driver
)paren
suffix:semicolon
id|register_parisc_driver
c_func
(paren
op_amp
id|asp_driver
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_GSC_WAX
id|register_parisc_driver
c_func
(paren
op_amp
id|wax_driver
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
