multiline_comment|/*&n; * Interrupt management for most GSC and related devices.&n; *&n; * (c) Copyright 1999 Alex deVries for The Puffin Group&n; * (c) Copyright 1999 Grant Grundler for Hewlett-Packard&n; * (c) Copyright 1999 Matthew Wilcox&n; * (c) Copyright 2000 Helge Deller&n; * (c) Copyright 2001 Matthew Wilcox for Hewlett-Packard&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *      the Free Software Foundation; either version 2 of the License, or&n; *      (at your option) any later version.&n; */
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;gsc.h&quot;
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#ifdef DEBUG
DECL|macro|DEBPRINTK
mdefine_line|#define DEBPRINTK printk
macro_line|#else
DECL|macro|DEBPRINTK
mdefine_line|#define DEBPRINTK(x,...)
macro_line|#endif
DECL|function|gsc_alloc_irq
r_int
id|gsc_alloc_irq
c_func
(paren
r_struct
id|gsc_irq
op_star
id|i
)paren
(brace
r_int
id|irq
op_assign
id|txn_alloc_irq
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot get irq&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
id|i-&gt;txn_addr
op_assign
id|txn_alloc_addr
c_func
(paren
id|irq
)paren
suffix:semicolon
id|i-&gt;txn_data
op_assign
id|txn_alloc_data
c_func
(paren
id|irq
comma
id|GSC_EIM_WIDTH
)paren
suffix:semicolon
id|i-&gt;irq
op_assign
id|irq
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
DECL|function|gsc_claim_irq
r_int
id|gsc_claim_irq
c_func
(paren
r_struct
id|gsc_irq
op_star
id|i
comma
r_int
id|irq
)paren
(brace
r_int
id|c
op_assign
id|irq
suffix:semicolon
id|irq
op_add_assign
id|CPU_IRQ_BASE
suffix:semicolon
multiline_comment|/* virtualize the IRQ first */
id|irq
op_assign
id|txn_claim_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot claim irq %d&bslash;n&quot;
comma
id|c
)paren
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
id|i-&gt;txn_addr
op_assign
id|txn_alloc_addr
c_func
(paren
id|irq
)paren
suffix:semicolon
id|i-&gt;txn_data
op_assign
id|txn_alloc_data
c_func
(paren
id|irq
comma
id|GSC_EIM_WIDTH
)paren
suffix:semicolon
id|i-&gt;irq
op_assign
id|irq
suffix:semicolon
r_return
id|irq
suffix:semicolon
)brace
DECL|variable|gsc_alloc_irq
id|EXPORT_SYMBOL
c_func
(paren
id|gsc_alloc_irq
)paren
suffix:semicolon
DECL|variable|gsc_claim_irq
id|EXPORT_SYMBOL
c_func
(paren
id|gsc_claim_irq
)paren
suffix:semicolon
multiline_comment|/* Common interrupt demultiplexer used by Asp, Lasi &amp; Wax.  */
DECL|function|gsc_asic_intr
id|irqreturn_t
id|gsc_asic_intr
c_func
(paren
r_int
id|gsc_asic_irq
comma
r_void
op_star
id|dev
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|irr
suffix:semicolon
r_struct
id|gsc_asic
op_star
id|gsc_asic
op_assign
id|dev
suffix:semicolon
id|irr
op_assign
id|gsc_readl
c_func
(paren
id|gsc_asic-&gt;hpa
op_plus
id|OFFSET_IRR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irr
op_eq
l_int|0
)paren
r_return
id|IRQ_NONE
suffix:semicolon
id|DEBPRINTK
c_func
(paren
l_string|&quot;%s intr, mask=0x%x&bslash;n&quot;
comma
id|gsc_asic-&gt;name
comma
id|irr
)paren
suffix:semicolon
r_do
(brace
r_int
id|local_irq
op_assign
id|__ffs
c_func
(paren
id|irr
)paren
suffix:semicolon
r_int
r_int
id|irq
op_assign
id|gsc_asic-&gt;global_irq
(braket
id|local_irq
)braket
suffix:semicolon
id|__do_IRQ
c_func
(paren
id|irq
comma
id|regs
)paren
suffix:semicolon
id|irr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|local_irq
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|irr
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|function|gsc_find_local_irq
r_int
id|gsc_find_local_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_int
op_star
id|global_irqs
comma
r_int
id|limit
)paren
(brace
r_int
id|local_irq
suffix:semicolon
r_for
c_loop
(paren
id|local_irq
op_assign
l_int|0
suffix:semicolon
id|local_irq
OL
id|limit
suffix:semicolon
id|local_irq
op_increment
)paren
(brace
r_if
c_cond
(paren
id|global_irqs
(braket
id|local_irq
)braket
op_eq
id|irq
)paren
r_return
id|local_irq
suffix:semicolon
)brace
r_return
id|NO_IRQ
suffix:semicolon
)brace
DECL|function|gsc_asic_disable_irq
r_static
r_void
id|gsc_asic_disable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|gsc_asic
op_star
id|irq_dev
op_assign
id|irq_desc
(braket
id|irq
)braket
dot
id|handler_data
suffix:semicolon
r_int
id|local_irq
op_assign
id|gsc_find_local_irq
c_func
(paren
id|irq
comma
id|irq_dev-&gt;global_irq
comma
l_int|32
)paren
suffix:semicolon
id|u32
id|imr
suffix:semicolon
id|DEBPRINTK
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s(%d) %s: IMR 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
comma
id|irq_dev-&gt;name
comma
id|imr
)paren
suffix:semicolon
multiline_comment|/* Disable the IRQ line by clearing the bit in the IMR */
id|imr
op_assign
id|gsc_readl
c_func
(paren
id|irq_dev-&gt;hpa
op_plus
id|OFFSET_IMR
)paren
suffix:semicolon
id|imr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|local_irq
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
id|imr
comma
id|irq_dev-&gt;hpa
op_plus
id|OFFSET_IMR
)paren
suffix:semicolon
)brace
DECL|function|gsc_asic_enable_irq
r_static
r_void
id|gsc_asic_enable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|gsc_asic
op_star
id|irq_dev
op_assign
id|irq_desc
(braket
id|irq
)braket
dot
id|handler_data
suffix:semicolon
r_int
id|local_irq
op_assign
id|gsc_find_local_irq
c_func
(paren
id|irq
comma
id|irq_dev-&gt;global_irq
comma
l_int|32
)paren
suffix:semicolon
id|u32
id|imr
suffix:semicolon
id|DEBPRINTK
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s(%d) %s: IMR 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
comma
id|irq_dev-&gt;name
comma
id|imr
)paren
suffix:semicolon
multiline_comment|/* Enable the IRQ line by setting the bit in the IMR */
id|imr
op_assign
id|gsc_readl
c_func
(paren
id|irq_dev-&gt;hpa
op_plus
id|OFFSET_IMR
)paren
suffix:semicolon
id|imr
op_or_assign
l_int|1
op_lshift
id|local_irq
suffix:semicolon
id|gsc_writel
c_func
(paren
id|imr
comma
id|irq_dev-&gt;hpa
op_plus
id|OFFSET_IMR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: read IPR to make sure the IRQ isn&squot;t already pending.&n;&t; *   If so, we need to read IRR and manually call do_irq().&n;&t; */
)brace
DECL|function|gsc_asic_startup_irq
r_static
r_int
r_int
id|gsc_asic_startup_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|gsc_asic_enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|gsc_asic_interrupt_type
r_static
r_struct
id|hw_interrupt_type
id|gsc_asic_interrupt_type
op_assign
(brace
dot
r_typename
op_assign
l_string|&quot;GSC-ASIC&quot;
comma
dot
id|startup
op_assign
id|gsc_asic_startup_irq
comma
dot
id|shutdown
op_assign
id|gsc_asic_disable_irq
comma
dot
id|enable
op_assign
id|gsc_asic_enable_irq
comma
dot
id|disable
op_assign
id|gsc_asic_disable_irq
comma
dot
id|ack
op_assign
id|no_ack_irq
comma
dot
id|end
op_assign
id|no_end_irq
comma
)brace
suffix:semicolon
DECL|function|gsc_assign_irq
r_int
id|gsc_assign_irq
c_func
(paren
r_struct
id|hw_interrupt_type
op_star
id|type
comma
r_void
op_star
id|data
)paren
(brace
r_static
r_int
id|irq
op_assign
id|GSC_IRQ_BASE
suffix:semicolon
r_if
c_cond
(paren
id|irq
OG
id|GSC_IRQ_MAX
)paren
r_return
id|NO_IRQ
suffix:semicolon
id|irq_desc
(braket
id|irq
)braket
dot
id|handler
op_assign
id|type
suffix:semicolon
id|irq_desc
(braket
id|irq
)braket
dot
id|handler_data
op_assign
id|data
suffix:semicolon
r_return
id|irq
op_increment
suffix:semicolon
)brace
DECL|function|gsc_asic_assign_irq
r_void
id|gsc_asic_assign_irq
c_func
(paren
r_struct
id|gsc_asic
op_star
id|asic
comma
r_int
id|local_irq
comma
r_int
op_star
id|irqp
)paren
(brace
r_int
id|irq
op_assign
id|gsc_assign_irq
c_func
(paren
op_amp
id|gsc_asic_interrupt_type
comma
id|asic
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
id|NO_IRQ
)paren
r_return
suffix:semicolon
op_star
id|irqp
op_assign
id|irq
suffix:semicolon
id|asic-&gt;global_irq
(braket
id|local_irq
)braket
op_assign
id|irq
suffix:semicolon
)brace
DECL|function|gsc_fixup_irqs
r_void
id|gsc_fixup_irqs
c_func
(paren
r_struct
id|parisc_device
op_star
id|parent
comma
r_void
op_star
id|ctrl
comma
r_void
(paren
op_star
id|choose_irq
)paren
(paren
r_struct
id|parisc_device
op_star
comma
r_void
op_star
)paren
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|dev
comma
op_amp
id|parent-&gt;dev.children
comma
id|node
)paren
(brace
r_struct
id|parisc_device
op_star
id|padev
op_assign
id|to_parisc_device
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* work-around for 715/64 and others which have parent &n;&t;&t;   at path [5] and children at path [5/0/x] */
r_if
c_cond
(paren
id|padev-&gt;id.hw_type
op_eq
id|HPHW_FAULTY
)paren
r_return
id|gsc_fixup_irqs
c_func
(paren
id|padev
comma
id|ctrl
comma
id|choose_irq
)paren
suffix:semicolon
id|choose_irq
c_func
(paren
id|padev
comma
id|ctrl
)paren
suffix:semicolon
)brace
)brace
DECL|function|gsc_common_setup
r_int
id|gsc_common_setup
c_func
(paren
r_struct
id|parisc_device
op_star
id|parent
comma
r_struct
id|gsc_asic
op_star
id|gsc_asic
)paren
(brace
r_struct
id|resource
op_star
id|res
suffix:semicolon
id|gsc_asic-&gt;gsc
op_assign
id|parent
suffix:semicolon
multiline_comment|/* allocate resource region */
id|res
op_assign
id|request_mem_region
c_func
(paren
id|gsc_asic-&gt;hpa
comma
l_int|0x100000
comma
id|gsc_asic-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
multiline_comment|/* do not mark it busy ! */
)brace
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s IRQ %d EIM 0x%x&quot;
comma
id|gsc_asic-&gt;name
comma
id|parent-&gt;irq
comma
id|gsc_asic-&gt;eim
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gsc_readl
c_func
(paren
id|gsc_asic-&gt;hpa
op_plus
id|OFFSET_IMR
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;  IMR is non-zero! (0x%x)&quot;
comma
id|gsc_readl
c_func
(paren
id|gsc_asic-&gt;hpa
op_plus
id|OFFSET_IMR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_extern
r_struct
id|parisc_driver
id|lasi_driver
suffix:semicolon
r_extern
r_struct
id|parisc_driver
id|asp_driver
suffix:semicolon
r_extern
r_struct
id|parisc_driver
id|wax_driver
suffix:semicolon
DECL|function|gsc_init
r_void
id|__init
id|gsc_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_GSC_LASI
id|register_parisc_driver
c_func
(paren
op_amp
id|lasi_driver
)paren
suffix:semicolon
id|register_parisc_driver
c_func
(paren
op_amp
id|asp_driver
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_GSC_WAX
id|register_parisc_driver
c_func
(paren
op_amp
id|wax_driver
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
