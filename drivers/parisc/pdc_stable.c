multiline_comment|/* &n; *    Interfaces to retrieve and set PDC Stable options (firmware)&n; *&n; *    Copyright (C) 2005 Thibaut VARENE &lt;varenet@parisc-linux.org&gt;&n; *&n; *    This program is free software; you can redistribute it and/or modify&n; *    it under the terms of the GNU General Public License as published by&n; *    the Free Software Foundation; either version 2 of the License, or&n; *    (at your option) any later version.&n; *&n; *    This program is distributed in the hope that it will be useful,&n; *    but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *    GNU General Public License for more details.&n; *&n; *    You should have received a copy of the GNU General Public License&n; *    along with this program; if not, write to the Free Software&n; *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; *&n; *    DEV NOTE: the PDC Procedures reference states that:&n; *    &quot;A minimum of 96 bytes of Stable Storage is required. Providing more than&n; *    96 bytes of Stable Storage is optional [...]. Failure to provide the&n; *    optional locations from 96 to 192 results in the loss of certain&n; *    functionality during boot.&quot;&n; *&n; *    Since locations between 96 and 192 are the various paths, most (if not&n; *    all) PA-RISC machines should have them. Anyway, for safety reasons, the&n; *    following code can deal with only 96 bytes of Stable Storage, and all&n; *    sizes between 96 and 192 bytes (provided they are multiple of struct&n; *    device_path size, eg: 128, 160 and 192) to provide full information.&n; *    The code makes no use of data above 192 bytes. One last word: there&squot;s one&n; *    path we can always count on: the primary path.&n; */
DECL|macro|PDCS_DEBUG
macro_line|#undef PDCS_DEBUG
macro_line|#ifdef PDCS_DEBUG
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(fmt, args...)&t;printk(KERN_DEBUG fmt, ## args)
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(fmt, args...)
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;&t;&t;/* for capable() */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/sysfs.h&gt;
macro_line|#include &lt;linux/kobject.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/pdc.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
DECL|macro|PDCS_VERSION
mdefine_line|#define PDCS_VERSION&t;&quot;0.09&quot;
DECL|macro|PDCS_ADDR_PPRI
mdefine_line|#define PDCS_ADDR_PPRI&t;0x00
DECL|macro|PDCS_ADDR_OSID
mdefine_line|#define PDCS_ADDR_OSID&t;0x40
DECL|macro|PDCS_ADDR_FSIZ
mdefine_line|#define PDCS_ADDR_FSIZ&t;0x5C
DECL|macro|PDCS_ADDR_PCON
mdefine_line|#define PDCS_ADDR_PCON&t;0x60
DECL|macro|PDCS_ADDR_PALT
mdefine_line|#define PDCS_ADDR_PALT&t;0x80
DECL|macro|PDCS_ADDR_PKBD
mdefine_line|#define PDCS_ADDR_PKBD&t;0xA0
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Thibaut VARENE &lt;varenet@parisc-linux.org&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;sysfs interface to HP PDC Stable Storage data&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|PDCS_VERSION
id|MODULE_VERSION
c_func
(paren
id|PDCS_VERSION
)paren
suffix:semicolon
DECL|variable|pdcs_size
r_static
r_int
r_int
id|pdcs_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This struct defines what we need to deal with a parisc pdc path entry */
DECL|struct|pdcspath_entry
r_struct
id|pdcspath_entry
(brace
DECL|member|ready
r_int
id|ready
suffix:semicolon
multiline_comment|/* entry record is valid if != 0 */
DECL|member|addr
r_int
r_int
id|addr
suffix:semicolon
multiline_comment|/* entry address in stable storage */
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* entry name */
DECL|member|devpath
r_struct
id|device_path
id|devpath
suffix:semicolon
multiline_comment|/* device path in parisc representation */
DECL|member|dev
r_struct
id|device
op_star
id|dev
suffix:semicolon
multiline_comment|/* corresponding device */
DECL|member|kobj
r_struct
id|kobject
id|kobj
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pdcspath_attribute
r_struct
id|pdcspath_attribute
(brace
DECL|member|attr
r_struct
id|attribute
id|attr
suffix:semicolon
DECL|member|show
id|ssize_t
(paren
op_star
id|show
)paren
(paren
r_struct
id|pdcspath_entry
op_star
id|entry
comma
r_char
op_star
id|buf
)paren
suffix:semicolon
DECL|member|store
id|ssize_t
(paren
op_star
id|store
)paren
(paren
r_struct
id|pdcspath_entry
op_star
id|entry
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|PDCSPATH_ENTRY
mdefine_line|#define PDCSPATH_ENTRY(_addr, _name) &bslash;&n;struct pdcspath_entry pdcspath_entry_##_name = { &bslash;&n;&t;.ready = 0, &bslash;&n;&t;.addr = _addr, &bslash;&n;&t;.name = __stringify(_name), &bslash;&n;};
DECL|macro|PDCS_ATTR
mdefine_line|#define PDCS_ATTR(_name, _mode, _show, _store) &bslash;&n;struct subsys_attribute pdcs_attr_##_name = { &bslash;&n;&t;.attr = {.name = __stringify(_name), .mode = _mode, .owner = THIS_MODULE}, &bslash;&n;&t;.show = _show, &bslash;&n;&t;.store = _store, &bslash;&n;};
DECL|macro|PATHS_ATTR
mdefine_line|#define PATHS_ATTR(_name, _mode, _show, _store) &bslash;&n;struct pdcspath_attribute paths_attr_##_name = { &bslash;&n;&t;.attr = {.name = __stringify(_name), .mode = _mode, .owner = THIS_MODULE}, &bslash;&n;&t;.show = _show, &bslash;&n;&t;.store = _store, &bslash;&n;};
DECL|macro|to_pdcspath_attribute
mdefine_line|#define to_pdcspath_attribute(_attr) container_of(_attr, struct pdcspath_attribute, attr)
DECL|macro|to_pdcspath_entry
mdefine_line|#define to_pdcspath_entry(obj)  container_of(obj, struct pdcspath_entry, kobj)
multiline_comment|/**&n; * pdcspath_fetch - This function populates the path entry structs.&n; * @entry: A pointer to an allocated pdcspath_entry.&n; * &n; * The general idea is that you don&squot;t read from the Stable Storage every time&n; * you access the files provided by the facilites. We store a copy of the&n; * content of the stable storage WRT various paths in these structs. We read&n; * these structs when reading the files, and we will write to these structs when&n; * writing to the files, and only then write them back to the Stable Storage.&n; */
r_static
r_int
DECL|function|pdcspath_fetch
id|pdcspath_fetch
c_func
(paren
r_struct
id|pdcspath_entry
op_star
id|entry
)paren
(brace
r_struct
id|device_path
op_star
id|devpath
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|devpath
op_assign
op_amp
id|entry-&gt;devpath
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;%s: fetch: 0x%p, 0x%p, addr: 0x%lx&bslash;n&quot;
comma
id|__func__
comma
id|entry
comma
id|devpath
comma
id|entry-&gt;addr
)paren
suffix:semicolon
multiline_comment|/* addr, devpath and count must be word aligned */
r_if
c_cond
(paren
id|pdc_stable_read
c_func
(paren
id|entry-&gt;addr
comma
id|devpath
comma
r_sizeof
(paren
op_star
id|devpath
)paren
)paren
op_ne
id|PDC_OK
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Find the matching device.&n;&t;   NOTE: hardware_path overlays with device_path, so the nice cast can&n;&t;   be used */
id|entry-&gt;dev
op_assign
id|hwpath_to_device
c_func
(paren
(paren
r_struct
id|hardware_path
op_star
)paren
id|devpath
)paren
suffix:semicolon
id|entry-&gt;ready
op_assign
l_int|1
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;%s: device: 0x%p&bslash;n&quot;
comma
id|__func__
comma
id|entry-&gt;dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * pdcspath_store - This function writes a path to stable storage.&n; * @entry: A pointer to an allocated pdcspath_entry.&n; * &n; * It can be used in two ways: either by passing it a preset devpath struct&n; * containing an already computed hardware path, or by passing it a device&n; * pointer, from which it&squot;ll find out the corresponding hardware path.&n; * For now we do not handle the case where there&squot;s an error in writing to the&n; * Stable Storage area, so you&squot;d better not mess up the data :P&n; */
r_static
r_int
DECL|function|pdcspath_store
id|pdcspath_store
c_func
(paren
r_struct
id|pdcspath_entry
op_star
id|entry
)paren
(brace
r_struct
id|device_path
op_star
id|devpath
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|devpath
op_assign
op_amp
id|entry-&gt;devpath
suffix:semicolon
multiline_comment|/* We expect the caller to set the ready flag to 0 if the hardware&n;&t;   path struct provided is invalid, so that we know we have to fill it.&n;&t;   First case, we don&squot;t have a preset hwpath... */
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;ready
)paren
(brace
multiline_comment|/* ...but we have a device, map it */
r_if
c_cond
(paren
id|entry-&gt;dev
)paren
id|device_to_hwpath
c_func
(paren
id|entry-&gt;dev
comma
(paren
r_struct
id|hardware_path
op_star
)paren
id|devpath
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* else, we expect the provided hwpath to be valid. */
id|DPRINTK
c_func
(paren
l_string|&quot;%s: store: 0x%p, 0x%p, addr: 0x%lx&bslash;n&quot;
comma
id|__func__
comma
id|entry
comma
id|devpath
comma
id|entry-&gt;addr
)paren
suffix:semicolon
multiline_comment|/* addr, devpath and count must be word aligned */
r_if
c_cond
(paren
id|pdc_stable_write
c_func
(paren
id|entry-&gt;addr
comma
id|devpath
comma
r_sizeof
(paren
op_star
id|devpath
)paren
)paren
op_ne
id|PDC_OK
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: an error occured when writing to PDC.&bslash;n&quot;
l_string|&quot;It is likely that the Stable Storage data has been corrupted.&bslash;n&quot;
l_string|&quot;Please check it carefully upon next reboot.&bslash;n&quot;
comma
id|__func__
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|entry-&gt;ready
op_assign
l_int|1
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;%s: device: 0x%p&bslash;n&quot;
comma
id|__func__
comma
id|entry-&gt;dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * pdcspath_hwpath_read - This function handles hardware path pretty printing.&n; * @entry: An allocated and populated pdscpath_entry struct.&n; * @buf: The output buffer to write to.&n; * &n; * We will call this function to format the output of the hwpath attribute file.&n; */
r_static
id|ssize_t
DECL|function|pdcspath_hwpath_read
id|pdcspath_hwpath_read
c_func
(paren
r_struct
id|pdcspath_entry
op_star
id|entry
comma
r_char
op_star
id|buf
)paren
(brace
r_char
op_star
id|out
op_assign
id|buf
suffix:semicolon
r_struct
id|device_path
op_star
id|devpath
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
op_logical_or
op_logical_neg
id|buf
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|devpath
op_assign
op_amp
id|entry-&gt;devpath
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;ready
)paren
r_return
op_minus
id|ENODATA
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|devpath-&gt;bc
(braket
id|i
)braket
op_ge
l_int|128
)paren
r_continue
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%u/&quot;
comma
(paren
r_int
r_char
)paren
id|devpath-&gt;bc
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%u&bslash;n&quot;
comma
(paren
r_int
r_char
)paren
id|devpath-&gt;mod
)paren
suffix:semicolon
r_return
id|out
op_minus
id|buf
suffix:semicolon
)brace
multiline_comment|/**&n; * pdcspath_hwpath_write - This function handles hardware path modifying.&n; * @entry: An allocated and populated pdscpath_entry struct.&n; * @buf: The input buffer to read from.&n; * @count: The number of bytes to be read.&n; * &n; * We will call this function to change the current hardware path.&n; * Hardware paths are to be given &squot;/&squot;-delimited, without brackets.&n; * We take care to make sure that the provided path actually maps to an existing&n; * device, BUT nothing would prevent some foolish user to set the path to some&n; * PCI bridge or even a CPU...&n; * A better work around would be to make sure we are at the end of a device tree&n; * for instance, but it would be IMHO beyond the simple scope of that driver.&n; * The aim is to provide a facility. Data correctness is left to userland.&n; */
r_static
id|ssize_t
DECL|function|pdcspath_hwpath_write
id|pdcspath_hwpath_write
c_func
(paren
r_struct
id|pdcspath_entry
op_star
id|entry
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|hardware_path
id|hwpath
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_char
id|in
(braket
id|count
op_plus
l_int|1
)braket
comma
op_star
id|temp
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
op_logical_or
op_logical_neg
id|buf
op_logical_or
op_logical_neg
id|count
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* We&squot;ll use a local copy of buf */
id|memset
c_func
(paren
id|in
comma
l_int|0
comma
id|count
op_plus
l_int|1
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|in
comma
id|buf
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Let&squot;s clean up the target. 0xff is a blank pattern */
id|memset
c_func
(paren
op_amp
id|hwpath
comma
l_int|0xff
comma
r_sizeof
(paren
id|hwpath
)paren
)paren
suffix:semicolon
multiline_comment|/* First, pick the mod field (the last one of the input string) */
r_if
c_cond
(paren
op_logical_neg
(paren
id|temp
op_assign
id|strrchr
c_func
(paren
id|in
comma
l_char|&squot;/&squot;
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|hwpath.mod
op_assign
id|simple_strtoul
c_func
(paren
id|temp
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|in
(braket
id|temp
op_minus
id|in
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* truncate the remaining string. just precaution */
id|DPRINTK
c_func
(paren
l_string|&quot;%s: mod: %d&bslash;n&quot;
comma
id|__func__
comma
id|hwpath.mod
)paren
suffix:semicolon
multiline_comment|/* Then, loop for each delimiter, making sure we don&squot;t have too many.&n;&t;   we write the bc fields in a down-top way. No matter what, we stop&n;&t;   before writing the last field. If there are too many fields anyway,&n;&t;   then the user is a moron and it&squot;ll be caught up later when we&squot;ll&n;&t;   check the consistency of the given hwpath. */
r_for
c_loop
(paren
id|i
op_assign
l_int|5
suffix:semicolon
(paren
(paren
id|temp
op_assign
id|strrchr
c_func
(paren
id|in
comma
l_char|&squot;/&squot;
)paren
)paren
)paren
op_logical_and
(paren
id|temp
op_minus
id|in
OG
l_int|0
)paren
op_logical_and
(paren
id|likely
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|hwpath.bc
(braket
id|i
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|temp
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|in
(braket
id|temp
op_minus
id|in
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;%s: bc[%d]: %d&bslash;n&quot;
comma
id|__func__
comma
id|i
comma
id|hwpath.bc
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Store the final field */
id|hwpath.bc
(braket
id|i
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|in
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;%s: bc[%d]: %d&bslash;n&quot;
comma
id|__func__
comma
id|i
comma
id|hwpath.bc
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Now we check that the user isn&squot;t trying to lure us */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev
op_assign
id|hwpath_to_device
c_func
(paren
(paren
r_struct
id|hardware_path
op_star
)paren
op_amp
id|hwpath
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: attempt to set invalid &bslash;&quot;%s&bslash;&quot; &quot;
l_string|&quot;hardware path: %s&bslash;n&quot;
comma
id|__func__
comma
id|entry-&gt;name
comma
id|buf
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* So far so good, let&squot;s get in deep */
id|entry-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|entry-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Now, dive in. Write back to the hardware */
id|WARN_ON
c_func
(paren
id|pdcspath_store
c_func
(paren
id|entry
)paren
)paren
suffix:semicolon
multiline_comment|/* this warn should *NEVER* happen */
multiline_comment|/* Update the symlink to the real device */
id|sysfs_remove_link
c_func
(paren
op_amp
id|entry-&gt;kobj
comma
l_string|&quot;device&quot;
)paren
suffix:semicolon
id|sysfs_create_link
c_func
(paren
op_amp
id|entry-&gt;kobj
comma
op_amp
id|entry-&gt;dev-&gt;kobj
comma
l_string|&quot;device&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PDC Stable Storage: changed &bslash;&quot;%s&bslash;&quot; path to &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|entry-&gt;name
comma
id|buf
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/**&n; * pdcspath_layer_read - Extended layer (eg. SCSI ids) pretty printing.&n; * @entry: An allocated and populated pdscpath_entry struct.&n; * @buf: The output buffer to write to.&n; * &n; * We will call this function to format the output of the layer attribute file.&n; */
r_static
id|ssize_t
DECL|function|pdcspath_layer_read
id|pdcspath_layer_read
c_func
(paren
r_struct
id|pdcspath_entry
op_star
id|entry
comma
r_char
op_star
id|buf
)paren
(brace
r_char
op_star
id|out
op_assign
id|buf
suffix:semicolon
r_struct
id|device_path
op_star
id|devpath
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
op_logical_or
op_logical_neg
id|buf
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|devpath
op_assign
op_amp
id|entry-&gt;devpath
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;ready
)paren
r_return
op_minus
id|ENODATA
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|devpath-&gt;layers
(braket
id|i
)braket
op_logical_and
(paren
id|likely
c_func
(paren
id|i
OL
l_int|6
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%u &quot;
comma
id|devpath-&gt;layers
(braket
id|i
)braket
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|out
op_minus
id|buf
suffix:semicolon
)brace
multiline_comment|/**&n; * pdcspath_layer_write - This function handles extended layer modifying.&n; * @entry: An allocated and populated pdscpath_entry struct.&n; * @buf: The input buffer to read from.&n; * @count: The number of bytes to be read.&n; * &n; * We will call this function to change the current layer value.&n; * Layers are to be given &squot;.&squot;-delimited, without brackets.&n; * XXX beware we are far less checky WRT input data provided than for hwpath.&n; * Potential harm can be done, since there&squot;s no way to check the validity of&n; * the layer fields.&n; */
r_static
id|ssize_t
DECL|function|pdcspath_layer_write
id|pdcspath_layer_write
c_func
(paren
r_struct
id|pdcspath_entry
op_star
id|entry
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|layers
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* device-specific info (ctlr#, unit#, ...) */
r_int
r_int
id|i
suffix:semicolon
r_char
id|in
(braket
id|count
op_plus
l_int|1
)braket
comma
op_star
id|temp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
op_logical_or
op_logical_neg
id|buf
op_logical_or
op_logical_neg
id|count
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* We&squot;ll use a local copy of buf */
id|memset
c_func
(paren
id|in
comma
l_int|0
comma
id|count
op_plus
l_int|1
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|in
comma
id|buf
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Let&squot;s clean up the target. 0 is a blank pattern */
id|memset
c_func
(paren
op_amp
id|layers
comma
l_int|0
comma
r_sizeof
(paren
id|layers
)paren
)paren
suffix:semicolon
multiline_comment|/* First, pick the first layer */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|isdigit
c_func
(paren
op_star
id|in
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|layers
(braket
l_int|0
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|in
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;%s: layer[0]: %d&bslash;n&quot;
comma
id|__func__
comma
id|layers
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|temp
op_assign
id|in
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
(paren
(paren
id|temp
op_assign
id|strchr
c_func
(paren
id|temp
comma
l_char|&squot;.&squot;
)paren
)paren
)paren
op_logical_and
(paren
id|likely
c_func
(paren
id|i
OL
l_int|6
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|isdigit
c_func
(paren
op_star
(paren
op_increment
id|temp
)paren
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|layers
(braket
id|i
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|temp
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;%s: layer[%d]: %d&bslash;n&quot;
comma
id|__func__
comma
id|i
comma
id|layers
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* So far so good, let&squot;s get in deep */
multiline_comment|/* First, overwrite the current layers with the new ones, not touching&n;&t;   the hardware path. */
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;devpath.layers
comma
op_amp
id|layers
comma
r_sizeof
(paren
id|layers
)paren
)paren
suffix:semicolon
multiline_comment|/* Now, dive in. Write back to the hardware */
id|WARN_ON
c_func
(paren
id|pdcspath_store
c_func
(paren
id|entry
)paren
)paren
suffix:semicolon
multiline_comment|/* this warn should *NEVER* happen */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PDC Stable Storage: changed &bslash;&quot;%s&bslash;&quot; layers to &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|entry-&gt;name
comma
id|buf
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/**&n; * pdcspath_attr_show - Generic read function call wrapper.&n; * @kobj: The kobject to get info from.&n; * @attr: The attribute looked upon.&n; * @buf: The output buffer.&n; */
r_static
id|ssize_t
DECL|function|pdcspath_attr_show
id|pdcspath_attr_show
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
comma
r_struct
id|attribute
op_star
id|attr
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|pdcspath_entry
op_star
id|entry
op_assign
id|to_pdcspath_entry
c_func
(paren
id|kobj
)paren
suffix:semicolon
r_struct
id|pdcspath_attribute
op_star
id|pdcs_attr
op_assign
id|to_pdcspath_attribute
c_func
(paren
id|attr
)paren
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|pdcs_attr-&gt;show
)paren
id|ret
op_assign
id|pdcs_attr
op_member_access_from_pointer
id|show
c_func
(paren
id|entry
comma
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * pdcspath_attr_store - Generic write function call wrapper.&n; * @kobj: The kobject to write info to.&n; * @attr: The attribute to be modified.&n; * @buf: The input buffer.&n; * @count: The size of the buffer.&n; */
r_static
id|ssize_t
DECL|function|pdcspath_attr_store
id|pdcspath_attr_store
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
comma
r_struct
id|attribute
op_star
id|attr
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|pdcspath_entry
op_star
id|entry
op_assign
id|to_pdcspath_entry
c_func
(paren
id|kobj
)paren
suffix:semicolon
r_struct
id|pdcspath_attribute
op_star
id|pdcs_attr
op_assign
id|to_pdcspath_attribute
c_func
(paren
id|attr
)paren
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|pdcs_attr-&gt;store
)paren
id|ret
op_assign
id|pdcs_attr
op_member_access_from_pointer
id|store
c_func
(paren
id|entry
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|pdcspath_attr_ops
r_static
r_struct
id|sysfs_ops
id|pdcspath_attr_ops
op_assign
(brace
dot
id|show
op_assign
id|pdcspath_attr_show
comma
dot
id|store
op_assign
id|pdcspath_attr_store
comma
)brace
suffix:semicolon
multiline_comment|/* These are the two attributes of any PDC path. */
r_static
id|PATHS_ATTR
c_func
(paren
id|hwpath
comma
l_int|0600
comma
id|pdcspath_hwpath_read
comma
id|pdcspath_hwpath_write
)paren
suffix:semicolon
r_static
id|PATHS_ATTR
c_func
(paren
id|layer
comma
l_int|0600
comma
id|pdcspath_layer_read
comma
id|pdcspath_layer_write
)paren
suffix:semicolon
DECL|variable|paths_subsys_attrs
r_static
r_struct
id|attribute
op_star
id|paths_subsys_attrs
(braket
)braket
op_assign
(brace
op_amp
id|paths_attr_hwpath.attr
comma
op_amp
id|paths_attr_layer.attr
comma
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/* Specific kobject type for our PDC paths */
DECL|variable|ktype_pdcspath
r_static
r_struct
id|kobj_type
id|ktype_pdcspath
op_assign
(brace
dot
id|sysfs_ops
op_assign
op_amp
id|pdcspath_attr_ops
comma
dot
id|default_attrs
op_assign
id|paths_subsys_attrs
comma
)brace
suffix:semicolon
multiline_comment|/* We hard define the 4 types of path we expect to find */
r_static
id|PDCSPATH_ENTRY
c_func
(paren
id|PDCS_ADDR_PPRI
comma
id|primary
)paren
suffix:semicolon
r_static
id|PDCSPATH_ENTRY
c_func
(paren
id|PDCS_ADDR_PCON
comma
id|console
)paren
suffix:semicolon
r_static
id|PDCSPATH_ENTRY
c_func
(paren
id|PDCS_ADDR_PALT
comma
id|alternative
)paren
suffix:semicolon
r_static
id|PDCSPATH_ENTRY
c_func
(paren
id|PDCS_ADDR_PKBD
comma
id|keyboard
)paren
suffix:semicolon
multiline_comment|/* An array containing all PDC paths we will deal with */
DECL|variable|pdcspath_entries
r_static
r_struct
id|pdcspath_entry
op_star
id|pdcspath_entries
(braket
)braket
op_assign
(brace
op_amp
id|pdcspath_entry_primary
comma
op_amp
id|pdcspath_entry_alternative
comma
op_amp
id|pdcspath_entry_console
comma
op_amp
id|pdcspath_entry_keyboard
comma
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * pdcs_info_read - Pretty printing of the remaining useful data.&n; * @entry: An allocated and populated subsytem struct. We don&squot;t use it tho.&n; * @buf: The output buffer to write to.&n; * &n; * We will call this function to format the output of the &squot;info&squot; attribute file.&n; * Please refer to PDC Procedures documentation, section PDC_STABLE to get a&n; * better insight of what we&squot;re doing here.&n; */
r_static
id|ssize_t
DECL|function|pdcs_info_read
id|pdcs_info_read
c_func
(paren
r_struct
id|subsystem
op_star
id|entry
comma
r_char
op_star
id|buf
)paren
(brace
r_char
op_star
id|out
op_assign
id|buf
suffix:semicolon
id|__u32
id|result
suffix:semicolon
r_struct
id|device_path
id|devpath
suffix:semicolon
r_char
op_star
id|tmpstr
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
op_logical_or
op_logical_neg
id|buf
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* show the size of the stable storage */
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;Stable Storage size: %ld bytes&bslash;n&quot;
comma
id|pdcs_size
)paren
suffix:semicolon
multiline_comment|/* deal with flags */
r_if
c_cond
(paren
id|pdc_stable_read
c_func
(paren
id|PDCS_ADDR_PPRI
comma
op_amp
id|devpath
comma
r_sizeof
(paren
id|devpath
)paren
)paren
op_ne
id|PDC_OK
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;Autoboot: %s&bslash;n&quot;
comma
(paren
id|devpath.flags
op_amp
id|PF_AUTOBOOT
)paren
ques
c_cond
l_string|&quot;On&quot;
suffix:colon
l_string|&quot;Off&quot;
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;Autosearch: %s&bslash;n&quot;
comma
(paren
id|devpath.flags
op_amp
id|PF_AUTOSEARCH
)paren
ques
c_cond
l_string|&quot;On&quot;
suffix:colon
l_string|&quot;Off&quot;
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;Timer: %u s&bslash;n&quot;
comma
(paren
id|devpath.flags
op_amp
id|PF_TIMER
)paren
ques
c_cond
(paren
l_int|1
op_lshift
(paren
id|devpath.flags
op_amp
id|PF_TIMER
)paren
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* get OSID */
r_if
c_cond
(paren
id|pdc_stable_read
c_func
(paren
id|PDCS_ADDR_OSID
comma
op_amp
id|result
comma
r_sizeof
(paren
id|result
)paren
)paren
op_ne
id|PDC_OK
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* the actual result is 16 bits away */
r_switch
c_cond
(paren
id|result
op_rshift
l_int|16
)paren
(brace
r_case
l_int|0x0000
suffix:colon
id|tmpstr
op_assign
l_string|&quot;No OS-dependent data&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0001
suffix:colon
id|tmpstr
op_assign
l_string|&quot;HP-UX dependent data&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0002
suffix:colon
id|tmpstr
op_assign
l_string|&quot;MPE-iX dependent data&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0003
suffix:colon
id|tmpstr
op_assign
l_string|&quot;OSF dependent data&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0004
suffix:colon
id|tmpstr
op_assign
l_string|&quot;HP-RT dependent data&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0005
suffix:colon
id|tmpstr
op_assign
l_string|&quot;Novell Netware dependent data&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|tmpstr
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;OS ID: %s (0x%.4x)&bslash;n&quot;
comma
id|tmpstr
comma
(paren
id|result
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
multiline_comment|/* get fast-size */
r_if
c_cond
(paren
id|pdc_stable_read
c_func
(paren
id|PDCS_ADDR_FSIZ
comma
op_amp
id|result
comma
r_sizeof
(paren
id|result
)paren
)paren
op_ne
id|PDC_OK
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;Memory tested: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_amp
l_int|0x0F
)paren
OL
l_int|0x0E
)paren
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%.3f MB&quot;
comma
l_float|0.256
op_star
(paren
l_int|1
op_lshift
(paren
id|result
op_amp
l_int|0x0F
)paren
)paren
)paren
suffix:semicolon
r_else
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;All&quot;
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|out
op_minus
id|buf
suffix:semicolon
)brace
multiline_comment|/**&n; * pdcs_info_write - This function handles boot flag modifying.&n; * @entry: An allocated and populated subsytem struct. We don&squot;t use it tho.&n; * @buf: The input buffer to read from.&n; * @count: The number of bytes to be read.&n; * &n; * We will call this function to change the current boot flags.&n; * We expect a precise syntax:&n; *&t;&bslash;&quot;n n&bslash;&quot; (n == 0 or 1) to toggle respectively AutoBoot and AutoSearch&n; *&n; * As of now there is no incentive on my side to provide more &quot;knobs&quot; to that&n; * interface, since modifying the rest of the data is pretty meaningless when&n; * the machine is running and for the expected use of that facility, such as&n; * PALO setting up the boot disk when installing a Linux distribution...&n; */
r_static
id|ssize_t
DECL|function|pdcs_info_write
id|pdcs_info_write
c_func
(paren
r_struct
id|subsystem
op_star
id|entry
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|pdcspath_entry
op_star
id|pathentry
suffix:semicolon
r_int
r_char
id|flags
suffix:semicolon
r_char
id|in
(braket
id|count
op_plus
l_int|1
)braket
comma
op_star
id|temp
suffix:semicolon
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
op_logical_or
op_logical_neg
id|buf
op_logical_or
op_logical_neg
id|count
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* We&squot;ll use a local copy of buf */
id|memset
c_func
(paren
id|in
comma
l_int|0
comma
id|count
op_plus
l_int|1
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|in
comma
id|buf
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Current flags are stored in primary boot path entry */
id|pathentry
op_assign
op_amp
id|pdcspath_entry_primary
suffix:semicolon
multiline_comment|/* Be nice to the existing flag record */
id|flags
op_assign
id|pathentry-&gt;devpath.flags
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;%s: flags before: 0x%X&bslash;n&quot;
comma
id|__func__
comma
id|flags
)paren
suffix:semicolon
id|temp
op_assign
id|in
suffix:semicolon
r_while
c_loop
(paren
op_star
id|temp
op_logical_and
id|isspace
c_func
(paren
op_star
id|temp
)paren
)paren
id|temp
op_increment
suffix:semicolon
id|c
op_assign
op_star
id|temp
op_increment
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_ne
l_int|0
)paren
op_logical_and
(paren
id|c
op_ne
l_int|1
)paren
)paren
r_goto
id|parse_error
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|0
)paren
id|flags
op_and_assign
op_complement
id|PF_AUTOBOOT
suffix:semicolon
r_else
id|flags
op_or_assign
id|PF_AUTOBOOT
suffix:semicolon
r_if
c_cond
(paren
op_star
id|temp
op_increment
op_ne
l_char|&squot; &squot;
)paren
r_goto
id|parse_error
suffix:semicolon
id|c
op_assign
op_star
id|temp
op_increment
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_ne
l_int|0
)paren
op_logical_and
(paren
id|c
op_ne
l_int|1
)paren
)paren
r_goto
id|parse_error
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|0
)paren
id|flags
op_and_assign
op_complement
id|PF_AUTOSEARCH
suffix:semicolon
r_else
id|flags
op_or_assign
id|PF_AUTOSEARCH
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;%s: flags after: 0x%X&bslash;n&quot;
comma
id|__func__
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* So far so good, let&squot;s get in deep */
multiline_comment|/* Change the path entry flags first */
id|pathentry-&gt;devpath.flags
op_assign
id|flags
suffix:semicolon
multiline_comment|/* Now, dive in. Write back to the hardware */
id|WARN_ON
c_func
(paren
id|pdcspath_store
c_func
(paren
id|pathentry
)paren
)paren
suffix:semicolon
multiline_comment|/* this warn should *NEVER* happen */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PDC Stable Storage: changed flags to &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
id|parse_error
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Parse error: expect &bslash;&quot;n n&bslash;&quot; (n == 0 or 1) for AB and AS&bslash;n&quot;
comma
id|__func__
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* The last attribute (the &squot;root&squot; one actually) with all remaining data. */
r_static
id|PDCS_ATTR
c_func
(paren
id|info
comma
l_int|0600
comma
id|pdcs_info_read
comma
id|pdcs_info_write
)paren
suffix:semicolon
DECL|variable|pdcs_subsys_attrs
r_static
r_struct
id|subsys_attribute
op_star
id|pdcs_subsys_attrs
(braket
)braket
op_assign
(brace
op_amp
id|pdcs_attr_info
comma
l_int|NULL
comma
multiline_comment|/* maybe more in the future? */
)brace
suffix:semicolon
DECL|variable|decl_subsys
r_static
id|decl_subsys
c_func
(paren
id|paths
comma
op_amp
id|ktype_pdcspath
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|decl_subsys
c_func
(paren
id|pdc
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/**&n; * pdcs_register_pathentries - Prepares path entries kobjects for sysfs usage.&n; * &n; * It creates kobjects corresponding to each path entry with nice sysfs&n; * links to the real device. This is where the magic takes place: when&n; * registering the subsystem attributes during module init, each kobject hereby&n; * created will show in the sysfs tree as a folder containing files as defined&n; * by path_subsys_attr[].&n; */
r_static
r_inline
r_int
id|__init
DECL|function|pdcs_register_pathentries
id|pdcs_register_pathentries
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_struct
id|pdcspath_entry
op_star
id|entry
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|entry
op_assign
id|pdcspath_entries
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pdcspath_fetch
c_func
(paren
id|entry
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|kobject_set_name
c_func
(paren
op_amp
id|entry-&gt;kobj
comma
l_string|&quot;%s&quot;
comma
id|entry-&gt;name
)paren
suffix:semicolon
id|kobj_set_kset_s
c_func
(paren
id|entry
comma
id|paths_subsys
)paren
suffix:semicolon
id|kobject_register
c_func
(paren
op_amp
id|entry-&gt;kobj
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;dev
)paren
r_continue
suffix:semicolon
multiline_comment|/* Add a nice symlink to the real device */
id|sysfs_create_link
c_func
(paren
op_amp
id|entry-&gt;kobj
comma
op_amp
id|entry-&gt;dev-&gt;kobj
comma
l_string|&quot;device&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * pdcs_unregister_pathentries - Routine called when unregistering the module.&n; */
r_static
r_inline
r_void
id|__exit
DECL|function|pdcs_unregister_pathentries
id|pdcs_unregister_pathentries
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_struct
id|pdcspath_entry
op_star
id|entry
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|entry
op_assign
id|pdcspath_entries
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|entry-&gt;ready
)paren
id|kobject_unregister
c_func
(paren
op_amp
id|entry-&gt;kobj
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For now we register the pdc subsystem with the firmware subsystem&n; * and the paths subsystem with the pdc subsystem&n; */
r_static
r_int
id|__init
DECL|function|pdc_stable_init
id|pdc_stable_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|subsys_attribute
op_star
id|attr
suffix:semicolon
r_int
id|i
comma
id|rc
op_assign
l_int|0
comma
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* find the size of the stable storage */
r_if
c_cond
(paren
id|pdc_stable_get_size
c_func
(paren
op_amp
id|pdcs_size
)paren
op_ne
id|PDC_OK
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PDC Stable Storage facility v%s&bslash;n&quot;
comma
id|PDCS_VERSION
)paren
suffix:semicolon
multiline_comment|/* For now we&squot;ll register the pdc subsys within this driver */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|firmware_register
c_func
(paren
op_amp
id|pdc_subsys
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* Don&squot;t forget the info entry */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|attr
op_assign
id|pdcs_subsys_attrs
(braket
id|i
)braket
)paren
op_logical_and
op_logical_neg
id|error
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|attr-&gt;show
)paren
id|error
op_assign
id|subsys_create_file
c_func
(paren
op_amp
id|pdc_subsys
comma
id|attr
)paren
suffix:semicolon
multiline_comment|/* register the paths subsys as a subsystem of pdc subsys */
id|kset_set_kset_s
c_func
(paren
op_amp
id|paths_subsys
comma
id|pdc_subsys
)paren
suffix:semicolon
id|subsystem_register
c_func
(paren
op_amp
id|paths_subsys
)paren
suffix:semicolon
multiline_comment|/* now we create all &quot;files&quot; for the paths subsys */
id|pdcs_register_pathentries
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|pdc_stable_exit
id|pdc_stable_exit
c_func
(paren
r_void
)paren
(brace
id|pdcs_unregister_pathentries
c_func
(paren
)paren
suffix:semicolon
id|subsystem_unregister
c_func
(paren
op_amp
id|paths_subsys
)paren
suffix:semicolon
id|firmware_unregister
c_func
(paren
op_amp
id|pdc_subsys
)paren
suffix:semicolon
)brace
DECL|variable|pdc_stable_init
id|module_init
c_func
(paren
id|pdc_stable_init
)paren
suffix:semicolon
DECL|variable|pdc_stable_exit
id|module_exit
c_func
(paren
id|pdc_stable_exit
)paren
suffix:semicolon
eof
