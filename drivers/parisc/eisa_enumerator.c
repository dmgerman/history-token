multiline_comment|/*&n; * eisa_enumerator.c - provide support for EISA adapters in PA-RISC machines&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; * Copyright (c) 2002 Daniel Engstrom &lt;5116@telia.com&gt;&n; *&n; */
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/eisa_bus.h&gt;
macro_line|#include &lt;asm/eisa_eeprom.h&gt;
multiline_comment|/*&n; * Todo:&n; * &n; * PORT init with MASK attr and other size than byte&n; * MEMORY with other decode than 20 bit&n; * CRC stuff&n; * FREEFORM stuff&n; */
DECL|macro|EPI
mdefine_line|#define EPI 0xc80
DECL|macro|NUM_SLOT
mdefine_line|#define NUM_SLOT 16
DECL|macro|SLOT2PORT
mdefine_line|#define SLOT2PORT(x) (x&lt;&lt;12)
multiline_comment|/* macros to handle unaligned accesses and &n; * byte swapping. The data in the EEPROM is&n; * little-endian on the big-endian PAROSC */
DECL|macro|get_8
mdefine_line|#define get_8(x) (*(u_int8_t*)(x))
DECL|function|get_16
r_static
r_inline
id|u_int16_t
id|get_16
c_func
(paren
r_const
r_int
r_char
op_star
id|x
)paren
(brace
r_return
(paren
id|x
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
id|x
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|get_32
r_static
r_inline
id|u_int32_t
id|get_32
c_func
(paren
r_const
r_int
r_char
op_star
id|x
)paren
(brace
r_return
(paren
id|x
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|x
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|x
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
id|x
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|get_24
r_static
r_inline
id|u_int32_t
id|get_24
c_func
(paren
r_const
r_int
r_char
op_star
id|x
)paren
(brace
r_return
(paren
id|x
(braket
l_int|2
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|x
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|x
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
DECL|function|print_eisa_id
r_static
r_void
id|print_eisa_id
c_func
(paren
r_char
op_star
id|s
comma
id|u_int32_t
id|id
)paren
(brace
r_char
id|vendor
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|rev
suffix:semicolon
r_int
id|device
suffix:semicolon
id|rev
op_assign
id|id
op_amp
l_int|0xff
suffix:semicolon
id|id
op_rshift_assign
l_int|8
suffix:semicolon
id|device
op_assign
id|id
op_amp
l_int|0xff
suffix:semicolon
id|id
op_rshift_assign
l_int|8
suffix:semicolon
id|vendor
(braket
l_int|3
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|vendor
(braket
l_int|2
)braket
op_assign
l_char|&squot;@&squot;
op_plus
(paren
id|id
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|id
op_rshift_assign
l_int|5
suffix:semicolon
id|vendor
(braket
l_int|1
)braket
op_assign
l_char|&squot;@&squot;
op_plus
(paren
id|id
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|id
op_rshift_assign
l_int|5
suffix:semicolon
id|vendor
(braket
l_int|0
)braket
op_assign
l_char|&squot;@&squot;
op_plus
(paren
id|id
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|id
op_rshift_assign
l_int|5
suffix:semicolon
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%s%02X%02X&quot;
comma
id|vendor
comma
id|device
comma
id|rev
)paren
suffix:semicolon
)brace
DECL|function|configure_memory
r_static
r_int
id|configure_memory
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
comma
r_struct
id|resource
op_star
id|mem_parent
comma
r_char
op_star
id|name
)paren
(brace
r_int
id|len
suffix:semicolon
id|u_int8_t
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HPEE_MEMORY_MAX_ENT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
id|get_8
c_func
(paren
id|buf
op_plus
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_ne
(paren
id|res
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_int
id|result
suffix:semicolon
id|res-&gt;name
op_assign
id|name
suffix:semicolon
id|res-&gt;start
op_assign
id|mem_parent-&gt;start
op_plus
id|get_24
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|2
)paren
suffix:semicolon
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|5
)paren
op_star
l_int|1024
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;memory %lx-%lx &quot;
comma
id|res-&gt;start
comma
id|res-&gt;end
)paren
suffix:semicolon
id|result
op_assign
id|request_resource
c_func
(paren
id|mem_parent
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_ERR
l_string|&quot;EISA Enumerator: failed to claim EISA Bus address space!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
)brace
id|len
op_add_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c
op_amp
id|HPEE_MEMORY_MORE
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|configure_irq
r_static
r_int
id|configure_irq
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
id|len
suffix:semicolon
id|u_int8_t
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HPEE_IRQ_MAX_ENT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
id|get_8
c_func
(paren
id|buf
op_plus
id|len
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IRQ %d &quot;
comma
id|c
op_amp
id|HPEE_IRQ_CHANNEL_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
id|HPEE_IRQ_TRIG_LEVEL
)paren
(brace
id|eisa_make_irq_level
c_func
(paren
id|c
op_amp
id|HPEE_IRQ_CHANNEL_MASK
)paren
suffix:semicolon
)brace
r_else
(brace
id|eisa_make_irq_edge
c_func
(paren
id|c
op_amp
id|HPEE_IRQ_CHANNEL_MASK
)paren
suffix:semicolon
)brace
id|len
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* hpux seems to allow for&n;&t;&t; * two bytes of irq data but only defines one of&n;&t;&t; * them, I think */
r_if
c_cond
(paren
op_logical_neg
(paren
id|c
op_amp
id|HPEE_IRQ_MORE
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|configure_dma
r_static
r_int
id|configure_dma
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
id|len
suffix:semicolon
id|u_int8_t
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HPEE_DMA_MAX_ENT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
id|get_8
c_func
(paren
id|buf
op_plus
id|len
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;DMA %d &quot;
comma
id|c
op_amp
id|HPEE_DMA_CHANNEL_MASK
)paren
suffix:semicolon
multiline_comment|/* fixme: maybe initialize the dma channel withthe timing ? */
id|len
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c
op_amp
id|HPEE_DMA_MORE
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|configure_port
r_static
r_int
id|configure_port
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
comma
r_struct
id|resource
op_star
id|io_parent
comma
r_char
op_star
id|board
)paren
(brace
r_int
id|len
suffix:semicolon
id|u_int8_t
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
r_int
id|result
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HPEE_PORT_MAX_ENT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
id|get_8
c_func
(paren
id|buf
op_plus
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_ne
(paren
id|res
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|res-&gt;name
op_assign
id|board
suffix:semicolon
id|res-&gt;start
op_assign
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
id|res-&gt;end
op_assign
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|1
)paren
op_plus
(paren
id|c
op_amp
id|HPEE_PORT_SIZE_MASK
)paren
op_plus
l_int|1
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_IO
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ioports %lx-%lx &quot;
comma
id|res-&gt;start
comma
id|res-&gt;end
)paren
suffix:semicolon
id|result
op_assign
id|request_resource
c_func
(paren
id|io_parent
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_ERR
l_string|&quot;EISA Enumerator: failed to claim EISA Bus address space!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
)brace
id|len
op_add_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c
op_amp
id|HPEE_PORT_MORE
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* byte 1 and 2 is the port number to write&n; * and at byte 3 the value to write starts.&n; * I assume that there are and- and or- masks&n; * here when HPEE_PORT_INIT_MASK is set but I have &n; * not yet encountered this. */
DECL|function|configure_port_init
r_static
r_int
id|configure_port_init
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|u_int8_t
id|c
suffix:semicolon
r_while
c_loop
(paren
id|len
OL
id|HPEE_PORT_INIT_MAX_LEN
)paren
(brace
r_int
id|s
op_assign
l_int|0
suffix:semicolon
id|c
op_assign
id|get_8
c_func
(paren
id|buf
op_plus
id|len
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
op_amp
id|HPEE_PORT_INIT_WIDTH_MASK
)paren
(brace
r_case
id|HPEE_PORT_INIT_WIDTH_BYTE
suffix:colon
id|s
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
id|HPEE_PORT_INIT_MASK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_WARNING
l_string|&quot;port_init: unverified mask attribute&bslash;n&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|inb
c_func
(paren
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|1
)paren
op_amp
id|get_8
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|3
)paren
)paren
op_or
id|get_8
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|4
)paren
)paren
comma
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|get_8
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|3
)paren
comma
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|HPEE_PORT_INIT_WIDTH_WORD
suffix:colon
id|s
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
id|HPEE_PORT_INIT_MASK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;port_init: unverified mask attribute&bslash;n&quot;
)paren
suffix:semicolon
id|outw
c_func
(paren
(paren
id|inw
c_func
(paren
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|1
)paren
)paren
op_amp
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|3
)paren
)paren
op_or
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|5
)paren
comma
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|outw
c_func
(paren
id|cpu_to_le16
c_func
(paren
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|3
)paren
)paren
comma
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|HPEE_PORT_INIT_WIDTH_DWORD
suffix:colon
id|s
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
id|HPEE_PORT_INIT_MASK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_WARNING
l_string|&quot;port_init: unverified mask attribute&bslash;n&quot;
)paren
suffix:semicolon
id|outl
c_func
(paren
(paren
id|inl
c_func
(paren
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|1
)paren
op_amp
id|get_32
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|3
)paren
)paren
op_or
id|get_32
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|7
)paren
)paren
comma
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|outl
c_func
(paren
id|cpu_to_le32
c_func
(paren
id|get_32
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|3
)paren
)paren
comma
id|get_16
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_ERR
l_string|&quot;Invalid port init word %02x&bslash;n&quot;
comma
id|c
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_amp
id|HPEE_PORT_INIT_MASK
)paren
(brace
id|s
op_mul_assign
l_int|2
suffix:semicolon
)brace
id|len
op_add_assign
id|s
op_plus
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c
op_amp
id|HPEE_PORT_INIT_MORE
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|configure_choise
r_static
r_int
id|configure_choise
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
comma
id|u_int8_t
op_star
id|info
)paren
(brace
r_int
id|len
suffix:semicolon
multiline_comment|/* theis record contain the value of the functions&n;&t; * configuration choises and an info byte which &n;&t; * describes which other records to expect in this &n;&t; * function */
id|len
op_assign
id|get_8
c_func
(paren
id|buf
)paren
suffix:semicolon
op_star
id|info
op_assign
id|get_8
c_func
(paren
id|buf
op_plus
id|len
op_plus
l_int|1
)paren
suffix:semicolon
r_return
id|len
op_plus
l_int|2
suffix:semicolon
)brace
DECL|function|configure_type_string
r_static
r_int
id|configure_type_string
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
id|len
suffix:semicolon
multiline_comment|/* just skip past the type field */
id|len
op_assign
id|get_8
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|80
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_ERR
l_string|&quot;eisa_enumerator: type info field too long (%d, max is 80)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
)brace
r_return
l_int|1
op_plus
id|len
suffix:semicolon
)brace
DECL|function|configure_function
r_static
r_int
id|configure_function
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
comma
r_int
op_star
id|more
)paren
(brace
multiline_comment|/* the init field seems to be a two-byte field&n;&t; * which is non-zero if there are an other function following&n;&t; * I think it is the length of the function def &n;&t; */
op_star
id|more
op_assign
id|get_16
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
DECL|function|parse_slot_config
r_static
r_int
id|parse_slot_config
c_func
(paren
r_int
id|slot
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_struct
id|eeprom_eisa_slot_info
op_star
id|es
comma
r_struct
id|resource
op_star
id|io_parent
comma
r_struct
id|resource
op_star
id|mem_parent
)paren
(brace
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_int
id|function_len
suffix:semicolon
r_int
r_int
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|maxlen
suffix:semicolon
r_int
id|num_func
op_assign
l_int|0
suffix:semicolon
id|u_int8_t
id|flags
suffix:semicolon
r_int
id|p0
suffix:semicolon
r_char
op_star
id|board
suffix:semicolon
r_int
id|id_string_used
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
id|board
op_assign
id|kmalloc
c_func
(paren
l_int|8
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|print_eisa_id
c_func
(paren
id|board
comma
id|es-&gt;eisa_slot_id
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;EISA slot %d: %s %s &quot;
comma
id|slot
comma
id|board
comma
id|es-&gt;flags
op_amp
id|HPEE_FLAG_BOARD_IS_ISA
ques
c_cond
l_string|&quot;ISA&quot;
suffix:colon
l_string|&quot;EISA&quot;
)paren
suffix:semicolon
id|maxlen
op_assign
id|es-&gt;config_data_length
OL
id|HPEE_MAX_LENGTH
ques
c_cond
id|es-&gt;config_data_length
suffix:colon
id|HPEE_MAX_LENGTH
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pos
OL
id|maxlen
)paren
op_logical_and
(paren
id|num_func
op_le
id|es-&gt;num_functions
)paren
)paren
(brace
id|pos
op_add_assign
id|configure_function
c_func
(paren
id|buf
op_plus
id|pos
comma
op_amp
id|function_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|function_len
)paren
(brace
r_break
suffix:semicolon
)brace
id|num_func
op_increment
suffix:semicolon
id|p0
op_assign
id|pos
suffix:semicolon
id|pos
op_add_assign
id|configure_choise
c_func
(paren
id|buf
op_plus
id|pos
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|HPEE_FUNCTION_INFO_F_DISABLED
)paren
(brace
multiline_comment|/* function disabled, skip silently */
id|pos
op_assign
id|p0
op_plus
id|function_len
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|HPEE_FUNCTION_INFO_CFG_FREE_FORM
)paren
(brace
multiline_comment|/* I have no idea how to handle this */
id|printk
c_func
(paren
l_string|&quot;function %d have free-form confgiuration, skipping &quot;
comma
id|num_func
)paren
suffix:semicolon
id|pos
op_assign
id|p0
op_plus
id|function_len
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* the ordering of the sections need&n;&t;&t; * more investigation.&n;&t;&t; * Currently I think that memory comaed before IRQ&n;&t;&t; * I assume the order is LSB to MSB in the &n;&t;&t; * info flags &n;&t;&t; * eg type, memory, irq, dma, port, HPEE_PORT_init &n;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|HPEE_FUNCTION_INFO_HAVE_TYPE
)paren
(brace
id|pos
op_add_assign
id|configure_type_string
c_func
(paren
id|buf
op_plus
id|pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|HPEE_FUNCTION_INFO_HAVE_MEMORY
)paren
(brace
id|id_string_used
op_assign
l_int|1
suffix:semicolon
id|pos
op_add_assign
id|configure_memory
c_func
(paren
id|buf
op_plus
id|pos
comma
id|mem_parent
comma
id|board
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|HPEE_FUNCTION_INFO_HAVE_IRQ
)paren
(brace
id|pos
op_add_assign
id|configure_irq
c_func
(paren
id|buf
op_plus
id|pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|HPEE_FUNCTION_INFO_HAVE_DMA
)paren
(brace
id|pos
op_add_assign
id|configure_dma
c_func
(paren
id|buf
op_plus
id|pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|HPEE_FUNCTION_INFO_HAVE_PORT
)paren
(brace
id|id_string_used
op_assign
l_int|1
suffix:semicolon
id|pos
op_add_assign
id|configure_port
c_func
(paren
id|buf
op_plus
id|pos
comma
id|io_parent
comma
id|board
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|HPEE_FUNCTION_INFO_HAVE_PORT_INIT
)paren
(brace
id|pos
op_add_assign
id|configure_port_init
c_func
(paren
id|buf
op_plus
id|pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p0
op_plus
id|function_len
OL
id|pos
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_ERR
l_string|&quot;eisa_enumerator: function %d length mis-match &quot;
l_string|&quot;got %d, expected %d&bslash;n&quot;
comma
id|num_func
comma
id|pos
op_minus
id|p0
comma
id|function_len
)paren
suffix:semicolon
id|res
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pos
op_assign
id|p0
op_plus
id|function_len
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|id_string_used
)paren
(brace
id|kfree
c_func
(paren
id|board
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
op_ne
id|es-&gt;config_data_length
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;eisa_enumerator: config data length mis-match got %d, expected %d&bslash;n&quot;
comma
id|pos
comma
id|es-&gt;config_data_length
)paren
suffix:semicolon
id|res
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num_func
op_ne
id|es-&gt;num_functions
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;eisa_enumerator: number of functions mis-match got %d, expected %d&bslash;n&quot;
comma
id|num_func
comma
id|es-&gt;num_functions
)paren
suffix:semicolon
id|res
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|init_slot
r_static
r_int
id|init_slot
c_func
(paren
r_int
id|slot
comma
r_struct
id|eeprom_eisa_slot_info
op_star
id|es
)paren
(brace
r_int
r_int
id|id
suffix:semicolon
r_char
id|id_string
(braket
l_int|8
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|es-&gt;slot_info
op_amp
id|HPEE_SLOT_INFO_NO_READID
)paren
)paren
(brace
multiline_comment|/* try to read the id of the board in the slot */
id|id
op_assign
id|le32_to_cpu
c_func
(paren
id|inl
c_func
(paren
id|SLOT2PORT
c_func
(paren
id|slot
)paren
op_plus
id|EPI
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0xffffffff
op_eq
id|id
)paren
(brace
multiline_comment|/* Maybe we didn&squot;t expect a card to be here... */
r_if
c_cond
(paren
id|es-&gt;eisa_slot_id
op_eq
l_int|0xffffffff
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* this board is not here or it does not &n;&t;&t;&t; * support readid &n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EISA slot %d a configured board was not detected (&quot;
comma
id|slot
)paren
suffix:semicolon
id|print_eisa_id
c_func
(paren
id|id_string
comma
id|es-&gt;eisa_slot_id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; expected %s)&bslash;n&quot;
comma
id|id_string
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|es-&gt;eisa_slot_id
op_ne
id|id
)paren
(brace
id|print_eisa_id
c_func
(paren
id|id_string
comma
id|id
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;EISA slot %d id mis-match: got %s&quot;
comma
id|slot
comma
id|id_string
)paren
suffix:semicolon
id|print_eisa_id
c_func
(paren
id|id_string
comma
id|es-&gt;eisa_slot_id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; expected %s &bslash;n&quot;
comma
id|id_string
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* now: we need to enable the board if &n;&t; * it supports enabling and run through&n;&t; * the port init sction if present&n;&t; * and finally record any interrupt polarity&n;&t; */
r_if
c_cond
(paren
id|es-&gt;slot_features
op_amp
id|HPEE_SLOT_FEATURES_ENABLE
)paren
(brace
multiline_comment|/* enable board */
id|outb
c_func
(paren
l_int|0x01
op_or
id|inb
c_func
(paren
id|SLOT2PORT
c_func
(paren
id|slot
)paren
op_plus
id|EPI
op_plus
l_int|4
)paren
comma
id|SLOT2PORT
c_func
(paren
id|slot
)paren
op_plus
id|EPI
op_plus
l_int|4
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|eisa_enumerator
r_int
id|eisa_enumerator
c_func
(paren
r_int
r_int
id|eeprom_addr
comma
r_struct
id|resource
op_star
id|io_parent
comma
r_struct
id|resource
op_star
id|mem_parent
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|eeprom_header
op_star
id|eh
suffix:semicolon
r_static
r_char
id|eeprom_buf
(braket
id|HPEE_MAX_LENGTH
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HPEE_MAX_LENGTH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|eeprom_buf
(braket
id|i
)braket
op_assign
id|gsc_readb
c_func
(paren
id|eeprom_addr
op_plus
id|i
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Enumerating EISA bus&bslash;n&quot;
)paren
suffix:semicolon
id|eh
op_assign
(paren
r_struct
id|eeprom_header
op_star
)paren
(paren
id|eeprom_buf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|eh-&gt;num_slots
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|eeprom_eisa_slot_info
op_star
id|es
suffix:semicolon
id|es
op_assign
(paren
r_struct
id|eeprom_eisa_slot_info
op_star
)paren
(paren
op_amp
id|eeprom_buf
(braket
id|HPEE_SLOT_INFO
c_func
(paren
id|i
)paren
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|init_slot
c_func
(paren
id|i
op_plus
l_int|1
comma
id|es
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|es-&gt;config_data_offset
OL
id|HPEE_MAX_LENGTH
)paren
(brace
r_if
c_cond
(paren
id|parse_slot_config
c_func
(paren
id|i
op_plus
l_int|1
comma
op_amp
id|eeprom_buf
(braket
id|es-&gt;config_data_offset
)braket
comma
id|es
comma
id|io_parent
comma
id|mem_parent
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;EISA EEPROM offset 0x%x out of range&bslash;n&quot;
comma
id|es-&gt;config_data_offset
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|eh-&gt;num_slots
suffix:semicolon
)brace
eof
