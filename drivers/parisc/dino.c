multiline_comment|/*&n;**&t;DINO manager&n;**&n;**&t;(c) Copyright 1999 Red Hat Software&n;**&t;(c) Copyright 1999 SuSE GmbH&n;**&t;(c) Copyright 1999,2000 Hewlett-Packard Company&n;**&t;(c) Copyright 2000 Grant Grundler&n;**&n;**&t;This program is free software; you can redistribute it and/or modify&n;**&t;it under the terms of the GNU General Public License as published by&n;**      the Free Software Foundation; either version 2 of the License, or&n;**      (at your option) any later version.&n;**&n;**&t;This module provides access to Dino PCI bus (config/IOport spaces)&n;**&t;and helps manage Dino IRQ lines.&n;**&n;**&t;Dino interrupt handling is a bit complicated.&n;**&t;Dino always writes to the broadcast EIR via irr0 for now.&n;**&t;(BIG WARNING: using broadcast EIR is a really bad thing for SMP!)&n;**&t;Only one processor interrupt is used for the 11 IRQ line &n;**&t;inputs to dino.&n;**&n;**&t;The different between Built-in Dino and Card-Mode&n;**&t;dino is in chip initialization and pci device initialization.&n;**&n;**&t;Linux drivers can only use Card-Mode Dino if pci devices I/O port&n;**&t;BARs are configured and used by the driver. Programming MMIO address &n;**&t;requires substantial knowledge of available Host I/O address ranges&n;**&t;is currently not supported.  Port/Config accessor functions are the&n;**&t;same. &quot;BIOS&quot; differences are handled within the existing routines.&n;*/
multiline_comment|/*&t;Changes :&n;**&t;2001-06-14 : Clement Moyroud (moyroudc@esiee.fr)&n;**&t;&t;- added support for the integrated RS232. &t;&n;*/
multiline_comment|/*&n;** TODO: create a virtual address for each Dino HPA.&n;**       GSC code might be able to do this since IODC data tells us&n;**       how many pages are used. PCI subsystem could (must?) do this&n;**       for PCI drivers devices which implement/use MMIO registers.&n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;&t;/* for struct irqaction */
macro_line|#include &lt;linux/spinlock.h&gt;&t;/* for spinlock_t and prototypes */
macro_line|#include &lt;asm/pdc.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &quot;gsc.h&quot;
DECL|macro|DINO_DEBUG
macro_line|#undef DINO_DEBUG
macro_line|#ifdef DINO_DEBUG
DECL|macro|DBG
mdefine_line|#define DBG(x...) printk(x)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(x...)
macro_line|#endif
multiline_comment|/*&n;** Config accessor functions only pass in the 8-bit bus number&n;** and not the 8-bit &quot;PCI Segment&quot; number. Each Dino will be&n;** assigned a PCI bus number based on &quot;when&quot; it&squot;s discovered.&n;**&n;** The &quot;secondary&quot; bus number is set to this before calling&n;** pci_scan_bus(). If any PPB&squot;s are present, the scan will&n;** discover them and update the &quot;secondary&quot; and &quot;subordinate&quot;&n;** fields in Dino&squot;s pci_bus structure.&n;**&n;** Changes in the configuration *will* result in a different&n;** bus number for each dino.&n;*/
DECL|macro|is_card_dino
mdefine_line|#define is_card_dino(id) ((id)-&gt;hw_type == HPHW_A_DMA)
DECL|macro|DINO_IAR0
mdefine_line|#define DINO_IAR0&t;&t;0x004
DECL|macro|DINO_IODC_ADDR
mdefine_line|#define DINO_IODC_ADDR&t;&t;0x008
DECL|macro|DINO_IODC_DATA_0
mdefine_line|#define DINO_IODC_DATA_0&t;0x008
DECL|macro|DINO_IODC_DATA_1
mdefine_line|#define DINO_IODC_DATA_1&t;0x008
DECL|macro|DINO_IRR0
mdefine_line|#define DINO_IRR0&t;&t;0x00C
DECL|macro|DINO_IAR1
mdefine_line|#define DINO_IAR1&t;&t;0x010
DECL|macro|DINO_IRR1
mdefine_line|#define DINO_IRR1&t;&t;0x014
DECL|macro|DINO_IMR
mdefine_line|#define DINO_IMR&t;&t;0x018
DECL|macro|DINO_IPR
mdefine_line|#define DINO_IPR&t;&t;0x01C
DECL|macro|DINO_TOC_ADDR
mdefine_line|#define DINO_TOC_ADDR&t;&t;0x020
DECL|macro|DINO_ICR
mdefine_line|#define DINO_ICR&t;&t;0x024
DECL|macro|DINO_ILR
mdefine_line|#define DINO_ILR&t;&t;0x028
DECL|macro|DINO_IO_COMMAND
mdefine_line|#define DINO_IO_COMMAND&t;&t;0x030
DECL|macro|DINO_IO_STATUS
mdefine_line|#define DINO_IO_STATUS&t;&t;0x034
DECL|macro|DINO_IO_CONTROL
mdefine_line|#define DINO_IO_CONTROL&t;&t;0x038
DECL|macro|DINO_IO_GSC_ERR_RESP
mdefine_line|#define DINO_IO_GSC_ERR_RESP&t;0x040
DECL|macro|DINO_IO_ERR_INFO
mdefine_line|#define DINO_IO_ERR_INFO&t;0x044
DECL|macro|DINO_IO_PCI_ERR_RESP
mdefine_line|#define DINO_IO_PCI_ERR_RESP&t;0x048
DECL|macro|DINO_IO_FBB_EN
mdefine_line|#define DINO_IO_FBB_EN&t;&t;0x05c
DECL|macro|DINO_IO_ADDR_EN
mdefine_line|#define DINO_IO_ADDR_EN&t;&t;0x060
DECL|macro|DINO_PCI_ADDR
mdefine_line|#define DINO_PCI_ADDR&t;&t;0x064
DECL|macro|DINO_CONFIG_DATA
mdefine_line|#define DINO_CONFIG_DATA&t;0x068
DECL|macro|DINO_IO_DATA
mdefine_line|#define DINO_IO_DATA&t;&t;0x06c
DECL|macro|DINO_MEM_DATA
mdefine_line|#define DINO_MEM_DATA&t;&t;0x070&t;/* Dino 3.x only */
DECL|macro|DINO_GSC2X_CONFIG
mdefine_line|#define DINO_GSC2X_CONFIG&t;0x7b4
DECL|macro|DINO_GMASK
mdefine_line|#define DINO_GMASK&t;&t;0x800
DECL|macro|DINO_PAMR
mdefine_line|#define DINO_PAMR&t;&t;0x804
DECL|macro|DINO_PAPR
mdefine_line|#define DINO_PAPR&t;&t;0x808
DECL|macro|DINO_DAMODE
mdefine_line|#define DINO_DAMODE&t;&t;0x80c
DECL|macro|DINO_PCICMD
mdefine_line|#define DINO_PCICMD&t;&t;0x810
DECL|macro|DINO_PCISTS
mdefine_line|#define DINO_PCISTS&t;&t;0x814
DECL|macro|DINO_MLTIM
mdefine_line|#define DINO_MLTIM&t;&t;0x81c
DECL|macro|DINO_BRDG_FEAT
mdefine_line|#define DINO_BRDG_FEAT&t;&t;0x820
DECL|macro|DINO_PCIROR
mdefine_line|#define DINO_PCIROR&t;&t;0x824
DECL|macro|DINO_PCIWOR
mdefine_line|#define DINO_PCIWOR&t;&t;0x828
DECL|macro|DINO_TLTIM
mdefine_line|#define DINO_TLTIM&t;&t;0x830
DECL|macro|DINO_IRQS
mdefine_line|#define DINO_IRQS 11&t;&t;/* bits 0-10 are architected */
DECL|macro|DINO_IRR_MASK
mdefine_line|#define DINO_IRR_MASK&t;0x5ff&t;/* only 10 bits are implemented */
DECL|macro|DINO_MASK_IRQ
mdefine_line|#define DINO_MASK_IRQ(x)&t;(1&lt;&lt;(x))
DECL|macro|PCIINTA
mdefine_line|#define PCIINTA   0x001
DECL|macro|PCIINTB
mdefine_line|#define PCIINTB   0x002
DECL|macro|PCIINTC
mdefine_line|#define PCIINTC   0x004
DECL|macro|PCIINTD
mdefine_line|#define PCIINTD   0x008
DECL|macro|PCIINTE
mdefine_line|#define PCIINTE   0x010
DECL|macro|PCIINTF
mdefine_line|#define PCIINTF   0x020
DECL|macro|GSCEXTINT
mdefine_line|#define GSCEXTINT 0x040
multiline_comment|/* #define xxx       0x080 - bit 7 is &quot;default&quot; */
multiline_comment|/* #define xxx    0x100 - bit 8 not used */
multiline_comment|/* #define xxx    0x200 - bit 9 not used */
DECL|macro|RS232INT
mdefine_line|#define RS232INT  0x400
DECL|struct|dino_device
r_struct
id|dino_device
(brace
DECL|member|hba
r_struct
id|pci_hba_data
id|hba
suffix:semicolon
multiline_comment|/* &squot;C&squot; inheritance - must be first */
DECL|member|dinosaur_pen
id|spinlock_t
id|dinosaur_pen
suffix:semicolon
DECL|member|txn_addr
r_int
r_int
id|txn_addr
suffix:semicolon
multiline_comment|/* EIR addr to generate interrupt */
DECL|member|txn_data
id|u32
id|txn_data
suffix:semicolon
multiline_comment|/* EIR data assign to each dino */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* Virtual IRQ dino uses */
DECL|member|dino_region
r_struct
id|irq_region
op_star
id|dino_region
suffix:semicolon
multiline_comment|/* region for this Dino */
DECL|member|imr
id|u32
id|imr
suffix:semicolon
multiline_comment|/* IRQ&squot;s which are enabled */
macro_line|#ifdef DINO_DEBUG
DECL|member|dino_irr0
r_int
r_int
id|dino_irr0
suffix:semicolon
multiline_comment|/* save most recent IRQ line stat */
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* Looks nice and keeps the compiler happy */
DECL|macro|DINO_DEV
mdefine_line|#define DINO_DEV(d) ((struct dino_device *) d)
multiline_comment|/*&n; * Dino Configuration Space Accessor Functions&n; */
DECL|macro|DINO_CFG_TOK
mdefine_line|#define DINO_CFG_TOK(bus,dfn,pos) ((u32) ((bus)&lt;&lt;16 | (dfn)&lt;&lt;8 | (pos)))
DECL|function|dino_cfg_read
r_static
r_int
id|dino_cfg_read
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_int
r_int
id|devfn
comma
r_int
id|where
comma
r_int
id|size
comma
id|u32
op_star
id|val
)paren
(brace
r_struct
id|dino_device
op_star
id|d
op_assign
id|DINO_DEV
c_func
(paren
id|parisc_walk_tree
c_func
(paren
id|bus-&gt;dev
)paren
)paren
suffix:semicolon
id|u32
id|local_bus
op_assign
(paren
id|bus-&gt;parent
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|0
suffix:colon
id|bus-&gt;secondary
suffix:semicolon
id|u32
id|v
op_assign
id|DINO_CFG_TOK
c_func
(paren
id|local_bus
comma
id|devfn
comma
id|where
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
r_int
r_int
id|base_addr
op_assign
id|d-&gt;hba.base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|d-&gt;dinosaur_pen
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* tell HW which CFG address */
id|gsc_writel
c_func
(paren
id|v
comma
id|base_addr
op_plus
id|DINO_PCI_ADDR
)paren
suffix:semicolon
multiline_comment|/* generate cfg read cycle */
r_if
c_cond
(paren
id|size
op_eq
l_int|1
)paren
(brace
op_star
id|val
op_assign
id|gsc_readb
c_func
(paren
id|base_addr
op_plus
id|DINO_CONFIG_DATA
op_plus
(paren
id|where
op_amp
l_int|3
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|size
op_eq
l_int|2
)paren
(brace
op_star
id|val
op_assign
id|le16_to_cpu
c_func
(paren
id|gsc_readw
c_func
(paren
id|base_addr
op_plus
id|DINO_CONFIG_DATA
op_plus
(paren
id|where
op_amp
l_int|2
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|size
op_eq
l_int|4
)paren
(brace
op_star
id|val
op_assign
id|le32_to_cpu
c_func
(paren
id|gsc_readl
c_func
(paren
id|base_addr
op_plus
id|DINO_CONFIG_DATA
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|d-&gt;dinosaur_pen
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Dino address stepping &quot;feature&quot;:&n; * When address stepping, Dino attempts to drive the bus one cycle too soon&n; * even though the type of cycle (config vs. MMIO) might be different. &n; * The read of Ven/Prod ID is harmless and avoids Dino&squot;s address stepping.&n; */
DECL|function|dino_cfg_write
r_static
r_int
id|dino_cfg_write
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_int
r_int
id|devfn
comma
r_int
id|where
comma
r_int
id|size
comma
id|u32
id|val
)paren
(brace
r_struct
id|dino_device
op_star
id|d
op_assign
id|DINO_DEV
c_func
(paren
id|parisc_walk_tree
c_func
(paren
id|bus-&gt;dev
)paren
)paren
suffix:semicolon
id|u32
id|local_bus
op_assign
(paren
id|bus-&gt;parent
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|0
suffix:colon
id|bus-&gt;secondary
suffix:semicolon
id|u32
id|v
op_assign
id|DINO_CFG_TOK
c_func
(paren
id|local_bus
comma
id|devfn
comma
id|where
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
r_int
r_int
id|base_addr
op_assign
id|d-&gt;hba.base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|d-&gt;dinosaur_pen
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* avoid address stepping feature */
id|gsc_writel
c_func
(paren
id|v
op_amp
l_int|0xffffff00
comma
id|base_addr
op_plus
id|DINO_PCI_ADDR
)paren
suffix:semicolon
id|gsc_readl
c_func
(paren
id|base_addr
op_plus
id|DINO_CONFIG_DATA
)paren
suffix:semicolon
multiline_comment|/* tell HW which CFG address */
id|gsc_writel
c_func
(paren
id|v
comma
id|base_addr
op_plus
id|DINO_PCI_ADDR
)paren
suffix:semicolon
multiline_comment|/* generate cfg read cycle */
r_if
c_cond
(paren
id|size
op_eq
l_int|1
)paren
(brace
id|gsc_writeb
c_func
(paren
id|val
comma
id|base_addr
op_plus
id|DINO_CONFIG_DATA
op_plus
(paren
id|where
op_amp
l_int|3
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|size
op_eq
l_int|2
)paren
(brace
id|gsc_writew
c_func
(paren
id|cpu_to_le16
c_func
(paren
id|val
)paren
comma
id|base_addr
op_plus
id|DINO_CONFIG_DATA
op_plus
(paren
id|where
op_amp
l_int|2
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|size
op_eq
l_int|4
)paren
(brace
id|gsc_writel
c_func
(paren
id|cpu_to_le32
c_func
(paren
id|val
)paren
comma
id|base_addr
op_plus
id|DINO_CONFIG_DATA
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|d-&gt;dinosaur_pen
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|dino_cfg_ops
r_static
r_struct
id|pci_ops
id|dino_cfg_ops
op_assign
(brace
dot
id|read
op_assign
id|dino_cfg_read
comma
dot
id|write
op_assign
id|dino_cfg_write
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Dino &quot;I/O Port&quot; Space Accessor Functions&n; *&n; * Many PCI devices don&squot;t require use of I/O port space (eg Tulip,&n; * NCR720) since they export the same registers to both MMIO and&n; * I/O port space.  Performance is going to stink if drivers use&n; * I/O port instead of MMIO.&n; */
DECL|macro|cpu_to_le8
mdefine_line|#define cpu_to_le8(x) (x)
DECL|macro|le8_to_cpu
mdefine_line|#define le8_to_cpu(x) (x)
DECL|macro|DINO_PORT_IN
mdefine_line|#define DINO_PORT_IN(type, size, mask) &bslash;&n;static u##size dino_in##size (struct pci_hba_data *d, u16 addr) &bslash;&n;{ &bslash;&n;&t;u##size v; &bslash;&n;&t;unsigned long flags; &bslash;&n;&t;spin_lock_irqsave(&amp;(DINO_DEV(d)-&gt;dinosaur_pen), flags); &bslash;&n;&t;/* tell HW which IO Port address */ &bslash;&n;&t;gsc_writel((u32) addr, d-&gt;base_addr + DINO_PCI_ADDR); &bslash;&n;&t;/* generate I/O PORT read cycle */ &bslash;&n;&t;v = gsc_read##type(d-&gt;base_addr+DINO_IO_DATA+(addr&amp;mask)); &bslash;&n;&t;spin_unlock_irqrestore(&amp;(DINO_DEV(d)-&gt;dinosaur_pen), flags); &bslash;&n;&t;return le##size##_to_cpu(v); &bslash;&n;}
id|DINO_PORT_IN
c_func
(paren
id|b
comma
l_int|8
comma
l_int|3
)paren
id|DINO_PORT_IN
c_func
(paren
id|w
comma
l_int|16
comma
l_int|2
)paren
id|DINO_PORT_IN
c_func
(paren
id|l
comma
l_int|32
comma
l_int|0
)paren
DECL|macro|DINO_PORT_OUT
mdefine_line|#define DINO_PORT_OUT(type, size, mask) &bslash;&n;static void dino_out##size (struct pci_hba_data *d, u16 addr, u##size val) &bslash;&n;{ &bslash;&n;&t;unsigned long flags; &bslash;&n;&t;spin_lock_irqsave(&amp;(DINO_DEV(d)-&gt;dinosaur_pen), flags); &bslash;&n;&t;/* tell HW which IO port address */ &bslash;&n;&t;gsc_writel((u32) addr, d-&gt;base_addr + DINO_PCI_ADDR); &bslash;&n;&t;/* generate cfg write cycle */ &bslash;&n;&t;gsc_write##type(cpu_to_le##size(val), d-&gt;base_addr+DINO_IO_DATA+(addr&amp;mask)); &bslash;&n;&t;spin_unlock_irqrestore(&amp;(DINO_DEV(d)-&gt;dinosaur_pen), flags); &bslash;&n;}
id|DINO_PORT_OUT
c_func
(paren
id|b
comma
l_int|8
comma
l_int|3
)paren
id|DINO_PORT_OUT
c_func
(paren
id|w
comma
l_int|16
comma
l_int|2
)paren
id|DINO_PORT_OUT
c_func
(paren
id|l
comma
l_int|32
comma
l_int|0
)paren
DECL|variable|dino_port_ops
r_struct
id|pci_port_ops
id|dino_port_ops
op_assign
(brace
dot
id|inb
op_assign
id|dino_in8
comma
dot
id|inw
op_assign
id|dino_in16
comma
dot
id|inl
op_assign
id|dino_in32
comma
dot
id|outb
op_assign
id|dino_out8
comma
dot
id|outw
op_assign
id|dino_out16
comma
dot
id|outl
op_assign
id|dino_out32
)brace
suffix:semicolon
r_static
r_void
DECL|function|dino_mask_irq
id|dino_mask_irq
c_func
(paren
r_void
op_star
id|irq_dev
comma
r_int
id|irq
)paren
(brace
r_struct
id|dino_device
op_star
id|dino_dev
op_assign
id|DINO_DEV
c_func
(paren
id|irq_dev
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(0x%p, %d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq_dev
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|irq_dev
op_logical_or
id|irq
OG
id|DINO_IRQS
op_logical_or
id|irq
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(0x%lx, %d) - not a dino irq?&bslash;n&quot;
comma
id|__FUNCTION__
comma
(paren
r_int
)paren
id|irq_dev
comma
id|irq
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;** Clear the matching bit in the IMR register&n;&t;&t;*/
id|dino_dev-&gt;imr
op_and_assign
op_complement
(paren
id|DINO_MASK_IRQ
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
id|dino_dev-&gt;imr
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_IMR
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|dino_unmask_irq
id|dino_unmask_irq
c_func
(paren
r_void
op_star
id|irq_dev
comma
r_int
id|irq
)paren
(brace
r_struct
id|dino_device
op_star
id|dino_dev
op_assign
id|DINO_DEV
c_func
(paren
id|irq_dev
)paren
suffix:semicolon
id|u32
id|tmp
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(0x%p, %d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq_dev
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|irq_dev
op_logical_or
id|irq
OG
id|DINO_IRQS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(): %d not a dino irq?&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* set the matching bit in the IMR register */
id|dino_dev-&gt;imr
op_or_assign
id|DINO_MASK_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/* used in dino_isr() */
id|gsc_writel
c_func
(paren
id|dino_dev-&gt;imr
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_IMR
)paren
suffix:semicolon
multiline_comment|/* Emulate &quot;Level Triggered&quot; Interrupt&n;&t;** Basically, a driver is blowing it if the IRQ line is asserted&n;&t;** while the IRQ is disabled.  But tulip.c seems to do that....&n;&t;** Give &squot;em a kluge award and a nice round of applause!&n;&t;**&n;&t;** The gsc_write will generate an interrupt which invokes dino_isr().&n;&t;** dino_isr() will read IPR and find nothing. But then catch this&n;&t;** when it also checks ILR.&n;&t;*/
id|tmp
op_assign
id|gsc_readl
c_func
(paren
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_ILR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
id|DINO_MASK_IRQ
c_func
(paren
id|irq
)paren
)paren
(brace
id|DBG
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(): IRQ asserted! (ILR 0x%x)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tmp
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
id|dino_dev-&gt;txn_data
comma
id|dino_dev-&gt;txn_addr
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|dino_enable_irq
id|dino_enable_irq
c_func
(paren
r_void
op_star
id|irq_dev
comma
r_int
id|irq
)paren
(brace
r_struct
id|dino_device
op_star
id|dino_dev
op_assign
id|DINO_DEV
c_func
(paren
id|irq_dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** clear pending IRQ bits&n;&t;**&n;&t;** This does NOT change ILR state!&n;&t;** See comments in dino_unmask_irq() for ILR usage.&n;&t;*/
id|gsc_readl
c_func
(paren
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_IPR
)paren
suffix:semicolon
id|dino_unmask_irq
c_func
(paren
id|irq_dev
comma
id|irq
)paren
suffix:semicolon
)brace
DECL|variable|dino_irq_ops
r_static
r_struct
id|irq_region_ops
id|dino_irq_ops
op_assign
(brace
dot
id|disable_irq
op_assign
id|dino_mask_irq
comma
multiline_comment|/* ??? */
dot
id|enable_irq
op_assign
id|dino_enable_irq
comma
dot
id|mask_irq
op_assign
id|dino_mask_irq
comma
dot
id|unmask_irq
op_assign
id|dino_unmask_irq
)brace
suffix:semicolon
multiline_comment|/*&n; * Handle a Processor interrupt generated by Dino.&n; *&n; * ilr_loop counter is a kluge to prevent a &quot;stuck&quot; IRQ line from&n; * wedging the CPU. Could be removed or made optional at some point.&n; */
r_static
r_void
DECL|function|dino_isr
id|dino_isr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|intr_dev
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|dino_device
op_star
id|dino_dev
op_assign
id|DINO_DEV
c_func
(paren
id|intr_dev
)paren
suffix:semicolon
id|u32
id|mask
suffix:semicolon
r_int
id|ilr_loop
op_assign
l_int|100
suffix:semicolon
r_extern
r_void
id|do_irq
c_func
(paren
r_struct
id|irqaction
op_star
id|a
comma
r_int
id|i
comma
r_struct
id|pt_regs
op_star
id|p
)paren
suffix:semicolon
multiline_comment|/* read and acknowledge pending interrupts */
macro_line|#ifdef DINO_DEBUG
id|dino_dev-&gt;dino_irr0
op_assign
macro_line|#endif
id|mask
op_assign
id|gsc_readl
c_func
(paren
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_IRR0
)paren
op_amp
id|DINO_IRR_MASK
suffix:semicolon
id|ilr_again
suffix:colon
r_while
c_loop
(paren
id|mask
)paren
(brace
r_int
id|irq
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Perform a binary search on set bits.&n;&t;&t; * `Less than Fatal&squot; and PS2 interrupts aren&squot;t supported.&n;&t;&t; */
r_if
c_cond
(paren
id|mask
op_amp
l_int|0xf
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x3
)paren
(brace
id|irq
op_assign
(paren
id|mask
op_amp
l_int|0x1
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* PCI INT A, B */
)brace
r_else
(brace
id|irq
op_assign
(paren
id|mask
op_amp
l_int|0x4
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* PCI INT C, D */
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x30
)paren
(brace
id|irq
op_assign
(paren
id|mask
op_amp
l_int|0x10
)paren
ques
c_cond
l_int|4
suffix:colon
l_int|5
suffix:semicolon
multiline_comment|/* PCI INT E, F */
)brace
r_else
(brace
id|irq
op_assign
(paren
id|mask
op_amp
l_int|0x40
)paren
ques
c_cond
l_int|6
suffix:colon
l_int|10
suffix:semicolon
multiline_comment|/* GSC, RS232 */
)brace
)brace
id|mask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|irq
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(%x, %p) mask %0x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
comma
id|intr_dev
comma
id|mask
)paren
suffix:semicolon
id|do_irq
c_func
(paren
op_amp
id|dino_dev-&gt;dino_region-&gt;action
(braket
id|irq
)braket
comma
id|dino_dev-&gt;dino_region-&gt;data.irqbase
op_plus
id|irq
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/* Support for level triggered IRQ lines.&n;&t;** &n;&t;** Dropping this support would make this routine *much* faster.&n;&t;** But since PCI requires level triggered IRQ line to share lines...&n;&t;** device drivers may assume lines are level triggered (and not&n;&t;** edge triggered like EISA/ISA can be).&n;&t;*/
id|mask
op_assign
id|gsc_readl
c_func
(paren
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_ILR
)paren
op_amp
id|dino_dev-&gt;imr
suffix:semicolon
r_if
c_cond
(paren
id|mask
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|ilr_loop
OG
l_int|0
)paren
r_goto
id|ilr_again
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dino %lx: stuck interrupt %d&bslash;n&quot;
comma
id|dino_dev-&gt;hba.base_addr
comma
id|mask
)paren
suffix:semicolon
)brace
)brace
DECL|function|dino_choose_irq
r_static
r_int
id|dino_choose_irq
c_func
(paren
r_struct
id|parisc_device
op_star
id|dev
)paren
(brace
r_int
id|irq
op_assign
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|dev-&gt;id.sversion
)paren
(brace
r_case
l_int|0x00084
suffix:colon
id|irq
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* PS/2 */
r_case
l_int|0x0008c
suffix:colon
id|irq
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* RS232 */
r_case
l_int|0x00096
suffix:colon
id|irq
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* PS/2 */
)brace
r_return
id|irq
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|dino_bios_init
id|dino_bios_init
c_func
(paren
r_void
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;dino_bios_init&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * dino_card_setup - Set up the memory space for a Dino in card mode.&n; * @bus: the bus under this dino&n; *&n; * Claim an 8MB chunk of unused IO space and call the generic PCI routines&n; * to set up the addresses of the devices on this bus.&n; */
DECL|macro|_8MB
mdefine_line|#define _8MB 0x00800000UL
r_static
r_void
id|__init
DECL|function|dino_card_setup
id|dino_card_setup
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_int
r_int
id|base_addr
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|dino_device
op_star
id|dino_dev
op_assign
id|DINO_DEV
c_func
(paren
id|parisc_walk_tree
c_func
(paren
id|bus-&gt;dev
)paren
)paren
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
id|res
op_assign
op_amp
id|dino_dev-&gt;hba.lmmio_space
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
r_if
c_cond
(paren
id|ccio_allocate_resource
c_func
(paren
id|dino_dev-&gt;hba.dev
comma
id|res
comma
id|_8MB
comma
(paren
r_int
r_int
)paren
l_int|0xfffffffff0000000UL
op_or
id|_8MB
comma
l_int|0xffffffffffffffffUL
op_amp
op_complement
id|_8MB
comma
id|_8MB
comma
l_int|NULL
comma
l_int|NULL
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Dino: Failed to allocate memory region&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|bus-&gt;resource
(braket
l_int|1
)braket
op_assign
id|res
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|0
)braket
op_assign
op_amp
(paren
id|dino_dev-&gt;hba.io_space
)paren
suffix:semicolon
multiline_comment|/* Now tell dino what range it has */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|31
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|res-&gt;start
op_eq
(paren
l_int|0xfffffffff0000000UL
op_or
id|i
op_star
id|_8MB
)paren
)paren
r_break
suffix:semicolon
)brace
id|gsc_writel
c_func
(paren
l_int|1
op_lshift
id|i
comma
id|base_addr
op_plus
id|DINO_IO_ADDR_EN
)paren
suffix:semicolon
id|pci_bus_assign_resources
c_func
(paren
id|bus
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|dino_card_fixup
id|dino_card_fixup
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
id|u32
id|irq_pin
suffix:semicolon
multiline_comment|/*&n;&t;** REVISIT: card-mode PCI-PCI expansion chassis do exist.&n;&t;**         Not sure they were ever productized.&n;&t;**         Die here since we&squot;ll die later in dino_inb() anyway.&n;&t;*/
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_BRIDGE_PCI
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Card-Mode Dino: PCI-PCI Bridge not supported&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Set Latency Timer to 0xff (not a shared bus)&n;&t;** Set CACHELINE_SIZE.&n;&t;*/
id|dino_cfg_write
c_func
(paren
id|dev-&gt;bus
comma
id|dev-&gt;devfn
comma
id|PCI_CACHE_LINE_SIZE
comma
l_int|16
comma
l_int|0xff00
op_or
id|L1_CACHE_BYTES
op_div
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Program INT_LINE for card-mode devices.&n;&t;** The cards are hardwired according to this algorithm.&n;&t;** And it doesn&squot;t matter if PPB&squot;s are present or not since&n;&t;** the IRQ lines bypass the PPB.&n;&t;**&n;&t;** &quot;-1&quot; converts INTA-D (1-4) to PCIINTA-D (0-3) range.&n;&t;** The additional &quot;-1&quot; adjusts for skewing the IRQ&lt;-&gt;slot.&n;&t;*/
id|dino_cfg_read
c_func
(paren
id|dev-&gt;bus
comma
id|dev-&gt;devfn
comma
id|PCI_INTERRUPT_PIN
comma
l_int|8
comma
op_amp
id|irq_pin
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
(paren
id|irq_pin
op_plus
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
op_minus
l_int|1
)paren
op_mod
l_int|4
suffix:semicolon
multiline_comment|/* Shouldn&squot;t really need to do this but it&squot;s in case someone tries&n;&t;** to bypass PCI services and look at the card themselves.&n;&t;*/
id|dino_cfg_write
c_func
(paren
id|dev-&gt;bus
comma
id|dev-&gt;devfn
comma
id|PCI_INTERRUPT_LINE
comma
l_int|8
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|dino_fixup_bus
id|dino_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
r_struct
id|list_head
op_star
id|ln
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_struct
id|dino_device
op_star
id|dino_dev
op_assign
id|DINO_DEV
c_func
(paren
id|parisc_walk_tree
c_func
(paren
id|bus-&gt;dev
)paren
)paren
suffix:semicolon
r_int
id|port_base
op_assign
id|HBA_PORT_BASE
c_func
(paren
id|dino_dev-&gt;hba.hba_num
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(0x%p) bus %d sysdata 0x%p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|bus
comma
id|bus-&gt;secondary
comma
id|bus-&gt;dev-&gt;platform_data
)paren
suffix:semicolon
multiline_comment|/* Firmware doesn&squot;t set up card-mode dino, so we have to */
r_if
c_cond
(paren
id|is_card_dino
c_func
(paren
op_amp
id|dino_dev-&gt;hba.dev-&gt;id
)paren
)paren
id|dino_card_setup
c_func
(paren
id|bus
comma
id|dino_dev-&gt;hba.base_addr
)paren
suffix:semicolon
multiline_comment|/* If this is a PCI-PCI Bridge, read the window registers etc */
r_if
c_cond
(paren
id|bus-&gt;self
)paren
id|pci_read_bridge_bases
c_func
(paren
id|bus
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|ln
comma
op_amp
id|bus-&gt;devices
)paren
(brace
r_int
id|i
suffix:semicolon
id|dev
op_assign
id|pci_dev_b
c_func
(paren
id|ln
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_card_dino
c_func
(paren
op_amp
id|dino_dev-&gt;hba.dev-&gt;id
)paren
)paren
id|dino_card_fixup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** P2PB&squot;s only have 2 BARs, no IRQs.&n;&t;&t;** I&squot;d like to just ignore them for now.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_BRIDGE_PCI
)paren
r_continue
suffix:semicolon
multiline_comment|/* Adjust the I/O Port space addresses */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_NUM_RESOURCES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
op_amp
id|dev-&gt;resource
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
(brace
id|res-&gt;start
op_or_assign
id|port_base
suffix:semicolon
id|res-&gt;end
op_or_assign
id|port_base
suffix:semicolon
)brace
macro_line|#ifdef __LP64__
multiline_comment|/* Sign Extend MMIO addresses */
r_else
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_MEM
)paren
(brace
id|res-&gt;start
op_or_assign
l_int|0xffffffff00000000UL
suffix:semicolon
id|res-&gt;end
op_or_assign
l_int|0xffffffff00000000UL
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* Adjust INT_LINE for that busses region */
id|dev-&gt;irq
op_assign
id|dino_dev-&gt;dino_region-&gt;data.irqbase
op_plus
id|dev-&gt;irq
suffix:semicolon
)brace
)brace
DECL|variable|dino_bios_ops
r_struct
id|pci_bios_ops
id|dino_bios_ops
op_assign
(brace
dot
id|init
op_assign
id|dino_bios_init
comma
dot
id|fixup_bus
op_assign
id|dino_fixup_bus
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Initialise a DINO controller chip&n; */
r_static
r_void
id|__init
DECL|function|dino_card_init
id|dino_card_init
c_func
(paren
r_struct
id|dino_device
op_star
id|dino_dev
)paren
(brace
id|u32
id|brdg_feat
op_assign
l_int|0x00784e05
suffix:semicolon
id|gsc_writel
c_func
(paren
l_int|0x00000000
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_GMASK
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
l_int|0x00000001
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_IO_FBB_EN
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
l_int|0x00000000
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_ICR
)paren
suffix:semicolon
macro_line|#if 1
multiline_comment|/* REVISIT - should be a runtime check (eg if (CPU_IS_PCX_L) ...) */
multiline_comment|/*&n;&t;** PCX-L processors don&squot;t support XQL like Dino wants it.&n;&t;** PCX-L2 ignore XQL signal and it doesn&squot;t matter.&n;&t;*/
id|brdg_feat
op_and_assign
op_complement
l_int|0x4
suffix:semicolon
multiline_comment|/* UXQL */
macro_line|#endif
id|gsc_writel
c_func
(paren
id|brdg_feat
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_BRDG_FEAT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Don&squot;t enable address decoding until we know which I/O range&n;&t;** currently is available from the host. Only affects MMIO&n;&t;** and not I/O port space.&n;&t;*/
id|gsc_writel
c_func
(paren
l_int|0x00000000
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_IO_ADDR_EN
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
l_int|0x00000000
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_DAMODE
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
l_int|0x00222222
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_PCIROR
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
l_int|0x00222222
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_PCIWOR
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
l_int|0x00000040
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_MLTIM
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
l_int|0x00000080
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_IO_CONTROL
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
l_int|0x0000008c
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_TLTIM
)paren
suffix:semicolon
multiline_comment|/* Disable PAMR before writing PAPR */
id|gsc_writel
c_func
(paren
l_int|0x0000007e
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_PAMR
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
l_int|0x0000007f
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_PAPR
)paren
suffix:semicolon
id|gsc_writel
c_func
(paren
l_int|0x00000000
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_PAMR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Dino ERS encourages enabling FBB (0x6f).&n;&t;** We can&squot;t until we know *all* devices below us can support it.&n;&t;** (Something in device configuration header tells us).&n;&t;*/
id|gsc_writel
c_func
(paren
l_int|0x0000004f
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_PCICMD
)paren
suffix:semicolon
multiline_comment|/* Somewhere, the PCI spec says give devices 1 second&n;&t;** to recover from the #RESET being de-asserted.&n;&t;** Experience shows most devices only need 10ms.&n;&t;** This short-cut speeds up booting significantly.&n;&t;*/
id|mdelay
c_func
(paren
id|pci_post_reset_delay
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|dino_bridge_init
id|dino_bridge_init
c_func
(paren
r_struct
id|dino_device
op_star
id|dino_dev
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|io_addr
comma
id|bpos
suffix:semicolon
r_int
id|result
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
multiline_comment|/*&n;&t; * Decoding IO_ADDR_EN only works for Built-in Dino&n;&t; * since PDC has already initialized this.&n;&t; */
id|io_addr
op_assign
id|gsc_readl
c_func
(paren
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_IO_ADDR_EN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io_addr
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: No PCI devices enabled.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_for
c_loop
(paren
id|bpos
op_assign
l_int|0
suffix:semicolon
(paren
id|io_addr
op_amp
(paren
l_int|1
op_lshift
id|bpos
)paren
)paren
op_eq
l_int|0
suffix:semicolon
id|bpos
op_increment
)paren
suffix:semicolon
id|res
op_assign
op_amp
id|dino_dev-&gt;hba.lmmio_space
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
id|res-&gt;start
op_assign
(paren
r_int
r_int
)paren
(paren
r_int
r_int
)paren
(paren
l_int|0xf0000000
op_or
(paren
id|bpos
op_lshift
l_int|23
)paren
)paren
suffix:semicolon
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
l_int|8
op_star
l_int|1024
op_star
l_int|1024
op_minus
l_int|1
suffix:semicolon
id|result
op_assign
id|ccio_request_resource
c_func
(paren
id|dino_dev-&gt;hba.dev
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: failed to claim PCI Bus address space!&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dino_common_init
r_static
r_int
id|__init
id|dino_common_init
c_func
(paren
r_struct
id|parisc_device
op_star
id|dev
comma
r_struct
id|dino_device
op_star
id|dino_dev
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|status
suffix:semicolon
id|u32
id|eim
suffix:semicolon
r_struct
id|gsc_irq
id|gsc_irq
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
id|pcibios_register_hba
c_func
(paren
op_amp
id|dino_dev-&gt;hba
)paren
suffix:semicolon
id|pci_bios
op_assign
op_amp
id|dino_bios_ops
suffix:semicolon
multiline_comment|/* used by pci_scan_bus() */
id|pci_port
op_assign
op_amp
id|dino_port_ops
suffix:semicolon
multiline_comment|/*&n;&t;** Note: SMP systems can make use of IRR1/IAR1 registers&n;&t;**   But it won&squot;t buy much performance except in very&n;&t;**   specific applications/configurations. Note Dino&n;&t;**   still only has 11 IRQ input lines - just map some of them&n;&t;**   to a different processor.&n;&t;*/
id|dino_dev-&gt;irq
op_assign
id|gsc_alloc_irq
c_func
(paren
op_amp
id|gsc_irq
)paren
suffix:semicolon
id|dino_dev-&gt;txn_addr
op_assign
id|gsc_irq.txn_addr
suffix:semicolon
id|dino_dev-&gt;txn_data
op_assign
id|gsc_irq.txn_data
suffix:semicolon
id|eim
op_assign
(paren
(paren
id|u32
)paren
id|gsc_irq.txn_addr
)paren
op_or
id|gsc_irq.txn_data
suffix:semicolon
multiline_comment|/* &n;&t;** Dino needs a PA &quot;IRQ&quot; to get a processor&squot;s attention.&n;&t;** arch/parisc/kernel/irq.c returns an EIRR bit.&n;&t;*/
r_if
c_cond
(paren
id|dino_dev-&gt;irq
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: gsc_alloc_irq() failed&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|status
op_assign
id|request_irq
c_func
(paren
id|dino_dev-&gt;irq
comma
id|dino_isr
comma
l_int|0
comma
id|name
comma
id|dino_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: request_irq() failed with %d&bslash;n&quot;
comma
id|name
comma
id|status
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Tell generic interrupt support we have 11 bits which need&n;&t;** be checked in the interrupt handler.&n;&t;*/
id|dino_dev-&gt;dino_region
op_assign
id|alloc_irq_region
c_func
(paren
id|DINO_IRQS
comma
op_amp
id|dino_irq_ops
comma
id|name
comma
id|dino_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|dino_dev-&gt;dino_region
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: alloc_irq_region() failed&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Support the serial port which is sometimes attached on built-in&n;&t; * Dino / Cujo chips.&n;&t; */
id|fixup_child_irqs
c_func
(paren
id|dev
comma
id|dino_dev-&gt;dino_region-&gt;data.irqbase
comma
id|dino_choose_irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** This enables DINO to generate interrupts when it sees&n;&t;** any of its inputs *change*. Just asserting an IRQ&n;&t;** before it&squot;s enabled (ie unmasked) isn&squot;t good enough.&n;&t;*/
id|gsc_writel
c_func
(paren
id|eim
comma
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_IAR0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Some platforms don&squot;t clear Dino&squot;s IRR0 register at boot time.&n;&t;** Reading will clear it now.&n;&t;*/
id|gsc_readl
c_func
(paren
id|dino_dev-&gt;hba.base_addr
op_plus
id|DINO_IRR0
)paren
suffix:semicolon
multiline_comment|/* allocate I/O Port resource region */
id|res
op_assign
op_amp
id|dino_dev-&gt;hba.io_space
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;id.hversion
op_eq
l_int|0x680
op_logical_or
id|is_card_dino
c_func
(paren
op_amp
id|dev-&gt;id
)paren
)paren
(brace
id|res-&gt;name
op_assign
l_string|&quot;Dino I/O Port&quot;
suffix:semicolon
id|dino_dev-&gt;hba.lmmio_space.name
op_assign
l_string|&quot;Dino LMMIO&quot;
suffix:semicolon
)brace
r_else
(brace
id|res-&gt;name
op_assign
l_string|&quot;Cujo I/O Port&quot;
suffix:semicolon
id|dino_dev-&gt;hba.lmmio_space.name
op_assign
l_string|&quot;Cujo LMMIO&quot;
suffix:semicolon
)brace
id|res-&gt;start
op_assign
id|HBA_PORT_BASE
c_func
(paren
id|dino_dev-&gt;hba.hba_num
)paren
suffix:semicolon
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
(paren
id|HBA_PORT_SPACE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_IO
suffix:semicolon
multiline_comment|/* do not mark it busy ! */
r_if
c_cond
(paren
id|request_resource
c_func
(paren
op_amp
id|ioport_resource
comma
id|res
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: request I/O Port region failed 0x%lx/%lx (hpa 0x%lx)&bslash;n&quot;
comma
id|name
comma
id|res-&gt;start
comma
id|res-&gt;end
comma
id|dino_dev-&gt;hba.base_addr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|CUJO_RAVEN_ADDR
mdefine_line|#define CUJO_RAVEN_ADDR&t;&t;0xfffffffff1000000UL
DECL|macro|CUJO_FIREHAWK_ADDR
mdefine_line|#define CUJO_FIREHAWK_ADDR&t;0xfffffffff1604000UL
DECL|macro|CUJO_RAVEN_BADPAGE
mdefine_line|#define CUJO_RAVEN_BADPAGE&t;0x01003000UL
DECL|macro|CUJO_FIREHAWK_BADPAGE
mdefine_line|#define CUJO_FIREHAWK_BADPAGE&t;0x01607000UL
DECL|variable|dino_vers
r_static
r_const
r_char
op_star
id|dino_vers
(braket
)braket
op_assign
(brace
l_string|&quot;2.0&quot;
comma
l_string|&quot;2.1&quot;
comma
l_string|&quot;3.0&quot;
comma
l_string|&quot;3.1&quot;
)brace
suffix:semicolon
DECL|variable|cujo_vers
r_static
r_const
r_char
op_star
id|cujo_vers
(braket
)braket
op_assign
(brace
l_string|&quot;1.0&quot;
comma
l_string|&quot;2.0&quot;
)brace
suffix:semicolon
r_void
id|ccio_cujo20_fixup
c_func
(paren
r_struct
id|parisc_device
op_star
id|dev
comma
id|u32
id|iovp
)paren
suffix:semicolon
multiline_comment|/*&n;** Determine if dino should claim this chip (return 0) or not (return 1).&n;** If so, initialize the chip appropriately (card-mode vs bridge mode).&n;** Much of the initialization is common though.&n;*/
r_static
r_int
id|__init
DECL|function|dino_driver_callback
id|dino_driver_callback
c_func
(paren
r_struct
id|parisc_device
op_star
id|dev
)paren
(brace
r_struct
id|dino_device
op_star
id|dino_dev
suffix:semicolon
singleline_comment|// Dino specific control struct
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
l_string|&quot;Dino&quot;
suffix:semicolon
r_int
id|is_cujo
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_card_dino
c_func
(paren
op_amp
id|dev-&gt;id
)paren
)paren
(brace
id|version
op_assign
l_string|&quot;3.x (card mode)&quot;
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dev-&gt;id.hversion
op_eq
l_int|0x680
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;id.hversion_rev
OL
l_int|4
)paren
(brace
id|version
op_assign
id|dino_vers
(braket
id|dev-&gt;id.hversion_rev
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
id|name
op_assign
l_string|&quot;Cujo&quot;
suffix:semicolon
id|is_cujo
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;id.hversion_rev
OL
l_int|2
)paren
(brace
id|version
op_assign
id|cujo_vers
(braket
id|dev-&gt;id.hversion_rev
)braket
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;%s version %s found at 0x%lx&bslash;n&quot;
comma
id|name
comma
id|version
comma
id|dev-&gt;hpa
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|dev-&gt;dev.name
comma
r_sizeof
(paren
id|dev-&gt;dev.name
)paren
comma
l_string|&quot;%s version %s&quot;
comma
id|name
comma
id|version
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
c_func
(paren
id|dev-&gt;hpa
comma
id|PAGE_SIZE
comma
id|name
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;DINO: Hey! Someone took my MMIO space (0x%ld)!&bslash;n&quot;
comma
id|dev-&gt;hpa
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Check for bugs */
r_if
c_cond
(paren
id|is_cujo
op_logical_and
id|dev-&gt;id.hversion_rev
op_eq
l_int|1
)paren
(brace
macro_line|#ifdef CONFIG_IOMMU_CCIO
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Enabling Cujo 2.0 bug workaround&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;hpa
op_eq
(paren
r_int
r_int
)paren
id|CUJO_RAVEN_ADDR
)paren
(brace
id|ccio_cujo20_fixup
c_func
(paren
id|dev-&gt;parent
comma
id|CUJO_RAVEN_BADPAGE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;hpa
op_eq
(paren
r_int
r_int
)paren
id|CUJO_FIREHAWK_ADDR
)paren
(brace
id|ccio_cujo20_fixup
c_func
(paren
id|dev-&gt;parent
comma
id|CUJO_FIREHAWK_BADPAGE
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Don&squot;t recognise Cujo at address 0x%lx, not enabling workaround&bslash;n&quot;
comma
id|dev-&gt;hpa
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|is_cujo
op_logical_and
op_logical_neg
id|is_card_dino
c_func
(paren
op_amp
id|dev-&gt;id
)paren
op_logical_and
id|dev-&gt;id.hversion_rev
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;The GSCtoPCI (Dino hrev %d) bus converter found may exhibit&bslash;n&quot;
l_string|&quot;data corruption.  See Service Note Numbers: A4190A-01, A4191A-01.&bslash;n&quot;
l_string|&quot;Systems shipped after Aug 20, 1997 will not exhibit this problem.&bslash;n&quot;
l_string|&quot;Models affected: C180, C160, C160L, B160L, and B132L workstations.&bslash;n&bslash;n&quot;
comma
id|dev-&gt;id.hversion_rev
)paren
suffix:semicolon
multiline_comment|/* REVISIT: why are C200/C240 listed in the README table but not&n;**   &quot;Models affected&quot;? Could be an omission in the original literature.&n;*/
)brace
id|dino_dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dino_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dino_dev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dino_init_chip - couldn&squot;t alloc dino_device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dino_dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dino_device
)paren
)paren
suffix:semicolon
id|dino_dev-&gt;hba.dev
op_assign
id|dev
suffix:semicolon
id|dino_dev-&gt;hba.base_addr
op_assign
id|dev-&gt;hpa
suffix:semicolon
multiline_comment|/* faster access */
id|dino_dev-&gt;hba.lmmio_space_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CPU addrs == bus addrs */
id|dino_dev-&gt;dinosaur_pen
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|dino_dev-&gt;hba.iommu
op_assign
id|ccio_get_iommu
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_card_dino
c_func
(paren
op_amp
id|dev-&gt;id
)paren
)paren
(brace
id|dino_card_init
c_func
(paren
id|dino_dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|dino_bridge_init
c_func
(paren
id|dino_dev
comma
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dino_common_init
c_func
(paren
id|dev
comma
id|dino_dev
comma
id|name
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|dev-&gt;dev.platform_data
op_assign
id|dino_dev
suffix:semicolon
multiline_comment|/*&n;&t;** It&squot;s not used to avoid chicken/egg problems&n;&t;** with configuration accessor functions.&n;&t;*/
id|dino_dev-&gt;hba.hba_bus
op_assign
id|pci_scan_bus_parented
c_func
(paren
op_amp
id|dev-&gt;dev
comma
id|dino_dev-&gt;hba.hba_num
comma
op_amp
id|dino_cfg_ops
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Normally, we would just test sversion.  But the Elroy PCI adapter has&n; * the same sversion as Dino, so we have to check hversion as well.&n; * Unfortunately, the J2240 PDC reports the wrong hversion for the first&n; * Dino, so we have to test for Dino, Cujo and Dino-in-a-J2240.&n; */
DECL|variable|dino_tbl
r_static
r_struct
id|parisc_device_id
id|dino_tbl
(braket
)braket
op_assign
(brace
(brace
id|HPHW_A_DMA
comma
id|HVERSION_REV_ANY_ID
comma
l_int|0x004
comma
l_int|0x0009D
)brace
comma
multiline_comment|/* Card-mode Dino. */
(brace
id|HPHW_A_DMA
comma
id|HVERSION_REV_ANY_ID
comma
l_int|0x444
comma
l_int|0x08080
)brace
comma
multiline_comment|/* Same card in a 715.  Bug? */
(brace
id|HPHW_BRIDGE
comma
id|HVERSION_REV_ANY_ID
comma
l_int|0x680
comma
l_int|0xa
)brace
comma
multiline_comment|/* Bridge-mode Dino */
(brace
id|HPHW_BRIDGE
comma
id|HVERSION_REV_ANY_ID
comma
l_int|0x682
comma
l_int|0xa
)brace
comma
multiline_comment|/* Bridge-mode Cujo */
(brace
id|HPHW_BRIDGE
comma
id|HVERSION_REV_ANY_ID
comma
l_int|0x05d
comma
l_int|0xa
)brace
comma
multiline_comment|/* Dino in a J2240 */
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
DECL|variable|dino_driver
r_static
r_struct
id|parisc_driver
id|dino_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Dino&quot;
comma
dot
id|id_table
op_assign
id|dino_tbl
comma
dot
id|probe
op_assign
id|dino_driver_callback
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * One time initialization to let the world know Dino is here.&n; * This is the only routine which is NOT static.&n; * Must be called exactly once before pci_init().&n; */
DECL|function|dino_init
r_int
id|__init
id|dino_init
c_func
(paren
r_void
)paren
(brace
id|register_parisc_driver
c_func
(paren
op_amp
id|dino_driver
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
