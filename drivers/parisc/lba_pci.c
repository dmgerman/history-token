multiline_comment|/*&n;**  PCI Lower Bus Adapter (LBA) manager&n;**&n;**&t;(c) Copyright 1999,2000 Grant Grundler&n;**&t;(c) Copyright 1999,2000 Hewlett-Packard Company&n;**&n;**&t;This program is free software; you can redistribute it and/or modify&n;**&t;it under the terms of the GNU General Public License as published by&n;**      the Free Software Foundation; either version 2 of the License, or&n;**      (at your option) any later version.&n;**&n;**&n;** This module primarily provides access to PCI bus (config/IOport&n;** spaces) on platforms with an SBA/LBA chipset. A/B/C/J/L/N-class&n;** with 4 digit model numbers - eg C3000 (and A400...sigh).&n;**&n;** LBA driver isn&squot;t as simple as the Dino driver because:&n;**   (a) this chip has substantial bug fixes between revisions&n;**       (Only one Dino bug has a software workaround :^(  )&n;**   (b) has more options which we don&squot;t (yet) support (DMA hints, OLARD)&n;**   (c) IRQ support lives in the I/O SAPIC driver (not with PCI driver)&n;**   (d) play nicely with both PAT and &quot;Legacy&quot; PA-RISC firmware (PDC).&n;**       (dino only deals with &quot;Legacy&quot; PDC)&n;**&n;** LBA driver passes the I/O SAPIC HPA to the I/O SAPIC driver.&n;** (I/O SAPIC is integratd in the LBA chip).&n;**&n;** FIXME: Add support to SBA and LBA drivers for DMA hint sets&n;** FIXME: Add support for PCI card hot-plug (OLARD).&n;*/
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/init.h&gt;&t;&t;/* for __init and __devinit */
multiline_comment|/* #define PCI_DEBUG&t;enable ASSERT */
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;&t;&t;/* for struct irq_region support */
macro_line|#include &lt;asm/pdc.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;&t;/* for register_parisc_driver() stuff */
macro_line|#include &lt;asm/parisc-device.h&gt;
macro_line|#include &lt;asm/iosapic.h&gt;&t;/* for iosapic_register() */
macro_line|#include &lt;asm/io.h&gt;&t;&t;/* read/write stuff */
macro_line|#ifndef TRUE
DECL|macro|TRUE
mdefine_line|#define TRUE (1 == 1)
DECL|macro|FALSE
mdefine_line|#define FALSE (1 == 0)
macro_line|#endif
DECL|macro|DEBUG_LBA
macro_line|#undef DEBUG_LBA&t;/* general stuff */
DECL|macro|DEBUG_LBA_PORT
macro_line|#undef DEBUG_LBA_PORT&t;/* debug I/O Port access */
DECL|macro|DEBUG_LBA_CFG
macro_line|#undef DEBUG_LBA_CFG&t;/* debug Config Space Access (ie PCI Bus walk) */
DECL|macro|DEBUG_LBA_PAT
macro_line|#undef DEBUG_LBA_PAT&t;/* debug PCI Resource Mgt code - PDC PAT only */
DECL|macro|FBB_SUPPORT
macro_line|#undef FBB_SUPPORT&t;/* Fast Back-Back xfers - NOT READY YET */
macro_line|#ifdef DEBUG_LBA
DECL|macro|DBG
mdefine_line|#define DBG(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_LBA_PORT
DECL|macro|DBG_PORT
mdefine_line|#define DBG_PORT(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG_PORT
mdefine_line|#define DBG_PORT(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_LBA_CFG
DECL|macro|DBG_CFG
mdefine_line|#define DBG_CFG(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG_CFG
mdefine_line|#define DBG_CFG(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_LBA_PAT
DECL|macro|DBG_PAT
mdefine_line|#define DBG_PAT(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG_PAT
mdefine_line|#define DBG_PAT(x...)
macro_line|#endif
multiline_comment|/*&n;** Config accessor functions only pass in the 8-bit bus number and not&n;** the 8-bit &quot;PCI Segment&quot; number. Each LBA will be assigned a PCI bus&n;** number based on what firmware wrote into the scratch register.&n;**&n;** The &quot;secondary&quot; bus number is set to this before calling&n;** pci_register_ops(). If any PPB&squot;s are present, the scan will&n;** discover them and update the &quot;secondary&quot; and &quot;subordinate&quot;&n;** fields in the pci_bus structure.&n;**&n;** Changes in the configuration *may* result in a different&n;** bus number for each LBA depending on what firmware does.&n;*/
DECL|macro|MODULE_NAME
mdefine_line|#define MODULE_NAME &quot;lba&quot;
DECL|macro|LBA_FUNC_ID
mdefine_line|#define LBA_FUNC_ID&t;0x0000&t;/* function id */
DECL|macro|LBA_FCLASS
mdefine_line|#define LBA_FCLASS&t;0x0008&t;/* function class, bist, header, rev... */
DECL|macro|LBA_CAPABLE
mdefine_line|#define LBA_CAPABLE&t;0x0030&t;/* capabilities register */
DECL|macro|LBA_PCI_CFG_ADDR
mdefine_line|#define LBA_PCI_CFG_ADDR&t;0x0040&t;/* poke CFG address here */
DECL|macro|LBA_PCI_CFG_DATA
mdefine_line|#define LBA_PCI_CFG_DATA&t;0x0048&t;/* read or write data here */
DECL|macro|LBA_PMC_MTLT
mdefine_line|#define LBA_PMC_MTLT&t;0x0050&t;/* Firmware sets this - read only. */
DECL|macro|LBA_FW_SCRATCH
mdefine_line|#define LBA_FW_SCRATCH&t;0x0058&t;/* Firmware writes the PCI bus number here. */
DECL|macro|LBA_ERROR_ADDR
mdefine_line|#define LBA_ERROR_ADDR&t;0x0070&t;/* On error, address gets logged here */
DECL|macro|LBA_ARB_MASK
mdefine_line|#define LBA_ARB_MASK&t;0x0080&t;/* bit 0 enable arbitration. PAT/PDC enables */
DECL|macro|LBA_ARB_PRI
mdefine_line|#define LBA_ARB_PRI&t;0x0088&t;/* firmware sets this. */
DECL|macro|LBA_ARB_MODE
mdefine_line|#define LBA_ARB_MODE&t;0x0090&t;/* firmware sets this. */
DECL|macro|LBA_ARB_MTLT
mdefine_line|#define LBA_ARB_MTLT&t;0x0098&t;/* firmware sets this. */
DECL|macro|LBA_MOD_ID
mdefine_line|#define LBA_MOD_ID&t;0x0100&t;/* Module ID. PDC_PAT_CELL reports 4 */
DECL|macro|LBA_STAT_CTL
mdefine_line|#define LBA_STAT_CTL&t;0x0108&t;/* Status &amp; Control */
DECL|macro|LBA_BUS_RESET
mdefine_line|#define   LBA_BUS_RESET&t;&t;0x01&t;/*  Deassert PCI Bus Reset Signal */
DECL|macro|CLEAR_ERRLOG
mdefine_line|#define   CLEAR_ERRLOG&t;&t;0x10&t;/*  &quot;Clear Error Log&quot; cmd */
DECL|macro|CLEAR_ERRLOG_ENABLE
mdefine_line|#define   CLEAR_ERRLOG_ENABLE&t;0x20&t;/*  &quot;Clear Error Log&quot; Enable */
DECL|macro|HF_ENABLE
mdefine_line|#define   HF_ENABLE&t;0x40&t;/*    enable HF mode (default is -1 mode) */
DECL|macro|LBA_LMMIO_BASE
mdefine_line|#define LBA_LMMIO_BASE&t;0x0200&t;/* &lt; 4GB I/O address range */
DECL|macro|LBA_LMMIO_MASK
mdefine_line|#define LBA_LMMIO_MASK&t;0x0208
DECL|macro|LBA_GMMIO_BASE
mdefine_line|#define LBA_GMMIO_BASE&t;0x0210&t;/* &gt; 4GB I/O address range */
DECL|macro|LBA_GMMIO_MASK
mdefine_line|#define LBA_GMMIO_MASK&t;0x0218
DECL|macro|LBA_WLMMIO_BASE
mdefine_line|#define LBA_WLMMIO_BASE&t;0x0220&t;/* All &lt; 4GB ranges under the same *SBA* */
DECL|macro|LBA_WLMMIO_MASK
mdefine_line|#define LBA_WLMMIO_MASK&t;0x0228
DECL|macro|LBA_WGMMIO_BASE
mdefine_line|#define LBA_WGMMIO_BASE&t;0x0230&t;/* All &gt; 4GB ranges under the same *SBA* */
DECL|macro|LBA_WGMMIO_MASK
mdefine_line|#define LBA_WGMMIO_MASK&t;0x0238
DECL|macro|LBA_IOS_BASE
mdefine_line|#define LBA_IOS_BASE&t;0x0240&t;/* I/O port space for this LBA */
DECL|macro|LBA_IOS_MASK
mdefine_line|#define LBA_IOS_MASK&t;0x0248
DECL|macro|LBA_ELMMIO_BASE
mdefine_line|#define LBA_ELMMIO_BASE&t;0x0250&t;/* Extra LMMIO range */
DECL|macro|LBA_ELMMIO_MASK
mdefine_line|#define LBA_ELMMIO_MASK&t;0x0258
DECL|macro|LBA_EIOS_BASE
mdefine_line|#define LBA_EIOS_BASE&t;0x0260&t;/* Extra I/O port space */
DECL|macro|LBA_EIOS_MASK
mdefine_line|#define LBA_EIOS_MASK&t;0x0268
DECL|macro|LBA_DMA_CTL
mdefine_line|#define LBA_DMA_CTL&t;0x0278&t;/* firmware sets this */
DECL|macro|LBA_IBASE
mdefine_line|#define LBA_IBASE&t;0x0300&t;/* SBA DMA support */
DECL|macro|LBA_IMASK
mdefine_line|#define LBA_IMASK&t;0x0308
multiline_comment|/* FIXME: ignore DMA Hint stuff until we can measure performance */
DECL|macro|LBA_HINT_CFG
mdefine_line|#define LBA_HINT_CFG&t;0x0310
DECL|macro|LBA_HINT_BASE
mdefine_line|#define LBA_HINT_BASE&t;0x0380&t;/* 14 registers at every 8 bytes. */
multiline_comment|/* ERROR regs are needed for config cycle kluges */
DECL|macro|LBA_ERROR_CONFIG
mdefine_line|#define LBA_ERROR_CONFIG 0x0680
DECL|macro|LBA_SMART_MODE
mdefine_line|#define     LBA_SMART_MODE 0x20
DECL|macro|LBA_ERROR_STATUS
mdefine_line|#define LBA_ERROR_STATUS 0x0688
DECL|macro|LBA_ROPE_CTL
mdefine_line|#define LBA_ROPE_CTL     0x06A0
DECL|macro|LBA_IOSAPIC_BASE
mdefine_line|#define LBA_IOSAPIC_BASE&t;0x800 /* Offset of IRQ logic */
multiline_comment|/* non-postable I/O port space, densely packed */
macro_line|#ifdef __LP64__
DECL|macro|LBA_ASTRO_PORT_BASE
mdefine_line|#define LBA_ASTRO_PORT_BASE&t;(0xfffffffffee00000UL)
macro_line|#else
DECL|macro|LBA_ASTRO_PORT_BASE
mdefine_line|#define LBA_ASTRO_PORT_BASE&t;(0xfee00000UL)
macro_line|#endif
multiline_comment|/*&n;** lba_device: Per instance Elroy data structure&n;*/
DECL|struct|lba_device
r_struct
id|lba_device
(brace
DECL|member|hba
r_struct
id|pci_hba_data
id|hba
suffix:semicolon
DECL|member|lba_lock
id|spinlock_t
id|lba_lock
suffix:semicolon
DECL|member|iosapic_obj
r_void
op_star
id|iosapic_obj
suffix:semicolon
macro_line|#ifdef __LP64__
DECL|member|lmmio_base
r_int
r_int
id|lmmio_base
suffix:semicolon
multiline_comment|/* PA_VIEW - fixup MEM addresses */
DECL|member|gmmio_base
r_int
r_int
id|gmmio_base
suffix:semicolon
multiline_comment|/* PA_VIEW - Not used (yet) */
DECL|member|iop_base
r_int
r_int
id|iop_base
suffix:semicolon
multiline_comment|/* PA_VIEW - for IO port accessor funcs */
macro_line|#endif
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* state/functionality enabled */
DECL|member|hw_rev
r_int
id|hw_rev
suffix:semicolon
multiline_comment|/* HW revision of chip */
)brace
suffix:semicolon
DECL|variable|lba_t32
r_static
id|u32
id|lba_t32
suffix:semicolon
multiline_comment|/*&n;** lba &quot;flags&quot;&n;*/
DECL|macro|LBA_FLAG_NO_DMA_DURING_CFG
mdefine_line|#define LBA_FLAG_NO_DMA_DURING_CFG&t;0x01
DECL|macro|LBA_FLAG_SKIP_PROBE
mdefine_line|#define LBA_FLAG_SKIP_PROBE&t;0x10
multiline_comment|/* Tape Release 4 == hw_rev 5 */
DECL|macro|LBA_TR4PLUS
mdefine_line|#define LBA_TR4PLUS(d)      ((d)-&gt;hw_rev &gt; 0x4)
DECL|macro|LBA_DMA_DURING_CFG_DISABLED
mdefine_line|#define LBA_DMA_DURING_CFG_DISABLED(d) ((d)-&gt;flags &amp; LBA_FLAG_NO_DMA_DURING_CFG)
DECL|macro|LBA_SKIP_PROBE
mdefine_line|#define LBA_SKIP_PROBE(d) ((d)-&gt;flags &amp; LBA_FLAG_SKIP_PROBE)
multiline_comment|/* Looks nice and keeps the compiler happy */
DECL|macro|LBA_DEV
mdefine_line|#define LBA_DEV(d) ((struct lba_device *) (d))
multiline_comment|/*&n;** Only allow 8 subsidiary busses per LBA&n;** Problem is the PCI bus numbering is globally shared.&n;*/
DECL|macro|LBA_MAX_NUM_BUSES
mdefine_line|#define LBA_MAX_NUM_BUSES 8
multiline_comment|/************************************&n; * LBA register read and write support&n; *&n; * BE WARNED: register writes are posted.&n; *  (ie follow writes which must reach HW with a read)&n; */
DECL|macro|READ_U8
mdefine_line|#define READ_U8(addr)  __raw_readb(addr)
DECL|macro|READ_U16
mdefine_line|#define READ_U16(addr) __raw_readw(addr)
DECL|macro|READ_U32
mdefine_line|#define READ_U32(addr) __raw_readl(addr)
DECL|macro|WRITE_U8
mdefine_line|#define WRITE_U8(value, addr)  __raw_writeb(value, addr)
DECL|macro|WRITE_U16
mdefine_line|#define WRITE_U16(value, addr) __raw_writew(value, addr)
DECL|macro|WRITE_U32
mdefine_line|#define WRITE_U32(value, addr) __raw_writel(value, addr)
DECL|macro|READ_REG8
mdefine_line|#define READ_REG8(addr)  readb(addr)
DECL|macro|READ_REG16
mdefine_line|#define READ_REG16(addr) readw(addr)
DECL|macro|READ_REG32
mdefine_line|#define READ_REG32(addr) readl(addr)
DECL|macro|READ_REG64
mdefine_line|#define READ_REG64(addr) readq(addr)
DECL|macro|WRITE_REG8
mdefine_line|#define WRITE_REG8(value, addr)  writeb(value, addr)
DECL|macro|WRITE_REG16
mdefine_line|#define WRITE_REG16(value, addr) writew(value, addr)
DECL|macro|WRITE_REG32
mdefine_line|#define WRITE_REG32(value, addr) writel(value, addr)
DECL|macro|LBA_CFG_TOK
mdefine_line|#define LBA_CFG_TOK(bus,dfn) ((u32) ((bus)&lt;&lt;16 | (dfn)&lt;&lt;8))
DECL|macro|LBA_CFG_BUS
mdefine_line|#define LBA_CFG_BUS(tok)  ((u8) ((tok)&gt;&gt;16))
DECL|macro|LBA_CFG_DEV
mdefine_line|#define LBA_CFG_DEV(tok)  ((u8) ((tok)&gt;&gt;11) &amp; 0x1f)
DECL|macro|LBA_CFG_FUNC
mdefine_line|#define LBA_CFG_FUNC(tok) ((u8) ((tok)&gt;&gt;8 ) &amp; 0x7)
multiline_comment|/*&n;** Extract LBA (Rope) number from HPA&n;** REVISIT: 16 ropes for Stretch/Ike?&n;*/
DECL|macro|ROPES_PER_SBA
mdefine_line|#define ROPES_PER_SBA&t;8
DECL|macro|LBA_NUM
mdefine_line|#define LBA_NUM(x)    ((((unsigned long) x) &gt;&gt; 13) &amp; (ROPES_PER_SBA-1))
r_static
r_void
DECL|function|lba_dump_res
id|lba_dump_res
c_func
(paren
r_struct
id|resource
op_star
id|r
comma
r_int
id|d
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|r
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;(%p)&quot;
comma
id|r-&gt;parent
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|d
suffix:semicolon
id|i
suffix:semicolon
op_decrement
id|i
)paren
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%p [%lx,%lx]/%x&bslash;n&quot;
comma
id|r
comma
id|r-&gt;start
comma
id|r-&gt;end
comma
(paren
r_int
)paren
id|r-&gt;flags
)paren
suffix:semicolon
id|lba_dump_res
c_func
(paren
id|r-&gt;child
comma
id|d
op_plus
l_int|2
)paren
suffix:semicolon
id|lba_dump_res
c_func
(paren
id|r-&gt;sibling
comma
id|d
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** LBA rev 2.0, 2.1, 2.2, and 3.0 bus walks require a complex&n;** workaround for cfg cycles:&n;**&t;-- preserve  LBA state&n;**&t;-- LBA_FLAG_NO_DMA_DURING_CFG workaround&n;**&t;-- turn on smart mode&n;**&t;-- probe with config writes before doing config reads&n;**&t;-- check ERROR_STATUS&n;**&t;-- clear ERROR_STATUS&n;**&t;-- restore LBA state&n;**&n;** The workaround is only used for device discovery.&n;*/
r_static
r_int
DECL|function|lba_device_present
id|lba_device_present
c_func
(paren
id|u8
id|bus
comma
id|u8
id|dfn
comma
r_struct
id|lba_device
op_star
id|d
)paren
(brace
id|u8
id|first_bus
op_assign
id|d-&gt;hba.hba_bus-&gt;secondary
suffix:semicolon
id|u8
id|last_sub_bus
op_assign
id|d-&gt;hba.hba_bus-&gt;subordinate
suffix:semicolon
macro_line|#if 0
multiline_comment|/* FIXME - see below in this function */
id|u8
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|dfn
)paren
suffix:semicolon
id|u8
id|func
op_assign
id|PCI_FUNC
c_func
(paren
id|dfn
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|bus
op_ge
id|first_bus
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bus
op_le
id|last_sub_bus
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|bus
op_minus
id|first_bus
)paren
OL
id|LBA_MAX_NUM_BUSES
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bus
OL
id|first_bus
)paren
op_logical_or
(paren
id|bus
OG
id|last_sub_bus
)paren
op_logical_or
(paren
(paren
id|bus
op_minus
id|first_bus
)paren
op_ge
id|LBA_MAX_NUM_BUSES
)paren
)paren
(brace
multiline_comment|/* devices that fall into any of these cases won&squot;t get claimed */
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n;** FIXME: Need to implement code to fill the devices bitmap based&n;** on contents of the local pci_bus tree &quot;data base&quot;.&n;** pci_register_ops() walks the bus for us and builds the tree.&n;** For now, always do the config cycle.&n;*/
id|bus
op_sub_assign
id|first_bus
suffix:semicolon
r_return
(paren
(paren
(paren
id|d-&gt;devices
(braket
id|bus
)braket
(braket
id|dev
)braket
)paren
op_rshift
id|func
)paren
op_amp
l_int|0x1
)paren
suffix:semicolon
macro_line|#else
r_return
id|TRUE
suffix:semicolon
macro_line|#endif
)brace
DECL|macro|LBA_CFG_SETUP
mdefine_line|#define LBA_CFG_SETUP(d, tok) {&t;&t;&t;&t;&bslash;&n;    /* Save contents of error config register.  */&t;&t;&t;&bslash;&n;    error_config = READ_REG32(d-&gt;hba.base_addr + LBA_ERROR_CONFIG);&t;&t;&bslash;&n;&bslash;&n;    /* Save contents of status control register.  */&t;&t;&t;&bslash;&n;    status_control = READ_REG32(d-&gt;hba.base_addr + LBA_STAT_CTL);&t;&t;&bslash;&n;&bslash;&n;    /* For LBA rev 2.0, 2.1, 2.2, and 3.0, we must disable DMA&t;&t;&bslash;&n;    ** arbitration for full bus walks.&t;&t;&t;&t;&t;&bslash;&n;    */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (LBA_DMA_DURING_CFG_DISABLED(d)) {&t;&t;&t;&t;&bslash;&n;&t;/* Save contents of arb mask register. */&t;&t;&t;&bslash;&n;&t;arb_mask = READ_REG32(d-&gt;hba.base_addr + LBA_ARB_MASK);&t;&t;&bslash;&n;&bslash;&n;&t;/*&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * Turn off all device arbitration bits (i.e. everything&t;&bslash;&n;&t; * except arbitration enable bit).&t;&t;&t;&t;&bslash;&n;&t; */&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;WRITE_REG32(0x1, d-&gt;hba.base_addr + LBA_ARB_MASK);&t;&t;&t;&bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Set the smart mode bit so that master aborts don&squot;t cause&t;&t;&bslash;&n;     * LBA to go into PCI fatal mode (required).&t;&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(error_config | LBA_SMART_MODE, d-&gt;hba.base_addr + LBA_ERROR_CONFIG);&t;&bslash;&n;}
DECL|macro|LBA_CFG_PROBE
mdefine_line|#define LBA_CFG_PROBE(d, tok) {&t;&t;&t;&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Setup Vendor ID write and read back the address register&t;&t;&bslash;&n;     * to make sure that LBA is the bus master.&t;&t;&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(tok | PCI_VENDOR_ID, (d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Read address register to ensure that LBA is the bus master,&t;&bslash;&n;     * which implies that DMA traffic has stopped when DMA arb is off.&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    lba_t32 = READ_REG32((d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);&t;&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Generate a cfg write cycle (will have no affect on&t;&t;&bslash;&n;     * Vendor ID register since read-only).&t;&t;&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(~0, (d)-&gt;hba.base_addr + LBA_PCI_CFG_DATA);&t;&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Make sure write has completed before proceeding further,&t;&t;&bslash;&n;     * i.e. before setting clear enable.&t;&t;&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    lba_t32 = READ_REG32((d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);&t;&t;&bslash;&n;}
multiline_comment|/*&n; * HPREVISIT:&n; *   -- Can&squot;t tell if config cycle got the error.&n; *&n; *&t;&t;OV bit is broken until rev 4.0, so can&squot;t use OV bit and&n; *&t;&t;LBA_ERROR_LOG_ADDR to tell if error belongs to config cycle.&n; *&n; *&t;&t;As of rev 4.0, no longer need the error check.&n; *&n; *   -- Even if we could tell, we still want to return -1&n; *&t;for **ANY** error (not just master abort).&n; *&n; *   -- Only clear non-fatal errors (we don&squot;t want to bring&n; *&t;LBA out of pci-fatal mode).&n; *&n; *&t;&t;Actually, there is still a race in which&n; *&t;&t;we could be clearing a fatal error.  We will&n; *&t;&t;live with this during our initial bus walk&n; *&t;&t;until rev 4.0 (no driver activity during&n; *&t;&t;initial bus walk).  The initial bus walk&n; *&t;&t;has race conditions concerning the use of&n; *&t;&t;smart mode as well.&n; */
DECL|macro|LBA_MASTER_ABORT_ERROR
mdefine_line|#define LBA_MASTER_ABORT_ERROR 0xc
DECL|macro|LBA_FATAL_ERROR
mdefine_line|#define LBA_FATAL_ERROR 0x10
DECL|macro|LBA_CFG_MASTER_ABORT_CHECK
mdefine_line|#define LBA_CFG_MASTER_ABORT_CHECK(d, base, tok, error) {&t;&t;&bslash;&n;    u32 error_status = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Set clear enable (CE) bit. Unset by HW when new&t;&t;&t;&bslash;&n;     * errors are logged -- LBA HW ERS section 14.3.3).&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(status_control | CLEAR_ERRLOG_ENABLE, base + LBA_STAT_CTL); &bslash;&n;    error_status = READ_REG32(base + LBA_ERROR_STATUS);&t;&t;&bslash;&n;    if ((error_status &amp; 0x1f) != 0) {&t;&t;&t;&t;&t;&bslash;&n;&t;/*&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * Fail the config read request.&t;&t;&t;&t;&bslash;&n;&t; */&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;error = 1;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((error_status &amp; LBA_FATAL_ERROR) == 0) {&t;&t;&t;&bslash;&n;&t;    /*&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;     * Clear error status (if fatal bit not set) by setting&t;&bslash;&n;&t;     * clear error log bit (CL).&t;&t;&t;&t;&bslash;&n;&t;     */&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    WRITE_REG32(status_control | CLEAR_ERRLOG, base + LBA_STAT_CTL); &bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|LBA_CFG_TR4_ADDR_SETUP
mdefine_line|#define LBA_CFG_TR4_ADDR_SETUP(d, addr) &bslash;&n;    WRITE_REG32(((addr) &amp; ~3), (d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR)
DECL|macro|LBA_CFG_ADDR_SETUP
mdefine_line|#define LBA_CFG_ADDR_SETUP(d, addr) {&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(((addr) &amp; ~3), (d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * HPREVISIT:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     *       --&t;Potentially could skip this once DMA bug fixed.&t;&t;&bslash;&n;     *&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Read address register to ensure that LBA is the bus master,&t;&bslash;&n;     * which implies that DMA traffic has stopped when DMA arb is off.&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    lba_t32 = READ_REG32((d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);&t;&t;&bslash;&n;}
DECL|macro|LBA_CFG_RESTORE
mdefine_line|#define LBA_CFG_RESTORE(d, base) {&t;&t;&t;&t;&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Restore status control register (turn off clear enable).&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(status_control, base + LBA_STAT_CTL);&t;&t;&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Restore error config register (turn off smart mode).&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(error_config, base + LBA_ERROR_CONFIG);&t;&t;&t;&bslash;&n;    if (LBA_DMA_DURING_CFG_DISABLED(d)) {&t;&t;&t;&t;&bslash;&n;&t;/*&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * Restore arb mask register (reenables DMA arbitration).&t;&bslash;&n;&t; */&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;WRITE_REG32(arb_mask, base + LBA_ARB_MASK);&t;&t;&t;&bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
r_static
r_int
r_int
DECL|function|lba_rd_cfg
id|lba_rd_cfg
c_func
(paren
r_struct
id|lba_device
op_star
id|d
comma
id|u32
id|tok
comma
id|u8
id|reg
comma
id|u32
id|size
)paren
(brace
id|u32
id|data
op_assign
op_complement
l_int|0
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|u32
id|arb_mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used by LBA_CFG_SETUP/RESTORE */
id|u32
id|error_config
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used by LBA_CFG_SETUP/RESTORE */
id|u32
id|status_control
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used by LBA_CFG_SETUP/RESTORE */
id|ASSERT
c_func
(paren
(paren
id|size
op_eq
r_sizeof
(paren
id|u8
)paren
)paren
op_logical_or
(paren
id|size
op_eq
r_sizeof
(paren
id|u16
)paren
)paren
op_logical_or
(paren
id|size
op_eq
r_sizeof
(paren
id|u32
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|size
op_ne
r_sizeof
(paren
id|u8
)paren
)paren
op_logical_and
(paren
id|size
op_ne
r_sizeof
(paren
id|u16
)paren
)paren
op_logical_and
(paren
id|size
op_ne
r_sizeof
(paren
id|u32
)paren
)paren
)paren
(brace
r_return
id|data
suffix:semicolon
)brace
id|LBA_CFG_SETUP
c_func
(paren
id|d
comma
id|tok
)paren
suffix:semicolon
id|LBA_CFG_PROBE
c_func
(paren
id|d
comma
id|tok
)paren
suffix:semicolon
id|LBA_CFG_MASTER_ABORT_CHECK
c_func
(paren
id|d
comma
id|d-&gt;hba.base_addr
comma
id|tok
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|LBA_CFG_ADDR_SETUP
c_func
(paren
id|d
comma
id|tok
op_or
id|reg
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
r_sizeof
(paren
id|u8
)paren
suffix:colon
id|data
op_assign
(paren
id|u32
)paren
id|READ_REG8
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
op_plus
(paren
id|reg
op_amp
l_int|3
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
r_sizeof
(paren
id|u16
)paren
suffix:colon
id|data
op_assign
(paren
id|u32
)paren
id|READ_REG16
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
op_plus
(paren
id|reg
op_amp
l_int|2
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
r_sizeof
(paren
id|u32
)paren
suffix:colon
id|data
op_assign
id|READ_REG32
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* leave data as -1 */
)brace
)brace
id|LBA_CFG_RESTORE
c_func
(paren
id|d
comma
id|d-&gt;hba.base_addr
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|function|lba_cfg_read
r_static
r_int
id|lba_cfg_read
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_int
r_int
id|devfn
comma
r_int
id|pos
comma
r_int
id|size
comma
id|u32
op_star
id|data
)paren
(brace
r_struct
id|lba_device
op_star
id|d
op_assign
id|LBA_DEV
c_func
(paren
id|parisc_walk_tree
c_func
(paren
id|bus-&gt;dev
)paren
)paren
suffix:semicolon
id|u32
id|local_bus
op_assign
(paren
id|bus-&gt;parent
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|0
suffix:colon
id|bus-&gt;secondary
suffix:semicolon
id|u32
id|tok
op_assign
id|LBA_CFG_TOK
c_func
(paren
id|local_bus
comma
id|devfn
)paren
suffix:semicolon
multiline_comment|/* FIXME: B2K/C3600 workaround is always use old method... */
multiline_comment|/* if (!LBA_TR4PLUS(d) &amp;&amp; !LBA_SKIP_PROBE(d)) */
(brace
multiline_comment|/* original - Generate config cycle on broken elroy&n;&t;&t;  with risk we will miss PCI bus errors. */
op_star
id|data
op_assign
id|lba_rd_cfg
c_func
(paren
id|d
comma
id|tok
comma
id|pos
comma
id|size
)paren
suffix:semicolon
id|DBG_CFG
c_func
(paren
l_string|&quot;%s(%x+%2x) -&gt; 0x%x (a)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tok
comma
id|pos
comma
op_star
id|data
)paren
suffix:semicolon
r_return
op_star
id|data
op_eq
op_complement
l_int|0UL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|LBA_SKIP_PROBE
c_func
(paren
id|d
)paren
op_logical_and
(paren
op_logical_neg
id|lba_device_present
c_func
(paren
id|bus-&gt;secondary
comma
id|devfn
comma
id|d
)paren
)paren
)paren
(brace
id|DBG_CFG
c_func
(paren
l_string|&quot;%s(%x+%2x) -&gt; -1 (b)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tok
comma
id|pos
)paren
suffix:semicolon
multiline_comment|/* either don&squot;t want to look or know device isn&squot;t present. */
op_star
id|data
op_assign
op_complement
l_int|0U
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Basic Algorithm&n;&t;** Should only get here on fully working LBA rev.&n;&t;** This is how simple the code should have been.&n;&t;*/
id|LBA_CFG_TR4_ADDR_SETUP
c_func
(paren
id|d
comma
id|tok
op_or
id|pos
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|1
suffix:colon
op_star
(paren
id|u8
op_star
)paren
id|data
op_assign
id|READ_REG8
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
(paren
id|u16
op_star
)paren
id|data
op_assign
id|READ_REG16
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
id|u32
op_star
)paren
id|data
op_assign
id|READ_REG32
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DBG_CFG
c_func
(paren
l_string|&quot;%s(%x+%2x) -&gt; 0x%x (c)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tok
comma
id|pos
comma
op_star
id|data
)paren
suffix:semicolon
r_return
op_star
id|data
op_eq
op_complement
l_int|0U
suffix:semicolon
)brace
r_static
r_void
DECL|function|lba_wr_cfg
id|lba_wr_cfg
c_func
(paren
r_struct
id|lba_device
op_star
id|d
comma
id|u32
id|tok
comma
id|u8
id|reg
comma
id|u32
id|data
comma
id|u32
id|size
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|u32
id|arb_mask
op_assign
l_int|0
suffix:semicolon
id|u32
id|error_config
op_assign
l_int|0
suffix:semicolon
id|u32
id|status_control
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|size
op_eq
r_sizeof
(paren
id|u8
)paren
)paren
op_logical_or
(paren
id|size
op_eq
r_sizeof
(paren
id|u16
)paren
)paren
op_logical_or
(paren
id|size
op_eq
r_sizeof
(paren
id|u32
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|size
op_ne
r_sizeof
(paren
id|u8
)paren
)paren
op_logical_and
(paren
id|size
op_ne
r_sizeof
(paren
id|u16
)paren
)paren
op_logical_and
(paren
id|size
op_ne
r_sizeof
(paren
id|u32
)paren
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|LBA_CFG_SETUP
c_func
(paren
id|d
comma
id|tok
)paren
suffix:semicolon
id|LBA_CFG_ADDR_SETUP
c_func
(paren
id|d
comma
id|tok
op_or
id|reg
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
r_sizeof
(paren
id|u8
)paren
suffix:colon
id|WRITE_REG8
c_func
(paren
(paren
id|u8
)paren
id|data
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
op_plus
(paren
id|reg
op_amp
l_int|3
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
r_sizeof
(paren
id|u16
)paren
suffix:colon
id|WRITE_REG16
c_func
(paren
(paren
id|u8
)paren
id|data
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
op_plus
(paren
id|reg
op_amp
l_int|2
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
r_sizeof
(paren
id|u32
)paren
suffix:colon
id|WRITE_REG32
c_func
(paren
id|data
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|LBA_CFG_MASTER_ABORT_CHECK
c_func
(paren
id|d
comma
id|d-&gt;hba.base_addr
comma
id|tok
comma
id|error
)paren
suffix:semicolon
id|LBA_CFG_RESTORE
c_func
(paren
id|d
comma
id|d-&gt;hba.base_addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * LBA 4.0 config write code implements non-postable semantics&n; * by doing a read of CONFIG ADDR after the write.&n; */
DECL|function|lba_cfg_write
r_static
r_int
id|lba_cfg_write
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_int
r_int
id|devfn
comma
r_int
id|pos
comma
r_int
id|size
comma
id|u32
id|data
)paren
(brace
r_struct
id|lba_device
op_star
id|d
op_assign
id|LBA_DEV
c_func
(paren
id|parisc_walk_tree
c_func
(paren
id|bus-&gt;dev
)paren
)paren
suffix:semicolon
id|u32
id|local_bus
op_assign
(paren
id|bus-&gt;parent
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|0
suffix:colon
id|bus-&gt;secondary
suffix:semicolon
id|u32
id|tok
op_assign
id|LBA_CFG_TOK
c_func
(paren
id|local_bus
comma
id|devfn
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|tok
op_amp
l_int|0xff
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pos
OL
l_int|0x100
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|LBA_TR4PLUS
c_func
(paren
id|d
)paren
op_logical_and
op_logical_neg
id|LBA_SKIP_PROBE
c_func
(paren
id|d
)paren
)paren
(brace
multiline_comment|/* Original Workaround */
id|lba_wr_cfg
c_func
(paren
id|d
comma
id|tok
comma
id|pos
comma
(paren
id|u32
)paren
id|data
comma
id|size
)paren
suffix:semicolon
id|DBG_CFG
c_func
(paren
l_string|&quot;%s(%x+%2x) = 0x%x (a)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tok
comma
id|pos
comma
id|data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|LBA_SKIP_PROBE
c_func
(paren
id|d
)paren
op_logical_and
(paren
op_logical_neg
id|lba_device_present
c_func
(paren
id|bus-&gt;secondary
comma
id|devfn
comma
id|d
)paren
)paren
)paren
(brace
id|DBG_CFG
c_func
(paren
l_string|&quot;%s(%x+%2x) = 0x%x (b)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tok
comma
id|pos
comma
id|data
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* New Workaround */
)brace
id|DBG_CFG
c_func
(paren
l_string|&quot;%s(%x+%2x) = 0x%x (c)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tok
comma
id|pos
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* Basic Algorithm */
id|LBA_CFG_TR4_ADDR_SETUP
c_func
(paren
id|d
comma
id|tok
op_or
id|pos
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|1
suffix:colon
id|WRITE_REG8
(paren
id|data
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|WRITE_REG16
c_func
(paren
id|data
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|WRITE_REG32
c_func
(paren
id|data
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|lba_t32
op_assign
id|READ_REG32
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_ADDR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|lba_cfg_ops
r_static
r_struct
id|pci_ops
id|lba_cfg_ops
op_assign
(brace
dot
id|read
op_assign
id|lba_cfg_read
comma
dot
id|write
op_assign
id|lba_cfg_write
comma
)brace
suffix:semicolon
r_static
r_void
DECL|function|lba_bios_init
id|lba_bios_init
c_func
(paren
r_void
)paren
(brace
id|DBG
c_func
(paren
id|MODULE_NAME
l_string|&quot;: lba_bios_init&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef __LP64__
multiline_comment|/*&n;** Determine if a device is already configured.&n;** If so, reserve it resources.&n;**&n;** Read PCI cfg command register and see if I/O or MMIO is enabled.&n;** PAT has to enable the devices it&squot;s using.&n;**&n;** Note: resources are fixed up before we try to claim them.&n;*/
r_static
r_void
DECL|function|lba_claim_dev_resources
id|lba_claim_dev_resources
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
id|u16
id|cmd
suffix:semicolon
r_int
id|i
comma
id|srch_flags
suffix:semicolon
(paren
r_void
)paren
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|srch_flags
op_assign
(paren
id|cmd
op_amp
id|PCI_COMMAND_IO
)paren
ques
c_cond
id|IORESOURCE_IO
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
id|PCI_COMMAND_MEMORY
)paren
id|srch_flags
op_or_assign
id|IORESOURCE_MEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|srch_flags
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|PCI_ROM_RESOURCE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;resource
(braket
id|i
)braket
dot
id|flags
op_amp
id|srch_flags
)paren
(brace
id|pci_claim_resource
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   claimed %s %d [%lx,%lx]/%x&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|dev
)paren
comma
id|i
comma
id|dev-&gt;resource
(braket
id|i
)braket
dot
id|start
comma
id|dev-&gt;resource
(braket
id|i
)braket
dot
id|end
comma
(paren
r_int
)paren
id|dev-&gt;resource
(braket
id|i
)braket
dot
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;** The algorithm is generic code.&n;** But it needs to access local data structures to get the IRQ base.&n;** Could make this a &quot;pci_fixup_irq(bus, region)&quot; but not sure&n;** it&squot;s worth it.&n;**&n;** Called by do_pci_scan_bus() immediately after each PCI bus is walked.&n;** Resources aren&squot;t allocated until recursive buswalk below HBA is completed.&n;*/
r_static
r_void
DECL|function|lba_fixup_bus
id|lba_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
r_struct
id|list_head
op_star
id|ln
suffix:semicolon
macro_line|#ifdef FBB_SUPPORT
id|u16
id|fbb_enable
op_assign
id|PCI_STATUS_FAST_BACK
suffix:semicolon
id|u16
id|status
suffix:semicolon
macro_line|#endif
r_struct
id|lba_device
op_star
id|ldev
op_assign
id|LBA_DEV
c_func
(paren
id|parisc_walk_tree
c_func
(paren
id|bus-&gt;dev
)paren
)paren
suffix:semicolon
r_int
id|lba_portbase
op_assign
id|HBA_PORT_BASE
c_func
(paren
id|ldev-&gt;hba.hba_num
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;lba_fixup_bus(0x%p) bus %d sysdata 0x%p&bslash;n&quot;
comma
id|bus
comma
id|bus-&gt;secondary
comma
id|bus-&gt;dev-&gt;platform_data
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Properly Setup MMIO resources for this bus.&n;&t;** pci_alloc_primary_bus() mangles this.&n;&t;*/
r_if
c_cond
(paren
l_int|NULL
op_eq
id|bus-&gt;self
)paren
(brace
r_int
id|err
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;lba_fixup_bus() %s [%lx/%lx]/%x&bslash;n&quot;
comma
id|ldev-&gt;hba.io_space.name
comma
id|ldev-&gt;hba.io_space.start
comma
id|ldev-&gt;hba.io_space.end
comma
(paren
r_int
)paren
id|ldev-&gt;hba.io_space.flags
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;lba_fixup_bus() %s [%lx/%lx]/%x&bslash;n&quot;
comma
id|ldev-&gt;hba.lmmio_space.name
comma
id|ldev-&gt;hba.lmmio_space.start
comma
id|ldev-&gt;hba.lmmio_space.end
comma
(paren
r_int
)paren
id|ldev-&gt;hba.lmmio_space.flags
)paren
suffix:semicolon
id|err
op_assign
id|request_resource
c_func
(paren
op_amp
id|ioport_resource
comma
op_amp
(paren
id|ldev-&gt;hba.io_space
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|lba_dump_res
c_func
(paren
op_amp
id|ioport_resource
comma
l_int|2
)paren
suffix:semicolon
)brace
id|err
op_assign
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
(paren
id|ldev-&gt;hba.lmmio_space
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|lba_dump_res
c_func
(paren
op_amp
id|iomem_resource
comma
l_int|2
)paren
suffix:semicolon
)brace
id|bus-&gt;resource
(braket
l_int|0
)braket
op_assign
op_amp
(paren
id|ldev-&gt;hba.io_space
)paren
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|1
)braket
op_assign
op_amp
(paren
id|ldev-&gt;hba.lmmio_space
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* KLUGE ALERT!&n;&t;&t;** PCI-PCI Bridge resource munging.&n;&t;&t;** This hack should go away in the near future.&n;&t;&t;** It&squot;s based on the Alpha port.&n;&t;&t;*/
r_int
id|i
suffix:semicolon
id|u16
id|cmd
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bus-&gt;resource
(braket
id|i
)braket
op_assign
op_amp
id|bus-&gt;self-&gt;resource
(braket
id|PCI_BRIDGE_RESOURCES
op_plus
id|i
)braket
suffix:semicolon
id|bus-&gt;resource
(braket
id|i
)braket
op_member_access_from_pointer
id|name
op_assign
id|bus-&gt;name
suffix:semicolon
)brace
macro_line|#if 0
id|bus-&gt;resource
(braket
l_int|0
)braket
op_member_access_from_pointer
id|flags
op_or_assign
id|pci_bridge_check_io
c_func
(paren
id|bus-&gt;self
)paren
suffix:semicolon
macro_line|#else
id|bus-&gt;resource
(braket
l_int|0
)braket
op_member_access_from_pointer
id|flags
op_or_assign
id|IORESOURCE_IO
suffix:semicolon
macro_line|#endif
id|bus-&gt;resource
(braket
l_int|1
)braket
op_member_access_from_pointer
id|flags
op_or_assign
id|IORESOURCE_MEM
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|2
)braket
op_member_access_from_pointer
id|flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t support prefetchable */
id|bus-&gt;resource
(braket
l_int|3
)braket
op_member_access_from_pointer
id|flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not used */
multiline_comment|/* &n;&t;&t;** If the PPB is enabled (ie already configured) then&n;&t;&t;** just read those values.&n;&t;&t;*/
(paren
r_void
)paren
id|pci_read_config_word
c_func
(paren
id|bus-&gt;self
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
(paren
id|PCI_COMMAND_MEMORY
op_or
id|PCI_COMMAND_IO
)paren
)paren
(brace
id|pci_read_bridge_bases
c_func
(paren
id|bus
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Not configured.&n;&t;&t;&t;** For now, propagate HBA limits to the bus;&n;&t;&t;&t;**&t;PCI will adjust them later.&n;&t;&t;&t;*/
id|bus-&gt;resource
(braket
l_int|0
)braket
op_member_access_from_pointer
id|end
op_assign
id|ldev-&gt;hba.io_space.end
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|1
)braket
op_member_access_from_pointer
id|end
op_assign
id|ldev-&gt;hba.lmmio_space.end
suffix:semicolon
)brace
multiline_comment|/* Turn off downstream PF memory address range by default */
id|bus-&gt;resource
(braket
l_int|2
)braket
op_member_access_from_pointer
id|start
op_assign
l_int|1024
op_star
l_int|1024
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|2
)braket
op_member_access_from_pointer
id|end
op_assign
id|bus-&gt;resource
(braket
l_int|2
)braket
op_member_access_from_pointer
id|start
op_minus
l_int|1
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|ln
comma
op_amp
id|bus-&gt;devices
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
op_assign
id|pci_dev_b
c_func
(paren
id|ln
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;lba_fixup_bus() %s&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
multiline_comment|/* Virtualize Device/Bridge Resources. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_NUM_RESOURCES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
op_amp
id|dev-&gt;resource
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* If resource not allocated - skip it */
r_if
c_cond
(paren
op_logical_neg
id|res-&gt;start
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;lba_fixup_bus() I/O Ports [%lx/%lx] -&gt; &quot;
comma
id|res-&gt;start
comma
id|res-&gt;end
)paren
suffix:semicolon
id|res-&gt;start
op_or_assign
id|lba_portbase
suffix:semicolon
id|res-&gt;end
op_or_assign
id|lba_portbase
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;[%lx/%lx]&bslash;n&quot;
comma
id|res-&gt;start
comma
id|res-&gt;end
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_MEM
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;** Convert PCI (IO_VIEW) addresses to&n;&t;&t;&t;&t;** processor (PA_VIEW) addresses&n;&t;&t;&t;&t; */
id|DBG
c_func
(paren
l_string|&quot;lba_fixup_bus() MMIO [%lx/%lx] -&gt; &quot;
comma
id|res-&gt;start
comma
id|res-&gt;end
)paren
suffix:semicolon
id|res-&gt;start
op_assign
id|PCI_HOST_ADDR
c_func
(paren
id|HBA_DATA
c_func
(paren
id|ldev
)paren
comma
id|res-&gt;start
)paren
suffix:semicolon
id|res-&gt;end
op_assign
id|PCI_HOST_ADDR
c_func
(paren
id|HBA_DATA
c_func
(paren
id|ldev
)paren
comma
id|res-&gt;end
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;[%lx/%lx]&bslash;n&quot;
comma
id|res-&gt;start
comma
id|res-&gt;end
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef FBB_SUPPORT
multiline_comment|/*&n;&t;&t;** If one device does not support FBB transfers,&n;&t;&t;** No one on the bus can be allowed to use them.&n;&t;&t;*/
(paren
r_void
)paren
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_STATUS
comma
op_amp
id|status
)paren
suffix:semicolon
id|fbb_enable
op_and_assign
id|status
suffix:semicolon
macro_line|#endif
macro_line|#ifdef __LP64__
r_if
c_cond
(paren
id|is_pdc_pat
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* Claim resources for PDC&squot;s devices */
id|lba_claim_dev_resources
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t;** P2PB&squot;s have no IRQs. ignore them.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_BRIDGE_PCI
)paren
r_continue
suffix:semicolon
multiline_comment|/* Adjust INTERRUPT_LINE for this dev */
id|iosapic_fixup_irq
c_func
(paren
id|ldev-&gt;iosapic_obj
comma
id|dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef FBB_SUPPORT
multiline_comment|/* FIXME/REVISIT - finish figuring out to set FBB on both&n;** pci_setup_bridge() clobbers PCI_BRIDGE_CONTROL.&n;** Can&squot;t fixup here anyway....garr...&n;*/
r_if
c_cond
(paren
id|fbb_enable
)paren
(brace
r_if
c_cond
(paren
id|bus-&gt;self
)paren
(brace
id|u8
id|control
suffix:semicolon
multiline_comment|/* enable on PPB */
(paren
r_void
)paren
id|pci_read_config_byte
c_func
(paren
id|bus-&gt;self
comma
id|PCI_BRIDGE_CONTROL
comma
op_amp
id|control
)paren
suffix:semicolon
(paren
r_void
)paren
id|pci_write_config_byte
c_func
(paren
id|bus-&gt;self
comma
id|PCI_BRIDGE_CONTROL
comma
id|control
op_or
id|PCI_STATUS_FAST_BACK
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* enable on LBA */
)brace
id|fbb_enable
op_assign
id|PCI_COMMAND_FAST_BACK
suffix:semicolon
)brace
multiline_comment|/* Lastly enable FBB/PERR/SERR on all devices too */
id|list_for_each
c_func
(paren
id|ln
comma
op_amp
id|bus-&gt;devices
)paren
(brace
(paren
r_void
)paren
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|status
)paren
suffix:semicolon
id|status
op_or_assign
id|PCI_COMMAND_PARITY
op_or
id|PCI_COMMAND_SERR
op_or
id|fbb_enable
suffix:semicolon
(paren
r_void
)paren
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|status
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|variable|lba_bios_ops
r_struct
id|pci_bios_ops
id|lba_bios_ops
op_assign
(brace
dot
id|init
op_assign
id|lba_bios_init
comma
dot
id|fixup_bus
op_assign
id|lba_fixup_bus
comma
)brace
suffix:semicolon
multiline_comment|/*******************************************************&n;**&n;** LBA Sprockets &quot;I/O Port&quot; Space Accessor Functions&n;**&n;** This set of accessor functions is intended for use with&n;** &quot;legacy firmware&quot; (ie Sprockets on Allegro/Forte boxes).&n;**&n;** Many PCI devices don&squot;t require use of I/O port space (eg Tulip,&n;** NCR720) since they export the same registers to both MMIO and&n;** I/O port space. In general I/O port space is slower than&n;** MMIO since drivers are designed so PIO writes can be posted.&n;**&n;********************************************************/
DECL|macro|LBA_PORT_IN
mdefine_line|#define LBA_PORT_IN(size, mask) &bslash;&n;static u##size lba_astro_in##size (struct pci_hba_data *d, u16 addr) &bslash;&n;{ &bslash;&n;&t;u##size t; &bslash;&n;&t;t = READ_REG##size(LBA_ASTRO_PORT_BASE + addr); &bslash;&n;&t;DBG_PORT(&quot; 0x%x&bslash;n&quot;, t); &bslash;&n;&t;return (t); &bslash;&n;}
id|LBA_PORT_IN
c_func
(paren
l_int|8
comma
l_int|3
)paren
id|LBA_PORT_IN
c_func
(paren
l_int|16
comma
l_int|2
)paren
id|LBA_PORT_IN
c_func
(paren
l_int|32
comma
l_int|0
)paren
multiline_comment|/*&n;** BUG X4107:  Ordering broken - DMA RD return can bypass PIO WR&n;**&n;** Fixed in Elroy 2.2. The READ_U32(..., LBA_FUNC_ID) below is&n;** guarantee non-postable completion semantics - not avoid X4107.&n;** The READ_U32 only guarantees the write data gets to elroy but&n;** out to the PCI bus. We can&squot;t read stuff from I/O port space&n;** since we don&squot;t know what has side-effects. Attempting to read&n;** from configuration space would be suicidal given the number of&n;** bugs in that elroy functionality.&n;**&n;**      Description:&n;**          DMA read results can improperly pass PIO writes (X4107).  The&n;**          result of this bug is that if a processor modifies a location in&n;**          memory after having issued PIO writes, the PIO writes are not&n;**          guaranteed to be completed before a PCI device is allowed to see&n;**          the modified data in a DMA read.&n;**&n;**          Note that IKE bug X3719 in TR1 IKEs will result in the same&n;**          symptom.&n;**&n;**      Workaround:&n;**          The workaround for this bug is to always follow a PIO write with&n;**          a PIO read to the same bus before starting DMA on that PCI bus.&n;**&n;*/
DECL|macro|LBA_PORT_OUT
mdefine_line|#define LBA_PORT_OUT(size, mask) &bslash;&n;static void lba_astro_out##size (struct pci_hba_data *d, u16 addr, u##size val) &bslash;&n;{ &bslash;&n;&t;ASSERT(d != NULL); &bslash;&n;&t;DBG_PORT(&quot;%s(0x%p, 0x%x, 0x%x)&bslash;n&quot;, __FUNCTION__, d, addr, val); &bslash;&n;&t;WRITE_REG##size(val, LBA_ASTRO_PORT_BASE + addr); &bslash;&n;&t;if (LBA_DEV(d)-&gt;hw_rev &lt; 3) &bslash;&n;&t;&t;lba_t32 = READ_U32(d-&gt;base_addr + LBA_FUNC_ID); &bslash;&n;}
id|LBA_PORT_OUT
c_func
(paren
l_int|8
comma
l_int|3
)paren
id|LBA_PORT_OUT
c_func
(paren
l_int|16
comma
l_int|2
)paren
id|LBA_PORT_OUT
c_func
(paren
l_int|32
comma
l_int|0
)paren
DECL|variable|lba_astro_port_ops
r_static
r_struct
id|pci_port_ops
id|lba_astro_port_ops
op_assign
(brace
dot
id|inb
op_assign
id|lba_astro_in8
comma
dot
id|inw
op_assign
id|lba_astro_in16
comma
dot
id|inl
op_assign
id|lba_astro_in32
comma
dot
id|outb
op_assign
id|lba_astro_out8
comma
dot
id|outw
op_assign
id|lba_astro_out16
comma
dot
id|outl
op_assign
id|lba_astro_out32
)brace
suffix:semicolon
macro_line|#ifdef __LP64__
DECL|macro|PIOP_TO_GMMIO
mdefine_line|#define PIOP_TO_GMMIO(lba, addr) &bslash;&n;&t;((lba)-&gt;iop_base + (((addr)&amp;0xFFFC)&lt;&lt;10) + ((addr)&amp;3))
multiline_comment|/*******************************************************&n;**&n;** LBA PAT &quot;I/O Port&quot; Space Accessor Functions&n;**&n;** This set of accessor functions is intended for use with&n;** &quot;PAT PDC&quot; firmware (ie Prelude/Rhapsody/Piranha boxes).&n;**&n;** This uses the PIOP space located in the first 64MB of GMMIO.&n;** Each rope gets a full 64*KB* (ie 4 bytes per page) this way.&n;** bits 1:0 stay the same.  bits 15:2 become 25:12.&n;** Then add the base and we can generate an I/O Port cycle.&n;********************************************************/
DECL|macro|LBA_PORT_IN
macro_line|#undef LBA_PORT_IN
DECL|macro|LBA_PORT_IN
mdefine_line|#define LBA_PORT_IN(size, mask) &bslash;&n;static u##size lba_pat_in##size (struct pci_hba_data *l, u16 addr) &bslash;&n;{ &bslash;&n;&t;u##size t; &bslash;&n;&t;ASSERT(bus != NULL); &bslash;&n;&t;DBG_PORT(&quot;%s(0x%p, 0x%x) -&gt;&quot;, __FUNCTION__, l, addr); &bslash;&n;&t;t = READ_REG##size(PIOP_TO_GMMIO(LBA_DEV(l), addr)); &bslash;&n;&t;DBG_PORT(&quot; 0x%x&bslash;n&quot;, t); &bslash;&n;&t;return (t); &bslash;&n;}
id|LBA_PORT_IN
c_func
(paren
l_int|8
comma
l_int|3
)paren
id|LBA_PORT_IN
c_func
(paren
l_int|16
comma
l_int|2
)paren
id|LBA_PORT_IN
c_func
(paren
l_int|32
comma
l_int|0
)paren
DECL|macro|LBA_PORT_OUT
macro_line|#undef LBA_PORT_OUT
DECL|macro|LBA_PORT_OUT
mdefine_line|#define LBA_PORT_OUT(size, mask) &bslash;&n;static void lba_pat_out##size (struct pci_hba_data *l, u16 addr, u##size val) &bslash;&n;{ &bslash;&n;&t;void *where = (void *) PIOP_TO_GMMIO(LBA_DEV(l), addr); &bslash;&n;&t;ASSERT(bus != NULL); &bslash;&n;&t;DBG_PORT(&quot;%s(0x%p, 0x%x, 0x%x)&bslash;n&quot;, __FUNCTION__, l, addr, val); &bslash;&n;&t;WRITE_REG##size(val, where); &bslash;&n;&t;/* flush the I/O down to the elroy at least */ &bslash;&n;&t;lba_t32 = READ_U32(l-&gt;base_addr + LBA_FUNC_ID); &bslash;&n;}
id|LBA_PORT_OUT
c_func
(paren
l_int|8
comma
l_int|3
)paren
id|LBA_PORT_OUT
c_func
(paren
l_int|16
comma
l_int|2
)paren
id|LBA_PORT_OUT
c_func
(paren
l_int|32
comma
l_int|0
)paren
DECL|variable|lba_pat_port_ops
r_static
r_struct
id|pci_port_ops
id|lba_pat_port_ops
op_assign
(brace
dot
id|inb
op_assign
id|lba_pat_in8
comma
dot
id|inw
op_assign
id|lba_pat_in16
comma
dot
id|inl
op_assign
id|lba_pat_in32
comma
dot
id|outb
op_assign
id|lba_pat_out8
comma
dot
id|outw
op_assign
id|lba_pat_out16
comma
dot
id|outl
op_assign
id|lba_pat_out32
)brace
suffix:semicolon
multiline_comment|/*&n;** make range information from PDC available to PCI subsystem.&n;** We make the PDC call here in order to get the PCI bus range&n;** numbers. The rest will get forwarded in pcibios_fixup_bus().&n;** We don&squot;t have a struct pci_bus assigned to us yet.&n;*/
r_static
r_void
DECL|function|lba_pat_resources
id|lba_pat_resources
c_func
(paren
r_struct
id|parisc_device
op_star
id|pa_dev
comma
r_struct
id|lba_device
op_star
id|lba_dev
)paren
(brace
r_int
r_int
id|bytecnt
suffix:semicolon
id|pdc_pat_cell_mod_maddr_block_t
id|pa_pdc_cell
suffix:semicolon
multiline_comment|/* PA_VIEW */
id|pdc_pat_cell_mod_maddr_block_t
id|io_pdc_cell
suffix:semicolon
multiline_comment|/* IO_VIEW */
r_int
id|io_count
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* PDC return status */
r_int
id|pa_count
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* return cell module (IO view) */
id|status
op_assign
id|pdc_pat_cell_module
c_func
(paren
op_amp
id|bytecnt
comma
id|pa_dev-&gt;pcell_loc
comma
id|pa_dev-&gt;mod_index
comma
id|PA_VIEW
comma
op_amp
id|pa_pdc_cell
)paren
suffix:semicolon
id|pa_count
op_assign
id|pa_pdc_cell.mod
(braket
l_int|1
)braket
suffix:semicolon
id|status
op_or_assign
id|pdc_pat_cell_module
c_func
(paren
op_amp
id|bytecnt
comma
id|pa_dev-&gt;pcell_loc
comma
id|pa_dev-&gt;mod_index
comma
id|IO_VIEW
comma
op_amp
id|io_pdc_cell
)paren
suffix:semicolon
id|io_count
op_assign
id|io_pdc_cell.mod
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* We&squot;ve already done this once for device discovery...*/
r_if
c_cond
(paren
id|status
op_ne
id|PDC_OK
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;pdc_pat_cell_module() call failed for LBA!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PAT_GET_ENTITY
c_func
(paren
id|pa_pdc_cell.mod_info
)paren
op_ne
id|PAT_ENTITY_LBA
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;pdc_pat_cell_module() entity returned != PAT_ENTITY_LBA!&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Inspect the resources PAT tells us about&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pa_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
(brace
r_int
r_int
id|type
suffix:semicolon
r_int
r_int
id|start
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
multiline_comment|/* aka finish */
)brace
op_star
id|p
comma
op_star
id|io
suffix:semicolon
r_struct
id|resource
op_star
id|r
suffix:semicolon
id|p
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|pa_pdc_cell.mod
(braket
l_int|2
op_plus
id|i
op_star
l_int|3
)braket
)paren
suffix:semicolon
id|io
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|io_pdc_cell.mod
(braket
l_int|2
op_plus
id|i
op_star
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/* Convert the PAT range data to PCI &quot;struct resource&quot; */
r_switch
c_cond
(paren
id|p-&gt;type
op_amp
l_int|0xff
)paren
(brace
r_case
id|PAT_PBNUM
suffix:colon
id|lba_dev-&gt;hba.bus_num.start
op_assign
id|p-&gt;start
suffix:semicolon
id|lba_dev-&gt;hba.bus_num.end
op_assign
id|p-&gt;end
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PAT_LMMIO
suffix:colon
multiline_comment|/* used to fix up pre-initialized MEM BARs */
id|lba_dev-&gt;hba.lmmio_space_offset
op_assign
id|p-&gt;start
op_minus
id|io-&gt;start
suffix:semicolon
id|r
op_assign
op_amp
(paren
id|lba_dev-&gt;hba.lmmio_space
)paren
suffix:semicolon
id|r-&gt;name
op_assign
l_string|&quot;LBA LMMIO&quot;
suffix:semicolon
id|r-&gt;start
op_assign
id|p-&gt;start
suffix:semicolon
id|r-&gt;end
op_assign
id|p-&gt;end
suffix:semicolon
id|r-&gt;flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
id|r-&gt;parent
op_assign
id|r-&gt;sibling
op_assign
id|r-&gt;child
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PAT_GMMIO
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot; range[%d] : ignoring GMMIO (0x%lx)&bslash;n&quot;
comma
id|i
comma
id|p-&gt;start
)paren
suffix:semicolon
id|lba_dev-&gt;gmmio_base
op_assign
id|p-&gt;start
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PAT_NPIOP
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot; range[%d] : ignoring NPIOP (0x%lx)&bslash;n&quot;
comma
id|i
comma
id|p-&gt;start
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PAT_PIOP
suffix:colon
multiline_comment|/*&n;&t;&t;&t;** Postable I/O port space is per PCI host adapter.&n;&t;&t;&t;*/
multiline_comment|/* save base of 64MB PIOP region */
id|lba_dev-&gt;iop_base
op_assign
id|p-&gt;start
suffix:semicolon
id|r
op_assign
op_amp
(paren
id|lba_dev-&gt;hba.io_space
)paren
suffix:semicolon
id|r-&gt;name
op_assign
l_string|&quot;LBA I/O Port&quot;
suffix:semicolon
id|r-&gt;start
op_assign
id|HBA_PORT_BASE
c_func
(paren
id|lba_dev-&gt;hba.hba_num
)paren
suffix:semicolon
id|r-&gt;end
op_assign
id|r-&gt;start
op_plus
id|HBA_PORT_SPACE_SIZE
op_minus
l_int|1
suffix:semicolon
id|r-&gt;flags
op_assign
id|IORESOURCE_IO
suffix:semicolon
id|r-&gt;parent
op_assign
id|r-&gt;sibling
op_assign
id|r-&gt;child
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot; range[%d] : unknown pat range type (0x%lx)&bslash;n&quot;
comma
id|i
comma
id|p-&gt;type
op_amp
l_int|0xff
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif&t;/* __LP64__ */
r_static
r_void
DECL|function|lba_legacy_resources
id|lba_legacy_resources
c_func
(paren
r_struct
id|parisc_device
op_star
id|pa_dev
comma
r_struct
id|lba_device
op_star
id|lba_dev
)paren
(brace
r_struct
id|resource
op_star
id|r
suffix:semicolon
r_int
r_int
id|rsize
suffix:semicolon
r_int
id|lba_num
suffix:semicolon
macro_line|#ifdef __LP64__
multiline_comment|/*&n;&t;** Sign extend all BAR values on &quot;legacy&quot; platforms.&n;&t;** &quot;Sprockets&quot; PDC (Forte/Allegro) initializes everything&n;&t;** for &quot;legacy&quot; 32-bit OS (HPUX 10.20).&n;&t;** Upper 32-bits of 64-bit BAR will be zero too.&n;&t;*/
id|lba_dev-&gt;hba.lmmio_space_offset
op_assign
l_int|0xffffffff00000000UL
suffix:semicolon
macro_line|#else
id|lba_dev-&gt;hba.lmmio_space_offset
op_assign
l_int|0UL
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;** With &quot;legacy&quot; firmware, the lowest byte of FW_SCRATCH&n;&t;** represents bus-&gt;secondary and the second byte represents&n;&t;** bus-&gt;subsidiary (i.e. highest PPB programmed by firmware).&n;&t;** PCI bus walk *should* end up with the same result.&n;&t;** FIXME: But we don&squot;t have sanity checks in PCI or LBA.&n;&t;*/
id|lba_num
op_assign
id|READ_REG32
c_func
(paren
id|pa_dev-&gt;hpa
op_plus
id|LBA_FW_SCRATCH
)paren
suffix:semicolon
id|r
op_assign
op_amp
(paren
id|lba_dev-&gt;hba.bus_num
)paren
suffix:semicolon
id|r-&gt;name
op_assign
l_string|&quot;LBA PCI Busses&quot;
suffix:semicolon
id|r-&gt;start
op_assign
id|lba_num
op_amp
l_int|0xff
suffix:semicolon
id|r-&gt;end
op_assign
(paren
id|lba_num
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* Set up local PCI Bus resources - we don&squot;t really need&n;&t;** them for Legacy boxes but it&squot;s nice to see in /proc.&n;&t;*/
id|r
op_assign
op_amp
(paren
id|lba_dev-&gt;hba.lmmio_space
)paren
suffix:semicolon
id|r-&gt;name
op_assign
l_string|&quot;LBA PCI LMMIO&quot;
suffix:semicolon
id|r-&gt;flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
multiline_comment|/* Ignore &quot;Range Enable&quot; bit in the BASE register */
id|r-&gt;start
op_assign
id|PCI_HOST_ADDR
c_func
(paren
id|HBA_DATA
c_func
(paren
id|lba_dev
)paren
comma
(paren
(paren
r_int
)paren
id|READ_REG32
c_func
(paren
id|pa_dev-&gt;hpa
op_plus
id|LBA_LMMIO_BASE
)paren
)paren
op_amp
op_complement
l_int|1UL
)paren
suffix:semicolon
id|rsize
op_assign
op_complement
id|READ_REG32
c_func
(paren
id|pa_dev-&gt;hpa
op_plus
id|LBA_LMMIO_MASK
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;** Each rope only gets part of the distributed range.&n;&t;** Adjust &quot;window&quot; for this rope&n;&t;*/
id|rsize
op_div_assign
id|ROPES_PER_SBA
suffix:semicolon
id|r-&gt;start
op_add_assign
id|rsize
op_star
id|LBA_NUM
c_func
(paren
id|pa_dev-&gt;hpa
)paren
suffix:semicolon
id|r-&gt;end
op_assign
id|r-&gt;start
op_plus
id|rsize
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;** XXX FIXME - ignore LBA_ELMMIO_BASE for now&n;&t;** &quot;Directed&quot; ranges are used when the &quot;distributed range&quot; isn&squot;t&n;&t;** sufficient for all devices below a given LBA.  Typically devices&n;&t;** like graphics cards or X25 may need a directed range when the&n;&t;** bus has multiple slots (ie multiple devices) or the device&n;&t;** needs more than the typical 4 or 8MB a distributed range offers.&n;&t;**&n;&t;** The main reason for ignoring it now frigging complications.&n;&t;** Directed ranges may overlap (and have precedence) over&n;&t;** distributed ranges. Ie a distributed range assigned to a unused&n;&t;** rope may be used by a directed range on a different rope.&n;&t;** Support for graphics devices may require fixing this&n;&t;** since they may be assigned a directed range which overlaps&n;&t;** an existing (but unused portion of) distributed range.&n;&t;*/
id|r
op_assign
op_amp
(paren
id|lba_dev-&gt;hba.elmmio_space
)paren
suffix:semicolon
id|r-&gt;name
op_assign
l_string|&quot;extra LBA PCI LMMIO&quot;
suffix:semicolon
id|r-&gt;flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
id|r-&gt;start
op_assign
id|READ_REG32
c_func
(paren
id|pa_dev-&gt;hpa
op_plus
id|LBA_ELMMIO_BASE
)paren
suffix:semicolon
id|r-&gt;end
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check Range Enable bit */
r_if
c_cond
(paren
id|r-&gt;start
op_amp
l_int|1
)paren
(brace
multiline_comment|/* First baby step to getting Direct Ranges listed in /proc.&n;&t;&t;** AFAIK, only Sprockets PDC will setup a directed Range.&n;&t;&t;*/
id|r-&gt;start
op_and_assign
op_complement
l_int|1
suffix:semicolon
id|r-&gt;end
op_assign
id|r-&gt;start
suffix:semicolon
id|r-&gt;end
op_add_assign
op_complement
id|READ_REG32
c_func
(paren
id|pa_dev-&gt;hpa
op_plus
id|LBA_ELMMIO_MASK
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WARNING: Ignoring enabled ELMMIO BASE 0x%0lx  SIZE 0x%lx&bslash;n&quot;
comma
id|r-&gt;start
comma
id|r-&gt;end
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|r
op_assign
op_amp
(paren
id|lba_dev-&gt;hba.io_space
)paren
suffix:semicolon
id|r-&gt;name
op_assign
l_string|&quot;LBA PCI I/O Ports&quot;
suffix:semicolon
id|r-&gt;flags
op_assign
id|IORESOURCE_IO
suffix:semicolon
id|r-&gt;start
op_assign
id|READ_REG32
c_func
(paren
id|pa_dev-&gt;hpa
op_plus
id|LBA_IOS_BASE
)paren
op_amp
op_complement
l_int|1L
suffix:semicolon
id|r-&gt;end
op_assign
id|r-&gt;start
op_plus
(paren
id|READ_REG32
c_func
(paren
id|pa_dev-&gt;hpa
op_plus
id|LBA_IOS_MASK
)paren
op_xor
(paren
id|HBA_PORT_SPACE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Virtualize the I/O Port space ranges */
id|lba_num
op_assign
id|HBA_PORT_BASE
c_func
(paren
id|lba_dev-&gt;hba.hba_num
)paren
suffix:semicolon
id|r-&gt;start
op_or_assign
id|lba_num
suffix:semicolon
id|r-&gt;end
op_or_assign
id|lba_num
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n;**&n;**   LBA initialization code (HW and SW)&n;**&n;**   o identify LBA chip itself&n;**   o initialize LBA chip modes (HardFail)&n;**   o FIXME: initialize DMA hints for reasonable defaults&n;**   o enable configuration functions&n;**   o call pci_register_ops() to discover devs (fixup/fixup_bus get invoked)&n;**&n;**************************************************************************/
r_static
r_int
id|__init
DECL|function|lba_hw_init
id|lba_hw_init
c_func
(paren
r_struct
id|lba_device
op_star
id|d
)paren
(brace
id|u32
id|stat
suffix:semicolon
id|u32
id|bus_reset
suffix:semicolon
multiline_comment|/* PDC_PAT_BUG */
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;LBA %lx  STAT_CTL %Lx  ERROR_CFG %Lx  STATUS %Lx DMA_CTL %Lx&bslash;n&quot;
comma
id|d-&gt;hba.base_addr
comma
id|READ_REG64
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_STAT_CTL
)paren
comma
id|READ_REG64
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_ERROR_CONFIG
)paren
comma
id|READ_REG64
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_ERROR_STATUS
)paren
comma
id|READ_REG64
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_DMA_CTL
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&t;ARB mask %Lx  pri %Lx  mode %Lx  mtlt %Lx&bslash;n&quot;
comma
id|READ_REG64
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_ARB_MASK
)paren
comma
id|READ_REG64
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_ARB_PRI
)paren
comma
id|READ_REG64
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_ARB_MODE
)paren
comma
id|READ_REG64
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_ARB_MTLT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&t;HINT cfg 0x%Lx&bslash;n&quot;
comma
id|READ_REG64
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_HINT_CFG
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&t;HINT reg &quot;
)paren
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|LBA_HINT_BASE
suffix:semicolon
id|i
OL
(paren
l_int|14
op_star
l_int|8
op_plus
id|LBA_HINT_BASE
)paren
suffix:semicolon
id|i
op_add_assign
l_int|8
)paren
id|printk
c_func
(paren
l_string|&quot; %Lx&quot;
comma
id|READ_REG64
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_LBA_PAT */
macro_line|#ifdef __LP64__
macro_line|#warning FIXME add support for PDC_PAT_IO &quot;Get slot status&quot; - OLAR support
macro_line|#endif
multiline_comment|/* PDC_PAT_BUG: exhibited in rev 40.48  on L2000 */
id|bus_reset
op_assign
id|READ_REG32
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_STAT_CTL
op_plus
l_int|4
)paren
op_amp
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bus_reset
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;NOTICE: PCI bus reset still asserted! (clearing)&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|stat
op_assign
id|READ_REG32
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_ERROR_CONFIG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|LBA_SMART_MODE
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;NOTICE: LBA in SMART mode! (cleared)&bslash;n&quot;
)paren
suffix:semicolon
id|stat
op_and_assign
op_complement
id|LBA_SMART_MODE
suffix:semicolon
id|WRITE_REG32
c_func
(paren
id|stat
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_ERROR_CONFIG
)paren
suffix:semicolon
)brace
multiline_comment|/* Set HF mode as the default (vs. -1 mode). */
id|stat
op_assign
id|READ_REG32
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_STAT_CTL
)paren
suffix:semicolon
id|WRITE_REG32
c_func
(paren
id|stat
op_or
id|HF_ENABLE
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_STAT_CTL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Writing a zero to STAT_CTL.rf (bit 0) will clear reset signal&n;&t;** if it&squot;s not already set. If we just cleared the PCI Bus Reset&n;&t;** signal, wait a bit for the PCI devices to recover and setup.&n;&t;*/
r_if
c_cond
(paren
id|bus_reset
)paren
id|mdelay
c_func
(paren
id|pci_post_reset_delay
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|READ_REG32
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_ARB_MASK
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;** PDC_PAT_BUG: PDC rev 40.48 on L2000.&n;&t;&t;** B2000/C3600/J6000 also have this problem?&n;&t;&t;** &n;&t;&t;** Elroys with hot pluggable slots don&squot;t get configured&n;&t;&t;** correctly if the slot is empty.  ARB_MASK is set to 0&n;&t;&t;** and we can&squot;t master transactions on the bus if it&squot;s&n;&t;&t;** not at least one. 0x3 enables elroy and first slot.&n;&t;&t;*/
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;NOTICE: Enabling PCI Arbitration&bslash;n&quot;
)paren
suffix:semicolon
id|WRITE_REG32
c_func
(paren
l_int|0x3
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_ARB_MASK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** FIXME: Hint registers are programmed with default hint&n;&t;** values by firmware. Hints should be sane even if we&n;&t;** can&squot;t reprogram them the way drivers want.&n;&t;*/
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|lba_common_init
id|lba_common_init
c_func
(paren
r_struct
id|lba_device
op_star
id|lba_dev
)paren
(brace
id|pci_bios
op_assign
op_amp
id|lba_bios_ops
suffix:semicolon
id|pcibios_register_hba
c_func
(paren
id|HBA_DATA
c_func
(paren
id|lba_dev
)paren
)paren
suffix:semicolon
id|lba_dev-&gt;lba_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n;&t;** Set flags which depend on hw_rev&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|LBA_TR4PLUS
c_func
(paren
id|lba_dev
)paren
)paren
(brace
id|lba_dev-&gt;flags
op_or_assign
id|LBA_FLAG_NO_DMA_DURING_CFG
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** Determine if lba should claim this chip (return 0) or not (return 1).&n;** If so, initialize the chip and tell other partners in crime they&n;** have work to do.&n;*/
r_static
r_int
id|__init
DECL|function|lba_driver_callback
id|lba_driver_callback
c_func
(paren
r_struct
id|parisc_device
op_star
id|dev
)paren
(brace
r_struct
id|lba_device
op_star
id|lba_dev
suffix:semicolon
r_struct
id|pci_bus
op_star
id|lba_bus
suffix:semicolon
id|u32
id|func_class
suffix:semicolon
r_void
op_star
id|tmp_obj
suffix:semicolon
r_char
op_star
id|version
suffix:semicolon
multiline_comment|/* Read HW Rev First */
id|func_class
op_assign
id|READ_REG32
c_func
(paren
id|dev-&gt;hpa
op_plus
id|LBA_FCLASS
)paren
suffix:semicolon
id|func_class
op_and_assign
l_int|0xf
suffix:semicolon
r_switch
c_cond
(paren
id|func_class
)paren
(brace
r_case
l_int|0
suffix:colon
id|version
op_assign
l_string|&quot;TR1.0&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|version
op_assign
l_string|&quot;TR2.0&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|version
op_assign
l_string|&quot;TR2.1&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|version
op_assign
l_string|&quot;TR2.2&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|version
op_assign
l_string|&quot;TR3.0&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|version
op_assign
l_string|&quot;TR4.0&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|version
op_assign
l_string|&quot;TR4+&quot;
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s version %s (0x%x) found at 0x%lx&bslash;n&quot;
comma
id|MODULE_NAME
comma
id|version
comma
id|func_class
op_amp
l_int|0xf
comma
id|dev-&gt;hpa
)paren
suffix:semicolon
multiline_comment|/* Just in case we find some prototypes... */
r_if
c_cond
(paren
id|func_class
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Can&squot;t support LBA older than TR2.1 &quot;
l_string|&quot;- continuing under adversity.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Tell I/O SAPIC driver we have a IRQ handler/region.&n;&t;*/
id|tmp_obj
op_assign
id|iosapic_register
c_func
(paren
id|dev-&gt;hpa
op_plus
id|LBA_IOSAPIC_BASE
)paren
suffix:semicolon
multiline_comment|/* NOTE: PCI devices (e.g. 103c:1005 graphics card) which don&squot;t&n;&t;**&t;have an IRT entry will get NULL back from iosapic code.&n;&t;*/
id|lba_dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lba_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|lba_dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lba_init_chip - couldn&squot;t alloc lba_device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|lba_dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lba_device
)paren
)paren
suffix:semicolon
multiline_comment|/* ---------- First : initialize data we already have --------- */
multiline_comment|/*&n;&t;** Need hw_rev to adjust configuration space behavior.&n;&t;** LBA_TR4PLUS macro uses hw_rev field.&n;&t;*/
id|lba_dev-&gt;hw_rev
op_assign
id|func_class
suffix:semicolon
id|lba_dev-&gt;hba.base_addr
op_assign
id|dev-&gt;hpa
suffix:semicolon
multiline_comment|/* faster access */
id|lba_dev-&gt;hba.dev
op_assign
id|dev
suffix:semicolon
id|lba_dev-&gt;iosapic_obj
op_assign
id|tmp_obj
suffix:semicolon
multiline_comment|/* save interrupt handle */
id|lba_dev-&gt;hba.iommu
op_assign
id|sba_get_iommu
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* get iommu data */
multiline_comment|/* ------------ Second : initialize common stuff ---------- */
id|lba_common_init
c_func
(paren
id|lba_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lba_hw_init
c_func
(paren
id|lba_dev
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* ---------- Third : setup I/O Port and MMIO resources  --------- */
macro_line|#ifdef __LP64__
r_if
c_cond
(paren
id|is_pdc_pat
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* PDC PAT firmware uses PIOP region of GMMIO space. */
id|pci_port
op_assign
op_amp
id|lba_pat_port_ops
suffix:semicolon
multiline_comment|/* Go ask PDC PAT what resources this LBA has */
id|lba_pat_resources
c_func
(paren
id|dev
comma
id|lba_dev
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
multiline_comment|/* Sprockets PDC uses NPIOP region */
id|pci_port
op_assign
op_amp
id|lba_astro_port_ops
suffix:semicolon
multiline_comment|/* Poke the chip a bit for /proc output */
id|lba_legacy_resources
c_func
(paren
id|dev
comma
id|lba_dev
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;** Tell PCI support another PCI bus was found.&n;&t;** Walks PCI bus for us too.&n;&t;*/
id|dev-&gt;dev.platform_data
op_assign
id|lba_dev
suffix:semicolon
id|lba_bus
op_assign
id|lba_dev-&gt;hba.hba_bus
op_assign
id|pci_scan_bus_parented
c_func
(paren
op_amp
id|dev-&gt;dev
comma
id|lba_dev-&gt;hba.bus_num.start
comma
op_amp
id|lba_cfg_ops
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
r_if
c_cond
(paren
id|is_pdc_pat
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* assign resources to un-initialized devices */
id|DBG_PAT
c_func
(paren
l_string|&quot;LBA pci_bus_assign_resources()&bslash;n&quot;
)paren
suffix:semicolon
id|pci_bus_assign_resources
c_func
(paren
id|lba_bus
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_LBA_PAT
id|DBG_PAT
c_func
(paren
l_string|&quot;&bslash;nLBA PIOP resource tree&bslash;n&quot;
)paren
suffix:semicolon
id|lba_dump_res
c_func
(paren
op_amp
id|lba_dev-&gt;hba.io_space
comma
l_int|2
)paren
suffix:semicolon
id|DBG_PAT
c_func
(paren
l_string|&quot;&bslash;nLBA LMMIO resource tree&bslash;n&quot;
)paren
suffix:semicolon
id|lba_dump_res
c_func
(paren
op_amp
id|lba_dev-&gt;hba.lmmio_space
comma
l_int|2
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
multiline_comment|/*&n;&t;** Once PCI register ops has walked the bus, access to config&n;&t;** space is restricted. Avoids master aborts on config cycles.&n;&t;** Early LBA revs go fatal on *any* master abort.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|LBA_TR4PLUS
c_func
(paren
id|lba_dev
)paren
)paren
(brace
id|lba_dev-&gt;flags
op_or_assign
id|LBA_FLAG_SKIP_PROBE
suffix:semicolon
)brace
multiline_comment|/* Whew! Finally done! Tell services we got this one covered. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|lba_tbl
r_static
r_struct
id|parisc_device_id
id|lba_tbl
(braket
)braket
op_assign
(brace
(brace
id|HPHW_BRIDGE
comma
id|HVERSION_REV_ANY_ID
comma
l_int|0x782
comma
l_int|0xa
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
DECL|variable|lba_driver
r_static
r_struct
id|parisc_driver
id|lba_driver
op_assign
(brace
dot
id|name
op_assign
id|MODULE_NAME
comma
dot
id|id_table
op_assign
id|lba_tbl
comma
dot
id|probe
op_assign
id|lba_driver_callback
comma
)brace
suffix:semicolon
multiline_comment|/*&n;** One time initialization to let the world know the LBA was found.&n;** Must be called exactly once before pci_init().&n;*/
DECL|function|lba_init
r_void
id|__init
id|lba_init
c_func
(paren
r_void
)paren
(brace
id|register_parisc_driver
c_func
(paren
op_amp
id|lba_driver
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** Initialize the IBASE/IMASK registers for LBA (Elroy).&n;** Only called from sba_iommu.c in order to route ranges (MMIO vs DMA).&n;** sba_iommu is responsible for locking (none needed at init time).&n;*/
r_void
DECL|function|lba_set_iregs
id|lba_set_iregs
c_func
(paren
r_struct
id|parisc_device
op_star
id|lba
comma
id|u32
id|ibase
comma
id|u32
id|imask
)paren
(brace
r_int
r_int
id|base_addr
op_assign
id|lba-&gt;hpa
suffix:semicolon
id|imask
op_lshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* adjust for hints - 2 more bits */
id|ASSERT
c_func
(paren
(paren
id|ibase
op_amp
l_int|0x003fffff
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|imask
op_amp
l_int|0x003fffff
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;%s() ibase 0x%x imask 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ibase
comma
id|imask
)paren
suffix:semicolon
id|WRITE_REG32
c_func
(paren
id|imask
comma
id|base_addr
op_plus
id|LBA_IMASK
)paren
suffix:semicolon
id|WRITE_REG32
c_func
(paren
id|ibase
comma
id|base_addr
op_plus
id|LBA_IBASE
)paren
suffix:semicolon
)brace
eof
