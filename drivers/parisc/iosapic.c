multiline_comment|/*&n;** I/O Sapic Driver - PCI interrupt line support&n;**&n;**      (c) Copyright 1999 Grant Grundler&n;**      (c) Copyright 1999 Hewlett-Packard Company&n;**&n;**      This program is free software; you can redistribute it and/or modify&n;**      it under the terms of the GNU General Public License as published by&n;**      the Free Software Foundation; either version 2 of the License, or&n;**      (at your option) any later version.&n;**&n;** The I/O sapic driver manages the Interrupt Redirection Table which is&n;** the control logic to convert PCI line based interrupts into a Message&n;** Signaled Interrupt (aka Transaction Based Interrupt, TBI).&n;**&n;** Acronyms&n;** --------&n;** HPA  Hard Physical Address (aka MMIO address)&n;** IRQ  Interrupt ReQuest. Implies Line based interrupt.&n;** IRT&t;Interrupt Routing Table (provided by PAT firmware)&n;** IRdT Interrupt Redirection Table. IRQ line to TXN ADDR/DATA&n;**      table which is implemented in I/O SAPIC.&n;** ISR  Interrupt Service Routine. aka Interrupt handler.&n;** MSI&t;Message Signaled Interrupt. PCI 2.2 functionality.&n;**      aka Transaction Based Interrupt (or TBI).&n;** PA   Precision Architecture. HP&squot;s RISC architecture.&n;** RISC Reduced Instruction Set Computer.&n;**&n;**&n;** What&squot;s a Message Signalled Interrupt?&n;** -------------------------------------&n;** MSI is a write transaction which targets a processor and is similar&n;** to a processor write to memory or MMIO. MSIs can be generated by I/O&n;** devices as well as processors and require *architecture* to work.&n;**&n;** PA only supports MSI. So I/O subsystems must either natively generate&n;** MSIs (e.g. GSC or HP-PB) or convert line based interrupts into MSIs&n;** (e.g. PCI and EISA).  IA64 supports MSIs via a &quot;local SAPIC&quot; which&n;** acts on behalf of a processor.&n;**&n;** MSI allows any I/O device to interrupt any processor. This makes&n;** load balancing of the interrupt processing possible on an SMP platform.&n;** Interrupts are also ordered WRT to DMA data.  It&squot;s possible on I/O&n;** coherent systems to completely eliminate PIO reads from the interrupt&n;** path. The device and driver must be designed and implemented to&n;** guarantee all DMA has been issued (issues about atomicity here)&n;** before the MSI is issued. I/O status can then safely be read from&n;** DMA&squot;d data by the ISR.&n;**&n;**&n;** PA Firmware&n;** -----------&n;** PA-RISC platforms have two fundementally different types of firmware.&n;** For PCI devices, &quot;Legacy&quot; PDC initializes the &quot;INTERRUPT_LINE&quot; register&n;** and BARs similar to a traditional PC BIOS.&n;** The newer &quot;PAT&quot; firmware supports PDC calls which return tables.&n;** PAT firmware only initializes PCI Console and Boot interface.&n;** With these tables, the OS can progam all other PCI devices.&n;**&n;** One such PAT PDC call returns the &quot;Interrupt Routing Table&quot; (IRT).&n;** The IRT maps each PCI slot&squot;s INTA-D &quot;output&quot; line to an I/O SAPIC&n;** input line.  If the IRT is not available, this driver assumes&n;** INTERRUPT_LINE register has been programmed by firmware. The latter&n;** case also means online addition of PCI cards can NOT be supported&n;** even if HW support is present.&n;**&n;** All platforms with PAT firmware to date (Oct 1999) use one Interrupt&n;** Routing Table for the entire platform.&n;**&n;** Where&squot;s the iosapic?&n;** --------------------&n;** I/O sapic is part of the &quot;Core Electronics Complex&quot;. And on HP platforms&n;** it&squot;s integrated as part of the PCI bus adapter, &quot;lba&quot;.  So no bus walk&n;** will discover I/O Sapic. I/O Sapic driver learns about each device&n;** when lba driver advertises the presence of the I/O sapic by calling&n;** iosapic_register().&n;**&n;**&n;** IRQ handling notes&n;** ------------------&n;** The IO-SAPIC can indicate to the CPU which interrupt was asserted.&n;** So, unlike the GSC-ASIC and Dino, we allocate one CPU interrupt per&n;** IO-SAPIC interrupt and call the device driver&squot;s handler directly.&n;** The IO-SAPIC driver hijacks the CPU interrupt handler so it can&n;** issue the End Of Interrupt command to the IO-SAPIC.&n;**&n;** Overview of exported iosapic functions&n;** --------------------------------------&n;** (caveat: code isn&squot;t finished yet - this is just the plan)&n;**&n;** iosapic_init:&n;**   o initialize globals (lock, etc)&n;**   o try to read IRT. Presence of IRT determines if this is&n;**     a PAT platform or not.&n;**&n;** iosapic_register():&n;**   o create iosapic_info instance data structure&n;**   o allocate vector_info array for this iosapic&n;**   o initialize vector_info - read corresponding IRdT?&n;**&n;** iosapic_xlate_pin: (only called by fixup_irq for PAT platform)&n;**   o intr_pin = read cfg (INTERRUPT_PIN);&n;**   o if (device under PCI-PCI bridge)&n;**               translate slot/pin&n;**&n;** iosapic_fixup_irq:&n;**   o if PAT platform (IRT present)&n;**&t;   intr_pin = iosapic_xlate_pin(isi,pcidev):&n;**         intr_line = find IRT entry(isi, PCI_SLOT(pcidev), intr_pin)&n;**         save IRT entry into vector_info later&n;**         write cfg INTERRUPT_LINE (with intr_line)?&n;**     else&n;**         intr_line = pcidev-&gt;irq&n;**         IRT pointer = NULL&n;**     endif&n;**   o locate vector_info (needs: isi, intr_line)&n;**   o allocate processor &quot;irq&quot; and get txn_addr/data&n;**   o request_irq(processor_irq,  iosapic_interrupt, vector_info,...)&n;**&n;** iosapic_enable_irq:&n;**   o clear any pending IRQ on that line&n;**   o enable IRdT - call enable_irq(vector[line]-&gt;processor_irq)&n;**   o write EOI in case line is already asserted.&n;**&n;** iosapic_disable_irq:&n;**   o disable IRdT - call disable_irq(vector[line]-&gt;processor_irq)&n;*/
multiline_comment|/* FIXME: determine which include files are really needed */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;&t;/* get in-line asm for swab */
macro_line|#include &lt;asm/pdc.h&gt;
macro_line|#include &lt;asm/pdcpat.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;&t;&t;/* read/write functions */
macro_line|#ifdef CONFIG_SUPERIO
macro_line|#include &lt;asm/superio.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/iosapic.h&gt;
macro_line|#include &quot;./iosapic_private.h&quot;
DECL|macro|MODULE_NAME
mdefine_line|#define MODULE_NAME &quot;iosapic&quot;
multiline_comment|/* &quot;local&quot; compile flags */
DECL|macro|PCI_BRIDGE_FUNCS
macro_line|#undef PCI_BRIDGE_FUNCS
DECL|macro|DEBUG_IOSAPIC
macro_line|#undef DEBUG_IOSAPIC
DECL|macro|DEBUG_IOSAPIC_IRT
macro_line|#undef DEBUG_IOSAPIC_IRT
macro_line|#ifdef DEBUG_IOSAPIC
DECL|variable|assert_buf
r_static
r_char
id|assert_buf
(braket
l_int|128
)braket
suffix:semicolon
r_static
r_int
DECL|function|assert_failed
id|assert_failed
(paren
r_char
op_star
id|a
comma
r_char
op_star
id|f
comma
r_int
id|l
)paren
(brace
id|sprintf
c_func
(paren
id|assert_buf
comma
l_string|&quot;ASSERT(%s) failed!&bslash;nline %d in %s&bslash;n&quot;
comma
id|a
comma
multiline_comment|/* assertion text */
id|l
comma
multiline_comment|/* line number */
id|f
)paren
suffix:semicolon
multiline_comment|/* file name */
id|panic
c_func
(paren
id|assert_buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|ASSERT
macro_line|#undef ASSERT
DECL|macro|ASSERT
mdefine_line|#define ASSERT(EX) { if (!(EX)) assert_failed(# EX, __FILE__, __LINE__); }
DECL|macro|DBG
mdefine_line|#define DBG(x...) printk(x)
macro_line|#else /* DEBUG_IOSAPIC */
DECL|macro|DBG
mdefine_line|#define DBG(x...)
DECL|macro|ASSERT
macro_line|#undef&t;ASSERT
DECL|macro|ASSERT
mdefine_line|#define ASSERT(EX)
macro_line|#endif /* DEBUG_IOSAPIC */
macro_line|#ifdef DEBUG_IOSAPIC_IRT
DECL|macro|DBG_IRT
mdefine_line|#define DBG_IRT(x...) printk(x)
macro_line|#else
DECL|macro|DBG_IRT
mdefine_line|#define DBG_IRT(x...)
macro_line|#endif
DECL|macro|IOSAPIC_REG_SELECT
mdefine_line|#define IOSAPIC_REG_SELECT              0x00
DECL|macro|IOSAPIC_REG_WINDOW
mdefine_line|#define IOSAPIC_REG_WINDOW              0x10
DECL|macro|IOSAPIC_REG_EOI
mdefine_line|#define IOSAPIC_REG_EOI                 0x40
DECL|macro|IOSAPIC_REG_VERSION
mdefine_line|#define IOSAPIC_REG_VERSION&t;&t;0x1
DECL|macro|IOSAPIC_IRDT_ENTRY
mdefine_line|#define IOSAPIC_IRDT_ENTRY(idx)&t;&t;(0x10+(idx)*2)
DECL|macro|IOSAPIC_IRDT_ENTRY_HI
mdefine_line|#define IOSAPIC_IRDT_ENTRY_HI(idx)&t;(0x11+(idx)*2)
DECL|function|iosapic_read
r_static
r_inline
r_int
r_int
id|iosapic_read
c_func
(paren
r_int
r_int
id|iosapic
comma
r_int
r_int
id|reg
)paren
(brace
id|writel
c_func
(paren
id|reg
comma
id|iosapic
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
r_return
id|readl
c_func
(paren
id|iosapic
op_plus
id|IOSAPIC_REG_WINDOW
)paren
suffix:semicolon
)brace
DECL|function|iosapic_write
r_static
r_inline
r_void
id|iosapic_write
c_func
(paren
r_int
r_int
id|iosapic
comma
r_int
r_int
id|reg
comma
id|u32
id|val
)paren
(brace
id|writel
c_func
(paren
id|reg
comma
id|iosapic
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
id|writel
c_func
(paren
id|val
comma
id|iosapic
op_plus
id|IOSAPIC_REG_WINDOW
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;**     GFP_KERNEL includes __GFP_WAIT flag and that may not&n;**     be acceptable. Since this is boot time, we shouldn&squot;t have&n;**     to wait ever and this code should (will?) never get called&n;**     from the interrrupt context.&n;*/
DECL|macro|IOSAPIC_KALLOC
mdefine_line|#define&t;IOSAPIC_KALLOC(a_type, cnt) &bslash;&n;&t;&t;&t;(a_type *) kmalloc(sizeof(a_type)*(cnt), GFP_KERNEL)
DECL|macro|IOSAPIC_FREE
mdefine_line|#define IOSAPIC_FREE(addr, f_type, cnt) kfree((void *)addr)
DECL|macro|IOSAPIC_LOCK
mdefine_line|#define&t;IOSAPIC_LOCK(lck)&t;spin_lock_irqsave(lck, irqflags)
DECL|macro|IOSAPIC_UNLOCK
mdefine_line|#define&t;IOSAPIC_UNLOCK(lck)&t;spin_unlock_irqrestore(lck, irqflags)
DECL|macro|IOSAPIC_VERSION_MASK
mdefine_line|#define IOSAPIC_VERSION_MASK&t;0x000000ff
DECL|macro|IOSAPIC_VERSION
mdefine_line|#define&t;IOSAPIC_VERSION(ver)&t;((int) (ver &amp; IOSAPIC_VERSION_MASK))
DECL|macro|IOSAPIC_MAX_ENTRY_MASK
mdefine_line|#define IOSAPIC_MAX_ENTRY_MASK          0x00ff0000
DECL|macro|IOSAPIC_MAX_ENTRY_SHIFT
mdefine_line|#define IOSAPIC_MAX_ENTRY_SHIFT         0x10
DECL|macro|IOSAPIC_IRDT_MAX_ENTRY
mdefine_line|#define&t;IOSAPIC_IRDT_MAX_ENTRY(ver)&t;&bslash;&n;&t;(int) (((ver) &amp; IOSAPIC_MAX_ENTRY_MASK) &gt;&gt; IOSAPIC_MAX_ENTRY_SHIFT)
multiline_comment|/* bits in the &quot;low&quot; I/O Sapic IRdT entry */
DECL|macro|IOSAPIC_IRDT_ENABLE
mdefine_line|#define IOSAPIC_IRDT_ENABLE       0x10000
DECL|macro|IOSAPIC_IRDT_PO_LOW
mdefine_line|#define IOSAPIC_IRDT_PO_LOW       0x02000
DECL|macro|IOSAPIC_IRDT_LEVEL_TRIG
mdefine_line|#define IOSAPIC_IRDT_LEVEL_TRIG   0x08000
DECL|macro|IOSAPIC_IRDT_MODE_LPRI
mdefine_line|#define IOSAPIC_IRDT_MODE_LPRI    0x00100
multiline_comment|/* bits in the &quot;high&quot; I/O Sapic IRdT entry */
DECL|macro|IOSAPIC_IRDT_ID_EID_SHIFT
mdefine_line|#define IOSAPIC_IRDT_ID_EID_SHIFT              0x10
DECL|variable|iosapic_lock
r_static
id|spinlock_t
id|iosapic_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|iosapic_eoi
r_static
r_inline
r_void
id|iosapic_eoi
c_func
(paren
r_void
id|__iomem
op_star
id|addr
comma
r_int
r_int
id|data
)paren
(brace
id|__raw_writel
c_func
(paren
id|data
comma
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** REVISIT: future platforms may have more than one IRT.&n;** If so, the following three fields form a structure which&n;** then be linked into a list. Names are chosen to make searching&n;** for them easy - not necessarily accurate (eg &quot;cell&quot;).&n;**&n;** Alternative: iosapic_info could point to the IRT it&squot;s in.&n;** iosapic_register() could search a list of IRT&squot;s.&n;*/
DECL|variable|irt_cell
r_static
r_struct
id|irt_entry
op_star
id|irt_cell
suffix:semicolon
DECL|variable|irt_num_entry
r_static
r_int
id|irt_num_entry
suffix:semicolon
multiline_comment|/*&n;** iosapic_load_irt&n;**&n;** The &quot;Get PCI INT Routing Table Size&quot; option returns the number of &n;** entries in the PCI interrupt routing table for the cell specified &n;** in the cell_number argument.  The cell number must be for a cell &n;** within the caller&squot;s protection domain.&n;**&n;** The &quot;Get PCI INT Routing Table&quot; option returns, for the cell &n;** specified in the cell_number argument, the PCI interrupt routing &n;** table in the caller allocated memory pointed to by mem_addr.&n;** We assume the IRT only contains entries for I/O SAPIC and&n;** calculate the size based on the size of I/O sapic entries.&n;**&n;** The PCI interrupt routing table entry format is derived from the&n;** IA64 SAL Specification 2.4.   The PCI interrupt routing table defines&n;** the routing of PCI interrupt signals between the PCI device output&n;** &quot;pins&quot; and the IO SAPICs&squot; input &quot;lines&quot; (including core I/O PCI&n;** devices).  This table does NOT include information for devices/slots&n;** behind PCI to PCI bridges. See PCI to PCI Bridge Architecture Spec.&n;** for the architected method of routing of IRQ&squot;s behind PPB&squot;s.&n;*/
r_static
r_int
id|__init
multiline_comment|/* return number of entries as success/fail flag */
DECL|function|iosapic_load_irt
id|iosapic_load_irt
c_func
(paren
r_int
r_int
id|cell_num
comma
r_struct
id|irt_entry
op_star
op_star
id|irt
)paren
(brace
r_int
id|status
suffix:semicolon
multiline_comment|/* PDC return value status */
r_struct
id|irt_entry
op_star
id|table
suffix:semicolon
multiline_comment|/* start of interrupt routing tbl */
r_int
r_int
id|num_entries
op_assign
l_int|0UL
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|irt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_pdc_pat
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* Use pat pdc routine to get interrupt routing table size */
id|DBG
c_func
(paren
l_string|&quot;calling get_irt_size (cell %ld)&bslash;n&quot;
comma
id|cell_num
)paren
suffix:semicolon
id|status
op_assign
id|pdc_pat_get_irt_size
c_func
(paren
op_amp
id|num_entries
comma
id|cell_num
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;get_irt_size: %ld&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|status
op_eq
id|PDC_OK
)paren
suffix:semicolon
multiline_comment|/* save the number of entries in the table */
id|ASSERT
c_func
(paren
l_int|0UL
op_ne
id|num_entries
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** allocate memory for interrupt routing table&n;&t;&t;** This interface isn&squot;t really right. We are assuming&n;&t;&t;** the contents of the table are exclusively&n;&t;&t;** for I/O sapic devices.&n;&t;&t;*/
id|table
op_assign
id|IOSAPIC_KALLOC
c_func
(paren
r_struct
id|irt_entry
comma
id|num_entries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|table
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;: read_irt : can not alloc mem for IRT&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* get PCI INT routing table */
id|status
op_assign
id|pdc_pat_get_irt
c_func
(paren
id|table
comma
id|cell_num
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;pdc_pat_get_irt: %ld&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|status
op_eq
id|PDC_OK
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;** C3000/J5000 (and similar) platforms with Sprockets PDC&n;&t;&t;** will return exactly one IRT for all iosapics.&n;&t;&t;** So if we have one, don&squot;t need to get it again.&n;&t;&t;*/
r_if
c_cond
(paren
l_int|NULL
op_ne
id|irt_cell
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Should be using the Elroy&squot;s HPA, but it&squot;s ignored anyway */
id|status
op_assign
id|pdc_pci_irt_size
c_func
(paren
op_amp
id|num_entries
comma
l_int|0
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;pdc_pci_irt_size: %ld&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PDC_OK
op_ne
id|status
)paren
(brace
multiline_comment|/* Not a &quot;legacy&quot; system with I/O SAPIC either */
r_return
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
l_int|0UL
op_ne
id|num_entries
)paren
suffix:semicolon
id|table
op_assign
id|IOSAPIC_KALLOC
c_func
(paren
r_struct
id|irt_entry
comma
id|num_entries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|table
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;: read_irt : can not alloc mem for IRT&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* HPA ignored by this call too. */
id|status
op_assign
id|pdc_pci_irt
c_func
(paren
id|num_entries
comma
l_int|0
comma
id|table
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|PDC_OK
op_eq
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* return interrupt table address */
op_star
id|irt
op_assign
id|table
suffix:semicolon
macro_line|#ifdef DEBUG_IOSAPIC_IRT
(brace
r_struct
id|irt_entry
op_star
id|p
op_assign
id|table
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|MODULE_NAME
l_string|&quot; Interrupt Routing Table (cell %ld)&bslash;n&quot;
comma
id|cell_num
)paren
suffix:semicolon
id|printk
c_func
(paren
id|MODULE_NAME
l_string|&quot; start = 0x%p num_entries %ld entry_size %d&bslash;n&quot;
comma
id|table
comma
id|num_entries
comma
(paren
r_int
)paren
r_sizeof
(paren
r_struct
id|irt_entry
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_entries
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
id|printk
c_func
(paren
id|MODULE_NAME
l_string|&quot; %02x %02x %02x %02x %02x %02x %02x %02x %08x%08x&bslash;n&quot;
comma
id|p-&gt;entry_type
comma
id|p-&gt;entry_length
comma
id|p-&gt;interrupt_type
comma
id|p-&gt;polarity_trigger
comma
id|p-&gt;src_bus_irq_devno
comma
id|p-&gt;src_bus_id
comma
id|p-&gt;src_seg_id
comma
id|p-&gt;dest_iosapic_intin
comma
(paren
(paren
id|u32
op_star
)paren
id|p
)paren
(braket
l_int|2
)braket
comma
(paren
(paren
id|u32
op_star
)paren
id|p
)paren
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* DEBUG_IOSAPIC_IRT */
r_return
id|num_entries
suffix:semicolon
)brace
r_void
id|__init
DECL|function|iosapic_init
id|iosapic_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cell
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* init global data */
id|iosapic_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|iosapic_list
op_assign
(paren
r_struct
id|iosapic_info
op_star
)paren
l_int|NULL
suffix:semicolon
id|iosapic_count
op_assign
l_int|0
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;iosapic_init()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
r_if
c_cond
(paren
id|is_pdc_pat
c_func
(paren
)paren
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|pdc_pat_cell_num
id|cell_info
suffix:semicolon
id|status
op_assign
id|pdc_pat_cell_get_number
c_func
(paren
op_amp
id|cell_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|PDC_OK
)paren
(brace
id|cell
op_assign
id|cell_info.cell_num
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t;**  get IRT for this cell.&n;&t;*/
id|irt_num_entry
op_assign
id|iosapic_load_irt
c_func
(paren
id|cell
comma
op_amp
id|irt_cell
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|irt_num_entry
)paren
id|irt_cell
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* old PDC w/o iosapic */
)brace
multiline_comment|/*&n;** Return the IRT entry in case we need to look something else up.&n;*/
r_static
r_struct
id|irt_entry
op_star
DECL|function|irt_find_irqline
id|irt_find_irqline
c_func
(paren
r_struct
id|iosapic_info
op_star
id|isi
comma
id|u8
id|slot
comma
id|u8
id|intr_pin
)paren
(brace
r_struct
id|irt_entry
op_star
id|i
op_assign
id|irt_cell
suffix:semicolon
r_int
id|cnt
suffix:semicolon
multiline_comment|/* track how many entries we&squot;ve looked at */
id|u8
id|irq_devno
op_assign
(paren
id|slot
op_lshift
id|IRT_DEV_SHIFT
)paren
op_or
(paren
id|intr_pin
op_minus
l_int|1
)paren
suffix:semicolon
id|DBG_IRT
c_func
(paren
l_string|&quot;irt_find_irqline() SLOT %d pin %d&bslash;n&quot;
comma
id|slot
comma
id|intr_pin
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|irt_num_entry
suffix:semicolon
id|cnt
op_increment
comma
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;** Validate: entry_type, entry_length, interrupt_type&n;&t;&t;**&n;&t;&t;** Difference between validate vs compare is the former&n;&t;&t;** should print debug info and is not expected to &quot;fail&quot;&n;&t;&t;** on current platforms.&n;&t;&t;*/
r_if
c_cond
(paren
id|i-&gt;entry_type
op_ne
id|IRT_IOSAPIC_TYPE
)paren
(brace
id|DBG_IRT
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;:find_irqline(0x%p): skipping entry %d type %d&bslash;n&quot;
comma
id|i
comma
id|cnt
comma
id|i-&gt;entry_type
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i-&gt;entry_length
op_ne
id|IRT_IOSAPIC_LENGTH
)paren
(brace
id|DBG_IRT
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;:find_irqline(0x%p): skipping entry %d  length %d&bslash;n&quot;
comma
id|i
comma
id|cnt
comma
id|i-&gt;entry_length
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i-&gt;interrupt_type
op_ne
id|IRT_VECTORED_INTR
)paren
(brace
id|DBG_IRT
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;:find_irqline(0x%p): skipping entry  %d interrupt_type %d&bslash;n&quot;
comma
id|i
comma
id|cnt
comma
id|i-&gt;interrupt_type
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** Compare: dest_iosapic_addr, src_bus_irq_devno&n;&t;&t;*/
r_if
c_cond
(paren
id|i-&gt;dest_iosapic_addr
op_ne
(paren
id|u64
)paren
(paren
(paren
r_int
)paren
id|isi-&gt;isi_hpa
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i-&gt;src_bus_irq_devno
op_amp
id|IRT_IRQ_DEVNO_MASK
)paren
op_ne
id|irq_devno
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Ignore: src_bus_id and rc_seg_id correlate with&n;&t;&t;**         iosapic_info-&gt;isi_hpa on HP platforms.&n;&t;&t;**         If needed, pass in &quot;PFA&quot; (aka config space addr)&n;&t;&t;**         instead of slot.&n;&t;&t;*/
multiline_comment|/* Found it! */
r_return
id|i
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;: 0x%lx : no IRT entry for slot %d, pin %d&bslash;n&quot;
comma
id|isi-&gt;isi_hpa
comma
id|slot
comma
id|intr_pin
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;** xlate_pin() supports the skewing of IRQ lines done by subsidiary bridges.&n;** Legacy PDC already does this translation for us and stores it in INTR_LINE.&n;**&n;** PAT PDC needs to basically do what legacy PDC does:&n;** o read PIN&n;** o adjust PIN in case device is &quot;behind&quot; a PPB&n;**     (eg 4-port 100BT and SCSI/LAN &quot;Combo Card&quot;)&n;** o convert slot/pin to I/O SAPIC input line.&n;**&n;** HP platforms only support:&n;** o one level of skewing for any number of PPBs&n;** o only support PCI-PCI Bridges.&n;*/
r_static
r_struct
id|irt_entry
op_star
DECL|function|iosapic_xlate_pin
id|iosapic_xlate_pin
c_func
(paren
r_struct
id|iosapic_info
op_star
id|isi
comma
r_struct
id|pci_dev
op_star
id|pcidev
)paren
(brace
id|u8
id|intr_pin
comma
id|intr_slot
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pcidev
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|intr_pin
)paren
suffix:semicolon
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_xlate_pin() SLOT %d pin %d&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|pcidev-&gt;devfn
)paren
comma
id|intr_pin
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|intr_pin
)paren
(brace
multiline_comment|/* The device does NOT support/use IRQ lines.  */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Check if pcidev behind a PPB */
r_if
c_cond
(paren
l_int|NULL
op_ne
id|pcidev-&gt;bus-&gt;self
)paren
(brace
multiline_comment|/* Convert pcidev INTR_PIN into something we&n;&t;&t;** can lookup in the IRT.&n;&t;&t;*/
macro_line|#ifdef PCI_BRIDGE_FUNCS
multiline_comment|/*&n;&t;&t;** Proposal #1:&n;&t;&t;**&n;&t;&t;** call implementation specific translation function&n;&t;&t;** This is architecturally &quot;cleaner&quot;. HP-UX doesn&squot;t&n;&t;&t;** support other secondary bus types (eg. E/ISA) directly.&n;&t;&t;** May be needed for other processor (eg IA64) architectures&n;&t;&t;** or by some ambitous soul who wants to watch TV.&n;&t;&t;*/
r_if
c_cond
(paren
id|pci_bridge_funcs-&gt;xlate_intr_line
)paren
(brace
id|intr_pin
op_assign
id|pci_bridge_funcs
op_member_access_from_pointer
id|xlate_intr_line
c_func
(paren
id|pcidev
)paren
suffix:semicolon
)brace
macro_line|#else&t;/* PCI_BRIDGE_FUNCS */
r_struct
id|pci_bus
op_star
id|p
op_assign
id|pcidev-&gt;bus
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Proposal #2:&n;&t;&t;** The &quot;pin&quot; is skewed ((pin + dev - 1) % 4).&n;&t;&t;**&n;&t;&t;** This isn&squot;t very clean since I/O SAPIC must assume:&n;&t;&t;**   - all platforms only have PCI busses.&n;&t;&t;**   - only PCI-PCI bridge (eg not PCI-EISA, PCI-PCMCIA)&n;&t;&t;**   - IRQ routing is only skewed once regardless of&n;&t;&t;**     the number of PPB&squot;s between iosapic and device.&n;&t;&t;**     (Bit3 expansion chassis follows this rule)&n;&t;&t;**&n;&t;&t;** Advantage is it&squot;s really easy to implement.&n;&t;&t;*/
id|intr_pin
op_assign
(paren
(paren
id|intr_pin
op_minus
l_int|1
)paren
op_plus
id|PCI_SLOT
c_func
(paren
id|pcidev-&gt;devfn
)paren
)paren
op_mod
l_int|4
suffix:semicolon
id|intr_pin
op_increment
suffix:semicolon
multiline_comment|/* convert back to INTA-D (1-4) */
macro_line|#endif /* PCI_BRIDGE_FUNCS */
multiline_comment|/*&n;&t;&t;** Locate the host slot the PPB nearest the Host bus&n;&t;&t;** adapter.&n;&t;&t;*/
r_while
c_loop
(paren
l_int|NULL
op_ne
id|p-&gt;parent-&gt;self
)paren
id|p
op_assign
id|p-&gt;parent
suffix:semicolon
id|intr_slot
op_assign
id|PCI_SLOT
c_func
(paren
id|p-&gt;self-&gt;devfn
)paren
suffix:semicolon
)brace
r_else
(brace
id|intr_slot
op_assign
id|PCI_SLOT
c_func
(paren
id|pcidev-&gt;devfn
)paren
suffix:semicolon
)brace
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_xlate_pin:  bus %d slot %d pin %d&bslash;n&quot;
comma
id|pcidev-&gt;bus-&gt;secondary
comma
id|intr_slot
comma
id|intr_pin
)paren
suffix:semicolon
r_return
id|irt_find_irqline
c_func
(paren
id|isi
comma
id|intr_slot
comma
id|intr_pin
)paren
suffix:semicolon
)brace
DECL|function|iosapic_rd_irt_entry
r_static
r_void
id|iosapic_rd_irt_entry
c_func
(paren
r_struct
id|vector_info
op_star
id|vi
comma
id|u32
op_star
id|dp0
comma
id|u32
op_star
id|dp1
)paren
(brace
r_struct
id|iosapic_info
op_star
id|isp
op_assign
id|vi-&gt;iosapic
suffix:semicolon
id|u8
id|idx
op_assign
id|vi-&gt;irqline
suffix:semicolon
op_star
id|dp0
op_assign
id|iosapic_read
c_func
(paren
id|isp-&gt;addr
comma
id|IOSAPIC_IRDT_ENTRY
c_func
(paren
id|idx
)paren
)paren
suffix:semicolon
op_star
id|dp1
op_assign
id|iosapic_read
c_func
(paren
id|isp-&gt;addr
comma
id|IOSAPIC_IRDT_ENTRY_HI
c_func
(paren
id|idx
)paren
)paren
suffix:semicolon
)brace
DECL|function|iosapic_wr_irt_entry
r_static
r_void
id|iosapic_wr_irt_entry
c_func
(paren
r_struct
id|vector_info
op_star
id|vi
comma
id|u32
id|dp0
comma
id|u32
id|dp1
)paren
(brace
r_struct
id|iosapic_info
op_star
id|isp
op_assign
id|vi-&gt;iosapic
suffix:semicolon
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_wr_irt_entry(): irq %d hpa %lx 0x%x 0x%x&bslash;n&quot;
comma
id|vi-&gt;irqline
comma
id|isp-&gt;isi_hpa
comma
id|dp0
comma
id|dp1
)paren
suffix:semicolon
id|iosapic_write
c_func
(paren
id|isp-&gt;addr
comma
id|IOSAPIC_IRDT_ENTRY
c_func
(paren
id|vi-&gt;irqline
)paren
comma
id|dp0
)paren
suffix:semicolon
multiline_comment|/* Read the window register to flush the writes down to HW  */
id|dp0
op_assign
id|readl
c_func
(paren
id|isp-&gt;addr
op_plus
id|IOSAPIC_REG_WINDOW
)paren
suffix:semicolon
id|iosapic_write
c_func
(paren
id|isp-&gt;addr
comma
id|IOSAPIC_IRDT_ENTRY_HI
c_func
(paren
id|vi-&gt;irqline
)paren
comma
id|dp1
)paren
suffix:semicolon
multiline_comment|/* Read the window register to flush the writes down to HW  */
id|dp1
op_assign
id|readl
c_func
(paren
id|isp-&gt;addr
op_plus
id|IOSAPIC_REG_WINDOW
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** set_irt prepares the data (dp0, dp1) according to the vector_info&n;** and target cpu (id_eid).  dp0/dp1 are then used to program I/O SAPIC&n;** IRdT for the given &quot;vector&quot; (aka IRQ line).&n;*/
r_static
r_void
DECL|function|iosapic_set_irt_data
id|iosapic_set_irt_data
c_func
(paren
r_struct
id|vector_info
op_star
id|vi
comma
id|u32
op_star
id|dp0
comma
id|u32
op_star
id|dp1
)paren
(brace
id|u32
id|mode
op_assign
l_int|0
suffix:semicolon
r_struct
id|irt_entry
op_star
id|p
op_assign
id|vi-&gt;irte
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|vi-&gt;irte
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;polarity_trigger
op_amp
id|IRT_PO_MASK
)paren
op_eq
id|IRT_ACTIVE_LO
)paren
id|mode
op_or_assign
id|IOSAPIC_IRDT_PO_LOW
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|p-&gt;polarity_trigger
op_rshift
id|IRT_EL_SHIFT
)paren
op_amp
id|IRT_EL_MASK
)paren
op_eq
id|IRT_LEVEL_TRIG
)paren
id|mode
op_or_assign
id|IOSAPIC_IRDT_LEVEL_TRIG
suffix:semicolon
multiline_comment|/*&n;&t;** IA64 REVISIT&n;&t;** PA doesn&squot;t support EXTINT or LPRIO bits.&n;&t;*/
id|ASSERT
c_func
(paren
id|vi-&gt;txn_data
)paren
suffix:semicolon
op_star
id|dp0
op_assign
id|mode
op_or
(paren
id|u32
)paren
id|vi-&gt;txn_data
suffix:semicolon
multiline_comment|/*&n;&t;** Extracting id_eid isn&squot;t a real clean way of getting it.&n;&t;** But the encoding is the same for both PA and IA64 platforms.&n;&t;*/
r_if
c_cond
(paren
id|is_pdc_pat
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;** PAT PDC just hands it to us &quot;right&quot;.&n;&t;&t;** txn_addr comes from cpu_data[x].txn_addr.&n;&t;&t;*/
op_star
id|dp1
op_assign
(paren
id|u32
)paren
(paren
id|vi-&gt;txn_addr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t;** eg if base_addr == 0xfffa0000),&n;&t;&t;**    we want to get 0xa0ff0000.&n;&t;&t;**&n;&t;&t;** eid&t;0x0ff00000 -&gt; 0x00ff0000&n;&t;&t;** id&t;0x000ff000 -&gt; 0xff000000&n;&t;&t;*/
op_star
id|dp1
op_assign
(paren
(paren
(paren
id|u32
)paren
id|vi-&gt;txn_addr
op_amp
l_int|0x0ff00000
)paren
op_rshift
l_int|4
)paren
op_or
(paren
(paren
(paren
id|u32
)paren
id|vi-&gt;txn_addr
op_amp
l_int|0x000ff000
)paren
op_lshift
l_int|12
)paren
suffix:semicolon
)brace
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_set_irt_data(): 0x%x 0x%x&bslash;n&quot;
comma
op_star
id|dp0
comma
op_star
id|dp1
)paren
suffix:semicolon
)brace
DECL|function|iosapic_get_vector
r_static
r_struct
id|vector_info
op_star
id|iosapic_get_vector
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_return
id|irq_desc
(braket
id|irq
)braket
dot
id|handler_data
suffix:semicolon
)brace
DECL|function|iosapic_disable_irq
r_static
r_void
id|iosapic_disable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|vector_info
op_star
id|vi
op_assign
id|iosapic_get_vector
c_func
(paren
id|irq
)paren
suffix:semicolon
id|u32
id|d0
comma
id|d1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|iosapic_lock
comma
id|flags
)paren
suffix:semicolon
id|iosapic_rd_irt_entry
c_func
(paren
id|vi
comma
op_amp
id|d0
comma
op_amp
id|d1
)paren
suffix:semicolon
id|d0
op_or_assign
id|IOSAPIC_IRDT_ENABLE
suffix:semicolon
id|iosapic_wr_irt_entry
c_func
(paren
id|vi
comma
id|d0
comma
id|d1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|iosapic_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|iosapic_enable_irq
r_static
r_void
id|iosapic_enable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|vector_info
op_star
id|vi
op_assign
id|iosapic_get_vector
c_func
(paren
id|irq
)paren
suffix:semicolon
id|u32
id|d0
comma
id|d1
suffix:semicolon
multiline_comment|/* data is initialized by fixup_irq */
id|WARN_ON
c_func
(paren
id|vi-&gt;txn_irq
op_eq
l_int|0
)paren
suffix:semicolon
id|iosapic_set_irt_data
c_func
(paren
id|vi
comma
op_amp
id|d0
comma
op_amp
id|d1
)paren
suffix:semicolon
id|iosapic_wr_irt_entry
c_func
(paren
id|vi
comma
id|d0
comma
id|d1
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOSAPIC_IRT
(brace
id|u32
op_star
id|t
op_assign
(paren
id|u32
op_star
)paren
(paren
(paren
id|ulong
)paren
id|vi-&gt;eoi_addr
op_amp
op_complement
l_int|0xffUL
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;iosapic_enable_irq(): regs %p&quot;
comma
id|vi-&gt;eoi_addr
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|t
OL
id|vi-&gt;eoi_addr
suffix:semicolon
id|t
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %x&quot;
comma
id|readl
c_func
(paren
id|t
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;iosapic_enable_irq(): sel &quot;
)paren
suffix:semicolon
(brace
r_struct
id|iosapic_info
op_star
id|isp
op_assign
id|vi-&gt;iosapic
suffix:semicolon
r_for
c_loop
(paren
id|d0
op_assign
l_int|0x10
suffix:semicolon
id|d0
OL
l_int|0x1e
suffix:semicolon
id|d0
op_increment
)paren
(brace
id|d1
op_assign
id|iosapic_read
c_func
(paren
id|isp-&gt;addr
comma
id|d0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %x&quot;
comma
id|d1
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Issuing I/O SAPIC an EOI causes an interrupt IFF IRQ line is&n;&t; * asserted.  IRQ generally should not be asserted when a driver&n;&t; * enables their IRQ. It can lead to &quot;interesting&quot; race conditions&n;&t; * in the driver initialization sequence.&n;&t; */
id|DBG
c_func
(paren
id|KERN_DEBUG
l_string|&quot;enable_irq(%d): eoi(%p, 0x%x)&bslash;n&quot;
comma
id|irq
comma
id|vi-&gt;eoi_addr
comma
id|vi-&gt;eoi_data
)paren
suffix:semicolon
id|iosapic_eoi
c_func
(paren
id|vi-&gt;eoi_addr
comma
id|vi-&gt;eoi_data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * PARISC only supports PCI devices below I/O SAPIC.&n; * PCI only supports level triggered in order to share IRQ lines.&n; * ergo I/O SAPIC must always issue EOI on parisc.&n; *&n; * i386/ia64 support ISA devices and have to deal with&n; * edge-triggered interrupts too.&n; */
DECL|function|iosapic_end_irq
r_static
r_void
id|iosapic_end_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|vector_info
op_star
id|vi
op_assign
id|iosapic_get_vector
c_func
(paren
id|irq
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_DEBUG
l_string|&quot;end_irq(%d): eoi(%p, 0x%x)&bslash;n&quot;
comma
id|irq
comma
id|vi-&gt;eoi_addr
comma
id|vi-&gt;eoi_data
)paren
suffix:semicolon
id|iosapic_eoi
c_func
(paren
id|vi-&gt;eoi_addr
comma
id|vi-&gt;eoi_data
)paren
suffix:semicolon
)brace
DECL|function|iosapic_startup_irq
r_static
r_int
r_int
id|iosapic_startup_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|iosapic_enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|iosapic_interrupt_type
r_static
r_struct
id|hw_interrupt_type
id|iosapic_interrupt_type
op_assign
(brace
dot
r_typename
op_assign
l_string|&quot;IO-SAPIC-level&quot;
comma
dot
id|startup
op_assign
id|iosapic_startup_irq
comma
dot
id|shutdown
op_assign
id|iosapic_disable_irq
comma
dot
id|enable
op_assign
id|iosapic_enable_irq
comma
dot
id|disable
op_assign
id|iosapic_disable_irq
comma
dot
id|ack
op_assign
id|no_ack_irq
comma
dot
id|end
op_assign
id|iosapic_end_irq
comma
singleline_comment|//&t;.set_affinity =&t;iosapic_set_affinity_irq,
)brace
suffix:semicolon
DECL|function|iosapic_fixup_irq
r_int
id|iosapic_fixup_irq
c_func
(paren
r_void
op_star
id|isi_obj
comma
r_struct
id|pci_dev
op_star
id|pcidev
)paren
(brace
r_struct
id|iosapic_info
op_star
id|isi
op_assign
id|isi_obj
suffix:semicolon
r_struct
id|irt_entry
op_star
id|irte
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* only used if PAT PDC */
r_struct
id|vector_info
op_star
id|vi
suffix:semicolon
r_int
id|isi_line
suffix:semicolon
multiline_comment|/* line used by device */
r_if
c_cond
(paren
op_logical_neg
id|isi
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;: hpa not registered for %s&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|pcidev
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SUPERIO
multiline_comment|/*&n;&t; * HACK ALERT! (non-compliant PCI device support)&n;&t; *&n;&t; * All SuckyIO interrupts are routed through the PIC&squot;s on function 1.&n;&t; * But SuckyIO OHCI USB controller gets an IRT entry anyway because&n;&t; * it advertises INT D for INT_PIN.  Use that IRT entry to get the&n;&t; * SuckyIO interrupt routing for PICs on function 1 (*BLEECCHH*).&n;&t; */
r_if
c_cond
(paren
id|is_superio_device
c_func
(paren
id|pcidev
)paren
)paren
(brace
multiline_comment|/* We must call superio_fixup_irq() to register the pdev */
id|pcidev-&gt;irq
op_assign
id|superio_fixup_irq
c_func
(paren
id|pcidev
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t return if need to program the IOSAPIC&squot;s IRT... */
r_if
c_cond
(paren
id|PCI_FUNC
c_func
(paren
id|pcidev-&gt;devfn
)paren
op_ne
id|SUPERIO_USB_FN
)paren
r_return
id|pcidev-&gt;irq
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SUPERIO */
multiline_comment|/* lookup IRT entry for isi/slot/pin set */
id|irte
op_assign
id|iosapic_xlate_pin
c_func
(paren
id|isi
comma
id|pcidev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irte
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;iosapic: no IRTE for %s (IRQ not connected?)&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|pcidev
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_fixup_irq(): irte %p %x %x %x %x %x %x %x %x&bslash;n&quot;
comma
id|irte
comma
id|irte-&gt;entry_type
comma
id|irte-&gt;entry_length
comma
id|irte-&gt;polarity_trigger
comma
id|irte-&gt;src_bus_irq_devno
comma
id|irte-&gt;src_bus_id
comma
id|irte-&gt;src_seg_id
comma
id|irte-&gt;dest_iosapic_intin
comma
(paren
id|u32
)paren
id|irte-&gt;dest_iosapic_addr
)paren
suffix:semicolon
id|isi_line
op_assign
id|irte-&gt;dest_iosapic_intin
suffix:semicolon
multiline_comment|/* get vector info for this input line */
id|vi
op_assign
id|isi-&gt;isi_vector
op_plus
id|isi_line
suffix:semicolon
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_fixup_irq:  line %d vi 0x%p&bslash;n&quot;
comma
id|isi_line
comma
id|vi
)paren
suffix:semicolon
multiline_comment|/* If this IRQ line has already been setup, skip it */
r_if
c_cond
(paren
id|vi-&gt;irte
)paren
r_goto
id|out
suffix:semicolon
id|vi-&gt;irte
op_assign
id|irte
suffix:semicolon
multiline_comment|/* Allocate processor IRQ */
id|vi-&gt;txn_irq
op_assign
id|txn_alloc_irq
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX/FIXME The txn_alloc_irq() code and related code should be&n;&t; * moved to enable_irq(). That way we only allocate processor IRQ&n;&t; * bits for devices that actually have drivers claiming them.&n;&t; * Right now we assign an IRQ to every PCI device present,&n;&t; * regardless of whether it&squot;s used or not.&n;&t; */
r_if
c_cond
(paren
id|vi-&gt;txn_irq
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;I/O sapic: couldn&squot;t get TXN IRQ&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* enable_irq() will use txn_* to program IRdT */
id|vi-&gt;txn_addr
op_assign
id|txn_alloc_addr
c_func
(paren
id|vi-&gt;txn_irq
)paren
suffix:semicolon
id|vi-&gt;txn_data
op_assign
id|txn_alloc_data
c_func
(paren
id|vi-&gt;txn_irq
comma
l_int|8
)paren
suffix:semicolon
id|vi-&gt;eoi_addr
op_assign
id|isi-&gt;addr
op_plus
id|IOSAPIC_REG_EOI
suffix:semicolon
id|vi-&gt;eoi_data
op_assign
id|cpu_to_le32
c_func
(paren
id|vi-&gt;txn_data
)paren
suffix:semicolon
id|cpu_claim_irq
c_func
(paren
id|vi-&gt;txn_irq
comma
op_amp
id|iosapic_interrupt_type
comma
id|vi
)paren
suffix:semicolon
id|out
suffix:colon
id|pcidev-&gt;irq
op_assign
id|vi-&gt;txn_irq
suffix:semicolon
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_fixup_irq() %d:%d %x %x line %d irq %d&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|pcidev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|pcidev-&gt;devfn
)paren
comma
id|pcidev-&gt;vendor
comma
id|pcidev-&gt;device
comma
id|isi_line
comma
id|pcidev-&gt;irq
)paren
suffix:semicolon
r_return
id|pcidev-&gt;irq
suffix:semicolon
)brace
multiline_comment|/*&n;** squirrel away the I/O Sapic Version&n;*/
r_static
r_int
r_int
DECL|function|iosapic_rd_version
id|iosapic_rd_version
c_func
(paren
r_struct
id|iosapic_info
op_star
id|isi
)paren
(brace
id|ASSERT
c_func
(paren
id|isi
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|isi-&gt;isi_hpa
)paren
suffix:semicolon
r_return
id|iosapic_read
c_func
(paren
id|isi-&gt;isi_hpa
comma
id|IOSAPIC_REG_VERSION
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** iosapic_register() is called by &quot;drivers&quot; with an integrated I/O SAPIC.&n;** Caller must be certain they have an I/O SAPIC and know its MMIO address.&n;**&n;**&t;o allocate iosapic_info and add it to the list&n;**&t;o read iosapic version and squirrel that away&n;**&t;o read size of IRdT.&n;**&t;o allocate and initialize isi_vector[]&n;**&t;o allocate irq region&n;*/
DECL|function|iosapic_register
r_void
op_star
id|iosapic_register
c_func
(paren
r_int
r_int
id|hpa
)paren
(brace
r_struct
id|iosapic_info
op_star
id|isi
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|irt_entry
op_star
id|irte
op_assign
id|irt_cell
suffix:semicolon
r_struct
id|vector_info
op_star
id|vip
suffix:semicolon
r_int
id|cnt
suffix:semicolon
multiline_comment|/* track how many entries we&squot;ve looked at */
multiline_comment|/*&n;&t;** Astro based platforms can&squot;t support PCI OLARD if they&n;&t;** implement the legacy PDC (not PAT). Though Legacy PDC&n;&t;** supports an IRT, LBA&squot;s with no device under them&n;&t;** are *not* listed in the IRT.&n;&t;** Search the IRT and ignore iosapic&squot;s which aren&squot;t&n;&t;** in the IRT.&n;&t;*/
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|irte
)paren
suffix:semicolon
multiline_comment|/* always have built-in devices */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|irt_num_entry
suffix:semicolon
id|cnt
op_increment
comma
id|irte
op_increment
)paren
(brace
id|ASSERT
c_func
(paren
id|IRT_IOSAPIC_TYPE
op_eq
id|irte-&gt;entry_type
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** We need sign extension of the hpa on 32-bit kernels.&n;&t;&t;** The address in the IRT is *always* 64 bit and really&n;&t;&t;** is an unsigned quantity (like all physical addresses).&n;&t;&t;*/
r_if
c_cond
(paren
id|irte-&gt;dest_iosapic_addr
op_eq
(paren
id|s64
)paren
(paren
(paren
r_int
)paren
id|hpa
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
op_ge
id|irt_num_entry
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|isi
op_assign
id|IOSAPIC_KALLOC
c_func
(paren
r_struct
id|iosapic_info
comma
l_int|1
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|isi
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|iosapic_info
)paren
)paren
suffix:semicolon
id|isi-&gt;isi_hpa
op_assign
id|hpa
suffix:semicolon
id|isi-&gt;isi_version
op_assign
id|iosapic_rd_version
c_func
(paren
id|isi
)paren
suffix:semicolon
id|isi-&gt;isi_num_vectors
op_assign
id|IOSAPIC_IRDT_MAX_ENTRY
c_func
(paren
id|isi-&gt;isi_version
)paren
op_plus
l_int|1
suffix:semicolon
id|vip
op_assign
id|isi-&gt;isi_vector
op_assign
id|IOSAPIC_KALLOC
c_func
(paren
r_struct
id|vector_info
comma
id|isi-&gt;isi_num_vectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vip
op_eq
l_int|NULL
)paren
(brace
id|IOSAPIC_FREE
c_func
(paren
id|isi
comma
r_struct
id|iosapic_info
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|vip
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|vector_info
)paren
op_star
id|isi-&gt;isi_num_vectors
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|isi-&gt;isi_num_vectors
suffix:semicolon
id|cnt
op_increment
comma
id|vip
op_increment
)paren
(brace
id|vip-&gt;irqline
op_assign
(paren
r_int
r_char
)paren
id|cnt
suffix:semicolon
id|vip-&gt;iosapic
op_assign
id|isi
suffix:semicolon
)brace
r_return
id|isi
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_IOSAPIC
r_static
r_void
DECL|function|iosapic_prt_irt
id|iosapic_prt_irt
c_func
(paren
r_void
op_star
id|irt
comma
r_int
id|num_entry
)paren
(brace
r_int
r_int
id|i
comma
op_star
id|irp
op_assign
(paren
r_int
r_int
op_star
)paren
id|irt
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|irt
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
id|MODULE_NAME
l_string|&quot;: Interrupt Routing Table (%lx entries)&bslash;n&quot;
comma
id|num_entry
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_entry
suffix:semicolon
id|i
op_increment
comma
id|irp
op_add_assign
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%p : %2d %.8x %.8x %.8x %.8x&bslash;n&quot;
comma
id|irp
comma
id|i
comma
id|irp
(braket
l_int|0
)braket
comma
id|irp
(braket
l_int|1
)braket
comma
id|irp
(braket
l_int|2
)braket
comma
id|irp
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|iosapic_prt_vi
id|iosapic_prt_vi
c_func
(paren
r_struct
id|vector_info
op_star
id|vi
)paren
(brace
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|vi
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
id|MODULE_NAME
l_string|&quot;: vector_info[%d] is at %p&bslash;n&quot;
comma
id|vi-&gt;irqline
comma
id|vi
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tstatus:&t; %.4x&bslash;n&quot;
comma
id|vi-&gt;status
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;ttxn_irq:  %d&bslash;n&quot;
comma
id|vi-&gt;txn_irq
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;ttxn_addr: %lx&bslash;n&quot;
comma
id|vi-&gt;txn_addr
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;ttxn_data: %lx&bslash;n&quot;
comma
id|vi-&gt;txn_data
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;teoi_addr: %p&bslash;n&quot;
comma
id|vi-&gt;eoi_addr
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;teoi_data: %x&bslash;n&quot;
comma
id|vi-&gt;eoi_data
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|iosapic_prt_isi
id|iosapic_prt_isi
c_func
(paren
r_struct
id|iosapic_info
op_star
id|isi
)paren
(brace
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|isi
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
id|MODULE_NAME
l_string|&quot;: io_sapic_info at %p&bslash;n&quot;
comma
id|isi
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tisi_hpa:       %lx&bslash;n&quot;
comma
id|isi-&gt;isi_hpa
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tisi_status:     %x&bslash;n&quot;
comma
id|isi-&gt;isi_status
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tisi_version:   %x&bslash;n&quot;
comma
id|isi-&gt;isi_version
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tisi_vector:    %p&bslash;n&quot;
comma
id|isi-&gt;isi_vector
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG_IOSAPIC */
eof
