multiline_comment|/**&n; * iommu_fill_pdir - Insert coalesced scatter/gather chunks into the I/O Pdir.&n; * @ioc: The I/O Controller.&n; * @startsg: The scatter/gather list of coalesced chunks.&n; * @nents: The number of entries in the scatter/gather list.&n; * @hint: The DMA Hint.&n; *&n; * This function inserts the coalesced scatter/gather list chunks into the&n; * I/O Controller&squot;s I/O Pdir.&n; */
r_static
r_inline
r_int
r_int
DECL|function|iommu_fill_pdir
id|iommu_fill_pdir
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_struct
id|scatterlist
op_star
id|startsg
comma
r_int
id|nents
comma
r_int
r_int
id|hint
comma
r_void
(paren
op_star
id|iommu_io_pdir_entry
)paren
(paren
id|u64
op_star
comma
id|space_t
comma
r_int
r_int
comma
r_int
r_int
)paren
)paren
(brace
r_struct
id|scatterlist
op_star
id|dma_sg
op_assign
id|startsg
suffix:semicolon
multiline_comment|/* pointer to current DMA */
r_int
r_int
id|n_mappings
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|dma_offset
op_assign
l_int|0
comma
id|dma_len
op_assign
l_int|0
suffix:semicolon
id|u64
op_star
id|pdirp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Horrible hack.  For efficiency&squot;s sake, dma_sg starts one &n;&t; * entry below the true start (it is immediately incremented&n;&t; * in the loop) */
id|dma_sg
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|nents
op_decrement
OG
l_int|0
)paren
(brace
r_int
r_int
id|vaddr
suffix:semicolon
r_int
id|size
suffix:semicolon
id|DBG_RUN_SG
c_func
(paren
l_string|&quot; %d : %08lx/%05x %08lx/%05x&bslash;n&quot;
comma
id|nents
comma
(paren
r_int
r_int
)paren
id|sg_dma_address
c_func
(paren
id|startsg
)paren
comma
id|cnt
comma
id|sg_virt_addr
c_func
(paren
id|startsg
)paren
comma
id|startsg-&gt;length
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Look for the start of a new DMA stream&n;&t;&t;*/
r_if
c_cond
(paren
id|sg_dma_address
c_func
(paren
id|startsg
)paren
op_amp
id|PIDE_FLAG
)paren
(brace
id|u32
id|pide
op_assign
id|sg_dma_address
c_func
(paren
id|startsg
)paren
op_amp
op_complement
id|PIDE_FLAG
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pdirp
op_logical_and
(paren
id|dma_len
op_ne
id|sg_dma_len
c_func
(paren
id|dma_sg
)paren
)paren
)paren
suffix:semicolon
id|dma_sg
op_increment
suffix:semicolon
id|dma_len
op_assign
id|sg_dma_len
c_func
(paren
id|startsg
)paren
suffix:semicolon
id|sg_dma_len
c_func
(paren
id|startsg
)paren
op_assign
l_int|0
suffix:semicolon
id|dma_offset
op_assign
(paren
r_int
r_int
)paren
id|pide
op_amp
op_complement
id|IOVP_MASK
suffix:semicolon
id|n_mappings
op_increment
suffix:semicolon
macro_line|#if defined(ZX1_SUPPORT)
multiline_comment|/* Pluto IOMMU IO Virt Address is not zero based */
id|sg_dma_address
c_func
(paren
id|dma_sg
)paren
op_assign
id|pide
op_or
id|ioc-&gt;ibase
suffix:semicolon
macro_line|#else
multiline_comment|/* SBA, ccio, and dino are zero based.&n;&t;&t;&t; * Trying to save a few CPU cycles for most users.&n;&t;&t;&t; */
id|sg_dma_address
c_func
(paren
id|dma_sg
)paren
op_assign
id|pide
suffix:semicolon
macro_line|#endif
id|pdirp
op_assign
op_amp
(paren
id|ioc-&gt;pdir_base
(braket
id|pide
op_rshift
id|IOVP_SHIFT
)braket
)paren
suffix:semicolon
id|prefetchw
c_func
(paren
id|pdirp
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|pdirp
op_eq
l_int|NULL
)paren
suffix:semicolon
id|vaddr
op_assign
id|sg_virt_addr
c_func
(paren
id|startsg
)paren
suffix:semicolon
id|sg_dma_len
c_func
(paren
id|dma_sg
)paren
op_add_assign
id|startsg-&gt;length
suffix:semicolon
id|size
op_assign
id|startsg-&gt;length
op_plus
id|dma_offset
suffix:semicolon
id|dma_offset
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef IOMMU_MAP_STATS
id|ioc-&gt;msg_pages
op_add_assign
id|startsg-&gt;length
op_rshift
id|IOVP_SHIFT
suffix:semicolon
macro_line|#endif
r_do
(brace
id|iommu_io_pdir_entry
c_func
(paren
id|pdirp
comma
id|KERNEL_SPACE
comma
id|vaddr
comma
id|hint
)paren
suffix:semicolon
id|vaddr
op_add_assign
id|IOVP_SIZE
suffix:semicolon
id|size
op_sub_assign
id|IOVP_SIZE
suffix:semicolon
id|pdirp
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|unlikely
c_func
(paren
id|size
OG
l_int|0
)paren
)paren
(brace
suffix:semicolon
)brace
id|startsg
op_increment
suffix:semicolon
)brace
r_return
id|n_mappings
suffix:semicolon
)brace
multiline_comment|/*&n;** First pass is to walk the SG list and determine where the breaks are&n;** in the DMA stream. Allocates PDIR entries but does not fill them.&n;** Returns the number of DMA chunks.&n;**&n;** Doing the fill separate from the coalescing/allocation keeps the&n;** code simpler. Future enhancement could make one pass through&n;** the sglist do both.&n;*/
r_static
r_inline
r_int
r_int
DECL|function|iommu_coalesce_chunks
id|iommu_coalesce_chunks
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_struct
id|scatterlist
op_star
id|startsg
comma
r_int
id|nents
comma
r_int
(paren
op_star
id|iommu_alloc_range
)paren
(paren
r_struct
id|ioc
op_star
comma
r_int
)paren
)paren
(brace
r_struct
id|scatterlist
op_star
id|contig_sg
suffix:semicolon
multiline_comment|/* contig chunk head */
r_int
r_int
id|dma_offset
comma
id|dma_len
suffix:semicolon
multiline_comment|/* start/len of DMA stream */
r_int
r_int
id|n_mappings
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|nents
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;** Prepare for first/next DMA stream&n;&t;&t;*/
id|contig_sg
op_assign
id|startsg
suffix:semicolon
id|dma_len
op_assign
id|startsg-&gt;length
suffix:semicolon
id|dma_offset
op_assign
id|sg_virt_addr
c_func
(paren
id|startsg
)paren
op_amp
op_complement
id|IOVP_MASK
suffix:semicolon
multiline_comment|/* PARANOID: clear entries */
id|sg_dma_address
c_func
(paren
id|startsg
)paren
op_assign
l_int|0
suffix:semicolon
id|sg_dma_len
c_func
(paren
id|startsg
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;** This loop terminates one iteration &quot;early&quot; since&n;&t;&t;** it&squot;s always looking one &quot;ahead&quot;.&n;&t;&t;*/
r_while
c_loop
(paren
op_decrement
id|nents
OG
l_int|0
)paren
(brace
r_int
r_int
id|prevstartsg_end
comma
id|startsg_end
suffix:semicolon
id|prevstartsg_end
op_assign
id|sg_virt_addr
c_func
(paren
id|startsg
)paren
op_plus
id|startsg-&gt;length
suffix:semicolon
id|startsg
op_increment
suffix:semicolon
id|startsg_end
op_assign
id|sg_virt_addr
c_func
(paren
id|startsg
)paren
op_plus
id|startsg-&gt;length
suffix:semicolon
multiline_comment|/* PARANOID: clear entries */
id|sg_dma_address
c_func
(paren
id|startsg
)paren
op_assign
l_int|0
suffix:semicolon
id|sg_dma_len
c_func
(paren
id|startsg
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** First make sure current dma stream won&squot;t&n;&t;&t;&t;** exceed DMA_CHUNK_SIZE if we coalesce the&n;&t;&t;&t;** next entry.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ROUNDUP
c_func
(paren
id|dma_len
op_plus
id|dma_offset
op_plus
id|startsg-&gt;length
comma
id|IOVP_SIZE
)paren
OG
id|DMA_CHUNK_SIZE
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;** Next see if we can append the next chunk (i.e.&n;&t;&t;&t;** it must end on one page and begin on another&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
(paren
id|prevstartsg_end
op_or
id|sg_virt_addr
c_func
(paren
id|startsg
)paren
)paren
op_amp
op_complement
id|PAGE_MASK
)paren
op_ne
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|dma_len
op_add_assign
id|startsg-&gt;length
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** End of DMA Stream&n;&t;&t;** Terminate last VCONTIG block.&n;&t;&t;** Allocate space for DMA stream.&n;&t;&t;*/
id|sg_dma_len
c_func
(paren
id|contig_sg
)paren
op_assign
id|dma_len
suffix:semicolon
id|dma_len
op_assign
id|ROUNDUP
c_func
(paren
id|dma_len
op_plus
id|dma_offset
comma
id|IOVP_SIZE
)paren
suffix:semicolon
id|sg_dma_address
c_func
(paren
id|contig_sg
)paren
op_assign
id|PIDE_FLAG
op_or
(paren
id|iommu_alloc_range
c_func
(paren
id|ioc
comma
id|dma_len
)paren
op_lshift
id|IOVP_SHIFT
)paren
op_or
id|dma_offset
suffix:semicolon
id|n_mappings
op_increment
suffix:semicolon
)brace
r_return
id|n_mappings
suffix:semicolon
)brace
eof
