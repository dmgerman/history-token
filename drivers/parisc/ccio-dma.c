multiline_comment|/*&n;** ccio-dma.c:&n;**&t;DMA management routines for first generation cache-coherent machines.&n;**&t;Program U2/Uturn in &quot;Virtual Mode&quot; and use the I/O MMU.&n;**&n;**&t;(c) Copyright 2000 Grant Grundler&n;**&t;(c) Copyright 2000 Ryan Bradetich&n;**&t;(c) Copyright 2000 Hewlett-Packard Company&n;**&n;** This program is free software; you can redistribute it and/or modify&n;** it under the terms of the GNU General Public License as published by&n;** the Free Software Foundation; either version 2 of the License, or&n;** (at your option) any later version.&n;**&n;**&n;**  &quot;Real Mode&quot; operation refers to U2/Uturn chip operation.&n;**  U2/Uturn were designed to perform coherency checks w/o using&n;**  the I/O MMU - basically what x86 does.&n;**&n;**  Philipp Rumpf has a &quot;Real Mode&quot; driver for PCX-W machines at:&n;**      CVSROOT=:pserver:anonymous@198.186.203.37:/cvsroot/linux-parisc&n;**      cvs -z3 co linux/arch/parisc/kernel/dma-rm.c&n;**&n;**  I&squot;ve rewritten his code to work under TPG&squot;s tree. See ccio-rm-dma.c.&n;**&n;**  Drawbacks of using Real Mode are:&n;**&t;o outbound DMA is slower - U2 won&squot;t prefetch data (GSC+ XQL signal).&n;**      o Inbound DMA less efficient - U2 can&squot;t use DMA_FAST attribute.&n;**&t;o Ability to do scatter/gather in HW is lost.&n;**&t;o Doesn&squot;t work under PCX-U/U+ machines since they didn&squot;t follow&n;**        the coherency design originally worked out. Only PCX-W does.&n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
DECL|macro|PCI_DEBUG
mdefine_line|#define PCI_DEBUG
macro_line|#include &lt;linux/pci.h&gt;
DECL|macro|PCI_DEBUG
macro_line|#undef PCI_DEBUG
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/cache.h&gt;&t;&t;/* for L1_CACHE_BYTES */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;       /* for register_module() */
macro_line|#include &lt;asm/parisc-device.h&gt;
multiline_comment|/* &n;** Choose &quot;ccio&quot; since that&squot;s what HP-UX calls it.&n;** Make it easier for folks to migrate from one to the other :^)&n;*/
DECL|macro|MODULE_NAME
mdefine_line|#define MODULE_NAME &quot;ccio&quot;
DECL|macro|DEBUG_CCIO_RES
macro_line|#undef DEBUG_CCIO_RES
DECL|macro|DEBUG_CCIO_RUN
macro_line|#undef DEBUG_CCIO_RUN
DECL|macro|DEBUG_CCIO_INIT
macro_line|#undef DEBUG_CCIO_INIT
DECL|macro|DEBUG_CCIO_RUN_SG
macro_line|#undef DEBUG_CCIO_RUN_SG
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;asm/runway.h&gt;&t;&t;/* for proc_runway_root */
macro_line|#ifdef DEBUG_CCIO_INIT
DECL|macro|DBG_INIT
mdefine_line|#define DBG_INIT(x...)  printk(x)
macro_line|#else
DECL|macro|DBG_INIT
mdefine_line|#define DBG_INIT(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_CCIO_RUN
DECL|macro|DBG_RUN
mdefine_line|#define DBG_RUN(x...)   printk(x)
macro_line|#else
DECL|macro|DBG_RUN
mdefine_line|#define DBG_RUN(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_CCIO_RES
DECL|macro|DBG_RES
mdefine_line|#define DBG_RES(x...)   printk(x)
macro_line|#else
DECL|macro|DBG_RES
mdefine_line|#define DBG_RES(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_CCIO_RUN_SG
DECL|macro|DBG_RUN_SG
mdefine_line|#define DBG_RUN_SG(x...) printk(x)
macro_line|#else
DECL|macro|DBG_RUN_SG
mdefine_line|#define DBG_RUN_SG(x...)
macro_line|#endif
DECL|macro|CCIO_INLINE
mdefine_line|#define CCIO_INLINE&t;/* inline */
DECL|macro|WRITE_U32
mdefine_line|#define WRITE_U32(value, addr) gsc_writel(value, (u32 *)(addr))
DECL|macro|READ_U32
mdefine_line|#define READ_U32(addr) gsc_readl((u32 *)(addr))
DECL|macro|U2_IOA_RUNWAY
mdefine_line|#define U2_IOA_RUNWAY 0x580
DECL|macro|U2_BC_GSC
mdefine_line|#define U2_BC_GSC     0x501
DECL|macro|UTURN_IOA_RUNWAY
mdefine_line|#define UTURN_IOA_RUNWAY 0x581
DECL|macro|UTURN_BC_GSC
mdefine_line|#define UTURN_BC_GSC     0x502
DECL|macro|IOA_NORMAL_MODE
mdefine_line|#define IOA_NORMAL_MODE      0x00020080 /* IO_CONTROL to turn on CCIO        */
DECL|macro|CMD_TLB_DIRECT_WRITE
mdefine_line|#define CMD_TLB_DIRECT_WRITE 35         /* IO_COMMAND for I/O TLB Writes     */
DECL|macro|CMD_TLB_PURGE
mdefine_line|#define CMD_TLB_PURGE        33         /* IO_COMMAND to Purge I/O TLB entry */
DECL|struct|ioa_registers
r_struct
id|ioa_registers
(brace
multiline_comment|/* Runway Supervisory Set */
DECL|member|unused1
r_volatile
r_int32
id|unused1
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|io_command
r_volatile
r_uint32
id|io_command
suffix:semicolon
multiline_comment|/* Offset 12 */
DECL|member|io_status
r_volatile
r_uint32
id|io_status
suffix:semicolon
multiline_comment|/* Offset 13 */
DECL|member|io_control
r_volatile
r_uint32
id|io_control
suffix:semicolon
multiline_comment|/* Offset 14 */
DECL|member|unused2
r_volatile
r_int32
id|unused2
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Runway Auxiliary Register Set */
DECL|member|io_err_resp
r_volatile
r_uint32
id|io_err_resp
suffix:semicolon
multiline_comment|/* Offset  0 */
DECL|member|io_err_info
r_volatile
r_uint32
id|io_err_info
suffix:semicolon
multiline_comment|/* Offset  1 */
DECL|member|io_err_req
r_volatile
r_uint32
id|io_err_req
suffix:semicolon
multiline_comment|/* Offset  2 */
DECL|member|io_err_resp_hi
r_volatile
r_uint32
id|io_err_resp_hi
suffix:semicolon
multiline_comment|/* Offset  3 */
DECL|member|io_tlb_entry_m
r_volatile
r_uint32
id|io_tlb_entry_m
suffix:semicolon
multiline_comment|/* Offset  4 */
DECL|member|io_tlb_entry_l
r_volatile
r_uint32
id|io_tlb_entry_l
suffix:semicolon
multiline_comment|/* Offset  5 */
DECL|member|unused3
r_volatile
r_uint32
id|unused3
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|io_pdir_base
r_volatile
r_uint32
id|io_pdir_base
suffix:semicolon
multiline_comment|/* Offset  7 */
DECL|member|io_io_low_hv
r_volatile
r_uint32
id|io_io_low_hv
suffix:semicolon
multiline_comment|/* Offset  8 */
DECL|member|io_io_high_hv
r_volatile
r_uint32
id|io_io_high_hv
suffix:semicolon
multiline_comment|/* Offset  9 */
DECL|member|unused4
r_volatile
r_uint32
id|unused4
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|io_chain_id_mask
r_volatile
r_uint32
id|io_chain_id_mask
suffix:semicolon
multiline_comment|/* Offset 11 */
DECL|member|unused5
r_volatile
r_uint32
id|unused5
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|io_io_low
r_volatile
r_uint32
id|io_io_low
suffix:semicolon
multiline_comment|/* Offset 14 */
DECL|member|io_io_high
r_volatile
r_uint32
id|io_io_high
suffix:semicolon
multiline_comment|/* Offset 15 */
)brace
suffix:semicolon
multiline_comment|/*&n;** IOA Registers&n;** -------------&n;**&n;** Runway IO_CONTROL Register (+0x38)&n;** &n;** The Runway IO_CONTROL register controls the forwarding of transactions.&n;**&n;** | 0  ...  13  |  14 15 | 16 ... 21 | 22 | 23 24 |  25 ... 31 |&n;** |    HV       |   TLB  |  reserved | HV | mode  |  reserved  |&n;**&n;** o mode field indicates the address translation of transactions&n;**   forwarded from Runway to GSC+:&n;**       Mode Name     Value        Definition&n;**       Off (default)   0          Opaque to matching addresses.&n;**       Include         1          Transparent for matching addresses.&n;**       Peek            3          Map matching addresses.&n;**&n;**       + &quot;Off&quot; mode: Runway transactions which match the I/O range&n;**         specified by the IO_IO_LOW/IO_IO_HIGH registers will be ignored.&n;**       + &quot;Include&quot; mode: all addresses within the I/O range specified&n;**         by the IO_IO_LOW and IO_IO_HIGH registers are transparently&n;**         forwarded. This is the I/O Adapter&squot;s normal operating mode.&n;**       + &quot;Peek&quot; mode: used during system configuration to initialize the&n;**         GSC+ bus. Runway Write_Shorts in the address range specified by&n;**         IO_IO_LOW and IO_IO_HIGH are forwarded through the I/O Adapter&n;**         *AND* the GSC+ address is remapped to the Broadcast Physical&n;**         Address space by setting the 14 high order address bits of the&n;**         32 bit GSC+ address to ones.&n;**&n;** o TLB field affects transactions which are forwarded from GSC+ to Runway.&n;**   &quot;Real&quot; mode is the poweron default.&n;** &n;**   TLB Mode  Value  Description&n;**   Real        0    No TLB translation. Address is directly mapped and the&n;**                    virtual address is composed of selected physical bits.&n;**   Error       1    Software fills the TLB manually.&n;**   Normal      2    IOA fetches IO TLB misses from IO PDIR (in host memory).&n;**&n;**&n;** IO_IO_LOW_HV&t;  +0x60 (HV dependent)&n;** IO_IO_HIGH_HV  +0x64 (HV dependent)&n;** IO_IO_LOW      +0x78&t;(Architected register)&n;** IO_IO_HIGH     +0x7c&t;(Architected register)&n;**&n;** IO_IO_LOW and IO_IO_HIGH set the lower and upper bounds of the&n;** I/O Adapter address space, respectively.&n;**&n;** 0  ... 7 | 8 ... 15 |  16   ...   31 |&n;** 11111111 | 11111111 |      address   |&n;**&n;** Each LOW/HIGH pair describes a disjoint address space region.&n;** (2 per GSC+ port). Each incoming Runway transaction address is compared&n;** with both sets of LOW/HIGH registers. If the address is in the range&n;** greater than or equal to IO_IO_LOW and less than IO_IO_HIGH the transaction&n;** for forwarded to the respective GSC+ bus.&n;** Specify IO_IO_LOW equal to or greater than IO_IO_HIGH to avoid specifying&n;** an address space region.&n;**&n;** In order for a Runway address to reside within GSC+ extended address space:&n;**&t;Runway Address [0:7]    must identically compare to 8&squot;b11111111&n;**&t;Runway Address [8:11]   must be equal to IO_IO_LOW(_HV)[16:19]&n;** &t;Runway Address [12:23]  must be greater than or equal to&n;**&t;           IO_IO_LOW(_HV)[20:31] and less than IO_IO_HIGH(_HV)[20:31].&n;**&t;Runway Address [24:39]  is not used in the comparison.&n;**&n;** When the Runway transaction is forwarded to GSC+, the GSC+ address is&n;** as follows:&n;**&t;GSC+ Address[0:3]&t;4&squot;b1111&n;**&t;GSC+ Address[4:29]&t;Runway Address[12:37]&n;**&t;GSC+ Address[30:31]&t;2&squot;b00&n;**&n;** All 4 Low/High registers must be initialized (by PDC) once the lower bus&n;** is interrogated and address space is defined. The operating system will&n;** modify the architectural IO_IO_LOW and IO_IO_HIGH registers following&n;** the PDC initialization.  However, the hardware version dependent IO_IO_LOW&n;** and IO_IO_HIGH registers should not be subsequently altered by the OS.&n;** &n;** Writes to both sets of registers will take effect immediately, bypassing&n;** the queues, which ensures that subsequent Runway transactions are checked&n;** against the updated bounds values. However reads are queued, introducing&n;** the possibility of a read being bypassed by a subsequent write to the same&n;** register. This sequence can be avoided by having software wait for read&n;** returns before issuing subsequent writes.&n;*/
DECL|struct|ioc
r_struct
id|ioc
(brace
DECL|member|ioc_hpa
r_struct
id|ioa_registers
op_star
id|ioc_hpa
suffix:semicolon
multiline_comment|/* I/O MMU base address */
DECL|member|res_map
id|u8
op_star
id|res_map
suffix:semicolon
multiline_comment|/* resource map, bit == pdir entry */
DECL|member|pdir_base
id|u64
op_star
id|pdir_base
suffix:semicolon
multiline_comment|/* physical base address */
DECL|member|res_hint
id|u32
id|res_hint
suffix:semicolon
multiline_comment|/* next available IOVP - &n;&t;&t;&t;&t;&t;   circular search */
DECL|member|res_size
id|u32
id|res_size
suffix:semicolon
multiline_comment|/* size of resource map in bytes */
DECL|member|res_lock
id|spinlock_t
id|res_lock
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|macro|CCIO_SEARCH_SAMPLE
mdefine_line|#define CCIO_SEARCH_SAMPLE 0x100
DECL|member|avg_search
r_int
r_int
id|avg_search
(braket
id|CCIO_SEARCH_SAMPLE
)braket
suffix:semicolon
DECL|member|avg_idx
r_int
r_int
id|avg_idx
suffix:semicolon
multiline_comment|/* current index into avg_search */
DECL|member|used_pages
r_int
r_int
id|used_pages
suffix:semicolon
DECL|member|msingle_calls
r_int
r_int
id|msingle_calls
suffix:semicolon
DECL|member|msingle_pages
r_int
r_int
id|msingle_pages
suffix:semicolon
DECL|member|msg_calls
r_int
r_int
id|msg_calls
suffix:semicolon
DECL|member|msg_pages
r_int
r_int
id|msg_pages
suffix:semicolon
DECL|member|usingle_calls
r_int
r_int
id|usingle_calls
suffix:semicolon
DECL|member|usingle_pages
r_int
r_int
id|usingle_pages
suffix:semicolon
DECL|member|usg_calls
r_int
r_int
id|usg_calls
suffix:semicolon
DECL|member|usg_pages
r_int
r_int
id|usg_pages
suffix:semicolon
DECL|member|cujo20_bug
r_int
r_int
id|cujo20_bug
suffix:semicolon
macro_line|#endif
multiline_comment|/* STUFF We don&squot;t need in performance path */
DECL|member|pdir_size
id|u32
id|pdir_size
suffix:semicolon
multiline_comment|/* in bytes, determined by IOV Space size */
DECL|member|chainid_shift
id|u32
id|chainid_shift
suffix:semicolon
multiline_comment|/* specify bit location of chain_id */
DECL|member|next
r_struct
id|ioc
op_star
id|next
suffix:semicolon
multiline_comment|/* Linked list of discovered iocs */
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* device name from firmware */
DECL|member|hw_path
r_int
r_int
id|hw_path
suffix:semicolon
multiline_comment|/* the hardware path this ioc is associatd with */
DECL|member|fake_pci_dev
r_struct
id|pci_dev
op_star
id|fake_pci_dev
suffix:semicolon
multiline_comment|/* the fake pci_dev for non-pci devs */
DECL|member|mmio_region
r_struct
id|resource
id|mmio_region
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* The &quot;routed&quot; MMIO regions */
)brace
suffix:semicolon
multiline_comment|/* Ratio of Host MEM to IOV Space size */
DECL|variable|ccio_mem_ratio
r_static
r_int
r_int
id|ccio_mem_ratio
op_assign
l_int|4
suffix:semicolon
DECL|variable|ioc_list
r_static
r_struct
id|ioc
op_star
id|ioc_list
suffix:semicolon
DECL|variable|ioc_count
r_static
r_int
id|ioc_count
suffix:semicolon
multiline_comment|/**************************************************************&n;*&n;*   I/O Pdir Resource Management&n;*&n;*   Bits set in the resource map are in use.&n;*   Each bit can represent a number of pages.&n;*   LSbs represent lower addresses (IOVA&squot;s).&n;*&n;*   This was was copied from sba_iommu.c. Don&squot;t try to unify&n;*   the two resource managers unless a way to have different&n;*   allocation policies is also adjusted. We&squot;d like to avoid&n;*   I/O TLB thrashing by having resource allocation policy&n;*   match the I/O TLB replacement policy.&n;*&n;***************************************************************/
DECL|macro|IOVP_SIZE
mdefine_line|#define IOVP_SIZE PAGE_SIZE
DECL|macro|IOVP_SHIFT
mdefine_line|#define IOVP_SHIFT PAGE_SHIFT
DECL|macro|IOVP_MASK
mdefine_line|#define IOVP_MASK PAGE_MASK
multiline_comment|/* Convert from IOVP to IOVA and vice versa. */
DECL|macro|CCIO_IOVA
mdefine_line|#define CCIO_IOVA(iovp,offset) ((iovp) | (offset))
DECL|macro|CCIO_IOVP
mdefine_line|#define CCIO_IOVP(iova) ((iova) &amp; IOVP_MASK)
DECL|macro|PDIR_INDEX
mdefine_line|#define PDIR_INDEX(iovp)    ((iovp)&gt;&gt;IOVP_SHIFT)
DECL|macro|MKIOVP
mdefine_line|#define MKIOVP(pdir_idx)    ((long)(pdir_idx) &lt;&lt; IOVP_SHIFT)
DECL|macro|MKIOVA
mdefine_line|#define MKIOVA(iovp,offset) (dma_addr_t)((long)iovp | (long)offset)
DECL|macro|ROUNDUP
mdefine_line|#define ROUNDUP(x,y) ((x + ((y)-1)) &amp; ~((y)-1))
multiline_comment|/*&n;** Don&squot;t worry about the 150% average search length on a miss.&n;** If the search wraps around, and passes the res_hint, it will&n;** cause the kernel to panic anyhow.&n;*/
DECL|macro|CCIO_SEARCH_LOOP
mdefine_line|#define CCIO_SEARCH_LOOP(ioc, res_idx, mask_ptr, size)  &bslash;&n;       for(; res_ptr &lt; res_end; ++res_ptr) { &bslash;&n;               if(0 == (*res_ptr &amp; *mask_ptr)) { &bslash;&n;                       *res_ptr |= *mask_ptr; &bslash;&n;                       res_idx = (int)((unsigned long)res_ptr - (unsigned long)ioc-&gt;res_map); &bslash;&n;                       ioc-&gt;res_hint = res_idx + (size &gt;&gt; 3); &bslash;&n;                       goto resource_found; &bslash;&n;               } &bslash;&n;       }
DECL|macro|CCIO_FIND_FREE_MAPPING
mdefine_line|#define CCIO_FIND_FREE_MAPPING(ioa, res_idx, mask, size) &bslash;&n;       u##size *res_ptr = (u##size *)&amp;((ioc)-&gt;res_map[ioa-&gt;res_hint &amp; ~((size &gt;&gt; 3) - 1)]); &bslash;&n;       u##size *res_end = (u##size *)&amp;(ioc)-&gt;res_map[ioa-&gt;res_size]; &bslash;&n;       u##size *mask_ptr = (u##size *)&amp;mask; &bslash;&n;       CCIO_SEARCH_LOOP(ioc, res_idx, mask_ptr, size); &bslash;&n;       res_ptr = (u##size *)&amp;(ioc)-&gt;res_map[0]; &bslash;&n;       CCIO_SEARCH_LOOP(ioa, res_idx, mask_ptr, size);
multiline_comment|/*&n;** Find available bit in this ioa&squot;s resource map.&n;** Use a &quot;circular&quot; search:&n;**   o Most IOVA&squot;s are &quot;temporary&quot; - avg search time should be small.&n;** o keep a history of what happened for debugging&n;** o KISS.&n;**&n;** Perf optimizations:&n;** o search for log2(size) bits at a time.&n;** o search for available resource bits using byte/word/whatever.&n;** o use different search for &quot;large&quot; (eg &gt; 4 pages) or &quot;very large&quot;&n;**   (eg &gt; 16 pages) mappings.&n;*/
multiline_comment|/**&n; * ccio_alloc_range - Allocate pages in the ioc&squot;s resource map.&n; * @ioc: The I/O Controller.&n; * @pages_needed: The requested number of pages to be mapped into the&n; * I/O Pdir...&n; *&n; * This function searches the resource map of the ioc to locate a range&n; * of available pages for the requested size.&n; */
r_static
r_int
DECL|function|ccio_alloc_range
id|ccio_alloc_range
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_int
r_int
id|pages_needed
)paren
(brace
r_int
id|res_idx
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_int
r_int
id|cr_start
op_assign
id|mfctl
c_func
(paren
l_int|16
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|pages_needed
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|pages_needed
op_star
id|IOVP_SIZE
)paren
op_le
id|DMA_CHUNK_SIZE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pages_needed
op_le
id|BITS_PER_LONG
)paren
suffix:semicolon
id|mask
op_assign
op_complement
(paren
op_complement
l_int|0UL
op_rshift
id|pages_needed
)paren
suffix:semicolon
id|DBG_RES
c_func
(paren
l_string|&quot;%s() size: %d pages_needed %d mask 0x%08lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|size
comma
id|pages_needed
comma
id|mask
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** &quot;seek and ye shall find&quot;...praying never hurts either...&n;&t;** ggg sacrifices another 710 to the computer gods.&n;&t;*/
r_if
c_cond
(paren
id|pages_needed
op_le
l_int|8
)paren
(brace
id|CCIO_FIND_FREE_MAPPING
c_func
(paren
id|ioc
comma
id|res_idx
comma
id|mask
comma
l_int|8
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pages_needed
op_le
l_int|16
)paren
(brace
id|CCIO_FIND_FREE_MAPPING
c_func
(paren
id|ioc
comma
id|res_idx
comma
id|mask
comma
l_int|16
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pages_needed
op_le
l_int|32
)paren
(brace
id|CCIO_FIND_FREE_MAPPING
c_func
(paren
id|ioc
comma
id|res_idx
comma
id|mask
comma
l_int|32
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
)brace
r_else
r_if
c_cond
(paren
id|pages_needed
op_le
l_int|64
)paren
(brace
id|CCIO_FIND_FREE_MAPPING
c_func
(paren
id|ioc
comma
id|res_idx
comma
id|mask
comma
l_int|64
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|panic
c_func
(paren
id|__FILE__
l_string|&quot;: %s() Too many pages to map. pages_needed: %ld&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|pages_needed
)paren
suffix:semicolon
)brace
id|panic
c_func
(paren
id|__FILE__
l_string|&quot;: %s() I/O MMU is out of mapping resources.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|resource_found
suffix:colon
id|DBG_RES
c_func
(paren
l_string|&quot;%s() res_idx %d mask 0x%08lx res_hint: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|res_idx
comma
id|mask
comma
id|ioc-&gt;res_hint
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
(brace
r_int
r_int
id|cr_end
op_assign
id|mfctl
c_func
(paren
l_int|16
)paren
suffix:semicolon
r_int
r_int
id|tmp
op_assign
id|cr_end
op_minus
id|cr_start
suffix:semicolon
multiline_comment|/* check for roll over */
id|cr_start
op_assign
(paren
id|cr_end
OL
id|cr_start
)paren
ques
c_cond
op_minus
(paren
id|tmp
)paren
suffix:colon
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|ioc-&gt;avg_search
(braket
id|ioc-&gt;avg_idx
op_increment
)braket
op_assign
id|cr_start
suffix:semicolon
id|ioc-&gt;avg_idx
op_and_assign
id|CCIO_SEARCH_SAMPLE
op_minus
l_int|1
suffix:semicolon
id|ioc-&gt;used_pages
op_add_assign
id|pages_needed
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t;** return the bit address.&n;&t;*/
r_return
id|res_idx
op_lshift
l_int|3
suffix:semicolon
)brace
DECL|macro|CCIO_FREE_MAPPINGS
mdefine_line|#define CCIO_FREE_MAPPINGS(ioc, res_idx, mask, size) &bslash;&n;        u##size *res_ptr = (u##size *)&amp;((ioc)-&gt;res_map[res_idx]); &bslash;&n;&t;u##size *mask_ptr = (u##size *)&amp;mask; &bslash;&n;        ASSERT((*res_ptr &amp; *mask_ptr) == *mask_ptr); &bslash;&n;        *res_ptr &amp;= ~(*mask_ptr);
multiline_comment|/**&n; * ccio_free_range - Free pages from the ioc&squot;s resource map.&n; * @ioc: The I/O Controller.&n; * @iova: The I/O Virtual Address.&n; * @pages_mapped: The requested number of pages to be freed from the&n; * I/O Pdir.&n; *&n; * This function frees the resouces allocated for the iova.&n; */
r_static
r_void
DECL|function|ccio_free_range
id|ccio_free_range
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
id|dma_addr_t
id|iova
comma
r_int
r_int
id|pages_mapped
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_int
r_int
id|iovp
op_assign
id|CCIO_IOVP
c_func
(paren
id|iova
)paren
suffix:semicolon
r_int
r_int
id|res_idx
op_assign
id|PDIR_INDEX
c_func
(paren
id|iovp
)paren
op_rshift
l_int|3
suffix:semicolon
id|ASSERT
c_func
(paren
id|pages_mapped
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|pages_mapped
op_star
id|IOVP_SIZE
)paren
op_le
id|DMA_CHUNK_SIZE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pages_mapped
op_le
id|BITS_PER_LONG
)paren
suffix:semicolon
id|mask
op_assign
op_complement
(paren
op_complement
l_int|0UL
op_rshift
id|pages_mapped
)paren
suffix:semicolon
id|DBG_RES
c_func
(paren
l_string|&quot;%s():  res_idx: %d pages_mapped %d mask 0x%08lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|res_idx
comma
id|pages_mapped
comma
id|mask
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|ioc-&gt;used_pages
op_sub_assign
id|pages_mapped
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pages_mapped
op_le
l_int|8
)paren
(brace
id|CCIO_FREE_MAPPINGS
c_func
(paren
id|ioc
comma
id|res_idx
comma
id|mask
comma
l_int|8
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pages_mapped
op_le
l_int|16
)paren
(brace
id|CCIO_FREE_MAPPINGS
c_func
(paren
id|ioc
comma
id|res_idx
comma
id|mask
comma
l_int|16
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pages_mapped
op_le
l_int|32
)paren
(brace
id|CCIO_FREE_MAPPINGS
c_func
(paren
id|ioc
comma
id|res_idx
comma
id|mask
comma
l_int|32
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
)brace
r_else
r_if
c_cond
(paren
id|pages_mapped
op_le
l_int|64
)paren
(brace
id|CCIO_FREE_MAPPINGS
c_func
(paren
id|ioc
comma
id|res_idx
comma
id|mask
comma
l_int|64
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|panic
c_func
(paren
id|__FILE__
l_string|&quot;:%s() Too many pages to unmap.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/****************************************************************&n;**&n;**          CCIO dma_ops support routines&n;**&n;*****************************************************************/
DECL|typedef|space_t
r_typedef
r_int
r_int
id|space_t
suffix:semicolon
DECL|macro|KERNEL_SPACE
mdefine_line|#define KERNEL_SPACE 0
multiline_comment|/*&n;** DMA &quot;Page Type&quot; and Hints &n;** o if SAFE_DMA isn&squot;t set, mapping is for FAST_DMA. SAFE_DMA should be&n;**   set for subcacheline DMA transfers since we don&squot;t want to damage the&n;**   other part of a cacheline.&n;** o SAFE_DMA must be set for &quot;memory&quot; allocated via pci_alloc_consistent().&n;**   This bit tells U2 to do R/M/W for partial cachelines. &quot;Streaming&quot;&n;**   data can avoid this if the mapping covers full cache lines.&n;** o STOP_MOST is needed for atomicity across cachelines.&n;**   Apperently only &quot;some EISA devices&quot; need this.&n;**   Using CONFIG_ISA is hack. Only the IOA with EISA under it needs&n;**   to use this hint iff the EISA devices needs this feature.&n;**   According to the U2 ERS, STOP_MOST enabled pages hurt performance.&n;** o PREFETCH should *not* be set for cases like Multiple PCI devices&n;**   behind GSCtoPCI (dino) bus converter. Only one cacheline per GSC&n;**   device can be fetched and multiply DMA streams will thrash the&n;**   prefetch buffer and burn memory bandwidth. See 6.7.3 &quot;Prefetch Rules&n;**   and Invalidation of Prefetch Entries&quot;.&n;**&n;** FIXME: the default hints need to be per GSC device - not global.&n;** &n;** HP-UX dorks: linux device driver programming model is totally different&n;**    than HP-UX&squot;s. HP-UX always sets HINT_PREFETCH since it&squot;s drivers&n;**    do special things to work on non-coherent platforms...linux has to&n;**    be much more careful with this.&n;*/
DECL|macro|IOPDIR_VALID
mdefine_line|#define IOPDIR_VALID    0x01UL
DECL|macro|HINT_SAFE_DMA
mdefine_line|#define HINT_SAFE_DMA   0x02UL&t;/* used for pci_alloc_consistent() pages */
macro_line|#ifdef CONFIG_EISA
DECL|macro|HINT_STOP_MOST
mdefine_line|#define HINT_STOP_MOST  0x04UL&t;/* LSL support */
macro_line|#else
DECL|macro|HINT_STOP_MOST
mdefine_line|#define HINT_STOP_MOST  0x00UL&t;/* only needed for &quot;some EISA devices&quot; */
macro_line|#endif
DECL|macro|HINT_UDPATE_ENB
mdefine_line|#define HINT_UDPATE_ENB 0x08UL  /* not used/supported by U2 */
DECL|macro|HINT_PREFETCH
mdefine_line|#define HINT_PREFETCH   0x10UL&t;/* for outbound pages which are not SAFE */
multiline_comment|/*&n;** Use direction (ie PCI_DMA_TODEVICE) to pick hint.&n;** ccio_alloc_consistent() depends on this to get SAFE_DMA&n;** when it passes in BIDIRECTIONAL flag.&n;*/
DECL|variable|hint_lookup
r_static
id|u32
id|hint_lookup
(braket
)braket
op_assign
(brace
(braket
id|PCI_DMA_BIDIRECTIONAL
)braket
op_assign
id|HINT_STOP_MOST
op_or
id|HINT_SAFE_DMA
op_or
id|IOPDIR_VALID
comma
(braket
id|PCI_DMA_TODEVICE
)braket
op_assign
id|HINT_STOP_MOST
op_or
id|HINT_PREFETCH
op_or
id|IOPDIR_VALID
comma
(braket
id|PCI_DMA_FROMDEVICE
)braket
op_assign
id|HINT_STOP_MOST
op_or
id|IOPDIR_VALID
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * ccio_io_pdir_entry - Initialize an I/O Pdir.&n; * @pdir_ptr: A pointer into I/O Pdir.&n; * @sid: The Space Identifier.&n; * @vba: The virtual address.&n; * @hints: The DMA Hint.&n; *&n; * Given a virtual address (vba, arg2) and space id, (sid, arg1),&n; * load the I/O PDIR entry pointed to by pdir_ptr (arg0). Each IO Pdir&n; * entry consists of 8 bytes as shown below (MSB == bit 0):&n; *&n; *&n; * WORD 0:&n; * +------+----------------+-----------------------------------------------+&n; * | Phys | Virtual Index  |               Phys                            |&n; * | 0:3  |     0:11       |               4:19                            |&n; * |4 bits|   12 bits      |              16 bits                          |&n; * +------+----------------+-----------------------------------------------+&n; * WORD 1:&n; * +-----------------------+-----------------------------------------------+&n; * |      Phys    |  Rsvd  | Prefetch |Update |Rsvd  |Lock  |Safe  |Valid  |&n; * |     20:39    |        | Enable   |Enable |      |Enable|DMA   |       |&n; * |    20 bits   | 5 bits | 1 bit    |1 bit  |2 bits|1 bit |1 bit |1 bit  |&n; * +-----------------------+-----------------------------------------------+&n; *&n; * The virtual index field is filled with the results of the LCI&n; * (Load Coherence Index) instruction.  The 8 bits used for the virtual&n; * index are bits 12:19 of the value returned by LCI.&n; */
r_void
id|CCIO_INLINE
DECL|function|ccio_io_pdir_entry
id|ccio_io_pdir_entry
c_func
(paren
id|u64
op_star
id|pdir_ptr
comma
id|space_t
id|sid
comma
r_void
op_star
id|vba
comma
r_int
r_int
id|hints
)paren
(brace
r_register
r_int
r_int
id|pa
op_assign
(paren
r_volatile
r_int
r_int
)paren
id|vba
suffix:semicolon
r_register
r_int
r_int
id|ci
suffix:semicolon
multiline_comment|/* coherent index */
multiline_comment|/* We currently only support kernel addresses */
id|ASSERT
c_func
(paren
id|sid
op_eq
id|KERNEL_SPACE
)paren
suffix:semicolon
id|mtsp
c_func
(paren
id|sid
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** WORD 1 - low order word&n;&t;** &quot;hints&quot; parm includes the VALID bit!&n;&t;** &quot;dep&quot; clobbers the physical address offset bits as well.&n;&t;*/
id|pa
op_assign
id|virt_to_phys
c_func
(paren
id|vba
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;depw  %1,31,12,%0&quot;
suffix:colon
l_string|&quot;+r&quot;
(paren
id|pa
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|hints
)paren
)paren
suffix:semicolon
(paren
(paren
id|u32
op_star
)paren
id|pdir_ptr
)paren
(braket
l_int|1
)braket
op_assign
(paren
id|u32
)paren
id|pa
suffix:semicolon
multiline_comment|/*&n;&t;** WORD 0 - high order word&n;&t;*/
macro_line|#ifdef __LP64__
multiline_comment|/*&n;&t;** get bits 12:15 of physical address&n;&t;** shift bits 16:31 of physical address&n;&t;** and deposit them&n;&t;*/
id|asm
r_volatile
(paren
l_string|&quot;extrd,u %1,15,4,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ci
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|pa
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;extrd,u %1,31,16,%0&quot;
suffix:colon
l_string|&quot;+r&quot;
(paren
id|pa
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|pa
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;depd  %1,35,4,%0&quot;
suffix:colon
l_string|&quot;+r&quot;
(paren
id|pa
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|ci
)paren
)paren
suffix:semicolon
macro_line|#else
id|pa
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;** get CPU coherency index bits&n;&t;** Grab virtual index [0:11]&n;&t;** Deposit virt_idx bits into I/O PDIR word&n;&t;*/
id|asm
r_volatile
(paren
l_string|&quot;lci 0(%%sr1, %1), %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ci
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|vba
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;extru %1,19,12,%0&quot;
suffix:colon
l_string|&quot;+r&quot;
(paren
id|ci
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|ci
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;depw  %1,15,12,%0&quot;
suffix:colon
l_string|&quot;+r&quot;
(paren
id|pa
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|ci
)paren
)paren
suffix:semicolon
(paren
(paren
id|u32
op_star
)paren
id|pdir_ptr
)paren
(braket
l_int|0
)braket
op_assign
(paren
id|u32
)paren
id|pa
suffix:semicolon
multiline_comment|/* FIXME: PCX_W platforms don&squot;t need FDC/SYNC. (eg C360)&n;&t;**        PCX-U/U+ do. (eg C200/C240)&n;&t;**        PCX-T&squot;? Don&squot;t know. (eg C110 or similar K-class)&n;&t;**&n;&t;** See PDC_MODEL/option 0/SW_CAP word for &quot;Non-coherent IO-PDIR bit&quot;.&n;&t;** Hopefully we can patch (NOP) these out at boot time somehow.&n;&t;**&n;&t;** &quot;Since PCX-U employs an offset hash that is incompatible with&n;&t;** the real mode coherence index generation of U2, the PDIR entry&n;&t;** must be flushed to memory to retain coherence.&quot;&n;&t;*/
id|asm
r_volatile
(paren
l_string|&quot;fdc 0(%0)&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pdir_ptr
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;sync&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ccio_clear_io_tlb - Remove stale entries from the I/O TLB.&n; * @ioc: The I/O Controller.&n; * @iovp: The I/O Virtual Page.&n; * @byte_cnt: The requested number of bytes to be freed from the I/O Pdir.&n; *&n; * Purge invalid I/O PDIR entries from the I/O TLB.&n; *&n; * FIXME: Can we change the byte_cnt to pages_mapped?&n; */
r_static
id|CCIO_INLINE
r_void
DECL|function|ccio_clear_io_tlb
id|ccio_clear_io_tlb
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
id|dma_addr_t
id|iovp
comma
r_int
id|byte_cnt
)paren
(brace
id|u32
id|chain_size
op_assign
l_int|1
op_lshift
id|ioc-&gt;chainid_shift
suffix:semicolon
id|iovp
op_and_assign
id|IOVP_MASK
suffix:semicolon
multiline_comment|/* clear offset bits, just want pagenum */
id|byte_cnt
op_add_assign
id|chain_size
suffix:semicolon
r_while
c_loop
(paren
id|byte_cnt
OG
id|chain_size
)paren
(brace
id|WRITE_U32
c_func
(paren
id|CMD_TLB_PURGE
op_or
id|iovp
comma
op_amp
id|ioc-&gt;ioc_hpa-&gt;io_command
)paren
suffix:semicolon
id|iovp
op_add_assign
id|chain_size
suffix:semicolon
id|byte_cnt
op_sub_assign
id|chain_size
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * ccio_mark_invalid - Mark the I/O Pdir entries invalid.&n; * @ioc: The I/O Controller.&n; * @iova: The I/O Virtual Address.&n; * @byte_cnt: The requested number of bytes to be freed from the I/O Pdir.&n; *&n; * Mark the I/O Pdir entries invalid and blow away the corresponding I/O&n; * TLB entries.&n; *&n; * FIXME: at some threshhold it might be &quot;cheaper&quot; to just blow&n; *        away the entire I/O TLB instead of individual entries.&n; *&n; * FIXME: Uturn has 256 TLB entries. We don&squot;t need to purge every&n; *        PDIR entry - just once for each possible TLB entry.&n; *        (We do need to maker I/O PDIR entries invalid regardless).&n; *&n; * FIXME: Can we change byte_cnt to pages_mapped?&n; */
r_static
id|CCIO_INLINE
r_void
DECL|function|ccio_mark_invalid
id|ccio_mark_invalid
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
id|dma_addr_t
id|iova
comma
r_int
id|byte_cnt
)paren
(brace
id|u32
id|iovp
op_assign
(paren
id|u32
)paren
id|CCIO_IOVP
c_func
(paren
id|iova
)paren
suffix:semicolon
r_int
id|saved_byte_cnt
suffix:semicolon
multiline_comment|/* round up to nearest page size */
id|saved_byte_cnt
op_assign
id|byte_cnt
op_assign
id|ROUNDUP
c_func
(paren
id|byte_cnt
comma
id|IOVP_SIZE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|byte_cnt
OG
l_int|0
)paren
(brace
multiline_comment|/* invalidate one page at a time */
r_int
r_int
id|idx
op_assign
id|PDIR_INDEX
c_func
(paren
id|iovp
)paren
suffix:semicolon
r_char
op_star
id|pdir_ptr
op_assign
(paren
r_char
op_star
)paren
op_amp
(paren
id|ioc-&gt;pdir_base
(braket
id|idx
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idx
OL
(paren
id|ioc-&gt;pdir_size
op_div
r_sizeof
(paren
id|u64
)paren
)paren
)paren
suffix:semicolon
id|pdir_ptr
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear only VALID bit */
multiline_comment|/*&n;&t;&t;** FIXME: PCX_W platforms don&squot;t need FDC/SYNC. (eg C360)&n;&t;&t;**   PCX-U/U+ do. (eg C200/C240)&n;&t;&t;** See PDC_MODEL/option 0/SW_CAP for &quot;Non-coherent IO-PDIR bit&quot;.&n;&t;&t;**&n;&t;&t;** Hopefully someone figures out how to patch (NOP) the&n;&t;&t;** FDC/SYNC out at boot time.&n;&t;&t;*/
id|asm
r_volatile
(paren
l_string|&quot;fdc 0(%0)&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pdir_ptr
(braket
l_int|7
)braket
)paren
)paren
suffix:semicolon
id|iovp
op_add_assign
id|IOVP_SIZE
suffix:semicolon
id|byte_cnt
op_sub_assign
id|IOVP_SIZE
suffix:semicolon
)brace
id|asm
r_volatile
(paren
l_string|&quot;sync&quot;
)paren
suffix:semicolon
id|ccio_clear_io_tlb
c_func
(paren
id|ioc
comma
id|CCIO_IOVP
c_func
(paren
id|iova
)paren
comma
id|saved_byte_cnt
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************&n;**&n;**          CCIO dma_ops&n;**&n;*****************************************************************/
multiline_comment|/**&n; * ccio_dma_supported - Verify the IOMMU supports the DMA address range.&n; * @dev: The PCI device.&n; * @mask: A bit mask describing the DMA address range of the device.&n; *&n; * This function implements the pci_dma_supported function.&n; */
r_static
r_int
DECL|function|ccio_dma_supported
id|ccio_dma_supported
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u64
id|mask
)paren
(brace
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|MODULE_NAME
l_string|&quot;: EISA/ISA/et al not supported&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* only support 32-bit devices (ie PCI/GSC) */
r_return
(paren
r_int
)paren
(paren
id|mask
op_eq
l_int|0xffffffffUL
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ccio_map_single - Map an address range into the IOMMU.&n; * @dev: The PCI device.&n; * @addr: The start address of the DMA region.&n; * @size: The length of the DMA region.&n; * @direction: The direction of the DMA transaction (to/from device).&n; *&n; * This function implements the pci_map_single function.&n; */
r_static
id|dma_addr_t
DECL|function|ccio_map_single
id|ccio_map_single
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|addr
comma
r_int
id|size
comma
r_enum
id|dma_data_direction
id|direction
)paren
(brace
r_int
id|idx
suffix:semicolon
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dma_addr_t
id|iovp
suffix:semicolon
id|dma_addr_t
id|offset
suffix:semicolon
id|u64
op_star
id|pdir_start
suffix:semicolon
r_int
r_int
id|hint
op_assign
id|hint_lookup
(braket
(paren
r_int
)paren
id|direction
)braket
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dev
)paren
suffix:semicolon
id|ioc
op_assign
id|GET_IOC
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|size
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/* save offset bits */
id|offset
op_assign
(paren
(paren
r_int
r_int
)paren
id|addr
)paren
op_amp
op_complement
id|IOVP_MASK
suffix:semicolon
multiline_comment|/* round up to nearest IOVP_SIZE */
id|size
op_assign
id|ROUNDUP
c_func
(paren
id|size
op_plus
id|offset
comma
id|IOVP_SIZE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|ioc-&gt;msingle_calls
op_increment
suffix:semicolon
id|ioc-&gt;msingle_pages
op_add_assign
id|size
op_rshift
id|IOVP_SHIFT
suffix:semicolon
macro_line|#endif
id|idx
op_assign
id|ccio_alloc_range
c_func
(paren
id|ioc
comma
(paren
id|size
op_rshift
id|IOVP_SHIFT
)paren
)paren
suffix:semicolon
id|iovp
op_assign
(paren
id|dma_addr_t
)paren
id|MKIOVP
c_func
(paren
id|idx
)paren
suffix:semicolon
id|pdir_start
op_assign
op_amp
(paren
id|ioc-&gt;pdir_base
(braket
id|idx
)braket
)paren
suffix:semicolon
id|DBG_RUN
c_func
(paren
l_string|&quot;%s() 0x%p -&gt; 0x%lx size: %0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|addr
comma
(paren
r_int
)paren
id|iovp
op_or
id|offset
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* If not cacheline aligned, force SAFE_DMA on the whole mess */
r_if
c_cond
(paren
(paren
id|size
op_mod
id|L1_CACHE_BYTES
)paren
op_logical_or
(paren
(paren
r_int
r_int
)paren
id|addr
op_mod
id|L1_CACHE_BYTES
)paren
)paren
(brace
id|hint
op_or_assign
id|HINT_SAFE_DMA
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|ccio_io_pdir_entry
c_func
(paren
id|pdir_start
comma
id|KERNEL_SPACE
comma
id|addr
comma
id|hint
)paren
suffix:semicolon
id|DBG_RUN
c_func
(paren
l_string|&quot; pdir %p %08x%08x&bslash;n&quot;
comma
id|pdir_start
comma
(paren
id|u32
)paren
(paren
(paren
(paren
id|u32
op_star
)paren
id|pdir_start
)paren
(braket
l_int|0
)braket
)paren
comma
(paren
id|u32
)paren
(paren
(paren
(paren
id|u32
op_star
)paren
id|pdir_start
)paren
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
op_increment
id|pdir_start
suffix:semicolon
id|addr
op_add_assign
id|IOVP_SIZE
suffix:semicolon
id|size
op_sub_assign
id|IOVP_SIZE
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* form complete address */
r_return
id|CCIO_IOVA
c_func
(paren
id|iovp
comma
id|offset
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ccio_unmap_single - Unmap an address range from the IOMMU.&n; * @dev: The PCI device.&n; * @addr: The start address of the DMA region.&n; * @size: The length of the DMA region.&n; * @direction: The direction of the DMA transaction (to/from device).&n; *&n; * This function implements the pci_unmap_single function.&n; */
r_static
r_void
DECL|function|ccio_unmap_single
id|ccio_unmap_single
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|dma_addr_t
id|iova
comma
r_int
id|size
comma
r_enum
id|dma_data_direction
id|direction
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dma_addr_t
id|offset
op_assign
id|iova
op_amp
op_complement
id|IOVP_MASK
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dev
)paren
suffix:semicolon
id|ioc
op_assign
id|GET_IOC
c_func
(paren
id|dev
)paren
suffix:semicolon
id|DBG_RUN
c_func
(paren
l_string|&quot;%s() iovp 0x%lx/%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
(paren
r_int
)paren
id|iova
comma
id|size
)paren
suffix:semicolon
id|iova
op_xor_assign
id|offset
suffix:semicolon
multiline_comment|/* clear offset bits */
id|size
op_add_assign
id|offset
suffix:semicolon
id|size
op_assign
id|ROUNDUP
c_func
(paren
id|size
comma
id|IOVP_SIZE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|ioc-&gt;usingle_calls
op_increment
suffix:semicolon
id|ioc-&gt;usingle_pages
op_add_assign
id|size
op_rshift
id|IOVP_SHIFT
suffix:semicolon
macro_line|#endif
id|ccio_mark_invalid
c_func
(paren
id|ioc
comma
id|iova
comma
id|size
)paren
suffix:semicolon
id|ccio_free_range
c_func
(paren
id|ioc
comma
id|iova
comma
(paren
id|size
op_rshift
id|IOVP_SHIFT
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ccio_alloc_consistent - Allocate a consistent DMA mapping.&n; * @dev: The PCI device.&n; * @size: The length of the DMA region.&n; * @dma_handle: The DMA address handed back to the device (not the cpu).&n; *&n; * This function implements the pci_alloc_consistent function.&n; */
r_static
r_void
op_star
DECL|function|ccio_alloc_consistent
id|ccio_alloc_consistent
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
comma
r_int
id|flag
)paren
(brace
r_void
op_star
id|ret
suffix:semicolon
macro_line|#if 0
multiline_comment|/* GRANT Need to establish hierarchy for non-PCI devs as well&n;** and then provide matching gsc_map_xxx() functions for them as well.&n;*/
r_if
c_cond
(paren
op_logical_neg
id|hwdev
)paren
(brace
multiline_comment|/* only support PCI */
op_star
id|dma_handle
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|ret
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|flag
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
op_star
id|dma_handle
op_assign
id|ccio_map_single
c_func
(paren
id|dev
comma
id|ret
comma
id|size
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * ccio_free_consistent - Free a consistent DMA mapping.&n; * @dev: The PCI device.&n; * @size: The length of the DMA region.&n; * @cpu_addr: The cpu address returned from the ccio_alloc_consistent.&n; * @dma_handle: The device address returned from the ccio_alloc_consistent.&n; *&n; * This function implements the pci_free_consistent function.&n; */
r_static
r_void
DECL|function|ccio_free_consistent
id|ccio_free_consistent
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|size
comma
r_void
op_star
id|cpu_addr
comma
id|dma_addr_t
id|dma_handle
)paren
(brace
id|ccio_unmap_single
c_func
(paren
id|dev
comma
id|dma_handle
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|cpu_addr
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** Since 0 is a valid pdir_base index value, can&squot;t use that&n;** to determine if a value is valid or not. Use a flag to indicate&n;** the SG list entry contains a valid pdir index.&n;*/
DECL|macro|PIDE_FLAG
mdefine_line|#define PIDE_FLAG 0x80000000UL
multiline_comment|/**&n; * ccio_fill_pdir - Insert coalesced scatter/gather chunks into the I/O Pdir.&n; * @ioc: The I/O Controller.&n; * @startsg: The scatter/gather list of coalesced chunks.&n; * @nents: The number of entries in the scatter/gather list.&n; * @hint: The DMA Hint.&n; *&n; * This function inserts the coalesced scatter/gather list chunks into the&n; * I/O Controller&squot;s I/O Pdir.&n; */
r_static
id|CCIO_INLINE
r_int
DECL|function|ccio_fill_pdir
id|ccio_fill_pdir
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_struct
id|scatterlist
op_star
id|startsg
comma
r_int
id|nents
comma
r_int
r_int
id|hint
)paren
(brace
r_struct
id|scatterlist
op_star
id|dma_sg
op_assign
id|startsg
suffix:semicolon
multiline_comment|/* pointer to current DMA */
r_int
id|n_mappings
op_assign
l_int|0
suffix:semicolon
id|u64
op_star
id|pdirp
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|dma_offset
op_assign
l_int|0
suffix:semicolon
id|dma_sg
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|nents
op_decrement
OG
l_int|0
)paren
(brace
r_int
id|cnt
op_assign
id|sg_dma_len
c_func
(paren
id|startsg
)paren
suffix:semicolon
id|sg_dma_len
c_func
(paren
id|startsg
)paren
op_assign
l_int|0
suffix:semicolon
id|DBG_RUN_SG
c_func
(paren
l_string|&quot; %d : %08lx/%05x %08lx/%05x&bslash;n&quot;
comma
id|nents
comma
(paren
r_int
r_int
)paren
id|sg_dma_address
c_func
(paren
id|startsg
)paren
comma
id|cnt
comma
id|sg_virt_addr
c_func
(paren
id|startsg
)paren
comma
id|startsg-&gt;length
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Look for the start of a new DMA stream&n;&t;&t;*/
r_if
c_cond
(paren
id|sg_dma_address
c_func
(paren
id|startsg
)paren
op_amp
id|PIDE_FLAG
)paren
(brace
id|u32
id|pide
op_assign
id|sg_dma_address
c_func
(paren
id|startsg
)paren
op_amp
op_complement
id|PIDE_FLAG
suffix:semicolon
id|dma_offset
op_assign
(paren
r_int
r_int
)paren
id|pide
op_amp
op_complement
id|IOVP_MASK
suffix:semicolon
id|sg_dma_address
c_func
(paren
id|startsg
)paren
op_assign
l_int|0
suffix:semicolon
id|dma_sg
op_increment
suffix:semicolon
id|sg_dma_address
c_func
(paren
id|dma_sg
)paren
op_assign
id|pide
suffix:semicolon
id|pdirp
op_assign
op_amp
(paren
id|ioc-&gt;pdir_base
(braket
id|pide
op_rshift
id|IOVP_SHIFT
)braket
)paren
suffix:semicolon
id|n_mappings
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** Look for a VCONTIG chunk&n;&t;&t;*/
r_if
c_cond
(paren
id|cnt
)paren
(brace
r_int
r_int
id|vaddr
op_assign
id|sg_virt_addr
c_func
(paren
id|startsg
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pdirp
)paren
suffix:semicolon
multiline_comment|/* Since multiple Vcontig blocks could make up&n;&t;&t;&t;** one DMA stream, *add* cnt to dma_len.&n;&t;&t;&t;*/
id|sg_dma_len
c_func
(paren
id|dma_sg
)paren
op_add_assign
id|cnt
suffix:semicolon
id|cnt
op_add_assign
id|dma_offset
suffix:semicolon
id|dma_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* only want offset on first chunk */
id|cnt
op_assign
id|ROUNDUP
c_func
(paren
id|cnt
comma
id|IOVP_SIZE
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|ioc-&gt;msg_pages
op_add_assign
id|cnt
op_rshift
id|IOVP_SHIFT
suffix:semicolon
macro_line|#endif
r_do
(brace
id|ccio_io_pdir_entry
c_func
(paren
id|pdirp
comma
id|KERNEL_SPACE
comma
(paren
r_void
op_star
)paren
id|vaddr
comma
id|hint
)paren
suffix:semicolon
id|vaddr
op_add_assign
id|IOVP_SIZE
suffix:semicolon
id|cnt
op_sub_assign
id|IOVP_SIZE
suffix:semicolon
id|pdirp
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cnt
OG
l_int|0
)paren
suffix:semicolon
)brace
id|startsg
op_increment
suffix:semicolon
)brace
r_return
id|n_mappings
suffix:semicolon
)brace
multiline_comment|/*&n;** First pass is to walk the SG list and determine where the breaks are&n;** in the DMA stream. Allocates PDIR entries but does not fill them.&n;** Returns the number of DMA chunks.&n;**&n;** Doing the fill separate from the coalescing/allocation keeps the&n;** code simpler. Future enhancement could make one pass through&n;** the sglist do both.&n;*/
r_static
id|CCIO_INLINE
r_int
DECL|function|ccio_coalesce_chunks
id|ccio_coalesce_chunks
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
comma
r_struct
id|scatterlist
op_star
id|startsg
comma
r_int
id|nents
)paren
(brace
r_struct
id|scatterlist
op_star
id|vcontig_sg
suffix:semicolon
multiline_comment|/* VCONTIG chunk head */
r_int
r_int
id|vcontig_len
suffix:semicolon
multiline_comment|/* len of VCONTIG chunk */
r_int
r_int
id|vcontig_end
suffix:semicolon
r_struct
id|scatterlist
op_star
id|dma_sg
suffix:semicolon
multiline_comment|/* next DMA stream head */
r_int
r_int
id|dma_offset
comma
id|dma_len
suffix:semicolon
multiline_comment|/* start/len of DMA stream */
r_int
id|n_mappings
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|nents
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;** Prepare for first/next DMA stream&n;&t;&t;*/
id|dma_sg
op_assign
id|vcontig_sg
op_assign
id|startsg
suffix:semicolon
id|dma_len
op_assign
id|vcontig_len
op_assign
id|vcontig_end
op_assign
id|startsg-&gt;length
suffix:semicolon
id|vcontig_end
op_add_assign
id|sg_virt_addr
c_func
(paren
id|startsg
)paren
suffix:semicolon
id|dma_offset
op_assign
id|sg_virt_addr
c_func
(paren
id|startsg
)paren
op_amp
op_complement
id|IOVP_MASK
suffix:semicolon
multiline_comment|/* PARANOID: clear entries */
id|sg_dma_address
c_func
(paren
id|startsg
)paren
op_assign
l_int|0
suffix:semicolon
id|sg_dma_len
c_func
(paren
id|startsg
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;** This loop terminates one iteration &quot;early&quot; since&n;&t;&t;** it&squot;s always looking one &quot;ahead&quot;.&n;&t;&t;*/
r_while
c_loop
(paren
op_decrement
id|nents
OG
l_int|0
)paren
(brace
r_int
r_int
id|startsg_end
suffix:semicolon
id|startsg
op_increment
suffix:semicolon
id|startsg_end
op_assign
id|sg_virt_addr
c_func
(paren
id|startsg
)paren
op_plus
id|startsg-&gt;length
suffix:semicolon
multiline_comment|/* PARANOID: clear entries */
id|sg_dma_address
c_func
(paren
id|startsg
)paren
op_assign
l_int|0
suffix:semicolon
id|sg_dma_len
c_func
(paren
id|startsg
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** First make sure current dma stream won&squot;t&n;&t;&t;&t;** exceed DMA_CHUNK_SIZE if we coalesce the&n;&t;&t;&t;** next entry.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|ROUNDUP
c_func
(paren
id|dma_len
op_plus
id|dma_offset
op_plus
id|startsg-&gt;length
comma
id|IOVP_SIZE
)paren
OG
id|DMA_CHUNK_SIZE
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;** Append the next transaction?&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|vcontig_end
op_eq
id|sg_virt_addr
c_func
(paren
id|startsg
)paren
)paren
(brace
id|vcontig_len
op_add_assign
id|startsg-&gt;length
suffix:semicolon
id|vcontig_end
op_add_assign
id|startsg-&gt;length
suffix:semicolon
id|dma_len
op_add_assign
id|startsg-&gt;length
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;** Not virtually contigous.&n;&t;&t;&t;** Terminate prev chunk.&n;&t;&t;&t;** Start a new chunk.&n;&t;&t;&t;**&n;&t;&t;&t;** Once we start a new VCONTIG chunk, dma_offset&n;&t;&t;&t;** can&squot;t change. And we need the offset from the first&n;&t;&t;&t;** chunk - not the last one. Ergo Successive chunks&n;&t;&t;&t;** must start on page boundaries and dove tail&n;&t;&t;&t;** with its predecessor.&n;&t;&t;&t;*/
id|sg_dma_len
c_func
(paren
id|vcontig_sg
)paren
op_assign
id|vcontig_len
suffix:semicolon
id|vcontig_sg
op_assign
id|startsg
suffix:semicolon
id|vcontig_len
op_assign
id|startsg-&gt;length
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** End of DMA Stream&n;&t;&t;** Terminate last VCONTIG block.&n;&t;&t;** Allocate space for DMA stream.&n;&t;&t;*/
id|sg_dma_len
c_func
(paren
id|vcontig_sg
)paren
op_assign
id|vcontig_len
suffix:semicolon
id|dma_len
op_assign
id|ROUNDUP
c_func
(paren
id|dma_len
op_plus
id|dma_offset
comma
id|IOVP_SIZE
)paren
suffix:semicolon
id|sg_dma_address
c_func
(paren
id|dma_sg
)paren
op_assign
id|PIDE_FLAG
op_or
(paren
id|ccio_alloc_range
c_func
(paren
id|ioc
comma
(paren
id|dma_len
op_rshift
id|IOVP_SHIFT
)paren
)paren
op_lshift
id|IOVP_SHIFT
)paren
op_or
id|dma_offset
suffix:semicolon
id|n_mappings
op_increment
suffix:semicolon
)brace
r_return
id|n_mappings
suffix:semicolon
)brace
multiline_comment|/**&n; * ccio_map_sg - Map the scatter/gather list into the IOMMU.&n; * @dev: The PCI device.&n; * @sglist: The scatter/gather list to be mapped in the IOMMU.&n; * @nents: The number of entries in the scatter/gather list.&n; * @direction: The direction of the DMA transaction (to/from device).&n; *&n; * This function implements the pci_map_sg function.&n; */
r_static
r_int
DECL|function|ccio_map_sg
id|ccio_map_sg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sglist
comma
r_int
id|nents
comma
r_enum
id|dma_data_direction
id|direction
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
r_int
id|coalesced
comma
id|filled
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|hint
op_assign
id|hint_lookup
(braket
(paren
r_int
)paren
id|direction
)braket
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dev
)paren
suffix:semicolon
id|ioc
op_assign
id|GET_IOC
c_func
(paren
id|dev
)paren
suffix:semicolon
id|DBG_RUN_SG
c_func
(paren
l_string|&quot;%s() START %d entries&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|nents
)paren
suffix:semicolon
multiline_comment|/* Fast path single entry scatterlists. */
r_if
c_cond
(paren
id|nents
op_eq
l_int|1
)paren
(brace
id|sg_dma_address
c_func
(paren
id|sglist
)paren
op_assign
id|ccio_map_single
c_func
(paren
id|dev
comma
(paren
r_void
op_star
)paren
id|sg_virt_addr
c_func
(paren
id|sglist
)paren
comma
id|sglist-&gt;length
comma
id|direction
)paren
suffix:semicolon
id|sg_dma_len
c_func
(paren
id|sglist
)paren
op_assign
id|sglist-&gt;length
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|ioc-&gt;msg_calls
op_increment
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;** First coalesce the chunks and allocate I/O pdir space&n;&t;**&n;&t;** If this is one DMA stream, we can properly map using the&n;&t;** correct virtual address associated with each DMA page.&n;&t;** w/o this association, we wouldn&squot;t have coherent DMA!&n;&t;** Access to the virtual address is what forces a two pass algorithm.&n;&t;*/
id|coalesced
op_assign
id|ccio_coalesce_chunks
c_func
(paren
id|ioc
comma
id|sglist
comma
id|nents
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Program the I/O Pdir&n;&t;**&n;&t;** map the virtual addresses to the I/O Pdir&n;&t;** o dma_address will contain the pdir index&n;&t;** o dma_len will contain the number of bytes to map &n;&t;** o page/offset contain the virtual address.&n;&t;*/
id|filled
op_assign
id|ccio_fill_pdir
c_func
(paren
id|ioc
comma
id|sglist
comma
id|nents
comma
id|hint
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ioc-&gt;res_lock
comma
id|flags
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|coalesced
op_eq
id|filled
)paren
suffix:semicolon
id|DBG_RUN_SG
c_func
(paren
l_string|&quot;%s() DONE %d mappings&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|filled
)paren
suffix:semicolon
r_return
id|filled
suffix:semicolon
)brace
multiline_comment|/**&n; * ccio_unmap_sg - Unmap the scatter/gather list from the IOMMU.&n; * @dev: The PCI device.&n; * @sglist: The scatter/gather list to be unmapped from the IOMMU.&n; * @nents: The number of entries in the scatter/gather list.&n; * @direction: The direction of the DMA transaction (to/from device).&n; *&n; * This function implements the pci_unmap_sg function.&n; */
r_static
r_void
DECL|function|ccio_unmap_sg
id|ccio_unmap_sg
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sglist
comma
r_int
id|nents
comma
r_enum
id|dma_data_direction
id|direction
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dev
)paren
suffix:semicolon
id|ioc
op_assign
id|GET_IOC
c_func
(paren
id|dev
)paren
suffix:semicolon
id|DBG_RUN_SG
c_func
(paren
l_string|&quot;%s() START %d entries,  %08lx,%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|nents
comma
id|sg_virt_addr
c_func
(paren
id|sglist
)paren
comma
id|sglist-&gt;length
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|ioc-&gt;usg_calls
op_increment
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|sg_dma_len
c_func
(paren
id|sglist
)paren
op_logical_and
id|nents
op_decrement
)paren
(brace
macro_line|#ifdef CONFIG_PROC_FS
id|ioc-&gt;usg_pages
op_add_assign
id|sg_dma_len
c_func
(paren
id|sglist
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
macro_line|#endif
id|ccio_unmap_single
c_func
(paren
id|dev
comma
id|sg_dma_address
c_func
(paren
id|sglist
)paren
comma
id|sg_dma_len
c_func
(paren
id|sglist
)paren
comma
id|direction
)paren
suffix:semicolon
op_increment
id|sglist
suffix:semicolon
)brace
id|DBG_RUN_SG
c_func
(paren
l_string|&quot;%s() DONE (nents %d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|nents
)paren
suffix:semicolon
)brace
DECL|variable|ccio_ops
r_static
r_struct
id|hppa_dma_ops
id|ccio_ops
op_assign
(brace
dot
id|dma_supported
op_assign
id|ccio_dma_supported
comma
dot
id|alloc_consistent
op_assign
id|ccio_alloc_consistent
comma
dot
id|alloc_noncoherent
op_assign
id|ccio_alloc_consistent
comma
dot
id|free_consistent
op_assign
id|ccio_free_consistent
comma
dot
id|map_single
op_assign
id|ccio_map_single
comma
dot
id|unmap_single
op_assign
id|ccio_unmap_single
comma
dot
id|map_sg
op_assign
id|ccio_map_sg
comma
dot
id|unmap_sg
op_assign
id|ccio_unmap_sg
comma
dot
id|dma_sync_single
op_assign
l_int|NULL
comma
multiline_comment|/* NOP for U2/Uturn */
dot
id|dma_sync_sg
op_assign
l_int|NULL
comma
multiline_comment|/* ditto */
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|proc_append
r_static
r_int
id|proc_append
c_func
(paren
r_char
op_star
id|src
comma
r_int
id|len
comma
r_char
op_star
op_star
id|dst
comma
id|off_t
op_star
id|offset
comma
r_int
op_star
id|max
)paren
(brace
r_if
c_cond
(paren
id|len
OL
op_star
id|offset
)paren
(brace
op_star
id|offset
op_sub_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|offset
OG
l_int|0
)paren
(brace
id|src
op_add_assign
op_star
id|offset
suffix:semicolon
id|len
op_sub_assign
op_star
id|offset
suffix:semicolon
op_star
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
op_star
id|max
)paren
(brace
id|len
op_assign
op_star
id|max
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_star
id|dst
comma
id|src
comma
id|len
)paren
suffix:semicolon
op_star
id|dst
op_add_assign
id|len
suffix:semicolon
op_star
id|max
op_sub_assign
id|len
suffix:semicolon
r_return
(paren
op_star
id|max
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|ccio_proc_info
r_static
r_int
id|ccio_proc_info
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|max
op_assign
id|count
suffix:semicolon
r_char
id|tmp
(braket
l_int|80
)braket
suffix:semicolon
multiline_comment|/* width of an ANSI-standard terminal */
r_struct
id|ioc
op_star
id|ioc
op_assign
id|ioc_list
suffix:semicolon
r_while
c_loop
(paren
id|ioc
op_ne
l_int|NULL
)paren
(brace
r_int
r_int
id|total_pages
op_assign
id|ioc-&gt;res_size
op_lshift
l_int|3
suffix:semicolon
r_int
r_int
id|avg
op_assign
l_int|0
comma
id|min
comma
id|max
suffix:semicolon
r_int
id|j
comma
id|len
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|ioc-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_append
c_func
(paren
id|tmp
comma
id|len
comma
op_amp
id|buf
comma
op_amp
id|offset
comma
op_amp
id|count
)paren
)paren
r_break
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;Cujo 2.0 bug    : %s&bslash;n&quot;
comma
(paren
id|ioc-&gt;cujo20_bug
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_append
c_func
(paren
id|tmp
comma
id|len
comma
op_amp
id|buf
comma
op_amp
id|offset
comma
op_amp
id|count
)paren
)paren
r_break
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;IO PDIR size    : %d bytes (%d entries)&bslash;n&quot;
comma
id|total_pages
op_star
l_int|8
comma
id|total_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_append
c_func
(paren
id|tmp
comma
id|len
comma
op_amp
id|buf
comma
op_amp
id|offset
comma
op_amp
id|count
)paren
)paren
r_break
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;IO PDIR entries : %ld free  %ld used (%d%%)&bslash;n&quot;
comma
id|total_pages
op_minus
id|ioc-&gt;used_pages
comma
id|ioc-&gt;used_pages
comma
(paren
r_int
)paren
(paren
id|ioc-&gt;used_pages
op_star
l_int|100
op_div
id|total_pages
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_append
c_func
(paren
id|tmp
comma
id|len
comma
op_amp
id|buf
comma
op_amp
id|offset
comma
op_amp
id|count
)paren
)paren
r_break
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;Resource bitmap : %d bytes (%d pages)&bslash;n&quot;
comma
id|ioc-&gt;res_size
comma
id|total_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_append
c_func
(paren
id|tmp
comma
id|len
comma
op_amp
id|buf
comma
op_amp
id|offset
comma
op_amp
id|count
)paren
)paren
r_break
suffix:semicolon
id|min
op_assign
id|max
op_assign
id|ioc-&gt;avg_search
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|CCIO_SEARCH_SAMPLE
suffix:semicolon
op_increment
id|j
)paren
(brace
id|avg
op_add_assign
id|ioc-&gt;avg_search
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ioc-&gt;avg_search
(braket
id|j
)braket
OG
id|max
)paren
(brace
id|max
op_assign
id|ioc-&gt;avg_search
(braket
id|j
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioc-&gt;avg_search
(braket
id|j
)braket
OL
id|min
)paren
(brace
id|min
op_assign
id|ioc-&gt;avg_search
(braket
id|j
)braket
suffix:semicolon
)brace
)brace
id|avg
op_div_assign
id|CCIO_SEARCH_SAMPLE
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;  Bitmap search : %ld/%ld/%ld (min/avg/max CPU Cycles)&bslash;n&quot;
comma
id|min
comma
id|avg
comma
id|max
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_append
c_func
(paren
id|tmp
comma
id|len
comma
op_amp
id|buf
comma
op_amp
id|offset
comma
op_amp
id|count
)paren
)paren
r_break
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;pci_map_single(): %8ld calls  %8ld pages (avg %d/1000)&bslash;n&quot;
comma
id|ioc-&gt;msingle_calls
comma
id|ioc-&gt;msingle_pages
comma
(paren
r_int
)paren
(paren
(paren
id|ioc-&gt;msingle_pages
op_star
l_int|1000
)paren
op_div
id|ioc-&gt;msingle_calls
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_append
c_func
(paren
id|tmp
comma
id|len
comma
op_amp
id|buf
comma
op_amp
id|offset
comma
op_amp
id|count
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* KLUGE - unmap_sg calls unmap_single for each mapped page */
id|min
op_assign
id|ioc-&gt;usingle_calls
op_minus
id|ioc-&gt;usg_calls
suffix:semicolon
id|max
op_assign
id|ioc-&gt;usingle_pages
op_minus
id|ioc-&gt;usg_pages
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;pci_unmap_single: %8ld calls  %8ld pages (avg %d/1000)&bslash;n&quot;
comma
id|min
comma
id|max
comma
(paren
r_int
)paren
(paren
(paren
id|max
op_star
l_int|1000
)paren
op_div
id|min
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_append
c_func
(paren
id|tmp
comma
id|len
comma
op_amp
id|buf
comma
op_amp
id|offset
comma
op_amp
id|count
)paren
)paren
r_break
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;pci_map_sg()    : %8ld calls  %8ld pages (avg %d/1000)&bslash;n&quot;
comma
id|ioc-&gt;msg_calls
comma
id|ioc-&gt;msg_pages
comma
(paren
r_int
)paren
(paren
(paren
id|ioc-&gt;msg_pages
op_star
l_int|1000
)paren
op_div
id|ioc-&gt;msg_calls
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_append
c_func
(paren
id|tmp
comma
id|len
comma
op_amp
id|buf
comma
op_amp
id|offset
comma
op_amp
id|count
)paren
)paren
r_break
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;pci_unmap_sg()  : %8ld calls  %8ld pages (avg %d/1000)&bslash;n&bslash;n&bslash;n&quot;
comma
id|ioc-&gt;usg_calls
comma
id|ioc-&gt;usg_pages
comma
(paren
r_int
)paren
(paren
(paren
id|ioc-&gt;usg_pages
op_star
l_int|1000
)paren
op_div
id|ioc-&gt;usg_calls
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_append
c_func
(paren
id|tmp
comma
id|len
comma
op_amp
id|buf
comma
op_amp
id|offset
comma
op_amp
id|count
)paren
)paren
r_break
suffix:semicolon
id|ioc
op_assign
id|ioc-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
)brace
r_return
(paren
id|max
op_minus
id|count
)paren
suffix:semicolon
)brace
DECL|function|ccio_resource_map
r_static
r_int
id|ccio_resource_map
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|len
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|ioc
op_star
id|ioc
op_assign
id|ioc_list
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_while
c_loop
(paren
id|ioc
op_ne
l_int|NULL
)paren
(brace
id|u32
op_star
id|res_ptr
op_assign
(paren
id|u32
op_star
)paren
id|ioc-&gt;res_map
suffix:semicolon
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
(paren
id|ioc-&gt;res_size
op_div
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|j
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
id|strcat
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;n   &quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s %08x&quot;
comma
id|buf
comma
op_star
id|res_ptr
)paren
suffix:semicolon
id|res_ptr
op_increment
suffix:semicolon
)brace
id|strcat
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|ioc
op_assign
id|ioc-&gt;next
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* XXX - remove me */
)brace
r_return
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * ccio_find_ioc - Find the ioc in the ioc_list&n; * @hw_path: The hardware path of the ioc.&n; *&n; * This function searches the ioc_list for an ioc that matches&n; * the provide hardware path.&n; */
DECL|function|ccio_find_ioc
r_static
r_struct
id|ioc
op_star
id|ccio_find_ioc
c_func
(paren
r_int
id|hw_path
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|ioc
op_star
id|ioc
suffix:semicolon
id|ioc
op_assign
id|ioc_list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ioc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ioc-&gt;hw_path
op_eq
id|hw_path
)paren
r_return
id|ioc
suffix:semicolon
id|ioc
op_assign
id|ioc-&gt;next
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * ccio_get_iommu - Find the iommu which controls this device&n; * @dev: The parisc device.&n; *&n; * This function searches through the registered IOMMU&squot;s and returns&n; * the appropriate IOMMU for the device based on its hardware path.&n; */
DECL|function|ccio_get_iommu
r_void
op_star
id|ccio_get_iommu
c_func
(paren
r_const
r_struct
id|parisc_device
op_star
id|dev
)paren
(brace
id|dev
op_assign
id|find_pa_parent_type
c_func
(paren
id|dev
comma
id|HPHW_IOA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|ccio_find_ioc
c_func
(paren
id|dev-&gt;hw_path
)paren
suffix:semicolon
)brace
DECL|macro|CUJO_20_STEP
mdefine_line|#define CUJO_20_STEP       0x10000000&t;/* inc upper nibble */
multiline_comment|/* Cujo 2.0 has a bug which will silently corrupt data being transferred&n; * to/from certain pages.  To avoid this happening, we mark these pages&n; * as `used&squot;, and ensure that nothing will try to allocate from them.&n; */
DECL|function|ccio_cujo20_fixup
r_void
id|ccio_cujo20_fixup
c_func
(paren
r_struct
id|parisc_device
op_star
id|dev
comma
id|u32
id|iovp
)paren
(brace
r_int
r_int
id|idx
suffix:semicolon
r_struct
id|ioc
op_star
id|ioc
op_assign
id|ccio_get_iommu
c_func
(paren
id|dev
)paren
suffix:semicolon
id|u8
op_star
id|res_ptr
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|ioc-&gt;cujo20_bug
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|res_ptr
op_assign
id|ioc-&gt;res_map
suffix:semicolon
id|idx
op_assign
id|PDIR_INDEX
c_func
(paren
id|iovp
)paren
op_rshift
l_int|3
suffix:semicolon
r_while
c_loop
(paren
id|idx
OL
id|ioc-&gt;res_size
)paren
(brace
id|res_ptr
(braket
id|idx
)braket
op_or_assign
l_int|0xff
suffix:semicolon
id|idx
op_add_assign
id|PDIR_INDEX
c_func
(paren
id|CUJO_20_STEP
)paren
op_rshift
l_int|3
suffix:semicolon
)brace
)brace
macro_line|#if 0
multiline_comment|/* GRANT -  is this needed for U2 or not? */
multiline_comment|/*&n;** Get the size of the I/O TLB for this I/O MMU.&n;**&n;** If spa_shift is non-zero (ie probably U2),&n;** then calculate the I/O TLB size using spa_shift.&n;**&n;** Otherwise we are supposed to get the IODC entry point ENTRY TLB&n;** and execute it. However, both U2 and Uturn firmware supplies spa_shift.&n;** I think only Java (K/D/R-class too?) systems don&squot;t do this.&n;*/
r_static
r_int
id|ccio_get_iotlb_size
c_func
(paren
r_struct
id|parisc_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;spa_shift
op_eq
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;%s() : Can&squot;t determine I/O TLB size.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
op_lshift
id|dev-&gt;spa_shift
)paren
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* Uturn supports 256 TLB entries */
DECL|macro|CCIO_CHAINID_SHIFT
mdefine_line|#define CCIO_CHAINID_SHIFT&t;8
DECL|macro|CCIO_CHAINID_MASK
mdefine_line|#define CCIO_CHAINID_MASK&t;0xff
macro_line|#endif /* 0 */
multiline_comment|/**&n; * ccio_ioc_init - Initalize the I/O Controller&n; * @ioc: The I/O Controller.&n; *&n; * Initalize the I/O Controller which includes setting up the&n; * I/O Page Directory, the resource map, and initalizing the&n; * U2/Uturn chip into virtual mode.&n; */
r_static
r_void
DECL|function|ccio_ioc_init
id|ccio_ioc_init
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
)paren
(brace
r_int
id|i
comma
id|iov_order
suffix:semicolon
id|u32
id|iova_space_size
suffix:semicolon
r_int
r_int
id|physmem
suffix:semicolon
multiline_comment|/*&n;&t;** Determine IOVA Space size from memory size.&n;&t;**&n;&t;** Ideally, PCI drivers would register the maximum number&n;&t;** of DMA they can have outstanding for each device they&n;&t;** own.  Next best thing would be to guess how much DMA&n;&t;** can be outstanding based on PCI Class/sub-class. Both&n;&t;** methods still require some &quot;extra&quot; to support PCI&n;&t;** Hot-Plug/Removal of PCI cards. (aka PCI OLARD).&n;&t;*/
multiline_comment|/* limit IOVA space size to 1MB-1GB */
id|physmem
op_assign
id|num_physpages
op_lshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|physmem
OL
(paren
id|ccio_mem_ratio
op_star
l_int|1024
op_star
l_int|1024
)paren
)paren
(brace
id|iova_space_size
op_assign
l_int|1024
op_star
l_int|1024
suffix:semicolon
macro_line|#ifdef __LP64__
)brace
r_else
r_if
c_cond
(paren
id|physmem
OG
(paren
id|ccio_mem_ratio
op_star
l_int|512
op_star
l_int|1024
op_star
l_int|1024
)paren
)paren
(brace
id|iova_space_size
op_assign
l_int|512
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|iova_space_size
op_assign
(paren
id|u32
)paren
(paren
id|physmem
op_div
id|ccio_mem_ratio
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** iova space must be log2() in size.&n;&t;** thus, pdir/res_map will also be log2().&n;&t;*/
multiline_comment|/* We could use larger page sizes in order to *decrease* the number&n;&t;** of mappings needed.  (ie 8k pages means 1/2 the mappings).&n;&t;**&n;&t;** Note: Grant Grunder says &quot;Using 8k I/O pages isn&squot;t trivial either&n;&t;**   since the pages must also be physically contiguous - typically&n;&t;**   this is the case under linux.&quot;&n;&t;*/
id|iov_order
op_assign
id|get_order
c_func
(paren
id|iova_space_size
)paren
op_rshift
(paren
id|IOVP_SHIFT
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iov_order
op_le
(paren
l_int|30
op_minus
id|IOVP_SHIFT
)paren
)paren
suffix:semicolon
multiline_comment|/* iova_space_size &lt;= 1GB */
id|ASSERT
c_func
(paren
id|iov_order
op_ge
(paren
l_int|20
op_minus
id|IOVP_SHIFT
)paren
)paren
suffix:semicolon
multiline_comment|/* iova_space_size &gt;= 1MB */
id|iova_space_size
op_assign
l_int|1
op_lshift
(paren
id|iov_order
op_plus
id|IOVP_SHIFT
)paren
suffix:semicolon
id|ioc-&gt;pdir_size
op_assign
(paren
id|iova_space_size
op_div
id|IOVP_SIZE
)paren
op_star
r_sizeof
(paren
id|u64
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ioc-&gt;pdir_size
OL
l_int|4
op_star
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
multiline_comment|/* max pdir size &lt; 4MB */
multiline_comment|/* Verify it&squot;s a power of two */
id|ASSERT
c_func
(paren
(paren
l_int|1
op_lshift
id|get_order
c_func
(paren
id|ioc-&gt;pdir_size
)paren
)paren
op_eq
(paren
id|ioc-&gt;pdir_size
op_rshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot;%s() hpa 0x%p mem %luMB IOV %dMB (%d bits) PDIR size 0x%0x&quot;
comma
id|__FUNCTION__
comma
id|ioc-&gt;ioc_hpa
comma
id|physmem
op_rshift
l_int|20
comma
id|iova_space_size
op_rshift
l_int|20
comma
id|iov_order
op_plus
id|PAGE_SHIFT
comma
id|ioc-&gt;pdir_size
)paren
suffix:semicolon
id|ioc-&gt;pdir_base
op_assign
(paren
id|u64
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|get_order
c_func
(paren
id|ioc-&gt;pdir_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|ioc-&gt;pdir_base
)paren
(brace
id|panic
c_func
(paren
id|__FILE__
l_string|&quot;:%s() could not allocate I/O Page Table&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ioc-&gt;pdir_base
comma
l_int|0
comma
id|ioc-&gt;pdir_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|ioc-&gt;pdir_base
)paren
op_amp
id|PAGE_MASK
)paren
op_eq
(paren
r_int
r_int
)paren
id|ioc-&gt;pdir_base
)paren
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot; base %p&quot;
comma
id|ioc-&gt;pdir_base
)paren
suffix:semicolon
multiline_comment|/* resource map size dictated by pdir_size */
id|ioc-&gt;res_size
op_assign
(paren
id|ioc-&gt;pdir_size
op_div
r_sizeof
(paren
id|u64
)paren
)paren
op_rshift
l_int|3
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot;%s() res_size 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ioc-&gt;res_size
)paren
suffix:semicolon
id|ioc-&gt;res_map
op_assign
(paren
id|u8
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|get_order
c_func
(paren
id|ioc-&gt;res_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|ioc-&gt;res_map
)paren
(brace
id|panic
c_func
(paren
id|__FILE__
l_string|&quot;:%s() could not allocate resource map&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ioc-&gt;res_map
comma
l_int|0
comma
id|ioc-&gt;res_size
)paren
suffix:semicolon
multiline_comment|/* Initialize the res_hint to 16 */
id|ioc-&gt;res_hint
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* Initialize the spinlock */
id|spin_lock_init
c_func
(paren
op_amp
id|ioc-&gt;res_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Chainid is the upper most bits of an IOVP used to determine&n;&t;** which TLB entry an IOVP will use.&n;&t;*/
id|ioc-&gt;chainid_shift
op_assign
id|get_order
c_func
(paren
id|iova_space_size
)paren
op_plus
id|PAGE_SHIFT
op_minus
id|CCIO_CHAINID_SHIFT
suffix:semicolon
id|DBG_INIT
c_func
(paren
l_string|&quot; chainid_shift 0x%x&bslash;n&quot;
comma
id|ioc-&gt;chainid_shift
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Initialize IOA hardware&n;&t;*/
id|WRITE_U32
c_func
(paren
id|CCIO_CHAINID_MASK
op_lshift
id|ioc-&gt;chainid_shift
comma
op_amp
id|ioc-&gt;ioc_hpa-&gt;io_chain_id_mask
)paren
suffix:semicolon
id|WRITE_U32
c_func
(paren
id|virt_to_phys
c_func
(paren
id|ioc-&gt;pdir_base
)paren
comma
op_amp
id|ioc-&gt;ioc_hpa-&gt;io_pdir_base
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Go to &quot;Virtual Mode&quot;&n;&t;*/
id|WRITE_U32
c_func
(paren
id|IOA_NORMAL_MODE
comma
op_amp
id|ioc-&gt;ioc_hpa-&gt;io_control
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Initialize all I/O TLB entries to 0 (Valid bit off).&n;&t;*/
id|WRITE_U32
c_func
(paren
l_int|0
comma
op_amp
id|ioc-&gt;ioc_hpa-&gt;io_tlb_entry_m
)paren
suffix:semicolon
id|WRITE_U32
c_func
(paren
l_int|0
comma
op_amp
id|ioc-&gt;ioc_hpa-&gt;io_tlb_entry_l
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
op_lshift
id|CCIO_CHAINID_SHIFT
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|WRITE_U32
c_func
(paren
(paren
id|CMD_TLB_DIRECT_WRITE
op_or
(paren
id|i
op_lshift
id|ioc-&gt;chainid_shift
)paren
)paren
comma
op_amp
id|ioc-&gt;ioc_hpa-&gt;io_command
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ccio_init_resource
id|ccio_init_resource
c_func
(paren
r_struct
id|resource
op_star
id|res
comma
r_char
op_star
id|name
comma
r_int
r_int
id|ioaddr
)paren
(brace
r_int
id|result
suffix:semicolon
id|res-&gt;parent
op_assign
l_int|NULL
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
id|res-&gt;start
op_assign
(paren
r_int
r_int
)paren
(paren
r_int
)paren
id|__raw_readl
c_func
(paren
id|ioaddr
)paren
op_lshift
l_int|16
suffix:semicolon
id|res-&gt;end
op_assign
(paren
r_int
r_int
)paren
(paren
r_int
)paren
(paren
id|__raw_readl
c_func
(paren
id|ioaddr
op_plus
l_int|4
)paren
op_lshift
l_int|16
)paren
op_minus
l_int|1
suffix:semicolon
id|res-&gt;name
op_assign
id|name
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;end
op_plus
l_int|1
op_eq
id|res-&gt;start
)paren
r_return
suffix:semicolon
id|result
op_assign
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: failed to claim CCIO bus address space (%08lx,%08lx)&bslash;n&quot;
comma
id|__FILE__
comma
id|res-&gt;start
comma
id|res-&gt;end
)paren
suffix:semicolon
)brace
)brace
DECL|function|ccio_init_resources
r_static
r_void
id|__init
id|ccio_init_resources
c_func
(paren
r_struct
id|ioc
op_star
id|ioc
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
id|ioc-&gt;mmio_region
suffix:semicolon
r_char
op_star
id|name
op_assign
id|kmalloc
c_func
(paren
l_int|14
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;GSC Bus [%d/]&quot;
comma
id|ioc-&gt;hw_path
)paren
suffix:semicolon
id|ccio_init_resource
c_func
(paren
id|res
comma
id|name
comma
(paren
r_int
r_int
)paren
op_amp
id|ioc-&gt;ioc_hpa-&gt;io_io_low
)paren
suffix:semicolon
id|ccio_init_resource
c_func
(paren
id|res
op_plus
l_int|1
comma
id|name
comma
(paren
r_int
r_int
)paren
op_amp
id|ioc-&gt;ioc_hpa-&gt;io_io_low_hv
)paren
suffix:semicolon
)brace
DECL|function|new_ioc_area
r_static
r_int
id|new_ioc_area
c_func
(paren
r_struct
id|resource
op_star
id|res
comma
r_int
r_int
id|size
comma
r_int
r_int
id|min
comma
r_int
r_int
id|max
comma
r_int
r_int
id|align
)paren
(brace
r_if
c_cond
(paren
id|max
op_le
id|min
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|res-&gt;start
op_assign
(paren
id|max
op_minus
id|size
op_plus
l_int|1
)paren
op_amp
op_complement
(paren
id|align
op_minus
l_int|1
)paren
suffix:semicolon
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|res
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|new_ioc_area
c_func
(paren
id|res
comma
id|size
comma
id|min
comma
id|max
op_minus
id|size
comma
id|align
)paren
suffix:semicolon
)brace
DECL|function|expand_ioc_area
r_static
r_int
id|expand_ioc_area
c_func
(paren
r_struct
id|resource
op_star
id|res
comma
r_int
r_int
id|size
comma
r_int
r_int
id|min
comma
r_int
r_int
id|max
comma
r_int
r_int
id|align
)paren
(brace
r_int
r_int
id|start
comma
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res-&gt;parent
)paren
r_return
id|new_ioc_area
c_func
(paren
id|res
comma
id|size
comma
id|min
comma
id|max
comma
id|align
)paren
suffix:semicolon
id|start
op_assign
(paren
id|res-&gt;start
op_minus
id|size
)paren
op_amp
op_complement
(paren
id|align
op_minus
l_int|1
)paren
suffix:semicolon
id|len
op_assign
id|res-&gt;end
op_minus
id|start
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ge
id|min
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|adjust_resource
c_func
(paren
id|res
comma
id|start
comma
id|len
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|start
op_assign
id|res-&gt;start
suffix:semicolon
id|len
op_assign
(paren
(paren
id|size
op_plus
id|res-&gt;end
op_plus
id|align
)paren
op_amp
op_complement
(paren
id|align
op_minus
l_int|1
)paren
)paren
op_minus
id|start
suffix:semicolon
r_if
c_cond
(paren
id|start
op_plus
id|len
op_le
id|max
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|adjust_resource
c_func
(paren
id|res
comma
id|start
comma
id|len
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n; * Dino calls this function.  Beware that we may get called on systems&n; * which have no IOC (725, B180, C160L, etc) but do have a Dino.&n; * So it&squot;s legal to find no parent IOC.&n; *&n; * Some other issues: one of the resources in the ioc may be unassigned.&n; */
DECL|function|ccio_allocate_resource
r_int
id|ccio_allocate_resource
c_func
(paren
r_const
r_struct
id|parisc_device
op_star
id|dev
comma
r_struct
id|resource
op_star
id|res
comma
r_int
r_int
id|size
comma
r_int
r_int
id|min
comma
r_int
r_int
id|max
comma
r_int
r_int
id|align
)paren
(brace
r_struct
id|resource
op_star
id|parent
op_assign
op_amp
id|iomem_resource
suffix:semicolon
r_struct
id|ioc
op_star
id|ioc
op_assign
id|ccio_get_iommu
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioc
)paren
r_goto
id|out
suffix:semicolon
id|parent
op_assign
id|ioc-&gt;mmio_region
suffix:semicolon
r_if
c_cond
(paren
id|parent-&gt;parent
op_logical_and
op_logical_neg
id|allocate_resource
c_func
(paren
id|parent
comma
id|res
comma
id|size
comma
id|min
comma
id|max
comma
id|align
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|parent
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|parent
op_logical_and
op_logical_neg
id|allocate_resource
c_func
(paren
id|parent
op_plus
l_int|1
comma
id|res
comma
id|size
comma
id|min
comma
id|max
comma
id|align
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|expand_ioc_area
c_func
(paren
id|parent
comma
id|size
comma
id|min
comma
id|max
comma
id|align
)paren
)paren
(brace
id|__raw_writel
c_func
(paren
(paren
(paren
id|parent-&gt;start
)paren
op_rshift
l_int|16
)paren
op_or
l_int|0xffff0000
comma
(paren
r_int
r_int
)paren
op_amp
(paren
id|ioc-&gt;ioc_hpa-&gt;io_io_low
)paren
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
(paren
(paren
id|parent-&gt;end
)paren
op_rshift
l_int|16
)paren
op_or
l_int|0xffff0000
comma
(paren
r_int
r_int
)paren
op_amp
(paren
id|ioc-&gt;ioc_hpa-&gt;io_io_high
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|expand_ioc_area
c_func
(paren
id|parent
op_plus
l_int|1
comma
id|size
comma
id|min
comma
id|max
comma
id|align
)paren
)paren
(brace
id|parent
op_increment
suffix:semicolon
id|__raw_writel
c_func
(paren
(paren
(paren
id|parent-&gt;start
)paren
op_rshift
l_int|16
)paren
op_or
l_int|0xffff0000
comma
(paren
r_int
r_int
)paren
op_amp
(paren
id|ioc-&gt;ioc_hpa-&gt;io_io_low_hv
)paren
)paren
suffix:semicolon
id|__raw_writel
c_func
(paren
(paren
(paren
id|parent-&gt;end
)paren
op_rshift
l_int|16
)paren
op_or
l_int|0xffff0000
comma
(paren
r_int
r_int
)paren
op_amp
(paren
id|ioc-&gt;ioc_hpa-&gt;io_io_high_hv
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|allocate_resource
c_func
(paren
id|parent
comma
id|res
comma
id|size
comma
id|min
comma
id|max
comma
id|align
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|ccio_request_resource
r_int
id|ccio_request_resource
c_func
(paren
r_const
r_struct
id|parisc_device
op_star
id|dev
comma
r_struct
id|resource
op_star
id|res
)paren
(brace
r_struct
id|resource
op_star
id|parent
suffix:semicolon
r_struct
id|ioc
op_star
id|ioc
op_assign
id|ccio_get_iommu
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioc
)paren
(brace
id|parent
op_assign
op_amp
id|iomem_resource
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ioc-&gt;mmio_region-&gt;start
op_le
id|dev-&gt;hpa
)paren
op_logical_and
(paren
id|dev-&gt;hpa
OL
id|ioc-&gt;mmio_region-&gt;end
)paren
)paren
(brace
id|parent
op_assign
id|ioc-&gt;mmio_region
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|ioc-&gt;mmio_region
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|start
op_le
id|dev-&gt;hpa
)paren
op_logical_and
(paren
id|dev-&gt;hpa
OL
(paren
id|ioc-&gt;mmio_region
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|end
)paren
)paren
(brace
id|parent
op_assign
id|ioc-&gt;mmio_region
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_return
id|request_resource
c_func
(paren
id|parent
comma
id|res
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ccio_probe - Determine if ccio should claim this device.&n; * @dev: The device which has been found&n; *&n; * Determine if ccio should claim this chip (return 0) or not (return 1).&n; * If so, initialize the chip and tell other partners in crime they&n; * have work to do.&n; */
DECL|function|ccio_probe
r_static
r_int
id|ccio_probe
c_func
(paren
r_struct
id|parisc_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|ioc
op_star
id|ioc
comma
op_star
op_star
id|ioc_p
op_assign
op_amp
id|ioc_list
suffix:semicolon
id|ioc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ioc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioc
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|MODULE_NAME
l_string|&quot;: memory allocation failure&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ioc
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ioc
)paren
)paren
suffix:semicolon
id|ioc-&gt;name
op_assign
id|dev-&gt;id.hversion
op_eq
id|U2_IOA_RUNWAY
ques
c_cond
l_string|&quot;U2&quot;
suffix:colon
l_string|&quot;UTurn&quot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Found %s at 0x%lx&bslash;n&quot;
comma
id|ioc-&gt;name
comma
id|dev-&gt;hpa
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ioc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ioc_p
op_assign
op_amp
(paren
op_star
id|ioc_p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
op_star
id|ioc_p
op_assign
id|ioc
suffix:semicolon
id|ioc-&gt;hw_path
op_assign
id|dev-&gt;hw_path
suffix:semicolon
id|ioc-&gt;ioc_hpa
op_assign
(paren
r_struct
id|ioa_registers
op_star
)paren
id|dev-&gt;hpa
suffix:semicolon
id|ccio_ioc_init
c_func
(paren
id|ioc
)paren
suffix:semicolon
id|ccio_init_resources
c_func
(paren
id|ioc
)paren
suffix:semicolon
id|hppa_dma_ops
op_assign
op_amp
id|ccio_ops
suffix:semicolon
id|dev-&gt;dev.platform_data
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_hba_data
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* if this fails, no I/O cards will work, so may as well bug */
id|BUG_ON
c_func
(paren
id|dev-&gt;dev.platform_data
op_eq
l_int|NULL
)paren
suffix:semicolon
id|HBA_DATA
c_func
(paren
id|dev-&gt;dev.platform_data
)paren
op_member_access_from_pointer
id|iommu
op_assign
id|ioc
suffix:semicolon
r_if
c_cond
(paren
id|ioc_count
op_eq
l_int|0
)paren
(brace
multiline_comment|/* XXX: Create separate entries for each ioc */
id|create_proc_read_entry
c_func
(paren
id|MODULE_NAME
comma
id|S_IRWXU
comma
id|proc_runway_root
comma
id|ccio_proc_info
comma
l_int|NULL
)paren
suffix:semicolon
id|create_proc_read_entry
c_func
(paren
id|MODULE_NAME
l_string|&quot;-bitmap&quot;
comma
id|S_IRWXU
comma
id|proc_runway_root
comma
id|ccio_resource_map
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|ioc_count
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We *can&squot;t* support JAVA (T600). Venture there at your own risk. */
DECL|variable|ccio_tbl
r_static
r_struct
id|parisc_device_id
id|ccio_tbl
(braket
)braket
op_assign
(brace
(brace
id|HPHW_IOA
comma
id|HVERSION_REV_ANY_ID
comma
id|U2_IOA_RUNWAY
comma
l_int|0xb
)brace
comma
multiline_comment|/* U2 */
(brace
id|HPHW_IOA
comma
id|HVERSION_REV_ANY_ID
comma
id|UTURN_IOA_RUNWAY
comma
l_int|0xb
)brace
comma
multiline_comment|/* UTurn */
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
DECL|variable|ccio_driver
r_static
r_struct
id|parisc_driver
id|ccio_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;U2:Uturn&quot;
comma
dot
id|id_table
op_assign
id|ccio_tbl
comma
dot
id|probe
op_assign
id|ccio_probe
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * ccio_init - ccio initalization procedure.&n; *&n; * Register this driver.&n; */
DECL|function|ccio_init
r_void
id|__init
id|ccio_init
c_func
(paren
r_void
)paren
(brace
id|register_parisc_driver
c_func
(paren
op_amp
id|ccio_driver
)paren
suffix:semicolon
)brace
eof
