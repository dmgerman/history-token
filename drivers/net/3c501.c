multiline_comment|/* 3c501.c: A 3Com 3c501 Ethernet driver for Linux. */
multiline_comment|/*&n;    Written 1992,1993,1994  Donald Becker&n;&n;    Copyright 1993 United States Government as represented by the&n;    Director, National Security Agency.  This software may be used and&n;    distributed according to the terms of the GNU General Public License,&n;    incorporated herein by reference.&n;&n;    This is a device driver for the 3Com Etherlink 3c501.&n;    Do not purchase this card, even as a joke.  It&squot;s performance is horrible,&n;    and it breaks in many ways.&n;&n;    The original author may be reached as becker@scyld.com, or C/O&n;&t;Scyld Computing Corporation&n;&t;410 Severn Ave., Suite 210&n;&t;Annapolis MD 21403&n;&n;    Fixed (again!) the missing interrupt locking on TX/RX shifting.&n;    &t;&t;Alan Cox &lt;Alan.Cox@linux.org&gt;&n;&n;    Removed calls to init_etherdev since they are no longer needed, and&n;    cleaned up modularization just a bit. The driver still allows only&n;    the default address for cards when loaded as a module, but that&squot;s&n;    really less braindead than anyone using a 3c501 board. :)&n;&t;&t;    19950208 (invid@msen.com)&n;&n;    Added traps for interrupts hitting the window as we clear and TX load&n;    the board. Now getting 150K/second FTP with a 3c501 card. Still playing&n;    with a TX-TX optimisation to see if we can touch 180-200K/second as seems&n;    theoretically maximum.&n;    &t;&t;19950402 Alan Cox &lt;Alan.Cox@linux.org&gt;&n;    &t;&t;&n;    Cleaned up for 2.3.x because we broke SMP now. &n;    &t;&t;20000208 Alan Cox &lt;alan@redhat.com&gt;&n;&n;    Check up pass for 2.5. Nothing significant changed&n;    &t;&t;20021009 Alan Cox &lt;alan@redhat.com&gt;&n;&n;    Fixed zero fill corner case &n;    &t;&t;20030104 Alan Cox &lt;alan@redhat.com&gt;&n;    &t;&t;&n;    &t;&t;&n;   For the avoidance of doubt the &quot;preferred form&quot; of this code is one which&n;   is in an open non patent encumbered format. Where cryptographic key signing&n;   forms part of the process of creating an executable the information&n;   including keys needed to generate an equivalently functional executable&n;   are deemed to be part of the source code.&n;&n;*/
multiline_comment|/**&n; * DOC: 3c501 Card Notes&n; *&n; *  Some notes on this thing if you have to hack it.  [Alan]&n; *&n; *  Some documentation is available from 3Com. Due to the boards age&n; *  standard responses when you ask for this will range from &squot;be serious&squot;&n; *  to &squot;give it to a museum&squot;. The documentation is incomplete and mostly&n; *  of historical interest anyway. &n; *&n; *  The basic system is a single buffer which can be used to receive or&n; *  transmit a packet. A third command mode exists when you are setting&n; *  things up.&n; *&n; *  If it&squot;s transmitting it&squot;s not receiving and vice versa. In fact the&n; *  time to get the board back into useful state after an operation is&n; *  quite large.&n; *&n; *  The driver works by keeping the board in receive mode waiting for a&n; *  packet to arrive. When one arrives it is copied out of the buffer&n; *  and delivered to the kernel. The card is reloaded and off we go.&n; *&n; *  When transmitting lp-&gt;txing is set and the card is reset (from&n; *  receive mode) [possibly losing a packet just received] to command&n; *  mode. A packet is loaded and transmit mode triggered. The interrupt&n; *  handler runs different code for transmit interrupts and can handle&n; *  returning to receive mode or retransmissions (yes you have to help&n; *  out with those too).&n; *&n; * DOC: Problems&n; *  &n; *  There are a wide variety of undocumented error returns from the card&n; *  and you basically have to kick the board and pray if they turn up. Most&n; *  only occur under extreme load or if you do something the board doesn&squot;t&n; *  like (eg touching a register at the wrong time).&n; *&n; *  The driver is less efficient than it could be. It switches through&n; *  receive mode even if more transmits are queued. If this worries you buy&n; *  a real Ethernet card.&n; *&n; *  The combination of slow receive restart and no real multicast&n; *  filter makes the board unusable with a kernel compiled for IP&n; *  multicasting in a real multicast environment. That&squot;s down to the board,&n; *  but even with no multicast programs running a multicast IP kernel is&n; *  in group 224.0.0.1 and you will therefore be listening to all multicasts.&n; *  One nv conference running over that Ethernet and you can give up.&n; *&n; */
DECL|macro|DRV_NAME
mdefine_line|#define DRV_NAME&t;&quot;3c501&quot;
DECL|macro|DRV_VERSION
mdefine_line|#define DRV_VERSION&t;&quot;2002/10/09&quot;
DECL|variable|version
r_static
r_const
r_char
id|version
(braket
)braket
op_assign
id|DRV_NAME
l_string|&quot;.c: &quot;
id|DRV_VERSION
l_string|&quot; Alan Cox (alan@redhat.com).&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; *&t;Braindamage remaining:&n; *&t;The 3c501 board.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/config.h&gt;&t;/* for CONFIG_IP_MULTICAST */
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/ethtool.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &quot;3c501.h&quot;
multiline_comment|/*&n; *&t;The boilerplate probe code.&n; */
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0x280
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
op_assign
l_int|5
suffix:semicolon
DECL|variable|mem_start
r_static
r_int
id|mem_start
suffix:semicolon
multiline_comment|/**&n; * el1_probe:&t;&t;-&t;probe for a 3c501&n; * @dev: The device structure passed in to probe. &n; *&n; * This can be called from two places. The network layer will probe using&n; * a device structure passed in with the probe information completed. For a&n; * modular driver we use #init_module to fill in our own structure and probe&n; * for it.&n; *&n; * Returns 0 on success. ENXIO if asked not to probe and ENODEV if asked to&n; * probe and failing to find anything.&n; */
DECL|function|el1_probe
r_struct
id|net_device
op_star
id|__init
id|el1_probe
c_func
(paren
r_int
id|unit
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|alloc_etherdev
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
r_static
r_int
id|ports
(braket
)braket
op_assign
(brace
l_int|0x280
comma
l_int|0x300
comma
l_int|0
)brace
suffix:semicolon
r_int
op_star
id|port
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
op_ge
l_int|0
)paren
(brace
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth%d&quot;
comma
id|unit
)paren
suffix:semicolon
id|netdev_boot_setup_check
c_func
(paren
id|dev
)paren
suffix:semicolon
id|io
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|mem_start
op_assign
id|dev-&gt;mem_start
op_amp
l_int|7
suffix:semicolon
)brace
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io
OG
l_int|0x1ff
)paren
(brace
multiline_comment|/* Check a single specified location. */
id|err
op_assign
id|el1_probe1
c_func
(paren
id|dev
comma
id|io
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|io
op_ne
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* Don&squot;t probe at all. */
)brace
r_else
(brace
r_for
c_loop
(paren
id|port
op_assign
id|ports
suffix:semicolon
op_star
id|port
op_logical_and
id|el1_probe1
c_func
(paren
id|dev
comma
op_star
id|port
)paren
suffix:semicolon
id|port
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|port
)paren
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|register_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out1
suffix:semicolon
r_return
id|dev
suffix:semicolon
id|out1
suffix:colon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|EL1_IO_EXTENT
)paren
suffix:semicolon
id|out
suffix:colon
id|free_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;el1_probe1: &n; *&t;@dev: The device structure to use&n; *&t;@ioaddr: An I/O address to probe at.&n; *&n; *&t;The actual probe. This is iterated over by #el1_probe in order to&n; *&t;check all the applicable device locations.&n; *&n; *&t;Returns 0 for a success, in which case the device is activated,&n; *&t;EAGAIN if the IRQ is in use by another driver, and ENODEV if the&n; *&t;board cannot be found.&n; */
DECL|function|el1_probe1
r_static
r_int
id|__init
id|el1_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_const
r_char
op_star
id|mname
suffix:semicolon
multiline_comment|/* Vendor name */
r_int
r_char
id|station_addr
(braket
l_int|6
)braket
suffix:semicolon
r_int
id|autoirq
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Reserve I/O resource for exclusive use by this driver&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|ioaddr
comma
id|EL1_IO_EXTENT
comma
id|DRV_NAME
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Read the station address PROM data from the special port.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outw
c_func
(paren
id|i
comma
id|ioaddr
op_plus
id|EL1_DATAPTR
)paren
suffix:semicolon
id|station_addr
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|EL1_SAPROM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Check the first three octets of the S.A. for 3Com&squot;s prefix, or&n;&t; *&t;for the Sager NP943 prefix.&n;&t; */
r_if
c_cond
(paren
id|station_addr
(braket
l_int|0
)braket
op_eq
l_int|0x02
op_logical_and
id|station_addr
(braket
l_int|1
)braket
op_eq
l_int|0x60
op_logical_and
id|station_addr
(braket
l_int|2
)braket
op_eq
l_int|0x8c
)paren
(brace
id|mname
op_assign
l_string|&quot;3c501&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|station_addr
(braket
l_int|0
)braket
op_eq
l_int|0x00
op_logical_and
id|station_addr
(braket
l_int|1
)braket
op_eq
l_int|0x80
op_logical_and
id|station_addr
(braket
l_int|2
)braket
op_eq
l_int|0xC8
)paren
(brace
id|mname
op_assign
l_string|&quot;NP943&quot;
suffix:semicolon
)brace
r_else
(brace
id|release_region
c_func
(paren
id|ioaddr
comma
id|EL1_IO_EXTENT
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We auto-IRQ by shutting off the interrupt line and letting it float&n;&t; *&t;high.&n;&t; */
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
r_int
r_int
id|irq_mask
suffix:semicolon
id|irq_mask
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
multiline_comment|/* Clear pending interrupts. */
id|inb
c_func
(paren
id|TX_STATUS
)paren
suffix:semicolon
id|outb
c_func
(paren
id|AX_LOOP
op_plus
l_int|1
comma
id|AX_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|AX_CMD
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|autoirq
op_assign
id|probe_irq_off
c_func
(paren
id|irq_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|autoirq
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s probe at %#x failed to detect IRQ line.&bslash;n&quot;
comma
id|mname
comma
id|ioaddr
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|ioaddr
comma
id|EL1_IO_EXTENT
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
id|outb
c_func
(paren
id|AX_RESET
op_plus
id|AX_LOOP
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Loopback mode. */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|station_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem_start
op_amp
l_int|0xf
)paren
id|el_debug
op_assign
id|mem_start
op_amp
l_int|0x7
suffix:semicolon
r_if
c_cond
(paren
id|autoirq
)paren
id|dev-&gt;irq
op_assign
id|autoirq
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s EtherLink at %#lx, using %sIRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|mname
comma
id|dev-&gt;base_addr
comma
id|autoirq
ques
c_cond
l_string|&quot;auto&quot;
suffix:colon
l_string|&quot;assigned &quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WARNING: Use of the 3c501 in a multicast kernel is NOT recommended.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|el_debug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The EL1-specific entries in the device structure.&n;&t; */
id|dev-&gt;open
op_assign
op_amp
id|el_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|el_start_xmit
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
op_amp
id|el_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|HZ
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|el1_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|el1_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
id|dev-&gt;ethtool_ops
op_assign
op_amp
id|netdev_ethtool_ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;el1_open:&n; *&t;@dev: device that is being opened&n; *&n; *&t;When an ifconfig is issued which changes the device flags to include&n; *&t;IFF_UP this function is called. It is only called when the change &n; *&t;occurs, not when the interface remains up. #el1_close will be called&n; *&t;when it goes down.&n; *&n; *&t;Returns 0 for a successful open, or -EAGAIN if someone has run off&n; *&t;with our interrupt line.&n; */
DECL|function|el_open
r_static
r_int
id|el_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Doing el_open()...&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|el_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
)paren
)paren
r_return
id|retval
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|el_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|lp-&gt;txing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Board in RX mode */
id|outb
c_func
(paren
id|AX_RX
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Aux control, irq and receive enabled */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * el_timeout:&n; * @dev: The 3c501 card that has timed out&n; *&n; * Attempt to restart the board. This is basically a mixture of extreme&n; * violence and prayer&n; *&n; */
DECL|function|el_timeout
r_static
r_void
id|el_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: transmit timed out, txsr %#2x axsr=%02x rxsr=%02x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|TX_STATUS
)paren
comma
id|inb
c_func
(paren
id|AX_STATUS
)paren
comma
id|inb
c_func
(paren
id|RX_STATUS
)paren
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|outb
c_func
(paren
id|TX_NORM
comma
id|TX_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
id|RX_NORM
comma
id|RX_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
id|AX_OFF
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Just trigger a false interrupt. */
id|outb
c_func
(paren
id|AX_RX
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Aux control, irq and receive enabled */
id|lp-&gt;txing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Ripped back in to RX */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * el_start_xmit:&n; * @skb: The packet that is queued to be sent&n; * @dev: The 3c501 card we want to throw it down&n; *&n; * Attempt to send a packet to a 3c501 card. There are some interesting&n; * catches here because the 3c501 is an extremely old and therefore&n; * stupid piece of technology.&n; *&n; * If we are handling an interrupt on the other CPU we cannot load a packet&n; * as we may still be attempting to retrieve the last RX packet buffer.&n; *&n; * When a transmit times out we dump the card into control mode and just&n; * start again. It happens enough that it isnt worth logging.&n; *&n; * We avoid holding the spin locks when doing the packet load to the board.&n; * The device is very slow, and its DMA mode is even slower. If we held the&n; * lock while loading 1500 bytes onto the controller we would drop a lot of&n; * serial port characters. This requires we do extra locking, but we have&n; * no real choice.&n; */
DECL|function|el_start_xmit
r_static
r_int
id|el_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Avoid incoming interrupts between us flipping txing and flipping&n;&t; *&t;mode as the driver assumes txing is a faithful indicator of card&n;&t; *&t;state&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Avoid timer-based retransmission conflicts.&n;&t; */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_do
(brace
r_int
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_int
id|pad
op_assign
l_int|0
suffix:semicolon
r_int
id|gp_start
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|ETH_ZLEN
)paren
id|pad
op_assign
id|ETH_ZLEN
op_minus
id|len
suffix:semicolon
id|gp_start
op_assign
l_int|0x800
op_minus
(paren
id|len
op_plus
id|pad
)paren
suffix:semicolon
id|lp-&gt;tx_pkt_start
op_assign
id|gp_start
suffix:semicolon
id|lp-&gt;collisions
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Command mode with status cleared should [in theory]&n;&t;&t; *&t;mean no more interrupts can be pending on the card.&n;&t;&t; */
id|outb_p
c_func
(paren
id|AX_SYS
comma
id|AX_CMD
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|TX_STATUS
)paren
suffix:semicolon
id|lp-&gt;loading
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;txing
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Turn interrupts back on while we spend a pleasant afternoon&n;&t;&t; *&t;loading bytes into the board&n;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x00
comma
id|RX_BUF_CLR
)paren
suffix:semicolon
multiline_comment|/* Set rx packet area to 0. */
id|outw
c_func
(paren
id|gp_start
comma
id|GP_LOW
)paren
suffix:semicolon
multiline_comment|/* aim - packet will be loaded into buffer start */
id|outsb
c_func
(paren
id|DATAPORT
comma
id|buf
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* load buffer (usual thing each byte increments the pointer) */
r_if
c_cond
(paren
id|pad
)paren
(brace
r_while
c_loop
(paren
id|pad
op_decrement
)paren
(brace
multiline_comment|/* Zero fill buffer tail */
id|outb
c_func
(paren
l_int|0
comma
id|DATAPORT
)paren
suffix:semicolon
)brace
)brace
id|outw
c_func
(paren
id|gp_start
comma
id|GP_LOW
)paren
suffix:semicolon
multiline_comment|/* the board reuses the same register */
r_if
c_cond
(paren
id|lp-&gt;loading
op_ne
l_int|2
)paren
(brace
id|outb
c_func
(paren
id|AX_XMIT
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* fire ... Trigger xmit.  */
id|lp-&gt;loading
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; queued xmit.&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* A receive upset our load, despite our best efforts */
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: burped during tx load.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * el_interrupt:&n; * @irq: Interrupt number&n; * @dev_id: The 3c501 that burped&n; * @regs: Register data (surplus to our requirements)&n; *&n; * Handle the ether interface interrupts. The 3c501 needs a lot more &n; * hand holding than most cards. In particular we get a transmit interrupt&n; * with a collision error because the board firmware isnt capable of rewinding&n; * its own transmit buffer pointers. It can however count to 16 for us.&n; *&n; * On the receive side the card is also very dumb. It has no buffering to&n; * speak of. We simply pull the packet out of its PIO buffer (which is slow)&n; * and queue it for the kernel. Then we reset the card for the next packet.&n; *&n; * We sometimes get suprise interrupts late both because the SMP IRQ delivery&n; * is message passing and because the card sometimes seems to deliver late. I&n; * think if it is part way through a receive and the mode is changed it carries&n; * on receiving and sends us an interrupt. We have to band aid all these cases&n; * to get a sensible 150kbytes/second performance. Even then you want a small&n; * TCP window.&n; */
DECL|function|el_interrupt
r_static
id|irqreturn_t
id|el_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
suffix:semicolon
r_int
id|axsr
suffix:semicolon
multiline_comment|/* Aux. status reg. */
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;What happened ?&n;&t; */
id|axsr
op_assign
id|inb
c_func
(paren
id|AX_STATUS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Log it&n;&t; */
r_if
c_cond
(paren
id|el_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: el_interrupt() aux=%#02x&quot;
comma
id|dev-&gt;name
comma
id|axsr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;loading
op_eq
l_int|1
op_logical_and
op_logical_neg
id|lp-&gt;txing
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Inconsistent state loading while not in tx&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;txing
)paren
(brace
multiline_comment|/*&n;    &t;&t; *&t;Board in transmit mode. May be loading. If we are&n;    &t;&t; *&t;loading we shouldn&squot;t have got this.&n;    &t;&t; */
r_int
id|txsr
op_assign
id|inb
c_func
(paren
id|TX_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;loading
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Interrupt while loading [&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; txsr=%02x gp=%04x rp=%04x]&bslash;n&quot;
comma
id|txsr
comma
id|inw
c_func
(paren
id|GP_LOW
)paren
comma
id|inw
c_func
(paren
id|RX_LOW
)paren
)paren
suffix:semicolon
)brace
id|lp-&gt;loading
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Force a reload */
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|el_debug
OG
l_int|6
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; txsr=%02x gp=%04x rp=%04x&quot;
comma
id|txsr
comma
id|inw
c_func
(paren
id|GP_LOW
)paren
comma
id|inw
c_func
(paren
id|RX_LOW
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|axsr
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|txsr
op_amp
id|TX_READY
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;FIXME: is there a logic to whether to keep on trying or&n;&t;&t;&t; *&t;reset immediately ?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|el_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Unusual interrupt during Tx, txsr=%02x axsr=%02x&quot;
l_string|&quot; gp=%03x rp=%03x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|txsr
comma
id|axsr
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|EL1_DATAPTR
)paren
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|EL1_RXPTR
)paren
)paren
suffix:semicolon
)brace
id|lp-&gt;txing
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|txsr
op_amp
id|TX_16COLLISIONS
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Timed out&n;&t;&t;&t; */
r_if
c_cond
(paren
id|el_debug
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: Transmit failed 16 times, Ethernet jammed?&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|outb
c_func
(paren
id|AX_SYS
comma
id|AX_CMD
)paren
suffix:semicolon
id|lp-&gt;txing
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|txsr
op_amp
id|TX_COLLISION
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Retrigger xmit.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|el_debug
OG
l_int|6
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; retransmitting after a collision.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Poor little chip can&squot;t reset its own start pointer&n;&t;&t;&t; */
id|outb
c_func
(paren
id|AX_SYS
comma
id|AX_CMD
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_pkt_start
comma
id|GP_LOW
)paren
suffix:semicolon
id|outb
c_func
(paren
id|AX_XMIT
comma
id|AX_CMD
)paren
suffix:semicolon
id|lp-&gt;stats.collisions
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;It worked.. we will now fall through and receive&n;&t;&t;&t; */
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|6
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; Tx succeeded %s&bslash;n&quot;
comma
(paren
id|txsr
op_amp
id|TX_RDY
)paren
ques
c_cond
l_string|&quot;.&quot;
suffix:colon
l_string|&quot;but tx is busy!&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;This is safe the interrupt is atomic WRT itself.&n;&t;&t;&t; */
id|lp-&gt;txing
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* In case more to transmit */
)brace
)brace
r_else
(brace
multiline_comment|/*&n;    &t;&t; *&t;In receive mode.&n;    &t;&t; */
r_int
id|rxsr
op_assign
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; rxsr=%02x txsr=%02x rp=%04x&quot;
comma
id|rxsr
comma
id|inb
c_func
(paren
id|TX_STATUS
)paren
comma
id|inw
c_func
(paren
id|RX_LOW
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Just reading rx_status fixes most errors.&n;&t;&t; */
r_if
c_cond
(paren
id|rxsr
op_amp
id|RX_MISSED
)paren
id|lp-&gt;stats.rx_missed_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rxsr
op_amp
id|RX_RUNT
)paren
(brace
multiline_comment|/* Handled to avoid board lock-up. */
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; runt.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rxsr
op_amp
id|RX_GOOD
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Receive worked.&n;&t;&t;&t; */
id|el_receive
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Nothing?  Something is broken!&n;&t;&t;&t; */
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: No packet seen, rxsr=%02x **resetting 3c501***&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rxsr
)paren
suffix:semicolon
id|el_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|el_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Move into receive mode&n;&t; */
id|outb
c_func
(paren
id|AX_RX
comma
id|AX_CMD
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x00
comma
id|RX_BUF_CLR
)paren
suffix:semicolon
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
multiline_comment|/* Be certain that interrupts are cleared. */
id|inb
c_func
(paren
id|TX_STATUS
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/**&n; * el_receive:&n; * @dev: Device to pull the packets from&n; *&n; * We have a good packet. Well, not really &quot;good&quot;, just mostly not broken.&n; * We must check everything to see if it is good. In particular we occasionally&n; * get wild packet sizes from the card. If the packet seems sane we PIO it&n; * off the card and queue it for the protocol layers.&n; */
DECL|function|el_receive
r_static
r_void
id|el_receive
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|pkt_len
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|pkt_len
op_assign
id|inw
c_func
(paren
id|RX_LOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; el_receive %d.&bslash;n&quot;
comma
id|pkt_len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pkt_len
OL
l_int|60
)paren
op_logical_or
(paren
id|pkt_len
OG
l_int|1536
)paren
)paren
(brace
r_if
c_cond
(paren
id|el_debug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: bogus packet, length=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pkt_len
)paren
suffix:semicolon
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Command mode so we can empty the buffer&n;&t; */
id|outb
c_func
(paren
id|AX_SYS
comma
id|AX_CMD
)paren
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Start of frame&n;&t; */
id|outw
c_func
(paren
l_int|0x00
comma
id|GP_LOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Force 16 byte alignment */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;The read increments through the bytes. The interrupt&n;&t;&t; *&t;handler will fix the pointer when it returns to&n;&t;&t; *&t;receive mode.&n;&t;&t; */
id|insb
c_func
(paren
id|DATAPORT
comma
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
comma
id|pkt_len
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * el_reset: Reset a 3c501 card&n; * @dev: The 3c501 card about to get zapped&n; *&n; * Even resetting a 3c501 isnt simple. When you activate reset it loses all&n; * its configuration. You must hold the lock when doing this. The function&n; * cannot take the lock itself as it is callable from the irq handler.&n; */
DECL|function|el_reset
r_static
r_void
id|el_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;3c501 reset...&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
id|AX_RESET
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Reset the chip */
id|outb
c_func
(paren
id|AX_LOOP
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Aux control, irq and loopback enabled */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* Set the station address. */
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|ioaddr
op_plus
id|i
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
l_int|0
comma
id|RX_BUF_CLR
)paren
suffix:semicolon
multiline_comment|/* Set rx packet area to 0. */
id|outb
c_func
(paren
id|TX_NORM
comma
id|TX_CMD
)paren
suffix:semicolon
multiline_comment|/* tx irq on done, collision */
id|outb
c_func
(paren
id|RX_NORM
comma
id|RX_CMD
)paren
suffix:semicolon
multiline_comment|/* Set Rx commands. */
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
multiline_comment|/* Clear status. */
id|inb
c_func
(paren
id|TX_STATUS
)paren
suffix:semicolon
id|lp-&gt;txing
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * el1_close:&n; * @dev: 3c501 card to shut down&n; *&n; * Close a 3c501 card. The IFF_UP flag has been cleared by the user via&n; * the SIOCSIFFLAGS ioctl. We stop any further transmissions being queued,&n; * and then disable the interrupts. Finally we reset the chip. The effects&n; * of the rest will be cleaned up by #el1_open. Always returns 0 indicating&n; * a success.&n; */
DECL|function|el1_close
r_static
r_int
id|el1_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Shutting down Ethernet card at %#x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Free and disable the IRQ.&n;&t; */
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
id|AX_RESET
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Reset the chip */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * el1_get_stats:&n; * @dev: The card to get the statistics for&n; *&n; * In smarter devices this function is needed to pull statistics off the&n; * board itself. The 3c501 has no hardware statistics. We maintain them all&n; * so they are by definition always up to date.&n; *&n; * Returns the statistics for the card from the card private data&n; */
DECL|function|el1_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|el1_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/**&n; * set_multicast_list:&n; * @dev: The device to adjust&n; *&n; * Set or clear the multicast filter for this adaptor to use the best-effort &n; * filtering supported. The 3c501 supports only three modes of filtering.&n; * It always receives broadcasts and packets for itself. You can choose to&n; * optionally receive all packets, or all multicast packets on top of this.&n; */
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|outb
c_func
(paren
id|RX_PROM
comma
id|RX_CMD
)paren
suffix:semicolon
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_list
op_logical_or
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
id|outb
c_func
(paren
id|RX_MULT
comma
id|RX_CMD
)paren
suffix:semicolon
multiline_comment|/* Multicast or all multicast is the same */
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
multiline_comment|/* Clear status. */
)brace
r_else
(brace
id|outb
c_func
(paren
id|RX_NORM
comma
id|RX_CMD
)paren
suffix:semicolon
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
)brace
)brace
DECL|function|netdev_get_drvinfo
r_static
r_void
id|netdev_get_drvinfo
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ethtool_drvinfo
op_star
id|info
)paren
(brace
id|strcpy
c_func
(paren
id|info-&gt;driver
comma
id|DRV_NAME
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|info-&gt;version
comma
id|DRV_VERSION
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|info-&gt;bus_info
comma
l_string|&quot;ISA 0x%lx&quot;
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
)brace
DECL|function|netdev_get_msglevel
r_static
id|u32
id|netdev_get_msglevel
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_return
id|debug
suffix:semicolon
)brace
DECL|function|netdev_set_msglevel
r_static
r_void
id|netdev_set_msglevel
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|level
)paren
(brace
id|debug
op_assign
id|level
suffix:semicolon
)brace
DECL|variable|netdev_ethtool_ops
r_static
r_struct
id|ethtool_ops
id|netdev_ethtool_ops
op_assign
(brace
dot
id|get_drvinfo
op_assign
id|netdev_get_drvinfo
comma
dot
id|get_msglevel
op_assign
id|netdev_get_msglevel
comma
dot
id|set_msglevel
op_assign
id|netdev_set_msglevel
comma
)brace
suffix:semicolon
macro_line|#ifdef MODULE
DECL|variable|dev_3c501
r_static
r_struct
id|net_device
op_star
id|dev_3c501
suffix:semicolon
id|module_param
c_func
(paren
id|io
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|irq
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|io
comma
l_string|&quot;EtherLink I/O base address&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|irq
comma
l_string|&quot;EtherLink IRQ number&quot;
)paren
suffix:semicolon
multiline_comment|/**&n; * init_module:&n; *&n; * When the driver is loaded as a module this function is called. We fake up&n; * a device structure with the base I/O and interrupt set as if it were being&n; * called from Space.c. This minimises the extra code that would otherwise&n; * be required.&n; *&n; * Returns 0 for success or -EIO if a card is not found. Returning an error&n; * here also causes the module to be unloaded&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|dev_3c501
op_assign
id|el1_probe
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dev_3c501
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|dev_3c501
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * cleanup_module:&n; * &n; * The module is being unloaded. We unhook our network device from the system&n; * and then free up the resources we took when the card was found.&n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_3c501
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|EL1_IO_EXTENT
)paren
suffix:semicolon
id|free_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Donald Becker, Alan Cox&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Support for the ancient 3Com 3c501 ethernet card&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
