multiline_comment|/*******************************************************************************&n;&n;  &n;  Copyright(c) 1999 - 2005 Intel Corporation. All rights reserved.&n;  &n;  This program is free software; you can redistribute it and/or modify it &n;  under the terms of the GNU General Public License as published by the Free &n;  Software Foundation; either version 2 of the License, or (at your option) &n;  any later version.&n;  &n;  This program is distributed in the hope that it will be useful, but WITHOUT &n;  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or &n;  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for &n;  more details.&n;  &n;  You should have received a copy of the GNU General Public License along with&n;  this program; if not, write to the Free Software Foundation, Inc., 59 &n;  Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n;  &n;  The full GNU General Public License is included in this distribution in the&n;  file called LICENSE.&n;  &n;  Contact Information:&n;  Linux NICS &lt;linux.nics@intel.com&gt;&n;  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497&n;&n;*******************************************************************************/
multiline_comment|/* ixgb_hw.c&n; * Shared functions for accessing and configuring the adapter&n; */
macro_line|#include &quot;ixgb_hw.h&quot;
macro_line|#include &quot;ixgb_ids.h&quot;
multiline_comment|/*  Local function prototypes */
r_static
r_uint32
id|ixgb_hash_mc_addr
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
comma
r_uint8
op_star
id|mc_addr
)paren
suffix:semicolon
r_static
r_void
id|ixgb_mta_set
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
comma
r_uint32
id|hash_value
)paren
suffix:semicolon
r_static
r_void
id|ixgb_get_bus_info
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
id|boolean_t
id|ixgb_link_reset
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_void
id|ixgb_optics_reset
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
id|ixgb_phy_type
id|ixgb_identify_phy
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
suffix:semicolon
r_uint32
id|ixgb_mac_reset
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
suffix:semicolon
DECL|function|ixgb_mac_reset
r_uint32
id|ixgb_mac_reset
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl_reg
suffix:semicolon
id|ctrl_reg
op_assign
id|IXGB_CTRL0_RST
op_or
id|IXGB_CTRL0_SDP3_DIR
op_or
multiline_comment|/* All pins are Output=1 */
id|IXGB_CTRL0_SDP2_DIR
op_or
id|IXGB_CTRL0_SDP1_DIR
op_or
id|IXGB_CTRL0_SDP0_DIR
op_or
id|IXGB_CTRL0_SDP3
op_or
multiline_comment|/* Initial value 1101   */
id|IXGB_CTRL0_SDP2
op_or
id|IXGB_CTRL0_SDP0
suffix:semicolon
macro_line|#ifdef HP_ZX1
multiline_comment|/* Workaround for 82597EX reset errata */
id|IXGB_WRITE_REG_IO
c_func
(paren
id|hw
comma
id|CTRL0
comma
id|ctrl_reg
)paren
suffix:semicolon
macro_line|#else
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL0
comma
id|ctrl_reg
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Delay a few ms just to allow the reset to complete */
id|msec_delay
c_func
(paren
id|IXGB_DELAY_AFTER_RESET
)paren
suffix:semicolon
id|ctrl_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|CTRL0
)paren
suffix:semicolon
macro_line|#ifdef DBG
multiline_comment|/* Make sure the self-clearing global reset bit did self clear */
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|ctrl_reg
op_amp
id|IXGB_CTRL0_RST
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|ixgb_phy_type_txn17401
)paren
(brace
id|ixgb_optics_reset
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_return
id|ctrl_reg
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Reset the transmit and receive units; mask and clear all interrupts.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
id|boolean_t
DECL|function|ixgb_adapter_stop
id|ixgb_adapter_stop
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl_reg
suffix:semicolon
r_uint32
id|icr_reg
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;ixgb_adapter_stop&quot;
)paren
suffix:semicolon
multiline_comment|/* If we are stopped or resetting exit gracefully and wait to be&n;&t; * started again before accessing the hardware.&n;&t; */
r_if
c_cond
(paren
id|hw-&gt;adapter_stopped
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Exiting because the adapter is already stopped!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Set the Adapter Stopped flag so other driver functions stop&n;&t; * touching the Hardware.&n;&t; */
id|hw-&gt;adapter_stopped
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Clear interrupt mask to stop board from generating interrupts */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Masking off all interrupts&bslash;n&quot;
)paren
suffix:semicolon
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|IMC
comma
l_int|0xFFFFFFFF
)paren
suffix:semicolon
multiline_comment|/* Disable the Transmit and Receive units.  Then delay to allow&n;&t; * any pending transactions to complete before we hit the MAC with&n;&t; * the global reset.&n;&t; */
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|RCTL
comma
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|RCTL
)paren
op_amp
op_complement
id|IXGB_RCTL_RXEN
)paren
suffix:semicolon
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|TCTL
comma
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|TCTL
)paren
op_amp
op_complement
id|IXGB_TCTL_TXEN
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
id|IXGB_DELAY_BEFORE_RESET
)paren
suffix:semicolon
multiline_comment|/* Issue a global reset to the MAC.  This will reset the chip&squot;s&n;&t; * transmit, receive, DMA, and link units.  It will not effect&n;&t; * the current PCI configuration.  The global reset bit is self-&n;&t; * clearing, and should clear within a microsecond.&n;&t; */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Issuing a global reset to MAC&bslash;n&quot;
)paren
suffix:semicolon
id|ctrl_reg
op_assign
id|ixgb_mac_reset
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Clear interrupt mask to stop board from generating interrupts */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Masking off all interrupts&bslash;n&quot;
)paren
suffix:semicolon
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|IMC
comma
l_int|0xffffffff
)paren
suffix:semicolon
multiline_comment|/* Clear any pending interrupt events. */
id|icr_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|ICR
)paren
suffix:semicolon
r_return
(paren
id|ctrl_reg
op_amp
id|IXGB_CTRL0_RST
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Identifies the vendor of the optics module on the adapter.  The SR adapters&n; * support two different types of XPAK optics, so it is necessary to determine&n; * which optics are present before applying any optics-specific workarounds.&n; *&n; * hw - Struct containing variables accessed by shared code.&n; *&n; * Returns: the vendor of the XPAK optics module.&n; *****************************************************************************/
r_static
id|ixgb_xpak_vendor
DECL|function|ixgb_identify_xpak_vendor
id|ixgb_identify_xpak_vendor
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_uint16
id|vendor_name
(braket
l_int|5
)braket
suffix:semicolon
id|ixgb_xpak_vendor
id|xpak_vendor
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;ixgb_identify_xpak_vendor&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the first few bytes of the vendor string from the XPAK NVR&n;&t; * registers.  These are standard XENPAK/XPAK registers, so all XPAK&n;&t; * devices should implement them. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|vendor_name
(braket
id|i
)braket
op_assign
id|ixgb_read_phy_reg
c_func
(paren
id|hw
comma
id|MDIO_PMA_PMD_XPAK_VENDOR_NAME
op_plus
id|i
comma
id|IXGB_PHY_ADDRESS
comma
id|MDIO_PMA_PMD_DID
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine the actual vendor */
r_if
c_cond
(paren
id|vendor_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;I&squot;
op_logical_and
id|vendor_name
(braket
l_int|1
)braket
op_eq
l_char|&squot;N&squot;
op_logical_and
id|vendor_name
(braket
l_int|2
)braket
op_eq
l_char|&squot;T&squot;
op_logical_and
id|vendor_name
(braket
l_int|3
)braket
op_eq
l_char|&squot;E&squot;
op_logical_and
id|vendor_name
(braket
l_int|4
)braket
op_eq
l_char|&squot;L&squot;
)paren
(brace
id|xpak_vendor
op_assign
id|ixgb_xpak_vendor_intel
suffix:semicolon
)brace
r_else
(brace
id|xpak_vendor
op_assign
id|ixgb_xpak_vendor_infineon
suffix:semicolon
)brace
r_return
(paren
id|xpak_vendor
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Determine the physical layer module on the adapter.&n; *&n; * hw - Struct containing variables accessed by shared code.  The device_id&n; *      field must be (correctly) populated before calling this routine.&n; *&n; * Returns: the phy type of the adapter.&n; *****************************************************************************/
r_static
id|ixgb_phy_type
DECL|function|ixgb_identify_phy
id|ixgb_identify_phy
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
id|ixgb_phy_type
id|phy_type
suffix:semicolon
id|ixgb_xpak_vendor
id|xpak_vendor
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;ixgb_identify_phy&quot;
)paren
suffix:semicolon
multiline_comment|/* Infer the transceiver/phy type from the device id */
r_switch
c_cond
(paren
id|hw-&gt;device_id
)paren
(brace
r_case
id|IXGB_DEVICE_ID_82597EX
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Identified TXN17401 optics&bslash;n&quot;
)paren
suffix:semicolon
id|phy_type
op_assign
id|ixgb_phy_type_txn17401
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IXGB_DEVICE_ID_82597EX_SR
suffix:colon
multiline_comment|/* The SR adapters carry two different types of XPAK optics&n;&t;&t; * modules; read the vendor identifier to determine the exact&n;&t;&t; * type of optics. */
id|xpak_vendor
op_assign
id|ixgb_identify_xpak_vendor
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xpak_vendor
op_eq
id|ixgb_xpak_vendor_intel
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Identified TXN17201 optics&bslash;n&quot;
)paren
suffix:semicolon
id|phy_type
op_assign
id|ixgb_phy_type_txn17201
suffix:semicolon
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Identified G6005 optics&bslash;n&quot;
)paren
suffix:semicolon
id|phy_type
op_assign
id|ixgb_phy_type_g6005
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IXGB_DEVICE_ID_82597EX_LR
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Identified G6104 optics&bslash;n&quot;
)paren
suffix:semicolon
id|phy_type
op_assign
id|ixgb_phy_type_g6104
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Unknown physical layer module&bslash;n&quot;
)paren
suffix:semicolon
id|phy_type
op_assign
id|ixgb_phy_type_unknown
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|phy_type
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Performs basic configuration of the adapter.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Resets the controller.&n; * Reads and validates the EEPROM.&n; * Initializes the receive address registers.&n; * Initializes the multicast table.&n; * Clears all on-chip counters.&n; * Calls routine to setup flow control settings.&n; * Leaves the transmit and receive units disabled and uninitialized.&n; *&n; * Returns:&n; *      TRUE if successful,&n; *      FALSE if unrecoverable problems were encountered.&n; *****************************************************************************/
id|boolean_t
DECL|function|ixgb_init_hw
id|ixgb_init_hw
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_uint32
id|ctrl_reg
suffix:semicolon
id|boolean_t
id|status
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;ixgb_init_hw&quot;
)paren
suffix:semicolon
multiline_comment|/* Issue a global reset to the MAC.  This will reset the chip&squot;s&n;&t; * transmit, receive, DMA, and link units.  It will not effect&n;&t; * the current PCI configuration.  The global reset bit is self-&n;&t; * clearing, and should clear within a microsecond.&n;&t; */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Issuing a global reset to MAC&bslash;n&quot;
)paren
suffix:semicolon
id|ctrl_reg
op_assign
id|ixgb_mac_reset
c_func
(paren
id|hw
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Issuing an EE reset to MAC&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef HP_ZX1
multiline_comment|/* Workaround for 82597EX reset errata */
id|IXGB_WRITE_REG_IO
c_func
(paren
id|hw
comma
id|CTRL1
comma
id|IXGB_CTRL1_EE_RST
)paren
suffix:semicolon
macro_line|#else
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL1
comma
id|IXGB_CTRL1_EE_RST
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Delay a few ms just to allow the reset to complete */
id|msec_delay
c_func
(paren
id|IXGB_DELAY_AFTER_EE_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ixgb_get_eeprom_data
c_func
(paren
id|hw
)paren
op_eq
id|FALSE
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Use the device id to determine the type of phy/transceiver. */
id|hw-&gt;device_id
op_assign
id|ixgb_get_ee_device_id
c_func
(paren
id|hw
)paren
suffix:semicolon
id|hw-&gt;phy_type
op_assign
id|ixgb_identify_phy
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Setup the receive addresses.&n;&t; * Receive Address Registers (RARs 0 - 15).&n;&t; */
id|ixgb_init_rx_addrs
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check that a valid MAC address has been set.&n;&t; * If it is not valid, we fail hardware init.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mac_addr_valid
c_func
(paren
id|hw-&gt;curr_mac_addr
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MAC address invalid after ixgb_init_rx_addrs&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* tell the routines in this file they can access hardware again */
id|hw-&gt;adapter_stopped
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Fill in the bus_info structure */
id|ixgb_get_bus_info
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Zero out the Multicast HASH table */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Zeroing the MTA&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IXGB_MC_TBL_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|IXGB_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Zero out the VLAN Filter Table Array */
id|ixgb_clear_vfta
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Zero all of the hardware counters */
id|ixgb_clear_hw_cntrs
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Call a subroutine to setup flow control. */
id|status
op_assign
id|ixgb_setup_fc
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* 82597EX errata: Call check-for-link in case lane deskew is locked */
id|ixgb_check_for_link
c_func
(paren
id|hw
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Initializes receive address filters.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Places the MAC address in receive address register 0 and clears the rest&n; * of the receive addresss registers. Clears the multicast table. Assumes&n; * the receiver is in reset when the routine is called.&n; *****************************************************************************/
r_void
DECL|function|ixgb_init_rx_addrs
id|ixgb_init_rx_addrs
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_uint32
id|i
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;ixgb_init_rx_addrs&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the current mac address is valid, assume it is a software override&n;&t; * to the permanent address.&n;&t; * Otherwise, use the permanent address from the eeprom.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mac_addr_valid
c_func
(paren
id|hw-&gt;curr_mac_addr
)paren
)paren
(brace
multiline_comment|/* Get the MAC address from the eeprom for later reference */
id|ixgb_get_ee_mac_addr
c_func
(paren
id|hw
comma
id|hw-&gt;curr_mac_addr
)paren
suffix:semicolon
id|DEBUGOUT3
c_func
(paren
l_string|&quot; Keeping Permanent MAC Addr =%.2X %.2X %.2X &quot;
comma
id|hw-&gt;curr_mac_addr
(braket
l_int|0
)braket
comma
id|hw-&gt;curr_mac_addr
(braket
l_int|1
)braket
comma
id|hw-&gt;curr_mac_addr
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|DEBUGOUT3
c_func
(paren
l_string|&quot;%.2X %.2X %.2X&bslash;n&quot;
comma
id|hw-&gt;curr_mac_addr
(braket
l_int|3
)braket
comma
id|hw-&gt;curr_mac_addr
(braket
l_int|4
)braket
comma
id|hw-&gt;curr_mac_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Setup the receive address. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Overriding MAC Address in RAR[0]&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUGOUT3
c_func
(paren
l_string|&quot; New MAC Addr =%.2X %.2X %.2X &quot;
comma
id|hw-&gt;curr_mac_addr
(braket
l_int|0
)braket
comma
id|hw-&gt;curr_mac_addr
(braket
l_int|1
)braket
comma
id|hw-&gt;curr_mac_addr
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|DEBUGOUT3
c_func
(paren
l_string|&quot;%.2X %.2X %.2X&bslash;n&quot;
comma
id|hw-&gt;curr_mac_addr
(braket
l_int|3
)braket
comma
id|hw-&gt;curr_mac_addr
(braket
l_int|4
)braket
comma
id|hw-&gt;curr_mac_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|ixgb_rar_set
c_func
(paren
id|hw
comma
id|hw-&gt;curr_mac_addr
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Zero out the other 15 receive addresses. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Clearing RAR[1-15]&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|IXGB_RAR_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|IXGB_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
id|i
op_lshift
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
id|IXGB_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
(paren
id|i
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Updates the MAC&squot;s list of multicast addresses.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * mc_addr_list - the list of new multicast addresses&n; * mc_addr_count - number of addresses&n; * pad - number of bytes between addresses in the list&n; *&n; * The given list replaces any existing list. Clears the last 15 receive&n; * address registers and the multicast table. Uses receive address registers&n; * for the first 15 multicast addresses, and hashes the rest into the&n; * multicast table.&n; *****************************************************************************/
r_void
DECL|function|ixgb_mc_addr_list_update
id|ixgb_mc_addr_list_update
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
comma
r_uint8
op_star
id|mc_addr_list
comma
r_uint32
id|mc_addr_count
comma
r_uint32
id|pad
)paren
(brace
r_uint32
id|hash_value
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_uint32
id|rar_used_count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* RAR[0] is used for our MAC address */
id|DEBUGFUNC
c_func
(paren
l_string|&quot;ixgb_mc_addr_list_update&quot;
)paren
suffix:semicolon
multiline_comment|/* Set the new number of MC addresses that we are being requested to use. */
id|hw-&gt;num_mc_addrs
op_assign
id|mc_addr_count
suffix:semicolon
multiline_comment|/* Clear RAR[1-15] */
id|DEBUGOUT
c_func
(paren
l_string|&quot; Clearing RAR[1-15]&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rar_used_count
suffix:semicolon
id|i
OL
id|IXGB_RAR_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|IXGB_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
id|i
op_lshift
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
id|IXGB_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
(paren
id|i
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear the MTA */
id|DEBUGOUT
c_func
(paren
l_string|&quot; Clearing MTA&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IXGB_MC_TBL_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|IXGB_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Add the new addresses */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mc_addr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot; Adding the multicast addresses:&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUGOUT7
c_func
(paren
l_string|&quot; MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X&bslash;n&quot;
comma
id|i
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|IXGB_ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|IXGB_ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|1
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|IXGB_ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|2
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|IXGB_ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|3
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|IXGB_ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|4
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|IXGB_ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/* Place this multicast address in the RAR if there is room, *&n;&t;&t; * else put it in the MTA&n;&t;&t; */
r_if
c_cond
(paren
id|rar_used_count
OL
id|IXGB_RAR_ENTRIES
)paren
(brace
id|ixgb_rar_set
c_func
(paren
id|hw
comma
id|mc_addr_list
op_plus
(paren
id|i
op_star
(paren
id|IXGB_ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
)paren
comma
id|rar_used_count
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Added a multicast address to RAR[%d]&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|rar_used_count
op_increment
suffix:semicolon
)brace
r_else
(brace
id|hash_value
op_assign
id|ixgb_hash_mc_addr
c_func
(paren
id|hw
comma
id|mc_addr_list
op_plus
(paren
id|i
op_star
(paren
id|IXGB_ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
)paren
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot; Hash value = 0x%03X&bslash;n&quot;
comma
id|hash_value
)paren
suffix:semicolon
id|ixgb_mta_set
c_func
(paren
id|hw
comma
id|hash_value
)paren
suffix:semicolon
)brace
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MC Update Complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Hashes an address to determine its location in the multicast table&n; *&n; * hw - Struct containing variables accessed by shared code&n; * mc_addr - the multicast address to hash&n; *&n; * Returns:&n; *      The hash value&n; *****************************************************************************/
r_static
r_uint32
DECL|function|ixgb_hash_mc_addr
id|ixgb_hash_mc_addr
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
comma
r_uint8
op_star
id|mc_addr
)paren
(brace
r_uint32
id|hash_value
op_assign
l_int|0
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;ixgb_hash_mc_addr&quot;
)paren
suffix:semicolon
multiline_comment|/* The portion of the address that is used for the hash table is&n;&t; * determined by the mc_filter_type setting.&n;&t; */
r_switch
c_cond
(paren
id|hw-&gt;mc_filter_type
)paren
(brace
multiline_comment|/* [0] [1] [2] [3] [4] [5]&n;&t;&t; * 01  AA  00  12  34  56&n;&t;&t; * LSB                 MSB - According to H/W docs */
r_case
l_int|0
suffix:colon
multiline_comment|/* [47:36] i.e. 0x563 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
op_rshift
l_int|4
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* [46:35] i.e. 0xAC6 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
op_rshift
l_int|3
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|5
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* [45:34] i.e. 0x5D8 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
op_rshift
l_int|2
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|6
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* [43:32] i.e. 0x634 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Invalid mc_filter_type, what should we do? */
id|DEBUGOUT
c_func
(paren
l_string|&quot;MC filter type param set incorrectly&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hash_value
op_and_assign
l_int|0xFFF
suffix:semicolon
r_return
(paren
id|hash_value
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Sets the bit in the multicast table corresponding to the hash value.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * hash_value - Multicast address hash value&n; *****************************************************************************/
r_static
r_void
DECL|function|ixgb_mta_set
id|ixgb_mta_set
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
comma
r_uint32
id|hash_value
)paren
(brace
r_uint32
id|hash_bit
comma
id|hash_reg
suffix:semicolon
r_uint32
id|mta_reg
suffix:semicolon
multiline_comment|/* The MTA is a register array of 128 32-bit registers.&n;&t; * It is treated like an array of 4096 bits.  We want to set&n;&t; * bit BitArray[hash_value]. So we figure out what register&n;&t; * the bit is in, read it, OR in the new bit, then write&n;&t; * back the new value.  The register is determined by the&n;&t; * upper 7 bits of the hash value and the bit within that&n;&t; * register are determined by the lower 5 bits of the value.&n;&t; */
id|hash_reg
op_assign
(paren
id|hash_value
op_rshift
l_int|5
)paren
op_amp
l_int|0x7F
suffix:semicolon
id|hash_bit
op_assign
id|hash_value
op_amp
l_int|0x1F
suffix:semicolon
id|mta_reg
op_assign
id|IXGB_READ_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|hash_reg
)paren
suffix:semicolon
id|mta_reg
op_or_assign
(paren
l_int|1
op_lshift
id|hash_bit
)paren
suffix:semicolon
id|IXGB_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|hash_reg
comma
id|mta_reg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Puts an ethernet address into a receive address register.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * addr - Address to put into receive address register&n; * index - Receive address register to write&n; *****************************************************************************/
r_void
DECL|function|ixgb_rar_set
id|ixgb_rar_set
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
comma
r_uint8
op_star
id|addr
comma
r_uint32
id|index
)paren
(brace
r_uint32
id|rar_low
comma
id|rar_high
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;ixgb_rar_set&quot;
)paren
suffix:semicolon
multiline_comment|/* HW expects these in little endian so we reverse the byte order&n;&t; * from network order (big endian) to little endian&n;&t; */
id|rar_low
op_assign
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|0
)braket
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
)paren
suffix:semicolon
id|rar_high
op_assign
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|4
)braket
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_or
id|IXGB_RAH_AV
)paren
suffix:semicolon
id|IXGB_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
id|index
op_lshift
l_int|1
)paren
comma
id|rar_low
)paren
suffix:semicolon
id|IXGB_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
(paren
id|index
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
comma
id|rar_high
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Writes a value to the specified offset in the VLAN filter table.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * offset - Offset in VLAN filer table to write&n; * value - Value to write into VLAN filter table&n; *****************************************************************************/
r_void
DECL|function|ixgb_write_vfta
id|ixgb_write_vfta
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
comma
r_uint32
id|offset
comma
r_uint32
id|value
)paren
(brace
id|IXGB_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|VFTA
comma
id|offset
comma
id|value
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Clears the VLAN filer table&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|ixgb_clear_vfta
id|ixgb_clear_vfta
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_uint32
id|offset
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|IXGB_VLAN_FILTER_TBL_SIZE
suffix:semicolon
id|offset
op_increment
)paren
(brace
id|IXGB_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|VFTA
comma
id|offset
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Configures the flow control settings based on SW configuration.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
id|boolean_t
DECL|function|ixgb_setup_fc
id|ixgb_setup_fc
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl_reg
suffix:semicolon
r_uint32
id|pap_reg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* by default, assume no pause time */
id|boolean_t
id|status
op_assign
id|TRUE
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;ixgb_setup_fc&quot;
)paren
suffix:semicolon
multiline_comment|/* Get the current control reg 0 settings */
id|ctrl_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|CTRL0
)paren
suffix:semicolon
multiline_comment|/* Clear the Receive Pause Enable and Transmit Pause Enable bits */
id|ctrl_reg
op_and_assign
op_complement
(paren
id|IXGB_CTRL0_RPE
op_or
id|IXGB_CTRL0_TPE
)paren
suffix:semicolon
multiline_comment|/* The possible values of the &quot;flow_control&quot; parameter are:&n;&t; *      0:  Flow control is completely disabled&n;&t; *      1:  Rx flow control is enabled (we can receive pause frames&n;&t; *          but not send pause frames).&n;&t; *      2:  Tx flow control is enabled (we can send pause frames&n;&t; *          but we do not support receiving pause frames).&n;&t; *      3:  Both Rx and TX flow control (symmetric) are enabled.&n;&t; *  other:  Invalid.&n;&t; */
r_switch
c_cond
(paren
id|hw-&gt;fc.type
)paren
(brace
r_case
id|ixgb_fc_none
suffix:colon
multiline_comment|/* 0 */
multiline_comment|/* Set CMDC bit to disable Rx Flow control */
id|ctrl_reg
op_or_assign
(paren
id|IXGB_CTRL0_CMDC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ixgb_fc_rx_pause
suffix:colon
multiline_comment|/* 1 */
multiline_comment|/* RX Flow control is enabled, and TX Flow control is&n;&t;&t; * disabled.&n;&t;&t; */
id|ctrl_reg
op_or_assign
(paren
id|IXGB_CTRL0_RPE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ixgb_fc_tx_pause
suffix:colon
multiline_comment|/* 2 */
multiline_comment|/* TX Flow control is enabled, and RX Flow control is&n;&t;&t; * disabled, by a software over-ride.&n;&t;&t; */
id|ctrl_reg
op_or_assign
(paren
id|IXGB_CTRL0_TPE
)paren
suffix:semicolon
id|pap_reg
op_assign
id|hw-&gt;fc.pause_time
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ixgb_fc_full
suffix:colon
multiline_comment|/* 3 */
multiline_comment|/* Flow control (both RX and TX) is enabled by a software&n;&t;&t; * over-ride.&n;&t;&t; */
id|ctrl_reg
op_or_assign
(paren
id|IXGB_CTRL0_RPE
op_or
id|IXGB_CTRL0_TPE
)paren
suffix:semicolon
id|pap_reg
op_assign
id|hw-&gt;fc.pause_time
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* We should never get here.  The value should be 0-3. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow control param set incorrectly&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Write the new settings */
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL0
comma
id|ctrl_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pap_reg
op_ne
l_int|0
)paren
(brace
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|PAP
comma
id|pap_reg
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the flow control receive threshold registers.  Normally,&n;&t; * these registers will be set to a default threshold that may be&n;&t; * adjusted later by the driver&squot;s runtime code.  However, if the&n;&t; * ability to transmit pause frames in not enabled, then these&n;&t; * registers will be set to 0.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hw-&gt;fc.type
op_amp
id|ixgb_fc_tx_pause
)paren
)paren
(brace
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTL
comma
l_int|0
)paren
suffix:semicolon
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTH
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We need to set up the Receive Threshold high and low water&n;&t;    * marks as well as (optionally) enabling the transmission of XON&n;&t;    * frames. */
r_if
c_cond
(paren
id|hw-&gt;fc.send_xon
)paren
(brace
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTL
comma
(paren
id|hw-&gt;fc.low_water
op_or
id|IXGB_FCRTL_XONE
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTL
comma
id|hw-&gt;fc.low_water
)paren
suffix:semicolon
)brace
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTH
comma
id|hw-&gt;fc.high_water
)paren
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Reads a word from a device over the Management Data Interface (MDI) bus.&n; * This interface is used to manage Physical layer devices.&n; *&n; * hw          - Struct containing variables accessed by hw code&n; * reg_address - Offset of device register being read.&n; * phy_address - Address of device on MDI.&n; *&n; * Returns:  Data word (16 bits) from MDI device.&n; *&n; * The 82597EX has support for several MDI access methods.  This routine&n; * uses the new protocol MDI Single Command and Address Operation.&n; * This requires that first an address cycle command is sent, followed by a&n; * read command.&n; *****************************************************************************/
r_uint16
DECL|function|ixgb_read_phy_reg
id|ixgb_read_phy_reg
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
comma
r_uint32
id|reg_address
comma
r_uint32
id|phy_address
comma
r_uint32
id|device_type
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_uint32
id|data
suffix:semicolon
r_uint32
id|command
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|reg_address
op_le
id|IXGB_MAX_PHY_REG_ADDRESS
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|phy_address
op_le
id|IXGB_MAX_PHY_ADDRESS
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|device_type
op_le
id|IXGB_MAX_PHY_DEV_TYPE
)paren
suffix:semicolon
multiline_comment|/* Setup and write the address cycle command */
id|command
op_assign
(paren
(paren
id|reg_address
op_lshift
id|IXGB_MSCA_NP_ADDR_SHIFT
)paren
op_or
(paren
id|device_type
op_lshift
id|IXGB_MSCA_DEV_TYPE_SHIFT
)paren
op_or
(paren
id|phy_address
op_lshift
id|IXGB_MSCA_PHY_ADDR_SHIFT
)paren
op_or
(paren
id|IXGB_MSCA_ADDR_CYCLE
op_or
id|IXGB_MSCA_MDI_COMMAND
)paren
)paren
suffix:semicolon
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|MSCA
comma
id|command
)paren
suffix:semicolon
multiline_comment|/**************************************************************&n;    ** Check every 10 usec to see if the address cycle completed&n;    ** The COMMAND bit will clear when the operation is complete.&n;    ** This may take as long as 64 usecs (we&squot;ll wait 100 usecs max)&n;    ** from the CPU Write to the Ready bit assertion.&n;    **************************************************************/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|command
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|MSCA
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|command
op_amp
id|IXGB_MSCA_MDI_COMMAND
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
(paren
id|command
op_amp
id|IXGB_MSCA_MDI_COMMAND
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Address cycle complete, setup and write the read command */
id|command
op_assign
(paren
(paren
id|reg_address
op_lshift
id|IXGB_MSCA_NP_ADDR_SHIFT
)paren
op_or
(paren
id|device_type
op_lshift
id|IXGB_MSCA_DEV_TYPE_SHIFT
)paren
op_or
(paren
id|phy_address
op_lshift
id|IXGB_MSCA_PHY_ADDR_SHIFT
)paren
op_or
(paren
id|IXGB_MSCA_READ
op_or
id|IXGB_MSCA_MDI_COMMAND
)paren
)paren
suffix:semicolon
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|MSCA
comma
id|command
)paren
suffix:semicolon
multiline_comment|/**************************************************************&n;    ** Check every 10 usec to see if the read command completed&n;    ** The COMMAND bit will clear when the operation is complete.&n;    ** The read may take as long as 64 usecs (we&squot;ll wait 100 usecs max)&n;    ** from the CPU Write to the Ready bit assertion.&n;    **************************************************************/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|command
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|MSCA
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|command
op_amp
id|IXGB_MSCA_MDI_COMMAND
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
(paren
id|command
op_amp
id|IXGB_MSCA_MDI_COMMAND
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Operation is complete, get the data from the MDIO Read/Write Data&n;&t; * register and return.&n;&t; */
id|data
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|MSRWD
)paren
suffix:semicolon
id|data
op_rshift_assign
id|IXGB_MSRWD_READ_DATA_SHIFT
suffix:semicolon
r_return
(paren
r_uint16
)paren
id|data
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Writes a word to a device over the Management Data Interface (MDI) bus.&n; * This interface is used to manage Physical layer devices.&n; *&n; * hw          - Struct containing variables accessed by hw code&n; * reg_address - Offset of device register being read.&n; * phy_address - Address of device on MDI.&n; * device_type - Also known as the Device ID or DID.&n; * data        - 16-bit value to be written&n; *&n; * Returns:  void.&n; *&n; * The 82597EX has support for several MDI access methods.  This routine&n; * uses the new protocol MDI Single Command and Address Operation.&n; * This requires that first an address cycle command is sent, followed by a&n; * write command.&n; *****************************************************************************/
r_void
DECL|function|ixgb_write_phy_reg
id|ixgb_write_phy_reg
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
comma
r_uint32
id|reg_address
comma
r_uint32
id|phy_address
comma
r_uint32
id|device_type
comma
r_uint16
id|data
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_uint32
id|command
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|reg_address
op_le
id|IXGB_MAX_PHY_REG_ADDRESS
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|phy_address
op_le
id|IXGB_MAX_PHY_ADDRESS
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|device_type
op_le
id|IXGB_MAX_PHY_DEV_TYPE
)paren
suffix:semicolon
multiline_comment|/* Put the data in the MDIO Read/Write Data register */
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|MSRWD
comma
(paren
r_uint32
)paren
id|data
)paren
suffix:semicolon
multiline_comment|/* Setup and write the address cycle command */
id|command
op_assign
(paren
(paren
id|reg_address
op_lshift
id|IXGB_MSCA_NP_ADDR_SHIFT
)paren
op_or
(paren
id|device_type
op_lshift
id|IXGB_MSCA_DEV_TYPE_SHIFT
)paren
op_or
(paren
id|phy_address
op_lshift
id|IXGB_MSCA_PHY_ADDR_SHIFT
)paren
op_or
(paren
id|IXGB_MSCA_ADDR_CYCLE
op_or
id|IXGB_MSCA_MDI_COMMAND
)paren
)paren
suffix:semicolon
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|MSCA
comma
id|command
)paren
suffix:semicolon
multiline_comment|/**************************************************************&n;&t;** Check every 10 usec to see if the address cycle completed&n;&t;** The COMMAND bit will clear when the operation is complete.&n;&t;** This may take as long as 64 usecs (we&squot;ll wait 100 usecs max)&n;&t;** from the CPU Write to the Ready bit assertion.&n;&t;**************************************************************/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|command
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|MSCA
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|command
op_amp
id|IXGB_MSCA_MDI_COMMAND
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
(paren
id|command
op_amp
id|IXGB_MSCA_MDI_COMMAND
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Address cycle complete, setup and write the write command */
id|command
op_assign
(paren
(paren
id|reg_address
op_lshift
id|IXGB_MSCA_NP_ADDR_SHIFT
)paren
op_or
(paren
id|device_type
op_lshift
id|IXGB_MSCA_DEV_TYPE_SHIFT
)paren
op_or
(paren
id|phy_address
op_lshift
id|IXGB_MSCA_PHY_ADDR_SHIFT
)paren
op_or
(paren
id|IXGB_MSCA_WRITE
op_or
id|IXGB_MSCA_MDI_COMMAND
)paren
)paren
suffix:semicolon
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|MSCA
comma
id|command
)paren
suffix:semicolon
multiline_comment|/**************************************************************&n;&t;** Check every 10 usec to see if the read command completed&n;&t;** The COMMAND bit will clear when the operation is complete.&n;&t;** The write may take as long as 64 usecs (we&squot;ll wait 100 usecs max)&n;&t;** from the CPU Write to the Ready bit assertion.&n;&t;**************************************************************/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|command
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|MSCA
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|command
op_amp
id|IXGB_MSCA_MDI_COMMAND
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
(paren
id|command
op_amp
id|IXGB_MSCA_MDI_COMMAND
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Operation is complete, return. */
)brace
multiline_comment|/******************************************************************************&n; * Checks to see if the link status of the hardware has changed.&n; *&n; * hw - Struct containing variables accessed by hw code&n; *&n; * Called by any function that needs to check the link status of the adapter.&n; *****************************************************************************/
r_void
DECL|function|ixgb_check_for_link
id|ixgb_check_for_link
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_uint32
id|status_reg
suffix:semicolon
r_uint32
id|xpcss_reg
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;ixgb_check_for_link&quot;
)paren
suffix:semicolon
id|xpcss_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|XPCSS
)paren
suffix:semicolon
id|status_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xpcss_reg
op_amp
id|IXGB_XPCSS_ALIGN_STATUS
)paren
op_logical_and
(paren
id|status_reg
op_amp
id|IXGB_STATUS_LU
)paren
)paren
(brace
id|hw-&gt;link_up
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|xpcss_reg
op_amp
id|IXGB_XPCSS_ALIGN_STATUS
)paren
op_logical_and
(paren
id|status_reg
op_amp
id|IXGB_STATUS_LU
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;XPCSS Not Aligned while Status:LU is set.&bslash;n&quot;
)paren
suffix:semicolon
id|hw-&gt;link_up
op_assign
id|ixgb_link_reset
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * 82597EX errata.  Since the lane deskew problem may prevent&n;&t;&t; * link, reset the link before reporting link down.&n;&t;&t; */
id|hw-&gt;link_up
op_assign
id|ixgb_link_reset
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
multiline_comment|/*  Anything else for 10 Gig?? */
)brace
multiline_comment|/******************************************************************************&n; * Check for a bad link condition that may have occured.&n; * The indication is that the RFC / LFC registers may be incrementing&n; * continually.  A full adapter reset is required to recover.&n; *&n; * hw - Struct containing variables accessed by hw code&n; *&n; * Called by any function that needs to check the link status of the adapter.&n; *****************************************************************************/
DECL|function|ixgb_check_for_bad_link
id|boolean_t
id|ixgb_check_for_bad_link
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_uint32
id|newLFC
comma
id|newRFC
suffix:semicolon
id|boolean_t
id|bad_link_returncode
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|ixgb_phy_type_txn17401
)paren
(brace
id|newLFC
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|LFC
)paren
suffix:semicolon
id|newRFC
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|RFC
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hw-&gt;lastLFC
op_plus
l_int|250
OL
id|newLFC
)paren
op_logical_or
(paren
id|hw-&gt;lastRFC
op_plus
l_int|250
OL
id|newRFC
)paren
)paren
(brace
id|DEBUGOUT
(paren
l_string|&quot;BAD LINK! too many LFC/RFC since last check&bslash;n&quot;
)paren
suffix:semicolon
id|bad_link_returncode
op_assign
id|TRUE
suffix:semicolon
)brace
id|hw-&gt;lastLFC
op_assign
id|newLFC
suffix:semicolon
id|hw-&gt;lastRFC
op_assign
id|newRFC
suffix:semicolon
)brace
r_return
id|bad_link_returncode
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Clears all hardware statistics counters.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|ixgb_clear_hw_cntrs
id|ixgb_clear_hw_cntrs
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_volatile
r_uint32
id|temp_reg
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;ixgb_clear_hw_cntrs&quot;
)paren
suffix:semicolon
multiline_comment|/* if we are stopped or resetting exit gracefully */
r_if
c_cond
(paren
id|hw-&gt;adapter_stopped
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Exiting because the adapter is stopped!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|TPRL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|TPRH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|GPRCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|GPRCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|BPRCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|BPRCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|MPRCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|MPRCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|UPRCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|UPRCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|VPRCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|VPRCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|JPRCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|JPRCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|GORCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|GORCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|TORL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|TORH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|RNBC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|RUC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|ROC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|RLEC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|CRCERRS
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|ICBC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|ECBC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|MPC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|TPTL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|TPTH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|GPTCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|GPTCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|BPTCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|BPTCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|MPTCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|MPTCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|UPTCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|UPTCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|VPTCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|VPTCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|JPTCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|JPTCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|GOTCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|GOTCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|TOTL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|TOTH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|DC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|PLT64C
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|TSCTC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|TSCTFC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|IBIC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|RFC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|LFC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|PFRC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|PFTC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|MCFRC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|MCFTC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|XONRXC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|XONTXC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|XOFFRXC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|XOFFTXC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|RJC
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Turns on the software controllable LED&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|ixgb_led_on
id|ixgb_led_on
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl0_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|CTRL0
)paren
suffix:semicolon
multiline_comment|/* To turn on the LED, clear software-definable pin 0 (SDP0). */
id|ctrl0_reg
op_and_assign
op_complement
id|IXGB_CTRL0_SDP0
suffix:semicolon
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL0
comma
id|ctrl0_reg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Turns off the software controllable LED&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|ixgb_led_off
id|ixgb_led_off
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl0_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|CTRL0
)paren
suffix:semicolon
multiline_comment|/* To turn off the LED, set software-definable pin 0 (SDP0). */
id|ctrl0_reg
op_or_assign
id|IXGB_CTRL0_SDP0
suffix:semicolon
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL0
comma
id|ctrl0_reg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Gets the current PCI bus type, speed, and width of the hardware&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_static
r_void
DECL|function|ixgb_get_bus_info
id|ixgb_get_bus_info
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_uint32
id|status_reg
suffix:semicolon
id|status_reg
op_assign
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
suffix:semicolon
id|hw-&gt;bus.type
op_assign
(paren
id|status_reg
op_amp
id|IXGB_STATUS_PCIX_MODE
)paren
ques
c_cond
id|ixgb_bus_type_pcix
suffix:colon
id|ixgb_bus_type_pci
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;bus.type
op_eq
id|ixgb_bus_type_pci
)paren
(brace
id|hw-&gt;bus.speed
op_assign
(paren
id|status_reg
op_amp
id|IXGB_STATUS_PCI_SPD
)paren
ques
c_cond
id|ixgb_bus_speed_66
suffix:colon
id|ixgb_bus_speed_33
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|status_reg
op_amp
id|IXGB_STATUS_PCIX_SPD_MASK
)paren
(brace
r_case
id|IXGB_STATUS_PCIX_SPD_66
suffix:colon
id|hw-&gt;bus.speed
op_assign
id|ixgb_bus_speed_66
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IXGB_STATUS_PCIX_SPD_100
suffix:colon
id|hw-&gt;bus.speed
op_assign
id|ixgb_bus_speed_100
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IXGB_STATUS_PCIX_SPD_133
suffix:colon
id|hw-&gt;bus.speed
op_assign
id|ixgb_bus_speed_133
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|hw-&gt;bus.speed
op_assign
id|ixgb_bus_speed_reserved
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|hw-&gt;bus.width
op_assign
(paren
id|status_reg
op_amp
id|IXGB_STATUS_BUS64
)paren
ques
c_cond
id|ixgb_bus_width_64
suffix:colon
id|ixgb_bus_width_32
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Tests a MAC address to ensure it is a valid Individual Address&n; *&n; * mac_addr - pointer to MAC address.&n; *&n; *****************************************************************************/
id|boolean_t
DECL|function|mac_addr_valid
id|mac_addr_valid
c_func
(paren
r_uint8
op_star
id|mac_addr
)paren
(brace
id|boolean_t
id|is_valid
op_assign
id|TRUE
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;mac_addr_valid&quot;
)paren
suffix:semicolon
multiline_comment|/* Make sure it is not a multicast address */
r_if
c_cond
(paren
id|IS_MULTICAST
c_func
(paren
id|mac_addr
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MAC address is multicast&bslash;n&quot;
)paren
suffix:semicolon
id|is_valid
op_assign
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Not a broadcast address */
r_else
r_if
c_cond
(paren
id|IS_BROADCAST
c_func
(paren
id|mac_addr
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MAC address is broadcast&bslash;n&quot;
)paren
suffix:semicolon
id|is_valid
op_assign
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Reject the zero address */
r_else
r_if
c_cond
(paren
id|mac_addr
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
id|mac_addr
(braket
l_int|1
)braket
op_eq
l_int|0
op_logical_and
id|mac_addr
(braket
l_int|2
)braket
op_eq
l_int|0
op_logical_and
id|mac_addr
(braket
l_int|3
)braket
op_eq
l_int|0
op_logical_and
id|mac_addr
(braket
l_int|4
)braket
op_eq
l_int|0
op_logical_and
id|mac_addr
(braket
l_int|5
)braket
op_eq
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MAC address is all zeros&bslash;n&quot;
)paren
suffix:semicolon
id|is_valid
op_assign
id|FALSE
suffix:semicolon
)brace
r_return
(paren
id|is_valid
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Resets the 10GbE link.  Waits the settle time and returns the state of&n; * the link.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
id|boolean_t
DECL|function|ixgb_link_reset
id|ixgb_link_reset
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
id|boolean_t
id|link_status
op_assign
id|FALSE
suffix:semicolon
r_uint8
id|wait_retries
op_assign
id|MAX_RESET_ITERATIONS
suffix:semicolon
r_uint8
id|lrst_retries
op_assign
id|MAX_RESET_ITERATIONS
suffix:semicolon
r_do
(brace
multiline_comment|/* Reset the link */
id|IXGB_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL0
comma
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|CTRL0
)paren
op_or
id|IXGB_CTRL0_LRST
)paren
suffix:semicolon
multiline_comment|/* Wait for link-up and lane re-alignment */
r_do
(brace
id|udelay
c_func
(paren
id|IXGB_DELAY_USECS_AFTER_LINK_RESET
)paren
suffix:semicolon
id|link_status
op_assign
(paren
(paren
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
op_amp
id|IXGB_STATUS_LU
)paren
op_logical_and
(paren
id|IXGB_READ_REG
c_func
(paren
id|hw
comma
id|XPCSS
)paren
op_amp
id|IXGB_XPCSS_ALIGN_STATUS
)paren
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|link_status
op_logical_and
op_decrement
id|wait_retries
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|link_status
op_logical_and
op_decrement
id|lrst_retries
)paren
suffix:semicolon
r_return
id|link_status
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Resets the 10GbE optics module.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|ixgb_optics_reset
id|ixgb_optics_reset
c_func
(paren
r_struct
id|ixgb_hw
op_star
id|hw
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|ixgb_phy_type_txn17401
)paren
(brace
r_uint16
id|mdio_reg
suffix:semicolon
id|ixgb_write_phy_reg
c_func
(paren
id|hw
comma
id|MDIO_PMA_PMD_CR1
comma
id|IXGB_PHY_ADDRESS
comma
id|MDIO_PMA_PMD_DID
comma
id|MDIO_PMA_PMD_CR1_RESET
)paren
suffix:semicolon
id|mdio_reg
op_assign
id|ixgb_read_phy_reg
c_func
(paren
id|hw
comma
id|MDIO_PMA_PMD_CR1
comma
id|IXGB_PHY_ADDRESS
comma
id|MDIO_PMA_PMD_DID
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
eof
