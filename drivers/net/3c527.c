multiline_comment|/* 3c527.c: 3Com Etherlink/MC32 driver for Linux 2.4&n; *&n; *&t;(c) Copyright 1998 Red Hat Software Inc&n; *&t;Written by Alan Cox. &n; *&t;Further debugging by Carl Drougge.&n; *      Modified by Richard Procter (rnp@netlink.co.nz)&n; *&n; *&t;Based on skeleton.c written 1993-94 by Donald Becker and ne2.c&n; *&t;(for the MCA stuff) written by Wim Dumon.&n; *&n; *&t;Thanks to 3Com for making this possible by providing me with the&n; *&t;documentation.&n; *&n; *&t;This software may be used and distributed according to the terms&n; *&t;of the GNU General Public License, incorporated herein by reference.&n; *&n; */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;3c527.c:v0.6 2001/03/03 Richard Proctor (rnp@netlink.co.nz)&bslash;n&quot;
suffix:semicolon
multiline_comment|/**&n; * DOC: Traps for the unwary&n; *&n; *&t;The diagram (Figure 1-1) and the POS summary disagree with the&n; *&t;&quot;Interrupt Level&quot; section in the manual.&n; *&n; *&t;The manual contradicts itself when describing the minimum number &n; *&t;buffers in the &squot;configure lists&squot; command. &n; *&t;My card accepts a buffer config of 4/4. &n; *&n; *&t;Setting the SAV BP bit does not save bad packets, but&n; *&t;only enables RX on-card stats collection. &n; *&n; *&t;The documentation in places seems to miss things. In actual fact&n; *&t;I&squot;ve always eventually found everything is documented, it just&n; *&t;requires careful study.&n; *&n; * DOC: Theory Of Operation&n; *&n; *&t;The 3com 3c527 is a 32bit MCA bus mastering adapter with a large&n; *&t;amount of on board intelligence that housekeeps a somewhat dumber&n; *&t;Intel NIC. For performance we want to keep the transmit queue deep&n; *&t;as the card can transmit packets while fetching others from main&n; *&t;memory by bus master DMA. Transmission and reception are driven by&n; *&t;circular buffer queues.&n; *&n; *&t;The mailboxes can be used for controlling how the card traverses&n; *&t;its buffer rings, but are used only for inital setup in this&n; *&t;implementation.  The exec mailbox allows a variety of commands to&n; *&t;be executed. Each command must complete before the next is&n; *&t;executed. Primarily we use the exec mailbox for controlling the&n; *&t;multicast lists.  We have to do a certain amount of interesting&n; *&t;hoop jumping as the multicast list changes can occur in interrupt&n; *&t;state when the card has an exec command pending. We defer such&n; *&t;events until the command completion interrupt.&n; *&n; *&t;A copy break scheme (taken from 3c59x.c) is employed whereby&n; *&t;received frames exceeding a configurable length are passed&n; *&t;directly to the higher networking layers without incuring a copy,&n; *&t;in what amounts to a time/space trade-off.&n; *&t; &n; *&t;The card also keeps a large amount of statistical information&n; *&t;on-board. In a perfect world, these could be used safely at no&n; *&t;cost. However, lacking information to the contrary, processing&n; *&t;them without races would involve so much extra complexity as to&n; *&t;make it unworthwhile to do so. In the end, a hybrid SW/HW&n; *&t;implementation was made necessary --- see mc32_update_stats().  &n; *&n; * DOC: Notes&n; *&t;&n; *&t;It should be possible to use two or more cards, but at this stage&n; *&t;only by loading two copies of the same module.&n; *&n; *&t;The on-board 82586 NIC has trouble receiving multiple&n; *&t;back-to-back frames and so is likely to drop packets from fast&n; *&t;senders.&n;**/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mca.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &quot;3c527.h&quot;
multiline_comment|/*&n; * The name of the card. Is used for messages and in the requests for&n; * io regions, irqs and dma channels&n; */
DECL|variable|cardname
r_static
r_const
r_char
op_star
id|cardname
op_assign
l_string|&quot;3c527&quot;
suffix:semicolon
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 2
macro_line|#endif
DECL|macro|DEBUG_IRQ
macro_line|#undef DEBUG_IRQ
DECL|variable|mc32_debug
r_static
r_int
r_int
id|mc32_debug
op_assign
id|NET_DEBUG
suffix:semicolon
multiline_comment|/* The number of low I/O ports used by the ethercard. */
DECL|macro|MC32_IO_EXTENT
mdefine_line|#define MC32_IO_EXTENT&t;8
multiline_comment|/* As implemented, values must be a power-of-2 -- 4/8/16/32 */
DECL|macro|TX_RING_LEN
mdefine_line|#define TX_RING_LEN     32       /* Typically the card supports 37  */
DECL|macro|RX_RING_LEN
mdefine_line|#define RX_RING_LEN     8        /*     &quot;       &quot;        &quot;          */
multiline_comment|/* Copy break point, see above for details. &n; * Setting to &gt; 1512 effectively disables this feature.&t;*/
DECL|macro|RX_COPYBREAK
mdefine_line|#define RX_COPYBREAK    200      /* Value from 3c59x.c */
multiline_comment|/* Issue the 82586 workaround command - this is for &quot;busy lans&quot;, but&n; * basically means for all lans now days - has a performance (latency) &n; * cost, but best set. */
DECL|variable|WORKAROUND_82586
r_static
r_const
r_int
id|WORKAROUND_82586
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Pointers to buffers and their on-card records */
DECL|struct|mc32_ring_desc
r_struct
id|mc32_ring_desc
(brace
DECL|member|p
r_volatile
r_struct
id|skb_header
op_star
id|p
suffix:semicolon
DECL|member|skb
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Information that needs to be kept for each board. */
DECL|struct|mc32_local
r_struct
id|mc32_local
(brace
DECL|member|net_stats
r_struct
id|net_device_stats
id|net_stats
suffix:semicolon
DECL|member|slot
r_int
id|slot
suffix:semicolon
DECL|member|rx_box
r_volatile
r_struct
id|mc32_mailbox
op_star
id|rx_box
suffix:semicolon
DECL|member|tx_box
r_volatile
r_struct
id|mc32_mailbox
op_star
id|tx_box
suffix:semicolon
DECL|member|exec_box
r_volatile
r_struct
id|mc32_mailbox
op_star
id|exec_box
suffix:semicolon
DECL|member|stats
r_volatile
r_struct
id|mc32_stats
op_star
id|stats
suffix:semicolon
multiline_comment|/* Start of on-card statistics */
DECL|member|tx_chain
id|u16
id|tx_chain
suffix:semicolon
multiline_comment|/* Transmit list start offset */
DECL|member|rx_chain
id|u16
id|rx_chain
suffix:semicolon
multiline_comment|/* Receive list start offset */
DECL|member|tx_len
id|u16
id|tx_len
suffix:semicolon
multiline_comment|/* Transmit list count */
DECL|member|rx_len
id|u16
id|rx_len
suffix:semicolon
multiline_comment|/* Receive list count */
DECL|member|base
id|u32
id|base
suffix:semicolon
DECL|member|exec_pending
id|u16
id|exec_pending
suffix:semicolon
DECL|member|mc_reload_wait
id|u16
id|mc_reload_wait
suffix:semicolon
multiline_comment|/* a multicast load request is pending */
DECL|member|mc_list_valid
id|u32
id|mc_list_valid
suffix:semicolon
multiline_comment|/* True when the mclist is set */
DECL|member|xceiver_state
id|u16
id|xceiver_state
suffix:semicolon
multiline_comment|/* Current transceiver state. bitmapped */
DECL|member|desired_state
id|u16
id|desired_state
suffix:semicolon
multiline_comment|/* The state we want the transceiver to be in */
DECL|member|tx_count
id|atomic_t
id|tx_count
suffix:semicolon
multiline_comment|/* buffers left */
DECL|member|event
id|wait_queue_head_t
id|event
suffix:semicolon
DECL|member|tx_ring
r_struct
id|mc32_ring_desc
id|tx_ring
(braket
id|TX_RING_LEN
)braket
suffix:semicolon
multiline_comment|/* Host Transmit ring */
DECL|member|rx_ring
r_struct
id|mc32_ring_desc
id|rx_ring
(braket
id|RX_RING_LEN
)braket
suffix:semicolon
multiline_comment|/* Host Receive ring */
DECL|member|tx_ring_tail
id|u16
id|tx_ring_tail
suffix:semicolon
multiline_comment|/* index to tx de-queue end */
DECL|member|tx_ring_head
id|u16
id|tx_ring_head
suffix:semicolon
multiline_comment|/* index to tx en-queue end */
DECL|member|rx_ring_tail
id|u16
id|rx_ring_tail
suffix:semicolon
multiline_comment|/* index to rx de-queue end */
)brace
suffix:semicolon
multiline_comment|/* The station (ethernet) address prefix, used for a sanity check. */
DECL|macro|SA_ADDR0
mdefine_line|#define SA_ADDR0 0x02
DECL|macro|SA_ADDR1
mdefine_line|#define SA_ADDR1 0x60
DECL|macro|SA_ADDR2
mdefine_line|#define SA_ADDR2 0xAC
DECL|struct|mca_adapters_t
r_struct
id|mca_adapters_t
(brace
DECL|member|id
r_int
r_int
id|id
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|mc32_adapters
r_const
r_struct
id|mca_adapters_t
id|mc32_adapters
(braket
)braket
op_assign
(brace
(brace
l_int|0x0041
comma
l_string|&quot;3COM EtherLink MC/32&quot;
)brace
comma
(brace
l_int|0x8EF5
comma
l_string|&quot;IBM High Performance Lan Adapter&quot;
)brace
comma
(brace
l_int|0x0000
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/* Macros for ring index manipulations */
DECL|function|next_rx
r_static
r_inline
id|u16
id|next_rx
c_func
(paren
id|u16
id|rx
)paren
(brace
r_return
(paren
id|rx
op_plus
l_int|1
)paren
op_amp
(paren
id|RX_RING_LEN
op_minus
l_int|1
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|function|prev_rx
r_static
r_inline
id|u16
id|prev_rx
c_func
(paren
id|u16
id|rx
)paren
(brace
r_return
(paren
id|rx
op_minus
l_int|1
)paren
op_amp
(paren
id|RX_RING_LEN
op_minus
l_int|1
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|function|next_tx
r_static
r_inline
id|u16
id|next_tx
c_func
(paren
id|u16
id|tx
)paren
(brace
r_return
(paren
id|tx
op_plus
l_int|1
)paren
op_amp
(paren
id|TX_RING_LEN
op_minus
l_int|1
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|mc32_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|mc32_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|mc32_command
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u16
id|cmd
comma
r_void
op_star
id|data
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|mc32_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|mc32_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|mc32_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|mc32_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|mc32_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|mc32_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|mc32_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|mc32_reset_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/**&n; * mc32_probe &t;-&t;Search for supported boards&n; * @dev: device to probe&n; *&n; * Because MCA bus is a real bus and we can scan for cards we could do a&n; * single scan for all boards here. Right now we use the passed in device&n; * structure and scan for only one board. This needs fixing for modules&n; * in paticular.&n; */
DECL|function|mc32_probe
r_int
id|__init
id|mc32_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_static
r_int
id|current_mca_slot
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|adapter_found
op_assign
l_int|0
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Do not check any supplied i/o locations. &n;&t;   POS registers usually don&squot;t fail :) */
multiline_comment|/* MCA cards have POS registers.  &n;&t;   Autodetecting MCA cards is extremely simple. &n;&t;   Just search for the card. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|mc32_adapters
(braket
id|i
)braket
dot
id|name
op_ne
l_int|NULL
)paren
op_logical_and
op_logical_neg
id|adapter_found
suffix:semicolon
id|i
op_increment
)paren
(brace
id|current_mca_slot
op_assign
id|mca_find_unused_adapter
c_func
(paren
id|mc32_adapters
(braket
id|i
)braket
dot
id|id
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current_mca_slot
op_ne
id|MCA_NOTFOUND
)paren
op_logical_and
op_logical_neg
id|adapter_found
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mc32_probe1
c_func
(paren
id|dev
comma
id|current_mca_slot
)paren
)paren
(brace
id|mca_set_adapter_name
c_func
(paren
id|current_mca_slot
comma
id|mc32_adapters
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|mca_mark_as_used
c_func
(paren
id|current_mca_slot
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/**&n; * mc32_probe1&t;-&t;Check a given slot for a board and test the card&n; * @dev:  Device structure to fill in&n; * @slot: The MCA bus slot being used by this card&n; *&n; * Decode the slot data and configure the card structures. Having done this we&n; * can reset the card and configure it. The card does a full self test cycle&n; * in firmware so we have to wait for it to return and post us either a &n; * failure case or some addresses we use to find the board internals.&n; */
DECL|function|mc32_probe1
r_static
r_int
id|__init
id|mc32_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|slot
)paren
(brace
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|err
suffix:semicolon
id|u8
id|POS
suffix:semicolon
id|u32
id|base
suffix:semicolon
r_struct
id|mc32_local
op_star
id|lp
suffix:semicolon
r_static
id|u16
id|mca_io_bases
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_static
id|u32
id|mca_mem_bases
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_static
r_char
op_star
id|failures
(braket
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Time to play MCA games */
r_if
c_cond
(paren
id|mc32_debug
op_logical_and
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s found in slot %d:&quot;
comma
id|dev-&gt;name
comma
id|cardname
comma
id|slot
)paren
suffix:semicolon
id|POS
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|POS
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; disabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Fill in the &squot;dev&squot; fields. */
id|dev-&gt;base_addr
op_assign
id|mca_io_bases
(braket
(paren
id|POS
op_rshift
l_int|1
)paren
op_amp
l_int|7
)braket
suffix:semicolon
id|dev-&gt;mem_start
op_assign
id|mca_mem_bases
(braket
(paren
id|POS
op_rshift
l_int|4
)paren
op_amp
l_int|7
)braket
suffix:semicolon
id|POS
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|POS
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;memory window disabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|POS
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|5
)paren
suffix:semicolon
id|i
op_assign
(paren
id|POS
op_rshift
l_int|4
)paren
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;invalid memory window.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|i
op_mul_assign
l_int|16384
suffix:semicolon
id|i
op_add_assign
l_int|16384
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
id|i
suffix:semicolon
id|dev-&gt;irq
op_assign
(paren
(paren
id|POS
op_rshift
l_int|2
)paren
op_amp
l_int|3
)paren
op_plus
l_int|9
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|MC32_IO_EXTENT
comma
id|cardname
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;io 0x%3lX, which is busy.&bslash;n&quot;
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;io 0x%3lX irq %d mem 0x%lX (%dK)&bslash;n&quot;
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
comma
id|dev-&gt;mem_start
comma
id|i
op_div
l_int|1024
)paren
suffix:semicolon
multiline_comment|/* We ought to set the cache line size here.. */
multiline_comment|/*&n;&t; *&t;Go PROM browsing&n;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: Address &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Retrieve and print the ethernet address. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|6
comma
id|i
op_plus
l_int|12
)paren
suffix:semicolon
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|7
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|mca_read_pos
c_func
(paren
id|slot
comma
l_int|3
)paren
)paren
suffix:semicolon
)brace
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|6
comma
l_int|0
)paren
suffix:semicolon
id|mca_write_pos
c_func
(paren
id|slot
comma
l_int|7
comma
l_int|0
)paren
suffix:semicolon
id|POS
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|POS
op_amp
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; : BNC port selected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; : AUI port selected.&bslash;n&quot;
)paren
suffix:semicolon
id|POS
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|POS
op_or_assign
id|HOST_CTRL_ATTN
op_or
id|HOST_CTRL_RESET
suffix:semicolon
id|POS
op_and_assign
op_complement
id|HOST_CTRL_INTE
suffix:semicolon
id|outb
c_func
(paren
id|POS
comma
id|dev-&gt;base_addr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
multiline_comment|/* Reset adapter */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Reset off */
id|POS
op_and_assign
op_complement
(paren
id|HOST_CTRL_ATTN
op_or
id|HOST_CTRL_RESET
)paren
suffix:semicolon
id|outb
c_func
(paren
id|POS
comma
id|dev-&gt;base_addr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|300
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Grab the IRQ&n;&t; */
id|i
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|mc32_interrupt
comma
id|SA_SHIRQ
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|MC32_IO_EXTENT
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unable to get IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* Initialize the device structure. */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|mc32_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_exit_irq
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mc32_local
)paren
)paren
suffix:semicolon
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|lp-&gt;slot
op_assign
id|slot
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|base
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|base
op_eq
l_int|0xFF
)paren
(brace
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1000
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: failed to boot adapter.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_exit_free
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
l_int|2
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
(brace
id|base
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|base
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|base
OL
l_int|0x0C
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: %s%s.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|failures
(braket
id|base
op_minus
l_int|1
)braket
comma
id|base
OL
l_int|0x0A
ques
c_cond
l_string|&quot; test failure&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unknown failure %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|base
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_exit_free
suffix:semicolon
)brace
id|base
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
l_int|2
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
)paren
(brace
id|n
op_increment
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|100
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: mailbox read fail (%d).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|i
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_exit_free
suffix:semicolon
)brace
)brace
id|base
op_or_assign
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
)paren
op_lshift
(paren
l_int|8
op_star
id|i
)paren
)paren
suffix:semicolon
)brace
id|lp-&gt;exec_box
op_assign
id|bus_to_virt
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|base
)paren
suffix:semicolon
id|base
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|1
)braket
op_lshift
l_int|16
op_or
id|lp-&gt;exec_box-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|lp-&gt;base
op_assign
id|dev-&gt;mem_start
op_plus
id|base
suffix:semicolon
id|lp-&gt;rx_box
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|lp-&gt;exec_box-&gt;data
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|lp-&gt;tx_box
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|lp-&gt;exec_box-&gt;data
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|lp-&gt;stats
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|lp-&gt;exec_box-&gt;data
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Descriptor chains (card relative)&n;&t; */
id|lp-&gt;tx_chain
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Transmit list start offset */
id|lp-&gt;rx_chain
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* Receive list start offset */
id|lp-&gt;tx_len
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|9
)braket
suffix:semicolon
multiline_comment|/* Transmit list count */
id|lp-&gt;rx_len
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|11
)braket
suffix:semicolon
multiline_comment|/* Receive list count */
id|init_waitqueue_head
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Firmware Rev %d. %d RX buffers, %d TX buffers. Base of 0x%08X.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;exec_box-&gt;data
(braket
l_int|12
)braket
comma
id|lp-&gt;rx_len
comma
id|lp-&gt;tx_len
comma
id|lp-&gt;base
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|mc32_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|mc32_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|mc32_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|mc32_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|mc32_set_multicast_list
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|mc32_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|HZ
op_star
l_int|5
suffix:semicolon
multiline_comment|/* Board does all the work */
id|lp-&gt;xceiver_state
op_assign
id|HALTED
suffix:semicolon
id|lp-&gt;tx_ring_tail
op_assign
id|lp-&gt;tx_ring_head
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_exit_free
suffix:colon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|err_exit_irq
suffix:colon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|MC32_IO_EXTENT
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_ready_poll&t;&t;-&t;wait until we can feed it a command&n; *&t;@dev:&t;The device to wait for&n; *&t;&n; *&t;Wait until the card becomes ready to accept a command via the&n; *&t;command register. This tells us nothing about the completion&n; *&t;status of any pending commands and takes very little time at all.&n; */
DECL|function|mc32_ready_poll
r_static
r_void
id|mc32_ready_poll
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;mc32_command_nowait&t;-&t;send a command non blocking&n; *&t;@dev: The 3c527 to issue the command to&n; *&t;@cmd: The command word to write to the mailbox&n; *&t;@data: A data block if the command expects one&n; *&t;@len: Length of the data block&n; *&n; *&t;Send a command from interrupt state. If there is a command&n; *&t;currently being executed then we return an error of -1. It simply&n; *&t;isn&squot;t viable to wait around as commands may be slow. Providing we&n; *&t;get in, we busy wait for the board to become ready to accept the&n; *&t;command and issue it. We do not wait for the command to complete&n; *&t;--- the card will interrupt us when it&squot;s done.&n; */
DECL|function|mc32_command_nowait
r_static
r_int
id|mc32_command_nowait
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u16
id|cmd
comma
r_void
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;exec_pending
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|lp-&gt;exec_pending
op_assign
l_int|3
suffix:semicolon
id|lp-&gt;exec_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;exec_box-&gt;mbox
op_assign
id|cmd
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|lp-&gt;exec_box-&gt;data
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* the memcpy forgot the volatile so be sure */
multiline_comment|/* Send the command */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|1
op_lshift
l_int|6
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_command&t;-&t;send a command and sleep until completion&n; *&t;@dev: The 3c527 card to issue the command to&n; *&t;@cmd: The command word to write to the mailbox&n; *&t;@data: A data block if the command expects one&n; *&t;@len: Length of the data block&n; *&n; *&t;Sends exec commands in a user context. This permits us to wait around&n; *&t;for the replies and also to wait for the command buffer to complete&n; *&t;from a previous command before we execute our command. After our &n; *&t;command completes we will complete any pending multicast reload&n; *&t;we blocked off by hogging the exec buffer.&n; *&n; *&t;You feed the card a command, you wait, it interrupts you get a &n; *&t;reply. All well and good. The complication arises because you use&n; *&t;commands for filter list changes which come in at bh level from things&n; *&t;like IPV6 group stuff.&n; *&n; *&t;We have a simple state machine&n; *&n; *&t;0&t;- nothing issued&n; *&n; *&t;1&t;- command issued, wait reply&n; *&n; *&t;2&t;- reply waiting - reader then goes to state 0&n; *&n; *&t;3&t;- command issued, trash reply. In which case the irq&n; *&t;&t;  takes it back to state 0&n; *&n; */
DECL|function|mc32_command
r_static
r_int
id|mc32_command
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u16
id|cmd
comma
r_void
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Wait for a command&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lp-&gt;exec_pending
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Issue mine&n;&t; */
id|lp-&gt;exec_pending
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|lp-&gt;exec_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;exec_box-&gt;mbox
op_assign
id|cmd
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|lp-&gt;exec_box-&gt;data
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* the memcpy forgot the volatile so be sure */
multiline_comment|/* Send the command */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CRR
)paren
)paren
(brace
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|1
op_lshift
l_int|6
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lp-&gt;exec_pending
op_ne
l_int|2
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
id|lp-&gt;exec_pending
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;exec_box-&gt;mbox
op_amp
(paren
l_int|1
op_lshift
l_int|13
)paren
)paren
(brace
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;A multicast set got blocked - do it now&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;mc_reload_wait
)paren
(brace
id|mc32_reset_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_start_transceiver&t;-&t;tell board to restart tx/rx&n; *&t;@dev: The 3c527 card to issue the command to&n; *&n; *&t;This may be called from the interrupt state, where it is used&n; *&t;to restart the rx ring if the card runs out of rx buffers. &n; *&t;&n; * &t;First, we check if it&squot;s ok to start the transceiver. We then show&n; * &t;the card where to start in the rx ring and issue the&n; * &t;commands to start reception and transmission. We don&squot;t wait&n; * &t;around for these to complete.&n; */
DECL|function|mc32_start_transceiver
r_static
r_void
id|mc32_start_transceiver
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* Ignore RX overflow on device closure */
r_if
c_cond
(paren
id|lp-&gt;desired_state
op_eq
id|HALTED
)paren
r_return
suffix:semicolon
id|mc32_ready_poll
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;tx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Give the card the offset to the post-EOL-bit RX descriptor */
id|lp-&gt;rx_box-&gt;data
(braket
l_int|0
)braket
op_assign
id|lp-&gt;rx_ring
(braket
id|prev_rx
c_func
(paren
id|lp-&gt;rx_ring_tail
)paren
)braket
dot
id|p-&gt;next
suffix:semicolon
id|outb
c_func
(paren
id|HOST_CMD_START_RX
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
id|mc32_ready_poll
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
id|HOST_CMD_RESTRT_TX
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
multiline_comment|/* card ignores this on RX restart */
multiline_comment|/* We are not interrupted on start completion */
id|lp-&gt;xceiver_state
op_assign
id|RUNNING
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_halt_transceiver&t;-&t;tell board to stop tx/rx&n; *&t;@dev: The 3c527 card to issue the command to&n; *&n; *&t;We issue the commands to halt the card&squot;s transceiver. In fact,&n; *&t;after some experimenting we now simply tell the card to&n; *&t;suspend. When issuing aborts occasionally odd things happened.&n; *&n; *&t;We then sleep until the card has notified us that both rx and&n; *&t;tx have been suspended.&n; */
DECL|function|mc32_halt_transceiver
r_static
r_void
id|mc32_halt_transceiver
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|mc32_ready_poll
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;tx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_box-&gt;mbox
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|HOST_CMD_SUSPND_RX
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
id|mc32_ready_poll
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
id|HOST_CMD_SUSPND_TX
comma
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lp-&gt;xceiver_state
op_ne
id|HALTED
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_load_rx_ring&t;-&t;load the ring of receive buffers&n; *&t;@dev: 3c527 to build the ring for&n; *&n; *&t;This initalises the on-card and driver datastructures to&n; *&t;the point where mc32_start_transceiver() can be called.&n; *&n; *&t;The card sets up the receive ring for us. We are required to use the&n; *&t;ring it provides although we can change the size of the ring.&n; *&n; * &t;We allocate an sk_buff for each ring entry in turn and&n; * &t;initalise its house-keeping info. At the same time, we read&n; * &t;each &squot;next&squot; pointer in our rx_ring array. This reduces slow&n; * &t;shared-memory reads and makes it easy to access predecessor&n; * &t;descriptors.&n; *&n; *&t;We then set the end-of-list bit for the last entry so that the&n; * &t;card will know when it has run out of buffers.&n; */
DECL|function|mc32_load_rx_ring
r_static
r_int
id|mc32_load_rx_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u16
id|rx_base
suffix:semicolon
r_volatile
r_struct
id|skb_header
op_star
id|p
suffix:semicolon
id|rx_base
op_assign
id|lp-&gt;rx_chain
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_LEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|skb
op_assign
id|alloc_skb
c_func
(paren
l_int|1532
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|skb_reserve
c_func
(paren
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|skb
comma
l_int|18
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|skb
op_eq
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|kfree_skb
c_func
(paren
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|skb
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|p
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|rx_base
)paren
suffix:semicolon
id|p-&gt;control
op_assign
l_int|0
suffix:semicolon
id|p-&gt;data
op_assign
id|virt_to_bus
c_func
(paren
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|skb-&gt;data
)paren
suffix:semicolon
id|p-&gt;status
op_assign
l_int|0
suffix:semicolon
id|p-&gt;length
op_assign
l_int|1532
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|p
op_assign
id|p
suffix:semicolon
id|rx_base
op_assign
id|p-&gt;next
suffix:semicolon
)brace
id|lp-&gt;rx_ring
(braket
id|i
op_minus
l_int|1
)braket
dot
id|p-&gt;control
op_or_assign
id|CONTROL_EOL
suffix:semicolon
id|lp-&gt;rx_ring_tail
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_flush_rx_ring&t;-&t;free the ring of receive buffers&n; *&t;@lp: Local data of 3c527 to flush the rx ring of&n; *&n; *&t;Free the buffer for each ring slot. This may be called &n; *      before mc32_load_rx_ring(), eg. on error in mc32_open().&n; */
DECL|function|mc32_flush_rx_ring
r_static
r_void
id|mc32_flush_rx_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_LEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb
op_assign
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|p
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;mc32_load_tx_ring&t;-&t;load transmit ring&n; *&t;@dev: The 3c527 card to issue the command to&n; *&n; *&t;This sets up the host transmit data-structures. &n; *&n; *&t;First, we obtain from the card it&squot;s current postion in the tx&n; *&t;ring, so that we will know where to begin transmitting&n; *&t;packets.&n; * &t;&n; * &t;Then, we read the &squot;next&squot; pointers from the on-card tx ring into&n; *  &t;our tx_ring array to reduce slow shared-mem reads. Finally, we&n; * &t;intitalise the tx house keeping variables.&n; * &n; */
DECL|function|mc32_load_tx_ring
r_static
r_void
id|mc32_load_tx_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_volatile
r_struct
id|skb_header
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u16
id|tx_base
suffix:semicolon
id|tx_base
op_assign
id|lp-&gt;tx_box-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;tx_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p
op_assign
id|bus_to_virt
c_func
(paren
id|lp-&gt;base
op_plus
id|tx_base
)paren
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|p
op_assign
id|p
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|tx_base
op_assign
id|p-&gt;next
suffix:semicolon
)brace
multiline_comment|/* -1 so that tx_ring_head cannot &quot;lap&quot; tx_ring_tail,           */
multiline_comment|/* which would be bad news for mc32_tx_ring as cur. implemented */
id|atomic_set
c_func
(paren
op_amp
id|lp-&gt;tx_count
comma
id|TX_RING_LEN
op_minus
l_int|1
)paren
suffix:semicolon
id|lp-&gt;tx_ring_head
op_assign
id|lp-&gt;tx_ring_tail
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_flush_tx_ring &t;-&t;free transmit ring&n; *&t;@lp: Local data of 3c527 to flush the tx ring of&n; *&n; *&t;We have to consider two cases here. We want to free the pending&n; *&t;buffers only. If the ring buffer head is past the start then the&n; *&t;ring segment we wish to free wraps through zero. The tx ring &n; *&t;house-keeping variables are then reset.&n; */
DECL|function|mc32_flush_tx_ring
r_static
r_void
id|mc32_flush_tx_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_ring_tail
op_ne
id|lp-&gt;tx_ring_head
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_ring_tail
OL
id|lp-&gt;tx_ring_head
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|lp-&gt;tx_ring_tail
suffix:semicolon
id|i
OL
id|lp-&gt;tx_ring_head
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|skb
)paren
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|p
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
id|lp-&gt;tx_ring_tail
suffix:semicolon
id|i
OL
id|TX_RING_LEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|skb
)paren
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|p
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;tx_ring_head
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|skb
)paren
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|p
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|atomic_set
c_func
(paren
op_amp
id|lp-&gt;tx_count
comma
l_int|0
)paren
suffix:semicolon
id|lp-&gt;tx_ring_tail
op_assign
id|lp-&gt;tx_ring_head
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_open&t;-&t;handle &squot;up&squot; of card&n; *&t;@dev: device to open&n; *&n; *&t;The user is trying to bring the card into ready state. This requires&n; *&t;a brief dialogue with the card. Firstly we enable interrupts and then&n; *&t;&squot;indications&squot;. Without these enabled the card doesn&squot;t bother telling&n; *&t;us what it has done. This had me puzzled for a week.&n; *&n; *&t;We configure the number of card descriptors, then load the network&n; *&t;address and multicast filters. Turn on the workaround mode. This&n; *&t;works around a bug in the 82586 - it asks the firmware to do&n; *&t;so. It has a performance (latency) hit but is needed on busy&n; *&t;[read most] lans. We load the ring with buffers then we kick it&n; *&t;all off.&n; */
DECL|function|mc32_open
r_static
r_int
id|mc32_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u8
id|one
op_assign
l_int|1
suffix:semicolon
id|u8
id|regs
suffix:semicolon
id|u16
id|descnumbuffs
(braket
l_int|2
)braket
op_assign
(brace
id|TX_RING_LEN
comma
id|RX_RING_LEN
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Interrupts enabled&n;&t; */
id|regs
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|regs
op_or_assign
id|HOST_CTRL_INTE
suffix:semicolon
id|outb
c_func
(paren
id|regs
comma
id|ioaddr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send the indications on command&n;&t; */
id|mc32_command
c_func
(paren
id|dev
comma
l_int|4
comma
op_amp
id|one
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Poke it to make sure it&squot;s really dead. &n;&t; */
id|mc32_halt_transceiver
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mc32_flush_tx_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Ask card to set up on-card descriptors to our spec &n;&t; */
r_if
c_cond
(paren
id|mc32_command
c_func
(paren
id|dev
comma
l_int|8
comma
id|descnumbuffs
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s rejected our buffer configuration!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|cardname
)paren
suffix:semicolon
id|mc32_close
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
multiline_comment|/* Report new configuration */
id|mc32_command
c_func
(paren
id|dev
comma
l_int|6
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|lp-&gt;tx_chain
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Transmit list start offset */
id|lp-&gt;rx_chain
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* Receive list start offset */
id|lp-&gt;tx_len
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|9
)braket
suffix:semicolon
multiline_comment|/* Transmit list count */
id|lp-&gt;rx_len
op_assign
id|lp-&gt;exec_box-&gt;data
(braket
l_int|11
)braket
suffix:semicolon
multiline_comment|/* Receive list count */
multiline_comment|/* Set Network Address */
id|mc32_command
c_func
(paren
id|dev
comma
l_int|1
comma
id|dev-&gt;dev_addr
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Set the filters */
id|mc32_set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|WORKAROUND_82586
)paren
(brace
id|u16
id|zero_word
op_assign
l_int|0
suffix:semicolon
id|mc32_command
c_func
(paren
id|dev
comma
l_int|0x0D
comma
op_amp
id|zero_word
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 82586 bug workaround on  */
)brace
id|mc32_load_tx_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mc32_load_rx_ring
c_func
(paren
id|dev
)paren
)paren
(brace
id|mc32_close
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|lp-&gt;desired_state
op_assign
id|RUNNING
suffix:semicolon
multiline_comment|/* And finally, set the ball rolling... */
id|mc32_start_transceiver
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_timeout&t;-&t;handle a timeout from the network layer&n; *&t;@dev: 3c527 that timed out&n; *&n; *&t;Handle a timeout on transmit from the 3c527. This normally means&n; *&t;bad things as the hardware handles cable timeouts and mess for&n; *&t;us.&n; *&n; */
DECL|function|mc32_timeout
r_static
r_void
id|mc32_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: transmit timed out?&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_send_packet&t;-&t;queue a frame for transmit&n; *&t;@skb: buffer to transmit&n; *&t;@dev: 3c527 to send it out of&n; *&n; *&t;Transmit a buffer. This normally means throwing the buffer onto&n; *&t;the transmit queue as the queue is quite large. If the queue is&n; *&t;full then we set tx_busy and return. Once the interrupt handler&n; *&t;gets messages telling it to reclaim transmit queue entries we will&n; *&t;clear tx_busy and the kernel will start calling this again.&n; *&n; *&t;We use cli rather than spinlocks. Since I have no access to an SMP&n; *&t;MCA machine I don&squot;t plan to change it. It is probably the top &n; *&t;performance hit for this driver on SMP however.&n; */
DECL|function|mc32_send_packet
r_static
r_int
id|mc32_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_struct
id|skb_header
op_star
id|p
comma
op_star
id|np
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|lp-&gt;tx_count
)paren
op_eq
l_int|0
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|lp-&gt;tx_count
)paren
suffix:semicolon
multiline_comment|/* P is the last sending/sent buffer as a pointer */
id|p
op_assign
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_ring_head
)braket
dot
id|p
suffix:semicolon
id|lp-&gt;tx_ring_head
op_assign
id|next_tx
c_func
(paren
id|lp-&gt;tx_ring_head
)paren
suffix:semicolon
multiline_comment|/* NP is the buffer we will be loading */
id|np
op_assign
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_ring_head
)braket
dot
id|p
suffix:semicolon
multiline_comment|/* We will need this to flush the buffer out */
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_ring_head
)braket
dot
id|skb
op_assign
id|skb
suffix:semicolon
id|np-&gt;length
op_assign
(paren
id|skb-&gt;len
OL
id|ETH_ZLEN
)paren
ques
c_cond
id|ETH_ZLEN
suffix:colon
id|skb-&gt;len
suffix:semicolon
id|np-&gt;data
op_assign
id|virt_to_bus
c_func
(paren
id|skb-&gt;data
)paren
suffix:semicolon
id|np-&gt;status
op_assign
l_int|0
suffix:semicolon
id|np-&gt;control
op_assign
id|CONTROL_EOP
op_or
id|CONTROL_EOL
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|p-&gt;control
op_and_assign
op_complement
id|CONTROL_EOL
suffix:semicolon
multiline_comment|/* Clear EOL on p */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_update_stats&t;-&t;pull off the on board statistics&n; *&t;@dev: 3c527 to service&n; *&n; * &n; *&t;Query and reset the on-card stats. There&squot;s the small possibility&n; *&t;of a race here, which would result in an underestimation of&n; *&t;actual errors. As such, we&squot;d prefer to keep all our stats&n; *&t;collection in software. As a rule, we do. However it can&squot;t be&n; *&t;used for rx errors and collisions as, by default, the card discards&n; *&t;bad rx packets. &n; *&n; *&t;Setting the SAV BP in the rx filter command supposedly&n; *&t;stops this behaviour. However, testing shows that it only seems to&n; *&t;enable the collation of on-card rx statistics --- the driver&n; *&t;never sees an RX descriptor with an error status set.&n; *&n; */
DECL|function|mc32_update_stats
r_static
r_void
id|mc32_update_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_volatile
r_struct
id|mc32_stats
op_star
id|st
op_assign
id|lp-&gt;stats
suffix:semicolon
id|u32
id|rx_errors
op_assign
l_int|0
suffix:semicolon
id|rx_errors
op_add_assign
id|lp-&gt;net_stats.rx_crc_errors
op_add_assign
id|st-&gt;rx_crc_errors
suffix:semicolon
id|st-&gt;rx_crc_errors
op_assign
l_int|0
suffix:semicolon
id|rx_errors
op_add_assign
id|lp-&gt;net_stats.rx_fifo_errors
op_add_assign
id|st-&gt;rx_overrun_errors
suffix:semicolon
id|st-&gt;rx_overrun_errors
op_assign
l_int|0
suffix:semicolon
id|rx_errors
op_add_assign
id|lp-&gt;net_stats.rx_frame_errors
op_add_assign
id|st-&gt;rx_alignment_errors
suffix:semicolon
id|st-&gt;rx_alignment_errors
op_assign
l_int|0
suffix:semicolon
id|rx_errors
op_add_assign
id|lp-&gt;net_stats.rx_length_errors
op_add_assign
id|st-&gt;rx_tooshort_errors
suffix:semicolon
id|st-&gt;rx_tooshort_errors
op_assign
l_int|0
suffix:semicolon
id|rx_errors
op_add_assign
id|lp-&gt;net_stats.rx_missed_errors
op_add_assign
id|st-&gt;rx_outofresource_errors
suffix:semicolon
id|st-&gt;rx_outofresource_errors
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;net_stats.rx_errors
op_assign
id|rx_errors
suffix:semicolon
multiline_comment|/* Number of packets which saw one collision */
id|lp-&gt;net_stats.collisions
op_add_assign
id|st-&gt;dataC
(braket
l_int|10
)braket
suffix:semicolon
id|st-&gt;dataC
(braket
l_int|10
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of packets which saw 2--15 collisions */
id|lp-&gt;net_stats.collisions
op_add_assign
id|st-&gt;dataC
(braket
l_int|11
)braket
suffix:semicolon
id|st-&gt;dataC
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_rx_ring&t;-&t;process the receive ring&n; *&t;@dev: 3c527 that needs its receive ring processing&n; *&n; *&n; *&t;We have received one or more indications from the card that a&n; *&t;receive has completed. The buffer ring thus contains dirty&n; *&t;entries. We walk the ring by iterating over the circular rx_ring&n; *&t;array, starting at the next dirty buffer (which happens to be the&n; *&t;one we finished up at last time around).&n; *&n; *&t;For each completed packet, we will either copy it and pass it up&n; * &t;the stack or, if the packet is near MTU sized, we allocate&n; *&t;another buffer and flip the old one up the stack.&n; * &n; *&t;We must succeed in keeping a buffer on the ring. If neccessary we&n; *&t;will toss a received packet rather than lose a ring entry. Once&n; *&t;the first uncompleted descriptor is found, we move the&n; *&t;End-Of-List bit to include the buffers just processed.&n; *&n; */
DECL|function|mc32_rx_ring
r_static
r_void
id|mc32_rx_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
r_volatile
r_struct
id|skb_header
op_star
id|p
suffix:semicolon
id|u16
id|rx_ring_tail
op_assign
id|lp-&gt;rx_ring_tail
suffix:semicolon
id|u16
id|rx_old_tail
op_assign
id|rx_ring_tail
suffix:semicolon
r_int
id|x
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|p
op_assign
id|lp-&gt;rx_ring
(braket
id|rx_ring_tail
)braket
dot
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;status
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
)paren
(brace
multiline_comment|/* Not COMPLETED */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;status
op_amp
(paren
l_int|1
op_lshift
l_int|6
)paren
)paren
multiline_comment|/* COMPLETED_OK */
(brace
id|u16
id|length
op_assign
id|p-&gt;length
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|sk_buff
op_star
id|newskb
suffix:semicolon
multiline_comment|/* Try to save time by avoiding a copy on big frames */
r_if
c_cond
(paren
(paren
id|length
OG
id|RX_COPYBREAK
)paren
op_logical_and
(paren
(paren
id|newskb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|1532
)paren
)paren
op_ne
l_int|NULL
)paren
)paren
(brace
id|skb
op_assign
id|lp-&gt;rx_ring
(braket
id|rx_ring_tail
)braket
dot
id|skb
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|length
)paren
suffix:semicolon
id|skb_reserve
c_func
(paren
id|newskb
comma
l_int|18
)paren
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|rx_ring_tail
)braket
dot
id|skb
op_assign
id|newskb
suffix:semicolon
id|p-&gt;data
op_assign
id|virt_to_bus
c_func
(paren
id|newskb-&gt;data
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|length
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|lp-&gt;net_stats.rx_dropped
op_increment
suffix:semicolon
r_goto
id|dropped
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|length
)paren
comma
id|lp-&gt;rx_ring
(braket
id|rx_ring_tail
)braket
dot
id|skb-&gt;data
comma
id|length
)paren
suffix:semicolon
)brace
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|lp-&gt;net_stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;net_stats.rx_bytes
op_add_assign
id|length
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|dropped
suffix:colon
id|p-&gt;length
op_assign
l_int|1532
suffix:semicolon
id|p-&gt;status
op_assign
l_int|0
suffix:semicolon
id|rx_ring_tail
op_assign
id|next_rx
c_func
(paren
id|rx_ring_tail
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|x
op_increment
OL
l_int|48
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* If there was actually a frame to be processed, place the EOL bit */
multiline_comment|/* at the descriptor prior to the one to be filled next */
r_if
c_cond
(paren
id|rx_ring_tail
op_ne
id|rx_old_tail
)paren
(brace
id|lp-&gt;rx_ring
(braket
id|prev_rx
c_func
(paren
id|rx_ring_tail
)paren
)braket
dot
id|p-&gt;control
op_or_assign
id|CONTROL_EOL
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|prev_rx
c_func
(paren
id|rx_old_tail
)paren
)braket
dot
id|p-&gt;control
op_and_assign
op_complement
id|CONTROL_EOL
suffix:semicolon
id|lp-&gt;rx_ring_tail
op_assign
id|rx_ring_tail
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;mc32_tx_ring&t;-&t;process completed transmits&n; *&t;@dev: 3c527 that needs its transmit ring processing&n; *&n; *&n; *&t;This operates in a similar fashion to mc32_rx_ring. We iterate&n; *&t;over the transmit ring. For each descriptor which has been&n; *&t;processed by the card, we free its associated buffer and note&n; *&t;any errors. This continues until the transmit ring is emptied&n; *&t;or we reach a descriptor that hasn&squot;t yet been processed by the&n; *&t;card.&n; * &n; */
DECL|function|mc32_tx_ring
r_static
r_void
id|mc32_tx_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_volatile
r_struct
id|skb_header
op_star
id|np
suffix:semicolon
multiline_comment|/* NB: lp-&gt;tx_count=TX_RING_LEN-1 so that tx_ring_head cannot &quot;lap&quot; tail here */
r_while
c_loop
(paren
id|lp-&gt;tx_ring_tail
op_ne
id|lp-&gt;tx_ring_head
)paren
(brace
id|u16
id|t
suffix:semicolon
id|t
op_assign
id|next_tx
c_func
(paren
id|lp-&gt;tx_ring_tail
)paren
suffix:semicolon
id|np
op_assign
id|lp-&gt;tx_ring
(braket
id|t
)braket
dot
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;status
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
)paren
(brace
multiline_comment|/* Not COMPLETED */
r_break
suffix:semicolon
)brace
id|lp-&gt;net_stats.tx_packets
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;status
op_amp
(paren
l_int|1
op_lshift
l_int|6
)paren
)paren
)paren
multiline_comment|/* Not COMPLETED_OK */
(brace
id|lp-&gt;net_stats.tx_errors
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|np-&gt;status
op_amp
l_int|0x0F
)paren
(brace
r_case
l_int|1
suffix:colon
id|lp-&gt;net_stats.tx_aborted_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Max collisions */
r_case
l_int|2
suffix:colon
id|lp-&gt;net_stats.tx_fifo_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|lp-&gt;net_stats.tx_carrier_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|lp-&gt;net_stats.tx_window_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* CTS Lost */
r_case
l_int|5
suffix:colon
id|lp-&gt;net_stats.tx_aborted_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Transmit timeout */
)brace
)brace
multiline_comment|/* Packets are sent in order - this is&n;&t;&t;    basically a FIFO queue of buffers matching&n;&t;&t;    the card ring */
id|lp-&gt;net_stats.tx_bytes
op_add_assign
id|lp-&gt;tx_ring
(braket
id|t
)braket
dot
id|skb-&gt;len
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|lp-&gt;tx_ring
(braket
id|t
)braket
dot
id|skb
)paren
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|t
)braket
dot
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|lp-&gt;tx_count
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;tx_ring_tail
op_assign
id|t
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;mc32_interrupt&t;&t;-&t;handle an interrupt from a 3c527&n; *&t;@irq: Interrupt number&n; *&t;@dev_id: 3c527 that requires servicing&n; *&t;@regs: Registers (unused)&n; *&n; *&n; *&t;An interrupt is raised whenever the 3c527 writes to the command&n; *&t;register. This register contains the message it wishes to send us&n; *&t;packed into a single byte field. We keep reading status entries&n; *&t;until we have processed all the control items, but simply count&n; *&t;transmit and receive reports. When all reports are in we empty the&n; *&t;transceiver rings as appropriate. This saves the overhead of&n; *&t;multiple command requests.&n; *&n; *&t;Because MCA is level-triggered, we shouldn&squot;t miss indications.&n; *&t;Therefore, we needn&squot;t ask the card to suspend interrupts within&n; *&t;this handler. The card receives an implicit acknowledgment of the&n; *&t;current interrupt when we read the command register.&n; *&n; */
DECL|function|mc32_interrupt
r_static
r_void
id|mc32_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|mc32_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
comma
id|status
comma
id|boguscount
op_assign
l_int|0
suffix:semicolon
r_int
id|rx_event
op_assign
l_int|0
suffix:semicolon
r_int
id|tx_event
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: irq %d for unknown device.&bslash;n&quot;
comma
id|cardname
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* See whats cooking */
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_STATUS
)paren
op_amp
id|HOST_STATUS_CWR
)paren
op_logical_and
id|boguscount
op_increment
OL
l_int|2000
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_CMD
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IRQ&t;&t;
id|printk
c_func
(paren
l_string|&quot;Status TX%d RX%d EX%d OV%d BC%d&bslash;n&quot;
comma
(paren
id|status
op_amp
l_int|7
)paren
comma
(paren
id|status
op_rshift
l_int|3
)paren
op_amp
l_int|7
comma
(paren
id|status
op_rshift
l_int|6
)paren
op_amp
l_int|1
comma
(paren
id|status
op_rshift
l_int|7
)paren
op_amp
l_int|1
comma
id|boguscount
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|status
op_amp
l_int|7
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* TX fail */
r_case
l_int|2
suffix:colon
multiline_comment|/* TX ok */
id|tx_event
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* Halt */
r_case
l_int|4
suffix:colon
multiline_comment|/* Abort */
id|lp-&gt;xceiver_state
op_or_assign
id|TX_HALTED
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: strange tx ack %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
op_amp
l_int|7
)paren
suffix:semicolon
)brace
id|status
op_rshift_assign
l_int|3
suffix:semicolon
r_switch
c_cond
(paren
id|status
op_amp
l_int|7
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* RX */
id|rx_event
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* Halt */
r_case
l_int|4
suffix:colon
multiline_comment|/* Abort */
id|lp-&gt;xceiver_state
op_or_assign
id|RX_HALTED
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Out of RX buffers stat */
multiline_comment|/* Must restart rx */
id|lp-&gt;net_stats.rx_dropped
op_increment
suffix:semicolon
id|mc32_rx_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mc32_start_transceiver
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: strange rx ack %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
op_amp
l_int|7
)paren
suffix:semicolon
)brace
id|status
op_rshift_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|1
)paren
(brace
multiline_comment|/* 0=no 1=yes 2=replied, get cmd, 3 = wait reply &amp; dump it */
r_if
c_cond
(paren
id|lp-&gt;exec_pending
op_ne
l_int|3
)paren
(brace
id|lp-&gt;exec_pending
op_assign
l_int|2
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;exec_pending
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* A new multicast set may have been&n;&t;&t;&t;&t;   blocked while the old one was&n;&t;&t;&t;&t;   running. If so, do it now. */
r_if
c_cond
(paren
id|lp-&gt;mc_reload_wait
)paren
id|mc32_reset_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
id|wake_up
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|2
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;We get interrupted once per&n;&t;&t;&t; *&t;counter that is about to overflow. &n;&t;&t;&t; */
id|mc32_update_stats
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Process the transmit and receive rings &n;         */
r_if
c_cond
(paren
id|tx_event
)paren
(brace
id|mc32_tx_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rx_event
)paren
(brace
id|mc32_rx_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_close&t;-&t;user configuring the 3c527 down&n; *&t;@dev: 3c527 card to shut down&n; *&n; *&t;The 3c527 is a bus mastering device. We must be careful how we&n; *&t;shut it down. It may also be running shared interrupt so we have&n; *&t;to be sure to silence it properly&n; *&n; *&t;We indicate that the card is closing to the rest of the&n; *&t;driver.  Otherwise, it is possible that the card may run out&n; *&t;of receive buffers and restart the transceiver while we&squot;re&n; *&t;trying to close it.&n; * &n; *&t;We abort any receive and transmits going on and then wait until&n; *&t;any pending exec commands have completed in other code threads.&n; *&t;In theory we can&squot;t get here while that is true, in practice I am&n; *&t;paranoid&n; *&n; *&t;We turn off the interrupt enable for the board to be sure it can&squot;t&n; *&t;intefere with other devices.&n; */
DECL|function|mc32_close
r_static
r_int
id|mc32_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u8
id|regs
suffix:semicolon
id|u16
id|one
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;desired_state
op_assign
id|HALTED
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send the indications on command (handy debug check)&n;&t; */
id|mc32_command
c_func
(paren
id|dev
comma
l_int|4
comma
op_amp
id|one
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Shut down the transceiver */
id|mc32_halt_transceiver
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Catch any waiting commands */
r_while
c_loop
(paren
id|lp-&gt;exec_pending
op_eq
l_int|1
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lp-&gt;event
)paren
suffix:semicolon
)brace
multiline_comment|/* Ok the card is now stopping */
id|regs
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|regs
op_and_assign
op_complement
id|HOST_CTRL_INTE
suffix:semicolon
id|outb
c_func
(paren
id|regs
comma
id|ioaddr
op_plus
id|HOST_CTRL
)paren
suffix:semicolon
id|mc32_flush_rx_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mc32_flush_tx_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mc32_update_stats
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_get_stats&t;&t;-&t;hand back stats to network layer&n; *&t;@dev: The 3c527 card to handle&n; *&n; *&t;We&squot;ve collected all the stats we can in software already. Now&n; *&t;it&squot;s time to update those kept on-card and return the lot. &n; * &n; */
DECL|function|mc32_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|mc32_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
suffix:semicolon
id|mc32_update_stats
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;net_stats
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;do_mc32_set_multicast_list&t;-&t;attempt to update multicasts&n; *&t;@dev: 3c527 device to load the list on&n; *&t;@retry: indicates this is not the first call. &n; *&n; *&n; * &t;Actually set or clear the multicast filter for this adaptor. The&n; *&t;locking issues are handled by this routine. We have to track&n; *&t;state as it may take multiple calls to get the command sequence&n; *&t;completed. We just keep trying to schedule the loads until we&n; *&t;manage to process them all.&n; * &n; *&t;num_addrs == -1&t;Promiscuous mode, receive all packets&n; * &n; *&t;num_addrs == 0&t;Normal mode, clear multicast list&n; * &n; *&t;num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets, &n; *&t;&t;&t;and do best-effort filtering. &n; *&n; *&t;See mc32_update_stats() regards setting the SAV BP bit. &n; *&n; */
DECL|function|do_mc32_set_multicast_list
r_static
r_void
id|do_mc32_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|retry
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
(paren
r_struct
id|mc32_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u16
id|filt
op_assign
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Save Bad Packets, for stats purposes */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
multiline_comment|/* Enable promiscuous mode */
id|filt
op_or_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
id|dev-&gt;mc_count
OG
l_int|10
)paren
(brace
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
id|filt
op_or_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
)paren
(brace
r_int
r_char
id|block
(braket
l_int|62
)braket
suffix:semicolon
r_int
r_char
op_star
id|bp
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmc
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|retry
op_eq
l_int|0
)paren
(brace
id|lp-&gt;mc_list_valid
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;mc_list_valid
)paren
(brace
id|block
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|block
(braket
l_int|0
)braket
op_assign
id|dev-&gt;mc_count
suffix:semicolon
id|bp
op_assign
id|block
op_plus
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|bp
comma
id|dmc-&gt;dmi_addr
comma
l_int|6
)paren
suffix:semicolon
id|bp
op_add_assign
l_int|6
suffix:semicolon
id|dmc
op_assign
id|dmc-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mc32_command_nowait
c_func
(paren
id|dev
comma
l_int|2
comma
id|block
comma
l_int|2
op_plus
l_int|6
op_star
id|dev-&gt;mc_count
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|lp-&gt;mc_reload_wait
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lp-&gt;mc_list_valid
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mc32_command_nowait
c_func
(paren
id|dev
comma
l_int|0
comma
op_amp
id|filt
comma
l_int|2
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|lp-&gt;mc_reload_wait
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;mc_reload_wait
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;mc32_set_multicast_list&t;-&t;queue multicast list update&n; *&t;@dev: The 3c527 to use&n; *&n; *&t;Commence loading the multicast list. This is called when the kernel&n; *&t;changes the lists. It will override any pending list we are trying to&n; *&t;load.&n; */
DECL|function|mc32_set_multicast_list
r_static
r_void
id|mc32_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|do_mc32_set_multicast_list
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mc32_reset_multicast_list&t;-&t;reset multicast list&n; *&t;@dev: The 3c527 to use&n; *&n; *&t;Attempt the next step in loading the multicast lists. If this attempt&n; *&t;fails to complete then it will be scheduled and this function called&n; *&t;again later from elsewhere.&n; */
DECL|function|mc32_reset_multicast_list
r_static
r_void
id|mc32_reset_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|do_mc32_set_multicast_list
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|this_device
r_static
r_struct
id|net_device
id|this_device
suffix:semicolon
multiline_comment|/**&n; *&t;init_module&t;&t;-&t;entry point&n; *&n; *&t;Probe and locate a 3c527 card. This really should probe and locate&n; *&t;all the 3c527 cards in the machine not just one of them. Yes you can&n; *&t;insmod multiple modules for now but it&squot;s a hack.&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
id|this_device.init
op_assign
id|mc32_probe
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|register_netdev
c_func
(paren
op_amp
id|this_device
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;cleanup_module&t;-&t;free resources for an unload&n; *&n; *&t;Unloading time. We release the MCA bus resources and the interrupt&n; *&t;at which point everything is ready to unload. The card must be stopped&n; *&t;at this point or we would not have been called. When we unload we&n; *&t;leave the card stopped but not totally shut down. When the card is&n; *&t;initialized it must be rebooted or the rings reloaded before any&n; *&t;transmit operations are allowed to start scribbling into memory.&n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|slot
suffix:semicolon
multiline_comment|/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
id|unregister_netdev
c_func
(paren
op_amp
id|this_device
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we don&squot;t do this, we can&squot;t re-insmod it later.&n;&t; */
r_if
c_cond
(paren
id|this_device.priv
)paren
(brace
r_struct
id|mc32_local
op_star
id|lp
op_assign
id|this_device.priv
suffix:semicolon
id|slot
op_assign
id|lp-&gt;slot
suffix:semicolon
id|mca_mark_as_unused
c_func
(paren
id|slot
)paren
suffix:semicolon
id|mca_set_adapter_name
c_func
(paren
id|slot
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|this_device.priv
)paren
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|this_device.irq
comma
op_amp
id|this_device
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|this_device.base_addr
comma
id|MC32_IO_EXTENT
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
