multiline_comment|/*  ewrk3.c: A DIGITAL EtherWORKS 3 ethernet driver for Linux.&n;&n;   Written 1994 by David C. Davies.&n;&n;   Copyright 1994 Digital Equipment Corporation.&n;&n;   This software may be used and distributed according to the terms of&n;   the GNU General Public License, incorporated herein by reference.&n;&n;   This driver is written for the Digital Equipment Corporation series&n;   of EtherWORKS ethernet cards:&n;&n;   DE203 Turbo (BNC)&n;   DE204 Turbo (TP)&n;   DE205 Turbo (TP BNC)&n;&n;   The driver has been tested on a relatively busy  network using the DE205&n;   card and benchmarked with &squot;ttcp&squot;: it transferred 16M  of data at 975kB/s&n;   (7.8Mb/s) to a DECstation 5000/200.&n;&n;   The author may be reached at davies@maniac.ultranet.com.&n;&n;   =========================================================================&n;   This driver has been written  substantially  from scratch, although  its&n;   inheritance of style and stack interface from &squot;depca.c&squot; and in turn from&n;   Donald Becker&squot;s &squot;lance.c&squot; should be obvious.&n;&n;   The  DE203/4/5 boards  all  use a new proprietary   chip in place of the&n;   LANCE chip used in prior cards  (DEPCA, DE100, DE200/1/2, DE210, DE422).&n;   Use the depca.c driver in the standard distribution  for the LANCE based&n;   cards from DIGITAL; this driver will not work with them.&n;&n;   The DE203/4/5 cards have 2  main modes: shared memory  and I/O only. I/O&n;   only makes  all the card accesses through  I/O transactions and  no high&n;   (shared)  memory is used. This  mode provides a &gt;48% performance penalty&n;   and  is deprecated in this  driver,  although allowed to provide initial&n;   setup when hardstrapped.&n;&n;   The shared memory mode comes in 3 flavours: 2kB, 32kB and 64kB. There is&n;   no point in using any mode other than the 2kB  mode - their performances&n;   are virtually identical, although the driver has  been tested in the 2kB&n;   and 32kB modes. I would suggest you uncomment the line:&n;&n;   FORCE_2K_MODE;&n;&n;   to allow the driver to configure the card as a  2kB card at your current&n;   base  address, thus leaving more  room to clutter  your  system box with&n;   other memory hungry boards.&n;&n;   As many ISA  and EISA cards  can be supported  under this driver  as you&n;   wish, limited primarily  by the available IRQ lines,  rather than by the&n;   available I/O addresses  (24 ISA,  16 EISA).   I have  checked different&n;   configurations of  multiple  depca cards and  ewrk3 cards  and have  not&n;   found a problem yet (provided you have at least depca.c v0.38) ...&n;&n;   The board IRQ setting   must be at  an unused  IRQ which is  auto-probed&n;   using  Donald  Becker&squot;s autoprobe  routines.   All  these cards   are at&n;   {5,10,11,15}.&n;&n;   No 16MB memory  limitation should exist with this  driver as DMA is  not&n;   used and the common memory area is in low memory on the network card (my&n;   current system has 20MB and I&squot;ve not had problems yet).&n;&n;   The ability to load  this driver as a  loadable module has been included&n;   and used  extensively during the  driver development (to save those long&n;   reboot sequences). To utilise this ability, you have to do 8 things:&n;&n;   0) have a copy of the loadable modules code installed on your system.&n;   1) copy ewrk3.c from the  /linux/drivers/net directory to your favourite&n;   temporary directory.&n;   2) edit the  source code near  line 1898 to reflect  the I/O address and&n;   IRQ you&squot;re using.&n;   3) compile  ewrk3.c, but include -DMODULE in  the command line to ensure&n;   that the correct bits are compiled (see end of source code).&n;   4) if you are wanting to add a new  card, goto 5. Otherwise, recompile a&n;   kernel with the ewrk3 configuration turned off and reboot.&n;   5) insmod ewrk3.o&n;   [Alan Cox: Changed this so you can insmod ewrk3.o irq=x io=y]&n;   [Adam Kropelin: now accepts irq=x1,x2 io=y1,y2 for multiple cards]&n;   6) run the net startup bits for your new eth?? interface manually&n;   (usually /etc/rc.inet[12] at boot time).&n;   7) enjoy!&n;&n;   Note that autoprobing is not allowed in loadable modules - the system is&n;   already up and running and you&squot;re messing with interrupts.&n;&n;   To unload a module, turn off the associated interface&n;   &squot;ifconfig eth?? down&squot; then &squot;rmmod ewrk3&squot;.&n;&n;   Promiscuous   mode has been  turned  off  in this driver,   but  all the&n;   multicast  address bits  have been   turned on. This  improved the  send&n;   performance on a busy network by about 13%.&n;&n;   Ioctl&squot;s have now been provided (primarily because  I wanted to grab some&n;   packet size statistics). They  are patterned after &squot;plipconfig.c&squot; from a&n;   suggestion by Alan Cox.  Using these  ioctls, you can enable promiscuous&n;   mode, add/delete multicast  addresses, change the hardware address,  get&n;   packet size distribution statistics and muck around with the control and&n;   status register. I&squot;ll add others if and when the need arises.&n;&n;   TO DO:&n;   ------&n;&n;&n;   Revision History&n;   ----------------&n;&n;   Version   Date        Description&n;&n;   0.1     26-aug-94   Initial writing. ALPHA code release.&n;   0.11    31-aug-94   Fixed: 2k mode memory base calc.,&n;   LeMAC version calc.,&n;   IRQ vector assignments during autoprobe.&n;   0.12    31-aug-94   Tested working on LeMAC2 (DE20[345]-AC) card.&n;   Fixed up MCA hash table algorithm.&n;   0.20     4-sep-94   Added IOCTL functionality.&n;   0.21    14-sep-94   Added I/O mode.&n;   0.21axp 15-sep-94   Special version for ALPHA AXP Linux V1.0.&n;   0.22    16-sep-94   Added more IOCTLs &amp; tidied up.&n;   0.23    21-sep-94   Added transmit cut through.&n;   0.24    31-oct-94   Added uid checks in some ioctls.&n;   0.30     1-nov-94   BETA code release.&n;   0.31     5-dec-94   Added check/allocate region code.&n;   0.32    16-jan-95   Broadcast packet fix.&n;   0.33    10-Feb-95   Fix recognition bug reported by &lt;bkm@star.rl.ac.uk&gt;.&n;   0.40    27-Dec-95   Rationalise MODULE and autoprobe code.&n;   Rewrite for portability &amp; updated.&n;   ALPHA support from &lt;jestabro@amt.tay1.dec.com&gt;&n;   Added verify_area() calls in ewrk3_ioctl() from&n;   suggestion by &lt;heiko@colossus.escape.de&gt;.&n;   Add new multicasting code.&n;   0.41    20-Jan-96   Fix IRQ set up problem reported by&n;   &lt;kenneth@bbs.sas.ntu.ac.sg&gt;.&n;   0.42    22-Apr-96   Fix alloc_device() bug &lt;jari@markkus2.fimr.fi&gt;&n;   0.43    16-Aug-96   Update alloc_device() to conform to de4x5.c&n;   0.44    08-Nov-01   use library crc32 functions &lt;Matt_Domsch@dell.com&gt;&n;   0.45    19-Jul-02   fix unaligned access on alpha &lt;martin@bruli.net&gt;&n;   0.46    10-Oct-02   Multiple NIC support when module &lt;akropel1@rochester.rr.com&gt;&n;   0.47    18-Oct-02   ethtool support &lt;akropel1@rochester.rr.com&gt;&n;   0.48    18-Oct-02   cli/sti removal for 2.5 &lt;vda@port.imtp.ilyichevsk.odessa.ua&gt;&n;   ioctl locking, signature search cleanup &lt;akropel1@rochester.rr.com&gt;&n;&n;   =========================================================================&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/ethtool.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;ewrk3.h&quot;
DECL|macro|DRV_NAME
mdefine_line|#define DRV_NAME&t;&quot;ewrk3&quot;
DECL|macro|DRV_VERSION
mdefine_line|#define DRV_VERSION&t;&quot;0.48&quot;
DECL|variable|__initdata
r_static
r_char
id|version
(braket
)braket
id|__initdata
op_assign
id|DRV_NAME
l_string|&quot;:v&quot;
id|DRV_VERSION
l_string|&quot; 2002/10/18 davies@maniac.ultranet.com&bslash;n&quot;
suffix:semicolon
macro_line|#ifdef EWRK3_DEBUG
DECL|variable|ewrk3_debug
r_static
r_int
id|ewrk3_debug
op_assign
id|EWRK3_DEBUG
suffix:semicolon
macro_line|#else
DECL|variable|ewrk3_debug
r_static
r_int
id|ewrk3_debug
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
DECL|macro|EWRK3_NDA
mdefine_line|#define EWRK3_NDA 0xffe0&t;/* No Device Address */
DECL|macro|PROBE_LENGTH
mdefine_line|#define PROBE_LENGTH    32
DECL|macro|ETH_PROM_SIG
mdefine_line|#define ETH_PROM_SIG    0xAA5500FFUL
macro_line|#ifndef EWRK3_SIGNATURE
DECL|macro|EWRK3_SIGNATURE
mdefine_line|#define EWRK3_SIGNATURE {&quot;DE203&quot;,&quot;DE204&quot;,&quot;DE205&quot;,&quot;&quot;}
DECL|macro|EWRK3_STRLEN
mdefine_line|#define EWRK3_STRLEN 8
macro_line|#endif
macro_line|#ifndef EWRK3_RAM_BASE_ADDRESSES
DECL|macro|EWRK3_RAM_BASE_ADDRESSES
mdefine_line|#define EWRK3_RAM_BASE_ADDRESSES {0xc0000,0xd0000,0x00000}
macro_line|#endif
multiline_comment|/*&n;   ** Sets up the I/O area for the autoprobe.&n; */
DECL|macro|EWRK3_IO_BASE
mdefine_line|#define EWRK3_IO_BASE 0x100&t;/* Start address for probe search */
DECL|macro|EWRK3_IOP_INC
mdefine_line|#define EWRK3_IOP_INC 0x20&t;/* I/O address increment */
DECL|macro|EWRK3_TOTAL_SIZE
mdefine_line|#define EWRK3_TOTAL_SIZE 0x20&t;/* required I/O address length */
macro_line|#ifndef MAX_NUM_EWRK3S
DECL|macro|MAX_NUM_EWRK3S
mdefine_line|#define MAX_NUM_EWRK3S 21
macro_line|#endif
macro_line|#ifndef EWRK3_EISA_IO_PORTS
DECL|macro|EWRK3_EISA_IO_PORTS
mdefine_line|#define EWRK3_EISA_IO_PORTS 0x0c00&t;/* I/O port base address, slot 0 */
macro_line|#endif
macro_line|#ifndef MAX_EISA_SLOTS
DECL|macro|MAX_EISA_SLOTS
mdefine_line|#define MAX_EISA_SLOTS 16
DECL|macro|EISA_SLOT_INC
mdefine_line|#define EISA_SLOT_INC 0x1000
macro_line|#endif
DECL|macro|QUEUE_PKT_TIMEOUT
mdefine_line|#define QUEUE_PKT_TIMEOUT (1*HZ)&t;/* Jiffies */
multiline_comment|/*&n;   ** EtherWORKS 3 shared memory window sizes&n; */
DECL|macro|IO_ONLY
mdefine_line|#define IO_ONLY         0x00
DECL|macro|SHMEM_2K
mdefine_line|#define SHMEM_2K        0x800
DECL|macro|SHMEM_32K
mdefine_line|#define SHMEM_32K       0x8000
DECL|macro|SHMEM_64K
mdefine_line|#define SHMEM_64K       0x10000
multiline_comment|/*&n;   ** EtherWORKS 3 IRQ ENABLE/DISABLE&n; */
DECL|macro|ENABLE_IRQs
mdefine_line|#define ENABLE_IRQs { &bslash;&n;  icr |= lp-&gt;irq_mask;&bslash;&n;  outb(icr, EWRK3_ICR);                     /* Enable the IRQs */&bslash;&n;}
DECL|macro|DISABLE_IRQs
mdefine_line|#define DISABLE_IRQs { &bslash;&n;  icr = inb(EWRK3_ICR);&bslash;&n;  icr &amp;= ~lp-&gt;irq_mask;&bslash;&n;  outb(icr, EWRK3_ICR);                     /* Disable the IRQs */&bslash;&n;}
multiline_comment|/*&n;   ** EtherWORKS 3 START/STOP&n; */
DECL|macro|START_EWRK3
mdefine_line|#define START_EWRK3 { &bslash;&n;  csr = inb(EWRK3_CSR);&bslash;&n;  csr &amp;= ~(CSR_TXD|CSR_RXD);&bslash;&n;  outb(csr, EWRK3_CSR);                     /* Enable the TX and/or RX */&bslash;&n;}
DECL|macro|STOP_EWRK3
mdefine_line|#define STOP_EWRK3 { &bslash;&n;  csr = (CSR_TXD|CSR_RXD);&bslash;&n;  outb(csr, EWRK3_CSR);                     /* Disable the TX and/or RX */&bslash;&n;}
multiline_comment|/*&n;   ** The EtherWORKS 3 private structure&n; */
DECL|macro|EWRK3_PKT_STAT_SZ
mdefine_line|#define EWRK3_PKT_STAT_SZ 16
DECL|macro|EWRK3_PKT_BIN_SZ
mdefine_line|#define EWRK3_PKT_BIN_SZ  128&t;/* Should be &gt;=100 unless you&n;&t;&t;&t;&t;   increase EWRK3_PKT_STAT_SZ */
DECL|struct|ewrk3_stats
r_struct
id|ewrk3_stats
(brace
DECL|member|bins
id|u32
id|bins
(braket
id|EWRK3_PKT_STAT_SZ
)braket
suffix:semicolon
DECL|member|unicast
id|u32
id|unicast
suffix:semicolon
DECL|member|multicast
id|u32
id|multicast
suffix:semicolon
DECL|member|broadcast
id|u32
id|broadcast
suffix:semicolon
DECL|member|excessive_collisions
id|u32
id|excessive_collisions
suffix:semicolon
DECL|member|tx_underruns
id|u32
id|tx_underruns
suffix:semicolon
DECL|member|excessive_underruns
id|u32
id|excessive_underruns
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|ewrk3_private
r_struct
id|ewrk3_private
(brace
DECL|member|adapter_name
r_char
id|adapter_name
(braket
l_int|80
)braket
suffix:semicolon
multiline_comment|/* Name exported to /proc/ioports */
DECL|member|shmem_base
id|u_long
id|shmem_base
suffix:semicolon
multiline_comment|/* Shared memory start address */
DECL|member|shmem_length
id|u_long
id|shmem_length
suffix:semicolon
multiline_comment|/* Shared memory window length */
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
multiline_comment|/* Public stats */
DECL|member|pktStats
r_struct
id|ewrk3_stats
id|pktStats
suffix:semicolon
multiline_comment|/* Private stats counters */
DECL|member|irq_mask
id|u_char
id|irq_mask
suffix:semicolon
multiline_comment|/* Adapter IRQ mask bits */
DECL|member|mPage
id|u_char
id|mPage
suffix:semicolon
multiline_comment|/* Maximum 2kB Page number */
DECL|member|lemac
id|u_char
id|lemac
suffix:semicolon
multiline_comment|/* Chip rev. level */
DECL|member|hard_strapped
id|u_char
id|hard_strapped
suffix:semicolon
multiline_comment|/* Don&squot;t allow a full open */
DECL|member|txc
id|u_char
id|txc
suffix:semicolon
multiline_comment|/* Transmit cut through */
DECL|member|mctbl
id|u_char
op_star
id|mctbl
suffix:semicolon
multiline_comment|/* Pointer to the multicast table */
DECL|member|led_mask
id|u_char
id|led_mask
suffix:semicolon
multiline_comment|/* Used to reserve LED access for ethtool */
DECL|member|hw_lock
id|spinlock_t
id|hw_lock
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;   ** Force the EtherWORKS 3 card to be in 2kB MODE&n; */
DECL|macro|FORCE_2K_MODE
mdefine_line|#define FORCE_2K_MODE { &bslash;&n;  shmem_length = SHMEM_2K;&bslash;&n;  outb(((mem_start - 0x80000) &gt;&gt; 11), EWRK3_MBR);&bslash;&n;}
multiline_comment|/*&n;   ** Public Functions&n; */
r_static
r_int
id|ewrk3_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_queue_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
id|irqreturn_t
id|ewrk3_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|ewrk3_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
DECL|variable|ethtool_ops_203
r_static
r_struct
id|ethtool_ops
id|ethtool_ops_203
suffix:semicolon
DECL|variable|ethtool_ops
r_static
r_struct
id|ethtool_ops
id|ethtool_ops
suffix:semicolon
multiline_comment|/*&n;   ** Private functions&n; */
r_static
r_int
id|ewrk3_hw_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|ewrk3_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ewrk3_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|EthwrkSignature
c_func
(paren
r_char
op_star
id|name
comma
r_char
op_star
id|eeprom_image
)paren
suffix:semicolon
r_static
r_int
id|DevicePresent
c_func
(paren
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|EISA_signature
c_func
(paren
r_char
op_star
id|name
comma
id|s32
id|eisa_id
)paren
suffix:semicolon
r_static
r_int
id|Read_EEPROM
c_func
(paren
id|u_long
id|iobase
comma
id|u_char
id|eaddr
)paren
suffix:semicolon
r_static
r_int
id|Write_EEPROM
c_func
(paren
r_int
id|data
comma
id|u_long
id|iobase
comma
id|u_char
id|eaddr
)paren
suffix:semicolon
r_static
id|u_char
id|get_hw_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
op_star
id|eeprom_image
comma
r_char
id|chipType
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
comma
r_int
id|irq
)paren
suffix:semicolon
r_static
r_int
id|isa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_int
id|eisa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
DECL|variable|irq
r_static
id|u_char
id|irq
(braket
id|MAX_NUM_EWRK3S
op_plus
l_int|1
)braket
op_assign
(brace
l_int|5
comma
l_int|0
comma
l_int|10
comma
l_int|3
comma
l_int|11
comma
l_int|9
comma
l_int|15
comma
l_int|12
)brace
suffix:semicolon
DECL|variable|name
r_static
r_char
id|name
(braket
id|EWRK3_STRLEN
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|num_ewrks3s
r_static
r_int
id|num_ewrks3s
suffix:semicolon
multiline_comment|/*&n;   ** Miscellaneous defines...&n; */
DECL|macro|INIT_EWRK3
mdefine_line|#define INIT_EWRK3 {&bslash;&n;    outb(EEPROM_INIT, EWRK3_IOPR);&bslash;&n;    mdelay(1);&bslash;&n;}
macro_line|#ifndef MODULE
DECL|function|ewrk3_probe
r_struct
id|net_device
op_star
id|__init
id|ewrk3_probe
c_func
(paren
r_int
id|unit
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|alloc_etherdev
c_func
(paren
r_sizeof
(paren
r_struct
id|ewrk3_private
)paren
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
op_ge
l_int|0
)paren
(brace
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth%d&quot;
comma
id|unit
)paren
suffix:semicolon
id|netdev_boot_setup_check
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
id|err
op_assign
id|ewrk3_probe1
c_func
(paren
id|dev
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_return
id|dev
suffix:semicolon
id|out
suffix:colon
id|free_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ewrk3_probe1
r_static
r_int
id|__init
id|ewrk3_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
comma
r_int
id|irq
)paren
(brace
r_int
id|err
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|iobase
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
multiline_comment|/* Address PROM pattern */
id|err
op_assign
id|isa_probe
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
)paren
id|err
op_assign
id|eisa_probe
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|err
op_assign
id|register_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|EWRK3_TOTAL_SIZE
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|ewrk3_hw_init
id|ewrk3_hw_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_long
id|mem_start
comma
id|shmem_length
suffix:semicolon
id|u_char
id|cr
comma
id|cmr
comma
id|icr
comma
id|nicsr
comma
id|lemac
comma
id|hard_strapped
op_assign
l_int|0
suffix:semicolon
id|u_char
id|eeprom_image
(braket
id|EEPROM_MAX
)braket
comma
id|chksum
comma
id|eisa_cr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;** Stop the EWRK3. Enable the DBR ROM. Disable interrupts and remote boot.&n;&t;** This also disables the EISA_ENABLE bit in the EISA Control Register.&n;&t; */
r_if
c_cond
(paren
id|iobase
OG
l_int|0x400
)paren
id|eisa_cr
op_assign
id|inb
c_func
(paren
id|EISA_CR
)paren
suffix:semicolon
id|INIT_EWRK3
suffix:semicolon
id|nicsr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|icr
op_assign
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
suffix:semicolon
id|icr
op_and_assign
l_int|0x70
suffix:semicolon
id|outb
c_func
(paren
id|icr
comma
id|EWRK3_ICR
)paren
suffix:semicolon
multiline_comment|/* Disable all the IRQs */
r_if
c_cond
(paren
id|nicsr
op_eq
(paren
id|CSR_TXD
op_or
id|CSR_RXD
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* Check that the EEPROM is alive and well and not living on Pluto... */
r_for
c_loop
(paren
id|chksum
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EEPROM_MAX
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
r_union
(brace
r_int
id|val
suffix:semicolon
r_char
id|c
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|tmp
suffix:semicolon
id|tmp.val
op_assign
(paren
r_int
)paren
id|Read_EEPROM
c_func
(paren
id|iobase
comma
(paren
id|i
op_rshift
l_int|1
)paren
)paren
suffix:semicolon
id|eeprom_image
(braket
id|i
)braket
op_assign
id|tmp.c
(braket
l_int|0
)braket
suffix:semicolon
id|eeprom_image
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|tmp.c
(braket
l_int|1
)braket
suffix:semicolon
id|chksum
op_add_assign
id|eeprom_image
(braket
id|i
)braket
op_plus
id|eeprom_image
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chksum
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Bad EEPROM Data! */
id|printk
c_func
(paren
l_string|&quot;%s: Device has a bad on-board EEPROM.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|EthwrkSignature
c_func
(paren
id|name
comma
id|eeprom_image
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|name
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|iobase
suffix:semicolon
r_if
c_cond
(paren
id|iobase
OG
l_int|0x400
)paren
(brace
id|outb
c_func
(paren
id|eisa_cr
comma
id|EISA_CR
)paren
suffix:semicolon
multiline_comment|/* Rewrite the EISA CR */
)brace
id|lemac
op_assign
id|eeprom_image
(braket
id|EEPROM_CHIPVER
)braket
suffix:semicolon
id|cmr
op_assign
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|lemac
op_eq
id|LeMAC
)paren
op_logical_and
(paren
(paren
id|cmr
op_amp
id|CMR_NO_EEPROM
)paren
op_ne
id|CMR_NO_EEPROM
)paren
)paren
op_logical_or
(paren
(paren
id|lemac
op_eq
id|LeMAC2
)paren
op_logical_and
op_logical_neg
(paren
id|cmr
op_amp
id|CMR_HS
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#4lx&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|iobase
)paren
suffix:semicolon
id|hard_strapped
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|iobase
op_amp
l_int|0x0fff
)paren
op_eq
id|EWRK3_EISA_IO_PORTS
)paren
(brace
multiline_comment|/* EISA slot address */
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#4lx (EISA slot %ld)&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|iobase
comma
(paren
(paren
id|iobase
op_rshift
l_int|12
)paren
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ISA port address */
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#4lx&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|iobase
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;, h/w address &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lemac
op_ne
id|LeMAC2
)paren
id|DevicePresent
c_func
(paren
id|iobase
)paren
suffix:semicolon
multiline_comment|/* need after EWRK3_INIT */
id|status
op_assign
id|get_hw_addr
c_func
(paren
id|dev
comma
id|eeprom_image
comma
id|lemac
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* get the ethernet addr. */
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%2.2x,&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      which has an EEPROM CRC error.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lemac
op_eq
id|LeMAC2
)paren
(brace
multiline_comment|/* Special LeMAC2 CMR things */
id|cmr
op_and_assign
op_complement
(paren
id|CMR_RA
op_or
id|CMR_WB
op_or
id|CMR_LINK
op_or
id|CMR_POLARITY
op_or
id|CMR_0WS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|READ_AHEAD
)paren
id|cmr
op_or_assign
id|CMR_RA
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|WRITE_BEHIND
)paren
id|cmr
op_or_assign
id|CMR_WB
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_NETMAN0
)braket
op_amp
id|NETMAN_POL
)paren
id|cmr
op_or_assign
id|CMR_POLARITY
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_NETMAN0
)braket
op_amp
id|NETMAN_LINK
)paren
id|cmr
op_or_assign
id|CMR_LINK
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|_0WS_ENA
)paren
id|cmr
op_or_assign
id|CMR_0WS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_SETUP
)braket
op_amp
id|SETUP_DRAM
)paren
id|cmr
op_or_assign
id|CMR_DRAM
suffix:semicolon
id|outb
c_func
(paren
id|cmr
comma
id|EWRK3_CMR
)paren
suffix:semicolon
id|cr
op_assign
id|inb
c_func
(paren
id|EWRK3_CR
)paren
suffix:semicolon
multiline_comment|/* Set up the Control Register */
id|cr
op_or_assign
id|eeprom_image
(braket
id|EEPROM_SETUP
)braket
op_amp
id|SETUP_APD
suffix:semicolon
r_if
c_cond
(paren
id|cr
op_amp
id|SETUP_APD
)paren
id|cr
op_or_assign
id|eeprom_image
(braket
id|EEPROM_SETUP
)braket
op_amp
id|SETUP_PS
suffix:semicolon
id|cr
op_or_assign
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|FAST_BUS
suffix:semicolon
id|cr
op_or_assign
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|ENA_16
suffix:semicolon
id|outb
c_func
(paren
id|cr
comma
id|EWRK3_CR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Determine the base address and window length for the EWRK3&n;&t;** RAM from the memory base register.&n;&t;*/
id|mem_start
op_assign
id|inb
c_func
(paren
id|EWRK3_MBR
)paren
suffix:semicolon
id|shmem_length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mem_start
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|mem_start
op_ge
l_int|0x0a
)paren
op_logical_and
(paren
id|mem_start
op_le
l_int|0x0f
)paren
)paren
(brace
id|mem_start
op_mul_assign
id|SHMEM_64K
suffix:semicolon
id|shmem_length
op_assign
id|SHMEM_64K
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|mem_start
op_ge
l_int|0x14
)paren
op_logical_and
(paren
id|mem_start
op_le
l_int|0x1f
)paren
)paren
(brace
id|mem_start
op_mul_assign
id|SHMEM_32K
suffix:semicolon
id|shmem_length
op_assign
id|SHMEM_32K
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|mem_start
op_ge
l_int|0x40
)paren
op_logical_and
(paren
id|mem_start
op_le
l_int|0xff
)paren
)paren
(brace
id|mem_start
op_assign
id|mem_start
op_star
id|SHMEM_2K
op_plus
l_int|0x80000
suffix:semicolon
id|shmem_length
op_assign
id|SHMEM_2K
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;** See the top of this source code for comments about&n;&t;** uncommenting this line.&n;&t;*/
multiline_comment|/*          FORCE_2K_MODE; */
r_if
c_cond
(paren
id|hard_strapped
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      is hard strapped.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mem_start
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      has a %dk RAM window&quot;
comma
(paren
r_int
)paren
(paren
id|shmem_length
op_rshift
l_int|10
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; at 0x%.5lx&quot;
comma
id|mem_start
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;      is in I/O only mode&quot;
)paren
suffix:semicolon
)brace
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;shmem_base
op_assign
id|mem_start
suffix:semicolon
id|lp-&gt;shmem_length
op_assign
id|shmem_length
suffix:semicolon
id|lp-&gt;lemac
op_assign
id|lemac
suffix:semicolon
id|lp-&gt;hard_strapped
op_assign
id|hard_strapped
suffix:semicolon
id|lp-&gt;led_mask
op_assign
id|CR_LED
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|lp-&gt;hw_lock
)paren
suffix:semicolon
id|lp-&gt;mPage
op_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|cmr
op_amp
id|CMR_DRAM
)paren
id|lp-&gt;mPage
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* 2 DRAMS on module */
id|sprintf
c_func
(paren
id|lp-&gt;adapter_name
comma
l_string|&quot;%s (%s)&quot;
comma
id|name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;irq_mask
op_assign
id|ICR_TNEM
op_or
id|ICR_TXDM
op_or
id|ICR_RNEM
op_or
id|ICR_RXDM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hard_strapped
)paren
(brace
multiline_comment|/*&n;&t;&t;** Enable EWRK3 board interrupts for autoprobing&n;&t;&t;*/
id|icr
op_or_assign
id|ICR_IE
suffix:semicolon
multiline_comment|/* Enable interrupts */
id|outb
c_func
(paren
id|icr
comma
id|EWRK3_ICR
)paren
suffix:semicolon
multiline_comment|/* The DMA channel may be passed in on this parameter. */
id|dev-&gt;dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* To auto-IRQ we enable the initialization-done and DMA err,&n;&t;&t;   interrupts. For now we will always get a DMA error. */
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
macro_line|#ifndef MODULE
id|u_char
id|irqnum
suffix:semicolon
r_int
r_int
id|irq_mask
suffix:semicolon
id|irq_mask
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** Trigger a TNE interrupt.&n;&t;&t;&t;*/
id|icr
op_or_assign
id|ICR_TNEM
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|EWRK3_TDQ
)paren
suffix:semicolon
multiline_comment|/* Write to the TX done queue */
id|outb
c_func
(paren
id|icr
comma
id|EWRK3_ICR
)paren
suffix:semicolon
multiline_comment|/* Unmask the TXD interrupt */
id|irqnum
op_assign
id|irq
(braket
(paren
(paren
id|icr
op_amp
id|IRQ_SEL
)paren
op_rshift
l_int|4
)paren
)braket
suffix:semicolon
id|mdelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|probe_irq_off
c_func
(paren
id|irq_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;irq
)paren
op_logical_and
(paren
id|irqnum
op_eq
id|dev-&gt;irq
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; and uses IRQ%d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; and failed to detect IRQ line.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|irqnum
op_eq
l_int|1
)paren
op_logical_and
(paren
id|lemac
op_eq
id|LeMAC2
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; and an illegal IRQ line detected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, but incorrect IRQ line detected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|DISABLE_IRQs
suffix:semicolon
multiline_comment|/* Mask all interrupts */
macro_line|#endif&t;&t;&t;&t;/* MODULE */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; and requires IRQ%d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ewrk3_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
)brace
multiline_comment|/* The EWRK3-specific entries in the device structure. */
id|dev-&gt;open
op_assign
id|ewrk3_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|ewrk3_queue_pkt
suffix:semicolon
id|dev-&gt;stop
op_assign
id|ewrk3_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|ewrk3_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|set_multicast_list
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|ewrk3_ioctl
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;adapter_name
(braket
l_int|4
)braket
op_eq
l_char|&squot;3&squot;
)paren
id|SET_ETHTOOL_OPS
c_func
(paren
id|dev
comma
op_amp
id|ethtool_ops_203
)paren
suffix:semicolon
r_else
id|SET_ETHTOOL_OPS
c_func
(paren
id|dev
comma
op_amp
id|ethtool_ops
)paren
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|ewrk3_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|QUEUE_PKT_TIMEOUT
suffix:semicolon
id|dev-&gt;mem_start
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
DECL|function|ewrk3_open
r_static
r_int
id|ewrk3_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_char
id|icr
comma
id|csr
suffix:semicolon
multiline_comment|/*&n;&t;   ** Stop the TX and RX...&n;&t; */
id|STOP_EWRK3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;hard_strapped
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
(paren
r_void
op_star
)paren
id|ewrk3_interrupt
comma
l_int|0
comma
l_string|&quot;ewrk3&quot;
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ewrk3_open(): Requested IRQ%d is busy&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;   ** Re-initialize the EWRK3...&n;&t;&t;&t; */
id|ewrk3_init
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ewrk3_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ewrk3 open with irq %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  physical address: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
(paren
id|u_char
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&bslash;n&quot;
comma
(paren
id|u_char
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  no shared memory, I/O only mode&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;  start of shared memory: 0x%08lx&bslash;n&quot;
comma
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  window length: 0x%04lx&bslash;n&quot;
comma
id|lp-&gt;shmem_length
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  # of DRAMS: %d&bslash;n&quot;
comma
(paren
(paren
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
op_amp
l_int|0x02
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  csr:  0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  cr:   0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  icr:  0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  cmr:  0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  fmqc: 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
)paren
suffix:semicolon
)brace
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;   ** Unmask EWRK3 board interrupts&n;&t;&t;&t; */
id|icr
op_assign
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
suffix:semicolon
id|ENABLE_IRQs
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ewrk3 available for hard strapped set up only.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;      Run the &squot;ewrk3setup&squot; utility or remove the hard straps.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Initialize the EtherWORKS 3 operating conditions&n; */
DECL|function|ewrk3_init
r_static
r_void
id|ewrk3_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|u_char
id|csr
comma
id|page
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;   ** Enable any multicasts&n;&t; */
id|set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Set hardware MAC address. Address is initialized from the EEPROM&n;&t;** during startup but may have since been changed by the user.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|EWRK3_PAR0
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   ** Clean out any remaining entries in all the queues here&n;&t; */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_TQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_TDQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_RQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_FMQ
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   ** Write a clean free memory queue&n;&t; */
r_for
c_loop
(paren
id|page
op_assign
l_int|1
suffix:semicolon
id|page
OL
id|lp-&gt;mPage
suffix:semicolon
id|page
op_increment
)paren
(brace
multiline_comment|/* Write the free page numbers */
id|outb
c_func
(paren
id|page
comma
id|EWRK3_FMQ
)paren
suffix:semicolon
multiline_comment|/* to the Free Memory Queue */
)brace
id|START_EWRK3
suffix:semicolon
multiline_comment|/* Enable the TX and/or RX */
)brace
multiline_comment|/*&n; *  Transmit timeout&n; */
DECL|function|ewrk3_timeout
r_static
r_void
id|ewrk3_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|u_char
id|icr
comma
id|csr
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;hard_strapped
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: transmit timed/locked out, status %04x, resetting.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   ** Mask all board interrupts&n;&t;&t; */
id|DISABLE_IRQs
suffix:semicolon
multiline_comment|/*&n;&t;&t;   ** Stop the TX and RX...&n;&t;&t; */
id|STOP_EWRK3
suffix:semicolon
id|ewrk3_init
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   ** Unmask EWRK3 board interrupts&n;&t;&t; */
id|ENABLE_IRQs
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   ** Writes a socket buffer to the free page queue&n; */
DECL|function|ewrk3_queue_pkt
r_static
r_int
id|ewrk3_queue_pkt
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u_long
id|buf
op_assign
l_int|0
suffix:semicolon
id|u_char
id|icr
suffix:semicolon
id|u_char
id|page
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|lp-&gt;hw_lock
)paren
suffix:semicolon
id|DISABLE_IRQs
suffix:semicolon
multiline_comment|/* if no resources available, exit, request packet be queued */
r_if
c_cond
(paren
id|inb
(paren
id|EWRK3_FMQC
)paren
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: ewrk3_queue_pkt(): No free resources...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: ewrk3_queue_pkt(): CSR: %02x ICR: %02x FMQC: %02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
(paren
id|EWRK3_CSR
)paren
comma
id|inb
(paren
id|EWRK3_ICR
)paren
comma
id|inb
(paren
id|EWRK3_FMQC
)paren
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; ** Get a free page from the FMQ&n;&t; */
r_if
c_cond
(paren
(paren
id|page
op_assign
id|inb
(paren
id|EWRK3_FMQ
)paren
)paren
op_ge
id|lp-&gt;mPage
)paren
(brace
id|printk
(paren
l_string|&quot;ewrk3_queue_pkt(): Invalid free memory page (%d).&bslash;n&quot;
comma
(paren
id|u_char
)paren
id|page
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; ** Set up shared memory window and pointer into the window&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
(paren
id|page
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_2K
)paren
(brace
id|buf
op_assign
id|lp-&gt;shmem_base
suffix:semicolon
id|outb
(paren
id|page
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_32K
)paren
(brace
id|buf
op_assign
(paren
(paren
(paren
(paren
r_int
)paren
id|page
op_lshift
l_int|11
)paren
op_amp
l_int|0x7800
)paren
op_plus
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|outb
(paren
(paren
id|page
op_rshift
l_int|4
)paren
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_64K
)paren
(brace
id|buf
op_assign
(paren
(paren
(paren
(paren
r_int
)paren
id|page
op_lshift
l_int|11
)paren
op_amp
l_int|0xf800
)paren
op_plus
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|outb
(paren
(paren
id|page
op_rshift
l_int|5
)paren
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: Oops - your private data area is hosed!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; ** Set up the buffer control structures and copy the data from&n;&t; ** the socket buffer to the shared memory .&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
r_int
id|i
suffix:semicolon
id|u_char
op_star
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
id|outb
(paren
(paren
r_char
)paren
(paren
id|TCR_QMODE
op_or
id|TCR_PAD
op_or
id|TCR_IFC
)paren
comma
id|EWRK3_DATA
)paren
suffix:semicolon
id|outb
(paren
(paren
r_char
)paren
(paren
id|skb-&gt;len
op_amp
l_int|0xff
)paren
comma
id|EWRK3_DATA
)paren
suffix:semicolon
id|outb
(paren
(paren
r_char
)paren
(paren
(paren
id|skb-&gt;len
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
id|EWRK3_DATA
)paren
suffix:semicolon
id|outb
(paren
(paren
r_char
)paren
l_int|0x04
comma
id|EWRK3_DATA
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
(paren
op_star
id|p
op_increment
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
id|outb
(paren
id|page
comma
id|EWRK3_TQ
)paren
suffix:semicolon
multiline_comment|/* Start sending pkt */
)brace
r_else
(brace
id|isa_writeb
(paren
(paren
r_char
)paren
(paren
id|TCR_QMODE
op_or
id|TCR_PAD
op_or
id|TCR_IFC
)paren
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* ctrl byte */
id|buf
op_add_assign
l_int|1
suffix:semicolon
id|isa_writeb
(paren
(paren
r_char
)paren
(paren
id|skb-&gt;len
op_amp
l_int|0xff
)paren
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* length (16 bit xfer) */
id|buf
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;txc
)paren
(brace
id|isa_writeb
(paren
(paren
r_char
)paren
(paren
(paren
(paren
id|skb-&gt;len
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
op_or
id|XCT
)paren
comma
id|buf
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|1
suffix:semicolon
id|isa_writeb
(paren
l_int|0x04
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* index byte */
id|buf
op_add_assign
l_int|1
suffix:semicolon
id|isa_writeb
(paren
l_int|0x00
comma
(paren
id|buf
op_plus
id|skb-&gt;len
)paren
)paren
suffix:semicolon
multiline_comment|/* Write the XCT flag */
id|isa_memcpy_toio
(paren
id|buf
comma
id|skb-&gt;data
comma
id|PRELOAD
)paren
suffix:semicolon
multiline_comment|/* Write PRELOAD bytes */
id|outb
(paren
id|page
comma
id|EWRK3_TQ
)paren
suffix:semicolon
multiline_comment|/* Start sending pkt */
id|isa_memcpy_toio
(paren
id|buf
op_plus
id|PRELOAD
comma
id|skb-&gt;data
op_plus
id|PRELOAD
comma
id|skb-&gt;len
op_minus
id|PRELOAD
)paren
suffix:semicolon
id|isa_writeb
(paren
l_int|0xff
comma
(paren
id|buf
op_plus
id|skb-&gt;len
)paren
)paren
suffix:semicolon
multiline_comment|/* Write the XCT flag */
)brace
r_else
(brace
id|isa_writeb
(paren
(paren
r_char
)paren
(paren
(paren
id|skb-&gt;len
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
id|buf
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|1
suffix:semicolon
id|isa_writeb
(paren
l_int|0x04
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* index byte */
id|buf
op_add_assign
l_int|1
suffix:semicolon
id|isa_memcpy_toio
(paren
id|buf
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Write data bytes */
id|outb
(paren
id|page
comma
id|EWRK3_TQ
)paren
suffix:semicolon
multiline_comment|/* Start sending pkt */
)brace
)brace
id|ENABLE_IRQs
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|lp-&gt;hw_lock
)paren
suffix:semicolon
id|lp-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Check for free resources: stop Tx queue if there are none */
r_if
c_cond
(paren
id|inb
(paren
id|EWRK3_FMQC
)paren
op_eq
l_int|0
)paren
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
id|ENABLE_IRQs
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|lp-&gt;hw_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   ** The EWRK3 interrupt handler.&n; */
DECL|function|ewrk3_interrupt
r_static
id|irqreturn_t
id|ewrk3_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|ewrk3_private
op_star
id|lp
suffix:semicolon
id|u_long
id|iobase
suffix:semicolon
id|u_char
id|icr
comma
id|cr
comma
id|csr
suffix:semicolon
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* get the interrupt information */
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; ** Mask the EWRK3 board interrupts and turn on the LED&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|lp-&gt;hw_lock
)paren
suffix:semicolon
id|DISABLE_IRQs
suffix:semicolon
id|cr
op_assign
id|inb
c_func
(paren
id|EWRK3_CR
)paren
suffix:semicolon
id|cr
op_or_assign
id|lp-&gt;led_mask
suffix:semicolon
id|outb
c_func
(paren
id|cr
comma
id|EWRK3_CR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr
op_amp
id|CSR_RNE
)paren
multiline_comment|/* Rx interrupt (packet[s] arrived) */
id|ewrk3_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr
op_amp
id|CSR_TNE
)paren
multiline_comment|/* Tx interrupt (packet sent) */
id|ewrk3_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; ** Now deal with the TX/RX disable flags. These are set when there&n;&t; ** are no more resources. If resources free up then enable these&n;&t; ** interrupts, otherwise mask them - failure to do this will result&n;&t; ** in the system hanging in an interrupt loop.&n;&t; */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
)paren
(brace
multiline_comment|/* any resources available? */
id|lp-&gt;irq_mask
op_or_assign
id|ICR_TXDM
op_or
id|ICR_RXDM
suffix:semicolon
multiline_comment|/* enable the interrupt source */
id|csr
op_and_assign
op_complement
(paren
id|CSR_TXD
op_or
id|CSR_RXD
)paren
suffix:semicolon
multiline_comment|/* ensure restart of a stalled TX or RX */
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;irq_mask
op_and_assign
op_complement
(paren
id|ICR_TXDM
op_or
id|ICR_RXDM
)paren
suffix:semicolon
multiline_comment|/* disable the interrupt source */
)brace
multiline_comment|/* Unmask the EWRK3 board interrupts and turn off the LED */
id|cr
op_and_assign
op_complement
(paren
id|lp-&gt;led_mask
)paren
suffix:semicolon
id|outb
c_func
(paren
id|cr
comma
id|EWRK3_CR
)paren
suffix:semicolon
id|ENABLE_IRQs
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;hw_lock
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* Called with lp-&gt;hw_lock held */
DECL|function|ewrk3_rx
r_static
r_int
id|ewrk3_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_char
id|page
suffix:semicolon
id|u_long
id|buf
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_RQC
)paren
op_logical_and
op_logical_neg
id|status
)paren
(brace
multiline_comment|/* Whilst there&squot;s incoming data */
r_if
c_cond
(paren
(paren
id|page
op_assign
id|inb
c_func
(paren
id|EWRK3_RQ
)paren
)paren
OL
id|lp-&gt;mPage
)paren
(brace
multiline_comment|/* Get next entry&squot;s buffer page */
multiline_comment|/*&n;&t;&t;&t;   ** Set up shared memory window and pointer into the window&n;&t;&t;&t; */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
id|page
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_2K
)paren
(brace
id|buf
op_assign
id|lp-&gt;shmem_base
suffix:semicolon
id|outb
c_func
(paren
id|page
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_32K
)paren
(brace
id|buf
op_assign
(paren
(paren
(paren
(paren
r_int
)paren
id|page
op_lshift
l_int|11
)paren
op_amp
l_int|0x7800
)paren
op_plus
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|page
op_rshift
l_int|4
)paren
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_64K
)paren
(brace
id|buf
op_assign
(paren
(paren
(paren
(paren
r_int
)paren
id|page
op_lshift
l_int|11
)paren
op_amp
l_int|0xf800
)paren
op_plus
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|page
op_rshift
l_int|5
)paren
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Oops - your private data area is hosed!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_char
id|rx_status
suffix:semicolon
r_int
id|pkt_len
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|rx_status
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
id|pkt_len
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
id|pkt_len
op_or_assign
(paren
(paren
id|u_short
)paren
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
id|rx_status
op_assign
id|isa_readb
c_func
(paren
id|buf
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|1
suffix:semicolon
id|pkt_len
op_assign
id|isa_readw
c_func
(paren
id|buf
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|rx_status
op_amp
id|R_ROK
)paren
)paren
(brace
multiline_comment|/* There was an error. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
multiline_comment|/* Update the error stats. */
r_if
c_cond
(paren
id|rx_status
op_amp
id|R_DBE
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rx_status
op_amp
id|R_CRC
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rx_status
op_amp
id|R_PLL
)paren
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|2
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Align to 16 bytes */
id|p
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
op_star
id|p
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
multiline_comment|/* dummy read */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pkt_len
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|isa_memcpy_fromio
c_func
(paren
id|p
comma
id|buf
comma
id|pkt_len
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|EWRK3_PKT_STAT_SZ
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pkt_len
OL
id|i
op_star
id|EWRK3_PKT_BIN_SZ
)paren
(brace
id|lp-&gt;pktStats.bins
(braket
id|i
)braket
op_increment
suffix:semicolon
id|i
op_assign
id|EWRK3_PKT_STAT_SZ
suffix:semicolon
)brace
)brace
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Look at the dest addr */
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* Multicast/Broadcast */
r_if
c_cond
(paren
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|p
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|p
(braket
l_int|2
)braket
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|p
(braket
l_int|4
)braket
op_eq
op_minus
l_int|1
)paren
)paren
(brace
id|lp-&gt;pktStats.broadcast
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;pktStats.multicast
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|p
(braket
l_int|0
)braket
op_eq
op_star
(paren
id|s16
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
op_logical_and
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|p
(braket
l_int|2
)braket
op_eq
op_star
(paren
id|s16
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
)paren
op_logical_and
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|p
(braket
l_int|4
)braket
op_eq
op_star
(paren
id|s16
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
)paren
)paren
(brace
id|lp-&gt;pktStats.unicast
op_increment
suffix:semicolon
)brace
id|lp-&gt;pktStats.bins
(braket
l_int|0
)braket
op_increment
suffix:semicolon
multiline_comment|/* Duplicates stats.rx_packets */
r_if
c_cond
(paren
id|lp-&gt;pktStats.bins
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Reset counters */
id|memset
c_func
(paren
op_amp
id|lp-&gt;pktStats
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;   ** Notify the upper protocol layers that there is another&n;&t;&t;&t;&t;&t;&t;   ** packet to handle&n;&t;&t;&t;&t;&t;&t; */
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;   ** Update stats&n;&t;&t;&t;&t;&t;&t; */
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Insufficient memory; nuking packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
multiline_comment|/* Really, deferred. */
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;   ** Return the received buffer to the free memory queue&n;&t;&t;&t; */
id|outb
c_func
(paren
id|page
comma
id|EWRK3_FMQ
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ewrk3_rx(): Illegal page number, page %d&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ewrk3_rx(): CSR: %02x ICR: %02x FMQC: %02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
comma
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
comma
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** Buffer sent - check for TX buffer errors.&n;** Called with lp-&gt;hw_lock held&n;*/
DECL|function|ewrk3_tx
r_static
r_int
id|ewrk3_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u_char
id|tx_status
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tx_status
op_assign
id|inb
c_func
(paren
id|EWRK3_TDQ
)paren
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* Whilst there&squot;s old buffers */
r_if
c_cond
(paren
id|tx_status
op_amp
id|T_VSTS
)paren
(brace
multiline_comment|/* The status is valid */
r_if
c_cond
(paren
id|tx_status
op_amp
id|T_TXE
)paren
(brace
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|T_NCL
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|T_LCL
)paren
id|lp-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|T_CTU
)paren
(brace
r_if
c_cond
(paren
(paren
id|tx_status
op_amp
id|T_COLL
)paren
op_xor
id|T_XUR
)paren
(brace
id|lp-&gt;pktStats.tx_underruns
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;pktStats.excessive_underruns
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|tx_status
op_amp
id|T_COLL
)paren
(brace
r_if
c_cond
(paren
(paren
id|tx_status
op_amp
id|T_COLL
)paren
op_xor
id|T_XCOLL
)paren
(brace
id|lp-&gt;stats.collisions
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;pktStats.excessive_collisions
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ewrk3_close
r_static
r_int
id|ewrk3_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u_char
id|icr
comma
id|csr
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ewrk3_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Shutting down ethercard, status was %2.2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   ** We stop the EWRK3 here... mask interrupts and stop TX &amp; RX&n;&t; */
id|DISABLE_IRQs
suffix:semicolon
id|STOP_EWRK3
suffix:semicolon
multiline_comment|/*&n;&t;   ** Clean out the TX and RX queues here (note that one entry&n;&t;   ** may get added to either the TXD or RX queues if the TX or RX&n;&t;   ** just starts processing a packet before the STOP_EWRK3 command&n;&t;   ** is received. This will be flushed in the ewrk3_open() call).&n;&t; */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_TQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_TDQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_RQ
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;hard_strapped
)paren
(brace
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ewrk3_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|ewrk3_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Null body since there is no framing error counter */
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Set or clear the multicast filter for this adapter.&n; */
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u_char
id|csr
suffix:semicolon
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|lp-&gt;mctbl
op_assign
(paren
r_char
op_star
)paren
id|PAGE0_HTE
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;mctbl
op_assign
(paren
r_char
op_star
)paren
(paren
id|lp-&gt;shmem_base
op_plus
id|PAGE0_HTE
)paren
suffix:semicolon
)brace
id|csr
op_and_assign
op_complement
(paren
id|CSR_PME
op_or
id|CSR_MCE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* set promiscuous mode */
id|csr
op_or_assign
id|CSR_PME
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|SetMulticastFilter
c_func
(paren
id|dev
)paren
suffix:semicolon
id|csr
op_or_assign
id|CSR_MCE
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   ** Calculate the hash code and update the logical address filter&n;   ** from a list of ethernet multicast addresses.&n;   ** Little endian crc one liner from Matt Thomas, DEC.&n;   **&n;   ** Note that when clearing the table, the broadcast bit must remain asserted&n;   ** to receive broadcast messages.&n; */
DECL|function|SetMulticastFilter
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|addrs
comma
id|bit
comma
id|byte
suffix:semicolon
r_int
op_star
id|p
op_assign
(paren
r_int
op_star
)paren
id|lp-&gt;mctbl
suffix:semicolon
id|u16
id|hashcode
suffix:semicolon
id|u32
id|crc
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|lp-&gt;hw_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|EEPROM_OFFSET
c_func
(paren
id|lp-&gt;mctbl
)paren
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
l_int|0xff
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* memset didn&squot;t work here */
id|isa_writew
c_func
(paren
l_int|0xffff
comma
(paren
r_int
)paren
id|p
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Clear table except for broadcast bit */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|4
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
l_int|0x00
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x80
comma
id|EWRK3_DATA
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
multiline_comment|/* insert the broadcast bit */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
l_int|0x00
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|isa_memset_io
c_func
(paren
(paren
r_int
)paren
id|lp-&gt;mctbl
comma
l_int|0
comma
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
id|isa_writeb
c_func
(paren
l_int|0x80
comma
(paren
r_int
)paren
(paren
id|lp-&gt;mctbl
op_plus
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|4
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Update table */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* for each address in the list */
id|addrs
op_assign
id|dmi-&gt;dmi_addr
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|addrs
op_amp
l_int|0x01
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* multicast address? */
id|crc
op_assign
id|ether_crc_le
c_func
(paren
id|ETH_ALEN
comma
id|addrs
)paren
suffix:semicolon
id|hashcode
op_assign
id|crc
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|9
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* hashcode is 9 LSb of CRC */
id|byte
op_assign
id|hashcode
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* bit[3-8] -&gt; byte in filter */
id|bit
op_assign
l_int|1
op_lshift
(paren
id|hashcode
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/* bit[0-2] -&gt; bit in byte */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|u_char
id|tmp
suffix:semicolon
id|outw
c_func
(paren
(paren
r_int
)paren
(paren
(paren
r_int
)paren
id|lp-&gt;mctbl
)paren
op_plus
id|byte
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
id|tmp
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
id|tmp
op_or_assign
id|bit
suffix:semicolon
id|outw
c_func
(paren
(paren
r_int
)paren
(paren
(paren
r_int
)paren
id|lp-&gt;mctbl
)paren
op_plus
id|byte
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tmp
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
r_else
(brace
id|isa_writeb
c_func
(paren
id|isa_readb
c_func
(paren
(paren
r_int
)paren
(paren
id|lp-&gt;mctbl
op_plus
id|byte
)paren
)paren
op_or
id|bit
comma
(paren
r_int
)paren
(paren
id|lp-&gt;mctbl
op_plus
id|byte
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|lp-&gt;hw_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   ** ISA bus I/O device probe&n; */
DECL|function|isa_probe
r_static
r_int
id|__init
id|isa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|ioaddr
)paren
(brace
r_int
id|i
op_assign
id|num_ewrks3s
comma
id|maxSlots
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|u_long
id|iobase
suffix:semicolon
r_if
c_cond
(paren
id|ioaddr
op_ge
l_int|0x400
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|ioaddr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Autoprobing */
id|iobase
op_assign
id|EWRK3_IO_BASE
suffix:semicolon
multiline_comment|/* Get the first slot address */
id|maxSlots
op_assign
l_int|24
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Probe a specific location */
id|iobase
op_assign
id|ioaddr
suffix:semicolon
id|maxSlots
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
(paren
id|i
OL
id|maxSlots
)paren
op_logical_and
(paren
id|dev
op_ne
l_int|NULL
)paren
suffix:semicolon
id|iobase
op_add_assign
id|EWRK3_IOP_INC
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|request_region
c_func
(paren
id|iobase
comma
id|EWRK3_TOTAL_SIZE
comma
id|DRV_NAME
)paren
)paren
(brace
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|iobase
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|ret
op_assign
id|ewrk3_hw_init
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_break
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
)brace
id|release_region
c_func
(paren
id|iobase
comma
id|EWRK3_TOTAL_SIZE
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;   ** EISA bus I/O device probe. Probe from slot 1 since slot 0 is usually&n;   ** the motherboard.&n; */
DECL|function|eisa_probe
r_static
r_int
id|__init
id|eisa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|ioaddr
)paren
(brace
r_int
id|i
comma
id|maxSlots
suffix:semicolon
id|u_long
id|iobase
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|ioaddr
OL
l_int|0x1000
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|ioaddr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Autoprobing */
id|iobase
op_assign
id|EISA_SLOT_INC
suffix:semicolon
multiline_comment|/* Get the first slot address */
id|i
op_assign
l_int|1
suffix:semicolon
id|maxSlots
op_assign
id|MAX_EISA_SLOTS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Probe a specific location */
id|iobase
op_assign
id|ioaddr
suffix:semicolon
id|i
op_assign
(paren
id|ioaddr
op_rshift
l_int|12
)paren
suffix:semicolon
id|maxSlots
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
(paren
id|i
OL
id|maxSlots
)paren
op_logical_and
(paren
id|dev
op_ne
l_int|NULL
)paren
suffix:semicolon
id|i
op_increment
comma
id|iobase
op_add_assign
id|EISA_SLOT_INC
)paren
(brace
r_if
c_cond
(paren
id|EISA_signature
c_func
(paren
id|name
comma
id|EISA_ID
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|request_region
c_func
(paren
id|iobase
comma
id|EWRK3_TOTAL_SIZE
comma
id|DRV_NAME
)paren
op_logical_and
id|DevicePresent
c_func
(paren
id|iobase
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|ret
op_assign
id|ewrk3_hw_init
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_break
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
)brace
id|release_region
c_func
(paren
id|iobase
comma
id|EWRK3_TOTAL_SIZE
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Read the EWRK3 EEPROM using this routine&n; */
DECL|function|Read_EEPROM
r_static
r_int
id|Read_EEPROM
c_func
(paren
id|u_long
id|iobase
comma
id|u_char
id|eaddr
)paren
(brace
r_int
id|i
suffix:semicolon
id|outb
c_func
(paren
(paren
id|eaddr
op_amp
l_int|0x3f
)paren
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
multiline_comment|/* set up 6 bits of address info */
id|outb
c_func
(paren
id|EEPROM_RD
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
multiline_comment|/* issue read command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5000
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* wait 1msec */
r_return
id|inw
c_func
(paren
id|EWRK3_EPROM1
)paren
suffix:semicolon
multiline_comment|/* 16 bits data return */
)brace
multiline_comment|/*&n;   ** Write the EWRK3 EEPROM using this routine&n; */
DECL|function|Write_EEPROM
r_static
r_int
id|Write_EEPROM
c_func
(paren
r_int
id|data
comma
id|u_long
id|iobase
comma
id|u_char
id|eaddr
)paren
(brace
r_int
id|i
suffix:semicolon
id|outb
c_func
(paren
id|EEPROM_WR_EN
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
multiline_comment|/* issue write enable command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5000
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* wait 1msec */
id|outw
c_func
(paren
id|data
comma
id|EWRK3_EPROM1
)paren
suffix:semicolon
multiline_comment|/* write data to register */
id|outb
c_func
(paren
(paren
id|eaddr
op_amp
l_int|0x3f
)paren
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
multiline_comment|/* set up 6 bits of address info */
id|outb
c_func
(paren
id|EEPROM_WR
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
multiline_comment|/* issue write command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|75000
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* wait 15msec */
id|outb
c_func
(paren
id|EEPROM_WR_DIS
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
multiline_comment|/* issue write disable command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5000
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* wait 1msec */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Look for a particular board name in the on-board EEPROM.&n; */
DECL|function|EthwrkSignature
r_static
r_void
id|__init
id|EthwrkSignature
c_func
(paren
r_char
op_star
id|name
comma
r_char
op_star
id|eeprom_image
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|signatures
(braket
)braket
op_assign
id|EWRK3_SIGNATURE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|signatures
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|eeprom_image
op_plus
id|EEPROM_PNAME7
comma
id|signatures
(braket
id|i
)braket
comma
id|strlen
c_func
(paren
id|signatures
(braket
id|i
)braket
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|signatures
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|memcpy
c_func
(paren
id|name
comma
id|eeprom_image
op_plus
id|EEPROM_PNAME7
comma
id|EWRK3_STRLEN
)paren
suffix:semicolon
id|name
(braket
id|EWRK3_STRLEN
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_else
id|name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Look for a special sequence in the Ethernet station address PROM that&n;   ** is common across all EWRK3 products.&n;   **&n;   ** Search the Ethernet address ROM for the signature. Since the ROM address&n;   ** counter can start at an arbitrary point, the search must include the entire&n;   ** probe sequence length plus the (length_of_the_signature - 1).&n;   ** Stop the search IMMEDIATELY after the signature is found so that the&n;   ** PROM address counter is correctly positioned at the start of the&n;   ** ethernet address for later read out.&n; */
DECL|function|DevicePresent
r_static
r_int
id|__init
id|DevicePresent
c_func
(paren
id|u_long
id|iobase
)paren
(brace
r_union
(brace
r_struct
(brace
id|u32
id|a
suffix:semicolon
id|u32
id|b
suffix:semicolon
)brace
id|llsig
suffix:semicolon
r_char
id|Sig
(braket
r_sizeof
(paren
id|u32
)paren
op_lshift
l_int|1
)braket
suffix:semicolon
)brace
id|dev
suffix:semicolon
r_int
id|sigLength
suffix:semicolon
r_char
id|data
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|dev.llsig.a
op_assign
id|ETH_PROM_SIG
suffix:semicolon
id|dev.llsig.b
op_assign
id|ETH_PROM_SIG
suffix:semicolon
id|sigLength
op_assign
r_sizeof
(paren
id|u32
)paren
op_lshift
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sigLength
op_logical_and
id|i
OL
id|PROBE_LENGTH
op_plus
id|sigLength
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev.Sig
(braket
id|j
)braket
op_eq
id|data
)paren
(brace
multiline_comment|/* track signature */
id|j
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lost signature; begin search again */
r_if
c_cond
(paren
id|data
op_eq
id|dev.Sig
(braket
l_int|0
)braket
)paren
(brace
id|j
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|j
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|j
op_ne
id|sigLength
)paren
(brace
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* search failed */
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|function|get_hw_addr
r_static
id|u_char
id|__init
id|get_hw_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
op_star
id|eeprom_image
comma
r_char
id|chipType
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
id|u_short
id|chksum
suffix:semicolon
id|u_char
id|crc
comma
id|lfsr
comma
id|sd
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u16
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|chipType
op_eq
id|LeMAC2
)paren
(brace
r_for
c_loop
(paren
id|crc
op_assign
l_int|0x6a
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ETH_ALEN
suffix:semicolon
id|j
op_increment
)paren
(brace
id|sd
op_assign
id|dev-&gt;dev_addr
(braket
id|j
)braket
op_assign
id|eeprom_image
(braket
id|EEPROM_PADDR0
op_plus
id|j
)braket
suffix:semicolon
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|j
)braket
comma
id|EWRK3_PAR0
op_plus
id|j
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|8
suffix:semicolon
id|k
op_increment
comma
id|sd
op_rshift_assign
l_int|1
)paren
(brace
id|lfsr
op_assign
(paren
(paren
(paren
(paren
id|crc
op_amp
l_int|0x02
)paren
op_rshift
l_int|1
)paren
op_xor
(paren
id|crc
op_amp
l_int|0x01
)paren
)paren
op_xor
(paren
id|sd
op_amp
l_int|0x01
)paren
)paren
op_lshift
l_int|7
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|1
)paren
op_plus
id|lfsr
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|crc
op_ne
id|eeprom_image
(braket
id|EEPROM_PA_CRC
)braket
)paren
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|k
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
)paren
(brace
id|k
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
l_int|0xffff
)paren
id|k
op_sub_assign
l_int|0xffff
suffix:semicolon
id|k
op_add_assign
(paren
id|u_char
)paren
(paren
id|tmp
op_assign
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|EWRK3_PAR0
op_plus
id|i
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|k
op_add_assign
(paren
id|u_short
)paren
(paren
(paren
id|tmp
op_assign
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|EWRK3_PAR0
op_plus
id|i
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
l_int|0xffff
)paren
id|k
op_sub_assign
l_int|0xffff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_eq
l_int|0xffff
)paren
id|k
op_assign
l_int|0
suffix:semicolon
id|chksum
op_assign
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
suffix:semicolon
id|chksum
op_or_assign
(paren
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_ne
id|chksum
)paren
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Look for a particular board name in the EISA configuration space&n; */
DECL|function|EISA_signature
r_static
r_int
id|__init
id|EISA_signature
c_func
(paren
r_char
op_star
id|name
comma
id|s32
id|eisa_id
)paren
(brace
id|u_long
id|i
suffix:semicolon
r_char
op_star
id|signatures
(braket
)braket
op_assign
id|EWRK3_SIGNATURE
suffix:semicolon
r_char
id|ManCode
(braket
id|EWRK3_STRLEN
)braket
suffix:semicolon
r_union
(brace
id|s32
id|ID
suffix:semicolon
r_char
id|Id
(braket
l_int|4
)braket
suffix:semicolon
)brace
id|Eisa
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
op_star
id|name
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Eisa.Id
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|eisa_id
op_plus
id|i
)paren
suffix:semicolon
)brace
id|ManCode
(braket
l_int|0
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|0
)braket
op_rshift
l_int|2
)paren
op_amp
l_int|0x1f
)paren
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ManCode
(braket
l_int|1
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|1
)braket
op_amp
l_int|0xe0
)paren
op_rshift
l_int|5
)paren
op_plus
(paren
(paren
id|Eisa.Id
(braket
l_int|0
)braket
op_amp
l_int|0x03
)paren
op_lshift
l_int|3
)paren
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ManCode
(braket
l_int|2
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|2
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|3
)braket
op_assign
(paren
(paren
id|Eisa.Id
(braket
l_int|2
)braket
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|4
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|3
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|5
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
op_star
id|signatures
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_logical_and
(paren
op_star
id|name
op_eq
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|ManCode
comma
id|signatures
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|strcpy
c_func
(paren
id|name
comma
id|ManCode
)paren
suffix:semicolon
id|status
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
multiline_comment|/* return the device name string */
)brace
DECL|function|ewrk3_get_drvinfo
r_static
r_void
id|ewrk3_get_drvinfo
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ethtool_drvinfo
op_star
id|info
)paren
(brace
r_int
id|fwrev
op_assign
id|Read_EEPROM
c_func
(paren
id|dev-&gt;base_addr
comma
id|EEPROM_REVLVL
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|info-&gt;driver
comma
id|DRV_NAME
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|info-&gt;version
comma
id|DRV_VERSION
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|info-&gt;fw_version
comma
l_string|&quot;%d&quot;
comma
id|fwrev
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|info-&gt;bus_info
comma
l_string|&quot;N/A&quot;
)paren
suffix:semicolon
id|info-&gt;eedump_len
op_assign
id|EEPROM_MAX
suffix:semicolon
)brace
DECL|function|ewrk3_get_settings
r_static
r_int
id|ewrk3_get_settings
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ethtool_cmd
op_star
id|ecmd
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u8
id|cr
op_assign
id|inb
c_func
(paren
id|EWRK3_CR
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|lp-&gt;adapter_name
(braket
l_int|4
)braket
)paren
(brace
r_case
l_char|&squot;3&squot;
suffix:colon
multiline_comment|/* DE203 */
id|ecmd-&gt;supported
op_assign
id|SUPPORTED_BNC
suffix:semicolon
id|ecmd-&gt;port
op_assign
id|PORT_BNC
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;4&squot;
suffix:colon
multiline_comment|/* DE204 */
id|ecmd-&gt;supported
op_assign
id|SUPPORTED_TP
suffix:semicolon
id|ecmd-&gt;port
op_assign
id|PORT_TP
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;5&squot;
suffix:colon
multiline_comment|/* DE205 */
id|ecmd-&gt;supported
op_assign
id|SUPPORTED_TP
op_or
id|SUPPORTED_BNC
op_or
id|SUPPORTED_AUI
suffix:semicolon
id|ecmd-&gt;autoneg
op_assign
op_logical_neg
(paren
id|cr
op_amp
id|CR_APD
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Port is only valid if autoneg is disabled&n;&t;&t;** and even then we don&squot;t know if AUI is jumpered.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|ecmd-&gt;autoneg
)paren
id|ecmd-&gt;port
op_assign
(paren
id|cr
op_amp
id|CR_PSEL
)paren
ques
c_cond
id|PORT_BNC
suffix:colon
id|PORT_TP
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ecmd-&gt;supported
op_or_assign
id|SUPPORTED_10baseT_Half
suffix:semicolon
id|ecmd-&gt;speed
op_assign
id|SPEED_10
suffix:semicolon
id|ecmd-&gt;duplex
op_assign
id|DUPLEX_HALF
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ewrk3_set_settings
r_static
r_int
id|ewrk3_set_settings
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ethtool_cmd
op_star
id|ecmd
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|cr
suffix:semicolon
multiline_comment|/* DE205 is the only card with anything to set */
r_if
c_cond
(paren
id|lp-&gt;adapter_name
(braket
l_int|4
)braket
op_ne
l_char|&squot;5&squot;
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* Sanity-check parameters */
r_if
c_cond
(paren
id|ecmd-&gt;speed
op_ne
id|SPEED_10
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ecmd-&gt;port
op_ne
id|PORT_TP
op_logical_and
id|ecmd-&gt;port
op_ne
id|PORT_BNC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* AUI is not software-selectable */
r_if
c_cond
(paren
id|ecmd-&gt;transceiver
op_ne
id|XCVR_INTERNAL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ecmd-&gt;duplex
op_ne
id|DUPLEX_HALF
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ecmd-&gt;phy_address
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
id|cr
op_assign
id|inb
c_func
(paren
id|EWRK3_CR
)paren
suffix:semicolon
multiline_comment|/* If Autoneg is set, change to Auto Port mode */
multiline_comment|/* Otherwise, disable Auto Port and set port explicitly */
r_if
c_cond
(paren
id|ecmd-&gt;autoneg
)paren
(brace
id|cr
op_and_assign
op_complement
id|CR_APD
suffix:semicolon
)brace
r_else
(brace
id|cr
op_or_assign
id|CR_APD
suffix:semicolon
r_if
c_cond
(paren
id|ecmd-&gt;port
op_eq
id|PORT_TP
)paren
id|cr
op_and_assign
op_complement
id|CR_PSEL
suffix:semicolon
multiline_comment|/* Force TP */
r_else
id|cr
op_or_assign
id|CR_PSEL
suffix:semicolon
multiline_comment|/* Force BNC */
)brace
multiline_comment|/* Commit the changes */
id|outb
c_func
(paren
id|cr
comma
id|EWRK3_CR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ewrk3_get_link
r_static
id|u32
id|ewrk3_get_link
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u8
id|cmr
op_assign
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
suffix:semicolon
multiline_comment|/* DE203 has BNC only and link status does not apply */
multiline_comment|/* On DE204 this is always valid since TP is the only port. */
multiline_comment|/* On DE205 this reflects TP status even if BNC or AUI is selected. */
r_return
op_logical_neg
(paren
id|cmr
op_amp
id|CMR_LINK
)paren
suffix:semicolon
)brace
DECL|function|ewrk3_phys_id
r_static
r_int
id|ewrk3_phys_id
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|data
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|cr
suffix:semicolon
r_int
id|count
suffix:semicolon
multiline_comment|/* Toggle LED 4x per second */
id|count
op_assign
id|data
op_lshift
l_int|2
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Bail if a PHYS_ID is already in progress */
r_if
c_cond
(paren
id|lp-&gt;led_mask
op_eq
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Prevent ISR from twiddling the LED */
id|lp-&gt;led_mask
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
multiline_comment|/* Toggle the LED */
id|cr
op_assign
id|inb
c_func
(paren
id|EWRK3_CR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|cr
op_xor
id|CR_LED
comma
id|EWRK3_CR
)paren
suffix:semicolon
multiline_comment|/* Wait a little while */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_rshift
l_int|2
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Exit if we got a signal */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
)brace
id|lp-&gt;led_mask
op_assign
id|CR_LED
suffix:semicolon
id|cr
op_assign
id|inb
c_func
(paren
id|EWRK3_CR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|cr
op_amp
op_complement
id|CR_LED
comma
id|EWRK3_CR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|signal_pending
c_func
(paren
id|current
)paren
ques
c_cond
op_minus
id|ERESTARTSYS
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|variable|ethtool_ops_203
r_static
r_struct
id|ethtool_ops
id|ethtool_ops_203
op_assign
(brace
dot
id|get_drvinfo
op_assign
id|ewrk3_get_drvinfo
comma
dot
id|get_settings
op_assign
id|ewrk3_get_settings
comma
dot
id|set_settings
op_assign
id|ewrk3_set_settings
comma
dot
id|phys_id
op_assign
id|ewrk3_phys_id
comma
)brace
suffix:semicolon
DECL|variable|ethtool_ops
r_static
r_struct
id|ethtool_ops
id|ethtool_ops
op_assign
(brace
dot
id|get_drvinfo
op_assign
id|ewrk3_get_drvinfo
comma
dot
id|get_settings
op_assign
id|ewrk3_get_settings
comma
dot
id|set_settings
op_assign
id|ewrk3_set_settings
comma
dot
id|get_link
op_assign
id|ewrk3_get_link
comma
dot
id|phys_id
op_assign
id|ewrk3_phys_id
comma
)brace
suffix:semicolon
multiline_comment|/*&n;   ** Perform IOCTL call functions here. Some are privileged operations and the&n;   ** effective uid is checked in those cases.&n; */
DECL|function|ewrk3_ioctl
r_static
r_int
id|ewrk3_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|ewrk3_ioctl
op_star
id|ioc
op_assign
(paren
r_struct
id|ewrk3_ioctl
op_star
)paren
op_amp
id|rq-&gt;ifr_ifru
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_char
id|csr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_union
id|ewrk3_addr
(brace
id|u_char
id|addr
(braket
id|HASH_TABLE_LEN
op_star
id|ETH_ALEN
)braket
suffix:semicolon
id|u_short
id|val
(braket
(paren
id|HASH_TABLE_LEN
op_star
id|ETH_ALEN
)paren
op_rshift
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
r_union
id|ewrk3_addr
op_star
id|tmp
suffix:semicolon
multiline_comment|/* All we handle are private IOCTLs */
r_if
c_cond
(paren
id|cmd
op_ne
id|EWRK3IOCTL
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|tmp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_union
id|ewrk3_addr
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ioc-&gt;cmd
)paren
(brace
r_case
id|EWRK3_GET_HWADDR
suffix:colon
multiline_comment|/* Get the hardware address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp-&gt;addr
(braket
id|i
)braket
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
id|ioc-&gt;len
op_assign
id|ETH_ALEN
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp-&gt;addr
comma
id|ioc-&gt;len
)paren
)paren
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_SET_HWADDR
suffix:colon
multiline_comment|/* Set the hardware address */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_or_assign
(paren
id|CSR_TXD
op_or
id|CSR_RXD
)paren
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* Disable the TX and RX */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp-&gt;addr
comma
id|ioc-&gt;data
comma
id|ETH_ALEN
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|tmp-&gt;addr
(braket
id|i
)braket
suffix:semicolon
id|outb
c_func
(paren
id|tmp-&gt;addr
(braket
id|i
)braket
comma
id|EWRK3_PAR0
op_plus
id|i
)paren
suffix:semicolon
)brace
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_and_assign
op_complement
(paren
id|CSR_TXD
op_or
id|CSR_RXD
)paren
suffix:semicolon
multiline_comment|/* Enable the TX and RX */
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_SET_PROM
suffix:colon
multiline_comment|/* Set Promiscuous Mode */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_or_assign
id|CSR_PME
suffix:semicolon
id|csr
op_and_assign
op_complement
id|CSR_MCE
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_CLR_PROM
suffix:colon
multiline_comment|/* Clear Promiscuous Mode */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_and_assign
op_complement
id|CSR_PME
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_MCA
suffix:colon
multiline_comment|/* Get the multicast address table */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|PAGE0_HTE
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp-&gt;addr
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0
comma
id|EWRK3_MPR
)paren
suffix:semicolon
id|isa_memcpy_fromio
c_func
(paren
id|tmp-&gt;addr
comma
id|lp-&gt;shmem_base
op_plus
id|PAGE0_HTE
comma
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
id|ioc-&gt;len
op_assign
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp-&gt;addr
comma
id|ioc-&gt;len
)paren
)paren
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_SET_MCA
suffix:colon
multiline_comment|/* Set a multicast address */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_if
c_cond
(paren
id|ioc-&gt;len
OG
l_int|1024
)paren
(brace
id|status
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp-&gt;addr
comma
id|ioc-&gt;data
comma
id|ETH_ALEN
op_star
id|ioc-&gt;len
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_CLR_MCA
suffix:colon
multiline_comment|/* Clear all multicast addresses */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_MCA_EN
suffix:colon
multiline_comment|/* Enable multicast addressing */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_or_assign
id|CSR_MCE
suffix:semicolon
id|csr
op_and_assign
op_complement
id|CSR_PME
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_STATS
suffix:colon
(brace
multiline_comment|/* Get the driver statistics */
r_struct
id|ewrk3_stats
op_star
id|tmp_stats
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_stats
)paren
(brace
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmp_stats
comma
op_amp
id|lp-&gt;pktStats
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
id|ioc-&gt;len
op_assign
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp_stats
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
)paren
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|kfree
c_func
(paren
id|tmp_stats
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|EWRK3_CLR_STATS
suffix:colon
multiline_comment|/* Zero out the driver statistics */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|lp-&gt;pktStats
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;hw_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_CSR
suffix:colon
multiline_comment|/* Get the CSR Register contents */
id|tmp-&gt;addr
(braket
l_int|0
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|ioc-&gt;len
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp-&gt;addr
comma
id|ioc-&gt;len
)paren
)paren
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_SET_CSR
suffix:colon
multiline_comment|/* Set the CSR Register contents */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp-&gt;addr
comma
id|ioc-&gt;data
comma
l_int|1
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|outb
c_func
(paren
id|tmp-&gt;addr
(braket
l_int|0
)braket
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_EEPROM
suffix:colon
multiline_comment|/* Get the EEPROM contents */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|EEPROM_MAX
op_rshift
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp-&gt;val
(braket
id|i
)braket
op_assign
(paren
r_int
)paren
id|Read_EEPROM
c_func
(paren
id|iobase
comma
id|i
)paren
suffix:semicolon
)brace
id|i
op_assign
id|EEPROM_MAX
suffix:semicolon
id|tmp-&gt;addr
(braket
id|i
op_increment
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
suffix:semicolon
multiline_comment|/* Config/Management Reg. */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ETH_ALEN
suffix:semicolon
id|j
op_increment
)paren
(brace
id|tmp-&gt;addr
(braket
id|i
op_increment
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_PAR0
op_plus
id|j
)paren
suffix:semicolon
)brace
id|ioc-&gt;len
op_assign
id|EEPROM_MAX
op_plus
l_int|1
op_plus
id|ETH_ALEN
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp-&gt;addr
comma
id|ioc-&gt;len
)paren
)paren
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_SET_EEPROM
suffix:colon
multiline_comment|/* Set the EEPROM contents */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp-&gt;addr
comma
id|ioc-&gt;data
comma
id|EEPROM_MAX
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|EEPROM_MAX
op_rshift
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Write_EEPROM
c_func
(paren
id|tmp-&gt;val
(braket
id|i
)braket
comma
id|iobase
comma
id|i
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_CMR
suffix:colon
multiline_comment|/* Get the CMR Register contents */
id|tmp-&gt;addr
(braket
l_int|0
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
suffix:semicolon
id|ioc-&gt;len
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp-&gt;addr
comma
id|ioc-&gt;len
)paren
)paren
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_SET_TX_CUT_THRU
suffix:colon
multiline_comment|/* Set TX cut through mode */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|lp-&gt;txc
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_CLR_TX_CUT_THRU
suffix:colon
multiline_comment|/* Clear TX cut through mode */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|lp-&gt;txc
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|ewrk3_devs
r_static
r_struct
id|net_device
op_star
id|ewrk3_devs
(braket
id|MAX_NUM_EWRK3S
)braket
suffix:semicolon
DECL|variable|ndevs
r_static
r_int
id|ndevs
suffix:semicolon
DECL|variable|io
r_static
r_int
id|io
(braket
id|MAX_NUM_EWRK3S
op_plus
l_int|1
)braket
op_assign
(brace
l_int|0x300
comma
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* &squot;21&squot; below should really be &squot;MAX_NUM_EWRK3S&squot; */
id|module_param_array
c_func
(paren
id|io
comma
r_int
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|irq
comma
r_int
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|io
comma
l_string|&quot;EtherWORKS 3 I/O base address(es)&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|irq
comma
l_string|&quot;EtherWORKS 3 IRQ number(s)&quot;
)paren
suffix:semicolon
DECL|function|ewrk3_exit_module
r_static
id|__exit
r_void
id|ewrk3_exit_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ndevs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|unregister_netdev
c_func
(paren
id|ewrk3_devs
(braket
id|i
)braket
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|ewrk3_devs
(braket
id|i
)braket
op_member_access_from_pointer
id|base_addr
comma
id|EWRK3_TOTAL_SIZE
)paren
suffix:semicolon
id|free_netdev
c_func
(paren
id|ewrk3_devs
(braket
id|i
)braket
)paren
suffix:semicolon
id|ewrk3_devs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|ewrk3_init_module
r_static
id|__init
r_int
id|ewrk3_init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|io
(braket
id|i
)braket
op_logical_and
id|irq
(braket
id|i
)braket
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|alloc_etherdev
c_func
(paren
r_sizeof
(paren
r_struct
id|ewrk3_private
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ewrk3_probe1
c_func
(paren
id|dev
comma
id|io
(braket
id|i
)braket
comma
id|irq
(braket
id|i
)braket
)paren
op_ne
l_int|0
)paren
(brace
id|free_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ewrk3_devs
(braket
id|ndevs
op_increment
)braket
op_assign
id|dev
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_return
id|ndevs
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Hack for breakage in new module stuff */
DECL|variable|ewrk3_exit_module
id|module_exit
c_func
(paren
id|ewrk3_exit_module
)paren
suffix:semicolon
DECL|variable|ewrk3_init_module
id|module_init
c_func
(paren
id|ewrk3_init_module
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* MODULE */
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/linux/include -Wall -Wstrict-prototypes -fomit-frame-pointer -fno-strength-reduce -malign-loops=2 -malign-jumps=2 -malign-functions=2 -O2 -m486 -c ewrk3.c&quot;&n; *&n; *  compile-command: &quot;gcc -D__KERNEL__ -DMODULE -I/linux/include -Wall -Wstrict-prototypes -fomit-frame-pointer -fno-strength-reduce -malign-loops=2 -malign-jumps=2 -malign-functions=2 -O2 -m486 -c ewrk3.c&quot;&n; * End:&n; */
eof
