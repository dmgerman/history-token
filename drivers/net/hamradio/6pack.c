multiline_comment|/*&n; * 6pack.c&t;This module implements the 6pack protocol for kernel-based&n; *&t;&t;devices like TTY. It interfaces between a raw TTY and the&n; *&t;&t;kernel&squot;s AX.25 protocol layers.&n; *&n; * Authors:&t;Andreas K&#xfffd;nsgen &lt;ajk@iehk.rwth-aachen.de&gt;&n; *              Ralf Baechle DO1GRB &lt;ralf@linux-mips.org&gt;&n; *&n; * Quite a lot of stuff &quot;stolen&quot; by Joerg Reuter from slip.c, written by&n; *&n; *&t;&t;Laurence Culhane, &lt;loz@holmes.demon.co.uk&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uwalt.nl.mugnet.org&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;net/ax25.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|macro|SIXPACK_VERSION
mdefine_line|#define SIXPACK_VERSION    &quot;Revision: 0.3.0&quot;
multiline_comment|/* sixpack priority commands */
DECL|macro|SIXP_SEOF
mdefine_line|#define SIXP_SEOF&t;&t;0x40&t;/* start and end of a 6pack frame */
DECL|macro|SIXP_TX_URUN
mdefine_line|#define SIXP_TX_URUN&t;&t;0x48&t;/* transmit overrun */
DECL|macro|SIXP_RX_ORUN
mdefine_line|#define SIXP_RX_ORUN&t;&t;0x50&t;/* receive overrun */
DECL|macro|SIXP_RX_BUF_OVL
mdefine_line|#define SIXP_RX_BUF_OVL&t;&t;0x58&t;/* receive buffer overflow */
DECL|macro|SIXP_CHKSUM
mdefine_line|#define SIXP_CHKSUM&t;&t;0xFF&t;/* valid checksum of a 6pack frame */
multiline_comment|/* masks to get certain bits out of the status bytes sent by the TNC */
DECL|macro|SIXP_CMD_MASK
mdefine_line|#define SIXP_CMD_MASK&t;&t;0xC0
DECL|macro|SIXP_CHN_MASK
mdefine_line|#define SIXP_CHN_MASK&t;&t;0x07
DECL|macro|SIXP_PRIO_CMD_MASK
mdefine_line|#define SIXP_PRIO_CMD_MASK&t;0x80
DECL|macro|SIXP_STD_CMD_MASK
mdefine_line|#define SIXP_STD_CMD_MASK&t;0x40
DECL|macro|SIXP_PRIO_DATA_MASK
mdefine_line|#define SIXP_PRIO_DATA_MASK&t;0x38
DECL|macro|SIXP_TX_MASK
mdefine_line|#define SIXP_TX_MASK&t;&t;0x20
DECL|macro|SIXP_RX_MASK
mdefine_line|#define SIXP_RX_MASK&t;&t;0x10
DECL|macro|SIXP_RX_DCD_MASK
mdefine_line|#define SIXP_RX_DCD_MASK&t;0x18
DECL|macro|SIXP_LEDS_ON
mdefine_line|#define SIXP_LEDS_ON&t;&t;0x78
DECL|macro|SIXP_LEDS_OFF
mdefine_line|#define SIXP_LEDS_OFF&t;&t;0x60
DECL|macro|SIXP_CON
mdefine_line|#define SIXP_CON&t;&t;0x08
DECL|macro|SIXP_STA
mdefine_line|#define SIXP_STA&t;&t;0x10
DECL|macro|SIXP_FOUND_TNC
mdefine_line|#define SIXP_FOUND_TNC&t;&t;0xe9
DECL|macro|SIXP_CON_ON
mdefine_line|#define SIXP_CON_ON&t;&t;0x68
DECL|macro|SIXP_DCD_MASK
mdefine_line|#define SIXP_DCD_MASK&t;&t;0x08
DECL|macro|SIXP_DAMA_OFF
mdefine_line|#define SIXP_DAMA_OFF&t;&t;0
multiline_comment|/* default level 2 parameters */
DECL|macro|SIXP_TXDELAY
mdefine_line|#define SIXP_TXDELAY&t;&t;&t;(HZ/4)&t;/* in 1 s */
DECL|macro|SIXP_PERSIST
mdefine_line|#define SIXP_PERSIST&t;&t;&t;50&t;/* in 256ths */
DECL|macro|SIXP_SLOTTIME
mdefine_line|#define SIXP_SLOTTIME&t;&t;&t;(HZ/10)&t;/* in 1 s */
DECL|macro|SIXP_INIT_RESYNC_TIMEOUT
mdefine_line|#define SIXP_INIT_RESYNC_TIMEOUT&t;(3*HZ/2) /* in 1 s */
DECL|macro|SIXP_RESYNC_TIMEOUT
mdefine_line|#define SIXP_RESYNC_TIMEOUT&t;&t;5*HZ&t;/* in 1 s */
multiline_comment|/* 6pack configuration. */
DECL|macro|SIXP_NRUNIT
mdefine_line|#define SIXP_NRUNIT&t;&t;&t;31      /* MAX number of 6pack channels */
DECL|macro|SIXP_MTU
mdefine_line|#define SIXP_MTU&t;&t;&t;256&t;/* Default MTU */
DECL|enum|sixpack_flags
r_enum
id|sixpack_flags
(brace
DECL|enumerator|SIXPF_ERROR
id|SIXPF_ERROR
comma
multiline_comment|/* Parity, etc. error&t;*/
)brace
suffix:semicolon
DECL|struct|sixpack
r_struct
id|sixpack
(brace
multiline_comment|/* Various fields. */
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
multiline_comment|/* ptr to TTY structure&t;*/
DECL|member|dev
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* easy for intr handling  */
multiline_comment|/* These are pointers to the malloc()ed frame buffers. */
DECL|member|rbuff
r_int
r_char
op_star
id|rbuff
suffix:semicolon
multiline_comment|/* receiver buffer&t;*/
DECL|member|rcount
r_int
id|rcount
suffix:semicolon
multiline_comment|/* received chars counter  */
DECL|member|xbuff
r_int
r_char
op_star
id|xbuff
suffix:semicolon
multiline_comment|/* transmitter buffer&t;*/
DECL|member|xhead
r_int
r_char
op_star
id|xhead
suffix:semicolon
multiline_comment|/* next byte to XMIT */
DECL|member|xleft
r_int
id|xleft
suffix:semicolon
multiline_comment|/* bytes left in XMIT queue  */
DECL|member|raw_buf
r_int
r_char
id|raw_buf
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|cooked_buf
r_int
r_char
id|cooked_buf
(braket
l_int|400
)braket
suffix:semicolon
DECL|member|rx_count
r_int
r_int
id|rx_count
suffix:semicolon
DECL|member|rx_count_cooked
r_int
r_int
id|rx_count_cooked
suffix:semicolon
multiline_comment|/* 6pack interface statistics. */
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|mtu
r_int
id|mtu
suffix:semicolon
multiline_comment|/* Our mtu (to spot changes!) */
DECL|member|buffsize
r_int
id|buffsize
suffix:semicolon
multiline_comment|/* Max buffers sizes */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Flag values/ mode etc */
DECL|member|mode
r_int
r_char
id|mode
suffix:semicolon
multiline_comment|/* 6pack mode */
multiline_comment|/* 6pack stuff */
DECL|member|tx_delay
r_int
r_char
id|tx_delay
suffix:semicolon
DECL|member|persistence
r_int
r_char
id|persistence
suffix:semicolon
DECL|member|slottime
r_int
r_char
id|slottime
suffix:semicolon
DECL|member|duplex
r_int
r_char
id|duplex
suffix:semicolon
DECL|member|led_state
r_int
r_char
id|led_state
suffix:semicolon
DECL|member|status
r_int
r_char
id|status
suffix:semicolon
DECL|member|status1
r_int
r_char
id|status1
suffix:semicolon
DECL|member|status2
r_int
r_char
id|status2
suffix:semicolon
DECL|member|tx_enable
r_int
r_char
id|tx_enable
suffix:semicolon
DECL|member|tnc_ok
r_int
r_char
id|tnc_ok
suffix:semicolon
DECL|member|tx_t
r_struct
id|timer_list
id|tx_t
suffix:semicolon
DECL|member|resync_t
r_struct
id|timer_list
id|resync_t
suffix:semicolon
DECL|member|refcnt
id|atomic_t
id|refcnt
suffix:semicolon
DECL|member|dead_sem
r_struct
id|semaphore
id|dead_sem
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|AX25_6PACK_HEADER_LEN
mdefine_line|#define AX25_6PACK_HEADER_LEN 0
r_static
r_void
id|sp_start_tx_timer
c_func
(paren
r_struct
id|sixpack
op_star
)paren
suffix:semicolon
r_static
r_void
id|sixpack_decode
c_func
(paren
r_struct
id|sixpack
op_star
comma
r_int
r_char
(braket
)braket
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|encode_sixpack
c_func
(paren
r_int
r_char
op_star
comma
r_int
r_char
op_star
comma
r_int
comma
r_int
r_char
)paren
suffix:semicolon
r_static
r_int
id|sixpack_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; * perform the persistence/slottime algorithm for CSMA access. If the&n; * persistence check was successful, write the data to the serial driver.&n; * Note that in case of DAMA operation, the data is not sent here.&n; */
DECL|function|sp_xmit_on_air
r_static
r_void
id|sp_xmit_on_air
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|channel
suffix:semicolon
r_int
id|actual
suffix:semicolon
r_static
r_int
r_char
id|random
suffix:semicolon
id|random
op_assign
id|random
op_star
l_int|17
op_plus
l_int|41
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|sp-&gt;status1
op_amp
id|SIXP_DCD_MASK
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|random
OL
id|sp-&gt;persistence
)paren
)paren
(brace
id|sp-&gt;led_state
op_assign
l_int|0x70
suffix:semicolon
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
id|sp-&gt;tx_enable
op_assign
l_int|1
suffix:semicolon
id|actual
op_assign
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
id|sp-&gt;xbuff
comma
id|sp-&gt;status2
)paren
suffix:semicolon
id|sp-&gt;xleft
op_sub_assign
id|actual
suffix:semicolon
id|sp-&gt;xhead
op_add_assign
id|actual
suffix:semicolon
id|sp-&gt;led_state
op_assign
l_int|0x60
suffix:semicolon
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
id|sp-&gt;status2
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|sp_start_tx_timer
c_func
(paren
id|sp
)paren
suffix:semicolon
)brace
multiline_comment|/* ----&gt; 6pack timer interrupt handler and friends. &lt;---- */
DECL|function|sp_start_tx_timer
r_static
r_void
id|sp_start_tx_timer
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
r_int
id|when
op_assign
id|sp-&gt;slottime
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;tx_t
)paren
suffix:semicolon
id|sp-&gt;tx_t.data
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
id|sp-&gt;tx_t.function
op_assign
id|sp_xmit_on_air
suffix:semicolon
id|sp-&gt;tx_t.expires
op_assign
id|jiffies
op_plus
(paren
(paren
id|when
op_plus
l_int|1
)paren
op_star
id|HZ
)paren
op_div
l_int|100
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sp-&gt;tx_t
)paren
suffix:semicolon
)brace
multiline_comment|/* Encapsulate one AX.25 frame and stuff into a TTY queue. */
DECL|function|sp_encaps
r_static
r_void
id|sp_encaps
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
comma
r_int
r_char
op_star
id|icp
comma
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|msg
comma
op_star
id|p
op_assign
id|icp
suffix:semicolon
r_int
id|actual
comma
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|sp-&gt;mtu
)paren
(brace
multiline_comment|/* sp-&gt;mtu = AX25_MTU = max. PACLEN = 256 */
id|msg
op_assign
l_string|&quot;oversized transmit packet!&quot;
suffix:semicolon
r_goto
id|out_drop
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
OG
l_int|5
)paren
(brace
id|msg
op_assign
l_string|&quot;invalid KISS command&quot;
suffix:semicolon
r_goto
id|out_drop
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|len
OG
l_int|2
)paren
)paren
(brace
id|msg
op_assign
l_string|&quot;KISS control packet too long&quot;
suffix:semicolon
r_goto
id|out_drop
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|len
OL
l_int|15
)paren
)paren
(brace
id|msg
op_assign
l_string|&quot;bad AX.25 packet to transmit&quot;
suffix:semicolon
r_goto
id|out_drop
suffix:semicolon
)brace
id|count
op_assign
id|encode_sixpack
c_func
(paren
id|p
comma
id|sp-&gt;xbuff
comma
id|len
comma
id|sp-&gt;tx_delay
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|TTY_DO_WRITE_WAKEUP
comma
op_amp
id|sp-&gt;tty-&gt;flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|p
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|1
suffix:colon
id|sp-&gt;tx_delay
op_assign
id|p
(braket
l_int|1
)braket
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|2
suffix:colon
id|sp-&gt;persistence
op_assign
id|p
(braket
l_int|1
)braket
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|3
suffix:colon
id|sp-&gt;slottime
op_assign
id|p
(braket
l_int|1
)braket
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* ignored */
r_return
suffix:semicolon
r_case
l_int|5
suffix:colon
id|sp-&gt;duplex
op_assign
id|p
(braket
l_int|1
)braket
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * In case of fullduplex or DAMA operation, we don&squot;t take care about the&n;&t; * state of the DCD or of any timers, as the determination of the&n;&t; * correct time to send is the job of the AX.25 layer. We send&n;&t; * immediately after data has arrived.&n;&t; */
r_if
c_cond
(paren
id|sp-&gt;duplex
op_eq
l_int|1
)paren
(brace
id|sp-&gt;led_state
op_assign
l_int|0x70
suffix:semicolon
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
id|sp-&gt;tx_enable
op_assign
l_int|1
suffix:semicolon
id|actual
op_assign
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
id|sp-&gt;xbuff
comma
id|count
)paren
suffix:semicolon
id|sp-&gt;xleft
op_assign
id|count
op_minus
id|actual
suffix:semicolon
id|sp-&gt;xhead
op_assign
id|sp-&gt;xbuff
op_plus
id|actual
suffix:semicolon
id|sp-&gt;led_state
op_assign
l_int|0x60
suffix:semicolon
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|sp-&gt;xleft
op_assign
id|count
suffix:semicolon
id|sp-&gt;xhead
op_assign
id|sp-&gt;xbuff
suffix:semicolon
id|sp-&gt;status2
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;duplex
op_eq
l_int|0
)paren
id|sp_start_tx_timer
c_func
(paren
id|sp
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|out_drop
suffix:colon
id|sp-&gt;stats.tx_dropped
op_increment
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|sp-&gt;dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: %s - dropped.&bslash;n&quot;
comma
id|sp-&gt;dev-&gt;name
comma
id|msg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Encapsulate an IP datagram and kick it into a TTY queue. */
DECL|function|sp_xmit
r_static
r_int
id|sp_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* We were not busy, so we are now... :-) */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sp-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|sp_encaps
c_func
(paren
id|sp
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sp-&gt;lock
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sp_open_dev
r_static
r_int
id|sp_open_dev
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;tty
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Close the low-level part of the 6pack channel. */
DECL|function|sp_close
r_static
r_int
id|sp_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sp-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;tty
)paren
(brace
multiline_comment|/* TTY discipline is running. */
id|clear_bit
c_func
(paren
id|TTY_DO_WRITE_WAKEUP
comma
op_amp
id|sp-&gt;tty-&gt;flags
)paren
suffix:semicolon
)brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sp-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Return the frame type ID */
DECL|function|sp_header
r_static
r_int
id|sp_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
macro_line|#ifdef CONFIG_INET
r_if
c_cond
(paren
id|type
op_ne
id|htons
c_func
(paren
id|ETH_P_AX25
)paren
)paren
r_return
id|ax25_encapsulate
c_func
(paren
id|skb
comma
id|dev
comma
id|type
comma
id|daddr
comma
id|saddr
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sp_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|sp_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_amp
id|sp-&gt;stats
suffix:semicolon
)brace
DECL|function|sp_set_dev_mac_address
r_static
r_int
id|sp_set_dev_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_struct
id|sockaddr
op_star
id|sa
op_assign
id|addr
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|sa-&gt;sa_data
comma
id|AX25_ADDR_LEN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sp_rebuild_header
r_static
r_int
id|sp_rebuild_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
macro_line|#ifdef CONFIG_INET
r_return
id|ax25_rebuild_header
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
DECL|function|sp_setup
r_static
r_void
id|sp_setup
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_static
r_char
id|ax25_bcast
(braket
id|AX25_ADDR_LEN
)braket
op_assign
(brace
l_char|&squot;Q&squot;
op_lshift
l_int|1
comma
l_char|&squot;S&squot;
op_lshift
l_int|1
comma
l_char|&squot;T&squot;
op_lshift
l_int|1
comma
l_char|&squot; &squot;
op_lshift
l_int|1
comma
l_char|&squot; &squot;
op_lshift
l_int|1
comma
l_char|&squot; &squot;
op_lshift
l_int|1
comma
l_char|&squot;0&squot;
op_lshift
l_int|1
)brace
suffix:semicolon
r_static
r_char
id|ax25_test
(braket
id|AX25_ADDR_LEN
)braket
op_assign
(brace
l_char|&squot;L&squot;
op_lshift
l_int|1
comma
l_char|&squot;I&squot;
op_lshift
l_int|1
comma
l_char|&squot;N&squot;
op_lshift
l_int|1
comma
l_char|&squot;U&squot;
op_lshift
l_int|1
comma
l_char|&squot;X&squot;
op_lshift
l_int|1
comma
l_char|&squot; &squot;
op_lshift
l_int|1
comma
l_char|&squot;1&squot;
op_lshift
l_int|1
)brace
suffix:semicolon
multiline_comment|/* Finish setting up the DEVICE info. */
id|dev-&gt;init
op_assign
id|sixpack_init
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|SIXP_MTU
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|sp_xmit
suffix:semicolon
id|dev-&gt;open
op_assign
id|sp_open_dev
suffix:semicolon
id|dev-&gt;destructor
op_assign
id|free_netdev
suffix:semicolon
id|dev-&gt;stop
op_assign
id|sp_close
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|sp_header
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|sp_get_stats
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
id|sp_set_dev_mac_address
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
id|AX25_MAX_HEADER_LEN
suffix:semicolon
id|dev-&gt;addr_len
op_assign
id|AX25_ADDR_LEN
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_AX25
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|10
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|sp_rebuild_header
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Only activated in AX.25 mode */
id|memcpy
c_func
(paren
id|dev-&gt;broadcast
comma
id|ax25_bcast
comma
id|AX25_ADDR_LEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|ax25_test
comma
id|AX25_ADDR_LEN
)paren
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* New-style flags. */
id|dev-&gt;flags
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find a free 6pack channel, and link in this `tty&squot; line. */
DECL|function|sp_alloc
r_static
r_inline
r_struct
id|sixpack
op_star
id|sp_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|alloc_netdev
c_func
(paren
r_sizeof
(paren
r_struct
id|sixpack
)paren
comma
l_string|&quot;sp%d&quot;
comma
id|sp_setup
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
id|sp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sp-&gt;dev
op_assign
id|dev
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sp-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|dev
)paren
)paren
r_goto
id|out_free
suffix:semicolon
r_return
id|sp
suffix:semicolon
id|out_free
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sp_alloc() - register_netdev() failure.&bslash;n&quot;
)paren
suffix:semicolon
id|free_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Free a 6pack channel. */
DECL|function|sp_free
r_static
r_inline
r_void
id|sp_free
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
r_void
op_star
id|tmp
suffix:semicolon
multiline_comment|/* Free all 6pack frame buffers. */
r_if
c_cond
(paren
(paren
id|tmp
op_assign
id|xchg
c_func
(paren
op_amp
id|sp-&gt;rbuff
comma
l_int|NULL
)paren
)paren
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_assign
id|xchg
c_func
(paren
op_amp
id|sp-&gt;xbuff
comma
l_int|NULL
)paren
)paren
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/* Send one completely decapsulated IP datagram to the IP layer. */
multiline_comment|/*&n; * This is the routine that sends the received data to the kernel AX.25.&n; * &squot;cmd&squot; is the KISS command. For AX.25 data, it is zero.&n; */
DECL|function|sp_bump
r_static
r_void
id|sp_bump
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
comma
r_char
id|cmd
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
id|count
op_assign
id|sp-&gt;rcount
op_plus
l_int|1
suffix:semicolon
id|sp-&gt;stats.rx_bytes
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|count
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out_mem
suffix:semicolon
id|skb-&gt;dev
op_assign
id|sp-&gt;dev
suffix:semicolon
id|ptr
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|count
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|cmd
suffix:semicolon
multiline_comment|/* KISS command */
id|memcpy
c_func
(paren
id|ptr
comma
id|sp-&gt;cooked_buf
op_plus
l_int|1
comma
id|count
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_AX25
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|sp-&gt;dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|sp-&gt;stats.rx_packets
op_increment
suffix:semicolon
r_return
suffix:semicolon
id|out_mem
suffix:colon
id|sp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
)brace
multiline_comment|/* ----------------------------------------------------------------------- */
multiline_comment|/*&n; * We have a potential race on dereferencing tty-&gt;disc_data, because the tty&n; * layer provides no locking at all - thus one cpu could be running&n; * sixpack_receive_buf while another calls sixpack_close, which zeroes&n; * tty-&gt;disc_data and frees the memory that sixpack_receive_buf is using.  The&n; * best way to fix this is to use a rwlock in the tty struct, but for now we&n; * use a single global rwlock for all ttys in ppp line discipline.&n; */
DECL|variable|disc_data_lock
r_static
id|rwlock_t
id|disc_data_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|function|sp_get
r_static
r_struct
id|sixpack
op_star
id|sp_get
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|disc_data_lock
)paren
suffix:semicolon
id|sp
op_assign
id|tty-&gt;disc_data
suffix:semicolon
r_if
c_cond
(paren
id|sp
)paren
id|atomic_inc
c_func
(paren
op_amp
id|sp-&gt;refcnt
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|disc_data_lock
)paren
suffix:semicolon
r_return
id|sp
suffix:semicolon
)brace
DECL|function|sp_put
r_static
r_void
id|sp_put
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|sp-&gt;refcnt
)paren
)paren
id|up
c_func
(paren
op_amp
id|sp-&gt;dead_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the TTY driver when there&squot;s room for more data.  If we have&n; * more packets to send, we send them here.&n; */
DECL|function|sixpack_write_wakeup
r_static
r_void
id|sixpack_write_wakeup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
id|sp_get
c_func
(paren
id|tty
)paren
suffix:semicolon
r_int
id|actual
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;xleft
op_le
l_int|0
)paren
(brace
multiline_comment|/* Now serial buffer is almost free &amp; we can start&n;&t;&t; * transmission of another packet */
id|sp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|clear_bit
c_func
(paren
id|TTY_DO_WRITE_WAKEUP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|sp-&gt;tx_enable
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|sp-&gt;dev
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sp-&gt;tx_enable
op_eq
l_int|1
)paren
(brace
id|actual
op_assign
id|tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|sp-&gt;xhead
comma
id|sp-&gt;xleft
)paren
suffix:semicolon
id|sp-&gt;xleft
op_sub_assign
id|actual
suffix:semicolon
id|sp-&gt;xhead
op_add_assign
id|actual
suffix:semicolon
)brace
id|out
suffix:colon
id|sp_put
c_func
(paren
id|sp
)paren
suffix:semicolon
)brace
multiline_comment|/* ----------------------------------------------------------------------- */
multiline_comment|/* Open the low-level part of the 6pack channel. */
DECL|function|sp_open
r_static
r_int
id|sp_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_char
op_star
id|rbuff
comma
op_star
id|xbuff
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
multiline_comment|/* !!! length of the buffers. MTU is IP MTU, not PACLEN!  */
id|len
op_assign
id|dev-&gt;mtu
op_star
l_int|2
suffix:semicolon
id|rbuff
op_assign
id|kmalloc
c_func
(paren
id|len
op_plus
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbuff
op_eq
l_int|NULL
)paren
r_goto
id|err_exit
suffix:semicolon
id|xbuff
op_assign
id|kmalloc
c_func
(paren
id|len
op_plus
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xbuff
op_eq
l_int|NULL
)paren
r_goto
id|err_exit
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|sp-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;tty
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate the 6pack frame buffers:&n;&t; *&n;&t; * rbuff&t;Receive buffer.&n;&t; * xbuff&t;Transmit buffer.&n;&t; */
id|rbuff
op_assign
id|xchg
c_func
(paren
op_amp
id|sp-&gt;rbuff
comma
id|rbuff
)paren
suffix:semicolon
id|xbuff
op_assign
id|xchg
c_func
(paren
op_amp
id|sp-&gt;xbuff
comma
id|xbuff
)paren
suffix:semicolon
id|sp-&gt;mtu
op_assign
id|AX25_MTU
op_plus
l_int|73
suffix:semicolon
id|sp-&gt;buffsize
op_assign
id|len
suffix:semicolon
id|sp-&gt;rcount
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;rx_count
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;rx_count_cooked
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;xleft
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear ESCAPE &amp; ERROR flags */
id|sp-&gt;duplex
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;tx_delay
op_assign
id|SIXP_TXDELAY
suffix:semicolon
id|sp-&gt;persistence
op_assign
id|SIXP_PERSIST
suffix:semicolon
id|sp-&gt;slottime
op_assign
id|SIXP_SLOTTIME
suffix:semicolon
id|sp-&gt;led_state
op_assign
l_int|0x60
suffix:semicolon
id|sp-&gt;status
op_assign
l_int|1
suffix:semicolon
id|sp-&gt;status1
op_assign
l_int|1
suffix:semicolon
id|sp-&gt;status2
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;tnc_ok
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;tx_enable
op_assign
l_int|0
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sp-&gt;tx_t
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|sp-&gt;lock
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|err_exit
suffix:colon
r_if
c_cond
(paren
id|xbuff
)paren
id|kfree
c_func
(paren
id|xbuff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbuff
)paren
id|kfree
c_func
(paren
id|rbuff
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sixpack_receive_room
r_static
r_int
id|sixpack_receive_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
l_int|65536
suffix:semicolon
multiline_comment|/* We can handle an infinite amount of data. :-) */
)brace
multiline_comment|/*&n; * Handle the &squot;receiver data ready&squot; interrupt.&n; * This function is called by the &squot;tty_io&squot; module in the kernel when&n; * a block of 6pack data has been received, which can now be decapsulated&n; * and sent on to some IP layer for further processing.&n; */
DECL|function|sixpack_receive_buf
r_static
r_void
id|sixpack_receive_buf
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|512
)braket
suffix:semicolon
r_int
id|count1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
suffix:semicolon
id|sp
op_assign
id|sp_get
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sp
)paren
r_return
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|cp
comma
id|count
OL
r_sizeof
(paren
id|buf
)paren
ques
c_cond
id|count
suffix:colon
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
multiline_comment|/* Read the characters out of the buffer */
id|count1
op_assign
id|count
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|fp
op_logical_and
op_star
id|fp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|SIXPF_ERROR
comma
op_amp
id|sp-&gt;flags
)paren
)paren
id|sp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|sixpack_decode
c_func
(paren
id|sp
comma
id|buf
comma
id|count1
)paren
suffix:semicolon
id|sp_put
c_func
(paren
id|sp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
op_logical_and
id|tty-&gt;driver-&gt;unthrottle
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to resync the TNC. Called by the resync timer defined in&n; * decode_prio_command&n; */
DECL|function|resync_tnc
r_static
r_void
id|resync_tnc
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|channel
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|sp-&gt;dev
suffix:semicolon
r_static
r_char
id|resync_cmd
op_assign
l_int|0xe8
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: resyncing TNC&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* clear any data that might have been received */
id|sp-&gt;rx_count
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;rx_count_cooked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset state machine */
id|sp-&gt;status
op_assign
l_int|1
suffix:semicolon
id|sp-&gt;status1
op_assign
l_int|1
suffix:semicolon
id|sp-&gt;status2
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;tnc_ok
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* resync the TNC */
id|sp-&gt;led_state
op_assign
l_int|0x60
suffix:semicolon
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|resync_cmd
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Start resync timer again -- the TNC might be still absent */
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
id|sp-&gt;resync_t.data
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
id|sp-&gt;resync_t.function
op_assign
id|resync_tnc
suffix:semicolon
id|sp-&gt;resync_t.expires
op_assign
id|jiffies
op_plus
id|SIXP_RESYNC_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
)brace
DECL|function|tnc_init
r_static
r_inline
r_int
id|tnc_init
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
r_int
r_char
id|inbyte
op_assign
l_int|0xe8
suffix:semicolon
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|inbyte
comma
l_int|1
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
id|sp-&gt;resync_t.data
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
id|sp-&gt;resync_t.function
op_assign
id|resync_tnc
suffix:semicolon
id|sp-&gt;resync_t.expires
op_assign
id|jiffies
op_plus
id|SIXP_RESYNC_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the high-level part of the 6pack channel.&n; * This function is called by the TTY module when the&n; * 6pack line discipline is called for.  Because we are&n; * sure the tty line exists, we only have to link it to&n; * a free 6pcack channel...&n; */
DECL|function|sixpack_open
r_static
r_int
id|sixpack_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|sp
op_assign
id|sp_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sp
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|sp-&gt;tty
op_assign
id|tty
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sp-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|sp-&gt;dead_sem
)paren
suffix:semicolon
multiline_comment|/* Perform the low-level 6pack initialization. */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|sp_open
c_func
(paren
id|sp-&gt;dev
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Done.  We have linked the TTY line to a channel. */
id|tty-&gt;disc_data
op_assign
id|sp
suffix:semicolon
id|tnc_init
c_func
(paren
id|sp
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down a 6pack channel.&n; * This means flushing out any pending queues, and then restoring the&n; * TTY line discipline to what it was before it got hooked to 6pack&n; * (which usually is TTY again).&n; */
DECL|function|sixpack_close
r_static
r_void
id|sixpack_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|disc_data_lock
)paren
suffix:semicolon
id|sp
op_assign
id|tty-&gt;disc_data
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|0
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|disc_data_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * We have now ensured that nobody can start using ap from now on, but&n;&t; * we have to wait for all existing users to finish.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|sp-&gt;refcnt
)paren
)paren
id|down
c_func
(paren
op_amp
id|sp-&gt;dead_sem
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;tx_t
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
id|sp_free
c_func
(paren
id|sp
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|sp-&gt;dev
)paren
suffix:semicolon
)brace
DECL|function|sp_set_mac_address
r_static
r_int
id|sp_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_return
id|copy_from_user
c_func
(paren
id|dev-&gt;dev_addr
comma
id|addr
comma
id|AX25_ADDR_LEN
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Perform I/O control on an active 6pack channel. */
DECL|function|sixpack_ioctl
r_static
r_int
id|sixpack_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
id|sp_get
c_func
(paren
id|tty
)paren
suffix:semicolon
r_int
r_int
id|tmp
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sp
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGIFNAME
suffix:colon
id|err
op_assign
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|sp-&gt;dev-&gt;name
comma
id|strlen
c_func
(paren
id|sp-&gt;dev-&gt;name
)paren
op_plus
l_int|1
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGIFENCAP
suffix:colon
id|err
op_assign
id|put_user
c_func
(paren
l_int|0
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFENCAP
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|tmp
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sp-&gt;mode
op_assign
id|tmp
suffix:semicolon
id|sp-&gt;dev-&gt;addr_len
op_assign
id|AX25_ADDR_LEN
suffix:semicolon
multiline_comment|/* sizeof an AX.25 addr */
id|sp-&gt;dev-&gt;hard_header_len
op_assign
id|AX25_KISS_HEADER_LEN
op_plus
id|AX25_MAX_HEADER_LEN
op_plus
l_int|3
suffix:semicolon
id|sp-&gt;dev-&gt;type
op_assign
id|ARPHRD_AX25
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSIFHWADDR
suffix:colon
id|err
op_assign
id|sp_set_mac_address
c_func
(paren
id|sp-&gt;dev
comma
(paren
r_void
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Allow stty to read, but not set, the serial port */
r_case
id|TCGETS
suffix:colon
r_case
id|TCGETA
suffix:colon
id|err
op_assign
id|n_tty_ioctl
c_func
(paren
id|tty
comma
(paren
r_struct
id|file
op_star
)paren
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
id|sp_put
c_func
(paren
id|sp
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Fill in our line protocol discipline */
DECL|variable|sp_ldisc
r_static
r_struct
id|tty_ldisc
id|sp_ldisc
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|magic
op_assign
id|TTY_LDISC_MAGIC
comma
dot
id|name
op_assign
l_string|&quot;6pack&quot;
comma
dot
id|open
op_assign
id|sixpack_open
comma
dot
id|close
op_assign
id|sixpack_close
comma
dot
id|ioctl
op_assign
id|sixpack_ioctl
comma
dot
id|receive_buf
op_assign
id|sixpack_receive_buf
comma
dot
id|receive_room
op_assign
id|sixpack_receive_room
comma
dot
id|write_wakeup
op_assign
id|sixpack_write_wakeup
comma
)brace
suffix:semicolon
multiline_comment|/* Initialize 6pack control device -- register 6pack line discipline */
DECL|variable|__initdata
r_static
r_char
id|msg_banner
(braket
)braket
id|__initdata
op_assign
id|KERN_INFO
l_string|&quot;AX.25: 6pack driver, &quot;
id|SIXPACK_VERSION
l_string|&quot;&bslash;n&quot;
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|msg_regfail
(braket
)braket
id|__initdata
op_assign
id|KERN_ERR
l_string|&quot;6pack: can&squot;t register line discipline (err = %d)&bslash;n&quot;
suffix:semicolon
DECL|function|sixpack_init_driver
r_static
r_int
id|__init
id|sixpack_init_driver
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
id|printk
c_func
(paren
id|msg_banner
)paren
suffix:semicolon
multiline_comment|/* Register the provided line protocol discipline */
r_if
c_cond
(paren
(paren
id|status
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_6PACK
comma
op_amp
id|sp_ldisc
)paren
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|msg_regfail
comma
id|status
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|variable|__exitdata
r_static
r_const
r_char
id|msg_unregfail
(braket
)braket
id|__exitdata
op_assign
id|KERN_ERR
l_string|&quot;6pack: can&squot;t unregister line discipline (err = %d)&bslash;n&quot;
suffix:semicolon
DECL|function|sixpack_exit_driver
r_static
r_void
id|__exit
id|sixpack_exit_driver
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_6PACK
comma
l_int|NULL
)paren
)paren
)paren
id|printk
c_func
(paren
id|msg_unregfail
comma
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize the 6pack driver.  Called by DDI. */
DECL|function|sixpack_init
r_static
r_int
id|sixpack_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp
op_eq
l_int|NULL
)paren
multiline_comment|/* Allocation failed ?? */
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Set up the &quot;6pack Control Block&quot;. (And clear statistics) */
id|memset
c_func
(paren
id|sp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sixpack
)paren
)paren
suffix:semicolon
id|sp-&gt;dev
op_assign
id|dev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* encode an AX.25 packet into 6pack */
DECL|function|encode_sixpack
r_static
r_int
id|encode_sixpack
c_func
(paren
r_int
r_char
op_star
id|tx_buf
comma
r_int
r_char
op_star
id|tx_buf_raw
comma
r_int
id|length
comma
r_int
r_char
id|tx_delay
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|checksum
op_assign
l_int|0
comma
id|buf
(braket
l_int|400
)braket
suffix:semicolon
r_int
id|raw_count
op_assign
l_int|0
suffix:semicolon
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_assign
id|SIXP_PRIO_CMD_MASK
op_or
id|SIXP_TX_MASK
suffix:semicolon
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_assign
id|SIXP_SEOF
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
id|tx_delay
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
OL
id|length
suffix:semicolon
id|count
op_increment
)paren
id|buf
(braket
id|count
)braket
op_assign
id|tx_buf
(braket
id|count
)braket
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|length
suffix:semicolon
id|count
op_increment
)paren
id|checksum
op_add_assign
id|buf
(braket
id|count
)braket
suffix:semicolon
id|buf
(braket
id|length
)braket
op_assign
(paren
r_int
r_char
)paren
l_int|0xff
op_minus
id|checksum
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
op_le
id|length
suffix:semicolon
id|count
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|count
op_mod
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_assign
(paren
id|buf
(braket
id|count
)braket
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|tx_buf_raw
(braket
id|raw_count
)braket
op_assign
(paren
(paren
id|buf
(braket
id|count
)braket
op_rshift
l_int|2
)paren
op_amp
l_int|0x30
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|count
op_mod
l_int|3
)paren
op_eq
l_int|1
)paren
(brace
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_or_assign
(paren
id|buf
(braket
id|count
)braket
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|tx_buf_raw
(braket
id|raw_count
)braket
op_assign
(paren
(paren
id|buf
(braket
id|count
)braket
op_rshift
l_int|2
)paren
op_amp
l_int|0x3c
)paren
suffix:semicolon
)brace
r_else
(brace
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_or_assign
(paren
id|buf
(braket
id|count
)braket
op_amp
l_int|0x03
)paren
suffix:semicolon
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_assign
(paren
id|buf
(braket
id|count
)braket
op_rshift
l_int|2
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|length
op_mod
l_int|3
)paren
op_ne
l_int|2
)paren
id|raw_count
op_increment
suffix:semicolon
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_assign
id|SIXP_SEOF
suffix:semicolon
r_return
id|raw_count
suffix:semicolon
)brace
multiline_comment|/* decode 4 sixpack-encoded bytes into 3 data bytes */
DECL|function|decode_data
r_static
r_void
id|decode_data
c_func
(paren
r_int
r_char
id|inbyte
comma
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;rx_count
op_ne
l_int|3
)paren
(brace
id|sp-&gt;raw_buf
(braket
id|sp-&gt;rx_count
op_increment
)braket
op_assign
id|inbyte
suffix:semicolon
r_return
suffix:semicolon
)brace
id|buf
op_assign
id|sp-&gt;raw_buf
suffix:semicolon
id|sp-&gt;cooked_buf
(braket
id|sp-&gt;rx_count_cooked
op_increment
)braket
op_assign
id|buf
(braket
l_int|0
)braket
op_or
(paren
(paren
id|buf
(braket
l_int|1
)braket
op_lshift
l_int|2
)paren
op_amp
l_int|0xc0
)paren
suffix:semicolon
id|sp-&gt;cooked_buf
(braket
id|sp-&gt;rx_count_cooked
op_increment
)braket
op_assign
(paren
id|buf
(braket
l_int|1
)braket
op_amp
l_int|0x0f
)paren
op_or
(paren
(paren
id|buf
(braket
l_int|2
)braket
op_lshift
l_int|2
)paren
op_amp
l_int|0xf0
)paren
suffix:semicolon
id|sp-&gt;cooked_buf
(braket
id|sp-&gt;rx_count_cooked
op_increment
)braket
op_assign
(paren
id|buf
(braket
l_int|2
)braket
op_amp
l_int|0x03
)paren
op_or
(paren
id|inbyte
op_lshift
l_int|2
)paren
suffix:semicolon
id|sp-&gt;rx_count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* identify and execute a 6pack priority command byte */
DECL|function|decode_prio_command
r_static
r_void
id|decode_prio_command
c_func
(paren
r_int
r_char
id|cmd
comma
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
r_int
r_char
id|channel
suffix:semicolon
r_int
id|actual
suffix:semicolon
id|channel
op_assign
id|cmd
op_amp
id|SIXP_CHN_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_amp
id|SIXP_PRIO_DATA_MASK
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* idle ? */
multiline_comment|/* RX and DCD flags can only be set in the same prio command,&n;&t;   if the DCD flag has been set without the RX flag in the previous&n;&t;   prio command. If DCD has not been set before, something in the&n;&t;   transmission has gone wrong. In this case, RX and DCD are&n;&t;   cleared in order to prevent the decode_data routine from&n;&t;   reading further data that might be corrupt. */
r_if
c_cond
(paren
(paren
(paren
id|sp-&gt;status
op_amp
id|SIXP_DCD_MASK
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|cmd
op_amp
id|SIXP_RX_DCD_MASK
)paren
op_eq
id|SIXP_RX_DCD_MASK
)paren
)paren
(brace
r_if
c_cond
(paren
id|sp-&gt;status
op_ne
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;6pack: protocol violation&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|sp-&gt;status
op_assign
l_int|0
suffix:semicolon
id|cmd
op_and_assign
op_logical_neg
id|SIXP_RX_DCD_MASK
suffix:semicolon
)brace
id|sp-&gt;status
op_assign
id|cmd
op_amp
id|SIXP_PRIO_DATA_MASK
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* output watchdog char if idle */
r_if
c_cond
(paren
(paren
id|sp-&gt;status2
op_ne
l_int|0
)paren
op_logical_and
(paren
id|sp-&gt;duplex
op_eq
l_int|1
)paren
)paren
(brace
id|sp-&gt;led_state
op_assign
l_int|0x70
suffix:semicolon
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
id|sp-&gt;tx_enable
op_assign
l_int|1
suffix:semicolon
id|actual
op_assign
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
id|sp-&gt;xbuff
comma
id|sp-&gt;status2
)paren
suffix:semicolon
id|sp-&gt;xleft
op_sub_assign
id|actual
suffix:semicolon
id|sp-&gt;xhead
op_add_assign
id|actual
suffix:semicolon
id|sp-&gt;led_state
op_assign
l_int|0x60
suffix:semicolon
id|sp-&gt;status2
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* needed to trigger the TNC watchdog */
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if the state byte has been received, the TNC is present,&n;           so the resync timer can be reset. */
r_if
c_cond
(paren
id|sp-&gt;tnc_ok
op_eq
l_int|1
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
id|sp-&gt;resync_t.data
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
id|sp-&gt;resync_t.function
op_assign
id|resync_tnc
suffix:semicolon
id|sp-&gt;resync_t.expires
op_assign
id|jiffies
op_plus
id|SIXP_INIT_RESYNC_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
)brace
id|sp-&gt;status1
op_assign
id|cmd
op_amp
id|SIXP_PRIO_DATA_MASK
suffix:semicolon
)brace
multiline_comment|/* identify and execute a standard 6pack command byte */
DECL|function|decode_std_command
r_static
r_void
id|decode_std_command
c_func
(paren
r_int
r_char
id|cmd
comma
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
r_int
r_char
id|checksum
op_assign
l_int|0
comma
id|rest
op_assign
l_int|0
comma
id|channel
suffix:semicolon
r_int
id|i
suffix:semicolon
id|channel
op_assign
id|cmd
op_amp
id|SIXP_CHN_MASK
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
op_amp
id|SIXP_CMD_MASK
)paren
(brace
multiline_comment|/* normal command */
r_case
id|SIXP_SEOF
suffix:colon
r_if
c_cond
(paren
(paren
id|sp-&gt;rx_count
op_eq
l_int|0
)paren
op_logical_and
(paren
id|sp-&gt;rx_count_cooked
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|sp-&gt;status
op_amp
id|SIXP_RX_DCD_MASK
)paren
op_eq
id|SIXP_RX_DCD_MASK
)paren
(brace
id|sp-&gt;led_state
op_assign
l_int|0x68
suffix:semicolon
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|sp-&gt;led_state
op_assign
l_int|0x60
suffix:semicolon
multiline_comment|/* fill trailing bytes with zeroes */
id|sp-&gt;tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
id|rest
op_assign
id|sp-&gt;rx_count
suffix:semicolon
r_if
c_cond
(paren
id|rest
op_ne
l_int|0
)paren
r_for
c_loop
(paren
id|i
op_assign
id|rest
suffix:semicolon
id|i
op_le
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|decode_data
c_func
(paren
l_int|0
comma
id|sp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rest
op_eq
l_int|2
)paren
id|sp-&gt;rx_count_cooked
op_sub_assign
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rest
op_eq
l_int|3
)paren
id|sp-&gt;rx_count_cooked
op_sub_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sp-&gt;rx_count_cooked
suffix:semicolon
id|i
op_increment
)paren
id|checksum
op_add_assign
id|sp-&gt;cooked_buf
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_ne
id|SIXP_CHKSUM
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;6pack: bad checksum %2.2x&bslash;n&quot;
comma
id|checksum
)paren
suffix:semicolon
)brace
r_else
(brace
id|sp-&gt;rcount
op_assign
id|sp-&gt;rx_count_cooked
op_minus
l_int|2
suffix:semicolon
id|sp_bump
c_func
(paren
id|sp
comma
l_int|0
)paren
suffix:semicolon
)brace
id|sp-&gt;rx_count_cooked
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIXP_TX_URUN
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;6pack: TX underrun&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIXP_RX_ORUN
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;6pack: RX overrun&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIXP_RX_BUF_OVL
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;6pack: RX buffer overflow&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* decode a 6pack packet */
r_static
r_void
DECL|function|sixpack_decode
id|sixpack_decode
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
comma
r_int
r_char
id|pre_rbuff
(braket
)braket
comma
r_int
id|count
)paren
(brace
r_int
r_char
id|inbyte
suffix:semicolon
r_int
id|count1
suffix:semicolon
r_for
c_loop
(paren
id|count1
op_assign
l_int|0
suffix:semicolon
id|count1
OL
id|count
suffix:semicolon
id|count1
op_increment
)paren
(brace
id|inbyte
op_assign
id|pre_rbuff
(braket
id|count1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|inbyte
op_eq
id|SIXP_FOUND_TNC
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;6pack: TNC found.&bslash;n&quot;
)paren
suffix:semicolon
id|sp-&gt;tnc_ok
op_assign
l_int|1
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|inbyte
op_amp
id|SIXP_PRIO_CMD_MASK
)paren
op_ne
l_int|0
)paren
id|decode_prio_command
c_func
(paren
id|inbyte
comma
id|sp
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|inbyte
op_amp
id|SIXP_STD_CMD_MASK
)paren
op_ne
l_int|0
)paren
id|decode_std_command
c_func
(paren
id|inbyte
comma
id|sp
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|sp-&gt;status
op_amp
id|SIXP_RX_DCD_MASK
)paren
op_eq
id|SIXP_RX_DCD_MASK
)paren
id|decode_data
c_func
(paren
id|inbyte
comma
id|sp
)paren
suffix:semicolon
)brace
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Ralf Baechle DO1GRB &lt;ralf@linux-mips.org&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;6pack driver for AX.25&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|N_6PACK
id|MODULE_ALIAS_LDISC
c_func
(paren
id|N_6PACK
)paren
suffix:semicolon
DECL|variable|sixpack_init_driver
id|module_init
c_func
(paren
id|sixpack_init_driver
)paren
suffix:semicolon
DECL|variable|sixpack_exit_driver
id|module_exit
c_func
(paren
id|sixpack_exit_driver
)paren
suffix:semicolon
eof
