multiline_comment|/*&n; * Copyright (C) 2001 Broadcom Corporation&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version 2&n; * of the License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n; */
multiline_comment|/*&n;  This driver is designed for the Broadcom BCM12500 SOC chip&squot;s built-in&n;  Ethernet controllers.&n;  &n;  The author may be reached as mpl@broadcom.com&n;*/
multiline_comment|/* A few user-configurable values.&n;   These may be modified when a driver module is loaded. */
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 1 normal messages, 0 quiet .. 7 verbose. */
multiline_comment|/* Used to pass the media type, etc.&n;   Both &squot;options[]&squot; and &squot;full_duplex[]&squot; should exist for driver&n;   interoperability.&n;   The media type is usually passed in &squot;options[]&squot;.&n;*/
DECL|macro|MAX_UNITS
mdefine_line|#define MAX_UNITS 3&t;&t;/* More are supported, limit only on options */
macro_line|#ifdef MODULE
DECL|variable|options
r_static
r_int
id|options
(braket
id|MAX_UNITS
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|full_duplex
r_static
r_int
id|full_duplex
(braket
id|MAX_UNITS
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* Operational parameters that usually are not changed. */
multiline_comment|/* Time in jiffies before concluding the transmitter is hung. */
DECL|macro|TX_TIMEOUT
mdefine_line|#define TX_TIMEOUT  (2*HZ)
macro_line|#if !defined(__OPTIMIZE__)  ||  !defined(__KERNEL__)
macro_line|#warning  You must compile this file with the correct options!
macro_line|#warning  See the last lines of the source file.
macro_line|#error  You must compile this driver with &quot;-O&quot;.
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/processor.h&gt;&t;&t;/* Processor type for cache alignment. */
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250.h&gt;
macro_line|#include &lt;asm/sibyte/64bit.h&gt;
multiline_comment|/* This is only here until the firmware is ready.  In that case,&n;   the firmware leaves the ethernet address in the register for us. */
macro_line|#ifdef CONFIG_SWARM_STANDALONE
DECL|macro|SBMAC_ETH0_HWADDR
mdefine_line|#define SBMAC_ETH0_HWADDR &quot;40:00:00:00:01:00&quot;
DECL|macro|SBMAC_ETH1_HWADDR
mdefine_line|#define SBMAC_ETH1_HWADDR &quot;40:00:00:00:01:01&quot;
DECL|macro|SBMAC_ETH2_HWADDR
mdefine_line|#define SBMAC_ETH2_HWADDR &quot;40:00:00:00:01:02&quot;
macro_line|#endif
multiline_comment|/* These identify the driver base version and may not be removed. */
macro_line|#if 0
r_static
r_char
id|version1
(braket
)braket
id|__devinitdata
op_assign
l_string|&quot;sb1250-mac.c:1.00 1/11/2001 Written by Mitch Lichtenberg (mpl@broadcom.com)&bslash;n&quot;
suffix:semicolon
macro_line|#endif
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Mitch Lichtenberg (mpl@broadcom.com)&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Broadcom BCM12500 SOC GB Ethernet driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|options
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_UNITS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|full_duplex
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_UNITS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#include &lt;asm/sibyte/sb1250_defs.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_regs.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_mac.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_dma.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_int.h&gt;
multiline_comment|/**********************************************************************&n; *  Simple types&n; ********************************************************************* */
DECL|typedef|sbmac_port_t
r_typedef
r_int
r_int
id|sbmac_port_t
suffix:semicolon
DECL|typedef|sbmac_physaddr_t
r_typedef
r_uint64
id|sbmac_physaddr_t
suffix:semicolon
DECL|typedef|sbmac_enetaddr_t
r_typedef
r_uint64
id|sbmac_enetaddr_t
suffix:semicolon
DECL|enumerator|sbmac_speed_auto
DECL|enumerator|sbmac_speed_10
r_typedef
r_enum
(brace
id|sbmac_speed_auto
comma
id|sbmac_speed_10
comma
DECL|enumerator|sbmac_speed_100
DECL|enumerator|sbmac_speed_1000
DECL|typedef|sbmac_speed_t
id|sbmac_speed_100
comma
id|sbmac_speed_1000
)brace
id|sbmac_speed_t
suffix:semicolon
DECL|enumerator|sbmac_duplex_auto
DECL|enumerator|sbmac_duplex_half
r_typedef
r_enum
(brace
id|sbmac_duplex_auto
comma
id|sbmac_duplex_half
comma
DECL|enumerator|sbmac_duplex_full
DECL|typedef|sbmac_duplex_t
id|sbmac_duplex_full
)brace
id|sbmac_duplex_t
suffix:semicolon
DECL|enumerator|sbmac_fc_auto
DECL|enumerator|sbmac_fc_disabled
DECL|enumerator|sbmac_fc_frame
r_typedef
r_enum
(brace
id|sbmac_fc_auto
comma
id|sbmac_fc_disabled
comma
id|sbmac_fc_frame
comma
DECL|enumerator|sbmac_fc_collision
DECL|enumerator|sbmac_fc_carrier
DECL|typedef|sbmac_fc_t
id|sbmac_fc_collision
comma
id|sbmac_fc_carrier
)brace
id|sbmac_fc_t
suffix:semicolon
DECL|enumerator|sbmac_state_uninit
DECL|enumerator|sbmac_state_off
DECL|enumerator|sbmac_state_on
r_typedef
r_enum
(brace
id|sbmac_state_uninit
comma
id|sbmac_state_off
comma
id|sbmac_state_on
comma
DECL|enumerator|sbmac_state_broken
DECL|typedef|sbmac_state_t
id|sbmac_state_broken
)brace
id|sbmac_state_t
suffix:semicolon
multiline_comment|/**********************************************************************&n; *  Macros&n; ********************************************************************* */
DECL|macro|SBDMA_NEXTBUF
mdefine_line|#define SBDMA_NEXTBUF(d,f) ((((d)-&gt;f+1) == (d)-&gt;sbdma_dscrtable_end) ? &bslash;&n;&t;&t;&t;  (d)-&gt;sbdma_dscrtable : (d)-&gt;f+1)
DECL|macro|CACHELINESIZE
mdefine_line|#define CACHELINESIZE 32
DECL|macro|NUMCACHEBLKS
mdefine_line|#define NUMCACHEBLKS(x) (((x)+CACHELINESIZE-1)/CACHELINESIZE)
DECL|macro|KMALLOC
mdefine_line|#define KMALLOC(x) kmalloc((x),GFP_KERNEL)
DECL|macro|KFREE
mdefine_line|#define KFREE(x) kfree(x)
DECL|macro|KVTOPHYS
mdefine_line|#define KVTOPHYS(x) virt_to_bus((void *)(x))
DECL|macro|SBMAC_READCSR
mdefine_line|#define SBMAC_READCSR(t)    (in64((unsigned long)(t)))
DECL|macro|SBMAC_WRITECSR
mdefine_line|#define SBMAC_WRITECSR(t,v) (out64(v, (unsigned long)(t)))
DECL|macro|PKSEG1
mdefine_line|#define PKSEG1(x) ((sbmac_port_t) KSEG1ADDR(x))
DECL|macro|SBMAC_MAX_TXDESCR
mdefine_line|#define SBMAC_MAX_TXDESCR&t;32
DECL|macro|SBMAC_MAX_RXDESCR
mdefine_line|#define SBMAC_MAX_RXDESCR&t;32
DECL|macro|ETHER_ALIGN
mdefine_line|#define ETHER_ALIGN&t;2
DECL|macro|ETHER_ADDR_LEN
mdefine_line|#define ETHER_ADDR_LEN&t;6
DECL|macro|ENET_PACKET_SIZE
mdefine_line|#define ENET_PACKET_SIZE&t;1518
multiline_comment|/**********************************************************************&n; *  DMA Descriptor structure&n; ********************************************************************* */
DECL|struct|sbdmadscr_s
r_typedef
r_struct
id|sbdmadscr_s
(brace
DECL|member|dscr_a
r_uint64
id|dscr_a
suffix:semicolon
DECL|member|dscr_b
r_uint64
id|dscr_b
suffix:semicolon
DECL|typedef|sbdmadscr_t
)brace
id|sbdmadscr_t
suffix:semicolon
DECL|typedef|paddr_t
r_typedef
r_int
r_int
id|paddr_t
suffix:semicolon
DECL|typedef|vaddr_t
r_typedef
r_int
r_int
id|vaddr_t
suffix:semicolon
multiline_comment|/**********************************************************************&n; *  DMA Controller structure&n; ********************************************************************* */
DECL|struct|sbmacdma_s
r_typedef
r_struct
id|sbmacdma_s
(brace
multiline_comment|/* &n;&t; * This stuff is used to identify the channel and the registers&n;&t; * associated with it.&n;&t; */
DECL|member|sbdma_eth
r_struct
id|sbmac_softc
op_star
id|sbdma_eth
suffix:semicolon
multiline_comment|/* back pointer to associated MAC */
DECL|member|sbdma_channel
r_int
id|sbdma_channel
suffix:semicolon
multiline_comment|/* channel number */
DECL|member|sbdma_txdir
r_int
id|sbdma_txdir
suffix:semicolon
multiline_comment|/* direction (1=transmit) */
DECL|member|sbdma_maxdescr
r_int
id|sbdma_maxdescr
suffix:semicolon
multiline_comment|/* total # of descriptors in ring */
DECL|member|sbdma_config0
id|sbmac_port_t
id|sbdma_config0
suffix:semicolon
multiline_comment|/* DMA config register 0 */
DECL|member|sbdma_config1
id|sbmac_port_t
id|sbdma_config1
suffix:semicolon
multiline_comment|/* DMA config register 1 */
DECL|member|sbdma_dscrbase
id|sbmac_port_t
id|sbdma_dscrbase
suffix:semicolon
multiline_comment|/* Descriptor base address */
DECL|member|sbdma_dscrcnt
id|sbmac_port_t
id|sbdma_dscrcnt
suffix:semicolon
multiline_comment|/* Descriptor count register */
DECL|member|sbdma_curdscr
id|sbmac_port_t
id|sbdma_curdscr
suffix:semicolon
multiline_comment|/* current descriptor address */
multiline_comment|/*&n;&t; * This stuff is for maintenance of the ring&n;&t; */
DECL|member|sbdma_dscrtable
id|sbdmadscr_t
op_star
id|sbdma_dscrtable
suffix:semicolon
multiline_comment|/* base of descriptor table */
DECL|member|sbdma_dscrtable_end
id|sbdmadscr_t
op_star
id|sbdma_dscrtable_end
suffix:semicolon
multiline_comment|/* end of descriptor table */
DECL|member|sbdma_ctxtable
r_struct
id|sk_buff
op_star
op_star
id|sbdma_ctxtable
suffix:semicolon
multiline_comment|/* context table, one per descr */
DECL|member|sbdma_dscrtable_phys
id|paddr_t
id|sbdma_dscrtable_phys
suffix:semicolon
multiline_comment|/* and also the phys addr */
DECL|member|sbdma_addptr
id|sbdmadscr_t
op_star
id|sbdma_addptr
suffix:semicolon
multiline_comment|/* next dscr for sw to add */
DECL|member|sbdma_remptr
id|sbdmadscr_t
op_star
id|sbdma_remptr
suffix:semicolon
multiline_comment|/* next dscr for sw to remove */
DECL|typedef|sbmacdma_t
)brace
id|sbmacdma_t
suffix:semicolon
multiline_comment|/**********************************************************************&n; *  Ethernet softc structure&n; ********************************************************************* */
DECL|struct|sbmac_softc
r_struct
id|sbmac_softc
(brace
multiline_comment|/*&n;&t; * Linux-specific things&n;&t; */
DECL|member|sbm_dev
r_struct
id|net_device
op_star
id|sbm_dev
suffix:semicolon
multiline_comment|/* pointer to linux device */
DECL|member|sbm_lock
id|spinlock_t
id|sbm_lock
suffix:semicolon
multiline_comment|/* spin lock */
DECL|member|sbm_timer
r_struct
id|timer_list
id|sbm_timer
suffix:semicolon
multiline_comment|/* for monitoring MII */
DECL|member|sbm_stats
r_struct
id|net_device_stats
id|sbm_stats
suffix:semicolon
DECL|member|sbm_devflags
r_int
id|sbm_devflags
suffix:semicolon
multiline_comment|/* current device flags */
DECL|member|sbm_phy_oldbmsr
r_int
id|sbm_phy_oldbmsr
suffix:semicolon
DECL|member|sbm_phy_oldanlpar
r_int
id|sbm_phy_oldanlpar
suffix:semicolon
DECL|member|sbm_phy_oldk1stsr
r_int
id|sbm_phy_oldk1stsr
suffix:semicolon
DECL|member|sbm_phy_oldlinkstat
r_int
id|sbm_phy_oldlinkstat
suffix:semicolon
DECL|member|sbm_buffersize
r_int
id|sbm_buffersize
suffix:semicolon
DECL|member|sbm_phys
r_int
r_char
id|sbm_phys
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Controller-specific things&n;&t; */
DECL|member|sbm_base
id|sbmac_port_t
id|sbm_base
suffix:semicolon
multiline_comment|/* MAC&squot;s base address */
DECL|member|sbm_state
id|sbmac_state_t
id|sbm_state
suffix:semicolon
multiline_comment|/* current state */
DECL|member|sbm_macenable
id|sbmac_port_t
id|sbm_macenable
suffix:semicolon
multiline_comment|/* MAC Enable Register */
DECL|member|sbm_maccfg
id|sbmac_port_t
id|sbm_maccfg
suffix:semicolon
multiline_comment|/* MAC Configuration Register */
DECL|member|sbm_fifocfg
id|sbmac_port_t
id|sbm_fifocfg
suffix:semicolon
multiline_comment|/* FIFO configuration register */
DECL|member|sbm_framecfg
id|sbmac_port_t
id|sbm_framecfg
suffix:semicolon
multiline_comment|/* Frame configuration register */
DECL|member|sbm_rxfilter
id|sbmac_port_t
id|sbm_rxfilter
suffix:semicolon
multiline_comment|/* receive filter register */
DECL|member|sbm_isr
id|sbmac_port_t
id|sbm_isr
suffix:semicolon
multiline_comment|/* Interrupt status register */
DECL|member|sbm_imr
id|sbmac_port_t
id|sbm_imr
suffix:semicolon
multiline_comment|/* Interrupt mask register */
DECL|member|sbm_mdio
id|sbmac_port_t
id|sbm_mdio
suffix:semicolon
multiline_comment|/* MDIO register */
DECL|member|sbm_speed
id|sbmac_speed_t
id|sbm_speed
suffix:semicolon
multiline_comment|/* current speed */
DECL|member|sbm_duplex
id|sbmac_duplex_t
id|sbm_duplex
suffix:semicolon
multiline_comment|/* current duplex */
DECL|member|sbm_fc
id|sbmac_fc_t
id|sbm_fc
suffix:semicolon
multiline_comment|/* current flow control setting */
DECL|member|sbm_hwaddr
id|u_char
id|sbm_hwaddr
(braket
id|ETHER_ADDR_LEN
)braket
suffix:semicolon
DECL|member|sbm_txdma
id|sbmacdma_t
id|sbm_txdma
suffix:semicolon
multiline_comment|/* for now, only use channel 0 */
DECL|member|sbm_rxdma
id|sbmacdma_t
id|sbm_rxdma
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**********************************************************************&n; *  Externs&n; ********************************************************************* */
multiline_comment|/**********************************************************************&n; *  Prototypes&n; ********************************************************************* */
r_static
r_void
id|sbdma_initctx
c_func
(paren
id|sbmacdma_t
op_star
id|d
comma
r_struct
id|sbmac_softc
op_star
id|s
comma
r_int
id|chan
comma
r_int
id|txrx
comma
r_int
id|maxdescr
)paren
suffix:semicolon
r_static
r_void
id|sbdma_channel_start
c_func
(paren
id|sbmacdma_t
op_star
id|d
)paren
suffix:semicolon
r_static
r_int
id|sbdma_add_rcvbuffer
c_func
(paren
id|sbmacdma_t
op_star
id|d
comma
r_struct
id|sk_buff
op_star
id|m
)paren
suffix:semicolon
r_static
r_int
id|sbdma_add_txbuffer
c_func
(paren
id|sbmacdma_t
op_star
id|d
comma
r_struct
id|sk_buff
op_star
id|m
)paren
suffix:semicolon
r_static
r_void
id|sbdma_emptyring
c_func
(paren
id|sbmacdma_t
op_star
id|d
)paren
suffix:semicolon
r_static
r_void
id|sbdma_fillring
c_func
(paren
id|sbmacdma_t
op_star
id|d
)paren
suffix:semicolon
r_static
r_void
id|sbdma_rx_process
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|sc
comma
id|sbmacdma_t
op_star
id|d
)paren
suffix:semicolon
r_static
r_void
id|sbdma_tx_process
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|sc
comma
id|sbmacdma_t
op_star
id|d
)paren
suffix:semicolon
r_static
r_int
id|sbmac_initctx
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
)paren
suffix:semicolon
r_static
r_void
id|sbmac_channel_start
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
)paren
suffix:semicolon
r_static
r_void
id|sbmac_channel_stop
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
)paren
suffix:semicolon
r_static
id|sbmac_state_t
id|sbmac_set_channel_state
c_func
(paren
r_struct
id|sbmac_softc
op_star
comma
id|sbmac_state_t
)paren
suffix:semicolon
r_static
r_void
id|sbmac_promiscuous_mode
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|sc
comma
r_int
id|onoff
)paren
suffix:semicolon
multiline_comment|/*static void sbmac_init_and_start(struct sbmac_softc *sc);*/
r_static
r_uint64
id|sbmac_addr2reg
c_func
(paren
r_int
r_char
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|sbmac_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|rgs
)paren
suffix:semicolon
r_static
r_int
id|sbmac_start_tx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|sbmac_setmulti
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|sc
)paren
suffix:semicolon
r_static
r_int
id|sbmac_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|sbmac_set_speed
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
comma
id|sbmac_speed_t
id|speed
)paren
suffix:semicolon
r_static
r_int
id|sbmac_set_duplex
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
comma
id|sbmac_duplex_t
id|duplex
comma
id|sbmac_fc_t
id|fc
)paren
suffix:semicolon
r_static
r_int
id|sbmac_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|sbmac_timer
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|sbmac_tx_timeout
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|sbmac_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|sbmac_set_rx_mode
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|sbmac_mii_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|sbmac_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|sbmac_mii_poll
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
comma
r_int
id|noisy
)paren
suffix:semicolon
r_static
r_void
id|sbmac_mii_sync
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
)paren
suffix:semicolon
r_static
r_void
id|sbmac_mii_senddata
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
comma
r_int
r_int
id|data
comma
r_int
id|bitcnt
)paren
suffix:semicolon
r_static
r_int
r_int
id|sbmac_mii_read
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
comma
r_int
id|phyaddr
comma
r_int
id|regidx
)paren
suffix:semicolon
r_static
r_void
id|sbmac_mii_write
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
comma
r_int
id|phyaddr
comma
r_int
id|regidx
comma
r_int
r_int
id|regval
)paren
suffix:semicolon
multiline_comment|/**********************************************************************&n; *  Globals&n; ********************************************************************* */
multiline_comment|/**********************************************************************&n; *  MDIO constants&n; ********************************************************************* */
DECL|macro|MII_COMMAND_START
mdefine_line|#define&t;MII_COMMAND_START&t;0x01
DECL|macro|MII_COMMAND_READ
mdefine_line|#define&t;MII_COMMAND_READ&t;0x02
DECL|macro|MII_COMMAND_WRITE
mdefine_line|#define&t;MII_COMMAND_WRITE&t;0x01
DECL|macro|MII_COMMAND_ACK
mdefine_line|#define&t;MII_COMMAND_ACK&t;&t;0x02
DECL|macro|BMCR_RESET
mdefine_line|#define BMCR_RESET     0x8000
DECL|macro|BMCR_LOOPBACK
mdefine_line|#define BMCR_LOOPBACK  0x4000
DECL|macro|BMCR_SPEED0
mdefine_line|#define BMCR_SPEED0    0x2000
DECL|macro|BMCR_ANENABLE
mdefine_line|#define BMCR_ANENABLE  0x1000
DECL|macro|BMCR_POWERDOWN
mdefine_line|#define BMCR_POWERDOWN 0x0800
DECL|macro|BMCR_ISOLATE
mdefine_line|#define BMCR_ISOLATE   0x0400
DECL|macro|BMCR_RESTARTAN
mdefine_line|#define BMCR_RESTARTAN 0x0200
DECL|macro|BMCR_DUPLEX
mdefine_line|#define BMCR_DUPLEX    0x0100
DECL|macro|BMCR_COLTEST
mdefine_line|#define BMCR_COLTEST   0x0080
DECL|macro|BMCR_SPEED1
mdefine_line|#define BMCR_SPEED1    0x0040
DECL|macro|BMCR_SPEED1000
mdefine_line|#define BMCR_SPEED1000 (BMCR_SPEED1|BMCR_SPEED0)
DECL|macro|BMCR_SPEED100
mdefine_line|#define BMCR_SPEED100  (BMCR_SPEED0)
DECL|macro|BMCR_SPEED10
mdefine_line|#define BMCR_SPEED10 &t;0
DECL|macro|BMSR_100BT4
mdefine_line|#define BMSR_100BT4&t;0x8000
DECL|macro|BMSR_100BT_FDX
mdefine_line|#define BMSR_100BT_FDX&t;0x4000
DECL|macro|BMSR_100BT_HDX
mdefine_line|#define BMSR_100BT_HDX  0x2000
DECL|macro|BMSR_10BT_FDX
mdefine_line|#define BMSR_10BT_FDX   0x1000
DECL|macro|BMSR_10BT_HDX
mdefine_line|#define BMSR_10BT_HDX   0x0800
DECL|macro|BMSR_100BT2_FDX
mdefine_line|#define BMSR_100BT2_FDX 0x0400
DECL|macro|BMSR_100BT2_HDX
mdefine_line|#define BMSR_100BT2_HDX 0x0200
DECL|macro|BMSR_1000BT_XSR
mdefine_line|#define BMSR_1000BT_XSR&t;0x0100
DECL|macro|BMSR_PRESUP
mdefine_line|#define BMSR_PRESUP&t;0x0040
DECL|macro|BMSR_ANCOMPLT
mdefine_line|#define BMSR_ANCOMPLT&t;0x0020
DECL|macro|BMSR_REMFAULT
mdefine_line|#define BMSR_REMFAULT&t;0x0010
DECL|macro|BMSR_AUTONEG
mdefine_line|#define BMSR_AUTONEG&t;0x0008
DECL|macro|BMSR_LINKSTAT
mdefine_line|#define BMSR_LINKSTAT&t;0x0004
DECL|macro|BMSR_JABDETECT
mdefine_line|#define BMSR_JABDETECT&t;0x0002
DECL|macro|BMSR_EXTCAPAB
mdefine_line|#define BMSR_EXTCAPAB&t;0x0001
DECL|macro|PHYIDR1
mdefine_line|#define PHYIDR1 &t;0x2000
DECL|macro|PHYIDR2
mdefine_line|#define PHYIDR2&t;&t;0x5C60
DECL|macro|ANAR_NP
mdefine_line|#define ANAR_NP&t;&t;0x8000
DECL|macro|ANAR_RF
mdefine_line|#define ANAR_RF&t;&t;0x2000
DECL|macro|ANAR_ASYPAUSE
mdefine_line|#define ANAR_ASYPAUSE&t;0x0800
DECL|macro|ANAR_PAUSE
mdefine_line|#define ANAR_PAUSE&t;0x0400
DECL|macro|ANAR_T4
mdefine_line|#define ANAR_T4&t;&t;0x0200
DECL|macro|ANAR_TXFD
mdefine_line|#define ANAR_TXFD&t;0x0100
DECL|macro|ANAR_TXHD
mdefine_line|#define ANAR_TXHD&t;0x0080
DECL|macro|ANAR_10FD
mdefine_line|#define ANAR_10FD&t;0x0040
DECL|macro|ANAR_10HD
mdefine_line|#define ANAR_10HD&t;0x0020
DECL|macro|ANAR_PSB
mdefine_line|#define ANAR_PSB&t;0x0001
DECL|macro|ANLPAR_NP
mdefine_line|#define ANLPAR_NP&t;0x8000
DECL|macro|ANLPAR_ACK
mdefine_line|#define ANLPAR_ACK&t;0x4000
DECL|macro|ANLPAR_RF
mdefine_line|#define ANLPAR_RF&t;0x2000
DECL|macro|ANLPAR_ASYPAUSE
mdefine_line|#define ANLPAR_ASYPAUSE&t;0x0800
DECL|macro|ANLPAR_PAUSE
mdefine_line|#define ANLPAR_PAUSE&t;0x0400
DECL|macro|ANLPAR_T4
mdefine_line|#define ANLPAR_T4&t;0x0200
DECL|macro|ANLPAR_TXFD
mdefine_line|#define ANLPAR_TXFD&t;0x0100
DECL|macro|ANLPAR_TXHD
mdefine_line|#define ANLPAR_TXHD&t;0x0080
DECL|macro|ANLPAR_10FD
mdefine_line|#define ANLPAR_10FD&t;0x0040
DECL|macro|ANLPAR_10HD
mdefine_line|#define ANLPAR_10HD&t;0x0020
DECL|macro|ANLPAR_PSB
mdefine_line|#define ANLPAR_PSB&t;0x0001&t;/* 802.3 */
DECL|macro|ANER_PDF
mdefine_line|#define ANER_PDF&t;0x0010
DECL|macro|ANER_LPNPABLE
mdefine_line|#define ANER_LPNPABLE&t;0x0008
DECL|macro|ANER_NPABLE
mdefine_line|#define ANER_NPABLE&t;0x0004
DECL|macro|ANER_PAGERX
mdefine_line|#define ANER_PAGERX&t;0x0002
DECL|macro|ANER_LPANABLE
mdefine_line|#define ANER_LPANABLE&t;0x0001
DECL|macro|ANNPTR_NP
mdefine_line|#define ANNPTR_NP&t;0x8000
DECL|macro|ANNPTR_MP
mdefine_line|#define ANNPTR_MP&t;0x2000
DECL|macro|ANNPTR_ACK2
mdefine_line|#define ANNPTR_ACK2&t;0x1000
DECL|macro|ANNPTR_TOGTX
mdefine_line|#define ANNPTR_TOGTX&t;0x0800
DECL|macro|ANNPTR_CODE
mdefine_line|#define ANNPTR_CODE&t;0x0008
DECL|macro|ANNPRR_NP
mdefine_line|#define ANNPRR_NP&t;0x8000
DECL|macro|ANNPRR_MP
mdefine_line|#define ANNPRR_MP&t;0x2000
DECL|macro|ANNPRR_ACK3
mdefine_line|#define ANNPRR_ACK3&t;0x1000
DECL|macro|ANNPRR_TOGTX
mdefine_line|#define ANNPRR_TOGTX&t;0x0800
DECL|macro|ANNPRR_CODE
mdefine_line|#define ANNPRR_CODE&t;0x0008
DECL|macro|K1TCR_TESTMODE
mdefine_line|#define K1TCR_TESTMODE&t;0x0000
DECL|macro|K1TCR_MSMCE
mdefine_line|#define K1TCR_MSMCE&t;0x1000
DECL|macro|K1TCR_MSCV
mdefine_line|#define K1TCR_MSCV&t;0x0800
DECL|macro|K1TCR_RPTR
mdefine_line|#define K1TCR_RPTR&t;0x0400
DECL|macro|K1TCR_1000BT_FDX
mdefine_line|#define K1TCR_1000BT_FDX 0x200
DECL|macro|K1TCR_1000BT_HDX
mdefine_line|#define K1TCR_1000BT_HDX 0x100
DECL|macro|K1STSR_MSMCFLT
mdefine_line|#define K1STSR_MSMCFLT&t;0x8000
DECL|macro|K1STSR_MSCFGRES
mdefine_line|#define K1STSR_MSCFGRES&t;0x4000
DECL|macro|K1STSR_LRSTAT
mdefine_line|#define K1STSR_LRSTAT&t;0x2000
DECL|macro|K1STSR_RRSTAT
mdefine_line|#define K1STSR_RRSTAT&t;0x1000
DECL|macro|K1STSR_LP1KFD
mdefine_line|#define K1STSR_LP1KFD&t;0x0800
DECL|macro|K1STSR_LP1KHD
mdefine_line|#define K1STSR_LP1KHD   0x0400
DECL|macro|K1STSR_LPASMDIR
mdefine_line|#define K1STSR_LPASMDIR&t;0x0200
DECL|macro|K1SCR_1KX_FDX
mdefine_line|#define K1SCR_1KX_FDX&t;0x8000
DECL|macro|K1SCR_1KX_HDX
mdefine_line|#define K1SCR_1KX_HDX&t;0x4000
DECL|macro|K1SCR_1KT_FDX
mdefine_line|#define K1SCR_1KT_FDX&t;0x2000
DECL|macro|K1SCR_1KT_HDX
mdefine_line|#define K1SCR_1KT_HDX&t;0x1000
DECL|macro|STRAP_PHY1
mdefine_line|#define STRAP_PHY1&t;0x0800
DECL|macro|STRAP_NCMODE
mdefine_line|#define STRAP_NCMODE&t;0x0400
DECL|macro|STRAP_MANMSCFG
mdefine_line|#define STRAP_MANMSCFG&t;0x0200
DECL|macro|STRAP_ANENABLE
mdefine_line|#define STRAP_ANENABLE&t;0x0100
DECL|macro|STRAP_MSVAL
mdefine_line|#define STRAP_MSVAL&t;0x0080
DECL|macro|STRAP_1KHDXADV
mdefine_line|#define STRAP_1KHDXADV&t;0x0010
DECL|macro|STRAP_1KFDXADV
mdefine_line|#define STRAP_1KFDXADV&t;0x0008
DECL|macro|STRAP_100ADV
mdefine_line|#define STRAP_100ADV&t;0x0004
DECL|macro|STRAP_SPEEDSEL
mdefine_line|#define STRAP_SPEEDSEL&t;0x0000
DECL|macro|STRAP_SPEED100
mdefine_line|#define STRAP_SPEED100&t;0x0001
DECL|macro|PHYSUP_SPEED1000
mdefine_line|#define PHYSUP_SPEED1000 0x10
DECL|macro|PHYSUP_SPEED100
mdefine_line|#define PHYSUP_SPEED100  0x08
DECL|macro|PHYSUP_SPEED10
mdefine_line|#define PHYSUP_SPEED10   0x00
DECL|macro|PHYSUP_LINKUP
mdefine_line|#define PHYSUP_LINKUP&t; 0x04
DECL|macro|PHYSUP_FDX
mdefine_line|#define PHYSUP_FDX       0x02
DECL|macro|MII_BMCR
mdefine_line|#define&t;MII_BMCR&t;0x00 &t;/* Basic mode control register (rw) */
DECL|macro|MII_BMSR
mdefine_line|#define&t;MII_BMSR&t;0x01&t;/* Basic mode status register (ro) */
DECL|macro|MII_K1STSR
mdefine_line|#define MII_K1STSR&t;0x0A&t;/* 1K Status Register (ro) */
DECL|macro|MII_ANLPAR
mdefine_line|#define&t;MII_ANLPAR&t;0x05&t;/* Autonegotiation lnk partner abilities (rw) */
DECL|macro|M_MAC_MDIO_DIR_OUTPUT
mdefine_line|#define M_MAC_MDIO_DIR_OUTPUT&t;0&t;&t;/* for clarity */
multiline_comment|/**********************************************************************&n; *  SBMAC_MII_SYNC(s)&n; *  &n; *  Synchronize with the MII - send a pattern of bits to the MII&n; *  that will guarantee that it is ready to accept a command.&n; *  &n; *  Input parameters: &n; *  &t;   s - sbmac structure&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbmac_mii_sync
r_static
r_void
id|sbmac_mii_sync
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_uint64
id|bits
suffix:semicolon
id|bits
op_assign
id|M_MAC_MDIO_DIR_OUTPUT
op_or
id|M_MAC_MDIO_OUT
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|bits
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|32
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|bits
op_or
id|M_MAC_MDC
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|bits
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_MII_SENDDATA(s,data,bitcnt)&n; *  &n; *  Send some bits to the MII.  The bits to be sent are right-&n; *  justified in the &squot;data&squot; parameter.&n; *  &n; *  Input parameters: &n; *  &t;   s - sbmac structure&n; *  &t;   data - data to send&n; *  &t;   bitcnt - number of bits to send&n; ********************************************************************* */
DECL|function|sbmac_mii_senddata
r_static
r_void
id|sbmac_mii_senddata
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
comma
r_int
r_int
id|data
comma
r_int
id|bitcnt
)paren
(brace
r_int
id|i
suffix:semicolon
r_uint64
id|bits
suffix:semicolon
r_int
r_int
id|curmask
suffix:semicolon
id|bits
op_assign
id|M_MAC_MDIO_DIR_OUTPUT
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|bits
)paren
suffix:semicolon
id|curmask
op_assign
l_int|1
op_lshift
(paren
id|bitcnt
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bitcnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
op_amp
id|curmask
)paren
id|bits
op_or_assign
id|M_MAC_MDIO_OUT
suffix:semicolon
r_else
id|bits
op_and_assign
op_complement
id|M_MAC_MDIO_OUT
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|bits
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|bits
op_or
id|M_MAC_MDC
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|bits
)paren
suffix:semicolon
id|curmask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_MII_READ(s,phyaddr,regidx)&n; *  &n; *  Read a PHY register.&n; *  &n; *  Input parameters: &n; *  &t;   s - sbmac structure&n; *  &t;   phyaddr - PHY&squot;s address&n; *  &t;   regidx = index of register to read&n; *  &t;   &n; *  Return value:&n; *  &t;   value read, or 0 if an error occured.&n; ********************************************************************* */
DECL|function|sbmac_mii_read
r_static
r_int
r_int
id|sbmac_mii_read
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
comma
r_int
id|phyaddr
comma
r_int
id|regidx
)paren
(brace
r_int
id|idx
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|regval
suffix:semicolon
multiline_comment|/*&n;&t; * Synchronize ourselves so that the PHY knows the next&n;&t; * thing coming down is a command&n;&t; */
id|sbmac_mii_sync
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Send the data to the PHY.  The sequence is&n;&t; * a &quot;start&quot; command (2 bits)&n;&t; * a &quot;read&quot; command (2 bits)&n;&t; * the PHY addr (5 bits)&n;&t; * the register index (5 bits)&n;&t; */
id|sbmac_mii_senddata
c_func
(paren
id|s
comma
id|MII_COMMAND_START
comma
l_int|2
)paren
suffix:semicolon
id|sbmac_mii_senddata
c_func
(paren
id|s
comma
id|MII_COMMAND_READ
comma
l_int|2
)paren
suffix:semicolon
id|sbmac_mii_senddata
c_func
(paren
id|s
comma
id|phyaddr
comma
l_int|5
)paren
suffix:semicolon
id|sbmac_mii_senddata
c_func
(paren
id|s
comma
id|regidx
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Switch the port around without a clock transition.&n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|M_MAC_MDIO_DIR_INPUT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Send out a clock pulse to signal we want the status&n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|M_MAC_MDIO_DIR_INPUT
op_or
id|M_MAC_MDC
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|M_MAC_MDIO_DIR_INPUT
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * If an error occured, the PHY will signal &squot;1&squot; back&n;&t; */
id|error
op_assign
id|SBMAC_READCSR
c_func
(paren
id|s-&gt;sbm_mdio
)paren
op_amp
id|M_MAC_MDIO_IN
suffix:semicolon
multiline_comment|/* &n;&t; * Issue an &squot;idle&squot; clock pulse, but keep the direction&n;&t; * the same.&n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|M_MAC_MDIO_DIR_INPUT
op_or
id|M_MAC_MDC
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|M_MAC_MDIO_DIR_INPUT
)paren
suffix:semicolon
id|regval
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|16
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|regval
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|SBMAC_READCSR
c_func
(paren
id|s-&gt;sbm_mdio
)paren
op_amp
id|M_MAC_MDIO_IN
)paren
id|regval
op_or_assign
l_int|1
suffix:semicolon
)brace
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|M_MAC_MDIO_DIR_INPUT
op_or
id|M_MAC_MDC
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|M_MAC_MDIO_DIR_INPUT
)paren
suffix:semicolon
)brace
multiline_comment|/* Switch back to output */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|M_MAC_MDIO_DIR_OUTPUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
r_return
id|regval
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_MII_WRITE(s,phyaddr,regidx,regval)&n; *  &n; *  Write a value to a PHY register.&n; *  &n; *  Input parameters: &n; *  &t;   s - sbmac structure&n; *  &t;   phyaddr - PHY to use&n; *  &t;   regidx - register within the PHY&n; *  &t;   regval - data to write to register&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbmac_mii_write
r_static
r_void
id|sbmac_mii_write
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
comma
r_int
id|phyaddr
comma
r_int
id|regidx
comma
r_int
r_int
id|regval
)paren
(brace
id|sbmac_mii_sync
c_func
(paren
id|s
)paren
suffix:semicolon
id|sbmac_mii_senddata
c_func
(paren
id|s
comma
id|MII_COMMAND_START
comma
l_int|2
)paren
suffix:semicolon
id|sbmac_mii_senddata
c_func
(paren
id|s
comma
id|MII_COMMAND_WRITE
comma
l_int|2
)paren
suffix:semicolon
id|sbmac_mii_senddata
c_func
(paren
id|s
comma
id|phyaddr
comma
l_int|5
)paren
suffix:semicolon
id|sbmac_mii_senddata
c_func
(paren
id|s
comma
id|regidx
comma
l_int|5
)paren
suffix:semicolon
id|sbmac_mii_senddata
c_func
(paren
id|s
comma
id|MII_COMMAND_ACK
comma
l_int|2
)paren
suffix:semicolon
id|sbmac_mii_senddata
c_func
(paren
id|s
comma
id|regval
comma
l_int|16
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_mdio
comma
id|M_MAC_MDIO_DIR_OUTPUT
)paren
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBDMA_INITCTX(d,s,chan,txrx,maxdescr)&n; *  &n; *  Initialize a DMA channel context.  Since there are potentially&n; *  eight DMA channels per MAC, it&squot;s nice to do this in a standard&n; *  way.  &n; *  &n; *  Input parameters: &n; *  &t;   d - sbmacdma_t structure (DMA channel context)&n; *  &t;   s - sbmac_softc structure (pointer to a MAC)&n; *  &t;   chan - channel number (0..1 right now)&n; *  &t;   txrx - Identifies DMA_TX or DMA_RX for channel direction&n; *      maxdescr - number of descriptors&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbdma_initctx
r_static
r_void
id|sbdma_initctx
c_func
(paren
id|sbmacdma_t
op_star
id|d
comma
r_struct
id|sbmac_softc
op_star
id|s
comma
r_int
id|chan
comma
r_int
id|txrx
comma
r_int
id|maxdescr
)paren
(brace
multiline_comment|/* &n;&t; * Save away interesting stuff in the structure &n;&t; */
id|d-&gt;sbdma_eth
op_assign
id|s
suffix:semicolon
id|d-&gt;sbdma_channel
op_assign
id|chan
suffix:semicolon
id|d-&gt;sbdma_txdir
op_assign
id|txrx
suffix:semicolon
multiline_comment|/* &n;&t; * initialize register pointers &n;&t; */
id|d-&gt;sbdma_config0
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_DMA_REGISTER
c_func
(paren
id|txrx
comma
id|chan
comma
id|R_MAC_DMA_CONFIG0
)paren
)paren
suffix:semicolon
id|d-&gt;sbdma_config1
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_DMA_REGISTER
c_func
(paren
id|txrx
comma
id|chan
comma
id|R_MAC_DMA_CONFIG0
)paren
)paren
suffix:semicolon
id|d-&gt;sbdma_dscrbase
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_DMA_REGISTER
c_func
(paren
id|txrx
comma
id|chan
comma
id|R_MAC_DMA_DSCR_BASE
)paren
)paren
suffix:semicolon
id|d-&gt;sbdma_dscrcnt
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_DMA_REGISTER
c_func
(paren
id|txrx
comma
id|chan
comma
id|R_MAC_DMA_DSCR_CNT
)paren
)paren
suffix:semicolon
id|d-&gt;sbdma_curdscr
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_DMA_REGISTER
c_func
(paren
id|txrx
comma
id|chan
comma
id|R_MAC_DMA_CUR_DSCRADDR
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate memory for the ring&n;&t; */
id|d-&gt;sbdma_maxdescr
op_assign
id|maxdescr
suffix:semicolon
id|d-&gt;sbdma_dscrtable
op_assign
(paren
id|sbdmadscr_t
op_star
)paren
id|KMALLOC
c_func
(paren
id|d-&gt;sbdma_maxdescr
op_star
r_sizeof
(paren
id|sbdmadscr_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|d-&gt;sbdma_dscrtable
comma
l_int|0
comma
id|d-&gt;sbdma_maxdescr
op_star
r_sizeof
(paren
id|sbdmadscr_t
)paren
)paren
suffix:semicolon
id|d-&gt;sbdma_dscrtable_end
op_assign
id|d-&gt;sbdma_dscrtable
op_plus
id|d-&gt;sbdma_maxdescr
suffix:semicolon
id|d-&gt;sbdma_dscrtable_phys
op_assign
id|KVTOPHYS
c_func
(paren
id|d-&gt;sbdma_dscrtable
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * And context table&n;&t; */
id|d-&gt;sbdma_ctxtable
op_assign
(paren
r_struct
id|sk_buff
op_star
op_star
)paren
id|KMALLOC
c_func
(paren
id|d-&gt;sbdma_maxdescr
op_star
r_sizeof
(paren
r_struct
id|sk_buff
op_star
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|d-&gt;sbdma_ctxtable
comma
l_int|0
comma
id|d-&gt;sbdma_maxdescr
op_star
r_sizeof
(paren
r_struct
id|sk_buff
op_star
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBDMA_CHANNEL_START(d)&n; *  &n; *  Initialize the hardware registers for a DMA channel.&n; *  &n; *  Input parameters: &n; *  &t;   d - DMA channel to init (context must be previously init&squot;d&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbdma_channel_start
r_static
r_void
id|sbdma_channel_start
c_func
(paren
id|sbmacdma_t
op_star
id|d
)paren
(brace
multiline_comment|/*&n;&t; * Turn on the DMA channel&n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|d-&gt;sbdma_config1
comma
l_int|0
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|d-&gt;sbdma_dscrbase
comma
id|d-&gt;sbdma_dscrtable_phys
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|d-&gt;sbdma_config0
comma
id|V_DMA_RINGSZ
c_func
(paren
id|d-&gt;sbdma_maxdescr
)paren
op_or
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize ring pointers&n;&t; */
id|d-&gt;sbdma_addptr
op_assign
id|d-&gt;sbdma_dscrtable
suffix:semicolon
id|d-&gt;sbdma_remptr
op_assign
id|d-&gt;sbdma_dscrtable
suffix:semicolon
)brace
DECL|function|sbdma_align_skb
r_static
r_void
id|sbdma_align_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|power2
comma
r_int
id|offset
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
r_int
id|newaddr
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|skb-&gt;data
suffix:semicolon
id|newaddr
op_assign
(paren
id|addr
op_plus
id|power2
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|power2
op_minus
l_int|1
)paren
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
id|newaddr
op_minus
id|addr
op_plus
id|offset
)paren
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBDMA_ADD_RCVBUFFER(d,sb)&n; *  &n; *  Add a buffer to the specified DMA channel.   For receive channels,&n; *  this queues a buffer for inbound packets.&n; *  &n; *  Input parameters: &n; *  &t;   d - DMA channel descriptor&n; * &t;   sb - sk_buff to add, or NULL if we should allocate one&n; *  &t;   &n; *  Return value:&n; *  &t;   0 if buffer could not be added (ring is full)&n; *  &t;   1 if buffer added successfully&n; ********************************************************************* */
DECL|function|sbdma_add_rcvbuffer
r_static
r_int
id|sbdma_add_rcvbuffer
c_func
(paren
id|sbmacdma_t
op_star
id|d
comma
r_struct
id|sk_buff
op_star
id|sb
)paren
(brace
id|sbdmadscr_t
op_star
id|dsc
suffix:semicolon
id|sbdmadscr_t
op_star
id|nextdsc
suffix:semicolon
r_struct
id|sk_buff
op_star
id|sb_new
op_assign
l_int|NULL
suffix:semicolon
r_int
id|pktsize
op_assign
id|ENET_PACKET_SIZE
suffix:semicolon
multiline_comment|/* get pointer to our current place in the ring */
id|dsc
op_assign
id|d-&gt;sbdma_addptr
suffix:semicolon
id|nextdsc
op_assign
id|SBDMA_NEXTBUF
c_func
(paren
id|d
comma
id|sbdma_addptr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * figure out if the ring is full - if the next descriptor&n;&t; * is the same as the one that we&squot;re going to remove from&n;&t; * the ring, the ring is full&n;&t; */
r_if
c_cond
(paren
id|nextdsc
op_eq
id|d-&gt;sbdma_remptr
)paren
(brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Allocate a sk_buff if we don&squot;t already have one.  &n;&t; * If we do have an sk_buff, reset it so that it&squot;s empty.&n;&t; *&n;&t; * Note: sk_buffs don&squot;t seem to be guaranteed to have any sort&n;&t; * of alignment when they are allocated.  Therefore, allocate enough&n;&t; * extra space to make sure that:&n;&t; *&n;&t; *    1. the data does not start in the middle of a cache line.&n;&t; *    2. The data does not end in the middle of a cache line&n;&t; * &t;  3. The buffer can be aligned such that the IP addresses are &n;&t; *       naturally aligned.&n;&t; *&n;&t; *  Remember, the SB1250&squot;s MAC writes whole cache lines at a time,&n;&t; *  without reading the old contents first.  So, if the sk_buff&squot;s&n;&t; *  data portion starts in the middle of a cache line, the SB1250&n;&t; *  DMA will trash the beginning (and ending) portions.&n;&t; */
r_if
c_cond
(paren
id|sb
op_eq
l_int|NULL
)paren
(brace
id|sb_new
op_assign
id|dev_alloc_skb
c_func
(paren
id|ENET_PACKET_SIZE
op_plus
id|CACHELINESIZE
op_star
l_int|2
op_plus
id|ETHER_ALIGN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb_new
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: sk_buff allocation failed&bslash;n&quot;
comma
id|d-&gt;sbdma_eth-&gt;sbm_dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|sbdma_align_skb
c_func
(paren
id|sb_new
comma
id|CACHELINESIZE
comma
id|ETHER_ALIGN
)paren
suffix:semicolon
multiline_comment|/* mark skbuff owned by our device */
id|sb_new-&gt;dev
op_assign
id|d-&gt;sbdma_eth-&gt;sbm_dev
suffix:semicolon
)brace
r_else
(brace
id|sb_new
op_assign
id|sb
suffix:semicolon
multiline_comment|/* &n;&t;&t; * nothing special to reinit buffer, it&squot;s already aligned&n;&t;&t; * and sb-&gt;tail already points to a good place.&n;&t;&t; */
)brace
multiline_comment|/*&n;&t; * fill in the descriptor &n;&t; */
id|dsc-&gt;dscr_a
op_assign
id|KVTOPHYS
c_func
(paren
id|sb_new-&gt;tail
)paren
op_or
id|V_DMA_DSCRA_A_SIZE
c_func
(paren
id|NUMCACHEBLKS
c_func
(paren
id|pktsize
op_plus
id|ETHER_ALIGN
)paren
)paren
op_or
id|M_DMA_DSCRA_INTERRUPT
suffix:semicolon
multiline_comment|/* receiving: no options */
id|dsc-&gt;dscr_b
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * fill in the context &n;&t; */
id|d-&gt;sbdma_ctxtable
(braket
id|dsc
op_minus
id|d-&gt;sbdma_dscrtable
)braket
op_assign
id|sb_new
suffix:semicolon
multiline_comment|/* &n;&t; * point at next packet &n;&t; */
id|d-&gt;sbdma_addptr
op_assign
id|nextdsc
suffix:semicolon
multiline_comment|/* &n;&t; * Give the buffer to the DMA engine.&n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|d-&gt;sbdma_dscrcnt
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we did it */
)brace
multiline_comment|/**********************************************************************&n; *  SBDMA_ADD_TXBUFFER(d,sb)&n; *  &n; *  Add a transmit buffer to the specified DMA channel, causing a&n; *  transmit to start.&n; *  &n; *  Input parameters: &n; *  &t;   d - DMA channel descriptor&n; * &t;   sb - sk_buff to add&n; *  &t;   &n; *  Return value:&n; *  &t;   0 transmit queued successfully&n; *  &t;   otherwise error code&n; ********************************************************************* */
DECL|function|sbdma_add_txbuffer
r_static
r_int
id|sbdma_add_txbuffer
c_func
(paren
id|sbmacdma_t
op_star
id|d
comma
r_struct
id|sk_buff
op_star
id|sb
)paren
(brace
id|sbdmadscr_t
op_star
id|dsc
suffix:semicolon
id|sbdmadscr_t
op_star
id|nextdsc
suffix:semicolon
r_uint64
id|phys
suffix:semicolon
r_uint64
id|ncb
suffix:semicolon
r_int
id|length
suffix:semicolon
multiline_comment|/* get pointer to our current place in the ring */
id|dsc
op_assign
id|d-&gt;sbdma_addptr
suffix:semicolon
id|nextdsc
op_assign
id|SBDMA_NEXTBUF
c_func
(paren
id|d
comma
id|sbdma_addptr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * figure out if the ring is full - if the next descriptor&n;&t; * is the same as the one that we&squot;re going to remove from&n;&t; * the ring, the ring is full&n;&t; */
r_if
c_cond
(paren
id|nextdsc
op_eq
id|d-&gt;sbdma_remptr
)paren
(brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Under Linux, it&squot;s not necessary to copy/coalesce buffers&n;&t; * like it is on NetBSD.  We think they&squot;re all contiguous,&n;&t; * but that may not be true for GBE.&n;&t; */
id|length
op_assign
id|sb-&gt;len
suffix:semicolon
multiline_comment|/*&n;&t; * fill in the descriptor.  Note that the number of cache&n;&t; * blocks in the descriptor is the number of blocks&n;&t; * *spanned*, so we need to add in the offset (if any)&n;&t; * while doing the calculation.&n;&t; */
id|phys
op_assign
id|KVTOPHYS
c_func
(paren
id|sb-&gt;data
)paren
suffix:semicolon
id|ncb
op_assign
id|NUMCACHEBLKS
c_func
(paren
id|length
op_plus
(paren
id|phys
op_amp
(paren
id|CACHELINESIZE
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|dsc-&gt;dscr_a
op_assign
id|phys
op_or
id|V_DMA_DSCRA_A_SIZE
c_func
(paren
id|ncb
)paren
op_or
id|M_DMA_DSCRA_INTERRUPT
op_or
id|M_DMA_ETHTX_SOP
suffix:semicolon
multiline_comment|/* transmitting: set outbound options and length */
id|dsc-&gt;dscr_b
op_assign
id|V_DMA_DSCRB_OPTIONS
c_func
(paren
id|K_DMA_ETHTX_APPENDCRC_APPENDPAD
)paren
op_or
id|V_DMA_DSCRB_PKT_SIZE
c_func
(paren
id|length
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * fill in the context &n;&t; */
id|d-&gt;sbdma_ctxtable
(braket
id|dsc
op_minus
id|d-&gt;sbdma_dscrtable
)braket
op_assign
id|sb
suffix:semicolon
multiline_comment|/* &n;&t; * point at next packet &n;&t; */
id|d-&gt;sbdma_addptr
op_assign
id|nextdsc
suffix:semicolon
multiline_comment|/* &n;&t; * Give the buffer to the DMA engine.&n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|d-&gt;sbdma_dscrcnt
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we did it */
)brace
multiline_comment|/**********************************************************************&n; *  SBDMA_EMPTYRING(d)&n; *  &n; *  Free all allocated sk_buffs on the specified DMA channel;&n; *  &n; *  Input parameters: &n; *  &t;   d  - DMA channel&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbdma_emptyring
r_static
r_void
id|sbdma_emptyring
c_func
(paren
id|sbmacdma_t
op_star
id|d
)paren
(brace
r_int
id|idx
suffix:semicolon
r_struct
id|sk_buff
op_star
id|sb
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|d-&gt;sbdma_maxdescr
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|sb
op_assign
id|d-&gt;sbdma_ctxtable
(braket
id|idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|sb
)paren
suffix:semicolon
id|d-&gt;sbdma_ctxtable
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**********************************************************************&n; *  SBDMA_FILLRING(d)&n; *  &n; *  Fill the specified DMA channel (must be receive channel)&n; *  with sk_buffs&n; *  &n; *  Input parameters: &n; *  &t;   d - DMA channel&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbdma_fillring
r_static
r_void
id|sbdma_fillring
c_func
(paren
id|sbmacdma_t
op_star
id|d
)paren
(brace
r_int
id|idx
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|SBMAC_MAX_RXDESCR
op_minus
l_int|1
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sbdma_add_rcvbuffer
c_func
(paren
id|d
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/**********************************************************************&n; *  SBDMA_RX_PROCESS(sc,d)&n; *  &n; *  Process &quot;completed&quot; receive buffers on the specified DMA channel.  &n; *  Note that this isn&squot;t really ideal for priority channels, since&n; *  it processes all of the packets on a given channel before &n; *  returning. &n; *&n; *  Input parameters: &n; *&t;   sc - softc structure&n; *  &t;   d - DMA channel context&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbdma_rx_process
r_static
r_void
id|sbdma_rx_process
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|sc
comma
id|sbmacdma_t
op_star
id|d
)paren
(brace
r_int
id|curidx
suffix:semicolon
r_int
id|hwidx
suffix:semicolon
id|sbdmadscr_t
op_star
id|dsc
suffix:semicolon
r_struct
id|sk_buff
op_star
id|sb
suffix:semicolon
r_int
id|len
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* &n;&t;&t; * figure out where we are (as an index) and where&n;&t;&t; * the hardware is (also as an index)&n;&t;&t; *&n;&t;&t; * This could be done faster if (for example) the &n;&t;&t; * descriptor table was page-aligned and contiguous in&n;&t;&t; * both virtual and physical memory -- you could then&n;&t;&t; * just compare the low-order bits of the virtual address&n;&t;&t; * (sbdma_remptr) and the physical address (sbdma_curdscr CSR)&n;&t;&t; */
id|curidx
op_assign
id|d-&gt;sbdma_remptr
op_minus
id|d-&gt;sbdma_dscrtable
suffix:semicolon
id|hwidx
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|SBMAC_READCSR
c_func
(paren
id|d-&gt;sbdma_curdscr
)paren
op_amp
id|M_DMA_CURDSCR_ADDR
)paren
op_minus
id|d-&gt;sbdma_dscrtable_phys
)paren
op_div
r_sizeof
(paren
id|sbdmadscr_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If they&squot;re the same, that means we&squot;ve processed all&n;&t;&t; * of the descriptors up to (but not including) the one that&n;&t;&t; * the hardware is working on right now.&n;&t;&t; */
r_if
c_cond
(paren
id|curidx
op_eq
id|hwidx
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Otherwise, get the packet&squot;s sk_buff ptr back&n;&t;&t; */
id|dsc
op_assign
op_amp
(paren
id|d-&gt;sbdma_dscrtable
(braket
id|curidx
)braket
)paren
suffix:semicolon
id|sb
op_assign
id|d-&gt;sbdma_ctxtable
(braket
id|curidx
)braket
suffix:semicolon
id|d-&gt;sbdma_ctxtable
(braket
id|curidx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|len
op_assign
(paren
r_int
)paren
id|G_DMA_DSCRB_PKT_SIZE
c_func
(paren
id|dsc-&gt;dscr_b
)paren
op_minus
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check packet status.  If good, process it.&n;&t;&t; * If not, silently drop it and put it back on the&n;&t;&t; * receive ring.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dsc-&gt;dscr_a
op_amp
id|M_DMA_ETHRX_BAD
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Set length into the packet&n;&t;&t;&t; */
id|skb_put
c_func
(paren
id|sb
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Add a new buffer to replace the old one.  If we fail&n;&t;&t;&t; * to allocate a buffer, we&squot;re going to drop this&n;&t;&t;&t; * packet and put it right back on the receive ring.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sbdma_add_rcvbuffer
c_func
(paren
id|d
comma
l_int|NULL
)paren
op_eq
op_minus
id|ENOBUFS
)paren
(brace
id|sbdma_add_rcvbuffer
c_func
(paren
id|d
comma
id|sb
)paren
suffix:semicolon
multiline_comment|/* re-add old buffer */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;     * Buffer has been replaced on the receive ring.&n;&t;&t;&t;     * Pass the buffer to the kernel&n;&t;&t;&t;     */
id|sc-&gt;sbm_stats.rx_bytes
op_add_assign
id|len
suffix:semicolon
id|sc-&gt;sbm_stats.rx_packets
op_increment
suffix:semicolon
id|sb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|sb
comma
id|d-&gt;sbdma_eth-&gt;sbm_dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Packet was mangled somehow.  Just drop it and&n;&t;&t;&t; * put it back on the receive ring.&n;&t;&t;&t; */
id|sbdma_add_rcvbuffer
c_func
(paren
id|d
comma
id|sb
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * .. and advance to the next buffer.&n;&t;&t; */
id|d-&gt;sbdma_remptr
op_assign
id|SBDMA_NEXTBUF
c_func
(paren
id|d
comma
id|sbdma_remptr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**********************************************************************&n; *  SBDMA_TX_PROCESS(sc,d)&n; *  &n; *  Process &quot;completed&quot; transmit buffers on the specified DMA channel.  &n; *  This is normally called within the interrupt service routine.&n; *  Note that this isn&squot;t really ideal for priority channels, since&n; *  it processes all of the packets on a given channel before &n; *  returning. &n; *&n; *  Input parameters: &n; *      sc - softc structure&n; *  &t;   d - DMA channel context&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbdma_tx_process
r_static
r_void
id|sbdma_tx_process
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|sc
comma
id|sbmacdma_t
op_star
id|d
)paren
(brace
r_int
id|curidx
suffix:semicolon
r_int
id|hwidx
suffix:semicolon
id|sbdmadscr_t
op_star
id|dsc
suffix:semicolon
r_struct
id|sk_buff
op_star
id|sb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|sc-&gt;sbm_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* &n;&t;&t; * figure out where we are (as an index) and where&n;&t;&t; * the hardware is (also as an index)&n;&t;&t; *&n;&t;&t; * This could be done faster if (for example) the &n;&t;&t; * descriptor table was page-aligned and contiguous in&n;&t;&t; * both virtual and physical memory -- you could then&n;&t;&t; * just compare the low-order bits of the virtual address&n;&t;&t; * (sbdma_remptr) and the physical address (sbdma_curdscr CSR)&n;&t;&t; */
id|curidx
op_assign
id|d-&gt;sbdma_remptr
op_minus
id|d-&gt;sbdma_dscrtable
suffix:semicolon
(brace
multiline_comment|/* XXX This is gross, ugly, and only here because justin hacked it&n;&t;&t;&t;   in to fix a problem without really understanding it. &n;&t;&t;&t;   &n;&t;&t;&t;   It seems that, for whatever reason, this routine is invoked immediately upon the enabling of interrupts.&n;&t;&t;&t;   So then the Read below returns zero, making hwidx a negative number, and anti-hilarity&n;&t;&t;&t;   ensues.&n;&t;&t;&t;   &n;&t;&t;&t;   I&squot;m guessing there&squot;s a proper fix involving clearing out interrupt state from old packets&n;&t;&t;&t;   before enabling interrupts, but I&squot;m not sure.  &n;&n;&t;&t;&t;   Anyways, this hack seems to work, and is Good Enough for 11 PM.  :)&n;&t;&t;&t;   &n;&t;&t;&t;   -Justin&n;&t;&t;&t;*/
r_uint64
id|tmp
op_assign
id|SBMAC_READCSR
c_func
(paren
id|d-&gt;sbdma_curdscr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
r_break
suffix:semicolon
)brace
id|hwidx
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|tmp
op_amp
id|M_DMA_CURDSCR_ADDR
)paren
op_minus
id|d-&gt;sbdma_dscrtable_phys
)paren
op_div
r_sizeof
(paren
id|sbdmadscr_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If they&squot;re the same, that means we&squot;ve processed all&n;&t;&t; * of the descriptors up to (but not including) the one that&n;&t;&t; * the hardware is working on right now.&n;&t;&t; */
r_if
c_cond
(paren
id|curidx
op_eq
id|hwidx
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Otherwise, get the packet&squot;s sk_buff ptr back&n;&t;&t; */
id|dsc
op_assign
op_amp
(paren
id|d-&gt;sbdma_dscrtable
(braket
id|curidx
)braket
)paren
suffix:semicolon
id|sb
op_assign
id|d-&gt;sbdma_ctxtable
(braket
id|curidx
)braket
suffix:semicolon
id|d-&gt;sbdma_ctxtable
(braket
id|curidx
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Stats&n;&t;&t; */
id|sc-&gt;sbm_stats.tx_bytes
op_add_assign
id|sb-&gt;len
suffix:semicolon
id|sc-&gt;sbm_stats.tx_packets
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * for transmits, we just free buffers.&n;&t;&t; */
id|dev_kfree_skb_irq
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * .. and advance to the next buffer.&n;&t;&t; */
id|d-&gt;sbdma_remptr
op_assign
id|SBDMA_NEXTBUF
c_func
(paren
id|d
comma
id|sbdma_remptr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Decide if we should wake up the protocol or not.&n;&t; * Other drivers seem to do this when we reach a low&n;&t; * watermark on the transmit queue.&n;&t; */
id|netif_wake_queue
c_func
(paren
id|d-&gt;sbdma_eth-&gt;sbm_dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|sc-&gt;sbm_lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_INITCTX(s)&n; *  &n; *  Initialize an Ethernet context structure - this is called&n; *  once per MAC on the 1250.  Memory is allocated here, so don&squot;t&n; *  call it again from inside the ioctl routines that bring the&n; *  interface up/down&n; *  &n; *  Input parameters: &n; *  &t;   s - sbmac context structure&n; *  &t;   &n; *  Return value:&n; *  &t;   0&n; ********************************************************************* */
DECL|function|sbmac_initctx
r_static
r_int
id|sbmac_initctx
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
)paren
(brace
multiline_comment|/* &n;&t; * figure out the addresses of some ports &n;&t; */
id|s-&gt;sbm_macenable
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_ENABLE
)paren
suffix:semicolon
id|s-&gt;sbm_maccfg
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_CFG
)paren
suffix:semicolon
id|s-&gt;sbm_fifocfg
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_THRSH_CFG
)paren
suffix:semicolon
id|s-&gt;sbm_framecfg
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_FRAMECFG
)paren
suffix:semicolon
id|s-&gt;sbm_rxfilter
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_ADFILTER_CFG
)paren
suffix:semicolon
id|s-&gt;sbm_isr
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_STATUS
)paren
suffix:semicolon
id|s-&gt;sbm_imr
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_INT_MASK
)paren
suffix:semicolon
id|s-&gt;sbm_mdio
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_MDIO
)paren
suffix:semicolon
id|s-&gt;sbm_phys
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
id|s-&gt;sbm_phys
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|s-&gt;sbm_phy_oldbmsr
op_assign
l_int|0
suffix:semicolon
id|s-&gt;sbm_phy_oldanlpar
op_assign
l_int|0
suffix:semicolon
id|s-&gt;sbm_phy_oldk1stsr
op_assign
l_int|0
suffix:semicolon
id|s-&gt;sbm_phy_oldlinkstat
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the DMA channels.  Right now, only one per MAC is used&n;&t; * Note: Only do this _once_, as it allocates memory from the kernel!&n;&t; */
id|sbdma_initctx
c_func
(paren
op_amp
(paren
id|s-&gt;sbm_txdma
)paren
comma
id|s
comma
l_int|0
comma
id|DMA_TX
comma
id|SBMAC_MAX_TXDESCR
)paren
suffix:semicolon
id|sbdma_initctx
c_func
(paren
op_amp
(paren
id|s-&gt;sbm_rxdma
)paren
comma
id|s
comma
l_int|0
comma
id|DMA_RX
comma
id|SBMAC_MAX_RXDESCR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initial state is OFF&n;&t; */
id|s-&gt;sbm_state
op_assign
id|sbmac_state_off
suffix:semicolon
multiline_comment|/*&n;&t; * Initial speed is (XXX TEMP) 10MBit/s HDX no FC&n;&t; */
id|s-&gt;sbm_speed
op_assign
id|sbmac_speed_10
suffix:semicolon
id|s-&gt;sbm_duplex
op_assign
id|sbmac_duplex_half
suffix:semicolon
id|s-&gt;sbm_fc
op_assign
id|sbmac_fc_disabled
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sbdma_uninitctx
r_static
r_void
id|sbdma_uninitctx
c_func
(paren
r_struct
id|sbmacdma_s
op_star
id|d
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;sbdma_dscrtable
)paren
(brace
id|KFREE
c_func
(paren
id|d-&gt;sbdma_dscrtable
)paren
suffix:semicolon
id|d-&gt;sbdma_dscrtable
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;sbdma_ctxtable
)paren
(brace
id|KFREE
c_func
(paren
id|d-&gt;sbdma_ctxtable
)paren
suffix:semicolon
id|d-&gt;sbdma_ctxtable
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|sbmac_uninitctx
r_static
r_void
id|sbmac_uninitctx
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|sc
)paren
(brace
id|sbdma_uninitctx
c_func
(paren
op_amp
(paren
id|sc-&gt;sbm_txdma
)paren
)paren
suffix:semicolon
id|sbdma_uninitctx
c_func
(paren
op_amp
(paren
id|sc-&gt;sbm_rxdma
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_CHANNEL_START(s)&n; *  &n; *  Start packet processing on this MAC.&n; *  &n; *  Input parameters: &n; *  &t;   s - sbmac structure&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbmac_channel_start
r_static
r_void
id|sbmac_channel_start
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
)paren
(brace
r_uint64
id|reg
suffix:semicolon
id|sbmac_port_t
id|port
suffix:semicolon
r_uint64
id|cfg
comma
id|fifo
comma
id|framecfg
suffix:semicolon
r_int
id|idx
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t do this if running&n;&t; */
r_if
c_cond
(paren
id|s-&gt;sbm_state
op_eq
id|sbmac_state_on
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Bring the controller out of reset, but leave it off.&n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_macenable
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ignore all received packets&n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_rxfilter
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Calculate values for various control registers.&n;&t; */
id|cfg
op_assign
id|M_MAC_RETRY_EN
op_or
id|M_MAC_TX_HOLD_SOP_EN
op_or
id|V_MAC_TX_PAUSE_CNT_16K
op_or
id|M_MAC_AP_STAT_EN
op_or
id|M_MAC_FAST_SYNC
op_or
id|M_MAC_SS_EN
op_or
l_int|0
suffix:semicolon
id|fifo
op_assign
id|V_MAC_TX_WR_THRSH
c_func
(paren
l_int|4
)paren
op_or
multiline_comment|/* Must be &squot;4&squot; or &squot;8&squot; */
id|V_MAC_TX_RD_THRSH
c_func
(paren
l_int|4
)paren
op_or
id|V_MAC_TX_RL_THRSH
c_func
(paren
l_int|4
)paren
op_or
id|V_MAC_RX_PL_THRSH
c_func
(paren
l_int|4
)paren
op_or
id|V_MAC_RX_RD_THRSH
c_func
(paren
l_int|4
)paren
op_or
multiline_comment|/* Must be &squot;4&squot; */
id|V_MAC_RX_PL_THRSH
c_func
(paren
l_int|4
)paren
op_or
id|V_MAC_RX_RL_THRSH
c_func
(paren
l_int|8
)paren
op_or
l_int|0
suffix:semicolon
id|framecfg
op_assign
id|V_MAC_MIN_FRAMESZ_DEFAULT
op_or
id|V_MAC_MAX_FRAMESZ_DEFAULT
op_or
id|V_MAC_BACKOFF_SEL
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear out the hash address map &n;&t; */
id|port
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_HASH_BASE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|MAC_HASH_COUNT
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|SBMAC_WRITECSR
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
id|port
op_add_assign
r_sizeof
(paren
r_uint64
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear out the exact-match table&n;&t; */
id|port
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_ADDR_BASE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|MAC_ADDR_COUNT
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|SBMAC_WRITECSR
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
id|port
op_add_assign
r_sizeof
(paren
r_uint64
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear out the DMA Channel mapping table registers&n;&t; */
id|port
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_CHUP0_BASE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|MAC_CHMAP_COUNT
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|SBMAC_WRITECSR
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
id|port
op_add_assign
r_sizeof
(paren
r_uint64
)paren
suffix:semicolon
)brace
id|port
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_CHLO0_BASE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|MAC_CHMAP_COUNT
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|SBMAC_WRITECSR
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
id|port
op_add_assign
r_sizeof
(paren
r_uint64
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Program the hardware address.  It goes into the hardware-address&n;&t; * register as well as the first filter register.&n;&t; */
id|reg
op_assign
id|sbmac_addr2reg
c_func
(paren
id|s-&gt;sbm_hwaddr
)paren
suffix:semicolon
id|port
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_ADDR_BASE
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
id|port
op_assign
id|PKSEG1
c_func
(paren
id|s-&gt;sbm_base
op_plus
id|R_MAC_ETHERNET_ADDR
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SB1_PASS_1_WORKAROUNDS
multiline_comment|/*&n;&t; * Pass1 SB1250s do not receive packets addressed to the&n;&t; * destination address in the R_MAC_ETHERNET_ADDR register.&n;&t; * Set the value to zero.&n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
macro_line|#else
id|SBMAC_WRITECSR
c_func
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Set the receive filter for no packets, and write values&n;&t; * to the various config registers&n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_rxfilter
comma
l_int|0
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_imr
comma
l_int|0
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_framecfg
comma
id|framecfg
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_fifocfg
comma
id|fifo
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_maccfg
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize DMA channels (rings should be ok now)&n;&t; */
id|sbdma_channel_start
c_func
(paren
op_amp
(paren
id|s-&gt;sbm_rxdma
)paren
)paren
suffix:semicolon
id|sbdma_channel_start
c_func
(paren
op_amp
(paren
id|s-&gt;sbm_txdma
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Configure the speed, duplex, and flow control&n;&t; */
id|sbmac_set_speed
c_func
(paren
id|s
comma
id|s-&gt;sbm_speed
)paren
suffix:semicolon
id|sbmac_set_duplex
c_func
(paren
id|s
comma
id|s-&gt;sbm_duplex
comma
id|s-&gt;sbm_fc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill the receive ring&n;&t; */
id|sbdma_fillring
c_func
(paren
op_amp
(paren
id|s-&gt;sbm_rxdma
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Turn on the rest of the bits in the enable register&n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_macenable
comma
id|M_MAC_RXDMA_EN0
op_or
id|M_MAC_TXDMA_EN0
op_or
id|M_MAC_RX_ENABLE
op_or
id|M_MAC_TX_ENABLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Accept any kind of interrupt on TX and RX DMA channel 0&n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_imr
comma
(paren
id|M_MAC_INT_CHANNEL
op_lshift
id|S_MAC_TX_CH0
)paren
op_or
(paren
id|M_MAC_INT_CHANNEL
op_lshift
id|S_MAC_RX_CH0
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Enable receiving unicasts and broadcasts &n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_rxfilter
comma
id|M_MAC_UCAST_EN
op_or
id|M_MAC_BCAST_EN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we&squot;re running now. &n;&t; */
id|s-&gt;sbm_state
op_assign
id|sbmac_state_on
suffix:semicolon
multiline_comment|/* &n;&t; * Program multicast addresses &n;&t; */
id|sbmac_setmulti
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * If channel was in promiscuous mode before, turn that on &n;&t; */
r_if
c_cond
(paren
id|s-&gt;sbm_devflags
op_amp
id|IFF_PROMISC
)paren
(brace
id|sbmac_promiscuous_mode
c_func
(paren
id|s
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_CHANNEL_STOP(s)&n; *  &n; *  Stop packet processing on this MAC.&n; *  &n; *  Input parameters: &n; *  &t;   s - sbmac structure&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbmac_channel_stop
r_static
r_void
id|sbmac_channel_stop
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
)paren
(brace
r_uint64
id|ctl
suffix:semicolon
multiline_comment|/* don&squot;t do this if already stopped */
r_if
c_cond
(paren
id|s-&gt;sbm_state
op_eq
id|sbmac_state_off
)paren
r_return
suffix:semicolon
multiline_comment|/* don&squot;t accept any packets, disable all interrupts */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_rxfilter
comma
l_int|0
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_imr
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Turn off ticker */
multiline_comment|/* XXX */
multiline_comment|/* turn off receiver and transmitter */
id|ctl
op_assign
id|SBMAC_READCSR
c_func
(paren
id|s-&gt;sbm_macenable
)paren
suffix:semicolon
id|ctl
op_and_assign
op_complement
(paren
id|M_MAC_RXDMA_EN0
op_or
id|M_MAC_TXDMA_EN0
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_macenable
comma
id|ctl
)paren
suffix:semicolon
multiline_comment|/* We&squot;re stopped now. */
id|s-&gt;sbm_state
op_assign
id|sbmac_state_off
suffix:semicolon
multiline_comment|/* Empty the receive and transmit rings */
id|sbdma_emptyring
c_func
(paren
op_amp
(paren
id|s-&gt;sbm_rxdma
)paren
)paren
suffix:semicolon
id|sbdma_emptyring
c_func
(paren
op_amp
(paren
id|s-&gt;sbm_txdma
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_SET_CHANNEL_STATE(state)&n; *  &n; *  Set the channel&squot;s state ON or OFF&n; *  &n; *  Input parameters: &n; *  &t;   state - new state&n; *  &t;   &n; *  Return value:&n; *  &t;   old state&n; ********************************************************************* */
DECL|function|sbmac_set_channel_state
r_static
id|sbmac_state_t
id|sbmac_set_channel_state
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|sc
comma
id|sbmac_state_t
id|state
)paren
(brace
id|sbmac_state_t
id|oldstate
op_assign
id|sc-&gt;sbm_state
suffix:semicolon
multiline_comment|/*&n;&t; * If same as previous state, return&n;&t; */
r_if
c_cond
(paren
id|state
op_eq
id|oldstate
)paren
(brace
r_return
id|oldstate
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If new state is ON, turn channel on &n;&t; */
r_if
c_cond
(paren
id|state
op_eq
id|sbmac_state_on
)paren
(brace
id|sbmac_channel_start
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
r_else
(brace
id|sbmac_channel_stop
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Return previous state&n;&t; */
r_return
id|oldstate
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_PROMISCUOUS_MODE(sc,onoff)&n; *  &n; *  Turn on or off promiscuous mode&n; *  &n; *  Input parameters: &n; *  &t;   sc - softc&n; *      onoff - 1 to turn on, 0 to turn off&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbmac_promiscuous_mode
r_static
r_void
id|sbmac_promiscuous_mode
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|sc
comma
r_int
id|onoff
)paren
(brace
r_uint64
id|reg
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;sbm_state
op_ne
id|sbmac_state_on
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|onoff
)paren
(brace
id|reg
op_assign
id|SBMAC_READCSR
c_func
(paren
id|sc-&gt;sbm_rxfilter
)paren
suffix:semicolon
id|reg
op_or_assign
id|M_MAC_ALLPKT_EN
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|sc-&gt;sbm_rxfilter
comma
id|reg
)paren
suffix:semicolon
)brace
r_else
(brace
id|reg
op_assign
id|SBMAC_READCSR
c_func
(paren
id|sc-&gt;sbm_rxfilter
)paren
suffix:semicolon
id|reg
op_and_assign
op_complement
id|M_MAC_ALLPKT_EN
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|sc-&gt;sbm_rxfilter
comma
id|reg
)paren
suffix:semicolon
)brace
)brace
macro_line|#if 0
multiline_comment|/**********************************************************************&n; *  SBMAC_INIT_AND_START(sc)&n; *  &n; *  Stop the channel and restart it.  This is generally used&n; *  when we have to do something to the channel that requires&n; *  a swift kick.&n; *  &n; *  Input parameters: &n; *  &t;   sc - softc&n; ********************************************************************* */
r_static
r_void
id|sbmac_init_and_start
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|sc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|sc-&gt;sbm_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|sbmac_set_channel_state
c_func
(paren
id|sc
comma
id|sbmac_state_on
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|sc-&gt;sbm_lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**********************************************************************&n; *  SBMAC_ADDR2REG(ptr)&n; *  &n; *  Convert six bytes into the 64-bit register value that&n; *  we typically write into the SBMAC&squot;s address/mcast registers&n; *  &n; *  Input parameters: &n; *  &t;   ptr - pointer to 6 bytes&n; *  &t;   &n; *  Return value:&n; *  &t;   register value&n; ********************************************************************* */
DECL|function|sbmac_addr2reg
r_static
r_uint64
id|sbmac_addr2reg
c_func
(paren
r_int
r_char
op_star
id|ptr
)paren
(brace
r_uint64
id|reg
op_assign
l_int|0
suffix:semicolon
id|ptr
op_add_assign
l_int|6
suffix:semicolon
id|reg
op_or_assign
(paren
r_uint64
)paren
op_star
(paren
op_decrement
id|ptr
)paren
suffix:semicolon
id|reg
op_lshift_assign
l_int|8
suffix:semicolon
id|reg
op_or_assign
(paren
r_uint64
)paren
op_star
(paren
op_decrement
id|ptr
)paren
suffix:semicolon
id|reg
op_lshift_assign
l_int|8
suffix:semicolon
id|reg
op_or_assign
(paren
r_uint64
)paren
op_star
(paren
op_decrement
id|ptr
)paren
suffix:semicolon
id|reg
op_lshift_assign
l_int|8
suffix:semicolon
id|reg
op_or_assign
(paren
r_uint64
)paren
op_star
(paren
op_decrement
id|ptr
)paren
suffix:semicolon
id|reg
op_lshift_assign
l_int|8
suffix:semicolon
id|reg
op_or_assign
(paren
r_uint64
)paren
op_star
(paren
op_decrement
id|ptr
)paren
suffix:semicolon
id|reg
op_lshift_assign
l_int|8
suffix:semicolon
id|reg
op_or_assign
(paren
r_uint64
)paren
op_star
(paren
op_decrement
id|ptr
)paren
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_SET_SPEED(s,speed)&n; *  &n; *  Configure LAN speed for the specified MAC.&n; *  Warning: must be called when MAC is off!&n; *  &n; *  Input parameters: &n; *  &t;   s - sbmac structure&n; *  &t;   speed - speed to set MAC to (see sbmac_speed_t enum)&n; *  &t;   &n; *  Return value:&n; *  &t;   1 if successful&n; *      0 indicates invalid parameters&n; ********************************************************************* */
DECL|function|sbmac_set_speed
r_static
r_int
id|sbmac_set_speed
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
comma
id|sbmac_speed_t
id|speed
)paren
(brace
r_uint64
id|cfg
suffix:semicolon
r_uint64
id|framecfg
suffix:semicolon
multiline_comment|/*&n;&t; * Save new current values&n;&t; */
id|s-&gt;sbm_speed
op_assign
id|speed
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;sbm_state
op_eq
id|sbmac_state_on
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* save for next restart */
multiline_comment|/*&n;&t; * Read current register values &n;&t; */
id|cfg
op_assign
id|SBMAC_READCSR
c_func
(paren
id|s-&gt;sbm_maccfg
)paren
suffix:semicolon
id|framecfg
op_assign
id|SBMAC_READCSR
c_func
(paren
id|s-&gt;sbm_framecfg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mask out the stuff we want to change&n;&t; */
id|cfg
op_and_assign
op_complement
(paren
id|M_MAC_BURST_EN
op_or
id|M_MAC_SPEED_SEL
)paren
suffix:semicolon
id|framecfg
op_and_assign
op_complement
(paren
id|M_MAC_IFG_RX
op_or
id|M_MAC_IFG_TX
op_or
id|M_MAC_IFG_THRSH
op_or
id|M_MAC_SLOT_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now add in the new bits&n;&t; */
r_switch
c_cond
(paren
id|speed
)paren
(brace
r_case
id|sbmac_speed_10
suffix:colon
id|framecfg
op_or_assign
id|V_MAC_IFG_RX_10
op_or
id|V_MAC_IFG_TX_10
op_or
id|K_MAC_IFG_THRSH_10
op_or
id|V_MAC_SLOT_SIZE_10
suffix:semicolon
id|cfg
op_or_assign
id|V_MAC_SPEED_SEL_10MBPS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sbmac_speed_100
suffix:colon
id|framecfg
op_or_assign
id|V_MAC_IFG_RX_100
op_or
id|V_MAC_IFG_TX_100
op_or
id|V_MAC_IFG_THRSH_100
op_or
id|V_MAC_SLOT_SIZE_100
suffix:semicolon
id|cfg
op_or_assign
id|V_MAC_SPEED_SEL_100MBPS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sbmac_speed_1000
suffix:colon
id|framecfg
op_or_assign
id|V_MAC_IFG_RX_1000
op_or
id|V_MAC_IFG_TX_1000
op_or
id|V_MAC_IFG_THRSH_1000
op_or
id|V_MAC_SLOT_SIZE_1000
suffix:semicolon
id|cfg
op_or_assign
id|V_MAC_SPEED_SEL_1000MBPS
op_or
id|M_MAC_BURST_EN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sbmac_speed_auto
suffix:colon
multiline_comment|/* XXX not implemented */
multiline_comment|/* fall through */
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Send the bits back to the hardware &n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_framecfg
comma
id|framecfg
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_maccfg
comma
id|cfg
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_SET_DUPLEX(s,duplex,fc)&n; *  &n; *  Set Ethernet duplex and flow control options for this MAC&n; *  Warning: must be called when MAC is off!&n; *  &n; *  Input parameters: &n; *  &t;   s - sbmac structure&n; *  &t;   duplex - duplex setting (see sbmac_duplex_t)&n; *  &t;   fc - flow control setting (see sbmac_fc_t)&n; *  &t;   &n; *  Return value:&n; *  &t;   1 if ok&n; *  &t;   0 if an invalid parameter combination was specified&n; ********************************************************************* */
DECL|function|sbmac_set_duplex
r_static
r_int
id|sbmac_set_duplex
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
comma
id|sbmac_duplex_t
id|duplex
comma
id|sbmac_fc_t
id|fc
)paren
(brace
r_uint64
id|cfg
suffix:semicolon
multiline_comment|/*&n;&t; * Save new current values&n;&t; */
id|s-&gt;sbm_duplex
op_assign
id|duplex
suffix:semicolon
id|s-&gt;sbm_fc
op_assign
id|fc
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;sbm_state
op_eq
id|sbmac_state_on
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* save for next restart */
multiline_comment|/*&n;&t; * Read current register values &n;&t; */
id|cfg
op_assign
id|SBMAC_READCSR
c_func
(paren
id|s-&gt;sbm_maccfg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mask off the stuff we&squot;re about to change&n;&t; */
id|cfg
op_and_assign
op_complement
(paren
id|M_MAC_FC_SEL
op_or
id|M_MAC_FC_CMD
op_or
id|M_MAC_HDX_EN
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|duplex
)paren
(brace
r_case
id|sbmac_duplex_half
suffix:colon
r_switch
c_cond
(paren
id|fc
)paren
(brace
r_case
id|sbmac_fc_disabled
suffix:colon
id|cfg
op_or_assign
id|M_MAC_HDX_EN
op_or
id|V_MAC_FC_CMD_DISABLED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sbmac_fc_collision
suffix:colon
id|cfg
op_or_assign
id|M_MAC_HDX_EN
op_or
id|V_MAC_FC_CMD_ENABLED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sbmac_fc_carrier
suffix:colon
id|cfg
op_or_assign
id|M_MAC_HDX_EN
op_or
id|V_MAC_FC_CMD_ENAB_FALSECARR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sbmac_fc_auto
suffix:colon
multiline_comment|/* XXX not implemented */
multiline_comment|/* fall through */
r_case
id|sbmac_fc_frame
suffix:colon
multiline_comment|/* not valid in half duplex */
r_default
suffix:colon
multiline_comment|/* invalid selection */
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|sbmac_duplex_full
suffix:colon
r_switch
c_cond
(paren
id|fc
)paren
(brace
r_case
id|sbmac_fc_disabled
suffix:colon
id|cfg
op_or_assign
id|V_MAC_FC_CMD_DISABLED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sbmac_fc_frame
suffix:colon
id|cfg
op_or_assign
id|V_MAC_FC_CMD_ENABLED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sbmac_fc_collision
suffix:colon
multiline_comment|/* not valid in full duplex */
r_case
id|sbmac_fc_carrier
suffix:colon
multiline_comment|/* not valid in full duplex */
r_case
id|sbmac_fc_auto
suffix:colon
multiline_comment|/* XXX not implemented */
multiline_comment|/* fall through */
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|sbmac_duplex_auto
suffix:colon
multiline_comment|/* XXX not implemented */
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Send the bits back to the hardware &n;&t; */
id|SBMAC_WRITECSR
c_func
(paren
id|s-&gt;sbm_maccfg
comma
id|cfg
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_INTR()&n; *  &n; *  Interrupt handler for MAC interrupts&n; *  &n; *  Input parameters: &n; *  &t;   MAC structure&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbmac_intr
r_static
r_void
id|sbmac_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|rgs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_instance
suffix:semicolon
r_struct
id|sbmac_softc
op_star
id|sc
op_assign
(paren
r_struct
id|sbmac_softc
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_uint64
id|isr
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * Read the ISR (this clears the bits in the real register)&n;&t;&t; */
id|isr
op_assign
id|SBMAC_READCSR
c_func
(paren
id|sc-&gt;sbm_isr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isr
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Transmits on channel 0&n;&t;&t; */
r_if
c_cond
(paren
id|isr
op_amp
(paren
id|M_MAC_INT_CHANNEL
op_lshift
id|S_MAC_TX_CH0
)paren
)paren
(brace
id|sbdma_tx_process
c_func
(paren
id|sc
comma
op_amp
(paren
id|sc-&gt;sbm_txdma
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Receives on channel 0&n;&t;&t; */
r_if
c_cond
(paren
id|isr
op_amp
(paren
id|M_MAC_INT_CHANNEL
op_lshift
id|S_MAC_RX_CH0
)paren
)paren
(brace
id|sbdma_rx_process
c_func
(paren
id|sc
comma
op_amp
(paren
id|sc-&gt;sbm_rxdma
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_START_TX(skb,dev)&n; *  &n; *  Start output on the specified interface.  Basically, we &n; *  queue as many buffers as we can until the ring fills up, or&n; *  we run off the end of the queue, whichever comes first.&n; *  &n; *  Input parameters: &n; *  &t;   &n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbmac_start_tx
r_static
r_int
id|sbmac_start_tx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sbmac_softc
op_star
id|sc
op_assign
(paren
r_struct
id|sbmac_softc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* lock eth irq */
id|spin_lock_irq
(paren
op_amp
id|sc-&gt;sbm_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Put the buffer on the transmit ring.  If we &n;&t; * don&squot;t have room, stop the queue.&n;&t; */
r_if
c_cond
(paren
id|sbdma_add_txbuffer
c_func
(paren
op_amp
(paren
id|sc-&gt;sbm_txdma
)paren
comma
id|skb
)paren
)paren
(brace
multiline_comment|/* XXX save skb that we could not send */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|sc-&gt;sbm_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_SETMULTI(sc)&n; *  &n; *  Reprogram the multicast table into the hardware, given&n; *  the list of multicasts associated with the interface&n; *  structure.&n; *  &n; *  Input parameters: &n; *  &t;   sc - softc&n; *  &t;   &n; *  Return value:&n; *  &t;   nothing&n; ********************************************************************* */
DECL|function|sbmac_setmulti
r_static
r_void
id|sbmac_setmulti
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|sc
)paren
(brace
r_uint64
id|reg
suffix:semicolon
id|sbmac_port_t
id|port
suffix:semicolon
r_int
id|idx
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|mclist
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|sc-&gt;sbm_dev
suffix:semicolon
multiline_comment|/* &n;&t; * Clear out entire multicast table.  We do this by nuking&n;&t; * the entire hash table and all the direct matches except&n;&t; * the first one, which is used for our station address &n;&t; */
r_for
c_loop
(paren
id|idx
op_assign
l_int|1
suffix:semicolon
id|idx
OL
id|MAC_ADDR_COUNT
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|port
op_assign
id|PKSEG1
c_func
(paren
id|sc-&gt;sbm_base
op_plus
id|R_MAC_ADDR_BASE
op_plus
(paren
id|idx
op_star
r_sizeof
(paren
r_uint64
)paren
)paren
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|MAC_HASH_COUNT
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|port
op_assign
id|PKSEG1
c_func
(paren
id|sc-&gt;sbm_base
op_plus
id|R_MAC_HASH_BASE
op_plus
(paren
id|idx
op_star
r_sizeof
(paren
r_uint64
)paren
)paren
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear the filter to say we don&squot;t want any multicasts.&n;&t; */
id|reg
op_assign
id|SBMAC_READCSR
c_func
(paren
id|sc-&gt;sbm_rxfilter
)paren
suffix:semicolon
id|reg
op_and_assign
op_complement
(paren
id|M_MAC_MCAST_INV
op_or
id|M_MAC_MCAST_EN
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|sc-&gt;sbm_rxfilter
comma
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
multiline_comment|/* &n;&t;&t; * Enable ALL multicasts.  Do this by inverting the &n;&t;&t; * multicast enable bit. &n;&t;&t; */
id|reg
op_assign
id|SBMAC_READCSR
c_func
(paren
id|sc-&gt;sbm_rxfilter
)paren
suffix:semicolon
id|reg
op_or_assign
(paren
id|M_MAC_MCAST_INV
op_or
id|M_MAC_MCAST_EN
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|sc-&gt;sbm_rxfilter
comma
id|reg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Progam new multicast entries.  For now, only use the&n;&t; * perfect filter.  In the future we&squot;ll need to use the&n;&t; * hash filter if the perfect filter overflows&n;&t; */
multiline_comment|/* XXX only using perfect filter for now, need to use hash&n;&t; * XXX if the table overflows */
id|idx
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* skip station address */
id|mclist
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_while
c_loop
(paren
id|mclist
op_logical_and
(paren
id|idx
OL
id|MAC_ADDR_COUNT
)paren
)paren
(brace
id|reg
op_assign
id|sbmac_addr2reg
c_func
(paren
id|mclist-&gt;dmi_addr
)paren
suffix:semicolon
id|port
op_assign
id|PKSEG1
c_func
(paren
id|sc-&gt;sbm_base
op_plus
id|R_MAC_ADDR_BASE
op_plus
(paren
id|idx
op_star
r_sizeof
(paren
r_uint64
)paren
)paren
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
id|idx
op_increment
suffix:semicolon
id|mclist
op_assign
id|mclist-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&t;&n;&t; * Enable the &quot;accept multicast bits&quot; if we programmed at least one&n;&t; * multicast. &n;&t; */
r_if
c_cond
(paren
id|idx
OG
l_int|1
)paren
(brace
id|reg
op_assign
id|SBMAC_READCSR
c_func
(paren
id|sc-&gt;sbm_rxfilter
)paren
suffix:semicolon
id|reg
op_or_assign
id|M_MAC_MCAST_EN
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|sc-&gt;sbm_rxfilter
comma
id|reg
)paren
suffix:semicolon
)brace
)brace
macro_line|#if defined(SBMAC_ETH0_HWADDR) || defined(SBMAC_ETH1_HWADDR) || defined(SBMAC_ETH2_HWADDR)
multiline_comment|/**********************************************************************&n; *  SBMAC_PARSE_XDIGIT(str)&n; *  &n; *  Parse a hex digit, returning its value&n; *  &n; *  Input parameters: &n; *  &t;   str - character&n; *  &t;   &n; *  Return value:&n; *  &t;   hex value, or -1 if invalid&n; ********************************************************************* */
DECL|function|sbmac_parse_xdigit
r_static
r_int
id|sbmac_parse_xdigit
c_func
(paren
r_char
id|str
)paren
(brace
r_int
id|digit
suffix:semicolon
r_if
c_cond
(paren
(paren
id|str
op_ge
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
id|str
op_le
l_char|&squot;9&squot;
)paren
)paren
id|digit
op_assign
id|str
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|str
op_ge
l_char|&squot;a&squot;
)paren
op_logical_and
(paren
id|str
op_le
l_char|&squot;f&squot;
)paren
)paren
id|digit
op_assign
id|str
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|str
op_ge
l_char|&squot;A&squot;
)paren
op_logical_and
(paren
id|str
op_le
l_char|&squot;F&squot;
)paren
)paren
id|digit
op_assign
id|str
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:semicolon
r_else
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|digit
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *  SBMAC_PARSE_HWADDR(str,hwaddr)&n; *  &n; *  Convert a string in the form xx:xx:xx:xx:xx:xx into a 6-byte&n; *  Ethernet address.&n; *  &n; *  Input parameters: &n; *  &t;   str - string&n; *  &t;   hwaddr - pointer to hardware address&n; *  &t;   &n; *  Return value:&n; *  &t;   0 if ok, else -1&n; ********************************************************************* */
DECL|function|sbmac_parse_hwaddr
r_static
r_int
id|sbmac_parse_hwaddr
c_func
(paren
r_char
op_star
id|str
comma
id|u_char
op_star
id|hwaddr
)paren
(brace
r_int
id|digit1
comma
id|digit2
suffix:semicolon
r_int
id|idx
op_assign
l_int|6
suffix:semicolon
r_while
c_loop
(paren
op_star
id|str
op_logical_and
(paren
id|idx
OG
l_int|0
)paren
)paren
(brace
id|digit1
op_assign
id|sbmac_parse_xdigit
c_func
(paren
op_star
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|digit1
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|str
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|str
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|str
op_eq
l_char|&squot;:&squot;
)paren
op_logical_or
(paren
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
)paren
(brace
id|digit2
op_assign
id|digit1
suffix:semicolon
id|digit1
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|digit2
op_assign
id|sbmac_parse_xdigit
c_func
(paren
op_star
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|digit2
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|str
op_increment
suffix:semicolon
)brace
op_star
id|hwaddr
op_increment
op_assign
(paren
id|digit1
op_lshift
l_int|4
)paren
op_or
id|digit2
suffix:semicolon
id|idx
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
id|str
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;:&squot;
)paren
id|str
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**********************************************************************&n; *  SBMAC_INIT(dev)&n; *  &n; *  Attach routine - init hardware and hook ourselves into linux&n; *  &n; *  Input parameters: &n; *  &t;   dev - net_device structure&n; *  &t;   &n; *  Return value:&n; *  &t;   status&n; ********************************************************************* */
DECL|function|sbmac_init
r_static
r_int
id|sbmac_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sbmac_softc
op_star
id|sc
suffix:semicolon
id|u_char
op_star
id|eaddr
suffix:semicolon
r_uint64
id|ea_reg
suffix:semicolon
r_int
id|idx
suffix:semicolon
id|sc
op_assign
(paren
r_struct
id|sbmac_softc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Determine controller base address */
id|sc-&gt;sbm_base
op_assign
(paren
id|sbmac_port_t
)paren
id|dev-&gt;base_addr
suffix:semicolon
id|sc-&gt;sbm_dev
op_assign
id|dev
suffix:semicolon
id|eaddr
op_assign
id|sc-&gt;sbm_hwaddr
suffix:semicolon
multiline_comment|/* &n;&t; * Read the ethernet address.  The firwmare left this programmed&n;&t; * for us in the ethernet address register for each mac.&n;&t; */
id|ea_reg
op_assign
id|SBMAC_READCSR
c_func
(paren
id|PKSEG1
c_func
(paren
id|sc-&gt;sbm_base
op_plus
id|R_MAC_ETHERNET_ADDR
)paren
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|PKSEG1
c_func
(paren
id|sc-&gt;sbm_base
op_plus
id|R_MAC_ETHERNET_ADDR
)paren
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|6
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|eaddr
(braket
id|idx
)braket
op_assign
(paren
r_uint8
)paren
(paren
id|ea_reg
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ea_reg
op_rshift_assign
l_int|8
suffix:semicolon
)brace
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|6
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|idx
)braket
op_assign
id|eaddr
(braket
id|idx
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Init packet size &n;&t; */
id|sc-&gt;sbm_buffersize
op_assign
id|ENET_PACKET_SIZE
op_plus
id|CACHELINESIZE
op_star
l_int|2
op_plus
id|ETHER_ALIGN
suffix:semicolon
multiline_comment|/* &n;&t; * Initialize context (get pointers to registers and stuff), then&n;&t; * allocate the memory for the descriptor tables.&n;&t; */
id|sbmac_initctx
c_func
(paren
id|sc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Display Ethernet address (this is called during the config process&n;&t; * so we need to finish off the config message that was being displayed)&n;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: SB1250 Ethernet at 0x%08lX, address: %02X-%02X-%02X-%02X-%02X-%02X&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
r_int
)paren
id|sc-&gt;sbm_base
comma
id|eaddr
(braket
l_int|0
)braket
comma
id|eaddr
(braket
l_int|1
)braket
comma
id|eaddr
(braket
l_int|2
)braket
comma
id|eaddr
(braket
l_int|3
)braket
comma
id|eaddr
(braket
l_int|4
)braket
comma
id|eaddr
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up Linux device callins&n;&t; */
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|sc-&gt;sbm_lock
)paren
)paren
suffix:semicolon
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|sbmac_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|sbmac_start_tx
suffix:semicolon
id|dev-&gt;stop
op_assign
id|sbmac_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|sbmac_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|sbmac_set_rx_mode
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|sbmac_mii_ioctl
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|sbmac_tx_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sbmac_open
r_static
r_int
id|sbmac_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sbmac_softc
op_star
id|sc
op_assign
(paren
r_struct
id|sbmac_softc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: sbmac_open() irq %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * map/route interrupt &n;&t; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|sbmac_intr
comma
id|SA_SHIRQ
comma
id|dev-&gt;name
comma
id|dev
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Configure default speed &n;&t; */
id|sbmac_mii_poll
c_func
(paren
id|sc
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Turn on the channel&n;&t; */
id|sbmac_set_channel_state
c_func
(paren
id|sc
comma
id|sbmac_state_on
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX Station address is in dev-&gt;dev_addr&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;if_port
op_eq
l_int|0
)paren
id|dev-&gt;if_port
op_assign
l_int|0
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sbmac_set_rx_mode
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Set the timer to check for link beat. */
id|init_timer
c_func
(paren
op_amp
id|sc-&gt;sbm_timer
)paren
suffix:semicolon
id|sc-&gt;sbm_timer.expires
op_assign
id|jiffies
op_plus
l_int|2
suffix:semicolon
id|sc-&gt;sbm_timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|sc-&gt;sbm_timer.function
op_assign
op_amp
id|sbmac_timer
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sc-&gt;sbm_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sbmac_mii_poll
r_static
r_int
id|sbmac_mii_poll
c_func
(paren
r_struct
id|sbmac_softc
op_star
id|s
comma
r_int
id|noisy
)paren
(brace
r_int
id|bmsr
comma
id|bmcr
comma
id|k1stsr
comma
id|anlpar
suffix:semicolon
r_int
id|chg
suffix:semicolon
r_char
id|buffer
(braket
l_int|100
)braket
suffix:semicolon
r_char
op_star
id|p
op_assign
id|buffer
suffix:semicolon
multiline_comment|/* Read the mode status and mode control registers. */
id|bmsr
op_assign
id|sbmac_mii_read
c_func
(paren
id|s
comma
id|s-&gt;sbm_phys
(braket
l_int|0
)braket
comma
id|MII_BMSR
)paren
suffix:semicolon
id|bmcr
op_assign
id|sbmac_mii_read
c_func
(paren
id|s
comma
id|s-&gt;sbm_phys
(braket
l_int|0
)braket
comma
id|MII_BMCR
)paren
suffix:semicolon
multiline_comment|/* get the link partner status */
id|anlpar
op_assign
id|sbmac_mii_read
c_func
(paren
id|s
comma
id|s-&gt;sbm_phys
(braket
l_int|0
)braket
comma
id|MII_ANLPAR
)paren
suffix:semicolon
multiline_comment|/* if supported, read the 1000baseT register */
r_if
c_cond
(paren
id|bmsr
op_amp
id|BMSR_1000BT_XSR
)paren
(brace
id|k1stsr
op_assign
id|sbmac_mii_read
c_func
(paren
id|s
comma
id|s-&gt;sbm_phys
(braket
l_int|0
)braket
comma
id|MII_K1STSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|k1stsr
op_assign
l_int|0
suffix:semicolon
)brace
id|chg
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bmsr
op_amp
id|BMSR_LINKSTAT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t; * If link status is down, clear out old info so that when&n;&t; * it comes back up it will force us to reconfigure speed&n;&t; */
id|s-&gt;sbm_phy_oldbmsr
op_assign
l_int|0
suffix:semicolon
id|s-&gt;sbm_phy_oldanlpar
op_assign
l_int|0
suffix:semicolon
id|s-&gt;sbm_phy_oldk1stsr
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|s-&gt;sbm_phy_oldbmsr
op_ne
id|bmsr
)paren
op_logical_or
(paren
id|s-&gt;sbm_phy_oldanlpar
op_ne
id|anlpar
)paren
op_logical_or
(paren
id|s-&gt;sbm_phy_oldk1stsr
op_ne
id|k1stsr
)paren
)paren
(brace
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: bmsr:%x/%x anlpar:%x/%x  k1stsr:%x/%x&bslash;n&quot;
comma
id|s-&gt;sbm_dev-&gt;name
comma
id|s-&gt;sbm_phy_oldbmsr
comma
id|bmsr
comma
id|s-&gt;sbm_phy_oldanlpar
comma
id|anlpar
comma
id|s-&gt;sbm_phy_oldk1stsr
comma
id|k1stsr
)paren
suffix:semicolon
)brace
id|s-&gt;sbm_phy_oldbmsr
op_assign
id|bmsr
suffix:semicolon
id|s-&gt;sbm_phy_oldanlpar
op_assign
id|anlpar
suffix:semicolon
id|s-&gt;sbm_phy_oldk1stsr
op_assign
id|k1stsr
suffix:semicolon
id|chg
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chg
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Link speed: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k1stsr
op_amp
id|K1STSR_LP1KFD
)paren
(brace
id|s-&gt;sbm_speed
op_assign
id|sbmac_speed_1000
suffix:semicolon
id|s-&gt;sbm_duplex
op_assign
id|sbmac_duplex_full
suffix:semicolon
id|s-&gt;sbm_fc
op_assign
id|sbmac_fc_frame
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;1000BaseT FDX&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|k1stsr
op_amp
id|K1STSR_LP1KHD
)paren
(brace
id|s-&gt;sbm_speed
op_assign
id|sbmac_speed_1000
suffix:semicolon
id|s-&gt;sbm_duplex
op_assign
id|sbmac_duplex_half
suffix:semicolon
id|s-&gt;sbm_fc
op_assign
id|sbmac_fc_disabled
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;1000BaseT HDX&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|anlpar
op_amp
id|ANLPAR_TXFD
)paren
(brace
id|s-&gt;sbm_speed
op_assign
id|sbmac_speed_100
suffix:semicolon
id|s-&gt;sbm_duplex
op_assign
id|sbmac_duplex_full
suffix:semicolon
id|s-&gt;sbm_fc
op_assign
(paren
id|anlpar
op_amp
id|ANLPAR_PAUSE
)paren
ques
c_cond
id|sbmac_fc_frame
suffix:colon
id|sbmac_fc_disabled
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;100BaseT FDX&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|anlpar
op_amp
id|ANLPAR_TXHD
)paren
(brace
id|s-&gt;sbm_speed
op_assign
id|sbmac_speed_100
suffix:semicolon
id|s-&gt;sbm_duplex
op_assign
id|sbmac_duplex_half
suffix:semicolon
id|s-&gt;sbm_fc
op_assign
id|sbmac_fc_disabled
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;100BaseT HDX&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|anlpar
op_amp
id|ANLPAR_10FD
)paren
(brace
id|s-&gt;sbm_speed
op_assign
id|sbmac_speed_10
suffix:semicolon
id|s-&gt;sbm_duplex
op_assign
id|sbmac_duplex_full
suffix:semicolon
id|s-&gt;sbm_fc
op_assign
id|sbmac_fc_frame
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;10BaseT FDX&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|anlpar
op_amp
id|ANLPAR_10HD
)paren
(brace
id|s-&gt;sbm_speed
op_assign
id|sbmac_speed_10
suffix:semicolon
id|s-&gt;sbm_duplex
op_assign
id|sbmac_duplex_half
suffix:semicolon
id|s-&gt;sbm_fc
op_assign
id|sbmac_fc_collision
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;10BaseT HDX&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|noisy
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|s-&gt;sbm_dev-&gt;name
comma
id|buffer
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|sbmac_timer
r_static
r_void
id|sbmac_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
r_struct
id|sbmac_softc
op_star
id|sc
op_assign
(paren
r_struct
id|sbmac_softc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|next_tick
op_assign
id|HZ
suffix:semicolon
r_int
id|mii_status
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|sc-&gt;sbm_lock
)paren
suffix:semicolon
multiline_comment|/* make IFF_RUNNING follow the MII status bit &quot;Link established&quot; */
id|mii_status
op_assign
id|sbmac_mii_read
c_func
(paren
id|sc
comma
id|sc-&gt;sbm_phys
(braket
l_int|0
)braket
comma
id|MII_BMSR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mii_status
op_amp
id|BMSR_LINKSTAT
)paren
op_ne
(paren
id|sc-&gt;sbm_phy_oldlinkstat
)paren
)paren
(brace
id|sc-&gt;sbm_phy_oldlinkstat
op_assign
id|mii_status
op_amp
id|BMSR_LINKSTAT
suffix:semicolon
r_if
c_cond
(paren
id|mii_status
op_amp
id|BMSR_LINKSTAT
)paren
(brace
id|netif_carrier_on
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|netif_carrier_off
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Poll the PHY to see what speed we should be running at&n;&t; */
r_if
c_cond
(paren
id|sbmac_mii_poll
c_func
(paren
id|sc
comma
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|sc-&gt;sbm_state
op_ne
id|sbmac_state_off
)paren
(brace
multiline_comment|/*&n;&t;&t; * something changed, restart the channel&n;&t;&t; */
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: restarting channel because speed changed&bslash;n&quot;
comma
id|sc-&gt;sbm_dev-&gt;name
)paren
suffix:semicolon
)brace
id|sbmac_channel_stop
c_func
(paren
id|sc
)paren
suffix:semicolon
id|sbmac_channel_start
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irq
(paren
op_amp
id|sc-&gt;sbm_lock
)paren
suffix:semicolon
id|sc-&gt;sbm_timer.expires
op_assign
id|jiffies
op_plus
id|next_tick
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sc-&gt;sbm_timer
)paren
suffix:semicolon
)brace
DECL|function|sbmac_tx_timeout
r_static
r_void
id|sbmac_tx_timeout
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sbmac_softc
op_star
id|sc
op_assign
(paren
r_struct
id|sbmac_softc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|sc-&gt;sbm_lock
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|sc-&gt;sbm_stats.tx_errors
op_increment
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|sc-&gt;sbm_lock
)paren
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: Transmit timed out&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|sbmac_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|sbmac_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sbmac_softc
op_star
id|sc
op_assign
(paren
r_struct
id|sbmac_softc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;sbm_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* XXX update other stats here */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;sbm_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_amp
id|sc-&gt;sbm_stats
suffix:semicolon
)brace
DECL|function|sbmac_set_rx_mode
r_static
r_void
id|sbmac_set_rx_mode
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|msg_flag
op_assign
l_int|0
suffix:semicolon
r_struct
id|sbmac_softc
op_star
id|sc
op_assign
(paren
r_struct
id|sbmac_softc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;sbm_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_xor
id|sc-&gt;sbm_devflags
)paren
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/*&n;&t;&t; * Promiscuous changed.&n;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* Unconditionally log net taps. */
id|msg_flag
op_assign
l_int|1
suffix:semicolon
id|sbmac_promiscuous_mode
c_func
(paren
id|sc
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|msg_flag
op_assign
l_int|2
suffix:semicolon
id|sbmac_promiscuous_mode
c_func
(paren
id|sc
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;sbm_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg_flag
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Promiscuous mode %sabled.&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|msg_flag
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Program the multicasts.  Do this every time.&n;&t; */
id|sbmac_setmulti
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
DECL|function|sbmac_mii_ioctl
r_static
r_int
id|sbmac_mii_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
r_struct
id|sbmac_softc
op_star
id|sc
op_assign
(paren
r_struct
id|sbmac_softc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u16
op_star
id|data
op_assign
(paren
id|u16
op_star
)paren
op_amp
id|rq-&gt;ifr_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;sbm_lock
comma
id|flags
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDEVPRIVATE
suffix:colon
multiline_comment|/* Get the address of the PHY in use. */
id|data
(braket
l_int|0
)braket
op_assign
id|sc-&gt;sbm_phys
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* Fall Through */
r_case
id|SIOCDEVPRIVATE
op_plus
l_int|1
suffix:colon
multiline_comment|/* Read the specified MII register. */
id|data
(braket
l_int|3
)braket
op_assign
id|sbmac_mii_read
c_func
(paren
id|sc
comma
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
comma
id|data
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCDEVPRIVATE
op_plus
l_int|2
suffix:colon
multiline_comment|/* Write the specified MII register */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: sbmac_mii_ioctl: write %02X %02X %02X&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|data
(braket
l_int|0
)braket
comma
id|data
(braket
l_int|1
)braket
comma
id|data
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
id|sbmac_mii_write
c_func
(paren
id|sc
comma
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
comma
id|data
(braket
l_int|1
)braket
op_amp
l_int|0x1f
comma
id|data
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;sbm_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sbmac_close
r_static
r_int
id|sbmac_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sbmac_softc
op_star
id|sc
op_assign
(paren
r_struct
id|sbmac_softc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sbmac_set_channel_state
c_func
(paren
id|sc
comma
id|sbmac_state_off
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|sc-&gt;sbm_timer
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sc-&gt;sbm_lock
comma
id|flags
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Shutting down ethercard&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sc-&gt;sbm_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Make sure there is no irq-handler running on a different CPU. */
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|sbdma_emptyring
c_func
(paren
op_amp
(paren
id|sc-&gt;sbm_txdma
)paren
)paren
suffix:semicolon
id|sbdma_emptyring
c_func
(paren
op_amp
(paren
id|sc-&gt;sbm_rxdma
)paren
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if defined(SBMAC_ETH0_HWADDR) || defined(SBMAC_ETH1_HWADDR) || defined(SBMAC_ETH2_HWADDR)
r_static
r_void
DECL|function|sbmac_setup_hwaddr
id|sbmac_setup_hwaddr
c_func
(paren
r_int
id|chan
comma
r_char
op_star
id|addr
)paren
(brace
r_uint8
id|eaddr
(braket
l_int|6
)braket
suffix:semicolon
r_uint64
id|val
suffix:semicolon
id|sbmac_port_t
id|port
suffix:semicolon
id|port
op_assign
id|A_MAC_CHANNEL_BASE
c_func
(paren
id|chan
)paren
suffix:semicolon
id|sbmac_parse_hwaddr
c_func
(paren
id|addr
comma
id|eaddr
)paren
suffix:semicolon
id|val
op_assign
id|sbmac_addr2reg
c_func
(paren
id|eaddr
)paren
suffix:semicolon
id|SBMAC_WRITECSR
c_func
(paren
id|PKSEG1
c_func
(paren
id|port
op_plus
id|R_MAC_ETHERNET_ADDR
)paren
comma
id|val
)paren
suffix:semicolon
id|val
op_assign
id|SBMAC_READCSR
c_func
(paren
id|PKSEG1
c_func
(paren
id|port
op_plus
id|R_MAC_ETHERNET_ADDR
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|dev_sbmac
r_static
r_struct
id|net_device
op_star
id|dev_sbmac
(braket
id|MAX_UNITS
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_static
r_int
id|__init
DECL|function|sbmac_init_module
id|sbmac_init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|idx
suffix:semicolon
r_int
id|macidx
op_assign
l_int|0
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|sbmac_port_t
id|port
suffix:semicolon
multiline_comment|/*&n;&t; * For bringup when not using the firmware, we can pre-fill&n;&t; * the MAC addresses using the environment variables&n;&t; * specified in this file (or maybe from the config file?)&n;&t; */
macro_line|#ifdef SBMAC_ETH0_HWADDR
id|sbmac_setup_hwaddr
c_func
(paren
l_int|0
comma
id|SBMAC_ETH0_HWADDR
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SBMAC_ETH1_HWADDR
id|sbmac_setup_hwaddr
c_func
(paren
l_int|1
comma
id|SBMAC_ETH1_HWADDR
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SBMAC_ETH2_HWADDR
id|sbmac_setup_hwaddr
c_func
(paren
l_int|2
comma
id|SBMAC_ETH2_HWADDR
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Walk through the Ethernet controllers and find&n;&t; * those who have their MAC addresses set.&n;&t; */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|MAX_UNITS
suffix:semicolon
id|idx
op_increment
)paren
(brace
multiline_comment|/*&n;&t;         * This is the base address of the MAC.&n;&t;&t; */
id|port
op_assign
id|A_MAC_CHANNEL_BASE
c_func
(paren
id|idx
)paren
suffix:semicolon
multiline_comment|/*&t;&n;&t;&t; * The R_MAC_ETHERNET_ADDR register will be set to some nonzero&n;&t;&t; * value for us by the firmware if we&squot;re going to use this MAC.&n;&t;&t; * If we find a zero, skip this MAC.&n;&t;&t; */
r_if
c_cond
(paren
id|SBMAC_READCSR
c_func
(paren
id|PKSEG1
c_func
(paren
id|port
op_plus
id|R_MAC_ETHERNET_ADDR
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Okay, cool.  Initialize this MAC.&n;&t;&t; */
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|NULL
comma
r_sizeof
(paren
r_struct
id|sbmac_softc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_break
suffix:semicolon
multiline_comment|/* problems, get out now. */
id|dev-&gt;irq
op_assign
id|K_INT_MAC_0
op_plus
id|idx
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|port
suffix:semicolon
id|dev-&gt;mem_end
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*dev-&gt;init = sbmac_init;*/
id|sbmac_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev_sbmac
(braket
id|macidx
)braket
op_assign
id|dev
suffix:semicolon
id|macidx
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Should we care, &squot;macidx&squot; is the total number of enabled MACs.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|sbmac_cleanup_module
id|sbmac_cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|idx
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|MAX_UNITS
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|dev
op_assign
id|dev_sbmac
(braket
id|idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sbmac_softc
op_star
id|sc
op_assign
(paren
r_struct
id|sbmac_softc
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sbmac_uninitctx
c_func
(paren
id|sc
)paren
suffix:semicolon
id|KFREE
c_func
(paren
id|sc
)paren
suffix:semicolon
)brace
id|KFREE
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev_sbmac
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|variable|sbmac_init_module
id|module_init
c_func
(paren
id|sbmac_init_module
)paren
suffix:semicolon
DECL|variable|sbmac_cleanup_module
id|module_exit
c_func
(paren
id|sbmac_cleanup_module
)paren
suffix:semicolon
eof
