multiline_comment|/*****************************************************************************&n; *&n; * Name:&t;skgepnmi.c&n; * Project:&t;GEnesis, PCI Gigabit Ethernet Adapter&n; * Version:&t;$Revision: 1.109 $&n; * Date:&t;$Date: 2003/07/17 14:15:24 $&n; * Purpose:&t;Private Network Management Interface&n; *&n; ****************************************************************************/
multiline_comment|/******************************************************************************&n; *&n; *&t;(C)Copyright 1998-2002 SysKonnect GmbH.&n; *&t;(C)Copyright 2002-2003 Marvell.&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;The information in this file is provided &quot;AS IS&quot; without warranty.&n; *&n; ******************************************************************************/
multiline_comment|/*****************************************************************************&n; *&n; * History:&n; *&n; *&t;$Log: skgepnmi.c,v $&n; *&t;Revision 1.109  2003/07/17 14:15:24  tschilli&n; *&t;Bug in SkPnmiGenIoctl() fixed.&n; *&t;&n; *&t;Revision 1.108  2003/05/27 07:10:11  tschilli&n; *&t;Bug in SkPnmiGenIoctl() fixed.&n; *&t;&n; *&t;Revision 1.107  2003/05/23 13:01:10  tschilli&n; *&t;Code for DIAG support added (#define SK_DIAG_SUPPORT).&n; *&t;Code for generic PNMI IOCTL support added. The new function&n; *&t;SkPnmiGenIoctl() is used for this purpose.&n; *&t;Handling of OID_SKGE_BOARDLEVEL added.&n; *&t;Incorrect buffer size handling of OID_SKGE_MTU during GET action fixed.&n; *&t;Return code handling in PowerManagement() fixed.&n; *&t;Editorial changes.&n; *  &n; *&t;Revision 1.106  2003/04/10 14:47:31  rschmidt&n; *&t;Fixed handling for OID_GEN_RCV_OK and OID_GEN_XMIT_OK for YUKON&squot;s GMAC&n; *&t;in GetPhysStatVal().&n; *&t;Replaced macro PHY_READ() with function call SkXmPhyRead().&n; *&t;Made optimisations for readability and code size.&n; *&t;Editorial changes.&n; *&t;&n; *&t;Revision 1.105  2003/04/09 12:51:32  rschmidt&n; *&t;Fixed XMAC only handling for some events in SkPnmiEvent().&n; *&t;Fixed return value for OID_GEN_RCV_OK (SK_PNMI_HRX) in GetPhysStatVal().&n; *&t;Editorial changes.&n; *&t;&n; *&t;Revision 1.104  2003/03/27 11:18:21  tschilli&n; *&t;BRK statements from DEBUG code removed.&n; *&t;OID_GEN_XMIT_OK and OID_GEN_RCV_OK work with Yukon now.&n; *&t;Copyright messages changed.&n; *&t;&n; *&t;Revision 1.103  2002/12/20 09:57:13  tschilli&n; *&t;SK_PNMI_EVT_VCT_RESET event code changed.&n; *&t;Unused variable from Vct() removed.&n; *&t;&n; *&t;Revision 1.102  2002/12/16 14:03:24  tschilli&n; *&t;VCT code in Vct() changed.&n; *&t;&n; *&t;Revision 1.101  2002/12/16 09:04:10  tschilli&n; *&t;Code for VCT handling added.&n; *&t;&n; *&t;Revision 1.100  2002/09/26 14:28:13  tschilli&n; *&t;For XMAC the values in the SK_PNMI_PORT Port struct are copied to&n; *&t;the new SK_PNMI_PORT BufPort struct during a MacUpdate() call.&n; *&t;These values are used when GetPhysStatVal() is called. With this&n; *&t;mechanism you get the best results when software corrections for&n; *&t;counters are needed. Example: RX_LONGFRAMES.&n; *&t;&n; *&t;Revision 1.99  2002/09/17 12:31:19  tschilli&n; *&t;OID_SKGE_TX_HW_ERROR_CTS, OID_SKGE_OUT_ERROR_CTS, OID_GEN_XMIT_ERROR:&n; *&t;Double count of SK_PNMI_HTX_EXCESS_COL in function General() removed.&n; *&t;OID_PNP_CAPABILITIES: sizeof(SK_PM_WAKE_UP_CAPABILITIES) changed to&n; *&t;sizeof(SK_PNP_CAPABILITIES) in function PowerManagement().&n; *&t;&n; *&t;Revision 1.98  2002/09/10 09:00:03  rwahl&n; *&t;Adapted boolean definitions according sktypes.&n; *&t;&n; *&t;Revision 1.97  2002/09/05 15:07:03  rwahl&n; *&t;Editorial changes.&n; *&t;&n; *&t;Revision 1.96  2002/09/05 11:04:14  rwahl&n; *&t;- Rx/Tx packets statistics of virtual port were zero on link down (#10750)&n; *&t;- For GMAC the overflow IRQ for Rx longframe counter was not counted.&n; *&t;- Incorrect calculation for oids OID_SKGE_RX_HW_ERROR_CTS,&n; *&t;  OID_SKGE_IN_ERRORS_CTS,  OID_GEN_RCV_ERROR.&n; *&t;- Moved correction for OID_SKGE_STAT_RX_TOO_LONG to GetPhysStatVal().&n; *&t;- Editorial changes.&n; *&t;&n; *&t;Revision 1.95  2002/09/04 08:53:37  rwahl&n; *&t;- Incorrect statistics for Rx_too_long counter with jumbo frame (#10751)&n; *&t;- StatRxFrameTooLong &amp; StatRxPMaccErr counters were not reset.&n; *&t;- Fixed compiler warning for debug msg arg types.&n; *&t;&n; *&t;Revision 1.94  2002/08/09 15:42:14  rwahl&n; *&t;- Fixed StatAddr table for GMAC.&n; *&t;- VirtualConf(): returned indeterminated status for speed oids if no&n; *&t;  active port.&n; *&t;&n; *&t;Revision 1.93  2002/08/09 11:04:59  rwahl&n; *&t;Added handler for link speed caps.&n; *&t;&n; *&t;Revision 1.92  2002/08/09 09:43:03  rwahl&n; *&t;- Added handler for NDIS OID_PNP_xxx ids.&n; *&t;&n; *&t;Revision 1.91  2002/07/17 19:53:03  rwahl&n; *&t;- Added StatOvrflwBit table for XMAC &amp; GMAC.&n; *&t;- Extended StatAddr table for GMAC. Added check of number of counters&n; *&t;  in enumeration and size of StatAddr table on init level.&n; *&t;- Added use of GIFunc table.&n; *&t;- ChipSet is not static anymore,&n; *&t;- Extended SIRQ event handler for both mac types.&n; *&t;- Fixed rx short counter bug (#10620)&n; *&t;- Added handler for oids SKGE_SPEED_MODE &amp; SKGE_SPEED_STATUS.&n; *&t;- Extended GetPhysStatVal() for GMAC.&n; *&t;- Editorial changes.&n; *&t;&n; *&t;Revision 1.90  2002/05/22 08:56:25  rwahl&n; *&t;- Moved OID table to separate source file.&n; *&t;- Fix: TX_DEFFERAL counter incremented in full-duplex mode.&n; *&t;- Use string definitions for error msgs.&n; *&t;&n; *&t;Revision 1.89  2001/09/18 10:01:30  mkunz&n; *&t;some OID&squot;s fixed for dualnetmode&n; *&t;&n; *&t;Revision 1.88  2001/08/02 07:58:08  rwahl&n; *&t;- Fixed NetIndex to csum module at ResetCounter().&n; *&t;&n; *&t;Revision 1.87  2001/04/06 13:35:09  mkunz&n; *&t;-Bugs fixed in handling of OID_SKGE_MTU and the VPD OID&squot;s&n; *&t;&n; *&t;Revision 1.86  2001/03/09 09:18:03  mkunz&n; *&t;Changes in SK_DBG_MSG&n; *&t;&n; *&t;Revision 1.85  2001/03/08 09:37:31  mkunz&n; *&t;Bugfix in ResetCounter for Pnmi.Port structure&n; *&t;&n; *&t;Revision 1.84  2001/03/06 09:04:55  mkunz&n; *&t;Made some changes in instance calculation&n; *&t;&n; *&t;Revision 1.83  2001/02/15 09:15:32  mkunz&n; *&t;Necessary changes for dual net mode added&n; *&t;&n; *&t;Revision 1.82  2001/02/07 08:24:19  mkunz&n; *&t;-Made changes in handling of OID_SKGE_MTU&n; *&t;&n; *&t;Revision 1.81  2001/02/06 09:58:00  mkunz&n; *&t;-Vpd bug fixed&n; *&t;-OID_SKGE_MTU added&n; *&t;-pnmi support for dual net mode. Interface function and macros extended&n; *&t;&n; *&t;Revision 1.80  2001/01/22 13:41:35  rassmann&n; *&t;Supporting two nets on dual-port adapters.&n; *&t;&n; *&t;Revision 1.79  2000/12/05 14:57:40  cgoos&n; *&t;SetStruct failed before first Link Up (link mode of virtual&n; *&t;port &quot;INDETERMINATED&quot;).&n; *&t;&n; *&t;Revision 1.78  2000/09/12 10:44:58  cgoos&n; *&t;Fixed SK_PNMI_STORE_U32 calls with typecasted argument.&n; *&t;&n; *&t;Revision 1.77  2000/09/07 08:10:19  rwahl&n; *&t;- Modified algorithm for 64bit NDIS statistic counters;&n; *&t;  returns 64bit or 32bit value depending on passed buffer&n; *&t;  size. Indicate capability for 64bit NDIS counter, if passed&n; *&t;  buffer size is zero. OID_GEN_XMIT_ERROR, OID_GEN_RCV_ERROR,&n; *&t;  and OID_GEN_RCV_NO_BUFFER handled as 64bit counter, too.&n; *&t;- corrected OID_SKGE_RLMT_PORT_PREFERRED.&n; *&t;&n; *&t;Revision 1.76  2000/08/03 15:23:39  rwahl&n; *&t;- Correction for FrameTooLong counter has to be moved to OID handling&n; *&t;  routines (instead of statistic counter routine).&n; *&t;- Fix in XMAC Reset Event handling: Only offset counter for hardware&n; *&t;  statistic registers are updated.&n; *&t;&n; *&t;Revision 1.75  2000/08/01 16:46:05  rwahl&n; *&t;- Added StatRxLongFrames counter and correction of FrameTooLong counter.&n; *&t;- Added directive to control width (default = 32bit) of NDIS statistic&n; *&t;  counters (SK_NDIS_64BIT_CTR).&n; *&t;&n; *&t;Revision 1.74  2000/07/04 11:41:53  rwahl&n; *&t;- Added volition connector type.&n; *&t;&n; *&t;Revision 1.73  2000/03/15 16:33:10  rwahl&n; *&t;Fixed bug 10510; wrong reset of virtual port statistic counters.&n; *&t;&n; *&t;Revision 1.72  1999/12/06 16:15:53  rwahl&n; *&t;Fixed problem of instance range for current and factory MAC address.&n; *&t;&n; *&t;Revision 1.71  1999/12/06 10:14:20  rwahl&n; *&t;Fixed bug 10476; set operation for PHY_OPERATION_MODE.&n; *&t;&n; *&t;Revision 1.70  1999/11/22 13:33:34  cgoos&n; *&t;Changed license header to GPL.&n; *&t;&n; *&t;Revision 1.69  1999/10/18 11:42:15  rwahl&n; *&t;Added typecasts for checking event dependent param (debug only).&n; *&t;&n; *&t;Revision 1.68  1999/10/06 09:35:59  cgoos&n; *&t;Added state check to PHY_READ call (hanged if called during startup).&n; *&t;&n; *&t;Revision 1.67  1999/09/22 09:53:20  rwahl&n; *&t;- Read Broadcom register for updating FCS error counter (1000Base-T).&n; *&n; *&t;Revision 1.66  1999/08/26 13:47:56  rwahl&n; *&t;Added SK_DRIVER_SENDEVENT when queueing RLMT_CHANGE_THRES trap.&n; *&t;&n; *&t;Revision 1.65  1999/07/26 07:49:35  cgoos&n; *&t;Added two typecasts to avoid compiler warnings.&n; *&t;&n; *&t;Revision 1.64  1999/05/20 09:24:12  cgoos&n; *&t;Changes for 1000Base-T (sensors, Master/Slave).&n; *&n; *&t;Revision 1.63  1999/04/13 15:11:58  mhaveman&n; *&t;Moved include of rlmt.h to header skgepnmi.h because some macros&n; *&t;are needed there.&n; *&t;&n; *&t;Revision 1.62  1999/04/13 15:08:07  mhaveman&n; *&t;Replaced again SK_RLMT_CHECK_LINK with SK_PNMI_RLMT_MODE_CHK_LINK&n; *&t;to grant unified interface by only using the PNMI header file.&n; *&t;SK_PNMI_RLMT_MODE_CHK_LINK is defined the same as SK_RLMT_CHECK_LINK.&n; *&t;&n; *&t;Revision 1.61  1999/04/13 15:02:48  mhaveman&n; *&t;Changes caused by review:&n; *&t;-Changed some comments&n; *&t;-Removed redundant check for OID_SKGE_PHYS_FAC_ADDR&n; *&t;-Optimized PRESET check.&n; *&t;-Meaning of error SK_ADDR_DUPLICATE_ADDRESS changed. Set of same&n; *&t; address will now not cause this error. Removed corresponding check.&n; *&t;&n; *&t;Revision 1.60  1999/03/23 10:41:23  mhaveman&n; *&t;Added comments.&n; *&t;&n; *&t;Revision 1.59  1999/02/19 08:01:28  mhaveman&n; *&t;Fixed bug 10372 that after counter reset all ports were displayed&n; *&t;as inactive.&n; *&t;&n; *&t;Revision 1.58  1999/02/16 18:04:47  mhaveman&n; *&t;Fixed problem of twisted OIDs SENSOR_WAR_TIME and SENSOR_ERR_TIME.&n; *&t;&n; *&t;Revision 1.56  1999/01/27 12:29:11  mhaveman&n; *&t;SkTimerStart was called with time value in milli seconds but needs&n; *&t;micro seconds.&n; *&t;&n; *&t;Revision 1.55  1999/01/25 15:00:38  mhaveman&n; *&t;Added support to allow multiple ports to be active. If this feature in&n; *&t;future will be used, the Management Data Base variables PORT_ACTIVE&n; *&t;and PORT_PREFERED should be moved to the port specific part of RLMT.&n; *&t;Currently they return the values of the first active physical port&n; *&t;found. A set to the virtual port will actually change all active&n; *&t;physical ports. A get returns the melted values of all active physical&n; *&t;ports. If the port values differ a return value INDETERMINATED will&n; *&t;be returned. This effects especially the CONF group.&n; *&t;&n; *&t;Revision 1.54  1999/01/19 10:10:22  mhaveman&n; *&t;-Fixed bug 10354: Counter values of virtual port were wrong after port&n; *&t; switches&n; *&t;-Added check if a switch to the same port is notified.&n; *&t;&n; *&t;Revision 1.53  1999/01/07 09:25:21  mhaveman&n; *&t;Forgot to initialize a variable.&n; *&t;&n; *&t;Revision 1.52  1999/01/05 10:34:33  mhaveman&n; *&t;Fixed little error in RlmtChangeEstimate calculation.&n; *&t;&n; *&t;Revision 1.51  1999/01/05 09:59:07  mhaveman&n; *&t;-Moved timer start to init level 2&n; *&t;-Redesigned port switch average calculation to avoid 64bit&n; *&t; arithmetic.&n; *&t;&n; *&t;Revision 1.50  1998/12/10 15:13:59  mhaveman&n; *&t;-Fixed: PHYS_CUR_ADDR returned wrong addresses&n; *&t;-Fixed: RLMT_PORT_PREFERED and RLMT_CHANGE_THRES preset returned&n; *&t;        always BAD_VALUE.&n; *&t;-Fixed: TRAP buffer seemed to sometimes suddenly empty&n; *&t;&n; *&t;Revision 1.49  1998/12/09 16:17:07  mhaveman&n; *&t;Fixed: Couldnot delete VPD keys on UNIX.&n; *&t;&n; *&t;Revision 1.48  1998/12/09 14:11:10  mhaveman&n; *&t;-Add: Debugmessage for XMAC_RESET supressed to minimize output.&n; *&t;-Fixed: RlmtChangeThreshold will now be initialized.&n; *&t;-Fixed: VPD_ENTRIES_LIST extended value with unnecessary space char.&n; *&t;-Fixed: On VPD key creation an invalid key name could be created&n; *&t;        (e.g. A5)&n; *&t;-Some minor changes in comments and code.&n; *&t;&n; *&t;Revision 1.47  1998/12/08 16:00:31  mhaveman&n; *&t;-Fixed: For RLMT_PORT_ACTIVE will now be returned a 0 if no port&n; *&t;&t;is active.&n; *&t;-Fixed: For the RLMT statistics group only the last value was&n; *&t;&t;returned and the rest of the buffer was filled with 0xff&n; *&t;-Fixed: Mysteriously the preset on RLMT_MODE still returned&n; *&t;&t;BAD_VALUE.&n; *&t;Revision 1.46  1998/12/08 10:04:56  mhaveman&n; *&t;-Fixed: Preset on RLMT_MODE returned always BAD_VALUE error.&n; *&t;-Fixed: Alignment error in GetStruct&n; *&t;-Fixed: If for Get/Preset/SetStruct the buffer size is equal or&n; *&t;        larger than SK_PNMI_MIN_STRUCT_SIZE the return value is stored&n; *&t;&t;to the buffer. In this case the caller should always return&n; *&t;        ok to its upper routines. Only if the buffer size is less&n; *&t;        than SK_PNMI_MIN_STRUCT_SIZE and the return value is unequal&n; *&t;        to 0, an error should be returned by the caller.&n; *&t;-Fixed: Wrong number of instances with RLMT statistic.&n; *&t;-Fixed: Return now SK_LMODE_STAT_UNKNOWN if the LinkModeStatus is 0.&n; *&t;&n; *&t;Revision 1.45  1998/12/03 17:17:24  mhaveman&n; *&t;-Removed for VPD create action the buffer size limitation to 4 bytes.&n; *&t;-Pass now physical/active physical port to ADDR for CUR_ADDR set&n; *&t;&n; *&t;Revision 1.44  1998/12/03 15:14:35  mhaveman&n; *&t;Another change to Vpd instance evaluation.&n; *&n; *&t;Revision 1.43  1998/12/03 14:18:10  mhaveman&n; *&t;-Fixed problem in PnmiSetStruct. It was impossible to set any value.&n; *&t;-Removed VPD key evaluation for VPD_FREE_BYTES and VPD_ACTION.&n; *&n; *&t;Revision 1.42  1998/12/03 11:31:47  mhaveman&n; *&t;Inserted cast to satisfy lint.&n; *&t;&n; *&t;Revision 1.41  1998/12/03 11:28:16  mhaveman&n; *&t;Removed SK_PNMI_CHECKPTR&n; *&t;&n; *&t;Revision 1.40  1998/12/03 11:19:07  mhaveman&n; *&t;Fixed problems&n; *&t;-A set to virtual port will now be ignored. A set with broadcast&n; *&t; address to any port will be ignored.&n; *&t;-GetStruct function made VPD instance calculation wrong.&n; *&t;-Prefered port returned -1 instead of 0.&n; *&t;&n; *&t;Revision 1.39  1998/11/26 15:30:29  mhaveman&n; *&t;Added sense mode to link mode.&n; *&t;&n; *&t;Revision 1.38  1998/11/23 15:34:00  mhaveman&n; *&t;-Fixed bug for RX counters. On an RX overflow interrupt the high&n; *&t; words of all RX counters were incremented.&n; *&t;-SET operations on FLOWCTRL_MODE and LINK_MODE accept now the&n; *&t; value 0, which has no effect. It is usefull for multiple instance&n; *&t; SETs.&n; *&t;&n; *&t;Revision 1.37  1998/11/20 08:02:04  mhaveman&n; *&t;-Fixed: Ports were compared with MAX_SENSORS&n; *&t;-Fixed: Crash in GetTrapEntry with MEMSET macro&n; *&t;-Fixed: Conversions between physical, logical port index and instance&n; *&t;&n; *&t;Revision 1.36  1998/11/16 07:48:53  mhaveman&n; *&t;Casted SK_DRIVER_SENDEVENT with (void) to eleminate compiler warnings&n; *&t;on Solaris.&n; *&t;&n; *&t;Revision 1.35  1998/11/16 07:45:34  mhaveman&n; *&t;SkAddrOverride now returns value and will be checked.&n; *&n; *&t;Revision 1.34  1998/11/10 13:40:37  mhaveman&n; *&t;Needed to change interface, because NT driver needs a return value&n; *&t;of needed buffer space on TOO_SHORT errors. Therefore all&n; *&t;SkPnmiGet/Preset/Set functions now have a pointer to the length&n; *&t;parameter, where the needed space on error is returned.&n; *&t;&n; *&t;Revision 1.33  1998/11/03 13:52:46  mhaveman&n; *&t;Made file lint conform.&n; *&t;&n; *&t;Revision 1.32  1998/11/03 13:19:07  mhaveman&n; *&t;The events SK_HWEV_SET_LMODE and SK_HWEV_SET_FLOWMODE pass now in&n; *&t;Para32[0] the physical MAC index and in Para32[1] the new mode.&n; *&t;&n; *&t;Revision 1.31  1998/11/03 12:30:40  gklug&n; *&t;fix: compiler warning memset&n; *&n; *&t;Revision 1.30  1998/11/03 12:04:46  mhaveman&n; *&t;Fixed problem in SENSOR_VALUE, which wrote beyond the buffer end&n; *&t;Fixed alignment problem with CHIPSET.&n; *&n; *&t;Revision 1.29  1998/11/02 11:23:54  mhaveman&n; *&t;Corrected SK_ERROR_LOG to SK_ERR_LOG. Sorry.&n; *&t;&n; *&t;Revision 1.28  1998/11/02 10:47:16  mhaveman&n; *&t;Added syslog messages for internal errors.&n; *&t;&n; *&t;Revision 1.27  1998/10/30 15:48:06  mhaveman&n; *&t;Fixed problems after simulation of SK_PNMI_EVT_CHG_EST_TIMER and&n; *&t;RlmtChangeThreshold calculation.&n; *&t;&n; *&t;Revision 1.26  1998/10/29 15:36:55  mhaveman&n; *&t;-Fixed bug in trap buffer handling.&n; *&t;-OID_SKGE_DRIVER_DESCR, OID_SKGE_DRIVER_VERSION, OID_SKGE_HW_DESCR,&n; *&t; OID_SKGE_HW_VERSION, OID_SKGE_VPD_ENTRIES_LIST, OID_SKGE_VPD_KEY,&n; *&t; OID_SKGE_VPD_VALUE, and OID_SKGE_SENSOR_DESCR return values with&n; *&t; a leading octet before each string storing the string length.&n; *&t;-Perform a RlmtUpdate during SK_PNMI_EVT_XMAC_RESET to minimize&n; *&t; RlmtUpdate calls in GetStatVal.&n; *&t;-Inserted SK_PNMI_CHECKFLAGS macro increase readability.&n; *&t;&n; *&t;Revision 1.25  1998/10/29 08:50:36  mhaveman&n; *&t;Fixed problems after second event simulation.&n; *&t;&n; *&t;Revision 1.24  1998/10/28 08:44:37  mhaveman&n; *&t;-Fixed alignment problem&n; *&t;-Fixed problems during event simulation&n; *&t;-Fixed sequence of error return code (INSTANCE -&gt; ACCESS -&gt; SHORT)&n; *&t;-Changed type of parameter Instance back to SK_U32 because of VPD&n; *&t;-Updated new VPD function calls&n; *&n; *&t;Revision 1.23  1998/10/23 10:16:37  mhaveman&n; *&t;Fixed bugs after buffer test simulation.&n; *&t;&n; *&t;Revision 1.22  1998/10/21 13:23:52  mhaveman&n; *&t;-Call syntax of SkOsGetTime() changed to SkOsGetTime(pAc).&n; *&t;-Changed calculation of hundrets of seconds.&n; *&n; *&t;Revision 1.20  1998/10/20 07:30:45  mhaveman&n; *&t;Made type changes to unsigned integer where possible.&n; *&t;&n; *&t;Revision 1.19  1998/10/19 10:51:30  mhaveman&n; *&t;-Made Bug fixes after simulation run&n; *&t;-Renamed RlmtMAC... to RlmtPort...&n; *&t;-Marked workarounds with Errata comments&n; *&t;&n; *&t;Revision 1.18  1998/10/14 07:50:08  mhaveman&n; *&t;-For OID_SKGE_LINK_STATUS the link down detection has moved from RLMT&n; *&t; to HWACCESS.&n; *&t;-Provided all MEMCPY/MEMSET macros with (char *) pointers, because&n; *&t; Solaris throwed warnings when mapping to bcopy/bset.&n; *&n; *&t;Revision 1.17  1998/10/13 07:42:01  mhaveman&n; *&t;-Added OIDs OID_SKGE_TRAP_NUMBER and OID_SKGE_ALL_DATA&n; *&t;-Removed old cvs history entries&n; *&t;-Renamed MacNumber to PortNumber&n; *&n; *&t;Revision 1.16  1998/10/07 10:52:49  mhaveman&n; *&t;-Inserted handling of some OID_GEN_ Ids for windows&n; *&t;-Fixed problem with 803.2 statistic.&n; *&t;&n; *&t;Revision 1.15  1998/10/01 09:16:29  mhaveman&n; *&t;Added Debug messages for function call and UpdateFlag tracing.&n; *&t;&n; *&t;Revision 1.14  1998/09/30 13:39:09  mhaveman&n; *&t;-Reduced namings of &squot;MAC&squot; by replacing them with &squot;PORT&squot;.&n; *&t;-Completed counting of OID_SKGE_RX_HW_ERROR_CTS,&n; *       OID_SKGE_TX_HW_ERROR_CTS,&n; *&t; OID_SKGE_IN_ERRORS_CTS, and OID_SKGE_OUT_ERROR_CTS.&n; *&t;-SET check for RlmtMode&n; *&t;&n; *&t;Revision 1.13  1998/09/28 13:13:08  mhaveman&n; *&t;Hide strcmp, strlen, and strncpy behind macros SK_STRCMP, SK_STRLEN,&n; *&t;and SK_STRNCPY. (Same reasons as for mem.. and MEM..)&n; *&t;&n; *&t;Revision 1.12  1998/09/16 08:18:36  cgoos&n; *&t;Fix: XM_INxx and XM_OUTxx called with different parameter order:&n; *      sometimes IoC,Mac,...  sometimes Mac,IoC,... Now always first variant.&n; *&t;Fix: inserted &quot;Pnmi.&quot; into some pAC-&gt;pDriverDescription / Version.&n; *&t;Change: memset, memcpy to makros SK_MEMSET, SK_MEMCPY&n; *&n; *&t;Revision 1.11  1998/09/04 17:01:45  mhaveman&n; *&t;Added SyncCounter as macro and OID_SKGE_.._NO_DESCR_CTS to&n; *&t;OID_SKGE_RX_NO_BUF_CTS.&n; *&t;&n; *&t;Revision 1.10  1998/09/04 14:35:35  mhaveman&n; *&t;Added macro counters, that are counted by driver.&n; *&t;&n; ****************************************************************************/
macro_line|#ifndef _lint
DECL|variable|SysKonnectFileId
r_static
r_const
r_char
id|SysKonnectFileId
(braket
)braket
op_assign
l_string|&quot;@(#) $Id: skgepnmi.c,v 1.109 2003/07/17 14:15:24 tschilli Exp $ (C) Marvell.&quot;
suffix:semicolon
macro_line|#endif /* !_lint */
macro_line|#include &quot;h/skdrv1st.h&quot;
macro_line|#include &quot;h/sktypes.h&quot;
macro_line|#include &quot;h/xmac_ii.h&quot;
macro_line|#include &quot;h/skdebug.h&quot;
macro_line|#include &quot;h/skqueue.h&quot;
macro_line|#include &quot;h/skgepnmi.h&quot;
macro_line|#include &quot;h/skgesirq.h&quot;
macro_line|#include &quot;h/skcsum.h&quot;
macro_line|#include &quot;h/skvpd.h&quot;
macro_line|#include &quot;h/skgehw.h&quot;
macro_line|#include &quot;h/skgeinit.h&quot;
macro_line|#include &quot;h/skdrv2nd.h&quot;
macro_line|#include &quot;h/skgepnm2.h&quot;
macro_line|#ifdef SK_POWER_MGMT
macro_line|#include &quot;h/skgepmgt.h&quot;
macro_line|#endif
multiline_comment|/* defines *******************************************************************/
macro_line|#ifndef DEBUG
DECL|macro|PNMI_STATIC
mdefine_line|#define PNMI_STATIC&t;static
macro_line|#else&t;/* DEBUG */
DECL|macro|PNMI_STATIC
mdefine_line|#define PNMI_STATIC
macro_line|#endif /* DEBUG */
multiline_comment|/*&n; * Public Function prototypes&n; */
r_int
id|SkPnmiInit
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|level
)paren
suffix:semicolon
r_int
id|SkPnmiGetVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
id|SK_U32
id|Id
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
r_int
id|SkPnmiPreSetVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
id|SK_U32
id|Id
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
r_int
id|SkPnmiSetVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
id|SK_U32
id|Id
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
r_int
id|SkPnmiGetStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
r_int
id|SkPnmiPreSetStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
r_int
id|SkPnmiSetStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
r_int
id|SkPnmiEvent
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
id|SK_U32
id|Event
comma
id|SK_EVPARA
id|Param
)paren
suffix:semicolon
r_int
id|SkPnmiGenIoctl
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_void
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
multiline_comment|/*&n; * Private Function prototypes&n; */
id|PNMI_STATIC
id|SK_U8
id|CalculateLinkModeStatus
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
r_int
id|PhysPortIndex
)paren
suffix:semicolon
id|PNMI_STATIC
id|SK_U8
id|CalculateLinkStatus
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
r_int
id|PhysPortIndex
)paren
suffix:semicolon
id|PNMI_STATIC
r_void
id|CopyMac
c_func
(paren
r_char
op_star
id|pDst
comma
id|SK_MAC_ADDR
op_star
id|pMac
)paren
suffix:semicolon
id|PNMI_STATIC
r_void
id|CopyTrapQueue
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
r_char
op_star
id|pDstBuf
)paren
suffix:semicolon
id|PNMI_STATIC
id|SK_U64
id|GetPhysStatVal
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
r_int
id|PhysPortIndex
comma
r_int
r_int
id|StatIndex
)paren
suffix:semicolon
id|PNMI_STATIC
id|SK_U64
id|GetStatVal
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
r_int
id|LogPortIndex
comma
r_int
r_int
id|StatIndex
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
id|PNMI_STATIC
r_char
op_star
id|GetTrapEntry
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_U32
id|TrapId
comma
r_int
r_int
id|Size
)paren
suffix:semicolon
id|PNMI_STATIC
r_void
id|GetTrapQueueLen
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
r_int
r_int
op_star
id|pLen
comma
r_int
r_int
op_star
id|pEntries
)paren
suffix:semicolon
id|PNMI_STATIC
r_int
id|GetVpdKeyArr
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_char
op_star
id|pKeyArr
comma
r_int
r_int
id|KeyArrLen
comma
r_int
r_int
op_star
id|pKeyNo
)paren
suffix:semicolon
id|PNMI_STATIC
r_int
id|LookupId
c_func
(paren
id|SK_U32
id|Id
)paren
suffix:semicolon
id|PNMI_STATIC
r_int
id|MacUpdate
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
r_int
id|FirstMac
comma
r_int
r_int
id|LastMac
)paren
suffix:semicolon
id|PNMI_STATIC
r_int
id|PnmiStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|Action
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
id|PNMI_STATIC
r_int
id|PnmiVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|Action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
id|PNMI_STATIC
r_void
id|QueueRlmtNewMacTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
r_int
r_int
id|ActiveMac
)paren
suffix:semicolon
id|PNMI_STATIC
r_void
id|QueueRlmtPortTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_U32
id|TrapId
comma
r_int
r_int
id|PortIndex
)paren
suffix:semicolon
id|PNMI_STATIC
r_void
id|QueueSensorTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_U32
id|TrapId
comma
r_int
r_int
id|SensorIndex
)paren
suffix:semicolon
id|PNMI_STATIC
r_void
id|QueueSimpleTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_U32
id|TrapId
)paren
suffix:semicolon
id|PNMI_STATIC
r_void
id|ResetCounter
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
id|PNMI_STATIC
r_int
id|RlmtUpdate
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
id|PNMI_STATIC
r_int
id|SirqUpdate
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
)paren
suffix:semicolon
id|PNMI_STATIC
r_void
id|VirtualConf
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
)paren
suffix:semicolon
id|PNMI_STATIC
r_int
id|Vct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_int
id|Action
comma
id|SK_U32
id|Id
comma
r_char
op_star
id|pBuf
comma
r_int
r_int
op_star
id|pLen
comma
id|SK_U32
id|Instance
comma
r_int
r_int
id|TableIndex
comma
id|SK_U32
id|NetIndex
)paren
suffix:semicolon
id|PNMI_STATIC
r_void
id|CheckVctStatus
c_func
(paren
id|SK_AC
op_star
comma
id|SK_IOC
comma
r_char
op_star
comma
id|SK_U32
comma
id|SK_U32
)paren
suffix:semicolon
multiline_comment|/*&n; * Table to correlate OID with handler function and index to&n; * hardware register stored in StatAddress if applicable.&n; */
macro_line|#include &quot;skgemib.c&quot;
multiline_comment|/* global variables **********************************************************/
multiline_comment|/*&n; * Overflow status register bit table and corresponding counter&n; * dependent on MAC type - the number relates to the size of overflow&n; * mask returned by the pFnMacOverflow function&n; */
DECL|variable|StatOvrflwBit
id|PNMI_STATIC
r_const
id|SK_U16
id|StatOvrflwBit
(braket
)braket
(braket
id|SK_PNMI_MAC_TYPES
)braket
op_assign
(brace
multiline_comment|/* Bit0  */
(brace
id|SK_PNMI_HTX
comma
id|SK_PNMI_HTX_UNICAST
)brace
comma
multiline_comment|/* Bit1  */
(brace
id|SK_PNMI_HTX_OCTETHIGH
comma
id|SK_PNMI_HTX_BROADCAST
)brace
comma
multiline_comment|/* Bit2  */
(brace
id|SK_PNMI_HTX_OCTETLOW
comma
id|SK_PNMI_HTX_PMACC
)brace
comma
multiline_comment|/* Bit3  */
(brace
id|SK_PNMI_HTX_BROADCAST
comma
id|SK_PNMI_HTX_MULTICAST
)brace
comma
multiline_comment|/* Bit4  */
(brace
id|SK_PNMI_HTX_MULTICAST
comma
id|SK_PNMI_HTX_OCTETLOW
)brace
comma
multiline_comment|/* Bit5  */
(brace
id|SK_PNMI_HTX_UNICAST
comma
id|SK_PNMI_HTX_OCTETHIGH
)brace
comma
multiline_comment|/* Bit6  */
(brace
id|SK_PNMI_HTX_LONGFRAMES
comma
id|SK_PNMI_HTX_64
)brace
comma
multiline_comment|/* Bit7  */
(brace
id|SK_PNMI_HTX_BURST
comma
id|SK_PNMI_HTX_127
)brace
comma
multiline_comment|/* Bit8  */
(brace
id|SK_PNMI_HTX_PMACC
comma
id|SK_PNMI_HTX_255
)brace
comma
multiline_comment|/* Bit9  */
(brace
id|SK_PNMI_HTX_MACC
comma
id|SK_PNMI_HTX_511
)brace
comma
multiline_comment|/* Bit10 */
(brace
id|SK_PNMI_HTX_SINGLE_COL
comma
id|SK_PNMI_HTX_1023
)brace
comma
multiline_comment|/* Bit11 */
(brace
id|SK_PNMI_HTX_MULTI_COL
comma
id|SK_PNMI_HTX_MAX
)brace
comma
multiline_comment|/* Bit12 */
(brace
id|SK_PNMI_HTX_EXCESS_COL
comma
id|SK_PNMI_HTX_LONGFRAMES
)brace
comma
multiline_comment|/* Bit13 */
(brace
id|SK_PNMI_HTX_LATE_COL
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit14 */
(brace
id|SK_PNMI_HTX_DEFFERAL
comma
id|SK_PNMI_HTX_COL
)brace
comma
multiline_comment|/* Bit15 */
(brace
id|SK_PNMI_HTX_EXCESS_DEF
comma
id|SK_PNMI_HTX_LATE_COL
)brace
comma
multiline_comment|/* Bit16 */
(brace
id|SK_PNMI_HTX_UNDERRUN
comma
id|SK_PNMI_HTX_EXCESS_COL
)brace
comma
multiline_comment|/* Bit17 */
(brace
id|SK_PNMI_HTX_CARRIER
comma
id|SK_PNMI_HTX_MULTI_COL
)brace
comma
multiline_comment|/* Bit18 */
(brace
id|SK_PNMI_HTX_UTILUNDER
comma
id|SK_PNMI_HTX_SINGLE_COL
)brace
comma
multiline_comment|/* Bit19 */
(brace
id|SK_PNMI_HTX_UTILOVER
comma
id|SK_PNMI_HTX_UNDERRUN
)brace
comma
multiline_comment|/* Bit20 */
(brace
id|SK_PNMI_HTX_64
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit21 */
(brace
id|SK_PNMI_HTX_127
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit22 */
(brace
id|SK_PNMI_HTX_255
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit23 */
(brace
id|SK_PNMI_HTX_511
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit24 */
(brace
id|SK_PNMI_HTX_1023
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit25 */
(brace
id|SK_PNMI_HTX_MAX
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit26 */
(brace
id|SK_PNMI_HTX_RESERVED
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit27 */
(brace
id|SK_PNMI_HTX_RESERVED
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit28 */
(brace
id|SK_PNMI_HTX_RESERVED
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit29 */
(brace
id|SK_PNMI_HTX_RESERVED
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit30 */
(brace
id|SK_PNMI_HTX_RESERVED
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit31 */
(brace
id|SK_PNMI_HTX_RESERVED
comma
id|SK_PNMI_HTX_RESERVED
)brace
comma
multiline_comment|/* Bit32 */
(brace
id|SK_PNMI_HRX
comma
id|SK_PNMI_HRX_UNICAST
)brace
comma
multiline_comment|/* Bit33 */
(brace
id|SK_PNMI_HRX_OCTETHIGH
comma
id|SK_PNMI_HRX_BROADCAST
)brace
comma
multiline_comment|/* Bit34 */
(brace
id|SK_PNMI_HRX_OCTETLOW
comma
id|SK_PNMI_HRX_PMACC
)brace
comma
multiline_comment|/* Bit35 */
(brace
id|SK_PNMI_HRX_BROADCAST
comma
id|SK_PNMI_HRX_MULTICAST
)brace
comma
multiline_comment|/* Bit36 */
(brace
id|SK_PNMI_HRX_MULTICAST
comma
id|SK_PNMI_HRX_FCS
)brace
comma
multiline_comment|/* Bit37 */
(brace
id|SK_PNMI_HRX_UNICAST
comma
id|SK_PNMI_HRX_RESERVED
)brace
comma
multiline_comment|/* Bit38 */
(brace
id|SK_PNMI_HRX_PMACC
comma
id|SK_PNMI_HRX_OCTETLOW
)brace
comma
multiline_comment|/* Bit39 */
(brace
id|SK_PNMI_HRX_MACC
comma
id|SK_PNMI_HRX_OCTETHIGH
)brace
comma
multiline_comment|/* Bit40 */
(brace
id|SK_PNMI_HRX_PMACC_ERR
comma
id|SK_PNMI_HRX_BADOCTETLOW
)brace
comma
multiline_comment|/* Bit41 */
(brace
id|SK_PNMI_HRX_MACC_UNKWN
comma
id|SK_PNMI_HRX_BADOCTETHIGH
)brace
comma
multiline_comment|/* Bit42 */
(brace
id|SK_PNMI_HRX_BURST
comma
id|SK_PNMI_HRX_UNDERSIZE
)brace
comma
multiline_comment|/* Bit43 */
(brace
id|SK_PNMI_HRX_MISSED
comma
id|SK_PNMI_HRX_RUNT
)brace
comma
multiline_comment|/* Bit44 */
(brace
id|SK_PNMI_HRX_FRAMING
comma
id|SK_PNMI_HRX_64
)brace
comma
multiline_comment|/* Bit45 */
(brace
id|SK_PNMI_HRX_OVERFLOW
comma
id|SK_PNMI_HRX_127
)brace
comma
multiline_comment|/* Bit46 */
(brace
id|SK_PNMI_HRX_JABBER
comma
id|SK_PNMI_HRX_255
)brace
comma
multiline_comment|/* Bit47 */
(brace
id|SK_PNMI_HRX_CARRIER
comma
id|SK_PNMI_HRX_511
)brace
comma
multiline_comment|/* Bit48 */
(brace
id|SK_PNMI_HRX_IRLENGTH
comma
id|SK_PNMI_HRX_1023
)brace
comma
multiline_comment|/* Bit49 */
(brace
id|SK_PNMI_HRX_SYMBOL
comma
id|SK_PNMI_HRX_MAX
)brace
comma
multiline_comment|/* Bit50 */
(brace
id|SK_PNMI_HRX_SHORTS
comma
id|SK_PNMI_HRX_LONGFRAMES
)brace
comma
multiline_comment|/* Bit51 */
(brace
id|SK_PNMI_HRX_RUNT
comma
id|SK_PNMI_HRX_TOO_LONG
)brace
comma
multiline_comment|/* Bit52 */
(brace
id|SK_PNMI_HRX_TOO_LONG
comma
id|SK_PNMI_HRX_JABBER
)brace
comma
multiline_comment|/* Bit53 */
(brace
id|SK_PNMI_HRX_FCS
comma
id|SK_PNMI_HRX_RESERVED
)brace
comma
multiline_comment|/* Bit54 */
(brace
id|SK_PNMI_HRX_RESERVED
comma
id|SK_PNMI_HRX_OVERFLOW
)brace
comma
multiline_comment|/* Bit55 */
(brace
id|SK_PNMI_HRX_CEXT
comma
id|SK_PNMI_HRX_RESERVED
)brace
comma
multiline_comment|/* Bit56 */
(brace
id|SK_PNMI_HRX_UTILUNDER
comma
id|SK_PNMI_HRX_RESERVED
)brace
comma
multiline_comment|/* Bit57 */
(brace
id|SK_PNMI_HRX_UTILOVER
comma
id|SK_PNMI_HRX_RESERVED
)brace
comma
multiline_comment|/* Bit58 */
(brace
id|SK_PNMI_HRX_64
comma
id|SK_PNMI_HRX_RESERVED
)brace
comma
multiline_comment|/* Bit59 */
(brace
id|SK_PNMI_HRX_127
comma
id|SK_PNMI_HRX_RESERVED
)brace
comma
multiline_comment|/* Bit60 */
(brace
id|SK_PNMI_HRX_255
comma
id|SK_PNMI_HRX_RESERVED
)brace
comma
multiline_comment|/* Bit61 */
(brace
id|SK_PNMI_HRX_511
comma
id|SK_PNMI_HRX_RESERVED
)brace
comma
multiline_comment|/* Bit62 */
(brace
id|SK_PNMI_HRX_1023
comma
id|SK_PNMI_HRX_RESERVED
)brace
comma
multiline_comment|/* Bit63 */
(brace
id|SK_PNMI_HRX_MAX
comma
id|SK_PNMI_HRX_RESERVED
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Table for hardware register saving on resets and port switches&n; */
DECL|variable|StatAddr
id|PNMI_STATIC
r_const
id|SK_PNMI_STATADDR
id|StatAddr
(braket
id|SK_PNMI_MAX_IDX
)braket
(braket
id|SK_PNMI_MAC_TYPES
)braket
op_assign
(brace
multiline_comment|/* SK_PNMI_HTX */
(brace
(brace
id|XM_TXF_OK
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_OCTETHIGH */
(brace
(brace
id|XM_TXO_OK_HI
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXO_OK_HI
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_OCTETLOW */
(brace
(brace
id|XM_TXO_OK_LO
comma
id|SK_FALSE
)brace
comma
(brace
id|GM_TXO_OK_LO
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_BROADCAST */
(brace
(brace
id|XM_TXF_BC_OK
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_BC_OK
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_MULTICAST */
(brace
(brace
id|XM_TXF_MC_OK
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_MC_OK
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_UNICAST */
(brace
(brace
id|XM_TXF_UC_OK
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_UC_OK
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_BURST */
(brace
(brace
id|XM_TXE_BURST
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_PMACC */
(brace
(brace
id|XM_TXF_MPAUSE
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_MPAUSE
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_MACC */
(brace
(brace
id|XM_TXF_MCTRL
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_COL */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
id|GM_TXF_COL
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_SINGLE_COL */
(brace
(brace
id|XM_TXF_SNG_COL
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_SNG_COL
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_MULTI_COL */
(brace
(brace
id|XM_TXF_MUL_COL
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_MUL_COL
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_EXCESS_COL */
(brace
(brace
id|XM_TXF_ABO_COL
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_ABO_COL
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_LATE_COL */
(brace
(brace
id|XM_TXF_LAT_COL
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_LAT_COL
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_DEFFERAL */
(brace
(brace
id|XM_TXF_DEF
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_EXCESS_DEF */
(brace
(brace
id|XM_TXF_EX_DEF
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_UNDERRUN */
(brace
(brace
id|XM_TXE_FIFO_UR
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXE_FIFO_UR
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_CARRIER */
(brace
(brace
id|XM_TXE_CS_ERR
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_UTILUNDER */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_UTILOVER */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_64 */
(brace
(brace
id|XM_TXF_64B
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_64B
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_127 */
(brace
(brace
id|XM_TXF_127B
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_127B
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_255 */
(brace
(brace
id|XM_TXF_255B
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_255B
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_511 */
(brace
(brace
id|XM_TXF_511B
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_511B
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_1023 */
(brace
(brace
id|XM_TXF_1023B
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_1023B
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_MAX */
(brace
(brace
id|XM_TXF_MAX_SZ
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_1518B
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_LONGFRAMES  */
(brace
(brace
id|XM_TXF_LONG
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_TXF_MAX_SZ
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_SYNC */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_SYNC_OCTET */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HTX_RESERVED */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX */
(brace
(brace
id|XM_RXF_OK
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_OCTETHIGH */
(brace
(brace
id|XM_RXO_OK_HI
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXO_OK_HI
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_OCTETLOW */
(brace
(brace
id|XM_RXO_OK_LO
comma
id|SK_FALSE
)brace
comma
(brace
id|GM_RXO_OK_LO
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_BADOCTETHIGH */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
id|GM_RXO_ERR_HI
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_BADOCTETLOW */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
id|GM_RXO_ERR_LO
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_BROADCAST */
(brace
(brace
id|XM_RXF_BC_OK
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_BC_OK
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_MULTICAST */
(brace
(brace
id|XM_RXF_MC_OK
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_MC_OK
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_UNICAST */
(brace
(brace
id|XM_RXF_UC_OK
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_UC_OK
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_PMACC */
(brace
(brace
id|XM_RXF_MPAUSE
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_MPAUSE
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_MACC */
(brace
(brace
id|XM_RXF_MCTRL
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_PMACC_ERR */
(brace
(brace
id|XM_RXF_INV_MP
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_MACC_UNKWN */
(brace
(brace
id|XM_RXF_INV_MOC
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_BURST */
(brace
(brace
id|XM_RXE_BURST
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_MISSED */
(brace
(brace
id|XM_RXE_FMISS
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_FRAMING */
(brace
(brace
id|XM_RXF_FRA_ERR
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_UNDERSIZE */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
id|GM_RXF_SHT
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_OVERFLOW */
(brace
(brace
id|XM_RXE_FIFO_OV
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXE_FIFO_OV
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_JABBER */
(brace
(brace
id|XM_RXF_JAB_PKT
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_JAB_PKT
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_CARRIER */
(brace
(brace
id|XM_RXE_CAR_ERR
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_IRLENGTH */
(brace
(brace
id|XM_RXF_LEN_ERR
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_SYMBOL */
(brace
(brace
id|XM_RXE_SYM_ERR
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_SHORTS */
(brace
(brace
id|XM_RXE_SHT_ERR
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_RUNT */
(brace
(brace
id|XM_RXE_RUNT
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXE_FRAG
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_TOO_LONG */
(brace
(brace
id|XM_RXF_LNG_ERR
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_LNG_ERR
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_FCS */
(brace
(brace
id|XM_RXF_FCS_ERR
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_FCS_ERR
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_CEXT */
(brace
(brace
id|XM_RXF_CEX_ERR
comma
id|SK_TRUE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_UTILUNDER */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_UTILOVER */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_64 */
(brace
(brace
id|XM_RXF_64B
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_64B
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_127 */
(brace
(brace
id|XM_RXF_127B
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_127B
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_255 */
(brace
(brace
id|XM_RXF_255B
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_255B
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_511 */
(brace
(brace
id|XM_RXF_511B
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_511B
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_1023 */
(brace
(brace
id|XM_RXF_1023B
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_1023B
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_MAX */
(brace
(brace
id|XM_RXF_MAX_SZ
comma
id|SK_TRUE
)brace
comma
(brace
id|GM_RXF_1518B
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_LONGFRAMES */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
id|GM_RXF_MAX_SZ
comma
id|SK_TRUE
)brace
)brace
comma
multiline_comment|/* SK_PNMI_HRX_RESERVED */
(brace
(brace
l_int|0
comma
id|SK_FALSE
)brace
comma
(brace
l_int|0
comma
id|SK_FALSE
)brace
)brace
)brace
suffix:semicolon
multiline_comment|/*****************************************************************************&n; *&n; * Public functions&n; *&n; */
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiInit - Init function of PNMI&n; *&n; * Description:&n; *&t;SK_INIT_DATA: Initialises the data structures&n; *&t;SK_INIT_IO:   Resets the XMAC statistics, determines the device and&n; *&t;              connector type.&n; *&t;SK_INIT_RUN:  Starts a timer event for port switch per hour&n; *&t;              calculation.&n; *&n; * Returns:&n; *&t;Always 0&n; */
DECL|function|SkPnmiInit
r_int
id|SkPnmiInit
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Level
)paren
multiline_comment|/* Initialization level */
(brace
r_int
r_int
id|PortMax
suffix:semicolon
multiline_comment|/* Number of ports */
r_int
r_int
id|PortIndex
suffix:semicolon
multiline_comment|/* Current port index in loop */
id|SK_U16
id|Val16
suffix:semicolon
multiline_comment|/* Multiple purpose 16 bit variable */
id|SK_U8
id|Val8
suffix:semicolon
multiline_comment|/* Mulitple purpose 8 bit variable */
id|SK_EVPARA
id|EventParam
suffix:semicolon
multiline_comment|/* Event struct for timer event */
id|SK_PNMI_VCT
op_star
id|pVctBackupData
suffix:semicolon
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiInit: Called, level=%d&bslash;n&quot;
comma
id|Level
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|Level
)paren
(brace
r_case
id|SK_INIT_DATA
suffix:colon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi
)paren
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.TrapBufFree
op_assign
id|SK_PNMI_TRAP_QUEUE_LEN
suffix:semicolon
id|pAC-&gt;Pnmi.StartUpTime
op_assign
id|SK_PNMI_HUNDREDS_SEC
c_func
(paren
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeThreshold
op_assign
id|SK_PNMI_DEF_RLMT_CHG_THRES
suffix:semicolon
r_for
c_loop
(paren
id|PortIndex
op_assign
l_int|0
suffix:semicolon
id|PortIndex
OL
id|SK_MAX_MACS
suffix:semicolon
id|PortIndex
op_increment
)paren
(brace
id|pAC-&gt;Pnmi.Port
(braket
id|PortIndex
)braket
dot
id|ActiveFlag
op_assign
id|SK_FALSE
suffix:semicolon
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_assign
id|SK_FALSE
suffix:semicolon
)brace
macro_line|#ifdef SK_PNMI_CHECK
r_if
c_cond
(paren
id|SK_PNMI_MAX_IDX
op_ne
id|SK_PNMI_CNT_NO
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR049
comma
id|SK_PNMI_ERR049MSG
)paren
suffix:semicolon
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_INIT
op_or
id|SK_DBGCAT_FATAL
comma
(paren
l_string|&quot;CounterOffset struct size (%d) differs from&quot;
l_string|&quot;SK_PNMI_MAX_IDX (%d)&bslash;n&quot;
comma
id|SK_PNMI_CNT_NO
comma
id|SK_PNMI_MAX_IDX
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SK_PNMI_MAX_IDX
op_ne
(paren
r_sizeof
(paren
id|StatAddr
)paren
op_div
(paren
r_sizeof
(paren
id|SK_PNMI_STATADDR
)paren
op_star
id|SK_PNMI_MAC_TYPES
)paren
)paren
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR050
comma
id|SK_PNMI_ERR050MSG
)paren
suffix:semicolon
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_INIT
op_or
id|SK_DBGCAT_FATAL
comma
(paren
l_string|&quot;StatAddr table size (%d) differs from &quot;
l_string|&quot;SK_PNMI_MAX_IDX (%d)&bslash;n&quot;
comma
(paren
r_sizeof
(paren
id|StatAddr
)paren
op_div
(paren
r_sizeof
(paren
id|SK_PNMI_STATADDR
)paren
op_star
id|SK_PNMI_MAC_TYPES
)paren
)paren
comma
id|SK_PNMI_MAX_IDX
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* SK_PNMI_CHECK */
r_break
suffix:semicolon
r_case
id|SK_INIT_IO
suffix:colon
multiline_comment|/*&n;&t;&t; * Reset MAC counters&n;&t;&t; */
id|PortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
r_for
c_loop
(paren
id|PortIndex
op_assign
l_int|0
suffix:semicolon
id|PortIndex
OL
id|PortMax
suffix:semicolon
id|PortIndex
op_increment
)paren
(brace
id|pAC-&gt;GIni.GIFunc
dot
id|pFnMacResetCounter
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PortIndex
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize DSP variables for Vct() to 0xff =&gt; Never written! */
r_for
c_loop
(paren
id|PortIndex
op_assign
l_int|0
suffix:semicolon
id|PortIndex
OL
id|PortMax
suffix:semicolon
id|PortIndex
op_increment
)paren
(brace
id|pAC-&gt;GIni.GP
(braket
id|PortIndex
)braket
dot
id|PCableLen
op_assign
l_int|0xff
suffix:semicolon
id|pVctBackupData
op_assign
op_amp
id|pAC-&gt;Pnmi.VctBackup
(braket
id|PortIndex
)braket
suffix:semicolon
id|pVctBackupData-&gt;PCableLen
op_assign
l_int|0xff
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get pci bus speed&n;&t;&t; */
id|SK_IN16
c_func
(paren
id|IoC
comma
id|B0_CTST
comma
op_amp
id|Val16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Val16
op_amp
id|CS_BUS_CLOCK
)paren
op_eq
l_int|0
)paren
(brace
id|pAC-&gt;Pnmi.PciBusSpeed
op_assign
l_int|33
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;Pnmi.PciBusSpeed
op_assign
l_int|66
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get pci bus width&n;&t;&t; */
id|SK_IN16
c_func
(paren
id|IoC
comma
id|B0_CTST
comma
op_amp
id|Val16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Val16
op_amp
id|CS_BUS_SLOT_SZ
)paren
op_eq
l_int|0
)paren
(brace
id|pAC-&gt;Pnmi.PciBusWidth
op_assign
l_int|32
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;Pnmi.PciBusWidth
op_assign
l_int|64
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get chipset&n;&t;&t; */
r_switch
c_cond
(paren
id|pAC-&gt;GIni.GIChipId
)paren
(brace
r_case
id|CHIP_ID_GENESIS
suffix:colon
id|pAC-&gt;Pnmi.Chipset
op_assign
id|SK_PNMI_CHIPSET_XMAC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CHIP_ID_YUKON
suffix:colon
id|pAC-&gt;Pnmi.Chipset
op_assign
id|SK_PNMI_CHIPSET_YUKON
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get PMD and DeviceType&n;&t;&t; */
id|SK_IN8
c_func
(paren
id|IoC
comma
id|B2_PMD_TYP
comma
op_amp
id|Val8
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|Val8
)paren
(brace
r_case
l_char|&squot;S&squot;
suffix:colon
id|pAC-&gt;Pnmi.PMD
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacsFound
OG
l_int|1
)paren
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020002
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020001
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;L&squot;
suffix:colon
id|pAC-&gt;Pnmi.PMD
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacsFound
OG
l_int|1
)paren
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020004
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020003
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
id|pAC-&gt;Pnmi.PMD
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacsFound
OG
l_int|1
)paren
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020006
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020005
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;T&squot;
suffix:colon
id|pAC-&gt;Pnmi.PMD
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacsFound
OG
l_int|1
)paren
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020008
suffix:semicolon
)brace
r_else
(brace
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0x00020007
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|pAC-&gt;Pnmi.PMD
op_assign
l_int|1
suffix:semicolon
id|pAC-&gt;Pnmi.DeviceType
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get connector&n;&t;&t; */
id|SK_IN8
c_func
(paren
id|IoC
comma
id|B2_CONN_TYP
comma
op_amp
id|Val8
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|Val8
)paren
(brace
r_case
l_char|&squot;C&squot;
suffix:colon
id|pAC-&gt;Pnmi.Connector
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
id|pAC-&gt;Pnmi.Connector
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;F&squot;
suffix:colon
id|pAC-&gt;Pnmi.Connector
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;J&squot;
suffix:colon
id|pAC-&gt;Pnmi.Connector
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;V&squot;
suffix:colon
id|pAC-&gt;Pnmi.Connector
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|pAC-&gt;Pnmi.Connector
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_INIT_RUN
suffix:colon
multiline_comment|/*&n;&t;&t; * Start timer for RLMT change counter&n;&t;&t; */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
id|SkTimerStart
c_func
(paren
id|pAC
comma
id|IoC
comma
op_amp
id|pAC-&gt;Pnmi.RlmtChangeEstimate.EstTimer
comma
l_int|28125000
comma
id|SKGE_PNMI
comma
id|SK_PNMI_EVT_CHG_EST_TIMER
comma
id|EventParam
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* Nothing todo */
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiGetVar - Retrieves the value of a single OID&n; *&n; * Description:&n; *&t;Calls a general sub-function for all this stuff. If the instance&n; *&t;-1 is passed, the values of all instances are returned in an&n; *&t;array of values.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to take&n; *&t;                         the data.&n; *&t;SK_PNMI_ERR_UNKNOWN_OID  The requested OID is unknown&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|SkPnmiGetVar
r_int
id|SkPnmiGetVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which the management data will be copied */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiGetVar: Called, Id=0x%x, BufLen=%d, Instance=%d, NetIndex=%d&bslash;n&quot;
comma
id|Id
comma
op_star
id|pLen
comma
id|Instance
comma
id|NetIndex
)paren
)paren
suffix:semicolon
r_return
(paren
id|PnmiVar
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_GET
comma
id|Id
comma
(paren
r_char
op_star
)paren
id|pBuf
comma
id|pLen
comma
id|Instance
comma
id|NetIndex
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiPreSetVar - Presets the value of a single OID&n; *&n; * Description:&n; *&t;Calls a general sub-function for all this stuff. The preset does&n; *&t;the same as a set, but returns just before finally setting the&n; *&t;new value. This is usefull to check if a set might be successfull.&n; *&t;If the instance -1 is passed, an array of values is supposed and&n; *&t;all instances of the OID will be set.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_OID  The requested OID is unknown.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|SkPnmiPreSetVar
r_int
id|SkPnmiPreSetVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which the management data will be copied */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Total length of management data */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be set or -1 */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiPreSetVar: Called, Id=0x%x, BufLen=%d, Instance=%d, NetIndex=%d&bslash;n&quot;
comma
id|Id
comma
op_star
id|pLen
comma
id|Instance
comma
id|NetIndex
)paren
)paren
suffix:semicolon
r_return
(paren
id|PnmiVar
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_PRESET
comma
id|Id
comma
(paren
r_char
op_star
)paren
id|pBuf
comma
id|pLen
comma
id|Instance
comma
id|NetIndex
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiSetVar - Sets the value of a single OID&n; *&n; * Description:&n; *&t;Calls a general sub-function for all this stuff. The preset does&n; *&t;the same as a set, but returns just before finally setting the&n; *&t;new value. This is usefull to check if a set might be successfull.&n; *&t;If the instance -1 is passed, an array of values is supposed and&n; *&t;all instances of the OID will be set.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_OID  The requested OID is unknown.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|SkPnmiSetVar
r_int
id|SkPnmiSetVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which the management data will be copied */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Total length of management data */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be set or -1 */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiSetVar: Called, Id=0x%x, BufLen=%d, Instance=%d, NetIndex=%d&bslash;n&quot;
comma
id|Id
comma
op_star
id|pLen
comma
id|Instance
comma
id|NetIndex
)paren
)paren
suffix:semicolon
r_return
(paren
id|PnmiVar
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_SET
comma
id|Id
comma
(paren
r_char
op_star
)paren
id|pBuf
comma
id|pLen
comma
id|Instance
comma
id|NetIndex
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiGetStruct - Retrieves the management database in SK_PNMI_STRUCT_DATA&n; *&n; * Description:&n; *&t;Runs through the IdTable, queries the single OIDs and stores the&n; *&t;returned data into the management database structure&n; *&t;SK_PNMI_STRUCT_DATA. The offset of the OID in the structure&n; *&t;is stored in the IdTable. The return value of the function will also&n; *&t;be stored in SK_PNMI_STRUCT_DATA if the passed buffer has the&n; *&t;minimum size of SK_PNMI_MIN_STRUCT_SIZE.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to take&n; *&t;                         the data.&n; *&t;SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn&squot;t exist&n; */
DECL|function|SkPnmiGetStruct
r_int
id|SkPnmiGetStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which the management data will be copied. */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Length of buffer */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
id|Ret
suffix:semicolon
r_int
r_int
id|TableIndex
suffix:semicolon
r_int
r_int
id|DstOffset
suffix:semicolon
r_int
r_int
id|InstanceNo
suffix:semicolon
r_int
r_int
id|InstanceCnt
suffix:semicolon
id|SK_U32
id|Instance
suffix:semicolon
r_int
r_int
id|TmpLen
suffix:semicolon
r_char
id|KeyArr
(braket
id|SK_PNMI_VPD_ENTRIES
)braket
(braket
id|SK_PNMI_VPD_KEY_SIZE
)braket
suffix:semicolon
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiGetStruct: Called, BufLen=%d, NetIndex=%d&bslash;n&quot;
comma
op_star
id|pLen
comma
id|NetIndex
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|SK_PNMI_STRUCT_SIZE
)paren
(brace
r_if
c_cond
(paren
op_star
id|pLen
op_ge
id|SK_PNMI_MIN_STRUCT_SIZE
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|SK_PNMI_ERR_TOO_SHORT
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|SK_PNMI_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Check NetIndex&n;     */
r_if
c_cond
(paren
id|NetIndex
op_ge
id|pAC-&gt;Rlmt.NumNets
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_NET
)paren
suffix:semicolon
)brace
multiline_comment|/* Update statistic */
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiGetStruct: On call&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|RlmtUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
id|NetIndex
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|SirqUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Increment semaphores to indicate that an update was&n;&t; * already done&n;&t; */
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_increment
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/* Get vpd keys for instance calculation */
id|Ret
op_assign
id|GetVpdKeyArr
c_func
(paren
id|pAC
comma
id|IoC
comma
op_amp
id|KeyArr
(braket
l_int|0
)braket
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|KeyArr
)paren
comma
op_amp
id|TmpLen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiGetStruct: On return&quot;
)paren
suffix:semicolon
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/* Retrieve values */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
id|pBuf
comma
l_int|0
comma
id|SK_PNMI_STRUCT_SIZE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TableIndex
op_assign
l_int|0
suffix:semicolon
id|TableIndex
OL
id|ID_TABLE_SIZE
suffix:semicolon
id|TableIndex
op_increment
)paren
(brace
id|InstanceNo
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|InstanceNo
suffix:semicolon
r_for
c_loop
(paren
id|InstanceCnt
op_assign
l_int|1
suffix:semicolon
id|InstanceCnt
op_le
id|InstanceNo
suffix:semicolon
id|InstanceCnt
op_increment
)paren
(brace
id|DstOffset
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Offset
op_plus
(paren
id|InstanceCnt
op_minus
l_int|1
)paren
op_star
id|IdTable
(braket
id|TableIndex
)braket
dot
id|StructSize
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * For the VPD the instance is not an index number&n;&t;&t;&t; * but the key itself. Determin with the instance&n;&t;&t;&t; * counter the VPD key to be used.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
op_eq
id|OID_SKGE_VPD_KEY
op_logical_or
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
op_eq
id|OID_SKGE_VPD_VALUE
op_logical_or
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
op_eq
id|OID_SKGE_VPD_ACCESS
op_logical_or
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
op_eq
id|OID_SKGE_VPD_ACTION
)paren
(brace
id|SK_STRNCPY
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|Instance
comma
id|KeyArr
(braket
id|InstanceCnt
op_minus
l_int|1
)braket
comma
l_int|4
)paren
suffix:semicolon
)brace
r_else
(brace
id|Instance
op_assign
(paren
id|SK_U32
)paren
id|InstanceCnt
suffix:semicolon
)brace
id|TmpLen
op_assign
op_star
id|pLen
op_minus
id|DstOffset
suffix:semicolon
id|Ret
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Func
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_GET
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
comma
(paren
r_char
op_star
)paren
id|pBuf
op_plus
id|DstOffset
comma
op_amp
id|TmpLen
comma
id|Instance
comma
id|TableIndex
comma
id|NetIndex
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * An unknown instance error means that we reached&n;&t;&t;&t; * the last instance of that variable. Proceed with&n;&t;&t;&t; * the next OID in the table and ignore the return&n;&t;&t;&t; * code.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Ret
op_eq
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiGetStruct: On return&quot;
)paren
suffix:semicolon
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
id|DstOffset
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
)brace
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_STRUCT_SIZE
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiGetStruct: On return&quot;
)paren
suffix:semicolon
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|SK_PNMI_ERR_OK
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiPreSetStruct - Presets the management database in SK_PNMI_STRUCT_DATA&n; *&n; * Description:&n; *&t;Calls a general sub-function for all this set stuff. The preset does&n; *&t;the same as a set, but returns just before finally setting the&n; *&t;new value. This is usefull to check if a set might be successfull.&n; *&t;The sub-function runs through the IdTable, checks which OIDs are able&n; *&t;to set, and calls the handler function of the OID to perform the&n; *&t;preset. The return value of the function will also be stored in&n; *&t;SK_PNMI_STRUCT_DATA if the passed buffer has the minimum size of&n; *&t;SK_PNMI_MIN_STRUCT_SIZE.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; */
DECL|function|SkPnmiPreSetStruct
r_int
id|SkPnmiPreSetStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer which contains the data to be set */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Length of buffer */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiPreSetStruct: Called, BufLen=%d, NetIndex=%d&bslash;n&quot;
comma
op_star
id|pLen
comma
id|NetIndex
)paren
)paren
suffix:semicolon
r_return
(paren
id|PnmiStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_PRESET
comma
(paren
r_char
op_star
)paren
id|pBuf
comma
id|pLen
comma
id|NetIndex
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiSetStruct - Sets the management database in SK_PNMI_STRUCT_DATA&n; *&n; * Description:&n; *&t;Calls a general sub-function for all this set stuff. The return value&n; *&t;of the function will also be stored in SK_PNMI_STRUCT_DATA if the&n; *&t;passed buffer has the minimum size of SK_PNMI_MIN_STRUCT_SIZE.&n; *&t;The sub-function runs through the IdTable, checks which OIDs are able&n; *&t;to set, and calls the handler function of the OID to perform the&n; *&t;set. The return value of the function will also be stored in&n; *&t;SK_PNMI_STRUCT_DATA if the passed buffer has the minimum size of&n; *&t;SK_PNMI_MIN_STRUCT_SIZE.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; */
DECL|function|SkPnmiSetStruct
r_int
id|SkPnmiSetStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer which contains the data to be set */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Length of buffer */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiSetStruct: Called, BufLen=%d, NetIndex=%d&bslash;n&quot;
comma
op_star
id|pLen
comma
id|NetIndex
)paren
)paren
suffix:semicolon
r_return
(paren
id|PnmiStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_SET
comma
(paren
r_char
op_star
)paren
id|pBuf
comma
id|pLen
comma
id|NetIndex
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SkPnmiEvent - Event handler&n; *&n; * Description:&n; *&t;Handles the following events:&n; *&t;SK_PNMI_EVT_SIRQ_OVERFLOW     When a hardware counter overflows an&n; *&t;                              interrupt will be generated which is&n; *&t;                              first handled by SIRQ which generates a&n; *&t;                              this event. The event increments the&n; *&t;                              upper 32 bit of the 64 bit counter.&n; *&t;SK_PNMI_EVT_SEN_XXX           The event is generated by the I2C module&n; *&t;                              when a sensor reports a warning or&n; *&t;                              error. The event will store a trap&n; *&t;                              message in the trap buffer.&n; *&t;SK_PNMI_EVT_CHG_EST_TIMER     The timer event was initiated by this&n; *&t;                              module and is used to calculate the&n; *&t;                              port switches per hour.&n; *&t;SK_PNMI_EVT_CLEAR_COUNTER     The event clears all counters and&n; *&t;                              timestamps.&n; *&t;SK_PNMI_EVT_XMAC_RESET        The event is generated by the driver&n; *&t;                              before a hard reset of the XMAC is&n; *&t;                              performed. All counters will be saved&n; *&t;                              and added to the hardware counter&n; *&t;                              values after reset to grant continuous&n; *&t;                              counter values.&n; *&t;SK_PNMI_EVT_RLMT_PORT_UP      Generated by RLMT to notify that a port&n; *&t;                              went logically up. A trap message will&n; *&t;                              be stored to the trap buffer.&n; *&t;SK_PNMI_EVT_RLMT_PORT_DOWN    Generated by RLMT to notify that a port&n; *&t;                              went logically down. A trap message will&n; *&t;                              be stored to the trap buffer.&n; *&t;SK_PNMI_EVT_RLMT_SEGMENTATION Generated by RLMT to notify that two&n; *&t;                              spanning tree root bridges were&n; *&t;                              detected. A trap message will be stored&n; *&t;                              to the trap buffer.&n; *&t;SK_PNMI_EVT_RLMT_ACTIVE_DOWN  Notifies PNMI that an active port went&n; *&t;                              down. PNMI will not further add the&n; *&t;                              statistic values to the virtual port.&n; *&t;SK_PNMI_EVT_RLMT_ACTIVE_UP    Notifies PNMI that a port went up and&n; *&t;                              is now an active port. PNMI will now&n; *&t;                              add the statistic data of this port to&n; *&t;                              the virtual port.&n; *&t;SK_PNMI_EVT_RLMT_SET_NETS     Notifies PNMI about the net mode. The first parameter&n; *&t;                              contains the number of nets. 1 means single net, 2 means&n; *&t;                              dual net. The second parameter is -1&n; *&n; * Returns:&n; *&t;Always 0&n; */
DECL|function|SkPnmiEvent
r_int
id|SkPnmiEvent
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
id|SK_U32
id|Event
comma
multiline_comment|/* Event-Id */
id|SK_EVPARA
id|Param
)paren
multiline_comment|/* Event dependent parameter */
(brace
r_int
r_int
id|PhysPortIndex
suffix:semicolon
r_int
r_int
id|MaxNetNumber
suffix:semicolon
r_int
id|CounterIndex
suffix:semicolon
r_int
id|Ret
suffix:semicolon
id|SK_U16
id|MacStatus
suffix:semicolon
id|SK_U64
id|OverflowStatus
suffix:semicolon
id|SK_U64
id|Mask
suffix:semicolon
r_int
id|MacType
suffix:semicolon
id|SK_U64
id|Value
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|SK_U16
id|Register
suffix:semicolon
id|SK_EVPARA
id|EventParam
suffix:semicolon
id|SK_U64
id|NewestValue
suffix:semicolon
id|SK_U64
id|OldestValue
suffix:semicolon
id|SK_U64
id|Delta
suffix:semicolon
id|SK_PNMI_ESTIMATE
op_star
id|pEst
suffix:semicolon
id|SK_U32
id|NetIndex
suffix:semicolon
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
id|SK_PNMI_VCT
op_star
id|pVctBackupData
suffix:semicolon
id|SK_U32
id|RetCode
suffix:semicolon
r_int
id|i
suffix:semicolon
id|SK_U32
id|CableLength
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|Event
op_ne
id|SK_PNMI_EVT_XMAC_RESET
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: SkPnmiEvent: Called, Event=0x%x, Param=0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Event
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On call&quot;
)paren
suffix:semicolon
id|MacType
op_assign
id|pAC-&gt;GIni.GIMacType
suffix:semicolon
r_switch
c_cond
(paren
id|Event
)paren
(brace
r_case
id|SK_PNMI_EVT_SIRQ_OVERFLOW
suffix:colon
id|PhysPortIndex
op_assign
(paren
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
suffix:semicolon
id|MacStatus
op_assign
(paren
id|SK_U16
)paren
id|Param.Para32
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|PhysPortIndex
op_ge
id|SK_MAX_MACS
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SIRQ_OVERFLOW parameter&quot;
l_string|&quot; wrong, PhysPortIndex=0x%x&bslash;n&quot;
comma
id|PhysPortIndex
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
id|OverflowStatus
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check which source caused an overflow interrupt.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|pAC-&gt;GIni.GIFunc
dot
id|pFnMacOverflow
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|MacStatus
comma
op_amp
id|OverflowStatus
)paren
op_ne
l_int|0
)paren
op_logical_or
(paren
id|OverflowStatus
op_eq
l_int|0
)paren
)paren
(brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On return&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check the overflow status register and increment&n;&t;&t; * the upper dword of corresponding counter.&n;&t;&t; */
r_for
c_loop
(paren
id|CounterIndex
op_assign
l_int|0
suffix:semicolon
id|CounterIndex
OL
r_sizeof
(paren
id|Mask
)paren
op_star
l_int|8
suffix:semicolon
id|CounterIndex
op_increment
)paren
(brace
id|Mask
op_assign
(paren
id|SK_U64
)paren
l_int|1
op_lshift
id|CounterIndex
suffix:semicolon
r_if
c_cond
(paren
(paren
id|OverflowStatus
op_amp
id|Mask
)paren
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|StatOvrflwBit
(braket
id|CounterIndex
)braket
(braket
id|MacType
)braket
)paren
(brace
r_case
id|SK_PNMI_HTX_UTILUNDER
suffix:colon
r_case
id|SK_PNMI_HTX_UTILOVER
suffix:colon
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
id|XM_IN16
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_TX_CMD
comma
op_amp
id|Register
)paren
suffix:semicolon
id|Register
op_or_assign
id|XM_TX_SAM_LINE
suffix:semicolon
id|XM_OUT16
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_TX_CMD
comma
id|Register
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX_UTILUNDER
suffix:colon
r_case
id|SK_PNMI_HRX_UTILOVER
suffix:colon
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
id|XM_IN16
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_RX_CMD
comma
op_amp
id|Register
)paren
suffix:semicolon
id|Register
op_or_assign
id|XM_RX_SAM_LINE
suffix:semicolon
id|XM_OUT16
c_func
(paren
id|IoC
comma
id|PhysPortIndex
comma
id|XM_RX_CMD
comma
id|Register
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_PNMI_HTX_OCTETHIGH
suffix:colon
r_case
id|SK_PNMI_HTX_OCTETLOW
suffix:colon
r_case
id|SK_PNMI_HTX_RESERVED
suffix:colon
r_case
id|SK_PNMI_HRX_OCTETHIGH
suffix:colon
r_case
id|SK_PNMI_HRX_OCTETLOW
suffix:colon
r_case
id|SK_PNMI_HRX_IRLENGTH
suffix:colon
r_case
id|SK_PNMI_HRX_RESERVED
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * the following counters aren&squot;t be handled (id &gt; 63)&n;&t;&t;&t; */
r_case
id|SK_PNMI_HTX_SYNC
suffix:colon
r_case
id|SK_PNMI_HTX_SYNC_OCTET
suffix:colon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX_LONGFRAMES
suffix:colon
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_GMAC
)paren
(brace
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
(braket
id|CounterIndex
)braket
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
(braket
id|CounterIndex
)braket
op_increment
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_SEN_WAR_LOW
suffix:colon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para64
op_ge
(paren
r_int
r_int
)paren
id|pAC-&gt;I2c.MaxSens
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SEN_WAR_LOW parameter wrong, SensorIndex=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate&n;&t;&t; * an event for user space applications with the&n;&t;&t; * SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueSensorTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_SEN_WAR_LOW
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_SEN_WAR_UPP
suffix:colon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para64
op_ge
(paren
r_int
r_int
)paren
id|pAC-&gt;I2c.MaxSens
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SEN_WAR_UPP parameter wrong, SensorIndex=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate&n;&t;&t; * an event for user space applications with the&n;&t;&t; * SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueSensorTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_SEN_WAR_UPP
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_SEN_ERR_LOW
suffix:colon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para64
op_ge
(paren
r_int
r_int
)paren
id|pAC-&gt;I2c.MaxSens
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SEN_ERR_LOW parameter wrong, SensorIndex=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate&n;&t;&t; * an event for user space applications with the&n;&t;&t; * SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueSensorTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_SEN_ERR_LOW
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_SEN_ERR_UPP
suffix:colon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para64
op_ge
(paren
r_int
r_int
)paren
id|pAC-&gt;I2c.MaxSens
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SEN_ERR_UPP parameter wrong, SensorIndex=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate&n;&t;&t; * an event for user space applications with the&n;&t;&t; * SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueSensorTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_SEN_ERR_UPP
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_CHG_EST_TIMER
suffix:colon
multiline_comment|/*&n;&t;&t; * Calculate port switch average on a per hour basis&n;&t;&t; *   Time interval for check       : 28125 ms&n;&t;&t; *   Number of values for average  : 8&n;&t;&t; *&n;&t;&t; * Be careful in changing these values, on change check&n;&t;&t; *   - typedef of SK_PNMI_ESTIMATE (Size of EstValue&n;&t;&t; *     array one less than value number)&n;&t;&t; *   - Timer initialization SkTimerStart() in SkPnmiInit&n;&t;&t; *   - Delta value below must be multiplicated with&n;&t;&t; *     power of 2&n;&t;&t; *&n;&t;&t; */
id|pEst
op_assign
op_amp
id|pAC-&gt;Pnmi.RlmtChangeEstimate
suffix:semicolon
id|CounterIndex
op_assign
id|pEst-&gt;EstValueIndex
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|CounterIndex
op_eq
l_int|7
)paren
(brace
id|CounterIndex
op_assign
l_int|0
suffix:semicolon
)brace
id|pEst-&gt;EstValueIndex
op_assign
id|CounterIndex
suffix:semicolon
id|NewestValue
op_assign
id|pAC-&gt;Pnmi.RlmtChangeCts
suffix:semicolon
id|OldestValue
op_assign
id|pEst-&gt;EstValue
(braket
id|CounterIndex
)braket
suffix:semicolon
id|pEst-&gt;EstValue
(braket
id|CounterIndex
)braket
op_assign
id|NewestValue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate average. Delta stores the number of&n;&t;&t; * port switches per 28125 * 8 = 225000 ms&n;&t;&t; */
r_if
c_cond
(paren
id|NewestValue
op_ge
id|OldestValue
)paren
(brace
id|Delta
op_assign
id|NewestValue
op_minus
id|OldestValue
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Overflow situation */
id|Delta
op_assign
(paren
id|SK_U64
)paren
(paren
l_int|0
op_minus
id|OldestValue
)paren
op_plus
id|NewestValue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Extrapolate delta to port switches per hour.&n;&t;&t; *     Estimate = Delta * (3600000 / 225000)&n;&t;&t; *              = Delta * 16&n;&t;&t; *              = Delta &lt;&lt; 4&n;&t;&t; */
id|pAC-&gt;Pnmi.RlmtChangeEstimate.Estimate
op_assign
id|Delta
op_lshift
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if threshold is exceeded. If the threshold is&n;&t;&t; * permanently exceeded every 28125 ms an event will be&n;&t;&t; * generated to remind the user of this condition.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|pAC-&gt;Pnmi.RlmtChangeThreshold
op_ne
l_int|0
)paren
op_logical_and
(paren
id|pAC-&gt;Pnmi.RlmtChangeEstimate.Estimate
op_ge
id|pAC-&gt;Pnmi.RlmtChangeThreshold
)paren
)paren
(brace
id|QueueSimpleTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_RLMT_CHANGE_THRES
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
)brace
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
id|SkTimerStart
c_func
(paren
id|pAC
comma
id|IoC
comma
op_amp
id|pAC-&gt;Pnmi.RlmtChangeEstimate.EstTimer
comma
l_int|28125000
comma
id|SKGE_PNMI
comma
id|SK_PNMI_EVT_CHG_EST_TIMER
comma
id|EventParam
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_CLEAR_COUNTER
suffix:colon
multiline_comment|/*&n;&t;&t; *  Param.Para32[0] contains the NetIndex (0 ..1).&n;&t;&t; *  Param.Para32[1] is reserved, contains -1.&n;&t;&t; */
id|NetIndex
op_assign
(paren
id|SK_U32
)paren
id|Param.Para32
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|NetIndex
op_ge
id|pAC-&gt;Rlmt.NumNets
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_CLEAR_COUNTER parameter wrong, NetIndex=%d&bslash;n&quot;
comma
id|NetIndex
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/*&n;&t;&t; * Set all counters and timestamps to zero.&n;&t;&t; * The according NetIndex is required as a&n;&t;&t; * parameter of the event.&n;&t;&t; */
id|ResetCounter
c_func
(paren
id|pAC
comma
id|IoC
comma
id|NetIndex
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_XMAC_RESET
suffix:colon
multiline_comment|/*&n;&t;&t; * To grant continuous counter values store the current&n;&t;&t; * XMAC statistic values to the entries 1..n of the&n;&t;&t; * CounterOffset array. XMAC Errata #2&n;&t;&t; */
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para64
op_ge
id|SK_MAX_MACS
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_XMAC_RESET parameter wrong, PhysPortIndex=%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|Param.Para64
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
id|PhysPortIndex
op_assign
(paren
r_int
r_int
)paren
id|Param.Para64
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update XMAC statistic to get fresh values&n;&t;&t; */
id|Ret
op_assign
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On return&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Increment semaphore to indicate that an update was&n;&t;&t; * already done&n;&t;&t; */
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|CounterIndex
op_assign
l_int|0
suffix:semicolon
id|CounterIndex
OL
id|SK_PNMI_MAX_IDX
suffix:semicolon
id|CounterIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|StatAddr
(braket
id|CounterIndex
)braket
(braket
id|MacType
)braket
dot
id|GetOffset
)paren
(brace
r_continue
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterOffset
(braket
id|CounterIndex
)braket
op_assign
id|GetPhysStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|CounterIndex
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
(braket
id|CounterIndex
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_RLMT_PORT_UP
suffix:colon
id|PhysPortIndex
op_assign
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|PhysPortIndex
op_ge
id|SK_MAX_MACS
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_PORT_UP parameter&quot;
l_string|&quot; wrong, PhysPortIndex=%d&bslash;n&quot;
comma
id|PhysPortIndex
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate an event for&n;&t;&t; * user space applications with the SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueRlmtPortTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_RLMT_PORT_UP
comma
id|PhysPortIndex
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
multiline_comment|/* Bugfix for XMAC errata (#10620)*/
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Add incremental difference to offset (#10620)*/
(paren
r_void
)paren
id|pAC-&gt;GIni.GIFunc
dot
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|XM_RXE_SHT_ERR
comma
op_amp
id|Val32
)paren
suffix:semicolon
id|Value
op_assign
(paren
(paren
(paren
id|SK_U64
)paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
(braket
id|SK_PNMI_HRX_SHORTS
)braket
op_lshift
l_int|32
)paren
op_or
(paren
id|SK_U64
)paren
id|Val32
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterOffset
(braket
id|SK_PNMI_HRX_SHORTS
)braket
op_add_assign
id|Value
op_minus
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|RxShortZeroMark
suffix:semicolon
)brace
multiline_comment|/* Tell VctStatus() that a link was up meanwhile. */
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_or_assign
id|SK_PNMI_VCT_LINK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_RLMT_PORT_DOWN
suffix:colon
id|PhysPortIndex
op_assign
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|PhysPortIndex
op_ge
id|SK_MAX_MACS
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_PORT_DOWN parameter&quot;
l_string|&quot; wrong, PhysPortIndex=%d&bslash;n&quot;
comma
id|PhysPortIndex
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate an event for&n;&t;&t; * user space applications with the SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueRlmtPortTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_RLMT_PORT_DOWN
comma
id|PhysPortIndex
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
multiline_comment|/* Bugfix #10620 - get zero level for incremental difference */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
(paren
r_void
)paren
id|pAC-&gt;GIni.GIFunc
dot
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|XM_RXE_SHT_ERR
comma
op_amp
id|Val32
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|RxShortZeroMark
op_assign
(paren
(paren
(paren
id|SK_U64
)paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
(braket
id|SK_PNMI_HRX_SHORTS
)braket
op_lshift
l_int|32
)paren
op_or
(paren
id|SK_U64
)paren
id|Val32
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_RLMT_ACTIVE_DOWN
suffix:colon
id|PhysPortIndex
op_assign
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
suffix:semicolon
id|NetIndex
op_assign
(paren
id|SK_U32
)paren
id|Param.Para32
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|PhysPortIndex
op_ge
id|SK_MAX_MACS
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_ACTIVE_DOWN parameter too high, PhysPort=%d&bslash;n&quot;
comma
id|PhysPortIndex
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NetIndex
op_ge
id|pAC-&gt;Rlmt.NumNets
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_ACTIVE_DOWN parameter too high, NetIndex=%d&bslash;n&quot;
comma
id|NetIndex
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/*&n;&t;&t; * For now, ignore event if NetIndex != 0.&n;&t;&t; */
r_if
c_cond
(paren
id|Param.Para32
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Nothing to do if port is already inactive&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Update statistic counters to calculate new offset for the virtual&n;&t;&t; * port and increment semaphore to indicate that an update was already&n;&t;&t; * done.&n;&t;&t; */
r_if
c_cond
(paren
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On return&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate new counter offset for virtual port to grant continous&n;&t;&t; * counting on port switches. The virtual port consists of all currently&n;&t;&t; * active ports. The port down event indicates that a port is removed&n;&t;&t; * from the virtual port. Therefore add the counter value of the removed&n;&t;&t; * port to the CounterOffset for the virtual port to grant the same&n;&t;&t; * counter value.&n;&t;&t; */
r_for
c_loop
(paren
id|CounterIndex
op_assign
l_int|0
suffix:semicolon
id|CounterIndex
OL
id|SK_PNMI_MAX_IDX
suffix:semicolon
id|CounterIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|StatAddr
(braket
id|CounterIndex
)braket
(braket
id|MacType
)braket
dot
id|GetOffset
)paren
(brace
r_continue
suffix:semicolon
)brace
id|Value
op_assign
id|GetPhysStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|CounterIndex
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.VirtualCounterOffset
(braket
id|CounterIndex
)braket
op_add_assign
id|Value
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set port to inactive&n;&t;&t; */
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
op_assign
id|SK_FALSE
suffix:semicolon
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_RLMT_ACTIVE_UP
suffix:colon
id|PhysPortIndex
op_assign
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
suffix:semicolon
id|NetIndex
op_assign
(paren
id|SK_U32
)paren
id|Param.Para32
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|PhysPortIndex
op_ge
id|SK_MAX_MACS
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_ACTIVE_UP parameter too high, PhysPort=%d&bslash;n&quot;
comma
id|PhysPortIndex
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NetIndex
op_ge
id|pAC-&gt;Rlmt.NumNets
)paren
(brace
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_CTRL
comma
(paren
l_string|&quot;PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_ACTIVE_UP parameter too high, NetIndex=%d&bslash;n&quot;
comma
id|NetIndex
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/*&n;&t;&t; * For now, ignore event if NetIndex != 0.&n;&t;&t; */
r_if
c_cond
(paren
id|Param.Para32
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Nothing to do if port is already active&n;&t;&t; */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Statistic maintenance&n;&t;&t; */
id|pAC-&gt;Pnmi.RlmtChangeCts
op_increment
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeTime
op_assign
id|SK_PNMI_HUNDREDS_SEC
c_func
(paren
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate an event for&n;&t;&t; * user space applications with the SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueRlmtNewMacTrap
c_func
(paren
id|pAC
comma
id|PhysPortIndex
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update statistic counters to calculate new offset for the virtual&n;&t;&t; * port and increment semaphore to indicate that an update was&n;&t;&t; * already done.&n;&t;&t; */
r_if
c_cond
(paren
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On return&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate new counter offset for virtual port to grant continous&n;&t;&t; * counting on port switches. A new port is added to the virtual port.&n;&t;&t; * Therefore substract the counter value of the new port from the&n;&t;&t; * CounterOffset for the virtual port to grant the same value.&n;&t;&t; */
r_for
c_loop
(paren
id|CounterIndex
op_assign
l_int|0
suffix:semicolon
id|CounterIndex
OL
id|SK_PNMI_MAX_IDX
suffix:semicolon
id|CounterIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|StatAddr
(braket
id|CounterIndex
)braket
(braket
id|MacType
)braket
dot
id|GetOffset
)paren
(brace
r_continue
suffix:semicolon
)brace
id|Value
op_assign
id|GetPhysStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|CounterIndex
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.VirtualCounterOffset
(braket
id|CounterIndex
)braket
op_sub_assign
id|Value
suffix:semicolon
)brace
multiline_comment|/* Set port to active */
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
op_assign
id|SK_TRUE
suffix:semicolon
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_RLMT_SEGMENTATION
suffix:colon
multiline_comment|/*&n;&t;&t; * Para.Para32[0] contains the NetIndex.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * Store a trap message in the trap buffer and generate an event for&n;&t;&t; * user space applications with the SK_DRIVER_SENDEVENT macro.&n;&t;&t; */
id|QueueSimpleTrap
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_RLMT_SEGMENTATION
)paren
suffix:semicolon
(paren
r_void
)paren
id|SK_DRIVER_SENDEVENT
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_RLMT_SET_NETS
suffix:colon
multiline_comment|/*&n;&t;&t; *  Param.Para32[0] contains the number of Nets.&n;&t;&t; *  Param.Para32[1] is reserved, contains -1.&n;&t;&t; */
multiline_comment|/*&n;    &t; * Check number of nets&n;&t;&t; */
id|MaxNetNumber
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
OL
l_int|1
)paren
op_logical_or
(paren
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
OG
id|MaxNetNumber
)paren
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_NET
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|Param.Para32
(braket
l_int|0
)braket
op_eq
l_int|1
)paren
(brace
multiline_comment|/* single net mode */
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_assign
id|SK_FALSE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* dual net mode */
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_assign
id|SK_TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_PNMI_EVT_VCT_RESET
suffix:colon
id|PhysPortIndex
op_assign
id|Param.Para32
(braket
l_int|0
)braket
suffix:semicolon
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
suffix:semicolon
id|pVctBackupData
op_assign
op_amp
id|pAC-&gt;Pnmi.VctBackup
(braket
id|PhysPortIndex
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_amp
id|SK_PNMI_VCT_PENDING
)paren
(brace
id|RetCode
op_assign
id|SkGmCableDiagStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|SK_FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RetCode
op_eq
l_int|2
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * VCT test is still running.&n;&t;&t;&t;&t; * Start VCT timer counter again.&n;&t;&t;&t;&t; */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|Param
comma
l_int|0
comma
r_sizeof
(paren
id|Param
)paren
)paren
suffix:semicolon
id|Param.Para32
(braket
l_int|0
)braket
op_assign
id|PhysPortIndex
suffix:semicolon
id|Param.Para32
(braket
l_int|1
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|SkTimerStart
c_func
(paren
id|pAC
comma
id|IoC
comma
op_amp
id|pAC-&gt;Pnmi.VctTimeout
(braket
id|PhysPortIndex
)braket
dot
id|VctTimer
comma
l_int|4000000
comma
id|SKGE_PNMI
comma
id|SK_PNMI_EVT_VCT_RESET
comma
id|Param
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_and_assign
op_complement
id|SK_PNMI_VCT_PENDING
suffix:semicolon
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_or_assign
(paren
id|SK_PNMI_VCT_NEW_VCT_DATA
op_or
id|SK_PNMI_VCT_TEST_DONE
)paren
suffix:semicolon
multiline_comment|/* Copy results for later use to PNMI struct. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pPrt-&gt;PMdiPairSts
(braket
id|i
)braket
op_eq
id|SK_PNMI_VCT_NORMAL_CABLE
)paren
(brace
r_if
c_cond
(paren
(paren
id|pPrt-&gt;PMdiPairLen
(braket
id|i
)braket
OG
l_int|35
)paren
op_logical_and
(paren
id|pPrt-&gt;PMdiPairLen
(braket
id|i
)braket
OL
l_int|0xff
)paren
)paren
(brace
id|pPrt-&gt;PMdiPairSts
(braket
id|i
)braket
op_assign
id|SK_PNMI_VCT_IMPEDANCE_MISMATCH
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|pPrt-&gt;PMdiPairLen
(braket
id|i
)braket
OG
l_int|35
)paren
op_logical_and
(paren
id|pPrt-&gt;PMdiPairLen
(braket
id|i
)braket
op_ne
l_int|0xff
)paren
)paren
(brace
id|CableLength
op_assign
l_int|1000
op_star
(paren
(paren
(paren
l_int|175
op_star
id|pPrt-&gt;PMdiPairLen
(braket
id|i
)braket
)paren
op_div
l_int|210
)paren
op_minus
l_int|28
)paren
suffix:semicolon
)brace
r_else
(brace
id|CableLength
op_assign
l_int|0
suffix:semicolon
)brace
id|pVctBackupData-&gt;PMdiPairLen
(braket
id|i
)braket
op_assign
id|CableLength
suffix:semicolon
id|pVctBackupData-&gt;PMdiPairSts
(braket
id|i
)braket
op_assign
id|pPrt-&gt;PMdiPairSts
(braket
id|i
)braket
suffix:semicolon
)brace
id|Param.Para32
(braket
l_int|0
)braket
op_assign
id|PhysPortIndex
suffix:semicolon
id|Param.Para32
(braket
l_int|1
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_DRV
comma
id|SK_DRV_PORT_RESET
comma
id|Param
)paren
suffix:semicolon
id|SkEventDispatcher
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;SkPnmiEvent: On return&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * Private functions&n; *&n; */
multiline_comment|/*****************************************************************************&n; *&n; * PnmiVar - Gets, presets, and sets single OIDs&n; *&n; * Description:&n; *&t;Looks up the requested OID, calls the corresponding handler&n; *&t;function, and passes the parameters with the get, preset, or&n; *&t;set command. The function is called by SkGePnmiGetVar,&n; *&t;SkGePnmiPreSetVar, or SkGePnmiSetVar.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_XXX. For details have a look at the description of the&n; *&t;calling functions.&n; *&t;SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn&squot;t exist&n; */
DECL|function|PnmiVar
id|PNMI_STATIC
r_int
id|PnmiVar
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Total length of pBuf management data  */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be set or -1 */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
r_int
id|TableIndex
suffix:semicolon
r_int
id|Ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|TableIndex
op_assign
id|LookupId
c_func
(paren
id|Id
)paren
)paren
op_eq
(paren
r_int
r_int
)paren
(paren
op_minus
l_int|1
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_OID
)paren
suffix:semicolon
)brace
multiline_comment|/* Check NetIndex */
r_if
c_cond
(paren
id|NetIndex
op_ge
id|pAC-&gt;Rlmt.NumNets
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_NET
)paren
suffix:semicolon
)brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;PnmiVar: On call&quot;
)paren
suffix:semicolon
id|Ret
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Func
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Action
comma
id|Id
comma
id|pBuf
comma
id|pLen
comma
id|Instance
comma
id|TableIndex
comma
id|NetIndex
)paren
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;PnmiVar: On return&quot;
)paren
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * PnmiStruct - Presets and Sets data in structure SK_PNMI_STRUCT_DATA&n; *&n; * Description:&n; *&t;The return value of the function will also be stored in&n; *&t;SK_PNMI_STRUCT_DATA if the passed buffer has the minimum size of&n; *&t;SK_PNMI_MIN_STRUCT_SIZE. The sub-function runs through the IdTable,&n; *&t;checks which OIDs are able to set, and calls the handler function of&n; *&t;the OID to perform the set. The return value of the function will&n; *&t;also be stored in SK_PNMI_STRUCT_DATA if the passed buffer has the&n; *&t;minimum size of SK_PNMI_MIN_STRUCT_SIZE. The function is called&n; *&t;by SkGePnmiPreSetStruct and SkGePnmiSetStruct.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_XXX. The codes are described in the calling functions.&n; *&t;SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn&squot;t exist&n; */
DECL|function|PnmiStruct
id|PNMI_STATIC
r_int
id|PnmiStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* PRESET/SET action to be performed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Length of pBuf management data buffer */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
id|Ret
suffix:semicolon
r_int
r_int
id|TableIndex
suffix:semicolon
r_int
r_int
id|DstOffset
suffix:semicolon
r_int
r_int
id|Len
suffix:semicolon
r_int
r_int
id|InstanceNo
suffix:semicolon
r_int
r_int
id|InstanceCnt
suffix:semicolon
id|SK_U32
id|Instance
suffix:semicolon
id|SK_U32
id|Id
suffix:semicolon
multiline_comment|/* Check if the passed buffer has the right size */
r_if
c_cond
(paren
op_star
id|pLen
OL
id|SK_PNMI_STRUCT_SIZE
)paren
(brace
multiline_comment|/* Check if we can return the error within the buffer */
r_if
c_cond
(paren
op_star
id|pLen
op_ge
id|SK_PNMI_MIN_STRUCT_SIZE
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|SK_PNMI_ERR_TOO_SHORT
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|SK_PNMI_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Check NetIndex */
r_if
c_cond
(paren
id|NetIndex
op_ge
id|pAC-&gt;Rlmt.NumNets
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_NET
)paren
suffix:semicolon
)brace
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;PnmiStruct: On call&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update the values of RLMT and SIRQ and increment semaphores to&n;&t; * indicate that an update was already done.&n;&t; */
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|RlmtUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
id|NetIndex
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|SirqUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|Ret
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_increment
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/* Preset/Set values */
r_for
c_loop
(paren
id|TableIndex
op_assign
l_int|0
suffix:semicolon
id|TableIndex
OL
id|ID_TABLE_SIZE
suffix:semicolon
id|TableIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Access
op_ne
id|SK_PNMI_RW
)paren
op_logical_and
(paren
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Access
op_ne
id|SK_PNMI_WO
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|InstanceNo
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|InstanceNo
suffix:semicolon
id|Id
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
suffix:semicolon
r_for
c_loop
(paren
id|InstanceCnt
op_assign
l_int|1
suffix:semicolon
id|InstanceCnt
op_le
id|InstanceNo
suffix:semicolon
id|InstanceCnt
op_increment
)paren
(brace
id|DstOffset
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Offset
op_plus
(paren
id|InstanceCnt
op_minus
l_int|1
)paren
op_star
id|IdTable
(braket
id|TableIndex
)braket
dot
id|StructSize
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Because VPD multiple instance variables are&n;&t;&t;&t; * not setable we do not need to evaluate VPD&n;&t;&t;&t; * instances. Have a look to VPD instance&n;&t;&t;&t; * calculation in SkPnmiGetStruct().&n;&t;&t;&t; */
id|Instance
op_assign
(paren
id|SK_U32
)paren
id|InstanceCnt
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Evaluate needed buffer length&n;&t;&t;&t; */
id|Len
op_assign
l_int|0
suffix:semicolon
id|Ret
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Func
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_PNMI_GET
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
comma
l_int|NULL
comma
op_amp
id|Len
comma
id|Instance
comma
id|TableIndex
comma
id|NetIndex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_eq
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_TOO_SHORT
)paren
(brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;PnmiStruct: On return&quot;
)paren
suffix:semicolon
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|SK_PNMI_ERR_GENERAL
comma
id|DstOffset
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Id
op_eq
id|OID_SKGE_VPD_ACTION
)paren
(brace
r_switch
c_cond
(paren
op_star
(paren
id|pBuf
op_plus
id|DstOffset
)paren
)paren
(brace
r_case
id|SK_PNMI_VPD_CREATE
suffix:colon
id|Len
op_assign
l_int|3
op_plus
op_star
(paren
id|pBuf
op_plus
id|DstOffset
op_plus
l_int|3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_VPD_DELETE
suffix:colon
id|Len
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|Len
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Call the OID handler function */
id|Ret
op_assign
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Func
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Action
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Id
comma
id|pBuf
op_plus
id|DstOffset
comma
op_amp
id|Len
comma
id|Instance
comma
id|TableIndex
comma
id|NetIndex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;PnmiStruct: On return&quot;
)paren
suffix:semicolon
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|SK_PNMI_ERR_BAD_VALUE
comma
id|DstOffset
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|SK_PNMI_MIN_STRUCT_SIZE
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
)brace
)brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
id|SK_PNMI_CHECKFLAGS
c_func
(paren
l_string|&quot;PnmiStruct: On return&quot;
)paren
suffix:semicolon
id|SK_PNMI_SET_STAT
c_func
(paren
id|pBuf
comma
id|SK_PNMI_ERR_OK
comma
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * LookupId - Lookup an OID in the IdTable&n; *&n; * Description:&n; *&t;Scans the IdTable to find the table entry of an OID.&n; *&n; * Returns:&n; *&t;The table index or -1 if not found.&n; */
DECL|function|LookupId
id|PNMI_STATIC
r_int
id|LookupId
c_func
(paren
id|SK_U32
id|Id
)paren
multiline_comment|/* Object identifier to be searched */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ID_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|IdTable
(braket
id|i
)braket
dot
id|Id
op_eq
id|Id
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * OidStruct - Handler of OID_SKGE_ALL_DATA&n; *&n; * Description:&n; *&t;This OID performs a Get/Preset/SetStruct call and returns all data&n; *&t;in a SK_PNMI_STRUCT_DATA structure.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|OidStruct
id|PNMI_STATIC
r_int
id|OidStruct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_if
c_cond
(paren
id|Id
op_ne
id|OID_SKGE_ALL_DATA
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR003
comma
id|SK_PNMI_ERR003MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check instance. We only handle single instance variables&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
op_logical_and
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|Action
)paren
(brace
r_case
id|SK_PNMI_GET
suffix:colon
r_return
(paren
id|SkPnmiGetStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
comma
id|NetIndex
)paren
)paren
suffix:semicolon
r_case
id|SK_PNMI_PRESET
suffix:colon
r_return
(paren
id|SkPnmiPreSetStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
comma
id|NetIndex
)paren
)paren
suffix:semicolon
r_case
id|SK_PNMI_SET
suffix:colon
r_return
(paren
id|SkPnmiSetStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
comma
id|NetIndex
)paren
)paren
suffix:semicolon
)brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR004
comma
id|SK_PNMI_ERR004MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * Perform - OID handler of OID_SKGE_ACTION&n; *&n; * Description:&n; *&t;None.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|Perform
id|PNMI_STATIC
r_int
id|Perform
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
id|Ret
suffix:semicolon
id|SK_U32
id|ActionOp
suffix:semicolon
multiline_comment|/*&n;&t; * Check instance. We only handle single instance variables&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
op_logical_and
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if a get should be performed */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
multiline_comment|/* A get is easy. We always return the same value */
id|ActionOp
op_assign
(paren
id|SK_U32
)paren
id|SK_PNMI_ACT_IDLE
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|ActionOp
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Continue with PRESET/SET action */
r_if
c_cond
(paren
op_star
id|pLen
OG
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if the command is a known one */
id|SK_PNMI_READ_U32
c_func
(paren
id|pBuf
comma
id|ActionOp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pLen
OG
r_sizeof
(paren
id|SK_U32
)paren
op_logical_or
(paren
id|ActionOp
op_ne
id|SK_PNMI_ACT_IDLE
op_logical_and
id|ActionOp
op_ne
id|SK_PNMI_ACT_RESET
op_logical_and
id|ActionOp
op_ne
id|SK_PNMI_ACT_SELFTEST
op_logical_and
id|ActionOp
op_ne
id|SK_PNMI_ACT_RESETCNT
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* A preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ActionOp
)paren
(brace
r_case
id|SK_PNMI_ACT_IDLE
suffix:colon
multiline_comment|/* Nothing to do */
r_break
suffix:semicolon
r_case
id|SK_PNMI_ACT_RESET
suffix:colon
multiline_comment|/*&n;&t;&t; * Perform a driver reset or something that comes near&n;&t;&t; * to this.&n;&t;&t; */
id|Ret
op_assign
id|SK_DRIVER_RESET
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR005
comma
id|SK_PNMI_ERR005MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_PNMI_ACT_SELFTEST
suffix:colon
multiline_comment|/*&n;&t;&t; * Perform a driver selftest or something similar to this.&n;&t;&t; * Currently this feature is not used and will probably&n;&t;&t; * implemented in another way.&n;&t;&t; */
id|Ret
op_assign
id|SK_DRIVER_SELFTEST
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.TestResult
op_assign
id|Ret
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_ACT_RESETCNT
suffix:colon
multiline_comment|/* Set all counters and timestamps to zero */
id|ResetCounter
c_func
(paren
id|pAC
comma
id|IoC
comma
id|NetIndex
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR006
comma
id|SK_PNMI_ERR006MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * Mac8023Stat - OID handler of OID_GEN_XXX and OID_802_3_XXX&n; *&n; * Description:&n; *&t;Retrieves the statistic values of the virtual port (logical&n; *&t;index 0). Only special OIDs of NDIS are handled which consist&n; *&t;of a 32 bit instead of a 64 bit value. The OIDs are public&n; *&t;because perhaps some other platform can use them too.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|Mac8023Stat
id|PNMI_STATIC
r_int
id|Mac8023Stat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
id|Ret
suffix:semicolon
id|SK_U64
id|StatVal
suffix:semicolon
id|SK_U32
id|StatVal32
suffix:semicolon
id|SK_BOOL
id|Is64BitReq
op_assign
id|SK_FALSE
suffix:semicolon
multiline_comment|/*&n;&t; * Only the active Mac is returned&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
op_logical_and
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check action type&n;&t; */
r_if
c_cond
(paren
id|Action
op_ne
id|SK_PNMI_GET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/* Check length */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_802_3_PERMANENT_ADDRESS
suffix:colon
r_case
id|OID_802_3_CURRENT_ADDRESS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_MAC_ADDR
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_MAC_ADDR
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
macro_line|#ifndef SK_NDIS_64BIT_CTR
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
macro_line|#else /* SK_NDIS_64BIT_CTR */
multiline_comment|/* for compatibility, at least 32bit are required for OID */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;* but indicate handling for 64bit values,&n;&t;&t;&t;* if insufficient space is provided&n;&t;&t;&t;*/
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|Is64BitReq
op_assign
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U64
)paren
)paren
ques
c_cond
id|SK_FALSE
suffix:colon
id|SK_TRUE
suffix:semicolon
macro_line|#endif /* SK_NDIS_64BIT_CTR */
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update all statistics, because we retrieve virtual MAC, which&n;&t; * consists of multiple physical statistics and increment semaphore&n;&t; * to indicate that an update was already done.&n;&t; */
id|Ret
op_assign
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Get value (MAC Index 0 identifies the virtual MAC)&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_802_3_PERMANENT_ADDRESS
suffix:colon
id|CopyMac
c_func
(paren
id|pBuf
comma
op_amp
id|pAC-&gt;Addr.Net
(braket
id|NetIndex
)braket
dot
id|PermanentMacAddress
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_MAC_ADDR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_802_3_CURRENT_ADDRESS
suffix:colon
id|CopyMac
c_func
(paren
id|pBuf
comma
op_amp
id|pAC-&gt;Addr.Net
(braket
id|NetIndex
)braket
dot
id|CurrentMacAddress
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_MAC_ADDR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|StatVal
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Param
comma
id|NetIndex
)paren
suffix:semicolon
multiline_comment|/* by default 32bit values are evaluated */
r_if
c_cond
(paren
op_logical_neg
id|Is64BitReq
)paren
(brace
id|StatVal32
op_assign
(paren
id|SK_U32
)paren
id|StatVal
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|StatVal32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
)brace
r_else
(brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|StatVal
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * MacPrivateStat - OID handler function of OID_SKGE_STAT_XXX&n; *&n; * Description:&n; *&t;Retrieves the MAC statistic data.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|MacPrivateStat
id|PNMI_STATIC
r_int
id|MacPrivateStat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
r_int
id|LogPortMax
suffix:semicolon
r_int
r_int
id|LogPortIndex
suffix:semicolon
r_int
r_int
id|PhysPortMax
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
id|MacType
suffix:semicolon
r_int
id|Ret
suffix:semicolon
id|SK_U64
id|StatVal
suffix:semicolon
multiline_comment|/* Calculate instance if wished. MAC index 0 is the virtual MAC */
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|LogPortMax
op_assign
id|SK_PNMI_PORT_PHYS2LOG
c_func
(paren
id|PhysPortMax
)paren
suffix:semicolon
id|MacType
op_assign
id|pAC-&gt;GIni.GIMacType
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
multiline_comment|/* Dual net mode */
id|LogPortMax
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* Only one specific instance is queried */
multiline_comment|/* Check instance range */
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
id|LogPortMax
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|LogPortIndex
op_assign
id|SK_PNMI_PORT_INST2LOG
c_func
(paren
id|Instance
)paren
suffix:semicolon
id|Limit
op_assign
id|LogPortIndex
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Instance == (SK_U32)(-1), get all Instances of that OID */
id|LogPortIndex
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|LogPortMax
suffix:semicolon
)brace
multiline_comment|/* Check action */
r_if
c_cond
(paren
id|Action
op_ne
id|SK_PNMI_GET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/* Check length */
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update MAC statistic and increment semaphore to indicate that&n;&t; * an update was already done.&n;&t; */
id|Ret
op_assign
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/* Get value */
id|Offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|LogPortIndex
OL
id|Limit
suffix:semicolon
id|LogPortIndex
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
multiline_comment|/* XXX not yet implemented due to XMAC problems&n;&t;&t;case OID_SKGE_STAT_TX_UTIL:&n;&t;&t;&t;return (SK_PNMI_ERR_GENERAL);&n;*/
multiline_comment|/* XXX not yet implemented due to XMAC problems&n;&t;&t;case OID_SKGE_STAT_RX_UTIL:&n;&t;&t;&t;return (SK_PNMI_ERR_GENERAL);&n;*/
r_case
id|OID_SKGE_STAT_RX
suffix:colon
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_GMAC
)paren
(brace
id|StatVal
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|SK_PNMI_HRX_BROADCAST
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|SK_PNMI_HRX_MULTICAST
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|SK_PNMI_HRX_UNICAST
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|SK_PNMI_HRX_UNDERSIZE
comma
id|NetIndex
)paren
suffix:semicolon
)brace
r_else
(brace
id|StatVal
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Param
comma
id|NetIndex
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_STAT_TX
suffix:colon
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_GMAC
)paren
(brace
id|StatVal
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|SK_PNMI_HTX_BROADCAST
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|SK_PNMI_HTX_MULTICAST
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|SK_PNMI_HTX_UNICAST
comma
id|NetIndex
)paren
suffix:semicolon
)brace
r_else
(brace
id|StatVal
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Param
comma
id|NetIndex
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|StatVal
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|LogPortIndex
comma
id|IdTable
(braket
id|TableIndex
)braket
dot
id|Param
comma
id|NetIndex
)paren
suffix:semicolon
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|StatVal
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * Addr - OID handler function of OID_SKGE_PHYS_CUR_ADDR and _FAC_ADDR&n; *&n; * Description:&n; *&t;Get/Presets/Sets the current and factory MAC address. The MAC&n; *&t;address of the virtual port, which is reported to the OS, may&n; *&t;not be changed, but the physical ones. A set to the virtual port&n; *&t;will be ignored. No error should be reported because otherwise&n; *&t;a multiple instance set (-1) would always fail.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|Addr
id|PNMI_STATIC
r_int
id|Addr
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
id|Ret
suffix:semicolon
r_int
r_int
id|LogPortMax
suffix:semicolon
r_int
r_int
id|PhysPortMax
suffix:semicolon
r_int
r_int
id|LogPortIndex
suffix:semicolon
r_int
r_int
id|PhysPortIndex
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate instance if wished. MAC index 0 is the virtual&n;&t; * MAC.&n;&t; */
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|LogPortMax
op_assign
id|SK_PNMI_PORT_PHYS2LOG
c_func
(paren
id|PhysPortMax
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
multiline_comment|/* Dual net mode */
id|LogPortMax
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* Only one specific instance is queried */
multiline_comment|/* Check instance range */
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
id|LogPortMax
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|LogPortIndex
op_assign
id|SK_PNMI_PORT_INST2LOG
c_func
(paren
id|Instance
)paren
suffix:semicolon
id|Limit
op_assign
id|LogPortIndex
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Instance == (SK_U32)(-1), get all Instances of that OID */
id|LogPortIndex
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|LogPortMax
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Perform Action&n;&t; */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
multiline_comment|/* Check length */
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
l_int|6
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
l_int|6
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get value&n;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|LogPortIndex
OL
id|Limit
suffix:semicolon
id|LogPortIndex
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_PHYS_CUR_ADDR
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
id|CopyMac
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
op_amp
id|pAC-&gt;Addr.Net
(braket
id|NetIndex
)braket
dot
id|CurrentMacAddress
)paren
suffix:semicolon
)brace
r_else
(brace
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|CopyMac
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
op_amp
id|pAC-&gt;Addr.Port
(braket
id|PhysPortIndex
)braket
dot
id|CurrentMacAddress
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHYS_FAC_ADDR
suffix:colon
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
id|CopyMac
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
op_amp
id|pAC-&gt;Addr.Net
(braket
id|NetIndex
)braket
dot
id|PermanentMacAddress
)paren
suffix:semicolon
)brace
r_else
(brace
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|CopyMac
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
op_amp
id|pAC-&gt;Addr.Port
(braket
id|PhysPortIndex
)braket
dot
id|PermanentMacAddress
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR008
comma
id|SK_PNMI_ERR008MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The logical MAC address may not be changed only&n;&t;&t; * the physical ones&n;&t;&t; */
r_if
c_cond
(paren
id|Id
op_eq
id|OID_SKGE_PHYS_FAC_ADDR
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Only the current address may be changed&n;&t;&t; */
r_if
c_cond
(paren
id|Id
op_ne
id|OID_SKGE_PHYS_CUR_ADDR
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR009
comma
id|SK_PNMI_ERR009MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/* Check length */
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
l_int|6
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
l_int|6
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OG
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
l_int|6
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check Action&n;&t;&t; */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set OID_SKGE_MAC_CUR_ADDR&n;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|LogPortIndex
OL
id|Limit
suffix:semicolon
id|LogPortIndex
op_increment
comma
id|Offset
op_add_assign
l_int|6
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * A set to virtual port and set of broadcast&n;&t;&t;&t; * address will be ignored&n;&t;&t;&t; */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
op_logical_or
id|SK_MEMCMP
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
l_string|&quot;&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&bslash;xff&quot;
comma
l_int|6
)paren
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|Ret
op_assign
id|SkAddrOverride
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
(paren
id|SK_MAC_ADDR
op_star
)paren
(paren
id|pBuf
op_plus
id|Offset
)paren
comma
(paren
id|LogPortIndex
op_eq
l_int|0
ques
c_cond
id|SK_ADDR_VIRTUAL_ADDRESS
suffix:colon
id|SK_ADDR_PHYSICAL_ADDRESS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_ADDR_OVERRIDE_SUCCESS
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * CsumStat - OID handler function of OID_SKGE_CHKSM_XXX&n; *&n; * Description:&n; *&t;Retrieves the statistic values of the CSUM module. The CSUM data&n; *&t;structure must be available in the SK_AC even if the CSUM module&n; *&t;is not included, because PNMI reads the statistic data from the&n; *&t;CSUM part of SK_AC directly.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|CsumStat
id|PNMI_STATIC
r_int
id|CsumStat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
r_int
id|Index
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
op_assign
l_int|0
suffix:semicolon
id|SK_U64
id|StatVal
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate instance if wished&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
id|SKCS_NUM_PROTOCOLS
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|Index
op_assign
(paren
r_int
r_int
)paren
id|Instance
op_minus
l_int|1
suffix:semicolon
id|Limit
op_assign
id|Index
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|Index
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|SKCS_NUM_PROTOCOLS
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check action&n;&t; */
r_if
c_cond
(paren
id|Action
op_ne
id|SK_PNMI_GET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/* Check length */
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|Index
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|Index
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get value&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|Index
OL
id|Limit
suffix:semicolon
id|Index
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_CHKSM_RX_OK_CTS
suffix:colon
id|StatVal
op_assign
id|pAC-&gt;Csum.ProtoStats
(braket
id|NetIndex
)braket
(braket
id|Index
)braket
dot
id|RxOkCts
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHKSM_RX_UNABLE_CTS
suffix:colon
id|StatVal
op_assign
id|pAC-&gt;Csum.ProtoStats
(braket
id|NetIndex
)braket
(braket
id|Index
)braket
dot
id|RxUnableCts
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHKSM_RX_ERR_CTS
suffix:colon
id|StatVal
op_assign
id|pAC-&gt;Csum.ProtoStats
(braket
id|NetIndex
)braket
(braket
id|Index
)braket
dot
id|RxErrCts
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHKSM_TX_OK_CTS
suffix:colon
id|StatVal
op_assign
id|pAC-&gt;Csum.ProtoStats
(braket
id|NetIndex
)braket
(braket
id|Index
)braket
dot
id|TxOkCts
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHKSM_TX_UNABLE_CTS
suffix:colon
id|StatVal
op_assign
id|pAC-&gt;Csum.ProtoStats
(braket
id|NetIndex
)braket
(braket
id|Index
)braket
dot
id|TxUnableCts
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR010
comma
id|SK_PNMI_ERR010MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|StatVal
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Store used buffer space&n;&t; */
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SensorStat - OID handler function of OID_SKGE_SENSOR_XXX&n; *&n; * Description:&n; *&t;Retrieves the statistic values of the I2C module, which handles&n; *&t;the temperature and voltage sensors.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|SensorStat
id|PNMI_STATIC
r_int
id|SensorStat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|Index
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
r_int
id|Len
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|SK_U64
id|Val64
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate instance if wished&n;&t; */
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
(paren
id|SK_U32
)paren
id|pAC-&gt;I2c.MaxSens
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|Index
op_assign
(paren
r_int
r_int
)paren
id|Instance
op_minus
l_int|1
suffix:semicolon
id|Limit
op_assign
(paren
r_int
r_int
)paren
id|Instance
suffix:semicolon
)brace
r_else
(brace
id|Index
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
(paren
r_int
r_int
)paren
id|pAC-&gt;I2c.MaxSens
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check action&n;&t; */
r_if
c_cond
(paren
id|Action
op_ne
id|SK_PNMI_GET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/* Check length */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_SENSOR_VALUE
suffix:colon
r_case
id|OID_SKGE_SENSOR_WAR_THRES_LOW
suffix:colon
r_case
id|OID_SKGE_SENSOR_WAR_THRES_UPP
suffix:colon
r_case
id|OID_SKGE_SENSOR_ERR_THRES_LOW
suffix:colon
r_case
id|OID_SKGE_SENSOR_ERR_THRES_UPP
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|Index
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|Index
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_DESCR
suffix:colon
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
comma
id|i
op_assign
id|Index
suffix:semicolon
id|i
OL
id|Limit
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Len
op_assign
(paren
r_int
r_int
)paren
id|SK_STRLEN
c_func
(paren
id|pAC-&gt;I2c.SenTable
(braket
id|i
)braket
dot
id|SenDesc
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|Len
op_ge
id|SK_PNMI_STRINGLEN2
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR011
comma
id|SK_PNMI_ERR011MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
id|Len
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Offset
)paren
(brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_INDEX
suffix:colon
r_case
id|OID_SKGE_SENSOR_TYPE
suffix:colon
r_case
id|OID_SKGE_SENSOR_STATUS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Limit
op_minus
id|Index
)paren
(brace
op_star
id|pLen
op_assign
id|Limit
op_minus
id|Index
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_WAR_CTS
suffix:colon
r_case
id|OID_SKGE_SENSOR_WAR_TIME
suffix:colon
r_case
id|OID_SKGE_SENSOR_ERR_CTS
suffix:colon
r_case
id|OID_SKGE_SENSOR_ERR_TIME
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|Index
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|Index
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR012
comma
id|SK_PNMI_ERR012MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get value&n;&t; */
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|Limit
suffix:semicolon
id|Index
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_SENSOR_INDEX
suffix:colon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
(paren
r_char
)paren
id|Index
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_DESCR
suffix:colon
id|Len
op_assign
id|SK_STRLEN
c_func
(paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenDesc
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|1
comma
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenDesc
comma
id|Len
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
(paren
r_char
)paren
id|Len
suffix:semicolon
id|Offset
op_add_assign
id|Len
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_TYPE
suffix:colon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
(paren
r_char
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenType
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_VALUE
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenValue
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_WAR_THRES_LOW
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenThreWarnLow
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_WAR_THRES_UPP
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenThreWarnHigh
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_ERR_THRES_LOW
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenThreErrLow
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_ERR_THRES_UPP
suffix:colon
id|Val32
op_assign
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenThreErrHigh
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_STATUS
suffix:colon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
(paren
r_char
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenErrFlag
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_WAR_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenWarnCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_ERR_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenErrCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_WAR_TIME
suffix:colon
id|Val64
op_assign
id|SK_PNMI_HUNDREDS_SEC
c_func
(paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenBegWarnTS
)paren
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_ERR_TIME
suffix:colon
id|Val64
op_assign
id|SK_PNMI_HUNDREDS_SEC
c_func
(paren
id|pAC-&gt;I2c.SenTable
(braket
id|Index
)braket
dot
id|SenBegErrTS
)paren
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_ERR
comma
(paren
l_string|&quot;SensorStat: Unknown OID should be handled before&quot;
)paren
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Store used buffer space&n;&t; */
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * Vpd - OID handler function of OID_SKGE_VPD_XXX&n; *&n; * Description:&n; *&t;Get/preset/set of VPD data. As instance the name of a VPD key&n; *&t;can be passed. The Instance parameter is a SK_U32 and can be&n; *&t;used as a string buffer for the VPD key, because their maximum&n; *&t;length is 4 byte.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|Vpd
id|PNMI_STATIC
r_int
id|Vpd
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
id|SK_VPD_STATUS
op_star
id|pVpdStatus
suffix:semicolon
r_int
r_int
id|BufLen
suffix:semicolon
r_char
id|Buf
(braket
l_int|256
)braket
suffix:semicolon
r_char
id|KeyArr
(braket
id|SK_PNMI_VPD_ENTRIES
)braket
(braket
id|SK_PNMI_VPD_KEY_SIZE
)braket
suffix:semicolon
r_char
id|KeyStr
(braket
id|SK_PNMI_VPD_KEY_SIZE
)braket
suffix:semicolon
r_int
r_int
id|KeyNo
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
r_int
id|Index
suffix:semicolon
r_int
r_int
id|FirstIndex
suffix:semicolon
r_int
r_int
id|LastIndex
suffix:semicolon
r_int
r_int
id|Len
suffix:semicolon
r_int
id|Ret
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
multiline_comment|/*&n;&t; * Get array of all currently stored VPD keys&n;&t; */
id|Ret
op_assign
id|GetVpdKeyArr
c_func
(paren
id|pAC
comma
id|IoC
comma
op_amp
id|KeyArr
(braket
l_int|0
)braket
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|KeyArr
)paren
comma
op_amp
id|KeyNo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If instance is not -1, try to find the requested VPD key for&n;&t; * the multiple instance variables. The other OIDs as for example&n;&t; * OID VPD_ACTION are single instance variables and must be&n;&t; * handled separatly.&n;&t; */
id|FirstIndex
op_assign
l_int|0
suffix:semicolon
id|LastIndex
op_assign
id|KeyNo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|Id
op_eq
id|OID_SKGE_VPD_KEY
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_VALUE
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_ACCESS
)paren
(brace
id|SK_STRNCPY
c_func
(paren
id|KeyStr
comma
(paren
r_char
op_star
)paren
op_amp
id|Instance
comma
l_int|4
)paren
suffix:semicolon
id|KeyStr
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|Index
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|KeyNo
suffix:semicolon
id|Index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|SK_STRCMP
c_func
(paren
id|KeyStr
comma
id|KeyArr
(braket
id|Index
)braket
)paren
op_eq
l_int|0
)paren
(brace
id|FirstIndex
op_assign
id|Index
suffix:semicolon
id|LastIndex
op_assign
id|Index
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|Index
op_eq
id|KeyNo
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Get value, if a query should be performed&n;&t; */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_VPD_FREE_BYTES
suffix:colon
multiline_comment|/* Check length of buffer */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Get number of free bytes */
id|pVpdStatus
op_assign
id|VpdStat
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pVpdStatus
op_eq
l_int|NULL
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR017
comma
id|SK_PNMI_ERR017MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pVpdStatus-&gt;vpd_status
op_amp
id|VPD_VALID
)paren
op_eq
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR018
comma
id|SK_PNMI_ERR018MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pVpdStatus-&gt;vpd_free_rw
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VPD_ENTRIES_LIST
suffix:colon
multiline_comment|/* Check length */
r_for
c_loop
(paren
id|Len
op_assign
l_int|0
comma
id|Index
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|KeyNo
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|Len
op_add_assign
id|SK_STRLEN
c_func
(paren
id|KeyArr
(braket
id|Index
)braket
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Get value */
op_star
(paren
id|pBuf
)paren
op_assign
(paren
r_char
)paren
id|Len
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|Offset
op_assign
l_int|1
comma
id|Index
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|KeyNo
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|Len
op_assign
id|SK_STRLEN
c_func
(paren
id|KeyArr
(braket
id|Index
)braket
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|KeyArr
(braket
id|Index
)braket
comma
id|Len
)paren
suffix:semicolon
id|Offset
op_add_assign
id|Len
suffix:semicolon
r_if
c_cond
(paren
id|Index
OL
id|KeyNo
op_minus
l_int|1
)paren
(brace
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|Offset
op_increment
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VPD_ENTRIES_NUMBER
suffix:colon
multiline_comment|/* Check length */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|KeyNo
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VPD_KEY
suffix:colon
multiline_comment|/* Check buffer length, if it is large enough */
r_for
c_loop
(paren
id|Len
op_assign
l_int|0
comma
id|Index
op_assign
id|FirstIndex
suffix:semicolon
id|Index
OL
id|LastIndex
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|Len
op_add_assign
id|SK_STRLEN
c_func
(paren
id|KeyArr
(braket
id|Index
)braket
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Get the key to an intermediate buffer, because&n;&t;&t;&t; * we have to prepend a length byte.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
comma
id|Index
op_assign
id|FirstIndex
suffix:semicolon
id|Index
OL
id|LastIndex
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|Len
op_assign
id|SK_STRLEN
c_func
(paren
id|KeyArr
(braket
id|Index
)braket
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
(paren
r_char
)paren
id|Len
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|1
comma
id|KeyArr
(braket
id|Index
)braket
comma
id|Len
)paren
suffix:semicolon
id|Offset
op_add_assign
id|Len
op_plus
l_int|1
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VPD_VALUE
suffix:colon
multiline_comment|/* Check the buffer length if it is large enough */
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
comma
id|Index
op_assign
id|FirstIndex
suffix:semicolon
id|Index
OL
id|LastIndex
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|BufLen
op_assign
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|VpdRead
c_func
(paren
id|pAC
comma
id|IoC
comma
id|KeyArr
(braket
id|Index
)braket
comma
id|Buf
comma
(paren
r_int
op_star
)paren
op_amp
id|BufLen
)paren
OG
l_int|0
op_logical_or
id|BufLen
op_ge
id|SK_PNMI_VPD_DATALEN
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR021
comma
id|SK_PNMI_ERR021MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
id|BufLen
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Offset
)paren
(brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Get the value to an intermediate buffer, because&n;&t;&t;&t; * we have to prepend a length byte.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
comma
id|Index
op_assign
id|FirstIndex
suffix:semicolon
id|Index
OL
id|LastIndex
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|BufLen
op_assign
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|VpdRead
c_func
(paren
id|pAC
comma
id|IoC
comma
id|KeyArr
(braket
id|Index
)braket
comma
id|Buf
comma
(paren
r_int
op_star
)paren
op_amp
id|BufLen
)paren
OG
l_int|0
op_logical_or
id|BufLen
op_ge
id|SK_PNMI_VPD_DATALEN
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR022
comma
id|SK_PNMI_ERR022MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
(paren
r_char
)paren
id|BufLen
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|1
comma
id|Buf
comma
id|BufLen
)paren
suffix:semicolon
id|Offset
op_add_assign
id|BufLen
op_plus
l_int|1
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VPD_ACCESS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|LastIndex
op_minus
id|FirstIndex
)paren
(brace
op_star
id|pLen
op_assign
id|LastIndex
op_minus
id|FirstIndex
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
comma
id|Index
op_assign
id|FirstIndex
suffix:semicolon
id|Index
OL
id|LastIndex
suffix:semicolon
id|Index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|VpdMayWrite
c_func
(paren
id|KeyArr
(braket
id|Index
)braket
)paren
)paren
(brace
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|SK_PNMI_VPD_RW
suffix:semicolon
)brace
r_else
(brace
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|SK_PNMI_VPD_RO
suffix:semicolon
)brace
id|Offset
op_increment
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VPD_ACTION
suffix:colon
id|Offset
op_assign
id|LastIndex
op_minus
id|FirstIndex
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Offset
)paren
(brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|SK_MEMSET
c_func
(paren
id|pBuf
comma
l_int|0
comma
id|Offset
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR023
comma
id|SK_PNMI_ERR023MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* The only OID which can be set is VPD_ACTION */
r_if
c_cond
(paren
id|Id
op_ne
id|OID_SKGE_VPD_ACTION
)paren
(brace
r_if
c_cond
(paren
id|Id
op_eq
id|OID_SKGE_VPD_FREE_BYTES
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_ENTRIES_LIST
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_ENTRIES_NUMBER
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_KEY
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_VALUE
op_logical_or
id|Id
op_eq
id|OID_SKGE_VPD_ACCESS
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR024
comma
id|SK_PNMI_ERR024MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * From this point we handle VPD_ACTION. Check the buffer&n;&t;&t; * length. It should at least have the size of one byte.&n;&t;&t; */
r_if
c_cond
(paren
op_star
id|pLen
OL
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|1
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The first byte contains the VPD action type we should&n;&t;&t; * perform.&n;&t;&t; */
r_switch
c_cond
(paren
op_star
id|pBuf
)paren
(brace
r_case
id|SK_PNMI_VPD_IGNORE
suffix:colon
multiline_comment|/* Nothing to do */
r_break
suffix:semicolon
r_case
id|SK_PNMI_VPD_CREATE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * We have to create a new VPD entry or we modify&n;&t;&t;&t; * an existing one. Check first the buffer length.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pLen
OL
l_int|4
)paren
(brace
op_star
id|pLen
op_assign
l_int|4
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|KeyStr
(braket
l_int|0
)braket
op_assign
id|pBuf
(braket
l_int|1
)braket
suffix:semicolon
id|KeyStr
(braket
l_int|1
)braket
op_assign
id|pBuf
(braket
l_int|2
)braket
suffix:semicolon
id|KeyStr
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Is the entry writable or does it belong to the&n;&t;&t;&t; * read-only area?&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|VpdMayWrite
c_func
(paren
id|KeyStr
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
id|Offset
op_assign
(paren
r_int
)paren
id|pBuf
(braket
l_int|3
)braket
op_amp
l_int|0xFF
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|Buf
comma
id|pBuf
op_plus
l_int|4
comma
id|Offset
)paren
suffix:semicolon
id|Buf
(braket
id|Offset
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* A preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Write the new entry or modify an existing one */
id|Ret
op_assign
id|VpdWrite
c_func
(paren
id|pAC
comma
id|IoC
comma
id|KeyStr
comma
id|Buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_eq
id|SK_PNMI_VPD_NOWRITE
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_VPD_OK
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR025
comma
id|SK_PNMI_ERR025MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Perform an update of the VPD data. This is&n;&t;&t;&t; * not mandantory, but just to be sure.&n;&t;&t;&t; */
id|Ret
op_assign
id|VpdUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_VPD_OK
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR026
comma
id|SK_PNMI_ERR026MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_PNMI_VPD_DELETE
suffix:colon
multiline_comment|/* Check if the buffer size is plausible */
r_if
c_cond
(paren
op_star
id|pLen
OL
l_int|3
)paren
(brace
op_star
id|pLen
op_assign
l_int|3
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OG
l_int|3
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
id|KeyStr
(braket
l_int|0
)braket
op_assign
id|pBuf
(braket
l_int|1
)braket
suffix:semicolon
id|KeyStr
(braket
l_int|1
)braket
op_assign
id|pBuf
(braket
l_int|2
)braket
suffix:semicolon
id|KeyStr
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Find the passed key in the array */
r_for
c_loop
(paren
id|Index
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|KeyNo
suffix:semicolon
id|Index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|SK_STRCMP
c_func
(paren
id|KeyStr
comma
id|KeyArr
(braket
id|Index
)braket
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * If we cannot find the key it is wrong, so we&n;&t;&t;&t; * return an appropriate error value.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Index
op_eq
id|KeyNo
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Ok, you wanted it and you will get it */
id|Ret
op_assign
id|VpdDelete
c_func
(paren
id|pAC
comma
id|IoC
comma
id|KeyStr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_VPD_OK
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR027
comma
id|SK_PNMI_ERR027MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Perform an update of the VPD data. This is&n;&t;&t;&t; * not mandantory, but just to be sure.&n;&t;&t;&t; */
id|Ret
op_assign
id|VpdUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_VPD_OK
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR028
comma
id|SK_PNMI_ERR028MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * General - OID handler function of various single instance OIDs&n; *&n; * Description:&n; *&t;The code is simple. No description necessary.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|General
id|PNMI_STATIC
r_int
id|General
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
id|Ret
suffix:semicolon
r_int
r_int
id|Index
suffix:semicolon
r_int
r_int
id|Len
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
r_int
id|Val
suffix:semicolon
id|SK_U8
id|Val8
suffix:semicolon
id|SK_U16
id|Val16
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|SK_U64
id|Val64
suffix:semicolon
id|SK_U64
id|Val64RxHwErrs
op_assign
l_int|0
suffix:semicolon
id|SK_U64
id|Val64TxHwErrs
op_assign
l_int|0
suffix:semicolon
id|SK_BOOL
id|Is64BitReq
op_assign
id|SK_FALSE
suffix:semicolon
r_char
id|Buf
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|MacType
suffix:semicolon
multiline_comment|/*&n;&t; * Check instance. We only handle single instance variables.&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
op_logical_and
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check action. We only allow get requests.&n;&t; */
r_if
c_cond
(paren
id|Action
op_ne
id|SK_PNMI_GET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
id|MacType
op_assign
id|pAC-&gt;GIni.GIMacType
suffix:semicolon
multiline_comment|/*&n;&t; * Check length for the various supported OIDs&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_GEN_XMIT_ERROR
suffix:colon
r_case
id|OID_GEN_RCV_ERROR
suffix:colon
r_case
id|OID_GEN_RCV_NO_BUFFER
suffix:colon
macro_line|#ifndef SK_NDIS_64BIT_CTR
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
macro_line|#else /* SK_NDIS_64BIT_CTR */
multiline_comment|/*&n;&t;&t; * for compatibility, at least 32bit are required for oid&n;&t;&t; */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;* but indicate handling for 64bit values,&n;&t;&t;&t;* if insufficient space is provided&n;&t;&t;&t;*/
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|Is64BitReq
op_assign
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U64
)paren
)paren
ques
c_cond
id|SK_FALSE
suffix:colon
id|SK_TRUE
suffix:semicolon
macro_line|#endif /* SK_NDIS_64BIT_CTR */
r_break
suffix:semicolon
r_case
id|OID_SKGE_BOARDLEVEL
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_PORT_NUMBER
suffix:colon
r_case
id|OID_SKGE_DEVICE_TYPE
suffix:colon
r_case
id|OID_SKGE_RESULT
suffix:colon
r_case
id|OID_SKGE_RLMT_MONITOR_NUMBER
suffix:colon
r_case
id|OID_GEN_TRANSMIT_QUEUE_LENGTH
suffix:colon
r_case
id|OID_SKGE_TRAP_NUMBER
suffix:colon
r_case
id|OID_SKGE_MDB_VERSION
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHIPSET
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U16
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U16
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_BUS_TYPE
suffix:colon
r_case
id|OID_SKGE_BUS_SPEED
suffix:colon
r_case
id|OID_SKGE_BUS_WIDTH
suffix:colon
r_case
id|OID_SKGE_SENSOR_NUMBER
suffix:colon
r_case
id|OID_SKGE_CHKSM_NUMBER
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U8
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U8
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_SW_QUEUE_LEN
suffix:colon
r_case
id|OID_SKGE_TX_SW_QUEUE_MAX
suffix:colon
r_case
id|OID_SKGE_TX_RETRY
suffix:colon
r_case
id|OID_SKGE_RX_INTR_CTS
suffix:colon
r_case
id|OID_SKGE_TX_INTR_CTS
suffix:colon
r_case
id|OID_SKGE_RX_NO_BUF_CTS
suffix:colon
r_case
id|OID_SKGE_TX_NO_BUF_CTS
suffix:colon
r_case
id|OID_SKGE_TX_USED_DESCR_NO
suffix:colon
r_case
id|OID_SKGE_RX_DELIVERED_CTS
suffix:colon
r_case
id|OID_SKGE_RX_OCTETS_DELIV_CTS
suffix:colon
r_case
id|OID_SKGE_RX_HW_ERROR_CTS
suffix:colon
r_case
id|OID_SKGE_TX_HW_ERROR_CTS
suffix:colon
r_case
id|OID_SKGE_IN_ERRORS_CTS
suffix:colon
r_case
id|OID_SKGE_OUT_ERROR_CTS
suffix:colon
r_case
id|OID_SKGE_ERR_RECOVERY_CTS
suffix:colon
r_case
id|OID_SKGE_SYSUPTIME
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Checked later */
r_break
suffix:semicolon
)brace
multiline_comment|/* Update statistic */
r_if
c_cond
(paren
id|Id
op_eq
id|OID_SKGE_RX_HW_ERROR_CTS
op_logical_or
id|Id
op_eq
id|OID_SKGE_TX_HW_ERROR_CTS
op_logical_or
id|Id
op_eq
id|OID_SKGE_IN_ERRORS_CTS
op_logical_or
id|Id
op_eq
id|OID_SKGE_OUT_ERROR_CTS
op_logical_or
id|Id
op_eq
id|OID_GEN_XMIT_ERROR
op_logical_or
id|Id
op_eq
id|OID_GEN_RCV_ERROR
)paren
(brace
multiline_comment|/* Force the XMAC to update its statistic counters and&n;&t;&t; * Increment semaphore to indicate that an update was&n;&t;&t; * already done.&n;&t;&t; */
id|Ret
op_assign
id|MacUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|pAC-&gt;GIni.GIMacsFound
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Some OIDs consist of multiple hardware counters. Those&n;&t;&t; * values which are contained in all of them will be added&n;&t;&t; * now.&n;&t;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RX_HW_ERROR_CTS
suffix:colon
r_case
id|OID_SKGE_IN_ERRORS_CTS
suffix:colon
r_case
id|OID_GEN_RCV_ERROR
suffix:colon
id|Val64RxHwErrs
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_MISSED
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_FRAMING
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_OVERFLOW
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_JABBER
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_CARRIER
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_IRLENGTH
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_SYMBOL
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_SHORTS
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_RUNT
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_TOO_LONG
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_FCS
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HRX_CEXT
comma
id|NetIndex
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_HW_ERROR_CTS
suffix:colon
r_case
id|OID_SKGE_OUT_ERROR_CTS
suffix:colon
r_case
id|OID_GEN_XMIT_ERROR
suffix:colon
id|Val64TxHwErrs
op_assign
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HTX_EXCESS_COL
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HTX_LATE_COL
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HTX_UNDERRUN
comma
id|NetIndex
)paren
op_plus
id|GetStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
l_int|0
comma
id|SK_PNMI_HTX_CARRIER
comma
id|NetIndex
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Retrieve value&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_SUPPORTED_LIST
suffix:colon
id|Len
op_assign
id|ID_TABLE_SIZE
op_star
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
comma
id|Index
op_assign
l_int|0
suffix:semicolon
id|Offset
OL
id|Len
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
comma
id|Index
op_increment
)paren
(brace
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|IdTable
(braket
id|Index
)braket
dot
id|Id
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
)brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_BOARDLEVEL
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;GIni.GILevel
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PORT_NUMBER
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_DEVICE_TYPE
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;Pnmi.DeviceType
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_DRIVER_DESCR
suffix:colon
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.pDriverDescription
op_eq
l_int|NULL
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR007
comma
id|SK_PNMI_ERR007MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Len
op_assign
id|SK_STRLEN
c_func
(paren
id|pAC-&gt;Pnmi.pDriverDescription
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|Len
OG
id|SK_PNMI_STRINGLEN1
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR029
comma
id|SK_PNMI_ERR029MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
op_star
id|pBuf
op_assign
(paren
r_char
)paren
(paren
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
l_int|1
comma
id|pAC-&gt;Pnmi.pDriverDescription
comma
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_DRIVER_VERSION
suffix:colon
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.pDriverVersion
op_eq
l_int|NULL
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR030
comma
id|SK_PNMI_ERR030MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Len
op_assign
id|SK_STRLEN
c_func
(paren
id|pAC-&gt;Pnmi.pDriverVersion
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|Len
OG
id|SK_PNMI_STRINGLEN1
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR031
comma
id|SK_PNMI_ERR031MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
op_star
id|pBuf
op_assign
(paren
r_char
)paren
(paren
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
l_int|1
comma
id|pAC-&gt;Pnmi.pDriverVersion
comma
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_HW_DESCR
suffix:colon
multiline_comment|/*&n;&t;&t; * The hardware description is located in the VPD. This&n;&t;&t; * query may move to the initialisation routine. But&n;&t;&t; * the VPD data is cached and therefore a call here&n;&t;&t; * will not make much difference.&n;&t;&t; */
id|Len
op_assign
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|VpdRead
c_func
(paren
id|pAC
comma
id|IoC
comma
id|VPD_NAME
comma
id|Buf
comma
(paren
r_int
op_star
)paren
op_amp
id|Len
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR032
comma
id|SK_PNMI_ERR032MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Len
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|Len
OG
id|SK_PNMI_STRINGLEN1
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR033
comma
id|SK_PNMI_ERR033MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
op_star
id|pBuf
op_assign
(paren
r_char
)paren
(paren
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
l_int|1
comma
id|Buf
comma
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_HW_VERSION
suffix:colon
multiline_comment|/* Oh, I love to do some string manipulation */
r_if
c_cond
(paren
op_star
id|pLen
OL
l_int|5
)paren
(brace
op_star
id|pLen
op_assign
l_int|5
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|Val8
op_assign
(paren
id|SK_U8
)paren
id|pAC-&gt;GIni.GIPciHwRev
suffix:semicolon
id|pBuf
(braket
l_int|0
)braket
op_assign
l_int|4
suffix:semicolon
id|pBuf
(braket
l_int|1
)braket
op_assign
l_char|&squot;v&squot;
suffix:semicolon
id|pBuf
(braket
l_int|2
)braket
op_assign
(paren
r_char
)paren
(paren
l_int|0x30
op_or
(paren
(paren
id|Val8
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
)paren
)paren
suffix:semicolon
id|pBuf
(braket
l_int|3
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|pBuf
(braket
l_int|4
)braket
op_assign
(paren
r_char
)paren
(paren
l_int|0x30
op_or
(paren
id|Val8
op_amp
l_int|0x0F
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHIPSET
suffix:colon
id|Val16
op_assign
id|pAC-&gt;Pnmi.Chipset
suffix:semicolon
id|SK_PNMI_STORE_U16
c_func
(paren
id|pBuf
comma
id|Val16
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_BUS_TYPE
suffix:colon
op_star
id|pBuf
op_assign
(paren
r_char
)paren
id|SK_PNMI_BUS_PCI
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_BUS_SPEED
suffix:colon
op_star
id|pBuf
op_assign
id|pAC-&gt;Pnmi.PciBusSpeed
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_BUS_WIDTH
suffix:colon
op_star
id|pBuf
op_assign
id|pAC-&gt;Pnmi.PciBusWidth
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RESULT
suffix:colon
id|Val32
op_assign
id|pAC-&gt;Pnmi.TestResult
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SENSOR_NUMBER
suffix:colon
op_star
id|pBuf
op_assign
(paren
r_char
)paren
id|pAC-&gt;I2c.MaxSens
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CHKSM_NUMBER
suffix:colon
op_star
id|pBuf
op_assign
id|SKCS_NUM_PROTOCOLS
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TRAP_NUMBER
suffix:colon
id|GetTrapQueueLen
c_func
(paren
id|pAC
comma
op_amp
id|Len
comma
op_amp
id|Val
)paren
suffix:semicolon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|Val
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TRAP
suffix:colon
id|GetTrapQueueLen
c_func
(paren
id|pAC
comma
op_amp
id|Len
comma
op_amp
id|Val
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Len
)paren
(brace
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
id|CopyTrapQueue
c_func
(paren
id|pAC
comma
id|pBuf
)paren
suffix:semicolon
op_star
id|pLen
op_assign
id|Len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_MONITOR_NUMBER
suffix:colon
multiline_comment|/* XXX Not yet implemented by RLMT therefore we return zero elements */
id|Val32
op_assign
l_int|0
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_SW_QUEUE_LEN
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|TxSwQueueLen
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|TxSwQueueLen
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|TxSwQueueLen
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxSwQueueLen
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|TxSwQueueLen
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|TxSwQueueLen
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_SW_QUEUE_MAX
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|TxSwQueueMax
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|TxSwQueueMax
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|TxSwQueueMax
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxSwQueueMax
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|TxSwQueueMax
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|TxSwQueueMax
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_RETRY
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|TxRetryCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|TxRetryCts
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|TxRetryCts
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxRetryCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|TxRetryCts
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|TxRetryCts
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RX_INTR_CTS
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|RxIntrCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|RxIntrCts
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|RxIntrCts
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|RxIntrCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|RxIntrCts
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|RxIntrCts
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_INTR_CTS
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|TxIntrCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|TxIntrCts
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|TxIntrCts
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxIntrCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|TxIntrCts
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|TxIntrCts
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RX_NO_BUF_CTS
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|RxNoBufCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|RxNoBufCts
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|RxNoBufCts
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|RxNoBufCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|RxNoBufCts
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|RxNoBufCts
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_NO_BUF_CTS
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|TxNoBufCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|TxNoBufCts
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|TxNoBufCts
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxNoBufCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|TxNoBufCts
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|TxNoBufCts
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_USED_DESCR_NO
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|TxUsedDescrNo
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|TxUsedDescrNo
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|TxUsedDescrNo
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxUsedDescrNo
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|TxUsedDescrNo
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|TxUsedDescrNo
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RX_DELIVERED_CTS
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|RxDeliveredCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|RxDeliveredCts
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|RxDeliveredCts
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|RxDeliveredCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|RxDeliveredCts
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|RxDeliveredCts
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RX_OCTETS_DELIV_CTS
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|RxOctetsDeliveredCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|RxOctetsDeliveredCts
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|RxOctetsDeliveredCts
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|RxOctetsDeliveredCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|RxOctetsDeliveredCts
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|RxOctetsDeliveredCts
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RX_HW_ERROR_CTS
suffix:colon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64RxHwErrs
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_TX_HW_ERROR_CTS
suffix:colon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64TxHwErrs
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_IN_ERRORS_CTS
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|Val64RxHwErrs
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|RxNoBufCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|Val64RxHwErrs
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|RxNoBufCts
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|RxNoBufCts
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|Val64RxHwErrs
op_plus
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|RxNoBufCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|Val64RxHwErrs
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|RxNoBufCts
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|RxNoBufCts
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_OUT_ERROR_CTS
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|Val64TxHwErrs
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|TxNoBufCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|Val64TxHwErrs
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|TxNoBufCts
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|TxNoBufCts
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|Val64TxHwErrs
op_plus
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxNoBufCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|Val64TxHwErrs
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|TxNoBufCts
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|TxNoBufCts
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_ERR_RECOVERY_CTS
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|ErrRecoveryCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|0
)braket
dot
id|ErrRecoveryCts
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
l_int|1
)braket
dot
id|ErrRecoveryCts
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|ErrRecoveryCts
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
l_int|0
)braket
dot
id|ErrRecoveryCts
op_plus
id|pAC-&gt;Pnmi.Port
(braket
l_int|1
)braket
dot
id|ErrRecoveryCts
suffix:semicolon
)brace
)brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SYSUPTIME
suffix:colon
id|Val64
op_assign
id|SK_PNMI_HUNDREDS_SEC
c_func
(paren
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
)paren
suffix:semicolon
id|Val64
op_sub_assign
id|pAC-&gt;Pnmi.StartUpTime
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_MDB_VERSION
suffix:colon
id|Val32
op_assign
id|SK_PNMI_MDB_VERSION
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_GEN_RCV_ERROR
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
id|Val64
op_assign
id|Val64RxHwErrs
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|RxNoBufCts
suffix:semicolon
)brace
r_else
(brace
id|Val64
op_assign
id|Val64RxHwErrs
op_plus
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|RxNoBufCts
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * by default 32bit values are evaluated&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|Is64BitReq
)paren
(brace
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|Val64
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
)brace
r_else
(brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_GEN_XMIT_ERROR
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
id|Val64
op_assign
id|Val64TxHwErrs
op_plus
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|TxNoBufCts
suffix:semicolon
)brace
r_else
(brace
id|Val64
op_assign
id|Val64TxHwErrs
op_plus
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxNoBufCts
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * by default 32bit values are evaluated&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|Is64BitReq
)paren
(brace
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|Val64
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
)brace
r_else
(brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_GEN_RCV_NO_BUFFER
suffix:colon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.BufPort
(braket
id|NetIndex
)braket
dot
id|RxNoBufCts
suffix:semicolon
)brace
r_else
(brace
id|Val64
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|RxNoBufCts
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * by default 32bit values are evaluated&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|Is64BitReq
)paren
(brace
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|Val64
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
)brace
r_else
(brace
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_GEN_TRANSMIT_QUEUE_LENGTH
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxSwQueueLen
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR034
comma
id|SK_PNMI_ERR034MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Id
op_eq
id|OID_SKGE_RX_HW_ERROR_CTS
op_logical_or
id|Id
op_eq
id|OID_SKGE_TX_HW_ERROR_CTS
op_logical_or
id|Id
op_eq
id|OID_SKGE_IN_ERRORS_CTS
op_logical_or
id|Id
op_eq
id|OID_SKGE_OUT_ERROR_CTS
op_logical_or
id|Id
op_eq
id|OID_GEN_XMIT_ERROR
op_logical_or
id|Id
op_eq
id|OID_GEN_RCV_ERROR
)paren
(brace
id|pAC-&gt;Pnmi.MacUpdatedFlag
op_decrement
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * Rlmt - OID handler function of OID_SKGE_RLMT_XXX single instance.&n; *&n; * Description:&n; *&t;Get/Presets/Sets the RLMT OIDs.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|Rlmt
id|PNMI_STATIC
r_int
id|Rlmt
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
id|Ret
suffix:semicolon
r_int
r_int
id|PhysPortIndex
suffix:semicolon
r_int
r_int
id|PhysPortMax
suffix:semicolon
id|SK_EVPARA
id|EventParam
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|SK_U64
id|Val64
suffix:semicolon
multiline_comment|/*&n;&t; * Check instance. Only single instance OIDs are allowed here.&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
op_logical_and
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Perform the requested action.&n;&t; */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
multiline_comment|/*&n;&t;&t; * Check if the buffer length is large enough.&n;&t;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RLMT_MODE
suffix:colon
r_case
id|OID_SKGE_RLMT_PORT_ACTIVE
suffix:colon
r_case
id|OID_SKGE_RLMT_PORT_PREFERRED
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U8
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U8
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_PORT_NUMBER
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_CHANGE_CTS
suffix:colon
r_case
id|OID_SKGE_RLMT_CHANGE_TIME
suffix:colon
r_case
id|OID_SKGE_RLMT_CHANGE_ESTIM
suffix:colon
r_case
id|OID_SKGE_RLMT_CHANGE_THRES
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR035
comma
id|SK_PNMI_ERR035MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Update RLMT statistic and increment semaphores to indicate&n;&t;&t; * that an update was already done. Maybe RLMT will hold its&n;&t;&t; * statistic always up to date some time. Then we can&n;&t;&t; * remove this type of call.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|RlmtUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
id|NetIndex
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Retrieve Value&n;&t;&t;*/
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RLMT_MODE
suffix:colon
op_star
id|pBuf
op_assign
(paren
r_char
)paren
id|pAC-&gt;Rlmt.Net
(braket
l_int|0
)braket
dot
id|RlmtMode
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_PORT_NUMBER
suffix:colon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|Val32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_PORT_ACTIVE
suffix:colon
op_star
id|pBuf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If multiple ports may become active this OID&n;&t;&t;&t; * doesn&squot;t make sense any more. A new variable in&n;&t;&t;&t; * the port structure should be created. However,&n;&t;&t;&t; * for this variable the first active port is&n;&t;&t;&t; * returned.&n;&t;&t;&t; */
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
op_star
id|pBuf
op_assign
(paren
r_char
)paren
id|SK_PNMI_PORT_PHYS2LOG
c_func
(paren
id|PhysPortIndex
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_PORT_PREFERRED
suffix:colon
op_star
id|pBuf
op_assign
(paren
r_char
)paren
id|SK_PNMI_PORT_PHYS2LOG
c_func
(paren
id|pAC-&gt;Rlmt.Net
(braket
id|NetIndex
)braket
dot
id|Preference
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_CHANGE_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RlmtChangeCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_CHANGE_TIME
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RlmtChangeTime
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_CHANGE_ESTIM
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RlmtChangeEstimate.Estimate
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_CHANGE_THRES
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Pnmi.RlmtChangeThreshold
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_ERR
comma
(paren
l_string|&quot;Rlmt: Unknown OID should be handled before&quot;
)paren
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Perform a preset or set */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RLMT_MODE
suffix:colon
multiline_comment|/* Check if the buffer length is plausible */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
r_char
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if the value range is correct */
r_if
c_cond
(paren
op_star
id|pLen
op_ne
r_sizeof
(paren
r_char
)paren
op_logical_or
(paren
op_star
id|pBuf
op_amp
id|SK_PNMI_RLMT_MODE_CHK_LINK
)paren
op_eq
l_int|0
op_logical_or
op_star
(paren
id|SK_U8
op_star
)paren
id|pBuf
OG
l_int|15
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Send an event to RLMT to change the mode */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|0
)braket
op_or_assign
(paren
id|SK_U32
)paren
(paren
op_star
id|pBuf
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SkRlmtEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_RLMT_MODE_CHANGE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR037
comma
id|SK_PNMI_ERR037MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_PORT_PREFERRED
suffix:colon
multiline_comment|/* Check if the buffer length is plausible */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
r_char
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if the value range is correct */
r_if
c_cond
(paren
op_star
id|pLen
op_ne
r_sizeof
(paren
r_char
)paren
op_logical_or
op_star
(paren
id|SK_U8
op_star
)paren
id|pBuf
OG
(paren
id|SK_U8
)paren
id|pAC-&gt;GIni.GIMacsFound
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Send an event to RLMT change the preferred port.&n;&t;&t;&t; * A param of -1 means automatic mode. RLMT will&n;&t;&t;&t; * make the decision which is the preferred port.&n;&t;&t;&t; */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
(paren
id|SK_U32
)paren
(paren
op_star
id|pBuf
)paren
op_minus
l_int|1
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
id|NetIndex
suffix:semicolon
r_if
c_cond
(paren
id|SkRlmtEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_RLMT_PREFPORT_CHANGE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR038
comma
id|SK_PNMI_ERR038MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_CHANGE_THRES
suffix:colon
multiline_comment|/* Check if the buffer length is plausible */
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * There are not many restrictions to the&n;&t;&t;&t; * value range.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pLen
op_ne
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* A preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Store the new threshold, which will be taken&n;&t;&t;&t; * on the next timer event.&n;&t;&t;&t; */
id|SK_PNMI_READ_U64
c_func
(paren
id|pBuf
comma
id|Val64
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeThreshold
op_assign
id|Val64
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* The other OIDs are not be able for set */
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * RlmtStat - OID handler function of OID_SKGE_RLMT_XXX multiple instance.&n; *&n; * Description:&n; *&t;Performs get requests on multiple instance variables.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|RlmtStat
id|PNMI_STATIC
r_int
id|RlmtStat
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
r_int
id|PhysPortMax
suffix:semicolon
r_int
r_int
id|PhysPortIndex
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
id|Ret
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|SK_U64
id|Val64
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the port indexes from the instance.&n;&t; */
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* Check instance range */
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
id|PhysPortMax
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
multiline_comment|/* Single net mode */
id|PhysPortIndex
op_assign
id|Instance
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|PhysPortIndex
op_assign
id|NetIndex
suffix:semicolon
)brace
multiline_comment|/* Both net modes */
id|Limit
op_assign
id|PhysPortIndex
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Single net mode */
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|PhysPortMax
suffix:semicolon
multiline_comment|/* Dual net mode */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|PhysPortIndex
op_assign
id|NetIndex
suffix:semicolon
id|Limit
op_assign
id|PhysPortIndex
op_plus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Currently only get requests are allowed.&n;&t; */
r_if
c_cond
(paren
id|Action
op_ne
id|SK_PNMI_GET
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check if the buffer length is large enough.&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RLMT_PORT_INDEX
suffix:colon
r_case
id|OID_SKGE_RLMT_STATUS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_TX_HELLO_CTS
suffix:colon
r_case
id|OID_SKGE_RLMT_RX_HELLO_CTS
suffix:colon
r_case
id|OID_SKGE_RLMT_TX_SP_REQ_CTS
suffix:colon
r_case
id|OID_SKGE_RLMT_RX_SP_CTS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR039
comma
id|SK_PNMI_ERR039MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update statistic and increment semaphores to indicate that&n;&t; * an update was already done.&n;&t; */
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|RlmtUpdate
c_func
(paren
id|pAC
comma
id|IoC
comma
id|NetIndex
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Get value&n;&t; */
id|Offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|PhysPortIndex
OL
id|Limit
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RLMT_PORT_INDEX
suffix:colon
id|Val32
op_assign
id|PhysPortIndex
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_STATUS
suffix:colon
r_if
c_cond
(paren
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|PortState
op_eq
id|SK_RLMT_PS_INIT
op_logical_or
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|PortState
op_eq
id|SK_RLMT_PS_DOWN
)paren
(brace
id|Val32
op_assign
id|SK_PNMI_RLMT_STATUS_ERROR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
id|Val32
op_assign
id|SK_PNMI_RLMT_STATUS_ACTIVE
suffix:semicolon
)brace
r_else
(brace
id|Val32
op_assign
id|SK_PNMI_RLMT_STATUS_STANDBY
suffix:semicolon
)brace
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_TX_HELLO_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|TxHelloCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_RX_HELLO_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|RxHelloCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_TX_SP_REQ_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|TxSpHelloReqCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_RLMT_RX_SP_CTS
suffix:colon
id|Val64
op_assign
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|RxSpHelloCts
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val64
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U64
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_ERR
comma
(paren
l_string|&quot;RlmtStat: Unknown OID should be errored before&quot;
)paren
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
op_decrement
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * MacPrivateConf - OID handler function of OIDs concerning the configuration&n; *&n; * Description:&n; *&t;Get/Presets/Sets the OIDs concerning the configuration.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|MacPrivateConf
id|PNMI_STATIC
r_int
id|MacPrivateConf
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
r_int
id|PhysPortMax
suffix:semicolon
r_int
r_int
id|PhysPortIndex
suffix:semicolon
r_int
r_int
id|LogPortMax
suffix:semicolon
r_int
r_int
id|LogPortIndex
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_char
id|Val8
suffix:semicolon
r_char
op_star
id|pBufPtr
suffix:semicolon
r_int
id|Ret
suffix:semicolon
id|SK_EVPARA
id|EventParam
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate instance if wished. MAC index 0 is the virtual MAC.&n;&t; */
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|LogPortMax
op_assign
id|SK_PNMI_PORT_PHYS2LOG
c_func
(paren
id|PhysPortMax
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
multiline_comment|/* Dual net mode */
id|LogPortMax
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* Only one specific instance is queried */
multiline_comment|/* Check instance range */
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
id|LogPortMax
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|LogPortIndex
op_assign
id|SK_PNMI_PORT_INST2LOG
c_func
(paren
id|Instance
)paren
suffix:semicolon
id|Limit
op_assign
id|LogPortIndex
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Instance == (SK_U32)(-1), get all Instances of that OID */
id|LogPortIndex
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|LogPortMax
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Perform action&n;&t; */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
multiline_comment|/* Check length */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_PMD
suffix:colon
r_case
id|OID_SKGE_CONNECTOR
suffix:colon
r_case
id|OID_SKGE_LINK_CAP
suffix:colon
r_case
id|OID_SKGE_LINK_MODE
suffix:colon
r_case
id|OID_SKGE_LINK_MODE_STATUS
suffix:colon
r_case
id|OID_SKGE_LINK_STATUS
suffix:colon
r_case
id|OID_SKGE_FLOWCTRL_CAP
suffix:colon
r_case
id|OID_SKGE_FLOWCTRL_MODE
suffix:colon
r_case
id|OID_SKGE_FLOWCTRL_STATUS
suffix:colon
r_case
id|OID_SKGE_PHY_OPERATION_CAP
suffix:colon
r_case
id|OID_SKGE_PHY_OPERATION_MODE
suffix:colon
r_case
id|OID_SKGE_PHY_OPERATION_STATUS
suffix:colon
r_case
id|OID_SKGE_SPEED_CAP
suffix:colon
r_case
id|OID_SKGE_SPEED_MODE
suffix:colon
r_case
id|OID_SKGE_SPEED_STATUS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U8
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U8
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_MTU
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|LogPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR041
comma
id|SK_PNMI_ERR041MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Update statistic and increment semaphore to indicate&n;&t;&t; * that an update was already done.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|Ret
op_assign
id|SirqUpdate
c_func
(paren
id|pAC
comma
id|IoC
)paren
)paren
op_ne
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|Ret
)paren
suffix:semicolon
)brace
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get value&n;&t;&t; */
id|Offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|LogPortIndex
OL
id|Limit
suffix:semicolon
id|LogPortIndex
op_increment
)paren
(brace
id|pBufPtr
op_assign
id|pBuf
op_plus
id|Offset
suffix:semicolon
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_PMD
suffix:colon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;Pnmi.PMD
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_CONNECTOR
suffix:colon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;Pnmi.Connector
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_CAP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical ports */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkCap
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DualNetMode */
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|NetIndex
)braket
dot
id|PLinkCap
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_MODE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical ports */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkModeConf
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DualNetMode */
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|NetIndex
)braket
dot
id|PLinkModeConf
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_MODE_STATUS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|CalculateLinkModeStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DualNetMode */
op_star
id|pBufPtr
op_assign
id|CalculateLinkModeStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|NetIndex
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_STATUS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical ports */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|CalculateLinkStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DualNetMode */
op_star
id|pBufPtr
op_assign
id|CalculateLinkStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|NetIndex
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_CAP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical ports */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PFlowCtrlCap
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DualNetMode */
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|NetIndex
)braket
dot
id|PFlowCtrlCap
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_MODE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PFlowCtrlMode
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DualNetMode */
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|NetIndex
)braket
dot
id|PFlowCtrlMode
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_STATUS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PFlowCtrlStatus
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DualNetMode */
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|NetIndex
)braket
dot
id|PFlowCtrlStatus
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_CAP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical ports */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PMSCap
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DualNetMode */
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|NetIndex
)braket
dot
id|PMSCap
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_MODE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PMSMode
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DualNetMode */
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|NetIndex
)braket
dot
id|PMSMode
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_STATUS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PMSStatus
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|NetIndex
)braket
dot
id|PMSStatus
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SPEED_CAP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical ports */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkSpeedCap
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DualNetMode */
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|NetIndex
)braket
dot
id|PLinkSpeedCap
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SPEED_MODE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkSpeed
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DualNetMode */
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|NetIndex
)braket
dot
id|PLinkSpeed
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SPEED_STATUS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.DualNetActiveFlag
)paren
(brace
multiline_comment|/* SingleNetMode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Get value for virtual port */
id|VirtualConf
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Id
comma
id|pBufPtr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get value for physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkSpeedUsed
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DualNetMode */
op_star
id|pBufPtr
op_assign
id|pAC-&gt;GIni.GP
(braket
id|NetIndex
)braket
dot
id|PLinkSpeedUsed
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_MTU
suffix:colon
id|Val32
op_assign
id|SK_DRIVER_GET_MTU
c_func
(paren
id|pAC
comma
id|IoC
comma
id|NetIndex
)paren
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBufPtr
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_ERR
comma
(paren
l_string|&quot;MacPrivateConf: Unknown OID should be handled before&quot;
)paren
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
id|pAC-&gt;Pnmi.SirqUpdatedFlag
op_decrement
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * From here SET or PRESET action. Check if the passed&n;&t; * buffer length is plausible.&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_LINK_MODE
suffix:colon
r_case
id|OID_SKGE_FLOWCTRL_MODE
suffix:colon
r_case
id|OID_SKGE_PHY_OPERATION_MODE
suffix:colon
r_case
id|OID_SKGE_SPEED_MODE
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
id|Limit
op_minus
id|LogPortIndex
)paren
(brace
op_star
id|pLen
op_assign
id|Limit
op_minus
id|LogPortIndex
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
op_ne
id|Limit
op_minus
id|LogPortIndex
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_MTU
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pLen
op_ne
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Perform preset or set&n;&t; */
id|Offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|LogPortIndex
OL
id|Limit
suffix:semicolon
id|LogPortIndex
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_LINK_MODE
suffix:colon
multiline_comment|/* Check the value range */
id|Val8
op_assign
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Val8
op_eq
l_int|0
)paren
(brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Val8
OL
id|SK_LMODE_HALF
op_logical_or
(paren
id|LogPortIndex
op_ne
l_int|0
op_logical_and
id|Val8
OG
id|SK_LMODE_AUTOSENSE
)paren
op_logical_or
(paren
id|LogPortIndex
op_eq
l_int|0
op_logical_and
id|Val8
OG
id|SK_LMODE_INDETERMINATED
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The virtual port consists of all currently&n;&t;&t;&t;&t; * active ports. Find them and send an event&n;&t;&t;&t;&t; * with the new link mode to SIRQ.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_continue
suffix:semicolon
)brace
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|PhysPortIndex
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_LMODE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR043
comma
id|SK_PNMI_ERR043MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Send an event with the new link mode to&n;&t;&t;&t;&t; * the SIRQ module.&n;&t;&t;&t;&t; */
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_LMODE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR043
comma
id|SK_PNMI_ERR043MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_MODE
suffix:colon
multiline_comment|/* Check the value range */
id|Val8
op_assign
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Val8
op_eq
l_int|0
)paren
(brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Val8
OL
id|SK_FLOW_MODE_NONE
op_logical_or
(paren
id|LogPortIndex
op_ne
l_int|0
op_logical_and
id|Val8
OG
id|SK_FLOW_MODE_SYM_OR_REM
)paren
op_logical_or
(paren
id|LogPortIndex
op_eq
l_int|0
op_logical_and
id|Val8
OG
id|SK_FLOW_MODE_INDETERMINATED
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The virtual port consists of all currently&n;&t;&t;&t;&t; * active ports. Find them and send an event&n;&t;&t;&t;&t; * with the new flow control mode to SIRQ.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_continue
suffix:semicolon
)brace
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|PhysPortIndex
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_FLOWMODE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR044
comma
id|SK_PNMI_ERR044MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Send an event with the new flow control&n;&t;&t;&t;&t; * mode to the SIRQ module.&n;&t;&t;&t;&t; */
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_FLOWMODE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR044
comma
id|SK_PNMI_ERR044MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_MODE
suffix:colon
multiline_comment|/* Check the value range */
id|Val8
op_assign
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Val8
op_eq
l_int|0
)paren
(brace
multiline_comment|/* mode of this port remains unchanged */
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Val8
OL
id|SK_MS_MODE_AUTO
op_logical_or
(paren
id|LogPortIndex
op_ne
l_int|0
op_logical_and
id|Val8
OG
id|SK_MS_MODE_SLAVE
)paren
op_logical_or
(paren
id|LogPortIndex
op_eq
l_int|0
op_logical_and
id|Val8
OG
id|SK_MS_MODE_INDETERMINATED
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The virtual port consists of all currently&n;&t;&t;&t;&t; * active ports. Find them and send an event&n;&t;&t;&t;&t; * with new master/slave (role) mode to SIRQ.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_continue
suffix:semicolon
)brace
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|PhysPortIndex
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_ROLE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR042
comma
id|SK_PNMI_ERR042MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Send an event with the new master/slave&n;&t;&t;&t;&t; * (role) mode to the SIRQ module.&n;&t;&t;&t;&t; */
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_ROLE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR042
comma
id|SK_PNMI_ERR042MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SPEED_MODE
suffix:colon
multiline_comment|/* Check the value range */
id|Val8
op_assign
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Val8
op_eq
l_int|0
)paren
(brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Val8
OL
(paren
id|SK_LSPEED_AUTO
)paren
op_logical_or
(paren
id|LogPortIndex
op_ne
l_int|0
op_logical_and
id|Val8
OG
(paren
id|SK_LSPEED_1000MBPS
)paren
)paren
op_logical_or
(paren
id|LogPortIndex
op_eq
l_int|0
op_logical_and
id|Val8
OG
(paren
id|SK_LSPEED_INDETERMINATED
)paren
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The virtual port consists of all currently&n;&t;&t;&t;&t; * active ports. Find them and send an event&n;&t;&t;&t;&t; * with the new flow control mode to SIRQ.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_continue
suffix:semicolon
)brace
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|PhysPortIndex
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_SPEED
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR045
comma
id|SK_PNMI_ERR045MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Send an event with the new flow control&n;&t;&t;&t;&t; * mode to the SIRQ module.&n;&t;&t;&t;&t; */
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
id|Val8
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_SET_SPEED
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR045
comma
id|SK_PNMI_ERR045MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
id|Offset
op_add_assign
r_sizeof
(paren
r_char
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_MTU
suffix:colon
multiline_comment|/* Check the value range */
id|Val32
op_assign
op_star
(paren
id|SK_U32
op_star
)paren
(paren
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Val32
op_eq
l_int|0
)paren
(brace
multiline_comment|/* mtu of this port remains unchanged */
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SK_DRIVER_PRESET_MTU
c_func
(paren
id|pAC
comma
id|IoC
comma
id|NetIndex
comma
id|Val32
)paren
op_ne
l_int|0
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The preset ends here */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SK_DRIVER_SET_MTU
c_func
(paren
id|pAC
comma
id|IoC
comma
id|NetIndex
comma
id|Val32
)paren
op_ne
l_int|0
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_DBG_MSG
c_func
(paren
id|pAC
comma
id|SK_DBGMOD_PNMI
comma
id|SK_DBGCAT_ERR
comma
(paren
l_string|&quot;MacPrivateConf: Unknown OID should be handled before set&quot;
)paren
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * Monitor - OID handler function for RLMT_MONITOR_XXX&n; *&n; * Description:&n; *&t;Because RLMT currently does not support the monitoring of&n; *&t;remote adapter cards, we return always an empty table.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid&n; *&t;                         value range.&n; *&t;SK_PNMI_ERR_READ_ONLY    The OID is read-only and cannot be set.&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|Monitor
id|PNMI_STATIC
r_int
id|Monitor
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
r_int
r_int
id|Index
suffix:semicolon
r_int
r_int
id|Limit
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
r_int
id|Entries
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate instance if wished.&n;&t; */
multiline_comment|/* XXX Not yet implemented. Return always an empty table. */
id|Entries
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|1
)paren
op_logical_or
(paren
id|Instance
OG
id|Entries
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
id|Index
op_assign
(paren
r_int
r_int
)paren
id|Instance
op_minus
l_int|1
suffix:semicolon
id|Limit
op_assign
(paren
r_int
r_int
)paren
id|Instance
suffix:semicolon
)brace
r_else
(brace
id|Index
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|Entries
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get/Set value&n;&t;*/
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
r_for
c_loop
(paren
id|Offset
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|Limit
suffix:semicolon
id|Index
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_RLMT_MONITOR_INDEX
suffix:colon
r_case
id|OID_SKGE_RLMT_MONITOR_ADDR
suffix:colon
r_case
id|OID_SKGE_RLMT_MONITOR_ERRS
suffix:colon
r_case
id|OID_SKGE_RLMT_MONITOR_TIMESTAMP
suffix:colon
r_case
id|OID_SKGE_RLMT_MONITOR_ADMIN
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR046
comma
id|SK_PNMI_ERR046MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Only MONITOR_ADMIN can be set */
r_if
c_cond
(paren
id|Id
op_ne
id|OID_SKGE_RLMT_MONITOR_ADMIN
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_READ_ONLY
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if the length is plausible */
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|Index
)paren
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Okay, we have a wide value range */
r_if
c_cond
(paren
op_star
id|pLen
op_ne
(paren
id|Limit
op_minus
id|Index
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;for (Offset=0; Index &lt; Limit; Index ++) {&n;&t;&t;}&n;*/
multiline_comment|/*&n; * XXX Not yet implemented. Return always BAD_VALUE, because the table&n; * is empty.&n; */
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_BAD_VALUE
)paren
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * VirtualConf - Calculates the values of configuration OIDs for virtual port&n; *&n; * Description:&n; *&t;We handle here the get of the configuration group OIDs, which are&n; *&t;a little bit complicated. The virtual port consists of all currently&n; *&t;active physical ports. If multiple ports are active and configured&n; *&t;differently we get in some trouble to return a single value. So we&n; *&t;get the value of the first active port and compare it with that of&n; *&t;the other active ports. If they are not the same, we return a value&n; *&t;that indicates that the state is indeterminated.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|VirtualConf
id|PNMI_STATIC
r_void
id|VirtualConf
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
)paren
multiline_comment|/* Buffer used for the management data transfer */
(brace
r_int
r_int
id|PhysPortMax
suffix:semicolon
r_int
r_int
id|PhysPortIndex
suffix:semicolon
id|SK_U8
id|Val8
suffix:semicolon
id|SK_BOOL
id|PortActiveFlag
suffix:semicolon
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
op_star
id|pBuf
op_assign
l_int|0
suffix:semicolon
id|PortActiveFlag
op_assign
id|SK_FALSE
suffix:semicolon
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
suffix:semicolon
multiline_comment|/* Check if the physical port is active */
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
r_continue
suffix:semicolon
)brace
id|PortActiveFlag
op_assign
id|SK_TRUE
suffix:semicolon
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_LINK_CAP
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Different capabilities should not happen, but&n;&t;&t;&t; * in the case of the cases OR them all together.&n;&t;&t;&t; * From a curious point of view the virtual port&n;&t;&t;&t; * is capable of all found capabilities.&n;&t;&t;&t; */
op_star
id|pBuf
op_or_assign
id|pPrt-&gt;PLinkCap
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_MODE
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pPrt-&gt;PLinkModeConf
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different link&n;&t;&t;&t; * mode than the first one we return a value that&n;&t;&t;&t; * indicates that the link mode is indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|pPrt-&gt;PLinkModeConf
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_LMODE_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_MODE_STATUS
suffix:colon
multiline_comment|/* Get the link mode of the physical port */
id|Val8
op_assign
id|CalculateLinkModeStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
)paren
suffix:semicolon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|Val8
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different link&n;&t;&t;&t; * mode status than the first one we return a value&n;&t;&t;&t; * that indicates that the link mode status is&n;&t;&t;&t; * indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|Val8
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_LMODE_STAT_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_STATUS
suffix:colon
multiline_comment|/* Get the link status of the physical port */
id|Val8
op_assign
id|CalculateLinkStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
)paren
suffix:semicolon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|Val8
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different link&n;&t;&t;&t; * status than the first one, we return a value&n;&t;&t;&t; * that indicates that the link status is&n;&t;&t;&t; * indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|Val8
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_PNMI_RLMT_LSTAT_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_CAP
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pPrt-&gt;PFlowCtrlCap
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * From a curious point of view the virtual port&n;&t;&t;&t; * is capable of all found capabilities.&n;&t;&t;&t; */
op_star
id|pBuf
op_or_assign
id|pPrt-&gt;PFlowCtrlCap
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_MODE
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pPrt-&gt;PFlowCtrlMode
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different flow&n;&t;&t;&t; * control mode than the first one, we return a value&n;&t;&t;&t; * that indicates that the mode is indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|pPrt-&gt;PFlowCtrlMode
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_FLOW_MODE_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_STATUS
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pPrt-&gt;PFlowCtrlStatus
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different flow&n;&t;&t;&t; * control status than the first one, we return a&n;&t;&t;&t; * value that indicates that the status is&n;&t;&t;&t; * indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|pPrt-&gt;PFlowCtrlStatus
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_FLOW_STAT_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_CAP
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pPrt-&gt;PMSCap
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * From a curious point of view the virtual port&n;&t;&t;&t; * is capable of all found capabilities.&n;&t;&t;&t; */
op_star
id|pBuf
op_or_assign
id|pPrt-&gt;PMSCap
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_MODE
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pPrt-&gt;PMSMode
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different master/&n;&t;&t;&t; * slave mode than the first one, we return a value&n;&t;&t;&t; * that indicates that the mode is indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|pPrt-&gt;PMSMode
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_MS_MODE_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_STATUS
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pPrt-&gt;PMSStatus
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different master/&n;&t;&t;&t; * slave status than the first one, we return a&n;&t;&t;&t; * value that indicates that the status is&n;&t;&t;&t; * indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|pPrt-&gt;PMSStatus
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_MS_STAT_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_SPEED_MODE
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pPrt-&gt;PLinkSpeed
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different flow&n;&t;&t;&t; * control mode than the first one, we return a value&n;&t;&t;&t; * that indicates that the mode is indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|pPrt-&gt;PLinkSpeed
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_LSPEED_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_SPEED_STATUS
suffix:colon
multiline_comment|/* Check if it is the first active port */
r_if
c_cond
(paren
op_star
id|pBuf
op_eq
l_int|0
)paren
(brace
op_star
id|pBuf
op_assign
id|pPrt-&gt;PLinkSpeedUsed
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we find an active port with a different flow&n;&t;&t;&t; * control status than the first one, we return a&n;&t;&t;&t; * value that indicates that the status is&n;&t;&t;&t; * indeterminated.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|pBuf
op_ne
id|pPrt-&gt;PLinkSpeedUsed
)paren
(brace
op_star
id|pBuf
op_assign
id|SK_LSPEED_STAT_INDETERMINATED
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If no port is active return an indeterminated answer&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PortActiveFlag
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_LINK_CAP
suffix:colon
op_star
id|pBuf
op_assign
id|SK_LMODE_CAP_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_MODE
suffix:colon
op_star
id|pBuf
op_assign
id|SK_LMODE_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_MODE_STATUS
suffix:colon
op_star
id|pBuf
op_assign
id|SK_LMODE_STAT_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_LINK_STATUS
suffix:colon
op_star
id|pBuf
op_assign
id|SK_PNMI_RLMT_LSTAT_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_CAP
suffix:colon
r_case
id|OID_SKGE_FLOWCTRL_MODE
suffix:colon
op_star
id|pBuf
op_assign
id|SK_FLOW_MODE_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_FLOWCTRL_STATUS
suffix:colon
op_star
id|pBuf
op_assign
id|SK_FLOW_STAT_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_CAP
suffix:colon
op_star
id|pBuf
op_assign
id|SK_MS_CAP_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_MODE
suffix:colon
op_star
id|pBuf
op_assign
id|SK_MS_MODE_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_PHY_OPERATION_STATUS
suffix:colon
op_star
id|pBuf
op_assign
id|SK_MS_STAT_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SPEED_CAP
suffix:colon
op_star
id|pBuf
op_assign
id|SK_LSPEED_CAP_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SPEED_MODE
suffix:colon
op_star
id|pBuf
op_assign
id|SK_LSPEED_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_SPEED_STATUS
suffix:colon
op_star
id|pBuf
op_assign
id|SK_LSPEED_STAT_INDETERMINATED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*****************************************************************************&n; *&n; * CalculateLinkStatus - Determins the link status of a physical port&n; *&n; * Description:&n; *&t;Determins the link status the following way:&n; *&t;  LSTAT_PHY_DOWN:  Link is down&n; *&t;  LSTAT_AUTONEG:   Auto-negotiation failed&n; *&t;  LSTAT_LOG_DOWN:  Link is up but RLMT did not yet put the port&n; *&t;                   logically up.&n; *&t;  LSTAT_LOG_UP:    RLMT marked the port as up&n; *&n; * Returns:&n; *&t;Link status of physical port&n; */
DECL|function|CalculateLinkStatus
id|PNMI_STATIC
id|SK_U8
id|CalculateLinkStatus
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
r_int
id|PhysPortIndex
)paren
multiline_comment|/* Physical port index */
(brace
id|SK_U8
id|Result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PHWLinkUp
)paren
(brace
id|Result
op_assign
id|SK_PNMI_RLMT_LSTAT_PHY_DOWN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PAutoNegFail
OG
l_int|0
)paren
(brace
id|Result
op_assign
id|SK_PNMI_RLMT_LSTAT_AUTONEG
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;Rlmt.Port
(braket
id|PhysPortIndex
)braket
dot
id|PortDown
)paren
(brace
id|Result
op_assign
id|SK_PNMI_RLMT_LSTAT_LOG_UP
suffix:semicolon
)brace
r_else
(brace
id|Result
op_assign
id|SK_PNMI_RLMT_LSTAT_LOG_DOWN
suffix:semicolon
)brace
r_return
(paren
id|Result
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * CalculateLinkModeStatus - Determins the link mode status of a phys. port&n; *&n; * Description:&n; *&t;The COMMON module only tells us if the mode is half or full duplex.&n; *&t;But in the decade of auto sensing it is usefull for the user to&n; *&t;know if the mode was negotiated or forced. Therefore we have a&n; *&t;look to the mode, which was last used by the negotiation process.&n; *&n; * Returns:&n; *&t;The link mode status&n; */
DECL|function|CalculateLinkModeStatus
id|PNMI_STATIC
id|SK_U8
id|CalculateLinkModeStatus
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
r_int
id|PhysPortIndex
)paren
multiline_comment|/* Physical port index */
(brace
id|SK_U8
id|Result
suffix:semicolon
multiline_comment|/* Get the current mode, which can be full or half duplex */
id|Result
op_assign
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkModeStatus
suffix:semicolon
multiline_comment|/* Check if no valid mode could be found (link is down) */
r_if
c_cond
(paren
id|Result
OL
id|SK_LMODE_STAT_HALF
)paren
(brace
id|Result
op_assign
id|SK_LMODE_STAT_UNKNOWN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkMode
op_ge
id|SK_LMODE_AUTOHALF
)paren
(brace
multiline_comment|/*&n;&t;&t; * Auto-negotiation was used to bring up the link. Change&n;&t;&t; * the already found duplex status that it indicates&n;&t;&t; * auto-negotiation was involved.&n;&t;&t; */
r_if
c_cond
(paren
id|Result
op_eq
id|SK_LMODE_STAT_HALF
)paren
(brace
id|Result
op_assign
id|SK_LMODE_STAT_AUTOHALF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|Result
op_eq
id|SK_LMODE_STAT_FULL
)paren
(brace
id|Result
op_assign
id|SK_LMODE_STAT_AUTOFULL
suffix:semicolon
)brace
)brace
r_return
(paren
id|Result
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * GetVpdKeyArr - Obtain an array of VPD keys&n; *&n; * Description:&n; *&t;Read the VPD keys and build an array of VPD keys, which are&n; *&t;easy to access.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK&t;     Task successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL  Something went wrong.&n; */
DECL|function|GetVpdKeyArr
id|PNMI_STATIC
r_int
id|GetVpdKeyArr
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_char
op_star
id|pKeyArr
comma
multiline_comment|/* Ptr KeyArray */
r_int
r_int
id|KeyArrLen
comma
multiline_comment|/* Length of array in bytes */
r_int
r_int
op_star
id|pKeyNo
)paren
multiline_comment|/* Number of keys */
(brace
r_int
r_int
id|BufKeysLen
op_assign
id|SK_PNMI_VPD_BUFSIZE
suffix:semicolon
r_char
id|BufKeys
(braket
id|SK_PNMI_VPD_BUFSIZE
)braket
suffix:semicolon
r_int
r_int
id|StartOffset
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
id|Index
suffix:semicolon
r_int
id|Ret
suffix:semicolon
id|SK_MEMSET
c_func
(paren
id|pKeyArr
comma
l_int|0
comma
id|KeyArrLen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get VPD key list&n;&t; */
id|Ret
op_assign
id|VpdKeys
c_func
(paren
id|pAC
comma
id|IoC
comma
(paren
r_char
op_star
)paren
op_amp
id|BufKeys
comma
(paren
r_int
op_star
)paren
op_amp
id|BufKeysLen
comma
(paren
r_int
op_star
)paren
id|pKeyNo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Ret
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR014
comma
id|SK_PNMI_ERR014MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/* If no keys are available return now */
r_if
c_cond
(paren
op_star
id|pKeyNo
op_eq
l_int|0
op_logical_or
id|BufKeysLen
op_eq
l_int|0
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the key list is too long for us trunc it and give a&n;&t; * errorlog notification. This case should not happen because&n;&t; * the maximum number of keys is limited due to RAM limitations&n;&t; */
r_if
c_cond
(paren
op_star
id|pKeyNo
OG
id|SK_PNMI_VPD_ENTRIES
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR015
comma
id|SK_PNMI_ERR015MSG
)paren
suffix:semicolon
op_star
id|pKeyNo
op_assign
id|SK_PNMI_VPD_ENTRIES
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now build an array of fixed string length size and copy&n;&t; * the keys together.&n;&t; */
r_for
c_loop
(paren
id|Index
op_assign
l_int|0
comma
id|StartOffset
op_assign
l_int|0
comma
id|Offset
op_assign
l_int|0
suffix:semicolon
id|Offset
OL
id|BufKeysLen
suffix:semicolon
id|Offset
op_increment
)paren
(brace
r_if
c_cond
(paren
id|BufKeys
(braket
id|Offset
)braket
op_ne
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Offset
op_minus
id|StartOffset
OG
id|SK_PNMI_VPD_KEY_SIZE
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR016
comma
id|SK_PNMI_ERR016MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
id|SK_STRNCPY
c_func
(paren
id|pKeyArr
op_plus
id|Index
op_star
id|SK_PNMI_VPD_KEY_SIZE
comma
op_amp
id|BufKeys
(braket
id|StartOffset
)braket
comma
id|SK_PNMI_VPD_KEY_SIZE
)paren
suffix:semicolon
id|Index
op_increment
suffix:semicolon
id|StartOffset
op_assign
id|Offset
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Last key not zero terminated? Get it anyway */
r_if
c_cond
(paren
id|StartOffset
OL
id|Offset
)paren
(brace
id|SK_STRNCPY
c_func
(paren
id|pKeyArr
op_plus
id|Index
op_star
id|SK_PNMI_VPD_KEY_SIZE
comma
op_amp
id|BufKeys
(braket
id|StartOffset
)braket
comma
id|SK_PNMI_VPD_KEY_SIZE
)paren
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * SirqUpdate - Let the SIRQ update its internal values&n; *&n; * Description:&n; *&t;Just to be sure that the SIRQ module holds its internal data&n; *&t;structures up to date, we send an update event before we make&n; *&t;any access.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK&t;     Task successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL  Something went wrong.&n; */
DECL|function|SirqUpdate
id|PNMI_STATIC
r_int
id|SirqUpdate
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
)paren
multiline_comment|/* IO context handle */
(brace
id|SK_EVPARA
id|EventParam
suffix:semicolon
multiline_comment|/* Was the module already updated during the current PNMI call? */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.SirqUpdatedFlag
OG
l_int|0
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Send an synchronuous update event to the module */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SkGeSirqEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_HWEV_UPDATE_STAT
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR047
comma
id|SK_PNMI_ERR047MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * RlmtUpdate - Let the RLMT update its internal values&n; *&n; * Description:&n; *&t;Just to be sure that the RLMT module holds its internal data&n; *&t;structures up to date, we send an update event before we make&n; *&t;any access.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK&t;     Task successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL  Something went wrong.&n; */
DECL|function|RlmtUpdate
id|PNMI_STATIC
r_int
id|RlmtUpdate
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode allways zero */
(brace
id|SK_EVPARA
id|EventParam
suffix:semicolon
multiline_comment|/* Was the module already updated during the current PNMI call? */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.RlmtUpdatedFlag
OG
l_int|0
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Send an synchronuous update event to the module */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|NetIndex
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|SkRlmtEvent
c_func
(paren
id|pAC
comma
id|IoC
comma
id|SK_RLMT_STATS_UPDATE
comma
id|EventParam
)paren
OG
l_int|0
)paren
(brace
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR048
comma
id|SK_PNMI_ERR048MSG
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * MacUpdate - Force the XMAC to output the current statistic&n; *&n; * Description:&n; *&t;The XMAC holds its statistic internally. To obtain the current&n; *&t;values we must send a command so that the statistic data will&n; *&t;be written to a predefined memory area on the adapter.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK&t;     Task successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL  Something went wrong.&n; */
DECL|function|MacUpdate
id|PNMI_STATIC
r_int
id|MacUpdate
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
r_int
id|FirstMac
comma
multiline_comment|/* Index of the first Mac to be updated */
r_int
r_int
id|LastMac
)paren
multiline_comment|/* Index of the last Mac to be updated */
(brace
r_int
r_int
id|MacIndex
suffix:semicolon
multiline_comment|/*&n;&t; * Were the statistics already updated during the&n;&t; * current PNMI call?&n;&t; */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.MacUpdatedFlag
OG
l_int|0
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Send an update command to all MACs specified */
r_for
c_loop
(paren
id|MacIndex
op_assign
id|FirstMac
suffix:semicolon
id|MacIndex
op_le
id|LastMac
suffix:semicolon
id|MacIndex
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * 2002-09-13 pweber:&t;Freeze the current SW counters.&n;&t;&t; *                      (That should be done as close as&n;&t;&t; *                      possible to the update of the&n;&t;&t; *                      HW counters)&n;&t;&t; */
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIMacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
id|pAC-&gt;Pnmi.BufPort
(braket
id|MacIndex
)braket
op_assign
id|pAC-&gt;Pnmi.Port
(braket
id|MacIndex
)braket
suffix:semicolon
)brace
multiline_comment|/* 2002-09-13 pweber:  Update the HW counter  */
r_if
c_cond
(paren
id|pAC-&gt;GIni.GIFunc
dot
id|pFnMacUpdateStats
c_func
(paren
id|pAC
comma
id|IoC
comma
id|MacIndex
)paren
op_ne
l_int|0
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * GetStatVal - Retrieve an XMAC statistic counter&n; *&n; * Description:&n; *&t;Retrieves the statistic counter of a virtual or physical port. The&n; *&t;virtual port is identified by the index 0. It consists of all&n; *&t;currently active ports. To obtain the counter value for this port&n; *&t;we must add the statistic counter of all active ports. To grant&n; *&t;continuous counter values for the virtual port even when port&n; *&t;switches occur we must additionally add a delta value, which was&n; *&t;calculated during a SK_PNMI_EVT_RLMT_ACTIVE_UP event.&n; *&n; * Returns:&n; *&t;Requested statistic value&n; */
DECL|function|GetStatVal
id|PNMI_STATIC
id|SK_U64
id|GetStatVal
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
r_int
id|LogPortIndex
comma
multiline_comment|/* Index of the logical Port to be processed */
r_int
r_int
id|StatIndex
comma
multiline_comment|/* Index to statistic value */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode allways zero */
(brace
r_int
r_int
id|PhysPortIndex
suffix:semicolon
r_int
r_int
id|PhysPortMax
suffix:semicolon
id|SK_U64
id|Val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
multiline_comment|/* Dual net mode */
id|PhysPortIndex
op_assign
id|NetIndex
suffix:semicolon
id|Val
op_assign
id|GetPhysStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatIndex
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Single Net mode */
r_if
c_cond
(paren
id|LogPortIndex
op_eq
l_int|0
)paren
(brace
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
multiline_comment|/* Add counter of all active ports */
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
id|PhysPortMax
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|ActiveFlag
)paren
(brace
id|Val
op_add_assign
id|GetPhysStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatIndex
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Correct value because of port switches */
id|Val
op_add_assign
id|pAC-&gt;Pnmi.VirtualCounterOffset
(braket
id|StatIndex
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get counter value of physical port */
id|PhysPortIndex
op_assign
id|SK_PNMI_PORT_LOG2PHYS
c_func
(paren
id|pAC
comma
id|LogPortIndex
)paren
suffix:semicolon
id|Val
op_assign
id|GetPhysStatVal
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatIndex
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|Val
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * GetPhysStatVal - Get counter value for physical port&n; *&n; * Description:&n; *&t;Builds a 64bit counter value. Except for the octet counters&n; *&t;the lower 32bit are counted in hardware and the upper 32bit&n; *&t;in software by monitoring counter overflow interrupts in the&n; *&t;event handler. To grant continous counter values during XMAC&n; *&t;resets (caused by a workaround) we must add a delta value.&n; *&t;The delta was calculated in the event handler when a&n; *&t;SK_PNMI_EVT_XMAC_RESET was received.&n; *&n; * Returns:&n; *&t;Counter value&n; */
DECL|function|GetPhysStatVal
id|PNMI_STATIC
id|SK_U64
id|GetPhysStatVal
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
r_int
id|PhysPortIndex
comma
multiline_comment|/* Index of the logical Port to be processed */
r_int
r_int
id|StatIndex
)paren
multiline_comment|/* Index to statistic value */
(brace
id|SK_U64
id|Val
op_assign
l_int|0
suffix:semicolon
id|SK_U32
id|LowVal
op_assign
l_int|0
suffix:semicolon
id|SK_U32
id|HighVal
op_assign
l_int|0
suffix:semicolon
id|SK_U16
id|Word
suffix:semicolon
r_int
id|MacType
suffix:semicolon
r_int
r_int
id|HelpIndex
suffix:semicolon
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
id|SK_PNMI_PORT
op_star
id|pPnmiPrt
suffix:semicolon
id|SK_GEMACFUNC
op_star
id|pFnMac
suffix:semicolon
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
suffix:semicolon
id|MacType
op_assign
id|pAC-&gt;GIni.GIMacType
suffix:semicolon
multiline_comment|/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
id|pPnmiPrt
op_assign
op_amp
id|pAC-&gt;Pnmi.BufPort
(braket
id|PhysPortIndex
)braket
suffix:semicolon
)brace
r_else
(brace
id|pPnmiPrt
op_assign
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
suffix:semicolon
)brace
id|pFnMac
op_assign
op_amp
id|pAC-&gt;GIni.GIFunc
suffix:semicolon
r_switch
c_cond
(paren
id|StatIndex
)paren
(brace
r_case
id|SK_PNMI_HTX
suffix:colon
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_GMAC
)paren
(brace
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|SK_PNMI_HTX_BROADCAST
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|SK_PNMI_HTX_MULTICAST
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|HighVal
)paren
suffix:semicolon
id|LowVal
op_add_assign
id|HighVal
suffix:semicolon
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|SK_PNMI_HTX_UNICAST
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|HighVal
)paren
suffix:semicolon
id|LowVal
op_add_assign
id|HighVal
suffix:semicolon
)brace
r_else
(brace
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
)brace
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX
suffix:colon
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_GMAC
)paren
(brace
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|SK_PNMI_HRX_BROADCAST
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|SK_PNMI_HRX_MULTICAST
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|HighVal
)paren
suffix:semicolon
id|LowVal
op_add_assign
id|HighVal
suffix:semicolon
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|SK_PNMI_HRX_UNICAST
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|HighVal
)paren
suffix:semicolon
id|LowVal
op_add_assign
id|HighVal
suffix:semicolon
)brace
r_else
(brace
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
)brace
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HTX_OCTET
suffix:colon
r_case
id|SK_PNMI_HRX_OCTET
suffix:colon
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|HighVal
)paren
suffix:semicolon
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
op_plus
l_int|1
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HTX_BURST
suffix:colon
r_case
id|SK_PNMI_HTX_EXCESS_DEF
suffix:colon
r_case
id|SK_PNMI_HTX_CARRIER
suffix:colon
multiline_comment|/* Not supported by GMAC */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_GMAC
)paren
(brace
r_return
(paren
id|Val
)paren
suffix:semicolon
)brace
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HTX_MACC
suffix:colon
multiline_comment|/* GMAC only supports PAUSE MAC control frames */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_GMAC
)paren
(brace
id|HelpIndex
op_assign
id|SK_PNMI_HTX_PMACC
suffix:semicolon
)brace
r_else
(brace
id|HelpIndex
op_assign
id|StatIndex
suffix:semicolon
)brace
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|HelpIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HTX_COL
suffix:colon
r_case
id|SK_PNMI_HRX_UNDERSIZE
suffix:colon
multiline_comment|/* Not supported by XMAC */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
r_return
(paren
id|Val
)paren
suffix:semicolon
)brace
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HTX_DEFFERAL
suffix:colon
multiline_comment|/* Not supported by GMAC */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_GMAC
)paren
(brace
r_return
(paren
id|Val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * XMAC counts frames with deferred transmission&n;&t;&t; * even in full-duplex mode.&n;&t;&t; *&n;&t;&t; * In full-duplex mode the counter remains constant!&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|pPrt-&gt;PLinkModeStatus
op_eq
id|SK_LMODE_STAT_AUTOFULL
)paren
op_logical_or
(paren
id|pPrt-&gt;PLinkModeStatus
op_eq
id|SK_LMODE_STAT_FULL
)paren
)paren
(brace
id|LowVal
op_assign
l_int|0
suffix:semicolon
id|HighVal
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise get contents of hardware register */
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX_BADOCTET
suffix:colon
multiline_comment|/* Not supported by XMAC */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
r_return
(paren
id|Val
)paren
suffix:semicolon
)brace
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|HighVal
)paren
suffix:semicolon
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
op_plus
l_int|1
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HTX_OCTETLOW
suffix:colon
r_case
id|SK_PNMI_HRX_OCTETLOW
suffix:colon
r_case
id|SK_PNMI_HRX_BADOCTETLOW
suffix:colon
r_return
(paren
id|Val
)paren
suffix:semicolon
r_case
id|SK_PNMI_HRX_LONGFRAMES
suffix:colon
multiline_comment|/* For XMAC the SW counter is managed by PNMI */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_XMAC
)paren
(brace
r_return
(paren
id|pPnmiPrt-&gt;StatRxLongFrameCts
)paren
suffix:semicolon
)brace
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX_TOO_LONG
suffix:colon
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
id|Val
op_assign
(paren
(paren
(paren
id|SK_U64
)paren
id|HighVal
op_lshift
l_int|32
)paren
op_or
(paren
id|SK_U64
)paren
id|LowVal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_GMAC
)paren
(brace
multiline_comment|/* For GMAC the SW counter is additionally managed by PNMI */
id|Val
op_add_assign
id|pPnmiPrt-&gt;StatRxFrameTooLongCts
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Frames longer than IEEE 802.3 frame max size are counted&n;&t;&t;&t; * by XMAC in frame_too_long counter even reception of long&n;&t;&t;&t; * frames was enabled and the frame was correct.&n;&t;&t;&t; * So correct the value by subtracting RxLongFrame counter.&n;&t;&t;&t; */
id|Val
op_sub_assign
id|pPnmiPrt-&gt;StatRxLongFrameCts
suffix:semicolon
)brace
id|LowVal
op_assign
(paren
id|SK_U32
)paren
id|Val
suffix:semicolon
id|HighVal
op_assign
(paren
id|SK_U32
)paren
(paren
id|Val
op_rshift
l_int|32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX_SHORTS
suffix:colon
multiline_comment|/* Not supported by GMAC */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_GMAC
)paren
(brace
multiline_comment|/* GM_RXE_FRAG?? */
r_return
(paren
id|Val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * XMAC counts short frame errors even if link down (#10620)&n;&t;&t; *&n;&t;&t; * If link-down the counter remains constant&n;&t;&t; */
r_if
c_cond
(paren
id|pPrt-&gt;PLinkModeStatus
op_ne
id|SK_LMODE_STAT_UNKNOWN
)paren
(brace
multiline_comment|/* Otherwise get incremental difference */
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
id|Val
op_assign
(paren
(paren
(paren
id|SK_U64
)paren
id|HighVal
op_lshift
l_int|32
)paren
op_or
(paren
id|SK_U64
)paren
id|LowVal
)paren
suffix:semicolon
id|Val
op_sub_assign
id|pPnmiPrt-&gt;RxShortZeroMark
suffix:semicolon
id|LowVal
op_assign
(paren
id|SK_U32
)paren
id|Val
suffix:semicolon
id|HighVal
op_assign
(paren
id|SK_U32
)paren
(paren
id|Val
op_rshift
l_int|32
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX_MACC
suffix:colon
r_case
id|SK_PNMI_HRX_MACC_UNKWN
suffix:colon
r_case
id|SK_PNMI_HRX_BURST
suffix:colon
r_case
id|SK_PNMI_HRX_MISSED
suffix:colon
r_case
id|SK_PNMI_HRX_FRAMING
suffix:colon
r_case
id|SK_PNMI_HRX_CARRIER
suffix:colon
r_case
id|SK_PNMI_HRX_IRLENGTH
suffix:colon
r_case
id|SK_PNMI_HRX_SYMBOL
suffix:colon
r_case
id|SK_PNMI_HRX_CEXT
suffix:colon
multiline_comment|/* Not supported by GMAC */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_GMAC
)paren
(brace
r_return
(paren
id|Val
)paren
suffix:semicolon
)brace
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX_PMACC_ERR
suffix:colon
multiline_comment|/* For GMAC the SW counter is managed by PNMI */
r_if
c_cond
(paren
id|MacType
op_eq
id|SK_MAC_GMAC
)paren
(brace
r_return
(paren
id|pPnmiPrt-&gt;StatRxPMaccErr
)paren
suffix:semicolon
)brace
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* SW counter managed by PNMI */
r_case
id|SK_PNMI_HTX_SYNC
suffix:colon
id|LowVal
op_assign
(paren
id|SK_U32
)paren
id|pPnmiPrt-&gt;StatSyncCts
suffix:semicolon
id|HighVal
op_assign
(paren
id|SK_U32
)paren
(paren
id|pPnmiPrt-&gt;StatSyncCts
op_rshift
l_int|32
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* SW counter managed by PNMI */
r_case
id|SK_PNMI_HTX_SYNC_OCTET
suffix:colon
id|LowVal
op_assign
(paren
id|SK_U32
)paren
id|pPnmiPrt-&gt;StatSyncOctetsCts
suffix:semicolon
id|HighVal
op_assign
(paren
id|SK_U32
)paren
(paren
id|pPnmiPrt-&gt;StatSyncOctetsCts
op_rshift
l_int|32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PNMI_HRX_FCS
suffix:colon
multiline_comment|/*&n;&t;&t; * Broadcom filters FCS errors and counts it in&n;&t;&t; * Receive Error Counter register&n;&t;&t; */
r_if
c_cond
(paren
id|pPrt-&gt;PhyType
op_eq
id|SK_PHY_BCOM
)paren
(brace
multiline_comment|/* do not read while not initialized (PHY_READ hangs!)*/
r_if
c_cond
(paren
id|pPrt-&gt;PState
op_ne
id|SK_PRT_RESET
)paren
(brace
id|SkXmPhyRead
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|PHY_BCOM_RE_CTR
comma
op_amp
id|Word
)paren
suffix:semicolon
id|LowVal
op_assign
id|Word
suffix:semicolon
)brace
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
)brace
r_else
(brace
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(paren
r_void
)paren
id|pFnMac
op_member_access_from_pointer
id|pFnMacStatistic
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|StatAddr
(braket
id|StatIndex
)braket
(braket
id|MacType
)braket
dot
id|Reg
comma
op_amp
id|LowVal
)paren
suffix:semicolon
id|HighVal
op_assign
id|pPnmiPrt-&gt;CounterHigh
(braket
id|StatIndex
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
id|Val
op_assign
(paren
(paren
(paren
id|SK_U64
)paren
id|HighVal
op_lshift
l_int|32
)paren
op_or
(paren
id|SK_U64
)paren
id|LowVal
)paren
suffix:semicolon
multiline_comment|/* Correct value because of possible XMAC reset. XMAC Errata #2 */
id|Val
op_add_assign
id|pPnmiPrt-&gt;CounterOffset
(braket
id|StatIndex
)braket
suffix:semicolon
r_return
(paren
id|Val
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * ResetCounter - Set all counters and timestamps to zero&n; *&n; * Description:&n; *&t;Notifies other common modules which store statistic data to&n; *&t;reset their counters and finally reset our own counters.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|ResetCounter
id|PNMI_STATIC
r_void
id|ResetCounter
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
id|SK_U32
id|NetIndex
)paren
(brace
r_int
r_int
id|PhysPortIndex
suffix:semicolon
id|SK_EVPARA
id|EventParam
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|EventParam
comma
l_int|0
comma
r_sizeof
(paren
id|EventParam
)paren
)paren
suffix:semicolon
multiline_comment|/* Notify sensor module */
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_I2C
comma
id|SK_I2CEV_CLEAR
comma
id|EventParam
)paren
suffix:semicolon
multiline_comment|/* Notify RLMT module */
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|NetIndex
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
op_minus
l_int|1
suffix:semicolon
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_RLMT
comma
id|SK_RLMT_STATS_CLEAR
comma
id|EventParam
)paren
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Notify SIRQ module */
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_HWAC
comma
id|SK_HWEV_CLEAR_STAT
comma
id|EventParam
)paren
suffix:semicolon
multiline_comment|/* Notify CSUM module */
macro_line|#ifdef SK_USE_CSUM
id|EventParam.Para32
(braket
l_int|0
)braket
op_assign
id|NetIndex
suffix:semicolon
id|EventParam.Para32
(braket
l_int|1
)braket
op_assign
(paren
id|SK_U32
)paren
op_minus
l_int|1
suffix:semicolon
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_CSUM
comma
id|SK_CSUM_EVENT_CLEAR_PROTO_STATS
comma
id|EventParam
)paren
suffix:semicolon
macro_line|#endif /* SK_USE_CSUM */
multiline_comment|/* Clear XMAC statistic */
r_for
c_loop
(paren
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|PhysPortIndex
OL
(paren
r_int
r_int
)paren
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
(paren
r_void
)paren
id|pAC-&gt;GIni.GIFunc
dot
id|pFnMacResetCounter
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
)paren
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterHigh
)paren
)paren
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterOffset
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|CounterOffset
)paren
)paren
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatSyncCts
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatSyncCts
)paren
)paren
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatSyncOctetsCts
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatSyncOctetsCts
)paren
)paren
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatRxLongFrameCts
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatRxLongFrameCts
)paren
)paren
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatRxFrameTooLongCts
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatRxFrameTooLongCts
)paren
)paren
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatRxPMaccErr
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.Port
(braket
id|PhysPortIndex
)braket
dot
id|StatRxPMaccErr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear local statistics&n;&t; */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.VirtualCounterOffset
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.VirtualCounterOffset
)paren
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeTime
op_assign
l_int|0
suffix:semicolon
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|pAC-&gt;Pnmi.RlmtChangeEstimate.EstValue
(braket
l_int|0
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|pAC-&gt;Pnmi.RlmtChangeEstimate.EstValue
)paren
)paren
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeEstimate.EstValueIndex
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.RlmtChangeEstimate.Estimate
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxSwQueueMax
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxRetryCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|RxIntrCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxIntrCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|RxNoBufCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxNoBufCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|TxUsedDescrNo
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|RxDeliveredCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|RxOctetsDeliveredCts
op_assign
l_int|0
suffix:semicolon
id|pAC-&gt;Pnmi.Port
(braket
id|NetIndex
)braket
dot
id|ErrRecoveryCts
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * GetTrapEntry - Get an entry in the trap buffer&n; *&n; * Description:&n; *&t;The trap buffer stores various events. A user application somehow&n; *&t;gets notified that an event occured and retrieves the trap buffer&n; *&t;contens (or simply polls the buffer). The buffer is organized as&n; *&t;a ring which stores the newest traps at the beginning. The oldest&n; *&t;traps are overwritten by the newest ones. Each trap entry has a&n; *&t;unique number, so that applications may detect new trap entries.&n; *&n; * Returns:&n; *&t;A pointer to the trap entry&n; */
DECL|function|GetTrapEntry
id|PNMI_STATIC
r_char
op_star
id|GetTrapEntry
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_U32
id|TrapId
comma
multiline_comment|/* SNMP ID of the trap */
r_int
r_int
id|Size
)paren
multiline_comment|/* Space needed for trap entry */
(brace
r_int
r_int
id|BufPad
op_assign
id|pAC-&gt;Pnmi.TrapBufPad
suffix:semicolon
r_int
r_int
id|BufFree
op_assign
id|pAC-&gt;Pnmi.TrapBufFree
suffix:semicolon
r_int
r_int
id|Beg
op_assign
id|pAC-&gt;Pnmi.TrapQueueBeg
suffix:semicolon
r_int
r_int
id|End
op_assign
id|pAC-&gt;Pnmi.TrapQueueEnd
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
op_amp
id|pAC-&gt;Pnmi.TrapBuf
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|Wrap
suffix:semicolon
r_int
r_int
id|NeededSpace
suffix:semicolon
r_int
r_int
id|EntrySize
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|SK_U64
id|Val64
suffix:semicolon
multiline_comment|/* Last byte of entry will get a copy of the entry length */
id|Size
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate needed buffer space */
r_if
c_cond
(paren
id|Beg
op_ge
id|Size
)paren
(brace
id|NeededSpace
op_assign
id|Size
suffix:semicolon
id|Wrap
op_assign
id|SK_FALSE
suffix:semicolon
)brace
r_else
(brace
id|NeededSpace
op_assign
id|Beg
op_plus
id|Size
suffix:semicolon
id|Wrap
op_assign
id|SK_TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check if enough buffer space is provided. Otherwise&n;&t; * free some entries. Leave one byte space between begin&n;&t; * and end of buffer to make it possible to detect whether&n;&t; * the buffer is full or empty&n;&t; */
r_while
c_loop
(paren
id|BufFree
OL
id|NeededSpace
op_plus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|End
op_eq
l_int|0
)paren
(brace
id|End
op_assign
id|SK_PNMI_TRAP_QUEUE_LEN
suffix:semicolon
)brace
id|EntrySize
op_assign
(paren
r_int
r_int
)paren
op_star
(paren
(paren
r_int
r_char
op_star
)paren
id|pBuf
op_plus
id|End
op_minus
l_int|1
)paren
suffix:semicolon
id|BufFree
op_add_assign
id|EntrySize
suffix:semicolon
id|End
op_sub_assign
id|EntrySize
suffix:semicolon
macro_line|#ifdef DEBUG
id|SK_MEMSET
c_func
(paren
id|pBuf
op_plus
id|End
comma
(paren
r_char
)paren
(paren
op_minus
l_int|1
)paren
comma
id|EntrySize
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
r_if
c_cond
(paren
id|End
op_eq
id|BufPad
)paren
(brace
macro_line|#ifdef DEBUG
id|SK_MEMSET
c_func
(paren
id|pBuf
comma
(paren
r_char
)paren
(paren
op_minus
l_int|1
)paren
comma
id|End
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
id|BufFree
op_add_assign
id|End
suffix:semicolon
id|End
op_assign
l_int|0
suffix:semicolon
id|BufPad
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Insert new entry as first entry. Newest entries are&n;&t; * stored at the beginning of the queue.&n;&t; */
r_if
c_cond
(paren
id|Wrap
)paren
(brace
id|BufPad
op_assign
id|Beg
suffix:semicolon
id|Beg
op_assign
id|SK_PNMI_TRAP_QUEUE_LEN
op_minus
id|Size
suffix:semicolon
)brace
r_else
(brace
id|Beg
op_assign
id|Beg
op_minus
id|Size
suffix:semicolon
)brace
id|BufFree
op_sub_assign
id|NeededSpace
suffix:semicolon
multiline_comment|/* Save the current offsets */
id|pAC-&gt;Pnmi.TrapQueueBeg
op_assign
id|Beg
suffix:semicolon
id|pAC-&gt;Pnmi.TrapQueueEnd
op_assign
id|End
suffix:semicolon
id|pAC-&gt;Pnmi.TrapBufPad
op_assign
id|BufPad
suffix:semicolon
id|pAC-&gt;Pnmi.TrapBufFree
op_assign
id|BufFree
suffix:semicolon
multiline_comment|/* Initialize the trap entry */
op_star
(paren
id|pBuf
op_plus
id|Beg
op_plus
id|Size
op_minus
l_int|1
)paren
op_assign
(paren
r_char
)paren
id|Size
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Beg
)paren
op_assign
(paren
r_char
)paren
id|Size
suffix:semicolon
id|Val32
op_assign
(paren
id|pAC-&gt;Pnmi.TrapUnique
)paren
op_increment
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Beg
op_plus
l_int|1
comma
id|Val32
)paren
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Beg
op_plus
l_int|1
op_plus
r_sizeof
(paren
id|SK_U32
)paren
comma
id|TrapId
)paren
suffix:semicolon
id|Val64
op_assign
id|SK_PNMI_HUNDREDS_SEC
c_func
(paren
id|SkOsGetTime
c_func
(paren
id|pAC
)paren
)paren
suffix:semicolon
id|SK_PNMI_STORE_U64
c_func
(paren
id|pBuf
op_plus
id|Beg
op_plus
l_int|1
op_plus
l_int|2
op_star
r_sizeof
(paren
id|SK_U32
)paren
comma
id|Val64
)paren
suffix:semicolon
r_return
(paren
id|pBuf
op_plus
id|Beg
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * CopyTrapQueue - Copies the trap buffer for the TRAP OID&n; *&n; * Description:&n; *&t;On a query of the TRAP OID the trap buffer contents will be&n; *&t;copied continuously to the request buffer, which must be large&n; *&t;enough. No length check is performed.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|CopyTrapQueue
id|PNMI_STATIC
r_void
id|CopyTrapQueue
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
r_char
op_star
id|pDstBuf
)paren
multiline_comment|/* Buffer to which the queued traps will be copied */
(brace
r_int
r_int
id|BufPad
op_assign
id|pAC-&gt;Pnmi.TrapBufPad
suffix:semicolon
r_int
r_int
id|Trap
op_assign
id|pAC-&gt;Pnmi.TrapQueueBeg
suffix:semicolon
r_int
r_int
id|End
op_assign
id|pAC-&gt;Pnmi.TrapQueueEnd
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
op_amp
id|pAC-&gt;Pnmi.TrapBuf
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|Len
suffix:semicolon
r_int
r_int
id|DstOff
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|Trap
op_ne
id|End
)paren
(brace
id|Len
op_assign
(paren
r_int
r_int
)paren
op_star
(paren
id|pBuf
op_plus
id|Trap
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Last byte containing a copy of the length will&n;&t;&t; * not be copied.&n;&t;&t; */
op_star
(paren
id|pDstBuf
op_plus
id|DstOff
)paren
op_assign
(paren
r_char
)paren
(paren
id|Len
op_minus
l_int|1
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pDstBuf
op_plus
id|DstOff
op_plus
l_int|1
comma
id|pBuf
op_plus
id|Trap
op_plus
l_int|1
comma
id|Len
op_minus
l_int|2
)paren
suffix:semicolon
id|DstOff
op_add_assign
id|Len
op_minus
l_int|1
suffix:semicolon
id|Trap
op_add_assign
id|Len
suffix:semicolon
r_if
c_cond
(paren
id|Trap
op_eq
id|SK_PNMI_TRAP_QUEUE_LEN
)paren
(brace
id|Trap
op_assign
id|BufPad
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*****************************************************************************&n; *&n; * GetTrapQueueLen - Get the length of the trap buffer&n; *&n; * Description:&n; *&t;Evaluates the number of currently stored traps and the needed&n; *&t;buffer size to retrieve them.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|GetTrapQueueLen
id|PNMI_STATIC
r_void
id|GetTrapQueueLen
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Length in Bytes of all queued traps */
r_int
r_int
op_star
id|pEntries
)paren
multiline_comment|/* Returns number of trapes stored in queue */
(brace
r_int
r_int
id|BufPad
op_assign
id|pAC-&gt;Pnmi.TrapBufPad
suffix:semicolon
r_int
r_int
id|Trap
op_assign
id|pAC-&gt;Pnmi.TrapQueueBeg
suffix:semicolon
r_int
r_int
id|End
op_assign
id|pAC-&gt;Pnmi.TrapQueueEnd
suffix:semicolon
r_char
op_star
id|pBuf
op_assign
op_amp
id|pAC-&gt;Pnmi.TrapBuf
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|Len
suffix:semicolon
r_int
r_int
id|Entries
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|TotalLen
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|Trap
op_ne
id|End
)paren
(brace
id|Len
op_assign
(paren
r_int
r_int
)paren
op_star
(paren
id|pBuf
op_plus
id|Trap
)paren
suffix:semicolon
id|TotalLen
op_add_assign
id|Len
op_minus
l_int|1
suffix:semicolon
id|Entries
op_increment
suffix:semicolon
id|Trap
op_add_assign
id|Len
suffix:semicolon
r_if
c_cond
(paren
id|Trap
op_eq
id|SK_PNMI_TRAP_QUEUE_LEN
)paren
(brace
id|Trap
op_assign
id|BufPad
suffix:semicolon
)brace
)brace
op_star
id|pEntries
op_assign
id|Entries
suffix:semicolon
op_star
id|pLen
op_assign
id|TotalLen
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * QueueSimpleTrap - Store a simple trap to the trap buffer&n; *&n; * Description:&n; *&t;A simple trap is a trap with now additional data. It consists&n; *&t;simply of a trap code.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|QueueSimpleTrap
id|PNMI_STATIC
r_void
id|QueueSimpleTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_U32
id|TrapId
)paren
multiline_comment|/* Type of sensor trap */
(brace
id|GetTrapEntry
c_func
(paren
id|pAC
comma
id|TrapId
comma
id|SK_PNMI_TRAP_SIMPLE_LEN
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * QueueSensorTrap - Stores a sensor trap in the trap buffer&n; *&n; * Description:&n; *&t;Gets an entry in the trap buffer and fills it with sensor related&n; *&t;data.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|QueueSensorTrap
id|PNMI_STATIC
r_void
id|QueueSensorTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_U32
id|TrapId
comma
multiline_comment|/* Type of sensor trap */
r_int
r_int
id|SensorIndex
)paren
multiline_comment|/* Index of sensor which caused the trap */
(brace
r_char
op_star
id|pBuf
suffix:semicolon
r_int
r_int
id|Offset
suffix:semicolon
r_int
r_int
id|DescrLen
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
multiline_comment|/* Get trap buffer entry */
id|DescrLen
op_assign
id|SK_STRLEN
c_func
(paren
id|pAC-&gt;I2c.SenTable
(braket
id|SensorIndex
)braket
dot
id|SenDesc
)paren
suffix:semicolon
id|pBuf
op_assign
id|GetTrapEntry
c_func
(paren
id|pAC
comma
id|TrapId
comma
id|SK_PNMI_TRAP_SENSOR_LEN_BASE
op_plus
id|DescrLen
)paren
suffix:semicolon
id|Offset
op_assign
id|SK_PNMI_TRAP_SIMPLE_LEN
suffix:semicolon
multiline_comment|/* Store additionally sensor trap related data */
id|Val32
op_assign
id|OID_SKGE_SENSOR_INDEX
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|4
)paren
op_assign
l_int|4
suffix:semicolon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|SensorIndex
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|5
comma
id|Val32
)paren
suffix:semicolon
id|Offset
op_add_assign
l_int|9
suffix:semicolon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|OID_SKGE_SENSOR_DESCR
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|4
)paren
op_assign
(paren
r_char
)paren
id|DescrLen
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|5
comma
id|pAC-&gt;I2c.SenTable
(braket
id|SensorIndex
)braket
dot
id|SenDesc
comma
id|DescrLen
)paren
suffix:semicolon
id|Offset
op_add_assign
id|DescrLen
op_plus
l_int|5
suffix:semicolon
id|Val32
op_assign
id|OID_SKGE_SENSOR_TYPE
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|4
)paren
op_assign
l_int|1
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|5
)paren
op_assign
(paren
r_char
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|SensorIndex
)braket
dot
id|SenType
suffix:semicolon
id|Offset
op_add_assign
l_int|6
suffix:semicolon
id|Val32
op_assign
id|OID_SKGE_SENSOR_VALUE
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
comma
id|Val32
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|4
)paren
op_assign
l_int|4
suffix:semicolon
id|Val32
op_assign
(paren
id|SK_U32
)paren
id|pAC-&gt;I2c.SenTable
(braket
id|SensorIndex
)braket
dot
id|SenValue
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|Offset
op_plus
l_int|5
comma
id|Val32
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * QueueRlmtNewMacTrap - Store a port switch trap in the trap buffer&n; *&n; * Description:&n; *&t;Nothing further to explain.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|QueueRlmtNewMacTrap
id|PNMI_STATIC
r_void
id|QueueRlmtNewMacTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
r_int
r_int
id|ActiveMac
)paren
multiline_comment|/* Index (0..n) of the currently active port */
(brace
r_char
op_star
id|pBuf
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|pBuf
op_assign
id|GetTrapEntry
c_func
(paren
id|pAC
comma
id|OID_SKGE_TRAP_RLMT_CHANGE_PORT
comma
id|SK_PNMI_TRAP_RLMT_CHANGE_LEN
)paren
suffix:semicolon
id|Val32
op_assign
id|OID_SKGE_RLMT_PORT_ACTIVE
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|SK_PNMI_TRAP_SIMPLE_LEN
comma
id|Val32
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|SK_PNMI_TRAP_SIMPLE_LEN
op_plus
l_int|4
)paren
op_assign
l_int|1
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|SK_PNMI_TRAP_SIMPLE_LEN
op_plus
l_int|5
)paren
op_assign
(paren
r_char
)paren
id|ActiveMac
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * QueueRlmtPortTrap - Store port related RLMT trap to trap buffer&n; *&n; * Description:&n; *&t;Nothing further to explain.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|QueueRlmtPortTrap
id|PNMI_STATIC
r_void
id|QueueRlmtPortTrap
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_U32
id|TrapId
comma
multiline_comment|/* Type of RLMT port trap */
r_int
r_int
id|PortIndex
)paren
multiline_comment|/* Index of the port, which changed its state */
(brace
r_char
op_star
id|pBuf
suffix:semicolon
id|SK_U32
id|Val32
suffix:semicolon
id|pBuf
op_assign
id|GetTrapEntry
c_func
(paren
id|pAC
comma
id|TrapId
comma
id|SK_PNMI_TRAP_RLMT_PORT_LEN
)paren
suffix:semicolon
id|Val32
op_assign
id|OID_SKGE_RLMT_PORT_INDEX
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
op_plus
id|SK_PNMI_TRAP_SIMPLE_LEN
comma
id|Val32
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|SK_PNMI_TRAP_SIMPLE_LEN
op_plus
l_int|4
)paren
op_assign
l_int|1
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|SK_PNMI_TRAP_SIMPLE_LEN
op_plus
l_int|5
)paren
op_assign
(paren
r_char
)paren
id|PortIndex
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * CopyMac - Copies a MAC address&n; *&n; * Description:&n; *&t;Nothing further to explain.&n; *&n; * Returns:&n; *&t;Nothing&n; */
DECL|function|CopyMac
id|PNMI_STATIC
r_void
id|CopyMac
c_func
(paren
r_char
op_star
id|pDst
comma
multiline_comment|/* Pointer to destination buffer */
id|SK_MAC_ADDR
op_star
id|pMac
)paren
multiline_comment|/* Pointer of Source */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|SK_MAC_ADDR
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
(paren
id|pDst
op_plus
id|i
)paren
op_assign
id|pMac-&gt;a
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
macro_line|#ifdef SK_POWER_MGMT
multiline_comment|/*****************************************************************************&n; *&n; * PowerManagement - OID handler function of PowerManagement OIDs&n; *&n; * Description:&n; *&t;The code is simple. No description necessary.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                               exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|PowerManagement
id|PNMI_STATIC
r_int
id|PowerManagement
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* Get/PreSet/Set action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer to which to mgmt data will be retrieved */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode allways zero */
(brace
id|SK_U32
id|RetCode
op_assign
id|SK_PNMI_ERR_GENERAL
suffix:semicolon
multiline_comment|/*&n;&t; * Check instance. We only handle single instance variables&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
op_logical_and
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
multiline_comment|/* Check length */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_PNP_CAPABILITIES
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_PNP_CAPABILITIES
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_PNP_CAPABILITIES
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_PNP_SET_POWER
suffix:colon
r_case
id|OID_PNP_QUERY_POWER
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_DEVICE_POWER_STATE
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_DEVICE_POWER_STATE
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_PNP_ADD_WAKE_UP_PATTERN
suffix:colon
r_case
id|OID_PNP_REMOVE_WAKE_UP_PATTERN
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_PM_PACKET_PATTERN
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_PM_PACKET_PATTERN
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_PNP_ENABLE_WAKE_UP
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Perform action&n;&t; */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
multiline_comment|/*&n;&t;&t; * Get value&n;&t;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_PNP_CAPABILITIES
suffix:colon
id|RetCode
op_assign
id|SkPowerQueryPnPCapabilities
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_PNP_QUERY_POWER
suffix:colon
multiline_comment|/* The Windows DDK describes: An OID_PNP_QUERY_POWER requests&n;&t;&t;&t; the miniport to indicate whether it can transition its NIC&n;&t;&t;&t; to the low-power state.&n;&t;&t;&t; A miniport driver must always return NDIS_STATUS_SUCCESS&n;&t;&t;&t; to a query of OID_PNP_QUERY_POWER. */
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_DEVICE_POWER_STATE
)paren
suffix:semicolon
suffix:semicolon
id|RetCode
op_assign
id|SK_PNMI_ERR_OK
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* NDIS handles these OIDs as write-only.&n;&t;&t;&t; * So in case of get action the buffer with written length = 0&n;&t;&t;&t; * is returned&n;&t;&t;&t; */
r_case
id|OID_PNP_SET_POWER
suffix:colon
r_case
id|OID_PNP_ADD_WAKE_UP_PATTERN
suffix:colon
r_case
id|OID_PNP_REMOVE_WAKE_UP_PATTERN
suffix:colon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
id|RetCode
op_assign
id|SK_PNMI_ERR_NOT_SUPPORTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_PNP_ENABLE_WAKE_UP
suffix:colon
id|RetCode
op_assign
id|SkPowerGetEnableWakeUp
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|RetCode
op_assign
id|SK_PNMI_ERR_GENERAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|RetCode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Perform preset or set&n;&t; */
multiline_comment|/* POWER module does not support PRESET action */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_PNP_SET_POWER
suffix:colon
id|RetCode
op_assign
id|SkPowerSetPower
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_PNP_ADD_WAKE_UP_PATTERN
suffix:colon
id|RetCode
op_assign
id|SkPowerAddWakeUpPattern
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_PNP_REMOVE_WAKE_UP_PATTERN
suffix:colon
id|RetCode
op_assign
id|SkPowerRemoveWakeUpPattern
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_PNP_ENABLE_WAKE_UP
suffix:colon
id|RetCode
op_assign
id|SkPowerSetEnableWakeUp
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|RetCode
op_assign
id|SK_PNMI_ERR_READ_ONLY
suffix:semicolon
)brace
r_return
(paren
id|RetCode
)paren
suffix:semicolon
)brace
macro_line|#endif /* SK_POWER_MGMT */
macro_line|#ifdef SK_DIAG_SUPPORT
multiline_comment|/*****************************************************************************&n; *&n; * DiagActions - OID handler function of Diagnostic driver &n; *&n; * Description:&n; *&t;The code is simple. No description necessary.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|DiagActions
id|PNMI_STATIC
r_int
id|DiagActions
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (1..n) that is to be queried or -1 */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
id|SK_U32
id|RetCode
op_assign
id|SK_PNMI_ERR_GENERAL
suffix:semicolon
multiline_comment|/*&n;&t; * Check instance. We only handle single instance variables.&n;&t; */
r_if
c_cond
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
op_logical_and
id|Instance
op_ne
l_int|1
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check length.&n;&t; */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_DIAG_MODE
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|SK_ERR_LOG
c_func
(paren
id|pAC
comma
id|SK_ERRCL_SW
comma
id|SK_PNMI_ERR040
comma
id|SK_PNMI_ERR040MSG
)paren
suffix:semicolon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/* Perform action. */
multiline_comment|/* GET value. */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_DIAG_MODE
suffix:colon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|pAC-&gt;DiagModeActive
)paren
suffix:semicolon
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
id|RetCode
op_assign
id|SK_PNMI_ERR_OK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
id|RetCode
op_assign
id|SK_PNMI_ERR_GENERAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|RetCode
)paren
suffix:semicolon
)brace
multiline_comment|/* From here SET or PRESET value. */
multiline_comment|/* PRESET value is not supported. */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* SET value. */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_DIAG_MODE
suffix:colon
multiline_comment|/* Handle the SET. */
r_switch
c_cond
(paren
op_star
id|pBuf
)paren
(brace
multiline_comment|/* Enter the DIAG mode in the driver. */
r_case
l_int|1
suffix:colon
multiline_comment|/* If DiagMode is not active, we can enter it. */
r_if
c_cond
(paren
op_logical_neg
id|pAC-&gt;DiagModeActive
)paren
(brace
id|RetCode
op_assign
id|SkDrvEnterDiagMode
c_func
(paren
id|pAC
)paren
suffix:semicolon
)brace
r_else
(brace
id|RetCode
op_assign
id|SK_PNMI_ERR_GENERAL
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Leave the DIAG mode in the driver. */
r_case
l_int|0
suffix:colon
id|RetCode
op_assign
id|SkDrvLeaveDiagMode
c_func
(paren
id|pAC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|RetCode
op_assign
id|SK_PNMI_ERR_BAD_VALUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|RetCode
op_assign
id|SK_PNMI_ERR_GENERAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RetCode
op_eq
id|SK_PNMI_ERR_OK
)paren
(brace
op_star
id|pLen
op_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|RetCode
)paren
suffix:semicolon
)brace
macro_line|#endif /* SK_DIAG_SUPPORT */
multiline_comment|/*****************************************************************************&n; *&n; * Vct - OID handler function of  OIDs&n; *&n; * Description:&n; *&t;The code is simple. No description necessary.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was performed successfully.&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured.&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain&n; *&t;                         the correct data (e.g. a 32bit value is&n; *&t;                         needed, but a 16 bit value was passed).&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter).&n; *&t;SK_PNMI_ERR_READ_ONLY&t; Only the Get action is allowed.&n; *&n; */
DECL|function|Vct
id|PNMI_STATIC
r_int
id|Vct
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context */
id|SK_IOC
id|IoC
comma
multiline_comment|/* IO context handle */
r_int
id|Action
comma
multiline_comment|/* GET/PRESET/SET action */
id|SK_U32
id|Id
comma
multiline_comment|/* Object ID that is to be processed */
r_char
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* On call: pBuf buffer length. On return: used buffer */
id|SK_U32
id|Instance
comma
multiline_comment|/* Instance (-1,2..n) that is to be queried */
r_int
r_int
id|TableIndex
comma
multiline_comment|/* Index to the Id table */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
id|SK_PNMI_VCT
op_star
id|pVctBackupData
suffix:semicolon
id|SK_U32
id|LogPortMax
suffix:semicolon
id|SK_U32
id|PhysPortMax
suffix:semicolon
id|SK_U32
id|PhysPortIndex
suffix:semicolon
id|SK_U32
id|Limit
suffix:semicolon
id|SK_U32
id|Offset
suffix:semicolon
id|SK_BOOL
id|Link
suffix:semicolon
id|SK_U32
id|RetCode
op_assign
id|SK_PNMI_ERR_GENERAL
suffix:semicolon
r_int
id|i
suffix:semicolon
id|SK_EVPARA
id|Para
suffix:semicolon
id|SK_U32
id|CableLength
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the port indexes from the instance.&n;&t; */
id|PhysPortMax
op_assign
id|pAC-&gt;GIni.GIMacsFound
suffix:semicolon
id|LogPortMax
op_assign
id|SK_PNMI_PORT_PHYS2LOG
c_func
(paren
id|PhysPortMax
)paren
suffix:semicolon
multiline_comment|/* Dual net mode? */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|LogPortMax
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|Instance
op_ne
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* Check instance range. */
r_if
c_cond
(paren
(paren
id|Instance
OL
l_int|2
)paren
op_logical_or
(paren
id|Instance
OG
id|LogPortMax
)paren
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_UNKNOWN_INST
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.DualNetActiveFlag
op_eq
id|SK_TRUE
)paren
(brace
id|PhysPortIndex
op_assign
id|NetIndex
suffix:semicolon
)brace
r_else
(brace
id|PhysPortIndex
op_assign
id|Instance
op_minus
l_int|2
suffix:semicolon
)brace
id|Limit
op_assign
id|PhysPortIndex
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Instance == (SK_U32) (-1), get all Instances of that OID.&n;&t;&t; *&n;&t;&t; * Not implemented yet. May be used in future releases.&n;&t;&t; */
id|PhysPortIndex
op_assign
l_int|0
suffix:semicolon
id|Limit
op_assign
id|PhysPortMax
suffix:semicolon
)brace
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pPrt-&gt;PHWLinkUp
)paren
(brace
id|Link
op_assign
id|SK_TRUE
suffix:semicolon
)brace
r_else
(brace
id|Link
op_assign
id|SK_FALSE
suffix:semicolon
)brace
multiline_comment|/* Check MAC type */
r_if
c_cond
(paren
id|pPrt-&gt;PhyType
op_ne
id|SK_PHY_MARV_COPPER
)paren
(brace
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize backup data pointer. */
id|pVctBackupData
op_assign
op_amp
id|pAC-&gt;Pnmi.VctBackup
(braket
id|PhysPortIndex
)braket
suffix:semicolon
multiline_comment|/* Check action type */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_GET
)paren
(brace
multiline_comment|/* Check length */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_VCT_GET
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_PNMI_VCT
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_PNMI_VCT
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OID_SKGE_VCT_STATUS
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U8
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U8
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/* Get value */
id|Offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|PhysPortIndex
OL
id|Limit
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_VCT_GET
suffix:colon
r_if
c_cond
(paren
(paren
id|Link
op_eq
id|SK_FALSE
)paren
op_logical_and
(paren
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_amp
id|SK_PNMI_VCT_PENDING
)paren
)paren
(brace
id|RetCode
op_assign
id|SkGmCableDiagStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|SK_FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RetCode
op_eq
l_int|0
)paren
(brace
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_and_assign
op_complement
id|SK_PNMI_VCT_PENDING
suffix:semicolon
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_or_assign
(paren
id|SK_PNMI_VCT_NEW_VCT_DATA
op_or
id|SK_PNMI_VCT_TEST_DONE
)paren
suffix:semicolon
multiline_comment|/* Copy results for later use to PNMI struct. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pPrt-&gt;PMdiPairSts
(braket
id|i
)braket
op_eq
id|SK_PNMI_VCT_NORMAL_CABLE
)paren
(brace
r_if
c_cond
(paren
(paren
id|pPrt-&gt;PMdiPairLen
(braket
id|i
)braket
OG
l_int|35
)paren
op_logical_and
(paren
id|pPrt-&gt;PMdiPairLen
(braket
id|i
)braket
OL
l_int|0xff
)paren
)paren
(brace
id|pPrt-&gt;PMdiPairSts
(braket
id|i
)braket
op_assign
id|SK_PNMI_VCT_IMPEDANCE_MISMATCH
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|pPrt-&gt;PMdiPairLen
(braket
id|i
)braket
OG
l_int|35
)paren
op_logical_and
(paren
id|pPrt-&gt;PMdiPairLen
(braket
id|i
)braket
op_ne
l_int|0xff
)paren
)paren
(brace
id|CableLength
op_assign
l_int|1000
op_star
(paren
(paren
(paren
l_int|175
op_star
id|pPrt-&gt;PMdiPairLen
(braket
id|i
)braket
)paren
op_div
l_int|210
)paren
op_minus
l_int|28
)paren
suffix:semicolon
)brace
r_else
(brace
id|CableLength
op_assign
l_int|0
suffix:semicolon
)brace
id|pVctBackupData-&gt;PMdiPairLen
(braket
id|i
)braket
op_assign
id|CableLength
suffix:semicolon
id|pVctBackupData-&gt;PMdiPairSts
(braket
id|i
)braket
op_assign
id|pPrt-&gt;PMdiPairSts
(braket
id|i
)braket
suffix:semicolon
)brace
id|Para.Para32
(braket
l_int|0
)braket
op_assign
id|PhysPortIndex
suffix:semicolon
id|Para.Para32
(braket
l_int|1
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|SkEventQueue
c_func
(paren
id|pAC
comma
id|SKGE_DRV
comma
id|SK_DRV_PORT_RESET
comma
id|Para
)paren
suffix:semicolon
id|SkEventDispatcher
c_func
(paren
id|pAC
comma
id|IoC
)paren
suffix:semicolon
)brace
r_else
(brace
suffix:semicolon
multiline_comment|/* VCT test is running. */
)brace
)brace
multiline_comment|/* Get all results. */
id|CheckVctStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|Offset
comma
id|PhysPortIndex
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U8
)paren
suffix:semicolon
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|pPrt-&gt;PCableLen
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U8
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SK_PNMI_STORE_U32
c_func
(paren
(paren
id|pBuf
op_plus
id|Offset
)paren
comma
id|pVctBackupData-&gt;PMdiPairLen
(braket
id|i
)braket
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
(paren
id|pBuf
op_plus
id|Offset
)paren
op_assign
id|pVctBackupData-&gt;PMdiPairSts
(braket
id|i
)braket
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U8
)paren
suffix:semicolon
)brace
id|RetCode
op_assign
id|SK_PNMI_ERR_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OID_SKGE_VCT_STATUS
suffix:colon
id|CheckVctStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|Offset
comma
id|PhysPortIndex
)paren
suffix:semicolon
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U8
)paren
suffix:semicolon
id|RetCode
op_assign
id|SK_PNMI_ERR_OK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* for */
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_return
(paren
id|RetCode
)paren
suffix:semicolon
)brace
multiline_comment|/* if SK_PNMI_GET */
multiline_comment|/*&n;&t; * From here SET or PRESET action. Check if the passed&n;&t; * buffer length is plausible.&n;&t; */
multiline_comment|/* Check length */
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_VCT_SET
suffix:colon
r_if
c_cond
(paren
op_star
id|pLen
OL
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
)paren
(brace
op_star
id|pLen
op_assign
(paren
id|Limit
op_minus
id|PhysPortIndex
)paren
op_star
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_TOO_SHORT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Perform preset or set.&n;&t; */
multiline_comment|/* VCT does not support PRESET action. */
r_if
c_cond
(paren
id|Action
op_eq
id|SK_PNMI_PRESET
)paren
(brace
r_return
(paren
id|SK_PNMI_ERR_OK
)paren
suffix:semicolon
)brace
id|Offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|PhysPortIndex
OL
id|Limit
suffix:semicolon
id|PhysPortIndex
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|Id
)paren
(brace
r_case
id|OID_SKGE_VCT_SET
suffix:colon
multiline_comment|/* Start VCT test. */
r_if
c_cond
(paren
id|Link
op_eq
id|SK_FALSE
)paren
(brace
id|SkGeStopPort
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|SK_STOP_ALL
comma
id|SK_SOFT_RST
)paren
suffix:semicolon
id|RetCode
op_assign
id|SkGmCableDiagStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|SK_TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RetCode
op_eq
l_int|0
)paren
(brace
multiline_comment|/* RetCode: 0 =&gt; Start! */
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_or_assign
id|SK_PNMI_VCT_PENDING
suffix:semicolon
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_and_assign
op_complement
id|SK_PNMI_VCT_NEW_VCT_DATA
suffix:semicolon
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_and_assign
op_complement
id|SK_PNMI_VCT_LINK
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Start VCT timer counter.&n;&t;&t;&t;&t;&t; */
id|SK_MEMSET
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|Para
comma
l_int|0
comma
r_sizeof
(paren
id|Para
)paren
)paren
suffix:semicolon
id|Para.Para32
(braket
l_int|0
)braket
op_assign
id|PhysPortIndex
suffix:semicolon
id|Para.Para32
(braket
l_int|1
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|SkTimerStart
c_func
(paren
id|pAC
comma
id|IoC
comma
op_amp
id|pAC-&gt;Pnmi.VctTimeout
(braket
id|PhysPortIndex
)braket
dot
id|VctTimer
comma
l_int|4000000
comma
id|SKGE_PNMI
comma
id|SK_PNMI_EVT_VCT_RESET
comma
id|Para
)paren
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
(paren
id|pBuf
op_plus
id|Offset
)paren
comma
id|RetCode
)paren
suffix:semicolon
id|RetCode
op_assign
id|SK_PNMI_ERR_OK
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* RetCode: 2 =&gt; Running! */
id|SK_PNMI_STORE_U32
c_func
(paren
(paren
id|pBuf
op_plus
id|Offset
)paren
comma
id|RetCode
)paren
suffix:semicolon
id|RetCode
op_assign
id|SK_PNMI_ERR_OK
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* RetCode: 4 =&gt; Link! */
id|RetCode
op_assign
l_int|4
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
(paren
id|pBuf
op_plus
id|Offset
)paren
comma
id|RetCode
)paren
suffix:semicolon
id|RetCode
op_assign
id|SK_PNMI_ERR_OK
suffix:semicolon
)brace
id|Offset
op_add_assign
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|pLen
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|SK_PNMI_ERR_GENERAL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* for */
op_star
id|pLen
op_assign
id|Offset
suffix:semicolon
r_return
(paren
id|RetCode
)paren
suffix:semicolon
)brace
multiline_comment|/* Vct */
DECL|function|CheckVctStatus
id|PNMI_STATIC
r_void
id|CheckVctStatus
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
id|SK_IOC
id|IoC
comma
r_char
op_star
id|pBuf
comma
id|SK_U32
id|Offset
comma
id|SK_U32
id|PhysPortIndex
)paren
(brace
id|SK_GEPORT
op_star
id|pPrt
suffix:semicolon
id|SK_PNMI_VCT
op_star
id|pVctData
suffix:semicolon
id|SK_U32
id|RetCode
suffix:semicolon
id|pPrt
op_assign
op_amp
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
suffix:semicolon
id|pVctData
op_assign
(paren
id|SK_PNMI_VCT
op_star
)paren
(paren
id|pBuf
op_plus
id|Offset
)paren
suffix:semicolon
id|pVctData-&gt;VctStatus
op_assign
id|SK_PNMI_VCT_NONE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pPrt-&gt;PHWLinkUp
)paren
(brace
multiline_comment|/* Was a VCT test ever made before? */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_amp
id|SK_PNMI_VCT_TEST_DONE
)paren
(brace
r_if
c_cond
(paren
(paren
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_amp
id|SK_PNMI_VCT_LINK
)paren
)paren
(brace
id|pVctData-&gt;VctStatus
op_or_assign
id|SK_PNMI_VCT_OLD_VCT_DATA
suffix:semicolon
)brace
r_else
(brace
id|pVctData-&gt;VctStatus
op_or_assign
id|SK_PNMI_VCT_NEW_VCT_DATA
suffix:semicolon
)brace
)brace
multiline_comment|/* Check VCT test status. */
id|RetCode
op_assign
id|SkGmCableDiagStatus
c_func
(paren
id|pAC
comma
id|IoC
comma
id|PhysPortIndex
comma
id|SK_FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RetCode
op_eq
l_int|2
)paren
(brace
multiline_comment|/* VCT test is running. */
id|pVctData-&gt;VctStatus
op_or_assign
id|SK_PNMI_VCT_RUNNING
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* VCT data was copied to pAC here. Check PENDING state. */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_amp
id|SK_PNMI_VCT_PENDING
)paren
(brace
id|pVctData-&gt;VctStatus
op_or_assign
id|SK_PNMI_VCT_NEW_VCT_DATA
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pPrt-&gt;PCableLen
op_ne
l_int|0xff
)paren
(brace
multiline_comment|/* Old DSP value. */
id|pVctData-&gt;VctStatus
op_or_assign
id|SK_PNMI_VCT_OLD_DSP_DATA
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Was a VCT test ever made before? */
r_if
c_cond
(paren
id|pAC-&gt;Pnmi.VctStatus
(braket
id|PhysPortIndex
)braket
op_amp
id|SK_PNMI_VCT_TEST_DONE
)paren
(brace
id|pVctData-&gt;VctStatus
op_and_assign
op_complement
id|SK_PNMI_VCT_NEW_VCT_DATA
suffix:semicolon
id|pVctData-&gt;VctStatus
op_or_assign
id|SK_PNMI_VCT_OLD_VCT_DATA
suffix:semicolon
)brace
multiline_comment|/* DSP only valid in 100/1000 modes. */
r_if
c_cond
(paren
id|pAC-&gt;GIni.GP
(braket
id|PhysPortIndex
)braket
dot
id|PLinkSpeedUsed
op_ne
id|SK_LSPEED_STAT_10MBPS
)paren
(brace
id|pVctData-&gt;VctStatus
op_or_assign
id|SK_PNMI_VCT_NEW_DSP_DATA
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* CheckVctStatus */
multiline_comment|/*****************************************************************************&n; *&n; *      SkPnmiGenIoctl - Handles new generic PNMI IOCTL, calls the needed&n; *                       PNMI function depending on the subcommand and&n; *                       returns all data belonging to the complete database&n; *                       or OID request.&n; *&n; * Description:&n; *&t;Looks up the requested subcommand, calls the corresponding handler&n; *&t;function and passes all required parameters to it.&n; *&t;The function is called by the driver. It is needed to handle the new&n; *  generic PNMI IOCTL. This IOCTL is given to the driver and contains both&n; *  the OID and a subcommand to decide what kind of request has to be done.&n; *&n; * Returns:&n; *&t;SK_PNMI_ERR_OK           The request was successfully performed&n; *&t;SK_PNMI_ERR_GENERAL      A general severe internal error occured&n; *&t;SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to take&n; *&t;                         the data.&n; *&t;SK_PNMI_ERR_UNKNOWN_OID  The requested OID is unknown&n; *&t;SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn&squot;t&n; *                           exist (e.g. port instance 3 on a two port&n; *&t;                         adapter.&n; */
DECL|function|SkPnmiGenIoctl
r_int
id|SkPnmiGenIoctl
c_func
(paren
id|SK_AC
op_star
id|pAC
comma
multiline_comment|/* Pointer to adapter context struct */
id|SK_IOC
id|IoC
comma
multiline_comment|/* I/O context */
r_void
op_star
id|pBuf
comma
multiline_comment|/* Buffer used for the management data transfer */
r_int
r_int
op_star
id|pLen
comma
multiline_comment|/* Length of buffer */
id|SK_U32
id|NetIndex
)paren
multiline_comment|/* NetIndex (0..n), in single net mode always zero */
(brace
id|SK_I32
id|Mode
suffix:semicolon
multiline_comment|/* Store value of subcommand. */
id|SK_U32
id|Oid
suffix:semicolon
multiline_comment|/* Store value of OID. */
r_int
id|ReturnCode
suffix:semicolon
multiline_comment|/* Store return value to show status of PNMI action. */
r_int
id|HeaderLength
suffix:semicolon
multiline_comment|/* Length of desired action plus OID. */
id|ReturnCode
op_assign
id|SK_PNMI_ERR_GENERAL
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
op_amp
id|Mode
comma
id|pBuf
comma
r_sizeof
(paren
id|SK_I32
)paren
)paren
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
op_amp
id|Oid
comma
(paren
r_char
op_star
)paren
id|pBuf
op_plus
r_sizeof
(paren
id|SK_I32
)paren
comma
r_sizeof
(paren
id|SK_U32
)paren
)paren
suffix:semicolon
id|HeaderLength
op_assign
r_sizeof
(paren
id|SK_I32
)paren
op_plus
r_sizeof
(paren
id|SK_U32
)paren
suffix:semicolon
op_star
id|pLen
op_assign
op_star
id|pLen
op_minus
id|HeaderLength
suffix:semicolon
id|SK_MEMCPY
c_func
(paren
(paren
r_char
op_star
)paren
id|pBuf
op_plus
r_sizeof
(paren
id|SK_I32
)paren
comma
(paren
r_char
op_star
)paren
id|pBuf
op_plus
id|HeaderLength
comma
op_star
id|pLen
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|Mode
)paren
(brace
r_case
id|SK_GET_SINGLE_VAR
suffix:colon
id|ReturnCode
op_assign
id|SkPnmiGetVar
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Oid
comma
(paren
r_char
op_star
)paren
id|pBuf
op_plus
r_sizeof
(paren
id|SK_I32
)paren
comma
id|pLen
comma
(paren
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
comma
id|NetIndex
)paren
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|ReturnCode
)paren
suffix:semicolon
op_star
id|pLen
op_assign
op_star
id|pLen
op_plus
r_sizeof
(paren
id|SK_I32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PRESET_SINGLE_VAR
suffix:colon
id|ReturnCode
op_assign
id|SkPnmiPreSetVar
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Oid
comma
(paren
r_char
op_star
)paren
id|pBuf
op_plus
r_sizeof
(paren
id|SK_I32
)paren
comma
id|pLen
comma
(paren
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
comma
id|NetIndex
)paren
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|ReturnCode
)paren
suffix:semicolon
op_star
id|pLen
op_assign
op_star
id|pLen
op_plus
r_sizeof
(paren
id|SK_I32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_SET_SINGLE_VAR
suffix:colon
id|ReturnCode
op_assign
id|SkPnmiSetVar
c_func
(paren
id|pAC
comma
id|IoC
comma
id|Oid
comma
(paren
r_char
op_star
)paren
id|pBuf
op_plus
r_sizeof
(paren
id|SK_I32
)paren
comma
id|pLen
comma
(paren
(paren
id|SK_U32
)paren
(paren
op_minus
l_int|1
)paren
)paren
comma
id|NetIndex
)paren
suffix:semicolon
id|SK_PNMI_STORE_U32
c_func
(paren
id|pBuf
comma
id|ReturnCode
)paren
suffix:semicolon
op_star
id|pLen
op_assign
op_star
id|pLen
op_plus
r_sizeof
(paren
id|SK_I32
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_GET_FULL_MIB
suffix:colon
id|ReturnCode
op_assign
id|SkPnmiGetStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
comma
id|NetIndex
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_PRESET_FULL_MIB
suffix:colon
id|ReturnCode
op_assign
id|SkPnmiPreSetStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
comma
id|NetIndex
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SK_SET_FULL_MIB
suffix:colon
id|ReturnCode
op_assign
id|SkPnmiSetStruct
c_func
(paren
id|pAC
comma
id|IoC
comma
id|pBuf
comma
id|pLen
comma
id|NetIndex
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
(paren
id|ReturnCode
)paren
suffix:semicolon
)brace
multiline_comment|/* SkGeIocGen */
eof
