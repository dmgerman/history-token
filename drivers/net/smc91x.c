multiline_comment|/*&n; * smc91x.c&n; * This is a driver for SMSC&squot;s 91C9x/91C1xx single-chip Ethernet devices.&n; *&n; * Copyright (C) 1996 by Erik Stahlman&n; * Copyright (C) 2001 Standard Microsystems Corporation&n; *&t;Developed by Simple Network Magic Corporation&n; * Copyright (C) 2003 Monta Vista Software, Inc.&n; *&t;Unified SMC91x driver by Nicolas Pitre&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; * Arguments:&n; * &t;io&t;= for the base address&n; *&t;irq&t;= for the IRQ&n; *&t;nowait&t;= 0 for normal wait states, 1 eliminates additional wait states&n; *&n; * original author:&n; * &t;Erik Stahlman &lt;erik@vt.edu&gt;&n; *&n; * hardware multicast code:&n; *    Peter Cammaert &lt;pc@denkart.be&gt;&n; *&n; * contributors:&n; * &t;Daris A Nevil &lt;dnevil@snmc.com&gt;&n; *      Nicolas Pitre &lt;nico@cam.org&gt;&n; *&t;Russell King &lt;rmk@arm.linux.org.uk&gt;&n; *&n; * History:&n; *   08/20/00  Arnaldo Melo       fix kfree(skb) in smc_hardware_send_packet&n; *   12/15/00  Christian Jullien  fix &quot;Warning: kfree_skb on hard IRQ&quot;&n; *   03/16/01  Daris A Nevil      modified smc9194.c for use with LAN91C111&n; *   08/22/01  Scott Anderson     merge changes from smc9194 to smc91111&n; *   08/21/01  Pramod B Bhardwaj  added support for RevB of LAN91C111&n; *   12/20/01  Jeff Sutherland    initial port to Xscale PXA with DMA support&n; *   04/07/03  Nicolas Pitre      unified SMC91x driver, killed irq races,&n; *                                more bus abstraction, big cleanup, etc.&n; *   29/09/03  Russell King       - add driver model support&n; *                                - ethtool support&n; *                                - convert to use generic MII interface&n; *                                - add link up/down notification&n; *                                - don&squot;t try to handle full negotiation in&n; *                                  smc_phy_configure&n; *                                - clean up (and fix stack overrun) in PHY&n; *                                  MII read/write functions&n; *   22/09/04  Nicolas Pitre      big update (see commit log for details)&n; */
DECL|variable|version
r_static
r_const
r_char
id|version
(braket
)braket
op_assign
l_string|&quot;smc91x.c: v1.1, sep 22 2004 by Nicolas Pitre &lt;nico@cam.org&gt;&bslash;n&quot;
suffix:semicolon
multiline_comment|/* Debugging level */
macro_line|#ifndef SMC_DEBUG
DECL|macro|SMC_DEBUG
mdefine_line|#define SMC_DEBUG&t;&t;0
macro_line|#endif
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/ethtool.h&gt;
macro_line|#include &lt;linux/mii.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;smc91x.h&quot;
macro_line|#ifdef CONFIG_ISA
multiline_comment|/*&n; * the LAN91C111 can be at any of the following port addresses.  To change,&n; * for a slightly different card, you can add it to the array.  Keep in&n; * mind that the array must end in zero.&n; */
DECL|variable|__initdata
r_static
r_int
r_int
id|smc_portlist
(braket
)braket
id|__initdata
op_assign
(brace
l_int|0x200
comma
l_int|0x220
comma
l_int|0x240
comma
l_int|0x260
comma
l_int|0x280
comma
l_int|0x2A0
comma
l_int|0x2C0
comma
l_int|0x2E0
comma
l_int|0x300
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0x360
comma
l_int|0x380
comma
l_int|0x3A0
comma
l_int|0x3C0
comma
l_int|0x3E0
comma
l_int|0
)brace
suffix:semicolon
macro_line|#ifndef SMC_IOADDR
DECL|macro|SMC_IOADDR
macro_line|# define SMC_IOADDR&t;&t;-1
macro_line|#endif
DECL|variable|io
r_static
r_int
r_int
id|io
op_assign
id|SMC_IOADDR
suffix:semicolon
id|module_param
c_func
(paren
id|io
comma
id|ulong
comma
l_int|0400
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|io
comma
l_string|&quot;I/O base address&quot;
)paren
suffix:semicolon
macro_line|#ifndef SMC_IRQ
DECL|macro|SMC_IRQ
macro_line|# define SMC_IRQ&t;&t;-1
macro_line|#endif
DECL|variable|irq
r_static
r_int
id|irq
op_assign
id|SMC_IRQ
suffix:semicolon
id|module_param
c_func
(paren
id|irq
comma
r_int
comma
l_int|0400
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|irq
comma
l_string|&quot;IRQ number&quot;
)paren
suffix:semicolon
macro_line|#endif  /* CONFIG_ISA */
macro_line|#ifndef SMC_NOWAIT
DECL|macro|SMC_NOWAIT
macro_line|# define SMC_NOWAIT&t;&t;0
macro_line|#endif
DECL|variable|nowait
r_static
r_int
id|nowait
op_assign
id|SMC_NOWAIT
suffix:semicolon
id|module_param
c_func
(paren
id|nowait
comma
r_int
comma
l_int|0400
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|nowait
comma
l_string|&quot;set to 1 for no wait state&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Transmit timeout, default 5 seconds.&n; */
DECL|variable|watchdog
r_static
r_int
id|watchdog
op_assign
l_int|5000
suffix:semicolon
id|module_param
c_func
(paren
id|watchdog
comma
r_int
comma
l_int|0400
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|watchdog
comma
l_string|&quot;transmit timeout in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * The internal workings of the driver.  If you are changing anything&n; * here with the SMC stuff, you should have the datasheet and know&n; * what you are doing.&n; */
DECL|macro|CARDNAME
mdefine_line|#define CARDNAME &quot;smc91x&quot;
multiline_comment|/*&n; * Use power-down feature of the chip&n; */
DECL|macro|POWER_DOWN
mdefine_line|#define POWER_DOWN&t;&t;1
multiline_comment|/*&n; * Wait time for memory to be free.  This probably shouldn&squot;t be&n; * tuned that much, as waiting for this means nothing else happens&n; * in the system&n; */
DECL|macro|MEMORY_WAIT_TIME
mdefine_line|#define MEMORY_WAIT_TIME&t;16
multiline_comment|/*&n; * This selects whether TX packets are sent one by one to the SMC91x internal&n; * memory and throttled until transmission completes.  This may prevent&n; * RX overruns a litle by keeping much of the memory free for RX packets&n; * but to the expense of reduced TX throughput and increased IRQ overhead.&n; * Note this is not a cure for a too slow data bus or too high IRQ latency.&n; */
DECL|macro|THROTTLE_TX_PKTS
mdefine_line|#define THROTTLE_TX_PKTS&t;0
multiline_comment|/*&n; * The MII clock high/low times.  2x this number gives the MII clock period&n; * in microseconds. (was 50, but this gives 6.4ms for each MII transaction!)&n; */
DECL|macro|MII_DELAY
mdefine_line|#define MII_DELAY&t;&t;1
multiline_comment|/* store this information for the driver.. */
DECL|struct|smc_local
r_struct
id|smc_local
(brace
multiline_comment|/*&n;&t; * If I have to wait until memory is available to send a&n;&t; * packet, I will store the skbuff here, until I get the&n;&t; * desired memory.  Then, I&squot;ll send it out and free it.&n;&t; */
DECL|member|pending_tx_skb
r_struct
id|sk_buff
op_star
id|pending_tx_skb
suffix:semicolon
DECL|member|tx_task
r_struct
id|tasklet_struct
id|tx_task
suffix:semicolon
multiline_comment|/*&n;&t; * these are things that the kernel wants me to keep, so users&n;&t; * can find out semi-useless statistics of how well the card is&n;&t; * performing&n;&t; */
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
multiline_comment|/* version/revision of the SMC91x chip */
DECL|member|version
r_int
id|version
suffix:semicolon
multiline_comment|/* Contains the current active transmission mode */
DECL|member|tcr_cur_mode
r_int
id|tcr_cur_mode
suffix:semicolon
multiline_comment|/* Contains the current active receive mode */
DECL|member|rcr_cur_mode
r_int
id|rcr_cur_mode
suffix:semicolon
multiline_comment|/* Contains the current active receive/phy mode */
DECL|member|rpc_cur_mode
r_int
id|rpc_cur_mode
suffix:semicolon
DECL|member|ctl_rfduplx
r_int
id|ctl_rfduplx
suffix:semicolon
DECL|member|ctl_rspeed
r_int
id|ctl_rspeed
suffix:semicolon
DECL|member|msg_enable
id|u32
id|msg_enable
suffix:semicolon
DECL|member|phy_type
id|u32
id|phy_type
suffix:semicolon
DECL|member|mii
r_struct
id|mii_if_info
id|mii
suffix:semicolon
multiline_comment|/* work queue */
DECL|member|phy_configure
r_struct
id|work_struct
id|phy_configure
suffix:semicolon
DECL|member|work_pending
r_int
id|work_pending
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
macro_line|#ifdef SMC_USE_PXA_DMA
multiline_comment|/* DMA needs the physical address of the chip */
DECL|member|physaddr
id|u_long
id|physaddr
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
macro_line|#if SMC_DEBUG &gt; 0
DECL|macro|DBG
mdefine_line|#define DBG(n, args...)&t;&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (SMC_DEBUG &gt;= (n))&t;&t;&t;&bslash;&n;&t;&t;&t;printk(args);&t;&bslash;&n;&t;} while (0)
DECL|macro|PRINTK
mdefine_line|#define PRINTK(args...)   printk(args)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(n, args...)   do { } while(0)
DECL|macro|PRINTK
mdefine_line|#define PRINTK(args...)   printk(KERN_DEBUG args)
macro_line|#endif
macro_line|#if SMC_DEBUG &gt; 3
DECL|function|PRINT_PKT
r_static
r_void
id|PRINT_PKT
c_func
(paren
id|u_char
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|remainder
suffix:semicolon
r_int
id|lines
suffix:semicolon
id|lines
op_assign
id|length
op_div
l_int|16
suffix:semicolon
id|remainder
op_assign
id|length
op_mod
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lines
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|cur
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
l_int|0
suffix:semicolon
id|cur
OL
l_int|8
suffix:semicolon
id|cur
op_increment
)paren
(brace
id|u_char
id|a
comma
id|b
suffix:semicolon
id|a
op_assign
op_star
id|buf
op_increment
suffix:semicolon
id|b
op_assign
op_star
id|buf
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x%02x &quot;
comma
id|a
comma
id|b
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|remainder
op_div
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u_char
id|a
comma
id|b
suffix:semicolon
id|a
op_assign
op_star
id|buf
op_increment
suffix:semicolon
id|b
op_assign
op_star
id|buf
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x%02x &quot;
comma
id|a
comma
id|b
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|PRINT_PKT
mdefine_line|#define PRINT_PKT(x...)  do { } while(0)
macro_line|#endif
multiline_comment|/* this enables an interrupt in the interrupt mask register */
DECL|macro|SMC_ENABLE_INT
mdefine_line|#define SMC_ENABLE_INT(x) do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;unsigned char mask;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;spin_lock_irq(&amp;lp-&gt;lock);&t;&t;&t;&t;&t;&bslash;&n;&t;mask = SMC_GET_INT_MASK();&t;&t;&t;&t;&t;&bslash;&n;&t;mask |= (x);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;SMC_SET_INT_MASK(mask);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;spin_unlock_irq(&amp;lp-&gt;lock);&t;&t;&t;&t;&t;&bslash;&n;} while (0)
multiline_comment|/* this disables an interrupt from the interrupt mask register */
DECL|macro|SMC_DISABLE_INT
mdefine_line|#define SMC_DISABLE_INT(x) do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;unsigned char mask;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;spin_lock_irq(&amp;lp-&gt;lock);&t;&t;&t;&t;&t;&bslash;&n;&t;mask = SMC_GET_INT_MASK();&t;&t;&t;&t;&t;&bslash;&n;&t;mask &amp;= ~(x);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;SMC_SET_INT_MASK(mask);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;spin_unlock_irq(&amp;lp-&gt;lock);&t;&t;&t;&t;&t;&bslash;&n;} while (0)
multiline_comment|/*&n; * Wait while MMU is busy.  This is usually in the order of a few nanosecs&n; * if at all, but let&squot;s avoid deadlocking the system if the hardware&n; * decides to go south.&n; */
DECL|macro|SMC_WAIT_MMU_BUSY
mdefine_line|#define SMC_WAIT_MMU_BUSY() do {&t;&t;&t;&t;&t;&bslash;&n;&t;if (unlikely(SMC_GET_MMU_CMD() &amp; MC_BUSY)) {&t;&t;&t;&bslash;&n;&t;&t;unsigned long timeout = jiffies + 2;&t;&t;&t;&bslash;&n;&t;&t;while (SMC_GET_MMU_CMD() &amp; MC_BUSY) {&t;&t;&t;&bslash;&n;&t;&t;&t;if (time_after(jiffies, timeout)) {&t;&t;&bslash;&n;&t;&t;&t;&t;printk(&quot;%s: timeout %s line %d&bslash;n&quot;,&t;&bslash;&n;&t;&t;&t;&t;&t;dev-&gt;name, __FILE__, __LINE__);&t;&bslash;&n;&t;&t;&t;&t;break;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;cpu_relax();&t;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
multiline_comment|/*&n; * this does a soft reset on the device&n; */
DECL|function|smc_reset
r_static
r_void
id|smc_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|ctl
comma
id|cfg
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Disable all interrupts */
id|spin_lock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|SMC_SET_INT_MASK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This resets the registers mostly to defaults, but doesn&squot;t&n;&t; * affect EEPROM.  That seems unnecessary&n;&t; */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|SMC_SET_RCR
c_func
(paren
id|RCR_SOFTRST
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup the Configuration Register&n;&t; * This is necessary because the CONFIG_REG is not affected&n;&t; * by a soft reset&n;&t; */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|cfg
op_assign
id|CONFIG_DEFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * Setup for fast accesses if requested.  If the card/system&n;&t; * can&squot;t handle it then there will be no recovery except for&n;&t; * a hard reset or power cycle&n;&t; */
r_if
c_cond
(paren
id|nowait
)paren
id|cfg
op_or_assign
id|CONFIG_NO_WAIT
suffix:semicolon
multiline_comment|/*&n;&t; * Release from possible power-down state&n;&t; * Configuration register is not affected by Soft Reset&n;&t; */
id|cfg
op_or_assign
id|CONFIG_EPH_POWER_EN
suffix:semicolon
id|SMC_SET_CONFIG
c_func
(paren
id|cfg
)paren
suffix:semicolon
multiline_comment|/* this should pause enough for the chip to be happy */
multiline_comment|/*&n;&t; * elaborate?  What does the chip _need_? --jgarzik&n;&t; *&n;&t; * This seems to be undocumented, but something the original&n;&t; * driver(s) have always done.  Suspect undocumented timing&n;&t; * info/determined empirically. --rmk&n;&t; */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Disable transmit and receive functionality */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|SMC_SET_RCR
c_func
(paren
id|RCR_CLEAR
)paren
suffix:semicolon
id|SMC_SET_TCR
c_func
(paren
id|TCR_CLEAR
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|ctl
op_assign
id|SMC_GET_CTL
c_func
(paren
)paren
op_or
id|CTL_LE_ENABLE
suffix:semicolon
multiline_comment|/*&n;&t; * Set the control register to automatically release successfully&n;&t; * transmitted packets, to make the best use out of our limited&n;&t; * memory&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|THROTTLE_TX_PKTS
)paren
(brace
id|ctl
op_or_assign
id|CTL_AUTO_RELEASE
suffix:semicolon
)brace
r_else
id|ctl
op_and_assign
op_complement
id|CTL_AUTO_RELEASE
suffix:semicolon
id|SMC_SET_CTL
c_func
(paren
id|ctl
)paren
suffix:semicolon
multiline_comment|/* Reset the MMU */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|SMC_SET_MMU_CMD
c_func
(paren
id|MC_RESET
)paren
suffix:semicolon
id|SMC_WAIT_MMU_BUSY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* clear anything saved */
r_if
c_cond
(paren
id|lp-&gt;pending_tx_skb
op_ne
l_int|NULL
)paren
(brace
id|dev_kfree_skb
(paren
id|lp-&gt;pending_tx_skb
)paren
suffix:semicolon
id|lp-&gt;pending_tx_skb
op_assign
l_int|NULL
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Enable Interrupts, Receive, and Transmit&n; */
DECL|function|smc_enable
r_static
r_void
id|smc_enable
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|mask
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* see the header file for options in TCR/RCR DEFAULT */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|SMC_SET_TCR
c_func
(paren
id|lp-&gt;tcr_cur_mode
)paren
suffix:semicolon
id|SMC_SET_RCR
c_func
(paren
id|lp-&gt;rcr_cur_mode
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|SMC_SET_MAC_ADDR
c_func
(paren
id|dev-&gt;dev_addr
)paren
suffix:semicolon
multiline_comment|/* now, enable interrupts */
id|mask
op_assign
id|IM_EPH_INT
op_or
id|IM_RX_OVRN_INT
op_or
id|IM_RCV_INT
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;version
op_ge
(paren
id|CHIP_91100
op_lshift
l_int|4
)paren
)paren
id|mask
op_or_assign
id|IM_MDINT
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|SMC_SET_INT_MASK
c_func
(paren
id|mask
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * From this point the register bank must _NOT_ be switched away&n;&t; * to something else than bank 2 without proper locking against&n;&t; * races with any tasklet or interrupt handlers until smc_shutdown()&n;&t; * or smc_reset() is called.&n;&t; */
)brace
multiline_comment|/*&n; * this puts the device in an inactive state&n; */
DECL|function|smc_shutdown
r_static
r_void
id|smc_shutdown
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|CARDNAME
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* no more interrupts for me */
id|spin_lock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|SMC_SET_INT_MASK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* and tell the card to stay away from that nasty outside world */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|SMC_SET_RCR
c_func
(paren
id|RCR_CLEAR
)paren
suffix:semicolon
id|SMC_SET_TCR
c_func
(paren
id|TCR_CLEAR
)paren
suffix:semicolon
macro_line|#ifdef POWER_DOWN
multiline_comment|/* finally, shut the chip down */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|SMC_SET_CONFIG
c_func
(paren
id|SMC_GET_CONFIG
c_func
(paren
)paren
op_amp
op_complement
id|CONFIG_EPH_POWER_EN
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * This is the procedure to handle the receipt of a packet.&n; */
DECL|function|smc_rcv
r_static
r_inline
r_void
id|smc_rcv
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|packet_number
comma
id|status
comma
id|packet_len
suffix:semicolon
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|packet_number
op_assign
id|SMC_GET_RXFIFO
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|packet_number
op_amp
id|RXFIFO_REMPTY
)paren
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: smc_rcv with nothing on FIFO.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* read from start of packet */
id|SMC_SET_PTR
c_func
(paren
id|PTR_READ
op_or
id|PTR_RCV
op_or
id|PTR_AUTOINC
)paren
suffix:semicolon
multiline_comment|/* First two words are status and packet length */
id|SMC_GET_PKT_HDR
c_func
(paren
id|status
comma
id|packet_len
)paren
suffix:semicolon
id|packet_len
op_and_assign
l_int|0x07ff
suffix:semicolon
multiline_comment|/* mask off top bits */
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: RX PNR 0x%x STATUS 0x%04x LENGTH 0x%04x (%d)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|packet_number
comma
id|status
comma
id|packet_len
comma
id|packet_len
)paren
suffix:semicolon
id|back
suffix:colon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|packet_len
OL
l_int|6
op_logical_or
id|status
op_amp
id|RS_ERRORS
)paren
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|RS_TOOLONG
op_logical_and
id|packet_len
op_le
(paren
l_int|1514
op_plus
l_int|4
op_plus
l_int|6
)paren
)paren
(brace
multiline_comment|/* accept VLAN packets */
id|status
op_and_assign
op_complement
id|RS_TOOLONG
suffix:semicolon
r_goto
id|back
suffix:semicolon
)brace
r_if
c_cond
(paren
id|packet_len
OL
l_int|6
)paren
(brace
multiline_comment|/* bloody hardware */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: fubar (rxlen %u status %x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|packet_len
comma
id|status
)paren
suffix:semicolon
id|status
op_or_assign
id|RS_TOOSHORT
suffix:semicolon
)brace
id|SMC_WAIT_MMU_BUSY
c_func
(paren
)paren
suffix:semicolon
id|SMC_SET_MMU_CMD
c_func
(paren
id|MC_RELEASE
)paren
suffix:semicolon
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_ALGNERR
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|RS_TOOSHORT
op_or
id|RS_TOOLONG
)paren
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RS_BADCRC
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
r_int
id|data_len
suffix:semicolon
multiline_comment|/* set multicast stats */
r_if
c_cond
(paren
id|status
op_amp
id|RS_MULTICAST
)paren
id|lp-&gt;stats.multicast
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Actual payload is packet_len - 6 (or 5 if odd byte).&n;&t;&t; * We want skb_reserve(2) and the final ctrl word&n;&t;&t; * (2 bytes, possibly containing the payload odd byte).&n;&t;&t; * Furthermore, we add 2 bytes to allow rounding up to&n;&t;&t; * multiple of 4 bytes on 32 bit buses.&n;&t;&t; * Hence packet_len - 6 + 2 + 2 + 2.&n;&t;&t; */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|packet_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|skb
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Low memory, packet dropped.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|SMC_WAIT_MMU_BUSY
c_func
(paren
)paren
suffix:semicolon
id|SMC_SET_MMU_CMD
c_func
(paren
id|MC_RELEASE
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Align IP header to 32 bits */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* BUG: the LAN91C111 rev A never sets this bit. Force it. */
r_if
c_cond
(paren
id|lp-&gt;version
op_eq
l_int|0x90
)paren
id|status
op_or_assign
id|RS_ODDFRAME
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If odd length: packet_len - 5,&n;&t;&t; * otherwise packet_len - 6.&n;&t;&t; * With the trailing ctrl byte it&squot;s packet_len - 4.&n;&t;&t; */
id|data_len
op_assign
id|packet_len
op_minus
(paren
(paren
id|status
op_amp
id|RS_ODDFRAME
)paren
ques
c_cond
l_int|5
suffix:colon
l_int|6
)paren
suffix:semicolon
id|data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|data_len
)paren
suffix:semicolon
id|SMC_PULL_DATA
c_func
(paren
id|data
comma
id|packet_len
op_minus
l_int|4
)paren
suffix:semicolon
id|SMC_WAIT_MMU_BUSY
c_func
(paren
)paren
suffix:semicolon
id|SMC_SET_MMU_CMD
c_func
(paren
id|MC_RELEASE
)paren
suffix:semicolon
id|PRINT_PKT
c_func
(paren
id|data
comma
id|packet_len
op_minus
l_int|4
)paren
suffix:semicolon
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|data_len
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; * On SMP we have the following problem:&n; *&n; * &t;A = smc_hardware_send_pkt()&n; * &t;B = smc_hard_start_xmit()&n; * &t;C = smc_interrupt()&n; *&n; * A and B can never be executed simultaneously.  However, at least on UP,&n; * it is possible (and even desirable) for C to interrupt execution of&n; * A or B in order to have better RX reliability and avoid overruns.&n; * C, just like A and B, must have exclusive access to the chip and&n; * each of them must lock against any other concurrent access.&n; * Unfortunately this is not possible to have C suspend execution of A or&n; * B taking place on another CPU. On UP this is no an issue since A and B&n; * are run from softirq context and C from hard IRQ context, and there is&n; * no other CPU where concurrent access can happen.&n; * If ever there is a way to force at least B and C to always be executed&n; * on the same CPU then we could use read/write locks to protect against&n; * any other concurrent access and C would always interrupt B. But life&n; * isn&squot;t that easy in a SMP world...&n; */
DECL|macro|smc_special_trylock
mdefine_line|#define smc_special_trylock(lock)&t;&t;&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int __ret;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;local_irq_disable();&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__ret = spin_trylock(lock);&t;&t;&t;&t;&t;&bslash;&n;&t;if (!__ret)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;local_irq_enable();&t;&t;&t;&t;&t;&bslash;&n;&t;__ret;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|smc_special_lock
mdefine_line|#define smc_special_lock(lock)&t;&t;spin_lock_irq(lock)
DECL|macro|smc_special_unlock
mdefine_line|#define smc_special_unlock(lock)&t;spin_unlock_irq(lock)
macro_line|#else
DECL|macro|smc_special_trylock
mdefine_line|#define smc_special_trylock(lock)&t;(1)
DECL|macro|smc_special_lock
mdefine_line|#define smc_special_lock(lock)&t;&t;do { } while (0)
DECL|macro|smc_special_unlock
mdefine_line|#define smc_special_unlock(lock)&t;do { } while (0)
macro_line|#endif
multiline_comment|/*&n; * This is called to actually send a packet to the chip.&n; */
DECL|function|smc_hardware_send_pkt
r_static
r_void
id|smc_hardware_send_pkt
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|packet_no
comma
id|len
suffix:semicolon
r_int
r_char
op_star
id|buf
suffix:semicolon
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|smc_special_trylock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|lp-&gt;tx_task
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb
op_assign
id|lp-&gt;pending_tx_skb
suffix:semicolon
id|lp-&gt;pending_tx_skb
op_assign
l_int|NULL
suffix:semicolon
id|packet_no
op_assign
id|SMC_GET_AR
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|packet_no
op_amp
id|AR_FAILED
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory allocation failed.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|lp-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
id|smc_special_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* point to the beginning of the packet */
id|SMC_SET_PN
c_func
(paren
id|packet_no
)paren
suffix:semicolon
id|SMC_SET_PTR
c_func
(paren
id|PTR_AUTOINC
)paren
suffix:semicolon
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: TX PNR 0x%x LENGTH 0x%04x (%d) BUF 0x%p&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|packet_no
comma
id|len
comma
id|len
comma
id|buf
)paren
suffix:semicolon
id|PRINT_PKT
c_func
(paren
id|buf
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Send the packet length (+6 for status words, length, and ctl.&n;&t; * The card will pad to 64 bytes with zeroes if packet is too small.&n;&t; */
id|SMC_PUT_PKT_HDR
c_func
(paren
l_int|0
comma
id|len
op_plus
l_int|6
)paren
suffix:semicolon
multiline_comment|/* send the actual data */
id|SMC_PUSH_DATA
c_func
(paren
id|buf
comma
id|len
op_amp
op_complement
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Send final ctl word with the last byte if there is one */
id|SMC_outw
c_func
(paren
(paren
(paren
id|len
op_amp
l_int|1
)paren
ques
c_cond
(paren
l_int|0x2000
op_or
id|buf
(braket
id|len
op_minus
l_int|1
)braket
)paren
suffix:colon
l_int|0
)paren
comma
id|ioaddr
comma
id|DATA_REG
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If THROTTLE_TX_PKTS is set, we look at the TX_EMPTY flag&n;&t; * before queueing this packet for TX, and if it&squot;s clear then&n;&t; * we stop the queue here.  This will have the effect of&n;&t; * having at most 2 packets queued for TX in the chip&squot;s memory&n;&t; * at all time. If THROTTLE_TX_PKTS is not set then the queue&n;&t; * is stopped only when memory allocation (MC_ALLOC) does not&n;&t; * succeed right away.&n;&t; */
r_if
c_cond
(paren
id|THROTTLE_TX_PKTS
op_logical_and
op_logical_neg
(paren
id|SMC_GET_INT
c_func
(paren
)paren
op_amp
id|IM_TX_EMPTY_INT
)paren
)paren
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* queue the packet for TX */
id|SMC_SET_MMU_CMD
c_func
(paren
id|MC_ENQUEUE
)paren
suffix:semicolon
id|SMC_ACK_INT
c_func
(paren
id|IM_TX_EMPTY_INT
)paren
suffix:semicolon
id|smc_special_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.tx_bytes
op_add_assign
id|len
suffix:semicolon
id|SMC_ENABLE_INT
c_func
(paren
id|IM_TX_INT
op_or
id|IM_TX_EMPTY_INT
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|THROTTLE_TX_PKTS
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Since I am not sure if I will have enough room in the chip&squot;s ram&n; * to store the packet, I call this routine which either sends it&n; * now, or set the card to generates an interrupt when ready&n; * for the packet.&n; */
DECL|function|smc_hard_start_xmit
r_static
r_int
id|smc_hard_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|numPages
comma
id|poll_count
comma
id|status
suffix:semicolon
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|lp-&gt;pending_tx_skb
op_ne
l_int|NULL
)paren
suffix:semicolon
id|lp-&gt;pending_tx_skb
op_assign
id|skb
suffix:semicolon
multiline_comment|/*&n;&t; * The MMU wants the number of pages to be the number of 256 bytes&n;&t; * &squot;pages&squot;, minus 1 (since a packet can&squot;t ever have 0 pages :))&n;&t; *&n;&t; * The 91C111 ignores the size bits, but earlier models don&squot;t.&n;&t; *&n;&t; * Pkt size for allocating is data length +6 (for additional status&n;&t; * words, length and ctl)&n;&t; *&n;&t; * If odd size then last byte is included in ctl word.&n;&t; */
id|numPages
op_assign
(paren
(paren
id|skb-&gt;len
op_amp
op_complement
l_int|1
)paren
op_plus
(paren
l_int|6
op_minus
l_int|1
)paren
)paren
op_rshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|numPages
OG
l_int|7
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Far too big packet error.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;pending_tx_skb
op_assign
l_int|NULL
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|lp-&gt;stats.tx_dropped
op_increment
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|smc_special_lock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* now, try to allocate the memory */
id|SMC_SET_MMU_CMD
c_func
(paren
id|MC_ALLOC
op_or
id|numPages
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Poll the chip for a short amount of time in case the&n;&t; * allocation succeeds quickly.&n;&t; */
id|poll_count
op_assign
id|MEMORY_WAIT_TIME
suffix:semicolon
r_do
(brace
id|status
op_assign
id|SMC_GET_INT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|IM_ALLOC_INT
)paren
(brace
id|SMC_ACK_INT
c_func
(paren
id|IM_ALLOC_INT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_decrement
id|poll_count
)paren
suffix:semicolon
id|smc_special_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|poll_count
)paren
(brace
multiline_comment|/* oh well, wait until the chip finds memory later */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: TX memory allocation deferred.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|SMC_ENABLE_INT
c_func
(paren
id|IM_ALLOC_INT
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Allocation succeeded: push packet to the chip&squot;s own memory&n;&t;&t; * immediately.&n;&t;&t; */
id|smc_hardware_send_pkt
c_func
(paren
(paren
r_int
r_int
)paren
id|dev
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This handles a TX interrupt, which is only called when:&n; * - a TX error occurred, or&n; * - CTL_AUTO_RELEASE is not set and TX of a packet completed.&n; */
DECL|function|smc_tx
r_static
r_void
id|smc_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|saved_packet
comma
id|packet_no
comma
id|tx_status
comma
id|pkt_len
suffix:semicolon
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* If the TX FIFO is empty then nothing to do */
id|packet_no
op_assign
id|SMC_GET_TXFIFO
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|packet_no
op_amp
id|TXFIFO_TEMPTY
)paren
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: smc_tx with nothing on FIFO.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* select packet to read from */
id|saved_packet
op_assign
id|SMC_GET_PN
c_func
(paren
)paren
suffix:semicolon
id|SMC_SET_PN
c_func
(paren
id|packet_no
)paren
suffix:semicolon
multiline_comment|/* read the first word (status word) from this packet */
id|SMC_SET_PTR
c_func
(paren
id|PTR_AUTOINC
op_or
id|PTR_READ
)paren
suffix:semicolon
id|SMC_GET_PKT_HDR
c_func
(paren
id|tx_status
comma
id|pkt_len
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: TX STATUS 0x%04x PNR 0x%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|tx_status
comma
id|packet_no
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tx_status
op_amp
id|TS_SUCCESS
)paren
)paren
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|TS_LOSTCAR
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|TS_LATCOL
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: late collision occurred on last xmit&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|lp-&gt;stats.tx_window_errors
op_amp
l_int|63
)paren
op_logical_and
id|net_ratelimit
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: unexpectedly large numbers of &quot;
l_string|&quot;late collisions. Please check duplex &quot;
l_string|&quot;setting.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* kill the packet */
id|SMC_WAIT_MMU_BUSY
c_func
(paren
)paren
suffix:semicolon
id|SMC_SET_MMU_CMD
c_func
(paren
id|MC_FREEPKT
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t restore Packet Number Reg until busy bit is cleared */
id|SMC_WAIT_MMU_BUSY
c_func
(paren
)paren
suffix:semicolon
id|SMC_SET_PN
c_func
(paren
id|saved_packet
)paren
suffix:semicolon
multiline_comment|/* re-enable transmit */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|SMC_SET_TCR
c_func
(paren
id|lp-&gt;tcr_cur_mode
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*---PHY CONTROL AND CONFIGURATION-----------------------------------------*/
DECL|function|smc_mii_out
r_static
r_void
id|smc_mii_out
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|val
comma
r_int
id|bits
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|mii_reg
comma
id|mask
suffix:semicolon
id|mii_reg
op_assign
id|SMC_GET_MII
c_func
(paren
)paren
op_amp
op_complement
(paren
id|MII_MCLK
op_or
id|MII_MDOE
op_or
id|MII_MDO
)paren
suffix:semicolon
id|mii_reg
op_or_assign
id|MII_MDOE
suffix:semicolon
r_for
c_loop
(paren
id|mask
op_assign
l_int|1
op_lshift
(paren
id|bits
op_minus
l_int|1
)paren
suffix:semicolon
id|mask
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|mask
)paren
id|mii_reg
op_or_assign
id|MII_MDO
suffix:semicolon
r_else
id|mii_reg
op_and_assign
op_complement
id|MII_MDO
suffix:semicolon
id|SMC_SET_MII
c_func
(paren
id|mii_reg
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|MII_DELAY
)paren
suffix:semicolon
id|SMC_SET_MII
c_func
(paren
id|mii_reg
op_or
id|MII_MCLK
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|MII_DELAY
)paren
suffix:semicolon
)brace
)brace
DECL|function|smc_mii_in
r_static
r_int
r_int
id|smc_mii_in
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|bits
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|mii_reg
comma
id|mask
comma
id|val
suffix:semicolon
id|mii_reg
op_assign
id|SMC_GET_MII
c_func
(paren
)paren
op_amp
op_complement
(paren
id|MII_MCLK
op_or
id|MII_MDOE
op_or
id|MII_MDO
)paren
suffix:semicolon
id|SMC_SET_MII
c_func
(paren
id|mii_reg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mask
op_assign
l_int|1
op_lshift
(paren
id|bits
op_minus
l_int|1
)paren
comma
id|val
op_assign
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|SMC_GET_MII
c_func
(paren
)paren
op_amp
id|MII_MDI
)paren
id|val
op_or_assign
id|mask
suffix:semicolon
id|SMC_SET_MII
c_func
(paren
id|mii_reg
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|MII_DELAY
)paren
suffix:semicolon
id|SMC_SET_MII
c_func
(paren
id|mii_reg
op_or
id|MII_MCLK
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|MII_DELAY
)paren
suffix:semicolon
)brace
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n; * Reads a register from the MII Management serial interface&n; */
DECL|function|smc_phy_read
r_static
r_int
id|smc_phy_read
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|phyaddr
comma
r_int
id|phyreg
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|phydata
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Idle - 32 ones */
id|smc_mii_out
c_func
(paren
id|dev
comma
l_int|0xffffffff
comma
l_int|32
)paren
suffix:semicolon
multiline_comment|/* Start code (01) + read (10) + phyaddr + phyreg */
id|smc_mii_out
c_func
(paren
id|dev
comma
l_int|6
op_lshift
l_int|10
op_or
id|phyaddr
op_lshift
l_int|5
op_or
id|phyreg
comma
l_int|14
)paren
suffix:semicolon
multiline_comment|/* Turnaround (2bits) + phydata */
id|phydata
op_assign
id|smc_mii_in
c_func
(paren
id|dev
comma
l_int|18
)paren
suffix:semicolon
multiline_comment|/* Return to idle state */
id|SMC_SET_MII
c_func
(paren
id|SMC_GET_MII
c_func
(paren
)paren
op_amp
op_complement
(paren
id|MII_MCLK
op_or
id|MII_MDOE
op_or
id|MII_MDO
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|phyaddr
comma
id|phyreg
comma
id|phydata
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_return
id|phydata
suffix:semicolon
)brace
multiline_comment|/*&n; * Writes a register to the MII Management serial interface&n; */
DECL|function|smc_phy_write
r_static
r_void
id|smc_phy_write
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|phyaddr
comma
r_int
id|phyreg
comma
r_int
id|phydata
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Idle - 32 ones */
id|smc_mii_out
c_func
(paren
id|dev
comma
l_int|0xffffffff
comma
l_int|32
)paren
suffix:semicolon
multiline_comment|/* Start code (01) + write (01) + phyaddr + phyreg + turnaround + phydata */
id|smc_mii_out
c_func
(paren
id|dev
comma
l_int|5
op_lshift
l_int|28
op_or
id|phyaddr
op_lshift
l_int|23
op_or
id|phyreg
op_lshift
l_int|18
op_or
l_int|2
op_lshift
l_int|16
op_or
id|phydata
comma
l_int|32
)paren
suffix:semicolon
multiline_comment|/* Return to idle state */
id|SMC_SET_MII
c_func
(paren
id|SMC_GET_MII
c_func
(paren
)paren
op_amp
op_complement
(paren
id|MII_MCLK
op_or
id|MII_MDOE
op_or
id|MII_MDO
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|phyaddr
comma
id|phyreg
comma
id|phydata
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Finds and reports the PHY address&n; */
DECL|function|smc_phy_detect
r_static
r_void
id|smc_phy_detect
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|phyaddr
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|lp-&gt;phy_type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Scan all 32 PHY addresses if necessary, starting at&n;&t; * PHY#1 to PHY#31, and then PHY#0 last.&n;&t; */
r_for
c_loop
(paren
id|phyaddr
op_assign
l_int|1
suffix:semicolon
id|phyaddr
OL
l_int|33
suffix:semicolon
op_increment
id|phyaddr
)paren
(brace
r_int
r_int
id|id1
comma
id|id2
suffix:semicolon
multiline_comment|/* Read the PHY identifiers */
id|id1
op_assign
id|smc_phy_read
c_func
(paren
id|dev
comma
id|phyaddr
op_amp
l_int|31
comma
id|MII_PHYSID1
)paren
suffix:semicolon
id|id2
op_assign
id|smc_phy_read
c_func
(paren
id|dev
comma
id|phyaddr
op_amp
l_int|31
comma
id|MII_PHYSID2
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: phy_id1=0x%x, phy_id2=0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|id1
comma
id|id2
)paren
suffix:semicolon
multiline_comment|/* Make sure it is a valid identifier */
r_if
c_cond
(paren
id|id1
op_ne
l_int|0x0000
op_logical_and
id|id1
op_ne
l_int|0xffff
op_logical_and
id|id1
op_ne
l_int|0x8000
op_logical_and
id|id2
op_ne
l_int|0x0000
op_logical_and
id|id2
op_ne
l_int|0xffff
op_logical_and
id|id2
op_ne
l_int|0x8000
)paren
(brace
multiline_comment|/* Save the PHY&squot;s address */
id|lp-&gt;mii.phy_id
op_assign
id|phyaddr
op_amp
l_int|31
suffix:semicolon
id|lp-&gt;phy_type
op_assign
id|id1
op_lshift
l_int|16
op_or
id|id2
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Sets the PHY to a configuration as determined by the user&n; */
DECL|function|smc_phy_fixed
r_static
r_int
id|smc_phy_fixed
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|phyaddr
op_assign
id|lp-&gt;mii.phy_id
suffix:semicolon
r_int
id|bmcr
comma
id|cfg1
suffix:semicolon
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Enter Link Disable state */
id|cfg1
op_assign
id|smc_phy_read
c_func
(paren
id|dev
comma
id|phyaddr
comma
id|PHY_CFG1_REG
)paren
suffix:semicolon
id|cfg1
op_or_assign
id|PHY_CFG1_LNKDIS
suffix:semicolon
id|smc_phy_write
c_func
(paren
id|dev
comma
id|phyaddr
comma
id|PHY_CFG1_REG
comma
id|cfg1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set our fixed capabilities&n;&t; * Disable auto-negotiation&n;&t; */
id|bmcr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;ctl_rfduplx
)paren
id|bmcr
op_or_assign
id|BMCR_FULLDPLX
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;ctl_rspeed
op_eq
l_int|100
)paren
id|bmcr
op_or_assign
id|BMCR_SPEED100
suffix:semicolon
multiline_comment|/* Write our capabilities to the phy control register */
id|smc_phy_write
c_func
(paren
id|dev
comma
id|phyaddr
comma
id|MII_BMCR
comma
id|bmcr
)paren
suffix:semicolon
multiline_comment|/* Re-Configure the Receive/Phy Control register */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|SMC_SET_RPC
c_func
(paren
id|lp-&gt;rpc_cur_mode
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * smc_phy_reset - reset the phy&n; * @dev: net device&n; * @phy: phy address&n; *&n; * Issue a software reset for the specified PHY and&n; * wait up to 100ms for the reset to complete.  We should&n; * not access the PHY for 50ms after issuing the reset.&n; *&n; * The time to wait appears to be dependent on the PHY.&n; *&n; * Must be called with lp-&gt;lock locked.&n; */
DECL|function|smc_phy_reset
r_static
r_int
id|smc_phy_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|phy
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|bmcr
suffix:semicolon
r_int
id|timeout
suffix:semicolon
id|smc_phy_write
c_func
(paren
id|dev
comma
id|phy
comma
id|MII_BMCR
comma
id|BMCR_RESET
)paren
suffix:semicolon
r_for
c_loop
(paren
id|timeout
op_assign
l_int|2
suffix:semicolon
id|timeout
suffix:semicolon
id|timeout
op_decrement
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|bmcr
op_assign
id|smc_phy_read
c_func
(paren
id|dev
comma
id|phy
comma
id|MII_BMCR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bmcr
op_amp
id|BMCR_RESET
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|bmcr
op_amp
id|BMCR_RESET
suffix:semicolon
)brace
multiline_comment|/*&n; * smc_phy_powerdown - powerdown phy&n; * @dev: net device&n; * @phy: phy address&n; *&n; * Power down the specified PHY&n; */
DECL|function|smc_phy_powerdown
r_static
r_void
id|smc_phy_powerdown
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|phy
)paren
(brace
r_int
r_int
id|bmcr
suffix:semicolon
id|bmcr
op_assign
id|smc_phy_read
c_func
(paren
id|dev
comma
id|phy
comma
id|MII_BMCR
)paren
suffix:semicolon
id|smc_phy_write
c_func
(paren
id|dev
comma
id|phy
comma
id|MII_BMCR
comma
id|bmcr
op_or
id|BMCR_PDOWN
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * smc_phy_check_media - check the media status and adjust TCR&n; * @dev: net device&n; * @init: set true for initialisation&n; *&n; * Select duplex mode depending on negotiation state.  This&n; * also updates our carrier state.&n; */
DECL|function|smc_phy_check_media
r_static
r_void
id|smc_phy_check_media
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|init
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|mii_check_media
c_func
(paren
op_amp
id|lp-&gt;mii
comma
id|netif_msg_link
c_func
(paren
id|lp
)paren
comma
id|init
)paren
)paren
(brace
multiline_comment|/* duplex state has changed */
r_if
c_cond
(paren
id|lp-&gt;mii.full_duplex
)paren
(brace
id|lp-&gt;tcr_cur_mode
op_or_assign
id|TCR_SWFDUP
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;tcr_cur_mode
op_and_assign
op_complement
id|TCR_SWFDUP
suffix:semicolon
)brace
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|SMC_SET_TCR
c_func
(paren
id|lp-&gt;tcr_cur_mode
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Configures the specified PHY through the MII management interface&n; * using Autonegotiation.&n; * Calls smc_phy_fixed() if the user has requested a certain config.&n; * If RPC ANEG bit is set, the media selection is dependent purely on&n; * the selection by the MII (either in the MII BMCR reg or the result&n; * of autonegotiation.)  If the RPC ANEG bit is cleared, the selection&n; * is controlled by the RPC SPEED and RPC DPLX bits.&n; */
DECL|function|smc_phy_configure
r_static
r_void
id|smc_phy_configure
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|data
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|phyaddr
op_assign
id|lp-&gt;mii.phy_id
suffix:semicolon
r_int
id|my_phy_caps
suffix:semicolon
multiline_comment|/* My PHY capabilities */
r_int
id|my_ad_caps
suffix:semicolon
multiline_comment|/* My Advertised capabilities */
r_int
id|status
suffix:semicolon
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s:smc_program_phy()&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We should not be called if phy_type is zero.&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;phy_type
op_eq
l_int|0
)paren
r_goto
id|smc_phy_configure_exit
suffix:semicolon
r_if
c_cond
(paren
id|smc_phy_reset
c_func
(paren
id|dev
comma
id|phyaddr
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: PHY reset timed out&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_goto
id|smc_phy_configure_exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Enable PHY Interrupts (for register 18)&n;&t; * Interrupts listed here are disabled&n;&t; */
id|smc_phy_write
c_func
(paren
id|dev
comma
id|phyaddr
comma
id|PHY_MASK_REG
comma
id|PHY_INT_LOSSSYNC
op_or
id|PHY_INT_CWRD
op_or
id|PHY_INT_SSD
op_or
id|PHY_INT_ESD
op_or
id|PHY_INT_RPOL
op_or
id|PHY_INT_JAB
op_or
id|PHY_INT_SPDDET
op_or
id|PHY_INT_DPLXDET
)paren
suffix:semicolon
multiline_comment|/* Configure the Receive/Phy Control register */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|SMC_SET_RPC
c_func
(paren
id|lp-&gt;rpc_cur_mode
)paren
suffix:semicolon
multiline_comment|/* If the user requested no auto neg, then go set his request */
r_if
c_cond
(paren
id|lp-&gt;mii.force_media
)paren
(brace
id|smc_phy_fixed
c_func
(paren
id|dev
)paren
suffix:semicolon
r_goto
id|smc_phy_configure_exit
suffix:semicolon
)brace
multiline_comment|/* Copy our capabilities from MII_BMSR to MII_ADVERTISE */
id|my_phy_caps
op_assign
id|smc_phy_read
c_func
(paren
id|dev
comma
id|phyaddr
comma
id|MII_BMSR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|my_phy_caps
op_amp
id|BMSR_ANEGCAPABLE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Auto negotiation NOT supported&bslash;n&quot;
)paren
suffix:semicolon
id|smc_phy_fixed
c_func
(paren
id|dev
)paren
suffix:semicolon
r_goto
id|smc_phy_configure_exit
suffix:semicolon
)brace
id|my_ad_caps
op_assign
id|ADVERTISE_CSMA
suffix:semicolon
multiline_comment|/* I am CSMA capable */
r_if
c_cond
(paren
id|my_phy_caps
op_amp
id|BMSR_100BASE4
)paren
id|my_ad_caps
op_or_assign
id|ADVERTISE_100BASE4
suffix:semicolon
r_if
c_cond
(paren
id|my_phy_caps
op_amp
id|BMSR_100FULL
)paren
id|my_ad_caps
op_or_assign
id|ADVERTISE_100FULL
suffix:semicolon
r_if
c_cond
(paren
id|my_phy_caps
op_amp
id|BMSR_100HALF
)paren
id|my_ad_caps
op_or_assign
id|ADVERTISE_100HALF
suffix:semicolon
r_if
c_cond
(paren
id|my_phy_caps
op_amp
id|BMSR_10FULL
)paren
id|my_ad_caps
op_or_assign
id|ADVERTISE_10FULL
suffix:semicolon
r_if
c_cond
(paren
id|my_phy_caps
op_amp
id|BMSR_10HALF
)paren
id|my_ad_caps
op_or_assign
id|ADVERTISE_10HALF
suffix:semicolon
multiline_comment|/* Disable capabilities not selected by our user */
r_if
c_cond
(paren
id|lp-&gt;ctl_rspeed
op_ne
l_int|100
)paren
id|my_ad_caps
op_and_assign
op_complement
(paren
id|ADVERTISE_100BASE4
op_or
id|ADVERTISE_100FULL
op_or
id|ADVERTISE_100HALF
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;ctl_rfduplx
)paren
id|my_ad_caps
op_and_assign
op_complement
(paren
id|ADVERTISE_100FULL
op_or
id|ADVERTISE_10FULL
)paren
suffix:semicolon
multiline_comment|/* Update our Auto-Neg Advertisement Register */
id|smc_phy_write
c_func
(paren
id|dev
comma
id|phyaddr
comma
id|MII_ADVERTISE
comma
id|my_ad_caps
)paren
suffix:semicolon
id|lp-&gt;mii.advertising
op_assign
id|my_ad_caps
suffix:semicolon
multiline_comment|/*&n;&t; * Read the register back.  Without this, it appears that when&n;&t; * auto-negotiation is restarted, sometimes it isn&squot;t ready and&n;&t; * the link does not come up.&n;&t; */
id|status
op_assign
id|smc_phy_read
c_func
(paren
id|dev
comma
id|phyaddr
comma
id|MII_ADVERTISE
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: phy caps=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|my_phy_caps
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: phy advertised caps=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|my_ad_caps
)paren
suffix:semicolon
multiline_comment|/* Restart auto-negotiation process in order to advertise my caps */
id|smc_phy_write
c_func
(paren
id|dev
comma
id|phyaddr
comma
id|MII_BMCR
comma
id|BMCR_ANENABLE
op_or
id|BMCR_ANRESTART
)paren
suffix:semicolon
id|smc_phy_check_media
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|smc_phy_configure_exit
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|lp-&gt;work_pending
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * smc_phy_interrupt&n; *&n; * Purpose:  Handle interrupts relating to PHY register 18. This is&n; *  called from the &quot;hard&quot; interrupt handler under our private spinlock.&n; */
DECL|function|smc_phy_interrupt
r_static
r_void
id|smc_phy_interrupt
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|phyaddr
op_assign
id|lp-&gt;mii.phy_id
suffix:semicolon
r_int
id|phy18
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;phy_type
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|smc_phy_check_media
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Read PHY Register 18, Status Output */
id|phy18
op_assign
id|smc_phy_read
c_func
(paren
id|dev
comma
id|phyaddr
comma
id|PHY_INT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|phy18
op_amp
id|PHY_INT_INT
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*--- END PHY CONTROL AND CONFIGURATION-------------------------------------*/
DECL|function|smc_10bt_check_media
r_static
r_void
id|smc_10bt_check_media
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|init
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|old_carrier
comma
id|new_carrier
suffix:semicolon
id|old_carrier
op_assign
id|netif_carrier_ok
c_func
(paren
id|dev
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|new_carrier
op_assign
id|SMC_inw
c_func
(paren
id|ioaddr
comma
id|EPH_STATUS_REG
)paren
op_amp
id|ES_LINK_OK
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init
op_logical_or
(paren
id|old_carrier
op_ne
id|new_carrier
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|new_carrier
)paren
(brace
id|netif_carrier_off
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|netif_carrier_on
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|netif_msg_link
c_func
(paren
id|lp
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|new_carrier
ques
c_cond
l_string|&quot;up&quot;
suffix:colon
l_string|&quot;down&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|smc_eph_interrupt
r_static
r_void
id|smc_eph_interrupt
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|ctl
suffix:semicolon
id|smc_10bt_check_media
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|ctl
op_assign
id|SMC_GET_CTL
c_func
(paren
)paren
suffix:semicolon
id|SMC_SET_CTL
c_func
(paren
id|ctl
op_amp
op_complement
id|CTL_LE_ENABLE
)paren
suffix:semicolon
id|SMC_SET_CTL
c_func
(paren
id|ctl
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the main routine of the driver, to handle the device when&n; * it needs some attention.&n; */
DECL|function|smc_interrupt
r_static
id|irqreturn_t
id|smc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|status
comma
id|mask
comma
id|timeout
comma
id|card_stats
suffix:semicolon
r_int
id|saved_pointer
suffix:semicolon
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* A preamble may be used when there is a potential race&n;&t; * between the interruptible transmit functions and this&n;&t; * ISR. */
id|SMC_INTERRUPT_PREAMBLE
suffix:semicolon
id|saved_pointer
op_assign
id|SMC_GET_PTR
c_func
(paren
)paren
suffix:semicolon
id|mask
op_assign
id|SMC_GET_INT_MASK
c_func
(paren
)paren
suffix:semicolon
id|SMC_SET_INT_MASK
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* set a timeout value, so I don&squot;t stay here forever */
id|timeout
op_assign
l_int|8
suffix:semicolon
r_do
(brace
id|status
op_assign
id|SMC_GET_INT
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: INT 0x%02x MASK 0x%02x MEM 0x%04x FIFO 0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
comma
id|mask
comma
(paren
(brace
r_int
id|meminfo
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|meminfo
op_assign
id|SMC_GET_MIR
c_func
(paren
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|meminfo
suffix:semicolon
)brace
)paren
comma
id|SMC_GET_FIFO
c_func
(paren
)paren
)paren
suffix:semicolon
id|status
op_and_assign
id|mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|IM_RCV_INT
)paren
(brace
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: RX irq&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|smc_rcv
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_TX_INT
)paren
(brace
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: TX int&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|smc_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|SMC_ACK_INT
c_func
(paren
id|IM_TX_INT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|THROTTLE_TX_PKTS
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_ALLOC_INT
)paren
(brace
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: Allocation irq&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|tasklet_hi_schedule
c_func
(paren
op_amp
id|lp-&gt;tx_task
)paren
suffix:semicolon
id|mask
op_and_assign
op_complement
id|IM_ALLOC_INT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_TX_EMPTY_INT
)paren
(brace
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: TX empty&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|mask
op_and_assign
op_complement
id|IM_TX_EMPTY_INT
suffix:semicolon
multiline_comment|/* update stats */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|card_stats
op_assign
id|SMC_GET_COUNTER
c_func
(paren
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* single collisions */
id|lp-&gt;stats.collisions
op_add_assign
id|card_stats
op_amp
l_int|0xF
suffix:semicolon
id|card_stats
op_rshift_assign
l_int|4
suffix:semicolon
multiline_comment|/* multiple collisions */
id|lp-&gt;stats.collisions
op_add_assign
id|card_stats
op_amp
l_int|0xF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_RX_OVRN_INT
)paren
(brace
id|DBG
c_func
(paren
l_int|1
comma
l_string|&quot;%s: RX overrun&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|SMC_ACK_INT
c_func
(paren
id|IM_RX_OVRN_INT
)paren
suffix:semicolon
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_EPH_INT
)paren
(brace
id|smc_eph_interrupt
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_MDINT
)paren
(brace
id|SMC_ACK_INT
c_func
(paren
id|IM_MDINT
)paren
suffix:semicolon
id|smc_phy_interrupt
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|IM_ERCV_INT
)paren
(brace
id|SMC_ACK_INT
c_func
(paren
id|IM_ERCV_INT
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;%s: UNSUPPORTED: ERCV INTERRUPT &bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_decrement
id|timeout
)paren
suffix:semicolon
multiline_comment|/* restore register states */
id|SMC_SET_PTR
c_func
(paren
id|saved_pointer
)paren
suffix:semicolon
id|SMC_SET_INT_MASK
c_func
(paren
id|mask
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|3
comma
l_string|&quot;%s: Interrupt done (%d loops)&bslash;n&quot;
comma
id|dev-&gt;name
comma
l_int|8
op_minus
id|timeout
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We return IRQ_HANDLED unconditionally here even if there was&n;&t; * nothing to do.  There is a possibility that a packet might&n;&t; * get enqueued into the chip right after TX_EMPTY_INT is raised&n;&t; * but just before the CPU acknowledges the IRQ.&n;&t; * Better take an unneeded IRQ in some occasions than complexifying&n;&t; * the code for all cases.&n;&t; */
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_POLL_CONTROLLER
multiline_comment|/*&n; * Polling receive - used by netconsole and other diagnostic tools&n; * to allow network i/o with interrupts disabled.&n; */
DECL|function|smc_poll_controller
r_static
r_void
id|smc_poll_controller
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|disable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|smc_interrupt
c_func
(paren
id|dev-&gt;irq
comma
id|dev
comma
l_int|NULL
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Our watchdog timed out. Called by the networking layer */
DECL|function|smc_timeout
r_static
r_void
id|smc_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
comma
id|mask
comma
id|meminfo
comma
id|fifo
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|status
op_assign
id|SMC_GET_INT
c_func
(paren
)paren
suffix:semicolon
id|mask
op_assign
id|SMC_GET_INT_MASK
c_func
(paren
)paren
suffix:semicolon
id|fifo
op_assign
id|SMC_GET_FIFO
c_func
(paren
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|meminfo
op_assign
id|SMC_GET_MIR
c_func
(paren
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;%s: INT 0x%02x MASK 0x%02x MEM 0x%04x FIFO 0x%04x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
comma
id|mask
comma
id|meminfo
comma
id|fifo
)paren
suffix:semicolon
id|smc_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
id|smc_enable
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reconfiguring the PHY doesn&squot;t seem like a bad idea here, but&n;&t; * smc_phy_configure() calls msleep() which calls schedule_timeout()&n;&t; * which calls schedule().  Hence we use a work queue.&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;phy_type
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|schedule_work
c_func
(paren
op_amp
id|lp-&gt;phy_configure
)paren
)paren
(brace
id|lp-&gt;work_pending
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* We can accept TX packets again */
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine will, depending on the values passed to it,&n; * either make it accept multicast packets, go into&n; * promiscuous mode (for TCPDUMP and cousins) or accept&n; * a select set of multicast packets&n; */
DECL|function|smc_set_multicast_list
r_static
r_void
id|smc_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_char
id|multicast_table
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|update_multicast
op_assign
l_int|0
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: RCR_PRMS&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;rcr_cur_mode
op_or_assign
id|RCR_PRMS
suffix:semicolon
)brace
multiline_comment|/* BUG?  I never disable promiscuous mode if multicasting was turned on.&n;   Now, I turn off promiscuous mode, but I don&squot;t do anything to multicasting&n;   when promiscuous mode is turned on.&n;*/
multiline_comment|/*&n;&t; * Here, I am setting this to accept all multicast packets.&n;&t; * I don&squot;t need to zero the multicast table, because the flag is&n;&t; * checked before the table is&n;&t; */
r_else
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
op_logical_or
id|dev-&gt;mc_count
OG
l_int|16
)paren
(brace
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: RCR_ALMUL&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;rcr_cur_mode
op_or_assign
id|RCR_ALMUL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This sets the internal hardware table to filter out unwanted&n;&t; * multicast packets before they take up memory.&n;&t; *&n;&t; * The SMC chip uses a hash table where the high 6 bits of the CRC of&n;&t; * address are the offset into the table.  If that bit is 1, then the&n;&t; * multicast packet is accepted.  Otherwise, it&squot;s dropped silently.&n;&t; *&n;&t; * To use the 6 bits as an offset into the table, the high 3 bits are&n;&t; * the number of the 8 bit register, while the low 3 bits are the bit&n;&t; * within that register.&n;&t; */
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|cur_addr
suffix:semicolon
multiline_comment|/* table for flipping the order of 3 bits */
r_static
r_const
r_int
r_char
id|invert3
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|4
comma
l_int|2
comma
l_int|6
comma
l_int|1
comma
l_int|5
comma
l_int|3
comma
l_int|7
)brace
suffix:semicolon
multiline_comment|/* start with a table of all zeros: reject all */
id|memset
c_func
(paren
id|multicast_table
comma
l_int|0
comma
r_sizeof
(paren
id|multicast_table
)paren
)paren
suffix:semicolon
id|cur_addr
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
comma
id|cur_addr
op_assign
id|cur_addr-&gt;next
)paren
(brace
r_int
id|position
suffix:semicolon
multiline_comment|/* do we have a pointer here? */
r_if
c_cond
(paren
op_logical_neg
id|cur_addr
)paren
r_break
suffix:semicolon
multiline_comment|/* make sure this is a multicast address -&n;&t;&t;   &t;   shouldn&squot;t this be a given if we have it here ? */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|cur_addr-&gt;dmi_addr
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* only use the low order bits */
id|position
op_assign
id|crc32_le
c_func
(paren
op_complement
l_int|0
comma
id|cur_addr-&gt;dmi_addr
comma
l_int|6
)paren
op_amp
l_int|0x3f
suffix:semicolon
multiline_comment|/* do some messy swapping to put the bit in the right spot */
id|multicast_table
(braket
id|invert3
(braket
id|position
op_amp
l_int|7
)braket
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|invert3
(braket
(paren
id|position
op_rshift
l_int|3
)paren
op_amp
l_int|7
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* be sure I get rid of flags I might have set */
id|lp-&gt;rcr_cur_mode
op_and_assign
op_complement
(paren
id|RCR_PRMS
op_or
id|RCR_ALMUL
)paren
suffix:semicolon
multiline_comment|/* now, the table can be loaded into the chipset */
id|update_multicast
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: ~(RCR_PRMS|RCR_ALMUL)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;rcr_cur_mode
op_and_assign
op_complement
(paren
id|RCR_PRMS
op_or
id|RCR_ALMUL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * since I&squot;m disabling all multicast entirely, I need to&n;&t;&t; * clear the multicast list&n;&t;&t; */
id|memset
c_func
(paren
id|multicast_table
comma
l_int|0
comma
r_sizeof
(paren
id|multicast_table
)paren
)paren
suffix:semicolon
id|update_multicast
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|SMC_SET_RCR
c_func
(paren
id|lp-&gt;rcr_cur_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|update_multicast
)paren
(brace
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|SMC_SET_MCAST
c_func
(paren
id|multicast_table
)paren
suffix:semicolon
)brace
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Open and Initialize the board&n; *&n; * Set up everything, reset the card, etc..&n; */
r_static
r_int
DECL|function|smc_open
id|smc_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check that the address is valid.  If its not, refuse&n;&t; * to bring the device up.  The user must specify an&n;&t; * address using ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|is_valid_ether_addr
c_func
(paren
id|dev-&gt;dev_addr
)paren
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: no valid ethernet hw addr&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Setup the default Register Modes */
id|lp-&gt;tcr_cur_mode
op_assign
id|TCR_DEFAULT
suffix:semicolon
id|lp-&gt;rcr_cur_mode
op_assign
id|RCR_DEFAULT
suffix:semicolon
id|lp-&gt;rpc_cur_mode
op_assign
id|RPC_DEFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * If we are not using a MII interface, we need to&n;&t; * monitor our own carrier signal to detect faults.&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;phy_type
op_eq
l_int|0
)paren
id|lp-&gt;tcr_cur_mode
op_or_assign
id|TCR_MON_CSN
suffix:semicolon
multiline_comment|/* reset the hardware */
id|smc_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
id|smc_enable
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Configure the PHY, initialize the link state */
r_if
c_cond
(paren
id|lp-&gt;phy_type
op_ne
l_int|0
)paren
id|smc_phy_configure
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|smc_10bt_check_media
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
)brace
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * smc_close&n; *&n; * this makes the board clean up everything that it can&n; * and not talk to the outside world.   Caused by&n; * an &squot;ifconfig ethX down&squot;&n; */
DECL|function|smc_close
r_static
r_int
id|smc_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_carrier_off
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* clear everything */
id|smc_shutdown
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;phy_type
op_ne
l_int|0
)paren
(brace
multiline_comment|/* We need to ensure that no calls to&n;&t;&t;   smc_phy_configure are pending.&n;&n;&t;&t;   flush_scheduled_work() cannot be called because we&n;&t;&t;   are running with the netlink semaphore held (from&n;&t;&t;   devinet_ioctl()) and the pending work queue&n;&t;&t;   contains linkwatch_event() (scheduled by&n;&t;&t;   netif_carrier_off() above). linkwatch_event() also&n;&t;&t;   wants the netlink semaphore.&n;&t;&t;*/
r_while
c_loop
(paren
id|lp-&gt;work_pending
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|smc_phy_powerdown
c_func
(paren
id|dev
comma
id|lp-&gt;mii.phy_id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;pending_tx_skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;pending_tx_skb
)paren
suffix:semicolon
id|lp-&gt;pending_tx_skb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the current statistics.&n; * This may be called with the card open or closed.&n; */
DECL|function|smc_query_statistics
r_static
r_struct
id|net_device_stats
op_star
id|smc_query_statistics
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n; * Ethtool support&n; */
r_static
r_int
DECL|function|smc_ethtool_getsettings
id|smc_ethtool_getsettings
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ethtool_cmd
op_star
id|cmd
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|cmd-&gt;maxtxpkt
op_assign
l_int|1
suffix:semicolon
id|cmd-&gt;maxrxpkt
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;phy_type
op_ne
l_int|0
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
id|mii_ethtool_gset
c_func
(paren
op_amp
id|lp-&gt;mii
comma
id|cmd
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd-&gt;supported
op_assign
id|SUPPORTED_10baseT_Half
op_or
id|SUPPORTED_10baseT_Full
op_or
id|SUPPORTED_TP
op_or
id|SUPPORTED_AUI
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;ctl_rspeed
op_eq
l_int|10
)paren
id|cmd-&gt;speed
op_assign
id|SPEED_10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|lp-&gt;ctl_rspeed
op_eq
l_int|100
)paren
id|cmd-&gt;speed
op_assign
id|SPEED_100
suffix:semicolon
id|cmd-&gt;autoneg
op_assign
id|AUTONEG_DISABLE
suffix:semicolon
id|cmd-&gt;transceiver
op_assign
id|XCVR_INTERNAL
suffix:semicolon
id|cmd-&gt;port
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;duplex
op_assign
id|lp-&gt;tcr_cur_mode
op_amp
id|TCR_SWFDUP
ques
c_cond
id|DUPLEX_FULL
suffix:colon
id|DUPLEX_HALF
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|smc_ethtool_setsettings
id|smc_ethtool_setsettings
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ethtool_cmd
op_star
id|cmd
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;phy_type
op_ne
l_int|0
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
id|mii_ethtool_sset
c_func
(paren
op_amp
id|lp-&gt;mii
comma
id|cmd
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cmd-&gt;autoneg
op_ne
id|AUTONEG_DISABLE
op_logical_or
id|cmd-&gt;speed
op_ne
id|SPEED_10
op_logical_or
(paren
id|cmd-&gt;duplex
op_ne
id|DUPLEX_HALF
op_logical_and
id|cmd-&gt;duplex
op_ne
id|DUPLEX_FULL
)paren
op_logical_or
(paren
id|cmd-&gt;port
op_ne
id|PORT_TP
op_logical_and
id|cmd-&gt;port
op_ne
id|PORT_AUI
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
singleline_comment|//&t;&t;lp-&gt;port = cmd-&gt;port;
id|lp-&gt;ctl_rfduplx
op_assign
id|cmd-&gt;duplex
op_eq
id|DUPLEX_FULL
suffix:semicolon
singleline_comment|//&t;&t;if (netif_running(dev))
singleline_comment|//&t;&t;&t;smc_set_port(dev);
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|smc_ethtool_getdrvinfo
id|smc_ethtool_getdrvinfo
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ethtool_drvinfo
op_star
id|info
)paren
(brace
id|strncpy
c_func
(paren
id|info-&gt;driver
comma
id|CARDNAME
comma
r_sizeof
(paren
id|info-&gt;driver
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info-&gt;version
comma
id|version
comma
r_sizeof
(paren
id|info-&gt;version
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info-&gt;bus_info
comma
id|dev-&gt;class_dev.dev-&gt;bus_id
comma
r_sizeof
(paren
id|info-&gt;bus_info
)paren
)paren
suffix:semicolon
)brace
DECL|function|smc_ethtool_nwayreset
r_static
r_int
id|smc_ethtool_nwayreset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;phy_type
op_ne
l_int|0
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
id|mii_nway_restart
c_func
(paren
op_amp
id|lp-&gt;mii
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|smc_ethtool_getmsglevel
r_static
id|u32
id|smc_ethtool_getmsglevel
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|lp-&gt;msg_enable
suffix:semicolon
)brace
DECL|function|smc_ethtool_setmsglevel
r_static
r_void
id|smc_ethtool_setmsglevel
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|level
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;msg_enable
op_assign
id|level
suffix:semicolon
)brace
DECL|variable|smc_ethtool_ops
r_static
r_struct
id|ethtool_ops
id|smc_ethtool_ops
op_assign
(brace
dot
id|get_settings
op_assign
id|smc_ethtool_getsettings
comma
dot
id|set_settings
op_assign
id|smc_ethtool_setsettings
comma
dot
id|get_drvinfo
op_assign
id|smc_ethtool_getdrvinfo
comma
dot
id|get_msglevel
op_assign
id|smc_ethtool_getmsglevel
comma
dot
id|set_msglevel
op_assign
id|smc_ethtool_setmsglevel
comma
dot
id|nway_reset
op_assign
id|smc_ethtool_nwayreset
comma
dot
id|get_link
op_assign
id|ethtool_op_get_link
comma
singleline_comment|//&t;.get_eeprom&t;= smc_ethtool_geteeprom,
singleline_comment|//&t;.set_eeprom&t;= smc_ethtool_seteeprom,
)brace
suffix:semicolon
multiline_comment|/*&n; * smc_findirq&n; *&n; * This routine has a simple purpose -- make the SMC chip generate an&n; * interrupt, so an auto-detect routine can detect it, and find the IRQ,&n; */
multiline_comment|/*&n; * does this still work?&n; *&n; * I just deleted auto_irq.c, since it was never built...&n; *   --jgarzik&n; */
DECL|function|smc_findirq
r_static
r_int
id|__init
id|smc_findirq
c_func
(paren
r_int
r_int
id|ioaddr
)paren
(brace
r_int
id|timeout
op_assign
l_int|20
suffix:semicolon
r_int
r_int
id|cookie
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|CARDNAME
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|cookie
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * What I try to do here is trigger an ALLOC_INT. This is done&n;&t; * by allocating a small chunk of memory, which will give an interrupt&n;&t; * when done.&n;&t; */
multiline_comment|/* enable ALLOCation interrupts ONLY */
id|SMC_SELECT_BANK
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|SMC_SET_INT_MASK
c_func
(paren
id|IM_ALLOC_INT
)paren
suffix:semicolon
multiline_comment|/*&n; &t; * Allocate 512 bytes of memory.  Note that the chip was just&n;&t; * reset so all the memory is available&n;&t; */
id|SMC_SET_MMU_CMD
c_func
(paren
id|MC_ALLOC
op_or
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait until positive that the interrupt has been generated&n;&t; */
r_do
(brace
r_int
id|int_status
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|int_status
op_assign
id|SMC_GET_INT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|int_status
op_amp
id|IM_ALLOC_INT
)paren
r_break
suffix:semicolon
multiline_comment|/* got the interrupt */
)brace
r_while
c_loop
(paren
op_decrement
id|timeout
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * there is really nothing that I can do here if timeout fails,&n;&t; * as autoirq_report will return a 0 anyway, which is what I&n;&t; * want in this case.   Plus, the clean up is needed in both&n;&t; * cases.&n;&t; */
multiline_comment|/* and disable all interrupts again */
id|SMC_SET_INT_MASK
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* and return what I found */
r_return
id|probe_irq_off
c_func
(paren
id|cookie
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: smc_probe(unsigned long ioaddr)&n; *&n; * Purpose:&n; *&t;Tests to see if a given ioaddr points to an SMC91x chip.&n; *&t;Returns a 0 on success&n; *&n; * Algorithm:&n; *&t;(1) see if the high byte of BANK_SELECT is 0x33&n; * &t;(2) compare the ioaddr with the base register&squot;s address&n; *&t;(3) see if I recognize the chip ID in the appropriate register&n; *&n; * Here I do typical initialization tasks.&n; *&n; * o  Initialize the structure if needed&n; * o  print out my vanity message if not done so already&n; * o  print out what type of hardware is detected&n; * o  print out the ethernet address&n; * o  find the IRQ&n; * o  set up my private data&n; * o  configure the dev structure with my subroutines&n; * o  actually GRAB the irq.&n; * o  GRAB the region&n; */
DECL|function|smc_probe
r_static
r_int
id|__init
id|smc_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|ioaddr
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|retval
suffix:semicolon
r_int
r_int
id|val
comma
id|revision_register
suffix:semicolon
r_const
r_char
op_star
id|version_string
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|CARDNAME
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* First, see if the high byte is 0x33 */
id|val
op_assign
id|SMC_CURRENT_BANK
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: bank signature probe returned 0x%04x&bslash;n&quot;
comma
id|CARDNAME
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_amp
l_int|0xFF00
)paren
op_ne
l_int|0x3300
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_amp
l_int|0xFF
)paren
op_eq
l_int|0x33
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Detected possible byte-swapped interface&quot;
l_string|&quot; at IOADDR 0x%lx&bslash;n&quot;
comma
id|CARDNAME
comma
id|ioaddr
)paren
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The above MIGHT indicate a device, but I need to write to&n;&t; * further test this.&n;&t; */
id|SMC_SELECT_BANK
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|val
op_assign
id|SMC_CURRENT_BANK
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_amp
l_int|0xFF00
)paren
op_ne
l_int|0x3300
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * well, we&squot;ve already written once, so hopefully another&n;&t; * time won&squot;t hurt.  This time, I need to switch the bank&n;&t; * register to bank 1, so I can access the base address&n;&t; * register&n;&t; */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|val
op_assign
id|SMC_GET_BASE
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
(paren
(paren
id|val
op_amp
l_int|0x1F00
)paren
op_rshift
l_int|3
)paren
op_lshift
id|SMC_IO_SHIFT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ioaddr
op_amp
(paren
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_lshift
id|SMC_IO_SHIFT
)paren
)paren
op_ne
id|val
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: IOADDR %lx doesn&squot;t match configuration (%x).&bslash;n&quot;
comma
id|CARDNAME
comma
id|ioaddr
comma
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check if the revision register is something that I&n;&t; * recognize.  These might need to be added to later,&n;&t; * as future revisions could be added.&n;&t; */
id|SMC_SELECT_BANK
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|revision_register
op_assign
id|SMC_GET_REV
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_int|2
comma
l_string|&quot;%s: revision = 0x%04x&bslash;n&quot;
comma
id|CARDNAME
comma
id|revision_register
)paren
suffix:semicolon
id|version_string
op_assign
id|chip_ids
(braket
(paren
id|revision_register
op_rshift
l_int|4
)paren
op_amp
l_int|0xF
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|version_string
op_logical_or
(paren
id|revision_register
op_amp
l_int|0xff00
)paren
op_ne
l_int|0x3300
)paren
(brace
multiline_comment|/* I don&squot;t recognize this chip, so... */
id|printk
c_func
(paren
l_string|&quot;%s: IO 0x%lx: Unrecognized revision register 0x%04x&quot;
l_string|&quot;, Contact author.&bslash;n&quot;
comma
id|CARDNAME
comma
id|ioaddr
comma
id|revision_register
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* At this point I&squot;ll assume that the chip is an SMC91x. */
r_if
c_cond
(paren
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
multiline_comment|/* fill in some of the fields */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
id|lp-&gt;version
op_assign
id|revision_register
op_amp
l_int|0xff
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Get the MAC address */
id|SMC_SELECT_BANK
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|SMC_GET_MAC_ADDR
c_func
(paren
id|dev-&gt;dev_addr
)paren
suffix:semicolon
multiline_comment|/* now, reset the chip, and put it into a known state */
id|smc_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If dev-&gt;irq is 0, then the device has to be banged on to see&n;&t; * what the IRQ is.&n; &t; *&n;&t; * This banging doesn&squot;t always detect the IRQ, for unknown reasons.&n;&t; * a workaround is to reset the chip and try again.&n;&t; *&n;&t; * Interestingly, the DOS packet driver *SETS* the IRQ on the card to&n;&t; * be what is requested on the command line.   I don&squot;t do that, mostly&n;&t; * because the card that I have uses a non-standard method of accessing&n;&t; * the IRQs, and because this _should_ work in most configurations.&n;&t; *&n;&t; * Specifying an IRQ is done with the assumption that the user knows&n;&t; * what (s)he is doing.  No checking is done!!!!&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|1
)paren
(brace
r_int
id|trials
suffix:semicolon
id|trials
op_assign
l_int|3
suffix:semicolon
r_while
c_loop
(paren
id|trials
op_decrement
)paren
(brace
id|dev-&gt;irq
op_assign
id|smc_findirq
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
)paren
r_break
suffix:semicolon
multiline_comment|/* kick the card and try again */
id|smc_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Couldn&squot;t autodetect your IRQ. Use irq=xx.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|dev-&gt;irq
op_assign
id|irq_canonicalize
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet values. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|smc_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|smc_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|smc_hard_start_xmit
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|smc_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|msecs_to_jiffies
c_func
(paren
id|watchdog
)paren
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|smc_query_statistics
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|smc_set_multicast_list
suffix:semicolon
id|dev-&gt;ethtool_ops
op_assign
op_amp
id|smc_ethtool_ops
suffix:semicolon
macro_line|#ifdef CONFIG_NET_POLL_CONTROLLER
id|dev-&gt;poll_controller
op_assign
id|smc_poll_controller
suffix:semicolon
macro_line|#endif
id|tasklet_init
c_func
(paren
op_amp
id|lp-&gt;tx_task
comma
id|smc_hardware_send_pkt
comma
(paren
r_int
r_int
)paren
id|dev
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|lp-&gt;phy_configure
comma
id|smc_phy_configure
comma
id|dev
)paren
suffix:semicolon
id|lp-&gt;mii.phy_id_mask
op_assign
l_int|0x1f
suffix:semicolon
id|lp-&gt;mii.reg_num_mask
op_assign
l_int|0x1f
suffix:semicolon
id|lp-&gt;mii.force_media
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;mii.full_duplex
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;mii.dev
op_assign
id|dev
suffix:semicolon
id|lp-&gt;mii.mdio_read
op_assign
id|smc_phy_read
suffix:semicolon
id|lp-&gt;mii.mdio_write
op_assign
id|smc_phy_write
suffix:semicolon
multiline_comment|/*&n;&t; * Locate the phy, if any.&n;&t; */
r_if
c_cond
(paren
id|lp-&gt;version
op_ge
(paren
id|CHIP_91100
op_lshift
l_int|4
)paren
)paren
id|smc_phy_detect
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Set default parameters */
id|lp-&gt;msg_enable
op_assign
id|NETIF_MSG_LINK
suffix:semicolon
id|lp-&gt;ctl_rfduplx
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;ctl_rspeed
op_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;version
op_ge
(paren
id|CHIP_91100
op_lshift
l_int|4
)paren
)paren
(brace
id|lp-&gt;ctl_rfduplx
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;ctl_rspeed
op_assign
l_int|100
suffix:semicolon
)brace
multiline_comment|/* Grab the IRQ */
id|retval
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|smc_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|err_out
suffix:semicolon
id|set_irq_type
c_func
(paren
id|dev-&gt;irq
comma
id|IRQT_RISING
)paren
suffix:semicolon
macro_line|#ifdef SMC_USE_PXA_DMA
(brace
r_int
id|dma
op_assign
id|pxa_request_dma
c_func
(paren
id|dev-&gt;name
comma
id|DMA_PRIO_LOW
comma
id|smc_pxa_dma_irq
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma
op_ge
l_int|0
)paren
id|dev-&gt;dma
op_assign
id|dma
suffix:semicolon
)brace
macro_line|#endif
id|retval
op_assign
id|register_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
multiline_comment|/* now, print out the card info, in a short format.. */
id|printk
c_func
(paren
l_string|&quot;%s: %s (rev %d) at %#lx IRQ %d&quot;
comma
id|dev-&gt;name
comma
id|version_string
comma
id|revision_register
op_amp
l_int|0x0f
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dma
op_ne
(paren
r_int
r_char
)paren
op_minus
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; DMA %d&quot;
comma
id|dev-&gt;dma
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s%s&bslash;n&quot;
comma
id|nowait
ques
c_cond
l_string|&quot; [nowait]&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|THROTTLE_TX_PKTS
ques
c_cond
l_string|&quot; [throttle_tx]&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_valid_ether_addr
c_func
(paren
id|dev-&gt;dev_addr
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Invalid ethernet MAC address.  Please &quot;
l_string|&quot;set using ifconfig&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Print the Ethernet address */
id|printk
c_func
(paren
l_string|&quot;%s: Ethernet addr: &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%2.2x&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;phy_type
op_eq
l_int|0
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: No PHY found&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lp-&gt;phy_type
op_amp
l_int|0xfffffff0
)paren
op_eq
l_int|0x0016f840
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: PHY LAN83C183 (LAN91C111 Internal)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lp-&gt;phy_type
op_amp
l_int|0xfffffff0
)paren
op_eq
l_int|0x02821c50
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;%s: PHY LAN83C180&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|err_out
suffix:colon
macro_line|#ifdef SMC_USE_PXA_DMA
r_if
c_cond
(paren
id|retval
op_logical_and
id|dev-&gt;dma
op_ne
(paren
r_int
r_char
)paren
op_minus
l_int|1
)paren
id|pxa_free_dma
c_func
(paren
id|dev-&gt;dma
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
DECL|function|smc_enable_device
r_static
r_int
id|smc_enable_device
c_func
(paren
r_int
r_int
id|attrib_phys
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|ecor
comma
id|ecsr
suffix:semicolon
r_void
op_star
id|addr
suffix:semicolon
multiline_comment|/*&n;&t; * Map the attribute space.  This is overkill, but clean.&n;&t; */
id|addr
op_assign
id|ioremap
c_func
(paren
id|attrib_phys
comma
id|ATTRIB_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n;&t; * Reset the device.  We must disable IRQs around this&n;&t; * since a reset causes the IRQ line become active.&n;&t; */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ecor
op_assign
id|readb
c_func
(paren
id|addr
op_plus
(paren
id|ECOR
op_lshift
id|SMC_IO_SHIFT
)paren
)paren
op_amp
op_complement
id|ECOR_RESET
suffix:semicolon
id|writeb
c_func
(paren
id|ecor
op_or
id|ECOR_RESET
comma
id|addr
op_plus
(paren
id|ECOR
op_lshift
id|SMC_IO_SHIFT
)paren
)paren
suffix:semicolon
id|readb
c_func
(paren
id|addr
op_plus
(paren
id|ECOR
op_lshift
id|SMC_IO_SHIFT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait 100us for the chip to reset.&n;&t; */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The device will ignore all writes to the enable bit while&n;&t; * reset is asserted, even if the reset bit is cleared in the&n;&t; * same write.  Must clear reset first, then enable the device.&n;&t; */
id|writeb
c_func
(paren
id|ecor
comma
id|addr
op_plus
(paren
id|ECOR
op_lshift
id|SMC_IO_SHIFT
)paren
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|ecor
op_or
id|ECOR_ENABLE
comma
id|addr
op_plus
(paren
id|ECOR
op_lshift
id|SMC_IO_SHIFT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the appropriate byte/word mode.&n;&t; */
id|ecsr
op_assign
id|readb
c_func
(paren
id|addr
op_plus
(paren
id|ECSR
op_lshift
id|SMC_IO_SHIFT
)paren
)paren
op_amp
op_complement
id|ECSR_IOIS8
suffix:semicolon
macro_line|#ifndef SMC_CAN_USE_16BIT
id|ecsr
op_or_assign
id|ECSR_IOIS8
suffix:semicolon
macro_line|#endif
id|writeb
c_func
(paren
id|ecsr
comma
id|addr
op_plus
(paren
id|ECSR
op_lshift
id|SMC_IO_SHIFT
)paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|addr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for the chip to wake up.  We could poll the control&n;&t; * register in the main register space, but that isn&squot;t mapped&n;&t; * yet.  We know this is going to take 750us.&n;&t; */
id|msleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * smc_init(void)&n; *   Input parameters:&n; *&t;dev-&gt;base_addr == 0, try to find all possible locations&n; *&t;dev-&gt;base_addr &gt; 0x1ff, this is the address to check&n; *&t;dev-&gt;base_addr == &lt;anything else&gt;, return failure code&n; *&n; *   Output:&n; *&t;0 --&gt; there is a device&n; *&t;anything else, error&n; */
DECL|function|smc_drv_probe
r_static
r_int
id|smc_drv_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|platform_device
op_star
id|pdev
op_assign
id|to_platform_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|net_device
op_star
id|ndev
suffix:semicolon
r_struct
id|resource
op_star
id|res
comma
op_star
id|ext
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
op_star
id|addr
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|res
op_assign
id|platform_get_resource
c_func
(paren
id|pdev
comma
id|IORESOURCE_MEM
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Request the regions.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
c_func
(paren
id|res-&gt;start
comma
id|SMC_IO_EXTENT
comma
l_string|&quot;smc91x&quot;
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ndev
op_assign
id|alloc_etherdev
c_func
(paren
r_sizeof
(paren
r_struct
id|smc_local
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ndev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: could not allocate device.&bslash;n&quot;
comma
id|CARDNAME
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|release_1
suffix:semicolon
)brace
id|SET_MODULE_OWNER
c_func
(paren
id|ndev
)paren
suffix:semicolon
id|SET_NETDEV_DEV
c_func
(paren
id|ndev
comma
id|dev
)paren
suffix:semicolon
id|ndev-&gt;dma
op_assign
(paren
r_int
r_char
)paren
op_minus
l_int|1
suffix:semicolon
id|ndev-&gt;irq
op_assign
id|platform_get_irq
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|ext
op_assign
id|platform_get_resource
c_func
(paren
id|pdev
comma
id|IORESOURCE_MEM
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ext
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
c_func
(paren
id|ext-&gt;start
comma
id|ATTRIB_SIZE
comma
id|ndev-&gt;name
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|release_1
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_SA1100_ASSABET)
id|NCR_0
op_or_assign
id|NCR_ENET_OSC_EN
suffix:semicolon
macro_line|#endif
id|ret
op_assign
id|smc_enable_device
c_func
(paren
id|ext-&gt;start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|release_both
suffix:semicolon
)brace
id|addr
op_assign
id|ioremap
c_func
(paren
id|res-&gt;start
comma
id|SMC_IO_EXTENT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|release_both
suffix:semicolon
)brace
id|dev_set_drvdata
c_func
(paren
id|dev
comma
id|ndev
)paren
suffix:semicolon
id|ret
op_assign
id|smc_probe
c_func
(paren
id|ndev
comma
(paren
r_int
r_int
)paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|dev_set_drvdata
c_func
(paren
id|dev
comma
l_int|NULL
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|addr
)paren
suffix:semicolon
id|release_both
suffix:colon
r_if
c_cond
(paren
id|ext
)paren
id|release_mem_region
c_func
(paren
id|ext-&gt;start
comma
id|ATTRIB_SIZE
)paren
suffix:semicolon
id|free_netdev
c_func
(paren
id|ndev
)paren
suffix:semicolon
id|release_1
suffix:colon
id|release_mem_region
c_func
(paren
id|res-&gt;start
comma
id|SMC_IO_EXTENT
)paren
suffix:semicolon
id|out
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: not found (%d).&bslash;n&quot;
comma
id|CARDNAME
comma
id|ret
)paren
suffix:semicolon
)brace
macro_line|#ifdef SMC_USE_PXA_DMA
r_else
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|ndev
)paren
suffix:semicolon
id|lp-&gt;physaddr
op_assign
id|res-&gt;start
suffix:semicolon
)brace
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
DECL|function|smc_drv_remove
r_static
r_int
id|smc_drv_remove
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|platform_device
op_star
id|pdev
op_assign
id|to_platform_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|net_device
op_star
id|ndev
op_assign
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
id|dev_set_drvdata
c_func
(paren
id|dev
comma
l_int|NULL
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|ndev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|ndev-&gt;irq
comma
id|ndev
)paren
suffix:semicolon
macro_line|#ifdef SMC_USE_PXA_DMA
r_if
c_cond
(paren
id|ndev-&gt;dma
op_ne
(paren
r_int
r_char
)paren
op_minus
l_int|1
)paren
id|pxa_free_dma
c_func
(paren
id|ndev-&gt;dma
)paren
suffix:semicolon
macro_line|#endif
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|ndev-&gt;base_addr
)paren
suffix:semicolon
id|res
op_assign
id|platform_get_resource
c_func
(paren
id|pdev
comma
id|IORESOURCE_MEM
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
id|release_mem_region
c_func
(paren
id|res-&gt;start
comma
id|ATTRIB_SIZE
)paren
suffix:semicolon
id|res
op_assign
id|platform_get_resource
c_func
(paren
id|pdev
comma
id|IORESOURCE_MEM
comma
l_int|0
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|res-&gt;start
comma
id|SMC_IO_EXTENT
)paren
suffix:semicolon
id|free_netdev
c_func
(paren
id|ndev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|smc_drv_suspend
r_static
r_int
id|smc_drv_suspend
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|state
comma
id|u32
id|level
)paren
(brace
r_struct
id|net_device
op_star
id|ndev
op_assign
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ndev
op_logical_and
id|level
op_eq
id|SUSPEND_DISABLE
)paren
(brace
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|ndev
)paren
)paren
(brace
id|netif_device_detach
c_func
(paren
id|ndev
)paren
suffix:semicolon
id|smc_shutdown
c_func
(paren
id|ndev
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|smc_drv_resume
r_static
r_int
id|smc_drv_resume
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|level
)paren
(brace
r_struct
id|platform_device
op_star
id|pdev
op_assign
id|to_platform_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|net_device
op_star
id|ndev
op_assign
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ndev
op_logical_and
id|level
op_eq
id|RESUME_ENABLE
)paren
(brace
r_struct
id|smc_local
op_star
id|lp
op_assign
id|netdev_priv
c_func
(paren
id|ndev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;num_resources
op_eq
l_int|3
)paren
id|smc_enable_device
c_func
(paren
id|pdev-&gt;resource
(braket
l_int|2
)braket
dot
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|ndev
)paren
)paren
(brace
id|smc_reset
c_func
(paren
id|ndev
)paren
suffix:semicolon
id|smc_enable
c_func
(paren
id|ndev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;phy_type
op_ne
l_int|0
)paren
id|smc_phy_configure
c_func
(paren
id|ndev
)paren
suffix:semicolon
id|netif_device_attach
c_func
(paren
id|ndev
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|smc_driver
r_static
r_struct
id|device_driver
id|smc_driver
op_assign
(brace
dot
id|name
op_assign
id|CARDNAME
comma
dot
id|bus
op_assign
op_amp
id|platform_bus_type
comma
dot
id|probe
op_assign
id|smc_drv_probe
comma
dot
id|remove
op_assign
id|smc_drv_remove
comma
dot
id|suspend
op_assign
id|smc_drv_suspend
comma
dot
id|resume
op_assign
id|smc_drv_resume
comma
)brace
suffix:semicolon
DECL|function|smc_init
r_static
r_int
id|__init
id|smc_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
macro_line|#ifdef CONFIG_ISA
r_if
c_cond
(paren
id|io
op_eq
op_minus
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: You shouldn&squot;t use auto-probing with insmod!&bslash;n&quot;
comma
id|CARDNAME
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_return
id|driver_register
c_func
(paren
op_amp
id|smc_driver
)paren
suffix:semicolon
)brace
DECL|function|smc_cleanup
r_static
r_void
id|__exit
id|smc_cleanup
c_func
(paren
r_void
)paren
(brace
id|driver_unregister
c_func
(paren
op_amp
id|smc_driver
)paren
suffix:semicolon
)brace
DECL|variable|smc_init
id|module_init
c_func
(paren
id|smc_init
)paren
suffix:semicolon
DECL|variable|smc_cleanup
id|module_exit
c_func
(paren
id|smc_cleanup
)paren
suffix:semicolon
eof
