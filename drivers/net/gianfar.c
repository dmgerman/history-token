multiline_comment|/* &n; * drivers/net/gianfar.c&n; *&n; * Gianfar Ethernet Driver&n; * Driver for FEC on MPC8540 and TSEC on MPC8540/MPC8560&n; * Based on 8260_io/fcc_enet.c&n; *&n; * Author: Andy Fleming&n; * Maintainer: Kumar Gala (kumar.gala@freescale.com)&n; *&n; * Copyright (c) 2002-2004 Freescale Semiconductor, Inc.&n; *&n; * This program is free software; you can redistribute  it and/or modify it&n; * under  the terms of  the GNU General  Public License as published by the&n; * Free Software Foundation;  either version 2 of the  License, or (at your&n; * option) any later version.&n; *&n; *  Gianfar:  AKA Lambda Draconis, &quot;Dragon&quot;&n; *  RA 11 31 24.2&n; *  Dec +69 19 52&n; *  V 3.84&n; *  B-V +1.62&n; *&n; *  Theory of operation&n; *  This driver is designed for the Triple-speed Ethernet&n; *  controllers on the Freescale 8540/8560 integrated processors,&n; *  as well as the Fast Ethernet Controller on the 8540.  &n; *  &n; *  The driver is initialized through platform_device.  Structures which&n; *  define the configuration needed by the board are defined in a&n; *  board structure in arch/ppc/platforms (though I do not&n; *  discount the possibility that other architectures could one&n; *  day be supported.  One assumption the driver currently makes&n; *  is that the PHY is configured in such a way to advertise all&n; *  capabilities.  This is a sensible default, and on certain&n; *  PHYs, changing this default encounters substantial errata&n; *  issues.  Future versions may remove this requirement, but for&n; *  now, it is best for the firmware to ensure this is the case.&n; *&n; *  The Gianfar Ethernet Controller uses a ring of buffer&n; *  descriptors.  The beginning is indicated by a register&n; *  pointing to the physical address of the start of the ring. &n; *  The end is determined by a &quot;wrap&quot; bit being set in the &n; *  last descriptor of the ring.&n; *&n; *  When a packet is received, the RXF bit in the&n; *  IEVENT register is set, triggering an interrupt when the &n; *  corresponding bit in the IMASK register is also set (if&n; *  interrupt coalescing is active, then the interrupt may not&n; *  happen immediately, but will wait until either a set number&n; *  of frames or amount of time have passed.).  In NAPI, the&n; *  interrupt handler will signal there is work to be done, and&n; *  exit.  Without NAPI, the packet(s) will be handled&n; *  immediately.  Both methods will start at the last known empty&n; *  descriptor, and process every subsequent descriptor until there &n; *  are none left with data (NAPI will stop after a set number of&n; *  packets to give time to other tasks, but will eventually&n; *  process all the packets).  The data arrives inside a&n; *  pre-allocated skb, and so after the skb is passed up to the&n; *  stack, a new skb must be allocated, and the address field in&n; *  the buffer descriptor must be updated to indicate this new&n; *  skb.&n; *&n; *  When the kernel requests that a packet be transmitted, the&n; *  driver starts where it left off last time, and points the&n; *  descriptor at the buffer which was passed in.  The driver&n; *  then informs the DMA engine that there are packets ready to&n; *  be transmitted.  Once the controller is finished transmitting&n; *  the packet, an interrupt may be triggered (under the same&n; *  conditions as for reception, but depending on the TXF bit).&n; *  The driver then cleans up the buffer.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/dma-mapping.h&gt;
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &quot;gianfar.h&quot;
macro_line|#include &quot;gianfar_phy.h&quot;
DECL|macro|TX_TIMEOUT
mdefine_line|#define TX_TIMEOUT      (1*HZ)
DECL|macro|SKB_ALLOC_TIMEOUT
mdefine_line|#define SKB_ALLOC_TIMEOUT 1000000
DECL|macro|BRIEF_GFAR_ERRORS
macro_line|#undef BRIEF_GFAR_ERRORS
DECL|macro|VERBOSE_GFAR_ERRORS
macro_line|#undef VERBOSE_GFAR_ERRORS
macro_line|#ifdef CONFIG_GFAR_NAPI
DECL|macro|RECEIVE
mdefine_line|#define RECEIVE(x) netif_receive_skb(x)
macro_line|#else
DECL|macro|RECEIVE
mdefine_line|#define RECEIVE(x) netif_rx(x)
macro_line|#endif
DECL|variable|gfar_driver_name
r_const
r_char
id|gfar_driver_name
(braket
)braket
op_assign
l_string|&quot;Gianfar Ethernet&quot;
suffix:semicolon
DECL|variable|gfar_driver_version
r_const
r_char
id|gfar_driver_version
(braket
)braket
op_assign
l_string|&quot;1.1&quot;
suffix:semicolon
r_int
id|startup_gfar
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|gfar_enet_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|gfar_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|gfar_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|gfar_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|gfar_new_skb
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|rxbd8
op_star
id|bdp
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|gfar_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|gfar_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|gfar_change_mtu
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|new_mtu
)paren
suffix:semicolon
r_static
id|irqreturn_t
id|gfar_error
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
id|irqreturn_t
id|gfar_transmit
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
id|irqreturn_t
id|gfar_receive
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
id|irqreturn_t
id|gfar_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
id|irqreturn_t
id|phy_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|gfar_phy_change
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_void
id|gfar_phy_timer
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|adjust_link
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|init_registers
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|init_phy
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|gfar_probe
c_func
(paren
r_struct
id|device
op_star
id|device
)paren
suffix:semicolon
r_static
r_int
id|gfar_remove
c_func
(paren
r_struct
id|device
op_star
id|device
)paren
suffix:semicolon
r_void
id|free_skb_resources
c_func
(paren
r_struct
id|gfar_private
op_star
id|priv
)paren
suffix:semicolon
r_static
r_void
id|gfar_set_multi
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|gfar_set_hash_for_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u8
op_star
id|addr
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_GFAR_NAPI
r_static
r_int
id|gfar_poll
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
op_star
id|budget
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|gfar_clean_rx_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|rx_work_limit
)paren
suffix:semicolon
r_static
r_int
id|gfar_process_frame
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|length
)paren
suffix:semicolon
r_static
r_void
id|gfar_phy_startup_timer
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_extern
r_struct
id|ethtool_ops
id|gfar_ethtool_ops
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Freescale Semiconductor, Inc&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Gianfar Ethernet Driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|function|gfar_probe
r_static
r_int
id|gfar_probe
c_func
(paren
r_struct
id|device
op_star
id|device
)paren
(brace
id|u32
id|tempval
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|platform_device
op_star
id|pdev
op_assign
id|to_platform_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_struct
id|gianfar_platform_data
op_star
id|einfo
suffix:semicolon
r_struct
id|resource
op_star
id|r
suffix:semicolon
r_int
id|idx
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|dev_ethtool_ops
op_assign
l_int|0
suffix:semicolon
id|einfo
op_assign
(paren
r_struct
id|gianfar_platform_data
op_star
)paren
id|pdev-&gt;dev.platform_data
suffix:semicolon
r_if
c_cond
(paren
id|einfo
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gfar %d: Missing additional data!&bslash;n&quot;
comma
id|pdev-&gt;id
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Create an ethernet device instance */
id|dev
op_assign
id|alloc_etherdev
c_func
(paren
r_sizeof
(paren
op_star
id|priv
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Set the info in the priv to the current info */
id|priv-&gt;einfo
op_assign
id|einfo
suffix:semicolon
multiline_comment|/* fill out IRQ fields */
r_if
c_cond
(paren
id|einfo-&gt;device_flags
op_amp
id|FSL_GIANFAR_DEV_HAS_MULTI_INTR
)paren
(brace
id|priv-&gt;interruptTransmit
op_assign
id|platform_get_irq_byname
c_func
(paren
id|pdev
comma
l_string|&quot;tx&quot;
)paren
suffix:semicolon
id|priv-&gt;interruptReceive
op_assign
id|platform_get_irq_byname
c_func
(paren
id|pdev
comma
l_string|&quot;rx&quot;
)paren
suffix:semicolon
id|priv-&gt;interruptError
op_assign
id|platform_get_irq_byname
c_func
(paren
id|pdev
comma
l_string|&quot;error&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|priv-&gt;interruptTransmit
op_assign
id|platform_get_irq
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* get a pointer to the register memory */
id|r
op_assign
id|platform_get_resource
c_func
(paren
id|pdev
comma
id|IORESOURCE_MEM
comma
l_int|0
)paren
suffix:semicolon
id|priv-&gt;regs
op_assign
(paren
r_struct
id|gfar
op_star
)paren
id|ioremap
c_func
(paren
id|r-&gt;start
comma
r_sizeof
(paren
r_struct
id|gfar
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;regs
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|regs_fail
suffix:semicolon
)brace
multiline_comment|/* Set the PHY base address */
id|priv-&gt;phyregs
op_assign
(paren
r_struct
id|gfar
op_star
)paren
id|ioremap
c_func
(paren
id|einfo-&gt;phy_reg_addr
comma
r_sizeof
(paren
r_struct
id|gfar
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;phyregs
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|phy_regs_fail
suffix:semicolon
)brace
id|spin_lock_init
c_func
(paren
op_amp
id|priv-&gt;lock
)paren
suffix:semicolon
id|dev_set_drvdata
c_func
(paren
id|device
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* Stop the DMA engine now, in case it was running before */
multiline_comment|/* (The firmware could have used it, and left it running). */
multiline_comment|/* To do this, we write Graceful Receive Stop and Graceful */
multiline_comment|/* Transmit Stop, and then wait until the corresponding bits */
multiline_comment|/* in IEVENT indicate the stops have completed. */
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;dmactrl
)paren
suffix:semicolon
id|tempval
op_and_assign
op_complement
(paren
id|DMACTRL_GRS
op_or
id|DMACTRL_GTS
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;dmactrl
comma
id|tempval
)paren
suffix:semicolon
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;dmactrl
)paren
suffix:semicolon
id|tempval
op_or_assign
(paren
id|DMACTRL_GRS
op_or
id|DMACTRL_GTS
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;dmactrl
comma
id|tempval
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;ievent
)paren
op_amp
(paren
id|IEVENT_GRSC
op_or
id|IEVENT_GTSC
)paren
)paren
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Reset MAC layer */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;maccfg1
comma
id|MACCFG1_SOFT_RESET
)paren
suffix:semicolon
id|tempval
op_assign
(paren
id|MACCFG1_TX_FLOW
op_or
id|MACCFG1_RX_FLOW
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;maccfg1
comma
id|tempval
)paren
suffix:semicolon
multiline_comment|/* Initialize MACCFG2. */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;maccfg2
comma
id|MACCFG2_INIT_SETTINGS
)paren
suffix:semicolon
multiline_comment|/* Initialize ECNTRL */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;ecntrl
comma
id|ECNTRL_INIT_SETTINGS
)paren
suffix:semicolon
multiline_comment|/* Copy the station address into the dev structure, */
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|einfo-&gt;mac_addr
comma
id|MAC_ADDR_LEN
)paren
suffix:semicolon
multiline_comment|/* Set the dev-&gt;base_addr to the gfar reg region */
id|dev-&gt;base_addr
op_assign
(paren
r_int
r_int
)paren
(paren
id|priv-&gt;regs
)paren
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
id|SET_NETDEV_DEV
c_func
(paren
id|dev
comma
id|device
)paren
suffix:semicolon
multiline_comment|/* Fill in the dev structure */
id|dev-&gt;open
op_assign
id|gfar_enet_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|gfar_start_xmit
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|gfar_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
macro_line|#ifdef CONFIG_GFAR_NAPI
id|dev-&gt;poll
op_assign
id|gfar_poll
suffix:semicolon
id|dev-&gt;weight
op_assign
id|GFAR_DEV_WEIGHT
suffix:semicolon
macro_line|#endif
id|dev-&gt;stop
op_assign
id|gfar_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|gfar_get_stats
suffix:semicolon
id|dev-&gt;change_mtu
op_assign
id|gfar_change_mtu
suffix:semicolon
id|dev-&gt;mtu
op_assign
l_int|1500
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|gfar_set_multi
suffix:semicolon
multiline_comment|/* Index into the array of possible ethtool&n;&t; * ops to catch all 4 possibilities */
r_if
c_cond
(paren
(paren
id|priv-&gt;einfo-&gt;device_flags
op_amp
id|FSL_GIANFAR_DEV_HAS_RMON
)paren
op_eq
l_int|0
)paren
(brace
id|dev_ethtool_ops
op_add_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|priv-&gt;einfo-&gt;device_flags
op_amp
id|FSL_GIANFAR_DEV_HAS_COALESCE
)paren
op_eq
l_int|0
)paren
(brace
id|dev_ethtool_ops
op_add_assign
l_int|2
suffix:semicolon
)brace
id|dev-&gt;ethtool_ops
op_assign
id|gfar_op_array
(braket
id|dev_ethtool_ops
)braket
suffix:semicolon
id|priv-&gt;rx_buffer_size
op_assign
id|DEFAULT_RX_BUFFER_SIZE
suffix:semicolon
macro_line|#ifdef CONFIG_GFAR_BUFSTASH
id|priv-&gt;rx_stash_size
op_assign
id|STASH_LENGTH
suffix:semicolon
macro_line|#endif
id|priv-&gt;tx_ring_size
op_assign
id|DEFAULT_TX_RING_SIZE
suffix:semicolon
id|priv-&gt;rx_ring_size
op_assign
id|DEFAULT_RX_RING_SIZE
suffix:semicolon
id|priv-&gt;txcoalescing
op_assign
id|DEFAULT_TX_COALESCE
suffix:semicolon
id|priv-&gt;txcount
op_assign
id|DEFAULT_TXCOUNT
suffix:semicolon
id|priv-&gt;txtime
op_assign
id|DEFAULT_TXTIME
suffix:semicolon
id|priv-&gt;rxcoalescing
op_assign
id|DEFAULT_RX_COALESCE
suffix:semicolon
id|priv-&gt;rxcount
op_assign
id|DEFAULT_RXCOUNT
suffix:semicolon
id|priv-&gt;rxtime
op_assign
id|DEFAULT_RXTIME
suffix:semicolon
id|err
op_assign
id|register_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Cannot register net device, aborting.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_goto
id|register_fail
suffix:semicolon
)brace
multiline_comment|/* Print out the device info */
id|printk
c_func
(paren
id|KERN_INFO
id|DEVICE_NAME
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|6
suffix:semicolon
id|idx
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%2.2x%c&quot;
comma
id|dev-&gt;dev_addr
(braket
id|idx
)braket
comma
id|idx
op_eq
l_int|5
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;:&squot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Even more device info helps when determining which kernel */
multiline_comment|/* provided which set of benchmarks.  Since this is global for all */
multiline_comment|/* devices, we only print it once */
macro_line|#ifdef CONFIG_GFAR_NAPI
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Running with NAPI enabled&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Running with NAPI disabled&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %d/%d RX/TX BD ring size&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|priv-&gt;rx_ring_size
comma
id|priv-&gt;tx_ring_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|register_fail
suffix:colon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|priv-&gt;phyregs
)paren
suffix:semicolon
id|phy_regs_fail
suffix:colon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|priv-&gt;regs
)paren
suffix:semicolon
id|regs_fail
suffix:colon
id|free_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|gfar_remove
r_static
r_int
id|gfar_remove
c_func
(paren
r_struct
id|device
op_star
id|device
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_get_drvdata
c_func
(paren
id|device
)paren
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev_set_drvdata
c_func
(paren
id|device
comma
l_int|NULL
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|priv-&gt;regs
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|priv-&gt;phyregs
)paren
suffix:semicolon
id|free_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Configure the PHY for dev.&n; * returns 0 if success.  -1 if failure&n; */
DECL|function|init_phy
r_static
r_int
id|init_phy
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|phy_info
op_star
id|curphy
suffix:semicolon
r_int
r_int
id|timeout
op_assign
id|PHY_INIT_TIMEOUT
suffix:semicolon
r_struct
id|gfar
op_star
id|phyregs
op_assign
id|priv-&gt;phyregs
suffix:semicolon
r_struct
id|gfar_mii_info
op_star
id|mii_info
suffix:semicolon
r_int
id|err
suffix:semicolon
id|priv-&gt;oldlink
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;oldspeed
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;oldduplex
op_assign
op_minus
l_int|1
suffix:semicolon
id|mii_info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|gfar_mii_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|mii_info
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Could not allocate mii_info&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|mii_info-&gt;speed
op_assign
id|SPEED_1000
suffix:semicolon
id|mii_info-&gt;duplex
op_assign
id|DUPLEX_FULL
suffix:semicolon
id|mii_info-&gt;pause
op_assign
l_int|0
suffix:semicolon
id|mii_info-&gt;link
op_assign
l_int|1
suffix:semicolon
id|mii_info-&gt;advertising
op_assign
(paren
id|ADVERTISED_10baseT_Half
op_or
id|ADVERTISED_10baseT_Full
op_or
id|ADVERTISED_100baseT_Half
op_or
id|ADVERTISED_100baseT_Full
op_or
id|ADVERTISED_1000baseT_Full
)paren
suffix:semicolon
id|mii_info-&gt;autoneg
op_assign
l_int|1
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|mii_info-&gt;mdio_lock
)paren
suffix:semicolon
id|mii_info-&gt;mii_id
op_assign
id|priv-&gt;einfo-&gt;phyid
suffix:semicolon
id|mii_info-&gt;dev
op_assign
id|dev
suffix:semicolon
id|mii_info-&gt;mdio_read
op_assign
op_amp
id|read_phy_reg
suffix:semicolon
id|mii_info-&gt;mdio_write
op_assign
op_amp
id|write_phy_reg
suffix:semicolon
id|priv-&gt;mii_info
op_assign
id|mii_info
suffix:semicolon
multiline_comment|/* Reset the management interface */
id|gfar_write
c_func
(paren
op_amp
id|phyregs-&gt;miimcfg
comma
id|MIIMCFG_RESET
)paren
suffix:semicolon
multiline_comment|/* Setup the MII Mgmt clock speed */
id|gfar_write
c_func
(paren
op_amp
id|phyregs-&gt;miimcfg
comma
id|MIIMCFG_INIT_VALUE
)paren
suffix:semicolon
multiline_comment|/* Wait until the bus is free */
r_while
c_loop
(paren
(paren
id|gfar_read
c_func
(paren
op_amp
id|phyregs-&gt;miimind
)paren
op_amp
id|MIIMIND_BUSY
)paren
op_logical_and
id|timeout
op_decrement
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: The MII Bus is stuck!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|bus_fail
suffix:semicolon
)brace
multiline_comment|/* get info for this PHY */
id|curphy
op_assign
id|get_phy_info
c_func
(paren
id|priv-&gt;mii_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curphy
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: No PHY found&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|no_phy
suffix:semicolon
)brace
id|mii_info-&gt;phyinfo
op_assign
id|curphy
suffix:semicolon
multiline_comment|/* Run the commands which initialize the PHY */
r_if
c_cond
(paren
id|curphy-&gt;init
)paren
(brace
id|err
op_assign
id|curphy
op_member_access_from_pointer
id|init
c_func
(paren
id|priv-&gt;mii_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|phy_init_fail
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|phy_init_fail
suffix:colon
id|no_phy
suffix:colon
id|bus_fail
suffix:colon
id|kfree
c_func
(paren
id|mii_info
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|init_registers
r_static
r_void
id|init_registers
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Clear IEVENT */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;ievent
comma
id|IEVENT_INIT_CLEAR
)paren
suffix:semicolon
multiline_comment|/* Initialize IMASK */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;imask
comma
id|IMASK_INIT_CLEAR
)paren
suffix:semicolon
multiline_comment|/* Init hash registers to zero */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;iaddr0
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;iaddr1
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;iaddr2
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;iaddr3
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;iaddr4
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;iaddr5
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;iaddr6
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;iaddr7
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;gaddr0
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;gaddr1
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;gaddr2
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;gaddr3
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;gaddr4
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;gaddr5
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;gaddr6
comma
l_int|0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;gaddr7
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Zero out rctrl */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;rctrl
comma
l_int|0x00000000
)paren
suffix:semicolon
multiline_comment|/* Zero out the rmon mib registers if it has them */
r_if
c_cond
(paren
id|priv-&gt;einfo-&gt;device_flags
op_amp
id|FSL_GIANFAR_DEV_HAS_RMON
)paren
(brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
(paren
id|priv-&gt;regs-&gt;rmon
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|rmon_mib
)paren
)paren
suffix:semicolon
multiline_comment|/* Mask off the CAM interrupts */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;rmon.cam1
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;rmon.cam2
comma
l_int|0xffffffff
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize the max receive buffer length */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;mrblr
comma
id|priv-&gt;rx_buffer_size
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_GFAR_BUFSTASH
multiline_comment|/* If we are stashing buffers, we need to set the&n;&t; * extraction length to the size of the buffer */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;attreli
comma
id|priv-&gt;rx_stash_size
op_lshift
l_int|16
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Initialize the Minimum Frame Length Register */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;minflr
comma
id|MINFLR_INIT_SETTINGS
)paren
suffix:semicolon
multiline_comment|/* Setup Attributes so that snooping is on for rx */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;attr
comma
id|ATTR_INIT_SETTINGS
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;attreli
comma
id|ATTRELI_INIT_SETTINGS
)paren
suffix:semicolon
multiline_comment|/* Assign the TBI an address which won&squot;t conflict with the PHYs */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;tbipa
comma
id|TBIPA_VALUE
)paren
suffix:semicolon
)brace
DECL|function|stop_gfar
r_void
id|stop_gfar
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|gfar
op_star
id|regs
op_assign
id|priv-&gt;regs
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u32
id|tempval
suffix:semicolon
multiline_comment|/* Lock it down */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Tell the kernel the link is down */
id|priv-&gt;mii_info-&gt;link
op_assign
l_int|0
suffix:semicolon
id|adjust_link
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Mask all interrupts */
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;imask
comma
id|IMASK_INIT_CLEAR
)paren
suffix:semicolon
multiline_comment|/* Clear all interrupts */
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;ievent
comma
id|IEVENT_INIT_CLEAR
)paren
suffix:semicolon
multiline_comment|/* Stop the DMA, and wait for it to stop */
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;dmactrl
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tempval
op_amp
(paren
id|DMACTRL_GRS
op_or
id|DMACTRL_GTS
)paren
)paren
op_ne
(paren
id|DMACTRL_GRS
op_or
id|DMACTRL_GTS
)paren
)paren
(brace
id|tempval
op_or_assign
(paren
id|DMACTRL_GRS
op_or
id|DMACTRL_GTS
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;dmactrl
comma
id|tempval
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;ievent
)paren
op_amp
(paren
id|IEVENT_GRSC
op_or
id|IEVENT_GTSC
)paren
)paren
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Disable Rx and Tx */
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|regs-&gt;maccfg1
)paren
suffix:semicolon
id|tempval
op_and_assign
op_complement
(paren
id|MACCFG1_RX_EN
op_or
id|MACCFG1_TX_EN
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;maccfg1
comma
id|tempval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;einfo-&gt;board_flags
op_amp
id|FSL_GIANFAR_BRD_HAS_PHY_INTR
)paren
(brace
multiline_comment|/* Clear any pending interrupts */
id|mii_clear_phy_interrupt
c_func
(paren
id|priv-&gt;mii_info
)paren
suffix:semicolon
multiline_comment|/* Disable PHY Interrupts */
id|mii_configure_phy_interrupt
c_func
(paren
id|priv-&gt;mii_info
comma
id|MII_INTERRUPT_DISABLED
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|priv-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Free the IRQs */
r_if
c_cond
(paren
id|priv-&gt;einfo-&gt;device_flags
op_amp
id|FSL_GIANFAR_DEV_HAS_MULTI_INTR
)paren
(brace
id|free_irq
c_func
(paren
id|priv-&gt;interruptError
comma
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|priv-&gt;interruptTransmit
comma
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|priv-&gt;interruptReceive
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_irq
c_func
(paren
id|priv-&gt;interruptTransmit
comma
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|priv-&gt;einfo-&gt;board_flags
op_amp
id|FSL_GIANFAR_BRD_HAS_PHY_INTR
)paren
(brace
id|free_irq
c_func
(paren
id|priv-&gt;einfo-&gt;interruptPHY
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer_sync
c_func
(paren
op_amp
id|priv-&gt;phy_info_timer
)paren
suffix:semicolon
)brace
id|free_skb_resources
c_func
(paren
id|priv
)paren
suffix:semicolon
id|dma_free_coherent
c_func
(paren
l_int|NULL
comma
r_sizeof
(paren
r_struct
id|txbd8
)paren
op_star
id|priv-&gt;tx_ring_size
op_plus
r_sizeof
(paren
r_struct
id|rxbd8
)paren
op_star
id|priv-&gt;rx_ring_size
comma
id|priv-&gt;tx_bd_base
comma
id|gfar_read
c_func
(paren
op_amp
id|regs-&gt;tbase
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* If there are any tx skbs or rx skbs still around, free them.&n; * Then free tx_skbuff and rx_skbuff */
DECL|function|free_skb_resources
r_void
id|free_skb_resources
c_func
(paren
r_struct
id|gfar_private
op_star
id|priv
)paren
(brace
r_struct
id|rxbd8
op_star
id|rxbdp
suffix:semicolon
r_struct
id|txbd8
op_star
id|txbdp
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Go through all the buffer descriptors and free their data buffers */
id|txbdp
op_assign
id|priv-&gt;tx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|priv-&gt;tx_ring_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;tx_skbuff
(braket
id|i
)braket
)paren
(brace
id|dma_unmap_single
c_func
(paren
l_int|NULL
comma
id|txbdp-&gt;bufPtr
comma
id|txbdp-&gt;length
comma
id|DMA_TO_DEVICE
)paren
suffix:semicolon
id|dev_kfree_skb_any
c_func
(paren
id|priv-&gt;tx_skbuff
(braket
id|i
)braket
)paren
suffix:semicolon
id|priv-&gt;tx_skbuff
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|priv-&gt;tx_skbuff
)paren
suffix:semicolon
id|rxbdp
op_assign
id|priv-&gt;rx_bd_base
suffix:semicolon
multiline_comment|/* rx_skbuff is not guaranteed to be allocated, so only&n;&t; * free it and its contents if it is allocated */
r_if
c_cond
(paren
id|priv-&gt;rx_skbuff
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|priv-&gt;rx_ring_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;rx_skbuff
(braket
id|i
)braket
)paren
(brace
id|dma_unmap_single
c_func
(paren
l_int|NULL
comma
id|rxbdp-&gt;bufPtr
comma
id|priv-&gt;rx_buffer_size
op_plus
id|RXBUF_ALIGNMENT
comma
id|DMA_FROM_DEVICE
)paren
suffix:semicolon
id|dev_kfree_skb_any
c_func
(paren
id|priv-&gt;rx_skbuff
(braket
id|i
)braket
)paren
suffix:semicolon
id|priv-&gt;rx_skbuff
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|rxbdp-&gt;status
op_assign
l_int|0
suffix:semicolon
id|rxbdp-&gt;length
op_assign
l_int|0
suffix:semicolon
id|rxbdp-&gt;bufPtr
op_assign
l_int|0
suffix:semicolon
id|rxbdp
op_increment
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|priv-&gt;rx_skbuff
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Bring the controller up and running */
DECL|function|startup_gfar
r_int
id|startup_gfar
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|txbd8
op_star
id|txbdp
suffix:semicolon
r_struct
id|rxbd8
op_star
id|rxbdp
suffix:semicolon
id|dma_addr_t
id|addr
suffix:semicolon
r_int
r_int
id|vaddr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|gfar
op_star
id|regs
op_assign
id|priv-&gt;regs
suffix:semicolon
id|u32
id|tempval
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;imask
comma
id|IMASK_INIT_CLEAR
)paren
suffix:semicolon
multiline_comment|/* Allocate memory for the buffer descriptors */
id|vaddr
op_assign
(paren
r_int
r_int
)paren
id|dma_alloc_coherent
c_func
(paren
l_int|NULL
comma
r_sizeof
(paren
r_struct
id|txbd8
)paren
op_star
id|priv-&gt;tx_ring_size
op_plus
r_sizeof
(paren
r_struct
id|rxbd8
)paren
op_star
id|priv-&gt;rx_ring_size
comma
op_amp
id|addr
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vaddr
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Could not allocate buffer descriptors!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|priv-&gt;tx_bd_base
op_assign
(paren
r_struct
id|txbd8
op_star
)paren
id|vaddr
suffix:semicolon
multiline_comment|/* enet DMA only understands physical addresses */
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;tbase
comma
id|addr
)paren
suffix:semicolon
multiline_comment|/* Start the rx descriptor ring where the tx ring leaves off */
id|addr
op_assign
id|addr
op_plus
r_sizeof
(paren
r_struct
id|txbd8
)paren
op_star
id|priv-&gt;tx_ring_size
suffix:semicolon
id|vaddr
op_assign
id|vaddr
op_plus
r_sizeof
(paren
r_struct
id|txbd8
)paren
op_star
id|priv-&gt;tx_ring_size
suffix:semicolon
id|priv-&gt;rx_bd_base
op_assign
(paren
r_struct
id|rxbd8
op_star
)paren
id|vaddr
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;rbase
comma
id|addr
)paren
suffix:semicolon
multiline_comment|/* Setup the skbuff rings */
id|priv-&gt;tx_skbuff
op_assign
(paren
r_struct
id|sk_buff
op_star
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sk_buff
op_star
)paren
op_star
id|priv-&gt;tx_ring_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;tx_skbuff
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Could not allocate tx_skbuff&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|tx_skb_fail
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|priv-&gt;tx_ring_size
suffix:semicolon
id|i
op_increment
)paren
id|priv-&gt;tx_skbuff
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|priv-&gt;rx_skbuff
op_assign
(paren
r_struct
id|sk_buff
op_star
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sk_buff
op_star
)paren
op_star
id|priv-&gt;rx_ring_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;rx_skbuff
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Could not allocate rx_skbuff&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|rx_skb_fail
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|priv-&gt;rx_ring_size
suffix:semicolon
id|i
op_increment
)paren
id|priv-&gt;rx_skbuff
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Initialize some variables in our dev structure */
id|priv-&gt;dirty_tx
op_assign
id|priv-&gt;cur_tx
op_assign
id|priv-&gt;tx_bd_base
suffix:semicolon
id|priv-&gt;cur_rx
op_assign
id|priv-&gt;rx_bd_base
suffix:semicolon
id|priv-&gt;skb_curtx
op_assign
id|priv-&gt;skb_dirtytx
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;skb_currx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize Transmit Descriptor Ring */
id|txbdp
op_assign
id|priv-&gt;tx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|priv-&gt;tx_ring_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|txbdp-&gt;status
op_assign
l_int|0
suffix:semicolon
id|txbdp-&gt;length
op_assign
l_int|0
suffix:semicolon
id|txbdp-&gt;bufPtr
op_assign
l_int|0
suffix:semicolon
id|txbdp
op_increment
suffix:semicolon
)brace
multiline_comment|/* Set the last descriptor in the ring to indicate wrap */
id|txbdp
op_decrement
suffix:semicolon
id|txbdp-&gt;status
op_or_assign
id|TXBD_WRAP
suffix:semicolon
id|rxbdp
op_assign
id|priv-&gt;rx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|priv-&gt;rx_ring_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|rxbdp-&gt;status
op_assign
l_int|0
suffix:semicolon
id|skb
op_assign
id|gfar_new_skb
c_func
(paren
id|dev
comma
id|rxbdp
)paren
suffix:semicolon
id|priv-&gt;rx_skbuff
(braket
id|i
)braket
op_assign
id|skb
suffix:semicolon
id|rxbdp
op_increment
suffix:semicolon
)brace
multiline_comment|/* Set the last descriptor in the ring to wrap */
id|rxbdp
op_decrement
suffix:semicolon
id|rxbdp-&gt;status
op_or_assign
id|RXBD_WRAP
suffix:semicolon
multiline_comment|/* If the device has multiple interrupts, register for&n;&t; * them.  Otherwise, only register for the one */
r_if
c_cond
(paren
id|priv-&gt;einfo-&gt;device_flags
op_amp
id|FSL_GIANFAR_DEV_HAS_MULTI_INTR
)paren
(brace
multiline_comment|/* Install our interrupt handlers for Error, &n;&t;&t; * Transmit, and Receive */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|priv-&gt;interruptError
comma
id|gfar_error
comma
l_int|0
comma
l_string|&quot;enet_error&quot;
comma
id|dev
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Can&squot;t get IRQ %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|priv-&gt;interruptError
)paren
suffix:semicolon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|err_irq_fail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|priv-&gt;interruptTransmit
comma
id|gfar_transmit
comma
l_int|0
comma
l_string|&quot;enet_tx&quot;
comma
id|dev
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Can&squot;t get IRQ %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|priv-&gt;interruptTransmit
)paren
suffix:semicolon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|tx_irq_fail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|priv-&gt;interruptReceive
comma
id|gfar_receive
comma
l_int|0
comma
l_string|&quot;enet_rx&quot;
comma
id|dev
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Can&squot;t get IRQ %d (receive0)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|priv-&gt;interruptReceive
)paren
suffix:semicolon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|rx_irq_fail
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|priv-&gt;interruptTransmit
comma
id|gfar_interrupt
comma
l_int|0
comma
l_string|&quot;gfar_interrupt&quot;
comma
id|dev
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Can&squot;t get IRQ %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|priv-&gt;interruptError
)paren
suffix:semicolon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|err_irq_fail
suffix:semicolon
)brace
)brace
multiline_comment|/* Set up the PHY change work queue */
id|INIT_WORK
c_func
(paren
op_amp
id|priv-&gt;tq
comma
id|gfar_phy_change
comma
id|dev
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|priv-&gt;phy_info_timer
)paren
suffix:semicolon
id|priv-&gt;phy_info_timer.function
op_assign
op_amp
id|gfar_phy_startup_timer
suffix:semicolon
id|priv-&gt;phy_info_timer.data
op_assign
(paren
r_int
r_int
)paren
id|priv-&gt;mii_info
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|priv-&gt;phy_info_timer
comma
id|jiffies
op_plus
id|HZ
)paren
suffix:semicolon
multiline_comment|/* Configure the coalescing support */
r_if
c_cond
(paren
id|priv-&gt;txcoalescing
)paren
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;txic
comma
id|mk_ic_value
c_func
(paren
id|priv-&gt;txcount
comma
id|priv-&gt;txtime
)paren
)paren
suffix:semicolon
r_else
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;txic
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;rxcoalescing
)paren
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;rxic
comma
id|mk_ic_value
c_func
(paren
id|priv-&gt;rxcount
comma
id|priv-&gt;rxtime
)paren
)paren
suffix:semicolon
r_else
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;rxic
comma
l_int|0
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|priv-&gt;rxcleanupq
)paren
suffix:semicolon
multiline_comment|/* Enable Rx and Tx in MACCFG1 */
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|regs-&gt;maccfg1
)paren
suffix:semicolon
id|tempval
op_or_assign
(paren
id|MACCFG1_RX_EN
op_or
id|MACCFG1_TX_EN
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;maccfg1
comma
id|tempval
)paren
suffix:semicolon
multiline_comment|/* Initialize DMACTRL to have WWR and WOP */
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;dmactrl
)paren
suffix:semicolon
id|tempval
op_or_assign
id|DMACTRL_INIT_SETTINGS
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;dmactrl
comma
id|tempval
)paren
suffix:semicolon
multiline_comment|/* Clear THLT, so that the DMA starts polling now */
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;tstat
comma
id|TSTAT_CLEAR_THALT
)paren
suffix:semicolon
multiline_comment|/* Make sure we aren&squot;t stopped */
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;dmactrl
)paren
suffix:semicolon
id|tempval
op_and_assign
op_complement
(paren
id|DMACTRL_GRS
op_or
id|DMACTRL_GTS
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;dmactrl
comma
id|tempval
)paren
suffix:semicolon
multiline_comment|/* Unmask the interrupts we look for */
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;imask
comma
id|IMASK_DEFAULT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|rx_irq_fail
suffix:colon
id|free_irq
c_func
(paren
id|priv-&gt;interruptTransmit
comma
id|dev
)paren
suffix:semicolon
id|tx_irq_fail
suffix:colon
id|free_irq
c_func
(paren
id|priv-&gt;interruptError
comma
id|dev
)paren
suffix:semicolon
id|err_irq_fail
suffix:colon
id|rx_skb_fail
suffix:colon
id|free_skb_resources
c_func
(paren
id|priv
)paren
suffix:semicolon
id|tx_skb_fail
suffix:colon
id|dma_free_coherent
c_func
(paren
l_int|NULL
comma
r_sizeof
(paren
r_struct
id|txbd8
)paren
op_star
id|priv-&gt;tx_ring_size
op_plus
r_sizeof
(paren
r_struct
id|rxbd8
)paren
op_star
id|priv-&gt;rx_ring_size
comma
id|priv-&gt;tx_bd_base
comma
id|gfar_read
c_func
(paren
op_amp
id|regs-&gt;tbase
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;mii_info-&gt;phyinfo-&gt;close
)paren
id|priv-&gt;mii_info-&gt;phyinfo
op_member_access_from_pointer
id|close
c_func
(paren
id|priv-&gt;mii_info
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|priv-&gt;mii_info
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Called when something needs to use the ethernet device */
multiline_comment|/* Returns 0 for success. */
DECL|function|gfar_enet_open
r_static
r_int
id|gfar_enet_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* Initialize a bunch of registers */
id|init_registers
c_func
(paren
id|dev
)paren
suffix:semicolon
id|gfar_set_mac_address
c_func
(paren
id|dev
)paren
suffix:semicolon
id|err
op_assign
id|init_phy
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|err
op_assign
id|startup_gfar
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* This is called by the kernel when a frame is ready for transmission. */
multiline_comment|/* It is pointed to by the dev-&gt;hard_start_xmit function pointer */
DECL|function|gfar_start_xmit
r_static
r_int
id|gfar_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|txbd8
op_star
id|txbdp
suffix:semicolon
multiline_comment|/* Update transmit stats */
id|priv-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/* Lock priv now */
id|spin_lock_irq
c_func
(paren
op_amp
id|priv-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Point at the first free tx descriptor */
id|txbdp
op_assign
id|priv-&gt;cur_tx
suffix:semicolon
multiline_comment|/* Clear all but the WRAP status flags */
id|txbdp-&gt;status
op_and_assign
id|TXBD_WRAP
suffix:semicolon
multiline_comment|/* Set buffer length and pointer */
id|txbdp-&gt;length
op_assign
id|skb-&gt;len
suffix:semicolon
id|txbdp-&gt;bufPtr
op_assign
id|dma_map_single
c_func
(paren
l_int|NULL
comma
id|skb-&gt;data
comma
id|skb-&gt;len
comma
id|DMA_TO_DEVICE
)paren
suffix:semicolon
multiline_comment|/* Save the skb pointer so we can free it later */
id|priv-&gt;tx_skbuff
(braket
id|priv-&gt;skb_curtx
)braket
op_assign
id|skb
suffix:semicolon
multiline_comment|/* Update the current skb pointer (wrapping if this was the last) */
id|priv-&gt;skb_curtx
op_assign
(paren
id|priv-&gt;skb_curtx
op_plus
l_int|1
)paren
op_amp
id|TX_RING_MOD_MASK
c_func
(paren
id|priv-&gt;tx_ring_size
)paren
suffix:semicolon
multiline_comment|/* Flag the BD as interrupt-causing */
id|txbdp-&gt;status
op_or_assign
id|TXBD_INTERRUPT
suffix:semicolon
multiline_comment|/* Flag the BD as ready to go, last in frame, and  */
multiline_comment|/* in need of CRC */
id|txbdp-&gt;status
op_or_assign
(paren
id|TXBD_READY
op_or
id|TXBD_LAST
op_or
id|TXBD_CRC
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* If this was the last BD in the ring, the next one */
multiline_comment|/* is at the beginning of the ring */
r_if
c_cond
(paren
id|txbdp-&gt;status
op_amp
id|TXBD_WRAP
)paren
id|txbdp
op_assign
id|priv-&gt;tx_bd_base
suffix:semicolon
r_else
id|txbdp
op_increment
suffix:semicolon
multiline_comment|/* If the next BD still needs to be cleaned up, then the bds&n;&t;   are full.  We need to tell the kernel to stop sending us stuff. */
r_if
c_cond
(paren
id|txbdp
op_eq
id|priv-&gt;dirty_tx
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|priv-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
)brace
multiline_comment|/* Update the current txbd to the next one */
id|priv-&gt;cur_tx
op_assign
id|txbdp
suffix:semicolon
multiline_comment|/* Tell the DMA to go go go */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;tstat
comma
id|TSTAT_CLEAR_THALT
)paren
suffix:semicolon
multiline_comment|/* Unlock priv */
id|spin_unlock_irq
c_func
(paren
op_amp
id|priv-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Stops the kernel queue, and halts the controller */
DECL|function|gfar_close
r_static
r_int
id|gfar_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|stop_gfar
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Shutdown the PHY */
r_if
c_cond
(paren
id|priv-&gt;mii_info-&gt;phyinfo-&gt;close
)paren
id|priv-&gt;mii_info-&gt;phyinfo
op_member_access_from_pointer
id|close
c_func
(paren
id|priv-&gt;mii_info
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|priv-&gt;mii_info
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* returns a net_device_stats structure pointer */
DECL|function|gfar_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|gfar_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_amp
(paren
id|priv-&gt;stats
)paren
suffix:semicolon
)brace
multiline_comment|/* Changes the mac address if the controller is not running. */
DECL|function|gfar_set_mac_address
r_int
id|gfar_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|tmpbuf
(braket
id|MAC_ADDR_LEN
)braket
suffix:semicolon
id|u32
id|tempval
suffix:semicolon
multiline_comment|/* Now copy it into the mac registers backwards, cuz */
multiline_comment|/* little endian is silly */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAC_ADDR_LEN
suffix:semicolon
id|i
op_increment
)paren
id|tmpbuf
(braket
id|MAC_ADDR_LEN
op_minus
l_int|1
op_minus
id|i
)braket
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;macstnaddr1
comma
op_star
(paren
(paren
id|u32
op_star
)paren
(paren
id|tmpbuf
)paren
)paren
)paren
suffix:semicolon
id|tempval
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
(paren
id|tmpbuf
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;macstnaddr2
comma
id|tempval
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gfar_change_mtu
r_static
r_int
id|gfar_change_mtu
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|new_mtu
)paren
(brace
r_int
id|tempsize
comma
id|tempval
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|oldsize
op_assign
id|priv-&gt;rx_buffer_size
suffix:semicolon
r_int
id|frame_size
op_assign
id|new_mtu
op_plus
l_int|18
suffix:semicolon
r_if
c_cond
(paren
(paren
id|frame_size
OL
l_int|64
)paren
op_logical_or
(paren
id|frame_size
OG
id|JUMBO_FRAME_SIZE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Invalid MTU setting&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|tempsize
op_assign
(paren
id|frame_size
op_amp
op_complement
(paren
id|INCREMENTAL_BUFFER_SIZE
op_minus
l_int|1
)paren
)paren
op_plus
id|INCREMENTAL_BUFFER_SIZE
suffix:semicolon
multiline_comment|/* Only stop and start the controller if it isn&squot;t already&n;&t; * stopped */
r_if
c_cond
(paren
(paren
id|oldsize
op_ne
id|tempsize
)paren
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
id|stop_gfar
c_func
(paren
id|dev
)paren
suffix:semicolon
id|priv-&gt;rx_buffer_size
op_assign
id|tempsize
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;mrblr
comma
id|priv-&gt;rx_buffer_size
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;maxfrm
comma
id|priv-&gt;rx_buffer_size
)paren
suffix:semicolon
multiline_comment|/* If the mtu is larger than the max size for standard&n;&t; * ethernet frames (ie, a jumbo frame), then set maccfg2&n;&t; * to allow huge frames, and to check the length */
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;maccfg2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;rx_buffer_size
OG
id|DEFAULT_RX_BUFFER_SIZE
)paren
id|tempval
op_or_assign
(paren
id|MACCFG2_HUGEFRAME
op_or
id|MACCFG2_LENGTHCHECK
)paren
suffix:semicolon
r_else
id|tempval
op_and_assign
op_complement
(paren
id|MACCFG2_HUGEFRAME
op_or
id|MACCFG2_LENGTHCHECK
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;maccfg2
comma
id|tempval
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oldsize
op_ne
id|tempsize
)paren
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
id|startup_gfar
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* gfar_timeout gets called when a packet has not been&n; * transmitted after a set amount of time.&n; * For now, assume that clearing out all the structures, and&n; * starting over will fix the problem. */
DECL|function|gfar_timeout
r_static
r_void
id|gfar_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|priv-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
id|stop_gfar
c_func
(paren
id|dev
)paren
suffix:semicolon
id|startup_gfar
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|netif_schedule
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Interrupt Handler for Transmit complete */
DECL|function|gfar_transmit
r_static
id|irqreturn_t
id|gfar_transmit
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|txbd8
op_star
id|bdp
suffix:semicolon
multiline_comment|/* Clear IEVENT */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;ievent
comma
id|IEVENT_TX_MASK
)paren
suffix:semicolon
multiline_comment|/* Lock priv */
id|spin_lock
c_func
(paren
op_amp
id|priv-&gt;lock
)paren
suffix:semicolon
id|bdp
op_assign
id|priv-&gt;dirty_tx
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bdp-&gt;status
op_amp
id|TXBD_READY
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* If dirty_tx and cur_tx are the same, then either the */
multiline_comment|/* ring is empty or full now (it could only be full in the beginning, */
multiline_comment|/* obviously).  If it is empty, we are done. */
r_if
c_cond
(paren
(paren
id|bdp
op_eq
id|priv-&gt;cur_tx
)paren
op_logical_and
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|priv-&gt;stats.tx_packets
op_increment
suffix:semicolon
multiline_comment|/* Deferred means some collisions occurred during transmit, */
multiline_comment|/* but we eventually sent the packet. */
r_if
c_cond
(paren
id|bdp-&gt;status
op_amp
id|TXBD_DEF
)paren
id|priv-&gt;stats.collisions
op_increment
suffix:semicolon
multiline_comment|/* Free the sk buffer associated with this TxBD */
id|dev_kfree_skb_irq
c_func
(paren
id|priv-&gt;tx_skbuff
(braket
id|priv-&gt;skb_dirtytx
)braket
)paren
suffix:semicolon
id|priv-&gt;tx_skbuff
(braket
id|priv-&gt;skb_dirtytx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|priv-&gt;skb_dirtytx
op_assign
(paren
id|priv-&gt;skb_dirtytx
op_plus
l_int|1
)paren
op_amp
id|TX_RING_MOD_MASK
c_func
(paren
id|priv-&gt;tx_ring_size
)paren
suffix:semicolon
multiline_comment|/* update bdp to point at next bd in the ring (wrapping if necessary) */
r_if
c_cond
(paren
id|bdp-&gt;status
op_amp
id|TXBD_WRAP
)paren
id|bdp
op_assign
id|priv-&gt;tx_bd_base
suffix:semicolon
r_else
id|bdp
op_increment
suffix:semicolon
multiline_comment|/* Move dirty_tx to be the next bd */
id|priv-&gt;dirty_tx
op_assign
id|bdp
suffix:semicolon
multiline_comment|/* We freed a buffer, so now we can restart transmission */
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* while ((bdp-&gt;status &amp; TXBD_READY) == 0) */
multiline_comment|/* If we are coalescing the interrupts, reset the timer */
multiline_comment|/* Otherwise, clear it */
r_if
c_cond
(paren
id|priv-&gt;txcoalescing
)paren
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;txic
comma
id|mk_ic_value
c_func
(paren
id|priv-&gt;txcount
comma
id|priv-&gt;txtime
)paren
)paren
suffix:semicolon
r_else
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;txic
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|priv-&gt;lock
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|function|gfar_new_skb
r_struct
id|sk_buff
op_star
id|gfar_new_skb
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|rxbd8
op_star
id|bdp
)paren
(brace
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|timeout
op_assign
id|SKB_ALLOC_TIMEOUT
suffix:semicolon
multiline_comment|/* We have to allocate the skb, so keep trying till we succeed */
r_while
c_loop
(paren
(paren
op_logical_neg
id|skb
)paren
op_logical_and
id|timeout
op_decrement
)paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|priv-&gt;rx_buffer_size
op_plus
id|RXBUF_ALIGNMENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* We need the data buffer to be aligned properly.  We will reserve&n;&t; * as many bytes as needed to align the data properly&n;&t; */
id|skb_reserve
c_func
(paren
id|skb
comma
id|RXBUF_ALIGNMENT
op_minus
(paren
(paren
(paren
r_int
)paren
id|skb-&gt;data
)paren
op_amp
(paren
id|RXBUF_ALIGNMENT
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|bdp-&gt;bufPtr
op_assign
id|dma_map_single
c_func
(paren
l_int|NULL
comma
id|skb-&gt;data
comma
id|priv-&gt;rx_buffer_size
op_plus
id|RXBUF_ALIGNMENT
comma
id|DMA_FROM_DEVICE
)paren
suffix:semicolon
id|bdp-&gt;length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Mark the buffer empty */
id|bdp-&gt;status
op_or_assign
(paren
id|RXBD_EMPTY
op_or
id|RXBD_INTERRUPT
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
DECL|function|count_errors
r_static
r_inline
r_void
id|count_errors
c_func
(paren
r_int
r_int
id|status
comma
r_struct
id|gfar_private
op_star
id|priv
)paren
(brace
r_struct
id|net_device_stats
op_star
id|stats
op_assign
op_amp
id|priv-&gt;stats
suffix:semicolon
r_struct
id|gfar_extra_stats
op_star
id|estats
op_assign
op_amp
id|priv-&gt;extra_stats
suffix:semicolon
multiline_comment|/* If the packet was truncated, none of the other errors&n;&t; * matter */
r_if
c_cond
(paren
id|status
op_amp
id|RXBD_TRUNCATED
)paren
(brace
id|stats-&gt;rx_length_errors
op_increment
suffix:semicolon
id|estats-&gt;rx_trunc
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Count the errors, if there were any */
r_if
c_cond
(paren
id|status
op_amp
(paren
id|RXBD_LARGE
op_or
id|RXBD_SHORT
)paren
)paren
(brace
id|stats-&gt;rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RXBD_LARGE
)paren
id|estats-&gt;rx_large
op_increment
suffix:semicolon
r_else
id|estats-&gt;rx_short
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|RXBD_NONOCTET
)paren
(brace
id|stats-&gt;rx_frame_errors
op_increment
suffix:semicolon
id|estats-&gt;rx_nonoctet
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|RXBD_CRCERR
)paren
(brace
id|estats-&gt;rx_crcerr
op_increment
suffix:semicolon
id|stats-&gt;rx_crc_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|RXBD_OVERRUN
)paren
(brace
id|estats-&gt;rx_overrun
op_increment
suffix:semicolon
id|stats-&gt;rx_crc_errors
op_increment
suffix:semicolon
)brace
)brace
DECL|function|gfar_receive
id|irqreturn_t
id|gfar_receive
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_GFAR_NAPI
id|u32
id|tempval
suffix:semicolon
macro_line|#endif
multiline_comment|/* Clear IEVENT, so rx interrupt isn&squot;t called again&n;&t; * because of this interrupt */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;ievent
comma
id|IEVENT_RX_MASK
)paren
suffix:semicolon
multiline_comment|/* support NAPI */
macro_line|#ifdef CONFIG_GFAR_NAPI
r_if
c_cond
(paren
id|netif_rx_schedule_prep
c_func
(paren
id|dev
)paren
)paren
(brace
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;imask
)paren
suffix:semicolon
id|tempval
op_and_assign
id|IMASK_RX_DISABLED
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;imask
comma
id|tempval
)paren
suffix:semicolon
id|__netif_rx_schedule
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: receive called twice (%x)[%x]&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;ievent
)paren
comma
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;imask
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else
id|spin_lock
c_func
(paren
op_amp
id|priv-&gt;lock
)paren
suffix:semicolon
id|gfar_clean_rx_ring
c_func
(paren
id|dev
comma
id|priv-&gt;rx_ring_size
)paren
suffix:semicolon
multiline_comment|/* If we are coalescing interrupts, update the timer */
multiline_comment|/* Otherwise, clear it */
r_if
c_cond
(paren
id|priv-&gt;rxcoalescing
)paren
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;rxic
comma
id|mk_ic_value
c_func
(paren
id|priv-&gt;rxcount
comma
id|priv-&gt;rxtime
)paren
)paren
suffix:semicolon
r_else
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;rxic
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Just in case we need to wake the ring param changer */
id|priv-&gt;rxclean
op_assign
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|priv-&gt;lock
)paren
suffix:semicolon
macro_line|#endif
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* gfar_process_frame() -- handle one incoming packet if skb&n; * isn&squot;t NULL.  */
DECL|function|gfar_process_frame
r_static
r_int
id|gfar_process_frame
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|length
)paren
(brace
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
macro_line|#ifdef BRIEF_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Missing skb!!.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|priv-&gt;stats.rx_dropped
op_increment
suffix:semicolon
id|priv-&gt;extra_stats.rx_skbmissing
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Prep the skb for the packet */
id|skb_put
c_func
(paren
id|skb
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* Tell the skb what kind of packet this is */
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* Send the packet up the stack */
r_if
c_cond
(paren
id|RECEIVE
c_func
(paren
id|skb
)paren
op_eq
id|NET_RX_DROP
)paren
(brace
id|priv-&gt;extra_stats.kernel_dropped
op_increment
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* gfar_clean_rx_ring() -- Processes each frame in the rx ring&n; *   until the budget/quota has been reached. Returns the number &n; *   of frames handled&n; */
DECL|function|gfar_clean_rx_ring
r_static
r_int
id|gfar_clean_rx_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|rx_work_limit
)paren
(brace
r_struct
id|rxbd8
op_star
id|bdp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|u16
id|pkt_len
suffix:semicolon
r_int
id|howmany
op_assign
l_int|0
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Get the first full descriptor */
id|bdp
op_assign
id|priv-&gt;cur_rx
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|bdp-&gt;status
op_amp
id|RXBD_EMPTY
)paren
op_logical_or
(paren
op_decrement
id|rx_work_limit
OL
l_int|0
)paren
)paren
)paren
(brace
id|skb
op_assign
id|priv-&gt;rx_skbuff
(braket
id|priv-&gt;skb_currx
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bdp-&gt;status
op_amp
(paren
id|RXBD_LARGE
op_or
id|RXBD_SHORT
op_or
id|RXBD_NONOCTET
op_or
id|RXBD_CRCERR
op_or
id|RXBD_OVERRUN
op_or
id|RXBD_TRUNCATED
)paren
)paren
)paren
(brace
multiline_comment|/* Increment the number of packets */
id|priv-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|howmany
op_increment
suffix:semicolon
multiline_comment|/* Remove the FCS from the packet length */
id|pkt_len
op_assign
id|bdp-&gt;length
op_minus
l_int|4
suffix:semicolon
id|gfar_process_frame
c_func
(paren
id|dev
comma
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
id|priv-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
)brace
r_else
(brace
id|count_errors
c_func
(paren
id|bdp-&gt;status
comma
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|dev_kfree_skb_any
c_func
(paren
id|skb
)paren
suffix:semicolon
id|priv-&gt;rx_skbuff
(braket
id|priv-&gt;skb_currx
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Clear the status flags for this buffer */
id|bdp-&gt;status
op_and_assign
op_complement
id|RXBD_STATS
suffix:semicolon
multiline_comment|/* Add another skb for the future */
id|skb
op_assign
id|gfar_new_skb
c_func
(paren
id|dev
comma
id|bdp
)paren
suffix:semicolon
id|priv-&gt;rx_skbuff
(braket
id|priv-&gt;skb_currx
)braket
op_assign
id|skb
suffix:semicolon
multiline_comment|/* Update to the next pointer */
r_if
c_cond
(paren
id|bdp-&gt;status
op_amp
id|RXBD_WRAP
)paren
id|bdp
op_assign
id|priv-&gt;rx_bd_base
suffix:semicolon
r_else
id|bdp
op_increment
suffix:semicolon
multiline_comment|/* update to point at the next skb */
id|priv-&gt;skb_currx
op_assign
(paren
id|priv-&gt;skb_currx
op_plus
l_int|1
)paren
op_amp
id|RX_RING_MOD_MASK
c_func
(paren
id|priv-&gt;rx_ring_size
)paren
suffix:semicolon
)brace
multiline_comment|/* Update the current rxbd pointer to be the next one */
id|priv-&gt;cur_rx
op_assign
id|bdp
suffix:semicolon
multiline_comment|/* If no packets have arrived since the&n;&t; * last one we processed, clear the IEVENT RX and&n;&t; * BSY bits so that another interrupt won&squot;t be&n;&t; * generated when we set IMASK */
r_if
c_cond
(paren
id|bdp-&gt;status
op_amp
id|RXBD_EMPTY
)paren
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;ievent
comma
id|IEVENT_RX_MASK
)paren
suffix:semicolon
r_return
id|howmany
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_GFAR_NAPI
DECL|function|gfar_poll
r_static
r_int
id|gfar_poll
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
op_star
id|budget
)paren
(brace
r_int
id|howmany
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|rx_work_limit
op_assign
op_star
id|budget
suffix:semicolon
r_if
c_cond
(paren
id|rx_work_limit
OG
id|dev-&gt;quota
)paren
id|rx_work_limit
op_assign
id|dev-&gt;quota
suffix:semicolon
id|howmany
op_assign
id|gfar_clean_rx_ring
c_func
(paren
id|dev
comma
id|rx_work_limit
)paren
suffix:semicolon
id|dev-&gt;quota
op_sub_assign
id|howmany
suffix:semicolon
id|rx_work_limit
op_sub_assign
id|howmany
suffix:semicolon
op_star
id|budget
op_sub_assign
id|howmany
suffix:semicolon
r_if
c_cond
(paren
id|rx_work_limit
op_ge
l_int|0
)paren
(brace
id|netif_rx_complete
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Clear the halt bit in RSTAT */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;rstat
comma
id|RSTAT_CLEAR_RHALT
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;imask
comma
id|IMASK_DEFAULT
)paren
suffix:semicolon
multiline_comment|/* If we are coalescing interrupts, update the timer */
multiline_comment|/* Otherwise, clear it */
r_if
c_cond
(paren
id|priv-&gt;rxcoalescing
)paren
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;rxic
comma
id|mk_ic_value
c_func
(paren
id|priv-&gt;rxcount
comma
id|priv-&gt;rxtime
)paren
)paren
suffix:semicolon
r_else
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;rxic
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Signal to the ring size changer that it&squot;s safe to go */
id|priv-&gt;rxclean
op_assign
l_int|1
suffix:semicolon
)brace
r_return
(paren
id|rx_work_limit
OL
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* The interrupt handler for devices with one interrupt */
DECL|function|gfar_interrupt
r_static
id|irqreturn_t
id|gfar_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Save ievent for future reference */
id|u32
id|events
op_assign
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;ievent
)paren
suffix:semicolon
multiline_comment|/* Clear IEVENT */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;ievent
comma
id|events
)paren
suffix:semicolon
multiline_comment|/* Check for reception */
r_if
c_cond
(paren
(paren
id|events
op_amp
id|IEVENT_RXF0
)paren
op_logical_or
(paren
id|events
op_amp
id|IEVENT_RXB0
)paren
)paren
id|gfar_receive
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* Check for transmit completion */
r_if
c_cond
(paren
(paren
id|events
op_amp
id|IEVENT_TXF
)paren
op_logical_or
(paren
id|events
op_amp
id|IEVENT_TXB
)paren
)paren
id|gfar_transmit
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* Update error statistics */
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_TXE
)paren
(brace
id|priv-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_LC
)paren
id|priv-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_CRL
)paren
id|priv-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_XFUN
)paren
(brace
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: tx underrun. dropped packet&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|priv-&gt;stats.tx_dropped
op_increment
suffix:semicolon
id|priv-&gt;extra_stats.tx_underrun
op_increment
suffix:semicolon
multiline_comment|/* Reactivate the Tx Queues */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;tstat
comma
id|TSTAT_CLEAR_THALT
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_BSY
)paren
(brace
id|priv-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|priv-&gt;extra_stats.rx_bsy
op_increment
suffix:semicolon
id|gfar_receive
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_GFAR_NAPI
multiline_comment|/* Clear the halt bit in RSTAT */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;rstat
comma
id|RSTAT_CLEAR_RHALT
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: busy error (rhalt: %x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;rstat
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_BABR
)paren
(brace
id|priv-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|priv-&gt;extra_stats.rx_babr
op_increment
suffix:semicolon
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: babbling error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_EBERR
)paren
(brace
id|priv-&gt;extra_stats.eberr
op_increment
suffix:semicolon
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: EBERR&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_RXC
)paren
(brace
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: control frame&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_BABT
)paren
(brace
id|priv-&gt;extra_stats.tx_babt
op_increment
suffix:semicolon
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: babt error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|function|phy_interrupt
r_static
id|irqreturn_t
id|phy_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Clear the interrupt */
id|mii_clear_phy_interrupt
c_func
(paren
id|priv-&gt;mii_info
)paren
suffix:semicolon
multiline_comment|/* Disable PHY interrupts */
id|mii_configure_phy_interrupt
c_func
(paren
id|priv-&gt;mii_info
comma
id|MII_INTERRUPT_DISABLED
)paren
suffix:semicolon
multiline_comment|/* Schedule the phy change */
id|schedule_work
c_func
(paren
op_amp
id|priv-&gt;tq
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* Scheduled by the phy_interrupt/timer to handle PHY changes */
DECL|function|gfar_phy_change
r_static
r_void
id|gfar_phy_change
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Delay to give the PHY a chance to change the&n;&t; * register state */
id|msleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Update the link, speed, duplex */
id|result
op_assign
id|priv-&gt;mii_info-&gt;phyinfo
op_member_access_from_pointer
id|read_status
c_func
(paren
id|priv-&gt;mii_info
)paren
suffix:semicolon
multiline_comment|/* Adjust the known status as long as the link&n;&t; * isn&squot;t still coming up */
r_if
c_cond
(paren
(paren
l_int|0
op_eq
id|result
)paren
op_logical_or
(paren
id|priv-&gt;mii_info-&gt;link
op_eq
l_int|0
)paren
)paren
(brace
id|adjust_link
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Reenable interrupts, if needed */
r_if
c_cond
(paren
id|priv-&gt;einfo-&gt;board_flags
op_amp
id|FSL_GIANFAR_BRD_HAS_PHY_INTR
)paren
id|mii_configure_phy_interrupt
c_func
(paren
id|priv-&gt;mii_info
comma
id|MII_INTERRUPT_ENABLED
)paren
suffix:semicolon
)brace
multiline_comment|/* Called every so often on systems that don&squot;t interrupt&n; * the core for PHY changes */
DECL|function|gfar_phy_timer
r_static
r_void
id|gfar_phy_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|priv-&gt;tq
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|priv-&gt;phy_info_timer
comma
id|jiffies
op_plus
id|GFAR_PHY_CHANGE_TIME
op_star
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/* Keep trying aneg for some time&n; * If, after GFAR_AN_TIMEOUT seconds, it has not&n; * finished, we switch to forced.&n; * Either way, once the process has completed, we either&n; * request the interrupt, or switch the timer over to &n; * using gfar_phy_timer to check status */
DECL|function|gfar_phy_startup_timer
r_static
r_void
id|gfar_phy_startup_timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
id|result
suffix:semicolon
r_static
r_int
id|secondary
op_assign
id|GFAR_AN_TIMEOUT
suffix:semicolon
r_struct
id|gfar_mii_info
op_star
id|mii_info
op_assign
(paren
r_struct
id|gfar_mii_info
op_star
)paren
id|data
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|mii_info-&gt;dev
)paren
suffix:semicolon
multiline_comment|/* Configure the Auto-negotiation */
id|result
op_assign
id|mii_info-&gt;phyinfo
op_member_access_from_pointer
id|config_aneg
c_func
(paren
id|mii_info
)paren
suffix:semicolon
multiline_comment|/* If autonegotiation failed to start, and&n;&t; * we haven&squot;t timed out, reset the timer, and return */
r_if
c_cond
(paren
id|result
op_logical_and
id|secondary
op_decrement
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|priv-&gt;phy_info_timer
comma
id|jiffies
op_plus
id|HZ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* Couldn&squot;t start autonegotiation.&n;&t;&t; * Try switching to forced */
id|mii_info-&gt;autoneg
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|mii_info-&gt;phyinfo
op_member_access_from_pointer
id|config_aneg
c_func
(paren
id|mii_info
)paren
suffix:semicolon
multiline_comment|/* Forcing failed!  Give up */
r_if
c_cond
(paren
id|result
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Forcing failed!&bslash;n&quot;
comma
id|mii_info-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Kill the timer so it can be restarted */
id|del_timer_sync
c_func
(paren
op_amp
id|priv-&gt;phy_info_timer
)paren
suffix:semicolon
multiline_comment|/* Grab the PHY interrupt, if necessary/possible */
r_if
c_cond
(paren
id|priv-&gt;einfo-&gt;board_flags
op_amp
id|FSL_GIANFAR_BRD_HAS_PHY_INTR
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|priv-&gt;einfo-&gt;interruptPHY
comma
id|phy_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;phy_interrupt&quot;
comma
id|mii_info-&gt;dev
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Can&squot;t get IRQ %d (PHY)&bslash;n&quot;
comma
id|mii_info-&gt;dev-&gt;name
comma
id|priv-&gt;einfo-&gt;interruptPHY
)paren
suffix:semicolon
)brace
r_else
(brace
id|mii_configure_phy_interrupt
c_func
(paren
id|priv-&gt;mii_info
comma
id|MII_INTERRUPT_ENABLED
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Start the timer again, this time in order to&n;&t; * handle a change in status */
id|init_timer
c_func
(paren
op_amp
id|priv-&gt;phy_info_timer
)paren
suffix:semicolon
id|priv-&gt;phy_info_timer.function
op_assign
op_amp
id|gfar_phy_timer
suffix:semicolon
id|priv-&gt;phy_info_timer.data
op_assign
(paren
r_int
r_int
)paren
id|mii_info-&gt;dev
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|priv-&gt;phy_info_timer
comma
id|jiffies
op_plus
id|GFAR_PHY_CHANGE_TIME
op_star
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/* Called every time the controller might need to be made&n; * aware of new link state.  The PHY code conveys this&n; * information through variables in the priv structure, and this&n; * function converts those variables into the appropriate&n; * register values, and can bring down the device if needed.&n; */
DECL|function|adjust_link
r_static
r_void
id|adjust_link
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|gfar
op_star
id|regs
op_assign
id|priv-&gt;regs
suffix:semicolon
id|u32
id|tempval
suffix:semicolon
r_struct
id|gfar_mii_info
op_star
id|mii_info
op_assign
id|priv-&gt;mii_info
suffix:semicolon
r_if
c_cond
(paren
id|mii_info-&gt;link
)paren
(brace
multiline_comment|/* Now we make sure that we can be in full duplex mode.&n;&t;&t; * If not, we operate in half-duplex mode. */
r_if
c_cond
(paren
id|mii_info-&gt;duplex
op_ne
id|priv-&gt;oldduplex
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mii_info-&gt;duplex
)paren
)paren
(brace
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|regs-&gt;maccfg2
)paren
suffix:semicolon
id|tempval
op_and_assign
op_complement
(paren
id|MACCFG2_FULL_DUPLEX
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;maccfg2
comma
id|tempval
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Half Duplex&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|regs-&gt;maccfg2
)paren
suffix:semicolon
id|tempval
op_or_assign
id|MACCFG2_FULL_DUPLEX
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;maccfg2
comma
id|tempval
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Full Duplex&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|priv-&gt;oldduplex
op_assign
id|mii_info-&gt;duplex
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mii_info-&gt;speed
op_ne
id|priv-&gt;oldspeed
)paren
(brace
r_switch
c_cond
(paren
id|mii_info-&gt;speed
)paren
(brace
r_case
l_int|1000
suffix:colon
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|regs-&gt;maccfg2
)paren
suffix:semicolon
id|tempval
op_assign
(paren
(paren
id|tempval
op_amp
op_complement
(paren
id|MACCFG2_IF
)paren
)paren
op_or
id|MACCFG2_GMII
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;maccfg2
comma
id|tempval
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|100
suffix:colon
r_case
l_int|10
suffix:colon
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|regs-&gt;maccfg2
)paren
suffix:semicolon
id|tempval
op_assign
(paren
(paren
id|tempval
op_amp
op_complement
(paren
id|MACCFG2_IF
)paren
)paren
op_or
id|MACCFG2_MII
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;maccfg2
comma
id|tempval
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Ack!  Speed (%d) is not 10/100/1000!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|mii_info-&gt;speed
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Speed %dBT&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|mii_info-&gt;speed
)paren
suffix:semicolon
id|priv-&gt;oldspeed
op_assign
id|mii_info-&gt;speed
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;oldlink
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Link is up&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|priv-&gt;oldlink
op_assign
l_int|1
suffix:semicolon
id|netif_carrier_on
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_schedule
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|priv-&gt;oldlink
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Link is down&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|priv-&gt;oldlink
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;oldspeed
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;oldduplex
op_assign
op_minus
l_int|1
suffix:semicolon
id|netif_carrier_off
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Update the hash table based on the current list of multicast&n; * addresses we subscribe to.  Also, change the promiscuity of&n; * the device based on the flags (this function is called&n; * whenever dev-&gt;flags is changed */
DECL|function|gfar_set_multi
r_static
r_void
id|gfar_set_multi
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|mc_ptr
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|gfar
op_star
id|regs
op_assign
id|priv-&gt;regs
suffix:semicolon
id|u32
id|tempval
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Entering promiscuous mode.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Set RCTRL to PROM */
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|regs-&gt;rctrl
)paren
suffix:semicolon
id|tempval
op_or_assign
id|RCTRL_PROM
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;rctrl
comma
id|tempval
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Set RCTRL to not PROM */
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|regs-&gt;rctrl
)paren
suffix:semicolon
id|tempval
op_and_assign
op_complement
(paren
id|RCTRL_PROM
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;rctrl
comma
id|tempval
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
multiline_comment|/* Set the hash to rx all multicast frames */
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr0
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr1
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr2
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr3
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr4
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr5
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr6
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr7
comma
l_int|0xffffffff
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* zero out the hash */
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr0
comma
l_int|0x0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr1
comma
l_int|0x0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr2
comma
l_int|0x0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr3
comma
l_int|0x0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr4
comma
l_int|0x0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr5
comma
l_int|0x0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr6
comma
l_int|0x0
)paren
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|regs-&gt;gaddr7
comma
l_int|0x0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mc_count
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Parse the list, and set the appropriate bits */
r_for
c_loop
(paren
id|mc_ptr
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|mc_ptr
suffix:semicolon
id|mc_ptr
op_assign
id|mc_ptr-&gt;next
)paren
(brace
id|gfar_set_hash_for_addr
c_func
(paren
id|dev
comma
id|mc_ptr-&gt;dmi_addr
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Set the appropriate hash bit for the given addr */
multiline_comment|/* The algorithm works like so:&n; * 1) Take the Destination Address (ie the multicast address), and&n; * do a CRC on it (little endian), and reverse the bits of the&n; * result.&n; * 2) Use the 8 most significant bits as a hash into a 256-entry&n; * table.  The table is controlled through 8 32-bit registers:&n; * gaddr0-7.  gaddr0&squot;s MSB is entry 0, and gaddr7&squot;s LSB is&n; * gaddr7.  This means that the 3 most significant bits in the&n; * hash index which gaddr register to use, and the 5 other bits&n; * indicate which bit (assuming an IBM numbering scheme, which&n; * for PowerPC (tm) is usually the case) in the register holds&n; * the entry. */
DECL|function|gfar_set_hash_for_addr
r_static
r_void
id|gfar_set_hash_for_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u8
op_star
id|addr
)paren
(brace
id|u32
id|tempval
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|gfar
op_star
id|regs
op_assign
id|priv-&gt;regs
suffix:semicolon
id|u32
op_star
id|hash
op_assign
op_amp
id|regs-&gt;gaddr0
suffix:semicolon
id|u32
id|result
op_assign
id|ether_crc
c_func
(paren
id|MAC_ADDR_LEN
comma
id|addr
)paren
suffix:semicolon
id|u8
id|whichreg
op_assign
(paren
(paren
id|result
op_rshift
l_int|29
)paren
op_amp
l_int|0x7
)paren
suffix:semicolon
id|u8
id|whichbit
op_assign
(paren
(paren
id|result
op_rshift
l_int|24
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|u32
id|value
op_assign
(paren
l_int|1
op_lshift
(paren
l_int|31
op_minus
id|whichbit
)paren
)paren
suffix:semicolon
id|tempval
op_assign
id|gfar_read
c_func
(paren
op_amp
id|hash
(braket
id|whichreg
)braket
)paren
suffix:semicolon
id|tempval
op_or_assign
id|value
suffix:semicolon
id|gfar_write
c_func
(paren
op_amp
id|hash
(braket
id|whichreg
)braket
comma
id|tempval
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* GFAR error interrupt handler */
DECL|function|gfar_error
r_static
id|irqreturn_t
id|gfar_error
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|gfar_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Save ievent for future reference */
id|u32
id|events
op_assign
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;ievent
)paren
suffix:semicolon
multiline_comment|/* Clear IEVENT */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;ievent
comma
id|IEVENT_ERR_MASK
)paren
suffix:semicolon
multiline_comment|/* Hmm... */
macro_line|#if defined (BRIEF_GFAR_ERRORS) || defined (VERBOSE_GFAR_ERRORS)
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: error interrupt (ievent=0x%08x imask=0x%08x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|events
comma
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;imask
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Update the error counters */
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_TXE
)paren
(brace
id|priv-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_LC
)paren
id|priv-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_CRL
)paren
id|priv-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_XFUN
)paren
(brace
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: underrun.  packet dropped.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|priv-&gt;stats.tx_dropped
op_increment
suffix:semicolon
id|priv-&gt;extra_stats.tx_underrun
op_increment
suffix:semicolon
multiline_comment|/* Reactivate the Tx Queues */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;tstat
comma
id|TSTAT_CLEAR_THALT
)paren
suffix:semicolon
)brace
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Transmit Error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_BSY
)paren
(brace
id|priv-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|priv-&gt;extra_stats.rx_bsy
op_increment
suffix:semicolon
id|gfar_receive
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_GFAR_NAPI
multiline_comment|/* Clear the halt bit in RSTAT */
id|gfar_write
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;rstat
comma
id|RSTAT_CLEAR_RHALT
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: busy error (rhalt: %x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|gfar_read
c_func
(paren
op_amp
id|priv-&gt;regs-&gt;rstat
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_BABR
)paren
(brace
id|priv-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|priv-&gt;extra_stats.rx_babr
op_increment
suffix:semicolon
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: babbling error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_EBERR
)paren
(brace
id|priv-&gt;extra_stats.eberr
op_increment
suffix:semicolon
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: EBERR&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_RXC
)paren
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: control frame&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|events
op_amp
id|IEVENT_BABT
)paren
(brace
id|priv-&gt;extra_stats.tx_babt
op_increment
suffix:semicolon
macro_line|#ifdef VERBOSE_GFAR_ERRORS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: babt error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* Structure for a device driver */
DECL|variable|gfar_driver
r_static
r_struct
id|device_driver
id|gfar_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;fsl-gianfar&quot;
comma
dot
id|bus
op_assign
op_amp
id|platform_bus_type
comma
dot
id|probe
op_assign
id|gfar_probe
comma
dot
id|remove
op_assign
id|gfar_remove
comma
)brace
suffix:semicolon
DECL|function|gfar_init
r_static
r_int
id|__init
id|gfar_init
c_func
(paren
r_void
)paren
(brace
r_return
id|driver_register
c_func
(paren
op_amp
id|gfar_driver
)paren
suffix:semicolon
)brace
DECL|function|gfar_exit
r_static
r_void
id|__exit
id|gfar_exit
c_func
(paren
r_void
)paren
(brace
id|driver_unregister
c_func
(paren
op_amp
id|gfar_driver
)paren
suffix:semicolon
)brace
DECL|variable|gfar_init
id|module_init
c_func
(paren
id|gfar_init
)paren
suffix:semicolon
DECL|variable|gfar_exit
id|module_exit
c_func
(paren
id|gfar_exit
)paren
suffix:semicolon
eof
