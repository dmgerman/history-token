multiline_comment|/*&n; * PPP synchronous tty channel driver for Linux.&n; *&n; * This is a ppp channel driver that can be used with tty device drivers&n; * that are frame oriented, such as synchronous HDLC devices.&n; *&n; * Complete PPP frames without encoding/decoding are exchanged between&n; * the channel driver and the device driver.&n; * &n; * The async map IOCTL codes are implemented to keep the user mode&n; * applications happy if they call them. Synchronous PPP does not use&n; * the async maps.&n; *&n; * Copyright 1999 Paul Mackerras.&n; *&n; * Also touched by the grubby hands of Paul Fulghum paulkf@microgate.com&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; * This driver provides the encapsulation and framing for sending&n; * and receiving PPP frames over sync serial lines.  It relies on&n; * the generic PPP layer to give it frames to send and to process&n; * received frames.  It implements the PPP line discipline.&n; *&n; * Part of the code in this driver was inspired by the old async-only&n; * PPP driver, written by Michael Callahan and Al Longyear, and&n; * subsequently hacked by Paul Mackerras.&n; *&n; * ==FILEVERSION 20040616==&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/ppp_defs.h&gt;
macro_line|#include &lt;linux/if_ppp.h&gt;
macro_line|#include &lt;linux/ppp_channel.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
DECL|macro|PPP_VERSION
mdefine_line|#define PPP_VERSION&t;&quot;2.4.2&quot;
multiline_comment|/* Structure for storing local state. */
DECL|struct|syncppp
r_struct
id|syncppp
(brace
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|rbits
r_int
r_int
id|rbits
suffix:semicolon
DECL|member|mru
r_int
id|mru
suffix:semicolon
DECL|member|xmit_lock
id|spinlock_t
id|xmit_lock
suffix:semicolon
DECL|member|recv_lock
id|spinlock_t
id|recv_lock
suffix:semicolon
DECL|member|xmit_flags
r_int
r_int
id|xmit_flags
suffix:semicolon
DECL|member|xaccm
id|u32
id|xaccm
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|raccm
id|u32
id|raccm
suffix:semicolon
DECL|member|bytes_sent
r_int
r_int
id|bytes_sent
suffix:semicolon
DECL|member|bytes_rcvd
r_int
r_int
id|bytes_rcvd
suffix:semicolon
DECL|member|tpkt
r_struct
id|sk_buff
op_star
id|tpkt
suffix:semicolon
DECL|member|last_xmit
r_int
r_int
id|last_xmit
suffix:semicolon
DECL|member|rqueue
r_struct
id|sk_buff_head
id|rqueue
suffix:semicolon
DECL|member|tsk
r_struct
id|tasklet_struct
id|tsk
suffix:semicolon
DECL|member|refcnt
id|atomic_t
id|refcnt
suffix:semicolon
DECL|member|dead_sem
r_struct
id|semaphore
id|dead_sem
suffix:semicolon
DECL|member|chan
r_struct
id|ppp_channel
id|chan
suffix:semicolon
multiline_comment|/* interface to generic ppp layer */
)brace
suffix:semicolon
multiline_comment|/* Bit numbers in xmit_flags */
DECL|macro|XMIT_WAKEUP
mdefine_line|#define XMIT_WAKEUP&t;0
DECL|macro|XMIT_FULL
mdefine_line|#define XMIT_FULL&t;1
multiline_comment|/* Bits in rbits */
DECL|macro|SC_RCV_BITS
mdefine_line|#define SC_RCV_BITS&t;(SC_RCV_B7_1|SC_RCV_B7_0|SC_RCV_ODDP|SC_RCV_EVNP)
DECL|macro|PPPSYNC_MAX_RQLEN
mdefine_line|#define PPPSYNC_MAX_RQLEN&t;32&t;/* arbitrary */
multiline_comment|/*&n; * Prototypes.&n; */
r_static
r_struct
id|sk_buff
op_star
id|ppp_sync_txmunge
c_func
(paren
r_struct
id|syncppp
op_star
id|ap
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_int
id|ppp_sync_send
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_int
id|ppp_sync_ioctl
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|ppp_sync_process
c_func
(paren
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|ppp_sync_push
c_func
(paren
r_struct
id|syncppp
op_star
id|ap
)paren
suffix:semicolon
r_static
r_void
id|ppp_sync_flush_output
c_func
(paren
r_struct
id|syncppp
op_star
id|ap
)paren
suffix:semicolon
r_static
r_void
id|ppp_sync_input
c_func
(paren
r_struct
id|syncppp
op_star
id|ap
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_char
op_star
id|flags
comma
r_int
id|count
)paren
suffix:semicolon
DECL|variable|sync_ops
r_static
r_struct
id|ppp_channel_ops
id|sync_ops
op_assign
(brace
id|ppp_sync_send
comma
id|ppp_sync_ioctl
)brace
suffix:semicolon
multiline_comment|/*&n; * Utility procedures to print a buffer in hex/ascii&n; */
r_static
r_void
DECL|function|ppp_print_hex
id|ppp_print_hex
(paren
r_register
id|__u8
op_star
id|out
comma
r_const
id|__u8
op_star
id|in
comma
r_int
id|count
)paren
(brace
r_register
id|__u8
id|next_ch
suffix:semicolon
r_static
r_char
id|hex
(braket
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|next_ch
op_assign
op_star
id|in
op_increment
suffix:semicolon
op_star
id|out
op_increment
op_assign
id|hex
(braket
(paren
id|next_ch
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
)braket
suffix:semicolon
op_star
id|out
op_increment
op_assign
id|hex
(braket
id|next_ch
op_amp
l_int|0x0F
)braket
suffix:semicolon
op_increment
id|out
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ppp_print_char
id|ppp_print_char
(paren
r_register
id|__u8
op_star
id|out
comma
r_const
id|__u8
op_star
id|in
comma
r_int
id|count
)paren
(brace
r_register
id|__u8
id|next_ch
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|next_ch
op_assign
op_star
id|in
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|next_ch
template_param
l_int|0x7e
)paren
op_star
id|out
op_increment
op_assign
l_char|&squot;.&squot;
suffix:semicolon
r_else
(brace
op_star
id|out
op_increment
op_assign
id|next_ch
suffix:semicolon
r_if
c_cond
(paren
id|next_ch
op_eq
l_char|&squot;%&squot;
)paren
multiline_comment|/* printk/syslogd has a bug !! */
op_star
id|out
op_increment
op_assign
l_char|&squot;%&squot;
suffix:semicolon
)brace
)brace
op_star
id|out
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_static
r_void
DECL|function|ppp_print_buffer
id|ppp_print_buffer
(paren
r_const
r_char
op_star
id|name
comma
r_const
id|__u8
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|__u8
id|line
(braket
l_int|44
)braket
suffix:semicolon
r_if
c_cond
(paren
id|name
op_ne
l_int|NULL
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ppp_synctty: %s, count = %d&bslash;n&quot;
comma
id|name
comma
id|count
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|8
)paren
(brace
id|memset
(paren
id|line
comma
l_int|32
comma
l_int|44
)paren
suffix:semicolon
id|ppp_print_hex
(paren
id|line
comma
id|buf
comma
l_int|8
)paren
suffix:semicolon
id|ppp_print_char
(paren
op_amp
id|line
(braket
l_int|8
op_star
l_int|3
)braket
comma
id|buf
comma
l_int|8
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
id|count
op_sub_assign
l_int|8
suffix:semicolon
id|buf
op_add_assign
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
id|memset
(paren
id|line
comma
l_int|32
comma
l_int|44
)paren
suffix:semicolon
id|ppp_print_hex
(paren
id|line
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|ppp_print_char
(paren
op_amp
id|line
(braket
l_int|8
op_star
l_int|3
)braket
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Routines implementing the synchronous PPP line discipline.&n; */
multiline_comment|/*&n; * We have a potential race on dereferencing tty-&gt;disc_data,&n; * because the tty layer provides no locking at all - thus one&n; * cpu could be running ppp_synctty_receive while another&n; * calls ppp_synctty_close, which zeroes tty-&gt;disc_data and&n; * frees the memory that ppp_synctty_receive is using.  The best&n; * way to fix this is to use a rwlock in the tty struct, but for now&n; * we use a single global rwlock for all ttys in ppp line discipline.&n; */
DECL|variable|disc_data_lock
r_static
id|rwlock_t
id|disc_data_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|function|sp_get
r_static
r_struct
id|syncppp
op_star
id|sp_get
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|syncppp
op_star
id|ap
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|disc_data_lock
)paren
suffix:semicolon
id|ap
op_assign
id|tty-&gt;disc_data
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_ne
l_int|NULL
)paren
id|atomic_inc
c_func
(paren
op_amp
id|ap-&gt;refcnt
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|disc_data_lock
)paren
suffix:semicolon
r_return
id|ap
suffix:semicolon
)brace
DECL|function|sp_put
r_static
r_void
id|sp_put
c_func
(paren
r_struct
id|syncppp
op_star
id|ap
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ap-&gt;refcnt
)paren
)paren
id|up
c_func
(paren
op_amp
id|ap-&gt;dead_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when a tty is put into sync-PPP line discipline.&n; */
r_static
r_int
DECL|function|ppp_sync_open
id|ppp_sync_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|syncppp
op_star
id|ap
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ap
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ap
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* initialize the syncppp structure */
id|memset
c_func
(paren
id|ap
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ap
)paren
)paren
suffix:semicolon
id|ap-&gt;tty
op_assign
id|tty
suffix:semicolon
id|ap-&gt;mru
op_assign
id|PPP_MRU
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ap-&gt;recv_lock
)paren
suffix:semicolon
id|ap-&gt;xaccm
(braket
l_int|0
)braket
op_assign
op_complement
l_int|0U
suffix:semicolon
id|ap-&gt;xaccm
(braket
l_int|3
)braket
op_assign
l_int|0x60000000U
suffix:semicolon
id|ap-&gt;raccm
op_assign
op_complement
l_int|0U
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|ap-&gt;rqueue
)paren
suffix:semicolon
id|tasklet_init
c_func
(paren
op_amp
id|ap-&gt;tsk
comma
id|ppp_sync_process
comma
(paren
r_int
r_int
)paren
id|ap
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ap-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|ap-&gt;dead_sem
)paren
suffix:semicolon
id|ap-&gt;chan
dot
r_private
op_assign
id|ap
suffix:semicolon
id|ap-&gt;chan.ops
op_assign
op_amp
id|sync_ops
suffix:semicolon
id|ap-&gt;chan.mtu
op_assign
id|PPP_MRU
suffix:semicolon
id|ap-&gt;chan.hdrlen
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* for A/C bytes */
id|err
op_assign
id|ppp_register_channel
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_free
suffix:semicolon
id|tty-&gt;disc_data
op_assign
id|ap
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_free
suffix:colon
id|kfree
c_func
(paren
id|ap
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when the tty is put into another line discipline&n; * or it hangs up.  We have to wait for any cpu currently&n; * executing in any of the other ppp_synctty_* routines to&n; * finish before we can call ppp_unregister_channel and free&n; * the syncppp struct.  This routine must be called from&n; * process context, not interrupt or softirq context.&n; */
r_static
r_void
DECL|function|ppp_sync_close
id|ppp_sync_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|syncppp
op_star
id|ap
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|disc_data_lock
)paren
suffix:semicolon
id|ap
op_assign
id|tty-&gt;disc_data
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|0
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|disc_data_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * We have now ensured that nobody can start using ap from now&n;&t; * on, but we have to wait for all existing users to finish.&n;&t; * Note that ppp_unregister_channel ensures that no calls to&n;&t; * our channel ops (i.e. ppp_sync_send/ioctl) are in progress&n;&t; * by the time it returns.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ap-&gt;refcnt
)paren
)paren
id|down
c_func
(paren
op_amp
id|ap-&gt;dead_sem
)paren
suffix:semicolon
id|tasklet_kill
c_func
(paren
op_amp
id|ap-&gt;tsk
)paren
suffix:semicolon
id|ppp_unregister_channel
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|ap-&gt;rqueue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;tpkt
op_ne
l_int|0
)paren
id|kfree_skb
c_func
(paren
id|ap-&gt;tpkt
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read does nothing - no data is ever available this way.&n; * Pppd reads and writes packets via /dev/ppp instead.&n; */
r_static
id|ssize_t
DECL|function|ppp_sync_read
id|ppp_sync_read
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n; * Write on the tty does nothing, the packets all come in&n; * from the ppp generic stuff.&n; */
r_static
id|ssize_t
DECL|function|ppp_sync_write
id|ppp_sync_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_int
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_static
r_int
DECL|function|ppp_synctty_ioctl
id|ppp_synctty_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|syncppp
op_star
id|ap
op_assign
id|sp_get
c_func
(paren
id|tty
)paren
suffix:semicolon
r_int
id|__user
op_star
id|p
op_assign
(paren
r_int
id|__user
op_star
)paren
id|arg
suffix:semicolon
r_int
id|err
comma
id|val
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PPPIOCGCHAN
suffix:colon
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ppp_channel_index
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGUNIT
suffix:colon
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ppp_unit_number
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCGETS
suffix:colon
r_case
id|TCGETA
suffix:colon
id|err
op_assign
id|n_tty_ioctl
c_func
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCFLSH
suffix:colon
multiline_comment|/* flush our buffers and the serial port&squot;s buffer */
r_if
c_cond
(paren
id|arg
op_eq
id|TCIOFLUSH
op_logical_or
id|arg
op_eq
id|TCOFLUSH
)paren
id|ppp_sync_flush_output
c_func
(paren
id|ap
)paren
suffix:semicolon
id|err
op_assign
id|n_tty_ioctl
c_func
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIONREAD
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
id|sp_put
c_func
(paren
id|ap
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* No kernel lock - fine */
r_static
r_int
r_int
DECL|function|ppp_sync_poll
id|ppp_sync_poll
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|ppp_sync_room
id|ppp_sync_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
l_int|65535
suffix:semicolon
)brace
multiline_comment|/*&n; * This can now be called from hard interrupt level as well&n; * as soft interrupt level or mainline.&n; */
r_static
r_void
DECL|function|ppp_sync_receive
id|ppp_sync_receive
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_char
op_star
id|cflags
comma
r_int
id|count
)paren
(brace
r_struct
id|syncppp
op_star
id|ap
op_assign
id|sp_get
c_func
(paren
id|tty
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ap-&gt;recv_lock
comma
id|flags
)paren
suffix:semicolon
id|ppp_sync_input
c_func
(paren
id|ap
comma
id|buf
comma
id|cflags
comma
id|count
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ap-&gt;recv_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|ap-&gt;rqueue
)paren
)paren
id|tasklet_schedule
c_func
(paren
op_amp
id|ap-&gt;tsk
)paren
suffix:semicolon
id|sp_put
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
op_logical_and
id|tty-&gt;driver-&gt;unthrottle
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ppp_sync_wakeup
id|ppp_sync_wakeup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|syncppp
op_star
id|ap
op_assign
id|sp_get
c_func
(paren
id|tty
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|TTY_DO_WRITE_WAKEUP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|set_bit
c_func
(paren
id|XMIT_WAKEUP
comma
op_amp
id|ap-&gt;xmit_flags
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|ap-&gt;tsk
)paren
suffix:semicolon
id|sp_put
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
DECL|variable|ppp_sync_ldisc
r_static
r_struct
id|tty_ldisc
id|ppp_sync_ldisc
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|magic
op_assign
id|TTY_LDISC_MAGIC
comma
dot
id|name
op_assign
l_string|&quot;pppsync&quot;
comma
dot
id|open
op_assign
id|ppp_sync_open
comma
dot
id|close
op_assign
id|ppp_sync_close
comma
dot
id|read
op_assign
id|ppp_sync_read
comma
dot
id|write
op_assign
id|ppp_sync_write
comma
dot
id|ioctl
op_assign
id|ppp_synctty_ioctl
comma
dot
id|poll
op_assign
id|ppp_sync_poll
comma
dot
id|receive_room
op_assign
id|ppp_sync_room
comma
dot
id|receive_buf
op_assign
id|ppp_sync_receive
comma
dot
id|write_wakeup
op_assign
id|ppp_sync_wakeup
comma
)brace
suffix:semicolon
r_static
r_int
id|__init
DECL|function|ppp_sync_init
id|ppp_sync_init
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_SYNC_PPP
comma
op_amp
id|ppp_sync_ldisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP_sync: error %d registering line disc.&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * The following routines provide the PPP channel interface.&n; */
r_static
r_int
DECL|function|ppp_sync_ioctl
id|ppp_sync_ioctl
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|syncppp
op_star
id|ap
op_assign
id|chan
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|err
comma
id|val
suffix:semicolon
id|u32
id|accm
(braket
l_int|8
)braket
suffix:semicolon
r_void
id|__user
op_star
id|argp
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
id|u32
id|__user
op_star
id|p
op_assign
id|argp
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PPPIOCGFLAGS
suffix:colon
id|val
op_assign
id|ap-&gt;flags
op_or
id|ap-&gt;rbits
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
id|__user
op_star
)paren
id|argp
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSFLAGS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
id|__user
op_star
)paren
id|argp
)paren
)paren
r_break
suffix:semicolon
id|ap-&gt;flags
op_assign
id|val
op_amp
op_complement
id|SC_RCV_BITS
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ap-&gt;recv_lock
)paren
suffix:semicolon
id|ap-&gt;rbits
op_assign
id|val
op_amp
id|SC_RCV_BITS
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ap-&gt;recv_lock
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap-&gt;xaccm
(braket
l_int|0
)braket
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ap-&gt;xaccm
(braket
l_int|0
)braket
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGRASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap-&gt;raccm
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSRASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ap-&gt;raccm
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGXASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|argp
comma
id|ap-&gt;xaccm
comma
r_sizeof
(paren
id|ap-&gt;xaccm
)paren
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSXASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|accm
comma
id|argp
comma
r_sizeof
(paren
id|accm
)paren
)paren
)paren
r_break
suffix:semicolon
id|accm
(braket
l_int|2
)braket
op_and_assign
op_complement
l_int|0x40000000U
suffix:semicolon
multiline_comment|/* can&squot;t escape 0x5e */
id|accm
(braket
l_int|3
)braket
op_or_assign
l_int|0x60000000U
suffix:semicolon
multiline_comment|/* must escape 0x7d, 0x7e */
id|memcpy
c_func
(paren
id|ap-&gt;xaccm
comma
id|accm
comma
r_sizeof
(paren
id|ap-&gt;xaccm
)paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGMRU
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap-&gt;mru
comma
(paren
r_int
id|__user
op_star
)paren
id|argp
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSMRU
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
id|__user
op_star
)paren
id|argp
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|val
OL
id|PPP_MRU
)paren
id|val
op_assign
id|PPP_MRU
suffix:semicolon
id|ap-&gt;mru
op_assign
id|val
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|ENOTTY
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called at softirq level to deliver received packets&n; * to the ppp_generic code, and to tell the ppp_generic code&n; * if we can accept more output now.&n; */
DECL|function|ppp_sync_process
r_static
r_void
id|ppp_sync_process
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|syncppp
op_star
id|ap
op_assign
(paren
r_struct
id|syncppp
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* process received packets */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ap-&gt;rqueue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
)paren
(brace
multiline_comment|/* zero length buffers indicate error */
id|ppp_input_error
c_func
(paren
op_amp
id|ap-&gt;chan
comma
l_int|0
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
id|ppp_input
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* try to push more stuff out */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|XMIT_WAKEUP
comma
op_amp
id|ap-&gt;xmit_flags
)paren
op_logical_and
id|ppp_sync_push
c_func
(paren
id|ap
)paren
)paren
id|ppp_output_wakeup
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Procedures for encapsulation and framing.&n; */
r_struct
id|sk_buff
op_star
DECL|function|ppp_sync_txmunge
id|ppp_sync_txmunge
c_func
(paren
r_struct
id|syncppp
op_star
id|ap
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|proto
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|islcp
suffix:semicolon
id|data
op_assign
id|skb-&gt;data
suffix:semicolon
id|proto
op_assign
(paren
id|data
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|data
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* LCP packets with codes between 1 (configure-request)&n;&t; * and 7 (code-reject) must be sent as though no options&n;&t; * have been negotiated.&n;&t; */
id|islcp
op_assign
id|proto
op_eq
id|PPP_LCP
op_logical_and
l_int|1
op_le
id|data
(braket
l_int|2
)braket
op_logical_and
id|data
(braket
l_int|2
)braket
op_le
l_int|7
suffix:semicolon
multiline_comment|/* compress protocol field if option enabled */
r_if
c_cond
(paren
id|data
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
(paren
id|ap-&gt;flags
op_amp
id|SC_COMP_PROT
)paren
op_logical_and
op_logical_neg
id|islcp
)paren
id|skb_pull
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* prepend address/control fields if necessary */
r_if
c_cond
(paren
(paren
id|ap-&gt;flags
op_amp
id|SC_COMP_AC
)paren
op_eq
l_int|0
op_logical_or
id|islcp
)paren
(brace
r_if
c_cond
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
l_int|2
)paren
(brace
r_struct
id|sk_buff
op_star
id|npkt
op_assign
id|dev_alloc_skb
c_func
(paren
id|skb-&gt;len
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|npkt
op_eq
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|npkt
comma
l_int|2
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|npkt
comma
id|skb-&gt;len
)paren
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|npkt
suffix:semicolon
)brace
id|skb_push
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
id|skb-&gt;data
(braket
l_int|0
)braket
op_assign
id|PPP_ALLSTATIONS
suffix:semicolon
id|skb-&gt;data
(braket
l_int|1
)braket
op_assign
id|PPP_UI
suffix:semicolon
)brace
id|ap-&gt;last_xmit
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_logical_and
id|ap-&gt;flags
op_amp
id|SC_LOG_OUTPKT
)paren
id|ppp_print_buffer
(paren
l_string|&quot;send buffer&quot;
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; * Transmit-side routines.&n; */
multiline_comment|/*&n; * Send a packet to the peer over an sync tty line.&n; * Returns 1 iff the packet was accepted.&n; * If the packet was not accepted, we will call ppp_output_wakeup&n; * at some later time.&n; */
r_static
r_int
DECL|function|ppp_sync_send
id|ppp_sync_send
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|syncppp
op_star
id|ap
op_assign
id|chan
op_member_access_from_pointer
r_private
suffix:semicolon
id|ppp_sync_push
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;xmit_flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* already full */
id|skb
op_assign
id|ppp_sync_txmunge
c_func
(paren
id|ap
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
id|ap-&gt;tpkt
op_assign
id|skb
suffix:semicolon
r_else
id|clear_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;xmit_flags
)paren
suffix:semicolon
id|ppp_sync_push
c_func
(paren
id|ap
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Push as much data as possible out to the tty.&n; */
r_static
r_int
DECL|function|ppp_sync_push
id|ppp_sync_push
c_func
(paren
r_struct
id|syncppp
op_star
id|ap
)paren
(brace
r_int
id|sent
comma
id|done
op_assign
l_int|0
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|ap-&gt;tty
suffix:semicolon
r_int
id|tty_stuffed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock_bh
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|XMIT_WAKEUP
comma
op_amp
id|ap-&gt;xmit_flags
)paren
)paren
id|tty_stuffed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_stuffed
op_logical_and
id|ap-&gt;tpkt
op_ne
l_int|0
)paren
(brace
id|set_bit
c_func
(paren
id|TTY_DO_WRITE_WAKEUP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|sent
op_assign
id|tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|ap-&gt;tpkt-&gt;data
comma
id|ap-&gt;tpkt-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sent
OL
l_int|0
)paren
r_goto
id|flush
suffix:semicolon
multiline_comment|/* error, e.g. loss of CD */
r_if
c_cond
(paren
id|sent
OL
id|ap-&gt;tpkt-&gt;len
)paren
(brace
id|tty_stuffed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|kfree_skb
c_func
(paren
id|ap-&gt;tpkt
)paren
suffix:semicolon
id|ap-&gt;tpkt
op_assign
l_int|0
suffix:semicolon
id|clear_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;xmit_flags
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* haven&squot;t made any progress */
id|spin_unlock_bh
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|test_bit
c_func
(paren
id|XMIT_WAKEUP
comma
op_amp
id|ap-&gt;xmit_flags
)paren
op_logical_or
(paren
op_logical_neg
id|tty_stuffed
op_logical_and
id|ap-&gt;tpkt
op_ne
l_int|0
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock_bh
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|done
suffix:semicolon
id|flush
suffix:colon
r_if
c_cond
(paren
id|ap-&gt;tpkt
op_ne
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|ap-&gt;tpkt
)paren
suffix:semicolon
id|ap-&gt;tpkt
op_assign
l_int|0
suffix:semicolon
id|clear_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;xmit_flags
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
suffix:semicolon
r_return
id|done
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush output from our internal buffers.&n; * Called for the TCFLSH ioctl.&n; */
r_static
r_void
DECL|function|ppp_sync_flush_output
id|ppp_sync_flush_output
c_func
(paren
r_struct
id|syncppp
op_star
id|ap
)paren
(brace
r_int
id|done
op_assign
l_int|0
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;tpkt
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|ap-&gt;tpkt
)paren
suffix:semicolon
id|ap-&gt;tpkt
op_assign
l_int|0
suffix:semicolon
id|clear_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;xmit_flags
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
id|ppp_output_wakeup
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive-side routines.&n; */
multiline_comment|/* called when the tty driver has data for us.&n; *&n; * Data is frame oriented: each call to ppp_sync_input is considered&n; * a whole frame. If the 1st flag byte is non-zero then the whole&n; * frame is considered to be in error and is tossed.&n; */
r_static
r_void
DECL|function|ppp_sync_input
id|ppp_sync_input
c_func
(paren
r_struct
id|syncppp
op_star
id|ap
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_char
op_star
id|flags
comma
r_int
id|count
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|SC_LOG_INPKT
)paren
id|ppp_print_buffer
(paren
l_string|&quot;receive buffer&quot;
comma
id|buf
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* stuff the chars in the skb */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|ap-&gt;mru
op_plus
id|PPP_HDRLEN
op_plus
l_int|2
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPPsync: no memory (input pkt)&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* Try to get the payload 4-byte aligned */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_ne
id|PPP_ALLSTATIONS
)paren
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
op_plus
(paren
id|buf
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_ne
l_int|0
op_logical_and
op_star
id|flags
)paren
(brace
multiline_comment|/* error flag set, ignore frame */
r_goto
id|err
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
OG
id|skb_tailroom
c_func
(paren
id|skb
)paren
)paren
(brace
multiline_comment|/* packet overflowed MRU */
r_goto
id|err
suffix:semicolon
)brace
id|p
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|count
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|p
comma
id|buf
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* strip address/control field if present */
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_eq
id|PPP_ALLSTATIONS
op_logical_and
id|p
(braket
l_int|1
)braket
op_eq
id|PPP_UI
)paren
(brace
multiline_comment|/* chop off address/control */
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|3
)paren
r_goto
id|err
suffix:semicolon
id|p
op_assign
id|skb_pull
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* decompress protocol field if compressed */
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
(brace
multiline_comment|/* protocol is compressed */
id|skb_push
c_func
(paren
id|skb
comma
l_int|1
)paren
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|2
)paren
r_goto
id|err
suffix:semicolon
multiline_comment|/* queue the frame to be processed */
id|skb_queue_tail
c_func
(paren
op_amp
id|ap-&gt;rqueue
comma
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
id|err
suffix:colon
multiline_comment|/* queue zero length packet as error indication */
r_if
c_cond
(paren
id|skb
op_logical_or
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|0
)paren
)paren
)paren
(brace
id|skb_trim
c_func
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|ap-&gt;rqueue
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
id|__exit
DECL|function|ppp_sync_cleanup
id|ppp_sync_cleanup
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|tty_register_ldisc
c_func
(paren
id|N_SYNC_PPP
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;failed to unregister Sync PPP line discipline&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|ppp_sync_init
id|module_init
c_func
(paren
id|ppp_sync_init
)paren
suffix:semicolon
DECL|variable|ppp_sync_cleanup
id|module_exit
c_func
(paren
id|ppp_sync_cleanup
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|N_SYNC_PPP
id|MODULE_ALIAS_LDISC
c_func
(paren
id|N_SYNC_PPP
)paren
suffix:semicolon
eof
