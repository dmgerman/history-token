multiline_comment|/* mac8390.c: New driver for 8390-based Nubus (or Nubus-alike)&n;   Ethernet cards on Linux */
multiline_comment|/* Based on the former daynaport.c driver, by Alan Cox.  Some code&n;   taken from or inspired by skeleton.c by Donald Becker, acenic.c by&n;   Jes Sorensen, and ne2k-pci.c by Donald Becker and Paul Gortmaker.&n;&n;   This software may be used and distributed according to the terms of&n;   the GNU Public License, incorporated herein by reference.  */
multiline_comment|/* 2000-02-28: support added for Dayna and Kinetics cards by &n;   A.G.deWijn@phys.uu.nl */
multiline_comment|/* 2000-04-04: support added for Dayna2 by bart@etpmod.phys.tue.nl */
multiline_comment|/* 2001-04-18: support for DaynaPort E/LC-M by rayk@knightsmanor.org */
multiline_comment|/* 2001-05-15: support for Cabletron ported from old daynaport driver&n; * and fixed access to Sonic Sys card which masquerades as a Farallon &n; * by rayk@knightsmanor.org */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/nubus.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/hwtest.h&gt;
macro_line|#include &lt;asm/macints.h&gt;
macro_line|#include &quot;8390.h&quot;
macro_line|#if (LINUX_VERSION_CODE &lt; 0x02030e)
DECL|macro|net_device
mdefine_line|#define net_device device
macro_line|#endif
DECL|macro|WD_START_PG
mdefine_line|#define WD_START_PG&t;&t;&t;0x00&t;/* First page of TX buffer */
DECL|macro|CABLETRON_RX_START_PG
mdefine_line|#define CABLETRON_RX_START_PG&t;&t;0x00    /* First page of RX buffer */
DECL|macro|CABLETRON_RX_STOP_PG
mdefine_line|#define CABLETRON_RX_STOP_PG&t;&t;0x30    /* Last page +1 of RX ring */
DECL|macro|CABLETRON_TX_START_PG
mdefine_line|#define CABLETRON_TX_START_PG&t;&t;CABLETRON_RX_STOP_PG  /* First page of TX buffer */
multiline_comment|/* Unfortunately it seems we have to hardcode these for the moment */
multiline_comment|/* Shouldn&squot;t the card know about this? Does anyone know where to read it off the card? Do we trust the data provided by the card? */
DECL|macro|DAYNA_8390_BASE
mdefine_line|#define DAYNA_8390_BASE&t;&t;0x80000
DECL|macro|DAYNA_8390_MEM
mdefine_line|#define DAYNA_8390_MEM&t;&t;0x00000
DECL|macro|KINETICS_8390_BASE
mdefine_line|#define KINETICS_8390_BASE&t;0x80000
DECL|macro|KINETICS_8390_MEM
mdefine_line|#define KINETICS_8390_MEM&t;0x00000
DECL|macro|CABLETRON_8390_BASE
mdefine_line|#define CABLETRON_8390_BASE&t;0x90000&t;
DECL|macro|CABLETRON_8390_MEM
mdefine_line|#define CABLETRON_8390_MEM&t;0x00000
DECL|enum|mac8390_type
r_enum
id|mac8390_type
(brace
DECL|enumerator|MAC8390_NONE
id|MAC8390_NONE
op_assign
op_minus
l_int|1
comma
DECL|enumerator|MAC8390_APPLE
id|MAC8390_APPLE
comma
DECL|enumerator|MAC8390_ASANTE
id|MAC8390_ASANTE
comma
DECL|enumerator|MAC8390_FARALLON
id|MAC8390_FARALLON
comma
multiline_comment|/* Apple, Asante, and Farallon are all compatible */
DECL|enumerator|MAC8390_CABLETRON
id|MAC8390_CABLETRON
comma
DECL|enumerator|MAC8390_DAYNA
id|MAC8390_DAYNA
comma
DECL|enumerator|MAC8390_INTERLAN
id|MAC8390_INTERLAN
comma
DECL|enumerator|MAC8390_KINETICS
id|MAC8390_KINETICS
comma
DECL|enumerator|MAC8390_FOCUS
id|MAC8390_FOCUS
comma
DECL|enumerator|MAC8390_SONICSYS
id|MAC8390_SONICSYS
comma
DECL|enumerator|MAC8390_DAYNA2
id|MAC8390_DAYNA2
comma
DECL|enumerator|MAC8390_DAYNA3
id|MAC8390_DAYNA3
comma
)brace
suffix:semicolon
DECL|variable|cardname
r_static
r_const
r_char
op_star
id|cardname
(braket
)braket
op_assign
(brace
l_string|&quot;apple&quot;
comma
l_string|&quot;asante&quot;
comma
l_string|&quot;farallon&quot;
comma
l_string|&quot;cabletron&quot;
comma
l_string|&quot;dayna&quot;
comma
l_string|&quot;interlan&quot;
comma
l_string|&quot;kinetics&quot;
comma
l_string|&quot;focus&quot;
comma
l_string|&quot;sonic systems&quot;
comma
l_string|&quot;dayna2&quot;
comma
l_string|&quot;dayna_lc&quot;
comma
)brace
suffix:semicolon
DECL|variable|word16
r_static
r_int
id|word16
(braket
)braket
op_assign
(brace
l_int|1
comma
multiline_comment|/* apple */
l_int|1
comma
multiline_comment|/* asante */
l_int|1
comma
multiline_comment|/* farallon */
l_int|1
comma
multiline_comment|/* cabletron */
l_int|0
comma
multiline_comment|/* dayna */
l_int|1
comma
multiline_comment|/* interlan */
l_int|0
comma
multiline_comment|/* kinetics */
l_int|1
comma
multiline_comment|/* focus (??) */
l_int|1
comma
multiline_comment|/* sonic systems  */
l_int|1
comma
multiline_comment|/* dayna2 */
l_int|1
comma
multiline_comment|/* dayna-lc */
)brace
suffix:semicolon
multiline_comment|/* on which cards do we use NuBus resources? */
DECL|variable|useresources
r_static
r_int
id|useresources
(braket
)braket
op_assign
(brace
l_int|1
comma
multiline_comment|/* apple */
l_int|1
comma
multiline_comment|/* asante */
l_int|1
comma
multiline_comment|/* farallon */
l_int|0
comma
multiline_comment|/* cabletron */
l_int|0
comma
multiline_comment|/* dayna */
l_int|0
comma
multiline_comment|/* interlan */
l_int|0
comma
multiline_comment|/* kinetics */
l_int|0
comma
multiline_comment|/* focus (??) */
l_int|1
comma
multiline_comment|/* sonic systems */
l_int|1
comma
multiline_comment|/* dayna2 */
l_int|1
comma
multiline_comment|/* dayna-lc */
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|version
(braket
)braket
id|__initdata
op_assign
l_string|&quot;mac8390.c: v0.4 2001-05-15 David Huggins-Daines &lt;dhd@debian.org&gt; and others&bslash;n&quot;
suffix:semicolon
r_extern
r_enum
id|mac8390_type
id|mac8390_ident
c_func
(paren
r_struct
id|nubus_dev
op_star
id|dev
)paren
suffix:semicolon
r_extern
r_int
id|mac8390_memsize
c_func
(paren
r_int
r_int
id|membase
)paren
suffix:semicolon
r_extern
r_int
id|mac8390_memtest
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|mac8390_initdev
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|nubus_dev
op_star
id|ndev
comma
r_enum
id|mac8390_type
id|type
)paren
suffix:semicolon
r_static
r_int
id|mac8390_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|mac8390_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|mac8390_no_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Sane (32-bit chunk memory read/write) - Apple/Asante/Farallon do this*/
r_static
r_void
id|sane_get_8390_hdr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
suffix:semicolon
r_static
r_void
id|sane_block_input
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
suffix:semicolon
r_static
r_void
id|sane_block_output
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_const
r_int
id|start_page
)paren
suffix:semicolon
multiline_comment|/* dayna_memcpy to and from card */
r_static
r_void
id|dayna_memcpy_fromcard
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|to
comma
r_int
id|from
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|dayna_memcpy_tocard
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|count
)paren
suffix:semicolon
multiline_comment|/* Dayna - Dayna/Kinetics use this */
r_static
r_void
id|dayna_get_8390_hdr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
suffix:semicolon
r_static
r_void
id|dayna_block_input
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
suffix:semicolon
r_static
r_void
id|dayna_block_output
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|start_page
)paren
suffix:semicolon
DECL|macro|memcpy_fromio
mdefine_line|#define memcpy_fromio(a,b,c)&t;memcpy((a),(void *)(b),(c))
DECL|macro|memcpy_toio
mdefine_line|#define memcpy_toio(a,b,c)&t;memcpy((void *)(a),(b),(c))
multiline_comment|/* Slow Sane (16-bit chunk memory read/write) Cabletron uses this */
r_static
r_void
id|slow_sane_get_8390_hdr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
suffix:semicolon
r_static
r_void
id|slow_sane_block_input
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
suffix:semicolon
r_static
r_void
id|slow_sane_block_output
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|start_page
)paren
suffix:semicolon
r_static
r_void
id|word_memcpy_tocard
c_func
(paren
r_void
op_star
id|tp
comma
r_const
r_void
op_star
id|fp
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|word_memcpy_fromcard
c_func
(paren
r_void
op_star
id|tp
comma
r_const
r_void
op_star
id|fp
comma
r_int
id|count
)paren
suffix:semicolon
DECL|function|mac8390_ident
r_enum
id|mac8390_type
id|__init
id|mac8390_ident
c_func
(paren
r_struct
id|nubus_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;dr_sw
op_eq
id|NUBUS_DRSW_ASANTE
)paren
r_return
id|MAC8390_ASANTE
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dr_sw
op_eq
id|NUBUS_DRSW_FARALLON
)paren
r_return
id|MAC8390_FARALLON
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dr_sw
op_eq
id|NUBUS_DRSW_KINETICS
)paren
r_return
id|MAC8390_KINETICS
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dr_sw
op_eq
id|NUBUS_DRSW_DAYNA
)paren
r_return
id|MAC8390_DAYNA
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dr_sw
op_eq
id|NUBUS_DRSW_DAYNA2
)paren
r_return
id|MAC8390_DAYNA2
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dr_sw
op_eq
id|NUBUS_DRSW_DAYNA_LC
)paren
r_return
id|MAC8390_DAYNA3
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dr_hw
op_eq
id|NUBUS_DRHW_CABLETRON
)paren
r_return
id|MAC8390_CABLETRON
suffix:semicolon
r_return
id|MAC8390_NONE
suffix:semicolon
)brace
DECL|function|mac8390_memsize
r_int
id|__init
id|mac8390_memsize
c_func
(paren
r_int
r_int
id|membase
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Check up to 32K in 4K increments */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_volatile
r_int
r_int
op_star
id|m
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|membase
op_plus
(paren
id|i
op_star
l_int|0x1000
)paren
)paren
suffix:semicolon
multiline_comment|/* Unwriteable - we have a fully decoded card and the&n;&t;&t;   RAM end located */
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
id|m
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* write a distinctive byte */
op_star
id|m
op_assign
l_int|0xA5A0
op_or
id|i
suffix:semicolon
multiline_comment|/* check that we read back what we wrote */
r_if
c_cond
(paren
op_star
id|m
op_ne
(paren
l_int|0xA5A0
op_or
id|i
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* check for partial decode and wrap */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
(brace
r_volatile
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|membase
op_plus
(paren
id|j
op_star
l_int|0x1000
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
(paren
l_int|0xA5A0
op_or
id|j
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* in any case, we stopped once we tried one block too many,&n;           or once we reached 32K */
r_return
id|i
op_star
l_int|0x1000
suffix:semicolon
)brace
DECL|function|mac8390_probe
r_struct
id|net_device
op_star
id|__init
id|mac8390_probe
c_func
(paren
r_int
id|unit
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_volatile
r_int
r_int
op_star
id|i
suffix:semicolon
r_int
id|version_disp
op_assign
l_int|0
suffix:semicolon
r_struct
id|nubus_dev
op_star
id|ndev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_struct
id|nubus_dir
id|dir
suffix:semicolon
r_struct
id|nubus_dirent
id|ent
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_static
r_int
r_int
id|slots
suffix:semicolon
r_enum
id|mac8390_type
id|cardtype
suffix:semicolon
multiline_comment|/* probably should check for Nubus instead */
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_MAC
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
id|dev
op_assign
id|alloc_etherdev
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|unit
op_ge
l_int|0
)paren
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth%d&quot;
comma
id|unit
)paren
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ndev
op_assign
id|nubus_find_type
c_func
(paren
id|NUBUS_CAT_NETWORK
comma
id|NUBUS_TYPE_ETHERNET
comma
id|ndev
)paren
)paren
)paren
(brace
multiline_comment|/* Have we seen it already? */
r_if
c_cond
(paren
id|slots
op_amp
(paren
l_int|1
op_lshift
id|ndev-&gt;board-&gt;slot
)paren
)paren
r_continue
suffix:semicolon
id|slots
op_or_assign
l_int|1
op_lshift
id|ndev-&gt;board-&gt;slot
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cardtype
op_assign
id|mac8390_ident
c_func
(paren
id|ndev
)paren
)paren
op_eq
id|MAC8390_NONE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|version_disp
op_eq
l_int|0
)paren
(brace
id|version_disp
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
)brace
id|dev-&gt;irq
op_assign
id|SLOT2IRQ
c_func
(paren
id|ndev-&gt;board-&gt;slot
)paren
suffix:semicolon
multiline_comment|/* This is getting to be a habit */
id|dev-&gt;base_addr
op_assign
id|ndev-&gt;board-&gt;slot_addr
op_or
(paren
(paren
id|ndev-&gt;board-&gt;slot
op_amp
l_int|0xf
)paren
op_lshift
l_int|20
)paren
suffix:semicolon
multiline_comment|/* Get some Nubus info - we will trust the card&squot;s idea&n;&t;&t;   of where its memory and registers are. */
r_if
c_cond
(paren
id|nubus_get_func_dir
c_func
(paren
id|ndev
comma
op_amp
id|dir
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unable to get Nubus functional&quot;
l_string|&quot; directory for slot %X!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ndev-&gt;board-&gt;slot
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Get the MAC address */
r_if
c_cond
(paren
(paren
id|nubus_find_rsrc
c_func
(paren
op_amp
id|dir
comma
id|NUBUS_RESID_MAC_ADDRESS
comma
op_amp
id|ent
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Couldn&squot;t get MAC address!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
id|nubus_get_rsrc_mem
c_func
(paren
id|dev-&gt;dev_addr
comma
op_amp
id|ent
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Some Sonic Sys cards masquerade as Farallon */
r_if
c_cond
(paren
id|cardtype
op_eq
id|MAC8390_FARALLON
op_logical_and
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_eq
l_int|0x0
op_logical_and
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
op_eq
l_int|0x40
op_logical_and
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
op_eq
l_int|0x10
)paren
(brace
multiline_comment|/* This is really Sonic Sys card */
id|cardtype
op_assign
id|MAC8390_SONICSYS
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|useresources
(braket
id|cardtype
)braket
op_eq
l_int|1
)paren
(brace
id|nubus_rewinddir
c_func
(paren
op_amp
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nubus_find_rsrc
c_func
(paren
op_amp
id|dir
comma
id|NUBUS_RESID_MINOR_BASEOS
comma
op_amp
id|ent
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Memory offset resource&quot;
l_string|&quot; for slot %X not found!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ndev-&gt;board-&gt;slot
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|nubus_get_rsrc_mem
c_func
(paren
op_amp
id|offset
comma
op_amp
id|ent
comma
l_int|4
)paren
suffix:semicolon
id|dev-&gt;mem_start
op_assign
id|dev-&gt;base_addr
op_plus
id|offset
suffix:semicolon
multiline_comment|/* yes, this is how the Apple driver does it */
id|dev-&gt;base_addr
op_assign
id|dev-&gt;mem_start
op_plus
l_int|0x10000
suffix:semicolon
id|nubus_rewinddir
c_func
(paren
op_amp
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nubus_find_rsrc
c_func
(paren
op_amp
id|dir
comma
id|NUBUS_RESID_MINOR_LENGTH
comma
op_amp
id|ent
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Memory length resource&quot;
l_string|&quot; for slot %X not found&quot;
l_string|&quot;, probing&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ndev-&gt;board-&gt;slot
)paren
suffix:semicolon
id|offset
op_assign
id|mac8390_memsize
c_func
(paren
id|dev-&gt;mem_start
)paren
suffix:semicolon
)brace
r_else
(brace
id|nubus_get_rsrc_mem
c_func
(paren
op_amp
id|offset
comma
op_amp
id|ent
comma
l_int|4
)paren
suffix:semicolon
)brace
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
id|offset
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|cardtype
)paren
(brace
r_case
id|MAC8390_KINETICS
suffix:colon
r_case
id|MAC8390_DAYNA
suffix:colon
multiline_comment|/* it&squot;s the same */
id|dev-&gt;base_addr
op_assign
(paren
r_int
)paren
(paren
id|ndev-&gt;board-&gt;slot_addr
op_plus
id|DAYNA_8390_BASE
)paren
suffix:semicolon
id|dev-&gt;mem_start
op_assign
(paren
r_int
)paren
(paren
id|ndev-&gt;board-&gt;slot_addr
op_plus
id|DAYNA_8390_MEM
)paren
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
id|mac8390_memsize
c_func
(paren
id|dev-&gt;mem_start
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MAC8390_CABLETRON
suffix:colon
id|dev-&gt;base_addr
op_assign
(paren
r_int
)paren
(paren
id|ndev-&gt;board-&gt;slot_addr
op_plus
id|CABLETRON_8390_BASE
)paren
suffix:semicolon
id|dev-&gt;mem_start
op_assign
(paren
r_int
)paren
(paren
id|ndev-&gt;board-&gt;slot_addr
op_plus
id|CABLETRON_8390_MEM
)paren
suffix:semicolon
multiline_comment|/* The base address is unreadable if 0x00&n;&t;&t;&t;&t;&t; * has been written to the command register&n;&t;&t;&t;&t;&t; * Reset the chip by writing E8390_NODMA +&n;&t;&t;&t;&t;&t; *   E8390_PAGE0 + E8390_STOP just to be&n;&t;&t;&t;&t;&t; *   sure&n;&t;&t;&t;&t;&t; */
id|i
op_assign
(paren
r_void
op_star
)paren
id|dev-&gt;base_addr
suffix:semicolon
op_star
id|i
op_assign
l_int|0x21
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
id|mac8390_memsize
c_func
(paren
id|dev-&gt;mem_start
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Card type %s is&quot;
l_string|&quot; unsupported, sorry&bslash;n&quot;
comma
id|cardname
(braket
id|cardtype
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* Do the nasty 8390 stuff */
r_if
c_cond
(paren
op_logical_neg
id|mac8390_initdev
c_func
(paren
id|dev
comma
id|ndev
comma
id|cardtype
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ndev
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|register_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out1
suffix:semicolon
r_return
id|dev
suffix:semicolon
id|out1
suffix:colon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
id|free_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;David Huggins-Daines &lt;dhd@debian.org&gt; and others&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Macintosh NS8390-based Nubus Ethernet driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/* overkill, of course */
DECL|variable|dev_mac8390
r_static
r_struct
id|net_device
op_star
id|dev_mac8390
(braket
l_int|15
)braket
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|mac8390_probe
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dev
)paren
)paren
r_break
suffix:semicolon
id|dev_mac890
(braket
id|i
)braket
op_assign
id|dev
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;mac8390.c: No useable cards found, driver NOT installed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_mac890
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|free_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* MODULE */
DECL|function|mac8390_initdev
r_static
r_int
id|__init
id|mac8390_initdev
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|nubus_dev
op_star
id|ndev
comma
r_enum
id|mac8390_type
id|type
)paren
(brace
r_static
id|u32
id|fwrd4_offsets
(braket
l_int|16
)braket
op_assign
initialization_block
suffix:semicolon
r_static
id|u32
id|back4_offsets
(braket
l_int|16
)braket
op_assign
initialization_block
suffix:semicolon
r_static
id|u32
id|fwrd2_offsets
(braket
l_int|16
)braket
op_assign
initialization_block
suffix:semicolon
r_int
id|access_bitmode
suffix:semicolon
multiline_comment|/* 8390 specific init for dev - allocates dev-&gt;priv */
r_if
c_cond
(paren
id|ethdev_init
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unable to allocate memory for dev-&gt;priv!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Now fill in our stuff */
id|dev-&gt;open
op_assign
op_amp
id|mac8390_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|mac8390_close
suffix:semicolon
multiline_comment|/* GAR, ei_status is actually a macro even though it looks global */
id|ei_status.name
op_assign
id|cardname
(braket
id|type
)braket
suffix:semicolon
id|ei_status.word16
op_assign
id|word16
(braket
id|type
)braket
suffix:semicolon
multiline_comment|/* Cabletron&squot;s TX/RX buffers are backwards */
r_if
c_cond
(paren
id|type
op_eq
id|MAC8390_CABLETRON
)paren
(brace
id|ei_status.tx_start_page
op_assign
id|CABLETRON_TX_START_PG
suffix:semicolon
id|ei_status.rx_start_page
op_assign
id|CABLETRON_RX_START_PG
suffix:semicolon
id|ei_status.stop_page
op_assign
id|CABLETRON_RX_STOP_PG
suffix:semicolon
id|ei_status.rmem_start
op_assign
id|dev-&gt;mem_start
suffix:semicolon
id|ei_status.rmem_end
op_assign
id|dev-&gt;mem_start
op_plus
id|CABLETRON_RX_STOP_PG
op_star
l_int|256
suffix:semicolon
)brace
r_else
(brace
id|ei_status.tx_start_page
op_assign
id|WD_START_PG
suffix:semicolon
id|ei_status.rx_start_page
op_assign
id|WD_START_PG
op_plus
id|TX_PAGES
suffix:semicolon
id|ei_status.stop_page
op_assign
(paren
id|dev-&gt;mem_end
op_minus
id|dev-&gt;mem_start
)paren
op_div
l_int|256
suffix:semicolon
id|ei_status.rmem_start
op_assign
id|dev-&gt;mem_start
op_plus
id|TX_PAGES
op_star
l_int|256
suffix:semicolon
id|ei_status.rmem_end
op_assign
id|dev-&gt;mem_end
suffix:semicolon
)brace
multiline_comment|/* Fill in model-specific information and functions */
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|MAC8390_SONICSYS
suffix:colon
multiline_comment|/* 16 bit card, register map is reversed */
id|ei_status.reset_8390
op_assign
op_amp
id|mac8390_no_reset
suffix:semicolon
id|ei_status.block_input
op_assign
op_amp
id|slow_sane_block_input
suffix:semicolon
id|ei_status.block_output
op_assign
op_amp
id|slow_sane_block_output
suffix:semicolon
id|ei_status.get_8390_hdr
op_assign
op_amp
id|slow_sane_get_8390_hdr
suffix:semicolon
id|ei_status.reg_offset
op_assign
id|back4_offsets
suffix:semicolon
id|access_bitmode
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MAC8390_FARALLON
suffix:colon
r_case
id|MAC8390_APPLE
suffix:colon
r_case
id|MAC8390_ASANTE
suffix:colon
r_case
id|MAC8390_DAYNA2
suffix:colon
r_case
id|MAC8390_DAYNA3
suffix:colon
multiline_comment|/* 32 bit card, register map is reversed */
multiline_comment|/* sane */
id|ei_status.reset_8390
op_assign
op_amp
id|mac8390_no_reset
suffix:semicolon
id|ei_status.block_input
op_assign
op_amp
id|sane_block_input
suffix:semicolon
id|ei_status.block_output
op_assign
op_amp
id|sane_block_output
suffix:semicolon
id|ei_status.get_8390_hdr
op_assign
op_amp
id|sane_get_8390_hdr
suffix:semicolon
id|ei_status.reg_offset
op_assign
id|back4_offsets
suffix:semicolon
id|access_bitmode
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MAC8390_CABLETRON
suffix:colon
multiline_comment|/* 16 bit card, register map is short forward */
id|ei_status.reset_8390
op_assign
op_amp
id|mac8390_no_reset
suffix:semicolon
id|ei_status.block_input
op_assign
op_amp
id|slow_sane_block_input
suffix:semicolon
id|ei_status.block_output
op_assign
op_amp
id|slow_sane_block_output
suffix:semicolon
id|ei_status.get_8390_hdr
op_assign
op_amp
id|slow_sane_get_8390_hdr
suffix:semicolon
id|ei_status.reg_offset
op_assign
id|fwrd2_offsets
suffix:semicolon
id|access_bitmode
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MAC8390_DAYNA
suffix:colon
r_case
id|MAC8390_KINETICS
suffix:colon
multiline_comment|/* 16 bit memory */
multiline_comment|/* dayna and similar */
id|ei_status.reset_8390
op_assign
op_amp
id|mac8390_no_reset
suffix:semicolon
id|ei_status.block_input
op_assign
op_amp
id|dayna_block_input
suffix:semicolon
id|ei_status.block_output
op_assign
op_amp
id|dayna_block_output
suffix:semicolon
id|ei_status.get_8390_hdr
op_assign
op_amp
id|dayna_get_8390_hdr
suffix:semicolon
id|ei_status.reg_offset
op_assign
id|fwrd4_offsets
suffix:semicolon
id|access_bitmode
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Card type %s is unsupported, sorry&bslash;n&quot;
comma
id|cardname
(braket
id|type
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Good, done, now spit out some messages */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s in slot %X (type %s)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ndev-&gt;board-&gt;name
comma
id|ndev-&gt;board-&gt;slot
comma
id|cardname
(braket
id|type
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;MAC &quot;
)paren
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; IRQ %d, shared memory at %#lx-%#lx,  %d-bit access.&bslash;n&quot;
comma
id|dev-&gt;irq
comma
id|dev-&gt;mem_start
comma
id|dev-&gt;mem_end
op_minus
l_int|1
comma
id|access_bitmode
ques
c_cond
l_int|32
suffix:colon
l_int|16
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mac8390_open
r_static
r_int
id|mac8390_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|ei_open
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|ei_interrupt
comma
l_int|0
comma
l_string|&quot;8390 Ethernet&quot;
comma
id|dev
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: unable to get IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mac8390_close
r_static
r_int
id|mac8390_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|ei_close
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mac8390_no_reset
r_static
r_void
id|mac8390_no_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|ei_status.txing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;reset not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* dayna_memcpy_fromio/dayna_memcpy_toio */
multiline_comment|/* directly from daynaport.c by Alan Cox */
DECL|function|dayna_memcpy_fromcard
r_static
r_void
id|dayna_memcpy_fromcard
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|to
comma
r_int
id|from
comma
r_int
id|count
)paren
(brace
r_volatile
r_int
r_int
op_star
id|ptr
suffix:semicolon
r_int
r_int
op_star
id|target
op_assign
id|to
suffix:semicolon
id|from
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* word, skip overhead */
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|from
)paren
suffix:semicolon
multiline_comment|/* Leading byte? */
r_if
c_cond
(paren
id|from
op_amp
l_int|2
)paren
(brace
op_star
(paren
(paren
r_char
op_star
)paren
id|target
)paren
op_increment
op_assign
op_star
(paren
(paren
(paren
r_char
op_star
)paren
id|ptr
op_increment
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_ge
l_int|2
)paren
(brace
op_star
id|target
op_increment
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* Copy and */
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* skip cruft */
id|count
op_sub_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Trailing byte? */
r_if
c_cond
(paren
id|count
)paren
(brace
multiline_comment|/* Big endian */
r_int
r_int
id|v
op_assign
op_star
id|ptr
suffix:semicolon
op_star
(paren
(paren
r_char
op_star
)paren
id|target
)paren
op_assign
id|v
op_rshift
l_int|8
suffix:semicolon
)brace
)brace
DECL|function|dayna_memcpy_tocard
r_static
r_void
id|dayna_memcpy_tocard
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|count
)paren
(brace
r_volatile
r_int
r_int
op_star
id|ptr
suffix:semicolon
r_const
r_int
r_int
op_star
id|src
op_assign
id|from
suffix:semicolon
id|to
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* word, skip overhead */
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|to
)paren
suffix:semicolon
multiline_comment|/* Leading byte? */
r_if
c_cond
(paren
id|to
op_amp
l_int|2
)paren
(brace
multiline_comment|/* avoid a byte write (stomps on other data) */
id|ptr
(braket
op_minus
l_int|1
)braket
op_assign
(paren
id|ptr
(braket
op_minus
l_int|1
)braket
op_amp
l_int|0xFF00
)paren
op_or
op_star
(paren
(paren
r_int
r_char
op_star
)paren
id|src
)paren
op_increment
suffix:semicolon
id|ptr
op_increment
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_ge
l_int|2
)paren
(brace
op_star
id|ptr
op_increment
op_assign
op_star
id|src
op_increment
suffix:semicolon
multiline_comment|/* Copy and */
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* skip cruft */
id|count
op_sub_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Trailing byte? */
r_if
c_cond
(paren
id|count
)paren
(brace
multiline_comment|/* Big endian */
r_int
r_int
id|v
op_assign
op_star
id|src
suffix:semicolon
multiline_comment|/* card doesn&squot;t like byte writes */
op_star
id|ptr
op_assign
(paren
op_star
id|ptr
op_amp
l_int|0x00FF
)paren
op_or
(paren
id|v
op_amp
l_int|0xFF00
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* sane block input/output */
DECL|function|sane_get_8390_hdr
r_static
r_void
id|sane_get_8390_hdr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
(brace
r_int
r_int
id|hdr_start
op_assign
(paren
id|ring_page
op_minus
id|WD_START_PG
)paren
op_lshift
l_int|8
suffix:semicolon
id|memcpy_fromio
c_func
(paren
(paren
r_void
op_star
)paren
id|hdr
comma
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|hdr_start
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Fix endianness */
id|hdr-&gt;count
op_assign
id|swab16
c_func
(paren
id|hdr-&gt;count
)paren
suffix:semicolon
)brace
DECL|function|sane_block_input
r_static
r_void
id|sane_block_input
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
(brace
r_int
r_int
id|xfer_base
op_assign
id|ring_offset
op_minus
(paren
id|WD_START_PG
op_lshift
l_int|8
)paren
suffix:semicolon
r_int
r_int
id|xfer_start
op_assign
id|xfer_base
op_plus
id|dev-&gt;mem_start
suffix:semicolon
r_if
c_cond
(paren
id|xfer_start
op_plus
id|count
OG
id|ei_status.rmem_end
)paren
(brace
multiline_comment|/* We must wrap the input move. */
r_int
id|semi_count
op_assign
id|ei_status.rmem_end
op_minus
id|xfer_start
suffix:semicolon
id|memcpy_fromio
c_func
(paren
id|skb-&gt;data
comma
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|xfer_base
comma
id|semi_count
)paren
suffix:semicolon
id|count
op_sub_assign
id|semi_count
suffix:semicolon
id|memcpy_toio
c_func
(paren
id|skb-&gt;data
op_plus
id|semi_count
comma
(paren
r_char
op_star
)paren
id|ei_status.rmem_start
comma
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy_fromio
c_func
(paren
id|skb-&gt;data
comma
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|xfer_base
comma
id|count
)paren
suffix:semicolon
)brace
)brace
DECL|function|sane_block_output
r_static
r_void
id|sane_block_output
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|start_page
)paren
(brace
r_int
id|shmem
op_assign
(paren
id|start_page
op_minus
id|WD_START_PG
)paren
op_lshift
l_int|8
suffix:semicolon
id|memcpy_toio
c_func
(paren
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|shmem
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* dayna block input/output */
DECL|function|dayna_get_8390_hdr
r_static
r_void
id|dayna_get_8390_hdr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
(brace
r_int
r_int
id|hdr_start
op_assign
(paren
id|ring_page
op_minus
id|WD_START_PG
)paren
op_lshift
l_int|8
suffix:semicolon
id|dayna_memcpy_fromcard
c_func
(paren
id|dev
comma
(paren
r_void
op_star
)paren
id|hdr
comma
id|hdr_start
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Fix endianness */
id|hdr-&gt;count
op_assign
(paren
id|hdr-&gt;count
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
op_or
(paren
id|hdr-&gt;count
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
DECL|function|dayna_block_input
r_static
r_void
id|dayna_block_input
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
(brace
r_int
r_int
id|xfer_base
op_assign
id|ring_offset
op_minus
(paren
id|WD_START_PG
op_lshift
l_int|8
)paren
suffix:semicolon
r_int
r_int
id|xfer_start
op_assign
id|xfer_base
op_plus
id|dev-&gt;mem_start
suffix:semicolon
multiline_comment|/* Note the offset math is done in card memory space which is word&n;&t;   per long onto our space. */
r_if
c_cond
(paren
id|xfer_start
op_plus
id|count
OG
id|ei_status.rmem_end
)paren
(brace
multiline_comment|/* We must wrap the input move. */
r_int
id|semi_count
op_assign
id|ei_status.rmem_end
op_minus
id|xfer_start
suffix:semicolon
id|dayna_memcpy_fromcard
c_func
(paren
id|dev
comma
id|skb-&gt;data
comma
id|xfer_base
comma
id|semi_count
)paren
suffix:semicolon
id|count
op_sub_assign
id|semi_count
suffix:semicolon
id|dayna_memcpy_fromcard
c_func
(paren
id|dev
comma
id|skb-&gt;data
op_plus
id|semi_count
comma
id|ei_status.rmem_start
op_minus
id|dev-&gt;mem_start
comma
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
id|dayna_memcpy_fromcard
c_func
(paren
id|dev
comma
id|skb-&gt;data
comma
id|xfer_base
comma
id|count
)paren
suffix:semicolon
)brace
)brace
DECL|function|dayna_block_output
r_static
r_void
id|dayna_block_output
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|start_page
)paren
(brace
r_int
id|shmem
op_assign
(paren
id|start_page
op_minus
id|WD_START_PG
)paren
op_lshift
l_int|8
suffix:semicolon
id|dayna_memcpy_tocard
c_func
(paren
id|dev
comma
id|shmem
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* Cabletron block I/O */
DECL|function|slow_sane_get_8390_hdr
r_static
r_void
id|slow_sane_get_8390_hdr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
(brace
r_int
r_int
id|hdr_start
op_assign
(paren
id|ring_page
op_minus
id|WD_START_PG
)paren
op_lshift
l_int|8
suffix:semicolon
id|word_memcpy_fromcard
c_func
(paren
(paren
r_void
op_star
)paren
id|hdr
comma
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|hdr_start
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Register endianism - fix here rather than 8390.c */
id|hdr-&gt;count
op_assign
(paren
id|hdr-&gt;count
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
op_or
(paren
id|hdr-&gt;count
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
DECL|function|slow_sane_block_input
r_static
r_void
id|slow_sane_block_input
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
(brace
r_int
r_int
id|xfer_base
op_assign
id|ring_offset
op_minus
(paren
id|WD_START_PG
op_lshift
l_int|8
)paren
suffix:semicolon
r_int
r_int
id|xfer_start
op_assign
id|xfer_base
op_plus
id|dev-&gt;mem_start
suffix:semicolon
r_if
c_cond
(paren
id|xfer_start
op_plus
id|count
OG
id|ei_status.rmem_end
)paren
(brace
multiline_comment|/* We must wrap the input move. */
r_int
id|semi_count
op_assign
id|ei_status.rmem_end
op_minus
id|xfer_start
suffix:semicolon
id|word_memcpy_fromcard
c_func
(paren
id|skb-&gt;data
comma
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|xfer_base
comma
id|semi_count
)paren
suffix:semicolon
id|count
op_sub_assign
id|semi_count
suffix:semicolon
id|word_memcpy_fromcard
c_func
(paren
id|skb-&gt;data
op_plus
id|semi_count
comma
(paren
r_char
op_star
)paren
id|ei_status.rmem_start
comma
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
id|word_memcpy_fromcard
c_func
(paren
id|skb-&gt;data
comma
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|xfer_base
comma
id|count
)paren
suffix:semicolon
)brace
)brace
DECL|function|slow_sane_block_output
r_static
r_void
id|slow_sane_block_output
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|start_page
)paren
(brace
r_int
id|shmem
op_assign
(paren
id|start_page
op_minus
id|WD_START_PG
)paren
op_lshift
l_int|8
suffix:semicolon
id|word_memcpy_tocard
c_func
(paren
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|shmem
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
DECL|function|word_memcpy_tocard
r_static
r_void
id|word_memcpy_tocard
c_func
(paren
r_void
op_star
id|tp
comma
r_const
r_void
op_star
id|fp
comma
r_int
id|count
)paren
(brace
r_volatile
r_int
r_int
op_star
id|to
op_assign
id|tp
suffix:semicolon
r_const
r_int
r_int
op_star
id|from
op_assign
id|fp
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|count
op_div_assign
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
op_star
id|to
op_increment
op_assign
op_star
id|from
op_increment
suffix:semicolon
)brace
)brace
DECL|function|word_memcpy_fromcard
r_static
r_void
id|word_memcpy_fromcard
c_func
(paren
r_void
op_star
id|tp
comma
r_const
r_void
op_star
id|fp
comma
r_int
id|count
)paren
(brace
r_int
r_int
op_star
id|to
op_assign
id|tp
suffix:semicolon
r_const
r_volatile
r_int
r_int
op_star
id|from
op_assign
id|fp
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|count
op_div_assign
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
op_star
id|to
op_increment
op_assign
op_star
id|from
op_increment
suffix:semicolon
)brace
)brace
eof
