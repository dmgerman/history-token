multiline_comment|/*&n; * Copyright(c) 1999 - 2003 Intel Corporation. All rights reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY&n; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; * for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n; *&n; * The full GNU General Public License is included in this distribution in the&n; * file called LICENSE.&n; */
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/pkt_sched.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/ipv6.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/if_bonding.h&gt;
macro_line|#include &lt;net/ipx.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &quot;bonding.h&quot;
macro_line|#include &quot;bond_alb.h&quot;
DECL|macro|ALB_TIMER_TICKS_PER_SEC
mdefine_line|#define ALB_TIMER_TICKS_PER_SEC&t;    10&t;/* should be a divisor of HZ */
DECL|macro|BOND_TLB_REBALANCE_INTERVAL
mdefine_line|#define BOND_TLB_REBALANCE_INTERVAL 10&t;/* in seconds, periodic re-balancing&n;&t;&t;&t;&t;&t; * used for division - never set&n;&t;&t;&t;&t;&t; * to zero !!!&n;&t;&t;&t;&t;&t; */
DECL|macro|BOND_ALB_LP_INTERVAL
mdefine_line|#define BOND_ALB_LP_INTERVAL&t;    1&t;/* in seconds periodic send of&n;&t;&t;&t;&t;&t; * learning packets to the switch&n;&t;&t;&t;&t;&t; */
DECL|macro|BOND_TLB_REBALANCE_TICKS
mdefine_line|#define BOND_TLB_REBALANCE_TICKS (BOND_TLB_REBALANCE_INTERVAL &bslash;&n;&t;&t;&t;&t;  * ALB_TIMER_TICKS_PER_SEC)
DECL|macro|BOND_ALB_LP_TICKS
mdefine_line|#define BOND_ALB_LP_TICKS (BOND_ALB_LP_INTERVAL &bslash;&n;&t;&t;&t;   * ALB_TIMER_TICKS_PER_SEC)
DECL|macro|TLB_HASH_TABLE_SIZE
mdefine_line|#define TLB_HASH_TABLE_SIZE 256&t;/* The size of the clients hash table.&n;&t;&t;&t;&t; * Note that this value MUST NOT be smaller&n;&t;&t;&t;&t; * because the key hash table BYTE wide !&n;&t;&t;&t;&t; */
DECL|macro|TLB_NULL_INDEX
mdefine_line|#define TLB_NULL_INDEX&t;&t;0xffffffff
DECL|macro|MAX_LP_RETRY
mdefine_line|#define MAX_LP_RETRY&t;&t;3
multiline_comment|/* rlb defs */
DECL|macro|RLB_HASH_TABLE_SIZE
mdefine_line|#define RLB_HASH_TABLE_SIZE&t;256
DECL|macro|RLB_NULL_INDEX
mdefine_line|#define RLB_NULL_INDEX&t;&t;0xffffffff
DECL|macro|RLB_UPDATE_DELAY
mdefine_line|#define RLB_UPDATE_DELAY&t;2*ALB_TIMER_TICKS_PER_SEC /* 2 seconds */
DECL|macro|RLB_ARP_BURST_SIZE
mdefine_line|#define RLB_ARP_BURST_SIZE&t;2
DECL|macro|RLB_UPDATE_RETRY
mdefine_line|#define RLB_UPDATE_RETRY&t;3&t;/* 3-ticks - must be smaller than the rlb&n;&t;&t;&t;&t;&t; * rebalance interval (5 min).&n;&t;&t;&t;&t;&t; */
multiline_comment|/* RLB_PROMISC_TIMEOUT = 10 sec equals the time that the current slave is&n; * promiscuous after failover&n; */
DECL|macro|RLB_PROMISC_TIMEOUT
mdefine_line|#define RLB_PROMISC_TIMEOUT&t;10*ALB_TIMER_TICKS_PER_SEC
macro_line|#pragma pack(1)
DECL|struct|learning_pkt
r_struct
id|learning_pkt
(brace
DECL|member|mac_dst
id|u8
id|mac_dst
(braket
id|ETH_ALEN
)braket
suffix:semicolon
DECL|member|mac_src
id|u8
id|mac_src
(braket
id|ETH_ALEN
)braket
suffix:semicolon
DECL|member|type
id|u16
id|type
suffix:semicolon
DECL|member|padding
id|u8
id|padding
(braket
id|ETH_ZLEN
op_minus
(paren
l_int|2
op_star
id|ETH_ALEN
op_plus
l_int|2
)paren
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|arp_pkt
r_struct
id|arp_pkt
(brace
DECL|member|hw_addr_space
id|u16
id|hw_addr_space
suffix:semicolon
DECL|member|prot_addr_space
id|u16
id|prot_addr_space
suffix:semicolon
DECL|member|hw_addr_len
id|u8
id|hw_addr_len
suffix:semicolon
DECL|member|prot_addr_len
id|u8
id|prot_addr_len
suffix:semicolon
DECL|member|op_code
id|u16
id|op_code
suffix:semicolon
DECL|member|mac_src
id|u8
id|mac_src
(braket
id|ETH_ALEN
)braket
suffix:semicolon
multiline_comment|/* sender hardware address */
DECL|member|ip_src
id|u32
id|ip_src
suffix:semicolon
multiline_comment|/* sender IP address */
DECL|member|mac_dst
id|u8
id|mac_dst
(braket
id|ETH_ALEN
)braket
suffix:semicolon
multiline_comment|/* target hardware address */
DECL|member|ip_dst
id|u32
id|ip_dst
suffix:semicolon
multiline_comment|/* target IP address */
)brace
suffix:semicolon
macro_line|#pragma pack()
multiline_comment|/* Forward declaration */
r_static
r_void
id|alb_send_learning_packets
c_func
(paren
r_struct
id|slave
op_star
id|slave
comma
id|u8
id|mac_addr
(braket
)braket
)paren
suffix:semicolon
r_static
r_inline
id|u8
DECL|function|_simple_hash
id|_simple_hash
c_func
(paren
id|u8
op_star
id|hash_start
comma
r_int
id|hash_size
)paren
(brace
r_int
id|i
suffix:semicolon
id|u8
id|hash
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hash_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hash
op_xor_assign
id|hash_start
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
id|hash
suffix:semicolon
)brace
multiline_comment|/*********************** tlb specific functions ***************************/
r_static
r_inline
r_void
DECL|function|_lock_tx_hashtbl
id|_lock_tx_hashtbl
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
dot
id|tx_hashtbl_lock
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|_unlock_tx_hashtbl
id|_unlock_tx_hashtbl
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
dot
id|tx_hashtbl_lock
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Caller must hold tx_hashtbl lock */
r_static
r_inline
r_void
DECL|function|tlb_init_table_entry
id|tlb_init_table_entry
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
id|u8
id|index
comma
id|u8
id|save_load
)paren
(brace
r_struct
id|tlb_client_info
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
dot
id|tx_hashtbl
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
id|entry
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
dot
id|tx_hashtbl
(braket
id|index
)braket
)paren
suffix:semicolon
multiline_comment|/* at end of cycle, save the load that was transmitted to the client&n;&t; * during the cycle, and set the tx_bytes counter to 0 for counting&n;&t; * the load during the next cycle&n;&t; */
r_if
c_cond
(paren
id|save_load
)paren
(brace
id|entry-&gt;load_history
op_assign
l_int|1
op_plus
id|entry-&gt;tx_bytes
op_div
id|BOND_TLB_REBALANCE_INTERVAL
suffix:semicolon
id|entry-&gt;tx_bytes
op_assign
l_int|0
suffix:semicolon
)brace
id|entry-&gt;tx_slave
op_assign
l_int|NULL
suffix:semicolon
id|entry-&gt;next
op_assign
id|TLB_NULL_INDEX
suffix:semicolon
id|entry-&gt;prev
op_assign
id|TLB_NULL_INDEX
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|tlb_init_slave
id|tlb_init_slave
c_func
(paren
r_struct
id|slave
op_star
id|slave
)paren
(brace
r_struct
id|tlb_slave_info
op_star
id|slave_info
op_assign
op_amp
(paren
id|SLAVE_TLB_INFO
c_func
(paren
id|slave
)paren
)paren
suffix:semicolon
id|slave_info-&gt;load
op_assign
l_int|0
suffix:semicolon
id|slave_info-&gt;head
op_assign
id|TLB_NULL_INDEX
suffix:semicolon
)brace
multiline_comment|/* Caller must hold bond lock for read */
r_static
r_inline
r_void
DECL|function|tlb_clear_slave
id|tlb_clear_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|slave
comma
id|u8
id|save_load
)paren
(brace
r_struct
id|tlb_client_info
op_star
id|tx_hash_table
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|index
comma
id|next_index
suffix:semicolon
multiline_comment|/* clear slave from tx_hashtbl */
id|_lock_tx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
id|tx_hash_table
op_assign
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
dot
id|tx_hashtbl
suffix:semicolon
r_if
c_cond
(paren
id|tx_hash_table
)paren
(brace
id|index
op_assign
id|SLAVE_TLB_INFO
c_func
(paren
id|slave
)paren
dot
id|head
suffix:semicolon
r_while
c_loop
(paren
id|index
op_ne
id|TLB_NULL_INDEX
)paren
(brace
id|next_index
op_assign
id|tx_hash_table
(braket
id|index
)braket
dot
id|next
suffix:semicolon
id|tlb_init_table_entry
c_func
(paren
id|bond
comma
id|index
comma
id|save_load
)paren
suffix:semicolon
id|index
op_assign
id|next_index
suffix:semicolon
)brace
)brace
id|_unlock_tx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
id|tlb_init_slave
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
multiline_comment|/* Must be called before starting the monitor timer */
r_static
r_int
DECL|function|tlb_initialize
id|tlb_initialize
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|size
suffix:semicolon
macro_line|#if(TLB_HASH_TABLE_SIZE != 256)
multiline_comment|/* Key to the hash table is byte wide. Check the size! */
macro_line|#error Hash Table size is wrong.
macro_line|#endif
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|bond_info-&gt;tx_hashtbl_lock
)paren
)paren
suffix:semicolon
id|_lock_tx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;tx_hashtbl
op_ne
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: TLB hash table is not NULL&bslash;n&quot;
comma
id|bond-&gt;device-&gt;name
)paren
suffix:semicolon
id|_unlock_tx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|size
op_assign
id|TLB_HASH_TABLE_SIZE
op_star
r_sizeof
(paren
r_struct
id|tlb_client_info
)paren
suffix:semicolon
id|bond_info-&gt;tx_hashtbl
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;tx_hashtbl
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: Failed to allocate TLB hash table&bslash;n&quot;
comma
id|bond-&gt;device-&gt;name
)paren
suffix:semicolon
id|_unlock_tx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|bond_info-&gt;tx_hashtbl
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TLB_HASH_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tlb_init_table_entry
c_func
(paren
id|bond
comma
id|i
comma
l_int|1
)paren
suffix:semicolon
)brace
id|_unlock_tx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Must be called only after all slaves have been released */
r_static
r_void
DECL|function|tlb_deinitialize
id|tlb_deinitialize
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
id|_lock_tx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;tx_hashtbl
op_eq
l_int|NULL
)paren
(brace
id|_unlock_tx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|bond_info-&gt;tx_hashtbl
)paren
suffix:semicolon
id|bond_info-&gt;tx_hashtbl
op_assign
l_int|NULL
suffix:semicolon
id|_unlock_tx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
multiline_comment|/* Caller must hold bond lock for read */
r_static
r_struct
id|slave
op_star
DECL|function|tlb_get_least_loaded_slave
id|tlb_get_least_loaded_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|slave
op_star
id|slave
suffix:semicolon
r_struct
id|slave
op_star
id|least_loaded
suffix:semicolon
id|u32
id|curr_gap
comma
id|max_gap
suffix:semicolon
multiline_comment|/* Find the first enabled slave */
id|slave
op_assign
id|bond_get_first_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_while
c_loop
(paren
id|slave
)paren
(brace
r_if
c_cond
(paren
id|SLAVE_IS_OK
c_func
(paren
id|slave
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|slave
op_assign
id|bond_get_next_slave
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|slave
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|least_loaded
op_assign
id|slave
suffix:semicolon
id|max_gap
op_assign
(paren
id|slave-&gt;speed
op_star
l_int|1000000
)paren
op_minus
(paren
id|SLAVE_TLB_INFO
c_func
(paren
id|slave
)paren
dot
id|load
op_star
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Find the slave with the largest gap */
id|slave
op_assign
id|bond_get_next_slave
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
r_while
c_loop
(paren
id|slave
)paren
(brace
r_if
c_cond
(paren
id|SLAVE_IS_OK
c_func
(paren
id|slave
)paren
)paren
(brace
id|curr_gap
op_assign
(paren
id|slave-&gt;speed
op_star
l_int|1000000
)paren
op_minus
(paren
id|SLAVE_TLB_INFO
c_func
(paren
id|slave
)paren
dot
id|load
op_star
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_gap
OL
id|curr_gap
)paren
(brace
id|least_loaded
op_assign
id|slave
suffix:semicolon
id|max_gap
op_assign
id|curr_gap
suffix:semicolon
)brace
)brace
id|slave
op_assign
id|bond_get_next_slave
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
)brace
r_return
id|least_loaded
suffix:semicolon
)brace
multiline_comment|/* Caller must hold bond lock for read */
r_struct
id|slave
op_star
DECL|function|tlb_choose_channel
id|tlb_choose_channel
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
id|u32
id|hash_index
comma
id|u32
id|skb_len
)paren
(brace
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
r_struct
id|tlb_client_info
op_star
id|hash_table
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|slave
op_star
id|assigned_slave
op_assign
l_int|NULL
suffix:semicolon
id|_lock_tx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
id|hash_table
op_assign
id|bond_info-&gt;tx_hashtbl
suffix:semicolon
r_if
c_cond
(paren
id|hash_table
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: TLB hash table is NULL&bslash;n&quot;
comma
id|bond-&gt;device-&gt;name
)paren
suffix:semicolon
id|_unlock_tx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|assigned_slave
op_assign
id|hash_table
(braket
id|hash_index
)braket
dot
id|tx_slave
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|assigned_slave
)paren
(brace
id|assigned_slave
op_assign
id|tlb_get_least_loaded_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|assigned_slave
)paren
(brace
r_struct
id|tlb_slave_info
op_star
id|slave_info
op_assign
op_amp
(paren
id|SLAVE_TLB_INFO
c_func
(paren
id|assigned_slave
)paren
)paren
suffix:semicolon
id|u32
id|next_index
op_assign
id|slave_info-&gt;head
suffix:semicolon
id|hash_table
(braket
id|hash_index
)braket
dot
id|tx_slave
op_assign
id|assigned_slave
suffix:semicolon
id|hash_table
(braket
id|hash_index
)braket
dot
id|next
op_assign
id|next_index
suffix:semicolon
id|hash_table
(braket
id|hash_index
)braket
dot
id|prev
op_assign
id|TLB_NULL_INDEX
suffix:semicolon
r_if
c_cond
(paren
id|next_index
op_ne
id|TLB_NULL_INDEX
)paren
(brace
id|hash_table
(braket
id|next_index
)braket
dot
id|prev
op_assign
id|hash_index
suffix:semicolon
)brace
id|slave_info-&gt;head
op_assign
id|hash_index
suffix:semicolon
id|slave_info-&gt;load
op_add_assign
id|hash_table
(braket
id|hash_index
)braket
dot
id|load_history
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|assigned_slave
)paren
(brace
id|hash_table
(braket
id|hash_index
)braket
dot
id|tx_bytes
op_add_assign
id|skb_len
suffix:semicolon
)brace
id|_unlock_tx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
id|assigned_slave
suffix:semicolon
)brace
multiline_comment|/*********************** rlb specific functions ***************************/
r_static
r_inline
r_void
DECL|function|_lock_rx_hashtbl
id|_lock_rx_hashtbl
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
dot
id|rx_hashtbl_lock
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|_unlock_rx_hashtbl
id|_unlock_rx_hashtbl
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
dot
id|rx_hashtbl_lock
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* when an ARP REPLY is received from a client update its info&n; * in the rx_hashtbl&n; */
r_static
r_void
DECL|function|rlb_update_entry_from_arp
id|rlb_update_entry_from_arp
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|arp_pkt
op_star
id|arp
)paren
(brace
id|u32
id|hash_index
suffix:semicolon
r_struct
id|rlb_client_info
op_star
id|client_info
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
id|_lock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rx_hashtbl
op_eq
l_int|NULL
)paren
(brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hash_index
op_assign
id|_simple_hash
c_func
(paren
(paren
id|u8
op_star
)paren
op_amp
(paren
id|arp-&gt;ip_src
)paren
comma
l_int|4
)paren
suffix:semicolon
id|client_info
op_assign
op_amp
(paren
id|bond_info-&gt;rx_hashtbl
(braket
id|hash_index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|client_info-&gt;assigned
)paren
op_logical_and
(paren
id|client_info-&gt;ip_src
op_eq
id|arp-&gt;ip_dst
)paren
op_logical_and
(paren
id|client_info-&gt;ip_dst
op_eq
id|arp-&gt;ip_src
)paren
)paren
(brace
multiline_comment|/* update the clients MAC address */
id|memcpy
c_func
(paren
id|client_info-&gt;mac_dst
comma
id|arp-&gt;mac_src
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|client_info-&gt;ntt
op_assign
l_int|1
suffix:semicolon
id|bond_info-&gt;rx_ntt
op_assign
l_int|1
suffix:semicolon
)brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|rlb_arp_recv
id|rlb_arp_recv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|ptype
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ret
op_assign
id|NET_RX_DROP
suffix:semicolon
r_struct
id|arp_pkt
op_star
id|arp
op_assign
(paren
r_struct
id|arp_pkt
op_star
)paren
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_MASTER
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|arp
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Packet has no ARP data&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
OL
r_sizeof
(paren
r_struct
id|arp_pkt
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Packet is too small to be an ARP&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp-&gt;op_code
op_eq
id|htons
c_func
(paren
id|ARPOP_REPLY
)paren
)paren
(brace
multiline_comment|/* update rx hash table for this ARP */
id|rlb_update_entry_from_arp
c_func
(paren
id|bond
comma
id|arp
)paren
suffix:semicolon
id|BOND_PRINT_DBG
c_func
(paren
(paren
l_string|&quot;Server received an ARP Reply from client&quot;
)paren
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|NET_RX_SUCCESS
suffix:semicolon
id|out
suffix:colon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Caller must hold bond lock for read */
r_static
r_struct
id|slave
op_star
DECL|function|rlb_next_rx_slave
id|rlb_next_rx_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|slave
op_star
id|rx_slave
op_assign
l_int|NULL
comma
op_star
id|slave
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
id|slave
op_assign
id|bond_info-&gt;next_rx_slave
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_eq
l_int|NULL
)paren
(brace
id|slave
op_assign
id|bond-&gt;next
suffix:semicolon
)brace
multiline_comment|/* this loop uses the circular linked list property of the&n;&t; * slave&squot;s list to go through all slaves&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bond-&gt;slave_cnt
suffix:semicolon
id|i
op_increment
comma
id|slave
op_assign
id|slave-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|SLAVE_IS_OK
c_func
(paren
id|slave
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rx_slave
)paren
(brace
id|rx_slave
op_assign
id|slave
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|slave-&gt;speed
OG
id|rx_slave-&gt;speed
)paren
(brace
id|rx_slave
op_assign
id|slave
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|rx_slave
)paren
(brace
id|bond_info-&gt;next_rx_slave
op_assign
id|rx_slave-&gt;next
suffix:semicolon
)brace
r_return
id|rx_slave
suffix:semicolon
)brace
multiline_comment|/* teach the switch the mac of a disabled slave&n; * on the primary for fault tolerance&n; *&n; * Caller must hold bond-&gt;ptrlock for write or bond lock for write&n; */
r_static
r_void
DECL|function|rlb_teach_disabled_mac_on_primary
id|rlb_teach_disabled_mac_on_primary
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
id|u8
id|addr
(braket
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bond-&gt;current_slave
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bond-&gt;alb_info.primary_is_promisc
)paren
(brace
id|bond-&gt;alb_info.primary_is_promisc
op_assign
l_int|1
suffix:semicolon
id|dev_set_promiscuity
c_func
(paren
id|bond-&gt;current_slave-&gt;dev
comma
l_int|1
)paren
suffix:semicolon
)brace
id|bond-&gt;alb_info.rlb_promisc_timeout_counter
op_assign
l_int|0
suffix:semicolon
id|alb_send_learning_packets
c_func
(paren
id|bond-&gt;current_slave
comma
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/* slave being removed should not be active at this point&n; *&n; * Caller must hold bond lock for read&n; */
r_static
r_void
DECL|function|rlb_clear_slave
id|rlb_clear_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|slave
)paren
(brace
r_struct
id|rlb_client_info
op_star
id|rx_hash_table
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
id|u8
id|mac_bcast
(braket
id|ETH_ALEN
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
id|u32
id|index
comma
id|next_index
suffix:semicolon
multiline_comment|/* clear slave from rx_hashtbl */
id|_lock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
id|rx_hash_table
op_assign
id|bond_info-&gt;rx_hashtbl
suffix:semicolon
r_if
c_cond
(paren
id|rx_hash_table
op_eq
l_int|NULL
)paren
(brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|index
op_assign
id|bond_info-&gt;rx_hashtbl_head
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|index
op_ne
id|RLB_NULL_INDEX
suffix:semicolon
id|index
op_assign
id|next_index
)paren
(brace
id|next_index
op_assign
id|rx_hash_table
(braket
id|index
)braket
dot
id|next
suffix:semicolon
r_if
c_cond
(paren
id|rx_hash_table
(braket
id|index
)braket
dot
id|slave
op_eq
id|slave
)paren
(brace
r_struct
id|slave
op_star
id|assigned_slave
op_assign
id|rlb_next_rx_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|assigned_slave
)paren
(brace
id|rx_hash_table
(braket
id|index
)braket
dot
id|slave
op_assign
id|assigned_slave
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|rx_hash_table
(braket
id|index
)braket
dot
id|mac_dst
comma
id|mac_bcast
comma
id|ETH_ALEN
)paren
)paren
(brace
id|bond_info-&gt;rx_hashtbl
(braket
id|index
)braket
dot
id|ntt
op_assign
l_int|1
suffix:semicolon
id|bond_info-&gt;rx_ntt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* A slave has been removed from the&n;&t;&t;&t;&t;&t; * table because it is either disabled&n;&t;&t;&t;&t;&t; * or being released. We must retry the&n;&t;&t;&t;&t;&t; * update to avoid clients from not&n;&t;&t;&t;&t;&t; * being updated &amp; disconnecting when&n;&t;&t;&t;&t;&t; * there is stress&n;&t;&t;&t;&t;&t; */
id|bond_info-&gt;rlb_update_retry_counter
op_assign
id|RLB_UPDATE_RETRY
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* there is no active slave */
id|rx_hash_table
(braket
id|index
)braket
dot
id|slave
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_ne
id|bond-&gt;current_slave
)paren
(brace
id|rlb_teach_disabled_mac_on_primary
c_func
(paren
id|bond
comma
id|slave-&gt;dev-&gt;dev_addr
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|rlb_update_client
id|rlb_update_client
c_func
(paren
r_struct
id|rlb_client_info
op_star
id|client_info
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|client_info-&gt;slave
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RLB_ARP_BURST_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|arp_send
c_func
(paren
id|ARPOP_REPLY
comma
id|ETH_P_ARP
comma
id|client_info-&gt;ip_dst
comma
id|client_info-&gt;slave-&gt;dev
comma
id|client_info-&gt;ip_src
comma
id|client_info-&gt;mac_dst
comma
id|client_info-&gt;slave-&gt;dev-&gt;dev_addr
comma
id|client_info-&gt;mac_dst
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* sends ARP REPLIES that update the clients that need updating */
r_static
r_void
DECL|function|rlb_update_rx_clients
id|rlb_update_rx_clients
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
id|u32
id|hash_index
suffix:semicolon
r_struct
id|rlb_client_info
op_star
id|client_info
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
id|_lock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rx_hashtbl
op_eq
l_int|NULL
)paren
(brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hash_index
op_assign
id|bond_info-&gt;rx_hashtbl_head
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|hash_index
op_ne
id|RLB_NULL_INDEX
suffix:semicolon
id|hash_index
op_assign
id|client_info-&gt;next
)paren
(brace
id|client_info
op_assign
op_amp
(paren
id|bond_info-&gt;rx_hashtbl
(braket
id|hash_index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|client_info-&gt;ntt
)paren
(brace
id|rlb_update_client
c_func
(paren
id|client_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rlb_update_retry_counter
op_eq
l_int|0
)paren
(brace
id|client_info-&gt;ntt
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* do not update the entries again untill this counter is zero so that&n;&t; * not to confuse the clients.&n;&t; */
id|bond_info-&gt;rlb_update_delay_counter
op_assign
id|RLB_UPDATE_DELAY
suffix:semicolon
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
multiline_comment|/* The slave was assigned a new mac address - update the clients */
r_static
r_void
DECL|function|rlb_req_update_slave_clients
id|rlb_req_update_slave_clients
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|slave
)paren
(brace
id|u32
id|hash_index
suffix:semicolon
id|u8
id|ntt
op_assign
l_int|0
suffix:semicolon
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
id|u8
id|mac_bcast
(braket
id|ETH_ALEN
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
r_struct
id|rlb_client_info
op_star
id|client_info
op_assign
l_int|NULL
suffix:semicolon
id|_lock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rx_hashtbl
op_eq
l_int|NULL
)paren
(brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hash_index
op_assign
id|bond_info-&gt;rx_hashtbl_head
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|hash_index
op_ne
id|RLB_NULL_INDEX
suffix:semicolon
id|hash_index
op_assign
id|client_info-&gt;next
)paren
(brace
id|client_info
op_assign
op_amp
(paren
id|bond_info-&gt;rx_hashtbl
(braket
id|hash_index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|client_info-&gt;slave
op_eq
id|slave
)paren
op_logical_and
id|memcmp
c_func
(paren
id|client_info-&gt;mac_dst
comma
id|mac_bcast
comma
id|ETH_ALEN
)paren
)paren
(brace
id|client_info-&gt;ntt
op_assign
l_int|1
suffix:semicolon
id|ntt
op_assign
l_int|1
suffix:semicolon
)brace
)brace
singleline_comment|// update the team&squot;s flag only after the whole iteration
r_if
c_cond
(paren
id|ntt
)paren
(brace
id|bond_info-&gt;rx_ntt
op_assign
l_int|1
suffix:semicolon
singleline_comment|//fasten the change
id|bond_info-&gt;rlb_update_retry_counter
op_assign
id|RLB_UPDATE_RETRY
suffix:semicolon
)brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
multiline_comment|/* mark all clients using src_ip to be updated */
r_static
r_void
DECL|function|rlb_req_update_subnet_clients
id|rlb_req_update_subnet_clients
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
id|u32
id|src_ip
)paren
(brace
id|u32
id|hash_index
suffix:semicolon
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
id|u8
id|mac_bcast
(braket
id|ETH_ALEN
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
r_struct
id|rlb_client_info
op_star
id|client_info
op_assign
l_int|NULL
suffix:semicolon
id|_lock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rx_hashtbl
op_eq
l_int|NULL
)paren
(brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hash_index
op_assign
id|bond_info-&gt;rx_hashtbl_head
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|hash_index
op_ne
id|RLB_NULL_INDEX
suffix:semicolon
id|hash_index
op_assign
id|client_info-&gt;next
)paren
(brace
id|client_info
op_assign
op_amp
(paren
id|bond_info-&gt;rx_hashtbl
(braket
id|hash_index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|client_info-&gt;slave
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Bonding: Error: found a client with no&quot;
l_string|&quot; channel in the client&squot;s hash table&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*update all clients using this src_ip, that are not assigned&n;&t;&t; * to the team&squot;s address (current_slave) and have a known&n;&t;&t; * unicast mac address.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|client_info-&gt;ip_src
op_eq
id|src_ip
)paren
op_logical_and
id|memcmp
c_func
(paren
id|client_info-&gt;slave-&gt;dev-&gt;dev_addr
comma
id|bond-&gt;device-&gt;dev_addr
comma
id|ETH_ALEN
)paren
op_logical_and
id|memcmp
c_func
(paren
id|client_info-&gt;mac_dst
comma
id|mac_bcast
comma
id|ETH_ALEN
)paren
)paren
(brace
id|client_info-&gt;ntt
op_assign
l_int|1
suffix:semicolon
id|bond_info-&gt;rx_ntt
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
multiline_comment|/* Caller must hold both bond and ptr locks for read */
r_struct
id|slave
op_star
DECL|function|rlb_choose_channel
id|rlb_choose_channel
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|arp_pkt
op_star
id|arp
)paren
(brace
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
r_struct
id|rlb_client_info
op_star
id|client_info
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|hash_index
op_assign
l_int|0
suffix:semicolon
r_struct
id|slave
op_star
id|assigned_slave
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|mac_bcast
(braket
id|ETH_ALEN
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
id|_lock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rx_hashtbl
op_eq
l_int|NULL
)paren
(brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|hash_index
op_assign
id|_simple_hash
c_func
(paren
(paren
id|u8
op_star
)paren
op_amp
id|arp-&gt;ip_dst
comma
l_int|4
)paren
suffix:semicolon
id|client_info
op_assign
op_amp
(paren
id|bond_info-&gt;rx_hashtbl
(braket
id|hash_index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|client_info-&gt;assigned
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|client_info-&gt;ip_src
op_eq
id|arp-&gt;ip_src
)paren
op_logical_and
(paren
id|client_info-&gt;ip_dst
op_eq
id|arp-&gt;ip_dst
)paren
)paren
(brace
multiline_comment|/* the entry is already assigned to this client */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|arp-&gt;mac_dst
comma
id|mac_bcast
comma
id|ETH_ALEN
)paren
)paren
(brace
multiline_comment|/* update mac address from arp */
id|memcpy
c_func
(paren
id|client_info-&gt;mac_dst
comma
id|arp-&gt;mac_dst
comma
id|ETH_ALEN
)paren
suffix:semicolon
)brace
id|assigned_slave
op_assign
id|client_info-&gt;slave
suffix:semicolon
r_if
c_cond
(paren
id|assigned_slave
)paren
(brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
id|assigned_slave
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* the entry is already assigned to some other client,&n;&t;&t;&t; * move the old client to primary (current_slave) so&n;&t;&t;&t; * that the new client can be assigned to this entry.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_logical_and
id|client_info-&gt;slave
op_ne
id|bond-&gt;current_slave
)paren
(brace
id|client_info-&gt;slave
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|rlb_update_client
c_func
(paren
id|client_info
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* assign a new slave */
id|assigned_slave
op_assign
id|rlb_next_rx_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|assigned_slave
)paren
(brace
id|client_info-&gt;ip_src
op_assign
id|arp-&gt;ip_src
suffix:semicolon
id|client_info-&gt;ip_dst
op_assign
id|arp-&gt;ip_dst
suffix:semicolon
multiline_comment|/* arp-&gt;mac_dst is broadcast for arp reqeusts.&n;&t;&t; * will be updated with clients actual unicast mac address&n;&t;&t; * upon receiving an arp reply.&n;&t;&t; */
id|memcpy
c_func
(paren
id|client_info-&gt;mac_dst
comma
id|arp-&gt;mac_dst
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|client_info-&gt;slave
op_assign
id|assigned_slave
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|client_info-&gt;mac_dst
comma
id|mac_bcast
comma
id|ETH_ALEN
)paren
)paren
(brace
id|client_info-&gt;ntt
op_assign
l_int|1
suffix:semicolon
id|bond-&gt;alb_info.rx_ntt
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|client_info-&gt;ntt
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|client_info-&gt;assigned
)paren
(brace
id|u32
id|prev_tbl_head
op_assign
id|bond_info-&gt;rx_hashtbl_head
suffix:semicolon
id|bond_info-&gt;rx_hashtbl_head
op_assign
id|hash_index
suffix:semicolon
id|client_info-&gt;next
op_assign
id|prev_tbl_head
suffix:semicolon
r_if
c_cond
(paren
id|prev_tbl_head
op_ne
id|RLB_NULL_INDEX
)paren
(brace
id|bond_info-&gt;rx_hashtbl
(braket
id|prev_tbl_head
)braket
dot
id|prev
op_assign
id|hash_index
suffix:semicolon
)brace
id|client_info-&gt;assigned
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
id|assigned_slave
suffix:semicolon
)brace
multiline_comment|/* chooses (and returns) transmit channel for arp reply&n; * does not choose channel for other arp types since they are&n; * sent on the current_slave&n; */
r_static
r_struct
id|slave
op_star
DECL|function|rlb_arp_xmit
id|rlb_arp_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|arp_pkt
op_star
id|arp
op_assign
(paren
r_struct
id|arp_pkt
op_star
)paren
id|skb-&gt;nh.raw
suffix:semicolon
r_struct
id|slave
op_star
id|tx_slave
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|arp-&gt;op_code
op_eq
id|__constant_htons
c_func
(paren
id|ARPOP_REPLY
)paren
)paren
(brace
multiline_comment|/* the arp must be sent on the selected&n;&t;&t;* rx channel&n;&t;&t;*/
id|tx_slave
op_assign
id|rlb_choose_channel
c_func
(paren
id|bond
comma
id|arp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tx_slave
)paren
(brace
id|memcpy
c_func
(paren
id|arp-&gt;mac_src
comma
id|tx_slave-&gt;dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
)brace
id|BOND_PRINT_DBG
c_func
(paren
(paren
l_string|&quot;Server sent ARP Reply packet&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|arp-&gt;op_code
op_eq
id|__constant_htons
c_func
(paren
id|ARPOP_REQUEST
)paren
)paren
(brace
multiline_comment|/* Create an entry in the rx_hashtbl for this client as a&n;&t;&t; * place holder.&n;&t;&t; * When the arp reply is received the entry will be updated&n;&t;&t; * with the correct unicast address of the client.&n;&t;&t; */
id|rlb_choose_channel
c_func
(paren
id|bond
comma
id|arp
)paren
suffix:semicolon
multiline_comment|/* The ARP relpy packets must be delayed so that&n;&t;&t; * they can cancel out the influence of the ARP request.&n;&t;&t; */
id|bond-&gt;alb_info.rlb_update_delay_counter
op_assign
id|RLB_UPDATE_DELAY
suffix:semicolon
multiline_comment|/* arp requests are broadcast and are sent on the primary&n;&t;&t; * the arp request will collapse all clients on the subnet to&n;&t;&t; * the primary slave. We must register these clients to be&n;&t;&t; * updated with their assigned mac.&n;&t;&t; */
id|rlb_req_update_subnet_clients
c_func
(paren
id|bond
comma
id|arp-&gt;ip_src
)paren
suffix:semicolon
id|BOND_PRINT_DBG
c_func
(paren
(paren
l_string|&quot;Server sent ARP Request packet&quot;
)paren
)paren
suffix:semicolon
)brace
r_return
id|tx_slave
suffix:semicolon
)brace
multiline_comment|/* Caller must hold bond lock for read */
r_static
r_void
DECL|function|rlb_rebalance
id|rlb_rebalance
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
r_struct
id|slave
op_star
id|assigned_slave
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|hash_index
suffix:semicolon
r_struct
id|rlb_client_info
op_star
id|client_info
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|ntt
op_assign
l_int|0
suffix:semicolon
id|_lock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rx_hashtbl
op_eq
l_int|NULL
)paren
(brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hash_index
op_assign
id|bond_info-&gt;rx_hashtbl_head
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|hash_index
op_ne
id|RLB_NULL_INDEX
suffix:semicolon
id|hash_index
op_assign
id|client_info-&gt;next
)paren
(brace
id|client_info
op_assign
op_amp
(paren
id|bond_info-&gt;rx_hashtbl
(braket
id|hash_index
)braket
)paren
suffix:semicolon
id|assigned_slave
op_assign
id|rlb_next_rx_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|assigned_slave
op_logical_and
(paren
id|client_info-&gt;slave
op_ne
id|assigned_slave
)paren
)paren
(brace
id|client_info-&gt;slave
op_assign
id|assigned_slave
suffix:semicolon
id|client_info-&gt;ntt
op_assign
l_int|1
suffix:semicolon
id|ntt
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* update the team&squot;s flag only after the whole iteration */
r_if
c_cond
(paren
id|ntt
)paren
(brace
id|bond_info-&gt;rx_ntt
op_assign
l_int|1
suffix:semicolon
)brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
multiline_comment|/* Caller must hold rx_hashtbl lock */
r_static
r_inline
r_void
DECL|function|rlb_init_table_entry
id|rlb_init_table_entry
c_func
(paren
r_struct
id|rlb_client_info
op_star
id|entry
)paren
(brace
id|entry-&gt;next
op_assign
id|RLB_NULL_INDEX
suffix:semicolon
id|entry-&gt;prev
op_assign
id|RLB_NULL_INDEX
suffix:semicolon
id|entry-&gt;assigned
op_assign
l_int|0
suffix:semicolon
id|entry-&gt;ntt
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|rlb_initialize
id|rlb_initialize
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
r_struct
id|packet_type
op_star
id|pk_type
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
dot
id|rlb_pkt_type
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|size
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|bond_info-&gt;rx_hashtbl_lock
)paren
)paren
suffix:semicolon
id|_lock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rx_hashtbl
op_ne
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: RLB hash table is not NULL&bslash;n&quot;
comma
id|bond-&gt;device-&gt;name
)paren
suffix:semicolon
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|size
op_assign
id|RLB_HASH_TABLE_SIZE
op_star
r_sizeof
(paren
r_struct
id|rlb_client_info
)paren
suffix:semicolon
id|bond_info-&gt;rx_hashtbl
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rx_hashtbl
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: Failed to allocate&quot;
l_string|&quot; RLB hash table&bslash;n&quot;
comma
id|bond-&gt;device-&gt;name
)paren
suffix:semicolon
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|bond_info-&gt;rx_hashtbl_head
op_assign
id|RLB_NULL_INDEX
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RLB_HASH_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rlb_init_table_entry
c_func
(paren
id|bond_info-&gt;rx_hashtbl
op_plus
id|i
)paren
suffix:semicolon
)brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
multiline_comment|/* register to receive ARPs */
multiline_comment|/*initialize packet type*/
id|pk_type-&gt;type
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_ARP
)paren
suffix:semicolon
id|pk_type-&gt;dev
op_assign
id|bond-&gt;device
suffix:semicolon
id|pk_type-&gt;func
op_assign
id|rlb_arp_recv
suffix:semicolon
id|pk_type-&gt;data
op_assign
(paren
r_void
op_star
)paren
l_int|1
suffix:semicolon
multiline_comment|/* understand shared skbs */
id|dev_add_pack
c_func
(paren
id|pk_type
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|rlb_deinitialize
id|rlb_deinitialize
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
id|dev_remove_pack
c_func
(paren
op_amp
(paren
id|bond_info-&gt;rlb_pkt_type
)paren
)paren
suffix:semicolon
id|_lock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rx_hashtbl
op_eq
l_int|NULL
)paren
(brace
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|bond_info-&gt;rx_hashtbl
)paren
suffix:semicolon
id|bond_info-&gt;rx_hashtbl
op_assign
l_int|NULL
suffix:semicolon
id|_unlock_rx_hashtbl
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
multiline_comment|/*********************** tlb/rlb shared functions *********************/
r_static
r_void
DECL|function|alb_send_learning_packets
id|alb_send_learning_packets
c_func
(paren
r_struct
id|slave
op_star
id|slave
comma
id|u8
id|mac_addr
(braket
)braket
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|learning_pkt
id|pkt
suffix:semicolon
r_char
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|size
op_assign
r_sizeof
(paren
r_struct
id|learning_pkt
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pkt
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|pkt.mac_dst
comma
id|mac_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|pkt.mac_src
comma
id|mac_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|pkt.type
op_assign
id|__constant_htons
c_func
(paren
id|ETH_P_LOOP
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_LP_RETRY
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb
op_assign
l_int|NULL
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
r_return
suffix:semicolon
)brace
id|data
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|data
comma
op_amp
id|pkt
comma
id|size
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|data
suffix:semicolon
id|skb-&gt;nh.raw
op_assign
id|data
op_plus
id|ETH_HLEN
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|pkt.type
suffix:semicolon
id|skb-&gt;priority
op_assign
id|TC_PRIO_CONTROL
suffix:semicolon
id|skb-&gt;dev
op_assign
id|slave-&gt;dev
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* hw is a boolean parameter that determines whether we should try and&n; * set the hw address of the hw as well as the hw address of the net_device&n; */
r_static
r_int
DECL|function|alb_set_mac_addr
id|alb_set_mac_addr
c_func
(paren
r_struct
id|slave
op_star
id|slave
comma
id|u8
id|addr
(braket
)braket
comma
r_int
id|hw
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sockaddr
id|s_addr
suffix:semicolon
id|dev
op_assign
id|slave-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hw
)paren
(brace
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* for rlb each slave must have a unique hw mac addresses so that */
multiline_comment|/* each slave will receive packets destined to a different mac */
id|memcpy
c_func
(paren
id|s_addr.sa_data
comma
id|addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|s_addr.sa_family
op_assign
id|dev-&gt;type
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|dev
comma
op_amp
id|s_addr
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bonding: Error: alb_set_mac_addr:&quot;
l_string|&quot; dev-&gt;set_mac_address of dev %s failed!&quot;
l_string|&quot; ALB mode requires that the base driver&quot;
l_string|&quot; support setting the hw address also when&quot;
l_string|&quot; the network device&squot;s interface is open&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Caller must hold bond lock for write or ptrlock for write*/
r_static
r_void
DECL|function|alb_swap_mac_addr
id|alb_swap_mac_addr
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|slave1
comma
r_struct
id|slave
op_star
id|slave2
)paren
(brace
id|u8
id|tmp_mac_addr
(braket
id|ETH_ALEN
)braket
suffix:semicolon
r_struct
id|slave
op_star
id|disabled_slave
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|slaves_state_differ
suffix:semicolon
id|slaves_state_differ
op_assign
(paren
id|SLAVE_IS_OK
c_func
(paren
id|slave1
)paren
op_ne
id|SLAVE_IS_OK
c_func
(paren
id|slave2
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmp_mac_addr
comma
id|slave1-&gt;dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|alb_set_mac_addr
c_func
(paren
id|slave1
comma
id|slave2-&gt;dev-&gt;dev_addr
comma
id|bond-&gt;alb_info.rlb_enabled
)paren
suffix:semicolon
id|alb_set_mac_addr
c_func
(paren
id|slave2
comma
id|tmp_mac_addr
comma
id|bond-&gt;alb_info.rlb_enabled
)paren
suffix:semicolon
multiline_comment|/* fasten the change in the switch */
r_if
c_cond
(paren
id|SLAVE_IS_OK
c_func
(paren
id|slave1
)paren
)paren
(brace
id|alb_send_learning_packets
c_func
(paren
id|slave1
comma
id|slave1-&gt;dev-&gt;dev_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;alb_info.rlb_enabled
)paren
(brace
multiline_comment|/* inform the clients that the mac address&n;&t;&t;&t; * has changed&n;&t;&t;&t; */
id|rlb_req_update_slave_clients
c_func
(paren
id|bond
comma
id|slave1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|disabled_slave
op_assign
id|slave1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SLAVE_IS_OK
c_func
(paren
id|slave2
)paren
)paren
(brace
id|alb_send_learning_packets
c_func
(paren
id|slave2
comma
id|slave2-&gt;dev-&gt;dev_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;alb_info.rlb_enabled
)paren
(brace
multiline_comment|/* inform the clients that the mac address&n;&t;&t;&t; * has changed&n;&t;&t;&t; */
id|rlb_req_update_slave_clients
c_func
(paren
id|bond
comma
id|slave2
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|disabled_slave
op_assign
id|slave2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;alb_info.rlb_enabled
op_logical_and
id|slaves_state_differ
)paren
(brace
multiline_comment|/* A disabled slave was assigned an active mac addr */
id|rlb_teach_disabled_mac_on_primary
c_func
(paren
id|bond
comma
id|disabled_slave-&gt;dev-&gt;dev_addr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * alb_change_hw_addr_on_detach&n; * @bond: bonding we&squot;re working on&n; * @slave: the slave that was just detached&n; *&n; * We assume that @slave was already detached from the slave list.&n; *&n; * If @slave&squot;s permanent hw address is different both from its current&n; * address and from @bond&squot;s address, then somewhere in the bond there&squot;s&n; * a slave that has @slave&squot;s permanet address as its current address.&n; * We&squot;ll make sure that that slave no longer uses @slave&squot;s permanent address.&n; *&n; * Caller must hold bond lock&n; */
r_static
r_void
DECL|function|alb_change_hw_addr_on_detach
id|alb_change_hw_addr_on_detach
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|slave
)paren
(brace
r_struct
id|slave
op_star
id|tmp_slave
suffix:semicolon
r_int
id|perm_curr_diff
suffix:semicolon
r_int
id|perm_bond_diff
suffix:semicolon
id|perm_curr_diff
op_assign
id|memcmp
c_func
(paren
id|slave-&gt;perm_hwaddr
comma
id|slave-&gt;dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|perm_bond_diff
op_assign
id|memcmp
c_func
(paren
id|slave-&gt;perm_hwaddr
comma
id|bond-&gt;device-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|perm_curr_diff
op_logical_and
id|perm_bond_diff
)paren
(brace
id|tmp_slave
op_assign
id|bond_get_first_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tmp_slave
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|slave-&gt;perm_hwaddr
comma
id|tmp_slave-&gt;dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|tmp_slave
op_assign
id|bond_get_next_slave
c_func
(paren
id|bond
comma
id|tmp_slave
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp_slave
)paren
(brace
id|alb_swap_mac_addr
c_func
(paren
id|bond
comma
id|slave
comma
id|tmp_slave
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; * alb_handle_addr_collision_on_attach&n; * @bond: bonding we&squot;re working on&n; * @slave: the slave that was just attached&n; *&n; * checks uniqueness of slave&squot;s mac address and handles the case the&n; * new slave uses the bonds mac address.&n; *&n; * If the permanent hw address of @slave is @bond&squot;s hw address, we need to&n; * find a different hw address to give @slave, that isn&squot;t in use by any other&n; * slave in the bond. This address must be, of course, one of the premanent&n; * addresses of the other slaves.&n; *&n; * We go over the slave list, and for each slave there we compare its&n; * permanent hw address with the current address of all the other slaves.&n; * If no match was found, then we&squot;ve found a slave with a permanent address&n; * that isn&squot;t used by any other slave in the bond, so we can assign it to&n; * @slave.&n; *&n; * assumption: this function is called before @slave is attached to the&n; * &t;       bond slave list.&n; *&n; * caller must hold the bond lock for write since the mac addresses are compared&n; * and may be swapped.&n; */
r_static
r_int
DECL|function|alb_handle_addr_collision_on_attach
id|alb_handle_addr_collision_on_attach
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|slave
)paren
(brace
r_struct
id|slave
op_star
id|tmp_slave1
comma
op_star
id|tmp_slave2
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
op_eq
l_int|0
)paren
(brace
multiline_comment|/* this is the first slave */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if slave&squot;s mac address differs from bond&squot;s mac address&n;&t; * check uniqueness of slave&squot;s mac address against the other&n;&t; * slaves in the bond.&n;&t; */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|slave-&gt;perm_hwaddr
comma
id|bond-&gt;device-&gt;dev_addr
comma
id|ETH_ALEN
)paren
)paren
(brace
id|tmp_slave1
op_assign
id|bond_get_first_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|tmp_slave1
suffix:semicolon
id|tmp_slave1
op_assign
id|bond_get_next_slave
c_func
(paren
id|bond
comma
id|tmp_slave1
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|tmp_slave1-&gt;dev-&gt;dev_addr
comma
id|slave-&gt;dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tmp_slave1
)paren
(brace
multiline_comment|/* a slave was found that is using the mac address&n;&t;&t;&t; * of the new slave&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bonding: Warning: the hw address &quot;
l_string|&quot;of slave %s is not unique - cannot enslave it!&quot;
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* the slave&squot;s address is equal to the address of the bond&n;&t; * search for a spare address in the bond for this slave.&n;&t; */
id|tmp_slave1
op_assign
id|bond_get_first_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|tmp_slave1
suffix:semicolon
id|tmp_slave1
op_assign
id|bond_get_next_slave
c_func
(paren
id|bond
comma
id|tmp_slave1
)paren
)paren
(brace
id|tmp_slave2
op_assign
id|bond_get_first_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|tmp_slave2
suffix:semicolon
id|tmp_slave2
op_assign
id|bond_get_next_slave
c_func
(paren
id|bond
comma
id|tmp_slave2
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|tmp_slave1-&gt;perm_hwaddr
comma
id|tmp_slave2-&gt;dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp_slave2
)paren
(brace
multiline_comment|/* no slave has tmp_slave1&squot;s perm addr&n;&t;&t;&t; * as its curr addr&n;&t;&t;&t; */
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tmp_slave1
)paren
(brace
id|alb_set_mac_addr
c_func
(paren
id|slave
comma
id|tmp_slave1-&gt;perm_hwaddr
comma
id|bond-&gt;alb_info.rlb_enabled
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding: Warning: the hw address &quot;
l_string|&quot;of slave %s is in use by the bond; &quot;
l_string|&quot;giving it the hw address of %s&bslash;n&quot;
comma
id|slave-&gt;dev-&gt;name
comma
id|tmp_slave1-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;bonding: Error: the hw address &quot;
l_string|&quot;of slave %s is in use by the bond; &quot;
l_string|&quot;couldn&squot;t find a slave with a free hw &quot;
l_string|&quot;address to give it (this should not have &quot;
l_string|&quot;happened)&bslash;n&quot;
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/************************ exported alb funcions ************************/
r_int
DECL|function|bond_alb_initialize
id|bond_alb_initialize
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_int
id|rlb_enabled
)paren
(brace
r_int
id|res
suffix:semicolon
id|res
op_assign
id|tlb_initialize
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
r_return
id|res
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rlb_enabled
)paren
(brace
id|bond-&gt;alb_info.rlb_enabled
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* initialize rlb */
id|res
op_assign
id|rlb_initialize
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|tlb_deinitialize
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|bond_alb_deinitialize
id|bond_alb_deinitialize
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
id|tlb_deinitialize
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rlb_enabled
)paren
(brace
id|rlb_deinitialize
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|bond_alb_xmit
id|bond_alb_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ethhdr
op_star
id|eth_data
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
r_struct
id|slave
op_star
id|tx_slave
op_assign
l_int|NULL
suffix:semicolon
r_char
id|do_tx_balance
op_assign
l_int|1
suffix:semicolon
r_int
id|hash_size
op_assign
l_int|0
suffix:semicolon
id|u32
id|hash_index
op_assign
l_int|0
suffix:semicolon
id|u8
op_star
id|hash_start
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|mac_bcast
(braket
id|ETH_ALEN
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_UP
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* bond down */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* make sure that the current_slave and the slaves list do&n;&t; * not change during tx&n;&t; */
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
op_eq
l_int|0
)paren
(brace
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ntohs
c_func
(paren
id|skb-&gt;protocol
)paren
)paren
(brace
r_case
id|ETH_P_IP
suffix:colon
r_if
c_cond
(paren
(paren
id|memcmp
c_func
(paren
id|eth_data-&gt;h_dest
comma
id|mac_bcast
comma
id|ETH_ALEN
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|skb-&gt;nh.iph-&gt;daddr
op_eq
l_int|0xffffffff
)paren
)paren
(brace
id|do_tx_balance
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hash_start
op_assign
(paren
r_char
op_star
)paren
op_amp
(paren
id|skb-&gt;nh.iph-&gt;daddr
)paren
suffix:semicolon
id|hash_size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETH_P_IPV6
suffix:colon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|eth_data-&gt;h_dest
comma
id|mac_bcast
comma
id|ETH_ALEN
)paren
op_eq
l_int|0
)paren
(brace
id|do_tx_balance
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hash_start
op_assign
(paren
r_char
op_star
)paren
op_amp
(paren
id|skb-&gt;nh.ipv6h-&gt;daddr
)paren
suffix:semicolon
id|hash_size
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef FIXME
r_case
id|ETH_P_IPX
suffix:colon
r_if
c_cond
(paren
id|skb-&gt;nh.ipxh-&gt;ipx_checksum
op_ne
id|__constant_htons
c_func
(paren
id|IPX_NO_CHECKSUM
)paren
)paren
(brace
multiline_comment|/* something is wrong with this packet */
id|do_tx_balance
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;nh.ipxh-&gt;ipx_type
op_ne
id|__constant_htons
c_func
(paren
id|IPX_TYPE_NCP
)paren
)paren
(brace
multiline_comment|/* The only protocol worth balancing in&n;&t;&t;&t; * this family since it has an &quot;ARP&quot; like&n;&t;&t;&t; * mechanism&n;&t;&t;&t; */
id|do_tx_balance
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hash_start
op_assign
(paren
r_char
op_star
)paren
id|eth_data-&gt;h_dest
suffix:semicolon
id|hash_size
op_assign
id|ETH_ALEN
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|ETH_P_ARP
suffix:colon
id|do_tx_balance
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rlb_enabled
)paren
(brace
id|tx_slave
op_assign
id|rlb_arp_xmit
c_func
(paren
id|skb
comma
id|bond
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|do_tx_balance
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_tx_balance
)paren
(brace
id|hash_index
op_assign
id|_simple_hash
c_func
(paren
id|hash_start
comma
id|hash_size
)paren
suffix:semicolon
id|tx_slave
op_assign
id|tlb_choose_channel
c_func
(paren
id|bond
comma
id|hash_index
comma
id|skb-&gt;len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tx_slave
)paren
(brace
multiline_comment|/* unbalanced or unassigned, send through primary */
id|tx_slave
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|bond_info-&gt;unbalanced_load
op_add_assign
id|skb-&gt;len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_slave
op_logical_and
id|SLAVE_IS_OK
c_func
(paren
id|tx_slave
)paren
)paren
(brace
id|skb-&gt;dev
op_assign
id|tx_slave-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|tx_slave
op_ne
id|bond-&gt;current_slave
)paren
(brace
id|memcpy
c_func
(paren
id|eth_data-&gt;h_source
comma
id|tx_slave-&gt;dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
)brace
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no suitable interface, frame not sent */
r_if
c_cond
(paren
id|tx_slave
)paren
(brace
id|tlb_clear_slave
c_func
(paren
id|bond
comma
id|tx_slave
comma
l_int|0
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|bond_alb_monitor
id|bond_alb_monitor
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
r_struct
id|slave
op_star
id|slave
op_assign
l_int|NULL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bond-&gt;slave_cnt
op_eq
l_int|0
)paren
op_logical_or
op_logical_neg
(paren
id|bond-&gt;device-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
id|bond_info-&gt;tx_rebalance_counter
op_assign
l_int|0
suffix:semicolon
id|bond_info-&gt;lp_counter
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|bond_info-&gt;tx_rebalance_counter
op_increment
suffix:semicolon
id|bond_info-&gt;lp_counter
op_increment
suffix:semicolon
multiline_comment|/* send learning packets */
r_if
c_cond
(paren
id|bond_info-&gt;lp_counter
op_ge
id|BOND_ALB_LP_TICKS
)paren
(brace
multiline_comment|/* change of current_slave involves swapping of mac addresses.&n;&t;&t; * in order to avoid this swapping from happening while&n;&t;&t; * sending the learning packets, the ptrlock must be held for&n;&t;&t; * read.&n;&t;&t; */
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|slave
op_assign
id|bond_get_first_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_while
c_loop
(paren
id|slave
)paren
(brace
id|alb_send_learning_packets
c_func
(paren
id|slave
comma
id|slave-&gt;dev-&gt;dev_addr
)paren
suffix:semicolon
id|slave
op_assign
id|bond_get_next_slave
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond_info-&gt;lp_counter
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* rebalance tx traffic */
r_if
c_cond
(paren
id|bond_info-&gt;tx_rebalance_counter
op_ge
id|BOND_TLB_REBALANCE_TICKS
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|slave
op_assign
id|bond_get_first_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_while
c_loop
(paren
id|slave
)paren
(brace
id|tlb_clear_slave
c_func
(paren
id|bond
comma
id|slave
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_eq
id|bond-&gt;current_slave
)paren
(brace
id|SLAVE_TLB_INFO
c_func
(paren
id|slave
)paren
dot
id|load
op_assign
id|bond_info-&gt;unbalanced_load
op_div
id|BOND_TLB_REBALANCE_INTERVAL
suffix:semicolon
id|bond_info-&gt;unbalanced_load
op_assign
l_int|0
suffix:semicolon
)brace
id|slave
op_assign
id|bond_get_next_slave
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond_info-&gt;tx_rebalance_counter
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* handle rlb stuff */
r_if
c_cond
(paren
id|bond_info-&gt;rlb_enabled
)paren
(brace
multiline_comment|/* the following code changes the promiscuity of the&n;&t;&t; * the current_slave. It needs to be locked with a&n;&t;&t; * write lock to protect from other code that also&n;&t;&t; * sets the promiscuity.&n;&t;&t; */
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;primary_is_promisc
op_logical_and
(paren
op_increment
id|bond_info-&gt;rlb_promisc_timeout_counter
op_ge
id|RLB_PROMISC_TIMEOUT
)paren
)paren
(brace
id|bond_info-&gt;rlb_promisc_timeout_counter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If the primary was set to promiscuous mode&n;&t;&t;&t; * because a slave was disabled then&n;&t;&t;&t; * it can now leave promiscuous mode.&n;&t;&t;&t; */
id|dev_set_promiscuity
c_func
(paren
id|bond-&gt;current_slave-&gt;dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|bond_info-&gt;primary_is_promisc
op_assign
l_int|0
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rlb_rebalance
op_eq
l_int|1
)paren
(brace
id|bond_info-&gt;rlb_rebalance
op_assign
l_int|0
suffix:semicolon
id|rlb_rebalance
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
multiline_comment|/* check if clients need updating */
r_if
c_cond
(paren
id|bond_info-&gt;rx_ntt
)paren
(brace
r_if
c_cond
(paren
id|bond_info-&gt;rlb_update_delay_counter
)paren
(brace
op_decrement
id|bond_info-&gt;rlb_update_delay_counter
suffix:semicolon
)brace
r_else
(brace
id|rlb_update_rx_clients
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_info-&gt;rlb_update_retry_counter
)paren
(brace
op_decrement
id|bond_info-&gt;rlb_update_retry_counter
suffix:semicolon
)brace
r_else
(brace
id|bond_info-&gt;rx_ntt
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;device-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
multiline_comment|/* re-arm the timer */
id|mod_timer
c_func
(paren
op_amp
(paren
id|bond_info-&gt;alb_timer
)paren
comma
id|jiffies
op_plus
(paren
id|HZ
op_div
id|ALB_TIMER_TICKS_PER_SEC
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* assumption: called before the slave is attched to the bond&n; * and not locked by the bond lock&n; */
r_int
DECL|function|bond_alb_init_slave
id|bond_alb_init_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|slave
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|alb_set_mac_addr
c_func
(paren
id|slave
comma
id|slave-&gt;perm_hwaddr
comma
id|bond-&gt;alb_info.rlb_enabled
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* caller must hold the bond lock for write since the mac addresses&n;&t; * are compared and may be swapped.&n;&t; */
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|err
op_assign
id|alb_handle_addr_collision_on_attach
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|tlb_init_slave
c_func
(paren
id|slave
)paren
suffix:semicolon
multiline_comment|/* order a rebalance ASAP */
id|bond-&gt;alb_info.tx_rebalance_counter
op_assign
id|BOND_TLB_REBALANCE_TICKS
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;alb_info.rlb_enabled
)paren
(brace
id|bond-&gt;alb_info.rlb_rebalance
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Caller must hold bond lock for write */
r_void
DECL|function|bond_alb_deinit_slave
id|bond_alb_deinit_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|slave
)paren
(brace
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
OG
l_int|1
)paren
(brace
id|alb_change_hw_addr_on_detach
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
)brace
id|tlb_clear_slave
c_func
(paren
id|bond
comma
id|slave
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;alb_info.rlb_enabled
)paren
(brace
id|bond-&gt;alb_info.next_rx_slave
op_assign
l_int|NULL
suffix:semicolon
id|rlb_clear_slave
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Caller must hold bond lock for read */
r_void
DECL|function|bond_alb_handle_link_change
id|bond_alb_handle_link_change
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|slave
comma
r_char
id|link
)paren
(brace
r_struct
id|alb_bond_info
op_star
id|bond_info
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
op_eq
id|BOND_LINK_DOWN
)paren
(brace
id|tlb_clear_slave
c_func
(paren
id|bond
comma
id|slave
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;alb_info.rlb_enabled
)paren
(brace
id|rlb_clear_slave
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|link
op_eq
id|BOND_LINK_UP
)paren
(brace
multiline_comment|/* order a rebalance ASAP */
id|bond_info-&gt;tx_rebalance_counter
op_assign
id|BOND_TLB_REBALANCE_TICKS
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;alb_info.rlb_enabled
)paren
(brace
id|bond-&gt;alb_info.rlb_rebalance
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* If the updelay module parameter is smaller than the&n;&t;&t;&t; * forwarding delay of the switch the rebalance will&n;&t;&t;&t; * not work because the rebalance arp replies will&n;&t;&t;&t; * not be forwarded to the clients..&n;&t;&t;&t; */
)brace
)brace
)brace
multiline_comment|/**&n; * bond_alb_assign_current_slave - assign new current_slave&n; * @bond: our bonding struct&n; * @new_slave: new slave to assign&n; *&n; * Set the bond-&gt;current_slave to @new_slave and handle&n; * mac address swapping and promiscuity changes as needed.&n; *&n; * Caller must hold bond ptrlock for write (or bond lock for write)&n; */
r_void
DECL|function|bond_alb_assign_current_slave
id|bond_alb_assign_current_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|new_slave
)paren
(brace
r_struct
id|slave
op_star
id|swap_slave
op_assign
id|bond-&gt;current_slave
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_eq
id|new_slave
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_logical_and
id|bond-&gt;alb_info.primary_is_promisc
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|bond-&gt;current_slave-&gt;dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|bond-&gt;alb_info.primary_is_promisc
op_assign
l_int|0
suffix:semicolon
id|bond-&gt;alb_info.rlb_promisc_timeout_counter
op_assign
l_int|0
suffix:semicolon
)brace
id|bond-&gt;current_slave
op_assign
id|new_slave
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_slave
op_logical_or
(paren
id|bond-&gt;slave_cnt
op_eq
l_int|0
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* set the new current_slave to the bonds mac address&n;&t; * i.e. swap mac addresses of old current_slave and new current_slave&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|swap_slave
)paren
(brace
multiline_comment|/* find slave that is holding the bond&squot;s mac address */
id|swap_slave
op_assign
id|bond_get_first_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_while
c_loop
(paren
id|swap_slave
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|swap_slave-&gt;dev-&gt;dev_addr
comma
id|bond-&gt;device-&gt;dev_addr
comma
id|ETH_ALEN
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|swap_slave
op_assign
id|bond_get_next_slave
c_func
(paren
id|bond
comma
id|swap_slave
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* current_slave must be set before calling alb_swap_mac_addr */
r_if
c_cond
(paren
id|swap_slave
)paren
(brace
multiline_comment|/* swap mac address */
id|alb_swap_mac_addr
c_func
(paren
id|bond
comma
id|swap_slave
comma
id|new_slave
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* set the new_slave to the bond mac address */
id|alb_set_mac_addr
c_func
(paren
id|new_slave
comma
id|bond-&gt;device-&gt;dev_addr
comma
id|bond-&gt;alb_info.rlb_enabled
)paren
suffix:semicolon
multiline_comment|/* fasten bond mac on new current slave */
id|alb_send_learning_packets
c_func
(paren
id|new_slave
comma
id|bond-&gt;device-&gt;dev_addr
)paren
suffix:semicolon
)brace
)brace
eof
