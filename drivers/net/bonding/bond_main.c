multiline_comment|/*&n; * originally based on the dummy device.&n; *&n; * Copyright 1999, Thomas Davis, tadavis@lbl.gov.  &n; * Licensed under the GPL. Based on dummy.c, and eql.c devices.&n; *&n; * bonding.c: an Ethernet Bonding driver&n; *&n; * This is useful to talk to a Cisco EtherChannel compatible equipment:&n; *&t;Cisco 5500&n; *&t;Sun Trunking (Solaris)&n; *&t;Alteon AceDirector Trunks&n; *&t;Linux Bonding&n; *&t;and probably many L2 switches ...&n; *&n; * How it works:&n; *    ifconfig bond0 ipaddress netmask up&n; *      will setup a network device, with an ip address.  No mac address &n; *&t;will be assigned at this time.  The hw mac address will come from &n; *&t;the first slave bonded to the channel.  All slaves will then use &n; *&t;this hw mac address.&n; *&n; *    ifconfig bond0 down&n; *         will release all slaves, marking them as down.&n; *&n; *    ifenslave bond0 eth0&n; *&t;will attach eth0 to bond0 as a slave.  eth0 hw mac address will either&n; *&t;a: be used as initial mac address&n; *&t;b: if a hw mac address already is there, eth0&squot;s hw mac address &n; *&t;   will then be set from bond0.&n; *&n; * v0.1 - first working version.&n; * v0.2 - changed stats to be calculated by summing slaves stats.&n; *&n; * Changes:&n; * Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;&n; * - fix leaks on failure at bond_init&n; *&n; * 2000/09/30 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - added trivial code to release a slave device.&n; *     - fixed security bug (CAP_NET_ADMIN not checked)&n; *     - implemented MII link monitoring to disable dead links :&n; *       All MII capable slaves are checked every &lt;miimon&gt; milliseconds&n; *       (100 ms seems good). This value can be changed by passing it to&n; *       insmod. A value of zero disables the monitoring (default).&n; *     - fixed an infinite loop in bond_xmit_roundrobin() when there&squot;s no&n; *       good slave.&n; *     - made the code hopefully SMP safe&n; *&n; * 2000/10/03 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - optimized slave lists based on relevant suggestions from Thomas Davis&n; *     - implemented active-backup method to obtain HA with two switches:&n; *       stay as long as possible on the same active interface, while we&n; *       also monitor the backup one (MII link status) because we want to know&n; *       if we are able to switch at any time. ( pass &quot;mode=1&quot; to insmod )&n; *     - lots of stress testings because we need it to be more robust than the&n; *       wires ! :-&gt;&n; *&n; * 2000/10/09 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - added up and down delays after link state change.&n; *     - optimized the slaves chaining so that when we run forward, we never&n; *       repass through the bond itself, but we can find it by searching&n; *       backwards. Renders the deletion more difficult, but accelerates the&n; *       scan.&n; *     - smarter enslaving and releasing.&n; *     - finer and more robust SMP locking&n; *&n; * 2000/10/17 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - fixed two potential SMP race conditions&n; *&n; * 2000/10/18 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - small fixes to the monitoring FSM in case of zero delays&n; * 2000/11/01 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - fixed first slave not automatically used in trunk mode.&n; * 2000/11/10 : spelling of &quot;EtherChannel&quot; corrected.&n; * 2000/11/13 : fixed a race condition in case of concurrent accesses to ioctl().&n; * 2000/12/16 : fixed improper usage of rtnl_exlock_nowait().&n; *&n; * 2001/1/3 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - The bonding driver now simulates MII status monitoring, just like&n; *       a normal network device.  It will show that the link is down iff&n; *       every slave in the bond shows that their links are down.  If at least&n; *       one slave is up, the bond&squot;s MII status will appear as up.&n; *&n; * 2001/2/7 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Applications can now query the bond from user space to get&n; *       information which may be useful.  They do this by calling&n; *       the BOND_INFO_QUERY ioctl.  Once the app knows how many slaves&n; *       are in the bond, it can call the BOND_SLAVE_INFO_QUERY ioctl to&n; *       get slave specific information (# link failures, etc).  See&n; *       &lt;linux/if_bonding.h&gt; for more details.  The structs of interest&n; *       are ifbond and ifslave.&n; *&n; * 2001/4/5 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Ported to 2.4 Kernel&n; * &n; * 2001/5/2 - Jeffrey E. Mast &lt;jeff at mastfamily dot com&gt;&n; *     - When a device is detached from a bond, the slave device is no longer&n; *       left thinking that is has a master.&n; *&n; * 2001/5/16 - Jeffrey E. Mast &lt;jeff at mastfamily dot com&gt;&n; *     - memset did not appropriately initialized the bond rw_locks. Used &n; *       rwlock_init to initialize to unlocked state to prevent deadlock when &n; *       first attempting a lock&n; *     - Called SET_MODULE_OWNER for bond device&n; *&n; * 2001/5/17 - Tim Anderson &lt;tsa at mvista.com&gt;&n; *     - 2 paths for releasing for slave release; 1 through ioctl&n; *       and 2) through close. Both paths need to release the same way.&n; *     - the free slave in bond release is changing slave status before&n; *       the free. The netdev_set_master() is intended to change slave state&n; *       so it should not be done as part of the release process.&n; *     - Simple rule for slave state at release: only the active in A/B and&n; *       only one in the trunked case.&n; *&n; * 2001/6/01 - Tim Anderson &lt;tsa at mvista.com&gt;&n; *     - Now call dev_close when releasing a slave so it doesn&squot;t screw up&n; *       out routing table.&n; *&n; * 2001/6/01 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Added /proc support for getting bond and slave information.&n; *       Information is in /proc/net/&lt;bond device&gt;/info. &n; *     - Changed the locking when calling bond_close to prevent deadlock.&n; *&n; * 2001/8/05 - Janice Girouard &lt;girouard at us.ibm.com&gt;&n; *     - correct problem where refcnt of slave is not incremented in bond_ioctl&n; *       so the system hangs when halting.&n; *     - correct locking problem when unable to malloc in bond_enslave.&n; *     - adding bond_xmit_xor logic.&n; *     - adding multiple bond device support.&n; *&n; * 2001/8/13 - Erik Habbinga &lt;erik_habbinga at hp dot com&gt;&n; *     - correct locking problem with rtnl_exlock_nowait&n; *&n; * 2001/8/23 - Janice Girouard &lt;girouard at us.ibm.com&gt;&n; *     - bzero initial dev_bonds, to correct oops&n; *     - convert SIOCDEVPRIVATE to new MII ioctl calls&n; *&n; * 2001/9/13 - Takao Indoh &lt;indou dot takao at jp dot fujitsu dot com&gt;&n; *     - Add the BOND_CHANGE_ACTIVE ioctl implementation&n; *&n; * 2001/9/14 - Mark Huth &lt;mhuth at mvista dot com&gt;&n; *     - Change MII_LINK_READY to not check for end of auto-negotiation,&n; *       but only for an up link.&n; *&n; * 2001/9/20 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Add the device field to bonding_t.  Previously the net_device &n; *       corresponding to a bond wasn&squot;t available from the bonding_t &n; *       structure.&n; *&n; * 2001/9/25 - Janice Girouard &lt;girouard at us.ibm.com&gt;&n; *     - add arp_monitor for active backup mode&n; *&n; * 2001/10/23 - Takao Indoh &lt;indou dot takao at jp dot fujitsu dot com&gt;&n; *     - Various memory leak fixes&n; *&n; * 2001/11/5 - Mark Huth &lt;mark dot huth at mvista dot com&gt;&n; *     - Don&squot;t take rtnl lock in bond_mii_monitor as it deadlocks under &n; *       certain hotswap conditions.  &n; *       Note:  this same change may be required in bond_arp_monitor ???&n; *     - Remove possibility of calling bond_sethwaddr with NULL slave_dev ptr &n; *     - Handle hot swap ethernet interface deregistration events to remove&n; *       kernel oops following hot swap of enslaved interface&n; *&n; * 2002/1/2 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Restore original slave flags at release time.&n; *&n; * 2002/02/18 - Erik Habbinga &lt;erik_habbinga at hp dot com&gt;&n; *     - bond_release(): calling kfree on our_slave after call to&n; *       bond_restore_slave_flags, not before&n; *     - bond_enslave(): saving slave flags into original_flags before&n; *       call to netdev_set_master, so the IFF_SLAVE flag doesn&squot;t end&n; *       up in original_flags&n; *&n; * 2002/04/05 - Mark Smith &lt;mark.smith at comdev dot cc&gt; and&n; *              Steve Mead &lt;steve.mead at comdev dot cc&gt;&n; *     - Port Gleb Natapov&squot;s multicast support patchs from 2.4.12&n; *       to 2.4.18 adding support for multicast.&n; *&n; * 2002/06/10 - Tony Cureington &lt;tony.cureington * hp_com&gt;&n; *     - corrected uninitialized pointer (ifr.ifr_data) in bond_check_dev_link;&n; *       actually changed function to use MIIPHY, then MIIREG, and finally&n; *       ETHTOOL to determine the link status&n; *     - fixed bad ifr_data pointer assignments in bond_ioctl&n; *     - corrected mode 1 being reported as active-backup in bond_get_info;&n; *       also added text to distinguish type of load balancing (rr or xor)&n; *     - change arp_ip_target module param from &quot;1-12s&quot; (array of 12 ptrs)&n; *       to &quot;s&quot; (a single ptr)&n; *&n; * 2002/08/30 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *     - Removed acquisition of xmit_lock in set_multicast_list; caused&n; *       deadlock on SMP (lock is held by caller).&n; *     - Revamped SIOCGMIIPHY, SIOCGMIIREG portion of bond_check_dev_link().&n; *&n; * 2002/09/18 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *     - Fixed up bond_check_dev_link() (and callers): removed some magic&n; *&t; numbers, banished local MII_ defines, wrapped ioctl calls to&n; *&t; prevent EFAULT errors&n; *&n; * 2002/9/30 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *     - make sure the ip target matches the arp_target before saving the&n; *&t; hw address.&n; *&n; * 2002/9/30 - Dan Eisner &lt;eisner at 2robots dot com&gt;&n; *     - make sure my_ip is set before taking down the link, since&n; *&t; not all switches respond if the source ip is not set.&n; *&n; * 2002/10/8 - Janice Girouard &lt;girouard at us dot ibm dot com&gt;&n; *     - read in the local ip address when enslaving a device&n; *     - add primary support&n; *     - make sure 2*arp_interval has passed when a new device&n; *       is brought on-line before taking it down.&n; *&n; * 2002/09/11 - Philippe De Muyter &lt;phdm at macqel dot be&gt;&n; *     - Added bond_xmit_broadcast logic.&n; *     - Added bond_mode() support function.&n; *&n; * 2002/10/26 - Laurent Deniel &lt;laurent.deniel at free.fr&gt;&n; *     - allow to register multicast addresses only on active slave&n; *       (useful in active-backup mode)&n; *     - add multicast module parameter&n; *     - fix deletion of multicast groups after unloading module&n; *&n; * 2002/11/06 - Kameshwara Rayaprolu &lt;kameshwara.rao * wipro_com&gt;&n; *     - Changes to prevent panic from closing the device twice; if we close &n; *       the device in bond_release, we must set the original_flags to down &n; *       so it won&squot;t be closed again by the network layer.&n; *&n; * 2002/11/07 - Tony Cureington &lt;tony.cureington * hp_com&gt;&n; *     - Fix arp_target_hw_addr memory leak&n; *     - Created activebackup_arp_monitor function to handle arp monitoring &n; *       in active backup mode - the bond_arp_monitor had several problems... &n; *       such as allowing slaves to tx arps sequentially without any delay &n; *       for a response&n; *     - Renamed bond_arp_monitor to loadbalance_arp_monitor and re-wrote&n; *       this function to just handle arp monitoring in load-balancing mode;&n; *       it is a lot more compact now&n; *     - Changes to ensure one and only one slave transmits in active-backup &n; *       mode&n; *     - Robustesize parameters; warn users about bad combinations of &n; *       parameters; also if miimon is specified and a network driver does &n; *       not support MII or ETHTOOL, inform the user of this&n; *     - Changes to support link_failure_count when in arp monitoring mode&n; *     - Fix up/down delay reported in /proc&n; *     - Added version; log version; make version available from &quot;modinfo -d&quot;&n; *     - Fixed problem in bond_check_dev_link - if the first IOCTL (SIOCGMIIPH)&n; *&t; failed, the ETHTOOL ioctl never got a chance&n; *&n; * 2002/11/16 - Laurent Deniel &lt;laurent.deniel at free.fr&gt;&n; *     - fix multicast handling in activebackup_arp_monitor&n; *     - remove one unnecessary and confusing current_slave == slave test &n; *&t; in activebackup_arp_monitor&n; *&n; *  2002/11/17 - Laurent Deniel &lt;laurent.deniel at free.fr&gt;&n; *     - fix bond_slave_info_query when slave_id = num_slaves&n; *&n; *  2002/11/19 - Janice Girouard &lt;girouard at us dot ibm dot com&gt;&n; *     - correct ifr_data reference.  Update ifr_data reference&n; *       to mii_ioctl_data struct values to avoid confusion.&n; *&n; *  2002/11/22 - Bert Barbe &lt;bert.barbe at oracle dot com&gt;&n; *      - Add support for multiple arp_ip_target&n; *&n; *  2002/12/13 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *&t;- Changed to allow text strings for mode and multicast, e.g.,&n; *&t;  insmod bonding mode=active-backup.  The numbers still work.&n; *&t;  One change: an invalid choice will cause module load failure,&n; *&t;  rather than the previous behavior of just picking one.&n; *&t;- Minor cleanups; got rid of dup ctype stuff, atoi function&n; * &n; * 2003/02/07 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *&t;- Added use_carrier module parameter that causes miimon to&n; *&t;  use netif_carrier_ok() test instead of MII/ETHTOOL ioctls.&n; *&t;- Minor cleanups; consolidated ioctl calls to one function.&n; *&n; * 2003/02/07 - Tony Cureington &lt;tony.cureington * hp_com&gt;&n; *&t;- Fix bond_mii_monitor() logic error that could result in&n; *&t;  bonding round-robin mode ignoring links after failover/recovery&n; *&n; * 2003/03/17 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *&t;- kmalloc fix (GFP_KERNEL to GFP_ATOMIC) reported by&n; *&t;  Shmulik dot Hen at intel.com.&n; *&t;- Based on discussion on mailing list, changed use of&n; *&t;  update_slave_cnt(), created wrapper functions for adding/removing&n; *&t;  slaves, changed bond_xmit_xor() to check slave_cnt instead of&n; *&t;  checking slave and slave-&gt;dev (which only worked by accident).&n; *&t;- Misc code cleanup: get arp_send() prototype from header file,&n; *&t;  add max_bonds to bonding.txt.&n; *&n; * 2003/03/18 - Tsippy Mendelson &lt;tsippy.mendelson at intel dot com&gt; and&n; *&t;&t;Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Make sure only bond_attach_slave() and bond_detach_slave() can&n; *&t;  manipulate the slave list, including slave_cnt, even when in&n; *&t;  bond_release_all().&n; *&t;- Fixed hang in bond_release() with traffic running:&n; *&t;  netdev_set_master() must not be called from within the bond lock.&n; *&n; * 2003/03/18 - Tsippy Mendelson &lt;tsippy.mendelson at intel dot com&gt; and&n; *&t;&t;Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Fixed hang in bond_enslave() with traffic running:&n; *&t;  netdev_set_master() must not be called from within the bond lock.&n; *&n; * 2003/03/18 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; *&t;- Added support for getting slave&squot;s speed and duplex via ethtool.&n; *&t;  Needed for 802.3ad and other future modes.&n; *&n; * 2003/03/18 - Tsippy Mendelson &lt;tsippy.mendelson at intel dot com&gt; and&n; *&t;&t;Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Enable support of modes that need to use the unique mac address of&n; *&t;  each slave.&n; *&t;  * bond_enslave(): Moved setting the slave&squot;s mac address, and&n; *&t;    openning it, from the application to the driver. This breaks&n; *&t;    backward comaptibility with old versions of ifenslave that open&n; *&t;     the slave before enalsving it !!!.&n; *&t;  * bond_release(): The driver also takes care of closing the slave&n; *&t;    and restoring its original mac address.&n; *&t;- Removed the code that restores all base driver&squot;s flags.&n; *&t;  Flags are automatically restored once all undo stages are done&n; *&t;  properly.&n; *&t;- Block possibility of enslaving before the master is up. This&n; *&t;  prevents putting the system in an unstable state.&n; *&n; * 2003/03/18 - Amir Noam &lt;amir.noam at intel dot com&gt;,&n; *&t;&t;Tsippy Mendelson &lt;tsippy.mendelson at intel dot com&gt; and&n; *&t;&t;Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Added support for IEEE 802.3ad Dynamic link aggregation mode.&n; *&n; * 2003/05/01 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; *&t;- Added ABI version control to restore compatibility between&n; *&t;  new/old ifenslave and new/old bonding.&n; *&n; * 2003/05/01 - Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Fixed bug in bond_release_all(): save old value of current_slave&n; *&t;  before setting it to NULL.&n; *&t;- Changed driver versioning scheme to include version number instead&n; *&t;  of release date (that is already in another field). There are 3&n; *&t;  fields X.Y.Z where:&n; *&t;&t;X - Major version - big behavior changes&n; *&t;&t;Y - Minor version - addition of features&n; *&t;&t;Z - Extra version - minor changes and bug fixes&n; *&t;  The current version is 1.0.0 as a base line.&n; *&n; * 2003/05/01 - Tsippy Mendelson &lt;tsippy.mendelson at intel dot com&gt; and&n; *&t;&t;Amir Noam &lt;amir.noam at intel dot com&gt;&n; *&t;- Added support for lacp_rate module param.&n; *&t;- Code beautification and style changes (mainly in comments).&n; *&t;  new version - 1.0.1&n; *&n; * 2003/05/01 - Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Based on discussion on mailing list, changed locking scheme&n; *&t;  to use lock/unlock or lock_bh/unlock_bh appropriately instead&n; *&t;  of lock_irqsave/unlock_irqrestore. The new scheme helps exposing&n; *&t;  hidden bugs and solves system hangs that occurred due to the fact&n; *&t;  that holding lock_irqsave doesn&squot;t prevent softirqs from running.&n; *&t;  This also increases total throughput since interrupts are not&n; *&t;  blocked on each transmitted packets or monitor timeout.&n; *&t;  new version - 2.0.0&n; *&n; * 2003/05/01 - Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Added support for Transmit load balancing mode.&n; *&t;- Concentrate all assignments of current_slave to a single point&n; *&t;  so specific modes can take actions when the primary adapter is&n; *&t;  changed.&n; *&t;- Take the updelay parameter into consideration during bond_enslave&n; *&t;  since some adapters loose their link during setting the device.&n; *&t;- Renamed bond_3ad_link_status_changed() to&n; *&t;  bond_3ad_handle_link_change() for compatibility with TLB.&n; *&t;  new version - 2.1.0&n; *&n; * 2003/05/01 - Tsippy Mendelson &lt;tsippy.mendelson at intel dot com&gt;&n; *&t;- Added support for Adaptive load balancing mode which is&n; *&t;  equivalent to Transmit load balancing + Receive load balancing.&n; *&t;  new version - 2.2.0&n; *&n; * 2003/05/15 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *&t;- Applied fix to activebackup_arp_monitor posted to bonding-devel&n; *&t;  by Tony Cureington &lt;tony.cureington * hp_com&gt;.  Fixes ARP&n; *&t;  monitor endless failover bug.  Version to 2.2.10&n; *&n; * 2003/05/20 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; *&t;- Fixed bug in ABI version control - Don&squot;t commit to a specific&n; *&t;  ABI version if receiving unsupported ioctl commands.&n; *&n; * 2003/05/22 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *&t;- Fix ifenslave -c causing bond to loose existing routes;&n; *&t;  added bond_set_mac_address() that doesn&squot;t require the&n; *&t;  bond to be down.&n; *&t;- In conjunction with fix for ifenslave -c, in&n; *&t;  bond_change_active(), changing to the already active slave&n; *&t;  is no longer an error (it successfully does nothing).&n; *&n; * 2003/06/30 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; * &t;- Fixed bond_change_active() for ALB/TLB modes.&n; *&t;  Version to 2.2.14.&n; *&n; * 2003/07/29 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; * &t;- Fixed ARP monitoring bug.&n; *&t;  Version to 2.2.15.&n; *&n; * 2003/07/31 - Willy Tarreau &lt;willy at ods dot org&gt;&n; * &t;- Fixed kernel panic when using ARP monitoring without&n; *&t;  setting bond&squot;s IP address.&n; *&t;  Version to 2.2.16.&n; *&n; * 2003/08/06 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; * &t;- Back port from 2.6: use alloc_netdev(); fix /proc handling;&n; *&t;  made stats a part of bond struct so no need to allocate&n; *&t;  and free it separately; use standard list operations instead&n; *&t;  of pre-allocated array of bonds.&n; *&t;  Version to 2.3.0.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/inetdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/if_bonding.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;linux/mii.h&gt;
macro_line|#include &lt;linux/ethtool.h&gt;
macro_line|#include &quot;bonding.h&quot;
macro_line|#include &quot;bond_3ad.h&quot;
macro_line|#include &quot;bond_alb.h&quot;
DECL|macro|DRV_VERSION
mdefine_line|#define DRV_VERSION&t;&quot;2.3.0&quot;
DECL|macro|DRV_RELDATE
mdefine_line|#define DRV_RELDATE&t;&quot;August 6, 2003&quot;
DECL|macro|DRV_NAME
mdefine_line|#define DRV_NAME&t;&quot;bonding&quot;
DECL|macro|DRV_DESCRIPTION
mdefine_line|#define DRV_DESCRIPTION&t;&quot;Ethernet Channel Bonding Driver&quot;
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
id|DRV_NAME
l_string|&quot;.c:v&quot;
id|DRV_VERSION
l_string|&quot; (&quot;
id|DRV_RELDATE
l_string|&quot;)&bslash;n&quot;
suffix:semicolon
multiline_comment|/* monitor all links that often (in milliseconds). &lt;=0 disables monitoring */
macro_line|#ifndef BOND_LINK_MON_INTERV
DECL|macro|BOND_LINK_MON_INTERV
mdefine_line|#define BOND_LINK_MON_INTERV&t;0
macro_line|#endif
macro_line|#ifndef BOND_LINK_ARP_INTERV
DECL|macro|BOND_LINK_ARP_INTERV
mdefine_line|#define BOND_LINK_ARP_INTERV&t;0
macro_line|#endif
macro_line|#ifndef MAX_ARP_IP_TARGETS
DECL|macro|MAX_ARP_IP_TARGETS
mdefine_line|#define MAX_ARP_IP_TARGETS 16
macro_line|#endif
DECL|macro|USES_PRIMARY
mdefine_line|#define USES_PRIMARY(mode) &bslash;&n;&t;&t;(((mode) == BOND_MODE_ACTIVEBACKUP) || &bslash;&n;&t;&t; ((mode) == BOND_MODE_TLB) || &bslash;&n;&t;&t; ((mode) == BOND_MODE_ALB))
DECL|struct|bond_parm_tbl
r_struct
id|bond_parm_tbl
(brace
DECL|member|modename
r_char
op_star
id|modename
suffix:semicolon
DECL|member|mode
r_int
id|mode
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|arp_interval
r_static
r_int
id|arp_interval
op_assign
id|BOND_LINK_ARP_INTERV
suffix:semicolon
DECL|variable|arp_ip_target
r_static
r_char
op_star
id|arp_ip_target
(braket
id|MAX_ARP_IP_TARGETS
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|arp_target
r_static
id|u32
id|arp_target
(braket
id|MAX_ARP_IP_TARGETS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|arp_ip_count
r_static
r_int
id|arp_ip_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|my_ip
r_static
id|u32
id|my_ip
op_assign
l_int|0
suffix:semicolon
DECL|variable|arp_target_hw_addr
r_char
op_star
id|arp_target_hw_addr
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|primary
r_static
r_char
op_star
id|primary
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|app_abi_ver
r_static
r_int
id|app_abi_ver
op_assign
l_int|0
suffix:semicolon
DECL|variable|orig_app_abi_ver
r_static
r_int
id|orig_app_abi_ver
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* This is used to save the first ABI version&n;&t;&t;&t;&t;   * we receive from the application. Once set,&n;&t;&t;&t;&t;   * it won&squot;t be changed, and the module will&n;&t;&t;&t;&t;   * refuse to enslave/release interfaces if the&n;&t;&t;&t;&t;   * command comes from an application using&n;&t;&t;&t;&t;   * another ABI version.&n;&t;&t;&t;&t;   */
DECL|variable|max_bonds
r_static
r_int
id|max_bonds
op_assign
id|BOND_DEFAULT_MAX_BONDS
suffix:semicolon
DECL|variable|miimon
r_static
r_int
id|miimon
op_assign
id|BOND_LINK_MON_INTERV
suffix:semicolon
DECL|variable|use_carrier
r_static
r_int
id|use_carrier
op_assign
l_int|1
suffix:semicolon
DECL|variable|bond_mode
r_static
r_int
id|bond_mode
op_assign
id|BOND_MODE_ROUNDROBIN
suffix:semicolon
DECL|variable|updelay
r_static
r_int
id|updelay
op_assign
l_int|0
suffix:semicolon
DECL|variable|downdelay
r_static
r_int
id|downdelay
op_assign
l_int|0
suffix:semicolon
DECL|variable|mode
r_static
r_char
op_star
id|mode
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|bond_mode_tbl
r_static
r_struct
id|bond_parm_tbl
id|bond_mode_tbl
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;balance-rr&quot;
comma
id|BOND_MODE_ROUNDROBIN
)brace
comma
(brace
l_string|&quot;active-backup&quot;
comma
id|BOND_MODE_ACTIVEBACKUP
)brace
comma
(brace
l_string|&quot;balance-xor&quot;
comma
id|BOND_MODE_XOR
)brace
comma
(brace
l_string|&quot;broadcast&quot;
comma
id|BOND_MODE_BROADCAST
)brace
comma
(brace
l_string|&quot;802.3ad&quot;
comma
id|BOND_MODE_8023AD
)brace
comma
(brace
l_string|&quot;balance-tlb&quot;
comma
id|BOND_MODE_TLB
)brace
comma
(brace
l_string|&quot;balance-alb&quot;
comma
id|BOND_MODE_ALB
)brace
comma
(brace
l_int|NULL
comma
op_minus
l_int|1
)brace
comma
)brace
suffix:semicolon
DECL|variable|multicast_mode
r_static
r_int
id|multicast_mode
op_assign
id|BOND_MULTICAST_ALL
suffix:semicolon
DECL|variable|multicast
r_static
r_char
op_star
id|multicast
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|bond_mc_tbl
r_static
r_struct
id|bond_parm_tbl
id|bond_mc_tbl
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;disabled&quot;
comma
id|BOND_MULTICAST_DISABLED
)brace
comma
(brace
l_string|&quot;active&quot;
comma
id|BOND_MULTICAST_ACTIVE
)brace
comma
(brace
l_string|&quot;all&quot;
comma
id|BOND_MULTICAST_ALL
)brace
comma
(brace
l_int|NULL
comma
op_minus
l_int|1
)brace
comma
)brace
suffix:semicolon
DECL|variable|lacp_fast
r_static
r_int
id|lacp_fast
op_assign
l_int|0
suffix:semicolon
DECL|variable|lacp_rate
r_static
r_char
op_star
id|lacp_rate
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|bond_lacp_tbl
r_static
r_struct
id|bond_parm_tbl
id|bond_lacp_tbl
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;slow&quot;
comma
id|AD_LACP_SLOW
)brace
comma
(brace
l_string|&quot;fast&quot;
comma
id|AD_LACP_FAST
)brace
comma
(brace
l_int|NULL
comma
op_minus
l_int|1
)brace
comma
)brace
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|bond_dev_list
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_bonds
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_bonds
comma
l_string|&quot;Max number of bonded devices&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|miimon
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|miimon
comma
l_string|&quot;Link check interval in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|use_carrier
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|use_carrier
comma
l_string|&quot;Use netif_carrier_ok (vs MII ioctls) in miimon; 0 for off, 1 for on (default)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|mode
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|mode
comma
l_string|&quot;Mode of operation : 0 for round robin, 1 for active-backup, 2 for xor&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|arp_interval
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|arp_interval
comma
l_string|&quot;arp interval in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|arp_ip_target
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_ARP_IP_TARGETS
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|arp_ip_target
comma
l_string|&quot;arp targets in n.n.n.n form&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|updelay
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|updelay
comma
l_string|&quot;Delay before considering link up, in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|downdelay
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|downdelay
comma
l_string|&quot;Delay before considering link down, in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|primary
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|primary
comma
l_string|&quot;Primary network device to use&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|multicast
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|multicast
comma
l_string|&quot;Mode for multicast support : 0 for none, 1 for active slave, 2 for all slaves (default)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|lacp_rate
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|lacp_rate
comma
l_string|&quot;LACPDU tx rate to request from 802.3ad partner (slow/fast)&quot;
)paren
suffix:semicolon
r_static
r_int
id|bond_xmit_roundrobin
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|bond_xmit_xor
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|bond_xmit_activebackup
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|bond_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|bond_mii_monitor
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|loadbalance_arp_monitor
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|activebackup_arp_monitor
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|bond_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|bond_mc_list_destroy
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
suffix:semicolon
r_static
r_void
id|bond_mc_add
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_void
op_star
id|addr
comma
r_int
id|alen
)paren
suffix:semicolon
r_static
r_void
id|bond_mc_delete
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_void
op_star
id|addr
comma
r_int
id|alen
)paren
suffix:semicolon
r_static
r_int
id|bond_mc_list_copy
(paren
r_struct
id|dev_mc_list
op_star
id|src
comma
r_struct
id|bonding
op_star
id|dst
comma
r_int
id|gpf_flag
)paren
suffix:semicolon
r_static
r_inline
r_int
id|dmi_same
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|dmi1
comma
r_struct
id|dev_mc_list
op_star
id|dmi2
)paren
suffix:semicolon
r_static
r_void
id|bond_set_promiscuity
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_int
id|inc
)paren
suffix:semicolon
r_static
r_void
id|bond_set_allmulti
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_int
id|inc
)paren
suffix:semicolon
r_static
r_struct
id|dev_mc_list
op_star
id|bond_mc_list_find_dmi
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|dmi
comma
r_struct
id|dev_mc_list
op_star
id|mc_list
)paren
suffix:semicolon
r_static
r_void
id|bond_mc_update
c_func
(paren
id|bonding_t
op_star
id|bond
comma
id|slave_t
op_star
r_new
comma
id|slave_t
op_star
id|old
)paren
suffix:semicolon
r_static
r_int
id|bond_enslave
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|net_device
op_star
id|slave
)paren
suffix:semicolon
r_static
r_int
id|bond_release
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|net_device
op_star
id|slave
)paren
suffix:semicolon
r_static
r_int
id|bond_release_all
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
suffix:semicolon
r_static
r_int
id|bond_sethwaddr
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|net_device
op_star
id|slave
)paren
suffix:semicolon
r_static
r_void
id|change_active_interface
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
r_new
)paren
suffix:semicolon
r_static
r_void
id|reselect_active_interface
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
suffix:semicolon
r_static
r_struct
id|slave
op_star
id|find_best_interface
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
suffix:semicolon
multiline_comment|/* #define BONDING_DEBUG 1 */
multiline_comment|/* several macros */
DECL|function|arp_send_all
r_static
r_void
id|arp_send_all
c_func
(paren
id|slave_t
op_star
id|slave
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|MAX_ARP_IP_TARGETS
)paren
op_logical_and
id|arp_target
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|arp_target
(braket
id|i
)braket
comma
id|slave-&gt;dev
comma
id|my_ip
comma
id|arp_target_hw_addr
comma
id|slave-&gt;dev-&gt;dev_addr
comma
id|arp_target_hw_addr
)paren
suffix:semicolon
)brace
)brace
r_static
r_const
r_char
op_star
DECL|function|bond_mode_name
id|bond_mode_name
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|bond_mode
)paren
(brace
r_case
id|BOND_MODE_ROUNDROBIN
suffix:colon
r_return
l_string|&quot;load balancing (round-robin)&quot;
suffix:semicolon
r_case
id|BOND_MODE_ACTIVEBACKUP
suffix:colon
r_return
l_string|&quot;fault-tolerance (active-backup)&quot;
suffix:semicolon
r_case
id|BOND_MODE_XOR
suffix:colon
r_return
l_string|&quot;load balancing (xor)&quot;
suffix:semicolon
r_case
id|BOND_MODE_BROADCAST
suffix:colon
r_return
l_string|&quot;fault-tolerance (broadcast)&quot;
suffix:semicolon
r_case
id|BOND_MODE_8023AD
suffix:colon
r_return
l_string|&quot;IEEE 802.3ad Dynamic link aggregation&quot;
suffix:semicolon
r_case
id|BOND_MODE_TLB
suffix:colon
r_return
l_string|&quot;transmit load balancing&quot;
suffix:semicolon
r_case
id|BOND_MODE_ALB
suffix:colon
r_return
l_string|&quot;adaptive load balancing&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
)brace
r_static
r_const
r_char
op_star
DECL|function|multicast_mode_name
id|multicast_mode_name
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|multicast_mode
)paren
(brace
r_case
id|BOND_MULTICAST_DISABLED
suffix:colon
r_return
l_string|&quot;disabled&quot;
suffix:semicolon
r_case
id|BOND_MULTICAST_ACTIVE
suffix:colon
r_return
l_string|&quot;active slave only&quot;
suffix:semicolon
r_case
id|BOND_MULTICAST_ALL
suffix:colon
r_return
l_string|&quot;all slaves&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
)brace
DECL|function|bond_set_slave_inactive_flags
r_void
id|bond_set_slave_inactive_flags
c_func
(paren
id|slave_t
op_star
id|slave
)paren
(brace
id|slave-&gt;state
op_assign
id|BOND_STATE_BACKUP
suffix:semicolon
id|slave-&gt;dev-&gt;flags
op_or_assign
id|IFF_NOARP
suffix:semicolon
)brace
DECL|function|bond_set_slave_active_flags
r_void
id|bond_set_slave_active_flags
c_func
(paren
id|slave_t
op_star
id|slave
)paren
(brace
id|slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
id|slave-&gt;dev-&gt;flags
op_and_assign
op_complement
id|IFF_NOARP
suffix:semicolon
)brace
multiline_comment|/*&n; * This function counts and verifies the the number of attached&n; * slaves, checking the count against the expected value (given that incr&n; * is either 1 or -1, for add or removal of a slave).  Only&n; * bond_xmit_xor() uses the slave_cnt value, but this is still a good&n; * consistency check.&n; */
r_static
r_inline
r_void
DECL|function|update_slave_cnt
id|update_slave_cnt
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_int
id|incr
)paren
(brace
id|slave_t
op_star
id|slave
op_assign
l_int|NULL
suffix:semicolon
r_int
id|expect
op_assign
id|bond-&gt;slave_cnt
op_plus
id|incr
suffix:semicolon
id|bond-&gt;slave_cnt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
(brace
id|bond-&gt;slave_cnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|expect
op_ne
id|bond-&gt;slave_cnt
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * This function detaches the slave &lt;slave&gt; from the list &lt;bond&gt;.&n; * WARNING: no check is made to verify if the slave effectively&n; * belongs to &lt;bond&gt;. It returns &lt;slave&gt; in case it&squot;s needed.&n; * Nothing is freed on return, structures are just unchained.&n; * If the bond-&gt;current_slave pointer was pointing to &lt;slave&gt;,&n; * it should be changed by the calling function.&n; *&n; * bond-&gt;lock held for writing by caller.&n; */
r_static
id|slave_t
op_star
DECL|function|bond_detach_slave
id|bond_detach_slave
c_func
(paren
id|bonding_t
op_star
id|bond
comma
id|slave_t
op_star
id|slave
)paren
(brace
r_if
c_cond
(paren
(paren
id|bond
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|slave
op_eq
l_int|NULL
)paren
op_logical_or
(paren
(paren
r_void
op_star
)paren
id|bond
op_eq
(paren
r_void
op_star
)paren
id|slave
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bond_detach_slave(): trying to detach &quot;
l_string|&quot;slave %p from bond %p&bslash;n&quot;
comma
id|bond
comma
id|slave
)paren
suffix:semicolon
r_return
id|slave
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;next
op_eq
id|slave
)paren
(brace
multiline_comment|/* is the slave at the head ? */
r_if
c_cond
(paren
id|bond-&gt;prev
op_eq
id|slave
)paren
(brace
multiline_comment|/* is the slave alone ? */
id|bond-&gt;prev
op_assign
id|bond-&gt;next
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* not alone */
id|bond-&gt;next
op_assign
id|slave-&gt;next
suffix:semicolon
id|slave-&gt;next-&gt;prev
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|bond-&gt;prev-&gt;next
op_assign
id|slave-&gt;next
suffix:semicolon
)brace
)brace
r_else
(brace
id|slave-&gt;prev-&gt;next
op_assign
id|slave-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;prev
op_eq
id|slave
)paren
(brace
multiline_comment|/* is this slave the last one ? */
id|bond-&gt;prev
op_assign
id|slave-&gt;prev
suffix:semicolon
)brace
r_else
(brace
id|slave-&gt;next-&gt;prev
op_assign
id|slave-&gt;prev
suffix:semicolon
)brace
)brace
id|update_slave_cnt
c_func
(paren
id|bond
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|slave
suffix:semicolon
)brace
multiline_comment|/*&n; * This function attaches the slave &lt;slave&gt; to the list &lt;bond&gt;.&n; *&n; * bond-&gt;lock held for writing by caller.&n; */
r_static
r_void
DECL|function|bond_attach_slave
id|bond_attach_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|new_slave
)paren
(brace
multiline_comment|/* &n;&t; * queue to the end of the slaves list, make the first element its&n;&t; * successor, the last one its predecessor, and make it the bond&squot;s&n;&t; * predecessor. &n;&t; *&n;&t; * Just to clarify, so future bonding driver hackers don&squot;t go through&n;&t; * the same confusion stage I did trying to figure this out, the&n;&t; * slaves are stored in a double linked circular list, sortof.&n;&t; * In the -&gt;next direction, the last slave points to the first slave,&n;&t; * bypassing bond; only the slaves are in the -&gt;next direction.&n;&t; * In the -&gt;prev direction, however, the first slave points to bond&n;&t; * and bond points to the last slave.&n;&t; *&n;&t; * It looks like a circle with a little bubble hanging off one side&n;&t; * in the -&gt;prev direction only.&n;&t; *&n;&t; * When going through the list once, its best to start at bond-&gt;prev&n;&t; * and go in the -&gt;prev direction, testing for bond.  Doing this&n;&t; * in the -&gt;next direction doesn&squot;t work.  Trust me, I know this now.&n;&t; * :)  -mts 2002.03.14&n;&t; */
id|new_slave-&gt;prev
op_assign
id|bond-&gt;prev
suffix:semicolon
id|new_slave-&gt;prev-&gt;next
op_assign
id|new_slave
suffix:semicolon
id|bond-&gt;prev
op_assign
id|new_slave
suffix:semicolon
id|new_slave-&gt;next
op_assign
id|bond-&gt;next
suffix:semicolon
id|update_slave_cnt
c_func
(paren
id|bond
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Less bad way to call ioctl from within the kernel; this needs to be&n; * done some other way to get the call out of interrupt context.&n; * Needs &quot;ioctl&quot; variable to be supplied by calling context.&n; */
DECL|macro|IOCTL
mdefine_line|#define IOCTL(dev, arg, cmd) ({&t;&t;&bslash;&n;&t;int ret;&t;&t;&t;&bslash;&n;&t;mm_segment_t fs = get_fs();&t;&bslash;&n;&t;set_fs(get_ds());&t;&t;&bslash;&n;&t;ret = ioctl(dev, arg, cmd);&t;&bslash;&n;&t;set_fs(fs);&t;&t;&t;&bslash;&n;&t;ret; })
multiline_comment|/*&n; * Get link speed and duplex from the slave&squot;s base driver&n; * using ethtool. If for some reason the call fails or the&n; * values are invalid, fake speed and duplex to 100/Full&n; * and return error.&n; */
DECL|function|bond_update_speed_duplex
r_static
r_int
id|bond_update_speed_duplex
c_func
(paren
r_struct
id|slave
op_star
id|slave
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|slave-&gt;dev
suffix:semicolon
r_static
r_int
(paren
op_star
id|ioctl
)paren
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
comma
r_int
)paren
suffix:semicolon
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|ethtool_cmd
id|etool
suffix:semicolon
id|ioctl
op_assign
id|dev-&gt;do_ioctl
suffix:semicolon
r_if
c_cond
(paren
id|ioctl
)paren
(brace
id|etool.cmd
op_assign
id|ETHTOOL_GSET
suffix:semicolon
id|ifr.ifr_data
op_assign
(paren
r_char
op_star
)paren
op_amp
id|etool
suffix:semicolon
r_if
c_cond
(paren
id|IOCTL
c_func
(paren
id|dev
comma
op_amp
id|ifr
comma
id|SIOCETHTOOL
)paren
op_eq
l_int|0
)paren
(brace
id|slave-&gt;speed
op_assign
id|etool.speed
suffix:semicolon
id|slave-&gt;duplex
op_assign
id|etool.duplex
suffix:semicolon
)brace
r_else
(brace
r_goto
id|err_out
suffix:semicolon
)brace
)brace
r_else
(brace
r_goto
id|err_out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|slave-&gt;speed
)paren
(brace
r_case
id|SPEED_10
suffix:colon
r_case
id|SPEED_100
suffix:colon
r_case
id|SPEED_1000
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|err_out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|slave-&gt;duplex
)paren
(brace
r_case
id|DUPLEX_FULL
suffix:colon
r_case
id|DUPLEX_HALF
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|err_out
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
multiline_comment|/* Fake speed and duplex */
id|slave-&gt;speed
op_assign
id|SPEED_100
suffix:semicolon
id|slave-&gt;duplex
op_assign
id|DUPLEX_FULL
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * if &lt;dev&gt; supports MII link status reporting, check its link status.&n; *&n; * We either do MII/ETHTOOL ioctls, or check netif_carrier_ok(),&n; * depening upon the setting of the use_carrier parameter.&n; *&n; * Return either BMSR_LSTATUS, meaning that the link is up (or we&n; * can&squot;t tell and just pretend it is), or 0, meaning that the link is&n; * down.&n; *&n; * If reporting is non-zero, instead of faking link up, return -1 if&n; * both ETHTOOL and MII ioctls fail (meaning the device does not&n; * support them).  If use_carrier is set, return whatever it says.&n; * It&squot;d be nice if there was a good way to tell if a driver supports&n; * netif_carrier, but there really isn&squot;t.&n; */
r_static
r_int
DECL|function|bond_check_dev_link
id|bond_check_dev_link
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|reporting
)paren
(brace
r_static
r_int
(paren
op_star
id|ioctl
)paren
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
comma
r_int
)paren
suffix:semicolon
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|mii_ioctl_data
op_star
id|mii
suffix:semicolon
r_struct
id|ethtool_value
id|etool
suffix:semicolon
r_if
c_cond
(paren
id|use_carrier
)paren
(brace
r_return
id|netif_carrier_ok
c_func
(paren
id|dev
)paren
ques
c_cond
id|BMSR_LSTATUS
suffix:colon
l_int|0
suffix:semicolon
)brace
id|ioctl
op_assign
id|dev-&gt;do_ioctl
suffix:semicolon
r_if
c_cond
(paren
id|ioctl
)paren
(brace
multiline_comment|/* TODO: set pointer to correct ioctl on a per team member */
multiline_comment|/*       bases to make this more efficient. that is, once  */
multiline_comment|/*       we determine the correct ioctl, we will always    */
multiline_comment|/*       call it and not the others for that team          */
multiline_comment|/*       member.                                           */
multiline_comment|/*&n;&t;&t; * We cannot assume that SIOCGMIIPHY will also read a&n;&t;&t; * register; not all network drivers (e.g., e100)&n;&t;&t; * support that.&n;&t;&t; */
multiline_comment|/* Yes, the mii is overlaid on the ifreq.ifr_ifru */
id|mii
op_assign
(paren
r_struct
id|mii_ioctl_data
op_star
)paren
op_amp
id|ifr.ifr_data
suffix:semicolon
r_if
c_cond
(paren
id|IOCTL
c_func
(paren
id|dev
comma
op_amp
id|ifr
comma
id|SIOCGMIIPHY
)paren
op_eq
l_int|0
)paren
(brace
id|mii-&gt;reg_num
op_assign
id|MII_BMSR
suffix:semicolon
r_if
c_cond
(paren
id|IOCTL
c_func
(paren
id|dev
comma
op_amp
id|ifr
comma
id|SIOCGMIIREG
)paren
op_eq
l_int|0
)paren
(brace
r_return
id|mii-&gt;val_out
op_amp
id|BMSR_LSTATUS
suffix:semicolon
)brace
)brace
multiline_comment|/* try SIOCETHTOOL ioctl, some drivers cache ETHTOOL_GLINK */
multiline_comment|/* for a period of time so we attempt to get link status   */
multiline_comment|/* from it last if the above MII ioctls fail...            */
id|etool.cmd
op_assign
id|ETHTOOL_GLINK
suffix:semicolon
id|ifr.ifr_data
op_assign
(paren
r_char
op_star
)paren
op_amp
id|etool
suffix:semicolon
r_if
c_cond
(paren
id|IOCTL
c_func
(paren
id|dev
comma
op_amp
id|ifr
comma
id|SIOCETHTOOL
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|etool.data
op_eq
l_int|1
)paren
(brace
r_return
id|BMSR_LSTATUS
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;:: SIOCETHTOOL shows link down &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * If reporting, report that either there&squot;s no dev-&gt;do_ioctl,&n;&t; * or both SIOCGMIIREG and SIOCETHTOOL failed (meaning that we&n;&t; * cannot report link status).  If not reporting, pretend&n;&t; * we&squot;re ok.&n;&t; */
r_return
id|reporting
ques
c_cond
op_minus
l_int|1
suffix:colon
id|BMSR_LSTATUS
suffix:semicolon
)brace
DECL|function|bond_check_mii_link
r_static
id|u16
id|bond_check_mii_link
c_func
(paren
id|bonding_t
op_star
id|bond
)paren
(brace
r_int
id|has_active_interface
op_assign
l_int|0
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|has_active_interface
op_assign
(paren
id|bond-&gt;current_slave
op_ne
l_int|NULL
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
(paren
id|has_active_interface
ques
c_cond
id|BMSR_LSTATUS
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* register to receive lacpdus on a bond */
DECL|function|bond_register_lacpdu
r_static
r_void
id|bond_register_lacpdu
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|packet_type
op_star
id|pk_type
op_assign
op_amp
(paren
id|BOND_AD_INFO
c_func
(paren
id|bond
)paren
dot
id|ad_pkt_type
)paren
suffix:semicolon
multiline_comment|/* initialize packet type */
id|pk_type-&gt;type
op_assign
id|PKT_TYPE_LACPDU
suffix:semicolon
id|pk_type-&gt;dev
op_assign
id|bond-&gt;device
suffix:semicolon
id|pk_type-&gt;func
op_assign
id|bond_3ad_lacpdu_recv
suffix:semicolon
id|pk_type-&gt;data
op_assign
(paren
r_void
op_star
)paren
l_int|1
suffix:semicolon
multiline_comment|/* understand shared skbs */
id|dev_add_pack
c_func
(paren
id|pk_type
)paren
suffix:semicolon
)brace
multiline_comment|/* unregister to receive lacpdus on a bond */
DECL|function|bond_unregister_lacpdu
r_static
r_void
id|bond_unregister_lacpdu
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
id|dev_remove_pack
c_func
(paren
op_amp
(paren
id|BOND_AD_INFO
c_func
(paren
id|bond
)paren
dot
id|ad_pkt_type
)paren
)paren
suffix:semicolon
)brace
DECL|function|bond_open
r_static
r_int
id|bond_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_struct
id|timer_list
op_star
id|timer
op_assign
op_amp
(paren
(paren
r_struct
id|bonding
op_star
)paren
(paren
id|dev-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|mii_timer
suffix:semicolon
r_struct
id|timer_list
op_star
id|arp_timer
op_assign
op_amp
(paren
(paren
r_struct
id|bonding
op_star
)paren
(paren
id|dev-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|arp_timer
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
r_struct
id|timer_list
op_star
id|alb_timer
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
dot
id|alb_timer
)paren
suffix:semicolon
multiline_comment|/* bond_alb_initialize must be called before the timer&n;&t;&t; * is started.&n;&t;&t; */
r_if
c_cond
(paren
id|bond_alb_initialize
c_func
(paren
id|bond
comma
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
)paren
(brace
multiline_comment|/* something went wrong - fail the open operation */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|init_timer
c_func
(paren
id|alb_timer
)paren
suffix:semicolon
id|alb_timer-&gt;expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|alb_timer-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|bond
suffix:semicolon
id|alb_timer-&gt;function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|bond_alb_monitor
suffix:semicolon
id|add_timer
c_func
(paren
id|alb_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|miimon
OG
l_int|0
)paren
(brace
multiline_comment|/* link check interval, in milliseconds. */
id|init_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|timer-&gt;expires
op_assign
id|jiffies
op_plus
(paren
id|miimon
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|timer-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|timer-&gt;function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|bond_mii_monitor
suffix:semicolon
id|add_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp_interval
OG
l_int|0
)paren
(brace
multiline_comment|/* arp interval, in milliseconds. */
id|init_timer
c_func
(paren
id|arp_timer
)paren
suffix:semicolon
id|arp_timer-&gt;expires
op_assign
id|jiffies
op_plus
(paren
id|arp_interval
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|arp_timer-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
id|arp_timer-&gt;function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|activebackup_arp_monitor
suffix:semicolon
)brace
r_else
(brace
id|arp_timer-&gt;function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|loadbalance_arp_monitor
suffix:semicolon
)brace
id|add_timer
c_func
(paren
id|arp_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
r_struct
id|timer_list
op_star
id|ad_timer
op_assign
op_amp
(paren
id|BOND_AD_INFO
c_func
(paren
id|bond
)paren
dot
id|ad_timer
)paren
suffix:semicolon
id|init_timer
c_func
(paren
id|ad_timer
)paren
suffix:semicolon
id|ad_timer-&gt;expires
op_assign
id|jiffies
op_plus
(paren
id|AD_TIMER_INTERVAL
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|ad_timer-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|bond
suffix:semicolon
id|ad_timer-&gt;function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|bond_3ad_state_machine_handler
suffix:semicolon
id|add_timer
c_func
(paren
id|ad_timer
)paren
suffix:semicolon
multiline_comment|/* register to receive LACPDUs */
id|bond_register_lacpdu
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_close
r_static
r_int
id|bond_close
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|miimon
OG
l_int|0
)paren
(brace
multiline_comment|/* link check interval, in milliseconds. */
id|del_timer
c_func
(paren
op_amp
id|bond-&gt;mii_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp_interval
OG
l_int|0
)paren
(brace
multiline_comment|/* arp interval, in milliseconds. */
id|del_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp_target_hw_addr
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|arp_target_hw_addr
)paren
suffix:semicolon
id|arp_target_hw_addr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
id|del_timer_sync
c_func
(paren
op_amp
(paren
id|BOND_AD_INFO
c_func
(paren
id|bond
)paren
dot
id|ad_timer
)paren
)paren
suffix:semicolon
multiline_comment|/* Unregister the receive of LACPDUs */
id|bond_unregister_lacpdu
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
id|bond_mc_list_destroy
(paren
id|bond
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Release the bonded slaves */
id|bond_release_all
c_func
(paren
id|master
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
id|del_timer_sync
c_func
(paren
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
dot
id|alb_timer
)paren
)paren
suffix:semicolon
id|bond_alb_deinitialize
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * flush all members of flush-&gt;mc_list from device dev-&gt;mc_list&n; */
DECL|function|bond_mc_list_flush
r_static
r_void
id|bond_mc_list_flush
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device
op_star
id|flush
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
r_for
c_loop
(paren
id|dmi
op_assign
id|flush-&gt;mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
id|dev_mc_delete
c_func
(paren
id|dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
multiline_comment|/* del lacpdu mc addr from mc list */
id|u8
id|lacpdu_multicast
(braket
id|ETH_ALEN
)braket
op_assign
id|MULTICAST_LACPDU_ADDR
suffix:semicolon
id|dev_mc_delete
c_func
(paren
id|dev
comma
id|lacpdu_multicast
comma
id|ETH_ALEN
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Totally destroys the mc_list in bond&n; */
DECL|function|bond_mc_list_destroy
r_static
r_void
id|bond_mc_list_destroy
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
id|dmi
op_assign
id|bond-&gt;mc_list
suffix:semicolon
r_while
c_loop
(paren
id|dmi
)paren
(brace
id|bond-&gt;mc_list
op_assign
id|dmi-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|dmi
)paren
suffix:semicolon
id|dmi
op_assign
id|bond-&gt;mc_list
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Add a Multicast address to every slave in the bonding group&n; */
DECL|function|bond_mc_add
r_static
r_void
id|bond_mc_add
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_void
op_star
id|addr
comma
r_int
id|alen
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
r_switch
c_cond
(paren
id|multicast_mode
)paren
(brace
r_case
id|BOND_MULTICAST_ACTIVE
suffix:colon
multiline_comment|/* write lock already acquired */
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_ne
l_int|NULL
)paren
id|dev_mc_add
c_func
(paren
id|bond-&gt;current_slave-&gt;dev
comma
id|addr
comma
id|alen
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MULTICAST_ALL
suffix:colon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
id|dev_mc_add
c_func
(paren
id|slave-&gt;dev
comma
id|addr
comma
id|alen
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MULTICAST_DISABLED
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove a multicast address from every slave in the bonding group&n; */
DECL|function|bond_mc_delete
r_static
r_void
id|bond_mc_delete
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_void
op_star
id|addr
comma
r_int
id|alen
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
r_switch
c_cond
(paren
id|multicast_mode
)paren
(brace
r_case
id|BOND_MULTICAST_ACTIVE
suffix:colon
multiline_comment|/* write lock already acquired */
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_ne
l_int|NULL
)paren
id|dev_mc_delete
c_func
(paren
id|bond-&gt;current_slave-&gt;dev
comma
id|addr
comma
id|alen
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MULTICAST_ALL
suffix:colon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
id|dev_mc_delete
c_func
(paren
id|slave-&gt;dev
comma
id|addr
comma
id|alen
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MULTICAST_DISABLED
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Copy all the Multicast addresses from src to the bonding device dst&n; */
DECL|function|bond_mc_list_copy
r_static
r_int
id|bond_mc_list_copy
(paren
r_struct
id|dev_mc_list
op_star
id|src
comma
r_struct
id|bonding
op_star
id|dst
comma
r_int
id|gpf_flag
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
comma
op_star
id|new_dmi
suffix:semicolon
r_for
c_loop
(paren
id|dmi
op_assign
id|src
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
id|new_dmi
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dev_mc_list
)paren
comma
id|gpf_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_dmi
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|new_dmi-&gt;next
op_assign
id|dst-&gt;mc_list
suffix:semicolon
id|dst-&gt;mc_list
op_assign
id|new_dmi
suffix:semicolon
id|new_dmi-&gt;dmi_addrlen
op_assign
id|dmi-&gt;dmi_addrlen
suffix:semicolon
id|memcpy
c_func
(paren
id|new_dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
)paren
suffix:semicolon
id|new_dmi-&gt;dmi_users
op_assign
id|dmi-&gt;dmi_users
suffix:semicolon
id|new_dmi-&gt;dmi_gusers
op_assign
id|dmi-&gt;dmi_gusers
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns 0 if dmi1 and dmi2 are the same, non-0 otherwise&n; */
DECL|function|dmi_same
r_static
r_inline
r_int
id|dmi_same
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|dmi1
comma
r_struct
id|dev_mc_list
op_star
id|dmi2
)paren
(brace
r_return
id|memcmp
c_func
(paren
id|dmi1-&gt;dmi_addr
comma
id|dmi2-&gt;dmi_addr
comma
id|dmi1-&gt;dmi_addrlen
)paren
op_eq
l_int|0
op_logical_and
id|dmi1-&gt;dmi_addrlen
op_eq
id|dmi2-&gt;dmi_addrlen
suffix:semicolon
)brace
multiline_comment|/*&n; * Push the promiscuity flag down to appropriate slaves&n; */
DECL|function|bond_set_promiscuity
r_static
r_void
id|bond_set_promiscuity
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_int
id|inc
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|bond-&gt;current_slave
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|bond-&gt;current_slave-&gt;dev
comma
id|inc
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|slave-&gt;dev
comma
id|inc
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Push the allmulti flag down to all slaves&n; */
DECL|function|bond_set_allmulti
r_static
r_void
id|bond_set_allmulti
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_int
id|inc
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
r_switch
c_cond
(paren
id|multicast_mode
)paren
(brace
r_case
id|BOND_MULTICAST_ACTIVE
suffix:colon
multiline_comment|/* write lock already acquired */
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_ne
l_int|NULL
)paren
id|dev_set_allmulti
c_func
(paren
id|bond-&gt;current_slave-&gt;dev
comma
id|inc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MULTICAST_ALL
suffix:colon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
id|dev_set_allmulti
c_func
(paren
id|slave-&gt;dev
comma
id|inc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MULTICAST_DISABLED
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * returns dmi entry if found, NULL otherwise &n; */
DECL|function|bond_mc_list_find_dmi
r_static
r_struct
id|dev_mc_list
op_star
id|bond_mc_list_find_dmi
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|dmi
comma
r_struct
id|dev_mc_list
op_star
id|mc_list
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|idmi
suffix:semicolon
r_for
c_loop
(paren
id|idmi
op_assign
id|mc_list
suffix:semicolon
id|idmi
op_ne
l_int|NULL
suffix:semicolon
id|idmi
op_assign
id|idmi-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dmi_same
c_func
(paren
id|dmi
comma
id|idmi
)paren
)paren
(brace
r_return
id|idmi
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
id|master-&gt;priv
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do promisc before checking multicast_mode&n;&t; */
r_if
c_cond
(paren
(paren
id|master-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
op_logical_neg
(paren
id|bond-&gt;flags
op_amp
id|IFF_PROMISC
)paren
)paren
id|bond_set_promiscuity
c_func
(paren
id|bond
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|master-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
(paren
id|bond-&gt;flags
op_amp
id|IFF_PROMISC
)paren
)paren
id|bond_set_promiscuity
c_func
(paren
id|bond
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|multicast_mode
op_eq
id|BOND_MULTICAST_DISABLED
)paren
(brace
id|bond-&gt;flags
op_assign
id|master-&gt;flags
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* set allmulti flag to slaves */
r_if
c_cond
(paren
(paren
id|master-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_and
op_logical_neg
(paren
id|bond-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
id|bond_set_allmulti
c_func
(paren
id|bond
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|master-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_and
(paren
id|bond-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
id|bond_set_allmulti
c_func
(paren
id|bond
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|bond-&gt;flags
op_assign
id|master-&gt;flags
suffix:semicolon
multiline_comment|/* looking for addresses to add to slaves&squot; mc list */
r_for
c_loop
(paren
id|dmi
op_assign
id|master-&gt;mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|bond_mc_list_find_dmi
c_func
(paren
id|dmi
comma
id|bond-&gt;mc_list
)paren
op_eq
l_int|NULL
)paren
id|bond_mc_add
c_func
(paren
id|bond
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
)paren
suffix:semicolon
)brace
multiline_comment|/* looking for addresses to delete from slaves&squot; list */
r_for
c_loop
(paren
id|dmi
op_assign
id|bond-&gt;mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|bond_mc_list_find_dmi
c_func
(paren
id|dmi
comma
id|master-&gt;mc_list
)paren
op_eq
l_int|NULL
)paren
id|bond_mc_delete
c_func
(paren
id|bond
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
)paren
suffix:semicolon
)brace
multiline_comment|/* save master&squot;s multicast list */
id|bond_mc_list_destroy
(paren
id|bond
)paren
suffix:semicolon
id|bond_mc_list_copy
(paren
id|master-&gt;mc_list
comma
id|bond
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the mc list and multicast-related flags for the new and &n; * old active slaves (if any) according to the multicast mode, and&n; * promiscuous flags unconditionally.&n; */
DECL|function|bond_mc_update
r_static
r_void
id|bond_mc_update
c_func
(paren
id|bonding_t
op_star
id|bond
comma
id|slave_t
op_star
r_new
comma
id|slave_t
op_star
id|old
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|bond-&gt;device-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
r_if
c_cond
(paren
id|old
)paren
id|dev_set_promiscuity
c_func
(paren
id|old-&gt;dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
id|dev_set_promiscuity
c_func
(paren
r_new
op_member_access_from_pointer
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|multicast_mode
)paren
(brace
r_case
id|BOND_MULTICAST_ACTIVE
suffix:colon
r_if
c_cond
(paren
id|bond-&gt;device-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
r_if
c_cond
(paren
id|old
)paren
id|dev_set_allmulti
c_func
(paren
id|old-&gt;dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
id|dev_set_allmulti
c_func
(paren
r_new
op_member_access_from_pointer
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* first remove all mc addresses from old slave if any,&n;&t;&t;   and _then_ add them to new active slave */
r_if
c_cond
(paren
id|old
)paren
(brace
r_for
c_loop
(paren
id|dmi
op_assign
id|bond-&gt;device-&gt;mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
id|dev_mc_delete
c_func
(paren
id|old-&gt;dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
)paren
(brace
r_for
c_loop
(paren
id|dmi
op_assign
id|bond-&gt;device-&gt;mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
id|dev_mc_add
c_func
(paren
r_new
op_member_access_from_pointer
id|dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BOND_MULTICAST_ALL
suffix:colon
multiline_comment|/* nothing to do: mc list is already up-to-date on all slaves */
r_break
suffix:semicolon
r_case
id|BOND_MULTICAST_DISABLED
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* enslave device &lt;slave&gt; to bond device &lt;master&gt; */
DECL|function|bond_enslave
r_static
r_int
id|bond_enslave
c_func
(paren
r_struct
id|net_device
op_star
id|master_dev
comma
r_struct
id|net_device
op_star
id|slave_dev
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
l_int|NULL
suffix:semicolon
id|slave_t
op_star
id|new_slave
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|rflags
op_assign
l_int|0
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
r_struct
id|in_ifaddr
op_star
op_star
id|ifap
suffix:semicolon
r_struct
id|in_ifaddr
op_star
id|ifa
suffix:semicolon
r_int
id|link_reporting
suffix:semicolon
r_struct
id|sockaddr
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|master_dev
op_eq
l_int|NULL
op_logical_or
id|slave_dev
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master_dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|slave_dev-&gt;do_ioctl
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Warning : no link monitoring support for %s&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* bond must be initialized by bond_open() before enslaving */
r_if
c_cond
(paren
op_logical_neg
(paren
id|master_dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Error, master_dev is not up&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* already enslaved */
r_if
c_cond
(paren
id|master_dev-&gt;flags
op_amp
id|IFF_SLAVE
op_logical_or
id|slave_dev-&gt;flags
op_amp
id|IFF_SLAVE
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Error, Device was already enslaved&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|app_abi_ver
op_ge
l_int|1
)paren
(brace
multiline_comment|/* The application is using an ABI, which requires the&n;&t;&t; * slave interface to be closed.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|slave_dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Error, slave_dev is up&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slave_dev-&gt;set_mac_address
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;The slave device you specified does not support&quot;
l_string|&quot; setting the MAC address.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Your kernel likely does not support slave&quot;
l_string|&quot; devices.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* The application is not using an ABI, which requires the&n;&t;&t; * slave interface to be open.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|slave_dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Error, slave_dev is not running&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bonding: Error: to use %s mode, you must &quot;
l_string|&quot;upgrade ifenslave.&bslash;n&quot;
comma
id|bond_mode_name
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|new_slave
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|slave_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|new_slave
comma
l_int|0
comma
r_sizeof
(paren
id|slave_t
)paren
)paren
suffix:semicolon
multiline_comment|/* save slave&squot;s original flags before calling&n;&t; * netdev_set_master and dev_open&n;&t; */
id|new_slave-&gt;original_flags
op_assign
id|slave_dev-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
id|app_abi_ver
op_ge
l_int|1
)paren
(brace
multiline_comment|/* save slave&squot;s original (&quot;permanent&quot;) mac address for&n;&t;&t; * modes that needs it, and for restoring it upon release,&n;&t;&t; * and then set it to the master&squot;s address&n;&t;&t; */
id|memcpy
c_func
(paren
id|new_slave-&gt;perm_hwaddr
comma
id|slave_dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
OG
l_int|0
)paren
(brace
multiline_comment|/* set slave to master&squot;s mac address&n;&t;&t;&t; * The application already set the master&squot;s&n;&t;&t;&t; * mac address to that of the first slave&n;&t;&t;&t; */
id|memcpy
c_func
(paren
id|addr.sa_data
comma
id|master_dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|addr.sa_family
op_assign
id|slave_dev-&gt;type
suffix:semicolon
id|err
op_assign
id|slave_dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|slave_dev
comma
op_amp
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Error %d calling set_mac_address&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|err_free
suffix:semicolon
)brace
)brace
multiline_comment|/* open the slave since the application closed it */
id|err
op_assign
id|dev_open
c_func
(paren
id|slave_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Openning slave %s failed&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|err_restore_mac
suffix:semicolon
)brace
)brace
id|err
op_assign
id|netdev_set_master
c_func
(paren
id|slave_dev
comma
id|master_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Error %d calling netdev_set_master&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|app_abi_ver
OL
l_int|1
)paren
(brace
r_goto
id|err_free
suffix:semicolon
)brace
r_else
(brace
r_goto
id|err_close
suffix:semicolon
)brace
)brace
id|new_slave-&gt;dev
op_assign
id|slave_dev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
multiline_comment|/* bond_alb_init_slave() must be called before all other stages since&n;&t;&t; * it might fail and we do not want to have to undo everything&n;&t;&t; */
id|err
op_assign
id|bond_alb_init_slave
c_func
(paren
id|bond
comma
id|new_slave
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_goto
id|err_unset_master
suffix:semicolon
)brace
)brace
multiline_comment|/* set promiscuity level to new slave */
r_if
c_cond
(paren
id|master_dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* If the mode USES_PRIMARY, then the new slave gets the&n;&t;&t; * master&squot;s promisc (and mc) settings only if it becomes the&n;&t;&t; * current_slave, and that is taken care of later when calling&n;&t;&t; * bond_change_active()&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|slave_dev
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|multicast_mode
op_eq
id|BOND_MULTICAST_ALL
)paren
(brace
multiline_comment|/* set allmulti level to new slave */
r_if
c_cond
(paren
id|master_dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
id|dev_set_allmulti
c_func
(paren
id|slave_dev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* upload master&squot;s mc_list to new slave */
r_for
c_loop
(paren
id|dmi
op_assign
id|master_dev-&gt;mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
id|dev_mc_add
(paren
id|slave_dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
multiline_comment|/* add lacpdu mc addr to mc list */
id|u8
id|lacpdu_multicast
(braket
id|ETH_ALEN
)braket
op_assign
id|MULTICAST_LACPDU_ADDR
suffix:semicolon
id|dev_mc_add
c_func
(paren
id|slave_dev
comma
id|lacpdu_multicast
comma
id|ETH_ALEN
comma
l_int|0
)paren
suffix:semicolon
)brace
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|bond_attach_slave
c_func
(paren
id|bond
comma
id|new_slave
)paren
suffix:semicolon
id|new_slave-&gt;delay
op_assign
l_int|0
suffix:semicolon
id|new_slave-&gt;link_failure_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|miimon
OG
l_int|0
op_logical_and
op_logical_neg
id|use_carrier
)paren
(brace
id|link_reporting
op_assign
id|bond_check_dev_link
c_func
(paren
id|slave_dev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|link_reporting
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|arp_interval
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * miimon is set but a bonded network driver&n;&t;&t;&t; * does not support ETHTOOL/MII and&n;&t;&t;&t; * arp_interval is not set.  Note: if&n;&t;&t;&t; * use_carrier is enabled, we will never go&n;&t;&t;&t; * here (because netif_carrier is always&n;&t;&t;&t; * supported); thus, we don&squot;t need to change&n;&t;&t;&t; * the messages for netif_carrier.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bond_enslave(): MII and ETHTOOL support not &quot;
l_string|&quot;available for interface %s, and &quot;
l_string|&quot;arp_interval/arp_ip_target module parameters &quot;
l_string|&quot;not specified, thus bonding will not detect &quot;
l_string|&quot;link failures! see bonding.txt for details.&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|link_reporting
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* unable  get link status using mii/ethtool */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bond_enslave: can&squot;t get link status from &quot;
l_string|&quot;interface %s; the network driver associated &quot;
l_string|&quot;with this interface does not support &quot;
l_string|&quot;MII or ETHTOOL link status reporting, thus &quot;
l_string|&quot;miimon has no effect on this interface.&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* check for initial state */
r_if
c_cond
(paren
(paren
id|miimon
op_le
l_int|0
)paren
op_logical_or
(paren
id|bond_check_dev_link
c_func
(paren
id|slave_dev
comma
l_int|0
)paren
op_eq
id|BMSR_LSTATUS
)paren
)paren
(brace
r_if
c_cond
(paren
id|updelay
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Initial state of slave_dev is &quot;
l_string|&quot;BOND_LINK_BACK&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|new_slave-&gt;link
op_assign
id|BOND_LINK_BACK
suffix:semicolon
id|new_slave-&gt;delay
op_assign
id|updelay
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Initial state of slave_dev is &quot;
l_string|&quot;BOND_LINK_UP&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|new_slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
)brace
id|new_slave-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Initial state of slave_dev is &quot;
l_string|&quot;BOND_LINK_DOWN&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|new_slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond_update_speed_duplex
c_func
(paren
id|new_slave
)paren
op_logical_and
(paren
id|new_slave-&gt;link
op_ne
id|BOND_LINK_DOWN
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bond_enslave(): failed to get speed/duplex from %s, &quot;
l_string|&quot;speed forced to 100Mbps, duplex forced to Full.&bslash;n&quot;
comma
id|new_slave-&gt;dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Operation of 802.3ad mode requires ETHTOOL support &quot;
l_string|&quot;in base driver for proper aggregator selection.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* if we&squot;re in active-backup mode, we need one and only one active&n;&t; * interface. The backup interfaces will have their NOARP flag set&n;&t; * because we need them to be completely deaf and not to respond to&n;&t; * any ARP request on the network to avoid fooling a switch. Thus,&n;&t; * since we guarantee that current_slave always point to the last&n;&t; * usable interface, we just have to verify this interface&squot;s flag.&n;&t; */
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|bond-&gt;current_slave
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|bond-&gt;current_slave-&gt;dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
)paren
op_logical_and
(paren
id|new_slave-&gt;link
op_ne
id|BOND_LINK_DOWN
)paren
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;This is the first active slave&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* first slave or no active slave yet, and this link&n;&t;&t;&t;   is OK, so make this interface the active one */
id|change_active_interface
c_func
(paren
id|bond
comma
id|new_slave
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;This is just a backup slave&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|bond_set_slave_inactive_flags
c_func
(paren
id|new_slave
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
r_struct
id|in_device
op_star
)paren
id|slave_dev-&gt;ip_ptr
)paren
op_ne
l_int|NULL
)paren
(brace
id|read_lock_irqsave
c_func
(paren
op_amp
(paren
(paren
(paren
r_struct
id|in_device
op_star
)paren
id|slave_dev-&gt;ip_ptr
)paren
op_member_access_from_pointer
id|lock
)paren
comma
id|rflags
)paren
suffix:semicolon
id|ifap
op_assign
op_amp
(paren
(paren
(paren
r_struct
id|in_device
op_star
)paren
id|slave_dev-&gt;ip_ptr
)paren
op_member_access_from_pointer
id|ifa_list
)paren
suffix:semicolon
id|ifa
op_assign
op_star
id|ifap
suffix:semicolon
r_if
c_cond
(paren
id|ifa
op_ne
l_int|NULL
)paren
id|my_ip
op_assign
id|ifa-&gt;ifa_address
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
(paren
(paren
(paren
r_struct
id|in_device
op_star
)paren
id|slave_dev-&gt;ip_ptr
)paren
op_member_access_from_pointer
id|lock
)paren
comma
id|rflags
)paren
suffix:semicolon
)brace
multiline_comment|/* if there is a primary slave, remember it */
r_if
c_cond
(paren
id|primary
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|primary
comma
id|new_slave-&gt;dev-&gt;name
)paren
op_eq
l_int|0
)paren
(brace
id|bond-&gt;primary_slave
op_assign
id|new_slave
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
multiline_comment|/* in 802.3ad mode, the internal mechanism&n;&t;&t; * will activate the slaves in the selected&n;&t;&t; * aggregator&n;&t;&t; */
id|bond_set_slave_inactive_flags
c_func
(paren
id|new_slave
)paren
suffix:semicolon
multiline_comment|/* if this is the first slave */
r_if
c_cond
(paren
id|new_slave
op_eq
id|bond-&gt;next
)paren
(brace
id|SLAVE_AD_INFO
c_func
(paren
id|new_slave
)paren
dot
id|id
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Initialize AD with the number of times that the AD timer is called in 1 second&n;&t;&t;&t; * can be called only after the mac address of the bond is set&n;&t;&t;&t; */
id|bond_3ad_initialize
c_func
(paren
id|bond
comma
l_int|1000
op_div
id|AD_TIMER_INTERVAL
comma
id|lacp_fast
)paren
suffix:semicolon
)brace
r_else
(brace
id|SLAVE_AD_INFO
c_func
(paren
id|new_slave
)paren
dot
id|id
op_assign
id|SLAVE_AD_INFO
c_func
(paren
id|new_slave-&gt;prev
)paren
dot
id|id
op_plus
l_int|1
suffix:semicolon
)brace
id|bond_3ad_bind_slave
c_func
(paren
id|new_slave
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
id|new_slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bond-&gt;current_slave
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|new_slave-&gt;link
op_ne
id|BOND_LINK_DOWN
)paren
)paren
(brace
multiline_comment|/* first slave or no active slave yet, and this link&n;&t;&t;&t; * is OK, so make this interface the active one&n;&t;&t;&t; */
id|change_active_interface
c_func
(paren
id|bond
comma
id|new_slave
)paren
suffix:semicolon
)brace
multiline_comment|/* if there is a primary slave, remember it */
r_if
c_cond
(paren
id|primary
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|primary
comma
id|new_slave-&gt;dev-&gt;name
)paren
op_eq
l_int|0
)paren
(brace
id|bond-&gt;primary_slave
op_assign
id|new_slave
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;This slave is always active in trunk mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* always active in trunk mode */
id|new_slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
multiline_comment|/* In trunking mode there is little meaning to current_slave&n;&t;&t; * anyway (it holds no special properties of the bond device),&n;&t;&t; * so we can change it without calling change_active_interface()&n;&t;&t; */
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_eq
l_int|NULL
)paren
id|bond-&gt;current_slave
op_assign
id|new_slave
suffix:semicolon
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|app_abi_ver
OL
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * !!! This is to support old versions of ifenslave.&n;&t;&t; * We can remove this in 2.5 because our ifenslave takes&n;&t;&t; * care of this for us.&n;&t;&t; * We check to see if the master has a mac address yet.&n;&t;&t; * If not, we&squot;ll give it the mac address of our slave device.&n;&t;&t; */
r_int
id|ndx
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|ndx
op_assign
l_int|0
suffix:semicolon
id|ndx
OL
id|slave_dev-&gt;addr_len
suffix:semicolon
id|ndx
op_increment
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Checking ndx=%d of master_dev-&gt;dev_addr&bslash;n&quot;
comma
id|ndx
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|master_dev-&gt;dev_addr
(braket
id|ndx
)braket
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Found non-zero byte at ndx=%d&bslash;n&quot;
comma
id|ndx
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ndx
op_eq
id|slave_dev-&gt;addr_len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We got all the way through the address and it was&n;&t;&t;&t; * all 0&squot;s.&n;&t;&t;&t; */
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s doesn&squot;t have a MAC address yet.  &quot;
comma
id|master_dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Going to give assign it from %s.&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|bond_sethwaddr
c_func
(paren
id|master_dev
comma
id|slave_dev
)paren
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: enslaving %s as a%s interface with a%s link.&bslash;n&quot;
comma
id|master_dev-&gt;name
comma
id|slave_dev-&gt;name
comma
id|new_slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
ques
c_cond
l_string|&quot;n active&quot;
suffix:colon
l_string|&quot; backup&quot;
comma
id|new_slave-&gt;link
op_ne
id|BOND_LINK_DOWN
ques
c_cond
l_string|&quot;n up&quot;
suffix:colon
l_string|&quot; down&quot;
)paren
suffix:semicolon
multiline_comment|/* enslave is successful */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Undo stages on error */
id|err_unset_master
suffix:colon
id|netdev_set_master
c_func
(paren
id|slave_dev
comma
l_int|NULL
)paren
suffix:semicolon
id|err_close
suffix:colon
id|dev_close
c_func
(paren
id|slave_dev
)paren
suffix:semicolon
id|err_restore_mac
suffix:colon
id|memcpy
c_func
(paren
id|addr.sa_data
comma
id|new_slave-&gt;perm_hwaddr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|addr.sa_family
op_assign
id|slave_dev-&gt;type
suffix:semicolon
id|slave_dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|slave_dev
comma
op_amp
id|addr
)paren
suffix:semicolon
id|err_free
suffix:colon
id|kfree
c_func
(paren
id|new_slave
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* &n; * This function changes the active slave to slave &lt;slave_dev&gt;.&n; * It returns -EINVAL in the following cases.&n; *  - &lt;slave_dev&gt; is not found in the list.&n; *  - There is not active slave now.&n; *  - &lt;slave_dev&gt; is already active.&n; *  - The link state of &lt;slave_dev&gt; is not BOND_LINK_UP.&n; *  - &lt;slave_dev&gt; is not running.&n; * In these cases, this fuction does nothing.&n; * In the other cases, currnt_slave pointer is changed and 0 is returned.&n; */
DECL|function|bond_change_active
r_static
r_int
id|bond_change_active
c_func
(paren
r_struct
id|net_device
op_star
id|master_dev
comma
r_struct
id|net_device
op_star
id|slave_dev
)paren
(brace
id|bonding_t
op_star
id|bond
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
id|slave_t
op_star
id|oldactive
op_assign
l_int|NULL
suffix:semicolon
id|slave_t
op_star
id|newactive
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|master_dev
op_eq
l_int|NULL
op_logical_or
id|slave_dev
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Verify that master_dev is indeed the master of slave_dev */
r_if
c_cond
(paren
op_logical_neg
(paren
id|slave_dev-&gt;flags
op_amp
id|IFF_SLAVE
)paren
op_logical_or
(paren
id|slave_dev-&gt;master
op_ne
id|master_dev
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master_dev-&gt;priv
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|slave
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|oldactive
op_assign
id|bond-&gt;current_slave
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;prev
)paren
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
r_if
c_cond
(paren
id|slave_dev
op_eq
id|slave-&gt;dev
)paren
(brace
id|newactive
op_assign
id|slave
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Changing to the current active: do nothing; return success.&n;&t; */
r_if
c_cond
(paren
id|newactive
op_logical_and
(paren
id|newactive
op_eq
id|oldactive
)paren
)paren
(brace
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|newactive
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|oldactive
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|newactive-&gt;link
op_eq
id|BOND_LINK_UP
)paren
op_logical_and
id|IS_UP
c_func
(paren
id|newactive-&gt;dev
)paren
)paren
(brace
id|change_active_interface
c_func
(paren
id|bond
comma
id|newactive
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * find_best_interface - select the best available slave to be the active one&n; * @bond: our bonding struct&n; *&n; * Warning: Caller must hold ptrlock for writing.&n; */
DECL|function|find_best_interface
r_static
r_struct
id|slave
op_star
id|find_best_interface
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|slave
op_star
id|newslave
comma
op_star
id|oldslave
suffix:semicolon
r_struct
id|slave
op_star
id|bestslave
op_assign
l_int|NULL
suffix:semicolon
r_int
id|mintime
suffix:semicolon
id|newslave
op_assign
id|oldslave
op_assign
id|bond-&gt;current_slave
suffix:semicolon
r_if
c_cond
(paren
id|newslave
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* there were no active slaves left */
r_if
c_cond
(paren
id|bond-&gt;next
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
multiline_comment|/* found one slave */
id|newslave
op_assign
id|bond-&gt;next
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* still no slave, return NULL */
)brace
)brace
id|mintime
op_assign
id|updelay
suffix:semicolon
multiline_comment|/* first try the primary link; if arping, a link must tx/rx traffic &n;&t; * before it can be considered the current_slave - also, we would skip &n;&t; * slaves between the current_slave and primary_slave that may be up &n;&t; * and able to arp&n;&t; */
r_if
c_cond
(paren
(paren
id|bond-&gt;primary_slave
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|arp_interval
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|bond-&gt;primary_slave-&gt;dev
)paren
)paren
id|newslave
op_assign
id|bond-&gt;primary_slave
suffix:semicolon
)brace
multiline_comment|/* remember where to stop iterating over the slaves */
id|oldslave
op_assign
id|newslave
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|newslave-&gt;dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|newslave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
(brace
r_return
id|newslave
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|newslave-&gt;link
op_eq
id|BOND_LINK_BACK
)paren
(brace
multiline_comment|/* link up, but waiting for stabilization */
r_if
c_cond
(paren
id|newslave-&gt;delay
OL
id|mintime
)paren
(brace
id|mintime
op_assign
id|newslave-&gt;delay
suffix:semicolon
id|bestslave
op_assign
id|newslave
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
(paren
id|newslave
op_assign
id|newslave-&gt;next
)paren
op_ne
id|oldslave
)paren
suffix:semicolon
r_return
id|bestslave
suffix:semicolon
)brace
multiline_comment|/**&n; * change_active_interface - change the active slave into the specified one&n; * @bond: our bonding struct&n; * @new: the new slave to make the active one&n; * &n; * Set the new slave to the bond&squot;s settings and unset them on the old&n; * current_slave.&n; * Setting include flags, mc-list, promiscuity, allmulti, etc.&n; *&n; * If @new&squot;s link state is %BOND_LINK_BACK we&squot;ll set it to %BOND_LINK_UP,&n; * because it is apparently the best available slave we have, even though its&n; * updelay hasn&squot;t timed out yet.&n; *&n; * Warning: Caller must hold ptrlock for writing.&n; */
DECL|function|change_active_interface
r_static
r_void
id|change_active_interface
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
r_new
)paren
(brace
r_struct
id|slave
op_star
id|old
op_assign
id|bond-&gt;current_slave
suffix:semicolon
r_if
c_cond
(paren
id|old
op_eq
r_new
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
)paren
(brace
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|link
op_eq
id|BOND_LINK_BACK
)paren
(brace
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: making interface %s the new &quot;
l_string|&quot;active one %d ms earlier.&bslash;n&quot;
comma
id|bond-&gt;device-&gt;name
comma
r_new
op_member_access_from_pointer
id|dev-&gt;name
comma
(paren
id|updelay
op_minus
r_new
op_member_access_from_pointer
id|delay
)paren
op_star
id|miimon
)paren
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|delay
op_assign
l_int|0
suffix:semicolon
r_new
op_member_access_from_pointer
id|link
op_assign
id|BOND_LINK_UP
suffix:semicolon
r_new
op_member_access_from_pointer
id|jiffies
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
id|bond_3ad_handle_link_change
c_func
(paren
r_new
comma
id|BOND_LINK_UP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
id|bond_alb_handle_link_change
c_func
(paren
id|bond
comma
r_new
comma
id|BOND_LINK_UP
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: making interface %s the new active one.&bslash;n&quot;
comma
id|bond-&gt;device-&gt;name
comma
r_new
op_member_access_from_pointer
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
r_if
c_cond
(paren
id|old
)paren
(brace
id|bond_set_slave_inactive_flags
c_func
(paren
id|old
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
)paren
(brace
id|bond_set_slave_active_flags
c_func
(paren
r_new
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|bond_mc_update
c_func
(paren
id|bond
comma
r_new
comma
id|old
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
id|bond_alb_assign_current_slave
c_func
(paren
id|bond
comma
r_new
)paren
suffix:semicolon
)brace
r_else
(brace
id|bond-&gt;current_slave
op_assign
r_new
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * reselect_active_interface - select a new active slave, if needed&n; * @bond: our bonding struct&n; *&n; * This functions shoud be called when one of the following occurs:&n; * - The old current_slave has been released or lost its link.&n; * - The primary_slave has got its link back.&n; * - A slave has got its link back and there&squot;s no old current_slave.&n; *&n; * Warning: Caller must hold ptrlock for writing.&n; */
DECL|function|reselect_active_interface
r_static
r_void
id|reselect_active_interface
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|slave
op_star
id|best_slave
suffix:semicolon
id|best_slave
op_assign
id|find_best_interface
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|best_slave
op_ne
id|bond-&gt;current_slave
)paren
(brace
id|change_active_interface
c_func
(paren
id|bond
comma
id|best_slave
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Try to release the slave device &lt;slave&gt; from the bond device &lt;master&gt;&n; * It is legal to access current_slave without a lock because all the function&n; * is write-locked.&n; *&n; * The rules for slave state should be:&n; *   for Active/Backup:&n; *     Active stays on all backups go down&n; *   for Bonded connections:&n; *     The first up interface should be left on and all others downed.&n; */
DECL|function|bond_release
r_static
r_int
id|bond_release
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|net_device
op_star
id|slave
)paren
(brace
id|bonding_t
op_star
id|bond
suffix:semicolon
id|slave_t
op_star
id|our_slave
comma
op_star
id|old_current
suffix:semicolon
r_struct
id|sockaddr
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|master
op_eq
l_int|NULL
op_logical_or
id|slave
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
multiline_comment|/* master already enslaved, or slave not enslaved,&n;&t;   or no slave for this master */
r_if
c_cond
(paren
(paren
id|master-&gt;flags
op_amp
id|IFF_SLAVE
)paren
op_logical_or
op_logical_neg
(paren
id|slave-&gt;flags
op_amp
id|IFF_SLAVE
)paren
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: cannot release %s.&bslash;n&quot;
comma
id|master-&gt;name
comma
id|slave-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
l_int|NULL
suffix:semicolon
id|our_slave
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|old_current
op_assign
id|bond-&gt;current_slave
suffix:semicolon
r_while
c_loop
(paren
(paren
id|our_slave
op_assign
id|our_slave-&gt;prev
)paren
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
r_if
c_cond
(paren
id|our_slave-&gt;dev
op_eq
id|slave
)paren
(brace
r_int
id|mac_addr_differ
op_assign
id|memcmp
c_func
(paren
id|bond-&gt;device-&gt;dev_addr
comma
id|our_slave-&gt;perm_hwaddr
comma
id|ETH_ALEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mac_addr_differ
op_logical_and
(paren
id|bond-&gt;slave_cnt
OG
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WARNING: the permanent HWaddr of %s &quot;
l_string|&quot;- %02X:%02X:%02X:%02X:%02X:%02X - &quot;
l_string|&quot;is still in use by %s. Set the HWaddr &quot;
l_string|&quot;of %s to a different address &quot;
l_string|&quot;to avoid conflicts.&bslash;n&quot;
comma
id|slave-&gt;name
comma
id|slave-&gt;dev_addr
(braket
l_int|0
)braket
comma
id|slave-&gt;dev_addr
(braket
l_int|1
)braket
comma
id|slave-&gt;dev_addr
(braket
l_int|2
)braket
comma
id|slave-&gt;dev_addr
(braket
l_int|3
)braket
comma
id|slave-&gt;dev_addr
(braket
l_int|4
)braket
comma
id|slave-&gt;dev_addr
(braket
l_int|5
)braket
comma
id|bond-&gt;device-&gt;name
comma
id|slave-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* Inform AD package of unbinding of slave. */
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
multiline_comment|/* must be called before the slave is&n;&t;&t;&t;&t; * detached from the list&n;&t;&t;&t;&t; */
id|bond_3ad_unbind_slave
c_func
(paren
id|our_slave
)paren
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: releasing %s interface %s&bslash;n&quot;
comma
id|master-&gt;name
comma
(paren
id|our_slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
)paren
ques
c_cond
l_string|&quot;active&quot;
suffix:colon
l_string|&quot;backup&quot;
comma
id|slave-&gt;name
)paren
suffix:semicolon
multiline_comment|/* release the slave from its bond */
id|bond_detach_slave
c_func
(paren
id|bond
comma
id|our_slave
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;primary_slave
op_eq
id|our_slave
)paren
(brace
id|bond-&gt;primary_slave
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_eq
id|our_slave
)paren
(brace
id|change_active_interface
c_func
(paren
id|bond
comma
l_int|NULL
)paren
suffix:semicolon
id|reselect_active_interface
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: now running without any active interface !&bslash;n&quot;
comma
id|master-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
multiline_comment|/* must be called only after the slave has been&n;&t;&t;&t;&t; * detached from the list and the current_slave&n;&t;&t;&t;&t; * has been replaced (if our_slave == old_current)&n;&t;&t;&t;&t; */
id|bond_alb_deinit_slave
c_func
(paren
id|bond
comma
id|our_slave
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|our_slave
op_eq
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
multiline_comment|/* if we get here, it&squot;s because the device was not found */
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: %s not enslaved&bslash;n&quot;
comma
id|master-&gt;name
comma
id|slave-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* unset promiscuity level from slave */
r_if
c_cond
(paren
id|master-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* If the mode USES_PRIMARY, then we should only remove its&n;&t;&t; * promisc settings if it was the current_slave, but that was&n;&t;&t; * already taken care of above when we detached the slave&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|slave
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* undo settings and restore original values */
r_if
c_cond
(paren
id|multicast_mode
op_eq
id|BOND_MULTICAST_ALL
)paren
(brace
multiline_comment|/* flush master&squot;s mc_list from slave */
id|bond_mc_list_flush
(paren
id|slave
comma
id|master
)paren
suffix:semicolon
multiline_comment|/* unset allmulti level from slave */
r_if
c_cond
(paren
id|master-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
id|dev_set_allmulti
c_func
(paren
id|slave
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|netdev_set_master
c_func
(paren
id|slave
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* close slave before restoring its mac address */
id|dev_close
c_func
(paren
id|slave
)paren
suffix:semicolon
r_if
c_cond
(paren
id|app_abi_ver
op_ge
l_int|1
)paren
(brace
multiline_comment|/* restore original (&quot;permanent&quot;) mac address */
id|memcpy
c_func
(paren
id|addr.sa_data
comma
id|our_slave-&gt;perm_hwaddr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|addr.sa_family
op_assign
id|slave-&gt;type
suffix:semicolon
id|slave
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|slave
comma
op_amp
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/* restore the original state of the&n;&t; * IFF_NOARP flag that might have been&n;&t; * set by bond_set_slave_inactive_flags()&n;&t; */
r_if
c_cond
(paren
(paren
id|our_slave-&gt;original_flags
op_amp
id|IFF_NOARP
)paren
op_eq
l_int|0
)paren
(brace
id|slave-&gt;flags
op_and_assign
op_complement
id|IFF_NOARP
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|our_slave
)paren
suffix:semicolon
multiline_comment|/* if the last slave was removed, zero the mac address&n;&t; * of the master so it will be set by the application&n;&t; * to the mac address of the first slave&n;&t; */
r_if
c_cond
(paren
id|bond-&gt;next
op_eq
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
id|memset
c_func
(paren
id|master-&gt;dev_addr
comma
l_int|0
comma
id|master-&gt;addr_len
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* deletion OK */
)brace
multiline_comment|/* &n; * This function releases all slaves.&n; */
DECL|function|bond_release_all
r_static
r_int
id|bond_release_all
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
(brace
id|bonding_t
op_star
id|bond
suffix:semicolon
id|slave_t
op_star
id|our_slave
comma
op_star
id|old_current
suffix:semicolon
r_struct
id|net_device
op_star
id|slave_dev
suffix:semicolon
r_struct
id|sockaddr
id|addr
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|master
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|master-&gt;flags
op_amp
id|IFF_SLAVE
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;next
op_eq
(paren
r_struct
id|slave
op_star
)paren
id|bond
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|old_current
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|change_active_interface
c_func
(paren
id|bond
comma
l_int|NULL
)paren
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
l_int|NULL
suffix:semicolon
id|bond-&gt;primary_slave
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|our_slave
op_assign
id|bond-&gt;prev
)paren
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
multiline_comment|/* Inform AD package of unbinding of slave&n;&t;&t; * before slave is detached from the list.&n;&t;&t; */
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
id|bond_3ad_unbind_slave
c_func
(paren
id|our_slave
)paren
suffix:semicolon
)brace
id|slave_dev
op_assign
id|our_slave-&gt;dev
suffix:semicolon
id|bond_detach_slave
c_func
(paren
id|bond
comma
id|our_slave
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
multiline_comment|/* must be called only after the slave&n;&t;&t;&t; * has been detached from the list&n;&t;&t;&t; */
id|bond_alb_deinit_slave
c_func
(paren
id|bond
comma
id|our_slave
)paren
suffix:semicolon
)brace
multiline_comment|/* now that the slave is detached, unlock and perform&n;&t;&t; * all the undo steps that should not be called from&n;&t;&t; * within a lock.&n;&t;&t; */
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* unset promiscuity level from slave */
r_if
c_cond
(paren
id|master-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|slave_dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|multicast_mode
op_eq
id|BOND_MULTICAST_ALL
)paren
(brace
multiline_comment|/* flush master&squot;s mc_list from slave */
id|bond_mc_list_flush
(paren
id|slave_dev
comma
id|master
)paren
suffix:semicolon
multiline_comment|/* unset allmulti level from slave */
r_if
c_cond
(paren
id|master-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
id|dev_set_allmulti
c_func
(paren
id|slave_dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|netdev_set_master
c_func
(paren
id|slave_dev
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* close slave before restoring its mac address */
id|dev_close
c_func
(paren
id|slave_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|app_abi_ver
op_ge
l_int|1
)paren
(brace
multiline_comment|/* restore original (&quot;permanent&quot;) mac address*/
id|memcpy
c_func
(paren
id|addr.sa_data
comma
id|our_slave-&gt;perm_hwaddr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|addr.sa_family
op_assign
id|slave_dev-&gt;type
suffix:semicolon
id|slave_dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|slave_dev
comma
op_amp
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/* restore the original state of the IFF_NOARP flag that might have&n;&t;&t; * been set by bond_set_slave_inactive_flags()&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|our_slave-&gt;original_flags
op_amp
id|IFF_NOARP
)paren
op_eq
l_int|0
)paren
(brace
id|slave_dev-&gt;flags
op_and_assign
op_complement
id|IFF_NOARP
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|our_slave
)paren
suffix:semicolon
multiline_comment|/* re-acquire the lock before getting the next slave */
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* zero the mac address of the master so it will be&n;&t; * set by the application to the mac address of the&n;&t; * first slave&n;&t; */
id|memset
c_func
(paren
id|master-&gt;dev_addr
comma
l_int|0
comma
id|master-&gt;addr_len
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: released all slaves&bslash;n&quot;
comma
id|master-&gt;name
)paren
suffix:semicolon
id|out
suffix:colon
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* this function is called regularly to monitor each slave&squot;s link. */
DECL|function|bond_mii_monitor
r_static
r_void
id|bond_mii_monitor
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
id|slave_t
op_star
id|slave
comma
op_star
id|bestslave
comma
op_star
id|oldcurrent
suffix:semicolon
r_int
id|slave_died
op_assign
l_int|0
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* we will try to read the link status of each of our slaves, and&n;&t; * set their IFF_RUNNING flag appropriately. For each slave not&n;&t; * supporting MII status, we won&squot;t do anything so that a user-space&n;&t; * program could monitor the link itself if needed.&n;&t; */
id|bestslave
op_assign
l_int|NULL
suffix:semicolon
id|slave
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|oldcurrent
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;prev
)paren
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
multiline_comment|/* use updelay+1 to match an UP slave even when updelay is 0 */
r_int
id|mindelay
op_assign
id|updelay
op_plus
l_int|1
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|slave-&gt;dev
suffix:semicolon
r_int
id|link_state
suffix:semicolon
id|u16
id|old_speed
op_assign
id|slave-&gt;speed
suffix:semicolon
id|u8
id|old_duplex
op_assign
id|slave-&gt;duplex
suffix:semicolon
id|link_state
op_assign
id|bond_check_dev_link
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|slave-&gt;link
)paren
(brace
r_case
id|BOND_LINK_UP
suffix:colon
multiline_comment|/* the link was up */
r_if
c_cond
(paren
id|link_state
op_eq
id|BMSR_LSTATUS
)paren
(brace
multiline_comment|/* link stays up, tell that this one&n;&t;&t;&t;&t;   is immediately available */
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|dev
)paren
op_logical_and
(paren
id|mindelay
OG
op_minus
l_int|2
)paren
)paren
(brace
multiline_comment|/* -2 is the best case :&n;&t;&t;&t;&t;&t;   this slave was already up */
id|mindelay
op_assign
op_minus
l_int|2
suffix:semicolon
id|bestslave
op_assign
id|slave
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* link going down */
id|slave-&gt;link
op_assign
id|BOND_LINK_FAIL
suffix:semicolon
id|slave-&gt;delay
op_assign
id|downdelay
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;link_failure_count
OL
id|UINT_MAX
)paren
(brace
id|slave-&gt;link_failure_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|downdelay
OG
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: link status down for %sinterface &quot;
l_string|&quot;%s, disabling it in %d ms.&bslash;n&quot;
comma
id|master-&gt;name
comma
id|IS_UP
c_func
(paren
id|dev
)paren
ques
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
ques
c_cond
(paren
(paren
id|slave
op_eq
id|oldcurrent
)paren
ques
c_cond
l_string|&quot;active &quot;
suffix:colon
l_string|&quot;backup &quot;
)paren
suffix:colon
l_string|&quot;&quot;
)paren
suffix:colon
l_string|&quot;idle &quot;
comma
id|dev-&gt;name
comma
id|downdelay
op_star
id|miimon
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* no break ! fall through the BOND_LINK_FAIL test to&n;&t;&t;&t;   ensure proper action to be taken&n;&t;&t;&t;*/
r_case
id|BOND_LINK_FAIL
suffix:colon
multiline_comment|/* the link has just gone down */
r_if
c_cond
(paren
id|link_state
op_ne
id|BMSR_LSTATUS
)paren
(brace
multiline_comment|/* link stays down */
r_if
c_cond
(paren
id|slave-&gt;delay
op_le
l_int|0
)paren
(brace
multiline_comment|/* link down for too long time */
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
multiline_comment|/* in active/backup mode, we must&n;&t;&t;&t;&t;&t; * completely disable this interface&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
)paren
(brace
id|bond_set_slave_inactive_flags
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link status definitely down &quot;
l_string|&quot;for interface %s, disabling it&quot;
comma
id|master-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* notify ad that the link status has changed */
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
id|bond_3ad_handle_link_change
c_func
(paren
id|slave
comma
id|BOND_LINK_DOWN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
id|bond_alb_handle_link_change
c_func
(paren
id|bond
comma
id|slave
comma
id|BOND_LINK_DOWN
)paren
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_eq
id|bond-&gt;current_slave
)paren
(brace
multiline_comment|/* find a new interface and be verbose */
id|reselect_active_interface
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|slave_died
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|slave-&gt;delay
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* link up again */
id|slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
id|slave-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link status up again after %d ms &quot;
l_string|&quot;for interface %s.&bslash;n&quot;
comma
id|master-&gt;name
comma
(paren
id|downdelay
op_minus
id|slave-&gt;delay
)paren
op_star
id|miimon
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|dev
)paren
op_logical_and
(paren
id|mindelay
OG
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* -1 is a good case : this slave went&n;&t;&t;&t;&t;&t;   down only for a short time */
id|mindelay
op_assign
op_minus
l_int|1
suffix:semicolon
id|bestslave
op_assign
id|slave
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|BOND_LINK_DOWN
suffix:colon
multiline_comment|/* the link was down */
r_if
c_cond
(paren
id|link_state
op_ne
id|BMSR_LSTATUS
)paren
(brace
multiline_comment|/* the link stays down, nothing more to do */
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* link going up */
id|slave-&gt;link
op_assign
id|BOND_LINK_BACK
suffix:semicolon
id|slave-&gt;delay
op_assign
id|updelay
suffix:semicolon
r_if
c_cond
(paren
id|updelay
OG
l_int|0
)paren
(brace
multiline_comment|/* if updelay == 0, no need to&n;&t;&t;&t;&t;&t;   advertise about a 0 ms delay */
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: link status up for interface&quot;
l_string|&quot; %s, enabling it in %d ms.&bslash;n&quot;
comma
id|master-&gt;name
comma
id|dev-&gt;name
comma
id|updelay
op_star
id|miimon
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* no break ! fall through the BOND_LINK_BACK state in&n;&t;&t;&t;   case there&squot;s something to do.&n;&t;&t;&t;*/
r_case
id|BOND_LINK_BACK
suffix:colon
multiline_comment|/* the link has just come back */
r_if
c_cond
(paren
id|link_state
op_ne
id|BMSR_LSTATUS
)paren
(brace
multiline_comment|/* link down again */
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link status down again after %d ms &quot;
l_string|&quot;for interface %s.&bslash;n&quot;
comma
id|master-&gt;name
comma
(paren
id|updelay
op_minus
id|slave-&gt;delay
)paren
op_star
id|miimon
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* link stays up */
r_if
c_cond
(paren
id|slave-&gt;delay
op_eq
l_int|0
)paren
(brace
multiline_comment|/* now the link has been up for long time enough */
id|slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
id|slave-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
multiline_comment|/* prevent it from being the active one */
id|slave-&gt;state
op_assign
id|BOND_STATE_BACKUP
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bond_mode
op_ne
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
multiline_comment|/* make it immediately active */
id|slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|slave
op_ne
id|bond-&gt;primary_slave
)paren
(brace
multiline_comment|/* prevent it from being the active one */
id|slave-&gt;state
op_assign
id|BOND_STATE_BACKUP
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link status definitely up &quot;
l_string|&quot;for interface %s.&bslash;n&quot;
comma
id|master-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* notify ad that the link status has changed */
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
id|bond_3ad_handle_link_change
c_func
(paren
id|slave
comma
id|BOND_LINK_UP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
id|bond_alb_handle_link_change
c_func
(paren
id|bond
comma
id|slave
comma
id|BOND_LINK_UP
)paren
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bond-&gt;primary_slave
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|slave
op_eq
id|bond-&gt;primary_slave
)paren
)paren
id|reselect_active_interface
c_func
(paren
id|bond
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
r_else
id|slave-&gt;delay
op_decrement
suffix:semicolon
multiline_comment|/* we&squot;ll also look for the mostly eligible slave */
r_if
c_cond
(paren
id|bond-&gt;primary_slave
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|dev
)paren
op_logical_and
(paren
id|slave-&gt;delay
OL
id|mindelay
)paren
)paren
(brace
id|mindelay
op_assign
id|slave-&gt;delay
suffix:semicolon
id|bestslave
op_assign
id|slave
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|IS_UP
c_func
(paren
id|bond-&gt;primary_slave-&gt;dev
)paren
)paren
op_logical_or
(paren
(paren
op_logical_neg
id|IS_UP
c_func
(paren
id|bond-&gt;primary_slave-&gt;dev
)paren
)paren
op_logical_and
(paren
id|IS_UP
c_func
(paren
id|dev
)paren
op_logical_and
(paren
id|slave-&gt;delay
OL
id|mindelay
)paren
)paren
)paren
)paren
(brace
id|mindelay
op_assign
id|slave-&gt;delay
suffix:semicolon
id|bestslave
op_assign
id|slave
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* end of switch */
id|bond_update_speed_duplex
c_func
(paren
id|slave
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
r_if
c_cond
(paren
id|old_speed
op_ne
id|slave-&gt;speed
)paren
(brace
id|bond_3ad_adapter_speed_changed
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_duplex
op_ne
id|slave-&gt;duplex
)paren
(brace
id|bond_3ad_adapter_duplex_changed
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* end of while */
multiline_comment|/* &n;&t; * if there&squot;s no active interface and we discovered that one&n;&t; * of the slaves could be activated earlier, so we do it.&n;&t; */
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|oldcurrent
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
multiline_comment|/* no active interface at the moment or need to bring up the primary */
r_if
c_cond
(paren
id|oldcurrent
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* no active interface at the moment */
r_if
c_cond
(paren
id|bestslave
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* last chance to find one ? */
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|change_active_interface
c_func
(paren
id|bond
comma
id|bestslave
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|slave_died
)paren
(brace
multiline_comment|/* print this message only once a slave has just died */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: now running without any active interface !&bslash;n&quot;
comma
id|master-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* re-arm the timer */
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;mii_timer
comma
id|jiffies
op_plus
(paren
id|miimon
op_star
id|HZ
op_div
l_int|1000
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * this function is called regularly to monitor each slave&squot;s link &n; * ensuring that traffic is being sent and received when arp monitoring&n; * is used in load-balancing mode. if the adapter has been dormant, then an &n; * arp is transmitted to generate traffic. see activebackup_arp_monitor for &n; * arp monitoring in active backup mode. &n; */
DECL|function|loadbalance_arp_monitor
r_static
r_void
id|loadbalance_arp_monitor
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
(brace
id|bonding_t
op_star
id|bond
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
r_int
id|the_delta_in_ticks
op_assign
id|arp_interval
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
r_int
id|next_timer
op_assign
id|jiffies
op_plus
(paren
id|arp_interval
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|master-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
comma
id|next_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* TODO: investigate why rtnl_shlock_nowait and rtnl_exlock_nowait&n;&t; * are called below and add comment why they are required... &n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|IS_UP
c_func
(paren
id|master
)paren
)paren
op_logical_or
id|rtnl_shlock_nowait
c_func
(paren
)paren
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
comma
id|next_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtnl_exlock_nowait
c_func
(paren
)paren
)paren
(brace
id|rtnl_shunlock
c_func
(paren
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
comma
id|next_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* see if any of the previous devices are up now (i.e. they have&n;&t; * xmt and rcv traffic). the current_slave does not come into&n;&t; * the picture unless it is null. also, slave-&gt;jiffies is not needed&n;&t; * here because we send an arp on each slave and give a slave as&n;&t; * long as it needs to get the tx/rx within the delta.&n;&t; * TODO: what about up/down delay in arp mode? it wasn&squot;t here before&n;&t; *       so it can wait &n;&t; */
id|slave
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;prev
)paren
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
r_if
c_cond
(paren
id|slave-&gt;link
op_ne
id|BOND_LINK_UP
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;trans_start
)paren
op_le
id|the_delta_in_ticks
)paren
op_logical_and
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_le
id|the_delta_in_ticks
)paren
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
id|slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
multiline_comment|/* primary_slave has no meaning in round-robin&n;&t;&t;&t;&t; * mode. the window of a slave being up and &n;&t;&t;&t;&t; * current_slave being null after enslaving&n;&t;&t;&t;&t; * is closed.&n;&t;&t;&t;&t; */
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link status definitely up &quot;
l_string|&quot;for interface %s, &quot;
comma
id|master-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
id|reselect_active_interface
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: interface %s is now up&bslash;n&quot;
comma
id|master-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* slave-&gt;link == BOND_LINK_UP */
multiline_comment|/* not all switches will respond to an arp request&n;&t;&t;&t; * when the source ip is 0, so don&squot;t take the link down&n;&t;&t;&t; * if we don&squot;t know our ip yet&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;trans_start
)paren
op_ge
(paren
l_int|2
op_star
id|the_delta_in_ticks
)paren
)paren
op_logical_or
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_ge
(paren
l_int|2
op_star
id|the_delta_in_ticks
)paren
)paren
op_logical_and
id|my_ip
op_ne
l_int|0
)paren
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
id|slave-&gt;state
op_assign
id|BOND_STATE_BACKUP
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;link_failure_count
OL
id|UINT_MAX
)paren
(brace
id|slave-&gt;link_failure_count
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: interface %s is now down.&bslash;n&quot;
comma
id|master-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_eq
id|bond-&gt;current_slave
)paren
(brace
id|reselect_active_interface
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* note: if switch is in round-robin mode, all links &n;&t;&t; * must tx arp to ensure all links rx an arp - otherwise&n;&t;&t; * links may oscillate or not come up at all; if switch is &n;&t;&t; * in something like xor mode, there is nothing we can &n;&t;&t; * do - all replies will be rx&squot;ed on same link causing slaves &n;&t;&t; * to be unstable during low/no traffic periods&n;&t;&t; */
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|slave-&gt;dev
)paren
)paren
(brace
id|arp_send_all
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|rtnl_exunlock
c_func
(paren
)paren
suffix:semicolon
id|rtnl_shunlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* re-arm the timer */
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
comma
id|next_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * When using arp monitoring in active-backup mode, this function is&n; * called to determine if any backup slaves have went down or a new&n; * current slave needs to be found.&n; * The backup slaves never generate traffic, they are considered up by merely &n; * receiving traffic. If the current slave goes down, each backup slave will &n; * be given the opportunity to tx/rx an arp before being taken down - this &n; * prevents all slaves from being taken down due to the current slave not &n; * sending any traffic for the backups to receive. The arps are not necessarily&n; * necessary, any tx and rx traffic will keep the current slave up. While any &n; * rx traffic will keep the backup slaves up, the current slave is responsible &n; * for generating traffic to keep them up regardless of any other traffic they &n; * may have received.&n; * see loadbalance_arp_monitor for arp monitoring in load balancing mode&n; */
DECL|function|activebackup_arp_monitor
r_static
r_void
id|activebackup_arp_monitor
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
(brace
id|bonding_t
op_star
id|bond
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
r_int
id|the_delta_in_ticks
op_assign
id|arp_interval
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
r_int
id|next_timer
op_assign
id|jiffies
op_plus
(paren
id|arp_interval
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|master-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
comma
id|next_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|IS_UP
c_func
(paren
id|master
)paren
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
comma
id|next_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* determine if any slave has come up or any backup slave has &n;&t; * gone down &n;&t; * TODO: what about up/down delay in arp mode? it wasn&squot;t here before&n;&t; *       so it can wait &n;&t; */
id|slave
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;prev
)paren
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
r_if
c_cond
(paren
id|slave-&gt;link
op_ne
id|BOND_LINK_UP
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_le
id|the_delta_in_ticks
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bond-&gt;current_slave
op_eq
l_int|NULL
)paren
op_logical_and
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;trans_start
)paren
op_le
id|the_delta_in_ticks
)paren
)paren
(brace
id|change_active_interface
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_ne
id|slave
)paren
(brace
multiline_comment|/* this slave has just come up but we &n;&t;&t;&t;&t;&t; * already have a current slave; this&n;&t;&t;&t;&t;&t; * can also happen if bond_enslave adds&n;&t;&t;&t;&t;&t; * a new slave that is up while we are &n;&t;&t;&t;&t;&t; * searching for a new slave&n;&t;&t;&t;&t;&t; */
id|bond_set_slave_inactive_flags
c_func
(paren
id|slave
)paren
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slave
op_eq
id|bond-&gt;current_slave
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s is up and now the &quot;
l_string|&quot;active interface&bslash;n&quot;
comma
id|master-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: backup interface %s is &quot;
l_string|&quot;now up&bslash;n&quot;
comma
id|master-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|slave
op_ne
id|bond-&gt;current_slave
)paren
op_logical_and
(paren
id|bond-&gt;current_arp_slave
op_eq
l_int|NULL
)paren
op_logical_and
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_ge
l_int|3
op_star
id|the_delta_in_ticks
)paren
op_logical_and
(paren
id|my_ip
op_ne
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* a backup slave has gone down; three times &n;&t;&t;&t;&t; * the delta allows the current slave to be &n;&t;&t;&t;&t; * taken out before the backup slave.&n;&t;&t;&t;&t; * note: a non-null current_arp_slave indicates&n;&t;&t;&t;&t; * the current_slave went down and we are &n;&t;&t;&t;&t; * searching for a new one; under this &n;&t;&t;&t;&t; * condition we only take the current_slave &n;&t;&t;&t;&t; * down - this gives each slave a chance to &n;&t;&t;&t;&t; * tx/rx traffic before being taken out&n;&t;&t;&t;&t; */
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;link_failure_count
OL
id|UINT_MAX
)paren
(brace
id|slave-&gt;link_failure_count
op_increment
suffix:semicolon
)brace
id|bond_set_slave_inactive_flags
c_func
(paren
id|slave
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: backup interface %s is now down&bslash;n&quot;
comma
id|master-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
)brace
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|slave
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* if we have sent traffic in the past 2*arp_intervals but&n;&t;&t; * haven&squot;t xmit and rx traffic in that time interval, select &n;&t;&t; * a different slave. slave-&gt;jiffies is only updated when&n;&t;&t; * a slave first becomes the current_slave - not necessarily&n;&t;&t; * after every arp; this ensures the slave has a full 2*delta &n;&t;&t; * before being taken out. if a primary is being used, check &n;&t;&t; * if it is up and needs to take over as the current_slave&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;trans_start
)paren
op_ge
(paren
l_int|2
op_star
id|the_delta_in_ticks
)paren
)paren
op_logical_or
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_ge
(paren
l_int|2
op_star
id|the_delta_in_ticks
)paren
)paren
op_logical_and
(paren
id|my_ip
op_ne
l_int|0
)paren
)paren
)paren
op_logical_and
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;jiffies
)paren
op_ge
l_int|2
op_star
id|the_delta_in_ticks
)paren
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;link_failure_count
OL
id|UINT_MAX
)paren
(brace
id|slave-&gt;link_failure_count
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link status down for &quot;
l_string|&quot;active interface %s, disabling it&quot;
comma
id|master-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|reselect_active_interface
c_func
(paren
id|bond
)paren
suffix:semicolon
id|slave
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
id|slave
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_ne
l_int|NULL
)paren
(brace
id|slave-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|bond-&gt;primary_slave
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|bond-&gt;primary_slave
op_ne
id|slave
)paren
op_logical_and
(paren
id|bond-&gt;primary_slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
)paren
(brace
multiline_comment|/* at this point, slave is the current_slave */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: changing from interface %s to primary &quot;
l_string|&quot;interface %s&bslash;n&quot;
comma
id|master-&gt;name
comma
id|slave-&gt;dev-&gt;name
comma
id|bond-&gt;primary_slave-&gt;dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* primary is up so switch to it */
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|change_active_interface
c_func
(paren
id|bond
comma
id|bond-&gt;primary_slave
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|slave
op_assign
id|bond-&gt;primary_slave
suffix:semicolon
id|slave-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
)brace
r_else
(brace
id|bond-&gt;current_arp_slave
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* the current slave must tx an arp to ensure backup slaves&n;&t;&t; * rx traffic&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|slave
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|my_ip
op_ne
l_int|0
)paren
)paren
(brace
id|arp_send_all
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* if we don&squot;t have a current_slave, search for the next available &n;&t; * backup slave from the current_arp_slave and make it the candidate &n;&t; * for becoming the current_slave&n;&t; */
r_if
c_cond
(paren
id|slave
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|bond-&gt;current_arp_slave
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|bond-&gt;current_arp_slave
op_eq
(paren
id|slave_t
op_star
)paren
id|bond
)paren
)paren
(brace
id|bond-&gt;current_arp_slave
op_assign
id|bond-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;current_arp_slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
id|bond_set_slave_inactive_flags
c_func
(paren
id|bond-&gt;current_arp_slave
)paren
suffix:semicolon
id|slave
op_assign
id|bond-&gt;current_arp_slave-&gt;next
suffix:semicolon
multiline_comment|/* search for next candidate */
r_do
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|slave-&gt;dev
)paren
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_BACK
suffix:semicolon
id|bond_set_slave_active_flags
c_func
(paren
id|slave
)paren
suffix:semicolon
id|arp_send_all
c_func
(paren
id|slave
)paren
suffix:semicolon
id|slave-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
id|slave
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* if the link state is up at this point, we &n;&t;&t;&t;&t; * mark it down - this can happen if we have &n;&t;&t;&t;&t; * simultaneous link failures and &n;&t;&t;&t;&t; * reselect_active_interface doesn&squot;t make this &n;&t;&t;&t;&t; * one the current slave so it is still marked &n;&t;&t;&t;&t; * up when it is actually down&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;link_failure_count
OL
id|UINT_MAX
)paren
(brace
id|slave-&gt;link_failure_count
op_increment
suffix:semicolon
)brace
id|bond_set_slave_inactive_flags
c_func
(paren
id|slave
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: backup interface &quot;
l_string|&quot;%s is now down.&bslash;n&quot;
comma
id|master-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;next
)paren
op_ne
id|bond-&gt;current_arp_slave-&gt;next
)paren
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
comma
id|next_timer
)paren
suffix:semicolon
)brace
DECL|function|bond_sethwaddr
r_static
r_int
id|bond_sethwaddr
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|net_device
op_star
id|slave
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;bond_sethwaddr: master=%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|master
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;bond_sethwaddr: slave=%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|slave
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;bond_sethwaddr: slave-&gt;addr_len=%d&bslash;n&quot;
comma
id|slave-&gt;addr_len
)paren
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|master-&gt;dev_addr
comma
id|slave-&gt;dev_addr
comma
id|slave-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_info_query
r_static
r_int
id|bond_info_query
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|ifbond
op_star
id|info
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
id|info-&gt;bond_mode
op_assign
id|bond_mode
suffix:semicolon
id|info-&gt;num_slaves
op_assign
l_int|0
suffix:semicolon
id|info-&gt;miimon
op_assign
id|miimon
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
(brace
id|info-&gt;num_slaves
op_increment
suffix:semicolon
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_slave_info_query
r_static
r_int
id|bond_slave_info_query
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|ifslave
op_star
id|info
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
r_int
id|cur_ndx
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;slave_id
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|read_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
op_logical_and
id|cur_ndx
OL
id|info-&gt;slave_id
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
(brace
id|cur_ndx
op_increment
suffix:semicolon
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
id|strcpy
c_func
(paren
id|info-&gt;slave_name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
id|info-&gt;link
op_assign
id|slave-&gt;link
suffix:semicolon
id|info-&gt;state
op_assign
id|slave-&gt;state
suffix:semicolon
id|info-&gt;link_failure_count
op_assign
id|slave-&gt;link_failure_count
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_ethtool_ioctl
r_static
r_int
id|bond_ethtool_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|master_dev
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_void
op_star
id|addr
op_assign
id|ifr-&gt;ifr_data
suffix:semicolon
r_uint32
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|cmd
comma
(paren
r_uint32
op_star
)paren
id|addr
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|ETHTOOL_GDRVINFO
suffix:colon
(brace
r_struct
id|ethtool_drvinfo
id|info
suffix:semicolon
r_char
op_star
id|endptr
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
id|addr
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|info.driver
comma
l_string|&quot;ifenslave&quot;
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|new_abi_ver
suffix:semicolon
id|new_abi_ver
op_assign
id|simple_strtoul
c_func
(paren
id|info.fw_version
comma
op_amp
id|endptr
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|endptr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bonding: Error: got invalid ABI&quot;
l_string|&quot; version from application&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|orig_app_abi_ver
op_eq
op_minus
l_int|1
)paren
(brace
id|orig_app_abi_ver
op_assign
id|new_abi_ver
suffix:semicolon
)brace
id|app_abi_ver
op_assign
id|new_abi_ver
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|info.driver
comma
id|DRV_NAME
comma
l_int|32
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info.version
comma
id|DRV_VERSION
comma
l_int|32
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|info.fw_version
comma
l_int|32
comma
l_string|&quot;%d&quot;
comma
id|BOND_ABI_VERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|addr
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
DECL|function|bond_ioctl
r_static
r_int
id|bond_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|master_dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_struct
id|net_device
op_star
id|slave_dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ifbond
op_star
id|u_binfo
op_assign
l_int|NULL
comma
id|k_binfo
suffix:semicolon
r_struct
id|ifslave
op_star
id|u_sinfo
op_assign
l_int|NULL
comma
id|k_sinfo
suffix:semicolon
r_struct
id|mii_ioctl_data
op_star
id|mii
op_assign
l_int|NULL
suffix:semicolon
r_int
id|prev_abi_ver
op_assign
id|orig_app_abi_ver
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;bond_ioctl: master=%s, cmd=%d&bslash;n&quot;
comma
id|master_dev-&gt;name
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCETHTOOL
suffix:colon
r_return
id|bond_ethtool_ioctl
c_func
(paren
id|master_dev
comma
id|ifr
)paren
suffix:semicolon
r_case
id|SIOCGMIIPHY
suffix:colon
id|mii
op_assign
(paren
r_struct
id|mii_ioctl_data
op_star
)paren
op_amp
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
id|mii
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mii-&gt;phy_id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fall Through */
r_case
id|SIOCGMIIREG
suffix:colon
multiline_comment|/* &n;&t;&t; * We do this again just in case we were called by SIOCGMIIREG&n;&t;&t; * instead of SIOCGMIIPHY.&n;&t;&t; */
id|mii
op_assign
(paren
r_struct
id|mii_ioctl_data
op_star
)paren
op_amp
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
id|mii
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mii-&gt;reg_num
op_eq
l_int|1
)paren
(brace
id|mii-&gt;val_out
op_assign
id|bond_check_mii_link
c_func
(paren
(paren
r_struct
id|bonding
op_star
)paren
id|master_dev-&gt;priv
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|BOND_INFO_QUERY_OLD
suffix:colon
r_case
id|SIOCBONDINFOQUERY
suffix:colon
id|u_binfo
op_assign
(paren
r_struct
id|ifbond
op_star
)paren
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|k_binfo
comma
id|u_binfo
comma
r_sizeof
(paren
id|ifbond
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|ret
op_assign
id|bond_info_query
c_func
(paren
id|master_dev
comma
op_amp
id|k_binfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|u_binfo
comma
op_amp
id|k_binfo
comma
r_sizeof
(paren
id|ifbond
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
r_case
id|BOND_SLAVE_INFO_QUERY_OLD
suffix:colon
r_case
id|SIOCBONDSLAVEINFOQUERY
suffix:colon
id|u_sinfo
op_assign
(paren
r_struct
id|ifslave
op_star
)paren
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|k_sinfo
comma
id|u_sinfo
comma
r_sizeof
(paren
id|ifslave
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|ret
op_assign
id|bond_slave_info_query
c_func
(paren
id|master_dev
comma
op_amp
id|k_sinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|u_sinfo
comma
op_amp
id|k_sinfo
comma
r_sizeof
(paren
id|ifslave
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|orig_app_abi_ver
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* no orig_app_abi_ver was provided yet, so we&squot;ll use the&n;&t;&t; * current one from now on, even if it&squot;s 0&n;&t;&t; */
id|orig_app_abi_ver
op_assign
id|app_abi_ver
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|orig_app_abi_ver
op_ne
id|app_abi_ver
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bonding: Error: already using ifenslave ABI &quot;
l_string|&quot;version %d; to upgrade ifenslave to version %d, &quot;
l_string|&quot;you must first reload bonding.&bslash;n&quot;
comma
id|orig_app_abi_ver
comma
id|app_abi_ver
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|slave_dev
op_assign
id|dev_get_by_name
c_func
(paren
id|ifr-&gt;ifr_slave
)paren
suffix:semicolon
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;slave_dev=%x: &bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|slave_dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;slave_dev-&gt;name=%s: &bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|slave_dev
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BOND_ENSLAVE_OLD
suffix:colon
r_case
id|SIOCBONDENSLAVE
suffix:colon
id|ret
op_assign
id|bond_enslave
c_func
(paren
id|master_dev
comma
id|slave_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_RELEASE_OLD
suffix:colon
r_case
id|SIOCBONDRELEASE
suffix:colon
id|ret
op_assign
id|bond_release
c_func
(paren
id|master_dev
comma
id|slave_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_SETHWADDR_OLD
suffix:colon
r_case
id|SIOCBONDSETHWADDR
suffix:colon
id|ret
op_assign
id|bond_sethwaddr
c_func
(paren
id|master_dev
comma
id|slave_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_CHANGE_ACTIVE_OLD
suffix:colon
r_case
id|SIOCBONDCHANGEACTIVE
suffix:colon
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|ret
op_assign
id|bond_change_active
c_func
(paren
id|master_dev
comma
id|slave_dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|dev_put
c_func
(paren
id|slave_dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* The ioctl failed, so there&squot;s no point in changing the&n;&t;&t; * orig_app_abi_ver. We&squot;ll restore it&squot;s value just in case&n;&t;&t; * we&squot;ve changed it earlier in this function.&n;&t;&t; */
id|orig_app_abi_ver
op_assign
id|prev_abi_ver
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_FASTROUTE
DECL|function|bond_accept_fastpath
r_static
r_int
id|bond_accept_fastpath
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n; * in broadcast mode, we send everything to all usable interfaces.&n; */
DECL|function|bond_xmit_broadcast
r_static
r_int
id|bond_xmit_broadcast
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|slave_t
op_star
id|slave
comma
op_star
id|start_at
suffix:semicolon
r_struct
id|bonding
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|net_device
op_star
id|device_we_should_send_to
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_UP
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* bond down */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|slave
op_assign
id|start_at
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* we&squot;re at the root, get the first slave */
multiline_comment|/* no suitable interface, frame not sent */
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_do
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|slave-&gt;dev
)paren
op_logical_and
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
op_logical_and
(paren
id|slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
)paren
)paren
(brace
r_if
c_cond
(paren
id|device_we_should_send_to
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bond_xmit_broadcast: skb_clone() failed&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|skb2-&gt;dev
op_assign
id|device_we_should_send_to
suffix:semicolon
id|skb2-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb2
)paren
suffix:semicolon
)brace
id|device_we_should_send_to
op_assign
id|slave-&gt;dev
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;next
)paren
op_ne
id|start_at
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device_we_should_send_to
)paren
(brace
id|skb-&gt;dev
op_assign
id|device_we_should_send_to
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* frame sent to all suitable interfaces */
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_xmit_roundrobin
r_static
r_int
id|bond_xmit_roundrobin
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|slave_t
op_star
id|slave
comma
op_star
id|start_at
suffix:semicolon
r_struct
id|bonding
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_UP
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* bond down */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|slave
op_assign
id|start_at
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* we&squot;re at the root, get the first slave */
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_do
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|slave-&gt;dev
)paren
op_logical_and
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
op_logical_and
(paren
id|slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
)paren
)paren
(brace
id|skb-&gt;dev
op_assign
id|slave-&gt;dev
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond-&gt;current_slave
op_assign
id|slave-&gt;next
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;next
)paren
op_ne
id|start_at
)paren
suffix:semicolon
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * in XOR mode, we determine the output device by performing xor on&n; * the source and destination hw adresses.  If this device is not &n; * enabled, find the next slave following this xor slave. &n; */
DECL|function|bond_xmit_xor
r_static
r_int
id|bond_xmit_xor
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|slave_t
op_star
id|slave
comma
op_star
id|start_at
suffix:semicolon
r_struct
id|bonding
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ethhdr
op_star
id|data
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
r_int
id|slave_no
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_UP
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* bond down */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
multiline_comment|/* we&squot;re at the root, get the first slave */
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
op_eq
l_int|0
)paren
(brace
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|slave_no
op_assign
(paren
id|data-&gt;h_dest
(braket
l_int|5
)braket
op_xor
id|slave-&gt;dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
op_mod
id|bond-&gt;slave_cnt
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slave_no
OG
l_int|0
)paren
op_logical_and
(paren
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
)paren
(brace
id|slave
op_assign
id|slave-&gt;prev
suffix:semicolon
id|slave_no
op_decrement
suffix:semicolon
)brace
id|start_at
op_assign
id|slave
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|slave-&gt;dev
)paren
op_logical_and
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
op_logical_and
(paren
id|slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
)paren
)paren
(brace
id|skb-&gt;dev
op_assign
id|slave-&gt;dev
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;next
)paren
op_ne
id|start_at
)paren
suffix:semicolon
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * in active-backup mode, we know that bond-&gt;current_slave is always valid if&n; * the bond has a usable interface.&n; */
DECL|function|bond_xmit_activebackup
r_static
r_int
id|bond_xmit_activebackup
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_UP
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* bond down */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if we are sending arp packets, try to at least &n;&t;   identify our own ip address */
r_if
c_cond
(paren
(paren
id|arp_interval
OG
l_int|0
)paren
op_logical_and
(paren
id|my_ip
op_eq
l_int|0
)paren
op_logical_and
(paren
id|skb-&gt;protocol
op_eq
id|__constant_htons
c_func
(paren
id|ETH_P_ARP
)paren
)paren
)paren
(brace
r_char
op_star
id|the_ip
op_assign
(paren
(paren
(paren
r_char
op_star
)paren
id|skb-&gt;data
)paren
)paren
op_plus
r_sizeof
(paren
r_struct
id|ethhdr
)paren
op_plus
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
id|ETH_ALEN
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|my_ip
comma
id|the_ip
comma
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* if we are sending arp packets and don&squot;t know &n;&t; * the target hw address, save it so we don&squot;t need &n;&t; * to use a broadcast address.&n;&t; * don&squot;t do this if in active backup mode because the slaves must &n;&t; * receive packets to stay up, and the only ones they receive are &n;&t; * broadcasts. &n;&t; */
r_if
c_cond
(paren
(paren
id|bond_mode
op_ne
id|BOND_MODE_ACTIVEBACKUP
)paren
op_logical_and
(paren
id|arp_ip_count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|arp_interval
OG
l_int|0
)paren
op_logical_and
(paren
id|arp_target_hw_addr
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|skb-&gt;protocol
op_eq
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
)paren
(brace
r_struct
id|ethhdr
op_star
id|eth_hdr
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|skb-&gt;data
)paren
)paren
suffix:semicolon
r_struct
id|iphdr
op_star
id|ip_hdr
op_assign
(paren
r_struct
id|iphdr
op_star
)paren
(paren
id|eth_hdr
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp_target
(braket
l_int|0
)braket
op_eq
id|ip_hdr-&gt;daddr
)paren
(brace
id|arp_target_hw_addr
op_assign
id|kmalloc
c_func
(paren
id|ETH_ALEN
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp_target_hw_addr
op_ne
l_int|NULL
)paren
id|memcpy
c_func
(paren
id|arp_target_hw_addr
comma
id|eth_hdr-&gt;h_dest
comma
id|ETH_ALEN
)paren
suffix:semicolon
)brace
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* one usable interface */
id|skb-&gt;dev
op_assign
id|bond-&gt;current_slave-&gt;dev
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
multiline_comment|/* no suitable interface, frame not sent */
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;There was no suitable interface, so we don&squot;t transmit&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|bond_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|stats
op_assign
op_amp
(paren
id|bond-&gt;stats
)paren
comma
op_star
id|sstats
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
id|memset
c_func
(paren
id|stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
)paren
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
(brace
id|sstats
op_assign
id|slave-&gt;dev
op_member_access_from_pointer
id|get_stats
c_func
(paren
id|slave-&gt;dev
)paren
suffix:semicolon
id|stats-&gt;rx_packets
op_add_assign
id|sstats-&gt;rx_packets
suffix:semicolon
id|stats-&gt;rx_bytes
op_add_assign
id|sstats-&gt;rx_bytes
suffix:semicolon
id|stats-&gt;rx_errors
op_add_assign
id|sstats-&gt;rx_errors
suffix:semicolon
id|stats-&gt;rx_dropped
op_add_assign
id|sstats-&gt;rx_dropped
suffix:semicolon
id|stats-&gt;tx_packets
op_add_assign
id|sstats-&gt;tx_packets
suffix:semicolon
id|stats-&gt;tx_bytes
op_add_assign
id|sstats-&gt;tx_bytes
suffix:semicolon
id|stats-&gt;tx_errors
op_add_assign
id|sstats-&gt;tx_errors
suffix:semicolon
id|stats-&gt;tx_dropped
op_add_assign
id|sstats-&gt;tx_dropped
suffix:semicolon
id|stats-&gt;multicast
op_add_assign
id|sstats-&gt;multicast
suffix:semicolon
id|stats-&gt;collisions
op_add_assign
id|sstats-&gt;collisions
suffix:semicolon
id|stats-&gt;rx_length_errors
op_add_assign
id|sstats-&gt;rx_length_errors
suffix:semicolon
id|stats-&gt;rx_over_errors
op_add_assign
id|sstats-&gt;rx_over_errors
suffix:semicolon
id|stats-&gt;rx_crc_errors
op_add_assign
id|sstats-&gt;rx_crc_errors
suffix:semicolon
id|stats-&gt;rx_frame_errors
op_add_assign
id|sstats-&gt;rx_frame_errors
suffix:semicolon
id|stats-&gt;rx_fifo_errors
op_add_assign
id|sstats-&gt;rx_fifo_errors
suffix:semicolon
id|stats-&gt;rx_missed_errors
op_add_assign
id|sstats-&gt;rx_missed_errors
suffix:semicolon
id|stats-&gt;tx_aborted_errors
op_add_assign
id|sstats-&gt;tx_aborted_errors
suffix:semicolon
id|stats-&gt;tx_carrier_errors
op_add_assign
id|sstats-&gt;tx_carrier_errors
suffix:semicolon
id|stats-&gt;tx_fifo_errors
op_add_assign
id|sstats-&gt;tx_fifo_errors
suffix:semicolon
id|stats-&gt;tx_heartbeat_errors
op_add_assign
id|sstats-&gt;tx_heartbeat_errors
suffix:semicolon
id|stats-&gt;tx_window_errors
op_add_assign
id|sstats-&gt;tx_window_errors
suffix:semicolon
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
id|stats
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|bond_read_proc
r_static
r_int
id|bond_read_proc
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|data
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|u16
id|link
suffix:semicolon
id|slave_t
op_star
id|slave
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* make sure the bond won&squot;t be taken away */
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|version
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This function locks the mutex, so we can&squot;t lock it until&n;&t; * afterwards&n;&t; */
id|link
op_assign
id|bond_check_mii_link
c_func
(paren
id|bond
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Bonding Mode: %s&bslash;n&quot;
comma
id|bond_mode_name
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|read_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_ne
l_int|NULL
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Currently Active Slave: %s&bslash;n&quot;
comma
id|bond-&gt;current_slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;MII Status: &quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
id|link
op_eq
id|BMSR_LSTATUS
ques
c_cond
l_string|&quot;up&bslash;n&quot;
suffix:colon
l_string|&quot;down&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;MII Polling Interval (ms): %d&bslash;n&quot;
comma
id|miimon
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Up Delay (ms): %d&bslash;n&quot;
comma
id|updelay
op_star
id|miimon
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Down Delay (ms): %d&bslash;n&quot;
comma
id|downdelay
op_star
id|miimon
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Multicast Mode: %s&bslash;n&quot;
comma
id|multicast_mode_name
c_func
(paren
)paren
)paren
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
r_struct
id|ad_info
id|ad_info
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n802.3ad info&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_3ad_get_active_agg_info
c_func
(paren
id|bond
comma
op_amp
id|ad_info
)paren
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;bond %s has no active aggregator&bslash;n&quot;
comma
id|bond-&gt;device-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Active Aggregator Info:&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;tAggregator ID: %d&bslash;n&quot;
comma
id|ad_info.aggregator_id
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;tNumber of ports: %d&bslash;n&quot;
comma
id|ad_info.ports
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;tActor Key: %d&bslash;n&quot;
comma
id|ad_info.actor_key
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;tPartner Key: %d&bslash;n&quot;
comma
id|ad_info.partner_key
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;tPartner Mac Address: %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|ad_info.partner_system
(braket
l_int|0
)braket
comma
id|ad_info.partner_system
(braket
l_int|1
)braket
comma
id|ad_info.partner_system
(braket
l_int|2
)braket
comma
id|ad_info.partner_system
(braket
l_int|3
)braket
comma
id|ad_info.partner_system
(braket
l_int|4
)braket
comma
id|ad_info.partner_system
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;nSlave Interface: %s&bslash;n&quot;
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;MII Status: &quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
ques
c_cond
l_string|&quot;up&bslash;n&quot;
suffix:colon
l_string|&quot;down&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Link Failure Count: %d&bslash;n&quot;
comma
id|slave-&gt;link_failure_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|app_abi_ver
op_ge
l_int|1
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Permanent HW addr: %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|0
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|1
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|2
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|3
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|4
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
r_struct
id|aggregator
op_star
id|agg
op_assign
id|SLAVE_AD_INFO
c_func
(paren
id|slave
)paren
dot
id|port.aggregator
suffix:semicolon
r_if
c_cond
(paren
id|agg
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Aggregator ID: %d&bslash;n&quot;
comma
id|agg-&gt;aggregator_identifier
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Aggregator ID: N/A&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Figure out the calcs for the /proc/net interface&n;&t; */
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
(brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|start
op_assign
id|buf
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
(brace
id|len
op_assign
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
DECL|function|bond_event
r_static
r_int
id|bond_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|net_device
op_star
id|event_dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|ptr
suffix:semicolon
r_struct
id|net_device
op_star
id|master
op_assign
id|event_dev-&gt;master
suffix:semicolon
r_if
c_cond
(paren
(paren
id|event
op_eq
id|NETDEV_UNREGISTER
)paren
op_logical_and
(paren
id|master
op_ne
l_int|NULL
)paren
)paren
(brace
id|bond_release
c_func
(paren
id|master
comma
id|event_dev
)paren
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|bond_netdev_notifier
r_static
r_struct
id|notifier_block
id|bond_netdev_notifier
op_assign
(brace
dot
id|notifier_call
op_assign
id|bond_event
comma
)brace
suffix:semicolon
DECL|function|bond_deinit
r_static
r_void
id|bond_deinit
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|dev-&gt;priv
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|bond-&gt;bond_list
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|remove_proc_entry
c_func
(paren
l_string|&quot;info&quot;
comma
id|bond-&gt;bond_proc_dir
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|dev-&gt;name
comma
id|proc_net
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|bond_free_all
r_static
r_void
id|bond_free_all
c_func
(paren
r_void
)paren
(brace
r_struct
id|bonding
op_star
id|bond
comma
op_star
id|nxt
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|bond
comma
id|nxt
comma
op_amp
id|bond_dev_list
comma
id|bond_list
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|bond-&gt;device
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|bond_deinit
c_func
(paren
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
DECL|function|bond_init
r_static
r_int
id|__init
id|bond_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
suffix:semicolon
r_int
id|count
suffix:semicolon
macro_line|#ifdef BONDING_DEBUG
id|printk
(paren
id|KERN_INFO
l_string|&quot;Begin bond_init for %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|bond
op_assign
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* initialize rwlocks */
id|rwlock_init
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond-&gt;next
op_assign
id|bond-&gt;prev
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|bond-&gt;current_slave
op_assign
l_int|NULL
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
l_int|NULL
suffix:semicolon
id|bond-&gt;device
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
r_switch
c_cond
(paren
id|bond_mode
)paren
(brace
r_case
id|BOND_MODE_ACTIVEBACKUP
suffix:colon
id|dev-&gt;hard_start_xmit
op_assign
id|bond_xmit_activebackup
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MODE_ROUNDROBIN
suffix:colon
id|dev-&gt;hard_start_xmit
op_assign
id|bond_xmit_roundrobin
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MODE_XOR
suffix:colon
id|dev-&gt;hard_start_xmit
op_assign
id|bond_xmit_xor
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MODE_BROADCAST
suffix:colon
id|dev-&gt;hard_start_xmit
op_assign
id|bond_xmit_broadcast
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MODE_8023AD
suffix:colon
id|dev-&gt;hard_start_xmit
op_assign
id|bond_3ad_xmit_xor
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MODE_TLB
suffix:colon
r_case
id|BOND_MODE_ALB
suffix:colon
id|dev-&gt;hard_start_xmit
op_assign
id|bond_alb_xmit
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unknown bonding mode %d&bslash;n&quot;
comma
id|bond_mode
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev-&gt;get_stats
op_assign
id|bond_get_stats
suffix:semicolon
id|dev-&gt;open
op_assign
id|bond_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|bond_close
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|set_multicast_list
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|bond_ioctl
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_MASTER
op_or
id|IFF_MULTICAST
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
id|dev-&gt;accept_fastpath
op_assign
id|bond_accept_fastpath
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s registered with&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|miimon
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; MII link monitoring set to %d ms&quot;
comma
id|miimon
)paren
suffix:semicolon
id|updelay
op_div_assign
id|miimon
suffix:semicolon
id|downdelay
op_div_assign
id|miimon
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;out MII link monitoring&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;, in %s mode.&bslash;n&quot;
comma
id|bond_mode_name
c_func
(paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s registered with&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp_interval
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; ARP monitoring set to %d ms with %d target(s):&quot;
comma
id|arp_interval
comma
id|arp_ip_count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|arp_ip_count
suffix:semicolon
id|count
op_increment
)paren
id|printk
(paren
l_string|&quot; %s&quot;
comma
id|arp_ip_target
(braket
id|count
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;out ARP monitoring&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
id|bond-&gt;bond_proc_dir
op_assign
id|proc_mkdir
c_func
(paren
id|dev-&gt;name
comma
id|proc_net
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;bond_proc_dir
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Cannot init /proc/net/%s/&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|bond-&gt;bond_proc_dir-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|bond-&gt;bond_proc_info_file
op_assign
id|create_proc_read_entry
c_func
(paren
l_string|&quot;info&quot;
comma
l_int|0
comma
id|bond-&gt;bond_proc_dir
comma
id|bond_read_proc
comma
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;bond_proc_info_file
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Cannot init /proc/net/%s/info&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|dev-&gt;name
comma
id|proc_net
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|bond-&gt;bond_proc_info_file-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
id|list_add_tail
c_func
(paren
op_amp
id|bond-&gt;bond_list
comma
op_amp
id|bond_dev_list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;static int __init bond_probe(struct net_device *dev)&n;{&n;&t;bond_init(dev);&n;&t;return 0;&n;}&n; */
multiline_comment|/*&n; * Convert string input module parms.  Accept either the&n; * number of the mode or its string name.&n; */
r_static
r_inline
r_int
DECL|function|bond_parse_parm
id|bond_parse_parm
c_func
(paren
r_char
op_star
id|mode_arg
comma
r_struct
id|bond_parm_tbl
op_star
id|tbl
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|tbl
(braket
id|i
)braket
dot
id|modename
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|isdigit
c_func
(paren
op_star
id|mode_arg
)paren
op_logical_and
id|tbl
(braket
id|i
)braket
dot
id|mode
op_eq
id|simple_strtol
c_func
(paren
id|mode_arg
comma
l_int|NULL
comma
l_int|0
)paren
)paren
op_logical_or
(paren
l_int|0
op_eq
id|strncmp
c_func
(paren
id|mode_arg
comma
id|tbl
(braket
id|i
)braket
dot
id|modename
comma
id|strlen
c_func
(paren
id|tbl
(braket
id|i
)braket
dot
id|modename
)paren
)paren
)paren
)paren
(brace
r_return
id|tbl
(braket
id|i
)braket
dot
id|mode
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|bonding_init
r_static
r_int
id|__init
id|bonding_init
c_func
(paren
r_void
)paren
(brace
r_int
id|no
suffix:semicolon
r_int
id|err
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert string parameters.&n;&t; */
r_if
c_cond
(paren
id|mode
)paren
(brace
id|bond_mode
op_assign
id|bond_parse_parm
c_func
(paren
id|mode
comma
id|bond_mode_tbl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): Invalid bonding mode &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|mode
op_eq
l_int|NULL
ques
c_cond
l_string|&quot;NULL&quot;
suffix:colon
id|mode
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|multicast_mode
op_assign
id|BOND_MULTICAST_ACTIVE
suffix:semicolon
)brace
r_else
(brace
id|multicast_mode
op_assign
id|BOND_MULTICAST_ALL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|multicast
)paren
(brace
id|multicast_mode
op_assign
id|bond_parse_parm
c_func
(paren
id|multicast
comma
id|bond_mc_tbl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|multicast_mode
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): Invalid multicast mode &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|multicast
op_eq
l_int|NULL
ques
c_cond
l_string|&quot;NULL&quot;
suffix:colon
id|multicast
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lacp_rate
)paren
(brace
r_if
c_cond
(paren
id|bond_mode
op_ne
id|BOND_MODE_8023AD
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;lacp_rate param is irrelevant in mode %s&bslash;n&quot;
comma
id|bond_mode_name
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|lacp_fast
op_assign
id|bond_parse_parm
c_func
(paren
id|lacp_rate
comma
id|bond_lacp_tbl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lacp_fast
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): Invalid lacp rate &quot;
l_string|&quot;&bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|lacp_rate
op_eq
l_int|NULL
ques
c_cond
l_string|&quot;NULL&quot;
suffix:colon
id|lacp_rate
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|max_bonds
template_param
id|INT_MAX
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): max_bonds (%d) not in range %d-%d, &quot;
l_string|&quot;so it was reset to BOND_DEFAULT_MAX_BONDS (%d)&quot;
comma
id|max_bonds
comma
l_int|1
comma
id|INT_MAX
comma
id|BOND_DEFAULT_MAX_BONDS
)paren
suffix:semicolon
id|max_bonds
op_assign
id|BOND_DEFAULT_MAX_BONDS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|miimon
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): miimon module parameter (%d), &quot;
l_string|&quot;not in range 0-%d, so it was reset to %d&bslash;n&quot;
comma
id|miimon
comma
id|INT_MAX
comma
id|BOND_LINK_MON_INTERV
)paren
suffix:semicolon
id|miimon
op_assign
id|BOND_LINK_MON_INTERV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|updelay
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): updelay module parameter (%d), &quot;
l_string|&quot;not in range 0-%d, so it was reset to 0&bslash;n&quot;
comma
id|updelay
comma
id|INT_MAX
)paren
suffix:semicolon
id|updelay
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|downdelay
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): downdelay module parameter (%d), &quot;
l_string|&quot;not in range 0-%d, so it was reset to 0&bslash;n&quot;
comma
id|downdelay
comma
id|INT_MAX
)paren
suffix:semicolon
id|downdelay
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* reset values for 802.3ad */
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
r_if
c_cond
(paren
id|arp_interval
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): ARP monitoring&quot;
l_string|&quot;can&squot;t be used simultaneously with 802.3ad, &quot;
l_string|&quot;disabling ARP monitoring&bslash;n&quot;
)paren
suffix:semicolon
id|arp_interval
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|miimon
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bonding_init(): miimon must be specified, &quot;
l_string|&quot;otherwise bonding will not detect link failure, &quot;
l_string|&quot;speed and duplex which are essential &quot;
l_string|&quot;for 802.3ad operation&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Forcing miimon to 100msec&bslash;n&quot;
)paren
suffix:semicolon
id|miimon
op_assign
l_int|100
suffix:semicolon
)brace
r_if
c_cond
(paren
id|multicast_mode
op_ne
id|BOND_MULTICAST_ALL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bonding_init(): Multicast mode must &quot;
l_string|&quot;be set to ALL for 802.3ad&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Forcing Multicast mode to ALL&bslash;n&quot;
)paren
suffix:semicolon
id|multicast_mode
op_assign
id|BOND_MULTICAST_ALL
suffix:semicolon
)brace
)brace
multiline_comment|/* reset values for TLB/ALB */
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
r_if
c_cond
(paren
id|miimon
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bonding_init(): miimon must be specified, &quot;
l_string|&quot;otherwise bonding will not detect link failure &quot;
l_string|&quot;and link speed which are essential &quot;
l_string|&quot;for TLB/ALB load balancing&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Forcing miimon to 100msec&bslash;n&quot;
)paren
suffix:semicolon
id|miimon
op_assign
l_int|100
suffix:semicolon
)brace
r_if
c_cond
(paren
id|multicast_mode
op_ne
id|BOND_MULTICAST_ACTIVE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bonding_init(): Multicast mode must &quot;
l_string|&quot;be set to ACTIVE for TLB/ALB&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Forcing Multicast mode to ACTIVE&bslash;n&quot;
)paren
suffix:semicolon
id|multicast_mode
op_assign
id|BOND_MULTICAST_ACTIVE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;In ALB mode you might experience client disconnections&quot;
l_string|&quot; upon reconnection of a link if the bonding module&quot;
l_string|&quot; updelay parameter (%d msec) is incompatible with the&quot;
l_string|&quot; forwarding delay time of the switch&bslash;n&quot;
comma
id|updelay
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|miimon
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|updelay
op_ne
l_int|0
)paren
op_logical_or
(paren
id|downdelay
op_ne
l_int|0
)paren
)paren
(brace
multiline_comment|/* just warn the user the up/down delay will have&n;&t;&t;&t; * no effect since miimon is zero...&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): miimon module parameter not &quot;
l_string|&quot;set and updelay (%d) or downdelay (%d) module &quot;
l_string|&quot;parameter is set; updelay and downdelay have &quot;
l_string|&quot;no effect unless miimon is set&bslash;n&quot;
comma
id|updelay
comma
id|downdelay
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* don&squot;t allow arp monitoring */
r_if
c_cond
(paren
id|arp_interval
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): miimon (%d) and arp_interval &quot;
l_string|&quot;(%d) can&squot;t be used simultaneously, &quot;
l_string|&quot;disabling ARP monitoring&bslash;n&quot;
comma
id|miimon
comma
id|arp_interval
)paren
suffix:semicolon
id|arp_interval
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|updelay
op_mod
id|miimon
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* updelay will be rounded in bond_init() when it&n;&t;&t;&t; * is divided by miimon, we just inform user here&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): updelay (%d) is not a multiple &quot;
l_string|&quot;of miimon (%d), updelay rounded to %d ms&bslash;n&quot;
comma
id|updelay
comma
id|miimon
comma
(paren
id|updelay
op_div
id|miimon
)paren
op_star
id|miimon
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|downdelay
op_mod
id|miimon
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* downdelay will be rounded in bond_init() when it&n;&t;&t;&t; * is divided by miimon, we just inform user here&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): downdelay (%d) is not a &quot;
l_string|&quot;multiple of miimon (%d), downdelay rounded &quot;
l_string|&quot;to %d ms&bslash;n&quot;
comma
id|downdelay
comma
id|miimon
comma
(paren
id|downdelay
op_div
id|miimon
)paren
op_star
id|miimon
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|arp_interval
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): arp_interval module parameter (%d), &quot;
l_string|&quot;not in range 0-%d, so it was reset to %d&bslash;n&quot;
comma
id|arp_interval
comma
id|INT_MAX
comma
id|BOND_LINK_ARP_INTERV
)paren
suffix:semicolon
id|arp_interval
op_assign
id|BOND_LINK_ARP_INTERV
suffix:semicolon
)brace
r_for
c_loop
(paren
id|arp_ip_count
op_assign
l_int|0
suffix:semicolon
(paren
id|arp_ip_count
OL
id|MAX_ARP_IP_TARGETS
)paren
op_logical_and
id|arp_ip_target
(braket
id|arp_ip_count
)braket
suffix:semicolon
id|arp_ip_count
op_increment
)paren
(brace
multiline_comment|/* not complete check, but should be good enough to&n;&t;&t;   catch mistakes */
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
id|arp_ip_target
(braket
id|arp_ip_count
)braket
(braket
l_int|0
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): bad arp_ip_target module &quot;
l_string|&quot;parameter (%s), ARP monitoring will not be &quot;
l_string|&quot;performed&bslash;n&quot;
comma
id|arp_ip_target
(braket
id|arp_ip_count
)braket
)paren
suffix:semicolon
id|arp_interval
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|u32
id|ip
op_assign
id|in_aton
c_func
(paren
id|arp_ip_target
(braket
id|arp_ip_count
)braket
)paren
suffix:semicolon
id|arp_target
(braket
id|arp_ip_count
)braket
op_assign
id|ip
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|arp_interval
OG
l_int|0
)paren
op_logical_and
(paren
id|arp_ip_count
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* don&squot;t allow arping if no arp_ip_target given... */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): arp_interval module parameter &quot;
l_string|&quot;(%d) specified without providing an arp_ip_target &quot;
l_string|&quot;parameter, arp_interval was reset to 0&bslash;n&quot;
comma
id|arp_interval
)paren
suffix:semicolon
id|arp_interval
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|miimon
op_eq
l_int|0
)paren
op_logical_and
(paren
id|arp_interval
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* miimon and arp_interval not set, we need one so things&n;&t;&t; * work as expected, see bonding.txt for details&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bonding_init(): either miimon or &quot;
l_string|&quot;arp_interval and arp_ip_target module parameters &quot;
l_string|&quot;must be specified, otherwise bonding will not detect &quot;
l_string|&quot;link failures! see bonding.txt for details.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|primary
op_ne
l_int|NULL
)paren
op_logical_and
op_logical_neg
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
multiline_comment|/* currently, using a primary only makes sense&n;&t;&t; * in active backup, TLB or ALB modes&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): %s primary device specified but has &quot;
l_string|&quot;no effect in %s mode&bslash;n&quot;
comma
id|primary
comma
id|bond_mode_name
c_func
(paren
)paren
)paren
suffix:semicolon
id|primary
op_assign
l_int|NULL
suffix:semicolon
)brace
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|no
op_assign
l_int|0
suffix:semicolon
id|no
OL
id|max_bonds
suffix:semicolon
id|no
op_increment
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|dev
op_assign
id|alloc_netdev
c_func
(paren
r_sizeof
(paren
r_struct
id|bonding
)paren
comma
l_string|&quot;&quot;
comma
id|ether_setup
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|err
op_assign
id|dev_alloc_name
c_func
(paren
id|dev
comma
l_string|&quot;bond%d&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
multiline_comment|/* bond_init() must be called after dev_alloc_name() (for the&n;&t;&t; * /proc files), but before register_netdevice(), because we&n;&t;&t; * need to set function pointers.&n;&t;&t; */
id|err
op_assign
id|bond_init
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
id|err
op_assign
id|register_netdevice
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|bond_deinit
c_func
(paren
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
)brace
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
id|register_netdevice_notifier
c_func
(paren
op_amp
id|bond_netdev_notifier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_err
suffix:colon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* free and unregister all bonds that were successfully added */
id|bond_free_all
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|bonding_exit
r_static
r_void
id|__exit
id|bonding_exit
c_func
(paren
r_void
)paren
(brace
id|unregister_netdevice_notifier
c_func
(paren
op_amp
id|bond_netdev_notifier
)paren
suffix:semicolon
id|bond_free_all
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|bonding_init
id|module_init
c_func
(paren
id|bonding_init
)paren
suffix:semicolon
DECL|variable|bonding_exit
id|module_exit
c_func
(paren
id|bonding_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
id|DRV_DESCRIPTION
l_string|&quot;, v&quot;
id|DRV_VERSION
)paren
suffix:semicolon
multiline_comment|/*&n; * Local variables:&n; *  c-indent-level: 8&n; *  c-basic-offset: 8&n; *  tab-width: 8&n; * End:&n; */
eof
