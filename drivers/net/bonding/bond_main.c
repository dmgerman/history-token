multiline_comment|/*&n; * originally based on the dummy device.&n; *&n; * Copyright 1999, Thomas Davis, tadavis@lbl.gov.&n; * Licensed under the GPL. Based on dummy.c, and eql.c devices.&n; *&n; * bonding.c: an Ethernet Bonding driver&n; *&n; * This is useful to talk to a Cisco EtherChannel compatible equipment:&n; *&t;Cisco 5500&n; *&t;Sun Trunking (Solaris)&n; *&t;Alteon AceDirector Trunks&n; *&t;Linux Bonding&n; *&t;and probably many L2 switches ...&n; *&n; * How it works:&n; *    ifconfig bond0 ipaddress netmask up&n; *      will setup a network device, with an ip address.  No mac address&n; *&t;will be assigned at this time.  The hw mac address will come from&n; *&t;the first slave bonded to the channel.  All slaves will then use&n; *&t;this hw mac address.&n; *&n; *    ifconfig bond0 down&n; *         will release all slaves, marking them as down.&n; *&n; *    ifenslave bond0 eth0&n; *&t;will attach eth0 to bond0 as a slave.  eth0 hw mac address will either&n; *&t;a: be used as initial mac address&n; *&t;b: if a hw mac address already is there, eth0&squot;s hw mac address&n; *&t;   will then be set from bond0.&n; *&n; * v0.1 - first working version.&n; * v0.2 - changed stats to be calculated by summing slaves stats.&n; *&n; * Changes:&n; * Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;&n; * - fix leaks on failure at bond_init&n; *&n; * 2000/09/30 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - added trivial code to release a slave device.&n; *     - fixed security bug (CAP_NET_ADMIN not checked)&n; *     - implemented MII link monitoring to disable dead links :&n; *       All MII capable slaves are checked every &lt;miimon&gt; milliseconds&n; *       (100 ms seems good). This value can be changed by passing it to&n; *       insmod. A value of zero disables the monitoring (default).&n; *     - fixed an infinite loop in bond_xmit_roundrobin() when there&squot;s no&n; *       good slave.&n; *     - made the code hopefully SMP safe&n; *&n; * 2000/10/03 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - optimized slave lists based on relevant suggestions from Thomas Davis&n; *     - implemented active-backup method to obtain HA with two switches:&n; *       stay as long as possible on the same active interface, while we&n; *       also monitor the backup one (MII link status) because we want to know&n; *       if we are able to switch at any time. ( pass &quot;mode=1&quot; to insmod )&n; *     - lots of stress testings because we need it to be more robust than the&n; *       wires ! :-&gt;&n; *&n; * 2000/10/09 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - added up and down delays after link state change.&n; *     - optimized the slaves chaining so that when we run forward, we never&n; *       repass through the bond itself, but we can find it by searching&n; *       backwards. Renders the deletion more difficult, but accelerates the&n; *       scan.&n; *     - smarter enslaving and releasing.&n; *     - finer and more robust SMP locking&n; *&n; * 2000/10/17 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - fixed two potential SMP race conditions&n; *&n; * 2000/10/18 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - small fixes to the monitoring FSM in case of zero delays&n; * 2000/11/01 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - fixed first slave not automatically used in trunk mode.&n; * 2000/11/10 : spelling of &quot;EtherChannel&quot; corrected.&n; * 2000/11/13 : fixed a race condition in case of concurrent accesses to ioctl().&n; * 2000/12/16 : fixed improper usage of rtnl_exlock_nowait().&n; *&n; * 2001/1/3 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - The bonding driver now simulates MII status monitoring, just like&n; *       a normal network device.  It will show that the link is down iff&n; *       every slave in the bond shows that their links are down.  If at least&n; *       one slave is up, the bond&squot;s MII status will appear as up.&n; *&n; * 2001/2/7 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Applications can now query the bond from user space to get&n; *       information which may be useful.  They do this by calling&n; *       the BOND_INFO_QUERY ioctl.  Once the app knows how many slaves&n; *       are in the bond, it can call the BOND_SLAVE_INFO_QUERY ioctl to&n; *       get slave specific information (# link failures, etc).  See&n; *       &lt;linux/if_bonding.h&gt; for more details.  The structs of interest&n; *       are ifbond and ifslave.&n; *&n; * 2001/4/5 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Ported to 2.4 Kernel&n; *&n; * 2001/5/2 - Jeffrey E. Mast &lt;jeff at mastfamily dot com&gt;&n; *     - When a device is detached from a bond, the slave device is no longer&n; *       left thinking that is has a master.&n; *&n; * 2001/5/16 - Jeffrey E. Mast &lt;jeff at mastfamily dot com&gt;&n; *     - memset did not appropriately initialized the bond rw_locks. Used&n; *       rwlock_init to initialize to unlocked state to prevent deadlock when&n; *       first attempting a lock&n; *     - Called SET_MODULE_OWNER for bond device&n; *&n; * 2001/5/17 - Tim Anderson &lt;tsa at mvista.com&gt;&n; *     - 2 paths for releasing for slave release; 1 through ioctl&n; *       and 2) through close. Both paths need to release the same way.&n; *     - the free slave in bond release is changing slave status before&n; *       the free. The netdev_set_master() is intended to change slave state&n; *       so it should not be done as part of the release process.&n; *     - Simple rule for slave state at release: only the active in A/B and&n; *       only one in the trunked case.&n; *&n; * 2001/6/01 - Tim Anderson &lt;tsa at mvista.com&gt;&n; *     - Now call dev_close when releasing a slave so it doesn&squot;t screw up&n; *       out routing table.&n; *&n; * 2001/6/01 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Added /proc support for getting bond and slave information.&n; *       Information is in /proc/net/&lt;bond device&gt;/info.&n; *     - Changed the locking when calling bond_close to prevent deadlock.&n; *&n; * 2001/8/05 - Janice Girouard &lt;girouard at us.ibm.com&gt;&n; *     - correct problem where refcnt of slave is not incremented in bond_ioctl&n; *       so the system hangs when halting.&n; *     - correct locking problem when unable to malloc in bond_enslave.&n; *     - adding bond_xmit_xor logic.&n; *     - adding multiple bond device support.&n; *&n; * 2001/8/13 - Erik Habbinga &lt;erik_habbinga at hp dot com&gt;&n; *     - correct locking problem with rtnl_exlock_nowait&n; *&n; * 2001/8/23 - Janice Girouard &lt;girouard at us.ibm.com&gt;&n; *     - bzero initial dev_bonds, to correct oops&n; *     - convert SIOCDEVPRIVATE to new MII ioctl calls&n; *&n; * 2001/9/13 - Takao Indoh &lt;indou dot takao at jp dot fujitsu dot com&gt;&n; *     - Add the BOND_CHANGE_ACTIVE ioctl implementation&n; *&n; * 2001/9/14 - Mark Huth &lt;mhuth at mvista dot com&gt;&n; *     - Change MII_LINK_READY to not check for end of auto-negotiation,&n; *       but only for an up link.&n; *&n; * 2001/9/20 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Add the device field to bonding_t.  Previously the net_device&n; *       corresponding to a bond wasn&squot;t available from the bonding_t&n; *       structure.&n; *&n; * 2001/9/25 - Janice Girouard &lt;girouard at us.ibm.com&gt;&n; *     - add arp_monitor for active backup mode&n; *&n; * 2001/10/23 - Takao Indoh &lt;indou dot takao at jp dot fujitsu dot com&gt;&n; *     - Various memory leak fixes&n; *&n; * 2001/11/5 - Mark Huth &lt;mark dot huth at mvista dot com&gt;&n; *     - Don&squot;t take rtnl lock in bond_mii_monitor as it deadlocks under&n; *       certain hotswap conditions.&n; *       Note:  this same change may be required in bond_arp_monitor ???&n; *     - Remove possibility of calling bond_sethwaddr with NULL slave_dev ptr&n; *     - Handle hot swap ethernet interface deregistration events to remove&n; *       kernel oops following hot swap of enslaved interface&n; *&n; * 2002/1/2 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Restore original slave flags at release time.&n; *&n; * 2002/02/18 - Erik Habbinga &lt;erik_habbinga at hp dot com&gt;&n; *     - bond_release(): calling kfree on our_slave after call to&n; *       bond_restore_slave_flags, not before&n; *     - bond_enslave(): saving slave flags into original_flags before&n; *       call to netdev_set_master, so the IFF_SLAVE flag doesn&squot;t end&n; *       up in original_flags&n; *&n; * 2002/04/05 - Mark Smith &lt;mark.smith at comdev dot cc&gt; and&n; *              Steve Mead &lt;steve.mead at comdev dot cc&gt;&n; *     - Port Gleb Natapov&squot;s multicast support patchs from 2.4.12&n; *       to 2.4.18 adding support for multicast.&n; *&n; * 2002/06/10 - Tony Cureington &lt;tony.cureington * hp_com&gt;&n; *     - corrected uninitialized pointer (ifr.ifr_data) in bond_check_dev_link;&n; *       actually changed function to use MIIPHY, then MIIREG, and finally&n; *       ETHTOOL to determine the link status&n; *     - fixed bad ifr_data pointer assignments in bond_ioctl&n; *     - corrected mode 1 being reported as active-backup in bond_get_info;&n; *       also added text to distinguish type of load balancing (rr or xor)&n; *     - change arp_ip_target module param from &quot;1-12s&quot; (array of 12 ptrs)&n; *       to &quot;s&quot; (a single ptr)&n; *&n; * 2002/08/30 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *     - Removed acquisition of xmit_lock in set_multicast_list; caused&n; *       deadlock on SMP (lock is held by caller).&n; *     - Revamped SIOCGMIIPHY, SIOCGMIIREG portion of bond_check_dev_link().&n; *&n; * 2002/09/18 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *     - Fixed up bond_check_dev_link() (and callers): removed some magic&n; *&t; numbers, banished local MII_ defines, wrapped ioctl calls to&n; *&t; prevent EFAULT errors&n; *&n; * 2002/9/30 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *     - make sure the ip target matches the arp_target before saving the&n; *&t; hw address.&n; *&n; * 2002/9/30 - Dan Eisner &lt;eisner at 2robots dot com&gt;&n; *     - make sure my_ip is set before taking down the link, since&n; *&t; not all switches respond if the source ip is not set.&n; *&n; * 2002/10/8 - Janice Girouard &lt;girouard at us dot ibm dot com&gt;&n; *     - read in the local ip address when enslaving a device&n; *     - add primary support&n; *     - make sure 2*arp_interval has passed when a new device&n; *       is brought on-line before taking it down.&n; *&n; * 2002/09/11 - Philippe De Muyter &lt;phdm at macqel dot be&gt;&n; *     - Added bond_xmit_broadcast logic.&n; *     - Added bond_mode() support function.&n; *&n; * 2002/10/26 - Laurent Deniel &lt;laurent.deniel at free.fr&gt;&n; *     - allow to register multicast addresses only on active slave&n; *       (useful in active-backup mode)&n; *     - add multicast module parameter&n; *     - fix deletion of multicast groups after unloading module&n; *&n; * 2002/11/06 - Kameshwara Rayaprolu &lt;kameshwara.rao * wipro_com&gt;&n; *     - Changes to prevent panic from closing the device twice; if we close&n; *       the device in bond_release, we must set the original_flags to down&n; *       so it won&squot;t be closed again by the network layer.&n; *&n; * 2002/11/07 - Tony Cureington &lt;tony.cureington * hp_com&gt;&n; *     - Fix arp_target_hw_addr memory leak&n; *     - Created activebackup_arp_monitor function to handle arp monitoring&n; *       in active backup mode - the bond_arp_monitor had several problems...&n; *       such as allowing slaves to tx arps sequentially without any delay&n; *       for a response&n; *     - Renamed bond_arp_monitor to loadbalance_arp_monitor and re-wrote&n; *       this function to just handle arp monitoring in load-balancing mode;&n; *       it is a lot more compact now&n; *     - Changes to ensure one and only one slave transmits in active-backup&n; *       mode&n; *     - Robustesize parameters; warn users about bad combinations of&n; *       parameters; also if miimon is specified and a network driver does&n; *       not support MII or ETHTOOL, inform the user of this&n; *     - Changes to support link_failure_count when in arp monitoring mode&n; *     - Fix up/down delay reported in /proc&n; *     - Added version; log version; make version available from &quot;modinfo -d&quot;&n; *     - Fixed problem in bond_check_dev_link - if the first IOCTL (SIOCGMIIPH)&n; *&t; failed, the ETHTOOL ioctl never got a chance&n; *&n; * 2002/11/16 - Laurent Deniel &lt;laurent.deniel at free.fr&gt;&n; *     - fix multicast handling in activebackup_arp_monitor&n; *     - remove one unnecessary and confusing curr_active_slave == slave test&n; *&t; in activebackup_arp_monitor&n; *&n; *  2002/11/17 - Laurent Deniel &lt;laurent.deniel at free.fr&gt;&n; *     - fix bond_slave_info_query when slave_id = num_slaves&n; *&n; *  2002/11/19 - Janice Girouard &lt;girouard at us dot ibm dot com&gt;&n; *     - correct ifr_data reference.  Update ifr_data reference&n; *       to mii_ioctl_data struct values to avoid confusion.&n; *&n; *  2002/11/22 - Bert Barbe &lt;bert.barbe at oracle dot com&gt;&n; *      - Add support for multiple arp_ip_target&n; *&n; *  2002/12/13 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *&t;- Changed to allow text strings for mode and multicast, e.g.,&n; *&t;  insmod bonding mode=active-backup.  The numbers still work.&n; *&t;  One change: an invalid choice will cause module load failure,&n; *&t;  rather than the previous behavior of just picking one.&n; *&t;- Minor cleanups; got rid of dup ctype stuff, atoi function&n; *&n; * 2003/02/07 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *&t;- Added use_carrier module parameter that causes miimon to&n; *&t;  use netif_carrier_ok() test instead of MII/ETHTOOL ioctls.&n; *&t;- Minor cleanups; consolidated ioctl calls to one function.&n; *&n; * 2003/02/07 - Tony Cureington &lt;tony.cureington * hp_com&gt;&n; *&t;- Fix bond_mii_monitor() logic error that could result in&n; *&t;  bonding round-robin mode ignoring links after failover/recovery&n; *&n; * 2003/03/17 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *&t;- kmalloc fix (GFP_KERNEL to GFP_ATOMIC) reported by&n; *&t;  Shmulik dot Hen at intel.com.&n; *&t;- Based on discussion on mailing list, changed use of&n; *&t;  update_slave_cnt(), created wrapper functions for adding/removing&n; *&t;  slaves, changed bond_xmit_xor() to check slave_cnt instead of&n; *&t;  checking slave and slave-&gt;dev (which only worked by accident).&n; *&t;- Misc code cleanup: get arp_send() prototype from header file,&n; *&t;  add max_bonds to bonding.txt.&n; *&n; * 2003/03/18 - Tsippy Mendelson &lt;tsippy.mendelson at intel dot com&gt; and&n; *&t;&t;Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Make sure only bond_attach_slave() and bond_detach_slave() can&n; *&t;  manipulate the slave list, including slave_cnt, even when in&n; *&t;  bond_release_all().&n; *&t;- Fixed hang in bond_release() with traffic running:&n; *&t;  netdev_set_master() must not be called from within the bond lock.&n; *&n; * 2003/03/18 - Tsippy Mendelson &lt;tsippy.mendelson at intel dot com&gt; and&n; *&t;&t;Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Fixed hang in bond_enslave() with traffic running:&n; *&t;  netdev_set_master() must not be called from within the bond lock.&n; *&n; * 2003/03/18 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; *&t;- Added support for getting slave&squot;s speed and duplex via ethtool.&n; *&t;  Needed for 802.3ad and other future modes.&n; *&n; * 2003/03/18 - Tsippy Mendelson &lt;tsippy.mendelson at intel dot com&gt; and&n; *&t;&t;Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Enable support of modes that need to use the unique mac address of&n; *&t;  each slave.&n; *&t;  * bond_enslave(): Moved setting the slave&squot;s mac address, and&n; *&t;    openning it, from the application to the driver. This breaks&n; *&t;    backward comaptibility with old versions of ifenslave that open&n; *&t;     the slave before enalsving it !!!.&n; *&t;  * bond_release(): The driver also takes care of closing the slave&n; *&t;    and restoring its original mac address.&n; *&t;- Removed the code that restores all base driver&squot;s flags.&n; *&t;  Flags are automatically restored once all undo stages are done&n; *&t;  properly.&n; *&t;- Block possibility of enslaving before the master is up. This&n; *&t;  prevents putting the system in an unstable state.&n; *&n; * 2003/03/18 - Amir Noam &lt;amir.noam at intel dot com&gt;,&n; *&t;&t;Tsippy Mendelson &lt;tsippy.mendelson at intel dot com&gt; and&n; *&t;&t;Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Added support for IEEE 802.3ad Dynamic link aggregation mode.&n; *&n; * 2003/05/01 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; *&t;- Added ABI version control to restore compatibility between&n; *&t;  new/old ifenslave and new/old bonding.&n; *&n; * 2003/05/01 - Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Fixed bug in bond_release_all(): save old value of curr_active_slave&n; *&t;  before setting it to NULL.&n; *&t;- Changed driver versioning scheme to include version number instead&n; *&t;  of release date (that is already in another field). There are 3&n; *&t;  fields X.Y.Z where:&n; *&t;&t;X - Major version - big behavior changes&n; *&t;&t;Y - Minor version - addition of features&n; *&t;&t;Z - Extra version - minor changes and bug fixes&n; *&t;  The current version is 1.0.0 as a base line.&n; *&n; * 2003/05/01 - Tsippy Mendelson &lt;tsippy.mendelson at intel dot com&gt; and&n; *&t;&t;Amir Noam &lt;amir.noam at intel dot com&gt;&n; *&t;- Added support for lacp_rate module param.&n; *&t;- Code beautification and style changes (mainly in comments).&n; *&t;  new version - 1.0.1&n; *&n; * 2003/05/01 - Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Based on discussion on mailing list, changed locking scheme&n; *&t;  to use lock/unlock or lock_bh/unlock_bh appropriately instead&n; *&t;  of lock_irqsave/unlock_irqrestore. The new scheme helps exposing&n; *&t;  hidden bugs and solves system hangs that occurred due to the fact&n; *&t;  that holding lock_irqsave doesn&squot;t prevent softirqs from running.&n; *&t;  This also increases total throughput since interrupts are not&n; *&t;  blocked on each transmitted packets or monitor timeout.&n; *&t;  new version - 2.0.0&n; *&n; * 2003/05/01 - Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Added support for Transmit load balancing mode.&n; *&t;- Concentrate all assignments of curr_active_slave to a single point&n; *&t;  so specific modes can take actions when the primary adapter is&n; *&t;  changed.&n; *&t;- Take the updelay parameter into consideration during bond_enslave&n; *&t;  since some adapters loose their link during setting the device.&n; *&t;- Renamed bond_3ad_link_status_changed() to&n; *&t;  bond_3ad_handle_link_change() for compatibility with TLB.&n; *&t;  new version - 2.1.0&n; *&n; * 2003/05/01 - Tsippy Mendelson &lt;tsippy.mendelson at intel dot com&gt;&n; *&t;- Added support for Adaptive load balancing mode which is&n; *&t;  equivalent to Transmit load balancing + Receive load balancing.&n; *&t;  new version - 2.2.0&n; *&n; * 2003/05/15 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *&t;- Applied fix to activebackup_arp_monitor posted to bonding-devel&n; *&t;  by Tony Cureington &lt;tony.cureington * hp_com&gt;.  Fixes ARP&n; *&t;  monitor endless failover bug.  Version to 2.2.10&n; *&n; * 2003/05/20 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; *&t;- Fixed bug in ABI version control - Don&squot;t commit to a specific&n; *&t;  ABI version if receiving unsupported ioctl commands.&n; *&n; * 2003/05/22 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;&n; *&t;- Fix ifenslave -c causing bond to loose existing routes;&n; *&t;  added bond_set_mac_address() that doesn&squot;t require the&n; *&t;  bond to be down.&n; *&t;- In conjunction with fix for ifenslave -c, in&n; *&t;  bond_change_active(), changing to the already active slave&n; *&t;  is no longer an error (it successfully does nothing).&n; *&n; * 2003/06/30 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; * &t;- Fixed bond_change_active() for ALB/TLB modes.&n; *&t;  Version to 2.2.14.&n; *&n; * 2003/07/29 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; * &t;- Fixed ARP monitoring bug.&n; *&t;  Version to 2.2.15.&n; *&n; * 2003/07/31 - Willy Tarreau &lt;willy at ods dot org&gt;&n; * &t;- Fixed kernel panic when using ARP monitoring without&n; *&t;  setting bond&squot;s IP address.&n; *&t;  Version to 2.2.16.&n; *&n; * 2003/08/06 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; * &t;- Back port from 2.6: use alloc_netdev(); fix /proc handling;&n; *&t;  made stats a part of bond struct so no need to allocate&n; *&t;  and free it separately; use standard list operations instead&n; *&t;  of pre-allocated array of bonds.&n; *&t;  Version to 2.3.0.&n; *&n; * 2003/08/07 - Jay Vosburgh &lt;fubar at us dot ibm dot com&gt;,&n; *&t;       Amir Noam &lt;amir.noam at intel dot com&gt; and&n; *&t;       Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Propagating master&squot;s settings: Distinguish between modes that&n; *&t;  use a primary slave from those that don&squot;t, and propagate settings&n; *&t;  accordingly; Consolidate change_active opeartions and add&n; *&t;  reselect_active and find_best opeartions; Decouple promiscuous&n; *&t;  handling from the multicast mode setting; Add support for changing&n; *&t;  HW address and MTU with proper unwind; Consolidate procfs code,&n; *&t;  add CHANGENAME handler; Enhance netdev notification handling.&n; *&t;  Version to 2.4.0.&n; *&n; * 2003/09/15 - Stephen Hemminger &lt;shemminger at osdl dot org&gt;,&n; *&t;       Amir Noam &lt;amir.noam at intel dot com&gt;&n; *&t;- Convert /proc to seq_file interface.&n; *&t;  Change /proc/net/bondX/info to /proc/net/bonding/bondX.&n; *&t;  Set version to 2.4.1.&n; *&n; * 2003/11/20 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; *&t;- Fix /proc creation/destruction.&n; *&n; * 2003/12/01 - Shmulik Hen &lt;shmulik.hen at intel dot com&gt;&n; *&t;- Massive cleanup - Set version to 2.5.0&n; *&t;  Code changes:&n; *&t;  o Consolidate format of prints and debug prints.&n; *&t;  o Remove bonding_t/slave_t typedefs and consolidate all casts.&n; *&t;  o Remove dead code and unnecessary checks.&n; *&t;  o Consolidate starting/stopping timers.&n; *&t;  o Consolidate handling of primary module param throughout the code.&n; *&t;  o Removed multicast module param support - all settings are done&n; *&t;    according to mode.&n; *&t;  o Slave list iteration - bond is no longer part of the list,&n; *&t;    added cyclic list iteration macros.&n; *&t;  o Consolidate error handling in all xmit functions.&n; *&t;  Style changes:&n; *&t;  o Consolidate function naming and declarations.&n; *&t;  o Consolidate function params and local variables names.&n; *&t;  o Consolidate return values.&n; *&t;  o Consolidate curly braces.&n; *&t;  o Consolidate conditionals format.&n; *&t;  o Change struct member names and types.&n; *&t;  o Chomp trailing spaces, remove empty lines, fix indentations.&n; *&t;  o Re-organize code according to context.&n; *&n; * 2003/12/30 - Amir Noam &lt;amir.noam at intel dot com&gt;&n; *&t;- Fixed: Cannot remove and re-enslave the original active slave.&n; *&t;- Fixed: Releasing the original active slave causes mac address duplication.&n; *&t;- Add support for slaves that use ethtool_ops.&n; *&t;  Set version to 2.5.3.&n; */
singleline_comment|//#define BONDING_DEBUG 1
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/inetdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;linux/mii.h&gt;
macro_line|#include &lt;linux/ethtool.h&gt;
macro_line|#include &lt;linux/if_bonding.h&gt;
macro_line|#include &quot;bonding.h&quot;
macro_line|#include &quot;bond_3ad.h&quot;
macro_line|#include &quot;bond_alb.h&quot;
multiline_comment|/*---------------------------- Module parameters ----------------------------*/
multiline_comment|/* monitor all links that often (in milliseconds). &lt;=0 disables monitoring */
DECL|macro|BOND_LINK_MON_INTERV
mdefine_line|#define BOND_LINK_MON_INTERV&t;0
DECL|macro|BOND_LINK_ARP_INTERV
mdefine_line|#define BOND_LINK_ARP_INTERV&t;0
DECL|variable|max_bonds
r_static
r_int
id|max_bonds
op_assign
id|BOND_DEFAULT_MAX_BONDS
suffix:semicolon
DECL|variable|miimon
r_static
r_int
id|miimon
op_assign
id|BOND_LINK_MON_INTERV
suffix:semicolon
DECL|variable|updelay
r_static
r_int
id|updelay
op_assign
l_int|0
suffix:semicolon
DECL|variable|downdelay
r_static
r_int
id|downdelay
op_assign
l_int|0
suffix:semicolon
DECL|variable|use_carrier
r_static
r_int
id|use_carrier
op_assign
l_int|1
suffix:semicolon
DECL|variable|mode
r_static
r_char
op_star
id|mode
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|primary
r_static
r_char
op_star
id|primary
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|lacp_rate
r_static
r_char
op_star
id|lacp_rate
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|arp_interval
r_static
r_int
id|arp_interval
op_assign
id|BOND_LINK_ARP_INTERV
suffix:semicolon
DECL|variable|arp_ip_target
r_static
r_char
op_star
id|arp_ip_target
(braket
id|BOND_MAX_ARP_TARGETS
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_bonds
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_bonds
comma
l_string|&quot;Max number of bonded devices&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|miimon
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|miimon
comma
l_string|&quot;Link check interval in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|updelay
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|updelay
comma
l_string|&quot;Delay before considering link up, in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|downdelay
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|downdelay
comma
l_string|&quot;Delay before considering link down, in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|use_carrier
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|use_carrier
comma
l_string|&quot;Use netif_carrier_ok (vs MII ioctls) in miimon; 0 for off, 1 for on (default)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|mode
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|mode
comma
l_string|&quot;Mode of operation : 0 for round robin, 1 for active-backup, 2 for xor&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|primary
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|primary
comma
l_string|&quot;Primary network device to use&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|lacp_rate
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|lacp_rate
comma
l_string|&quot;LACPDU tx rate to request from 802.3ad partner (slow/fast)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|arp_interval
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|arp_interval
comma
l_string|&quot;arp interval in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|arp_ip_target
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|BOND_MAX_ARP_TARGETS
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|arp_ip_target
comma
l_string|&quot;arp targets in n.n.n.n form&quot;
)paren
suffix:semicolon
multiline_comment|/*----------------------------- Global variables ----------------------------*/
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
id|DRV_DESCRIPTION
l_string|&quot;: v&quot;
id|DRV_VERSION
l_string|&quot; (&quot;
id|DRV_RELDATE
l_string|&quot;)&bslash;n&quot;
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|bond_dev_list
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|variable|bond_proc_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|bond_proc_dir
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
DECL|variable|arp_target
r_static
id|u32
id|arp_target
(braket
id|BOND_MAX_ARP_TARGETS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|arp_ip_count
r_static
r_int
id|arp_ip_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|my_ip
r_static
id|u32
id|my_ip
op_assign
l_int|0
suffix:semicolon
DECL|variable|bond_mode
r_static
r_int
id|bond_mode
op_assign
id|BOND_MODE_ROUNDROBIN
suffix:semicolon
DECL|variable|lacp_fast
r_static
r_int
id|lacp_fast
op_assign
l_int|0
suffix:semicolon
DECL|variable|app_abi_ver
r_static
r_int
id|app_abi_ver
op_assign
l_int|0
suffix:semicolon
DECL|variable|orig_app_abi_ver
r_static
r_int
id|orig_app_abi_ver
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* This is used to save the first ABI version&n;&t;&t;&t;&t;   * we receive from the application. Once set,&n;&t;&t;&t;&t;   * it won&squot;t be changed, and the module will&n;&t;&t;&t;&t;   * refuse to enslave/release interfaces if the&n;&t;&t;&t;&t;   * command comes from an application using&n;&t;&t;&t;&t;   * another ABI version.&n;&t;&t;&t;&t;   */
DECL|struct|bond_parm_tbl
r_struct
id|bond_parm_tbl
(brace
DECL|member|modename
r_char
op_star
id|modename
suffix:semicolon
DECL|member|mode
r_int
id|mode
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|bond_lacp_tbl
r_static
r_struct
id|bond_parm_tbl
id|bond_lacp_tbl
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;slow&quot;
comma
id|AD_LACP_SLOW
)brace
comma
(brace
l_string|&quot;fast&quot;
comma
id|AD_LACP_FAST
)brace
comma
(brace
l_int|NULL
comma
op_minus
l_int|1
)brace
comma
)brace
suffix:semicolon
DECL|variable|bond_mode_tbl
r_static
r_struct
id|bond_parm_tbl
id|bond_mode_tbl
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;balance-rr&quot;
comma
id|BOND_MODE_ROUNDROBIN
)brace
comma
(brace
l_string|&quot;active-backup&quot;
comma
id|BOND_MODE_ACTIVEBACKUP
)brace
comma
(brace
l_string|&quot;balance-xor&quot;
comma
id|BOND_MODE_XOR
)brace
comma
(brace
l_string|&quot;broadcast&quot;
comma
id|BOND_MODE_BROADCAST
)brace
comma
(brace
l_string|&quot;802.3ad&quot;
comma
id|BOND_MODE_8023AD
)brace
comma
(brace
l_string|&quot;balance-tlb&quot;
comma
id|BOND_MODE_TLB
)brace
comma
(brace
l_string|&quot;balance-alb&quot;
comma
id|BOND_MODE_ALB
)brace
comma
(brace
l_int|NULL
comma
op_minus
l_int|1
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*-------------------------- Forward declarations ---------------------------*/
r_static
r_inline
r_void
id|bond_set_mode_ops
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_int
id|mode
)paren
suffix:semicolon
multiline_comment|/*---------------------------- General routines -----------------------------*/
DECL|function|bond_mode_name
r_static
r_const
r_char
op_star
id|bond_mode_name
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|bond_mode
)paren
(brace
r_case
id|BOND_MODE_ROUNDROBIN
suffix:colon
r_return
l_string|&quot;load balancing (round-robin)&quot;
suffix:semicolon
r_case
id|BOND_MODE_ACTIVEBACKUP
suffix:colon
r_return
l_string|&quot;fault-tolerance (active-backup)&quot;
suffix:semicolon
r_case
id|BOND_MODE_XOR
suffix:colon
r_return
l_string|&quot;load balancing (xor)&quot;
suffix:semicolon
r_case
id|BOND_MODE_BROADCAST
suffix:colon
r_return
l_string|&quot;fault-tolerance (broadcast)&quot;
suffix:semicolon
r_case
id|BOND_MODE_8023AD
suffix:colon
r_return
l_string|&quot;IEEE 802.3ad Dynamic link aggregation&quot;
suffix:semicolon
r_case
id|BOND_MODE_TLB
suffix:colon
r_return
l_string|&quot;transmit load balancing&quot;
suffix:semicolon
r_case
id|BOND_MODE_ALB
suffix:colon
r_return
l_string|&quot;adaptive load balancing&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
)brace
multiline_comment|/*------------------------------- Link status -------------------------------*/
multiline_comment|/*&n; * Get link speed and duplex from the slave&squot;s base driver&n; * using ethtool. If for some reason the call fails or the&n; * values are invalid, fake speed and duplex to 100/Full&n; * and return error.&n; */
DECL|function|bond_update_speed_duplex
r_static
r_int
id|bond_update_speed_duplex
c_func
(paren
r_struct
id|slave
op_star
id|slave
)paren
(brace
r_struct
id|net_device
op_star
id|slave_dev
op_assign
id|slave-&gt;dev
suffix:semicolon
r_static
r_int
(paren
op_star
id|ioctl
)paren
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
comma
r_int
)paren
suffix:semicolon
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|ethtool_cmd
id|etool
suffix:semicolon
multiline_comment|/* Fake speed and duplex */
id|slave-&gt;speed
op_assign
id|SPEED_100
suffix:semicolon
id|slave-&gt;duplex
op_assign
id|DUPLEX_FULL
suffix:semicolon
r_if
c_cond
(paren
id|slave_dev-&gt;ethtool_ops
)paren
(brace
id|u32
id|res
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slave_dev-&gt;ethtool_ops-&gt;get_settings
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|res
op_assign
id|slave_dev-&gt;ethtool_ops
op_member_access_from_pointer
id|get_settings
c_func
(paren
id|slave_dev
comma
op_amp
id|etool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_goto
id|verify
suffix:semicolon
)brace
id|ioctl
op_assign
id|slave_dev-&gt;do_ioctl
suffix:semicolon
id|strncpy
c_func
(paren
id|ifr.ifr_name
comma
id|slave_dev-&gt;name
comma
id|IFNAMSIZ
)paren
suffix:semicolon
id|etool.cmd
op_assign
id|ETHTOOL_GSET
suffix:semicolon
id|ifr.ifr_data
op_assign
(paren
r_char
op_star
)paren
op_amp
id|etool
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioctl
op_logical_or
(paren
id|IOCTL
c_func
(paren
id|slave_dev
comma
op_amp
id|ifr
comma
id|SIOCETHTOOL
)paren
OL
l_int|0
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|verify
suffix:colon
r_switch
c_cond
(paren
id|etool.speed
)paren
(brace
r_case
id|SPEED_10
suffix:colon
r_case
id|SPEED_100
suffix:colon
r_case
id|SPEED_1000
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|etool.duplex
)paren
(brace
r_case
id|DUPLEX_FULL
suffix:colon
r_case
id|DUPLEX_HALF
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|slave-&gt;speed
op_assign
id|etool.speed
suffix:semicolon
id|slave-&gt;duplex
op_assign
id|etool.duplex
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * if &lt;dev&gt; supports MII link status reporting, check its link status.&n; *&n; * We either do MII/ETHTOOL ioctls, or check netif_carrier_ok(),&n; * depening upon the setting of the use_carrier parameter.&n; *&n; * Return either BMSR_LSTATUS, meaning that the link is up (or we&n; * can&squot;t tell and just pretend it is), or 0, meaning that the link is&n; * down.&n; *&n; * If reporting is non-zero, instead of faking link up, return -1 if&n; * both ETHTOOL and MII ioctls fail (meaning the device does not&n; * support them).  If use_carrier is set, return whatever it says.&n; * It&squot;d be nice if there was a good way to tell if a driver supports&n; * netif_carrier, but there really isn&squot;t.&n; */
DECL|function|bond_check_dev_link
r_static
r_int
id|bond_check_dev_link
c_func
(paren
r_struct
id|net_device
op_star
id|slave_dev
comma
r_int
id|reporting
)paren
(brace
r_static
r_int
(paren
op_star
id|ioctl
)paren
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
comma
r_int
)paren
suffix:semicolon
r_struct
id|ifreq
id|ifr
suffix:semicolon
r_struct
id|mii_ioctl_data
op_star
id|mii
suffix:semicolon
r_struct
id|ethtool_value
id|etool
suffix:semicolon
r_if
c_cond
(paren
id|use_carrier
)paren
(brace
r_return
id|netif_carrier_ok
c_func
(paren
id|slave_dev
)paren
ques
c_cond
id|BMSR_LSTATUS
suffix:colon
l_int|0
suffix:semicolon
)brace
id|ioctl
op_assign
id|slave_dev-&gt;do_ioctl
suffix:semicolon
r_if
c_cond
(paren
id|ioctl
)paren
(brace
multiline_comment|/* TODO: set pointer to correct ioctl on a per team member */
multiline_comment|/*       bases to make this more efficient. that is, once  */
multiline_comment|/*       we determine the correct ioctl, we will always    */
multiline_comment|/*       call it and not the others for that team          */
multiline_comment|/*       member.                                           */
multiline_comment|/*&n;&t;&t; * We cannot assume that SIOCGMIIPHY will also read a&n;&t;&t; * register; not all network drivers (e.g., e100)&n;&t;&t; * support that.&n;&t;&t; */
multiline_comment|/* Yes, the mii is overlaid on the ifreq.ifr_ifru */
id|strncpy
c_func
(paren
id|ifr.ifr_name
comma
id|slave_dev-&gt;name
comma
id|IFNAMSIZ
)paren
suffix:semicolon
id|mii
op_assign
(paren
r_struct
id|mii_ioctl_data
op_star
)paren
op_amp
id|ifr.ifr_data
suffix:semicolon
r_if
c_cond
(paren
id|IOCTL
c_func
(paren
id|slave_dev
comma
op_amp
id|ifr
comma
id|SIOCGMIIPHY
)paren
op_eq
l_int|0
)paren
(brace
id|mii-&gt;reg_num
op_assign
id|MII_BMSR
suffix:semicolon
r_if
c_cond
(paren
id|IOCTL
c_func
(paren
id|slave_dev
comma
op_amp
id|ifr
comma
id|SIOCGMIIREG
)paren
op_eq
l_int|0
)paren
(brace
r_return
(paren
id|mii-&gt;val_out
op_amp
id|BMSR_LSTATUS
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* try SIOCETHTOOL ioctl, some drivers cache ETHTOOL_GLINK */
multiline_comment|/* for a period of time so we attempt to get link status   */
multiline_comment|/* from it last if the above MII ioctls fail...            */
r_if
c_cond
(paren
id|slave_dev-&gt;ethtool_ops
)paren
(brace
r_if
c_cond
(paren
id|slave_dev-&gt;ethtool_ops-&gt;get_link
)paren
(brace
id|u32
id|link
suffix:semicolon
id|link
op_assign
id|slave_dev-&gt;ethtool_ops
op_member_access_from_pointer
id|get_link
c_func
(paren
id|slave_dev
)paren
suffix:semicolon
r_return
id|link
ques
c_cond
id|BMSR_LSTATUS
suffix:colon
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ioctl
)paren
(brace
id|strncpy
c_func
(paren
id|ifr.ifr_name
comma
id|slave_dev-&gt;name
comma
id|IFNAMSIZ
)paren
suffix:semicolon
id|etool.cmd
op_assign
id|ETHTOOL_GLINK
suffix:semicolon
id|ifr.ifr_data
op_assign
(paren
r_char
op_star
)paren
op_amp
id|etool
suffix:semicolon
r_if
c_cond
(paren
id|IOCTL
c_func
(paren
id|slave_dev
comma
op_amp
id|ifr
comma
id|SIOCETHTOOL
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|etool.data
op_eq
l_int|1
)paren
(brace
r_return
id|BMSR_LSTATUS
suffix:semicolon
)brace
r_else
(brace
id|dprintk
c_func
(paren
l_string|&quot;SIOCETHTOOL shows link down&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * If reporting, report that either there&squot;s no dev-&gt;do_ioctl,&n;&t; * or both SIOCGMIIREG and SIOCETHTOOL failed (meaning that we&n;&t; * cannot report link status).  If not reporting, pretend&n;&t; * we&squot;re ok.&n;&t; */
r_return
(paren
id|reporting
ques
c_cond
op_minus
l_int|1
suffix:colon
id|BMSR_LSTATUS
)paren
suffix:semicolon
)brace
multiline_comment|/*----------------------------- Multicast list ------------------------------*/
multiline_comment|/*&n; * Returns 0 if dmi1 and dmi2 are the same, non-0 otherwise&n; */
DECL|function|bond_is_dmi_same
r_static
r_inline
r_int
id|bond_is_dmi_same
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|dmi1
comma
r_struct
id|dev_mc_list
op_star
id|dmi2
)paren
(brace
r_return
id|memcmp
c_func
(paren
id|dmi1-&gt;dmi_addr
comma
id|dmi2-&gt;dmi_addr
comma
id|dmi1-&gt;dmi_addrlen
)paren
op_eq
l_int|0
op_logical_and
id|dmi1-&gt;dmi_addrlen
op_eq
id|dmi2-&gt;dmi_addrlen
suffix:semicolon
)brace
multiline_comment|/*&n; * returns dmi entry if found, NULL otherwise&n; */
DECL|function|bond_mc_list_find_dmi
r_static
r_struct
id|dev_mc_list
op_star
id|bond_mc_list_find_dmi
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|dmi
comma
r_struct
id|dev_mc_list
op_star
id|mc_list
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|idmi
suffix:semicolon
r_for
c_loop
(paren
id|idmi
op_assign
id|mc_list
suffix:semicolon
id|idmi
suffix:semicolon
id|idmi
op_assign
id|idmi-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|bond_is_dmi_same
c_func
(paren
id|dmi
comma
id|idmi
)paren
)paren
(brace
r_return
id|idmi
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Push the promiscuity flag down to appropriate slaves&n; */
DECL|function|bond_set_promiscuity
r_static
r_void
id|bond_set_promiscuity
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_int
id|inc
)paren
(brace
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
multiline_comment|/* write lock already acquired */
r_if
c_cond
(paren
id|bond-&gt;curr_active_slave
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|bond-&gt;curr_active_slave-&gt;dev
comma
id|inc
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|slave
op_star
id|slave
suffix:semicolon
r_int
id|i
suffix:semicolon
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|slave-&gt;dev
comma
id|inc
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Push the allmulti flag down to all slaves&n; */
DECL|function|bond_set_allmulti
r_static
r_void
id|bond_set_allmulti
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_int
id|inc
)paren
(brace
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
multiline_comment|/* write lock already acquired */
r_if
c_cond
(paren
id|bond-&gt;curr_active_slave
)paren
(brace
id|dev_set_allmulti
c_func
(paren
id|bond-&gt;curr_active_slave-&gt;dev
comma
id|inc
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|slave
op_star
id|slave
suffix:semicolon
r_int
id|i
suffix:semicolon
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
id|dev_set_allmulti
c_func
(paren
id|slave-&gt;dev
comma
id|inc
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Add a Multicast address to slaves&n; * according to mode&n; */
DECL|function|bond_mc_add
r_static
r_void
id|bond_mc_add
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_void
op_star
id|addr
comma
r_int
id|alen
)paren
(brace
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
multiline_comment|/* write lock already acquired */
r_if
c_cond
(paren
id|bond-&gt;curr_active_slave
)paren
(brace
id|dev_mc_add
c_func
(paren
id|bond-&gt;curr_active_slave-&gt;dev
comma
id|addr
comma
id|alen
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|slave
op_star
id|slave
suffix:semicolon
r_int
id|i
suffix:semicolon
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
id|dev_mc_add
c_func
(paren
id|slave-&gt;dev
comma
id|addr
comma
id|alen
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Remove a multicast address from slave&n; * according to mode&n; */
DECL|function|bond_mc_delete
r_static
r_void
id|bond_mc_delete
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_void
op_star
id|addr
comma
r_int
id|alen
)paren
(brace
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
multiline_comment|/* write lock already acquired */
r_if
c_cond
(paren
id|bond-&gt;curr_active_slave
)paren
(brace
id|dev_mc_delete
c_func
(paren
id|bond-&gt;curr_active_slave-&gt;dev
comma
id|addr
comma
id|alen
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|slave
op_star
id|slave
suffix:semicolon
r_int
id|i
suffix:semicolon
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
id|dev_mc_delete
c_func
(paren
id|slave-&gt;dev
comma
id|addr
comma
id|alen
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Totally destroys the mc_list in bond&n; */
DECL|function|bond_mc_list_destroy
r_static
r_void
id|bond_mc_list_destroy
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
id|dmi
op_assign
id|bond-&gt;mc_list
suffix:semicolon
r_while
c_loop
(paren
id|dmi
)paren
(brace
id|bond-&gt;mc_list
op_assign
id|dmi-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|dmi
)paren
suffix:semicolon
id|dmi
op_assign
id|bond-&gt;mc_list
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Copy all the Multicast addresses from src to the bonding device dst&n; */
DECL|function|bond_mc_list_copy
r_static
r_int
id|bond_mc_list_copy
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|mc_list
comma
r_struct
id|bonding
op_star
id|bond
comma
r_int
id|gpf_flag
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
comma
op_star
id|new_dmi
suffix:semicolon
r_for
c_loop
(paren
id|dmi
op_assign
id|mc_list
suffix:semicolon
id|dmi
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
id|new_dmi
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dev_mc_list
)paren
comma
id|gpf_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_dmi
)paren
(brace
multiline_comment|/* FIXME: Potential memory leak !!! */
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|new_dmi-&gt;next
op_assign
id|bond-&gt;mc_list
suffix:semicolon
id|bond-&gt;mc_list
op_assign
id|new_dmi
suffix:semicolon
id|new_dmi-&gt;dmi_addrlen
op_assign
id|dmi-&gt;dmi_addrlen
suffix:semicolon
id|memcpy
c_func
(paren
id|new_dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
)paren
suffix:semicolon
id|new_dmi-&gt;dmi_users
op_assign
id|dmi-&gt;dmi_users
suffix:semicolon
id|new_dmi-&gt;dmi_gusers
op_assign
id|dmi-&gt;dmi_gusers
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * flush all members of flush-&gt;mc_list from device dev-&gt;mc_list&n; */
DECL|function|bond_mc_list_flush
r_static
r_void
id|bond_mc_list_flush
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_struct
id|net_device
op_star
id|slave_dev
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
r_for
c_loop
(paren
id|dmi
op_assign
id|bond_dev-&gt;mc_list
suffix:semicolon
id|dmi
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
id|dev_mc_delete
c_func
(paren
id|slave_dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
multiline_comment|/* del lacpdu mc addr from mc list */
id|u8
id|lacpdu_multicast
(braket
id|ETH_ALEN
)braket
op_assign
id|MULTICAST_LACPDU_ADDR
suffix:semicolon
id|dev_mc_delete
c_func
(paren
id|slave_dev
comma
id|lacpdu_multicast
comma
id|ETH_ALEN
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*--------------------------- Active slave change ---------------------------*/
multiline_comment|/*&n; * Update the mc list and multicast-related flags for the new and&n; * old active slaves (if any) according to the multicast mode, and&n; * promiscuous flags unconditionally.&n; */
DECL|function|bond_mc_swap
r_static
r_void
id|bond_mc_swap
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|new_active
comma
r_struct
id|slave
op_star
id|old_active
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
multiline_comment|/* nothing to do -  mc list is already up-to-date on&n;&t;&t; * all slaves&n;&t;&t; */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_active
)paren
(brace
r_if
c_cond
(paren
id|bond-&gt;dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|old_active-&gt;dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
id|dev_set_allmulti
c_func
(paren
id|old_active-&gt;dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|dmi
op_assign
id|bond-&gt;dev-&gt;mc_list
suffix:semicolon
id|dmi
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
id|dev_mc_delete
c_func
(paren
id|old_active-&gt;dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|new_active
)paren
(brace
r_if
c_cond
(paren
id|bond-&gt;dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|new_active-&gt;dev
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
id|dev_set_allmulti
c_func
(paren
id|new_active-&gt;dev
comma
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|dmi
op_assign
id|bond-&gt;dev-&gt;mc_list
suffix:semicolon
id|dmi
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
id|dev_mc_add
c_func
(paren
id|new_active-&gt;dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; * find_best_interface - select the best available slave to be the active one&n; * @bond: our bonding struct&n; *&n; * Warning: Caller must hold curr_slave_lock for writing.&n; */
DECL|function|bond_find_best_slave
r_static
r_struct
id|slave
op_star
id|bond_find_best_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|slave
op_star
id|new_active
comma
op_star
id|old_active
suffix:semicolon
r_struct
id|slave
op_star
id|bestslave
op_assign
l_int|NULL
suffix:semicolon
r_int
id|mintime
suffix:semicolon
r_int
id|i
suffix:semicolon
id|new_active
op_assign
id|old_active
op_assign
id|bond-&gt;curr_active_slave
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_active
)paren
(brace
multiline_comment|/* there were no active slaves left */
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
OG
l_int|0
)paren
(brace
multiline_comment|/* found one slave */
id|new_active
op_assign
id|bond-&gt;first_slave
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* still no slave, return NULL */
)brace
)brace
id|mintime
op_assign
id|updelay
suffix:semicolon
multiline_comment|/* first try the primary link; if arping, a link must tx/rx traffic&n;&t; * before it can be considered the curr_active_slave - also, we would skip&n;&t; * slaves between the curr_active_slave and primary_slave that may be up&n;&t; * and able to arp&n;&t; */
r_if
c_cond
(paren
(paren
id|bond-&gt;primary_slave
)paren
op_logical_and
(paren
op_logical_neg
id|arp_interval
)paren
op_logical_and
(paren
id|IS_UP
c_func
(paren
id|bond-&gt;primary_slave-&gt;dev
)paren
)paren
)paren
(brace
id|new_active
op_assign
id|bond-&gt;primary_slave
suffix:semicolon
)brace
multiline_comment|/* remember where to stop iterating over the slaves */
id|old_active
op_assign
id|new_active
suffix:semicolon
id|bond_for_each_slave_from
c_func
(paren
id|bond
comma
id|new_active
comma
id|i
comma
id|old_active
)paren
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|new_active-&gt;dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|new_active-&gt;link
op_eq
id|BOND_LINK_UP
)paren
(brace
r_return
id|new_active
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|new_active-&gt;link
op_eq
id|BOND_LINK_BACK
)paren
(brace
multiline_comment|/* link up, but waiting for stabilization */
r_if
c_cond
(paren
id|new_active-&gt;delay
OL
id|mintime
)paren
(brace
id|mintime
op_assign
id|new_active-&gt;delay
suffix:semicolon
id|bestslave
op_assign
id|new_active
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|bestslave
suffix:semicolon
)brace
multiline_comment|/**&n; * change_active_interface - change the active slave into the specified one&n; * @bond: our bonding struct&n; * @new: the new slave to make the active one&n; *&n; * Set the new slave to the bond&squot;s settings and unset them on the old&n; * curr_active_slave.&n; * Setting include flags, mc-list, promiscuity, allmulti, etc.&n; *&n; * If @new&squot;s link state is %BOND_LINK_BACK we&squot;ll set it to %BOND_LINK_UP,&n; * because it is apparently the best available slave we have, even though its&n; * updelay hasn&squot;t timed out yet.&n; *&n; * Warning: Caller must hold curr_slave_lock for writing.&n; */
DECL|function|bond_change_active_slave
r_static
r_void
id|bond_change_active_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|new_active
)paren
(brace
r_struct
id|slave
op_star
id|old_active
op_assign
id|bond-&gt;curr_active_slave
suffix:semicolon
r_if
c_cond
(paren
id|old_active
op_eq
id|new_active
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_active
)paren
(brace
r_if
c_cond
(paren
id|new_active-&gt;link
op_eq
id|BOND_LINK_BACK
)paren
(brace
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: making interface %s the new &quot;
l_string|&quot;active one %d ms earlier.&bslash;n&quot;
comma
id|bond-&gt;dev-&gt;name
comma
id|new_active-&gt;dev-&gt;name
comma
(paren
id|updelay
op_minus
id|new_active-&gt;delay
)paren
op_star
id|miimon
)paren
suffix:semicolon
)brace
id|new_active-&gt;delay
op_assign
l_int|0
suffix:semicolon
id|new_active-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
id|new_active-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
id|bond_3ad_handle_link_change
c_func
(paren
id|new_active
comma
id|BOND_LINK_UP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
id|bond_alb_handle_link_change
c_func
(paren
id|bond
comma
id|new_active
comma
id|BOND_LINK_UP
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: making interface %s the new &quot;
l_string|&quot;active one.&bslash;n&quot;
comma
id|bond-&gt;dev-&gt;name
comma
id|new_active-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
r_if
c_cond
(paren
id|old_active
)paren
(brace
id|bond_set_slave_inactive_flags
c_func
(paren
id|old_active
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_active
)paren
(brace
id|bond_set_slave_active_flags
c_func
(paren
id|new_active
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|bond_mc_swap
c_func
(paren
id|bond
comma
id|new_active
comma
id|old_active
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
id|bond_alb_handle_active_change
c_func
(paren
id|bond
comma
id|new_active
)paren
suffix:semicolon
)brace
r_else
(brace
id|bond-&gt;curr_active_slave
op_assign
id|new_active
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * bond_select_active_slave - select a new active slave, if needed&n; * @bond: our bonding struct&n; *&n; * This functions shoud be called when one of the following occurs:&n; * - The old curr_active_slave has been released or lost its link.&n; * - The primary_slave has got its link back.&n; * - A slave has got its link back and there&squot;s no old curr_active_slave.&n; *&n; * Warning: Caller must hold curr_slave_lock for writing.&n; */
DECL|function|bond_select_active_slave
r_static
r_void
id|bond_select_active_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|slave
op_star
id|best_slave
suffix:semicolon
id|best_slave
op_assign
id|bond_find_best_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|best_slave
op_ne
id|bond-&gt;curr_active_slave
)paren
(brace
id|bond_change_active_slave
c_func
(paren
id|bond
comma
id|best_slave
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*--------------------------- slave list handling ---------------------------*/
multiline_comment|/*&n; * This function attaches the slave to the end of list.&n; *&n; * bond-&gt;lock held for writing by caller.&n; */
DECL|function|bond_attach_slave
r_static
r_void
id|bond_attach_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|new_slave
)paren
(brace
r_if
c_cond
(paren
id|bond-&gt;first_slave
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* attaching the first slave */
id|new_slave-&gt;next
op_assign
id|new_slave
suffix:semicolon
id|new_slave-&gt;prev
op_assign
id|new_slave
suffix:semicolon
id|bond-&gt;first_slave
op_assign
id|new_slave
suffix:semicolon
)brace
r_else
(brace
id|new_slave-&gt;next
op_assign
id|bond-&gt;first_slave
suffix:semicolon
id|new_slave-&gt;prev
op_assign
id|bond-&gt;first_slave-&gt;prev
suffix:semicolon
id|new_slave-&gt;next-&gt;prev
op_assign
id|new_slave
suffix:semicolon
id|new_slave-&gt;prev-&gt;next
op_assign
id|new_slave
suffix:semicolon
)brace
id|bond-&gt;slave_cnt
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * This function detaches the slave from the list.&n; * WARNING: no check is made to verify if the slave effectively&n; * belongs to &lt;bond&gt;.&n; * Nothing is freed on return, structures are just unchained.&n; * If any slave pointer in bond was pointing to &lt;slave&gt;,&n; * it should be changed by the calling function.&n; *&n; * bond-&gt;lock held for writing by caller.&n; */
DECL|function|bond_detach_slave
r_static
r_void
id|bond_detach_slave
c_func
(paren
r_struct
id|bonding
op_star
id|bond
comma
r_struct
id|slave
op_star
id|slave
)paren
(brace
r_if
c_cond
(paren
id|slave-&gt;next
)paren
(brace
id|slave-&gt;next-&gt;prev
op_assign
id|slave-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slave-&gt;prev
)paren
(brace
id|slave-&gt;prev-&gt;next
op_assign
id|slave-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;first_slave
op_eq
id|slave
)paren
(brace
multiline_comment|/* slave is the first slave */
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
OG
l_int|1
)paren
(brace
multiline_comment|/* there are more slave */
id|bond-&gt;first_slave
op_assign
id|slave-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|bond-&gt;first_slave
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* slave was the last one */
)brace
)brace
id|slave-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|slave-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|bond-&gt;slave_cnt
op_decrement
suffix:semicolon
)brace
multiline_comment|/*---------------------------------- IOCTL ----------------------------------*/
DECL|function|bond_sethwaddr
r_static
r_int
id|bond_sethwaddr
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_struct
id|net_device
op_star
id|slave_dev
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;bond_dev=%p&bslash;n&quot;
comma
id|bond_dev
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;slave_dev=%p&bslash;n&quot;
comma
id|slave_dev
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;slave_dev-&gt;addr_len=%d&bslash;n&quot;
comma
id|slave_dev-&gt;addr_len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bond_dev-&gt;dev_addr
comma
id|slave_dev-&gt;dev_addr
comma
id|slave_dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* enslave device &lt;slave&gt; to bond device &lt;master&gt; */
DECL|function|bond_enslave
r_static
r_int
id|bond_enslave
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_struct
id|net_device
op_star
id|slave_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|slave
op_star
id|new_slave
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
r_struct
id|sockaddr
id|addr
suffix:semicolon
r_int
id|link_reporting
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|slave_dev-&gt;do_ioctl
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning : no link monitoring support for %s&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* bond must be initialized by bond_open() before enslaving */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bond_dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;Error, master_dev is not up&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* already enslaved */
r_if
c_cond
(paren
id|slave_dev-&gt;flags
op_amp
id|IFF_SLAVE
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;Error, Device was already enslaved&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|app_abi_ver
op_ge
l_int|1
)paren
(brace
multiline_comment|/* The application is using an ABI, which requires the&n;&t;&t; * slave interface to be closed.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|slave_dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: Error: %s is up&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slave_dev-&gt;set_mac_address
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: Error: The slave device you specified does &quot;
l_string|&quot;not support setting the MAC address.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Your kernel likely does not support slave &quot;
l_string|&quot;devices.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* The application is not using an ABI, which requires the&n;&t;&t; * slave interface to be open.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|slave_dev-&gt;flags
op_amp
id|IFF_UP
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: Error: %s is not running&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: Error: to use %s mode, you must upgrade &quot;
l_string|&quot;ifenslave.&bslash;n&quot;
comma
id|bond_mode_name
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
id|new_slave
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|slave
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_slave
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|new_slave
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|slave
)paren
)paren
suffix:semicolon
multiline_comment|/* save slave&squot;s original flags before calling&n;&t; * netdev_set_master and dev_open&n;&t; */
id|new_slave-&gt;original_flags
op_assign
id|slave_dev-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
id|app_abi_ver
op_ge
l_int|1
)paren
(brace
multiline_comment|/* save slave&squot;s original (&quot;permanent&quot;) mac address for&n;&t;&t; * modes that needs it, and for restoring it upon release,&n;&t;&t; * and then set it to the master&squot;s address&n;&t;&t; */
id|memcpy
c_func
(paren
id|new_slave-&gt;perm_hwaddr
comma
id|slave_dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
multiline_comment|/* set slave to master&squot;s mac address&n;&t;&t; * The application already set the master&squot;s&n;&t;&t; * mac address to that of the first slave&n;&t;&t; */
id|memcpy
c_func
(paren
id|addr.sa_data
comma
id|bond_dev-&gt;dev_addr
comma
id|bond_dev-&gt;addr_len
)paren
suffix:semicolon
id|addr.sa_family
op_assign
id|slave_dev-&gt;type
suffix:semicolon
id|res
op_assign
id|slave_dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|slave_dev
comma
op_amp
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;Error %d calling set_mac_address&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
r_goto
id|err_free
suffix:semicolon
)brace
multiline_comment|/* open the slave since the application closed it */
id|res
op_assign
id|dev_open
c_func
(paren
id|slave_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;Openning slave %s failed&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
r_goto
id|err_restore_mac
suffix:semicolon
)brace
)brace
id|res
op_assign
id|netdev_set_master
c_func
(paren
id|slave_dev
comma
id|bond_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;Error %d calling netdev_set_master&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|app_abi_ver
OL
l_int|1
)paren
(brace
r_goto
id|err_free
suffix:semicolon
)brace
r_else
(brace
r_goto
id|err_close
suffix:semicolon
)brace
)brace
id|new_slave-&gt;dev
op_assign
id|slave_dev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
multiline_comment|/* bond_alb_init_slave() must be called before all other stages since&n;&t;&t; * it might fail and we do not want to have to undo everything&n;&t;&t; */
id|res
op_assign
id|bond_alb_init_slave
c_func
(paren
id|bond
comma
id|new_slave
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
r_goto
id|err_unset_master
suffix:semicolon
)brace
)brace
multiline_comment|/* If the mode USES_PRIMARY, then the new slave gets the&n;&t; * master&squot;s promisc (and mc) settings only if it becomes the&n;&t; * curr_active_slave, and that is taken care of later when calling&n;&t; * bond_change_active()&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
multiline_comment|/* set promiscuity level to new slave */
r_if
c_cond
(paren
id|bond_dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|slave_dev
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* set allmulti level to new slave */
r_if
c_cond
(paren
id|bond_dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
id|dev_set_allmulti
c_func
(paren
id|slave_dev
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* upload master&squot;s mc_list to new slave */
r_for
c_loop
(paren
id|dmi
op_assign
id|bond_dev-&gt;mc_list
suffix:semicolon
id|dmi
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
id|dev_mc_add
(paren
id|slave_dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
multiline_comment|/* add lacpdu mc addr to mc list */
id|u8
id|lacpdu_multicast
(braket
id|ETH_ALEN
)braket
op_assign
id|MULTICAST_LACPDU_ADDR
suffix:semicolon
id|dev_mc_add
c_func
(paren
id|slave_dev
comma
id|lacpdu_multicast
comma
id|ETH_ALEN
comma
l_int|0
)paren
suffix:semicolon
)brace
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|bond_attach_slave
c_func
(paren
id|bond
comma
id|new_slave
)paren
suffix:semicolon
id|new_slave-&gt;delay
op_assign
l_int|0
suffix:semicolon
id|new_slave-&gt;link_failure_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|miimon
op_logical_and
op_logical_neg
id|use_carrier
)paren
(brace
id|link_reporting
op_assign
id|bond_check_dev_link
c_func
(paren
id|slave_dev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|link_reporting
op_eq
op_minus
l_int|1
)paren
op_logical_and
op_logical_neg
id|arp_interval
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * miimon is set but a bonded network driver&n;&t;&t;&t; * does not support ETHTOOL/MII and&n;&t;&t;&t; * arp_interval is not set.  Note: if&n;&t;&t;&t; * use_carrier is enabled, we will never go&n;&t;&t;&t; * here (because netif_carrier is always&n;&t;&t;&t; * supported); thus, we don&squot;t need to change&n;&t;&t;&t; * the messages for netif_carrier.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: MII and ETHTOOL support not &quot;
l_string|&quot;available for interface %s, and &quot;
l_string|&quot;arp_interval/arp_ip_target module parameters &quot;
l_string|&quot;not specified, thus bonding will not detect &quot;
l_string|&quot;link failures! see bonding.txt for details.&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|link_reporting
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* unable get link status using mii/ethtool */
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: can&squot;t get link status from &quot;
l_string|&quot;interface %s; the network driver associated &quot;
l_string|&quot;with this interface does not support MII or &quot;
l_string|&quot;ETHTOOL link status reporting, thus miimon &quot;
l_string|&quot;has no effect on this interface.&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* check for initial state */
r_if
c_cond
(paren
op_logical_neg
id|miimon
op_logical_or
(paren
id|bond_check_dev_link
c_func
(paren
id|slave_dev
comma
l_int|0
)paren
op_eq
id|BMSR_LSTATUS
)paren
)paren
(brace
r_if
c_cond
(paren
id|updelay
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;Initial state of slave_dev is &quot;
l_string|&quot;BOND_LINK_BACK&bslash;n&quot;
)paren
suffix:semicolon
id|new_slave-&gt;link
op_assign
id|BOND_LINK_BACK
suffix:semicolon
id|new_slave-&gt;delay
op_assign
id|updelay
suffix:semicolon
)brace
r_else
(brace
id|dprintk
c_func
(paren
l_string|&quot;Initial state of slave_dev is &quot;
l_string|&quot;BOND_LINK_UP&bslash;n&quot;
)paren
suffix:semicolon
id|new_slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
)brace
id|new_slave-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
)brace
r_else
(brace
id|dprintk
c_func
(paren
l_string|&quot;Initial state of slave_dev is &quot;
l_string|&quot;BOND_LINK_DOWN&bslash;n&quot;
)paren
suffix:semicolon
id|new_slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond_update_speed_duplex
c_func
(paren
id|new_slave
)paren
op_logical_and
(paren
id|new_slave-&gt;link
op_ne
id|BOND_LINK_DOWN
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: failed to get speed/duplex from %s, speed &quot;
l_string|&quot;forced to 100Mbps, duplex forced to Full.&bslash;n&quot;
comma
id|new_slave-&gt;dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Operation of 802.3ad mode requires ETHTOOL &quot;
l_string|&quot;support in base driver for proper aggregator &quot;
l_string|&quot;selection.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
op_logical_and
id|primary
)paren
(brace
multiline_comment|/* if there is a primary slave, remember it */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|primary
comma
id|new_slave-&gt;dev-&gt;name
)paren
op_eq
l_int|0
)paren
(brace
id|bond-&gt;primary_slave
op_assign
id|new_slave
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|bond_mode
)paren
(brace
r_case
id|BOND_MODE_ACTIVEBACKUP
suffix:colon
multiline_comment|/* if we&squot;re in active-backup mode, we need one and only one active&n;&t;&t; * interface. The backup interfaces will have their NOARP flag set&n;&t;&t; * because we need them to be completely deaf and not to respond to&n;&t;&t; * any ARP request on the network to avoid fooling a switch. Thus,&n;&t;&t; * since we guarantee that curr_active_slave always point to the last&n;&t;&t; * usable interface, we just have to verify this interface&squot;s flag.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
op_logical_neg
id|bond-&gt;curr_active_slave
)paren
op_logical_or
(paren
id|bond-&gt;curr_active_slave-&gt;dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
)paren
op_logical_and
(paren
id|new_slave-&gt;link
op_ne
id|BOND_LINK_DOWN
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;This is the first active slave&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* first slave or no active slave yet, and this link&n;&t;&t;&t;   is OK, so make this interface the active one */
id|bond_change_active_slave
c_func
(paren
id|bond
comma
id|new_slave
)paren
suffix:semicolon
)brace
r_else
(brace
id|dprintk
c_func
(paren
l_string|&quot;This is just a backup slave&bslash;n&quot;
)paren
suffix:semicolon
id|bond_set_slave_inactive_flags
c_func
(paren
id|new_slave
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BOND_MODE_8023AD
suffix:colon
multiline_comment|/* in 802.3ad mode, the internal mechanism&n;&t;&t; * will activate the slaves in the selected&n;&t;&t; * aggregator&n;&t;&t; */
id|bond_set_slave_inactive_flags
c_func
(paren
id|new_slave
)paren
suffix:semicolon
multiline_comment|/* if this is the first slave */
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
op_eq
l_int|1
)paren
(brace
id|SLAVE_AD_INFO
c_func
(paren
id|new_slave
)paren
dot
id|id
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Initialize AD with the number of times that the AD timer is called in 1 second&n;&t;&t;&t; * can be called only after the mac address of the bond is set&n;&t;&t;&t; */
id|bond_3ad_initialize
c_func
(paren
id|bond
comma
l_int|1000
op_div
id|AD_TIMER_INTERVAL
comma
id|lacp_fast
)paren
suffix:semicolon
)brace
r_else
(brace
id|SLAVE_AD_INFO
c_func
(paren
id|new_slave
)paren
dot
id|id
op_assign
id|SLAVE_AD_INFO
c_func
(paren
id|new_slave-&gt;prev
)paren
dot
id|id
op_plus
l_int|1
suffix:semicolon
)brace
id|bond_3ad_bind_slave
c_func
(paren
id|new_slave
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MODE_TLB
suffix:colon
r_case
id|BOND_MODE_ALB
suffix:colon
id|new_slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|bond-&gt;curr_active_slave
)paren
op_logical_and
(paren
id|new_slave-&gt;link
op_ne
id|BOND_LINK_DOWN
)paren
)paren
(brace
multiline_comment|/* first slave or no active slave yet, and this link&n;&t;&t;&t; * is OK, so make this interface the active one&n;&t;&t;&t; */
id|bond_change_active_slave
c_func
(paren
id|bond
comma
id|new_slave
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;This slave is always active in trunk mode&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* always active in trunk mode */
id|new_slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
multiline_comment|/* In trunking mode there is little meaning to curr_active_slave&n;&t;&t; * anyway (it holds no special properties of the bond device),&n;&t;&t; * so we can change it without calling change_active_interface()&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|bond-&gt;curr_active_slave
)paren
(brace
id|bond-&gt;curr_active_slave
op_assign
id|new_slave
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* switch(bond_mode) */
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|app_abi_ver
OL
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * !!! This is to support old versions of ifenslave.&n;&t;&t; * We can remove this in 2.5 because our ifenslave takes&n;&t;&t; * care of this for us.&n;&t;&t; * We check to see if the master has a mac address yet.&n;&t;&t; * If not, we&squot;ll give it the mac address of our slave device.&n;&t;&t; */
r_int
id|ndx
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|ndx
op_assign
l_int|0
suffix:semicolon
id|ndx
OL
id|bond_dev-&gt;addr_len
suffix:semicolon
id|ndx
op_increment
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;Checking ndx=%d of bond_dev-&gt;dev_addr&bslash;n&quot;
comma
id|ndx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_dev-&gt;dev_addr
(braket
id|ndx
)braket
op_ne
l_int|0
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;Found non-zero byte at ndx=%d&bslash;n&quot;
comma
id|ndx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ndx
op_eq
id|bond_dev-&gt;addr_len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We got all the way through the address and it was&n;&t;&t;&t; * all 0&squot;s.&n;&t;&t;&t; */
id|dprintk
c_func
(paren
l_string|&quot;%s doesn&squot;t have a MAC address yet.  &bslash;n&quot;
comma
id|bond_dev-&gt;name
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Going to give assign it from %s.&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
id|bond_sethwaddr
c_func
(paren
id|bond_dev
comma
id|slave_dev
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: enslaving %s as a%s interface with a%s link.&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave_dev-&gt;name
comma
id|new_slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
ques
c_cond
l_string|&quot;n active&quot;
suffix:colon
l_string|&quot; backup&quot;
comma
id|new_slave-&gt;link
op_ne
id|BOND_LINK_DOWN
ques
c_cond
l_string|&quot;n up&quot;
suffix:colon
l_string|&quot; down&quot;
)paren
suffix:semicolon
multiline_comment|/* enslave is successful */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Undo stages on error */
id|err_unset_master
suffix:colon
id|netdev_set_master
c_func
(paren
id|slave_dev
comma
l_int|NULL
)paren
suffix:semicolon
id|err_close
suffix:colon
id|dev_close
c_func
(paren
id|slave_dev
)paren
suffix:semicolon
id|err_restore_mac
suffix:colon
id|memcpy
c_func
(paren
id|addr.sa_data
comma
id|new_slave-&gt;perm_hwaddr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|addr.sa_family
op_assign
id|slave_dev-&gt;type
suffix:semicolon
id|slave_dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|slave_dev
comma
op_amp
id|addr
)paren
suffix:semicolon
id|err_free
suffix:colon
id|kfree
c_func
(paren
id|new_slave
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to release the slave device &lt;slave&gt; from the bond device &lt;master&gt;&n; * It is legal to access curr_active_slave without a lock because all the function&n; * is write-locked.&n; *&n; * The rules for slave state should be:&n; *   for Active/Backup:&n; *     Active stays on all backups go down&n; *   for Bonded connections:&n; *     The first up interface should be left on and all others downed.&n; */
DECL|function|bond_release
r_static
r_int
id|bond_release
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_struct
id|net_device
op_star
id|slave_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|slave
op_star
id|slave
comma
op_star
id|oldcurrent
suffix:semicolon
r_struct
id|sockaddr
id|addr
suffix:semicolon
r_int
id|mac_addr_differ
suffix:semicolon
multiline_comment|/* slave is not a slave or master is not master of this slave */
r_if
c_cond
(paren
op_logical_neg
(paren
id|slave_dev-&gt;flags
op_amp
id|IFF_SLAVE
)paren
op_logical_or
(paren
id|slave_dev-&gt;master
op_ne
id|bond_dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: Error: %s: cannot release %s.&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|slave
op_assign
id|bond_get_slave_by_dev
c_func
(paren
id|bond
comma
id|slave_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slave
)paren
(brace
multiline_comment|/* not a slave of this bond */
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: %s not enslaved&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mac_addr_differ
op_assign
id|memcmp
c_func
(paren
id|bond_dev-&gt;dev_addr
comma
id|slave-&gt;perm_hwaddr
comma
id|ETH_ALEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mac_addr_differ
op_logical_and
(paren
id|bond-&gt;slave_cnt
OG
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: the permanent HWaddr of %s &quot;
l_string|&quot;- %02X:%02X:%02X:%02X:%02X:%02X - is &quot;
l_string|&quot;still in use by %s. Set the HWaddr of &quot;
l_string|&quot;%s to a different address to avoid &quot;
l_string|&quot;conflicts.&bslash;n&quot;
comma
id|slave_dev-&gt;name
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|0
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|1
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|2
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|3
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|4
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|5
)braket
comma
id|bond_dev-&gt;name
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* Inform AD package of unbinding of slave. */
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
multiline_comment|/* must be called before the slave is&n;&t;&t; * detached from the list&n;&t;&t; */
id|bond_3ad_unbind_slave
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: releasing %s interface %s&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
(paren
id|slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
)paren
ques
c_cond
l_string|&quot;active&quot;
suffix:colon
l_string|&quot;backup&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
id|oldcurrent
op_assign
id|bond-&gt;curr_active_slave
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* release the slave from its bond */
id|bond_detach_slave
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;primary_slave
op_eq
id|slave
)paren
(brace
id|bond-&gt;primary_slave
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oldcurrent
op_eq
id|slave
)paren
(brace
id|bond_change_active_slave
c_func
(paren
id|bond
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
multiline_comment|/* Must be called only after the slave has been&n;&t;&t; * detached from the list and the curr_active_slave&n;&t;&t; * has been cleared (if our_slave == old_current),&n;&t;&t; * but before a new active slave is selected.&n;&t;&t; */
id|bond_alb_deinit_slave
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oldcurrent
op_eq
id|slave
)paren
(brace
id|bond_select_active_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bond-&gt;curr_active_slave
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: now running without any active &quot;
l_string|&quot;interface !&bslash;n&quot;
comma
id|bond_dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* If the mode USES_PRIMARY, then we should only remove its&n;&t; * promisc and mc settings if it was the curr_active_slave, but that was&n;&t; * already taken care of above when we detached the slave&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
multiline_comment|/* unset promiscuity level from slave */
r_if
c_cond
(paren
id|bond_dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|slave_dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* unset allmulti level from slave */
r_if
c_cond
(paren
id|bond_dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
id|dev_set_allmulti
c_func
(paren
id|slave_dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* flush master&squot;s mc_list from slave */
id|bond_mc_list_flush
c_func
(paren
id|bond_dev
comma
id|slave_dev
)paren
suffix:semicolon
)brace
id|netdev_set_master
c_func
(paren
id|slave_dev
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* close slave before restoring its mac address */
id|dev_close
c_func
(paren
id|slave_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|app_abi_ver
op_ge
l_int|1
)paren
(brace
multiline_comment|/* restore original (&quot;permanent&quot;) mac address */
id|memcpy
c_func
(paren
id|addr.sa_data
comma
id|slave-&gt;perm_hwaddr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|addr.sa_family
op_assign
id|slave_dev-&gt;type
suffix:semicolon
id|slave_dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|slave_dev
comma
op_amp
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/* restore the original state of the&n;&t; * IFF_NOARP flag that might have been&n;&t; * set by bond_set_slave_inactive_flags()&n;&t; */
r_if
c_cond
(paren
(paren
id|slave-&gt;original_flags
op_amp
id|IFF_NOARP
)paren
op_eq
l_int|0
)paren
(brace
id|slave_dev-&gt;flags
op_and_assign
op_complement
id|IFF_NOARP
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|slave
)paren
suffix:semicolon
multiline_comment|/* if the last slave was removed, zero the mac address&n;&t; * of the master so it will be set by the application&n;&t; * to the mac address of the first slave&n;&t; */
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
op_eq
l_int|0
)paren
(brace
id|memset
c_func
(paren
id|bond_dev-&gt;dev_addr
comma
l_int|0
comma
id|bond_dev-&gt;addr_len
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* deletion OK */
)brace
multiline_comment|/*&n; * This function releases all slaves.&n; */
DECL|function|bond_release_all
r_static
r_int
id|bond_release_all
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|slave
op_star
id|slave
suffix:semicolon
r_struct
id|net_device
op_star
id|slave_dev
suffix:semicolon
r_struct
id|sockaddr
id|addr
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
op_eq
l_int|0
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|bond-&gt;current_arp_slave
op_assign
l_int|NULL
suffix:semicolon
id|bond-&gt;primary_slave
op_assign
l_int|NULL
suffix:semicolon
id|bond_change_active_slave
c_func
(paren
id|bond
comma
l_int|NULL
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|bond-&gt;first_slave
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Inform AD package of unbinding of slave&n;&t;&t; * before slave is detached from the list.&n;&t;&t; */
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
id|bond_3ad_unbind_slave
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
id|slave_dev
op_assign
id|slave-&gt;dev
suffix:semicolon
id|bond_detach_slave
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
multiline_comment|/* must be called only after the slave&n;&t;&t;&t; * has been detached from the list&n;&t;&t;&t; */
id|bond_alb_deinit_slave
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
)brace
multiline_comment|/* now that the slave is detached, unlock and perform&n;&t;&t; * all the undo steps that should not be called from&n;&t;&t; * within a lock.&n;&t;&t; */
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* If the mode USES_PRIMARY, then we should only remove its&n;&t;&t; * promisc and mc settings if it was the curr_active_slave, but that was&n;&t;&t; * already taken care of above when we detached the slave&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
multiline_comment|/* unset promiscuity level from slave */
r_if
c_cond
(paren
id|bond_dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|dev_set_promiscuity
c_func
(paren
id|slave_dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* unset allmulti level from slave */
r_if
c_cond
(paren
id|bond_dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
id|dev_set_allmulti
c_func
(paren
id|slave_dev
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* flush master&squot;s mc_list from slave */
id|bond_mc_list_flush
c_func
(paren
id|bond_dev
comma
id|slave_dev
)paren
suffix:semicolon
)brace
id|netdev_set_master
c_func
(paren
id|slave_dev
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* close slave before restoring its mac address */
id|dev_close
c_func
(paren
id|slave_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|app_abi_ver
op_ge
l_int|1
)paren
(brace
multiline_comment|/* restore original (&quot;permanent&quot;) mac address*/
id|memcpy
c_func
(paren
id|addr.sa_data
comma
id|slave-&gt;perm_hwaddr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|addr.sa_family
op_assign
id|slave_dev-&gt;type
suffix:semicolon
id|slave_dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|slave_dev
comma
op_amp
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/* restore the original state of the IFF_NOARP flag that might have&n;&t;&t; * been set by bond_set_slave_inactive_flags()&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|slave-&gt;original_flags
op_amp
id|IFF_NOARP
)paren
op_eq
l_int|0
)paren
(brace
id|slave_dev-&gt;flags
op_and_assign
op_complement
id|IFF_NOARP
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|slave
)paren
suffix:semicolon
multiline_comment|/* re-acquire the lock before getting the next slave */
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* zero the mac address of the master so it will be&n;&t; * set by the application to the mac address of the&n;&t; * first slave&n;&t; */
id|memset
c_func
(paren
id|bond_dev-&gt;dev_addr
comma
l_int|0
comma
id|bond_dev-&gt;addr_len
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: released all slaves&bslash;n&quot;
comma
id|bond_dev-&gt;name
)paren
suffix:semicolon
id|out
suffix:colon
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function changes the active slave to slave &lt;slave_dev&gt;.&n; * It returns -EINVAL in the following cases.&n; *  - &lt;slave_dev&gt; is not found in the list.&n; *  - There is not active slave now.&n; *  - &lt;slave_dev&gt; is already active.&n; *  - The link state of &lt;slave_dev&gt; is not BOND_LINK_UP.&n; *  - &lt;slave_dev&gt; is not running.&n; * In these cases, this fuction does nothing.&n; * In the other cases, currnt_slave pointer is changed and 0 is returned.&n; */
DECL|function|bond_ioctl_change_active
r_static
r_int
id|bond_ioctl_change_active
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_struct
id|net_device
op_star
id|slave_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|slave
op_star
id|old_active
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|slave
op_star
id|new_active
op_assign
l_int|NULL
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Verify that master_dev is indeed the master of slave_dev */
r_if
c_cond
(paren
op_logical_neg
(paren
id|slave_dev-&gt;flags
op_amp
id|IFF_SLAVE
)paren
op_logical_or
(paren
id|slave_dev-&gt;master
op_ne
id|bond_dev
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|old_active
op_assign
id|bond-&gt;curr_active_slave
suffix:semicolon
id|new_active
op_assign
id|bond_get_slave_by_dev
c_func
(paren
id|bond
comma
id|slave_dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Changing to the current active: do nothing; return success.&n;&t; */
r_if
c_cond
(paren
id|new_active
op_logical_and
(paren
id|new_active
op_eq
id|old_active
)paren
)paren
(brace
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|new_active
)paren
op_logical_and
(paren
id|old_active
)paren
op_logical_and
(paren
id|new_active-&gt;link
op_eq
id|BOND_LINK_UP
)paren
op_logical_and
id|IS_UP
c_func
(paren
id|new_active-&gt;dev
)paren
)paren
(brace
id|bond_change_active_slave
c_func
(paren
id|bond
comma
id|new_active
)paren
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|bond_ethtool_ioctl
r_static
r_int
id|bond_ethtool_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_struct
id|ethtool_drvinfo
id|info
suffix:semicolon
r_void
op_star
id|addr
op_assign
id|ifr-&gt;ifr_data
suffix:semicolon
r_uint32
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|cmd
comma
(paren
r_uint32
op_star
)paren
id|addr
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|ETHTOOL_GDRVINFO
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
id|addr
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|info.driver
comma
l_string|&quot;ifenslave&quot;
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|new_abi_ver
suffix:semicolon
r_char
op_star
id|endptr
suffix:semicolon
id|new_abi_ver
op_assign
id|simple_strtoul
c_func
(paren
id|info.fw_version
comma
op_amp
id|endptr
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|endptr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: Error: got invalid ABI &quot;
l_string|&quot;version from application&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|orig_app_abi_ver
op_eq
op_minus
l_int|1
)paren
(brace
id|orig_app_abi_ver
op_assign
id|new_abi_ver
suffix:semicolon
)brace
id|app_abi_ver
op_assign
id|new_abi_ver
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|info.driver
comma
id|DRV_NAME
comma
l_int|32
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info.version
comma
id|DRV_VERSION
comma
l_int|32
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|info.fw_version
comma
l_int|32
comma
l_string|&quot;%d&quot;
comma
id|BOND_ABI_VERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|addr
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
DECL|function|bond_info_query
r_static
r_int
id|bond_info_query
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_struct
id|ifbond
op_star
id|info
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
id|info-&gt;bond_mode
op_assign
id|bond_mode
suffix:semicolon
id|info-&gt;miimon
op_assign
id|miimon
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|info-&gt;num_slaves
op_assign
id|bond-&gt;slave_cnt
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_slave_info_query
r_static
r_int
id|bond_slave_info_query
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_struct
id|ifslave
op_star
id|info
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|slave
op_star
id|slave
suffix:semicolon
r_int
id|i
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;slave_id
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|read_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
(paren
r_int
)paren
id|info-&gt;slave_id
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
(brace
id|strcpy
c_func
(paren
id|info-&gt;slave_name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
id|info-&gt;link
op_assign
id|slave-&gt;link
suffix:semicolon
id|info-&gt;state
op_assign
id|slave-&gt;state
suffix:semicolon
id|info-&gt;link_failure_count
op_assign
id|slave-&gt;link_failure_count
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------- Monitoring -------------------------------*/
multiline_comment|/* this function is called regularly to monitor each slave&squot;s link. */
DECL|function|bond_mii_monitor
r_static
r_void
id|bond_mii_monitor
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|slave
op_star
id|slave
comma
op_star
id|oldcurrent
suffix:semicolon
r_int
id|do_failover
op_assign
l_int|0
suffix:semicolon
r_int
id|delta_in_ticks
op_assign
(paren
id|miimon
op_star
id|HZ
)paren
op_div
l_int|1000
suffix:semicolon
r_int
id|i
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;kill_timers
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
op_eq
l_int|0
)paren
(brace
r_goto
id|re_arm
suffix:semicolon
)brace
multiline_comment|/* we will try to read the link status of each of our slaves, and&n;&t; * set their IFF_RUNNING flag appropriately. For each slave not&n;&t; * supporting MII status, we won&squot;t do anything so that a user-space&n;&t; * program could monitor the link itself if needed.&n;&t; */
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|oldcurrent
op_assign
id|bond-&gt;curr_active_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
r_struct
id|net_device
op_star
id|slave_dev
op_assign
id|slave-&gt;dev
suffix:semicolon
r_int
id|link_state
suffix:semicolon
id|u16
id|old_speed
op_assign
id|slave-&gt;speed
suffix:semicolon
id|u8
id|old_duplex
op_assign
id|slave-&gt;duplex
suffix:semicolon
id|link_state
op_assign
id|bond_check_dev_link
c_func
(paren
id|slave_dev
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|slave-&gt;link
)paren
(brace
r_case
id|BOND_LINK_UP
suffix:colon
multiline_comment|/* the link was up */
r_if
c_cond
(paren
id|link_state
op_eq
id|BMSR_LSTATUS
)paren
(brace
multiline_comment|/* link stays up, nothing more to do */
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* link going down */
id|slave-&gt;link
op_assign
id|BOND_LINK_FAIL
suffix:semicolon
id|slave-&gt;delay
op_assign
id|downdelay
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;link_failure_count
OL
id|UINT_MAX
)paren
(brace
id|slave-&gt;link_failure_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|downdelay
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: link status down for %s &quot;
l_string|&quot;interface %s, disabling it in &quot;
l_string|&quot;%d ms.&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|IS_UP
c_func
(paren
id|slave_dev
)paren
ques
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
ques
c_cond
(paren
(paren
id|slave
op_eq
id|oldcurrent
)paren
ques
c_cond
l_string|&quot;active &quot;
suffix:colon
l_string|&quot;backup &quot;
)paren
suffix:colon
l_string|&quot;&quot;
)paren
suffix:colon
l_string|&quot;idle &quot;
comma
id|slave_dev-&gt;name
comma
id|downdelay
op_star
id|miimon
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* no break ! fall through the BOND_LINK_FAIL test to&n;&t;&t;&t;   ensure proper action to be taken&n;&t;&t;&t;*/
r_case
id|BOND_LINK_FAIL
suffix:colon
multiline_comment|/* the link has just gone down */
r_if
c_cond
(paren
id|link_state
op_ne
id|BMSR_LSTATUS
)paren
(brace
multiline_comment|/* link stays down */
r_if
c_cond
(paren
id|slave-&gt;delay
op_le
l_int|0
)paren
(brace
multiline_comment|/* link down for too long time */
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
multiline_comment|/* in active/backup mode, we must&n;&t;&t;&t;&t;&t; * completely disable this interface&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
)paren
(brace
id|bond_set_slave_inactive_flags
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: link status definitely &quot;
l_string|&quot;down for interface %s, &quot;
l_string|&quot;disabling it&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* notify ad that the link status has changed */
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
id|bond_3ad_handle_link_change
c_func
(paren
id|slave
comma
id|BOND_LINK_DOWN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
id|bond_alb_handle_link_change
c_func
(paren
id|bond
comma
id|slave
comma
id|BOND_LINK_DOWN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slave
op_eq
id|oldcurrent
)paren
(brace
id|do_failover
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|slave-&gt;delay
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* link up again */
id|slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
id|slave-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: link status up again after %d &quot;
l_string|&quot;ms for interface %s.&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
(paren
id|downdelay
op_minus
id|slave-&gt;delay
)paren
op_star
id|miimon
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BOND_LINK_DOWN
suffix:colon
multiline_comment|/* the link was down */
r_if
c_cond
(paren
id|link_state
op_ne
id|BMSR_LSTATUS
)paren
(brace
multiline_comment|/* the link stays down, nothing more to do */
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* link going up */
id|slave-&gt;link
op_assign
id|BOND_LINK_BACK
suffix:semicolon
id|slave-&gt;delay
op_assign
id|updelay
suffix:semicolon
r_if
c_cond
(paren
id|updelay
)paren
(brace
multiline_comment|/* if updelay == 0, no need to&n;&t;&t;&t;&t;&t;   advertise about a 0 ms delay */
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: link status up for &quot;
l_string|&quot;interface %s, enabling it &quot;
l_string|&quot;in %d ms.&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave_dev-&gt;name
comma
id|updelay
op_star
id|miimon
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* no break ! fall through the BOND_LINK_BACK state in&n;&t;&t;&t;   case there&squot;s something to do.&n;&t;&t;&t;*/
r_case
id|BOND_LINK_BACK
suffix:colon
multiline_comment|/* the link has just come back */
r_if
c_cond
(paren
id|link_state
op_ne
id|BMSR_LSTATUS
)paren
(brace
multiline_comment|/* link down again */
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: link status down again after %d &quot;
l_string|&quot;ms for interface %s.&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
(paren
id|updelay
op_minus
id|slave-&gt;delay
)paren
op_star
id|miimon
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* link stays up */
r_if
c_cond
(paren
id|slave-&gt;delay
op_eq
l_int|0
)paren
(brace
multiline_comment|/* now the link has been up for long time enough */
id|slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
id|slave-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
multiline_comment|/* prevent it from being the active one */
id|slave-&gt;state
op_assign
id|BOND_STATE_BACKUP
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bond_mode
op_ne
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
multiline_comment|/* make it immediately active */
id|slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|slave
op_ne
id|bond-&gt;primary_slave
)paren
(brace
multiline_comment|/* prevent it from being the active one */
id|slave-&gt;state
op_assign
id|BOND_STATE_BACKUP
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: link status definitely &quot;
l_string|&quot;up for interface %s.&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* notify ad that the link status has changed */
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
id|bond_3ad_handle_link_change
c_func
(paren
id|slave
comma
id|BOND_LINK_UP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
id|bond_alb_handle_link_change
c_func
(paren
id|bond
comma
id|slave
comma
id|BOND_LINK_UP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|oldcurrent
)paren
op_logical_or
(paren
id|slave
op_eq
id|bond-&gt;primary_slave
)paren
)paren
(brace
id|do_failover
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|slave-&gt;delay
op_decrement
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Should not happen */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bonding: Error: %s  Illegal value (link=%d)&bslash;n&quot;
comma
id|slave-&gt;dev-&gt;name
comma
id|slave-&gt;link
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* end of switch (slave-&gt;link) */
id|bond_update_speed_duplex
c_func
(paren
id|slave
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
r_if
c_cond
(paren
id|old_speed
op_ne
id|slave-&gt;speed
)paren
(brace
id|bond_3ad_adapter_speed_changed
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_duplex
op_ne
id|slave-&gt;duplex
)paren
(brace
id|bond_3ad_adapter_duplex_changed
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* end of for */
r_if
c_cond
(paren
id|do_failover
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|bond_select_active_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldcurrent
op_logical_and
op_logical_neg
id|bond-&gt;curr_active_slave
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: now running without any active &quot;
l_string|&quot;interface !&bslash;n&quot;
comma
id|bond_dev-&gt;name
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
)brace
id|re_arm
suffix:colon
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;mii_timer
comma
id|jiffies
op_plus
id|delta_in_ticks
)paren
suffix:semicolon
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|bond_arp_send_all
r_static
r_void
id|bond_arp_send_all
c_func
(paren
r_struct
id|slave
op_star
id|slave
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|BOND_MAX_ARP_TARGETS
)paren
op_logical_and
id|arp_target
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|arp_target
(braket
id|i
)braket
comma
id|slave-&gt;dev
comma
id|my_ip
comma
l_int|NULL
comma
id|slave-&gt;dev-&gt;dev_addr
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * this function is called regularly to monitor each slave&squot;s link&n; * ensuring that traffic is being sent and received when arp monitoring&n; * is used in load-balancing mode. if the adapter has been dormant, then an&n; * arp is transmitted to generate traffic. see activebackup_arp_monitor for&n; * arp monitoring in active backup mode.&n; */
DECL|function|bond_loadbalance_arp_mon
r_static
r_void
id|bond_loadbalance_arp_mon
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|slave
op_star
id|slave
comma
op_star
id|oldcurrent
suffix:semicolon
r_int
id|do_failover
op_assign
l_int|0
suffix:semicolon
r_int
id|delta_in_ticks
op_assign
(paren
id|arp_interval
op_star
id|HZ
)paren
op_div
l_int|1000
suffix:semicolon
r_int
id|i
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;kill_timers
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
op_eq
l_int|0
)paren
(brace
r_goto
id|re_arm
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|oldcurrent
op_assign
id|bond-&gt;curr_active_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
multiline_comment|/* see if any of the previous devices are up now (i.e. they have&n;&t; * xmt and rcv traffic). the curr_active_slave does not come into&n;&t; * the picture unless it is null. also, slave-&gt;jiffies is not needed&n;&t; * here because we send an arp on each slave and give a slave as&n;&t; * long as it needs to get the tx/rx within the delta.&n;&t; * TODO: what about up/down delay in arp mode? it wasn&squot;t here before&n;&t; *       so it can wait&n;&t; */
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
r_if
c_cond
(paren
id|slave-&gt;link
op_ne
id|BOND_LINK_UP
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;trans_start
)paren
op_le
id|delta_in_ticks
)paren
op_logical_and
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_le
id|delta_in_ticks
)paren
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
id|slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
multiline_comment|/* primary_slave has no meaning in round-robin&n;&t;&t;&t;&t; * mode. the window of a slave being up and&n;&t;&t;&t;&t; * curr_active_slave being null after enslaving&n;&t;&t;&t;&t; * is closed.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|oldcurrent
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: link status definitely &quot;
l_string|&quot;up for interface %s, &quot;
comma
id|bond_dev-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
id|do_failover
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: interface %s is now up&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* slave-&gt;link == BOND_LINK_UP */
multiline_comment|/* not all switches will respond to an arp request&n;&t;&t;&t; * when the source ip is 0, so don&squot;t take the link down&n;&t;&t;&t; * if we don&squot;t know our ip yet&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;trans_start
)paren
op_ge
(paren
l_int|2
op_star
id|delta_in_ticks
)paren
)paren
op_logical_or
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_ge
(paren
l_int|2
op_star
id|delta_in_ticks
)paren
)paren
op_logical_and
id|my_ip
)paren
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
id|slave-&gt;state
op_assign
id|BOND_STATE_BACKUP
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;link_failure_count
OL
id|UINT_MAX
)paren
(brace
id|slave-&gt;link_failure_count
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: interface %s is now down.&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_eq
id|oldcurrent
)paren
(brace
id|do_failover
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* note: if switch is in round-robin mode, all links&n;&t;&t; * must tx arp to ensure all links rx an arp - otherwise&n;&t;&t; * links may oscillate or not come up at all; if switch is&n;&t;&t; * in something like xor mode, there is nothing we can&n;&t;&t; * do - all replies will be rx&squot;ed on same link causing slaves&n;&t;&t; * to be unstable during low/no traffic periods&n;&t;&t; */
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|slave-&gt;dev
)paren
)paren
(brace
id|bond_arp_send_all
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|do_failover
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|bond_select_active_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldcurrent
op_logical_and
op_logical_neg
id|bond-&gt;curr_active_slave
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: now running without any active &quot;
l_string|&quot;interface !&bslash;n&quot;
comma
id|bond_dev-&gt;name
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
)brace
id|re_arm
suffix:colon
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
comma
id|jiffies
op_plus
id|delta_in_ticks
)paren
suffix:semicolon
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * When using arp monitoring in active-backup mode, this function is&n; * called to determine if any backup slaves have went down or a new&n; * current slave needs to be found.&n; * The backup slaves never generate traffic, they are considered up by merely&n; * receiving traffic. If the current slave goes down, each backup slave will&n; * be given the opportunity to tx/rx an arp before being taken down - this&n; * prevents all slaves from being taken down due to the current slave not&n; * sending any traffic for the backups to receive. The arps are not necessarily&n; * necessary, any tx and rx traffic will keep the current slave up. While any&n; * rx traffic will keep the backup slaves up, the current slave is responsible&n; * for generating traffic to keep them up regardless of any other traffic they&n; * may have received.&n; * see loadbalance_arp_monitor for arp monitoring in load balancing mode&n; */
DECL|function|bond_activebackup_arp_mon
r_static
r_void
id|bond_activebackup_arp_mon
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|slave
op_star
id|slave
suffix:semicolon
r_int
id|delta_in_ticks
op_assign
(paren
id|arp_interval
op_star
id|HZ
)paren
op_div
l_int|1000
suffix:semicolon
r_int
id|i
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;kill_timers
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;slave_cnt
op_eq
l_int|0
)paren
(brace
r_goto
id|re_arm
suffix:semicolon
)brace
multiline_comment|/* determine if any slave has come up or any backup slave has&n;&t; * gone down&n;&t; * TODO: what about up/down delay in arp mode? it wasn&squot;t here before&n;&t; *       so it can wait&n;&t; */
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
r_if
c_cond
(paren
id|slave-&gt;link
op_ne
id|BOND_LINK_UP
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_le
id|delta_in_ticks
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|bond-&gt;curr_active_slave
)paren
op_logical_and
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;trans_start
)paren
op_le
id|delta_in_ticks
)paren
)paren
(brace
id|bond_change_active_slave
c_func
(paren
id|bond
comma
id|slave
)paren
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bond-&gt;curr_active_slave
op_ne
id|slave
)paren
(brace
multiline_comment|/* this slave has just come up but we&n;&t;&t;&t;&t;&t; * already have a current slave; this&n;&t;&t;&t;&t;&t; * can also happen if bond_enslave adds&n;&t;&t;&t;&t;&t; * a new slave that is up while we are&n;&t;&t;&t;&t;&t; * searching for a new slave&n;&t;&t;&t;&t;&t; */
id|bond_set_slave_inactive_flags
c_func
(paren
id|slave
)paren
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slave
op_eq
id|bond-&gt;curr_active_slave
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: %s is up and now the &quot;
l_string|&quot;active interface&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: backup interface %s is &quot;
l_string|&quot;now up&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|slave
op_ne
id|bond-&gt;curr_active_slave
)paren
op_logical_and
(paren
op_logical_neg
id|bond-&gt;current_arp_slave
)paren
op_logical_and
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_ge
l_int|3
op_star
id|delta_in_ticks
)paren
op_logical_and
id|my_ip
)paren
)paren
(brace
multiline_comment|/* a backup slave has gone down; three times&n;&t;&t;&t;&t; * the delta allows the current slave to be&n;&t;&t;&t;&t; * taken out before the backup slave.&n;&t;&t;&t;&t; * note: a non-null current_arp_slave indicates&n;&t;&t;&t;&t; * the curr_active_slave went down and we are&n;&t;&t;&t;&t; * searching for a new one; under this&n;&t;&t;&t;&t; * condition we only take the curr_active_slave&n;&t;&t;&t;&t; * down - this gives each slave a chance to&n;&t;&t;&t;&t; * tx/rx traffic before being taken out&n;&t;&t;&t;&t; */
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;link_failure_count
OL
id|UINT_MAX
)paren
(brace
id|slave-&gt;link_failure_count
op_increment
suffix:semicolon
)brace
id|bond_set_slave_inactive_flags
c_func
(paren
id|slave
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: backup interface %s is now down&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
)brace
)brace
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|slave
op_assign
id|bond-&gt;curr_active_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
)paren
(brace
multiline_comment|/* if we have sent traffic in the past 2*arp_intervals but&n;&t;&t; * haven&squot;t xmit and rx traffic in that time interval, select&n;&t;&t; * a different slave. slave-&gt;jiffies is only updated when&n;&t;&t; * a slave first becomes the curr_active_slave - not necessarily&n;&t;&t; * after every arp; this ensures the slave has a full 2*delta&n;&t;&t; * before being taken out. if a primary is being used, check&n;&t;&t; * if it is up and needs to take over as the curr_active_slave&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;trans_start
)paren
op_ge
(paren
l_int|2
op_star
id|delta_in_ticks
)paren
)paren
op_logical_or
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_ge
(paren
l_int|2
op_star
id|delta_in_ticks
)paren
)paren
op_logical_and
id|my_ip
)paren
)paren
op_logical_and
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;jiffies
)paren
op_ge
l_int|2
op_star
id|delta_in_ticks
)paren
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;link_failure_count
OL
id|UINT_MAX
)paren
(brace
id|slave-&gt;link_failure_count
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: link status down for active interface &quot;
l_string|&quot;%s, disabling it&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|bond_select_active_slave
c_func
(paren
id|bond
)paren
suffix:semicolon
id|slave
op_assign
id|bond-&gt;curr_active_slave
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
id|slave
suffix:semicolon
r_if
c_cond
(paren
id|slave
)paren
(brace
id|slave-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|bond-&gt;primary_slave
)paren
op_logical_and
(paren
id|bond-&gt;primary_slave
op_ne
id|slave
)paren
op_logical_and
(paren
id|bond-&gt;primary_slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
)paren
(brace
multiline_comment|/* at this point, slave is the curr_active_slave */
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: changing from interface %s to primary &quot;
l_string|&quot;interface %s&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave-&gt;dev-&gt;name
comma
id|bond-&gt;primary_slave-&gt;dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* primary is up so switch to it */
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|bond_change_active_slave
c_func
(paren
id|bond
comma
id|bond-&gt;primary_slave
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|slave
op_assign
id|bond-&gt;primary_slave
suffix:semicolon
id|slave-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
)brace
r_else
(brace
id|bond-&gt;current_arp_slave
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* the current slave must tx an arp to ensure backup slaves&n;&t;&t; * rx traffic&n;&t;&t; */
r_if
c_cond
(paren
id|slave
op_logical_and
id|my_ip
)paren
(brace
id|bond_arp_send_all
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* if we don&squot;t have a curr_active_slave, search for the next available&n;&t; * backup slave from the current_arp_slave and make it the candidate&n;&t; * for becoming the curr_active_slave&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|slave
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bond-&gt;current_arp_slave
)paren
(brace
id|bond-&gt;current_arp_slave
op_assign
id|bond-&gt;first_slave
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;current_arp_slave
)paren
(brace
id|bond_set_slave_inactive_flags
c_func
(paren
id|bond-&gt;current_arp_slave
)paren
suffix:semicolon
multiline_comment|/* search for next candidate */
id|bond_for_each_slave_from
c_func
(paren
id|bond
comma
id|slave
comma
id|i
comma
id|bond-&gt;current_arp_slave
)paren
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|slave-&gt;dev
)paren
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_BACK
suffix:semicolon
id|bond_set_slave_active_flags
c_func
(paren
id|slave
)paren
suffix:semicolon
id|bond_arp_send_all
c_func
(paren
id|slave
)paren
suffix:semicolon
id|slave-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
id|slave
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* if the link state is up at this point, we&n;&t;&t;&t;&t; * mark it down - this can happen if we have&n;&t;&t;&t;&t; * simultaneous link failures and&n;&t;&t;&t;&t; * reselect_active_interface doesn&squot;t make this&n;&t;&t;&t;&t; * one the current slave so it is still marked&n;&t;&t;&t;&t; * up when it is actually down&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;link_failure_count
OL
id|UINT_MAX
)paren
(brace
id|slave-&gt;link_failure_count
op_increment
suffix:semicolon
)brace
id|bond_set_slave_inactive_flags
c_func
(paren
id|slave
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: %s: backup interface %s is &quot;
l_string|&quot;now down.&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
id|re_arm
suffix:colon
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
comma
id|jiffies
op_plus
id|delta_in_ticks
)paren
suffix:semicolon
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------ proc/seq_file-------------------------------*/
macro_line|#ifdef CONFIG_PROC_FS
DECL|macro|SEQ_START_TOKEN
mdefine_line|#define SEQ_START_TOKEN ((void *)1)
DECL|function|bond_info_seq_start
r_static
r_void
op_star
id|bond_info_seq_start
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|seq
op_member_access_from_pointer
r_private
suffix:semicolon
id|loff_t
id|off
op_assign
l_int|0
suffix:semicolon
r_struct
id|slave
op_star
id|slave
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* make sure the bond won&squot;t be taken away */
id|read_lock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pos
op_eq
l_int|0
)paren
(brace
r_return
id|SEQ_START_TOKEN
suffix:semicolon
)brace
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
r_if
c_cond
(paren
op_increment
id|off
op_eq
op_star
id|pos
)paren
(brace
r_return
id|slave
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|bond_info_seq_next
r_static
r_void
op_star
id|bond_info_seq_next
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|seq
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|slave
op_star
id|slave
op_assign
id|v
suffix:semicolon
op_increment
op_star
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
id|SEQ_START_TOKEN
)paren
(brace
r_return
id|bond-&gt;first_slave
suffix:semicolon
)brace
id|slave
op_assign
id|slave-&gt;next
suffix:semicolon
r_return
(paren
id|slave
op_eq
id|bond-&gt;first_slave
)paren
ques
c_cond
l_int|NULL
suffix:colon
id|slave
suffix:semicolon
)brace
DECL|function|bond_info_seq_stop
r_static
r_void
id|bond_info_seq_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|seq
op_member_access_from_pointer
r_private
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|dev_base_lock
)paren
suffix:semicolon
)brace
DECL|function|bond_info_show_master
r_static
r_void
id|bond_info_show_master
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|slave
op_star
id|curr
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|curr
op_assign
id|bond-&gt;curr_active_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;Bonding Mode: %s&bslash;n&quot;
comma
id|bond_mode_name
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|curr
)paren
(brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;Currently Active Slave: %s&bslash;n&quot;
comma
id|curr-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;MII Status: %s&bslash;n&quot;
comma
(paren
id|curr
)paren
ques
c_cond
l_string|&quot;up&quot;
suffix:colon
l_string|&quot;down&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;MII Polling Interval (ms): %d&bslash;n&quot;
comma
id|miimon
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;Up Delay (ms): %d&bslash;n&quot;
comma
id|updelay
op_star
id|miimon
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;Down Delay (ms): %d&bslash;n&quot;
comma
id|downdelay
op_star
id|miimon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
r_struct
id|ad_info
id|ad_info
suffix:semicolon
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;n802.3ad info&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_3ad_get_active_agg_info
c_func
(paren
id|bond
comma
op_amp
id|ad_info
)paren
)paren
(brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;bond %s has no active aggregator&bslash;n&quot;
comma
id|bond-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;Active Aggregator Info:&bslash;n&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;tAggregator ID: %d&bslash;n&quot;
comma
id|ad_info.aggregator_id
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;tNumber of ports: %d&bslash;n&quot;
comma
id|ad_info.ports
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;tActor Key: %d&bslash;n&quot;
comma
id|ad_info.actor_key
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;tPartner Key: %d&bslash;n&quot;
comma
id|ad_info.partner_key
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;tPartner Mac Address: %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|ad_info.partner_system
(braket
l_int|0
)braket
comma
id|ad_info.partner_system
(braket
l_int|1
)braket
comma
id|ad_info.partner_system
(braket
l_int|2
)braket
comma
id|ad_info.partner_system
(braket
l_int|3
)braket
comma
id|ad_info.partner_system
(braket
l_int|4
)braket
comma
id|ad_info.partner_system
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|bond_info_show_slave
r_static
r_void
id|bond_info_show_slave
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_const
r_struct
id|slave
op_star
id|slave
)paren
(brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;nSlave Interface: %s&bslash;n&quot;
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;MII Status: %s&bslash;n&quot;
comma
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
ques
c_cond
l_string|&quot;up&quot;
suffix:colon
l_string|&quot;down&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;Link Failure Count: %d&bslash;n&quot;
comma
id|slave-&gt;link_failure_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|app_abi_ver
op_ge
l_int|1
)paren
(brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;Permanent HW addr: %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|0
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|1
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|2
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|3
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|4
)braket
comma
id|slave-&gt;perm_hwaddr
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
r_const
r_struct
id|aggregator
op_star
id|agg
op_assign
id|SLAVE_AD_INFO
c_func
(paren
id|slave
)paren
dot
id|port.aggregator
suffix:semicolon
r_if
c_cond
(paren
id|agg
)paren
(brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;Aggregator ID: %d&bslash;n&quot;
comma
id|agg-&gt;aggregator_identifier
)paren
suffix:semicolon
)brace
r_else
(brace
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;Aggregator ID: N/A&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|bond_info_seq_show
r_static
r_int
id|bond_info_seq_show
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|v
)paren
(brace
r_if
c_cond
(paren
id|v
op_eq
id|SEQ_START_TOKEN
)paren
(brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|version
)paren
suffix:semicolon
id|bond_info_show_master
c_func
(paren
id|seq
comma
id|seq
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
)brace
r_else
(brace
id|bond_info_show_slave
c_func
(paren
id|seq
comma
id|v
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|bond_info_seq_ops
r_static
r_struct
id|seq_operations
id|bond_info_seq_ops
op_assign
(brace
dot
id|start
op_assign
id|bond_info_seq_start
comma
dot
id|next
op_assign
id|bond_info_seq_next
comma
dot
id|stop
op_assign
id|bond_info_seq_stop
comma
dot
id|show
op_assign
id|bond_info_seq_show
comma
)brace
suffix:semicolon
DECL|function|bond_info_open
r_static
r_int
id|bond_info_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|seq_file
op_star
id|seq
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|proc
suffix:semicolon
r_int
id|res
suffix:semicolon
id|res
op_assign
id|seq_open
c_func
(paren
id|file
comma
op_amp
id|bond_info_seq_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
multiline_comment|/* recover the pointer buried in proc_dir_entry data */
id|seq
op_assign
id|file-&gt;private_data
suffix:semicolon
id|proc
op_assign
id|PDE
c_func
(paren
id|inode
)paren
suffix:semicolon
id|seq
op_member_access_from_pointer
r_private
op_assign
id|proc-&gt;data
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|variable|bond_info_fops
r_static
r_struct
id|file_operations
id|bond_info_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|bond_info_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|seq_release
comma
)brace
suffix:semicolon
DECL|function|bond_create_proc_entry
r_static
r_int
id|bond_create_proc_entry
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|net_device
op_star
id|bond_dev
op_assign
id|bond-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|bond_proc_dir
)paren
(brace
id|bond-&gt;proc_entry
op_assign
id|create_proc_entry
c_func
(paren
id|bond_dev-&gt;name
comma
id|S_IRUGO
comma
id|bond_proc_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;proc_entry
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: Cannot create /proc/net/%s/%s&bslash;n&quot;
comma
id|DRV_NAME
comma
id|bond_dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|bond-&gt;proc_entry-&gt;data
op_assign
id|bond
suffix:semicolon
id|bond-&gt;proc_entry-&gt;proc_fops
op_assign
op_amp
id|bond_info_fops
suffix:semicolon
id|bond-&gt;proc_entry-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|memcpy
c_func
(paren
id|bond-&gt;proc_file_name
comma
id|bond_dev-&gt;name
comma
id|IFNAMSIZ
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_remove_proc_entry
r_static
r_void
id|bond_remove_proc_entry
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_if
c_cond
(paren
id|bond_proc_dir
op_logical_and
id|bond-&gt;proc_entry
)paren
(brace
id|remove_proc_entry
c_func
(paren
id|bond-&gt;proc_file_name
comma
id|bond_proc_dir
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bond-&gt;proc_file_name
comma
l_int|0
comma
id|IFNAMSIZ
)paren
suffix:semicolon
id|bond-&gt;proc_entry
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Create the bonding directory under /proc/net, if doesn&squot;t exist yet.&n; * Caller must hold rtnl_lock.&n; */
DECL|function|bond_create_proc_dir
r_static
r_void
id|bond_create_proc_dir
c_func
(paren
r_void
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|DRV_NAME
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bond_proc_dir
op_assign
id|proc_net-&gt;subdir
suffix:semicolon
id|bond_proc_dir
suffix:semicolon
id|bond_proc_dir
op_assign
id|bond_proc_dir-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|bond_proc_dir-&gt;namelen
op_eq
id|len
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|bond_proc_dir-&gt;name
comma
id|DRV_NAME
comma
id|len
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|bond_proc_dir
)paren
(brace
id|bond_proc_dir
op_assign
id|proc_mkdir
c_func
(paren
id|DRV_NAME
comma
id|proc_net
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_proc_dir
)paren
(brace
id|bond_proc_dir-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: cannot create /proc/net/%s&bslash;n&quot;
comma
id|DRV_NAME
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Destroy the bonding directory under /proc/net, if empty.&n; * Caller must hold rtnl_lock.&n; */
DECL|function|bond_destroy_proc_dir
r_static
r_void
id|bond_destroy_proc_dir
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|de
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bond_proc_dir
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* verify that the /proc dir is empty */
r_for
c_loop
(paren
id|de
op_assign
id|bond_proc_dir-&gt;subdir
suffix:semicolon
id|de
suffix:semicolon
id|de
op_assign
id|de-&gt;next
)paren
(brace
multiline_comment|/* ignore . and .. */
r_if
c_cond
(paren
op_star
(paren
id|de-&gt;name
)paren
op_ne
l_char|&squot;.&squot;
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|de
)paren
(brace
r_if
c_cond
(paren
id|bond_proc_dir-&gt;owner
op_eq
id|THIS_MODULE
)paren
(brace
id|bond_proc_dir-&gt;owner
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
id|remove_proc_entry
c_func
(paren
id|DRV_NAME
comma
id|proc_net
)paren
suffix:semicolon
id|bond_proc_dir
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_PROC_FS */
multiline_comment|/*-------------------------- netdev event handling --------------------------*/
multiline_comment|/*&n; * Change device name&n; */
DECL|function|bond_event_changename
r_static
r_int
id|bond_event_changename
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
macro_line|#ifdef CONFIG_PROC_FS
id|bond_remove_proc_entry
c_func
(paren
id|bond
)paren
suffix:semicolon
id|bond_create_proc_entry
c_func
(paren
id|bond
)paren
suffix:semicolon
macro_line|#endif
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|function|bond_master_netdev_event
r_static
r_int
id|bond_master_netdev_event
c_func
(paren
r_int
r_int
id|event
comma
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|event_bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|NETDEV_CHANGENAME
suffix:colon
r_return
id|bond_event_changename
c_func
(paren
id|event_bond
)paren
suffix:semicolon
r_case
id|NETDEV_UNREGISTER
suffix:colon
multiline_comment|/*&n;&t;&t; * TODO: remove a bond from the list?&n;&t;&t; */
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|function|bond_slave_netdev_event
r_static
r_int
id|bond_slave_netdev_event
c_func
(paren
r_int
r_int
id|event
comma
r_struct
id|net_device
op_star
id|slave_dev
)paren
(brace
r_struct
id|net_device
op_star
id|bond_dev
op_assign
id|slave_dev-&gt;master
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|NETDEV_UNREGISTER
suffix:colon
r_if
c_cond
(paren
id|bond_dev
)paren
(brace
id|bond_release
c_func
(paren
id|bond_dev
comma
id|slave_dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|NETDEV_CHANGE
suffix:colon
multiline_comment|/*&n;&t;&t; * TODO: is this what we get if somebody&n;&t;&t; * sets up a hierarchical bond, then rmmod&squot;s&n;&t;&t; * one of the slave bonding devices?&n;&t;&t; */
r_break
suffix:semicolon
r_case
id|NETDEV_DOWN
suffix:colon
multiline_comment|/*&n;&t;&t; * ... Or is it this?&n;&t;&t; */
r_break
suffix:semicolon
r_case
id|NETDEV_CHANGEMTU
suffix:colon
multiline_comment|/*&n;&t;&t; * TODO: Should slaves be allowed to&n;&t;&t; * independently alter their MTU?  For&n;&t;&t; * an active-backup bond, slaves need&n;&t;&t; * not be the same type of device, so&n;&t;&t; * MTUs may vary.  For other modes,&n;&t;&t; * slaves arguably should have the&n;&t;&t; * same MTUs. To do this, we&squot;d need to&n;&t;&t; * take over the slave&squot;s change_mtu&n;&t;&t; * function for the duration of their&n;&t;&t; * servitude.&n;&t;&t; */
r_break
suffix:semicolon
r_case
id|NETDEV_CHANGENAME
suffix:colon
multiline_comment|/*&n;&t;&t; * TODO: handle changing the primary&squot;s name&n;&t;&t; */
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
multiline_comment|/*&n; * bond_netdev_event: handle netdev notifier chain events.&n; *&n; * This function receives events for the netdev chain.  The caller (an&n; * ioctl handler calling notifier_call_chain) holds the necessary&n; * locks for us to safely manipulate the slave devices (RTNL lock,&n; * dev_probe_lock).&n; */
DECL|function|bond_netdev_event
r_static
r_int
id|bond_netdev_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|net_device
op_star
id|event_dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|ptr
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;event_dev: %s, event: %lx&bslash;n&quot;
comma
(paren
id|event_dev
ques
c_cond
id|event_dev-&gt;name
suffix:colon
l_string|&quot;None&quot;
)paren
comma
id|event
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event_dev-&gt;flags
op_amp
id|IFF_MASTER
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;IFF_MASTER&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|bond_master_netdev_event
c_func
(paren
id|event
comma
id|event_dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|event_dev-&gt;flags
op_amp
id|IFF_SLAVE
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;IFF_SLAVE&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|bond_slave_netdev_event
c_func
(paren
id|event
comma
id|event_dev
)paren
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|bond_netdev_notifier
r_static
r_struct
id|notifier_block
id|bond_netdev_notifier
op_assign
(brace
dot
id|notifier_call
op_assign
id|bond_netdev_event
comma
)brace
suffix:semicolon
multiline_comment|/*-------------------------- Packet type handling ---------------------------*/
multiline_comment|/* register to receive lacpdus on a bond */
DECL|function|bond_register_lacpdu
r_static
r_void
id|bond_register_lacpdu
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|packet_type
op_star
id|pk_type
op_assign
op_amp
(paren
id|BOND_AD_INFO
c_func
(paren
id|bond
)paren
dot
id|ad_pkt_type
)paren
suffix:semicolon
multiline_comment|/* initialize packet type */
id|pk_type-&gt;type
op_assign
id|PKT_TYPE_LACPDU
suffix:semicolon
id|pk_type-&gt;dev
op_assign
id|bond-&gt;dev
suffix:semicolon
id|pk_type-&gt;func
op_assign
id|bond_3ad_lacpdu_recv
suffix:semicolon
id|dev_add_pack
c_func
(paren
id|pk_type
)paren
suffix:semicolon
)brace
multiline_comment|/* unregister to receive lacpdus on a bond */
DECL|function|bond_unregister_lacpdu
r_static
r_void
id|bond_unregister_lacpdu
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
id|dev_remove_pack
c_func
(paren
op_amp
(paren
id|BOND_AD_INFO
c_func
(paren
id|bond
)paren
dot
id|ad_pkt_type
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------- Device entry points ----------------------------*/
DECL|function|bond_open
r_static
r_int
id|bond_open
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|timer_list
op_star
id|mii_timer
op_assign
op_amp
id|bond-&gt;mii_timer
suffix:semicolon
r_struct
id|timer_list
op_star
id|arp_timer
op_assign
op_amp
id|bond-&gt;arp_timer
suffix:semicolon
id|bond-&gt;kill_timers
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
r_struct
id|timer_list
op_star
id|alb_timer
op_assign
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
dot
id|alb_timer
)paren
suffix:semicolon
multiline_comment|/* bond_alb_initialize must be called before the timer&n;&t;&t; * is started.&n;&t;&t; */
r_if
c_cond
(paren
id|bond_alb_initialize
c_func
(paren
id|bond
comma
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
)paren
(brace
multiline_comment|/* something went wrong - fail the open operation */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|init_timer
c_func
(paren
id|alb_timer
)paren
suffix:semicolon
id|alb_timer-&gt;expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|alb_timer-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|bond
suffix:semicolon
id|alb_timer-&gt;function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|bond_alb_monitor
suffix:semicolon
id|add_timer
c_func
(paren
id|alb_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|miimon
)paren
(brace
multiline_comment|/* link check interval, in milliseconds. */
id|init_timer
c_func
(paren
id|mii_timer
)paren
suffix:semicolon
id|mii_timer-&gt;expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|mii_timer-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|bond_dev
suffix:semicolon
id|mii_timer-&gt;function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|bond_mii_monitor
suffix:semicolon
id|add_timer
c_func
(paren
id|mii_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp_interval
)paren
(brace
multiline_comment|/* arp interval, in milliseconds. */
id|init_timer
c_func
(paren
id|arp_timer
)paren
suffix:semicolon
id|arp_timer-&gt;expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|arp_timer-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|bond_dev
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
id|arp_timer-&gt;function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|bond_activebackup_arp_mon
suffix:semicolon
)brace
r_else
(brace
id|arp_timer-&gt;function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|bond_loadbalance_arp_mon
suffix:semicolon
)brace
id|add_timer
c_func
(paren
id|arp_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
r_struct
id|timer_list
op_star
id|ad_timer
op_assign
op_amp
(paren
id|BOND_AD_INFO
c_func
(paren
id|bond
)paren
dot
id|ad_timer
)paren
suffix:semicolon
id|init_timer
c_func
(paren
id|ad_timer
)paren
suffix:semicolon
id|ad_timer-&gt;expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|ad_timer-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|bond
suffix:semicolon
id|ad_timer-&gt;function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|bond_3ad_state_machine_handler
suffix:semicolon
id|add_timer
c_func
(paren
id|ad_timer
)paren
suffix:semicolon
multiline_comment|/* register to receive LACPDUs */
id|bond_register_lacpdu
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_close
r_static
r_int
id|bond_close
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|bond_mc_list_destroy
c_func
(paren
id|bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
multiline_comment|/* Unregister the receive of LACPDUs */
id|bond_unregister_lacpdu
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
multiline_comment|/* signal timers not to re-arm */
id|bond-&gt;kill_timers
op_assign
l_int|1
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* del_timer_sync must run without holding the bond-&gt;lock&n;&t; * because a running timer might be trying to hold it too&n;&t; */
r_if
c_cond
(paren
id|miimon
)paren
(brace
multiline_comment|/* link check interval, in milliseconds. */
id|del_timer_sync
c_func
(paren
op_amp
id|bond-&gt;mii_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp_interval
)paren
(brace
multiline_comment|/* arp interval, in milliseconds. */
id|del_timer_sync
c_func
(paren
op_amp
id|bond-&gt;arp_timer
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|bond_mode
)paren
(brace
r_case
id|BOND_MODE_8023AD
suffix:colon
id|del_timer_sync
c_func
(paren
op_amp
(paren
id|BOND_AD_INFO
c_func
(paren
id|bond
)paren
dot
id|ad_timer
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MODE_TLB
suffix:colon
r_case
id|BOND_MODE_ALB
suffix:colon
id|del_timer_sync
c_func
(paren
op_amp
(paren
id|BOND_ALB_INFO
c_func
(paren
id|bond
)paren
dot
id|alb_timer
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* Release the bonded slaves */
id|bond_release_all
c_func
(paren
id|bond_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
multiline_comment|/* Must be called only after all&n;&t;&t; * slaves have been released&n;&t;&t; */
id|bond_alb_deinitialize
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|bond_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|stats
op_assign
op_amp
(paren
id|bond-&gt;stats
)paren
comma
op_star
id|sstats
suffix:semicolon
r_struct
id|slave
op_star
id|slave
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
id|stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
)paren
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
id|sstats
op_assign
id|slave-&gt;dev
op_member_access_from_pointer
id|get_stats
c_func
(paren
id|slave-&gt;dev
)paren
suffix:semicolon
id|stats-&gt;rx_packets
op_add_assign
id|sstats-&gt;rx_packets
suffix:semicolon
id|stats-&gt;rx_bytes
op_add_assign
id|sstats-&gt;rx_bytes
suffix:semicolon
id|stats-&gt;rx_errors
op_add_assign
id|sstats-&gt;rx_errors
suffix:semicolon
id|stats-&gt;rx_dropped
op_add_assign
id|sstats-&gt;rx_dropped
suffix:semicolon
id|stats-&gt;tx_packets
op_add_assign
id|sstats-&gt;tx_packets
suffix:semicolon
id|stats-&gt;tx_bytes
op_add_assign
id|sstats-&gt;tx_bytes
suffix:semicolon
id|stats-&gt;tx_errors
op_add_assign
id|sstats-&gt;tx_errors
suffix:semicolon
id|stats-&gt;tx_dropped
op_add_assign
id|sstats-&gt;tx_dropped
suffix:semicolon
id|stats-&gt;multicast
op_add_assign
id|sstats-&gt;multicast
suffix:semicolon
id|stats-&gt;collisions
op_add_assign
id|sstats-&gt;collisions
suffix:semicolon
id|stats-&gt;rx_length_errors
op_add_assign
id|sstats-&gt;rx_length_errors
suffix:semicolon
id|stats-&gt;rx_over_errors
op_add_assign
id|sstats-&gt;rx_over_errors
suffix:semicolon
id|stats-&gt;rx_crc_errors
op_add_assign
id|sstats-&gt;rx_crc_errors
suffix:semicolon
id|stats-&gt;rx_frame_errors
op_add_assign
id|sstats-&gt;rx_frame_errors
suffix:semicolon
id|stats-&gt;rx_fifo_errors
op_add_assign
id|sstats-&gt;rx_fifo_errors
suffix:semicolon
id|stats-&gt;rx_missed_errors
op_add_assign
id|sstats-&gt;rx_missed_errors
suffix:semicolon
id|stats-&gt;tx_aborted_errors
op_add_assign
id|sstats-&gt;tx_aborted_errors
suffix:semicolon
id|stats-&gt;tx_carrier_errors
op_add_assign
id|sstats-&gt;tx_carrier_errors
suffix:semicolon
id|stats-&gt;tx_fifo_errors
op_add_assign
id|sstats-&gt;tx_fifo_errors
suffix:semicolon
id|stats-&gt;tx_heartbeat_errors
op_add_assign
id|sstats-&gt;tx_heartbeat_errors
suffix:semicolon
id|stats-&gt;tx_window_errors
op_add_assign
id|sstats-&gt;tx_window_errors
suffix:semicolon
)brace
id|read_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
id|stats
suffix:semicolon
)brace
DECL|function|bond_do_ioctl
r_static
r_int
id|bond_do_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_struct
id|net_device
op_star
id|slave_dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ifbond
op_star
id|u_binfo
op_assign
l_int|NULL
comma
id|k_binfo
suffix:semicolon
r_struct
id|ifslave
op_star
id|u_sinfo
op_assign
l_int|NULL
comma
id|k_sinfo
suffix:semicolon
r_struct
id|mii_ioctl_data
op_star
id|mii
op_assign
l_int|NULL
suffix:semicolon
r_int
id|prev_abi_ver
op_assign
id|orig_app_abi_ver
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;bond_ioctl: master=%s, cmd=%d&bslash;n&quot;
comma
id|bond_dev-&gt;name
comma
id|cmd
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCETHTOOL
suffix:colon
r_return
id|bond_ethtool_ioctl
c_func
(paren
id|bond_dev
comma
id|ifr
)paren
suffix:semicolon
r_case
id|SIOCGMIIPHY
suffix:colon
id|mii
op_assign
(paren
r_struct
id|mii_ioctl_data
op_star
)paren
op_amp
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mii
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mii-&gt;phy_id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fall Through */
r_case
id|SIOCGMIIREG
suffix:colon
multiline_comment|/*&n;&t;&t; * We do this again just in case we were called by SIOCGMIIREG&n;&t;&t; * instead of SIOCGMIIPHY.&n;&t;&t; */
id|mii
op_assign
(paren
r_struct
id|mii_ioctl_data
op_star
)paren
op_amp
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mii
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mii-&gt;reg_num
op_eq
l_int|1
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
id|mii-&gt;val_out
op_assign
l_int|0
suffix:semicolon
id|read_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;curr_active_slave
)paren
(brace
id|mii-&gt;val_out
op_assign
id|BMSR_LSTATUS
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|read_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|BOND_INFO_QUERY_OLD
suffix:colon
r_case
id|SIOCBONDINFOQUERY
suffix:colon
id|u_binfo
op_assign
(paren
r_struct
id|ifbond
op_star
)paren
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|k_binfo
comma
id|u_binfo
comma
r_sizeof
(paren
id|ifbond
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|res
op_assign
id|bond_info_query
c_func
(paren
id|bond_dev
comma
op_amp
id|k_binfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|u_binfo
comma
op_amp
id|k_binfo
comma
r_sizeof
(paren
id|ifbond
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
id|res
suffix:semicolon
r_case
id|BOND_SLAVE_INFO_QUERY_OLD
suffix:colon
r_case
id|SIOCBONDSLAVEINFOQUERY
suffix:colon
id|u_sinfo
op_assign
(paren
r_struct
id|ifslave
op_star
)paren
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|k_sinfo
comma
id|u_sinfo
comma
r_sizeof
(paren
id|ifslave
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|res
op_assign
id|bond_slave_info_query
c_func
(paren
id|bond_dev
comma
op_amp
id|k_sinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|u_sinfo
comma
op_amp
id|k_sinfo
comma
r_sizeof
(paren
id|ifslave
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
id|res
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Go on */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|orig_app_abi_ver
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* no orig_app_abi_ver was provided yet, so we&squot;ll use the&n;&t;&t; * current one from now on, even if it&squot;s 0&n;&t;&t; */
id|orig_app_abi_ver
op_assign
id|app_abi_ver
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|orig_app_abi_ver
op_ne
id|app_abi_ver
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: Error: already using ifenslave ABI version %d; to &quot;
l_string|&quot;upgrade ifenslave to version %d, you must first &quot;
l_string|&quot;reload bonding.&bslash;n&quot;
comma
id|orig_app_abi_ver
comma
id|app_abi_ver
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|slave_dev
op_assign
id|dev_get_by_name
c_func
(paren
id|ifr-&gt;ifr_slave
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;slave_dev=%p: &bslash;n&quot;
comma
id|slave_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slave_dev
)paren
(brace
id|res
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
id|dprintk
c_func
(paren
l_string|&quot;slave_dev-&gt;name=%s: &bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BOND_ENSLAVE_OLD
suffix:colon
r_case
id|SIOCBONDENSLAVE
suffix:colon
id|res
op_assign
id|bond_enslave
c_func
(paren
id|bond_dev
comma
id|slave_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_RELEASE_OLD
suffix:colon
r_case
id|SIOCBONDRELEASE
suffix:colon
id|res
op_assign
id|bond_release
c_func
(paren
id|bond_dev
comma
id|slave_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_SETHWADDR_OLD
suffix:colon
r_case
id|SIOCBONDSETHWADDR
suffix:colon
id|res
op_assign
id|bond_sethwaddr
c_func
(paren
id|bond_dev
comma
id|slave_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_CHANGE_ACTIVE_OLD
suffix:colon
r_case
id|SIOCBONDCHANGEACTIVE
suffix:colon
r_if
c_cond
(paren
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
id|res
op_assign
id|bond_ioctl_change_active
c_func
(paren
id|bond_dev
comma
id|slave_dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|res
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|dev_put
c_func
(paren
id|slave_dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
multiline_comment|/* The ioctl failed, so there&squot;s no point in changing the&n;&t;&t; * orig_app_abi_ver. We&squot;ll restore it&squot;s value just in case&n;&t;&t; * we&squot;ve changed it earlier in this function.&n;&t;&t; */
id|orig_app_abi_ver
op_assign
id|prev_abi_ver
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|bond_set_multicast_list
r_static
r_void
id|bond_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
id|write_lock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do promisc before checking multicast_mode&n;&t; */
r_if
c_cond
(paren
(paren
id|bond_dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
op_logical_neg
(paren
id|bond-&gt;flags
op_amp
id|IFF_PROMISC
)paren
)paren
(brace
id|bond_set_promiscuity
c_func
(paren
id|bond
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bond_dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
(paren
id|bond-&gt;flags
op_amp
id|IFF_PROMISC
)paren
)paren
(brace
id|bond_set_promiscuity
c_func
(paren
id|bond
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* set allmulti flag to slaves */
r_if
c_cond
(paren
(paren
id|bond_dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_and
op_logical_neg
(paren
id|bond-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
(brace
id|bond_set_allmulti
c_func
(paren
id|bond
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bond_dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_and
(paren
id|bond-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
(brace
id|bond_set_allmulti
c_func
(paren
id|bond
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|bond-&gt;flags
op_assign
id|bond_dev-&gt;flags
suffix:semicolon
multiline_comment|/* looking for addresses to add to slaves&squot; mc list */
r_for
c_loop
(paren
id|dmi
op_assign
id|bond_dev-&gt;mc_list
suffix:semicolon
id|dmi
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bond_mc_list_find_dmi
c_func
(paren
id|dmi
comma
id|bond-&gt;mc_list
)paren
)paren
(brace
id|bond_mc_add
c_func
(paren
id|bond
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* looking for addresses to delete from slaves&squot; list */
r_for
c_loop
(paren
id|dmi
op_assign
id|bond-&gt;mc_list
suffix:semicolon
id|dmi
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bond_mc_list_find_dmi
c_func
(paren
id|dmi
comma
id|bond_dev-&gt;mc_list
)paren
)paren
(brace
id|bond_mc_delete
c_func
(paren
id|bond
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* save master&squot;s multicast list */
id|bond_mc_list_destroy
c_func
(paren
id|bond
)paren
suffix:semicolon
id|bond_mc_list_copy
c_func
(paren
id|bond_dev-&gt;mc_list
comma
id|bond
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Change the MTU of all of a master&squot;s slaves to match the master&n; */
DECL|function|bond_change_mtu
r_static
r_int
id|bond_change_mtu
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_int
id|new_mtu
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|slave
op_star
id|slave
comma
op_star
id|stop_at
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;bond=%p, name=%s, new_mtu=%d&bslash;n&quot;
comma
id|bond
comma
(paren
id|bond_dev
ques
c_cond
id|bond_dev-&gt;name
suffix:colon
l_string|&quot;None&quot;
)paren
comma
id|new_mtu
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t hold bond-&gt;lock with bh disabled here since&n;&t; * some base drivers panic. On the other hand we can&squot;t&n;&t; * hold bond-&gt;lock without bh disabled because we&squot;ll&n;&t; * deadlock. The only solution is to rely on the fact&n;&t; * that we&squot;re under rtnl_lock here, and the slaves&n;&t; * list won&squot;t change. This doesn&squot;t solve the problem&n;&t; * of setting the slave&squot;s MTU while it is&n;&t; * transmitting, but the assumption is that the base&n;&t; * driver can handle that.&n;&t; *&n;&t; * TODO: figure out a way to safely iterate the slaves&n;&t; * list, but without holding a lock around the actual&n;&t; * call to the base driver.&n;&t; */
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;s %p s-&gt;p %p c_m %p&bslash;n&quot;
comma
id|slave
comma
id|slave-&gt;prev
comma
id|slave-&gt;dev-&gt;change_mtu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;dev-&gt;change_mtu
)paren
(brace
id|res
op_assign
id|slave-&gt;dev
op_member_access_from_pointer
id|change_mtu
c_func
(paren
id|slave-&gt;dev
comma
id|new_mtu
)paren
suffix:semicolon
)brace
r_else
(brace
id|slave-&gt;dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|res
)paren
(brace
multiline_comment|/* If we failed to set the slave&squot;s mtu to the new value&n;&t;&t;&t; * we must abort the operation even in ACTIVE_BACKUP&n;&t;&t;&t; * mode, because if we allow the backup slaves to have&n;&t;&t;&t; * different mtu values than the active slave we&squot;ll&n;&t;&t;&t; * need to change their mtu when doing a failover. That&n;&t;&t;&t; * means changing their mtu from timer context, which&n;&t;&t;&t; * is probably not a good idea.&n;&t;&t;&t; */
id|dprintk
c_func
(paren
l_string|&quot;err %d %s&bslash;n&quot;
comma
id|res
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
r_goto
id|unwind
suffix:semicolon
)brace
)brace
id|bond_dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|unwind
suffix:colon
multiline_comment|/* unwind from head to the slave that failed */
id|stop_at
op_assign
id|slave
suffix:semicolon
id|bond_for_each_slave_from_to
c_func
(paren
id|bond
comma
id|slave
comma
id|i
comma
id|bond-&gt;first_slave
comma
id|stop_at
)paren
(brace
r_int
id|tmp_res
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;dev-&gt;change_mtu
)paren
(brace
id|tmp_res
op_assign
id|slave-&gt;dev
op_member_access_from_pointer
id|change_mtu
c_func
(paren
id|slave-&gt;dev
comma
id|bond_dev-&gt;mtu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp_res
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind err %d dev %s&bslash;n&quot;
comma
id|tmp_res
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|slave-&gt;dev-&gt;mtu
op_assign
id|bond_dev-&gt;mtu
suffix:semicolon
)brace
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * Change HW address&n; *&n; * Note that many devices must be down to change the HW address, and&n; * downing the master releases all slaves.  We can make bonds full of&n; * bonding devices to test this, however.&n; */
DECL|function|bond_set_mac_address
r_static
r_int
id|bond_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_void
op_star
id|addr
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|sockaddr
op_star
id|sa
op_assign
id|addr
comma
id|tmp_sa
suffix:semicolon
r_struct
id|slave
op_star
id|slave
comma
op_star
id|stop_at
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;bond=%p, name=%s&bslash;n&quot;
comma
id|bond
comma
(paren
id|bond_dev
ques
c_cond
id|bond_dev-&gt;name
suffix:colon
l_string|&quot;None&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_valid_ether_addr
c_func
(paren
id|sa-&gt;sa_data
)paren
)paren
(brace
r_return
op_minus
id|EADDRNOTAVAIL
suffix:semicolon
)brace
multiline_comment|/* Can&squot;t hold bond-&gt;lock with bh disabled here since&n;&t; * some base drivers panic. On the other hand we can&squot;t&n;&t; * hold bond-&gt;lock without bh disabled because we&squot;ll&n;&t; * deadlock. The only solution is to rely on the fact&n;&t; * that we&squot;re under rtnl_lock here, and the slaves&n;&t; * list won&squot;t change. This doesn&squot;t solve the problem&n;&t; * of setting the slave&squot;s hw address while it is&n;&t; * transmitting, but the assumption is that the base&n;&t; * driver can handle that.&n;&t; *&n;&t; * TODO: figure out a way to safely iterate the slaves&n;&t; * list, but without holding a lock around the actual&n;&t; * call to the base driver.&n;&t; */
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;slave %p %s&bslash;n&quot;
comma
id|slave
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;dev-&gt;set_mac_address
op_eq
l_int|NULL
)paren
(brace
id|res
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;EOPNOTSUPP %s&bslash;n&quot;
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
r_goto
id|unwind
suffix:semicolon
)brace
id|res
op_assign
id|slave-&gt;dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|slave-&gt;dev
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
multiline_comment|/* TODO: consider downing the slave&n;&t;&t;&t; * and retry ?&n;&t;&t;&t; * User should expect communications&n;&t;&t;&t; * breakage anyway until ARP finish&n;&t;&t;&t; * updating, so...&n;&t;&t;&t; */
id|dprintk
c_func
(paren
l_string|&quot;err %d %s&bslash;n&quot;
comma
id|res
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
r_goto
id|unwind
suffix:semicolon
)brace
)brace
multiline_comment|/* success */
id|memcpy
c_func
(paren
id|bond_dev-&gt;dev_addr
comma
id|sa-&gt;sa_data
comma
id|bond_dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|unwind
suffix:colon
id|memcpy
c_func
(paren
id|tmp_sa.sa_data
comma
id|bond_dev-&gt;dev_addr
comma
id|bond_dev-&gt;addr_len
)paren
suffix:semicolon
id|tmp_sa.sa_family
op_assign
id|bond_dev-&gt;type
suffix:semicolon
multiline_comment|/* unwind from head to the slave that failed */
id|stop_at
op_assign
id|slave
suffix:semicolon
id|bond_for_each_slave_from_to
c_func
(paren
id|bond
comma
id|slave
comma
id|i
comma
id|bond-&gt;first_slave
comma
id|stop_at
)paren
(brace
r_int
id|tmp_res
suffix:semicolon
id|tmp_res
op_assign
id|slave-&gt;dev
op_member_access_from_pointer
id|set_mac_address
c_func
(paren
id|slave-&gt;dev
comma
op_amp
id|tmp_sa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp_res
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind err %d dev %s&bslash;n&quot;
comma
id|tmp_res
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|bond_xmit_roundrobin
r_static
r_int
id|bond_xmit_roundrobin
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|slave
op_star
id|slave
comma
op_star
id|start_at
suffix:semicolon
r_int
id|i
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|BOND_IS_OK
c_func
(paren
id|bond
)paren
)paren
(brace
r_goto
id|free_out
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|slave
op_assign
id|start_at
op_assign
id|bond-&gt;curr_active_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slave
)paren
(brace
r_goto
id|free_out
suffix:semicolon
)brace
id|bond_for_each_slave_from
c_func
(paren
id|bond
comma
id|slave
comma
id|i
comma
id|start_at
)paren
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|slave-&gt;dev
)paren
op_logical_and
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
op_logical_and
(paren
id|slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
)paren
)paren
(brace
id|skb-&gt;dev
op_assign
id|slave-&gt;dev
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|bond-&gt;curr_active_slave
op_assign
id|slave-&gt;next
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|free_out
suffix:colon
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * in active-backup mode, we know that bond-&gt;curr_active_slave is always valid if&n; * the bond has a usable interface.&n; */
DECL|function|bond_xmit_activebackup
r_static
r_int
id|bond_xmit_activebackup
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
multiline_comment|/* if we are sending arp packets, try to at least&n;&t;   identify our own ip address */
r_if
c_cond
(paren
id|arp_interval
op_logical_and
op_logical_neg
id|my_ip
op_logical_and
(paren
id|skb-&gt;protocol
op_eq
id|__constant_htons
c_func
(paren
id|ETH_P_ARP
)paren
)paren
)paren
(brace
r_char
op_star
id|the_ip
op_assign
(paren
r_char
op_star
)paren
id|skb-&gt;data
op_plus
r_sizeof
(paren
r_struct
id|ethhdr
)paren
op_plus
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
id|ETH_ALEN
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|my_ip
comma
id|the_ip
comma
l_int|4
)paren
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|BOND_IS_OK
c_func
(paren
id|bond
)paren
)paren
(brace
r_goto
id|free_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;curr_active_slave
)paren
(brace
multiline_comment|/* one usable interface */
id|skb-&gt;dev
op_assign
id|bond-&gt;curr_active_slave-&gt;dev
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
r_goto
id|free_out
suffix:semicolon
)brace
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|free_out
suffix:colon
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * in XOR mode, we determine the output device by performing xor on&n; * the source and destination hw adresses.  If this device is not&n; * enabled, find the next slave following this xor slave.&n; */
DECL|function|bond_xmit_xor
r_static
r_int
id|bond_xmit_xor
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|ethhdr
op_star
id|data
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
r_struct
id|slave
op_star
id|slave
comma
op_star
id|start_at
suffix:semicolon
r_int
id|slave_no
suffix:semicolon
r_int
id|i
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|BOND_IS_OK
c_func
(paren
id|bond
)paren
)paren
(brace
r_goto
id|free_out
suffix:semicolon
)brace
id|slave_no
op_assign
(paren
id|data-&gt;h_dest
(braket
l_int|5
)braket
op_xor
id|bond_dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
op_mod
id|bond-&gt;slave_cnt
suffix:semicolon
id|bond_for_each_slave
c_func
(paren
id|bond
comma
id|slave
comma
id|i
)paren
(brace
id|slave_no
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|slave_no
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|start_at
op_assign
id|slave
suffix:semicolon
id|bond_for_each_slave_from
c_func
(paren
id|bond
comma
id|slave
comma
id|i
comma
id|start_at
)paren
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|slave-&gt;dev
)paren
op_logical_and
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
op_logical_and
(paren
id|slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
)paren
)paren
(brace
id|skb-&gt;dev
op_assign
id|slave-&gt;dev
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|free_out
suffix:colon
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * in broadcast mode, we send everything to all usable interfaces.&n; */
DECL|function|bond_xmit_broadcast
r_static
r_int
id|bond_xmit_broadcast
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
r_struct
id|slave
op_star
id|slave
comma
op_star
id|start_at
suffix:semicolon
r_struct
id|net_device
op_star
id|tx_dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|BOND_IS_OK
c_func
(paren
id|bond
)paren
)paren
(brace
r_goto
id|free_out
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|start_at
op_assign
id|bond-&gt;curr_active_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|start_at
)paren
(brace
r_goto
id|free_out
suffix:semicolon
)brace
id|bond_for_each_slave_from
c_func
(paren
id|bond
comma
id|slave
comma
id|i
comma
id|start_at
)paren
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|slave-&gt;dev
)paren
op_logical_and
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
op_logical_and
(paren
id|slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
)paren
)paren
(brace
r_if
c_cond
(paren
id|tx_dev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: Error: bond_xmit_broadcast(): &quot;
l_string|&quot;skb_clone() failed&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|skb2-&gt;dev
op_assign
id|tx_dev
suffix:semicolon
id|skb2-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb2
)paren
suffix:semicolon
)brace
id|tx_dev
op_assign
id|slave-&gt;dev
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tx_dev
)paren
(brace
id|skb-&gt;dev
op_assign
id|tx_dev
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
r_goto
id|free_out
suffix:semicolon
)brace
id|out
suffix:colon
multiline_comment|/* frame sent to all suitable interfaces */
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|free_out
suffix:colon
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_FASTROUTE
DECL|function|bond_accept_fastpath
r_static
r_int
id|bond_accept_fastpath
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*------------------------- Device initialization ---------------------------*/
multiline_comment|/*&n; * set bond mode specific net device operations&n; */
DECL|function|bond_set_mode_ops
r_static
r_inline
r_void
id|bond_set_mode_ops
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_int
id|mode
)paren
(brace
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|BOND_MODE_ROUNDROBIN
suffix:colon
id|bond_dev-&gt;hard_start_xmit
op_assign
id|bond_xmit_roundrobin
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MODE_ACTIVEBACKUP
suffix:colon
id|bond_dev-&gt;hard_start_xmit
op_assign
id|bond_xmit_activebackup
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MODE_XOR
suffix:colon
id|bond_dev-&gt;hard_start_xmit
op_assign
id|bond_xmit_xor
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MODE_BROADCAST
suffix:colon
id|bond_dev-&gt;hard_start_xmit
op_assign
id|bond_xmit_broadcast
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MODE_8023AD
suffix:colon
id|bond_dev-&gt;hard_start_xmit
op_assign
id|bond_3ad_xmit_xor
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_MODE_TLB
suffix:colon
r_case
id|BOND_MODE_ALB
suffix:colon
id|bond_dev-&gt;hard_start_xmit
op_assign
id|bond_alb_xmit
suffix:semicolon
id|bond_dev-&gt;set_mac_address
op_assign
id|bond_alb_set_mac_address
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Should never happen, mode already checked */
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: Error: Unknown bonding mode %d&bslash;n&quot;
comma
id|mode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Does not allocate but creates a /proc entry.&n; * Allowed to fail.&n; */
DECL|function|bond_init
r_static
r_int
id|__init
id|bond_init
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
comma
r_struct
id|bond_params
op_star
id|params
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Begin bond_init for %s&bslash;n&quot;
comma
id|bond_dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* initialize rwlocks */
id|rwlock_init
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
id|bond-&gt;curr_slave_lock
)paren
suffix:semicolon
id|bond-&gt;params
op_assign
op_star
id|params
suffix:semicolon
multiline_comment|/* copy params struct */
multiline_comment|/* Initialize pointers */
id|bond-&gt;first_slave
op_assign
l_int|NULL
suffix:semicolon
id|bond-&gt;curr_active_slave
op_assign
l_int|NULL
suffix:semicolon
id|bond-&gt;current_arp_slave
op_assign
l_int|NULL
suffix:semicolon
id|bond-&gt;primary_slave
op_assign
l_int|NULL
suffix:semicolon
id|bond-&gt;dev
op_assign
id|bond_dev
suffix:semicolon
multiline_comment|/* Initialize the device entry points */
id|bond_dev-&gt;open
op_assign
id|bond_open
suffix:semicolon
id|bond_dev-&gt;stop
op_assign
id|bond_close
suffix:semicolon
id|bond_dev-&gt;get_stats
op_assign
id|bond_get_stats
suffix:semicolon
id|bond_dev-&gt;do_ioctl
op_assign
id|bond_do_ioctl
suffix:semicolon
id|bond_dev-&gt;set_multicast_list
op_assign
id|bond_set_multicast_list
suffix:semicolon
id|bond_dev-&gt;change_mtu
op_assign
id|bond_change_mtu
suffix:semicolon
id|bond_dev-&gt;set_mac_address
op_assign
id|bond_set_mac_address
suffix:semicolon
id|bond_set_mode_ops
c_func
(paren
id|bond_dev
comma
id|bond-&gt;params.mode
)paren
suffix:semicolon
id|bond_dev-&gt;destructor
op_assign
id|free_netdev
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
id|bond_dev-&gt;accept_fastpath
op_assign
id|bond_accept_fastpath
suffix:semicolon
macro_line|#endif
multiline_comment|/* Initialize the device options */
id|bond_dev-&gt;tx_queue_len
op_assign
l_int|0
suffix:semicolon
id|bond_dev-&gt;flags
op_or_assign
id|IFF_MASTER
op_or
id|IFF_MULTICAST
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|bond_create_proc_entry
c_func
(paren
id|bond
)paren
suffix:semicolon
macro_line|#endif
id|list_add_tail
c_func
(paren
op_amp
id|bond-&gt;bond_list
comma
op_amp
id|bond_dev_list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* De-initialize device specific data.&n; * Caller must hold rtnl_lock.&n; */
DECL|function|bond_deinit
r_static
r_inline
r_void
id|bond_deinit
c_func
(paren
r_struct
id|net_device
op_star
id|bond_dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
id|bond_dev-&gt;priv
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|bond-&gt;bond_list
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|bond_remove_proc_entry
c_func
(paren
id|bond
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Unregister and free all bond devices.&n; * Caller must hold rtnl_lock.&n; */
DECL|function|bond_free_all
r_static
r_void
id|bond_free_all
c_func
(paren
r_void
)paren
(brace
r_struct
id|bonding
op_star
id|bond
comma
op_star
id|nxt
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|bond
comma
id|nxt
comma
op_amp
id|bond_dev_list
comma
id|bond_list
)paren
(brace
r_struct
id|net_device
op_star
id|bond_dev
op_assign
id|bond-&gt;dev
suffix:semicolon
id|unregister_netdevice
c_func
(paren
id|bond_dev
)paren
suffix:semicolon
id|bond_deinit
c_func
(paren
id|bond_dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
id|bond_destroy_proc_dir
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*------------------------- Module initialization ---------------------------*/
multiline_comment|/*&n; * Convert string input module parms.  Accept either the&n; * number of the mode or its string name.&n; */
DECL|function|bond_parse_parm
r_static
r_inline
r_int
id|bond_parse_parm
c_func
(paren
r_char
op_star
id|mode_arg
comma
r_struct
id|bond_parm_tbl
op_star
id|tbl
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|tbl
(braket
id|i
)braket
dot
id|modename
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|isdigit
c_func
(paren
op_star
id|mode_arg
)paren
op_logical_and
id|tbl
(braket
id|i
)braket
dot
id|mode
op_eq
id|simple_strtol
c_func
(paren
id|mode_arg
comma
l_int|NULL
comma
l_int|0
)paren
)paren
op_logical_or
(paren
id|strncmp
c_func
(paren
id|mode_arg
comma
id|tbl
(braket
id|i
)braket
dot
id|modename
comma
id|strlen
c_func
(paren
id|tbl
(braket
id|i
)braket
dot
id|modename
)paren
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_return
id|tbl
(braket
id|i
)braket
dot
id|mode
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|bond_check_params
r_static
r_int
id|bond_check_params
c_func
(paren
r_struct
id|bond_params
op_star
id|params
)paren
(brace
multiline_comment|/*&n;&t; * Convert string parameters.&n;&t; */
r_if
c_cond
(paren
id|mode
)paren
(brace
id|bond_mode
op_assign
id|bond_parse_parm
c_func
(paren
id|mode
comma
id|bond_mode_tbl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond_mode
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: Error: Invalid bonding mode &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|mode
op_eq
l_int|NULL
ques
c_cond
l_string|&quot;NULL&quot;
suffix:colon
id|mode
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lacp_rate
)paren
(brace
r_if
c_cond
(paren
id|bond_mode
op_ne
id|BOND_MODE_8023AD
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: lacp_rate param is irrelevant in mode %s&bslash;n&quot;
comma
id|bond_mode_name
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|lacp_fast
op_assign
id|bond_parse_parm
c_func
(paren
id|lacp_rate
comma
id|bond_lacp_tbl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lacp_fast
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;: Error: Invalid lacp rate &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|lacp_rate
op_eq
l_int|NULL
ques
c_cond
l_string|&quot;NULL&quot;
suffix:colon
id|lacp_rate
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|max_bonds
template_param
id|INT_MAX
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: max_bonds (%d) not in range %d-%d, so it &quot;
l_string|&quot;was reset to BOND_DEFAULT_MAX_BONDS (%d)&quot;
comma
id|max_bonds
comma
l_int|1
comma
id|INT_MAX
comma
id|BOND_DEFAULT_MAX_BONDS
)paren
suffix:semicolon
id|max_bonds
op_assign
id|BOND_DEFAULT_MAX_BONDS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|miimon
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: miimon module parameter (%d), &quot;
l_string|&quot;not in range 0-%d, so it was reset to %d&bslash;n&quot;
comma
id|miimon
comma
id|INT_MAX
comma
id|BOND_LINK_MON_INTERV
)paren
suffix:semicolon
id|miimon
op_assign
id|BOND_LINK_MON_INTERV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|updelay
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: updelay module parameter (%d), &quot;
l_string|&quot;not in range 0-%d, so it was reset to 0&bslash;n&quot;
comma
id|updelay
comma
id|INT_MAX
)paren
suffix:semicolon
id|updelay
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|downdelay
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: downdelay module parameter (%d), &quot;
l_string|&quot;not in range 0-%d, so it was reset to 0&bslash;n&quot;
comma
id|downdelay
comma
id|INT_MAX
)paren
suffix:semicolon
id|downdelay
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|use_carrier
op_ne
l_int|0
)paren
op_logical_and
(paren
id|use_carrier
op_ne
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: use_carrier module parameter (%d), &quot;
l_string|&quot;not of valid value (0/1), so it was set to 1&bslash;n&quot;
comma
id|use_carrier
)paren
suffix:semicolon
id|use_carrier
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* reset values for 802.3ad */
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_8023AD
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|miimon
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: miimon must be specified, &quot;
l_string|&quot;otherwise bonding will not detect link &quot;
l_string|&quot;failure, speed and duplex which are &quot;
l_string|&quot;essential for 802.3ad operation&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Forcing miimon to 100msec&bslash;n&quot;
)paren
suffix:semicolon
id|miimon
op_assign
l_int|100
suffix:semicolon
)brace
)brace
multiline_comment|/* reset values for TLB/ALB */
r_if
c_cond
(paren
(paren
id|bond_mode
op_eq
id|BOND_MODE_TLB
)paren
op_logical_or
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|miimon
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: miimon must be specified, &quot;
l_string|&quot;otherwise bonding will not detect link &quot;
l_string|&quot;failure and link speed which are essential &quot;
l_string|&quot;for TLB/ALB load balancing&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Forcing miimon to 100msec&bslash;n&quot;
)paren
suffix:semicolon
id|miimon
op_assign
l_int|100
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bond_mode
op_eq
id|BOND_MODE_ALB
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
id|DRV_NAME
l_string|&quot;: In ALB mode you might experience client &quot;
l_string|&quot;disconnections upon reconnection of a link if the &quot;
l_string|&quot;bonding module updelay parameter (%d msec) is &quot;
l_string|&quot;incompatible with the forwarding delay time of the &quot;
l_string|&quot;switch&bslash;n&quot;
comma
id|updelay
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|miimon
)paren
(brace
r_if
c_cond
(paren
id|updelay
op_logical_or
id|downdelay
)paren
(brace
multiline_comment|/* just warn the user the up/down delay will have&n;&t;&t;&t; * no effect since miimon is zero...&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: miimon module parameter not set &quot;
l_string|&quot;and updelay (%d) or downdelay (%d) module &quot;
l_string|&quot;parameter is set; updelay and downdelay have &quot;
l_string|&quot;no effect unless miimon is set&bslash;n&quot;
comma
id|updelay
comma
id|downdelay
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* don&squot;t allow arp monitoring */
r_if
c_cond
(paren
id|arp_interval
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: miimon (%d) and arp_interval (%d) &quot;
l_string|&quot;can&squot;t be used simultaneously, disabling ARP &quot;
l_string|&quot;monitoring&bslash;n&quot;
comma
id|miimon
comma
id|arp_interval
)paren
suffix:semicolon
id|arp_interval
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|updelay
op_mod
id|miimon
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: updelay (%d) is not a multiple &quot;
l_string|&quot;of miimon (%d), updelay rounded to %d ms&bslash;n&quot;
comma
id|updelay
comma
id|miimon
comma
(paren
id|updelay
op_div
id|miimon
)paren
op_star
id|miimon
)paren
suffix:semicolon
)brace
id|updelay
op_div_assign
id|miimon
suffix:semicolon
r_if
c_cond
(paren
(paren
id|downdelay
op_mod
id|miimon
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: downdelay (%d) is not a multiple &quot;
l_string|&quot;of miimon (%d), downdelay rounded to %d ms&bslash;n&quot;
comma
id|downdelay
comma
id|miimon
comma
(paren
id|downdelay
op_div
id|miimon
)paren
op_star
id|miimon
)paren
suffix:semicolon
)brace
id|downdelay
op_div_assign
id|miimon
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp_interval
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: arp_interval module parameter (%d) &quot;
l_string|&quot;, not in range 0-%d, so it was reset to %d&bslash;n&quot;
comma
id|arp_interval
comma
id|INT_MAX
comma
id|BOND_LINK_ARP_INTERV
)paren
suffix:semicolon
id|arp_interval
op_assign
id|BOND_LINK_ARP_INTERV
suffix:semicolon
)brace
r_for
c_loop
(paren
id|arp_ip_count
op_assign
l_int|0
suffix:semicolon
(paren
id|arp_ip_count
OL
id|BOND_MAX_ARP_TARGETS
)paren
op_logical_and
id|arp_ip_target
(braket
id|arp_ip_count
)braket
suffix:semicolon
id|arp_ip_count
op_increment
)paren
(brace
multiline_comment|/* not complete check, but should be good enough to&n;&t;&t;   catch mistakes */
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
id|arp_ip_target
(braket
id|arp_ip_count
)braket
(braket
l_int|0
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: bad arp_ip_target module parameter &quot;
l_string|&quot;(%s), ARP monitoring will not be performed&bslash;n&quot;
comma
id|arp_ip_target
(braket
id|arp_ip_count
)braket
)paren
suffix:semicolon
id|arp_interval
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|u32
id|ip
op_assign
id|in_aton
c_func
(paren
id|arp_ip_target
(braket
id|arp_ip_count
)braket
)paren
suffix:semicolon
id|arp_target
(braket
id|arp_ip_count
)braket
op_assign
id|ip
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|arp_interval
op_logical_and
op_logical_neg
id|arp_ip_count
)paren
(brace
multiline_comment|/* don&squot;t allow arping if no arp_ip_target given... */
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: arp_interval module parameter (%d) &quot;
l_string|&quot;specified without providing an arp_ip_target &quot;
l_string|&quot;parameter, arp_interval was reset to 0&bslash;n&quot;
comma
id|arp_interval
)paren
suffix:semicolon
id|arp_interval
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|miimon
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: MII link monitoring set to %d ms&bslash;n&quot;
comma
id|miimon
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|arp_interval
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|DRV_NAME
l_string|&quot;: ARP monitoring set to %d ms with %d target(s):&quot;
comma
id|arp_interval
comma
id|arp_ip_count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|arp_ip_count
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %s&quot;
comma
id|arp_ip_target
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* miimon and arp_interval not set, we need one so things&n;&t;&t; * work as expected, see bonding.txt for details&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: either miimon or arp_interval and &quot;
l_string|&quot;arp_ip_target module parameters must be specified, &quot;
l_string|&quot;otherwise bonding will not detect link failures! see &quot;
l_string|&quot;bonding.txt for details.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|primary
op_logical_and
op_logical_neg
id|USES_PRIMARY
c_func
(paren
id|bond_mode
)paren
)paren
(brace
multiline_comment|/* currently, using a primary only makes sense&n;&t;&t; * in active backup, TLB or ALB modes&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
id|DRV_NAME
l_string|&quot;: Warning: %s primary device specified but has no &quot;
l_string|&quot;effect in %s mode&bslash;n&quot;
comma
id|primary
comma
id|bond_mode_name
c_func
(paren
)paren
)paren
suffix:semicolon
id|primary
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* fill params struct with the proper values */
id|params-&gt;mode
op_assign
id|bond_mode
suffix:semicolon
id|params-&gt;miimon
op_assign
id|miimon
suffix:semicolon
id|params-&gt;arp_interval
op_assign
id|arp_interval
suffix:semicolon
id|params-&gt;updelay
op_assign
id|updelay
suffix:semicolon
id|params-&gt;downdelay
op_assign
id|downdelay
suffix:semicolon
id|params-&gt;use_carrier
op_assign
id|use_carrier
suffix:semicolon
id|params-&gt;lacp_fast
op_assign
id|lacp_fast
suffix:semicolon
id|params-&gt;primary
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|primary
)paren
(brace
id|strncpy
c_func
(paren
id|params-&gt;primary
comma
id|primary
comma
id|IFNAMSIZ
)paren
suffix:semicolon
id|params-&gt;primary
(braket
id|IFNAMSIZ
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|params-&gt;arp_targets
comma
id|arp_target
comma
r_sizeof
(paren
id|arp_target
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bonding_init
r_static
r_int
id|__init
id|bonding_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|bond_params
id|params
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|res
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
id|res
op_assign
id|bond_check_params
c_func
(paren
op_amp
id|params
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
r_return
id|res
suffix:semicolon
)brace
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|bond_create_proc_dir
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_bonds
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|net_device
op_star
id|bond_dev
suffix:semicolon
id|bond_dev
op_assign
id|alloc_netdev
c_func
(paren
r_sizeof
(paren
r_struct
id|bonding
)paren
comma
l_string|&quot;&quot;
comma
id|ether_setup
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bond_dev
)paren
(brace
id|res
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|res
op_assign
id|dev_alloc_name
c_func
(paren
id|bond_dev
comma
l_string|&quot;bond%d&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
id|free_netdev
c_func
(paren
id|bond_dev
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
multiline_comment|/* bond_init() must be called after dev_alloc_name() (for the&n;&t;&t; * /proc files), but before register_netdevice(), because we&n;&t;&t; * need to set function pointers.&n;&t;&t; */
id|res
op_assign
id|bond_init
c_func
(paren
id|bond_dev
comma
op_amp
id|params
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
id|free_netdev
c_func
(paren
id|bond_dev
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|SET_MODULE_OWNER
c_func
(paren
id|bond_dev
)paren
suffix:semicolon
id|res
op_assign
id|register_netdevice
c_func
(paren
id|bond_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
id|bond_deinit
c_func
(paren
id|bond_dev
)paren
suffix:semicolon
id|free_netdev
c_func
(paren
id|bond_dev
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
)brace
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
id|register_netdevice_notifier
c_func
(paren
op_amp
id|bond_netdev_notifier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_err
suffix:colon
multiline_comment|/* free and unregister all bonds that were successfully added */
id|bond_free_all
c_func
(paren
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|bonding_exit
r_static
r_void
id|__exit
id|bonding_exit
c_func
(paren
r_void
)paren
(brace
id|unregister_netdevice_notifier
c_func
(paren
op_amp
id|bond_netdev_notifier
)paren
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|bond_free_all
c_func
(paren
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|bonding_init
id|module_init
c_func
(paren
id|bonding_init
)paren
suffix:semicolon
DECL|variable|bonding_exit
id|module_exit
c_func
(paren
id|bonding_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
id|DRV_DESCRIPTION
l_string|&quot;, v&quot;
id|DRV_VERSION
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Thomas Davis, tadavis@lbl.gov and many others&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
l_string|&quot;most ethernet devices&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Local variables:&n; *  c-indent-level: 8&n; *  c-basic-offset: 8&n; *  tab-width: 8&n; * End:&n; */
eof
