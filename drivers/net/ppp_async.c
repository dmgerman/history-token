multiline_comment|/*&n; * PPP async serial channel driver for Linux.&n; *&n; * Copyright 1999 Paul Mackerras.&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; * This driver provides the encapsulation and framing for sending&n; * and receiving PPP frames over async serial lines.  It relies on&n; * the generic PPP layer to give it frames to send and to process&n; * received frames.  It implements the PPP line discipline.&n; *&n; * Part of the code in this driver was inspired by the old async-only&n; * PPP driver, written by Michael Callahan and Al Longyear, and&n; * subsequently hacked by Paul Mackerras.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/crc-ccitt.h&gt;
macro_line|#include &lt;linux/ppp_defs.h&gt;
macro_line|#include &lt;linux/if_ppp.h&gt;
macro_line|#include &lt;linux/ppp_channel.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|PPP_VERSION
mdefine_line|#define PPP_VERSION&t;&quot;2.4.2&quot;
DECL|macro|OBUFSIZE
mdefine_line|#define OBUFSIZE&t;256
multiline_comment|/* Structure for storing local state. */
DECL|struct|asyncppp
r_struct
id|asyncppp
(brace
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|state
r_int
r_int
id|state
suffix:semicolon
DECL|member|rbits
r_int
r_int
id|rbits
suffix:semicolon
DECL|member|mru
r_int
id|mru
suffix:semicolon
DECL|member|xmit_lock
id|spinlock_t
id|xmit_lock
suffix:semicolon
DECL|member|recv_lock
id|spinlock_t
id|recv_lock
suffix:semicolon
DECL|member|xmit_flags
r_int
r_int
id|xmit_flags
suffix:semicolon
DECL|member|xaccm
id|u32
id|xaccm
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|raccm
id|u32
id|raccm
suffix:semicolon
DECL|member|bytes_sent
r_int
r_int
id|bytes_sent
suffix:semicolon
DECL|member|bytes_rcvd
r_int
r_int
id|bytes_rcvd
suffix:semicolon
DECL|member|tpkt
r_struct
id|sk_buff
op_star
id|tpkt
suffix:semicolon
DECL|member|tpkt_pos
r_int
id|tpkt_pos
suffix:semicolon
DECL|member|tfcs
id|u16
id|tfcs
suffix:semicolon
DECL|member|optr
r_int
r_char
op_star
id|optr
suffix:semicolon
DECL|member|olim
r_int
r_char
op_star
id|olim
suffix:semicolon
DECL|member|last_xmit
r_int
r_int
id|last_xmit
suffix:semicolon
DECL|member|rpkt
r_struct
id|sk_buff
op_star
id|rpkt
suffix:semicolon
DECL|member|lcp_fcs
r_int
id|lcp_fcs
suffix:semicolon
DECL|member|rqueue
r_struct
id|sk_buff_head
id|rqueue
suffix:semicolon
DECL|member|tsk
r_struct
id|tasklet_struct
id|tsk
suffix:semicolon
DECL|member|refcnt
id|atomic_t
id|refcnt
suffix:semicolon
DECL|member|dead_sem
r_struct
id|semaphore
id|dead_sem
suffix:semicolon
DECL|member|chan
r_struct
id|ppp_channel
id|chan
suffix:semicolon
multiline_comment|/* interface to generic ppp layer */
DECL|member|obuf
r_int
r_char
id|obuf
(braket
id|OBUFSIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Bit numbers in xmit_flags */
DECL|macro|XMIT_WAKEUP
mdefine_line|#define XMIT_WAKEUP&t;0
DECL|macro|XMIT_FULL
mdefine_line|#define XMIT_FULL&t;1
DECL|macro|XMIT_BUSY
mdefine_line|#define XMIT_BUSY&t;2
multiline_comment|/* State bits */
DECL|macro|SC_TOSS
mdefine_line|#define SC_TOSS&t;&t;1
DECL|macro|SC_ESCAPE
mdefine_line|#define SC_ESCAPE&t;2
DECL|macro|SC_PREV_ERROR
mdefine_line|#define SC_PREV_ERROR&t;4
multiline_comment|/* Bits in rbits */
DECL|macro|SC_RCV_BITS
mdefine_line|#define SC_RCV_BITS&t;(SC_RCV_B7_1|SC_RCV_B7_0|SC_RCV_ODDP|SC_RCV_EVNP)
DECL|variable|flag_time
r_static
r_int
id|flag_time
op_assign
id|HZ
suffix:semicolon
id|module_param
c_func
(paren
id|flag_time
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|flag_time
comma
l_string|&quot;ppp_async: interval between flagged packets (in clock ticks)&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|N_PPP
id|MODULE_ALIAS_LDISC
c_func
(paren
id|N_PPP
)paren
suffix:semicolon
multiline_comment|/*&n; * Prototypes.&n; */
r_static
r_int
id|ppp_async_encode
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
suffix:semicolon
r_static
r_int
id|ppp_async_send
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_int
id|ppp_async_push
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
suffix:semicolon
r_static
r_void
id|ppp_async_flush_output
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
suffix:semicolon
r_static
r_void
id|ppp_async_input
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_char
op_star
id|flags
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|ppp_async_ioctl
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|ppp_async_process
c_func
(paren
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|async_lcp_peek
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
comma
r_int
r_char
op_star
id|data
comma
r_int
id|len
comma
r_int
id|inbound
)paren
suffix:semicolon
DECL|variable|async_ops
r_static
r_struct
id|ppp_channel_ops
id|async_ops
op_assign
(brace
id|ppp_async_send
comma
id|ppp_async_ioctl
)brace
suffix:semicolon
multiline_comment|/*&n; * Routines implementing the PPP line discipline.&n; */
multiline_comment|/*&n; * We have a potential race on dereferencing tty-&gt;disc_data,&n; * because the tty layer provides no locking at all - thus one&n; * cpu could be running ppp_asynctty_receive while another&n; * calls ppp_asynctty_close, which zeroes tty-&gt;disc_data and&n; * frees the memory that ppp_asynctty_receive is using.  The best&n; * way to fix this is to use a rwlock in the tty struct, but for now&n; * we use a single global rwlock for all ttys in ppp line discipline.&n; *&n; * FIXME: this is no longer true. The _close path for the ldisc is &n; * now guaranteed to be sane. &n; */
DECL|variable|disc_data_lock
r_static
id|rwlock_t
id|disc_data_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|function|ap_get
r_static
r_struct
id|asyncppp
op_star
id|ap_get
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|disc_data_lock
)paren
suffix:semicolon
id|ap
op_assign
id|tty-&gt;disc_data
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_ne
l_int|NULL
)paren
id|atomic_inc
c_func
(paren
op_amp
id|ap-&gt;refcnt
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|disc_data_lock
)paren
suffix:semicolon
r_return
id|ap
suffix:semicolon
)brace
DECL|function|ap_put
r_static
r_void
id|ap_put
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ap-&gt;refcnt
)paren
)paren
id|up
c_func
(paren
op_amp
id|ap-&gt;dead_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when a tty is put into PPP line discipline. Called in process&n; * context.&n; */
r_static
r_int
DECL|function|ppp_asynctty_open
id|ppp_asynctty_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|ap
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ap
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* initialize the asyncppp structure */
id|memset
c_func
(paren
id|ap
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ap
)paren
)paren
suffix:semicolon
id|ap-&gt;tty
op_assign
id|tty
suffix:semicolon
id|ap-&gt;mru
op_assign
id|PPP_MRU
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ap-&gt;recv_lock
)paren
suffix:semicolon
id|ap-&gt;xaccm
(braket
l_int|0
)braket
op_assign
op_complement
l_int|0U
suffix:semicolon
id|ap-&gt;xaccm
(braket
l_int|3
)braket
op_assign
l_int|0x60000000U
suffix:semicolon
id|ap-&gt;raccm
op_assign
op_complement
l_int|0U
suffix:semicolon
id|ap-&gt;optr
op_assign
id|ap-&gt;obuf
suffix:semicolon
id|ap-&gt;olim
op_assign
id|ap-&gt;obuf
suffix:semicolon
id|ap-&gt;lcp_fcs
op_assign
op_minus
l_int|1
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|ap-&gt;rqueue
)paren
suffix:semicolon
id|tasklet_init
c_func
(paren
op_amp
id|ap-&gt;tsk
comma
id|ppp_async_process
comma
(paren
r_int
r_int
)paren
id|ap
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ap-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|ap-&gt;dead_sem
)paren
suffix:semicolon
id|ap-&gt;chan
dot
r_private
op_assign
id|ap
suffix:semicolon
id|ap-&gt;chan.ops
op_assign
op_amp
id|async_ops
suffix:semicolon
id|ap-&gt;chan.mtu
op_assign
id|PPP_MRU
suffix:semicolon
id|err
op_assign
id|ppp_register_channel
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_free
suffix:semicolon
id|tty-&gt;disc_data
op_assign
id|ap
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_free
suffix:colon
id|kfree
c_func
(paren
id|ap
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when the tty is put into another line discipline&n; * or it hangs up.  We have to wait for any cpu currently&n; * executing in any of the other ppp_asynctty_* routines to&n; * finish before we can call ppp_unregister_channel and free&n; * the asyncppp struct.  This routine must be called from&n; * process context, not interrupt or softirq context.&n; */
r_static
r_void
DECL|function|ppp_asynctty_close
id|ppp_asynctty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|disc_data_lock
)paren
suffix:semicolon
id|ap
op_assign
id|tty-&gt;disc_data
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|disc_data_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * We have now ensured that nobody can start using ap from now&n;&t; * on, but we have to wait for all existing users to finish.&n;&t; * Note that ppp_unregister_channel ensures that no calls to&n;&t; * our channel ops (i.e. ppp_async_send/ioctl) are in progress&n;&t; * by the time it returns.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ap-&gt;refcnt
)paren
)paren
id|down
c_func
(paren
op_amp
id|ap-&gt;dead_sem
)paren
suffix:semicolon
id|tasklet_kill
c_func
(paren
op_amp
id|ap-&gt;tsk
)paren
suffix:semicolon
id|ppp_unregister_channel
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;rpkt
op_ne
l_int|0
)paren
id|kfree_skb
c_func
(paren
id|ap-&gt;rpkt
)paren
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|ap-&gt;rqueue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;tpkt
op_ne
l_int|0
)paren
id|kfree_skb
c_func
(paren
id|ap-&gt;tpkt
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called on tty hangup in process context.&n; *&n; * Wait for I/O to driver to complete and unregister PPP channel.&n; * This is already done by the close routine, so just call that.&n; */
DECL|function|ppp_asynctty_hangup
r_static
r_int
id|ppp_asynctty_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|ppp_asynctty_close
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read does nothing - no data is ever available this way.&n; * Pppd reads and writes packets via /dev/ppp instead.&n; */
r_static
id|ssize_t
DECL|function|ppp_asynctty_read
id|ppp_asynctty_read
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n; * Write on the tty does nothing, the packets all come in&n; * from the ppp generic stuff.&n; */
r_static
id|ssize_t
DECL|function|ppp_asynctty_write
id|ppp_asynctty_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n; * Called in process context only. May be re-entered by multiple&n; * ioctl calling threads.&n; */
r_static
r_int
DECL|function|ppp_asynctty_ioctl
id|ppp_asynctty_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|ap_get
c_func
(paren
id|tty
)paren
suffix:semicolon
r_int
id|err
comma
id|val
suffix:semicolon
r_int
id|__user
op_star
id|p
op_assign
(paren
r_int
id|__user
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PPPIOCGCHAN
suffix:colon
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ppp_channel_index
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGUNIT
suffix:colon
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ppp_unit_number
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCGETS
suffix:colon
r_case
id|TCGETA
suffix:colon
id|err
op_assign
id|n_tty_ioctl
c_func
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCFLSH
suffix:colon
multiline_comment|/* flush our buffers and the serial port&squot;s buffer */
r_if
c_cond
(paren
id|arg
op_eq
id|TCIOFLUSH
op_logical_or
id|arg
op_eq
id|TCOFLUSH
)paren
id|ppp_async_flush_output
c_func
(paren
id|ap
)paren
suffix:semicolon
id|err
op_assign
id|n_tty_ioctl
c_func
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIONREAD
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
id|ap_put
c_func
(paren
id|ap
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* No kernel lock - fine */
r_static
r_int
r_int
DECL|function|ppp_asynctty_poll
id|ppp_asynctty_poll
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|ppp_asynctty_room
id|ppp_asynctty_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
l_int|65535
suffix:semicolon
)brace
multiline_comment|/*&n; * This can now be called from hard interrupt level as well&n; * as soft interrupt level or mainline.&n; */
r_static
r_void
DECL|function|ppp_asynctty_receive
id|ppp_asynctty_receive
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_char
op_star
id|cflags
comma
r_int
id|count
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|ap_get
c_func
(paren
id|tty
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ap-&gt;recv_lock
comma
id|flags
)paren
suffix:semicolon
id|ppp_async_input
c_func
(paren
id|ap
comma
id|buf
comma
id|cflags
comma
id|count
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ap-&gt;recv_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|ap-&gt;rqueue
)paren
)paren
id|tasklet_schedule
c_func
(paren
op_amp
id|ap-&gt;tsk
)paren
suffix:semicolon
id|ap_put
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
op_logical_and
id|tty-&gt;driver-&gt;unthrottle
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ppp_asynctty_wakeup
id|ppp_asynctty_wakeup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|ap_get
c_func
(paren
id|tty
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|TTY_DO_WRITE_WAKEUP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|set_bit
c_func
(paren
id|XMIT_WAKEUP
comma
op_amp
id|ap-&gt;xmit_flags
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|ap-&gt;tsk
)paren
suffix:semicolon
id|ap_put
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
DECL|variable|ppp_ldisc
r_static
r_struct
id|tty_ldisc
id|ppp_ldisc
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|magic
op_assign
id|TTY_LDISC_MAGIC
comma
dot
id|name
op_assign
l_string|&quot;ppp&quot;
comma
dot
id|open
op_assign
id|ppp_asynctty_open
comma
dot
id|close
op_assign
id|ppp_asynctty_close
comma
dot
id|hangup
op_assign
id|ppp_asynctty_hangup
comma
dot
id|read
op_assign
id|ppp_asynctty_read
comma
dot
id|write
op_assign
id|ppp_asynctty_write
comma
dot
id|ioctl
op_assign
id|ppp_asynctty_ioctl
comma
dot
id|poll
op_assign
id|ppp_asynctty_poll
comma
dot
id|receive_room
op_assign
id|ppp_asynctty_room
comma
dot
id|receive_buf
op_assign
id|ppp_asynctty_receive
comma
dot
id|write_wakeup
op_assign
id|ppp_asynctty_wakeup
comma
)brace
suffix:semicolon
r_static
r_int
id|__init
DECL|function|ppp_async_init
id|ppp_async_init
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_PPP
comma
op_amp
id|ppp_ldisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPP_async: error %d registering line disc.&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * The following routines provide the PPP channel interface.&n; */
r_static
r_int
DECL|function|ppp_async_ioctl
id|ppp_async_ioctl
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|chan
op_member_access_from_pointer
r_private
suffix:semicolon
r_void
id|__user
op_star
id|argp
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
r_int
id|__user
op_star
id|p
op_assign
id|argp
suffix:semicolon
r_int
id|err
comma
id|val
suffix:semicolon
id|u32
id|accm
(braket
l_int|8
)braket
suffix:semicolon
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PPPIOCGFLAGS
suffix:colon
id|val
op_assign
id|ap-&gt;flags
op_or
id|ap-&gt;rbits
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|val
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSFLAGS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|ap-&gt;flags
op_assign
id|val
op_amp
op_complement
id|SC_RCV_BITS
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ap-&gt;recv_lock
)paren
suffix:semicolon
id|ap-&gt;rbits
op_assign
id|val
op_amp
id|SC_RCV_BITS
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ap-&gt;recv_lock
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap-&gt;xaccm
(braket
l_int|0
)braket
comma
(paren
id|u32
id|__user
op_star
)paren
id|argp
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ap-&gt;xaccm
(braket
l_int|0
)braket
comma
(paren
id|u32
id|__user
op_star
)paren
id|argp
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGRASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap-&gt;raccm
comma
(paren
id|u32
id|__user
op_star
)paren
id|argp
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSRASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ap-&gt;raccm
comma
(paren
id|u32
id|__user
op_star
)paren
id|argp
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGXASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|argp
comma
id|ap-&gt;xaccm
comma
r_sizeof
(paren
id|ap-&gt;xaccm
)paren
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSXASYNCMAP
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|accm
comma
id|argp
comma
r_sizeof
(paren
id|accm
)paren
)paren
)paren
r_break
suffix:semicolon
id|accm
(braket
l_int|2
)braket
op_and_assign
op_complement
l_int|0x40000000U
suffix:semicolon
multiline_comment|/* can&squot;t escape 0x5e */
id|accm
(braket
l_int|3
)braket
op_or_assign
l_int|0x60000000U
suffix:semicolon
multiline_comment|/* must escape 0x7d, 0x7e */
id|memcpy
c_func
(paren
id|ap-&gt;xaccm
comma
id|accm
comma
r_sizeof
(paren
id|ap-&gt;xaccm
)paren
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCGMRU
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ap-&gt;mru
comma
id|p
)paren
)paren
r_break
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPPIOCSMRU
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
id|p
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|val
OL
id|PPP_MRU
)paren
id|val
op_assign
id|PPP_MRU
suffix:semicolon
id|ap-&gt;mru
op_assign
id|val
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|ENOTTY
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called at softirq level to deliver received packets&n; * to the ppp_generic code, and to tell the ppp_generic code&n; * if we can accept more output now.&n; */
DECL|function|ppp_async_process
r_static
r_void
id|ppp_async_process
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
(paren
r_struct
id|asyncppp
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* process received packets */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ap-&gt;rqueue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;cb
(braket
l_int|0
)braket
)paren
id|ppp_input_error
c_func
(paren
op_amp
id|ap-&gt;chan
comma
l_int|0
)paren
suffix:semicolon
id|ppp_input
c_func
(paren
op_amp
id|ap-&gt;chan
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* try to push more stuff out */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|XMIT_WAKEUP
comma
op_amp
id|ap-&gt;xmit_flags
)paren
op_logical_and
id|ppp_async_push
c_func
(paren
id|ap
)paren
)paren
id|ppp_output_wakeup
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Procedures for encapsulation and framing.&n; */
multiline_comment|/*&n; * Procedure to encode the data for async serial transmission.&n; * Does octet stuffing (escaping), puts the address/control bytes&n; * on if A/C compression is disabled, and does protocol compression.&n; * Assumes ap-&gt;tpkt != 0 on entry.&n; * Returns 1 if we finished the current frame, 0 otherwise.&n; */
DECL|macro|PUT_BYTE
mdefine_line|#define PUT_BYTE(ap, buf, c, islcp)&t;do {&t;&t;&bslash;&n;&t;if ((islcp &amp;&amp; c &lt; 0x20) || (ap-&gt;xaccm[c &gt;&gt; 5] &amp; (1 &lt;&lt; (c &amp; 0x1f)))) {&bslash;&n;&t;&t;*buf++ = PPP_ESCAPE;&t;&t;&t;&bslash;&n;&t;&t;*buf++ = c ^ 0x20;&t;&t;&t;&bslash;&n;&t;} else&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;*buf++ = c;&t;&t;&t;&t;&bslash;&n;} while (0)
r_static
r_int
DECL|function|ppp_async_encode
id|ppp_async_encode
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
(brace
r_int
id|fcs
comma
id|i
comma
id|count
comma
id|c
comma
id|proto
suffix:semicolon
r_int
r_char
op_star
id|buf
comma
op_star
id|buflim
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|islcp
suffix:semicolon
id|buf
op_assign
id|ap-&gt;obuf
suffix:semicolon
id|ap-&gt;olim
op_assign
id|buf
suffix:semicolon
id|ap-&gt;optr
op_assign
id|buf
suffix:semicolon
id|i
op_assign
id|ap-&gt;tpkt_pos
suffix:semicolon
id|data
op_assign
id|ap-&gt;tpkt-&gt;data
suffix:semicolon
id|count
op_assign
id|ap-&gt;tpkt-&gt;len
suffix:semicolon
id|fcs
op_assign
id|ap-&gt;tfcs
suffix:semicolon
id|proto
op_assign
(paren
id|data
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|data
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * LCP packets with code values between 1 (configure-reqest)&n;&t; * and 7 (code-reject) must be sent as though no options&n;&t; * had been negotiated.&n;&t; */
id|islcp
op_assign
id|proto
op_eq
id|PPP_LCP
op_logical_and
l_int|1
op_le
id|data
(braket
l_int|2
)braket
op_logical_and
id|data
(braket
l_int|2
)braket
op_le
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|islcp
)paren
id|async_lcp_peek
c_func
(paren
id|ap
comma
id|data
comma
id|count
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Start of a new packet - insert the leading FLAG&n;&t;&t; * character if necessary.&n;&t;&t; */
r_if
c_cond
(paren
id|islcp
op_logical_or
id|flag_time
op_eq
l_int|0
op_logical_or
id|jiffies
op_minus
id|ap-&gt;last_xmit
op_ge
id|flag_time
)paren
op_star
id|buf
op_increment
op_assign
id|PPP_FLAG
suffix:semicolon
id|ap-&gt;last_xmit
op_assign
id|jiffies
suffix:semicolon
id|fcs
op_assign
id|PPP_INITFCS
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Put in the address/control bytes if necessary&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ap-&gt;flags
op_amp
id|SC_COMP_AC
)paren
op_eq
l_int|0
op_logical_or
id|islcp
)paren
(brace
id|PUT_BYTE
c_func
(paren
id|ap
comma
id|buf
comma
l_int|0xff
comma
id|islcp
)paren
suffix:semicolon
id|fcs
op_assign
id|PPP_FCS
c_func
(paren
id|fcs
comma
l_int|0xff
)paren
suffix:semicolon
id|PUT_BYTE
c_func
(paren
id|ap
comma
id|buf
comma
l_int|0x03
comma
id|islcp
)paren
suffix:semicolon
id|fcs
op_assign
id|PPP_FCS
c_func
(paren
id|fcs
comma
l_int|0x03
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Once we put in the last byte, we need to put in the FCS&n;&t; * and closing flag, so make sure there is at least 7 bytes&n;&t; * of free space in the output buffer.&n;&t; */
id|buflim
op_assign
id|ap-&gt;obuf
op_plus
id|OBUFSIZE
op_minus
l_int|6
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|count
op_logical_and
id|buf
OL
id|buflim
)paren
(brace
id|c
op_assign
id|data
(braket
id|i
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1
op_logical_and
id|c
op_eq
l_int|0
op_logical_and
(paren
id|ap-&gt;flags
op_amp
id|SC_COMP_PROT
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* compress protocol field */
id|fcs
op_assign
id|PPP_FCS
c_func
(paren
id|fcs
comma
id|c
)paren
suffix:semicolon
id|PUT_BYTE
c_func
(paren
id|ap
comma
id|buf
comma
id|c
comma
id|islcp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|count
)paren
(brace
multiline_comment|/*&n;&t;&t; * Remember where we are up to in this packet.&n;&t;&t; */
id|ap-&gt;olim
op_assign
id|buf
suffix:semicolon
id|ap-&gt;tpkt_pos
op_assign
id|i
suffix:semicolon
id|ap-&gt;tfcs
op_assign
id|fcs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have finished the packet.  Add the FCS and flag.&n;&t; */
id|fcs
op_assign
op_complement
id|fcs
suffix:semicolon
id|c
op_assign
id|fcs
op_amp
l_int|0xff
suffix:semicolon
id|PUT_BYTE
c_func
(paren
id|ap
comma
id|buf
comma
id|c
comma
id|islcp
)paren
suffix:semicolon
id|c
op_assign
(paren
id|fcs
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|PUT_BYTE
c_func
(paren
id|ap
comma
id|buf
comma
id|c
comma
id|islcp
)paren
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|PPP_FLAG
suffix:semicolon
id|ap-&gt;olim
op_assign
id|buf
suffix:semicolon
id|kfree_skb
c_func
(paren
id|ap-&gt;tpkt
)paren
suffix:semicolon
id|ap-&gt;tpkt
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Transmit-side routines.&n; */
multiline_comment|/*&n; * Send a packet to the peer over an async tty line.&n; * Returns 1 iff the packet was accepted.&n; * If the packet was not accepted, we will call ppp_output_wakeup&n; * at some later time.&n; */
r_static
r_int
DECL|function|ppp_async_send
id|ppp_async_send
c_func
(paren
r_struct
id|ppp_channel
op_star
id|chan
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|asyncppp
op_star
id|ap
op_assign
id|chan
op_member_access_from_pointer
r_private
suffix:semicolon
id|ppp_async_push
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;xmit_flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* already full */
id|ap-&gt;tpkt
op_assign
id|skb
suffix:semicolon
id|ap-&gt;tpkt_pos
op_assign
l_int|0
suffix:semicolon
id|ppp_async_push
c_func
(paren
id|ap
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Push as much data as possible out to the tty.&n; */
r_static
r_int
DECL|function|ppp_async_push
id|ppp_async_push
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
(brace
r_int
id|avail
comma
id|sent
comma
id|done
op_assign
l_int|0
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|ap-&gt;tty
suffix:semicolon
r_int
id|tty_stuffed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We can get called recursively here if the tty write&n;&t; * function calls our wakeup function.  This can happen&n;&t; * for example on a pty with both the master and slave&n;&t; * set to PPP line discipline.&n;&t; * We use the XMIT_BUSY bit to detect this and get out,&n;&t; * leaving the XMIT_WAKEUP bit set to tell the other&n;&t; * instance that it may now be able to write more now.&n;&t; */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|XMIT_BUSY
comma
op_amp
id|ap-&gt;xmit_flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|XMIT_WAKEUP
comma
op_amp
id|ap-&gt;xmit_flags
)paren
)paren
id|tty_stuffed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_stuffed
op_logical_and
id|ap-&gt;optr
OL
id|ap-&gt;olim
)paren
(brace
id|avail
op_assign
id|ap-&gt;olim
op_minus
id|ap-&gt;optr
suffix:semicolon
id|set_bit
c_func
(paren
id|TTY_DO_WRITE_WAKEUP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|sent
op_assign
id|tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|tty
comma
id|ap-&gt;optr
comma
id|avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sent
OL
l_int|0
)paren
r_goto
id|flush
suffix:semicolon
multiline_comment|/* error, e.g. loss of CD */
id|ap-&gt;optr
op_add_assign
id|sent
suffix:semicolon
r_if
c_cond
(paren
id|sent
OL
id|avail
)paren
id|tty_stuffed
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;optr
op_ge
id|ap-&gt;olim
op_logical_and
id|ap-&gt;tpkt
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ppp_async_encode
c_func
(paren
id|ap
)paren
)paren
(brace
multiline_comment|/* finished processing ap-&gt;tpkt */
id|clear_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;xmit_flags
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We haven&squot;t made any progress this time around.&n;&t;&t; * Clear XMIT_BUSY to let other callers in, but&n;&t;&t; * after doing so we have to check if anyone set&n;&t;&t; * XMIT_WAKEUP since we last checked it.  If they&n;&t;&t; * did, we should try again to set XMIT_BUSY and go&n;&t;&t; * around again in case XMIT_BUSY was still set when&n;&t;&t; * the other caller tried.&n;&t;&t; */
id|clear_bit
c_func
(paren
id|XMIT_BUSY
comma
op_amp
id|ap-&gt;xmit_flags
)paren
suffix:semicolon
multiline_comment|/* any more work to do? if not, exit the loop */
r_if
c_cond
(paren
op_logical_neg
(paren
id|test_bit
c_func
(paren
id|XMIT_WAKEUP
comma
op_amp
id|ap-&gt;xmit_flags
)paren
op_logical_or
(paren
op_logical_neg
id|tty_stuffed
op_logical_and
id|ap-&gt;tpkt
op_ne
l_int|0
)paren
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* more work to do, see if we can do it now */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|XMIT_BUSY
comma
op_amp
id|ap-&gt;xmit_flags
)paren
)paren
r_break
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
suffix:semicolon
r_return
id|done
suffix:semicolon
id|flush
suffix:colon
id|clear_bit
c_func
(paren
id|XMIT_BUSY
comma
op_amp
id|ap-&gt;xmit_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;tpkt
op_ne
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|ap-&gt;tpkt
)paren
suffix:semicolon
id|ap-&gt;tpkt
op_assign
l_int|NULL
suffix:semicolon
id|clear_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;xmit_flags
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
id|ap-&gt;optr
op_assign
id|ap-&gt;olim
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
suffix:semicolon
r_return
id|done
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush output from our internal buffers.&n; * Called for the TCFLSH ioctl. Can be entered in parallel&n; * but this is covered by the xmit_lock.&n; */
r_static
r_void
DECL|function|ppp_async_flush_output
id|ppp_async_flush_output
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
(brace
r_int
id|done
op_assign
l_int|0
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
suffix:semicolon
id|ap-&gt;optr
op_assign
id|ap-&gt;olim
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;tpkt
op_ne
l_int|NULL
)paren
(brace
id|kfree_skb
c_func
(paren
id|ap-&gt;tpkt
)paren
suffix:semicolon
id|ap-&gt;tpkt
op_assign
l_int|NULL
suffix:semicolon
id|clear_bit
c_func
(paren
id|XMIT_FULL
comma
op_amp
id|ap-&gt;xmit_flags
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|ap-&gt;xmit_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
id|ppp_output_wakeup
c_func
(paren
op_amp
id|ap-&gt;chan
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive-side routines.&n; */
multiline_comment|/* see how many ordinary chars there are at the start of buf */
r_static
r_inline
r_int
DECL|function|scan_ordinary
id|scan_ordinary
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|i
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
op_increment
id|i
)paren
(brace
id|c
op_assign
id|buf
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|PPP_ESCAPE
op_logical_or
id|c
op_eq
id|PPP_FLAG
op_logical_or
(paren
id|c
OL
l_int|0x20
op_logical_and
(paren
id|ap-&gt;raccm
op_amp
(paren
l_int|1
op_lshift
id|c
)paren
)paren
op_ne
l_int|0
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* called when a flag is seen - do end-of-packet processing */
r_static
r_void
DECL|function|process_input_packet
id|process_input_packet
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
r_int
id|len
comma
id|fcs
comma
id|proto
suffix:semicolon
id|skb
op_assign
id|ap-&gt;rpkt
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;state
op_amp
(paren
id|SC_TOSS
op_or
id|SC_ESCAPE
)paren
)paren
r_goto
id|err
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* 0-length packet */
multiline_comment|/* check the FCS */
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|3
)paren
r_goto
id|err
suffix:semicolon
multiline_comment|/* too short */
id|fcs
op_assign
id|PPP_INITFCS
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|len
OG
l_int|0
suffix:semicolon
op_decrement
id|len
)paren
id|fcs
op_assign
id|PPP_FCS
c_func
(paren
id|fcs
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fcs
op_ne
id|PPP_GOODFCS
)paren
r_goto
id|err
suffix:semicolon
multiline_comment|/* bad FCS */
id|skb_trim
c_func
(paren
id|skb
comma
id|skb-&gt;len
op_minus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* check for address/control and protocol compression */
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_eq
id|PPP_ALLSTATIONS
op_logical_and
id|p
(braket
l_int|1
)braket
op_eq
id|PPP_UI
)paren
(brace
multiline_comment|/* chop off address/control */
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|3
)paren
r_goto
id|err
suffix:semicolon
id|p
op_assign
id|skb_pull
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
)brace
id|proto
op_assign
id|p
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|proto
op_amp
l_int|1
)paren
(brace
multiline_comment|/* protocol is compressed */
id|skb_push
c_func
(paren
id|skb
comma
l_int|1
)paren
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|2
)paren
r_goto
id|err
suffix:semicolon
id|proto
op_assign
(paren
id|proto
op_lshift
l_int|8
)paren
op_plus
id|p
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|proto
op_eq
id|PPP_LCP
)paren
id|async_lcp_peek
c_func
(paren
id|ap
comma
id|p
comma
id|skb-&gt;len
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* queue the frame to be processed */
id|skb-&gt;cb
(braket
l_int|0
)braket
op_assign
id|ap-&gt;state
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|ap-&gt;rqueue
comma
id|skb
)paren
suffix:semicolon
id|ap-&gt;rpkt
op_assign
l_int|NULL
suffix:semicolon
id|ap-&gt;state
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
id|err
suffix:colon
multiline_comment|/* frame had an error, remember that, reset SC_TOSS &amp; SC_ESCAPE */
id|ap-&gt;state
op_assign
id|SC_PREV_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|skb_trim
c_func
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Called when the tty driver has data for us. Runs parallel with the&n;   other ldisc functions but will not be re-entered */
r_static
r_void
DECL|function|ppp_async_input
id|ppp_async_input
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_char
op_star
id|flags
comma
r_int
id|count
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|c
comma
id|i
comma
id|j
comma
id|n
comma
id|s
comma
id|f
suffix:semicolon
r_int
r_char
op_star
id|sp
suffix:semicolon
multiline_comment|/* update bits used for 8-bit cleanness detection */
r_if
c_cond
(paren
op_complement
id|ap-&gt;rbits
op_amp
id|SC_RCV_BITS
)paren
(brace
id|s
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
op_increment
id|i
)paren
(brace
id|c
op_assign
id|buf
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_ne
l_int|0
op_logical_and
id|flags
(braket
id|i
)braket
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|s
op_or_assign
(paren
id|c
op_amp
l_int|0x80
)paren
ques
c_cond
id|SC_RCV_B7_1
suffix:colon
id|SC_RCV_B7_0
suffix:semicolon
id|c
op_assign
(paren
(paren
id|c
op_rshift
l_int|4
)paren
op_xor
id|c
)paren
op_amp
l_int|0xf
suffix:semicolon
id|s
op_or_assign
(paren
l_int|0x6996
op_amp
(paren
l_int|1
op_lshift
id|c
)paren
)paren
ques
c_cond
id|SC_RCV_ODDP
suffix:colon
id|SC_RCV_EVNP
suffix:semicolon
)brace
id|ap-&gt;rbits
op_or_assign
id|s
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
multiline_comment|/* scan through and see how many chars we can do in bulk */
r_if
c_cond
(paren
(paren
id|ap-&gt;state
op_amp
id|SC_ESCAPE
)paren
op_logical_and
id|buf
(braket
l_int|0
)braket
op_eq
id|PPP_ESCAPE
)paren
id|n
op_assign
l_int|1
suffix:semicolon
r_else
id|n
op_assign
id|scan_ordinary
c_func
(paren
id|ap
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|f
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_ne
l_int|0
op_logical_and
(paren
id|ap-&gt;state
op_amp
id|SC_TOSS
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check the flags to see if any char had an error */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|n
suffix:semicolon
op_increment
id|j
)paren
r_if
c_cond
(paren
(paren
id|f
op_assign
id|flags
(braket
id|j
)braket
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|f
op_ne
l_int|0
)paren
(brace
multiline_comment|/* start tossing */
id|ap-&gt;state
op_or_assign
id|SC_TOSS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|n
OG
l_int|0
op_logical_and
(paren
id|ap-&gt;state
op_amp
id|SC_TOSS
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* stuff the chars in the skb */
id|skb
op_assign
id|ap-&gt;rpkt
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|0
)paren
(brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|ap-&gt;mru
op_plus
id|PPP_HDRLEN
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|0
)paren
r_goto
id|nomem
suffix:semicolon
multiline_comment|/* Try to get the payload 4-byte aligned */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_ne
id|PPP_ALLSTATIONS
)paren
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
op_plus
(paren
id|buf
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
)paren
suffix:semicolon
id|ap-&gt;rpkt
op_assign
id|skb
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
OG
id|skb_tailroom
c_func
(paren
id|skb
)paren
)paren
(brace
multiline_comment|/* packet overflowed MRU */
id|ap-&gt;state
op_or_assign
id|SC_TOSS
suffix:semicolon
)brace
r_else
(brace
id|sp
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|n
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sp
comma
id|buf
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;state
op_amp
id|SC_ESCAPE
)paren
(brace
id|sp
(braket
l_int|0
)braket
op_xor_assign
l_int|0x20
suffix:semicolon
id|ap-&gt;state
op_and_assign
op_complement
id|SC_ESCAPE
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|n
op_ge
id|count
)paren
r_break
suffix:semicolon
id|c
op_assign
id|buf
(braket
id|n
)braket
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_ne
l_int|NULL
op_logical_and
id|flags
(braket
id|n
)braket
op_ne
l_int|0
)paren
(brace
id|ap-&gt;state
op_or_assign
id|SC_TOSS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
id|PPP_FLAG
)paren
(brace
id|process_input_packet
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
id|PPP_ESCAPE
)paren
(brace
id|ap-&gt;state
op_or_assign
id|SC_ESCAPE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|I_IXON
c_func
(paren
id|ap-&gt;tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
id|START_CHAR
c_func
(paren
id|ap-&gt;tty
)paren
)paren
id|start_tty
c_func
(paren
id|ap-&gt;tty
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
id|STOP_CHAR
c_func
(paren
id|ap-&gt;tty
)paren
)paren
id|stop_tty
c_func
(paren
id|ap-&gt;tty
)paren
suffix:semicolon
)brace
multiline_comment|/* otherwise it&squot;s a char in the recv ACCM */
op_increment
id|n
suffix:semicolon
id|buf
op_add_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_ne
l_int|0
)paren
id|flags
op_add_assign
id|n
suffix:semicolon
id|count
op_sub_assign
id|n
suffix:semicolon
)brace
r_return
suffix:semicolon
id|nomem
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PPPasync: no memory (input pkt)&bslash;n&quot;
)paren
suffix:semicolon
id|ap-&gt;state
op_or_assign
id|SC_TOSS
suffix:semicolon
)brace
multiline_comment|/*&n; * We look at LCP frames going past so that we can notice&n; * and react to the LCP configure-ack from the peer.&n; * In the situation where the peer has been sent a configure-ack&n; * already, LCP is up once it has sent its configure-ack&n; * so the immediately following packet can be sent with the&n; * configured LCP options.  This allows us to process the following&n; * packet correctly without pppd needing to respond quickly.&n; *&n; * We only respond to the received configure-ack if we have just&n; * sent a configure-request, and the configure-ack contains the&n; * same data (this is checked using a 16-bit crc of the data).&n; */
DECL|macro|CONFREQ
mdefine_line|#define CONFREQ&t;&t;1&t;/* LCP code field values */
DECL|macro|CONFACK
mdefine_line|#define CONFACK&t;&t;2
DECL|macro|LCP_MRU
mdefine_line|#define LCP_MRU&t;&t;1&t;/* LCP option numbers */
DECL|macro|LCP_ASYNCMAP
mdefine_line|#define LCP_ASYNCMAP&t;2
DECL|function|async_lcp_peek
r_static
r_void
id|async_lcp_peek
c_func
(paren
r_struct
id|asyncppp
op_star
id|ap
comma
r_int
r_char
op_star
id|data
comma
r_int
id|len
comma
r_int
id|inbound
)paren
(brace
r_int
id|dlen
comma
id|fcs
comma
id|i
comma
id|code
suffix:semicolon
id|u32
id|val
suffix:semicolon
id|data
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* skip protocol bytes */
id|len
op_sub_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|4
)paren
multiline_comment|/* 4 = code, ID, length */
r_return
suffix:semicolon
id|code
op_assign
id|data
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|code
op_ne
id|CONFACK
op_logical_and
id|code
op_ne
id|CONFREQ
)paren
r_return
suffix:semicolon
id|dlen
op_assign
(paren
id|data
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_plus
id|data
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|dlen
)paren
r_return
suffix:semicolon
multiline_comment|/* packet got truncated or length is bogus */
r_if
c_cond
(paren
id|code
op_eq
(paren
id|inbound
ques
c_cond
id|CONFACK
suffix:colon
id|CONFREQ
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * sent confreq or received confack:&n;&t;&t; * calculate the crc of the data from the ID field on.&n;&t;&t; */
id|fcs
op_assign
id|PPP_INITFCS
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|dlen
suffix:semicolon
op_increment
id|i
)paren
id|fcs
op_assign
id|PPP_FCS
c_func
(paren
id|fcs
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inbound
)paren
(brace
multiline_comment|/* outbound confreq - remember the crc for later */
id|ap-&gt;lcp_fcs
op_assign
id|fcs
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* received confack, check the crc */
id|fcs
op_xor_assign
id|ap-&gt;lcp_fcs
suffix:semicolon
id|ap-&gt;lcp_fcs
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fcs
op_ne
l_int|0
)paren
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inbound
)paren
r_return
suffix:semicolon
multiline_comment|/* not interested in received confreq */
multiline_comment|/* process the options in the confack */
id|data
op_add_assign
l_int|4
suffix:semicolon
id|dlen
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* data[0] is code, data[1] is length */
r_while
c_loop
(paren
id|dlen
op_ge
l_int|2
op_logical_and
id|dlen
op_ge
id|data
(braket
l_int|1
)braket
)paren
(brace
r_switch
c_cond
(paren
id|data
(braket
l_int|0
)braket
)paren
(brace
r_case
id|LCP_MRU
suffix:colon
id|val
op_assign
(paren
id|data
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_plus
id|data
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|inbound
)paren
id|ap-&gt;mru
op_assign
id|val
suffix:semicolon
r_else
id|ap-&gt;chan.mtu
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LCP_ASYNCMAP
suffix:colon
id|val
op_assign
(paren
id|data
(braket
l_int|2
)braket
op_lshift
l_int|24
)paren
op_plus
(paren
id|data
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|data
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_plus
id|data
(braket
l_int|5
)braket
suffix:semicolon
r_if
c_cond
(paren
id|inbound
)paren
id|ap-&gt;raccm
op_assign
id|val
suffix:semicolon
r_else
id|ap-&gt;xaccm
(braket
l_int|0
)braket
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dlen
op_sub_assign
id|data
(braket
l_int|1
)braket
suffix:semicolon
id|data
op_add_assign
id|data
(braket
l_int|1
)braket
suffix:semicolon
)brace
)brace
DECL|function|ppp_async_cleanup
r_static
r_void
id|__exit
id|ppp_async_cleanup
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|tty_register_ldisc
c_func
(paren
id|N_PPP
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;failed to unregister PPP line discipline&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|ppp_async_init
id|module_init
c_func
(paren
id|ppp_async_init
)paren
suffix:semicolon
DECL|variable|ppp_async_cleanup
id|module_exit
c_func
(paren
id|ppp_async_cleanup
)paren
suffix:semicolon
eof
