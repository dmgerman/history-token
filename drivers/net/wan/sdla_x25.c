multiline_comment|/*****************************************************************************&n;* sdla_x25.c&t;WANPIPE(tm) Multiprotocol WAN Link Driver.  X.25 module.&n;*&n;* Author:&t;Nenad Corbic&t;&lt;ncorbic@sangoma.com&gt;&n;*&n;* Copyright:&t;(c) 1995-2001 Sangoma Technologies Inc.&n;*&n;*&t;&t;This program is free software; you can redistribute it and/or&n;*&t;&t;modify it under the terms of the GNU General Public License&n;*&t;&t;as published by the Free Software Foundation; either version&n;*&t;&t;2 of the License, or (at your option) any later version.&n;* ============================================================================&n;* Apr 03, 2001  Nenad Corbic&t; o Fixed the rx_skb=NULL bug in x25 in rx_intr().&n;* Dec 26, 2000  Nenad Corbic&t; o Added a new polling routine, that uses&n;*                                  a kernel timer (more efficient).&n;* Dec 25, 2000  Nenad Corbic&t; o Updated for 2.4.X kernel&n;* Jul 26, 2000  Nenad Corbic&t; o Increased the local packet buffering&n;* &t;&t;&t;&t;   for API to 4096+header_size. &n;* Jul 17, 2000  Nenad Corbic&t; o Fixed the x25 startup bug. Enable &n;* &t;&t;&t;&t;   communications only after all interfaces&n;* &t;&t;&t;&t;   come up.  HIGH SVC/PVC is used to calculate&n;* &t;&t;&t;&t;   the number of channels.&n;*                                  Enable protocol only after all interfaces&n;*                                  are enabled.&n;* Jul 10, 2000&t;Nenad Corbic&t; o Fixed the M_BIT bug. &n;* Apr 25, 2000  Nenad Corbic&t; o Pass Modem messages to the API.&n;*                                  Disable idle timeout in X25 API.&n;* Apr 14, 2000  Nenad Corbic&t; o Fixed: Large LCN number support.&n;*                                  Maximum LCN number is 4095.&n;*                                  Maximum number of X25 channels is 255.&n;* Apr 06, 2000  Nenad Corbic&t; o Added SMP Support.&n;* Mar 29, 2000  Nenad Corbic&t; o Added support for S514 PCI Card&n;* Mar 23, 2000  Nenad Corbic&t; o Improved task queue, BH handling.&n;* Mar 14, 2000  Nenad Corbic  &t; o Updated Protocol Violation handling&n;*                                  routines.  Bug Fix.&n;* Mar 10, 2000  Nenad Corbic&t; o Bug Fix: corrupted mbox recovery.&n;* Mar 09, 2000  Nenad Corbic     o Fixed the auto HDLC bug.&n;* Mar 08, 2000&t;Nenad Corbic     o Fixed LAPB HDLC startup problems.&n;*                                  Application must bring the link up &n;*                                  before tx/rx, and bring the &n;*                                  link down on close().&n;* Mar 06, 2000&t;Nenad Corbic&t; o Added an option for logging call setup &n;*                                  information. &n;* Feb 29, 2000  Nenad Corbic &t; o Added support for LAPB HDLC API&n;* Feb 25, 2000  Nenad Corbic     o Fixed the modem failure handling.&n;*                                  No Modem OOB message will be passed &n;*                                  to the user.&n;* Feb 21, 2000  Nenad Corbic &t; o Added Xpipemon Debug Support&n;* Dec 30, 1999 &t;Nenad Corbic&t; o Socket based X25API &n;* Sep 17, 1998&t;Jaspreet Singh&t; o Updates for 2.2.X  kernel&n;* Mar 15, 1998&t;Alan Cox&t; o 2.1.x porting&n;* Dec 19, 1997&t;Jaspreet Singh&t; o Added multi-channel IPX support&n;* Nov 27, 1997&t;Jaspreet Singh&t; o Added protection against enabling of irqs&n;*&t;&t;&t;&t;   when they are disabled.&n;* Nov 17, 1997  Farhan Thawar    o Added IPX support&n;*&t;&t;&t;&t; o Changed if_send() to now buffer packets when&n;*&t;&t;&t;&t;   the board is busy&n;*&t;&t;&t;&t; o Removed queueing of packets via the polling&n;*&t;&t;&t;&t;   routing&n;*&t;&t;&t;&t; o Changed if_send() critical flags to properly&n;*&t;&t;&t;&t;   handle race conditions&n;* Nov 06, 1997  Farhan Thawar    o Added support for SVC timeouts&n;*&t;&t;&t;&t; o Changed PVC encapsulation to ETH_P_IP&n;* Jul 21, 1997  Jaspreet Singh&t; o Fixed freeing up of buffers using kfree()&n;*&t;&t;&t;&t;   when packets are received.&n;* Mar 11, 1997  Farhan Thawar   Version 3.1.1&n;*                                o added support for V35&n;*                                o changed if_send() to return 0 if&n;*                                  wandev.critical() is true&n;*                                o free socket buffer in if_send() if&n;*                                  returning 0&n;*                                o added support for single &squot;@&squot; address to&n;*                                  accept all incoming calls&n;*                                o fixed bug in set_chan_state() to disconnect&n;* Jan 15, 1997&t;Gene Kozin&t;Version 3.1.0&n;*&t;&t;&t;&t; o implemented exec() entry point&n;* Jan 07, 1997&t;Gene Kozin&t;Initial version.&n;*****************************************************************************/
multiline_comment|/*======================================================&n; * &t;Includes &n; *=====================================================*/
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;&t;/* printk(), and other useful stuff */
macro_line|#include &lt;linux/stddef.h&gt;&t;/* offsetof(), etc. */
macro_line|#include &lt;linux/errno.h&gt;&t;/* return codes */
macro_line|#include &lt;linux/string.h&gt;&t;/* inline memset(), etc. */
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/slab.h&gt;&t;/* kmalloc(), kfree() */
macro_line|#include &lt;linux/wanrouter.h&gt;&t;/* WAN router definitions */
macro_line|#include &lt;linux/wanpipe.h&gt;&t;/* WANPIPE common user API definitions */
macro_line|#include &lt;asm/byteorder.h&gt;&t;/* htons(), etc. */
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;linux/delay.h&gt;&t;/* Experimental delay */
macro_line|#if defined(LINUX_2_1) || defined(LINUX_2_4)
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#else
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/if.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/sdla_x25.h&gt;&t;/* X.25 firmware API definitions */
macro_line|#include &lt;linux/if_wanpipe_common.h&gt;
macro_line|#include &lt;linux/if_wanpipe.h&gt;
multiline_comment|/*======================================================&n; * &t;Defines &amp; Macros &n; *=====================================================*/
DECL|macro|CMD_OK
mdefine_line|#define&t;CMD_OK&t;&t;0&t;&t;/* normal firmware return code */
DECL|macro|CMD_TIMEOUT
mdefine_line|#define&t;CMD_TIMEOUT&t;0xFF&t;&t;/* firmware command timed out */
DECL|macro|MAX_CMD_RETRY
mdefine_line|#define&t;MAX_CMD_RETRY&t;10&t;&t;/* max number of firmware retries */
DECL|macro|X25_CHAN_MTU
mdefine_line|#define&t;X25_CHAN_MTU&t;4096&t;&t;/* unfragmented logical channel MTU */
DECL|macro|X25_HRDHDR_SZ
mdefine_line|#define&t;X25_HRDHDR_SZ&t;7&t;&t;/* max encapsulation header size */
DECL|macro|X25_CONCT_TMOUT
mdefine_line|#define&t;X25_CONCT_TMOUT&t;(90*HZ)&t;&t;/* link connection timeout */
DECL|macro|X25_RECON_TMOUT
mdefine_line|#define&t;X25_RECON_TMOUT&t;(10*HZ)&t;&t;/* link connection timeout */
DECL|macro|CONNECT_TIMEOUT
mdefine_line|#define&t;CONNECT_TIMEOUT&t;(90*HZ)&t;&t;/* link connection timeout */
DECL|macro|HOLD_DOWN_TIME
mdefine_line|#define&t;HOLD_DOWN_TIME&t;(30*HZ)&t;&t;/* link hold down time */
DECL|macro|MAX_BH_BUFF
mdefine_line|#define MAX_BH_BUFF&t;10
DECL|macro|M_BIT
mdefine_line|#define M_BIT&t;&t;0x01&t;
singleline_comment|//#define PRINT_DEBUG 1
macro_line|#ifdef PRINT_DEBUG
DECL|macro|DBG_PRINTK
mdefine_line|#define DBG_PRINTK(format, a...) printk(format, ## a)
macro_line|#else
DECL|macro|DBG_PRINTK
mdefine_line|#define DBG_PRINTK(format, a...)
macro_line|#endif  
DECL|macro|TMR_INT_ENABLED_POLL_ACTIVE
mdefine_line|#define TMR_INT_ENABLED_POLL_ACTIVE      0x01
DECL|macro|TMR_INT_ENABLED_POLL_CONNECT_ON
mdefine_line|#define TMR_INT_ENABLED_POLL_CONNECT_ON  0x02
DECL|macro|TMR_INT_ENABLED_POLL_CONNECT_OFF
mdefine_line|#define TMR_INT_ENABLED_POLL_CONNECT_OFF 0x04
DECL|macro|TMR_INT_ENABLED_POLL_DISCONNECT
mdefine_line|#define TMR_INT_ENABLED_POLL_DISCONNECT  0x08
DECL|macro|TMR_INT_ENABLED_CMD_EXEC
mdefine_line|#define TMR_INT_ENABLED_CMD_EXEC&t; 0x10
DECL|macro|TMR_INT_ENABLED_UPDATE
mdefine_line|#define TMR_INT_ENABLED_UPDATE&t;&t; 0x20
DECL|macro|TMR_INT_ENABLED_UDP_PKT
mdefine_line|#define TMR_INT_ENABLED_UDP_PKT&t;&t; 0x40
DECL|macro|MAX_X25_ADDR_SIZE
mdefine_line|#define MAX_X25_ADDR_SIZE&t;16
DECL|macro|MAX_X25_DATA_SIZE
mdefine_line|#define MAX_X25_DATA_SIZE &t;129
DECL|macro|MAX_X25_FACL_SIZE
mdefine_line|#define MAX_X25_FACL_SIZE&t;110
DECL|macro|TRY_CMD_AGAIN
mdefine_line|#define TRY_CMD_AGAIN&t;2
DECL|macro|DELAY_RESULT
mdefine_line|#define DELAY_RESULT    1
DECL|macro|RETURN_RESULT
mdefine_line|#define RETURN_RESULT   0
DECL|macro|DCD
mdefine_line|#define DCD(x) (x &amp; 0x03 ? &quot;HIGH&quot; : &quot;LOW&quot;)
DECL|macro|CTS
mdefine_line|#define CTS(x) (x &amp; 0x05 ? &quot;HIGH&quot; : &quot;LOW&quot;)
multiline_comment|/* Driver will not write log messages about &n; * modem status if defined.*/
DECL|macro|MODEM_NOT_LOG
mdefine_line|#define MODEM_NOT_LOG 1
multiline_comment|/*==================================================== &n; * &t;For IPXWAN &n; *===================================================*/
DECL|macro|CVHexToAscii
mdefine_line|#define CVHexToAscii(b) (((unsigned char)(b) &gt; (unsigned char)9) ? ((unsigned char)&squot;A&squot; + ((unsigned char)(b) - (unsigned char)10)) : ((unsigned char)&squot;0&squot; + (unsigned char)(b)))
multiline_comment|/*====================================================&n; *           MEMORY DEBUGGING FUNCTION&n; *====================================================&n;&n;#define KMEM_SAFETYZONE 8&n;&n;static void * dbg_kmalloc(unsigned int size, int prio, int line) {&n;&t;int i = 0;&n;&t;void * v = kmalloc(size+sizeof(unsigned int)+2*KMEM_SAFETYZONE*8,prio);&n;&t;char * c1 = v;&t;&n;&t;c1 += sizeof(unsigned int);&n;&t;*((unsigned int *)v) = size;&n;&n;&t;for (i = 0; i &lt; KMEM_SAFETYZONE; i++) {&n;&t;&t;c1[0] = &squot;D&squot;; c1[1] = &squot;E&squot;; c1[2] = &squot;A&squot;; c1[3] = &squot;D&squot;;&n;&t;&t;c1[4] = &squot;B&squot;; c1[5] = &squot;E&squot;; c1[6] = &squot;E&squot;; c1[7] = &squot;F&squot;;&n;&t;&t;c1 += 8;&n;&t;}&n;&t;c1 += size;&n;&t;for (i = 0; i &lt; KMEM_SAFETYZONE; i++) {&n;&t;&t;c1[0] = &squot;M&squot;; c1[1] = &squot;U&squot;; c1[2] = &squot;N&squot;; c1[3] = &squot;G&squot;;&n;&t;&t;c1[4] = &squot;W&squot;; c1[5] = &squot;A&squot;; c1[6] = &squot;L&squot;; c1[7] = &squot;L&squot;;&n;&t;&t;c1 += 8;&n;&t;}&n;&t;v = ((char *)v) + sizeof(unsigned int) + KMEM_SAFETYZONE*8;&n;&t;printk(KERN_INFO &quot;line %d  kmalloc(%d,%d) = %p&bslash;n&quot;,line,size,prio,v);&n;&t;return v;&n;}&n;static void dbg_kfree(void * v, int line) {&n;&t;unsigned int * sp = (unsigned int *)(((char *)v) - (sizeof(unsigned int) + KMEM_SAFETYZONE*8));&n;&t;unsigned int size = *sp;&n;&t;char * c1 = ((char *)v) - KMEM_SAFETYZONE*8;&n;&t;int i = 0;&n;&t;for (i = 0; i &lt; KMEM_SAFETYZONE; i++) {&n;&t;&t;if (   c1[0] != &squot;D&squot; || c1[1] != &squot;E&squot; || c1[2] != &squot;A&squot; || c1[3] != &squot;D&squot;&n;&t;&t;    || c1[4] != &squot;B&squot; || c1[5] != &squot;E&squot; || c1[6] != &squot;E&squot; || c1[7] != &squot;F&squot;) {&n;&t;&t;&t;printk(KERN_INFO &quot;kmalloced block at %p has been corrupted (underrun)!&bslash;n&quot;,v);&n;&t;&t;&t;printk(KERN_INFO &quot; %4x: %2x %2x %2x %2x %2x %2x %2x %2x&bslash;n&quot;, i*8,&n;&t;&t;&t;                c1[0],c1[1],c1[2],c1[3],c1[4],c1[5],c1[6],c1[7] );&n;&t;&t;}&n;&t;&t;c1 += 8;&n;&t;}&n;&t;c1 += size;&n;&t;for (i = 0; i &lt; KMEM_SAFETYZONE; i++) {&n;&t;&t;if (   c1[0] != &squot;M&squot; || c1[1] != &squot;U&squot; || c1[2] != &squot;N&squot; || c1[3] != &squot;G&squot;&n;&t;&t;    || c1[4] != &squot;W&squot; || c1[5] != &squot;A&squot; || c1[6] != &squot;L&squot; || c1[7] != &squot;L&squot;&n;&t;&t;   ) {&n;&t;&t;&t;printk(KERN_INFO &quot;kmalloced block at %p has been corrupted (overrun):&bslash;n&quot;,v);&n;&t;&t;&t;printk(KERN_INFO &quot; %4x: %2x %2x %2x %2x %2x %2x %2x %2x&bslash;n&quot;, i*8,&n;&t;&t;&t;                c1[0],c1[1],c1[2],c1[3],c1[4],c1[5],c1[6],c1[7] );&n;&t;&t;}&n;&t;&t;c1 += 8;&n;&t;}&n;&t;printk(KERN_INFO &quot;line %d  kfree(%p)&bslash;n&quot;,line,v);&n;&t;v = ((char *)v) - (sizeof(unsigned int) + KMEM_SAFETYZONE*8);&n;&t;kfree(v);&n;}&n;&n;#define kmalloc(x,y) dbg_kmalloc(x,y,__LINE__)&n;#define kfree(x) dbg_kfree(x,__LINE__)&n;&n;==============================================================*/
multiline_comment|/*===============================================&n; * &t;Data Structures &n; *===============================================*/
multiline_comment|/*========================================================&n; * Name: &t;x25_channel&n; *&n; * Purpose:&t;To hold private informaton for each  &n; *              logical channel.&n; *&t;&t;&n; * Rationale:  &t;Per-channel debugging is possible if each &n; *              channel has its own private area.&n; *&t;&n; * Assumptions:&n; *&n; * Description:&t;This is an extention of the &squot;netdevice_t&squot; &n; *              we create for each network interface to keep &n; *              the rest of X.25 channel-specific data. &n; *&n; * Construct:&t;Typedef&n; */
DECL|struct|x25_channel
r_typedef
r_struct
id|x25_channel
(brace
DECL|member|common
id|wanpipe_common_t
id|common
suffix:semicolon
multiline_comment|/* common area for x25api and socket */
DECL|member|name
r_char
id|name
(braket
id|WAN_IFNAME_SZ
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* interface name, ASCIIZ */
DECL|member|addr
r_char
id|addr
(braket
id|WAN_ADDRESS_SZ
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* media address, ASCIIZ */
DECL|member|tx_pkt_size
r_int
id|tx_pkt_size
suffix:semicolon
DECL|member|protocol
r_int
r_int
id|protocol
suffix:semicolon
multiline_comment|/* ethertype, 0 - multiplexed */
DECL|member|drop_sequence
r_char
id|drop_sequence
suffix:semicolon
multiline_comment|/* mark sequence for dropping */
DECL|member|state_tick
r_int
r_int
id|state_tick
suffix:semicolon
multiline_comment|/* time of the last state change */
DECL|member|idle_timeout
r_int
id|idle_timeout
suffix:semicolon
multiline_comment|/* sec, before disconnecting */
DECL|member|i_timeout_sofar
r_int
r_int
id|i_timeout_sofar
suffix:semicolon
multiline_comment|/* # of sec&squot;s we&squot;ve been idle */
DECL|member|hold_timeout
r_int
id|hold_timeout
suffix:semicolon
multiline_comment|/* sec, before re-connecting */
DECL|member|tick_counter
r_int
r_int
id|tick_counter
suffix:semicolon
multiline_comment|/* counter for transmit time out */
DECL|member|devtint
r_char
id|devtint
suffix:semicolon
multiline_comment|/* Weather we should dev_tint() */
DECL|member|rx_skb
r_struct
id|sk_buff
op_star
id|rx_skb
suffix:semicolon
multiline_comment|/* receive socket buffer */
DECL|member|tx_skb
r_struct
id|sk_buff
op_star
id|tx_skb
suffix:semicolon
multiline_comment|/* transmit socket buffer */
DECL|member|bh_head
id|bh_data_t
op_star
id|bh_head
suffix:semicolon
multiline_comment|/* Circular buffer for x25api_bh */
DECL|member|tq_working
r_int
r_int
id|tq_working
suffix:semicolon
DECL|member|bh_write
r_volatile
r_int
id|bh_write
suffix:semicolon
DECL|member|bh_read
r_volatile
r_int
id|bh_read
suffix:semicolon
DECL|member|bh_buff_used
id|atomic_t
id|bh_buff_used
suffix:semicolon
DECL|member|card
id|sdla_t
op_star
id|card
suffix:semicolon
multiline_comment|/* -&gt; owner */
DECL|member|dev
id|netdevice_t
op_star
id|dev
suffix:semicolon
multiline_comment|/* -&gt; bound devce */
DECL|member|ch_idx
r_int
id|ch_idx
suffix:semicolon
DECL|member|enable_IPX
r_int
r_char
id|enable_IPX
suffix:semicolon
DECL|member|network_number
r_int
r_int
id|network_number
suffix:semicolon
macro_line|#if defined(LINUX_2_1) || defined(LINUX_2_4)
DECL|member|ifstats
r_struct
id|net_device_stats
id|ifstats
suffix:semicolon
multiline_comment|/* interface statistics */
macro_line|#else
DECL|member|ifstats
r_struct
id|enet_statistics
id|ifstats
suffix:semicolon
macro_line|#endif&t;
DECL|member|transmit_length
r_int
r_int
id|transmit_length
suffix:semicolon
DECL|member|tx_offset
r_int
r_int
id|tx_offset
suffix:semicolon
DECL|member|transmit_buffer
r_char
id|transmit_buffer
(braket
id|X25_CHAN_MTU
op_plus
r_sizeof
(paren
id|x25api_hdr_t
)paren
)braket
suffix:semicolon
DECL|member|if_send_stat
id|if_send_stat_t
id|if_send_stat
suffix:semicolon
DECL|member|rx_intr_stat
id|rx_intr_stat_t
id|rx_intr_stat
suffix:semicolon
DECL|member|pipe_mgmt_stat
id|pipe_mgmt_stat_t
id|pipe_mgmt_stat
suffix:semicolon
DECL|member|router_start_time
r_int
r_int
id|router_start_time
suffix:semicolon
multiline_comment|/* Router start time in seconds */
DECL|member|router_up_time
r_int
r_int
id|router_up_time
suffix:semicolon
DECL|typedef|x25_channel_t
)brace
id|x25_channel_t
suffix:semicolon
multiline_comment|/* FIXME Take this out */
macro_line|#ifdef NEX_OLD_CALL_INFO
DECL|struct|x25_call_info
r_typedef
r_struct
id|x25_call_info
(brace
DECL|member|dest
DECL|member|PACKED
r_char
id|dest
(braket
l_int|17
)braket
suffix:semicolon
id|PACKED
suffix:semicolon
multiline_comment|/* ASCIIZ destination address */
DECL|member|src
DECL|member|PACKED
r_char
id|src
(braket
l_int|17
)braket
suffix:semicolon
id|PACKED
suffix:semicolon
multiline_comment|/* ASCIIZ source address */
DECL|member|nuser
DECL|member|PACKED
r_char
id|nuser
suffix:semicolon
id|PACKED
suffix:semicolon
multiline_comment|/* number of user data bytes */
DECL|member|user
DECL|member|PACKED
r_int
r_char
id|user
(braket
l_int|127
)braket
suffix:semicolon
id|PACKED
suffix:semicolon
multiline_comment|/* user data */
DECL|member|nfacil
DECL|member|PACKED
r_char
id|nfacil
suffix:semicolon
id|PACKED
suffix:semicolon
multiline_comment|/* number of facilities */
r_struct
(brace
DECL|member|code
DECL|member|PACKED
r_int
r_char
id|code
suffix:semicolon
id|PACKED
suffix:semicolon
DECL|member|parm
DECL|member|PACKED
r_int
r_char
id|parm
suffix:semicolon
id|PACKED
suffix:semicolon
DECL|member|facil
)brace
id|facil
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* facilities */
DECL|typedef|x25_call_info_t
)brace
id|x25_call_info_t
suffix:semicolon
macro_line|#else
DECL|struct|x25_call_info
r_typedef
r_struct
id|x25_call_info
(brace
DECL|member|PACKED
r_char
id|dest
(braket
id|MAX_X25_ADDR_SIZE
)braket
id|PACKED
suffix:semicolon
multiline_comment|/* ASCIIZ destination address */
DECL|member|PACKED
r_char
id|src
(braket
id|MAX_X25_ADDR_SIZE
)braket
id|PACKED
suffix:semicolon
multiline_comment|/* ASCIIZ source address */
DECL|member|PACKED
r_int
r_char
id|nuser
id|PACKED
suffix:semicolon
DECL|member|PACKED
r_int
r_char
id|user
(braket
id|MAX_X25_DATA_SIZE
)braket
id|PACKED
suffix:semicolon
multiline_comment|/* user data */
DECL|member|PACKED
r_int
r_char
id|nfacil
id|PACKED
suffix:semicolon
DECL|member|PACKED
r_int
r_char
id|facil
(braket
id|MAX_X25_FACL_SIZE
)braket
id|PACKED
suffix:semicolon
DECL|member|PACKED
r_int
r_int
id|lcn
id|PACKED
suffix:semicolon
DECL|typedef|x25_call_info_t
)brace
id|x25_call_info_t
suffix:semicolon
macro_line|#endif
multiline_comment|/*===============================================&n; *&t;Private Function Prototypes&n; *==============================================*/
multiline_comment|/*================================================= &n; * WAN link driver entry points. These are &n; * called by the WAN router module.&n; */
r_static
r_int
id|update
(paren
id|wan_device_t
op_star
id|wandev
)paren
suffix:semicolon
r_static
r_int
id|new_if
(paren
id|wan_device_t
op_star
id|wandev
comma
id|netdevice_t
op_star
id|dev
comma
id|wanif_conf_t
op_star
id|conf
)paren
suffix:semicolon
r_static
r_int
id|del_if
(paren
id|wan_device_t
op_star
id|wandev
comma
id|netdevice_t
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|disable_comm
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|disable_comm_shutdown
c_func
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
multiline_comment|/*================================================= &n; *&t;WANPIPE-specific entry points &n; */
r_static
r_int
id|wpx_exec
(paren
r_struct
id|sdla
op_star
id|card
comma
r_void
op_star
id|u_cmd
comma
r_void
op_star
id|u_data
)paren
suffix:semicolon
r_static
r_void
id|x25api_bh
(paren
id|netdevice_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|x25api_bh_cleanup
(paren
id|netdevice_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|bh_enqueue
(paren
id|netdevice_t
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
multiline_comment|/*=================================================  &n; * &t;Network device interface &n; */
r_static
r_int
id|if_init
(paren
id|netdevice_t
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|if_open
(paren
id|netdevice_t
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|if_close
(paren
id|netdevice_t
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|if_header
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|netdevice_t
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|if_rebuild_hdr
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_int
id|if_send
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|netdevice_t
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|if_stats
(paren
id|netdevice_t
op_star
id|dev
)paren
suffix:semicolon
macro_line|#ifdef LINUX_2_4
r_static
r_void
id|if_tx_timeout
(paren
id|netdevice_t
op_star
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*=================================================  &n; * &t;Interrupt handlers &n; */
r_static
r_void
id|wpx_isr
(paren
id|sdla_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|rx_intr
(paren
id|sdla_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|tx_intr
(paren
id|sdla_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|status_intr
(paren
id|sdla_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|event_intr
(paren
id|sdla_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|spur_intr
(paren
id|sdla_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|timer_intr
(paren
id|sdla_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|tx_intr_send
c_func
(paren
id|sdla_t
op_star
comma
id|netdevice_t
op_star
)paren
suffix:semicolon
r_static
id|netdevice_t
op_star
id|move_dev_to_next
(paren
id|sdla_t
op_star
comma
id|netdevice_t
op_star
)paren
suffix:semicolon
multiline_comment|/*=================================================  &n; *&t;Background polling routines &n; */
r_static
r_void
id|wpx_poll
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|poll_disconnected
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|poll_connecting
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|poll_active
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|trigger_x25_poll
c_func
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|x25_timer_routine
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
multiline_comment|/*=================================================  &n; *&t;X.25 firmware interface functions &n; */
r_static
r_int
id|x25_get_version
(paren
id|sdla_t
op_star
id|card
comma
r_char
op_star
id|str
)paren
suffix:semicolon
r_static
r_int
id|x25_configure
(paren
id|sdla_t
op_star
id|card
comma
id|TX25Config
op_star
id|conf
)paren
suffix:semicolon
r_static
r_int
id|hdlc_configure
(paren
id|sdla_t
op_star
id|card
comma
id|TX25Config
op_star
id|conf
)paren
suffix:semicolon
r_static
r_int
id|set_hdlc_level
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_int
id|x25_get_err_stats
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_int
id|x25_get_stats
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_int
id|x25_set_intr_mode
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|mode
)paren
suffix:semicolon
r_static
r_int
id|x25_close_hdlc
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_int
id|x25_open_hdlc
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_int
id|x25_setup_hdlc
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_int
id|x25_set_dtr
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|dtr
)paren
suffix:semicolon
r_static
r_int
id|x25_get_chan_conf
(paren
id|sdla_t
op_star
id|card
comma
id|x25_channel_t
op_star
id|chan
)paren
suffix:semicolon
r_static
r_int
id|x25_place_call
(paren
id|sdla_t
op_star
id|card
comma
id|x25_channel_t
op_star
id|chan
)paren
suffix:semicolon
r_static
r_int
id|x25_accept_call
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|lcn
comma
r_int
id|qdm
)paren
suffix:semicolon
r_static
r_int
id|x25_clear_call
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|lcn
comma
r_int
id|cause
comma
r_int
id|diagn
)paren
suffix:semicolon
r_static
r_int
id|x25_send
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|lcn
comma
r_int
id|qdm
comma
r_int
id|len
comma
r_void
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|x25_fetch_events
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_int
id|x25_error
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|err
comma
r_int
id|cmd
comma
r_int
id|lcn
)paren
suffix:semicolon
multiline_comment|/*=================================================  &n; *&t;X.25 asynchronous event handlers &n; */
r_static
r_int
id|incoming_call
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|cmd
comma
r_int
id|lcn
comma
id|TX25Mbox
op_star
id|mb
)paren
suffix:semicolon
r_static
r_int
id|call_accepted
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|cmd
comma
r_int
id|lcn
comma
id|TX25Mbox
op_star
id|mb
)paren
suffix:semicolon
r_static
r_int
id|call_cleared
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|cmd
comma
r_int
id|lcn
comma
id|TX25Mbox
op_star
id|mb
)paren
suffix:semicolon
r_static
r_int
id|timeout_event
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|cmd
comma
r_int
id|lcn
comma
id|TX25Mbox
op_star
id|mb
)paren
suffix:semicolon
r_static
r_int
id|restart_event
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|cmd
comma
r_int
id|lcn
comma
id|TX25Mbox
op_star
id|mb
)paren
suffix:semicolon
multiline_comment|/*=================================================  &n; *&t;Miscellaneous functions &n; */
r_static
r_int
id|connect
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_int
id|disconnect
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
id|netdevice_t
op_star
id|get_dev_by_lcn
c_func
(paren
id|wan_device_t
op_star
id|wandev
comma
r_int
id|lcn
)paren
suffix:semicolon
r_static
r_int
id|chan_connect
(paren
id|netdevice_t
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|chan_disc
(paren
id|netdevice_t
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_chan_state
(paren
id|netdevice_t
op_star
id|dev
comma
r_int
id|state
)paren
suffix:semicolon
r_static
r_int
id|chan_send
(paren
id|netdevice_t
op_star
comma
r_void
op_star
comma
r_int
comma
r_int
r_char
)paren
suffix:semicolon
r_static
r_int
r_char
id|bps_to_speed_code
(paren
r_int
r_int
id|bps
)paren
suffix:semicolon
r_static
r_int
r_int
id|dec_to_uint
(paren
r_int
r_char
op_star
id|str
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
r_int
id|hex_to_uint
(paren
r_int
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|parse_call_info
(paren
r_int
r_char
op_star
comma
id|x25_call_info_t
op_star
)paren
suffix:semicolon
r_static
id|netdevice_t
op_star
id|find_channel
c_func
(paren
id|sdla_t
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|bind_lcn_to_dev
(paren
id|sdla_t
op_star
comma
id|netdevice_t
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|setup_for_delayed_transmit
(paren
id|netdevice_t
op_star
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*=================================================  &n; *      X25 API Functions &n; */
r_static
r_int
id|wanpipe_pull_data_in_skb
(paren
id|sdla_t
op_star
comma
id|netdevice_t
op_star
comma
r_struct
id|sk_buff
op_star
op_star
)paren
suffix:semicolon
r_static
r_void
id|timer_intr_exec
c_func
(paren
id|sdla_t
op_star
comma
r_int
r_char
)paren
suffix:semicolon
r_static
r_int
id|execute_delayed_cmd
(paren
id|sdla_t
op_star
comma
id|netdevice_t
op_star
comma
id|mbox_cmd_t
op_star
comma
r_char
)paren
suffix:semicolon
r_static
r_int
id|api_incoming_call
(paren
id|sdla_t
op_star
comma
id|TX25Mbox
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|alloc_and_init_skb_buf
(paren
id|sdla_t
op_star
comma
r_struct
id|sk_buff
op_star
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|send_delayed_cmd_result
c_func
(paren
id|sdla_t
op_star
comma
id|netdevice_t
op_star
id|dev
comma
id|TX25Mbox
op_star
)paren
suffix:semicolon
r_static
r_int
id|clear_confirm_event
(paren
id|sdla_t
op_star
comma
id|TX25Mbox
op_star
)paren
suffix:semicolon
r_static
r_void
id|send_oob_msg
(paren
id|sdla_t
op_star
comma
id|netdevice_t
op_star
comma
id|TX25Mbox
op_star
)paren
suffix:semicolon
r_static
r_int
id|timer_intr_cmd_exec
c_func
(paren
id|sdla_t
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|api_oob_event
(paren
id|sdla_t
op_star
id|card
comma
id|TX25Mbox
op_star
id|mbox
)paren
suffix:semicolon
r_static
r_int
id|check_bad_command
(paren
id|sdla_t
op_star
comma
id|netdevice_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|channel_disconnect
(paren
id|sdla_t
op_star
comma
id|netdevice_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|hdlc_link_down
(paren
id|sdla_t
op_star
)paren
suffix:semicolon
multiline_comment|/*=================================================&n; *     XPIPEMON Functions&n; */
r_static
r_int
id|process_udp_mgmt_pkt
c_func
(paren
id|sdla_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|udp_pkt_type
c_func
(paren
r_struct
id|sk_buff
op_star
comma
id|sdla_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|reply_udp
c_func
(paren
r_int
r_char
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|init_x25_channel_struct
c_func
(paren
id|x25_channel_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|init_global_statistics
c_func
(paren
id|sdla_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|store_udp_mgmt_pkt
c_func
(paren
r_int
comma
r_char
comma
id|sdla_t
op_star
comma
id|netdevice_t
op_star
comma
r_struct
id|sk_buff
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
r_int
id|calc_checksum
(paren
r_char
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*================================================= &n; *&t;IPX functions &n; */
r_static
r_void
id|switch_net_numbers
c_func
(paren
r_int
r_char
op_star
comma
r_int
r_int
comma
r_int
r_char
)paren
suffix:semicolon
r_static
r_int
id|handle_IPXWAN
c_func
(paren
r_int
r_char
op_star
comma
r_char
op_star
comma
r_int
r_char
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|disable_irq
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|enable_irq
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|S508_S514_lock
c_func
(paren
id|sdla_t
op_star
comma
r_int
r_int
op_star
)paren
suffix:semicolon
r_static
r_void
id|S508_S514_unlock
c_func
(paren
id|sdla_t
op_star
comma
r_int
r_int
op_star
)paren
suffix:semicolon
multiline_comment|/*=================================================  &n; * &t;Global Variables &n; *=================================================*/
multiline_comment|/*================================================= &n; *&t;Public Functions &n; *=================================================*/
multiline_comment|/*===================================================================&n; * wpx_init:&t;X.25 Protocol Initialization routine.&n; *&n; * Purpose:&t;To initialize the protocol/firmware.&n; * &n; * Rationale:&t;This function is called by setup() function, in&n; *              sdlamain.c, to dynamically setup the x25 protocol.&n; *&t;&t;This is the first protocol specific function, which&n; *              executes once on startup.&n; *                &n; * Description:&t;This procedure initializes the x25 firmware and&n; *    &t;&t;sets up the mailbox, transmit and receive buffer&n; *              pointers. It also initializes all debugging structures&n; *              and sets up the X25 environment.&n; *&n; *&t;&t;Sets up hardware options defined by user in [wanpipe#] &n; *&t;&t;section of wanpipe#.conf configuration file. &n; *&n; * &t;&t;At this point adapter is completely initialized &n; *      &t;and X.25 firmware is running.&n; *  &t;&t;o read firmware version (to make sure it&squot;s alive)&n; *  &t;&t;o configure adapter&n; *  &t;&t;o initialize protocol-specific fields of the &n; *                adapter data space.&n; *&n; * Called by:&t;setup() function in sdlamain.c&n; *&n; * Assumptions:&t;None&n; *&n; * Warnings:&t;None&n; *&n; * Return: &t;0&t;o.k.&n; *&t; &t;&lt; 0&t;failure.&n; */
DECL|function|wpx_init
r_int
id|wpx_init
(paren
id|sdla_t
op_star
id|card
comma
id|wandev_conf_t
op_star
id|conf
)paren
(brace
(def_block
r_union
(brace
r_char
id|str
(braket
l_int|80
)braket
suffix:semicolon
id|TX25Config
id|cfg
suffix:semicolon
)brace
)def_block
id|u
suffix:semicolon
multiline_comment|/* Verify configuration ID */
r_if
c_cond
(paren
id|conf-&gt;config_id
op_ne
id|WANCONFIG_X25
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: invalid configuration ID %u!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|conf-&gt;config_id
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Initialize protocol-specific fields */
id|card-&gt;mbox
op_assign
(paren
r_void
op_star
)paren
(paren
id|card-&gt;hw.dpmbase
op_plus
id|X25_MBOX_OFFS
)paren
suffix:semicolon
id|card-&gt;rxmb
op_assign
(paren
r_void
op_star
)paren
(paren
id|card-&gt;hw.dpmbase
op_plus
id|X25_RXMBOX_OFFS
)paren
suffix:semicolon
id|card-&gt;flags
op_assign
(paren
r_void
op_star
)paren
(paren
id|card-&gt;hw.dpmbase
op_plus
id|X25_STATUS_OFFS
)paren
suffix:semicolon
multiline_comment|/* Initialize for S514 Card */
r_if
c_cond
(paren
id|card-&gt;hw.type
op_eq
id|SDLA_S514
)paren
(brace
id|card-&gt;mbox
op_add_assign
id|X25_MB_VECTOR
suffix:semicolon
id|card-&gt;flags
op_add_assign
id|X25_MB_VECTOR
suffix:semicolon
id|card-&gt;rxmb
op_add_assign
id|X25_MB_VECTOR
suffix:semicolon
)brace
multiline_comment|/* Read firmware version.  Note that when adapter initializes, it&n;&t; * clears the mailbox, so it may appear that the first command was&n;&t; * executed successfully when in fact it was merely erased. To work&n;&t; * around this, we execute the first command twice.&n;&t; */
r_if
c_cond
(paren
id|x25_get_version
c_func
(paren
id|card
comma
l_int|NULL
)paren
op_logical_or
id|x25_get_version
c_func
(paren
id|card
comma
id|u.str
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* X25 firmware can run ether in X25 or LAPB HDLC mode.&n;         * Check the user defined option and configure accordingly */
r_if
c_cond
(paren
id|conf-&gt;u.x25.LAPB_hdlc_only
op_eq
id|WANOPT_YES
)paren
(brace
r_if
c_cond
(paren
id|set_hdlc_level
c_func
(paren
id|card
)paren
op_ne
id|CMD_OK
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: running LAP_B HDLC firmware v%s&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|u.str
)paren
suffix:semicolon
)brace
id|card-&gt;u.x.LAPB_hdlc
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: running X.25 firmware v%s&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|u.str
)paren
suffix:semicolon
id|card-&gt;u.x.LAPB_hdlc
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Configure adapter. Here we set resonable defaults, then parse&n;&t; * device configuration structure and set configuration options.&n;&t; * Most configuration options are verified and corrected (if&n;&t; * necessary) since we can&squot;t rely on the adapter to do so.&n;&t; */
id|memset
c_func
(paren
op_amp
id|u.cfg
comma
l_int|0
comma
r_sizeof
(paren
id|u.cfg
)paren
)paren
suffix:semicolon
id|u.cfg.t1
op_assign
l_int|3
suffix:semicolon
id|u.cfg.n2
op_assign
l_int|10
suffix:semicolon
id|u.cfg.autoHdlc
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* automatic HDLC connection */
id|u.cfg.hdlcWindow
op_assign
l_int|7
suffix:semicolon
id|u.cfg.pktWindow
op_assign
l_int|2
suffix:semicolon
id|u.cfg.station
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* DTE */
id|u.cfg.options
op_assign
l_int|0x0090
suffix:semicolon
multiline_comment|/* disable D-bit pragmatics */
id|u.cfg.ccittCompat
op_assign
l_int|1988
suffix:semicolon
id|u.cfg.t10t20
op_assign
l_int|30
suffix:semicolon
id|u.cfg.t11t21
op_assign
l_int|30
suffix:semicolon
id|u.cfg.t12t22
op_assign
l_int|30
suffix:semicolon
id|u.cfg.t13t23
op_assign
l_int|30
suffix:semicolon
id|u.cfg.t16t26
op_assign
l_int|30
suffix:semicolon
id|u.cfg.t28
op_assign
l_int|30
suffix:semicolon
id|u.cfg.r10r20
op_assign
l_int|5
suffix:semicolon
id|u.cfg.r12r22
op_assign
l_int|5
suffix:semicolon
id|u.cfg.r13r23
op_assign
l_int|5
suffix:semicolon
id|u.cfg.responseOpt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* RR&squot;s after every packet */
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
id|u.cfg.hdlcMTU
op_assign
l_int|1027
suffix:semicolon
)brace
r_if
c_cond
(paren
id|conf-&gt;u.x25.x25_conf_opt
)paren
(brace
id|u.cfg.options
op_assign
id|conf-&gt;u.x25.x25_conf_opt
suffix:semicolon
)brace
r_if
c_cond
(paren
id|conf-&gt;clocking
op_ne
id|WANOPT_EXTERNAL
)paren
id|u.cfg.baudRate
op_assign
id|bps_to_speed_code
c_func
(paren
id|conf-&gt;bps
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;station
op_ne
id|WANOPT_DTE
)paren
(brace
id|u.cfg.station
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* DCE mode */
)brace
r_if
c_cond
(paren
id|conf-&gt;interface
op_ne
id|WANOPT_RS232
)paren
(brace
id|u.cfg.hdlcOptions
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* V35 mode */
)brace
multiline_comment|/* adjust MTU */
r_if
c_cond
(paren
op_logical_neg
id|conf-&gt;mtu
op_logical_or
(paren
id|conf-&gt;mtu
op_ge
l_int|1024
)paren
)paren
id|card-&gt;wandev.mtu
op_assign
l_int|1024
suffix:semicolon
r_else
r_if
c_cond
(paren
id|conf-&gt;mtu
op_ge
l_int|512
)paren
id|card-&gt;wandev.mtu
op_assign
l_int|512
suffix:semicolon
r_else
r_if
c_cond
(paren
id|conf-&gt;mtu
op_ge
l_int|256
)paren
id|card-&gt;wandev.mtu
op_assign
l_int|256
suffix:semicolon
r_else
r_if
c_cond
(paren
id|conf-&gt;mtu
op_ge
l_int|128
)paren
id|card-&gt;wandev.mtu
op_assign
l_int|128
suffix:semicolon
r_else
id|card-&gt;wandev.mtu
op_assign
l_int|64
suffix:semicolon
id|u.cfg.defPktSize
op_assign
id|u.cfg.pktMTU
op_assign
id|card-&gt;wandev.mtu
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.hi_pvc
)paren
(brace
id|card-&gt;u.x.hi_pvc
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.hi_pvc
comma
id|MAX_LCN_NUM
)paren
suffix:semicolon
id|card-&gt;u.x.lo_pvc
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.lo_pvc
comma
id|card-&gt;u.x.hi_pvc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|conf-&gt;u.x25.hi_svc
)paren
(brace
id|card-&gt;u.x.hi_svc
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.hi_svc
comma
id|MAX_LCN_NUM
)paren
suffix:semicolon
id|card-&gt;u.x.lo_svc
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.lo_svc
comma
id|card-&gt;u.x.hi_svc
)paren
suffix:semicolon
)brace
multiline_comment|/* Figure out the total number of channels to configure */
id|card-&gt;u.x.num_of_ch
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.hi_svc
op_ne
l_int|0
)paren
(brace
id|card-&gt;u.x.num_of_ch
op_assign
(paren
id|card-&gt;u.x.hi_svc
op_minus
id|card-&gt;u.x.lo_svc
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;u.x.hi_pvc
op_ne
l_int|0
)paren
(brace
id|card-&gt;u.x.num_of_ch
op_add_assign
(paren
id|card-&gt;u.x.hi_pvc
op_minus
id|card-&gt;u.x.lo_pvc
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;u.x.num_of_ch
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: ERROR, Minimum number of PVC/SVC channels is 1 !&bslash;n&quot;
l_string|&quot;%s: Please set the Lowest/Highest PVC/SVC values !&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
op_minus
id|ECHRNG
suffix:semicolon
)brace
id|u.cfg.loPVC
op_assign
id|card-&gt;u.x.lo_pvc
suffix:semicolon
id|u.cfg.hiPVC
op_assign
id|card-&gt;u.x.hi_pvc
suffix:semicolon
id|u.cfg.loTwoWaySVC
op_assign
id|card-&gt;u.x.lo_svc
suffix:semicolon
id|u.cfg.hiTwoWaySVC
op_assign
id|card-&gt;u.x.hi_svc
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.hdlc_window
)paren
id|u.cfg.hdlcWindow
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.hdlc_window
comma
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.pkt_window
)paren
id|u.cfg.pktWindow
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.pkt_window
comma
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.t1
)paren
id|u.cfg.t1
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.t1
comma
l_int|30
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.t2
)paren
id|u.cfg.t2
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.t2
comma
l_int|29
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.t4
)paren
id|u.cfg.t4
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.t4
comma
l_int|240
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.n2
)paren
id|u.cfg.n2
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.n2
comma
l_int|30
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.t10_t20
)paren
id|u.cfg.t10t20
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.t10_t20
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.t11_t21
)paren
id|u.cfg.t11t21
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.t11_t21
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.t12_t22
)paren
id|u.cfg.t12t22
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.t12_t22
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.t13_t23
)paren
id|u.cfg.t13t23
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.t13_t23
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.t16_t26
)paren
id|u.cfg.t16t26
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.t16_t26
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.t28
)paren
id|u.cfg.t28
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.t28
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.r10_r20
)paren
id|u.cfg.r10r20
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.r10_r20
comma
l_int|250
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.r12_r22
)paren
id|u.cfg.r12r22
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.r12_r22
comma
l_int|250
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.r13_r23
)paren
id|u.cfg.r13r23
op_assign
id|min
c_func
(paren
id|conf-&gt;u.x25.r13_r23
comma
l_int|250
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;u.x25.ccitt_compat
)paren
id|u.cfg.ccittCompat
op_assign
id|conf-&gt;u.x25.ccitt_compat
suffix:semicolon
multiline_comment|/* initialize adapter */
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
r_if
c_cond
(paren
id|hdlc_configure
c_func
(paren
id|card
comma
op_amp
id|u.cfg
)paren
op_ne
id|CMD_OK
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|x25_configure
c_func
(paren
id|card
comma
op_amp
id|u.cfg
)paren
op_ne
id|CMD_OK
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|x25_close_hdlc
c_func
(paren
id|card
)paren
op_ne
id|CMD_OK
)paren
op_logical_or
multiline_comment|/* close HDLC link */
(paren
id|x25_set_dtr
c_func
(paren
id|card
comma
l_int|0
)paren
op_ne
id|CMD_OK
)paren
)paren
multiline_comment|/* drop DTR */
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Initialize protocol-specific fields of adapter data space */
id|card-&gt;wandev.bps
op_assign
id|conf-&gt;bps
suffix:semicolon
id|card-&gt;wandev.interface
op_assign
id|conf-&gt;interface
suffix:semicolon
id|card-&gt;wandev.clocking
op_assign
id|conf-&gt;clocking
suffix:semicolon
id|card-&gt;wandev.station
op_assign
id|conf-&gt;station
suffix:semicolon
id|card-&gt;isr
op_assign
op_amp
id|wpx_isr
suffix:semicolon
id|card-&gt;poll
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|//&amp;wpx_poll;
id|card-&gt;disable_comm
op_assign
op_amp
id|disable_comm
suffix:semicolon
id|card-&gt;exec
op_assign
op_amp
id|wpx_exec
suffix:semicolon
id|card-&gt;wandev.update
op_assign
op_amp
id|update
suffix:semicolon
id|card-&gt;wandev.new_if
op_assign
op_amp
id|new_if
suffix:semicolon
id|card-&gt;wandev.del_if
op_assign
op_amp
id|del_if
suffix:semicolon
multiline_comment|/* WARNING: This function cannot exit with an error&n;&t; *          after the change of state */
id|card-&gt;wandev.state
op_assign
id|WAN_DISCONNECTED
suffix:semicolon
id|card-&gt;wandev.enable_tx_int
op_assign
l_int|0
suffix:semicolon
id|card-&gt;irq_dis_if_send_count
op_assign
l_int|0
suffix:semicolon
id|card-&gt;irq_dis_poll_count
op_assign
l_int|0
suffix:semicolon
id|card-&gt;u.x.tx_dev
op_assign
l_int|NULL
suffix:semicolon
id|card-&gt;u.x.no_dev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Configure for S514 PCI Card */
r_if
c_cond
(paren
id|card-&gt;hw.type
op_eq
id|SDLA_S514
)paren
(brace
id|card-&gt;u.x.hdlc_buf_status
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|card-&gt;hw.dpmbase
op_plus
id|X25_MB_VECTOR
op_plus
id|X25_MISC_HDLC_BITS
)paren
suffix:semicolon
)brace
r_else
(brace
id|card-&gt;u.x.hdlc_buf_status
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|card-&gt;hw.dpmbase
op_plus
id|X25_MISC_HDLC_BITS
)paren
suffix:semicolon
)brace
id|card-&gt;u.x.poll_device
op_assign
l_int|NULL
suffix:semicolon
id|card-&gt;wandev.udp_port
op_assign
id|conf-&gt;udp_port
suffix:semicolon
multiline_comment|/* Enable or disable call setup logging */
r_if
c_cond
(paren
id|conf-&gt;u.x25.logging
op_eq
id|WANOPT_YES
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Enabling Call Logging.&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|card-&gt;u.x.logging
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|card-&gt;u.x.logging
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Enable or disable modem status reporting */
r_if
c_cond
(paren
id|conf-&gt;u.x25.oob_on_modem
op_eq
id|WANOPT_YES
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Enabling OOB on Modem change.&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|card-&gt;u.x.oob_on_modem
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|card-&gt;u.x.oob_on_modem
op_assign
l_int|0
suffix:semicolon
)brace
id|init_global_statistics
c_func
(paren
id|card
)paren
suffix:semicolon
macro_line|#ifndef LINUX_2_4
id|card-&gt;u.x.x25_poll_task.next
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|card-&gt;u.x.x25_poll_task.sync
op_assign
l_int|0
suffix:semicolon
id|card-&gt;u.x.x25_poll_task.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|wpx_poll
suffix:semicolon
id|card-&gt;u.x.x25_poll_task.data
op_assign
id|card
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|card-&gt;u.x.x25_timer
)paren
suffix:semicolon
id|card-&gt;u.x.x25_timer.data
op_assign
(paren
r_int
r_int
)paren
id|card
suffix:semicolon
id|card-&gt;u.x.x25_timer.function
op_assign
id|x25_timer_routine
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*=========================================================&n; *&t;WAN Device Driver Entry Points &n; *========================================================*/
multiline_comment|/*============================================================&n; * Name:&t;update(),  Update device status &amp; statistics.&n; *&n; * Purpose:&t;To provide debugging and statitical&n; *              information to the /proc file system.&n; *              /proc/net/wanrouter/wanpipe#&n; *              &t;&n; * Rationale:&t;The /proc file system is used to collect&n; *              information about the kernel and drivers.&n; *              Using the /proc file system the user&n; *              can see exactly what the sangoma drivers are&n; *              doing. And in what state they are in. &n; *                &n; * Description: Collect all driver statistical information&n; *              and pass it to the top laywer. &n; *&t;&t;&n; *&t;&t;Since we have to execute a debugging command, &n; *              to obtain firmware statitics, we trigger a &n; *              UPDATE function within the timer interrtup.&n; *              We wait until the timer update is complete.&n; *              Once complete return the appropriate return&n; *              code to indicate that the update was successful.&n; *              &n; * Called by:&t;device_stat() in wanmain.c&n; *&n; * Assumptions:&t;&n; *&n; * Warnings:&t;This function will degrade the performance&n; *              of the router, since it uses the mailbox. &n; *&n; * Return: &t;0 &t;OK&n; * &t;&t;&lt;0&t;Failed (or busy).&n; */
DECL|function|update
r_static
r_int
id|update
(paren
id|wan_device_t
op_star
id|wandev
)paren
(brace
r_volatile
id|sdla_t
op_star
id|card
suffix:semicolon
id|TX25Status
op_star
id|status
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/* sanity checks */
r_if
c_cond
(paren
(paren
id|wandev
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|wandev
op_member_access_from_pointer
r_private
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|wandev-&gt;state
op_eq
id|WAN_UNCONFIGURED
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SEND_CRIT
comma
(paren
r_void
op_star
)paren
op_amp
id|wandev-&gt;critical
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wandev-&gt;dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|card
op_assign
id|wandev
op_member_access_from_pointer
r_private
suffix:semicolon
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
id|card-&gt;u.x.timer_int_enabled
op_or_assign
id|TMR_INT_ENABLED_UPDATE
suffix:semicolon
id|status-&gt;imask
op_or_assign
id|INTR_ON_TIMER
suffix:semicolon
id|timeout
op_assign
id|jiffies
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|card-&gt;u.x.timer_int_enabled
op_amp
id|TMR_INT_ENABLED_UPDATE
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|timeout
)paren
OG
l_int|1
op_star
id|HZ
)paren
(brace
id|card-&gt;u.x.timer_int_enabled
op_and_assign
op_complement
id|TMR_INT_ENABLED_UPDATE
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n; * Name:&t;new_if&n; *&n; * Purpose:&t;To allocate and initialize resources for a &n; *              new logical channel.  &n; * &n; * Rationale:&t;A new channel can be added dynamically via&n; *              ioctl call.&n; *                &n; * Description:&t;Allocate a private channel structure, x25_channel_t.&n; *&t;&t;Parse the user interface options from wanpipe#.conf &n; *&t;&t;configuration file. &n; *&t;&t;Bind the private are into the network device private&n; *              area pointer (dev-&gt;priv).&n; *&t;&t;Prepare the network device structure for registration.&n; *&n; * Called by:&t;ROUTER_IFNEW Ioctl call, from wanrouter_ioctl() &n; *              (wanmain.c)&n; *&n; * Assumptions: None&n; *&n; * Warnings:&t;None&n; *&n; * Return: &t;0 &t;Ok&n; *&t;&t;&lt;0 &t;Failed (channel will not be created)&n; */
DECL|function|new_if
r_static
r_int
id|new_if
(paren
id|wan_device_t
op_star
id|wandev
comma
id|netdevice_t
op_star
id|dev
comma
id|wanif_conf_t
op_star
id|conf
)paren
(brace
id|sdla_t
op_star
id|card
op_assign
id|wandev
op_member_access_from_pointer
r_private
suffix:semicolon
id|x25_channel_t
op_star
id|chan
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|conf-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
op_logical_or
(paren
id|strlen
c_func
(paren
id|conf-&gt;name
)paren
OG
id|WAN_IFNAME_SZ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: invalid interface name!&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;wandev.new_if_cnt
op_increment
OG
l_int|0
op_logical_and
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Error: Running LAPB HDLC Mode !&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Maximum number of network interfaces must be one !&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
multiline_comment|/* allocate and initialize private data */
id|chan
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|x25_channel_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|chan
comma
l_int|0
comma
r_sizeof
(paren
id|x25_channel_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Bug Fix: Seg Err on PVC startup&n;&t; * It must be here since bind_lcn_to_dev expects &n;&t; * it bellow */
id|dev-&gt;priv
op_assign
id|chan
suffix:semicolon
id|strcpy
c_func
(paren
id|chan-&gt;name
comma
id|conf-&gt;name
)paren
suffix:semicolon
id|chan-&gt;card
op_assign
id|card
suffix:semicolon
id|chan-&gt;dev
op_assign
id|dev
suffix:semicolon
id|chan-&gt;common.sk
op_assign
l_int|NULL
suffix:semicolon
id|chan-&gt;common.func
op_assign
l_int|NULL
suffix:semicolon
id|chan-&gt;common.rw_bind
op_assign
l_int|0
suffix:semicolon
id|chan-&gt;tx_skb
op_assign
id|chan-&gt;rx_skb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* verify media address */
r_if
c_cond
(paren
id|conf-&gt;addr
(braket
l_int|0
)braket
op_eq
l_char|&squot;@&squot;
)paren
(brace
multiline_comment|/* SVC */
id|chan-&gt;common.svc
op_assign
l_int|1
suffix:semicolon
id|strncpy
c_func
(paren
id|chan-&gt;addr
comma
op_amp
id|conf-&gt;addr
(braket
l_int|1
)braket
comma
id|WAN_ADDRESS_SZ
)paren
suffix:semicolon
multiline_comment|/* Set channel timeouts (default if not specified) */
id|chan-&gt;idle_timeout
op_assign
(paren
id|conf-&gt;idle_timeout
)paren
ques
c_cond
id|conf-&gt;idle_timeout
suffix:colon
l_int|90
suffix:semicolon
id|chan-&gt;hold_timeout
op_assign
(paren
id|conf-&gt;hold_timeout
)paren
ques
c_cond
id|conf-&gt;hold_timeout
suffix:colon
l_int|10
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_digit
c_func
(paren
id|conf-&gt;addr
(braket
l_int|0
)braket
)paren
)paren
(brace
multiline_comment|/* PVC */
r_int
id|lcn
op_assign
id|dec_to_uint
c_func
(paren
id|conf-&gt;addr
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lcn
op_ge
id|card-&gt;u.x.lo_pvc
)paren
op_logical_and
(paren
id|lcn
op_le
id|card-&gt;u.x.hi_pvc
)paren
)paren
(brace
id|bind_lcn_to_dev
(paren
id|card
comma
id|dev
comma
id|lcn
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: PVC %u is out of range on interface %s!&bslash;n&quot;
comma
id|wandev-&gt;name
comma
id|lcn
comma
id|chan-&gt;name
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: invalid media address on interface %s!&bslash;n&quot;
comma
id|wandev-&gt;name
comma
id|chan-&gt;name
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|conf-&gt;usedby
comma
l_string|&quot;WANPIPE&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Running in WANPIPE mode %s&bslash;n&quot;
comma
id|wandev-&gt;name
comma
id|chan-&gt;name
)paren
suffix:semicolon
id|chan-&gt;common.usedby
op_assign
id|WANPIPE
suffix:semicolon
id|chan-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|conf-&gt;usedby
comma
l_string|&quot;API&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|chan-&gt;common.usedby
op_assign
id|API
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Running in API mode %s&bslash;n&quot;
comma
id|wandev-&gt;name
comma
id|chan-&gt;name
)paren
suffix:semicolon
id|chan-&gt;protocol
op_assign
id|htons
c_func
(paren
id|X25_PROT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
(brace
id|kfree
c_func
(paren
id|chan
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|chan-&gt;enable_IPX
op_assign
id|conf-&gt;enable_IPX
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;enable_IPX
)paren
id|chan-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IPX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|conf-&gt;network_number
)paren
id|chan-&gt;network_number
op_assign
id|conf-&gt;network_number
suffix:semicolon
r_else
id|chan-&gt;network_number
op_assign
l_int|0xDEADBEEF
suffix:semicolon
multiline_comment|/* prepare network device data space for registration */
macro_line|#ifdef LINUX_2_4
id|strcpy
c_func
(paren
id|dev-&gt;name
comma
id|chan-&gt;name
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;name
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|chan-&gt;name
)paren
op_plus
l_int|2
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;name
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|chan
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;%s&quot;
comma
id|chan-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|dev-&gt;init
op_assign
op_amp
id|if_init
suffix:semicolon
id|init_x25_channel_struct
c_func
(paren
id|chan
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n; * Name:&t;del_if(),  Remove a logical channel.&t; &n; *&n; * Purpose:&t;To dynamically remove a logical channel.&n; * &n; * Rationale:&t;Each logical channel should be dynamically&n; *              removable. This functin is called by an &n; *              IOCTL_IFDEL ioctl call or shutdown(). &n; *                &n; * Description: Do nothing.&n; *&n; * Called by:&t;IOCTL_IFDEL : wanrouter_ioctl() from wanmain.c&n; *              shutdown() from sdlamain.c&n; *&n; * Assumptions: &n; *&n; * Warnings:&n; *&n; * Return: &t;0 Ok. Void function.&n; */
singleline_comment|//FIXME Del IF Should be taken out now.
DECL|function|del_if
r_static
r_int
id|del_if
(paren
id|wan_device_t
op_star
id|wandev
comma
id|netdevice_t
op_star
id|dev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * Name:&t;wpx_exec&n; *&n; * Description:&t;Execute adapter interface command.&n; * &t;&t;This option is currently dissabled.&n; *===========================================================*/
DECL|function|wpx_exec
r_static
r_int
id|wpx_exec
(paren
r_struct
id|sdla
op_star
id|card
comma
r_void
op_star
id|u_cmd
comma
r_void
op_star
id|u_data
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; * Name:&t;disable_comm&t;&n; *&n; * Description:&t;Disable communications during shutdown.&n; *              Dont check return code because there is &n; *              nothing we can do about it.  &n; *&n; * Warning:&t;Dev and private areas are gone at this point.&n; *===========================================================*/
DECL|function|disable_comm
r_static
r_void
id|disable_comm
c_func
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|disable_comm_shutdown
c_func
(paren
id|card
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|card-&gt;u.x.x25_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*============================================================&n; *&t;Network Device Interface &n; *===========================================================*/
multiline_comment|/*===================================================================&n; * Name:&t;if_init(),   Netowrk Interface Initialization &t; &n; *&n; * Purpose:&t;To initialize a network interface device structure.&n; * &n; * Rationale:&t;During network interface startup, the if_init&n; *              is called by the kernel to initialize the&n; *              netowrk device structure.  Thus a driver&n; *              can customze a network device. &n; *                &n; * Description:&t;Initialize the netowrk device call back&n; *              routines.  This is where we tell the kernel&n; *              which function to use when it wants to send&n; *              via our interface. &n; *&t;&t;Furthermore, we initialize the device flags, &n; *              MTU and physical address of the board.&n; *&n; * Called by:&t;Kernel (/usr/src/linux/net/core/dev.c)&n; * &t;&t;(dev-&gt;init())&n; *&n; * Assumptions: None&n; *&t;&n; * Warnings:&t;None&n; *&n; * Return: &t;0 &t;Ok : Void function.&n; */
DECL|function|if_init
r_static
r_int
id|if_init
(paren
id|netdevice_t
op_star
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
id|wan_device_t
op_star
id|wandev
op_assign
op_amp
id|card-&gt;wandev
suffix:semicolon
macro_line|#ifdef LINUX_2_0
r_int
id|i
suffix:semicolon
macro_line|#endif
multiline_comment|/* Initialize device driver entry points */
id|dev-&gt;open
op_assign
op_amp
id|if_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|if_close
suffix:semicolon
id|dev-&gt;hard_header
op_assign
op_amp
id|if_header
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
op_amp
id|if_rebuild_hdr
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|if_send
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|if_stats
suffix:semicolon
macro_line|#ifdef LINUX_2_4
id|dev-&gt;tx_timeout
op_assign
op_amp
id|if_tx_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
macro_line|#endif
multiline_comment|/* Initialize media-specific parameters */
macro_line|#if defined(LINUX_2_1) || defined(LINUX_2_4)
id|dev-&gt;type
op_assign
id|ARPHRD_PPP
suffix:semicolon
multiline_comment|/* ARP h/w type */
macro_line|#else
id|dev-&gt;family
op_assign
id|AF_INET
suffix:semicolon
multiline_comment|/* address family */
id|dev-&gt;type
op_assign
id|ARPHRD_PPP
suffix:semicolon
multiline_comment|/* no x25 type */
macro_line|#endif
id|dev-&gt;flags
op_or_assign
id|IFF_POINTOPOINT
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_NOARP
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
id|dev-&gt;mtu
op_assign
id|X25_CHAN_MTU
op_plus
r_sizeof
(paren
id|x25api_hdr_t
)paren
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;mtu
op_assign
id|card-&gt;wandev.mtu
suffix:semicolon
)brace
id|dev-&gt;hard_header_len
op_assign
id|X25_HRDHDR_SZ
suffix:semicolon
multiline_comment|/* media header length */
id|dev-&gt;addr_len
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* hardware address length */
r_if
c_cond
(paren
op_logical_neg
id|chan-&gt;common.svc
)paren
(brace
op_star
(paren
r_int
r_int
op_star
)paren
id|dev-&gt;dev_addr
op_assign
id|htons
c_func
(paren
id|chan-&gt;common.lcn
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize hardware parameters (just for reference) */
id|dev-&gt;irq
op_assign
id|wandev-&gt;irq
suffix:semicolon
id|dev-&gt;dma
op_assign
id|wandev-&gt;dma
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|wandev-&gt;ioport
suffix:semicolon
id|dev-&gt;mem_start
op_assign
(paren
r_int
r_int
)paren
id|wandev-&gt;maddr
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|wandev-&gt;maddr
op_plus
id|wandev-&gt;msize
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Set transmit buffer queue length */
id|dev-&gt;tx_queue_len
op_assign
l_int|100
suffix:semicolon
multiline_comment|/* Initialize socket buffers */
macro_line|#if !defined(LINUX_2_1) &amp;&amp; !defined(LINUX_2_4)
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
op_increment
id|i
)paren
id|skb_queue_head_init
c_func
(paren
op_amp
id|dev-&gt;buffs
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* FIXME Why are we doing this */
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_DISCONNECTED
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n; * Name:&t;if_open(),   Open/Bring up the Netowrk Interface &n; *&n; * Purpose:&t;To bring up a network interface.&n; * &n; * Rationale:&t;&n; *                &n; * Description:&t;Open network interface.&n; * &t;&t;o prevent module from unloading by incrementing use count&n; * &t;&t;o if link is disconnected then initiate connection&n; *&n; * Called by:&t;Kernel (/usr/src/linux/net/core/dev.c)&n; * &t;&t;(dev-&gt;open())&n; *&n; * Assumptions: None&n; *&t;&n; * Warnings:&t;None&n; *&n; * Return: &t;0 &t;Ok&n; * &t;&t;&lt;0 &t;Failur: Interface will not come up.&n; */
DECL|function|if_open
r_static
r_int
id|if_open
(paren
id|netdevice_t
op_star
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
r_struct
id|timeval
id|tv
suffix:semicolon
r_int
r_int
id|smp_flags
suffix:semicolon
r_if
c_cond
(paren
id|is_dev_running
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|chan-&gt;tq_working
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the task queue */
macro_line|#ifndef LINUX_2_4
id|chan-&gt;common.wanpipe_task.next
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|chan-&gt;common.wanpipe_task.sync
op_assign
l_int|0
suffix:semicolon
id|chan-&gt;common.wanpipe_task.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|x25api_bh
suffix:semicolon
id|chan-&gt;common.wanpipe_task.data
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Allocate and initialize BH circular buffer */
multiline_comment|/* Add 1 to MAX_BH_BUFF so we don&squot;t have test with (MAX_BH_BUFF-1) */
id|chan-&gt;bh_head
op_assign
id|kmalloc
c_func
(paren
(paren
r_sizeof
(paren
id|bh_data_t
)paren
op_star
(paren
id|MAX_BH_BUFF
op_plus
l_int|1
)paren
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;bh_head
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: ERROR, failed to allocate memory ! BH_BUFFERS !&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|memset
c_func
(paren
id|chan-&gt;bh_head
comma
l_int|0
comma
(paren
r_sizeof
(paren
id|bh_data_t
)paren
op_star
(paren
id|MAX_BH_BUFF
op_plus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;bh_buff_used
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Increment the number of interfaces */
op_increment
id|card-&gt;u.x.no_dev
suffix:semicolon
id|wanpipe_open
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* LAPB protocol only uses one interface, thus&n;&t; * start the protocol after it comes up. */
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;open_cnt
op_eq
l_int|1
)paren
(brace
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
id|S508_S514_lock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
id|x25_set_intr_mode
c_func
(paren
id|card
comma
id|INTR_ON_TIMER
)paren
suffix:semicolon
id|status-&gt;imask
op_and_assign
op_complement
id|INTR_ON_TIMER
suffix:semicolon
id|S508_S514_unlock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* X25 can have multiple interfaces thus, start the &n;&t;&t; * protocol once all interfaces are up */
singleline_comment|//FIXME: There is a bug here. If interface is
singleline_comment|//brought down and up, it will try to enable comm.
r_if
c_cond
(paren
id|card-&gt;open_cnt
op_eq
id|card-&gt;u.x.num_of_ch
)paren
(brace
id|S508_S514_lock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
id|connect
c_func
(paren
id|card
)paren
suffix:semicolon
id|S508_S514_unlock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|card-&gt;u.x.x25_timer
)paren
suffix:semicolon
id|card-&gt;u.x.x25_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|card-&gt;u.x.x25_timer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Device is not up untill the we are in connected state */
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|chan-&gt;router_start_time
op_assign
id|tv.tv_sec
suffix:semicolon
macro_line|#ifdef LINUX_2_4
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else&t;
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n; * Name:&t;if_close(),   Close/Bring down the Netowrk Interface &n; *&n; * Purpose:&t;To bring down a network interface.&n; * &n; * Rationale:&t;&n; *                &n; * Description:&t;Close network interface.&n; * &t;&t;o decrement use module use count&n; *&n; * Called by:&t;Kernel (/usr/src/linux/net/core/dev.c)&n; * &t;&t;(dev-&gt;close())&n; *&t;&t;ifconfig &lt;name&gt; down: will trigger the kernel&n; *              which will call this function.&n; *&n; * Assumptions: None&n; *&t;&n; * Warnings:&t;None&n; *&n; * Return: &t;0 &t;Ok&n; * &t;&t;&lt;0 &t;Failure: Interface will not exit properly.&n; */
DECL|function|if_close
r_static
r_int
id|if_close
(paren
id|netdevice_t
op_star
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
r_int
r_int
id|smp_flags
suffix:semicolon
id|stop_net_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifndef LINUX_2_4
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|chan-&gt;common.state
op_eq
id|WAN_CONNECTED
)paren
op_logical_or
(paren
id|chan-&gt;common.state
op_eq
id|WAN_CONNECTING
)paren
)paren
(brace
id|S508_S514_lock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
id|chan_disc
c_func
(paren
id|dev
)paren
suffix:semicolon
id|S508_S514_unlock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
)brace
id|wanpipe_close
c_func
(paren
id|card
)paren
suffix:semicolon
id|S508_S514_lock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;bh_head
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|MAX_BH_BUFF
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|skb
op_assign
(paren
(paren
id|bh_data_t
op_star
)paren
op_amp
id|chan-&gt;bh_head
(braket
id|i
)braket
)paren
op_member_access_from_pointer
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|wan_dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|chan-&gt;bh_head
)paren
suffix:semicolon
id|chan-&gt;bh_head
op_assign
l_int|NULL
suffix:semicolon
)brace
id|S508_S514_unlock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
multiline_comment|/* If this is the last close, disconnect physical link */
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;open_cnt
)paren
(brace
id|S508_S514_lock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
id|disconnect
c_func
(paren
id|card
)paren
suffix:semicolon
id|x25_set_intr_mode
c_func
(paren
id|card
comma
l_int|0
)paren
suffix:semicolon
id|S508_S514_unlock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Decrement the number of interfaces */
op_decrement
id|card-&gt;u.x.no_dev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n; * &t;Build media header.&n; * &t;o encapsulate packet according to encapsulation type.&n; *&n; * &t;The trick here is to put packet type (Ethertype) into &squot;protocol&squot; &n; *      field of the socket buffer, so that we don&squot;t forget it.  &n; *      If encapsulation fails, set skb-&gt;protocol to 0 and discard &n; *      packet later.&n; *&n; * &t;Return:&t;&t;media header length.&n; *======================================================================*/
DECL|function|if_header
r_static
r_int
id|if_header
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|netdevice_t
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|hdr_len
op_assign
id|dev-&gt;hard_header_len
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan-&gt;protocol
)paren
(brace
id|hdr_len
op_assign
id|wanrouter_encapsulate
c_func
(paren
id|skb
comma
id|dev
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdr_len
OL
l_int|0
)paren
(brace
id|hdr_len
op_assign
l_int|0
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
id|hdr_len
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * &t;Re-build media header.&n; *&n; * &t;Return:&t;&t;1&t;physical address resolved.&n; *&t;&t;&t;0&t;physical address not resolved&n; *==============================================================*/
DECL|function|if_rebuild_hdr
r_static
r_int
id|if_rebuild_hdr
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|netdevice_t
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: rebuild_header() called for interface %s!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef LINUX_2_4
multiline_comment|/*============================================================================&n; * Handle transmit timeout event from netif watchdog&n; */
DECL|function|if_tx_timeout
r_static
r_void
id|if_tx_timeout
(paren
id|netdevice_t
op_star
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
multiline_comment|/* If our device stays busy for at least 5 seconds then we will&n;&t; * kick start the device by making dev-&gt;tbusy = 0.  We expect&n;&t; * that our device never stays busy more than 5 seconds. So this                 &n;&t; * is only used as a last resort.&n;&t; */
op_increment
id|chan-&gt;if_send_stat.if_send_tbusy_timeout
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: Transmit timed out on %s&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*=========================================================================&n; * &t;Send a packet on a network interface.&n; * &t;o set tbusy flag (marks start of the transmission).&n; * &t;o check link state. If link is not up, then drop the packet.&n; * &t;o check channel status. If it&squot;s down then initiate a call.&n; * &t;o pass a packet to corresponding WAN device.&n; * &t;o free socket buffer&n; *&n; * &t;Return:&t;0&t;complete (socket buffer must be freed)&n; *&t;&t;non-0&t;packet may be re-transmitted (tbusy must be set)&n; *&n; * &t;Notes:&n; * &t;1. This routine is called either by the protocol stack or by the &quot;net&n; *    &t;bottom half&quot; (with interrupts enabled).&n; * &t;2. Setting tbusy flag will inhibit further transmit requests from the&n; *    &t;protocol stack and can be used for flow control with protocol layer.&n; *&n; *========================================================================*/
DECL|function|if_send
r_static
r_int
id|if_send
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|netdevice_t
op_star
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
r_int
id|udp_type
suffix:semicolon
r_int
r_int
id|smp_flags
op_assign
l_int|0
suffix:semicolon
op_increment
id|chan-&gt;if_send_stat.if_send_entry
suffix:semicolon
macro_line|#ifdef LINUX_2_4
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* No need to check frame length, since socket code&n;         * will perform the check for us */
macro_line|#ifndef LINUX_2_4
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
id|netdevice_t
op_star
id|dev2
suffix:semicolon
op_increment
id|chan-&gt;if_send_stat.if_send_tbusy
suffix:semicolon
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|chan-&gt;tick_counter
)paren
OL
(paren
l_int|5
op_star
id|HZ
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Transmit time out %s!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev2
op_assign
id|card-&gt;wandev.dev
suffix:semicolon
id|dev2
suffix:semicolon
id|dev2
op_assign
op_star
(paren
(paren
id|netdevice_t
op_star
op_star
)paren
id|dev2-&gt;priv
)paren
)paren
(brace
id|dev2-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
)brace
op_increment
id|chan-&gt;if_send_stat.if_send_tbusy_timeout
suffix:semicolon
)brace
macro_line|#endif
id|chan-&gt;tick_counter
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Critical region starts here */
id|S508_S514_lock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|SEND_CRIT
comma
(paren
r_void
op_star
)paren
op_amp
id|card-&gt;wandev.critical
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Hit critical in if_send()! %lx&bslash;n&quot;
comma
id|card-&gt;wandev.critical
)paren
suffix:semicolon
r_goto
id|if_send_crit_exit
suffix:semicolon
)brace
id|udp_type
op_assign
id|udp_pkt_type
c_func
(paren
id|skb
comma
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udp_type
op_ne
id|UDP_INVALID_TYPE
)paren
(brace
r_if
c_cond
(paren
id|store_udp_mgmt_pkt
c_func
(paren
id|udp_type
comma
id|UDP_PKT_FRM_STACK
comma
id|card
comma
id|dev
comma
id|skb
comma
id|chan-&gt;common.lcn
)paren
)paren
(brace
id|status-&gt;imask
op_or_assign
id|INTR_ON_TIMER
suffix:semicolon
r_if
c_cond
(paren
id|udp_type
op_eq
id|UDP_XPIPE_TYPE
)paren
(brace
id|chan-&gt;if_send_stat.if_send_PIPE_request
op_increment
suffix:semicolon
)brace
)brace
id|start_net_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|SEND_CRIT
comma
(paren
r_void
op_star
)paren
op_amp
id|card-&gt;wandev.critical
)paren
suffix:semicolon
id|S508_S514_unlock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chan-&gt;transmit_length
)paren
(brace
singleline_comment|//FIXME: This check doesn&squot;t make sense any more
r_if
c_cond
(paren
id|chan-&gt;common.state
op_ne
id|WAN_CONNECTED
)paren
(brace
id|chan-&gt;transmit_length
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.driver_busy
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|stop_net_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
op_increment
id|card-&gt;u.x.tx_interrupts_pending
suffix:semicolon
id|status-&gt;imask
op_or_assign
id|INTR_ON_TX_FRAME
suffix:semicolon
id|clear_bit
c_func
(paren
id|SEND_CRIT
comma
(paren
r_void
op_star
)paren
op_amp
id|card-&gt;wandev.critical
)paren
suffix:semicolon
id|S508_S514_unlock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|card-&gt;wandev.state
op_ne
id|WAN_CONNECTED
)paren
(brace
op_increment
id|chan-&gt;ifstats.tx_dropped
suffix:semicolon
op_increment
id|card-&gt;wandev.stats.tx_dropped
suffix:semicolon
op_increment
id|chan-&gt;if_send_stat.if_send_wan_disconnected
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|chan-&gt;protocol
op_logical_and
(paren
id|chan-&gt;protocol
op_ne
id|skb-&gt;protocol
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: unsupported Ethertype 0x%04X on interface %s!&bslash;n&quot;
comma
id|chan-&gt;name
comma
id|htons
c_func
(paren
id|skb-&gt;protocol
)paren
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PROTO %Xn&quot;
comma
id|htons
c_func
(paren
id|chan-&gt;protocol
)paren
)paren
suffix:semicolon
op_increment
id|chan-&gt;ifstats.tx_errors
suffix:semicolon
op_increment
id|chan-&gt;ifstats.tx_dropped
suffix:semicolon
op_increment
id|card-&gt;wandev.stats.tx_dropped
suffix:semicolon
op_increment
id|chan-&gt;if_send_stat.if_send_protocol_error
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|chan-&gt;common.state
)paren
(brace
r_case
id|WAN_DISCONNECTED
suffix:colon
multiline_comment|/* Try to establish connection. If succeded, then start&n;&t;&t;&t; * transmission, else drop a packet.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
op_increment
id|chan-&gt;ifstats.tx_dropped
suffix:semicolon
op_increment
id|card-&gt;wandev.stats.tx_dropped
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|chan_connect
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
(brace
op_increment
id|chan-&gt;ifstats.tx_dropped
suffix:semicolon
op_increment
id|card-&gt;wandev.stats.tx_dropped
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* fall through */
r_case
id|WAN_CONNECTED
suffix:colon
r_if
c_cond
(paren
id|skb-&gt;protocol
op_eq
id|htons
c_func
(paren
id|ETH_P_IPX
)paren
)paren
(brace
r_if
c_cond
(paren
id|chan-&gt;enable_IPX
)paren
(brace
id|switch_net_numbers
c_func
(paren
id|skb-&gt;data
comma
id|chan-&gt;network_number
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
op_increment
id|card-&gt;wandev.stats.tx_dropped
suffix:semicolon
op_increment
id|chan-&gt;ifstats.tx_dropped
suffix:semicolon
op_increment
id|chan-&gt;if_send_stat.if_send_protocol_error
suffix:semicolon
r_goto
id|if_send_crit_exit
suffix:semicolon
)brace
)brace
multiline_comment|/* We never drop here, if cannot send than, copy&n;&t;                 * a packet into a transmit buffer &n;                         */
id|chan_send
c_func
(paren
id|dev
comma
id|skb-&gt;data
comma
id|skb-&gt;len
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_increment
id|chan-&gt;ifstats.tx_dropped
suffix:semicolon
op_increment
id|card-&gt;wandev.stats.tx_dropped
suffix:semicolon
r_break
suffix:semicolon
)brace
id|if_send_crit_exit
suffix:colon
id|wan_dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|start_net_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|SEND_CRIT
comma
(paren
r_void
op_star
)paren
op_amp
id|card-&gt;wandev.critical
)paren
suffix:semicolon
id|S508_S514_unlock
c_func
(paren
id|card
comma
op_amp
id|smp_flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Setup so that a frame can be transmitted on the occurence of a transmit&n; * interrupt.&n; *===========================================================================*/
DECL|function|setup_for_delayed_transmit
r_static
r_void
id|setup_for_delayed_transmit
(paren
id|netdevice_t
op_star
id|dev
comma
r_void
op_star
id|buf
comma
r_int
id|len
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
op_increment
id|chan-&gt;if_send_stat.if_send_adptr_bfrs_full
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;transmit_length
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Error, transmit length set in delayed transmit!&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
r_if
c_cond
(paren
id|len
OG
id|X25_CHAN_MTU
op_plus
r_sizeof
(paren
id|x25api_hdr_t
)paren
)paren
(brace
op_increment
id|chan-&gt;ifstats.tx_dropped
suffix:semicolon
op_increment
id|card-&gt;wandev.stats.tx_dropped
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Length is too big for delayed transmit&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|len
OG
id|X25_MAX_DATA
)paren
(brace
op_increment
id|chan-&gt;ifstats.tx_dropped
suffix:semicolon
op_increment
id|card-&gt;wandev.stats.tx_dropped
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Length is too big for delayed transmit&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|chan-&gt;transmit_length
op_assign
id|len
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.driver_busy
comma
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|chan-&gt;transmit_buffer
comma
id|buf
comma
id|len
)paren
suffix:semicolon
op_increment
id|chan-&gt;if_send_stat.if_send_tx_int_enabled
suffix:semicolon
multiline_comment|/* Enable Transmit Interrupt */
op_increment
id|card-&gt;u.x.tx_interrupts_pending
suffix:semicolon
id|status-&gt;imask
op_or_assign
id|INTR_ON_TX_FRAME
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * net_device_stats&n; *&n; * &t;Get ethernet-style interface statistics.&n; * &t;Return a pointer to struct enet_statistics.&n; *&n; *==============================================================*/
DECL|function|if_stats
r_static
r_struct
id|net_device_stats
op_star
id|if_stats
(paren
id|netdevice_t
op_star
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|chan
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
op_amp
id|chan-&gt;ifstats
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Interrupt Handlers &n; */
multiline_comment|/*&n; * X.25 Interrupt Service Routine.&n; */
DECL|function|wpx_isr
r_static
r_void
id|wpx_isr
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
id|card-&gt;in_isr
op_assign
l_int|1
suffix:semicolon
op_increment
id|card-&gt;statistics.isr_entry
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|PERI_CRIT
comma
(paren
r_void
op_star
)paren
op_amp
id|card-&gt;wandev.critical
)paren
)paren
(brace
id|card-&gt;in_isr
op_assign
l_int|0
suffix:semicolon
id|status-&gt;iflags
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SEND_CRIT
comma
(paren
r_void
op_star
)paren
op_amp
id|card-&gt;wandev.critical
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: wpx_isr: wandev.critical set to 0x%02lx, int type = 0x%02x&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|card-&gt;wandev.critical
comma
id|status-&gt;iflags
)paren
suffix:semicolon
id|card-&gt;in_isr
op_assign
l_int|0
suffix:semicolon
id|status-&gt;iflags
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* For all interrupts set the critical flag to CRITICAL_RX_INTR.&n;         * If the if_send routine is called with this flag set it will set&n;         * the enable transmit flag to 1. (for a delayed interrupt)&n;         */
r_switch
c_cond
(paren
id|status-&gt;iflags
)paren
(brace
r_case
id|RX_INTR_PENDING
suffix:colon
multiline_comment|/* receive interrupt */
id|rx_intr
c_func
(paren
id|card
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TX_INTR_PENDING
suffix:colon
multiline_comment|/* transmit interrupt */
id|tx_intr
c_func
(paren
id|card
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODEM_INTR_PENDING
suffix:colon
multiline_comment|/* modem status interrupt */
id|status_intr
c_func
(paren
id|card
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|X25_ASY_TRANS_INTR_PENDING
suffix:colon
multiline_comment|/* network event interrupt */
id|event_intr
c_func
(paren
id|card
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIMER_INTR_PENDING
suffix:colon
id|timer_intr
c_func
(paren
id|card
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* unwanted interrupt */
id|spur_intr
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
id|card-&gt;in_isr
op_assign
l_int|0
suffix:semicolon
id|status-&gt;iflags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear interrupt condition */
)brace
multiline_comment|/*&n; * &t;Receive interrupt handler.&n; * &t;This routine handles fragmented IP packets using M-bit according to the&n; * &t;RFC1356.&n; * &t;o map ligical channel number to network interface.&n; * &t;o allocate socket buffer or append received packet to the existing one.&n; * &t;o if M-bit is reset (i.e. it&squot;s the last packet in a sequence) then &n; *   &t;decapsulate packet and pass socket buffer to the protocol stack.&n; *&n; * &t;Notes:&n; * &t;1. When allocating a socket buffer, if M-bit is set then more data is&n; *    &t;coming and we have to allocate buffer for the maximum IP packet size&n; *    &t;expected on this channel.&n; * &t;2. If something goes wrong and X.25 packet has to be dropped (e.g. no&n; *    &t;socket buffers available) the whole packet sequence must be discarded.&n; */
DECL|function|rx_intr
r_static
r_void
id|rx_intr
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Mbox
op_star
id|rxmb
op_assign
id|card-&gt;rxmb
suffix:semicolon
r_int
id|lcn
op_assign
id|rxmb-&gt;cmd.lcn
suffix:semicolon
id|netdevice_t
op_star
id|dev
op_assign
id|find_channel
c_func
(paren
id|card
comma
id|lcn
)paren
suffix:semicolon
id|x25_channel_t
op_star
id|chan
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Invalid channel, discard packet */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: receiving on orphaned LCN %d!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|lcn
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|chan-&gt;i_timeout_sofar
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Copy the data from the board, into an&n;         * skb buffer &n;&t; */
r_if
c_cond
(paren
id|wanpipe_pull_data_in_skb
c_func
(paren
id|card
comma
id|dev
comma
op_amp
id|skb
)paren
)paren
(brace
op_increment
id|chan-&gt;ifstats.rx_dropped
suffix:semicolon
op_increment
id|card-&gt;wandev.stats.rx_dropped
suffix:semicolon
op_increment
id|chan-&gt;rx_intr_stat.rx_intr_no_socket
suffix:semicolon
op_increment
id|chan-&gt;rx_intr_stat.rx_intr_bfr_not_passed_to_stack
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* timestamp */
multiline_comment|/* ------------ API ----------------*/
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
r_if
c_cond
(paren
id|bh_enqueue
c_func
(paren
id|dev
comma
id|skb
)paren
)paren
(brace
op_increment
id|chan-&gt;ifstats.rx_dropped
suffix:semicolon
op_increment
id|card-&gt;wandev.stats.rx_dropped
suffix:semicolon
op_increment
id|chan-&gt;rx_intr_stat.rx_intr_bfr_not_passed_to_stack
suffix:semicolon
id|wan_dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
op_increment
id|chan-&gt;ifstats.rx_packets
suffix:semicolon
macro_line|#if defined(LINUX_2_1) || defined(LINUX_2_4)
id|chan-&gt;ifstats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
macro_line|#endif
id|chan-&gt;rx_skb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|chan-&gt;tq_working
)paren
)paren
(brace
id|wanpipe_queue_tq
c_func
(paren
op_amp
id|chan-&gt;common.wanpipe_task
)paren
suffix:semicolon
id|wanpipe_mark_bh
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* ------------- WANPIPE -------------------*/
multiline_comment|/* set rx_skb to NULL so we won&squot;t access it later when kernel already owns it */
id|chan-&gt;rx_skb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Decapsulate packet, if necessary */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;protocol
op_logical_and
op_logical_neg
id|wanrouter_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
)paren
(brace
multiline_comment|/* can&squot;t decapsulate packet */
id|wan_dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
op_increment
id|chan-&gt;ifstats.rx_errors
suffix:semicolon
op_increment
id|chan-&gt;ifstats.rx_dropped
suffix:semicolon
op_increment
id|card-&gt;wandev.stats.rx_dropped
suffix:semicolon
op_increment
id|chan-&gt;rx_intr_stat.rx_intr_bfr_not_passed_to_stack
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|handle_IPXWAN
c_func
(paren
id|skb-&gt;data
comma
id|chan-&gt;name
comma
id|chan-&gt;enable_IPX
comma
id|chan-&gt;network_number
comma
id|skb-&gt;protocol
)paren
)paren
(brace
r_if
c_cond
(paren
id|chan-&gt;enable_IPX
)paren
(brace
r_if
c_cond
(paren
id|chan_send
c_func
(paren
id|dev
comma
id|skb-&gt;data
comma
id|skb-&gt;len
comma
l_int|0
)paren
)paren
(brace
id|chan-&gt;tx_skb
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|wan_dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
op_increment
id|chan-&gt;rx_intr_stat.rx_intr_bfr_not_passed_to_stack
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* increment IPX packet dropped statistic */
op_increment
id|chan-&gt;ifstats.rx_dropped
suffix:semicolon
op_increment
id|chan-&gt;rx_intr_stat.rx_intr_bfr_not_passed_to_stack
suffix:semicolon
)brace
)brace
r_else
(brace
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
macro_line|#if defined(LINUX_2_1) || defined(LINUX_2_4)
id|chan-&gt;ifstats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
macro_line|#endif
op_increment
id|chan-&gt;ifstats.rx_packets
suffix:semicolon
op_increment
id|chan-&gt;rx_intr_stat.rx_intr_bfr_passed_to_stack
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
DECL|function|wanpipe_pull_data_in_skb
r_static
r_int
id|wanpipe_pull_data_in_skb
(paren
id|sdla_t
op_star
id|card
comma
id|netdevice_t
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
op_star
id|skb
)paren
(brace
r_void
op_star
id|bufptr
suffix:semicolon
id|TX25Mbox
op_star
id|rxmb
op_assign
id|card-&gt;rxmb
suffix:semicolon
r_int
id|len
op_assign
id|rxmb-&gt;cmd.length
suffix:semicolon
multiline_comment|/* packet length */
r_int
id|qdm
op_assign
id|rxmb-&gt;cmd.qdm
suffix:semicolon
multiline_comment|/* Q,D and M bits */
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|new_skb
op_assign
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|WANPIPE
)paren
(brace
r_if
c_cond
(paren
id|chan-&gt;drop_sequence
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|qdm
op_amp
l_int|0x01
)paren
)paren
(brace
id|chan-&gt;drop_sequence
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|new_skb
op_assign
id|chan-&gt;rx_skb
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Add on the API header to the received&n;                 * data &n;&t;&t; */
id|len
op_add_assign
r_sizeof
(paren
id|x25api_hdr_t
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_skb
op_eq
l_int|NULL
)paren
(brace
r_int
id|bufsize
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|WANPIPE
)paren
(brace
id|bufsize
op_assign
(paren
id|qdm
op_amp
l_int|0x01
)paren
ques
c_cond
id|dev-&gt;mtu
suffix:colon
id|len
suffix:semicolon
)brace
r_else
(brace
id|bufsize
op_assign
id|len
suffix:semicolon
)brace
multiline_comment|/* Allocate new socket buffer */
id|new_skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|bufsize
op_plus
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: no socket buffers available!&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|chan-&gt;drop_sequence
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* set flag */
op_increment
id|chan-&gt;ifstats.rx_dropped
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|skb_tailroom
c_func
(paren
id|new_skb
)paren
OL
id|len
)paren
(brace
multiline_comment|/* No room for the packet. Call off the whole thing! */
id|wan_dev_kfree_skb
c_func
(paren
id|new_skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|WANPIPE
)paren
(brace
id|chan-&gt;rx_skb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|qdm
op_amp
l_int|0x01
)paren
(brace
id|chan-&gt;drop_sequence
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: unexpectedly long packet sequence &quot;
l_string|&quot;on interface %s!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
)paren
suffix:semicolon
op_increment
id|chan-&gt;ifstats.rx_length_errors
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|bufptr
op_assign
id|skb_put
c_func
(paren
id|new_skb
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
multiline_comment|/* Fill in the x25api header &n;&t;&t; */
id|x25api_t
op_star
id|api_data
op_assign
(paren
id|x25api_t
op_star
)paren
id|bufptr
suffix:semicolon
id|api_data-&gt;hdr.qdm
op_assign
id|rxmb-&gt;cmd.qdm
suffix:semicolon
id|api_data-&gt;hdr.cause
op_assign
id|rxmb-&gt;cmd.cause
suffix:semicolon
id|api_data-&gt;hdr.diagn
op_assign
id|rxmb-&gt;cmd.diagn
suffix:semicolon
id|api_data-&gt;hdr.length
op_assign
id|rxmb-&gt;cmd.length
suffix:semicolon
id|memcpy
c_func
(paren
id|api_data-&gt;data
comma
id|rxmb-&gt;data
comma
id|rxmb-&gt;cmd.length
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|bufptr
comma
id|rxmb-&gt;data
comma
id|len
)paren
suffix:semicolon
)brace
id|new_skb-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
id|new_skb-&gt;mac.raw
op_assign
id|new_skb-&gt;data
suffix:semicolon
id|new_skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|X25_PROT
)paren
suffix:semicolon
id|new_skb-&gt;pkt_type
op_assign
id|WAN_PACKET_DATA
suffix:semicolon
)brace
r_else
(brace
id|new_skb-&gt;protocol
op_assign
id|chan-&gt;protocol
suffix:semicolon
id|chan-&gt;rx_skb
op_assign
id|new_skb
suffix:semicolon
)brace
multiline_comment|/* If qdm bit is set, more data is coming &n;         * thus, exit and wait for more data before&n;         * sending the packet up. (Used by router only) &n;&t; */
r_if
c_cond
(paren
(paren
id|qdm
op_amp
l_int|0x01
)paren
op_logical_and
(paren
id|chan-&gt;common.usedby
op_eq
id|WANPIPE
)paren
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|skb
op_assign
id|new_skb
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * tx_intr&n; *  &n; * &t;Transmit interrupt handler.&n; *&t;For each dev, check that there is something to send.&n; *&t;If data available, transmit. &t;&n; *&n; *===============================================================*/
DECL|function|tx_intr
r_static
r_void
id|tx_intr
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|netdevice_t
op_star
id|dev
suffix:semicolon
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
r_int
r_char
id|more_to_tx
op_assign
l_int|0
suffix:semicolon
id|x25_channel_t
op_star
id|chan
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.tx_dev
op_eq
l_int|NULL
)paren
(brace
id|card-&gt;u.x.tx_dev
op_assign
id|card-&gt;wandev.dev
suffix:semicolon
)brace
id|dev
op_assign
id|card-&gt;u.x.tx_dev
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;transmit_length
)paren
(brace
multiline_comment|/* Device was set to transmit, check if the TX&n;                         * buffers are available &n;&t;&t;&t; */
r_if
c_cond
(paren
id|chan-&gt;common.state
op_ne
id|WAN_CONNECTED
)paren
(brace
id|chan-&gt;transmit_length
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.driver_busy
comma
l_int|0
)paren
suffix:semicolon
id|chan-&gt;tx_offset
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_queue_stopped
c_func
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
id|start_net_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|wakeup_sk_bh
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|wake_net_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
id|dev
op_assign
id|move_dev_to_next
c_func
(paren
id|card
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status-&gt;cflags
(braket
id|chan-&gt;ch_idx
)braket
op_amp
l_int|0x40
op_logical_or
id|card-&gt;u.x.LAPB_hdlc
)paren
op_logical_and
(paren
op_star
id|card-&gt;u.x.hdlc_buf_status
op_amp
l_int|0x40
)paren
)paren
(brace
multiline_comment|/* Tx buffer available, we can send */
r_if
c_cond
(paren
id|tx_intr_send
c_func
(paren
id|card
comma
id|dev
)paren
)paren
(brace
id|more_to_tx
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If more than one interface present, move the&n;                                 * device pointer to the next interface, so on the &n;                                 * next TX interrupt we will try sending from it. &n;                                 */
id|dev
op_assign
id|move_dev_to_next
c_func
(paren
id|card
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Tx buffers not available, but device set&n;                                 * the TX interrupt.  Set more_to_tx and try  &n;                                 * to transmit for other devices.&n;&t;&t;&t;&t; */
id|more_to_tx
op_assign
l_int|1
suffix:semicolon
id|dev
op_assign
id|move_dev_to_next
c_func
(paren
id|card
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* This device was not set to transmit,&n;                         * go to next &n;&t;&t;&t; */
id|dev
op_assign
id|move_dev_to_next
c_func
(paren
id|card
comma
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|i
op_eq
id|card-&gt;u.x.no_dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|more_to_tx
)paren
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Nothing to Send in TX INTR&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
singleline_comment|//End of FOR
id|card-&gt;u.x.tx_dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|more_to_tx
)paren
(brace
multiline_comment|/* if any other interfaces have transmit interrupts pending, */
multiline_comment|/* do not disable the global transmit interrupt */
r_if
c_cond
(paren
op_logical_neg
(paren
op_decrement
id|card-&gt;u.x.tx_interrupts_pending
)paren
)paren
(brace
id|status-&gt;imask
op_and_assign
op_complement
id|INTR_ON_TX_FRAME
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * move_dev_to_next&n; *  &n; *&n; *===============================================================*/
DECL|function|move_dev_to_next
id|netdevice_t
op_star
id|move_dev_to_next
(paren
id|sdla_t
op_star
id|card
comma
id|netdevice_t
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;u.x.no_dev
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
(paren
id|netdevice_t
op_star
op_star
)paren
id|dev-&gt;priv
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
id|card-&gt;wandev.dev
suffix:semicolon
)brace
r_else
(brace
r_return
op_star
(paren
(paren
id|netdevice_t
op_star
op_star
)paren
id|dev-&gt;priv
)paren
suffix:semicolon
)brace
)brace
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; *  tx_intr_send&n; *  &n; *&n; *===============================================================*/
DECL|function|tx_intr_send
r_static
r_int
id|tx_intr_send
c_func
(paren
id|sdla_t
op_star
id|card
comma
id|netdevice_t
op_star
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|chan_send
(paren
id|dev
comma
id|chan-&gt;transmit_buffer
comma
id|chan-&gt;transmit_length
comma
l_int|1
)paren
)paren
(brace
multiline_comment|/* Packet was split up due to its size, do not disable&n;                 * tx_intr &n;                 */
r_return
l_int|1
suffix:semicolon
)brace
id|chan-&gt;transmit_length
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.driver_busy
comma
l_int|0
)paren
suffix:semicolon
id|chan-&gt;tx_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If we are in API mode, wakeup the &n;         * sock BH handler, not the NET_BH */
r_if
c_cond
(paren
id|is_queue_stopped
c_func
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
id|start_net_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|wakeup_sk_bh
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|wake_net_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * timer_intr&n; *  &n; * &t;Timer interrupt handler.&n; *&t;Check who called the timer interrupt and perform&n; *      action accordingly.&n; *&n; *===============================================================*/
DECL|function|timer_intr
r_static
r_void
id|timer_intr
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.timer_int_enabled
op_amp
id|TMR_INT_ENABLED_CMD_EXEC
)paren
(brace
r_if
c_cond
(paren
id|timer_intr_cmd_exec
c_func
(paren
id|card
)paren
op_eq
l_int|0
)paren
(brace
id|card-&gt;u.x.timer_int_enabled
op_and_assign
op_complement
id|TMR_INT_ENABLED_CMD_EXEC
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|card-&gt;u.x.timer_int_enabled
op_amp
id|TMR_INT_ENABLED_UDP_PKT
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|card-&gt;u.x.hdlc_buf_status
op_amp
l_int|0x40
)paren
op_logical_and
id|card-&gt;u.x.udp_type
op_eq
id|UDP_XPIPE_TYPE
)paren
(brace
r_if
c_cond
(paren
id|process_udp_mgmt_pkt
c_func
(paren
id|card
)paren
)paren
(brace
id|card-&gt;u.x.timer_int_enabled
op_and_assign
op_complement
id|TMR_INT_ENABLED_UDP_PKT
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|card-&gt;u.x.timer_int_enabled
op_amp
id|TMR_INT_ENABLED_POLL_ACTIVE
)paren
(brace
id|netdevice_t
op_star
id|dev
op_assign
id|card-&gt;u.x.poll_device
suffix:semicolon
id|x25_channel_t
op_star
id|chan
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|card-&gt;u.x.timer_int_enabled
op_and_assign
op_complement
id|TMR_INT_ENABLED_POLL_ACTIVE
suffix:semicolon
r_return
suffix:semicolon
)brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Closing down Idle link %s on LCN %d&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|chan-&gt;name
comma
id|chan-&gt;common.lcn
)paren
suffix:semicolon
id|chan-&gt;i_timeout_sofar
op_assign
id|jiffies
suffix:semicolon
id|chan_disc
c_func
(paren
id|dev
)paren
suffix:semicolon
id|card-&gt;u.x.timer_int_enabled
op_and_assign
op_complement
id|TMR_INT_ENABLED_POLL_ACTIVE
suffix:semicolon
id|card-&gt;u.x.poll_device
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|card-&gt;u.x.timer_int_enabled
op_amp
id|TMR_INT_ENABLED_POLL_CONNECT_ON
)paren
(brace
id|wanpipe_set_state
c_func
(paren
id|card
comma
id|WAN_CONNECTED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
id|netdevice_t
op_star
id|dev
op_assign
id|card-&gt;wandev.dev
suffix:semicolon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_CONNECTED
)paren
suffix:semicolon
id|send_delayed_cmd_result
c_func
(paren
id|card
comma
id|dev
comma
id|card-&gt;mbox
)paren
suffix:semicolon
)brace
multiline_comment|/* 0x8F enable all interrupts */
id|x25_set_intr_mode
c_func
(paren
id|card
comma
id|INTR_ON_RX_FRAME
op_or
id|INTR_ON_TX_FRAME
op_or
id|INTR_ON_MODEM_STATUS_CHANGE
op_or
singleline_comment|//INTR_ON_COMMAND_COMPLETE|
id|X25_ASY_TRANS_INTR_PENDING
op_or
id|INTR_ON_TIMER
op_or
id|DIRECT_RX_INTR_USAGE
)paren
suffix:semicolon
id|status-&gt;imask
op_and_assign
op_complement
id|INTR_ON_TX_FRAME
suffix:semicolon
multiline_comment|/* mask Tx interrupts */
id|card-&gt;u.x.timer_int_enabled
op_and_assign
op_complement
id|TMR_INT_ENABLED_POLL_CONNECT_ON
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|card-&gt;u.x.timer_int_enabled
op_amp
id|TMR_INT_ENABLED_POLL_CONNECT_OFF
)paren
(brace
singleline_comment|//printk(KERN_INFO &quot;Poll connect, Turning OFF&bslash;n&quot;);
id|disconnect
c_func
(paren
id|card
)paren
suffix:semicolon
id|card-&gt;u.x.timer_int_enabled
op_and_assign
op_complement
id|TMR_INT_ENABLED_POLL_CONNECT_OFF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|card-&gt;u.x.timer_int_enabled
op_amp
id|TMR_INT_ENABLED_POLL_DISCONNECT
)paren
(brace
singleline_comment|//printk(KERN_INFO &quot;POll disconnect, trying to connect&bslash;n&quot;);
id|connect
c_func
(paren
id|card
)paren
suffix:semicolon
id|card-&gt;u.x.timer_int_enabled
op_and_assign
op_complement
id|TMR_INT_ENABLED_POLL_DISCONNECT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|card-&gt;u.x.timer_int_enabled
op_amp
id|TMR_INT_ENABLED_UPDATE
)paren
(brace
r_if
c_cond
(paren
op_star
id|card-&gt;u.x.hdlc_buf_status
op_amp
l_int|0x40
)paren
(brace
id|x25_get_err_stats
c_func
(paren
id|card
)paren
suffix:semicolon
id|x25_get_stats
c_func
(paren
id|card
)paren
suffix:semicolon
id|card-&gt;u.x.timer_int_enabled
op_and_assign
op_complement
id|TMR_INT_ENABLED_UPDATE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;u.x.timer_int_enabled
)paren
(brace
singleline_comment|//printk(KERN_INFO &quot;Turning Timer Off &bslash;n&quot;);
id|status-&gt;imask
op_and_assign
op_complement
id|INTR_ON_TIMER
suffix:semicolon
)brace
)brace
multiline_comment|/*====================================================================&n; * &t;Modem status interrupt handler.&n; *===================================================================*/
DECL|function|status_intr
r_static
r_void
id|status_intr
(paren
id|sdla_t
op_star
id|card
)paren
(brace
multiline_comment|/* Added to avoid Modem status message flooding */
r_static
id|TX25ModemStatus
id|last_stat
suffix:semicolon
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
id|TX25ModemStatus
op_star
id|modem_status
suffix:semicolon
id|netdevice_t
op_star
id|dev
suffix:semicolon
id|x25_channel_t
op_star
id|chan
suffix:semicolon
r_int
id|err
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_READ_MODEM_STATUS
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_READ_MODEM_STATUS
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|modem_status
op_assign
(paren
id|TX25ModemStatus
op_star
)paren
id|mbox-&gt;data
suffix:semicolon
multiline_comment|/* Check if the last status was the same&n;           &t; * if it was, do NOT print message again */
r_if
c_cond
(paren
id|last_stat.status
op_ne
id|modem_status-&gt;status
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Modem Status Change: DCD=%s, CTS=%s&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|DCD
c_func
(paren
id|modem_status-&gt;status
)paren
comma
id|CTS
c_func
(paren
id|modem_status-&gt;status
)paren
)paren
suffix:semicolon
id|last_stat.status
op_assign
id|modem_status-&gt;status
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.oob_on_modem
)paren
(brace
id|mbox-&gt;cmd.pktType
op_assign
id|mbox-&gt;cmd.command
suffix:semicolon
id|mbox-&gt;cmd.result
op_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* Send a OOB to all connected sockets */
r_for
c_loop
(paren
id|dev
op_assign
id|card-&gt;wandev.dev
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
op_star
(paren
(paren
id|netdevice_t
op_star
op_star
)paren
id|dev-&gt;priv
)paren
)paren
(brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
id|send_oob_msg
c_func
(paren
id|card
comma
id|dev
comma
id|mbox
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* The modem OOB message will probably kill the&n;&t;&t;&t;&t; * the link. If we don&squot;t clear the flag here,&n;&t;&t;&t;&t; * a deadlock could occur */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
)paren
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_HDLC_LINK_STATUS
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_HDLC_LINK_STATUS
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*====================================================================&n; * &t;Network event interrupt handler.&n; *===================================================================*/
DECL|function|event_intr
r_static
r_void
id|event_intr
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|x25_fetch_events
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Spurious interrupt handler.&n; * &t;o print a warning&n; * &t;o&t; &n; *====================================================================*/
DECL|function|spur_intr
r_static
r_void
id|spur_intr
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: spurious interrupt!&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Background Polling Routines  &n; */
multiline_comment|/*====================================================================&n; * &t;Main polling routine.&n; * &t;This routine is repeatedly called by the WANPIPE &squot;thead&squot; to allow for&n; * &t;time-dependent housekeeping work.&n; *&n; * &t;Notes:&n; * &t;1. This routine may be called on interrupt context with all interrupts&n; *    &t;enabled. Beware!&n; *====================================================================*/
DECL|function|wpx_poll
r_static
r_void
id|wpx_poll
(paren
id|sdla_t
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;wandev.dev
)paren
(brace
r_goto
id|wpx_poll_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;open_cnt
op_ne
id|card-&gt;u.x.num_of_ch
)paren
(brace
r_goto
id|wpx_poll_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|PERI_CRIT
comma
op_amp
id|card-&gt;wandev.critical
)paren
)paren
(brace
r_goto
id|wpx_poll_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SEND_CRIT
comma
op_amp
id|card-&gt;wandev.critical
)paren
)paren
(brace
r_goto
id|wpx_poll_exit
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|card-&gt;wandev.state
)paren
(brace
r_case
id|WAN_CONNECTED
suffix:colon
id|poll_active
c_func
(paren
id|card
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WAN_CONNECTING
suffix:colon
id|poll_connecting
c_func
(paren
id|card
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WAN_DISCONNECTED
suffix:colon
id|poll_disconnected
c_func
(paren
id|card
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|wpx_poll_exit
suffix:colon
id|clear_bit
c_func
(paren
id|POLL_CRIT
comma
op_amp
id|card-&gt;wandev.critical
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|trigger_x25_poll
r_static
r_void
id|trigger_x25_poll
c_func
(paren
id|sdla_t
op_star
id|card
)paren
(brace
macro_line|#ifdef LINUX_2_4
id|schedule_task
c_func
(paren
op_amp
id|card-&gt;u.x.x25_poll_task
)paren
suffix:semicolon
macro_line|#else
id|queue_task
c_func
(paren
op_amp
id|card-&gt;u.x.x25_poll_task
comma
op_amp
id|tq_scheduler
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*====================================================================&n; * &t;Handle physical link establishment phase.&n; * &t;o if connection timed out, disconnect the link.&n; *===================================================================*/
DECL|function|poll_connecting
r_static
r_void
id|poll_connecting
(paren
id|sdla_t
op_star
id|card
)paren
(brace
r_volatile
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
id|status-&gt;gflags
op_amp
id|X25_HDLC_ABM
)paren
(brace
id|timer_intr_exec
(paren
id|card
comma
id|TMR_INT_ENABLED_POLL_CONNECT_ON
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|card-&gt;state_tick
)paren
OG
id|CONNECT_TIMEOUT
)paren
(brace
id|timer_intr_exec
(paren
id|card
comma
id|TMR_INT_ENABLED_POLL_CONNECT_OFF
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*====================================================================&n; * &t;Handle physical link disconnected phase.&n; * &t;o if hold-down timeout has expired and there are open interfaces, &n; *&t;connect link.&n; *===================================================================*/
DECL|function|poll_disconnected
r_static
r_void
id|poll_disconnected
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|netdevice_t
op_star
id|dev
suffix:semicolon
id|x25_channel_t
op_star
id|chan
suffix:semicolon
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;u.x.LAPB_hdlc
op_logical_and
id|card-&gt;open_cnt
op_logical_and
(paren
(paren
id|jiffies
op_minus
id|card-&gt;state_tick
)paren
OG
id|HOLD_DOWN_TIME
)paren
)paren
(brace
id|timer_intr_exec
c_func
(paren
id|card
comma
id|TMR_INT_ENABLED_POLL_DISCONNECT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|card-&gt;wandev.dev
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chan
op_assign
id|dev-&gt;priv
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;common.command
)paren
op_logical_and
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|card-&gt;u.x.timer_int_enabled
op_amp
id|TMR_INT_ENABLED_CMD_EXEC
)paren
)paren
id|card-&gt;u.x.timer_int_enabled
op_or_assign
id|TMR_INT_ENABLED_CMD_EXEC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status-&gt;imask
op_amp
id|INTR_ON_TIMER
)paren
)paren
id|status-&gt;imask
op_or_assign
id|INTR_ON_TIMER
suffix:semicolon
)brace
)brace
multiline_comment|/*====================================================================&n; * &t;Handle active link phase.&n; * &t;o fetch X.25 asynchronous events.&n; * &t;o kick off transmission on all interfaces.&n; *===================================================================*/
DECL|function|poll_active
r_static
r_void
id|poll_active
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|netdevice_t
op_star
id|dev
suffix:semicolon
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|card-&gt;wandev.dev
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
op_star
(paren
(paren
id|netdevice_t
op_star
op_star
)paren
id|dev-&gt;priv
)paren
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* If SVC has been idle long enough, close virtual circuit */
r_if
c_cond
(paren
id|chan-&gt;common.svc
op_logical_and
id|chan-&gt;common.state
op_eq
id|WAN_CONNECTED
op_logical_and
id|chan-&gt;common.usedby
op_eq
id|WANPIPE
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|chan-&gt;i_timeout_sofar
)paren
op_div
id|HZ
OG
id|chan-&gt;idle_timeout
)paren
(brace
multiline_comment|/* Close svc */
id|card-&gt;u.x.poll_device
op_assign
id|dev
suffix:semicolon
id|timer_intr_exec
(paren
id|card
comma
id|TMR_INT_ENABLED_POLL_ACTIVE
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef PRINT_DEBUG
id|chan-&gt;ifstats.tx_compressed
op_assign
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;common.command
)paren
suffix:semicolon
id|chan-&gt;ifstats.tx_errors
op_assign
id|chan-&gt;common.state
suffix:semicolon
id|chan-&gt;ifstats.rx_fifo_errors
op_assign
id|atomic_read
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
)paren
suffix:semicolon
op_increment
id|chan-&gt;ifstats.tx_bytes
suffix:semicolon
id|chan-&gt;ifstats.rx_fifo_errors
op_assign
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;common.disconnect
)paren
suffix:semicolon
id|chan-&gt;ifstats.multicast
op_assign
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;bh_buff_used
)paren
suffix:semicolon
id|chan-&gt;ifstats.rx_length_errors
op_assign
op_star
id|card-&gt;u.x.hdlc_buf_status
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;common.command
)paren
op_logical_and
op_logical_neg
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|card-&gt;u.x.timer_int_enabled
op_amp
id|TMR_INT_ENABLED_CMD_EXEC
)paren
)paren
id|card-&gt;u.x.timer_int_enabled
op_or_assign
id|TMR_INT_ENABLED_CMD_EXEC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status-&gt;imask
op_amp
id|INTR_ON_TIMER
)paren
)paren
id|status-&gt;imask
op_or_assign
id|INTR_ON_TIMER
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;common.disconnect
)paren
)paren
(brace
r_if
c_cond
(paren
id|chan-&gt;common.state
op_eq
id|WAN_DISCONNECTED
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.disconnect
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.command
comma
id|X25_CLEAR_CALL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|card-&gt;u.x.timer_int_enabled
op_amp
id|TMR_INT_ENABLED_CMD_EXEC
)paren
)paren
id|card-&gt;u.x.timer_int_enabled
op_or_assign
id|TMR_INT_ENABLED_CMD_EXEC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status-&gt;imask
op_amp
id|INTR_ON_TIMER
)paren
)paren
id|status-&gt;imask
op_or_assign
id|INTR_ON_TIMER
suffix:semicolon
)brace
)brace
)brace
DECL|function|timer_intr_exec
r_static
r_void
id|timer_intr_exec
c_func
(paren
id|sdla_t
op_star
id|card
comma
r_int
r_char
id|TYPE
)paren
(brace
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
id|card-&gt;u.x.timer_int_enabled
op_or_assign
id|TYPE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status-&gt;imask
op_amp
id|INTR_ON_TIMER
)paren
)paren
id|status-&gt;imask
op_or_assign
id|INTR_ON_TIMER
suffix:semicolon
)brace
multiline_comment|/*==================================================================== &n; * SDLA Firmware-Specific Functions &n; *&n; *  Almost all X.25 commands can unexpetedly fail due to so called &squot;X.25&n; *  asynchronous events&squot; such as restart, interrupt, incoming call request,&n; *  call clear request, etc.  They can&squot;t be ignored and have to be delt with&n; *  immediately.  To tackle with this problem we execute each interface &n; *  command in a loop until good return code is received or maximum number &n; *  of retries is reached.  Each interface command returns non-zero return &n; *  code, an asynchronous event/error handler x25_error() is called.&n; *====================================================================*/
multiline_comment|/*====================================================================&n; * &t;Read X.25 firmware version.&n; *&t;&t;Put code version as ASCII string in str. &n; *===================================================================*/
DECL|function|x25_get_version
r_static
r_int
id|x25_get_version
(paren
id|sdla_t
op_star
id|card
comma
r_char
op_star
id|str
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_READ_CODE_VERSION
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_READ_CODE_VERSION
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|str
)paren
(brace
r_int
id|len
op_assign
id|mbox-&gt;cmd.length
suffix:semicolon
id|memcpy
c_func
(paren
id|str
comma
id|mbox-&gt;data
comma
id|len
)paren
suffix:semicolon
id|str
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Configure adapter.&n; *===================================================================*/
DECL|function|x25_configure
r_static
r_int
id|x25_configure
(paren
id|sdla_t
op_star
id|card
comma
id|TX25Config
op_star
id|conf
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mbox-&gt;data
comma
(paren
r_void
op_star
)paren
id|conf
comma
r_sizeof
(paren
id|TX25Config
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
r_sizeof
(paren
id|TX25Config
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_SET_CONFIGURATION
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_SET_CONFIGURATION
comma
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Configure adapter for HDLC only.&n; *===================================================================*/
DECL|function|hdlc_configure
r_static
r_int
id|hdlc_configure
(paren
id|sdla_t
op_star
id|card
comma
id|TX25Config
op_star
id|conf
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mbox-&gt;data
comma
(paren
r_void
op_star
)paren
id|conf
comma
r_sizeof
(paren
id|TX25Config
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
r_sizeof
(paren
id|TX25Config
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_HDLC_SET_CONFIG
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_SET_CONFIGURATION
comma
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|set_hdlc_level
r_static
r_int
id|set_hdlc_level
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|SET_PROTOCOL_LEVEL
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
l_int|1
suffix:semicolon
id|mbox-&gt;data
(braket
l_int|0
)braket
op_assign
id|HDLC_LEVEL
suffix:semicolon
singleline_comment|//| DO_HDLC_LEVEL_ERROR_CHECKING; &t;
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|SET_PROTOCOL_LEVEL
comma
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * Get communications error statistics.&n; *====================================================================*/
DECL|function|x25_get_err_stats
r_static
r_int
id|x25_get_err_stats
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_HDLC_READ_COMM_ERR
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_HDLC_READ_COMM_ERR
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|THdlcCommErr
op_star
id|stats
op_assign
(paren
r_void
op_star
)paren
id|mbox-&gt;data
suffix:semicolon
id|card-&gt;wandev.stats.rx_over_errors
op_assign
id|stats-&gt;rxOverrun
suffix:semicolon
id|card-&gt;wandev.stats.rx_crc_errors
op_assign
id|stats-&gt;rxBadCrc
suffix:semicolon
id|card-&gt;wandev.stats.rx_missed_errors
op_assign
id|stats-&gt;rxAborted
suffix:semicolon
id|card-&gt;wandev.stats.tx_aborted_errors
op_assign
id|stats-&gt;txAborted
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Get protocol statistics.&n; *===================================================================*/
DECL|function|x25_get_stats
r_static
r_int
id|x25_get_stats
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_READ_STATISTICS
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_READ_STATISTICS
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|TX25Stats
op_star
id|stats
op_assign
(paren
r_void
op_star
)paren
id|mbox-&gt;data
suffix:semicolon
id|card-&gt;wandev.stats.rx_packets
op_assign
id|stats-&gt;rxData
suffix:semicolon
id|card-&gt;wandev.stats.tx_packets
op_assign
id|stats-&gt;txData
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Close HDLC link.&n; *===================================================================*/
DECL|function|x25_close_hdlc
r_static
r_int
id|x25_close_hdlc
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_HDLC_LINK_CLOSE
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_HDLC_LINK_CLOSE
comma
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Open HDLC link.&n; *===================================================================*/
DECL|function|x25_open_hdlc
r_static
r_int
id|x25_open_hdlc
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_HDLC_LINK_OPEN
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_HDLC_LINK_OPEN
comma
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*=====================================================================&n; * Setup HDLC link.&n; *====================================================================*/
DECL|function|x25_setup_hdlc
r_static
r_int
id|x25_setup_hdlc
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_HDLC_LINK_SETUP
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_HDLC_LINK_SETUP
comma
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * Set (raise/drop) DTR.&n; *===================================================================*/
DECL|function|x25_set_dtr
r_static
r_int
id|x25_set_dtr
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|dtr
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;data
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;data
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;data
(braket
l_int|1
)braket
op_assign
id|dtr
ques
c_cond
l_int|0x02
suffix:colon
l_int|0x01
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
l_int|3
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_SET_GLOBAL_VARS
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_SET_GLOBAL_VARS
comma
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Set interrupt mode.&n; *===================================================================*/
DECL|function|x25_set_intr_mode
r_static
r_int
id|x25_set_intr_mode
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|mode
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;data
(braket
l_int|0
)braket
op_assign
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;hw.fwid
op_eq
id|SFID_X25_508
)paren
(brace
id|mbox-&gt;data
(braket
l_int|1
)braket
op_assign
id|card-&gt;hw.irq
suffix:semicolon
id|mbox-&gt;data
(braket
l_int|2
)braket
op_assign
l_int|2
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|mbox-&gt;cmd.length
op_assign
l_int|1
suffix:semicolon
)brace
id|mbox-&gt;cmd.command
op_assign
id|X25_SET_INTERRUPT_MODE
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_SET_INTERRUPT_MODE
comma
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Read X.25 channel configuration.&n; *===================================================================*/
DECL|function|x25_get_chan_conf
r_static
r_int
id|x25_get_chan_conf
(paren
id|sdla_t
op_star
id|card
comma
id|x25_channel_t
op_star
id|chan
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|lcn
op_assign
id|chan-&gt;common.lcn
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.lcn
op_assign
id|lcn
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_READ_CHANNEL_CONFIG
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_READ_CHANNEL_CONFIG
comma
id|lcn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
multiline_comment|/* calculate an offset into the array of status bytes */
r_if
c_cond
(paren
id|card-&gt;u.x.hi_svc
op_le
id|X25_MAX_CHAN
)paren
(brace
id|chan-&gt;ch_idx
op_assign
id|lcn
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_int
id|offset
suffix:semicolon
multiline_comment|/* FIX: Apr 14 2000 : Nenad Corbic&n;&t;&t;&t; * The data field was being compared to 0x1F using&n;                         * &squot;&amp;&amp;&squot; instead of &squot;&amp;&squot;. &n;&t;&t;&t; * This caused X25API to fail for LCNs greater than 255.&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|mbox-&gt;data
(braket
l_int|0
)braket
op_amp
l_int|0x1F
)paren
(brace
r_case
l_int|0x01
suffix:colon
id|offset
op_assign
id|status-&gt;pvc_map
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x03
suffix:colon
id|offset
op_assign
id|status-&gt;icc_map
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x07
suffix:colon
id|offset
op_assign
id|status-&gt;twc_map
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0B
suffix:colon
id|offset
op_assign
id|status-&gt;ogc_map
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
id|chan-&gt;ch_idx
op_assign
id|lcn
op_minus
l_int|1
op_minus
id|offset
suffix:semicolon
)brace
multiline_comment|/* get actual transmit packet size on this channel */
r_switch
c_cond
(paren
id|mbox-&gt;data
(braket
l_int|1
)braket
op_amp
l_int|0x38
)paren
(brace
r_case
l_int|0x00
suffix:colon
id|chan-&gt;tx_pkt_size
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
id|chan-&gt;tx_pkt_size
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
id|chan-&gt;tx_pkt_size
op_assign
l_int|64
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x18
suffix:colon
id|chan-&gt;tx_pkt_size
op_assign
l_int|128
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
id|chan-&gt;tx_pkt_size
op_assign
l_int|256
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x28
suffix:colon
id|chan-&gt;tx_pkt_size
op_assign
l_int|512
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x30
suffix:colon
id|chan-&gt;tx_pkt_size
op_assign
l_int|1024
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;u.x.logging
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: X.25 packet size on LCN %d is %d.&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|lcn
comma
id|chan-&gt;tx_pkt_size
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Place X.25 call.&n; *====================================================================*/
DECL|function|x25_place_call
r_static
r_int
id|x25_place_call
(paren
id|sdla_t
op_star
id|card
comma
id|x25_channel_t
op_star
id|chan
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_char
id|str
(braket
l_int|64
)braket
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;protocol
op_eq
id|htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
(brace
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;-d%s -uCC&quot;
comma
id|chan-&gt;addr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|chan-&gt;protocol
op_eq
id|htons
c_func
(paren
id|ETH_P_IPX
)paren
)paren
(brace
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;-d%s -u800000008137&quot;
comma
id|chan-&gt;addr
)paren
suffix:semicolon
)brace
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|mbox-&gt;data
comma
id|str
)paren
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
id|strlen
c_func
(paren
id|str
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_PLACE_CALL
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_PLACE_CALL
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|bind_lcn_to_dev
(paren
id|card
comma
id|chan-&gt;dev
comma
id|mbox-&gt;cmd.lcn
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Accept X.25 call.&n; *====================================================================*/
DECL|function|x25_accept_call
r_static
r_int
id|x25_accept_call
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|lcn
comma
r_int
id|qdm
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.lcn
op_assign
id|lcn
suffix:semicolon
id|mbox-&gt;cmd.qdm
op_assign
id|qdm
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_ACCEPT_CALL
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_ACCEPT_CALL
comma
id|lcn
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Clear X.25 call.&n; *====================================================================*/
DECL|function|x25_clear_call
r_static
r_int
id|x25_clear_call
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|lcn
comma
r_int
id|cause
comma
r_int
id|diagn
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.lcn
op_assign
id|lcn
suffix:semicolon
id|mbox-&gt;cmd.cause
op_assign
id|cause
suffix:semicolon
id|mbox-&gt;cmd.diagn
op_assign
id|diagn
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_CLEAR_CALL
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_CLEAR_CALL
comma
id|lcn
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Send X.25 data packet.&n; *====================================================================*/
DECL|function|x25_send
r_static
r_int
id|x25_send
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|lcn
comma
r_int
id|qdm
comma
r_int
id|len
comma
r_void
op_star
id|buf
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
r_char
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
)paren
id|cmd
op_assign
id|X25_HDLC_WRITE
suffix:semicolon
r_else
id|cmd
op_assign
id|X25_WRITE
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mbox-&gt;data
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
id|len
suffix:semicolon
id|mbox-&gt;cmd.lcn
op_assign
id|lcn
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
id|mbox-&gt;cmd.pf
op_assign
id|qdm
suffix:semicolon
)brace
r_else
(brace
id|mbox-&gt;cmd.qdm
op_assign
id|qdm
suffix:semicolon
)brace
id|mbox-&gt;cmd.command
op_assign
id|cmd
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|cmd
comma
id|lcn
)paren
)paren
suffix:semicolon
multiline_comment|/* If buffers are busy the return code for LAPB HDLC is&n;         * 1. The above functions are looking for return code&n;         * of X25RES_NOT_READY if busy. */
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
op_logical_and
id|err
op_eq
l_int|1
)paren
(brace
id|err
op_assign
id|X25RES_NOT_READY
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Fetch X.25 asynchronous events.&n; *===================================================================*/
DECL|function|x25_fetch_events
r_static
r_int
id|x25_fetch_events
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status-&gt;gflags
op_amp
l_int|0x20
)paren
(brace
id|memset
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_IS_DATA_AVAILABLE
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_IS_DATA_AVAILABLE
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;X.25 asynchronous event/error handler.&n; *&t;&t;This routine is called each time interface command returns &n; *&t;&t;non-zero return code to handle X.25 asynchronous events and &n; *&t;&t;common errors. Return non-zero to repeat command or zero to &n; *&t;&t;cancel it.&n; *&n; * &t;Notes:&n; * &t;1. This function may be called recursively, as handling some of the&n; *    &t;asynchronous events (e.g. call request) requires execution of the&n; *    &t;interface command(s) that, in turn, may also return asynchronous&n; *    &t;events.  To avoid re-entrancy problems we copy mailbox to dynamically&n; *    &t;allocated memory before processing events.&n; *====================================================================*/
DECL|function|x25_error
r_static
r_int
id|x25_error
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|err
comma
r_int
id|cmd
comma
r_int
id|lcn
)paren
(brace
r_int
id|retry
op_assign
l_int|1
suffix:semicolon
r_int
id|dlen
op_assign
(paren
(paren
id|TX25Mbox
op_star
)paren
id|card-&gt;mbox
)paren
op_member_access_from_pointer
id|cmd.length
suffix:semicolon
id|TX25Mbox
op_star
id|mb
suffix:semicolon
id|mb
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|TX25Mbox
)paren
op_plus
id|dlen
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: x25_error() out of memory!&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|mb
comma
id|card-&gt;mbox
comma
r_sizeof
(paren
id|TX25Mbox
)paren
op_plus
id|dlen
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|err
)paren
(brace
r_case
id|X25RES_ASYNC_PACKET
suffix:colon
multiline_comment|/* X.25 asynchronous packet was received */
id|mb-&gt;data
(braket
id|dlen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_switch
c_cond
(paren
id|mb-&gt;cmd.pktType
op_amp
l_int|0x7F
)paren
(brace
r_case
id|ASE_CALL_RQST
suffix:colon
multiline_comment|/* incoming call */
id|retry
op_assign
id|incoming_call
c_func
(paren
id|card
comma
id|cmd
comma
id|lcn
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ASE_CALL_ACCEPTED
suffix:colon
multiline_comment|/* connected */
id|retry
op_assign
id|call_accepted
c_func
(paren
id|card
comma
id|cmd
comma
id|lcn
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ASE_CLEAR_RQST
suffix:colon
multiline_comment|/* call clear request */
id|retry
op_assign
id|call_cleared
c_func
(paren
id|card
comma
id|cmd
comma
id|lcn
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ASE_RESET_RQST
suffix:colon
multiline_comment|/* reset request */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: X.25 reset request on LCN %d! &quot;
l_string|&quot;Cause:0x%02X Diagn:0x%02X&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|mb-&gt;cmd.lcn
comma
id|mb-&gt;cmd.cause
comma
id|mb-&gt;cmd.diagn
)paren
suffix:semicolon
id|api_oob_event
(paren
id|card
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ASE_RESTART_RQST
suffix:colon
multiline_comment|/* restart request */
id|retry
op_assign
id|restart_event
c_func
(paren
id|card
comma
id|cmd
comma
id|lcn
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ASE_CLEAR_CONFRM
suffix:colon
r_if
c_cond
(paren
id|clear_confirm_event
(paren
id|card
comma
id|mb
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* I use the goto statement here so if &n;&t;                 * somebody inserts code between the&n;        &t;         * case and default, we will not have&n;                &t; * ghost problems */
r_goto
id|dflt_1
suffix:semicolon
r_default
suffix:colon
id|dflt_1
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: X.25 event 0x%02X on LCN %d! &quot;
l_string|&quot;Cause:0x%02X Diagn:0x%02X&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|mb-&gt;cmd.pktType
comma
id|mb-&gt;cmd.lcn
comma
id|mb-&gt;cmd.cause
comma
id|mb-&gt;cmd.diagn
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|X25RES_PROTO_VIOLATION
suffix:colon
multiline_comment|/* X.25 protocol violation indication */
multiline_comment|/* Bug Fix: Mar 14 2000&n;                 * The Protocol violation error conditions were  &n;                 * not handeled previously */
r_switch
c_cond
(paren
id|mb-&gt;cmd.pktType
op_amp
l_int|0x7F
)paren
(brace
r_case
id|PVE_CLEAR_RQST
suffix:colon
multiline_comment|/* Clear request */
id|retry
op_assign
id|call_cleared
c_func
(paren
id|card
comma
id|cmd
comma
id|lcn
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PVE_RESET_RQST
suffix:colon
multiline_comment|/* Reset request */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: X.25 reset request on LCN %d! &quot;
l_string|&quot;Cause:0x%02X Diagn:0x%02X&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|mb-&gt;cmd.lcn
comma
id|mb-&gt;cmd.cause
comma
id|mb-&gt;cmd.diagn
)paren
suffix:semicolon
id|api_oob_event
(paren
id|card
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PVE_RESTART_RQST
suffix:colon
multiline_comment|/* Restart request */
id|retry
op_assign
id|restart_event
c_func
(paren
id|card
comma
id|cmd
comma
id|lcn
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: X.25 protocol violation on LCN %d! &quot;
l_string|&quot;Packet:0x%02X Cause:0x%02X Diagn:0x%02X&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|mb-&gt;cmd.lcn
comma
id|mb-&gt;cmd.pktType
op_amp
l_int|0x7F
comma
id|mb-&gt;cmd.cause
comma
id|mb-&gt;cmd.diagn
)paren
suffix:semicolon
id|api_oob_event
c_func
(paren
id|card
comma
id|mb
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x42
suffix:colon
multiline_comment|/* X.25 timeout */
id|retry
op_assign
id|timeout_event
c_func
(paren
id|card
comma
id|cmd
comma
id|lcn
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x43
suffix:colon
multiline_comment|/* X.25 retry limit exceeded */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: exceeded X.25 retry limit on LCN %d! &quot;
l_string|&quot;Packet:0x%02X Diagn:0x%02X&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|mb-&gt;cmd.lcn
comma
id|mb-&gt;cmd.pktType
comma
id|mb-&gt;cmd.diagn
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
multiline_comment|/* modem failure */
macro_line|#ifndef MODEM_NOT_LOG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: modem failure!&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
macro_line|#endif /* MODEM_NOT_LOG */
id|api_oob_event
c_func
(paren
id|card
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x09
suffix:colon
multiline_comment|/* N2 retry limit */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: exceeded HDLC retry limit!&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|api_oob_event
c_func
(paren
id|card
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x06
suffix:colon
multiline_comment|/* unnumbered frame was received while in ABM */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: received Unnumbered frame 0x%02X!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|mb-&gt;data
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|api_oob_event
c_func
(paren
id|card
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_TIMEOUT
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: command 0x%02X timed out!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|cmd
)paren
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* abort command */
r_break
suffix:semicolon
r_case
id|X25RES_NOT_READY
suffix:colon
id|retry
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|mb-&gt;cmd.command
op_eq
l_int|0x16
)paren
r_break
suffix:semicolon
multiline_comment|/* I use the goto statement here so if &n;                 * somebody inserts code between the&n;                 * case and default, we will not have&n;                 * ghost problems */
r_goto
id|dflt_2
suffix:semicolon
r_default
suffix:colon
id|dflt_2
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: command 0x%02X returned 0x%02X! Lcn %i&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|cmd
comma
id|err
comma
id|mb-&gt;cmd.lcn
)paren
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* abort command */
)brace
id|kfree
c_func
(paren
id|mb
)paren
suffix:semicolon
r_return
id|retry
suffix:semicolon
)brace
multiline_comment|/*==================================================================== &n; *&t;X.25 Asynchronous Event Handlers&n; * &t;These functions are called by the x25_error() and should return 0, if&n; * &t;the command resulting in the asynchronous event must be aborted.&n; *====================================================================*/
multiline_comment|/*====================================================================&n; *Handle X.25 incoming call request.&n; *&t;RFC 1356 establishes the following rules:&n; *&t;1. The first octet in the Call User Data (CUD) field of the call&n; *     &t;   request packet contains NLPID identifying protocol encapsulation&n; * &t;2. Calls MUST NOT be accepted unless router supports requested&n; *   &t;   protocol encapsulation.&n; *&t;3. A diagnostic code 249 defined by ISO/IEC 8208 may be used &n; *&t;   when clearing a call because protocol encapsulation is not &n; *&t;   supported.&n; *&t;4. If an incoming call is received while a call request is &n; *&t;   pending (i.e. call collision has occured), the incoming call &n; *&t;   shall be rejected and call request shall be retried.&n; *====================================================================*/
DECL|function|incoming_call
r_static
r_int
id|incoming_call
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|cmd
comma
r_int
id|lcn
comma
id|TX25Mbox
op_star
id|mb
)paren
(brace
id|wan_device_t
op_star
id|wandev
op_assign
op_amp
id|card-&gt;wandev
suffix:semicolon
r_int
id|new_lcn
op_assign
id|mb-&gt;cmd.lcn
suffix:semicolon
id|netdevice_t
op_star
id|dev
op_assign
id|get_dev_by_lcn
c_func
(paren
id|wandev
comma
id|new_lcn
)paren
suffix:semicolon
id|x25_channel_t
op_star
id|chan
op_assign
l_int|NULL
suffix:semicolon
r_int
id|accept
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set to &squot;1&squot; if o.k. to accept call */
r_int
r_int
id|user_data
suffix:semicolon
id|x25_call_info_t
op_star
id|info
suffix:semicolon
multiline_comment|/* Make sure there is no call collision */
r_if
c_cond
(paren
id|dev
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: X.25 incoming call collision on LCN %d!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|new_lcn
)paren
suffix:semicolon
id|x25_clear_call
c_func
(paren
id|card
comma
id|new_lcn
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Make sure D bit is not set in call request */
singleline_comment|//FIXME: THIS IS NOT TURE !!!! TAKE IT OUT
singleline_comment|//&t;if (mb-&gt;cmd.qdm &amp; 0x02)
singleline_comment|//&t;{
singleline_comment|//&t;&t;printk(KERN_INFO
singleline_comment|//&t;&t;&t;&quot;%s: X.25 incoming call on LCN %d with D-bit set!&bslash;n&quot;,
singleline_comment|//&t;&t;&t;card-&gt;devname, new_lcn);
singleline_comment|//
singleline_comment|//&t;&t;x25_clear_call(card, new_lcn, 0, 0);
singleline_comment|//&t;&t;return 1;
singleline_comment|//&t;}
multiline_comment|/* Parse call request data */
id|info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|x25_call_info_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: not enough memory to parse X.25 incoming call &quot;
l_string|&quot;on LCN %d!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|new_lcn
)paren
suffix:semicolon
id|x25_clear_call
c_func
(paren
id|card
comma
id|new_lcn
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|parse_call_info
c_func
(paren
id|mb-&gt;data
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.logging
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;n%s: X.25 incoming call on LCN %d!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|new_lcn
)paren
suffix:semicolon
multiline_comment|/* Conver the first two ASCII characters into an&n;         * interger. Used to check the incoming protocol &n;         */
id|user_data
op_assign
id|hex_to_uint
c_func
(paren
id|info-&gt;user
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Find available channel */
r_for
c_loop
(paren
id|dev
op_assign
id|wandev-&gt;dev
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
op_star
(paren
(paren
id|netdevice_t
op_star
op_star
)paren
id|dev-&gt;priv
)paren
)paren
(brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan-&gt;common.svc
op_logical_or
(paren
id|chan-&gt;common.state
op_ne
id|WAN_DISCONNECTED
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|user_data
op_eq
id|NLPID_IP
op_logical_and
id|chan-&gt;protocol
op_ne
id|htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IP packet but configured for IPX : %x, %x&bslash;n&quot;
comma
id|htons
c_func
(paren
id|chan-&gt;protocol
)paren
comma
id|info-&gt;user
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|user_data
op_eq
id|NLPID_SNAP
op_logical_and
id|chan-&gt;protocol
op_ne
id|htons
c_func
(paren
id|ETH_P_IPX
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IPX packet but configured for IP: %x&bslash;n&quot;
comma
id|htons
c_func
(paren
id|chan-&gt;protocol
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|info-&gt;src
comma
id|chan-&gt;addr
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* If just an &squot;@&squot; is specified, accept all incoming calls */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|chan-&gt;addr
comma
l_string|&quot;&quot;
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* If the call is not for any WANPIPE interfaces&n;                 * check to see if there is an API listening queue&n;                 * waiting for data. If there is send the packet&n;                 * up the stack.&n;                 */
r_if
c_cond
(paren
id|card-&gt;sk
op_ne
l_int|NULL
op_logical_and
id|card-&gt;func
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|api_incoming_call
c_func
(paren
id|card
comma
id|mb
comma
id|new_lcn
)paren
)paren
(brace
id|x25_clear_call
c_func
(paren
id|card
comma
id|new_lcn
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|accept
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: no channels available!&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|x25_clear_call
c_func
(paren
id|card
comma
id|new_lcn
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|info-&gt;nuser
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: no user data in incoming call on LCN %d!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|new_lcn
)paren
suffix:semicolon
id|x25_clear_call
c_func
(paren
id|card
comma
id|new_lcn
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|info-&gt;user
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* multiplexed */
id|chan-&gt;protocol
op_assign
id|htons
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|accept
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NLPID_IP
suffix:colon
multiline_comment|/* IP datagrams */
id|accept
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NLPID_SNAP
suffix:colon
multiline_comment|/* IPX datagrams */
id|accept
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: unsupported NLPID 0x%02X in incoming call &quot;
l_string|&quot;on LCN %d!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|info-&gt;user
(braket
l_int|0
)braket
comma
id|new_lcn
)paren
suffix:semicolon
id|x25_clear_call
c_func
(paren
id|card
comma
id|new_lcn
comma
l_int|0
comma
l_int|249
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|accept
op_logical_and
(paren
id|x25_accept_call
c_func
(paren
id|card
comma
id|new_lcn
comma
l_int|0
)paren
op_eq
id|CMD_OK
)paren
)paren
(brace
id|bind_lcn_to_dev
(paren
id|card
comma
id|chan-&gt;dev
comma
id|new_lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x25_get_chan_conf
c_func
(paren
id|card
comma
id|chan
)paren
op_eq
id|CMD_OK
)paren
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_CONNECTED
)paren
suffix:semicolon
r_else
id|x25_clear_call
c_func
(paren
id|card
comma
id|new_lcn
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Handle accepted call.&n; *====================================================================*/
DECL|function|call_accepted
r_static
r_int
id|call_accepted
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|cmd
comma
r_int
id|lcn
comma
id|TX25Mbox
op_star
id|mb
)paren
(brace
r_int
id|new_lcn
op_assign
id|mb-&gt;cmd.lcn
suffix:semicolon
id|netdevice_t
op_star
id|dev
op_assign
id|find_channel
c_func
(paren
id|card
comma
id|new_lcn
)paren
suffix:semicolon
id|x25_channel_t
op_star
id|chan
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: clearing orphaned connection on LCN %d!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|new_lcn
)paren
suffix:semicolon
id|x25_clear_call
c_func
(paren
id|card
comma
id|new_lcn
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;u.x.logging
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: X.25 call accepted on Dev %s and LCN %d!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
comma
id|new_lcn
)paren
suffix:semicolon
multiline_comment|/* Get channel configuration and notify router */
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|x25_get_chan_conf
c_func
(paren
id|card
comma
id|chan
)paren
op_ne
id|CMD_OK
)paren
(brace
id|x25_clear_call
c_func
(paren
id|card
comma
id|new_lcn
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_CONNECTED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
id|send_delayed_cmd_result
c_func
(paren
id|card
comma
id|dev
comma
id|mb
)paren
suffix:semicolon
id|bind_lcn_to_dev
(paren
id|card
comma
id|dev
comma
id|new_lcn
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Handle cleared call.&n; *====================================================================*/
DECL|function|call_cleared
r_static
r_int
id|call_cleared
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|cmd
comma
r_int
id|lcn
comma
id|TX25Mbox
op_star
id|mb
)paren
(brace
r_int
id|new_lcn
op_assign
id|mb-&gt;cmd.lcn
suffix:semicolon
id|netdevice_t
op_star
id|dev
op_assign
id|find_channel
c_func
(paren
id|card
comma
id|new_lcn
)paren
suffix:semicolon
id|x25_channel_t
op_star
id|chan
suffix:semicolon
r_int
r_char
id|old_state
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.logging
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: X.25 clear request on LCN %d! Cause:0x%02X &quot;
l_string|&quot;Diagn:0x%02X&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|new_lcn
comma
id|mb-&gt;cmd.cause
comma
id|mb-&gt;cmd.diagn
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: X.25 clear request : No device for clear&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|old_state
op_assign
id|chan-&gt;common.state
suffix:semicolon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_DISCONNECTED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
r_switch
c_cond
(paren
id|old_state
)paren
(brace
r_case
id|WAN_CONNECTING
suffix:colon
id|send_delayed_cmd_result
c_func
(paren
id|card
comma
id|dev
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WAN_CONNECTED
suffix:colon
id|send_oob_msg
c_func
(paren
id|card
comma
id|dev
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
(paren
(paren
id|cmd
op_eq
id|X25_WRITE
)paren
op_logical_and
(paren
id|lcn
op_eq
id|new_lcn
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * &t;Handle X.25 restart event.&n; *====================================================================*/
DECL|function|restart_event
r_static
r_int
id|restart_event
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|cmd
comma
r_int
id|lcn
comma
id|TX25Mbox
op_star
id|mb
)paren
(brace
id|wan_device_t
op_star
id|wandev
op_assign
op_amp
id|card-&gt;wandev
suffix:semicolon
id|netdevice_t
op_star
id|dev
suffix:semicolon
id|x25_channel_t
op_star
id|chan
suffix:semicolon
r_int
r_char
id|old_state
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: X.25 restart request! Cause:0x%02X Diagn:0x%02X&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|mb-&gt;cmd.cause
comma
id|mb-&gt;cmd.diagn
)paren
suffix:semicolon
multiline_comment|/* down all logical channels */
r_for
c_loop
(paren
id|dev
op_assign
id|wandev-&gt;dev
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
op_star
(paren
(paren
id|netdevice_t
op_star
op_star
)paren
id|dev-&gt;priv
)paren
)paren
(brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|old_state
op_assign
id|chan-&gt;common.state
suffix:semicolon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_DISCONNECTED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
r_switch
c_cond
(paren
id|old_state
)paren
(brace
r_case
id|WAN_CONNECTING
suffix:colon
id|send_delayed_cmd_result
c_func
(paren
id|card
comma
id|dev
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WAN_CONNECTED
suffix:colon
id|send_oob_msg
c_func
(paren
id|card
comma
id|dev
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
(paren
id|cmd
op_eq
id|X25_WRITE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/*====================================================================&n; * Handle timeout event.&n; *====================================================================*/
DECL|function|timeout_event
r_static
r_int
id|timeout_event
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|cmd
comma
r_int
id|lcn
comma
id|TX25Mbox
op_star
id|mb
)paren
(brace
r_int
id|new_lcn
op_assign
id|mb-&gt;cmd.lcn
suffix:semicolon
r_if
c_cond
(paren
id|mb-&gt;cmd.pktType
op_eq
l_int|0x05
)paren
multiline_comment|/* call request time out */
(brace
id|netdevice_t
op_star
id|dev
op_assign
id|find_channel
c_func
(paren
id|card
comma
id|new_lcn
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: X.25 call timed timeout on LCN %d!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|new_lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_DISCONNECTED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
id|send_delayed_cmd_result
c_func
(paren
id|card
comma
id|dev
comma
id|card-&gt;mbox
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: X.25 packet 0x%02X timeout on LCN %d!&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|mb-&gt;cmd.pktType
comma
id|new_lcn
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Miscellaneous &n; */
multiline_comment|/*====================================================================&n; * &t;Establish physical connection.&n; * &t;o open HDLC and raise DTR&n; *&n; * &t;Return:&t;&t;0&t;connection established&n; *&t;&t;&t;1&t;connection is in progress&n; *&t;&t;&t;&lt;0&t;error&n; *===================================================================*/
DECL|function|connect
r_static
r_int
id|connect
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
id|x25_open_hdlc
c_func
(paren
id|card
)paren
op_logical_or
id|x25_setup_hdlc
c_func
(paren
id|card
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|wanpipe_set_state
c_func
(paren
id|card
comma
id|WAN_CONNECTING
)paren
suffix:semicolon
id|x25_set_intr_mode
c_func
(paren
id|card
comma
id|INTR_ON_TIMER
)paren
suffix:semicolon
id|status-&gt;imask
op_and_assign
op_complement
id|INTR_ON_TIMER
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Tear down physical connection.&n; * &t;o close HDLC link&n; * &t;o drop DTR&n; *&n; * &t;Return:&t;&t;0&n; *&t;&t;&t;&lt;0&t;error&n; */
DECL|function|disconnect
r_static
r_int
id|disconnect
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|wanpipe_set_state
c_func
(paren
id|card
comma
id|WAN_DISCONNECTED
)paren
suffix:semicolon
id|x25_set_intr_mode
c_func
(paren
id|card
comma
id|INTR_ON_TIMER
)paren
suffix:semicolon
multiline_comment|/* disable all interrupt except timer */
id|x25_close_hdlc
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* close HDLC link */
id|x25_set_dtr
c_func
(paren
id|card
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* drop DTR */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Find network device by its channel number.&n; */
DECL|function|get_dev_by_lcn
r_static
id|netdevice_t
op_star
id|get_dev_by_lcn
(paren
id|wan_device_t
op_star
id|wandev
comma
r_int
id|lcn
)paren
(brace
id|netdevice_t
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|wandev-&gt;dev
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
op_star
(paren
(paren
id|netdevice_t
op_star
op_star
)paren
id|dev-&gt;priv
)paren
)paren
r_if
c_cond
(paren
(paren
(paren
id|x25_channel_t
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|common.lcn
op_eq
id|lcn
)paren
r_break
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Initiate connection on the logical channel.&n; * &t;o for PVC we just get channel configuration&n; * &t;o for SVCs place an X.25 call&n; *&n; * &t;Return:&t;&t;0&t;connected&n; *&t;&t;&t;&gt;0&t;connection in progress&n; *&t;&t;&t;&lt;0&t;failure&n; */
DECL|function|chan_connect
r_static
r_int
id|chan_connect
(paren
id|netdevice_t
op_star
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.svc
op_logical_and
id|chan-&gt;common.usedby
op_eq
id|WANPIPE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|chan-&gt;addr
(braket
l_int|0
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: No Destination Address&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* no destination address */
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: placing X.25 call to %s ...&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|chan-&gt;addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x25_place_call
c_func
(paren
id|card
comma
id|chan
)paren
op_ne
id|CMD_OK
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_CONNECTING
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|x25_get_chan_conf
c_func
(paren
id|card
comma
id|chan
)paren
op_ne
id|CMD_OK
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_CONNECTED
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Disconnect logical channel.&n; * &t;o if SVC then clear X.25 call&n; */
DECL|function|chan_disc
r_static
r_int
id|chan_disc
(paren
id|netdevice_t
op_star
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.svc
)paren
(brace
id|x25_clear_call
c_func
(paren
id|chan-&gt;card
comma
id|chan-&gt;common.lcn
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* For API we disconnect on clear&n;                 * confirmation. &n;                 */
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_DISCONNECTED
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Set logical channel state.&n; */
DECL|function|set_chan_state
r_static
r_void
id|set_chan_state
(paren
id|netdevice_t
op_star
id|dev
comma
r_int
id|state
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.state
op_ne
id|state
)paren
(brace
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|WAN_CONNECTED
suffix:colon
r_if
c_cond
(paren
id|card-&gt;u.x.logging
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: interface %s connected, lcn %i !&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
comma
id|chan-&gt;common.lcn
)paren
suffix:semicolon
)brace
op_star
(paren
r_int
r_int
op_star
)paren
id|dev-&gt;dev_addr
op_assign
id|htons
c_func
(paren
id|chan-&gt;common.lcn
)paren
suffix:semicolon
id|chan-&gt;i_timeout_sofar
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* LAPB is PVC Based */
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
)paren
id|chan-&gt;common.svc
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WAN_CONNECTING
suffix:colon
r_if
c_cond
(paren
id|card-&gt;u.x.logging
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: interface %s connecting, lcn %i ...&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
comma
id|chan-&gt;common.lcn
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|WAN_DISCONNECTED
suffix:colon
r_if
c_cond
(paren
id|card-&gt;u.x.logging
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: interface %s disconnected, lcn %i !&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
comma
id|chan-&gt;common.lcn
)paren
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.disconnect
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.svc
)paren
(brace
op_star
(paren
r_int
r_int
op_star
)paren
id|dev-&gt;dev_addr
op_assign
l_int|0
suffix:semicolon
id|card-&gt;u.x.svc_to_dev_map
(braket
(paren
id|chan-&gt;common.lcn
op_mod
id|X25_MAX_CHAN
)paren
)braket
op_assign
l_int|NULL
suffix:semicolon
id|chan-&gt;common.lcn
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chan-&gt;transmit_length
)paren
(brace
id|chan-&gt;transmit_length
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.driver_busy
comma
l_int|0
)paren
suffix:semicolon
id|chan-&gt;tx_offset
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_queue_stopped
c_func
(paren
id|dev
)paren
)paren
(brace
id|wake_net_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.command
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WAN_DISCONNECTING
suffix:colon
r_if
c_cond
(paren
id|card-&gt;u.x.logging
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;&bslash;n%s: interface %s disconnecting, lcn %i ...&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
comma
id|chan-&gt;common.lcn
)paren
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.disconnect
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|chan-&gt;common.state
op_assign
id|state
suffix:semicolon
)brace
id|chan-&gt;state_tick
op_assign
id|jiffies
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Send packet on a logical channel.&n; *&t;&t;When this function is called, tx_skb field of the channel data &n; *&t;&t;space points to the transmit socket buffer.  When transmission &n; *&t;&t;is complete, release socket buffer and reset &squot;tbusy&squot; flag.&n; *&n; * &t;Return:&t;&t;0&t;- transmission complete&n; *&t;&t;&t;1&t;- busy&n; *&n; * &t;Notes:&n; * &t;1. If packet length is greater than MTU for this channel, we&squot;ll fragment&n; *    &t;the packet into &squot;complete sequence&squot; using M-bit.&n; * &t;2. When transmission is complete, an event notification should be issued&n; *    &t;to the router.&n; */
DECL|function|chan_send
r_static
r_int
id|chan_send
(paren
id|netdevice_t
op_star
id|dev
comma
r_void
op_star
id|buff
comma
r_int
id|data_len
comma
r_int
r_char
id|tx_intr
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
r_int
id|len
op_assign
l_int|0
comma
id|qdm
op_assign
l_int|0
comma
id|res
op_assign
l_int|0
comma
id|orig_len
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
multiline_comment|/* Check to see if channel is ready */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|status-&gt;cflags
(braket
id|chan-&gt;ch_idx
)braket
op_amp
l_int|0x40
)paren
op_logical_and
op_logical_neg
id|card-&gt;u.x.LAPB_hdlc
)paren
op_logical_or
op_logical_neg
(paren
op_star
id|card-&gt;u.x.hdlc_buf_status
op_amp
l_int|0x40
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tx_intr
)paren
(brace
id|setup_for_delayed_transmit
(paren
id|dev
comma
id|buff
comma
id|data_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* By returning 0 to tx_intr the packet will be dropped */
op_increment
id|card-&gt;wandev.stats.tx_dropped
suffix:semicolon
op_increment
id|chan-&gt;ifstats.tx_dropped
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: ERROR, Tx intr could not send, dropping %s:&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
)paren
suffix:semicolon
op_increment
id|chan-&gt;if_send_stat.if_send_bfr_not_passed_to_adptr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
multiline_comment|/* Remove the API Header */
id|x25api_hdr_t
op_star
id|api_data
op_assign
(paren
id|x25api_hdr_t
op_star
)paren
id|buff
suffix:semicolon
multiline_comment|/* Set the qdm bits from the packet header &n;                 * User has the option to set the qdm bits&n;                 */
id|qdm
op_assign
id|api_data-&gt;qdm
suffix:semicolon
id|orig_len
op_assign
id|len
op_assign
id|data_len
op_minus
r_sizeof
(paren
id|x25api_hdr_t
)paren
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|buff
op_plus
r_sizeof
(paren
id|x25api_hdr_t
)paren
suffix:semicolon
)brace
r_else
(brace
id|data
op_assign
id|buff
suffix:semicolon
id|orig_len
op_assign
id|len
op_assign
id|data_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_intr
)paren
(brace
multiline_comment|/* We are in tx_intr, minus the tx_offset from &n;                 * the total length. The tx_offset part of the&n;&t;&t; * data has already been sent. Also, move the &n;&t;&t; * data pointer to proper offset location.&n;                 */
id|len
op_sub_assign
id|chan-&gt;tx_offset
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|data
op_plus
id|chan-&gt;tx_offset
suffix:semicolon
)brace
multiline_comment|/* Check if the packet length is greater than MTU&n;         * If YES: Cut the len to MTU and set the M bit &n;         */
r_if
c_cond
(paren
id|len
OG
id|chan-&gt;tx_pkt_size
op_logical_and
op_logical_neg
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
id|len
op_assign
id|chan-&gt;tx_pkt_size
suffix:semicolon
id|qdm
op_or_assign
id|M_BIT
suffix:semicolon
)brace
multiline_comment|/* Pass only first three bits of the qdm byte to the send&n;         * routine. In case user sets any other bit which might&n;         * cause errors. &n;         */
r_switch
c_cond
(paren
id|x25_send
c_func
(paren
id|card
comma
id|chan-&gt;common.lcn
comma
(paren
id|qdm
op_amp
l_int|0x07
)paren
comma
id|len
comma
id|data
)paren
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/* success */
id|chan-&gt;i_timeout_sofar
op_assign
id|jiffies
suffix:semicolon
macro_line|#ifdef LINUX_2_4
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|qdm
op_amp
id|M_BIT
)paren
op_logical_and
op_logical_neg
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tx_intr
)paren
(brace
multiline_comment|/* The M bit was set, which means that part of the&n;                                         * packet has been sent. Copy the packet into a buffer&n;&t;&t;&t;&t;         * and set the offset to len, so on next tx_inter &n;&t;&t;&t;&t;&t; * the packet will be sent using the below offset.&n;&t;&t;&t;&t;&t; */
id|chan-&gt;tx_offset
op_add_assign
id|len
suffix:semicolon
op_increment
id|chan-&gt;ifstats.tx_packets
suffix:semicolon
macro_line|#if defined(LINUX_2_1) || defined(LINUX_2_4)
id|chan-&gt;ifstats.tx_bytes
op_add_assign
id|len
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|chan-&gt;tx_offset
OL
id|orig_len
)paren
(brace
id|setup_for_delayed_transmit
(paren
id|dev
comma
id|buff
comma
id|data_len
)paren
suffix:semicolon
)brace
id|res
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We are already in tx_inter, thus data is already&n;                                         * in the buffer. Update the offset and wait for&n;                                         * next tx_intr. We add on to the offset, since data can&n;                                         * be X number of times larger than max data size.&n;&t;&t;&t;&t;&t; */
op_increment
id|chan-&gt;ifstats.tx_packets
suffix:semicolon
macro_line|#if defined(LINUX_2_1) || defined(LINUX_2_4)
id|chan-&gt;ifstats.tx_bytes
op_add_assign
id|len
suffix:semicolon
macro_line|#endif
op_increment
id|chan-&gt;if_send_stat.if_send_bfr_passed_to_adptr
suffix:semicolon
id|chan-&gt;tx_offset
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* The user can set the qdm bit as well.&n;                                         * If the entire packet was sent and qdm is still&n;                                         * set, than it&squot;s the user who has set the M bit. In that,&n;                                         * case indicate that the packet was send by returning &n;&t;&t;&t;&t;&t; * 0 and wait for a new packet. Otherwise, wait for next&n;                                         * tx interrupt to send the rest of the packet */
r_if
c_cond
(paren
id|chan-&gt;tx_offset
OL
id|orig_len
)paren
(brace
id|res
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
op_increment
id|chan-&gt;ifstats.tx_packets
suffix:semicolon
macro_line|#if defined(LINUX_2_1) || defined(LINUX_2_4)
id|chan-&gt;ifstats.tx_bytes
op_add_assign
id|len
suffix:semicolon
macro_line|#endif
op_increment
id|chan-&gt;if_send_stat.if_send_bfr_passed_to_adptr
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x33
suffix:colon
multiline_comment|/* Tx busy */
r_if
c_cond
(paren
id|tx_intr
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Tx_intr: Big Error dropping packet %s&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
)paren
suffix:semicolon
op_increment
id|chan-&gt;ifstats.tx_dropped
suffix:semicolon
op_increment
id|card-&gt;wandev.stats.tx_dropped
suffix:semicolon
op_increment
id|chan-&gt;if_send_stat.if_send_bfr_not_passed_to_adptr
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Send: Big Error should have tx: storring %s&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|setup_for_delayed_transmit
(paren
id|dev
comma
id|buff
comma
id|data_len
)paren
suffix:semicolon
id|res
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* failure */
op_increment
id|chan-&gt;ifstats.tx_errors
suffix:semicolon
r_if
c_cond
(paren
id|tx_intr
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Tx_intr: Failure to send, dropping %s&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
)paren
suffix:semicolon
op_increment
id|chan-&gt;ifstats.tx_dropped
suffix:semicolon
op_increment
id|card-&gt;wandev.stats.tx_dropped
suffix:semicolon
op_increment
id|chan-&gt;if_send_stat.if_send_bfr_not_passed_to_adptr
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Send: Failure to send !!!, storing %s&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|setup_for_delayed_transmit
(paren
id|dev
comma
id|buff
comma
id|data_len
)paren
suffix:semicolon
id|res
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Parse X.25 call request data and fill x25_call_info_t structure.&n; */
DECL|function|parse_call_info
r_static
r_void
id|parse_call_info
(paren
r_int
r_char
op_star
id|str
comma
id|x25_call_info_t
op_star
id|info
)paren
(brace
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
id|x25_call_info_t
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|str
suffix:semicolon
op_increment
id|str
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
r_switch
c_cond
(paren
id|str
(braket
l_int|1
)braket
)paren
(brace
multiline_comment|/* Take minus 2 off the maximum size so that &n;                         * last byte is 0. This way we can use string&n;                         * manipulaton functions on call information.&n;                         */
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* destination address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|MAX_X25_ADDR_SIZE
op_minus
l_int|2
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ch
op_assign
id|str
(braket
l_int|2
op_plus
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|ch
)paren
)paren
r_break
suffix:semicolon
id|info-&gt;dest
(braket
id|i
)braket
op_assign
id|ch
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
multiline_comment|/* source address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|MAX_X25_ADDR_SIZE
op_minus
l_int|2
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ch
op_assign
id|str
(braket
l_int|2
op_plus
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|ch
)paren
)paren
r_break
suffix:semicolon
id|info-&gt;src
(braket
id|i
)braket
op_assign
id|ch
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
multiline_comment|/* user data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|MAX_X25_DATA_SIZE
op_minus
l_int|2
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ch
op_assign
id|str
(braket
l_int|2
op_plus
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|ch
)paren
)paren
r_break
suffix:semicolon
id|info-&gt;user
(braket
id|i
)braket
op_assign
id|ch
suffix:semicolon
)brace
id|info-&gt;nuser
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;f&squot;
suffix:colon
multiline_comment|/* facilities */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|MAX_X25_FACL_SIZE
op_minus
l_int|2
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ch
op_assign
id|str
(braket
l_int|2
op_plus
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|isspace
c_func
(paren
id|ch
)paren
)paren
r_break
suffix:semicolon
id|info-&gt;facil
(braket
id|i
)braket
op_assign
id|ch
suffix:semicolon
)brace
id|info-&gt;nfacil
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * &t;Convert line speed in bps to a number used by S502 code.&n; */
DECL|function|bps_to_speed_code
r_static
r_int
r_char
id|bps_to_speed_code
(paren
r_int
r_int
id|bps
)paren
(brace
r_int
r_char
id|number
suffix:semicolon
r_if
c_cond
(paren
id|bps
op_le
l_int|1200
)paren
id|number
op_assign
l_int|0x01
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bps
op_le
l_int|2400
)paren
id|number
op_assign
l_int|0x02
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bps
op_le
l_int|4800
)paren
id|number
op_assign
l_int|0x03
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bps
op_le
l_int|9600
)paren
id|number
op_assign
l_int|0x04
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bps
op_le
l_int|19200
)paren
id|number
op_assign
l_int|0x05
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bps
op_le
l_int|38400
)paren
id|number
op_assign
l_int|0x06
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bps
op_le
l_int|45000
)paren
id|number
op_assign
l_int|0x07
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bps
op_le
l_int|56000
)paren
id|number
op_assign
l_int|0x08
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bps
op_le
l_int|64000
)paren
id|number
op_assign
l_int|0x09
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bps
op_le
l_int|74000
)paren
id|number
op_assign
l_int|0x0A
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bps
op_le
l_int|112000
)paren
id|number
op_assign
l_int|0x0B
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bps
op_le
l_int|128000
)paren
id|number
op_assign
l_int|0x0C
suffix:semicolon
r_else
id|number
op_assign
l_int|0x0D
suffix:semicolon
r_return
id|number
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Convert decimal string to unsigned integer.&n; * &t;If len != 0 then only &squot;len&squot; characters of the string are converted.&n; */
DECL|function|dec_to_uint
r_static
r_int
r_int
id|dec_to_uint
(paren
r_int
r_char
op_star
id|str
comma
r_int
id|len
)paren
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
id|len
op_assign
id|strlen
c_func
(paren
id|str
)paren
suffix:semicolon
r_for
c_loop
(paren
id|val
op_assign
l_int|0
suffix:semicolon
id|len
op_logical_and
id|is_digit
c_func
(paren
op_star
id|str
)paren
suffix:semicolon
op_increment
id|str
comma
op_decrement
id|len
)paren
id|val
op_assign
(paren
id|val
op_star
l_int|10
)paren
op_plus
(paren
op_star
id|str
op_minus
(paren
r_int
)paren
l_char|&squot;0&squot;
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Convert hex string to unsigned integer.&n; * &t;If len != 0 then only &squot;len&squot; characters of the string are conferted.&n; */
DECL|function|hex_to_uint
r_static
r_int
r_int
id|hex_to_uint
(paren
r_int
r_char
op_star
id|str
comma
r_int
id|len
)paren
(brace
r_int
id|val
comma
id|ch
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
id|len
op_assign
id|strlen
c_func
(paren
id|str
)paren
suffix:semicolon
r_for
c_loop
(paren
id|val
op_assign
l_int|0
suffix:semicolon
id|len
suffix:semicolon
op_increment
id|str
comma
op_decrement
id|len
)paren
(brace
id|ch
op_assign
op_star
id|str
suffix:semicolon
r_if
c_cond
(paren
id|is_digit
c_func
(paren
id|ch
)paren
)paren
id|val
op_assign
(paren
id|val
op_lshift
l_int|4
)paren
op_plus
(paren
id|ch
op_minus
(paren
r_int
)paren
l_char|&squot;0&squot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|is_hex_digit
c_func
(paren
id|ch
)paren
)paren
id|val
op_assign
(paren
id|val
op_lshift
l_int|4
)paren
op_plus
(paren
(paren
id|ch
op_amp
l_int|0xDF
)paren
op_minus
(paren
r_int
)paren
l_char|&squot;A&squot;
op_plus
l_int|10
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
r_return
id|val
suffix:semicolon
)brace
DECL|function|handle_IPXWAN
r_static
r_int
id|handle_IPXWAN
c_func
(paren
r_int
r_char
op_star
id|sendpacket
comma
r_char
op_star
id|devname
comma
r_int
r_char
id|enable_IPX
comma
r_int
r_int
id|network_number
comma
r_int
r_int
id|proto
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|proto
op_eq
id|ETH_P_IPX
)paren
(brace
multiline_comment|/* It&squot;s an IPX packet */
r_if
c_cond
(paren
op_logical_neg
id|enable_IPX
)paren
(brace
multiline_comment|/* Return 1 so we don&squot;t pass it up the stack. */
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* It&squot;s not IPX so pass it up the stack.*/
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sendpacket
(braket
l_int|16
)braket
op_eq
l_int|0x90
op_logical_and
id|sendpacket
(braket
l_int|17
)braket
op_eq
l_int|0x04
)paren
(brace
multiline_comment|/* It&squot;s IPXWAN  */
r_if
c_cond
(paren
id|sendpacket
(braket
l_int|2
)braket
op_eq
l_int|0x02
op_logical_and
id|sendpacket
(braket
l_int|34
)braket
op_eq
l_int|0x00
)paren
(brace
multiline_comment|/* It&squot;s a timer request packet */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Received IPXWAN Timer Request packet&bslash;n&quot;
comma
id|devname
)paren
suffix:semicolon
multiline_comment|/* Go through the routing options and answer no to every&n;&t;&t;&t; * option except Unnumbered RIP/SAP&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|41
suffix:semicolon
id|sendpacket
(braket
id|i
)braket
op_eq
l_int|0x00
suffix:semicolon
id|i
op_add_assign
l_int|5
)paren
(brace
multiline_comment|/* 0x02 is the option for Unnumbered RIP/SAP */
r_if
c_cond
(paren
id|sendpacket
(braket
id|i
op_plus
l_int|4
)braket
op_ne
l_int|0x02
)paren
(brace
id|sendpacket
(braket
id|i
op_plus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Skip over the extended Node ID option */
r_if
c_cond
(paren
id|sendpacket
(braket
id|i
)braket
op_eq
l_int|0x04
)paren
(brace
id|i
op_add_assign
l_int|8
suffix:semicolon
)brace
multiline_comment|/* We also want to turn off all header compression opt. &t;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|sendpacket
(braket
id|i
)braket
op_eq
l_int|0x80
suffix:semicolon
)paren
(brace
id|sendpacket
(braket
id|i
op_plus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|i
op_add_assign
(paren
id|sendpacket
(braket
id|i
op_plus
l_int|2
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
id|sendpacket
(braket
id|i
op_plus
l_int|3
)braket
)paren
op_plus
l_int|4
suffix:semicolon
)brace
multiline_comment|/* Set the packet type to timer response */
id|sendpacket
(braket
l_int|34
)braket
op_assign
l_int|0x01
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Sending IPXWAN Timer Response&bslash;n&quot;
comma
id|devname
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sendpacket
(braket
l_int|34
)braket
op_eq
l_int|0x02
)paren
(brace
multiline_comment|/* This is an information request packet */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Received IPXWAN Information Request packet&bslash;n&quot;
comma
id|devname
)paren
suffix:semicolon
multiline_comment|/* Set the packet type to information response */
id|sendpacket
(braket
l_int|34
)braket
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* Set the router name */
id|sendpacket
(braket
l_int|51
)braket
op_assign
l_char|&squot;X&squot;
suffix:semicolon
id|sendpacket
(braket
l_int|52
)braket
op_assign
l_char|&squot;T&squot;
suffix:semicolon
id|sendpacket
(braket
l_int|53
)braket
op_assign
l_char|&squot;P&squot;
suffix:semicolon
id|sendpacket
(braket
l_int|54
)braket
op_assign
l_char|&squot;I&squot;
suffix:semicolon
id|sendpacket
(braket
l_int|55
)braket
op_assign
l_char|&squot;P&squot;
suffix:semicolon
id|sendpacket
(braket
l_int|56
)braket
op_assign
l_char|&squot;E&squot;
suffix:semicolon
id|sendpacket
(braket
l_int|57
)braket
op_assign
l_char|&squot;-&squot;
suffix:semicolon
id|sendpacket
(braket
l_int|58
)braket
op_assign
id|CVHexToAscii
c_func
(paren
id|network_number
op_rshift
l_int|28
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|59
)braket
op_assign
id|CVHexToAscii
c_func
(paren
(paren
id|network_number
op_amp
l_int|0x0F000000
)paren
op_rshift
l_int|24
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|60
)braket
op_assign
id|CVHexToAscii
c_func
(paren
(paren
id|network_number
op_amp
l_int|0x00F00000
)paren
op_rshift
l_int|20
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|61
)braket
op_assign
id|CVHexToAscii
c_func
(paren
(paren
id|network_number
op_amp
l_int|0x000F0000
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|62
)braket
op_assign
id|CVHexToAscii
c_func
(paren
(paren
id|network_number
op_amp
l_int|0x0000F000
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|63
)braket
op_assign
id|CVHexToAscii
c_func
(paren
(paren
id|network_number
op_amp
l_int|0x00000F00
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|64
)braket
op_assign
id|CVHexToAscii
c_func
(paren
(paren
id|network_number
op_amp
l_int|0x000000F0
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|65
)braket
op_assign
id|CVHexToAscii
c_func
(paren
id|network_number
op_amp
l_int|0x0000000F
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|66
suffix:semicolon
id|i
OL
l_int|99
suffix:semicolon
id|i
op_add_assign
l_int|1
)paren
(brace
id|sendpacket
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Sending IPXWAN Information Response packet&bslash;n&quot;
comma
id|devname
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Unknown IPXWAN packet!&bslash;n&quot;
comma
id|devname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Set the WNodeID to our network address */
id|sendpacket
(braket
l_int|35
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|network_number
op_rshift
l_int|24
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|36
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|network_number
op_amp
l_int|0x00FF0000
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|37
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|network_number
op_amp
l_int|0x0000FF00
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|38
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|network_number
op_amp
l_int|0x000000FF
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*If we get here its an IPX-data packet, so it&squot;ll get passed up the stack.&n;&t;&t; */
multiline_comment|/* switch the network numbers */
id|switch_net_numbers
c_func
(paren
id|sendpacket
comma
id|network_number
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  &t;If incoming is 0 (outgoing)- if the net numbers is ours make it 0&n; *  &t;if incoming is 1 - if the net number is 0 make it ours &n; */
DECL|function|switch_net_numbers
r_static
r_void
id|switch_net_numbers
c_func
(paren
r_int
r_char
op_star
id|sendpacket
comma
r_int
r_int
id|network_number
comma
r_int
r_char
id|incoming
)paren
(brace
r_int
r_int
id|pnetwork_number
suffix:semicolon
id|pnetwork_number
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
id|sendpacket
(braket
l_int|6
)braket
op_lshift
l_int|24
)paren
op_plus
(paren
id|sendpacket
(braket
l_int|7
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|sendpacket
(braket
l_int|8
)braket
op_lshift
l_int|8
)paren
op_plus
id|sendpacket
(braket
l_int|9
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|incoming
)paren
(brace
multiline_comment|/*If the destination network number is ours, make it 0 */
r_if
c_cond
(paren
id|pnetwork_number
op_eq
id|network_number
)paren
(brace
id|sendpacket
(braket
l_int|6
)braket
op_assign
id|sendpacket
(braket
l_int|7
)braket
op_assign
id|sendpacket
(braket
l_int|8
)braket
op_assign
id|sendpacket
(braket
l_int|9
)braket
op_assign
l_int|0x00
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* If the incoming network is 0, make it ours */
r_if
c_cond
(paren
id|pnetwork_number
op_eq
l_int|0
)paren
(brace
id|sendpacket
(braket
l_int|6
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|network_number
op_rshift
l_int|24
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|7
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|network_number
op_amp
l_int|0x00FF0000
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|8
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|network_number
op_amp
l_int|0x0000FF00
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|9
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|network_number
op_amp
l_int|0x000000FF
)paren
suffix:semicolon
)brace
)brace
id|pnetwork_number
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
id|sendpacket
(braket
l_int|18
)braket
op_lshift
l_int|24
)paren
op_plus
(paren
id|sendpacket
(braket
l_int|19
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|sendpacket
(braket
l_int|20
)braket
op_lshift
l_int|8
)paren
op_plus
id|sendpacket
(braket
l_int|21
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|incoming
)paren
(brace
multiline_comment|/* If the source network is ours, make it 0 */
r_if
c_cond
(paren
id|pnetwork_number
op_eq
id|network_number
)paren
(brace
id|sendpacket
(braket
l_int|18
)braket
op_assign
id|sendpacket
(braket
l_int|19
)braket
op_assign
id|sendpacket
(braket
l_int|20
)braket
op_assign
id|sendpacket
(braket
l_int|21
)braket
op_assign
l_int|0x00
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* If the source network is 0, make it ours */
r_if
c_cond
(paren
id|pnetwork_number
op_eq
l_int|0
)paren
(brace
id|sendpacket
(braket
l_int|18
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|network_number
op_rshift
l_int|24
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|19
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|network_number
op_amp
l_int|0x00FF0000
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|20
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|network_number
op_amp
l_int|0x0000FF00
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|sendpacket
(braket
l_int|21
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|network_number
op_amp
l_int|0x000000FF
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* switch_net_numbers */
multiline_comment|/********************* X25API SPECIFIC FUNCTIONS ****************/
multiline_comment|/*===============================================================&n; *  find_channel&n; *&n; *&t;Manages the lcn to device map. It increases performance&n; *      because it eliminates the need to search through the link  &n; *      list for a device which is bounded to a specific lcn.&n; *&n; *===============================================================*/
DECL|function|find_channel
id|netdevice_t
op_star
id|find_channel
c_func
(paren
id|sdla_t
op_star
id|card
comma
r_int
id|lcn
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
r_return
id|card-&gt;wandev.dev
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We don&squot;t know whether the incoming lcn&n;                 * is a PVC or an SVC channel. But we do know that&n;                 * the lcn cannot be for both the PVC and the SVC&n;                 * channel.&n;&n;&t;&t; * If the lcn number is greater or equal to 255, &n;                 * take the modulo 255 of that number. We only have&n;                 * 255 locations, thus higher numbers must be mapped&n;                 * to a number between 0 and 245. &n;&n;&t;&t; * We must separate pvc&squot;s and svc&squot;s since two don&squot;t&n;                 * have to be contiguous.  Meaning pvc&squot;s can start&n;                 * from 1 to 10 and svc&squot;s can start from 256 to 266.&n;                 * But 256%255 is 1, i.e. CONFLICT.&n;&t;&t; */
multiline_comment|/* Highest LCN number must be less or equal to 4096 */
r_if
c_cond
(paren
(paren
id|lcn
op_le
id|MAX_LCN_NUM
)paren
op_logical_and
(paren
id|lcn
OG
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|lcn
OL
id|X25_MAX_CHAN
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;u.x.svc_to_dev_map
(braket
id|lcn
)braket
)paren
r_return
id|card-&gt;u.x.svc_to_dev_map
(braket
id|lcn
)braket
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.pvc_to_dev_map
(braket
id|lcn
)braket
)paren
r_return
id|card-&gt;u.x.pvc_to_dev_map
(braket
id|lcn
)braket
suffix:semicolon
)brace
r_else
(brace
r_int
id|new_lcn
op_assign
id|lcn
op_mod
id|X25_MAX_CHAN
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.svc_to_dev_map
(braket
id|new_lcn
)braket
)paren
r_return
id|card-&gt;u.x.svc_to_dev_map
(braket
id|new_lcn
)braket
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.pvc_to_dev_map
(braket
id|new_lcn
)braket
)paren
r_return
id|card-&gt;u.x.pvc_to_dev_map
(braket
id|new_lcn
)braket
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|bind_lcn_to_dev
r_void
id|bind_lcn_to_dev
(paren
id|sdla_t
op_star
id|card
comma
id|netdevice_t
op_star
id|dev
comma
r_int
id|lcn
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Modulo the lcn number by X25_MAX_CHAN (255)&n;&t; * because the lcn number can be greater than 255 &n;         *&n;&t; * We need to split svc and pvc since they don&squot;t have&n;         * to be contigous. &n;&t; */
r_if
c_cond
(paren
id|chan-&gt;common.svc
)paren
(brace
id|card-&gt;u.x.svc_to_dev_map
(braket
(paren
id|lcn
op_mod
id|X25_MAX_CHAN
)paren
)braket
op_assign
id|dev
suffix:semicolon
)brace
r_else
(brace
id|card-&gt;u.x.pvc_to_dev_map
(braket
(paren
id|lcn
op_mod
id|X25_MAX_CHAN
)paren
)braket
op_assign
id|dev
suffix:semicolon
)brace
id|chan-&gt;common.lcn
op_assign
id|lcn
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * x25api_bh &n; *&n; *&n; *==============================================================*/
DECL|function|x25api_bh
r_static
r_void
id|x25api_bh
(paren
id|netdevice_t
op_star
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;bh_buff_used
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: BH Buffer Empty in BH&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|chan-&gt;tq_working
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;bh_buff_used
)paren
)paren
(brace
multiline_comment|/* If the sock is in the process of unlinking the&n;&t;&t; * driver from the socket, we must get out. &n;&t;&t; * This never happends but is a sanity check. */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
l_int|0
comma
op_amp
id|chan-&gt;common.common_critical
)paren
)paren
(brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|chan-&gt;tq_working
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If LAPB HDLC, do not drop packets if socket is&n;                 * not connected.  Let the buffer fill up and&n;                 * turn off rx interrupt */
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
r_if
c_cond
(paren
id|chan-&gt;common.sk
op_eq
l_int|NULL
op_logical_or
id|chan-&gt;common.func
op_eq
l_int|NULL
)paren
(brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|chan-&gt;tq_working
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|skb
op_assign
(paren
(paren
id|bh_data_t
op_star
)paren
op_amp
id|chan-&gt;bh_head
(braket
id|chan-&gt;bh_read
)braket
)paren
op_member_access_from_pointer
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: BH Skb empty for read %i&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|chan-&gt;bh_read
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|chan-&gt;common.sk
op_eq
l_int|NULL
op_logical_or
id|chan-&gt;common.func
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: BH: Socket disconnected, dropping&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|wan_dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|x25api_bh_cleanup
c_func
(paren
id|dev
)paren
suffix:semicolon
op_increment
id|chan-&gt;ifstats.rx_dropped
suffix:semicolon
op_increment
id|chan-&gt;rx_intr_stat.rx_intr_bfr_not_passed_to_stack
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chan-&gt;common
dot
id|func
c_func
(paren
id|skb
comma
id|dev
comma
id|chan-&gt;common.sk
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Sock full cannot send, queue us for another&n;                                 * try &n;&t;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: BH: !!! Packet failed to send !!!!! &bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.receive_block
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|x25api_bh_cleanup
c_func
(paren
id|dev
)paren
suffix:semicolon
op_increment
id|chan-&gt;rx_intr_stat.rx_intr_bfr_passed_to_stack
suffix:semicolon
)brace
)brace
)brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|chan-&gt;tq_working
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * x25api_bh_cleanup &n; *&n; *&n; *==============================================================*/
DECL|function|x25api_bh_cleanup
r_static
r_int
id|x25api_bh_cleanup
(paren
id|netdevice_t
op_star
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
(paren
(paren
id|bh_data_t
op_star
)paren
op_amp
id|chan-&gt;bh_head
(braket
id|chan-&gt;bh_read
)braket
)paren
op_member_access_from_pointer
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;bh_read
op_eq
id|MAX_BH_BUFF
)paren
(brace
id|chan-&gt;bh_read
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_increment
id|chan-&gt;bh_read
suffix:semicolon
)brace
multiline_comment|/* If the Receive interrupt was off, it means&n;         * that we filled up our circular buffer. Check    &n;         * that we have space in the buffer. If so &n;         * turn the RX interrupt back on. &n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status-&gt;imask
op_amp
id|INTR_ON_RX_FRAME
)paren
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;bh_buff_used
)paren
OL
(paren
id|MAX_BH_BUFF
op_plus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: BH: Turning on the interrupt&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|status-&gt;imask
op_or_assign
id|INTR_ON_RX_FRAME
suffix:semicolon
)brace
)brace
id|atomic_dec
c_func
(paren
op_amp
id|chan-&gt;bh_buff_used
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * bh_enqueue &n; *&n; *&n; *==============================================================*/
DECL|function|bh_enqueue
r_static
r_int
id|bh_enqueue
(paren
id|netdevice_t
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|sdla_t
op_star
id|card
op_assign
id|chan-&gt;card
suffix:semicolon
id|TX25Status
op_star
id|status
op_assign
id|card-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;bh_buff_used
)paren
op_eq
(paren
id|MAX_BH_BUFF
op_plus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Bottom half buffer FULL&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
(paren
(paren
id|bh_data_t
op_star
)paren
op_amp
id|chan-&gt;bh_head
(braket
id|chan-&gt;bh_write
)braket
)paren
op_member_access_from_pointer
id|skb
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;bh_write
op_eq
id|MAX_BH_BUFF
)paren
(brace
id|chan-&gt;bh_write
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_increment
id|chan-&gt;bh_write
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|chan-&gt;bh_buff_used
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;bh_buff_used
)paren
op_eq
(paren
id|MAX_BH_BUFF
op_plus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Buffer is now full, Turning off RX Intr&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|status-&gt;imask
op_and_assign
op_complement
id|INTR_ON_RX_FRAME
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * timer_intr_cmd_exec&n; *  &n; *&t;Called by timer interrupt to execute a command&n; *===============================================================*/
DECL|function|timer_intr_cmd_exec
r_static
r_int
id|timer_intr_cmd_exec
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|netdevice_t
op_star
id|dev
suffix:semicolon
r_int
r_char
id|more_to_exec
op_assign
l_int|0
suffix:semicolon
r_volatile
id|x25_channel_t
op_star
id|chan
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|bad_cmd
op_assign
l_int|0
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.cmd_dev
op_eq
l_int|NULL
)paren
(brace
id|card-&gt;u.x.cmd_dev
op_assign
id|card-&gt;wandev.dev
suffix:semicolon
)brace
id|dev
op_assign
id|card-&gt;u.x.cmd_dev
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;common.command
)paren
)paren
(brace
id|bad_cmd
op_assign
id|check_bad_command
c_func
(paren
id|card
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|chan-&gt;common.mbox
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;common.disconnect
)paren
)paren
op_logical_and
op_logical_neg
id|bad_cmd
)paren
(brace
multiline_comment|/* Socket has died or exited, We must bring the&n;                                 * channel down before anybody else tries to &n;                                 * use it */
id|err
op_assign
id|channel_disconnect
c_func
(paren
id|card
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|err
op_assign
id|execute_delayed_cmd
c_func
(paren
id|card
comma
id|dev
comma
(paren
id|mbox_cmd_t
op_star
)paren
id|chan-&gt;common.mbox
comma
id|bad_cmd
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|err
)paren
(brace
r_case
id|RETURN_RESULT
suffix:colon
multiline_comment|/* Return the result to the socket without&n;                                 * delay. NO_WAIT Command */
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.command
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
)paren
)paren
id|atomic_set
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
comma
l_int|0
)paren
suffix:semicolon
id|send_delayed_cmd_result
c_func
(paren
id|card
comma
id|dev
comma
id|card-&gt;mbox
)paren
suffix:semicolon
id|more_to_exec
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DELAY_RESULT
suffix:colon
multiline_comment|/* Wait for the remote to respond, before&n;                                 * sending the result up to the socket.&n;                                 * WAIT command */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
)paren
)paren
id|atomic_set
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.command
comma
l_int|0
)paren
suffix:semicolon
id|more_to_exec
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* If command could not be executed for&n;                                 * some reason (i.e return code 0x33 busy)&n;                                 * set the more_to_exec bit which will&n;                                 * indicate that this command must be exectued&n;                                 * again during next timer interrupt &n;&t;&t;&t;&t; */
id|more_to_exec
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
)paren
op_eq
l_int|0
)paren
id|atomic_set
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bad_cmd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If flags is set, there are no hdlc buffers,&n;                         * thus, wait for the next pass and try the&n;                         * same command again. Otherwise, start searching &n;                         * from next device on the next pass. &n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|more_to_exec
)paren
(brace
id|dev
op_assign
id|move_dev_to_next
c_func
(paren
id|card
comma
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This device has nothing to execute,&n;                         * go to next. &n;&t;&t;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
)paren
)paren
id|atomic_set
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
comma
l_int|0
)paren
suffix:semicolon
id|dev
op_assign
id|move_dev_to_next
c_func
(paren
id|card
comma
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|i
op_eq
id|card-&gt;u.x.no_dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|more_to_exec
)paren
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Nothing to execute in Timer&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
)paren
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|card-&gt;u.x.command_busy
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
singleline_comment|//End of FOR
id|card-&gt;u.x.cmd_dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|more_to_exec
)paren
(brace
multiline_comment|/* If more commands are pending, do not turn off timer &n;                 * interrupt */
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No more commands, turn off timer interrupt */
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*===============================================================&n; * execute_delayed_cmd &n; *&n; *&t;Execute an API command which was passed down from the&n; *      sock.  Sock is very limited in which commands it can&n; *      execute.  Wait and No Wait commands are supported.  &n; *      Place Call, Clear Call and Reset wait commands, where&n; *      Accept Call is a no_wait command.&n; *&n; *===============================================================*/
DECL|function|execute_delayed_cmd
r_static
r_int
id|execute_delayed_cmd
(paren
id|sdla_t
op_star
id|card
comma
id|netdevice_t
op_star
id|dev
comma
id|mbox_cmd_t
op_star
id|usr_cmd
comma
r_char
id|bad_cmd
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|err
suffix:semicolon
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|delay
op_assign
id|RETURN_RESULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|card-&gt;u.x.hdlc_buf_status
op_amp
l_int|0x40
)paren
op_logical_and
op_logical_neg
id|bad_cmd
)paren
(brace
r_return
id|TRY_CMD_AGAIN
suffix:semicolon
)brace
multiline_comment|/* This way a command is guaranteed to be executed for&n;         * a specific lcn, the network interface is bound to. */
id|usr_cmd-&gt;cmd.lcn
op_assign
id|chan-&gt;common.lcn
suffix:semicolon
multiline_comment|/* If channel is pvc, instead of place call&n;         * run x25_channel configuration. If running LAPB HDLC&n;         * enable communications. &n;         */
r_if
c_cond
(paren
(paren
op_logical_neg
id|chan-&gt;common.svc
)paren
op_logical_and
(paren
id|usr_cmd-&gt;cmd.command
op_eq
id|X25_PLACE_CALL
)paren
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;LAPB: Connecting&bslash;n&quot;
)paren
suffix:semicolon
id|connect
c_func
(paren
id|card
)paren
suffix:semicolon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_CONNECTING
)paren
suffix:semicolon
r_return
id|DELAY_RESULT
suffix:semicolon
)brace
r_else
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: PVC is CONNECTING&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x25_get_chan_conf
c_func
(paren
id|card
comma
id|chan
)paren
op_eq
id|CMD_OK
)paren
(brace
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_CONNECTED
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_DISCONNECTED
)paren
suffix:semicolon
)brace
r_return
id|RETURN_RESULT
suffix:semicolon
)brace
)brace
multiline_comment|/* Copy the socket mbox command onto the board */
id|memcpy
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
op_amp
id|usr_cmd-&gt;cmd
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usr_cmd-&gt;cmd.length
)paren
(brace
id|memcpy
c_func
(paren
id|mbox-&gt;data
comma
id|usr_cmd-&gt;data
comma
id|usr_cmd-&gt;cmd.length
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if command is bad. We need to copy the cmd into&n;         * the buffer regardless since we return the, mbox to&n;         * the user */
r_if
c_cond
(paren
id|bad_cmd
)paren
(brace
id|mbox-&gt;cmd.result
op_assign
l_int|0x01
suffix:semicolon
r_return
id|RETURN_RESULT
suffix:semicolon
)brace
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|CMD_OK
op_logical_and
id|err
op_ne
id|X25RES_NOT_READY
)paren
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|usr_cmd-&gt;cmd.command
comma
id|usr_cmd-&gt;cmd.lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mbox-&gt;cmd.result
op_eq
id|X25RES_NOT_READY
)paren
(brace
r_return
id|TRY_CMD_AGAIN
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|mbox-&gt;cmd.command
)paren
(brace
r_case
id|X25_PLACE_CALL
suffix:colon
r_switch
c_cond
(paren
id|mbox-&gt;cmd.result
)paren
(brace
r_case
id|CMD_OK
suffix:colon
multiline_comment|/* Check if Place call is a wait command or a &n;               &t;  &t; * no wait command */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;common.command
)paren
op_amp
l_int|0x80
)paren
id|delay
op_assign
id|RETURN_RESULT
suffix:semicolon
r_else
id|delay
op_assign
id|DELAY_RESULT
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;n%s: PLACE CALL Binding dev %s to lcn %i&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
comma
id|mbox-&gt;cmd.lcn
)paren
suffix:semicolon
id|bind_lcn_to_dev
(paren
id|card
comma
id|dev
comma
id|mbox-&gt;cmd.lcn
)paren
suffix:semicolon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_CONNECTING
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|delay
op_assign
id|RETURN_RESULT
suffix:semicolon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_DISCONNECTED
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|X25_ACCEPT_CALL
suffix:colon
r_switch
c_cond
(paren
id|mbox-&gt;cmd.result
)paren
(brace
r_case
id|CMD_OK
suffix:colon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;n%s: ACCEPT Binding dev %s to lcn %i&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
comma
id|mbox-&gt;cmd.lcn
)paren
suffix:semicolon
id|bind_lcn_to_dev
(paren
id|card
comma
id|dev
comma
id|mbox-&gt;cmd.lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x25_get_chan_conf
c_func
(paren
id|card
comma
id|chan
)paren
op_eq
id|CMD_OK
)paren
(brace
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_CONNECTED
)paren
suffix:semicolon
id|delay
op_assign
id|RETURN_RESULT
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|x25_clear_call
c_func
(paren
id|card
comma
id|usr_cmd-&gt;cmd.lcn
comma
l_int|0
comma
l_int|0
)paren
op_eq
id|CMD_OK
)paren
(brace
multiline_comment|/* if clear is successful, wait for clear confirm &n;&t;&t;&t;&t;&t; */
id|delay
op_assign
id|DELAY_RESULT
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Do not change the state here. If we fail &n;&t;&t;&t;&t;&t; * the accept the return code is send up &n;&t;&t;&t;&t;&t; *the stack, which will ether retry&n;                               &t;  &t; * or clear the call &n;&t;&t;&t;&t;&t; */
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: ACCEPT: STATE MAY BE CURRUPTED 2 !!!!!&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|delay
op_assign
id|RETURN_RESULT
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|X25RES_ASYNC_PACKET
suffix:colon
id|delay
op_assign
id|TRY_CMD_AGAIN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: ACCEPT FAILED&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x25_clear_call
c_func
(paren
id|card
comma
id|usr_cmd-&gt;cmd.lcn
comma
l_int|0
comma
l_int|0
)paren
op_eq
id|CMD_OK
)paren
(brace
id|delay
op_assign
id|DELAY_RESULT
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Do not change the state here. If we fail the accept. The&n;                                 * return code is send up the stack, which will ether retry&n;                                 * or clear the call */
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: ACCEPT: STATE MAY BE CORRUPTED 1 !!!!!&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|delay
op_assign
id|RETURN_RESULT
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|X25_CLEAR_CALL
suffix:colon
r_switch
c_cond
(paren
id|mbox-&gt;cmd.result
)paren
(brace
r_case
id|CMD_OK
suffix:colon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;CALL CLEAR OK: Dev %s Mbox Lcn %i  Chan Lcn %i&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|mbox-&gt;cmd.lcn
comma
id|chan-&gt;common.lcn
)paren
suffix:semicolon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_DISCONNECTING
)paren
suffix:semicolon
id|delay
op_assign
id|DELAY_RESULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|X25RES_CHANNEL_IN_USE
suffix:colon
r_case
id|X25RES_ASYNC_PACKET
suffix:colon
id|delay
op_assign
id|TRY_CMD_AGAIN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|X25RES_LINK_NOT_IN_ABM
suffix:colon
r_case
id|X25RES_INVAL_LCN
suffix:colon
r_case
id|X25RES_INVAL_STATE
suffix:colon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_DISCONNECTED
)paren
suffix:semicolon
id|delay
op_assign
id|RETURN_RESULT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* If command did not execute because of user&n;                         * fault, do not change the state. This will&n;                         * signal the socket that clear command failed.&n;                         * User can retry or close the socket.&n;                         * When socket gets killed, it will set the &n;                         * chan-&gt;disconnect which will signal&n;                         * driver to clear the call */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Clear Command Failed, Rc %x&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|mbox-&gt;cmd.command
)paren
suffix:semicolon
id|delay
op_assign
id|RETURN_RESULT
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|delay
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * api_incoming_call &n; *&n; *&t;Pass an incoming call request up the the listening&n; *      sock.  If the API sock is not listening reject the&n; *      call.&n; *&n; *===============================================================*/
DECL|function|api_incoming_call
r_static
r_int
id|api_incoming_call
(paren
id|sdla_t
op_star
id|card
comma
id|TX25Mbox
op_star
id|mbox
comma
r_int
id|lcn
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|len
op_assign
r_sizeof
(paren
id|TX25Cmd
)paren
op_plus
id|mbox-&gt;cmd.length
suffix:semicolon
r_if
c_cond
(paren
id|alloc_and_init_skb_buf
c_func
(paren
id|card
comma
op_amp
id|skb
comma
id|len
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: API incoming call, no memory&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
comma
op_amp
id|mbox-&gt;cmd
comma
id|len
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|X25_PROT
)paren
suffix:semicolon
id|skb-&gt;pkt_type
op_assign
id|WAN_PACKET_ASYNC
suffix:semicolon
r_if
c_cond
(paren
id|card
op_member_access_from_pointer
id|func
c_func
(paren
id|skb
comma
id|card-&gt;sk
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: MAJOR ERROR: Failed to send up place call &bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|wan_dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * send_delayed_cmd_result&n; *&n; *&t;Wait commands like PLEACE CALL or CLEAR CALL must wait&n; *      untill the result arrivers. This function passes&n; *      the result to a waiting sock. &n; *&n; *===============================================================*/
DECL|function|send_delayed_cmd_result
r_static
r_void
id|send_delayed_cmd_result
c_func
(paren
id|sdla_t
op_star
id|card
comma
id|netdevice_t
op_star
id|dev
comma
id|TX25Mbox
op_star
id|mbox
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|mbox_cmd_t
op_star
id|usr_cmd
op_assign
(paren
id|mbox_cmd_t
op_star
)paren
id|chan-&gt;common.mbox
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|len
op_assign
r_sizeof
(paren
r_int
r_char
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.command
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* If the sock is in the process of unlinking the&n;&t; * driver from the socket, we must get out. &n;&t; * This never happends but is a sanity check. */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
l_int|0
comma
op_amp
id|chan-&gt;common.common_critical
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|usr_cmd
op_logical_or
op_logical_neg
id|chan-&gt;common.sk
op_logical_or
op_logical_neg
id|chan-&gt;common.func
)paren
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;Delay result: Sock not bounded sk: %u, func: %u, mbox: %u&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|chan-&gt;common.sk
comma
(paren
r_int
r_int
)paren
id|chan-&gt;common.func
comma
(paren
r_int
r_int
)paren
id|usr_cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|usr_cmd-&gt;cmd
comma
op_amp
id|mbox-&gt;cmd
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mbox-&gt;cmd.length
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|usr_cmd-&gt;data
comma
id|mbox-&gt;data
comma
id|mbox-&gt;cmd.length
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alloc_and_init_skb_buf
c_func
(paren
id|card
comma
op_amp
id|skb
comma
id|len
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Delay result: No sock buffers&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
comma
op_amp
id|mbox-&gt;cmd.command
comma
id|len
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;pkt_type
op_assign
id|WAN_PACKET_CMD
suffix:semicolon
id|chan-&gt;common
dot
id|func
c_func
(paren
id|skb
comma
id|dev
comma
id|chan-&gt;common.sk
)paren
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * clear_confirm_event&n; *&n; * &t;Pass the clear confirmation event up the sock. The&n; *      API will disconnect only after the clear confirmation&n; *      has been received. &n; *&n; *      Depending on the state, clear confirmation could &n; *      be an OOB event, or a result of an API command.&n; *===============================================================*/
DECL|function|clear_confirm_event
r_static
r_int
id|clear_confirm_event
(paren
id|sdla_t
op_star
id|card
comma
id|TX25Mbox
op_star
id|mb
)paren
(brace
id|netdevice_t
op_star
id|dev
suffix:semicolon
id|x25_channel_t
op_star
id|chan
suffix:semicolon
r_int
r_char
id|old_state
suffix:semicolon
id|dev
op_assign
id|find_channel
c_func
(paren
id|card
comma
id|mb-&gt;cmd.lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: *** GOT CLEAR BUT NO DEV %i&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|mb-&gt;cmd.lcn
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: GOT CLEAR CONFIRM %s:  Mbox lcn %i  Chan lcn %i&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
comma
id|mb-&gt;cmd.lcn
comma
id|chan-&gt;common.lcn
)paren
suffix:semicolon
multiline_comment|/* If not API fall through to default. &n;&t; * If API, send the result to a waiting&n;         * socket.&n;&t; */
id|old_state
op_assign
id|chan-&gt;common.state
suffix:semicolon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_DISCONNECTED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
(brace
r_switch
c_cond
(paren
id|old_state
)paren
(brace
r_case
id|WAN_DISCONNECTING
suffix:colon
r_case
id|WAN_CONNECTING
suffix:colon
id|send_delayed_cmd_result
c_func
(paren
id|card
comma
id|dev
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WAN_CONNECTED
suffix:colon
id|send_oob_msg
c_func
(paren
id|card
comma
id|dev
comma
id|mb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * send_oob_msg&n; *&n; *    Construct an NEM Message and pass it up the connected&n; *    sock. If the sock is not bounded discard the NEM.&n; *&n; *===============================================================*/
DECL|function|send_oob_msg
r_static
r_void
id|send_oob_msg
(paren
id|sdla_t
op_star
id|card
comma
id|netdevice_t
op_star
id|dev
comma
id|TX25Mbox
op_star
id|mbox
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|mbox_cmd_t
op_star
id|usr_cmd
op_assign
(paren
id|mbox_cmd_t
op_star
)paren
id|chan-&gt;common.mbox
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|len
op_assign
r_sizeof
(paren
id|x25api_hdr_t
)paren
op_plus
id|mbox-&gt;cmd.length
suffix:semicolon
id|x25api_t
op_star
id|api_hdr
suffix:semicolon
multiline_comment|/* If the sock is in the process of unlinking the&n;&t; * driver from the socket, we must get out. &n;&t; * This never happends but is a sanity check. */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
l_int|0
comma
op_amp
id|chan-&gt;common.common_critical
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|usr_cmd
op_logical_or
op_logical_neg
id|chan-&gt;common.sk
op_logical_or
op_logical_neg
id|chan-&gt;common.func
)paren
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;OOB MSG: Sock not bounded&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|usr_cmd-&gt;cmd
comma
op_amp
id|mbox-&gt;cmd
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mbox-&gt;cmd.length
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|usr_cmd-&gt;data
comma
id|mbox-&gt;data
comma
id|mbox-&gt;cmd.length
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alloc_and_init_skb_buf
c_func
(paren
id|card
comma
op_amp
id|skb
comma
id|len
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: OOB MSG: No sock buffers&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|api_hdr
op_assign
(paren
id|x25api_t
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|api_hdr-&gt;hdr.pktType
op_assign
id|mbox-&gt;cmd.pktType
op_amp
l_int|0x7F
suffix:semicolon
id|api_hdr-&gt;hdr.qdm
op_assign
id|mbox-&gt;cmd.qdm
suffix:semicolon
id|api_hdr-&gt;hdr.cause
op_assign
id|mbox-&gt;cmd.cause
suffix:semicolon
id|api_hdr-&gt;hdr.diagn
op_assign
id|mbox-&gt;cmd.diagn
suffix:semicolon
id|api_hdr-&gt;hdr.length
op_assign
id|mbox-&gt;cmd.length
suffix:semicolon
id|api_hdr-&gt;hdr.result
op_assign
id|mbox-&gt;cmd.result
suffix:semicolon
id|api_hdr-&gt;hdr.lcn
op_assign
id|mbox-&gt;cmd.lcn
suffix:semicolon
r_if
c_cond
(paren
id|mbox-&gt;cmd.length
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|api_hdr-&gt;data
comma
id|mbox-&gt;data
comma
id|mbox-&gt;cmd.length
)paren
suffix:semicolon
)brace
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;pkt_type
op_assign
id|WAN_PACKET_ERR
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common
dot
id|func
c_func
(paren
id|skb
comma
id|dev
comma
id|chan-&gt;common.sk
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bh_enqueue
c_func
(paren
id|dev
comma
id|skb
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Dropping OOB MSG&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
id|wan_dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
)brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: OOB MSG OK, %s, lcn %i&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
comma
id|mbox-&gt;cmd.lcn
)paren
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; *  alloc_and_init_skb_buf &n; *&n; *&t;Allocate and initialize an skb buffer. &n; *&n; *===============================================================*/
DECL|function|alloc_and_init_skb_buf
r_static
r_int
id|alloc_and_init_skb_buf
(paren
id|sdla_t
op_star
id|card
comma
r_struct
id|sk_buff
op_star
op_star
id|skb
comma
r_int
id|len
)paren
(brace
r_struct
id|sk_buff
op_star
id|new_skb
op_assign
op_star
id|skb
suffix:semicolon
id|new_skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|len
op_plus
id|X25_HRDHDR_SZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: no socket buffers available!&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_tailroom
c_func
(paren
id|new_skb
)paren
OL
id|len
)paren
(brace
multiline_comment|/* No room for the packet. Call off the whole thing! */
id|wan_dev_kfree_skb
c_func
(paren
id|new_skb
comma
id|FREE_READ
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Listen: unexpectedly long packet sequence&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
op_star
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
op_star
id|skb
op_assign
id|new_skb
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; *  api_oob_event &n; *&n; *&t;Send an OOB event up to the sock &n; *&n; *===============================================================*/
DECL|function|api_oob_event
r_static
r_void
id|api_oob_event
(paren
id|sdla_t
op_star
id|card
comma
id|TX25Mbox
op_star
id|mbox
)paren
(brace
id|netdevice_t
op_star
id|dev
op_assign
id|find_channel
c_func
(paren
id|card
comma
id|mbox-&gt;cmd.lcn
)paren
suffix:semicolon
id|x25_channel_t
op_star
id|chan
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
id|send_oob_msg
c_func
(paren
id|card
comma
id|dev
comma
id|mbox
)paren
suffix:semicolon
)brace
DECL|function|channel_disconnect
r_static
r_int
id|channel_disconnect
(paren
id|sdla_t
op_star
id|card
comma
id|netdevice_t
op_star
id|dev
)paren
(brace
r_int
id|err
suffix:semicolon
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: TIMER: %s, Device down disconnecting&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.svc
)paren
(brace
id|err
op_assign
id|x25_clear_call
c_func
(paren
id|card
comma
id|chan-&gt;common.lcn
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If channel is PVC or LAPB HDLC, there is no call&n;                 * to be cleared, thus drop down to the default&n;                 * area &n;&t;         */
id|err
op_assign
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|err
)paren
(brace
r_case
id|X25RES_CHANNEL_IN_USE
suffix:colon
r_case
id|X25RES_NOT_READY
suffix:colon
id|err
op_assign
id|TRY_CMD_AGAIN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_OK
suffix:colon
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;CALL CLEAR OK: Dev %s Chan Lcn %i&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|chan-&gt;common.lcn
)paren
suffix:semicolon
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_DISCONNECTING
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.command
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|DELAY_RESULT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* If LAPB HDLC protocol, bring the whole link down&n;                         * once the application terminates &n;&t;&t;&t; */
id|set_chan_state
c_func
(paren
id|dev
comma
id|WAN_DISCONNECTED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.LAPB_hdlc
)paren
(brace
id|DBG_PRINTK
c_func
(paren
id|KERN_INFO
l_string|&quot;LAPB: Disconnecting Link&bslash;n&quot;
)paren
suffix:semicolon
id|hdlc_link_down
(paren
id|card
)paren
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|chan-&gt;common.command
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|RETURN_RESULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|hdlc_link_down
r_static
r_void
id|hdlc_link_down
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
r_sizeof
(paren
id|TX25Mbox
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_HDLC_LINK_DISC
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
l_int|1
suffix:semicolon
id|mbox-&gt;data
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|X25_HDLC_LINK_DISC
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Hdlc Link Down Failed %x&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|err
)paren
suffix:semicolon
id|disconnect
(paren
id|card
)paren
suffix:semicolon
)brace
DECL|function|check_bad_command
r_static
r_int
id|check_bad_command
(paren
id|sdla_t
op_star
id|card
comma
id|netdevice_t
op_star
id|dev
)paren
(brace
id|x25_channel_t
op_star
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|bad_cmd
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;common.command
)paren
op_amp
l_int|0x7F
)paren
(brace
r_case
id|X25_PLACE_CALL
suffix:colon
r_if
c_cond
(paren
id|chan-&gt;common.state
op_ne
id|WAN_DISCONNECTED
)paren
id|bad_cmd
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|X25_CLEAR_CALL
suffix:colon
r_if
c_cond
(paren
id|chan-&gt;common.state
op_eq
id|WAN_DISCONNECTED
)paren
id|bad_cmd
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|X25_ACCEPT_CALL
suffix:colon
r_if
c_cond
(paren
id|chan-&gt;common.state
op_ne
id|WAN_CONNECTING
)paren
id|bad_cmd
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|X25_RESET
suffix:colon
r_if
c_cond
(paren
id|chan-&gt;common.state
op_ne
id|WAN_CONNECTED
)paren
id|bad_cmd
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|bad_cmd
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bad_cmd
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Invalid State, BAD Command %x, dev %s, lcn %i, st %i&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|atomic_read
c_func
(paren
op_amp
id|chan-&gt;common.command
)paren
comma
id|dev-&gt;name
comma
id|chan-&gt;common.lcn
comma
id|chan-&gt;common.state
)paren
suffix:semicolon
)brace
r_return
id|bad_cmd
suffix:semicolon
)brace
multiline_comment|/*************************** XPIPEMON FUNCTIONS **************************/
multiline_comment|/*==============================================================================&n; * Process UDP call of type XPIPE&n; */
DECL|function|process_udp_mgmt_pkt
r_static
r_int
id|process_udp_mgmt_pkt
c_func
(paren
id|sdla_t
op_star
id|card
)paren
(brace
r_int
id|c_retry
op_assign
id|MAX_CMD_RETRY
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_struct
id|sk_buff
op_star
id|new_skb
suffix:semicolon
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|udp_mgmt_req_valid
op_assign
l_int|1
suffix:semicolon
id|netdevice_t
op_star
id|dev
suffix:semicolon
id|x25_channel_t
op_star
id|chan
suffix:semicolon
r_int
r_int
id|lcn
suffix:semicolon
r_struct
id|timeval
id|tv
suffix:semicolon
id|x25_udp_pkt_t
op_star
id|x25_udp_pkt
suffix:semicolon
id|x25_udp_pkt
op_assign
(paren
id|x25_udp_pkt_t
op_star
)paren
id|card-&gt;u.x.udp_pkt_data
suffix:semicolon
id|dev
op_assign
id|card-&gt;u.x.udp_dev
suffix:semicolon
id|chan
op_assign
id|dev-&gt;priv
suffix:semicolon
id|lcn
op_assign
id|chan-&gt;common.lcn
suffix:semicolon
r_switch
c_cond
(paren
id|x25_udp_pkt-&gt;cblock.command
)paren
(brace
multiline_comment|/* XPIPE_ENABLE_TRACE */
r_case
id|XPIPE_ENABLE_TRACING
suffix:colon
multiline_comment|/* XPIPE_GET_TRACE_INFO */
r_case
id|XPIPE_GET_TRACE_INFO
suffix:colon
multiline_comment|/* SET FT1 MODE */
r_case
id|XPIPE_SET_FT1_MODE
suffix:colon
r_if
c_cond
(paren
id|card-&gt;u.x.udp_pkt_src
op_eq
id|UDP_PKT_FRM_NETWORK
)paren
(brace
op_increment
id|chan-&gt;pipe_mgmt_stat.UDP_PIPE_mgmt_direction_err
suffix:semicolon
id|udp_mgmt_req_valid
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* XPIPE_FT1_READ_STATUS */
r_case
id|XPIPE_FT1_READ_STATUS
suffix:colon
multiline_comment|/* FT1 MONITOR STATUS */
r_case
id|XPIPE_FT1_STATUS_CTRL
suffix:colon
r_if
c_cond
(paren
id|card-&gt;hw.fwid
op_ne
id|SFID_X25_508
)paren
(brace
op_increment
id|chan-&gt;pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_type_err
suffix:semicolon
id|udp_mgmt_req_valid
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|udp_mgmt_req_valid
)paren
(brace
multiline_comment|/* set length to 0 */
id|x25_udp_pkt-&gt;cblock.length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set return code */
id|x25_udp_pkt-&gt;cblock.result
op_assign
(paren
id|card-&gt;hw.fwid
op_ne
id|SFID_X25_508
)paren
ques
c_cond
l_int|0x1F
suffix:colon
l_int|0xCD
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|x25_udp_pkt-&gt;cblock.command
)paren
(brace
r_case
id|XPIPE_FLUSH_DRIVER_STATS
suffix:colon
id|init_x25_channel_struct
c_func
(paren
id|chan
)paren
suffix:semicolon
id|init_global_statistics
c_func
(paren
id|card
)paren
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XPIPE_DRIVER_STAT_IFSEND
suffix:colon
id|memcpy
c_func
(paren
id|x25_udp_pkt-&gt;data
comma
op_amp
id|chan-&gt;if_send_stat
comma
r_sizeof
(paren
id|if_send_stat_t
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
r_sizeof
(paren
id|if_send_stat_t
)paren
suffix:semicolon
id|x25_udp_pkt-&gt;cblock.length
op_assign
id|mbox-&gt;cmd.length
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XPIPE_DRIVER_STAT_INTR
suffix:colon
id|memcpy
c_func
(paren
op_amp
id|x25_udp_pkt-&gt;data
(braket
l_int|0
)braket
comma
op_amp
id|card-&gt;statistics
comma
r_sizeof
(paren
id|global_stats_t
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|x25_udp_pkt-&gt;data
(braket
r_sizeof
(paren
id|global_stats_t
)paren
)braket
comma
op_amp
id|chan-&gt;rx_intr_stat
comma
r_sizeof
(paren
id|rx_intr_stat_t
)paren
)paren
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
r_sizeof
(paren
id|global_stats_t
)paren
op_plus
r_sizeof
(paren
id|rx_intr_stat_t
)paren
suffix:semicolon
id|x25_udp_pkt-&gt;cblock.length
op_assign
id|mbox-&gt;cmd.length
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XPIPE_DRIVER_STAT_GEN
suffix:colon
id|memcpy
c_func
(paren
id|x25_udp_pkt-&gt;data
comma
op_amp
id|chan-&gt;pipe_mgmt_stat.UDP_PIPE_mgmt_kmalloc_err
comma
r_sizeof
(paren
id|pipe_mgmt_stat_t
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|x25_udp_pkt-&gt;data
(braket
r_sizeof
(paren
id|pipe_mgmt_stat_t
)paren
)braket
comma
op_amp
id|card-&gt;statistics
comma
r_sizeof
(paren
id|global_stats_t
)paren
)paren
suffix:semicolon
id|x25_udp_pkt-&gt;cblock.result
op_assign
l_int|0
suffix:semicolon
id|x25_udp_pkt-&gt;cblock.length
op_assign
r_sizeof
(paren
id|global_stats_t
)paren
op_plus
r_sizeof
(paren
id|rx_intr_stat_t
)paren
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
id|x25_udp_pkt-&gt;cblock.length
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XPIPE_ROUTER_UP_TIME
suffix:colon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|chan-&gt;router_up_time
op_assign
id|tv.tv_sec
op_minus
id|chan-&gt;router_start_time
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|x25_udp_pkt-&gt;data
op_assign
id|chan-&gt;router_up_time
suffix:semicolon
id|x25_udp_pkt-&gt;cblock.length
op_assign
id|mbox-&gt;cmd.length
op_assign
l_int|4
suffix:semicolon
id|x25_udp_pkt-&gt;cblock.result
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_do
(brace
id|memcpy
c_func
(paren
op_amp
id|mbox-&gt;cmd
comma
op_amp
id|x25_udp_pkt-&gt;cblock.command
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mbox-&gt;cmd.length
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|mbox-&gt;data
comma
(paren
r_char
op_star
)paren
id|x25_udp_pkt-&gt;data
comma
id|mbox-&gt;cmd.length
)paren
suffix:semicolon
)brace
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|err
op_logical_and
id|c_retry
op_decrement
op_logical_and
id|x25_error
c_func
(paren
id|card
comma
id|err
comma
id|mbox-&gt;cmd.command
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
id|CMD_OK
op_logical_or
(paren
id|err
op_eq
l_int|1
op_logical_and
(paren
id|mbox-&gt;cmd.command
op_eq
l_int|0x06
op_logical_or
id|mbox-&gt;cmd.command
op_eq
l_int|0x16
)paren
)paren
)paren
(brace
op_increment
id|chan-&gt;pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_cmnd_OK
suffix:semicolon
)brace
r_else
(brace
op_increment
id|chan-&gt;pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_cmnd_timeout
suffix:semicolon
)brace
multiline_comment|/* copy the result back to our buffer */
id|memcpy
c_func
(paren
op_amp
id|x25_udp_pkt-&gt;cblock.command
comma
op_amp
id|mbox-&gt;cmd
comma
r_sizeof
(paren
id|TX25Cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mbox-&gt;cmd.length
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|x25_udp_pkt-&gt;data
comma
op_amp
id|mbox-&gt;data
comma
id|mbox-&gt;cmd.length
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
singleline_comment|//switch
)brace
multiline_comment|/* Fill UDP TTL */
id|x25_udp_pkt-&gt;ip_pkt.ttl
op_assign
id|card-&gt;wandev.ttl
suffix:semicolon
id|len
op_assign
id|reply_udp
c_func
(paren
id|card-&gt;u.x.udp_pkt_data
comma
id|mbox-&gt;cmd.length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;u.x.udp_pkt_src
op_eq
id|UDP_PKT_FRM_NETWORK
)paren
(brace
id|err
op_assign
id|x25_send
c_func
(paren
id|card
comma
id|lcn
comma
l_int|0
comma
id|len
comma
id|card-&gt;u.x.udp_pkt_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
op_increment
id|chan-&gt;pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_send_passed
suffix:semicolon
r_else
op_increment
id|chan-&gt;pipe_mgmt_stat.UDP_PIPE_mgmt_adptr_send_failed
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Allocate socket buffer */
r_if
c_cond
(paren
(paren
id|new_skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|len
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_void
op_star
id|buf
suffix:semicolon
multiline_comment|/* copy data into new_skb */
id|buf
op_assign
id|skb_put
c_func
(paren
id|new_skb
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|card-&gt;u.x.udp_pkt_data
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Decapsulate packet and pass it up the protocol &n;&t;&t;&t;   stack */
id|new_skb-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;common.usedby
op_eq
id|API
)paren
id|new_skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|X25_PROT
)paren
suffix:semicolon
r_else
id|new_skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:semicolon
id|new_skb-&gt;mac.raw
op_assign
id|new_skb-&gt;data
suffix:semicolon
id|netif_rx
c_func
(paren
id|new_skb
)paren
suffix:semicolon
op_increment
id|chan-&gt;pipe_mgmt_stat.UDP_PIPE_mgmt_passed_to_stack
suffix:semicolon
)brace
r_else
(brace
op_increment
id|chan-&gt;pipe_mgmt_stat.UDP_PIPE_mgmt_no_socket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: UDP mgmt cmnd, no socket buffers available!&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
)brace
)brace
id|card-&gt;u.x.udp_pkt_lgth
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*==============================================================================&n; * Determine what type of UDP call it is. DRVSTATS or XPIPE8ND ?&n; */
DECL|function|udp_pkt_type
r_static
r_int
id|udp_pkt_type
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|sdla_t
op_star
id|card
)paren
(brace
id|x25_udp_pkt_t
op_star
id|x25_udp_pkt
op_assign
(paren
id|x25_udp_pkt_t
op_star
)paren
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x25_udp_pkt-&gt;ip_pkt.protocol
op_eq
id|UDPMGMT_UDP_PROTOCOL
)paren
op_logical_and
(paren
id|x25_udp_pkt-&gt;ip_pkt.ver_inet_hdr_length
op_eq
l_int|0x45
)paren
op_logical_and
(paren
id|x25_udp_pkt-&gt;udp_pkt.udp_dst_port
op_eq
id|ntohs
c_func
(paren
id|card-&gt;wandev.udp_port
)paren
)paren
op_logical_and
(paren
id|x25_udp_pkt-&gt;wp_mgmt.request_reply
op_eq
id|UDPMGMT_REQUEST
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|x25_udp_pkt-&gt;wp_mgmt.signature
comma
id|UDPMGMT_XPIPE_SIGNATURE
comma
l_int|8
)paren
)paren
(brace
r_return
id|UDP_XPIPE_TYPE
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: UDP Packet, Failed Signature !&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
)brace
)brace
r_return
id|UDP_INVALID_TYPE
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Reply to UDP Management system.&n; * Return nothing.&n; */
DECL|function|reply_udp
r_static
r_int
id|reply_udp
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|mbox_len
)paren
(brace
r_int
r_int
id|len
comma
id|udp_length
comma
id|temp
comma
id|ip_length
suffix:semicolon
r_int
r_int
id|ip_temp
suffix:semicolon
r_int
id|even_bound
op_assign
l_int|0
suffix:semicolon
id|x25_udp_pkt_t
op_star
id|x25_udp_pkt
op_assign
(paren
id|x25_udp_pkt_t
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/* Set length of packet */
id|len
op_assign
r_sizeof
(paren
id|ip_pkt_t
)paren
op_plus
r_sizeof
(paren
id|udp_pkt_t
)paren
op_plus
r_sizeof
(paren
id|wp_mgmt_t
)paren
op_plus
r_sizeof
(paren
id|cblock_t
)paren
op_plus
id|mbox_len
suffix:semicolon
multiline_comment|/* fill in UDP reply */
id|x25_udp_pkt-&gt;wp_mgmt.request_reply
op_assign
id|UDPMGMT_REPLY
suffix:semicolon
multiline_comment|/* fill in UDP length */
id|udp_length
op_assign
r_sizeof
(paren
id|udp_pkt_t
)paren
op_plus
r_sizeof
(paren
id|wp_mgmt_t
)paren
op_plus
r_sizeof
(paren
id|cblock_t
)paren
op_plus
id|mbox_len
suffix:semicolon
multiline_comment|/* put it on an even boundary */
r_if
c_cond
(paren
id|udp_length
op_amp
l_int|0x0001
)paren
(brace
id|udp_length
op_add_assign
l_int|1
suffix:semicolon
id|len
op_add_assign
l_int|1
suffix:semicolon
id|even_bound
op_assign
l_int|1
suffix:semicolon
)brace
id|temp
op_assign
(paren
id|udp_length
op_lshift
l_int|8
)paren
op_or
(paren
id|udp_length
op_rshift
l_int|8
)paren
suffix:semicolon
id|x25_udp_pkt-&gt;udp_pkt.udp_length
op_assign
id|temp
suffix:semicolon
multiline_comment|/* swap UDP ports */
id|temp
op_assign
id|x25_udp_pkt-&gt;udp_pkt.udp_src_port
suffix:semicolon
id|x25_udp_pkt-&gt;udp_pkt.udp_src_port
op_assign
id|x25_udp_pkt-&gt;udp_pkt.udp_dst_port
suffix:semicolon
id|x25_udp_pkt-&gt;udp_pkt.udp_dst_port
op_assign
id|temp
suffix:semicolon
multiline_comment|/* add UDP pseudo header */
id|temp
op_assign
l_int|0x1100
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|x25_udp_pkt-&gt;data
op_plus
id|mbox_len
op_plus
id|even_bound
)paren
)paren
op_assign
id|temp
suffix:semicolon
id|temp
op_assign
(paren
id|udp_length
op_lshift
l_int|8
)paren
op_or
(paren
id|udp_length
op_rshift
l_int|8
)paren
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|x25_udp_pkt-&gt;data
op_plus
id|mbox_len
op_plus
id|even_bound
op_plus
l_int|2
)paren
)paren
op_assign
id|temp
suffix:semicolon
multiline_comment|/* calculate UDP checksum */
id|x25_udp_pkt-&gt;udp_pkt.udp_checksum
op_assign
l_int|0
suffix:semicolon
id|x25_udp_pkt-&gt;udp_pkt.udp_checksum
op_assign
id|calc_checksum
c_func
(paren
op_amp
id|data
(braket
id|UDP_OFFSET
)braket
comma
id|udp_length
op_plus
id|UDP_OFFSET
)paren
suffix:semicolon
multiline_comment|/* fill in IP length */
id|ip_length
op_assign
id|len
suffix:semicolon
id|temp
op_assign
(paren
id|ip_length
op_lshift
l_int|8
)paren
op_or
(paren
id|ip_length
op_rshift
l_int|8
)paren
suffix:semicolon
id|x25_udp_pkt-&gt;ip_pkt.total_length
op_assign
id|temp
suffix:semicolon
multiline_comment|/* swap IP addresses */
id|ip_temp
op_assign
id|x25_udp_pkt-&gt;ip_pkt.ip_src_address
suffix:semicolon
id|x25_udp_pkt-&gt;ip_pkt.ip_src_address
op_assign
id|x25_udp_pkt-&gt;ip_pkt.ip_dst_address
suffix:semicolon
id|x25_udp_pkt-&gt;ip_pkt.ip_dst_address
op_assign
id|ip_temp
suffix:semicolon
multiline_comment|/* fill in IP checksum */
id|x25_udp_pkt-&gt;ip_pkt.hdr_checksum
op_assign
l_int|0
suffix:semicolon
id|x25_udp_pkt-&gt;ip_pkt.hdr_checksum
op_assign
id|calc_checksum
c_func
(paren
id|data
comma
r_sizeof
(paren
id|ip_pkt_t
)paren
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* reply_udp */
DECL|function|calc_checksum
r_int
r_int
id|calc_checksum
(paren
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|temp
suffix:semicolon
r_int
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|temp
comma
op_amp
id|data
(braket
id|i
)braket
comma
l_int|2
)paren
suffix:semicolon
id|sum
op_add_assign
(paren
r_int
r_int
)paren
id|temp
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sum
op_rshift
l_int|16
)paren
(brace
id|sum
op_assign
(paren
id|sum
op_amp
l_int|0xffffUL
)paren
op_plus
(paren
id|sum
op_rshift
l_int|16
)paren
suffix:semicolon
)brace
id|temp
op_assign
(paren
r_int
r_int
)paren
id|sum
suffix:semicolon
id|temp
op_assign
op_complement
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_eq
l_int|0
)paren
(brace
id|temp
op_assign
l_int|0xffff
suffix:semicolon
)brace
r_return
id|temp
suffix:semicolon
)brace
multiline_comment|/*=============================================================================&n; * Store a UDP management packet for later processing.&n; */
DECL|function|store_udp_mgmt_pkt
r_static
r_int
id|store_udp_mgmt_pkt
c_func
(paren
r_int
id|udp_type
comma
r_char
id|udp_pkt_src
comma
id|sdla_t
op_star
id|card
comma
id|netdevice_t
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|lcn
)paren
(brace
r_int
id|udp_pkt_stored
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;u.x.udp_pkt_lgth
op_logical_and
(paren
id|skb-&gt;len
op_le
id|MAX_LGTH_UDP_MGNT_PKT
)paren
)paren
(brace
id|card-&gt;u.x.udp_pkt_lgth
op_assign
id|skb-&gt;len
suffix:semicolon
id|card-&gt;u.x.udp_type
op_assign
id|udp_type
suffix:semicolon
id|card-&gt;u.x.udp_pkt_src
op_assign
id|udp_pkt_src
suffix:semicolon
id|card-&gt;u.x.udp_lcn
op_assign
id|lcn
suffix:semicolon
id|card-&gt;u.x.udp_dev
op_assign
id|dev
suffix:semicolon
id|memcpy
c_func
(paren
id|card-&gt;u.x.udp_pkt_data
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|card-&gt;u.x.timer_int_enabled
op_or_assign
id|TMR_INT_ENABLED_UDP_PKT
suffix:semicolon
id|udp_pkt_stored
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: ERROR: UDP packet not stored for LCN %d&bslash;n&quot;
comma
id|card-&gt;devname
comma
id|lcn
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|udp_pkt_src
op_eq
id|UDP_PKT_FRM_STACK
)paren
(brace
id|wan_dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
r_else
(brace
id|wan_dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
)brace
r_return
id|udp_pkt_stored
suffix:semicolon
)brace
multiline_comment|/*=============================================================================&n; * Initial the ppp_private_area structure.&n; */
DECL|function|init_x25_channel_struct
r_static
r_void
id|init_x25_channel_struct
c_func
(paren
id|x25_channel_t
op_star
id|chan
)paren
(brace
id|memset
c_func
(paren
op_amp
id|chan-&gt;if_send_stat.if_send_entry
comma
l_int|0
comma
r_sizeof
(paren
id|if_send_stat_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|chan-&gt;rx_intr_stat.rx_intr_no_socket
comma
l_int|0
comma
r_sizeof
(paren
id|rx_intr_stat_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|chan-&gt;pipe_mgmt_stat.UDP_PIPE_mgmt_kmalloc_err
comma
l_int|0
comma
r_sizeof
(paren
id|pipe_mgmt_stat_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Initialize Global Statistics&n; */
DECL|function|init_global_statistics
r_static
r_void
id|init_global_statistics
c_func
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|memset
c_func
(paren
op_amp
id|card-&gt;statistics.isr_entry
comma
l_int|0
comma
r_sizeof
(paren
id|global_stats_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * SMP Support&n; * ==============================================================*/
DECL|function|S508_S514_lock
r_static
r_void
id|S508_S514_lock
c_func
(paren
id|sdla_t
op_star
id|card
comma
r_int
r_int
op_star
id|smp_flags
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;wandev.lock
comma
op_star
id|smp_flags
)paren
suffix:semicolon
)brace
DECL|function|S508_S514_unlock
r_static
r_void
id|S508_S514_unlock
c_func
(paren
id|sdla_t
op_star
id|card
comma
r_int
r_int
op_star
id|smp_flags
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;wandev.lock
comma
op_star
id|smp_flags
)paren
suffix:semicolon
)brace
multiline_comment|/*===============================================================&n; * x25_timer_routine&n; *&n; * &t;A more efficient polling routine.  Each half a second&n; * &t;queue a polling task. We want to do the polling in a &n; * &t;task not timer, because timer runs in interrupt time.&n; *&n; * &t;FIXME Polling should be rethinked.&n; *==============================================================*/
DECL|function|x25_timer_routine
r_static
r_void
id|x25_timer_routine
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|sdla_t
op_star
id|card
op_assign
(paren
id|sdla_t
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card-&gt;wandev.dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Stopping the X25 Poll Timer: No Dev.&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;open_cnt
op_ne
id|card-&gt;u.x.num_of_ch
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Stopping the X25 Poll Timer: Interface down.&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|PERI_CRIT
comma
op_amp
id|card-&gt;wandev.critical
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Stopping the X25 Poll Timer: Shutting down.&bslash;n&quot;
comma
id|card-&gt;devname
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|POLL_CRIT
comma
op_amp
id|card-&gt;wandev.critical
)paren
)paren
(brace
id|trigger_x25_poll
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
id|card-&gt;u.x.x25_timer.expires
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_rshift
l_int|1
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|card-&gt;u.x.x25_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|disable_comm_shutdown
r_void
id|disable_comm_shutdown
c_func
(paren
id|sdla_t
op_star
id|card
)paren
(brace
id|TX25Mbox
op_star
id|mbox
op_assign
id|card-&gt;mbox
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* Turn of interrutps */
id|mbox-&gt;data
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;hw.fwid
op_eq
id|SFID_X25_508
)paren
(brace
id|mbox-&gt;data
(braket
l_int|1
)braket
op_assign
id|card-&gt;hw.irq
suffix:semicolon
id|mbox-&gt;data
(braket
l_int|2
)braket
op_assign
l_int|2
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|mbox-&gt;cmd.length
op_assign
l_int|1
suffix:semicolon
)brace
id|mbox-&gt;cmd.command
op_assign
id|X25_SET_INTERRUPT_MODE
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;INTERRUPT OFF FAIED %x&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
multiline_comment|/* Bring down HDLC */
id|mbox-&gt;cmd.command
op_assign
id|X25_HDLC_LINK_CLOSE
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;LINK CLOSED FAILED %x&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
multiline_comment|/* Brind down DTR */
id|mbox-&gt;data
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;data
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;data
(braket
l_int|1
)braket
op_assign
l_int|0x01
suffix:semicolon
id|mbox-&gt;cmd.length
op_assign
l_int|3
suffix:semicolon
id|mbox-&gt;cmd.command
op_assign
id|X25_SET_GLOBAL_VARS
suffix:semicolon
id|err
op_assign
id|sdla_exec
c_func
(paren
id|mbox
)paren
ques
c_cond
id|mbox-&gt;cmd.result
suffix:colon
id|CMD_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;DTR DOWN FAILED %x&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/****** End *****************************************************************/
eof
