multiline_comment|/*&n; *      FarSync X21 driver for Linux (generic HDLC version)&n; *&n; *      Actually sync driver for X.21, V.35 and V.24 on FarSync T-series cards&n; *&n; *      Copyright (C) 2001 FarSite Communications Ltd.&n; *      www.farsite.co.uk&n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; *&n; *      Author: R.J.Dunlop      &lt;bob.dunlop@farsite.co.uk&gt;&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/if.h&gt;
macro_line|#include &lt;linux/hdlc.h&gt;
macro_line|#include &quot;farsync.h&quot;
multiline_comment|/*&n; *      Module info&n; */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;R.J.Dunlop &lt;bob.dunlop@farsite.co.uk&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;FarSync T-Series X21 driver. FarSite Communications Ltd.&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|EXPORT_NO_SYMBOLS
suffix:semicolon
multiline_comment|/*      Driver configuration and global parameters&n; *      ==========================================&n; */
multiline_comment|/*      Number of ports (per card) supported&n; */
DECL|macro|FST_MAX_PORTS
mdefine_line|#define FST_MAX_PORTS           4
multiline_comment|/*      PCI vendor and device IDs&n; */
DECL|macro|FSC_PCI_VENDOR_ID
mdefine_line|#define FSC_PCI_VENDOR_ID       0x1619  /* FarSite Communications Ltd */
DECL|macro|T2P_PCI_DEVICE_ID
mdefine_line|#define T2P_PCI_DEVICE_ID       0x0400  /* T2P X21 2 port card */
DECL|macro|T4P_PCI_DEVICE_ID
mdefine_line|#define T4P_PCI_DEVICE_ID       0x0440  /* T4P X21 4 port card */
multiline_comment|/*      Default parameters for the link&n; */
DECL|macro|FST_TX_QUEUE_LEN
mdefine_line|#define FST_TX_QUEUE_LEN        100     /* At 8Mbps a longer queue length is&n;                                         * useful, the syncppp module forces&n;                                         * this down assuming a slower line I&n;                                         * guess.&n;                                         */
DECL|macro|FST_MAX_MTU
mdefine_line|#define FST_MAX_MTU             8000    /* Huge but possible */
DECL|macro|FST_DEF_MTU
mdefine_line|#define FST_DEF_MTU             1500    /* Common sane value */
DECL|macro|FST_TX_TIMEOUT
mdefine_line|#define FST_TX_TIMEOUT          (2*HZ)
macro_line|#ifdef ARPHRD_RAWHDLC
DECL|macro|ARPHRD_MYTYPE
mdefine_line|#define ARPHRD_MYTYPE   ARPHRD_RAWHDLC  /* Raw frames */
macro_line|#else
DECL|macro|ARPHRD_MYTYPE
mdefine_line|#define ARPHRD_MYTYPE   ARPHRD_HDLC     /* Cisco-HDLC (keepalives etc) */
macro_line|#endif
multiline_comment|/*      Card shared memory layout&n; *      =========================&n; */
macro_line|#pragma pack(1)
multiline_comment|/*      This information is derived in part from the FarSite FarSync Smc.h&n; *      file. Unfortunately various name clashes and the non-portability of the&n; *      bit field declarations in that file have meant that I have chosen to&n; *      recreate the information here.&n; *&n; *      The SMC (Shared Memory Configuration) has a version number that is&n; *      incremented every time there is a significant change. This number can&n; *      be used to check that we have not got out of step with the firmware&n; *      contained in the .CDE files.&n; */
DECL|macro|SMC_VERSION
mdefine_line|#define SMC_VERSION 11
DECL|macro|FST_MEMSIZE
mdefine_line|#define FST_MEMSIZE 0x100000    /* Size of card memory (1Mb) */
DECL|macro|SMC_BASE
mdefine_line|#define SMC_BASE 0x00002000L    /* Base offset of the shared memory window main&n;                                 * configuration structure */
DECL|macro|BFM_BASE
mdefine_line|#define BFM_BASE 0x00010000L    /* Base offset of the shared memory window DMA&n;                                 * buffers */
DECL|macro|LEN_TX_BUFFER
mdefine_line|#define LEN_TX_BUFFER 8192      /* Size of packet buffers */
DECL|macro|LEN_RX_BUFFER
mdefine_line|#define LEN_RX_BUFFER 8192
DECL|macro|LEN_SMALL_TX_BUFFER
mdefine_line|#define LEN_SMALL_TX_BUFFER 256 /* Size of obsolete buffs used for DOS diags */
DECL|macro|LEN_SMALL_RX_BUFFER
mdefine_line|#define LEN_SMALL_RX_BUFFER 256
DECL|macro|NUM_TX_BUFFER
mdefine_line|#define NUM_TX_BUFFER 2         /* Must be power of 2. Fixed by firmware */
DECL|macro|NUM_RX_BUFFER
mdefine_line|#define NUM_RX_BUFFER 8
multiline_comment|/* Interrupt retry time in milliseconds */
DECL|macro|INT_RETRY_TIME
mdefine_line|#define INT_RETRY_TIME 2
multiline_comment|/*      The Am186CH/CC processors support a SmartDMA mode using circular pools&n; *      of buffer descriptors. The structure is almost identical to that used&n; *      in the LANCE Ethernet controllers. Details available as PDF from the&n; *      AMD web site: http://www.amd.com/products/epd/processors/&bslash;&n; *                    2.16bitcont/3.am186cxfa/a21914/21914.pdf&n; */
DECL|struct|txdesc
r_struct
id|txdesc
(brace
multiline_comment|/* Transmit descriptor */
DECL|member|ladr
r_volatile
id|u16
id|ladr
suffix:semicolon
multiline_comment|/* Low order address of packet. This is a&n;                                 * linear address in the Am186 memory space&n;                                 */
DECL|member|hadr
r_volatile
id|u8
id|hadr
suffix:semicolon
multiline_comment|/* High order address. Low 4 bits only, high 4&n;                                 * bits must be zero&n;                                 */
DECL|member|bits
r_volatile
id|u8
id|bits
suffix:semicolon
multiline_comment|/* Status and config */
DECL|member|bcnt
r_volatile
id|u16
id|bcnt
suffix:semicolon
multiline_comment|/* 2s complement of packet size in low 15 bits.&n;                                 * Transmit terminal count interrupt enable in&n;                                 * top bit.&n;                                 */
DECL|member|unused
id|u16
id|unused
suffix:semicolon
multiline_comment|/* Not used in Tx */
)brace
suffix:semicolon
DECL|struct|rxdesc
r_struct
id|rxdesc
(brace
multiline_comment|/* Receive descriptor */
DECL|member|ladr
r_volatile
id|u16
id|ladr
suffix:semicolon
multiline_comment|/* Low order address of packet */
DECL|member|hadr
r_volatile
id|u8
id|hadr
suffix:semicolon
multiline_comment|/* High order address */
DECL|member|bits
r_volatile
id|u8
id|bits
suffix:semicolon
multiline_comment|/* Status and config */
DECL|member|bcnt
r_volatile
id|u16
id|bcnt
suffix:semicolon
multiline_comment|/* 2s complement of buffer size in low 15 bits.&n;                                 * Receive terminal count interrupt enable in&n;                                 * top bit.&n;                                 */
DECL|member|mcnt
r_volatile
id|u16
id|mcnt
suffix:semicolon
multiline_comment|/* Message byte count (15 bits) */
)brace
suffix:semicolon
multiline_comment|/* Convert a length into the 15 bit 2&squot;s complement */
multiline_comment|/* #define cnv_bcnt(len)   (( ~(len) + 1 ) &amp; 0x7FFF ) */
multiline_comment|/* Since we need to set the high bit to enable the completion interrupt this&n; * can be made a lot simpler&n; */
DECL|macro|cnv_bcnt
mdefine_line|#define cnv_bcnt(len)   (-(len))
multiline_comment|/* Status and config bits for the above */
DECL|macro|DMA_OWN
mdefine_line|#define DMA_OWN         0x80            /* SmartDMA owns the descriptor */
DECL|macro|TX_STP
mdefine_line|#define TX_STP          0x02            /* Tx: start of packet */
DECL|macro|TX_ENP
mdefine_line|#define TX_ENP          0x01            /* Tx: end of packet */
DECL|macro|RX_ERR
mdefine_line|#define RX_ERR          0x40            /* Rx: error (OR of next 4 bits) */
DECL|macro|RX_FRAM
mdefine_line|#define RX_FRAM         0x20            /* Rx: framing error */
DECL|macro|RX_OFLO
mdefine_line|#define RX_OFLO         0x10            /* Rx: overflow error */
DECL|macro|RX_CRC
mdefine_line|#define RX_CRC          0x08            /* Rx: CRC error */
DECL|macro|RX_HBUF
mdefine_line|#define RX_HBUF         0x04            /* Rx: buffer error */
DECL|macro|RX_STP
mdefine_line|#define RX_STP          0x02            /* Rx: start of packet */
DECL|macro|RX_ENP
mdefine_line|#define RX_ENP          0x01            /* Rx: end of packet */
multiline_comment|/* Interrupts from the card are caused by various events and these are presented&n; * in a circular buffer as several events may be processed on one physical int&n; */
DECL|macro|MAX_CIRBUFF
mdefine_line|#define MAX_CIRBUFF     32
DECL|struct|cirbuff
r_struct
id|cirbuff
(brace
DECL|member|rdindex
id|u8
id|rdindex
suffix:semicolon
multiline_comment|/* read, then increment and wrap */
DECL|member|wrindex
id|u8
id|wrindex
suffix:semicolon
multiline_comment|/* write, then increment and wrap */
DECL|member|evntbuff
id|u8
id|evntbuff
(braket
id|MAX_CIRBUFF
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Interrupt event codes.&n; * Where appropriate the two low order bits indicate the port number&n; */
DECL|macro|CTLA_CHG
mdefine_line|#define CTLA_CHG        0x18    /* Control signal changed */
DECL|macro|CTLB_CHG
mdefine_line|#define CTLB_CHG        0x19
DECL|macro|CTLC_CHG
mdefine_line|#define CTLC_CHG        0x1A
DECL|macro|CTLD_CHG
mdefine_line|#define CTLD_CHG        0x1B
DECL|macro|INIT_CPLT
mdefine_line|#define INIT_CPLT       0x20    /* Initialisation complete */
DECL|macro|INIT_FAIL
mdefine_line|#define INIT_FAIL       0x21    /* Initialisation failed */
DECL|macro|ABTA_SENT
mdefine_line|#define ABTA_SENT       0x24    /* Abort sent */
DECL|macro|ABTB_SENT
mdefine_line|#define ABTB_SENT       0x25
DECL|macro|ABTC_SENT
mdefine_line|#define ABTC_SENT       0x26
DECL|macro|ABTD_SENT
mdefine_line|#define ABTD_SENT       0x27
DECL|macro|TXA_UNDF
mdefine_line|#define TXA_UNDF        0x28    /* Transmission underflow */
DECL|macro|TXB_UNDF
mdefine_line|#define TXB_UNDF        0x29
DECL|macro|TXC_UNDF
mdefine_line|#define TXC_UNDF        0x2A
DECL|macro|TXD_UNDF
mdefine_line|#define TXD_UNDF        0x2B
multiline_comment|/* Port physical configuration. See farsync.h for field values */
DECL|struct|port_cfg
r_struct
id|port_cfg
(brace
DECL|member|lineInterface
id|u16
id|lineInterface
suffix:semicolon
multiline_comment|/* Physical interface type */
DECL|member|x25op
id|u8
id|x25op
suffix:semicolon
multiline_comment|/* Unused at present */
DECL|member|internalClock
id|u8
id|internalClock
suffix:semicolon
multiline_comment|/* 1 =&gt; internal clock, 0 =&gt; external */
DECL|member|lineSpeed
id|u32
id|lineSpeed
suffix:semicolon
multiline_comment|/* Speed in bps */
)brace
suffix:semicolon
multiline_comment|/* Finally sling all the above together into the shared memory structure.&n; * Sorry it&squot;s a hodge podge of arrays, structures and unused bits, it&squot;s been&n; * evolving under NT for some time so I guess we&squot;re stuck with it.&n; * The structure starts at offset SMC_BASE.&n; * See farsync.h for some field values.&n; */
DECL|struct|fst_shared
r_struct
id|fst_shared
(brace
multiline_comment|/* DMA descriptor rings */
DECL|member|rxDescrRing
r_struct
id|rxdesc
id|rxDescrRing
(braket
id|FST_MAX_PORTS
)braket
(braket
id|NUM_RX_BUFFER
)braket
suffix:semicolon
DECL|member|txDescrRing
r_struct
id|txdesc
id|txDescrRing
(braket
id|FST_MAX_PORTS
)braket
(braket
id|NUM_TX_BUFFER
)braket
suffix:semicolon
multiline_comment|/* Obsolete small buffers */
DECL|member|smallRxBuffer
id|u8
id|smallRxBuffer
(braket
id|FST_MAX_PORTS
)braket
(braket
id|NUM_RX_BUFFER
)braket
(braket
id|LEN_SMALL_RX_BUFFER
)braket
suffix:semicolon
DECL|member|smallTxBuffer
id|u8
id|smallTxBuffer
(braket
id|FST_MAX_PORTS
)braket
(braket
id|NUM_TX_BUFFER
)braket
(braket
id|LEN_SMALL_TX_BUFFER
)braket
suffix:semicolon
DECL|member|taskStatus
id|u8
id|taskStatus
suffix:semicolon
multiline_comment|/* 0x00 =&gt; initialising, 0x01 =&gt; running,&n;                                 * 0xFF =&gt; halted&n;                                 */
DECL|member|interruptHandshake
id|u8
id|interruptHandshake
suffix:semicolon
multiline_comment|/* Set to 0x01 by adapter to signal interrupt,&n;                                 * set to 0xEE by host to acknowledge interrupt&n;                                 */
DECL|member|smcVersion
id|u16
id|smcVersion
suffix:semicolon
multiline_comment|/* Must match SMC_VERSION */
DECL|member|smcFirmwareVersion
id|u32
id|smcFirmwareVersion
suffix:semicolon
multiline_comment|/* 0xIIVVRRBB where II = product ID, VV = major&n;                                 * version, RR = revision and BB = build&n;                                 */
DECL|member|txa_done
id|u16
id|txa_done
suffix:semicolon
multiline_comment|/* Obsolete completion flags */
DECL|member|rxa_done
id|u16
id|rxa_done
suffix:semicolon
DECL|member|txb_done
id|u16
id|txb_done
suffix:semicolon
DECL|member|rxb_done
id|u16
id|rxb_done
suffix:semicolon
DECL|member|txc_done
id|u16
id|txc_done
suffix:semicolon
DECL|member|rxc_done
id|u16
id|rxc_done
suffix:semicolon
DECL|member|txd_done
id|u16
id|txd_done
suffix:semicolon
DECL|member|rxd_done
id|u16
id|rxd_done
suffix:semicolon
DECL|member|mailbox
id|u16
id|mailbox
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Diagnostics mailbox. Not used */
DECL|member|interruptEvent
r_struct
id|cirbuff
id|interruptEvent
suffix:semicolon
multiline_comment|/* interrupt causes */
DECL|member|v24IpSts
id|u32
id|v24IpSts
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
multiline_comment|/* V.24 control input status */
DECL|member|v24OpSts
id|u32
id|v24OpSts
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
multiline_comment|/* V.24 control output status */
DECL|member|portConfig
r_struct
id|port_cfg
id|portConfig
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
DECL|member|clockStatus
id|u16
id|clockStatus
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
multiline_comment|/* lsb: 0=&gt; present, 1=&gt; absent */
DECL|member|cableStatus
id|u16
id|cableStatus
suffix:semicolon
multiline_comment|/* lsb: 0=&gt; present, 1=&gt; absent */
DECL|member|txDescrIndex
id|u16
id|txDescrIndex
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
multiline_comment|/* transmit descriptor ring index */
DECL|member|rxDescrIndex
id|u16
id|rxDescrIndex
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
multiline_comment|/* receive descriptor ring index */
DECL|member|portMailbox
id|u16
id|portMailbox
(braket
id|FST_MAX_PORTS
)braket
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* command, modifier */
DECL|member|cardMailbox
id|u16
id|cardMailbox
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Not used */
multiline_comment|/* Number of times that card thinks the host has&n;                                 * missed an interrupt by not acknowledging&n;                                 * within 2mS (I guess NT has problems)&n;                                 */
DECL|member|interruptRetryCount
id|u32
id|interruptRetryCount
suffix:semicolon
multiline_comment|/* Driver private data used as an ID. We&squot;ll not&n;                                 * use this on Linux I&squot;d rather keep such things&n;                                 * in main memory rather than on the PCI bus&n;                                 */
DECL|member|portHandle
id|u32
id|portHandle
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
multiline_comment|/* Count of Tx underflows for stats */
DECL|member|transmitBufferUnderflow
id|u32
id|transmitBufferUnderflow
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
multiline_comment|/* Debounced V.24 control input status */
DECL|member|v24DebouncedSts
id|u32
id|v24DebouncedSts
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
multiline_comment|/* Adapter debounce timers. Don&squot;t touch */
DECL|member|ctsTimer
id|u32
id|ctsTimer
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
DECL|member|ctsTimerRun
id|u32
id|ctsTimerRun
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
DECL|member|dcdTimer
id|u32
id|dcdTimer
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
DECL|member|dcdTimerRun
id|u32
id|dcdTimerRun
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
DECL|member|numberOfPorts
id|u32
id|numberOfPorts
suffix:semicolon
multiline_comment|/* Number of ports detected at startup */
DECL|member|_reserved
id|u16
id|_reserved
(braket
l_int|64
)braket
suffix:semicolon
DECL|member|cardMode
id|u16
id|cardMode
suffix:semicolon
multiline_comment|/* Bit-mask to enable features:&n;                                 * Bit 0: 1 enables LED identify mode&n;                                 */
DECL|member|portScheduleOffset
id|u16
id|portScheduleOffset
suffix:semicolon
DECL|member|endOfSmcSignature
id|u32
id|endOfSmcSignature
suffix:semicolon
multiline_comment|/* endOfSmcSignature MUST be the last member of&n;                                 * the structure and marks the end of the shared&n;                                 * memory. Adapter code initializes its value as&n;                                 * END_SIG.&n;                                 */
)brace
suffix:semicolon
multiline_comment|/* endOfSmcSignature value */
DECL|macro|END_SIG
mdefine_line|#define END_SIG                 0x12345678
multiline_comment|/* Mailbox values. (portMailbox) */
DECL|macro|NOP
mdefine_line|#define NOP             0       /* No operation */
DECL|macro|ACK
mdefine_line|#define ACK             1       /* Positive acknowledgement to PC driver */
DECL|macro|NAK
mdefine_line|#define NAK             2       /* Negative acknowledgement to PC driver */
DECL|macro|STARTPORT
mdefine_line|#define STARTPORT       3       /* Start an HDLC port */
DECL|macro|STOPPORT
mdefine_line|#define STOPPORT        4       /* Stop an HDLC port */
DECL|macro|ABORTTX
mdefine_line|#define ABORTTX         5       /* Abort the transmitter for a port */
DECL|macro|SETV24O
mdefine_line|#define SETV24O         6       /* Set V24 outputs */
multiline_comment|/* Larger buffers are positioned in memory at offset BFM_BASE */
DECL|struct|buf_window
r_struct
id|buf_window
(brace
DECL|member|txBuffer
id|u8
id|txBuffer
(braket
id|FST_MAX_PORTS
)braket
(braket
id|NUM_TX_BUFFER
)braket
(braket
id|LEN_TX_BUFFER
)braket
suffix:semicolon
DECL|member|rxBuffer
id|u8
id|rxBuffer
(braket
id|FST_MAX_PORTS
)braket
(braket
id|NUM_RX_BUFFER
)braket
(braket
id|LEN_RX_BUFFER
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Calculate offset of a buffer object within the shared memory window */
DECL|macro|BUF_OFFSET
mdefine_line|#define BUF_OFFSET(X)   ((unsigned int)&amp;(((struct buf_window *)BFM_BASE)-&gt;X))
macro_line|#pragma pack()
multiline_comment|/*      Device driver private information&n; *      =================================&n; */
multiline_comment|/*      Per port (line or channel) information&n; */
DECL|struct|fst_port_info
r_struct
id|fst_port_info
(brace
DECL|member|hdlc
id|hdlc_device
id|hdlc
suffix:semicolon
multiline_comment|/* HDLC device struct - must be first */
DECL|member|card
r_struct
id|fst_card_info
op_star
id|card
suffix:semicolon
multiline_comment|/* Card we&squot;re associated with */
DECL|member|index
r_int
id|index
suffix:semicolon
multiline_comment|/* Port index on the card */
DECL|member|hwif
r_int
id|hwif
suffix:semicolon
multiline_comment|/* Line hardware (lineInterface copy) */
DECL|member|run
r_int
id|run
suffix:semicolon
multiline_comment|/* Port is running */
DECL|member|rxpos
r_int
id|rxpos
suffix:semicolon
multiline_comment|/* Next Rx buffer to use */
DECL|member|txpos
r_int
id|txpos
suffix:semicolon
multiline_comment|/* Next Tx buffer to use */
DECL|member|txipos
r_int
id|txipos
suffix:semicolon
multiline_comment|/* Next Tx buffer to check for free */
DECL|member|txcnt
r_int
id|txcnt
suffix:semicolon
multiline_comment|/* Count of Tx buffers in use */
)brace
suffix:semicolon
multiline_comment|/*      Per card information&n; */
DECL|struct|fst_card_info
r_struct
id|fst_card_info
(brace
DECL|member|mem
r_char
op_star
id|mem
suffix:semicolon
multiline_comment|/* Card memory mapped to kernel space */
DECL|member|ctlmem
r_char
op_star
id|ctlmem
suffix:semicolon
multiline_comment|/* Control memory for PCI cards */
DECL|member|phys_mem
r_int
r_int
id|phys_mem
suffix:semicolon
multiline_comment|/* Physical memory window address */
DECL|member|phys_ctlmem
r_int
r_int
id|phys_ctlmem
suffix:semicolon
multiline_comment|/* Physical control memory address */
DECL|member|irq
r_int
r_int
id|irq
suffix:semicolon
multiline_comment|/* Interrupt request line number */
DECL|member|nports
r_int
r_int
id|nports
suffix:semicolon
multiline_comment|/* Number of serial ports */
DECL|member|type
r_int
r_int
id|type
suffix:semicolon
multiline_comment|/* Type index of card */
DECL|member|state
r_int
r_int
id|state
suffix:semicolon
multiline_comment|/* State of card */
DECL|member|card_lock
id|spinlock_t
id|card_lock
suffix:semicolon
multiline_comment|/* Lock for SMP access */
DECL|member|pci_conf
r_int
r_int
id|pci_conf
suffix:semicolon
multiline_comment|/* PCI card config in I/O space */
multiline_comment|/* Per port info */
DECL|member|ports
r_struct
id|fst_port_info
id|ports
(braket
id|FST_MAX_PORTS
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Convert an HDLC device pointer into a port info pointer and similar */
DECL|macro|hdlc_to_port
mdefine_line|#define hdlc_to_port(H) ((struct fst_port_info *)(H))
DECL|macro|dev_to_port
mdefine_line|#define dev_to_port(D)  hdlc_to_port(dev_to_hdlc(D))
DECL|macro|port_to_dev
mdefine_line|#define port_to_dev(P)  hdlc_to_dev(&amp;(P)-&gt;hdlc)
multiline_comment|/*&n; *      Shared memory window access macros&n; *&n; *      We have a nice memory based structure above, which could be directly&n; *      mapped on i386 but might not work on other architectures unless we use&n; *      the readb,w,l and writeb,w,l macros. Unfortunately these macros take&n; *      physical offsets so we have to convert. The only saving grace is that&n; *      this should all collapse back to a simple indirection eventually.&n; */
DECL|macro|WIN_OFFSET
mdefine_line|#define WIN_OFFSET(X)   ((long)&amp;(((struct fst_shared *)SMC_BASE)-&gt;X))
DECL|macro|FST_RDB
mdefine_line|#define FST_RDB(C,E)    readb ((C)-&gt;mem + WIN_OFFSET(E))
DECL|macro|FST_RDW
mdefine_line|#define FST_RDW(C,E)    readw ((C)-&gt;mem + WIN_OFFSET(E))
DECL|macro|FST_RDL
mdefine_line|#define FST_RDL(C,E)    readl ((C)-&gt;mem + WIN_OFFSET(E))
DECL|macro|FST_WRB
mdefine_line|#define FST_WRB(C,E,B)  writeb ((B), (C)-&gt;mem + WIN_OFFSET(E))
DECL|macro|FST_WRW
mdefine_line|#define FST_WRW(C,E,W)  writew ((W), (C)-&gt;mem + WIN_OFFSET(E))
DECL|macro|FST_WRL
mdefine_line|#define FST_WRL(C,E,L)  writel ((L), (C)-&gt;mem + WIN_OFFSET(E))
multiline_comment|/*&n; *      Debug support&n; */
macro_line|#if FST_DEBUG
DECL|variable|fst_debug_mask
r_static
r_int
id|fst_debug_mask
op_assign
(brace
id|FST_DEBUG
)brace
suffix:semicolon
multiline_comment|/* Most common debug activity is to print something if the corresponding bit&n; * is set in the debug mask. Note: this uses a non-ANSI extension in GCC to&n; * support variable numbers of macro parameters. The inverted if prevents us&n; * eating someone else&squot;s else clause.&n; */
DECL|macro|dbg
mdefine_line|#define dbg(F,fmt,A...) if ( ! ( fst_debug_mask &amp; (F))) &bslash;&n;                                ; &bslash;&n;                        else &bslash;&n;                                printk ( KERN_DEBUG FST_NAME &quot;: &quot; fmt, ## A )
macro_line|#else
DECL|macro|dbg
macro_line|# define dbg(X...)      /* NOP */
macro_line|#endif
multiline_comment|/*      Printing short cuts&n; */
DECL|macro|printk_err
mdefine_line|#define printk_err(fmt,A...)    printk ( KERN_ERR     FST_NAME &quot;: &quot; fmt, ## A )
DECL|macro|printk_warn
mdefine_line|#define printk_warn(fmt,A...)   printk ( KERN_WARNING FST_NAME &quot;: &quot; fmt, ## A )
DECL|macro|printk_info
mdefine_line|#define printk_info(fmt,A...)   printk ( KERN_INFO    FST_NAME &quot;: &quot; fmt, ## A )
multiline_comment|/*&n; *      PCI ID lookup table&n; */
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|fst_pci_dev_id
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
id|FSC_PCI_VENDOR_ID
comma
id|T2P_PCI_DEVICE_ID
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|FST_TYPE_T2P
)brace
comma
(brace
id|FSC_PCI_VENDOR_ID
comma
id|T4P_PCI_DEVICE_ID
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|FST_TYPE_T4P
)brace
comma
(brace
l_int|0
comma
)brace
multiline_comment|/* End */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|pci
comma
id|fst_pci_dev_id
)paren
suffix:semicolon
multiline_comment|/*      Card control functions&n; *      ======================&n; */
multiline_comment|/*      Place the processor in reset state&n; *&n; * Used to be a simple write to card control space but a glitch in the latest&n; * AMD Am186CH processor means that we now have to do it by asserting and de-&n; * asserting the PLX chip PCI Adapter Software Reset. Bit 30 in CNTRL register&n; * at offset 0x50.&n; */
r_static
r_inline
r_void
DECL|function|fst_cpureset
id|fst_cpureset
(paren
r_struct
id|fst_card_info
op_star
id|card
)paren
(brace
r_int
r_int
id|regval
suffix:semicolon
id|regval
op_assign
id|inl
(paren
id|card-&gt;pci_conf
op_plus
l_int|0x50
)paren
suffix:semicolon
id|outl
(paren
id|regval
op_or
l_int|0x40000000
comma
id|card-&gt;pci_conf
op_plus
l_int|0x50
)paren
suffix:semicolon
id|outl
(paren
id|regval
op_amp
op_complement
l_int|0x40000000
comma
id|card-&gt;pci_conf
op_plus
l_int|0x50
)paren
suffix:semicolon
)brace
multiline_comment|/*      Release the processor from reset&n; */
r_static
r_inline
r_void
DECL|function|fst_cpurelease
id|fst_cpurelease
(paren
r_struct
id|fst_card_info
op_star
id|card
)paren
(brace
(paren
r_void
)paren
id|readb
(paren
id|card-&gt;ctlmem
)paren
suffix:semicolon
)brace
multiline_comment|/*      Clear the cards interrupt flag&n; */
r_static
r_inline
r_void
DECL|function|fst_clear_intr
id|fst_clear_intr
(paren
r_struct
id|fst_card_info
op_star
id|card
)paren
(brace
multiline_comment|/* Poke the appropriate PLX chip register (same as enabling interrupts)&n;         */
id|outw
(paren
l_int|0x0543
comma
id|card-&gt;pci_conf
op_plus
l_int|0x4C
)paren
suffix:semicolon
)brace
multiline_comment|/*      Disable card interrupts&n; */
r_static
r_inline
r_void
DECL|function|fst_disable_intr
id|fst_disable_intr
(paren
r_struct
id|fst_card_info
op_star
id|card
)paren
(brace
id|outw
(paren
l_int|0x0000
comma
id|card-&gt;pci_conf
op_plus
l_int|0x4C
)paren
suffix:semicolon
)brace
multiline_comment|/*      Issue a Mailbox command for a port.&n; *      Note we issue them on a fire and forget basis, not expecting to see an&n; *      error and not waiting for completion.&n; */
r_static
r_void
DECL|function|fst_issue_cmd
id|fst_issue_cmd
(paren
r_struct
id|fst_port_info
op_star
id|port
comma
r_int
r_int
id|cmd
)paren
(brace
r_struct
id|fst_card_info
op_star
id|card
suffix:semicolon
r_int
r_int
id|mbval
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|safety
suffix:semicolon
id|card
op_assign
id|port-&gt;card
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
id|mbval
op_assign
id|FST_RDW
(paren
id|card
comma
id|portMailbox
(braket
id|port-&gt;index
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|safety
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wait for any previous command to complete */
r_while
c_loop
(paren
id|mbval
OG
id|NAK
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
id|schedule_timeout
(paren
l_int|1
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|safety
OG
l_int|1000
)paren
(brace
id|printk_err
(paren
l_string|&quot;Mailbox safety timeout&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mbval
op_assign
id|FST_RDW
(paren
id|card
comma
id|portMailbox
(braket
id|port-&gt;index
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|safety
OG
l_int|0
)paren
(brace
id|dbg
(paren
id|DBG_CMD
comma
l_string|&quot;Mailbox clear after %d jiffies&bslash;n&quot;
comma
id|safety
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mbval
op_eq
id|NAK
)paren
(brace
id|dbg
(paren
id|DBG_CMD
comma
l_string|&quot;issue_cmd: previous command was NAK&squot;d&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|FST_WRW
(paren
id|card
comma
id|portMailbox
(braket
id|port-&gt;index
)braket
(braket
l_int|0
)braket
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|ABORTTX
op_logical_or
id|cmd
op_eq
id|STARTPORT
)paren
(brace
id|port-&gt;txpos
op_assign
l_int|0
suffix:semicolon
id|port-&gt;txipos
op_assign
l_int|0
suffix:semicolon
id|port-&gt;txcnt
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*      Port output signals control&n; */
r_static
r_inline
r_void
DECL|function|fst_op_raise
id|fst_op_raise
(paren
r_struct
id|fst_port_info
op_star
id|port
comma
r_int
r_int
id|outputs
)paren
(brace
id|outputs
op_or_assign
id|FST_RDL
(paren
id|port-&gt;card
comma
id|v24OpSts
(braket
id|port-&gt;index
)braket
)paren
suffix:semicolon
id|FST_WRL
(paren
id|port-&gt;card
comma
id|v24OpSts
(braket
id|port-&gt;index
)braket
comma
id|outputs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;run
)paren
id|fst_issue_cmd
(paren
id|port
comma
id|SETV24O
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|fst_op_lower
id|fst_op_lower
(paren
r_struct
id|fst_port_info
op_star
id|port
comma
r_int
r_int
id|outputs
)paren
(brace
id|outputs
op_assign
op_complement
id|outputs
op_amp
id|FST_RDL
(paren
id|port-&gt;card
comma
id|v24OpSts
(braket
id|port-&gt;index
)braket
)paren
suffix:semicolon
id|FST_WRL
(paren
id|port-&gt;card
comma
id|v24OpSts
(braket
id|port-&gt;index
)braket
comma
id|outputs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;run
)paren
id|fst_issue_cmd
(paren
id|port
comma
id|SETV24O
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *      Setup port Rx buffers&n; */
r_static
r_void
DECL|function|fst_rx_config
id|fst_rx_config
(paren
r_struct
id|fst_port_info
op_star
id|port
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|pi
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|fst_card_info
op_star
id|card
suffix:semicolon
id|pi
op_assign
id|port-&gt;index
suffix:semicolon
id|card
op_assign
id|port-&gt;card
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RX_BUFFER
suffix:semicolon
id|i
op_increment
)paren
(brace
id|offset
op_assign
id|BUF_OFFSET
(paren
id|rxBuffer
(braket
id|pi
)braket
(braket
id|i
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|FST_WRW
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|i
)braket
dot
id|ladr
comma
(paren
id|u16
)paren
id|offset
)paren
suffix:semicolon
id|FST_WRB
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|i
)braket
dot
id|hadr
comma
(paren
id|u8
)paren
(paren
id|offset
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
id|FST_WRW
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|i
)braket
dot
id|bcnt
comma
id|cnv_bcnt
(paren
id|LEN_RX_BUFFER
)paren
)paren
suffix:semicolon
id|FST_WRW
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|i
)braket
dot
id|mcnt
comma
l_int|0
)paren
suffix:semicolon
id|FST_WRB
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|i
)braket
dot
id|bits
comma
id|DMA_OWN
)paren
suffix:semicolon
)brace
id|port-&gt;rxpos
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *      Setup port Tx buffers&n; */
r_static
r_void
DECL|function|fst_tx_config
id|fst_tx_config
(paren
r_struct
id|fst_port_info
op_star
id|port
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|pi
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|fst_card_info
op_star
id|card
suffix:semicolon
id|pi
op_assign
id|port-&gt;index
suffix:semicolon
id|card
op_assign
id|port-&gt;card
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_TX_BUFFER
suffix:semicolon
id|i
op_increment
)paren
(brace
id|offset
op_assign
id|BUF_OFFSET
(paren
id|txBuffer
(braket
id|pi
)braket
(braket
id|i
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|FST_WRW
(paren
id|card
comma
id|txDescrRing
(braket
id|pi
)braket
(braket
id|i
)braket
dot
id|ladr
comma
(paren
id|u16
)paren
id|offset
)paren
suffix:semicolon
id|FST_WRB
(paren
id|card
comma
id|txDescrRing
(braket
id|pi
)braket
(braket
id|i
)braket
dot
id|hadr
comma
(paren
id|u8
)paren
(paren
id|offset
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
id|FST_WRW
(paren
id|card
comma
id|txDescrRing
(braket
id|pi
)braket
(braket
id|i
)braket
dot
id|bcnt
comma
l_int|0
)paren
suffix:semicolon
id|FST_WRB
(paren
id|card
comma
id|txDescrRing
(braket
id|pi
)braket
(braket
id|i
)braket
dot
id|bits
comma
l_int|0
)paren
suffix:semicolon
)brace
id|port-&gt;txpos
op_assign
l_int|0
suffix:semicolon
id|port-&gt;txipos
op_assign
l_int|0
suffix:semicolon
id|port-&gt;txcnt
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*      Control signal change interrupt event&n; */
r_static
r_void
DECL|function|fst_intr_ctlchg
id|fst_intr_ctlchg
(paren
r_struct
id|fst_card_info
op_star
id|card
comma
r_struct
id|fst_port_info
op_star
id|port
)paren
(brace
r_int
id|signals
suffix:semicolon
id|signals
op_assign
id|FST_RDL
(paren
id|card
comma
id|v24DebouncedSts
(braket
id|port-&gt;index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signals
op_amp
(paren
(paren
id|port-&gt;hwif
op_eq
id|X21
)paren
ques
c_cond
id|IPSTS_INDICATE
suffix:colon
id|IPSTS_DCD
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|netif_carrier_ok
(paren
id|port_to_dev
(paren
id|port
)paren
)paren
)paren
(brace
id|dbg
(paren
id|DBG_INTR
comma
l_string|&quot;DCD active&bslash;n&quot;
)paren
suffix:semicolon
id|netif_carrier_on
(paren
id|port_to_dev
(paren
id|port
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|netif_carrier_ok
(paren
id|port_to_dev
(paren
id|port
)paren
)paren
)paren
(brace
id|dbg
(paren
id|DBG_INTR
comma
l_string|&quot;DCD lost&bslash;n&quot;
)paren
suffix:semicolon
id|netif_carrier_off
(paren
id|port_to_dev
(paren
id|port
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*      Rx complete interrupt&n; */
r_static
r_void
DECL|function|fst_intr_rx
id|fst_intr_rx
(paren
r_struct
id|fst_card_info
op_star
id|card
comma
r_struct
id|fst_port_info
op_star
id|port
)paren
(brace
r_int
r_char
id|dmabits
suffix:semicolon
r_int
id|pi
suffix:semicolon
r_int
id|rxp
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Check we have a buffer to process */
id|pi
op_assign
id|port-&gt;index
suffix:semicolon
id|rxp
op_assign
id|port-&gt;rxpos
suffix:semicolon
id|dmabits
op_assign
id|FST_RDB
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|rxp
)braket
dot
id|bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabits
op_amp
id|DMA_OWN
)paren
(brace
id|dbg
(paren
id|DBG_RX
op_or
id|DBG_INTR
comma
l_string|&quot;intr_rx: No buffer port %d pos %d&bslash;n&quot;
comma
id|pi
comma
id|rxp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Get buffer length */
id|len
op_assign
id|FST_RDW
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|rxp
)braket
dot
id|mcnt
)paren
suffix:semicolon
multiline_comment|/* Discard the CRC */
id|len
op_sub_assign
l_int|2
suffix:semicolon
multiline_comment|/* Check buffer length and for other errors. We insist on one packet&n;         * in one buffer. This simplifies things greatly and since we&squot;ve&n;         * allocated 8K it shouldn&squot;t be a real world limitation&n;         */
id|dbg
(paren
id|DBG_RX
comma
l_string|&quot;intr_rx: %d,%d: flags %x len %d&bslash;n&quot;
comma
id|pi
comma
id|rxp
comma
id|dmabits
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabits
op_ne
(paren
id|RX_STP
op_or
id|RX_ENP
)paren
op_logical_or
id|len
OG
id|LEN_RX_BUFFER
op_minus
l_int|2
)paren
(brace
id|port-&gt;hdlc.stats.rx_errors
op_increment
suffix:semicolon
multiline_comment|/* Update error stats and discard buffer */
r_if
c_cond
(paren
id|dmabits
op_amp
id|RX_OFLO
)paren
(brace
id|port-&gt;hdlc.stats.rx_fifo_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabits
op_amp
id|RX_CRC
)paren
(brace
id|port-&gt;hdlc.stats.rx_crc_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabits
op_amp
id|RX_FRAM
)paren
(brace
id|port-&gt;hdlc.stats.rx_frame_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabits
op_eq
(paren
id|RX_STP
op_or
id|RX_ENP
)paren
)paren
(brace
id|port-&gt;hdlc.stats.rx_length_errors
op_increment
suffix:semicolon
)brace
multiline_comment|/* Discard buffer descriptors until we see the end of packet&n;                 * marker&n;                 */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dmabits
op_amp
(paren
id|DMA_OWN
op_or
id|RX_ENP
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|FST_WRB
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|rxp
)braket
dot
id|bits
comma
id|DMA_OWN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|rxp
op_ge
id|NUM_RX_BUFFER
)paren
id|rxp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
OG
id|NUM_RX_BUFFER
)paren
(brace
id|dbg
(paren
id|DBG_ASS
comma
l_string|&quot;intr_rx: Discarding more bufs&quot;
l_string|&quot; than we have&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dmabits
op_assign
id|FST_RDB
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|rxp
)braket
dot
id|bits
)paren
suffix:semicolon
)brace
multiline_comment|/* Discard the terminal buffer */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmabits
op_amp
id|DMA_OWN
)paren
)paren
(brace
id|FST_WRB
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|rxp
)braket
dot
id|bits
comma
id|DMA_OWN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|rxp
op_ge
id|NUM_RX_BUFFER
)paren
id|rxp
op_assign
l_int|0
suffix:semicolon
)brace
id|port-&gt;rxpos
op_assign
id|rxp
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Allocate SKB */
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|dev_alloc_skb
(paren
id|len
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|dbg
(paren
id|DBG_RX
comma
l_string|&quot;intr_rx: can&squot;t allocate buffer&bslash;n&quot;
)paren
suffix:semicolon
id|port-&gt;hdlc.stats.rx_dropped
op_increment
suffix:semicolon
multiline_comment|/* Return descriptor to card */
id|FST_WRB
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|rxp
)braket
dot
id|bits
comma
id|DMA_OWN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|rxp
op_ge
id|NUM_RX_BUFFER
)paren
id|port-&gt;rxpos
op_assign
l_int|0
suffix:semicolon
r_else
id|port-&gt;rxpos
op_assign
id|rxp
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy_fromio
(paren
id|skb_put
(paren
id|skb
comma
id|len
)paren
comma
id|card-&gt;mem
op_plus
id|BUF_OFFSET
(paren
id|rxBuffer
(braket
id|pi
)braket
(braket
id|rxp
)braket
(braket
l_int|0
)braket
)paren
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Reset buffer descriptor */
id|FST_WRB
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|rxp
)braket
dot
id|bits
comma
id|DMA_OWN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|rxp
op_ge
id|NUM_RX_BUFFER
)paren
id|port-&gt;rxpos
op_assign
l_int|0
suffix:semicolon
r_else
id|port-&gt;rxpos
op_assign
id|rxp
suffix:semicolon
multiline_comment|/* Update stats */
id|port-&gt;hdlc.stats.rx_packets
op_increment
suffix:semicolon
id|port-&gt;hdlc.stats.rx_bytes
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* Push upstream */
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;dev
op_assign
id|hdlc_to_dev
(paren
op_amp
id|port-&gt;hdlc
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
(paren
id|ETH_P_HDLC
)paren
suffix:semicolon
id|netif_rx
(paren
id|skb
)paren
suffix:semicolon
id|port_to_dev
(paren
id|port
)paren
op_member_access_from_pointer
id|last_rx
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/*&n; *      The interrupt service routine&n; *      Dev_id is our fst_card_info pointer&n; */
r_static
r_void
DECL|function|fst_intr
id|fst_intr
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|fst_card_info
op_star
id|card
suffix:semicolon
r_struct
id|fst_port_info
op_star
id|port
suffix:semicolon
r_int
id|rdidx
suffix:semicolon
multiline_comment|/* Event buffer indices */
r_int
id|wridx
suffix:semicolon
r_int
id|event
suffix:semicolon
multiline_comment|/* Actual event for processing */
r_int
id|pi
suffix:semicolon
r_if
c_cond
(paren
(paren
id|card
op_assign
id|dev_id
)paren
op_eq
l_int|NULL
)paren
(brace
id|dbg
(paren
id|DBG_INTR
comma
l_string|&quot;intr: spurious %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dbg
(paren
id|DBG_INTR
comma
l_string|&quot;intr: %d %p&bslash;n&quot;
comma
id|irq
comma
id|card
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|card-&gt;card_lock
)paren
suffix:semicolon
multiline_comment|/* Clear and reprime the interrupt source */
id|fst_clear_intr
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* Set the software acknowledge */
id|FST_WRB
(paren
id|card
comma
id|interruptHandshake
comma
l_int|0xEE
)paren
suffix:semicolon
multiline_comment|/* Drain the event queue */
id|rdidx
op_assign
id|FST_RDB
(paren
id|card
comma
id|interruptEvent.rdindex
)paren
suffix:semicolon
id|wridx
op_assign
id|FST_RDB
(paren
id|card
comma
id|interruptEvent.wrindex
)paren
suffix:semicolon
r_while
c_loop
(paren
id|rdidx
op_ne
id|wridx
)paren
(brace
id|event
op_assign
id|FST_RDB
(paren
id|card
comma
id|interruptEvent.evntbuff
(braket
id|rdidx
)braket
)paren
suffix:semicolon
id|port
op_assign
op_amp
id|card-&gt;ports
(braket
id|event
op_amp
l_int|0x03
)braket
suffix:semicolon
id|dbg
(paren
id|DBG_INTR
comma
l_string|&quot;intr: %x&bslash;n&quot;
comma
id|event
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|CTLA_CHG
suffix:colon
r_case
id|CTLB_CHG
suffix:colon
r_case
id|CTLC_CHG
suffix:colon
r_case
id|CTLD_CHG
suffix:colon
r_if
c_cond
(paren
id|port-&gt;run
)paren
id|fst_intr_ctlchg
(paren
id|card
comma
id|port
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ABTA_SENT
suffix:colon
r_case
id|ABTB_SENT
suffix:colon
r_case
id|ABTC_SENT
suffix:colon
r_case
id|ABTD_SENT
suffix:colon
id|dbg
(paren
id|DBG_TX
comma
l_string|&quot;Abort complete port %d&bslash;n&quot;
comma
id|event
op_amp
l_int|0x03
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TXA_UNDF
suffix:colon
r_case
id|TXB_UNDF
suffix:colon
r_case
id|TXC_UNDF
suffix:colon
r_case
id|TXD_UNDF
suffix:colon
multiline_comment|/* Difficult to see how we&squot;d get this given that we&n;                         * always load up the entire packet for DMA.&n;                         */
id|dbg
(paren
id|DBG_TX
comma
l_string|&quot;Tx underflow port %d&bslash;n&quot;
comma
id|event
op_amp
l_int|0x03
)paren
suffix:semicolon
id|port-&gt;hdlc.stats.tx_errors
op_increment
suffix:semicolon
id|port-&gt;hdlc.stats.tx_fifo_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INIT_CPLT
suffix:colon
id|dbg
(paren
id|DBG_INIT
comma
l_string|&quot;Card init OK intr&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INIT_FAIL
suffix:colon
id|dbg
(paren
id|DBG_INIT
comma
l_string|&quot;Card init FAILED intr&bslash;n&quot;
)paren
suffix:semicolon
id|card-&gt;state
op_assign
id|FST_IFAILED
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk_err
(paren
l_string|&quot;intr: unknown card event code. ignored&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Bump and wrap the index */
r_if
c_cond
(paren
op_increment
id|rdidx
op_ge
id|MAX_CIRBUFF
)paren
id|rdidx
op_assign
l_int|0
suffix:semicolon
)brace
id|FST_WRB
(paren
id|card
comma
id|interruptEvent.rdindex
comma
id|rdidx
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pi
op_assign
l_int|0
comma
id|port
op_assign
id|card-&gt;ports
suffix:semicolon
id|pi
OL
id|card-&gt;nports
suffix:semicolon
id|pi
op_increment
comma
id|port
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;run
)paren
r_continue
suffix:semicolon
multiline_comment|/* Check for rx completions */
r_while
c_loop
(paren
op_logical_neg
(paren
id|FST_RDB
(paren
id|card
comma
id|rxDescrRing
(braket
id|pi
)braket
(braket
id|port-&gt;rxpos
)braket
dot
id|bits
)paren
op_amp
id|DMA_OWN
)paren
)paren
(brace
id|fst_intr_rx
(paren
id|card
comma
id|port
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for Tx completions */
r_while
c_loop
(paren
id|port-&gt;txcnt
OG
l_int|0
op_logical_and
op_logical_neg
(paren
id|FST_RDB
(paren
id|card
comma
id|txDescrRing
(braket
id|pi
)braket
(braket
id|port-&gt;txipos
)braket
dot
id|bits
)paren
op_amp
id|DMA_OWN
)paren
)paren
(brace
op_decrement
id|port-&gt;txcnt
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|port-&gt;txipos
op_ge
id|NUM_TX_BUFFER
)paren
id|port-&gt;txipos
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
(paren
id|port_to_dev
(paren
id|port
)paren
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
(paren
op_amp
id|card-&gt;card_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*      Check that the shared memory configuration is one that we can handle&n; *      and that some basic parameters are correct&n; */
r_static
r_void
DECL|function|check_started_ok
id|check_started_ok
(paren
r_struct
id|fst_card_info
op_star
id|card
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Check structure version and end marker */
r_if
c_cond
(paren
id|FST_RDW
(paren
id|card
comma
id|smcVersion
)paren
op_ne
id|SMC_VERSION
)paren
(brace
id|printk_err
(paren
l_string|&quot;Bad shared memory version %d expected %d&bslash;n&quot;
comma
id|FST_RDW
(paren
id|card
comma
id|smcVersion
)paren
comma
id|SMC_VERSION
)paren
suffix:semicolon
id|card-&gt;state
op_assign
id|FST_BADVERSION
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FST_RDL
(paren
id|card
comma
id|endOfSmcSignature
)paren
op_ne
id|END_SIG
)paren
(brace
id|printk_err
(paren
l_string|&quot;Missing shared memory signature&bslash;n&quot;
)paren
suffix:semicolon
id|card-&gt;state
op_assign
id|FST_BADVERSION
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Firmware status flag, 0x00 = initialising, 0x01 = OK, 0xFF = fail */
r_if
c_cond
(paren
(paren
id|i
op_assign
id|FST_RDB
(paren
id|card
comma
id|taskStatus
)paren
)paren
op_eq
l_int|0x01
)paren
(brace
id|card-&gt;state
op_assign
id|FST_RUNNING
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
op_eq
l_int|0xFF
)paren
(brace
id|printk_err
(paren
l_string|&quot;Firmware initialisation failed. Card halted&bslash;n&quot;
)paren
suffix:semicolon
id|card-&gt;state
op_assign
id|FST_HALTED
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
op_ne
l_int|0x00
)paren
(brace
id|printk_err
(paren
l_string|&quot;Unknown firmware status 0x%x&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|card-&gt;state
op_assign
id|FST_HALTED
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Finally check the number of ports reported by firmware against the&n;         * number we assumed at card detection. Should never happen with&n;         * existing firmware etc so we just report it for the moment.&n;         */
r_if
c_cond
(paren
id|FST_RDL
(paren
id|card
comma
id|numberOfPorts
)paren
op_ne
id|card-&gt;nports
)paren
(brace
id|printk_warn
(paren
l_string|&quot;Port count mismatch.&quot;
l_string|&quot; Firmware thinks %d we say %d&bslash;n&quot;
comma
id|FST_RDL
(paren
id|card
comma
id|numberOfPorts
)paren
comma
id|card-&gt;nports
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|set_conf_from_info
id|set_conf_from_info
(paren
r_struct
id|fst_card_info
op_star
id|card
comma
r_struct
id|fst_port_info
op_star
id|port
comma
r_struct
id|fstioc_info
op_star
id|info
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* Set things according to the user set valid flags.&n;         * Several of the old options have been invalidated/replaced by the&n;         * generic HDLC package.&n;         */
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;valid
op_amp
id|FSTVAL_PROTO
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;valid
op_amp
id|FSTVAL_CABLE
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;valid
op_amp
id|FSTVAL_SPEED
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;valid
op_amp
id|FSTVAL_MODE
)paren
id|FST_WRW
(paren
id|card
comma
id|cardMode
comma
id|info-&gt;cardMode
)paren
suffix:semicolon
macro_line|#if FST_DEBUG
r_if
c_cond
(paren
id|info-&gt;valid
op_amp
id|FSTVAL_DEBUG
)paren
id|fst_debug_mask
op_assign
id|info-&gt;debug
suffix:semicolon
macro_line|#endif
r_return
id|err
suffix:semicolon
)brace
r_static
r_void
DECL|function|gather_conf_info
id|gather_conf_info
(paren
r_struct
id|fst_card_info
op_star
id|card
comma
r_struct
id|fst_port_info
op_star
id|port
comma
r_struct
id|fstioc_info
op_star
id|info
)paren
(brace
r_int
id|i
suffix:semicolon
id|memset
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|fstioc_info
)paren
)paren
suffix:semicolon
id|i
op_assign
id|port-&gt;index
suffix:semicolon
id|info-&gt;nports
op_assign
id|card-&gt;nports
suffix:semicolon
id|info-&gt;type
op_assign
id|card-&gt;type
suffix:semicolon
id|info-&gt;state
op_assign
id|card-&gt;state
suffix:semicolon
id|info-&gt;proto
op_assign
id|FST_GEN_HDLC
suffix:semicolon
id|info-&gt;index
op_assign
id|i
suffix:semicolon
macro_line|#if FST_DEBUG
id|info-&gt;debug
op_assign
id|fst_debug_mask
suffix:semicolon
macro_line|#endif
multiline_comment|/* Only mark information as valid if card is running.&n;         * Copy the data anyway in case it is useful for diagnostics&n;         */
id|info-&gt;valid
op_assign
(paren
(paren
id|card-&gt;state
op_eq
id|FST_RUNNING
)paren
ques
c_cond
id|FSTVAL_ALL
suffix:colon
id|FSTVAL_CARD
)paren
macro_line|#if FST_DEBUG
op_or
id|FSTVAL_DEBUG
macro_line|#endif
suffix:semicolon
id|info-&gt;lineInterface
op_assign
id|FST_RDW
(paren
id|card
comma
id|portConfig
(braket
id|i
)braket
dot
id|lineInterface
)paren
suffix:semicolon
id|info-&gt;internalClock
op_assign
id|FST_RDB
(paren
id|card
comma
id|portConfig
(braket
id|i
)braket
dot
id|internalClock
)paren
suffix:semicolon
id|info-&gt;lineSpeed
op_assign
id|FST_RDL
(paren
id|card
comma
id|portConfig
(braket
id|i
)braket
dot
id|lineSpeed
)paren
suffix:semicolon
id|info-&gt;v24IpSts
op_assign
id|FST_RDL
(paren
id|card
comma
id|v24IpSts
(braket
id|i
)braket
)paren
suffix:semicolon
id|info-&gt;v24OpSts
op_assign
id|FST_RDL
(paren
id|card
comma
id|v24OpSts
(braket
id|i
)braket
)paren
suffix:semicolon
id|info-&gt;clockStatus
op_assign
id|FST_RDW
(paren
id|card
comma
id|clockStatus
(braket
id|i
)braket
)paren
suffix:semicolon
id|info-&gt;cableStatus
op_assign
id|FST_RDW
(paren
id|card
comma
id|cableStatus
)paren
suffix:semicolon
id|info-&gt;cardMode
op_assign
id|FST_RDW
(paren
id|card
comma
id|cardMode
)paren
suffix:semicolon
id|info-&gt;smcFirmwareVersion
op_assign
id|FST_RDL
(paren
id|card
comma
id|smcFirmwareVersion
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|fst_set_iface
id|fst_set_iface
(paren
r_struct
id|fst_card_info
op_star
id|card
comma
r_struct
id|fst_port_info
op_star
id|port
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_union
id|line_settings
op_star
id|line
op_assign
op_amp
id|ifr-&gt;ifr_settings-&gt;ifs_line
suffix:semicolon
id|sync_serial_settings
id|sync
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sync
comma
op_amp
id|line-&gt;sync
comma
r_sizeof
(paren
id|sync
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|sync.loopback
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|i
op_assign
id|port-&gt;index
suffix:semicolon
r_switch
c_cond
(paren
id|ifr-&gt;ifr_settings-&gt;type
)paren
(brace
r_case
id|IF_IFACE_V35
suffix:colon
id|FST_WRW
(paren
id|card
comma
id|portConfig
(braket
id|i
)braket
dot
id|lineInterface
comma
id|V35
)paren
suffix:semicolon
id|port-&gt;hwif
op_assign
id|V35
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IF_IFACE_V24
suffix:colon
id|FST_WRW
(paren
id|card
comma
id|portConfig
(braket
id|i
)braket
dot
id|lineInterface
comma
id|V24
)paren
suffix:semicolon
id|port-&gt;hwif
op_assign
id|V24
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IF_IFACE_X21
suffix:colon
id|FST_WRW
(paren
id|card
comma
id|portConfig
(braket
id|i
)braket
dot
id|lineInterface
comma
id|X21
)paren
suffix:semicolon
id|port-&gt;hwif
op_assign
id|X21
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IF_IFACE_SYNC_SERIAL
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|sync.clock_type
)paren
(brace
r_case
id|CLOCK_EXT
suffix:colon
id|FST_WRB
(paren
id|card
comma
id|portConfig
(braket
id|i
)braket
dot
id|internalClock
comma
id|EXTCLK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLOCK_INT
suffix:colon
id|FST_WRB
(paren
id|card
comma
id|portConfig
(braket
id|i
)braket
dot
id|internalClock
comma
id|INTCLK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|FST_WRL
(paren
id|card
comma
id|portConfig
(braket
id|i
)braket
dot
id|lineSpeed
comma
id|sync.clock_rate
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|fst_get_iface
id|fst_get_iface
(paren
r_struct
id|fst_card_info
op_star
id|card
comma
r_struct
id|fst_port_info
op_star
id|port
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_union
id|line_settings
op_star
id|line
op_assign
op_amp
id|ifr-&gt;ifr_settings-&gt;ifs_line
suffix:semicolon
id|sync_serial_settings
id|sync
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* First check what line type is set, we&squot;ll default to reporting X.21&n;         * if nothing is set as IF_IFACE_SYNC_SERIAL implies it can&squot;t be&n;         * changed&n;         */
r_switch
c_cond
(paren
id|port-&gt;hwif
)paren
(brace
r_case
id|V35
suffix:colon
id|ifr-&gt;ifr_settings-&gt;type
op_assign
id|IF_IFACE_V35
suffix:semicolon
r_break
suffix:semicolon
r_case
id|V24
suffix:colon
id|ifr-&gt;ifr_settings-&gt;type
op_assign
id|IF_IFACE_V24
suffix:semicolon
r_break
suffix:semicolon
r_case
id|X21
suffix:colon
r_default
suffix:colon
id|ifr-&gt;ifr_settings-&gt;type
op_assign
id|IF_IFACE_X21
suffix:semicolon
r_break
suffix:semicolon
)brace
id|i
op_assign
id|port-&gt;index
suffix:semicolon
id|sync.clock_rate
op_assign
id|FST_RDL
(paren
id|card
comma
id|portConfig
(braket
id|i
)braket
dot
id|lineSpeed
)paren
suffix:semicolon
multiline_comment|/* Lucky card and linux use same encoding here */
id|sync.clock_type
op_assign
id|FST_RDB
(paren
id|card
comma
id|portConfig
(braket
id|i
)braket
dot
id|internalClock
)paren
suffix:semicolon
id|sync.loopback
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
op_amp
id|line-&gt;sync
comma
op_amp
id|sync
comma
r_sizeof
(paren
id|sync
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|fst_ioctl
id|fst_ioctl
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_struct
id|fst_card_info
op_star
id|card
suffix:semicolon
r_struct
id|fst_port_info
op_star
id|port
suffix:semicolon
r_struct
id|fstioc_write
id|wrthdr
suffix:semicolon
r_struct
id|fstioc_info
id|info
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dbg
(paren
id|DBG_IOCTL
comma
l_string|&quot;ioctl: %x, %p&bslash;n&quot;
comma
id|cmd
comma
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
id|port
op_assign
id|dev_to_port
(paren
id|dev
)paren
suffix:semicolon
id|card
op_assign
id|port-&gt;card
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FSTCPURESET
suffix:colon
id|fst_cpureset
(paren
id|card
)paren
suffix:semicolon
id|card-&gt;state
op_assign
id|FST_RESET
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FSTCPURELEASE
suffix:colon
id|fst_cpurelease
(paren
id|card
)paren
suffix:semicolon
id|card-&gt;state
op_assign
id|FST_STARTING
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FSTWRITE
suffix:colon
multiline_comment|/* Code write (download) */
multiline_comment|/* First copy in the header with the length and offset of data&n;                 * to write&n;                 */
r_if
c_cond
(paren
id|ifr-&gt;ifr_data
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|wrthdr
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
r_struct
id|fstioc_write
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* Sanity check the parameters. We don&squot;t support partial writes&n;                 * when going over the top&n;                 */
r_if
c_cond
(paren
id|wrthdr.size
OG
id|FST_MEMSIZE
op_logical_or
id|wrthdr.offset
OG
id|FST_MEMSIZE
op_logical_or
id|wrthdr.size
op_plus
id|wrthdr.offset
OG
id|FST_MEMSIZE
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* Now copy the data to the card.&n;                 * This will probably break on some architectures.&n;                 * I&squot;ll fix it when I have something to test on.&n;                 */
r_if
c_cond
(paren
id|copy_from_user
(paren
id|card-&gt;mem
op_plus
id|wrthdr.offset
comma
id|ifr-&gt;ifr_data
op_plus
r_sizeof
(paren
r_struct
id|fstioc_write
)paren
comma
id|wrthdr.size
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* Writes to the memory of a card in the reset state constitute&n;                 * a download&n;                 */
r_if
c_cond
(paren
id|card-&gt;state
op_eq
id|FST_RESET
)paren
(brace
id|card-&gt;state
op_assign
id|FST_DOWNLOAD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|FSTGETCONF
suffix:colon
multiline_comment|/* If card has just been started check the shared memory config&n;                 * version and marker&n;                 */
r_if
c_cond
(paren
id|card-&gt;state
op_eq
id|FST_STARTING
)paren
(brace
id|check_started_ok
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* If everything checked out enable card interrupts */
r_if
c_cond
(paren
id|card-&gt;state
op_eq
id|FST_RUNNING
)paren
(brace
id|spin_lock_irqsave
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
id|fst_clear_intr
(paren
id|card
)paren
suffix:semicolon
id|FST_WRB
(paren
id|card
comma
id|interruptHandshake
comma
l_int|0xEE
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ifr-&gt;ifr_data
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|gather_conf_info
(paren
id|card
comma
id|port
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|FSTSETCONF
suffix:colon
multiline_comment|/* Most of the setting have been moved to the generic ioctls&n;                 * this just covers debug and board ident mode now&n;                 */
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|info
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|set_conf_from_info
(paren
id|card
comma
id|port
comma
op_amp
id|info
)paren
suffix:semicolon
r_case
id|SIOCWANDEV
suffix:colon
r_switch
c_cond
(paren
id|ifr-&gt;ifr_settings-&gt;type
)paren
(brace
r_case
id|IF_GET_IFACE
suffix:colon
r_return
id|fst_get_iface
(paren
id|card
comma
id|port
comma
id|ifr
)paren
suffix:semicolon
r_case
id|IF_IFACE_SYNC_SERIAL
suffix:colon
r_case
id|IF_IFACE_V35
suffix:colon
r_case
id|IF_IFACE_V24
suffix:colon
r_case
id|IF_IFACE_X21
suffix:colon
r_return
id|fst_set_iface
(paren
id|card
comma
id|port
comma
id|ifr
)paren
suffix:semicolon
r_default
suffix:colon
r_return
id|hdlc_ioctl
(paren
id|dev
comma
id|ifr
comma
id|cmd
)paren
suffix:semicolon
)brace
r_default
suffix:colon
multiline_comment|/* Not one of ours. Pass through to HDLC package */
r_return
id|hdlc_ioctl
(paren
id|dev
comma
id|ifr
comma
id|cmd
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|fst_openport
id|fst_openport
(paren
r_struct
id|fst_port_info
op_star
id|port
)paren
(brace
r_int
id|signals
suffix:semicolon
multiline_comment|/* Only init things if card is actually running. This allows open to&n;         * succeed for downloads etc.&n;         */
r_if
c_cond
(paren
id|port-&gt;card-&gt;state
op_eq
id|FST_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;run
)paren
(brace
id|dbg
(paren
id|DBG_OPEN
comma
l_string|&quot;open: found port already running&bslash;n&quot;
)paren
suffix:semicolon
id|fst_issue_cmd
(paren
id|port
comma
id|STOPPORT
)paren
suffix:semicolon
id|port-&gt;run
op_assign
l_int|0
suffix:semicolon
)brace
id|fst_rx_config
(paren
id|port
)paren
suffix:semicolon
id|fst_tx_config
(paren
id|port
)paren
suffix:semicolon
id|fst_op_raise
(paren
id|port
comma
id|OPSTS_RTS
op_or
id|OPSTS_DTR
)paren
suffix:semicolon
id|fst_issue_cmd
(paren
id|port
comma
id|STARTPORT
)paren
suffix:semicolon
id|port-&gt;run
op_assign
l_int|1
suffix:semicolon
id|signals
op_assign
id|FST_RDL
(paren
id|port-&gt;card
comma
id|v24DebouncedSts
(braket
id|port-&gt;index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signals
op_amp
(paren
(paren
id|port-&gt;hwif
op_eq
id|X21
)paren
ques
c_cond
id|IPSTS_INDICATE
suffix:colon
id|IPSTS_DCD
)paren
)paren
id|netif_carrier_on
(paren
id|port_to_dev
(paren
id|port
)paren
)paren
suffix:semicolon
r_else
id|netif_carrier_off
(paren
id|port_to_dev
(paren
id|port
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|fst_closeport
id|fst_closeport
(paren
r_struct
id|fst_port_info
op_star
id|port
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;card-&gt;state
op_eq
id|FST_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;run
)paren
(brace
id|port-&gt;run
op_assign
l_int|0
suffix:semicolon
id|fst_op_lower
(paren
id|port
comma
id|OPSTS_RTS
op_or
id|OPSTS_DTR
)paren
suffix:semicolon
id|fst_issue_cmd
(paren
id|port
comma
id|STOPPORT
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg
(paren
id|DBG_OPEN
comma
l_string|&quot;close: port not running&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_int
DECL|function|fst_open
id|fst_open
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|hdlc_open
(paren
id|dev_to_hdlc
(paren
id|dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|fst_openport
(paren
id|dev_to_port
(paren
id|dev
)paren
)paren
suffix:semicolon
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|fst_close
id|fst_close
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
id|fst_closeport
(paren
id|dev_to_port
(paren
id|dev
)paren
)paren
suffix:semicolon
id|hdlc_close
(paren
id|dev_to_hdlc
(paren
id|dev
)paren
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|fst_attach
id|fst_attach
(paren
id|hdlc_device
op_star
id|hdlc
comma
r_int
r_int
id|encoding
comma
r_int
r_int
id|parity
)paren
(brace
multiline_comment|/* Setting currently fixed in FarSync card so we check and forget */
r_if
c_cond
(paren
id|encoding
op_ne
id|ENCODING_NRZ
op_logical_or
id|parity
op_ne
id|PARITY_CRC16_PR1_CCITT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|fst_tx_timeout
id|fst_tx_timeout
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|fst_port_info
op_star
id|port
suffix:semicolon
id|dbg
(paren
id|DBG_INTR
op_or
id|DBG_TX
comma
l_string|&quot;tx_timeout&bslash;n&quot;
)paren
suffix:semicolon
id|port
op_assign
id|dev_to_port
(paren
id|dev
)paren
suffix:semicolon
id|port-&gt;hdlc.stats.tx_errors
op_increment
suffix:semicolon
id|port-&gt;hdlc.stats.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;txcnt
OG
l_int|0
)paren
id|fst_issue_cmd
(paren
id|port
comma
id|ABORTTX
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|fst_start_xmit
id|fst_start_xmit
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|fst_card_info
op_star
id|card
suffix:semicolon
r_struct
id|fst_port_info
op_star
id|port
suffix:semicolon
r_int
r_char
id|dmabits
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|pi
suffix:semicolon
r_int
id|txp
suffix:semicolon
id|port
op_assign
id|dev_to_port
(paren
id|dev
)paren
suffix:semicolon
id|card
op_assign
id|port-&gt;card
suffix:semicolon
multiline_comment|/* Drop packet with error if we don&squot;t have carrier */
r_if
c_cond
(paren
op_logical_neg
id|netif_carrier_ok
(paren
id|dev
)paren
)paren
(brace
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|port-&gt;hdlc.stats.tx_errors
op_increment
suffix:semicolon
id|port-&gt;hdlc.stats.tx_carrier_errors
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Drop it if it&squot;s too big! MTU failure ? */
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|LEN_TX_BUFFER
)paren
(brace
id|dbg
(paren
id|DBG_TX
comma
l_string|&quot;Packet too large %d vs %d&bslash;n&quot;
comma
id|skb-&gt;len
comma
id|LEN_TX_BUFFER
)paren
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|port-&gt;hdlc.stats.tx_errors
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check we have a buffer */
id|pi
op_assign
id|port-&gt;index
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
id|txp
op_assign
id|port-&gt;txpos
suffix:semicolon
id|dmabits
op_assign
id|FST_RDB
(paren
id|card
comma
id|txDescrRing
(braket
id|pi
)braket
(braket
id|txp
)braket
dot
id|bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabits
op_amp
id|DMA_OWN
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
id|dbg
(paren
id|DBG_TX
comma
l_string|&quot;Out of Tx buffers&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|port-&gt;hdlc.stats.tx_errors
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|port-&gt;txpos
op_ge
id|NUM_TX_BUFFER
)paren
id|port-&gt;txpos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|port-&gt;txcnt
op_ge
id|NUM_TX_BUFFER
)paren
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Release the card lock before we copy the data as we now have&n;         * exclusive access to the buffer.&n;         */
id|spin_unlock_irqrestore
(paren
op_amp
id|card-&gt;card_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Enqueue the packet */
id|memcpy_toio
(paren
id|card-&gt;mem
op_plus
id|BUF_OFFSET
(paren
id|txBuffer
(braket
id|pi
)braket
(braket
id|txp
)braket
(braket
l_int|0
)braket
)paren
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|FST_WRW
(paren
id|card
comma
id|txDescrRing
(braket
id|pi
)braket
(braket
id|txp
)braket
dot
id|bcnt
comma
id|cnv_bcnt
(paren
id|skb-&gt;len
)paren
)paren
suffix:semicolon
id|FST_WRB
(paren
id|card
comma
id|txDescrRing
(braket
id|pi
)braket
(braket
id|txp
)braket
dot
id|bits
comma
id|DMA_OWN
op_or
id|TX_STP
op_or
id|TX_ENP
)paren
suffix:semicolon
id|port-&gt;hdlc.stats.tx_packets
op_increment
suffix:semicolon
id|port-&gt;hdlc.stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *      Card setup having checked hardware resources.&n; *      Should be pretty bizarre if we get an error here (kernel memory&n; *      exhaustion is one possibility). If we do see a problem we report it&n; *      via a printk and leave the corresponding interface and all that follow&n; *      disabled.&n; */
DECL|variable|__devinitdata
r_static
r_char
op_star
id|type_strings
(braket
)braket
id|__devinitdata
op_assign
(brace
l_string|&quot;no hardware&quot;
comma
multiline_comment|/* Should never be seen */
l_string|&quot;FarSync T2P&quot;
comma
l_string|&quot;FarSync T4P&quot;
)brace
suffix:semicolon
r_static
r_void
id|__devinit
DECL|function|fst_init_card
id|fst_init_card
(paren
r_struct
id|fst_card_info
op_star
id|card
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* We&squot;re working on a number of ports based on the card ID. If the&n;         * firmware detects something different later (should never happen)&n;         * we&squot;ll have to revise it in some way then.&n;         */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|card-&gt;nports
suffix:semicolon
id|i
op_increment
)paren
(brace
id|card-&gt;ports
(braket
id|i
)braket
dot
id|card
op_assign
id|card
suffix:semicolon
id|card-&gt;ports
(braket
id|i
)braket
dot
id|index
op_assign
id|i
suffix:semicolon
id|card-&gt;ports
(braket
id|i
)braket
dot
id|run
op_assign
l_int|0
suffix:semicolon
id|dev
op_assign
id|hdlc_to_dev
(paren
op_amp
id|card-&gt;ports
(braket
id|i
)braket
dot
id|hdlc
)paren
suffix:semicolon
multiline_comment|/* Fill in the net device info */
multiline_comment|/* Since this is a PCI setup this is purely&n;                                 * informational. Give them the buffer addresses&n;                                 * and basic card I/O.&n;                                 */
id|dev-&gt;mem_start
op_assign
id|card-&gt;phys_mem
op_plus
id|BUF_OFFSET
(paren
id|txBuffer
(braket
id|i
)braket
(braket
l_int|0
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|card-&gt;phys_mem
op_plus
id|BUF_OFFSET
(paren
id|txBuffer
(braket
id|i
)braket
(braket
id|NUM_TX_BUFFER
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|dev-&gt;rmem_start
op_assign
id|card-&gt;phys_mem
op_plus
id|BUF_OFFSET
(paren
id|rxBuffer
(braket
id|i
)braket
(braket
l_int|0
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|dev-&gt;rmem_end
op_assign
id|card-&gt;phys_mem
op_plus
id|BUF_OFFSET
(paren
id|rxBuffer
(braket
id|i
)braket
(braket
id|NUM_RX_BUFFER
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|card-&gt;pci_conf
suffix:semicolon
id|dev-&gt;irq
op_assign
id|card-&gt;irq
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
id|FST_TX_QUEUE_LEN
suffix:semicolon
id|dev-&gt;open
op_assign
id|fst_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|fst_close
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|fst_ioctl
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|FST_TX_TIMEOUT
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|fst_tx_timeout
suffix:semicolon
id|card-&gt;ports
(braket
id|i
)braket
dot
id|hdlc.attach
op_assign
id|fst_attach
suffix:semicolon
id|card-&gt;ports
(braket
id|i
)braket
dot
id|hdlc.xmit
op_assign
id|fst_start_xmit
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|register_hdlc_device
(paren
op_amp
id|card-&gt;ports
(braket
id|i
)braket
dot
id|hdlc
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk_err
(paren
l_string|&quot;Cannot register HDLC device for port %d&quot;
l_string|&quot; (errno %d)&bslash;n&quot;
comma
id|i
comma
op_minus
id|err
)paren
suffix:semicolon
id|card-&gt;nports
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_lock_init
(paren
op_amp
id|card-&gt;card_lock
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s-%s: %s IRQ%d, %d ports&bslash;n&quot;
comma
id|hdlc_to_dev
c_func
(paren
op_amp
id|card-&gt;ports
(braket
l_int|0
)braket
dot
id|hdlc
)paren
op_member_access_from_pointer
id|name
comma
id|hdlc_to_dev
c_func
(paren
op_amp
id|card-&gt;ports
(braket
id|card-&gt;nports
op_minus
l_int|1
)braket
dot
id|hdlc
)paren
op_member_access_from_pointer
id|name
comma
id|type_strings
(braket
id|card-&gt;type
)braket
comma
id|card-&gt;irq
comma
id|card-&gt;nports
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *      Initialise card when detected.&n; *      Returns 0 to indicate success, or errno otherwise.&n; */
r_static
r_int
id|__devinit
DECL|function|fst_add_one
id|fst_add_one
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|ent
)paren
(brace
r_static
r_int
id|firsttime_done
op_assign
l_int|0
suffix:semicolon
r_struct
id|fst_card_info
op_star
id|card
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|firsttime_done
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;FarSync X21 driver &quot;
id|FST_USER_VERSION
l_string|&quot; (c) 2001 FarSite Communications Ltd.&bslash;n&quot;
)paren
suffix:semicolon
id|firsttime_done
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Allocate driver private data */
id|card
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|fst_card_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_eq
l_int|NULL
)paren
(brace
id|printk_err
(paren
l_string|&quot;FarSync card found but insufficient memory for&quot;
l_string|&quot; driver storage&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|card
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|fst_card_info
)paren
)paren
suffix:semicolon
multiline_comment|/* Record info we need*/
id|card-&gt;irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|card-&gt;pci_conf
op_assign
id|pci_resource_start
(paren
id|pdev
comma
l_int|1
)paren
suffix:semicolon
id|card-&gt;phys_mem
op_assign
id|pci_resource_start
(paren
id|pdev
comma
l_int|2
)paren
suffix:semicolon
id|card-&gt;phys_ctlmem
op_assign
id|pci_resource_start
(paren
id|pdev
comma
l_int|3
)paren
suffix:semicolon
id|card-&gt;type
op_assign
id|ent-&gt;driver_data
suffix:semicolon
id|card-&gt;nports
op_assign
(paren
id|ent-&gt;driver_data
op_eq
id|FST_TYPE_T2P
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|4
suffix:semicolon
id|card-&gt;state
op_assign
id|FST_UNINIT
suffix:semicolon
id|dbg
(paren
id|DBG_PCI
comma
l_string|&quot;type %d nports %d irq %d&bslash;n&quot;
comma
id|card-&gt;type
comma
id|card-&gt;nports
comma
id|card-&gt;irq
)paren
suffix:semicolon
id|dbg
(paren
id|DBG_PCI
comma
l_string|&quot;conf %04x mem %08x ctlmem %08x&bslash;n&quot;
comma
id|card-&gt;pci_conf
comma
id|card-&gt;phys_mem
comma
id|card-&gt;phys_ctlmem
)paren
suffix:semicolon
multiline_comment|/* Check we can get access to the memory and I/O regions */
r_if
c_cond
(paren
op_logical_neg
id|request_region
(paren
id|card-&gt;pci_conf
comma
l_int|0x80
comma
l_string|&quot;PLX config regs&quot;
)paren
)paren
(brace
id|printk_err
(paren
l_string|&quot;Unable to get config I/O @ 0x%04X&bslash;n&quot;
comma
id|card-&gt;pci_conf
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|error_free_card
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
(paren
id|card-&gt;phys_mem
comma
id|FST_MEMSIZE
comma
l_string|&quot;Shared RAM&quot;
)paren
)paren
(brace
id|printk_err
(paren
l_string|&quot;Unable to get main memory @ 0x%08X&bslash;n&quot;
comma
id|card-&gt;phys_mem
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|error_release_io
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
(paren
id|card-&gt;phys_ctlmem
comma
l_int|0x10
comma
l_string|&quot;Control memory&quot;
)paren
)paren
(brace
id|printk_err
(paren
l_string|&quot;Unable to get control memory @ 0x%08X&bslash;n&quot;
comma
id|card-&gt;phys_ctlmem
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|error_release_mem
suffix:semicolon
)brace
multiline_comment|/* Try to enable the device */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|pci_enable_device
(paren
id|pdev
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk_err
(paren
l_string|&quot;Failed to enable card. Err %d&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|error_release_ctlmem
suffix:semicolon
)brace
multiline_comment|/* Get virtual addresses of memory regions */
r_if
c_cond
(paren
(paren
id|card-&gt;mem
op_assign
id|ioremap
(paren
id|card-&gt;phys_mem
comma
id|FST_MEMSIZE
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk_err
(paren
l_string|&quot;Physical memory remap failed&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|error_release_ctlmem
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|card-&gt;ctlmem
op_assign
id|ioremap
(paren
id|card-&gt;phys_ctlmem
comma
l_int|0x10
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk_err
(paren
l_string|&quot;Control memory remap failed&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|error_unmap_mem
suffix:semicolon
)brace
id|dbg
(paren
id|DBG_PCI
comma
l_string|&quot;kernel mem %p, ctlmem %p&bslash;n&quot;
comma
id|card-&gt;mem
comma
id|card-&gt;ctlmem
)paren
suffix:semicolon
multiline_comment|/* Reset the card&squot;s processor */
id|fst_cpureset
(paren
id|card
)paren
suffix:semicolon
id|card-&gt;state
op_assign
id|FST_RESET
suffix:semicolon
multiline_comment|/* Register the interrupt handler */
r_if
c_cond
(paren
id|request_irq
(paren
id|card-&gt;irq
comma
id|fst_intr
comma
id|SA_SHIRQ
comma
id|FST_DEV_NAME
comma
id|card
)paren
)paren
(brace
id|printk_err
(paren
l_string|&quot;Unable to register interrupt %d&bslash;n&quot;
comma
id|card-&gt;irq
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|error_unmap_ctlmem
suffix:semicolon
)brace
multiline_comment|/* Record driver data for later use */
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
id|card
)paren
suffix:semicolon
multiline_comment|/* Remainder of card setup */
id|fst_init_card
(paren
id|card
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Success */
multiline_comment|/* Failure. Release resources */
id|error_unmap_ctlmem
suffix:colon
id|iounmap
(paren
id|card-&gt;ctlmem
)paren
suffix:semicolon
id|error_unmap_mem
suffix:colon
id|iounmap
(paren
id|card-&gt;mem
)paren
suffix:semicolon
id|error_release_ctlmem
suffix:colon
id|release_mem_region
(paren
id|card-&gt;phys_ctlmem
comma
l_int|0x10
)paren
suffix:semicolon
id|error_release_mem
suffix:colon
id|release_mem_region
(paren
id|card-&gt;phys_mem
comma
id|FST_MEMSIZE
)paren
suffix:semicolon
id|error_release_io
suffix:colon
id|release_region
(paren
id|card-&gt;pci_conf
comma
l_int|0x80
)paren
suffix:semicolon
id|error_free_card
suffix:colon
id|kfree
(paren
id|card
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *      Cleanup and close down a card&n; */
r_static
r_void
id|__devexit
DECL|function|fst_remove_one
id|fst_remove_one
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|fst_card_info
op_star
id|card
suffix:semicolon
r_int
id|i
suffix:semicolon
id|card
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|card-&gt;nports
suffix:semicolon
id|i
op_increment
)paren
(brace
id|unregister_hdlc_device
(paren
op_amp
id|card-&gt;ports
(braket
id|i
)braket
dot
id|hdlc
)paren
suffix:semicolon
)brace
id|fst_disable_intr
(paren
id|card
)paren
suffix:semicolon
id|free_irq
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
id|iounmap
(paren
id|card-&gt;ctlmem
)paren
suffix:semicolon
id|iounmap
(paren
id|card-&gt;mem
)paren
suffix:semicolon
id|release_mem_region
(paren
id|card-&gt;phys_ctlmem
comma
l_int|0x10
)paren
suffix:semicolon
id|release_mem_region
(paren
id|card-&gt;phys_mem
comma
id|FST_MEMSIZE
)paren
suffix:semicolon
id|release_region
(paren
id|card-&gt;pci_conf
comma
l_int|0x80
)paren
suffix:semicolon
id|kfree
(paren
id|card
)paren
suffix:semicolon
)brace
DECL|variable|fst_driver
r_static
r_struct
id|pci_driver
id|fst_driver
op_assign
(brace
id|name
suffix:colon
id|FST_NAME
comma
id|id_table
suffix:colon
id|fst_pci_dev_id
comma
id|probe
suffix:colon
id|fst_add_one
comma
id|remove
suffix:colon
id|__devexit_p
c_func
(paren
id|fst_remove_one
)paren
comma
id|suspend
suffix:colon
l_int|NULL
comma
id|resume
suffix:colon
l_int|NULL
comma
)brace
suffix:semicolon
r_static
r_int
id|__init
DECL|function|fst_init
id|fst_init
c_func
(paren
r_void
)paren
(brace
r_return
id|pci_module_init
(paren
op_amp
id|fst_driver
)paren
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|fst_cleanup_module
id|fst_cleanup_module
c_func
(paren
r_void
)paren
(brace
id|pci_unregister_driver
(paren
op_amp
id|fst_driver
)paren
suffix:semicolon
)brace
DECL|variable|fst_init
id|module_init
(paren
id|fst_init
)paren
suffix:semicolon
DECL|variable|fst_cleanup_module
id|module_exit
(paren
id|fst_cleanup_module
)paren
suffix:semicolon
eof
