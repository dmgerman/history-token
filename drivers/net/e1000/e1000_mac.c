multiline_comment|/*******************************************************************************&n;&n;  This software program is available to you under a choice of one of two&n;  licenses. You may choose to be licensed under either the GNU General Public&n;  License (GPL) Version 2, June 1991, available at&n;  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the&n;  text of which follows:&n;  &n;  Recipient has requested a license and Intel Corporation (&quot;Intel&quot;) is willing&n;  to grant a license for the software entitled Linux Base Driver for the&n;  Intel(R) PRO/1000 Family of Adapters (e1000) (the &quot;Software&quot;) being provided&n;  by Intel Corporation. The following definitions apply to this license:&n;  &n;  &quot;Licensed Patents&quot; means patent claims licensable by Intel Corporation which&n;  are necessarily infringed by the use of sale of the Software alone or when&n;  combined with the operating system referred to below.&n;  &n;  &quot;Recipient&quot; means the party to whom Intel delivers this Software.&n;  &n;  &quot;Licensee&quot; means Recipient and those third parties that receive a license to&n;  any operating system available under the GNU Public License version 2.0 or&n;  later.&n;  &n;  Copyright (c) 1999 - 2002 Intel Corporation.&n;  All rights reserved.&n;  &n;  The license is provided to Recipient and Recipient&squot;s Licensees under the&n;  following terms.&n;  &n;  Redistribution and use in source and binary forms of the Software, with or&n;  without modification, are permitted provided that the following conditions&n;  are met:&n;  &n;  Redistributions of source code of the Software may retain the above&n;  copyright notice, this list of conditions and the following disclaimer.&n;  &n;  Redistributions in binary form of the Software may reproduce the above&n;  copyright notice, this list of conditions and the following disclaimer in&n;  the documentation and/or materials provided with the distribution.&n;  &n;  Neither the name of Intel Corporation nor the names of its contributors&n;  shall be used to endorse or promote products derived from this Software&n;  without specific prior written permission.&n;  &n;  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide,&n;  royalty-free patent license under Licensed Patents to make, use, sell, offer&n;  to sell, import and otherwise transfer the Software, if any, in source code&n;  and object code form. This license shall include changes to the Software&n;  that are error corrections or other minor changes to the Software that do&n;  not add functionality or features when the Software is incorporated in any&n;  version of an operating system that has been distributed under the GNU&n;  General Public License 2.0 or later. This patent license shall apply to the&n;  combination of the Software and any operating system licensed under the GNU&n;  Public License version 2.0 or later if, at the time Intel provides the&n;  Software to Recipient, such addition of the Software to the then publicly&n;  available versions of such operating systems available under the GNU Public&n;  License version 2.0 or later (whether in gold, beta or alpha form) causes&n;  such combination to be covered by the Licensed Patents. The patent license&n;  shall not apply to any other combinations which include the Software. NO&n;  hardware per se is licensed hereunder.&n;  &n;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;&n;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n;  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n;  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY&n;  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES&n;  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;&n;  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED&n;  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR&n;  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&n;  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n;&n;*******************************************************************************/
multiline_comment|/* e1000_mac.c&n; * Shared functions for accessing and configuring the MAC&n; */
macro_line|#include &quot;e1000_mac.h&quot;
macro_line|#include &quot;e1000_phy.h&quot;
multiline_comment|/******************************************************************************&n; * Raises the EEPROM&squot;s clock input.&n; *&n; * shared - Struct containing variables accessed by shared code&n; * eecd_reg - EECD&squot;s current value&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_raise_clock
id|e1000_raise_clock
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint32
op_star
id|eecd_reg
)paren
(brace
multiline_comment|/* Raise the clock input to the EEPROM (by setting the SK bit), and then&n;     * wait 50 microseconds.&n;     */
op_star
id|eecd_reg
op_assign
op_star
id|eecd_reg
op_or
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|EECD
comma
op_star
id|eecd_reg
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Lowers the EEPROM&squot;s clock input.&n; *&n; * shared - Struct containing variables accessed by shared code &n; * eecd_reg - EECD&squot;s current value&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_lower_clock
id|e1000_lower_clock
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint32
op_star
id|eecd_reg
)paren
(brace
multiline_comment|/* Lower the clock input to the EEPROM (by clearing the SK bit), and then &n;     * wait 50 microseconds. &n;     */
op_star
id|eecd_reg
op_assign
op_star
id|eecd_reg
op_amp
op_complement
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|EECD
comma
op_star
id|eecd_reg
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Shift data bits out to the EEPROM.&n; *&n; * shared - Struct containing variables accessed by shared code&n; * data - data to send to the EEPROM&n; * count - number of bits to shift out&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_shift_out_bits
id|e1000_shift_out_bits
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint16
id|data
comma
r_uint16
id|count
)paren
(brace
r_uint32
id|eecd_reg
suffix:semicolon
r_uint32
id|mask
suffix:semicolon
multiline_comment|/* We need to shift &quot;count&quot; bits out to the EEPROM. So, value in the&n;     * &quot;data&quot; parameter will be shifted out to the EEPROM one bit at a time.&n;     * In order to do this, &quot;data&quot; must be broken down into bits. &n;     */
id|mask
op_assign
l_int|0x01
op_lshift
(paren
id|count
op_minus
l_int|1
)paren
suffix:semicolon
id|eecd_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|EECD
)paren
suffix:semicolon
id|eecd_reg
op_and_assign
op_complement
(paren
id|E1000_EECD_DO
op_or
id|E1000_EECD_DI
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* A &quot;1&quot; is shifted out to the EEPROM by setting bit &quot;DI&quot; to a &quot;1&quot;,&n;         * and then raising and then lowering the clock (the SK bit controls&n;         * the clock input to the EEPROM).  A &quot;0&quot; is shifted out to the EEPROM&n;         * by setting &quot;DI&quot; to &quot;0&quot; and then raising and then lowering the clock.&n;         */
id|eecd_reg
op_and_assign
op_complement
id|E1000_EECD_DI
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|mask
)paren
(brace
id|eecd_reg
op_or_assign
id|E1000_EECD_DI
suffix:semicolon
)brace
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|EECD
comma
id|eecd_reg
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|e1000_raise_clock
c_func
(paren
id|shared
comma
op_amp
id|eecd_reg
)paren
suffix:semicolon
id|e1000_lower_clock
c_func
(paren
id|shared
comma
op_amp
id|eecd_reg
)paren
suffix:semicolon
id|mask
op_assign
id|mask
op_rshift
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mask
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* We leave the &quot;DI&quot; bit set to &quot;0&quot; when we leave this routine. */
id|eecd_reg
op_and_assign
op_complement
id|E1000_EECD_DI
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|EECD
comma
id|eecd_reg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Shift data bits in from the EEPROM&n; *&n; * shared - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_static
r_uint16
DECL|function|e1000_shift_in_bits
id|e1000_shift_in_bits
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|eecd_reg
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_uint16
id|data
suffix:semicolon
multiline_comment|/* In order to read a register from the EEPROM, we need to shift 16 bits &n;     * in from the EEPROM. Bits are &quot;shifted in&quot; by raising the clock input to&n;     * the EEPROM (setting the SK bit), and then reading the value of the &quot;DO&quot;&n;     * bit.  During this &quot;shifting in&quot; process the &quot;DI&quot; bit should always be &n;     * clear..&n;     */
id|eecd_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|EECD
)paren
suffix:semicolon
id|eecd_reg
op_and_assign
op_complement
(paren
id|E1000_EECD_DO
op_or
id|E1000_EECD_DI
)paren
suffix:semicolon
id|data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|data
op_lshift
l_int|1
suffix:semicolon
id|e1000_raise_clock
c_func
(paren
id|shared
comma
op_amp
id|eecd_reg
)paren
suffix:semicolon
id|eecd_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|EECD
)paren
suffix:semicolon
id|eecd_reg
op_and_assign
op_complement
(paren
id|E1000_EECD_DI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eecd_reg
op_amp
id|E1000_EECD_DO
)paren
(brace
id|data
op_or_assign
l_int|1
suffix:semicolon
)brace
id|e1000_lower_clock
c_func
(paren
id|shared
comma
op_amp
id|eecd_reg
)paren
suffix:semicolon
)brace
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Prepares EEPROM for access&n; *&n; * shared - Struct containing variables accessed by shared code&n; *&n; * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This &n; * function should be called before issuing a command to the EEPROM.&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_setup_eeprom
id|e1000_setup_eeprom
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|eecd_reg
suffix:semicolon
id|eecd_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|EECD
)paren
suffix:semicolon
multiline_comment|/* Clear SK and DI */
id|eecd_reg
op_and_assign
op_complement
(paren
id|E1000_EECD_SK
op_or
id|E1000_EECD_DI
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|EECD
comma
id|eecd_reg
)paren
suffix:semicolon
multiline_comment|/* Set CS */
id|eecd_reg
op_or_assign
id|E1000_EECD_CS
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|EECD
comma
id|eecd_reg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Returns EEPROM to a &quot;standby&quot; state&n; * &n; * shared - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_standby_eeprom
id|e1000_standby_eeprom
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|eecd_reg
suffix:semicolon
id|eecd_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|EECD
)paren
suffix:semicolon
multiline_comment|/* Deselct EEPROM */
id|eecd_reg
op_and_assign
op_complement
(paren
id|E1000_EECD_CS
op_or
id|E1000_EECD_SK
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|EECD
comma
id|eecd_reg
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* Clock high */
id|eecd_reg
op_or_assign
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|EECD
comma
id|eecd_reg
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* Select EEPROM */
id|eecd_reg
op_or_assign
id|E1000_EECD_CS
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|EECD
comma
id|eecd_reg
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* Clock low */
id|eecd_reg
op_and_assign
op_complement
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|EECD
comma
id|eecd_reg
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Forces the MAC&squot;s flow control settings.&n; * &n; * shared - Struct containing variables accessed by shared code&n; *&n; * Sets the TFCE and RFCE bits in the device control register to reflect&n; * the adapter settings. TFCE and RFCE need to be explicitly set by&n; * software when a Copper PHY is used because autonegotiation is managed&n; * by the PHY rather than the MAC. Software must also configure these&n; * bits when link is forced on a fiber connection.&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_force_mac_fc
id|e1000_force_mac_fc
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|ctrl_reg
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_force_mac_fc&quot;
)paren
suffix:semicolon
multiline_comment|/* Get the current configuration of the Device Control Register */
id|ctrl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Because we didn&squot;t get link via the internal auto-negotiation&n;     * mechanism (we either forced link or we got link via PHY&n;     * auto-neg), we have to manually enable/disable transmit an&n;     * receive flow control.&n;     *&n;     * The &quot;Case&quot; statement below enables/disable flow control&n;     * according to the &quot;shared-&gt;fc&quot; parameter.&n;     *&n;     * The possible values of the &quot;fc&quot; parameter are:&n;     *      0:  Flow control is completely disabled&n;     *      1:  Rx flow control is enabled (we can receive pause&n;     *          frames but not send pause frames).&n;     *      2:  Tx flow control is enabled (we can send pause frames&n;     *          frames but we do not receive pause frames).&n;     *      3:  Both Rx and TX flow control (symmetric) is enabled.&n;     *  other:  No other values should be possible at this point.&n;     */
r_switch
c_cond
(paren
id|shared-&gt;fc
)paren
(brace
r_case
id|e1000_fc_none
suffix:colon
id|ctrl_reg
op_and_assign
(paren
op_complement
(paren
id|E1000_CTRL_TFCE
op_or
id|E1000_CTRL_RFCE
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_rx_pause
suffix:colon
id|ctrl_reg
op_and_assign
(paren
op_complement
id|E1000_CTRL_TFCE
)paren
suffix:semicolon
id|ctrl_reg
op_or_assign
id|E1000_CTRL_RFCE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_tx_pause
suffix:colon
id|ctrl_reg
op_and_assign
(paren
op_complement
id|E1000_CTRL_RFCE
)paren
suffix:semicolon
id|ctrl_reg
op_or_assign
id|E1000_CTRL_TFCE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_full
suffix:colon
id|ctrl_reg
op_or_assign
(paren
id|E1000_CTRL_TFCE
op_or
id|E1000_CTRL_RFCE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow control param set incorrectly&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Disable TX Flow Control for 82542 (rev 2.0) */
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
id|ctrl_reg
op_and_assign
(paren
op_complement
id|E1000_CTRL_TFCE
)paren
suffix:semicolon
)brace
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
id|ctrl_reg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Reset the transmit and receive units; mask and clear all interrupts.&n; *&n; * shared - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|e1000_adapter_stop
id|e1000_adapter_stop
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|ctrl_reg
suffix:semicolon
r_uint32
id|ctrl_ext_reg
suffix:semicolon
r_uint32
id|icr_reg
suffix:semicolon
r_uint16
id|pci_cmd_word
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_shared_adapter_stop&quot;
)paren
suffix:semicolon
multiline_comment|/* If we are stopped or resetting exit gracefully and wait to be&n;     * started again before accessing the hardware.&n;     */
r_if
c_cond
(paren
id|shared-&gt;adapter_stopped
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Exiting because the adapter is already stopped!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Set the Adapter Stopped flag so other driver functions stop&n;     * touching the Hardware.&n;     */
id|shared-&gt;adapter_stopped
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
r_if
c_cond
(paren
id|shared-&gt;pci_cmd_word
op_amp
id|CMD_MEM_WRT_INVALIDATE
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Disabling MWI on 82542 rev 2.0&bslash;n&quot;
)paren
suffix:semicolon
id|pci_cmd_word
op_assign
id|shared-&gt;pci_cmd_word
op_amp
op_complement
id|CMD_MEM_WRT_INVALIDATE
suffix:semicolon
id|e1000_write_pci_cfg
c_func
(paren
id|shared
comma
id|PCI_COMMAND_REGISTER
comma
op_amp
id|pci_cmd_word
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Clear interrupt mask to stop board from generating interrupts */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Masking off all interrupts&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|IMC
comma
l_int|0xffffffff
)paren
suffix:semicolon
multiline_comment|/* Disable the Transmit and Receive units.  Then delay to allow&n;     * any pending transactions to complete before we hit the MAC with&n;     * the global reset.&n;     */
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|RCTL
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|TCTL
comma
id|E1000_TCTL_PSP
)paren
suffix:semicolon
multiline_comment|/* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
id|shared-&gt;tbi_compatibility_on
op_assign
id|FALSE
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Issue a global reset to the MAC.  This will reset the chip&squot;s&n;     * transmit, receive, DMA, and link units.  It will not effect&n;     * the current PCI configuration.  The global reset bit is self-&n;     * clearing, and should clear within a microsecond.&n;     */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Issuing a global reset to MAC&bslash;n&quot;
)paren
suffix:semicolon
id|ctrl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
(paren
id|ctrl_reg
op_or
id|E1000_CTRL_RST
)paren
)paren
suffix:semicolon
multiline_comment|/* Delay a few ms just to allow the reset to complete */
id|msec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
macro_line|#if DBG
multiline_comment|/* Make sure the self-clearing global reset bit did self clear */
id|ctrl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|ctrl_reg
op_amp
id|E1000_CTRL_RST
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Force a reload from the EEPROM */
id|ctrl_ext_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL_EXT
)paren
suffix:semicolon
id|ctrl_ext_reg
op_or_assign
id|E1000_CTRL_EXT_EE_RST
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL_EXT
comma
id|ctrl_ext_reg
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Clear interrupt mask to stop board from generating interrupts */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Masking off all interrupts&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|IMC
comma
l_int|0xffffffff
)paren
suffix:semicolon
multiline_comment|/* Clear any pending interrupt events. */
id|icr_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|ICR
)paren
suffix:semicolon
multiline_comment|/* If MWI was previously enabled, reenable it. */
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
r_if
c_cond
(paren
id|shared-&gt;pci_cmd_word
op_amp
id|CMD_MEM_WRT_INVALIDATE
)paren
(brace
id|e1000_write_pci_cfg
c_func
(paren
id|shared
comma
id|PCI_COMMAND_REGISTER
comma
op_amp
id|shared-&gt;pci_cmd_word
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Performs basic configuration of the adapter.&n; *&n; * shared - Struct containing variables accessed by shared code&n; * &n; * Assumes that the controller has previously been reset and is in a &n; * post-reset uninitialized state. Initializes the receive address registers,&n; * multicast table, and VLAN filter table. Calls routines to setup link&n; * configuration and flow control settings. Clears all on-chip counters. Leaves&n; * the transmit and receive units disabled and uninitialized.&n; *****************************************************************************/
id|boolean_t
DECL|function|e1000_init_hw
id|e1000_init_hw
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|status_reg
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_uint16
id|pci_cmd_word
suffix:semicolon
id|boolean_t
id|status
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_init_hw&quot;
)paren
suffix:semicolon
multiline_comment|/* Set the Media Type and exit with error if it is not valid. */
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_ne
id|e1000_82543
)paren
(brace
multiline_comment|/* tbi_compatibility is only valid on 82543 */
id|shared-&gt;tbi_compatibility_en
op_assign
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_ge
id|e1000_82543
)paren
(brace
id|status_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_reg
op_amp
id|E1000_STATUS_TBIMODE
)paren
(brace
id|shared-&gt;media_type
op_assign
id|e1000_media_type_fiber
suffix:semicolon
multiline_comment|/* tbi_compatibility not valid on fiber */
id|shared-&gt;tbi_compatibility_en
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|shared-&gt;media_type
op_assign
id|e1000_media_type_copper
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* This is an 82542 (fiber only) */
id|shared-&gt;media_type
op_assign
id|e1000_media_type_fiber
suffix:semicolon
)brace
multiline_comment|/* Disabling VLAN filtering. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Initializing the IEEE VLAN&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|VET
comma
l_int|0
)paren
suffix:semicolon
id|e1000_clear_vfta
c_func
(paren
id|shared
)paren
suffix:semicolon
multiline_comment|/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
r_if
c_cond
(paren
id|shared-&gt;pci_cmd_word
op_amp
id|CMD_MEM_WRT_INVALIDATE
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Disabling MWI on 82542 rev 2.0&bslash;n&quot;
)paren
suffix:semicolon
id|pci_cmd_word
op_assign
id|shared-&gt;pci_cmd_word
op_amp
op_complement
id|CMD_MEM_WRT_INVALIDATE
suffix:semicolon
id|e1000_write_pci_cfg
c_func
(paren
id|shared
comma
id|PCI_COMMAND_REGISTER
comma
op_amp
id|pci_cmd_word
)paren
suffix:semicolon
)brace
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|RCTL
comma
id|E1000_RCTL_RST
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
multiline_comment|/* Setup the receive address. This involves initializing all of the Receive&n;     * Address Registers (RARs 0 - 15).&n;     */
id|e1000_init_rx_addrs
c_func
(paren
id|shared
)paren
suffix:semicolon
multiline_comment|/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|RCTL
comma
l_int|0
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shared-&gt;pci_cmd_word
op_amp
id|CMD_MEM_WRT_INVALIDATE
)paren
(brace
id|e1000_write_pci_cfg
c_func
(paren
id|shared
comma
id|PCI_COMMAND_REGISTER
comma
op_amp
id|shared-&gt;pci_cmd_word
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Zero out the Multicast HASH table */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Zeroing the MTA&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|E1000_MC_TBL_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|MTA
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Call a subroutine to configure the link and setup flow control. */
id|status
op_assign
id|e1000_setup_fc_and_link
c_func
(paren
id|shared
)paren
suffix:semicolon
multiline_comment|/* Clear all of the statistics registers (clear on read).  It is&n;     * important that we do this after we have tried to establish link&n;     * because the symbol error count will increment wildly if there&n;     * is no link.&n;     */
id|e1000_clear_hw_cntrs
c_func
(paren
id|shared
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Initializes receive address filters.&n; *&n; * shared - Struct containing variables accessed by shared code &n; *&n; * Places the MAC address in receive address register 0 and clears the rest&n; * of the receive addresss registers. Clears the multicast table. Assumes&n; * the receiver is in reset when the routine is called.&n; *****************************************************************************/
r_void
DECL|function|e1000_init_rx_addrs
id|e1000_init_rx_addrs
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_uint32
id|addr_low
suffix:semicolon
r_uint32
id|addr_high
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_init_rx_addrs&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup the receive address. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Programming MAC Address into RAR[0]&bslash;n&quot;
)paren
suffix:semicolon
id|addr_low
op_assign
(paren
id|shared-&gt;mac_addr
(braket
l_int|0
)braket
op_or
(paren
id|shared-&gt;mac_addr
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|shared-&gt;mac_addr
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|shared-&gt;mac_addr
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
)paren
suffix:semicolon
id|addr_high
op_assign
(paren
id|shared-&gt;mac_addr
(braket
l_int|4
)braket
op_or
(paren
id|shared-&gt;mac_addr
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_or
id|E1000_RAH_AV
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|RA
comma
l_int|0
comma
id|addr_low
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|RA
comma
l_int|1
comma
id|addr_high
)paren
suffix:semicolon
multiline_comment|/* Zero out the other 15 receive addresses. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Clearing RAR[1-15]&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|E1000_RAR_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|RA
comma
(paren
id|i
op_lshift
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|RA
comma
(paren
(paren
id|i
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Updates the MAC&squot;s list of multicast addresses.&n; *&n; * shared - Struct containing variables accessed by shared code&n; * mc_addr_list - the list of new multicast addresses&n; * mc_addr_count - number of addresses&n; * pad - number of bytes between addresses in the list&n; *&n; * The given list replaces any existing list. Clears the last 15 receive&n; * address registers and the multicast table. Uses receive address registers&n; * for the first 15 multicast addresses, and hashes the rest into the &n; * multicast table.&n; *****************************************************************************/
r_void
DECL|function|e1000_mc_addr_list_update
id|e1000_mc_addr_list_update
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint8
op_star
id|mc_addr_list
comma
r_uint32
id|mc_addr_count
comma
r_uint32
id|pad
)paren
(brace
r_uint32
id|hash_value
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_uint32
id|rar_used_count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* RAR[0] is used for our MAC address */
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_mc_addr_list_update&quot;
)paren
suffix:semicolon
multiline_comment|/* Set the new number of MC addresses that we are being requested to use. */
id|shared-&gt;num_mc_addrs
op_assign
id|mc_addr_count
suffix:semicolon
multiline_comment|/* Clear RAR[1-15] */
id|DEBUGOUT
c_func
(paren
l_string|&quot; Clearing RAR[1-15]&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rar_used_count
suffix:semicolon
id|i
OL
id|E1000_RAR_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|RA
comma
(paren
id|i
op_lshift
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|RA
comma
(paren
(paren
id|i
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear the MTA */
id|DEBUGOUT
c_func
(paren
l_string|&quot; Clearing MTA&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|E1000_NUM_MTA_REGISTERS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|MTA
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Add the new addresses */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mc_addr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot; Adding the multicast addresses:&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUGOUT7
c_func
(paren
l_string|&quot; MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X&bslash;n&quot;
comma
id|i
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|1
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|2
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|3
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|4
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|5
)braket
)paren
suffix:semicolon
id|hash_value
op_assign
id|e1000_hash_mc_addr
c_func
(paren
id|shared
comma
id|mc_addr_list
op_plus
(paren
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
)paren
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot; Hash value = 0x%03X&bslash;n&quot;
comma
id|hash_value
)paren
suffix:semicolon
multiline_comment|/* Place this multicast address in the RAR if there is room, *&n;         * else put it in the MTA            &n;         */
r_if
c_cond
(paren
id|rar_used_count
OL
id|E1000_RAR_ENTRIES
)paren
(brace
id|e1000_rar_set
c_func
(paren
id|shared
comma
id|mc_addr_list
op_plus
(paren
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
)paren
comma
id|rar_used_count
)paren
suffix:semicolon
id|rar_used_count
op_increment
suffix:semicolon
)brace
r_else
(brace
id|e1000_mta_set
c_func
(paren
id|shared
comma
id|hash_value
)paren
suffix:semicolon
)brace
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MC Update Complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Hashes an address to determine its location in the multicast table&n; *&n; * shared - Struct containing variables accessed by shared code&n; * mc_addr - the multicast address to hash &n; *****************************************************************************/
r_uint32
DECL|function|e1000_hash_mc_addr
id|e1000_hash_mc_addr
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint8
op_star
id|mc_addr
)paren
(brace
r_uint32
id|hash_value
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The portion of the address that is used for the hash table is&n;     * determined by the mc_filter_type setting.  &n;     */
r_switch
c_cond
(paren
id|shared-&gt;mc_filter_type
)paren
(brace
multiline_comment|/* [0] [1] [2] [3] [4] [5]&n;            * 01  AA  00  12  34  56&n;            * LSB                 MSB - According to H/W docs */
r_case
l_int|0
suffix:colon
multiline_comment|/* [47:36] i.e. 0x563 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
op_rshift
l_int|4
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* [46:35] i.e. 0xAC6 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
op_rshift
l_int|3
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|5
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* [45:34] i.e. 0x5D8 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
op_rshift
l_int|2
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|6
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* [43:32] i.e. 0x634 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hash_value
op_and_assign
l_int|0xFFF
suffix:semicolon
r_return
(paren
id|hash_value
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Sets the bit in the multicast table corresponding to the hash value.&n; *&n; * shared - Struct containing variables accessed by shared code&n; * hash_value - Multicast address hash value&n; *****************************************************************************/
r_void
DECL|function|e1000_mta_set
id|e1000_mta_set
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint32
id|hash_value
)paren
(brace
r_uint32
id|hash_bit
comma
id|hash_reg
suffix:semicolon
r_uint32
id|mta_reg
suffix:semicolon
r_uint32
id|temp
suffix:semicolon
multiline_comment|/* The MTA is a register array of 128 32-bit registers.  &n;     * It is treated like an array of 4096 bits.  We want to set &n;     * bit BitArray[hash_value]. So we figure out what register&n;     * the bit is in, read it, OR in the new bit, then write&n;     * back the new value.  The register is determined by the &n;     * upper 7 bits of the hash value and the bit within that &n;     * register are determined by the lower 5 bits of the value.&n;     */
id|hash_reg
op_assign
(paren
id|hash_value
op_rshift
l_int|5
)paren
op_amp
l_int|0x7F
suffix:semicolon
id|hash_bit
op_assign
id|hash_value
op_amp
l_int|0x1F
suffix:semicolon
id|mta_reg
op_assign
id|E1000_READ_REG_ARRAY
c_func
(paren
id|shared
comma
id|MTA
comma
id|hash_reg
)paren
suffix:semicolon
id|mta_reg
op_or_assign
(paren
l_int|1
op_lshift
id|hash_bit
)paren
suffix:semicolon
multiline_comment|/* If we are on an 82544 and we are trying to write an odd offset&n;     * in the MTA, save off the previous entry before writing and&n;     * restore the old value after writing.&n;     */
r_if
c_cond
(paren
(paren
id|shared-&gt;mac_type
op_eq
id|e1000_82544
)paren
op_logical_and
(paren
(paren
id|hash_reg
op_amp
l_int|0x1
)paren
op_eq
l_int|1
)paren
)paren
(brace
id|temp
op_assign
id|E1000_READ_REG_ARRAY
c_func
(paren
id|shared
comma
id|MTA
comma
(paren
id|hash_reg
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|MTA
comma
id|hash_reg
comma
id|mta_reg
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|MTA
comma
(paren
id|hash_reg
op_minus
l_int|1
)paren
comma
id|temp
)paren
suffix:semicolon
)brace
r_else
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|MTA
comma
id|hash_reg
comma
id|mta_reg
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Puts an ethernet address into a receive address register.&n; *&n; * shared - Struct containing variables accessed by shared code&n; * addr - Address to put into receive address register&n; * index - Receive address register to write&n; *****************************************************************************/
r_void
DECL|function|e1000_rar_set
id|e1000_rar_set
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint8
op_star
id|addr
comma
r_uint32
id|index
)paren
(brace
r_uint32
id|rar_low
comma
id|rar_high
suffix:semicolon
multiline_comment|/* HW expects these in little endian so we reverse the byte order&n;     * from network order (big endian) to little endian              &n;     */
id|rar_low
op_assign
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|0
)braket
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
)paren
suffix:semicolon
id|rar_high
op_assign
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|4
)braket
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_or
id|E1000_RAH_AV
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|RA
comma
(paren
id|index
op_lshift
l_int|1
)paren
comma
id|rar_low
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|RA
comma
(paren
(paren
id|index
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
comma
id|rar_high
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Writes a value to the specified offset in the VLAN filter table.&n; *&n; * shared - Struct containing variables accessed by shared code&n; * offset - Offset in VLAN filer table to write&n; * value - Value to write into VLAN filter table&n; *****************************************************************************/
r_void
DECL|function|e1000_write_vfta
id|e1000_write_vfta
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint32
id|offset
comma
r_uint32
id|value
)paren
(brace
r_uint32
id|temp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|shared-&gt;mac_type
op_eq
id|e1000_82544
)paren
op_logical_and
(paren
(paren
id|offset
op_amp
l_int|0x1
)paren
op_eq
l_int|1
)paren
)paren
(brace
id|temp
op_assign
id|E1000_READ_REG_ARRAY
c_func
(paren
id|shared
comma
id|VFTA
comma
(paren
id|offset
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|VFTA
comma
id|offset
comma
id|value
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|VFTA
comma
(paren
id|offset
op_minus
l_int|1
)paren
comma
id|temp
)paren
suffix:semicolon
)brace
r_else
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|VFTA
comma
id|offset
comma
id|value
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Clears the VLAN filer table&n; *&n; * shared - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|e1000_clear_vfta
id|e1000_clear_vfta
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|offset
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|E1000_VLAN_FILTER_TBL_SIZE
suffix:semicolon
id|offset
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|shared
comma
id|VFTA
comma
id|offset
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Configures flow control and link settings.&n; * &n; * shared - Struct containing variables accessed by shared code&n; * &n; * Determines which flow control settings to use. Calls the apropriate media-&n; * specific link configuration function. Configures the flow control settings.&n; * Assuming the adapter has a valid link partner, a valid link should be&n; * established. Assumes the hardware has previously been reset and the &n; * transmitter and receiver are not enabled.&n; *****************************************************************************/
id|boolean_t
DECL|function|e1000_setup_fc_and_link
id|e1000_setup_fc_and_link
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|ctrl_reg
suffix:semicolon
r_uint32
id|eecd_reg
suffix:semicolon
r_uint32
id|ctrl_ext_reg
suffix:semicolon
id|boolean_t
id|status
op_assign
id|TRUE
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_setup_fc_and_link&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the SWDPIO bits and the ILOS bit out of word 0x0A in the&n;     * EEPROM.  Store these bits in a variable that we will later write&n;     * to the Device Control Register (CTRL).&n;     */
id|eecd_reg
op_assign
id|e1000_read_eeprom
c_func
(paren
id|shared
comma
id|EEPROM_INIT_CONTROL1_REG
)paren
suffix:semicolon
id|ctrl_reg
op_assign
(paren
(paren
(paren
id|eecd_reg
op_amp
id|EEPROM_WORD0A_SWDPIO
)paren
op_lshift
id|SWDPIO_SHIFT
)paren
op_or
(paren
(paren
id|eecd_reg
op_amp
id|EEPROM_WORD0A_ILOS
)paren
op_lshift
id|ILOS_SHIFT
)paren
)paren
suffix:semicolon
multiline_comment|/* Set the PCI priority bit correctly in the CTRL register.  This&n;     * determines if the adapter gives priority to receives, or if it&n;     * gives equal priority to transmits and receives.&n;     */
r_if
c_cond
(paren
id|shared-&gt;dma_fairness
)paren
(brace
id|ctrl_reg
op_or_assign
id|E1000_CTRL_PRIOR
suffix:semicolon
)brace
multiline_comment|/* Read and store word 0x0F of the EEPROM. This word contains bits&n;     * that determine the hardware&squot;s default PAUSE (flow control) mode,&n;     * a bit that determines whether the HW defaults to enabling or&n;     * disabling auto-negotiation, and the direction of the&n;     * SW defined pins. If there is no SW over-ride of the flow&n;     * control setting, then the variable shared-&gt;fc will&n;     * be initialized based on a value in the EEPROM.&n;     */
id|eecd_reg
op_assign
id|e1000_read_eeprom
c_func
(paren
id|shared
comma
id|EEPROM_INIT_CONTROL2_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shared-&gt;fc
OG
id|e1000_fc_full
)paren
(brace
r_if
c_cond
(paren
(paren
id|eecd_reg
op_amp
id|EEPROM_WORD0F_PAUSE_MASK
)paren
op_eq
l_int|0
)paren
(brace
id|shared-&gt;fc
op_assign
id|e1000_fc_none
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|eecd_reg
op_amp
id|EEPROM_WORD0F_PAUSE_MASK
)paren
op_eq
id|EEPROM_WORD0F_ASM_DIR
)paren
(brace
id|shared-&gt;fc
op_assign
id|e1000_fc_tx_pause
suffix:semicolon
)brace
r_else
id|shared-&gt;fc
op_assign
id|e1000_fc_full
suffix:semicolon
)brace
multiline_comment|/* We want to save off the original Flow Control configuration just&n;     * in case we get disconnected and then reconnected into a different&n;     * hub or switch with different Flow Control capabilities.&n;     */
id|shared-&gt;original_fc
op_assign
id|shared-&gt;fc
suffix:semicolon
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
id|shared-&gt;fc
op_and_assign
(paren
op_complement
id|e1000_fc_tx_pause
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|shared-&gt;mac_type
OL
id|e1000_82543
)paren
op_logical_and
(paren
id|shared-&gt;report_tx_early
op_eq
l_int|1
)paren
)paren
(brace
id|shared-&gt;fc
op_and_assign
(paren
op_complement
id|e1000_fc_rx_pause
)paren
suffix:semicolon
)brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;After fix-ups FlowControl is now = %x&bslash;n&quot;
comma
id|shared-&gt;fc
)paren
suffix:semicolon
multiline_comment|/* Take the 4 bits from EEPROM word 0x0F that determine the initial&n;     * polarity value for the SW controlled pins, and setup the&n;     * Extended Device Control reg with that info.&n;     * This is needed because one of the SW controlled pins is used for&n;     * signal detection.  So this should be done before e1000_setup_pcs_link()&n;     * or e1000_phy_setup() is called.&n;     */
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_eq
id|e1000_82543
)paren
(brace
id|ctrl_ext_reg
op_assign
(paren
(paren
id|eecd_reg
op_amp
id|EEPROM_WORD0F_SWPDIO_EXT
)paren
op_lshift
id|SWDPIO__EXT_SHIFT
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL_EXT
comma
id|ctrl_ext_reg
)paren
suffix:semicolon
)brace
multiline_comment|/* Call the necessary subroutine to configure the link. */
r_if
c_cond
(paren
id|shared-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
(brace
id|status
op_assign
id|e1000_setup_pcs_link
c_func
(paren
id|shared
comma
id|ctrl_reg
)paren
suffix:semicolon
)brace
r_else
id|status
op_assign
id|e1000_phy_setup
c_func
(paren
id|shared
comma
id|ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* Initialize the flow control address, type, and PAUSE timer&n;     * registers to their default values.  This is done even if flow&n;     * control is disabled, because it does not hurt anything to&n;     * initialize these registers.&n;     */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Initializing the Flow Control address, type and timer regs&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|FCAL
comma
id|FLOW_CONTROL_ADDRESS_LOW
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|FCAH
comma
id|FLOW_CONTROL_ADDRESS_HIGH
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|FCT
comma
id|FLOW_CONTROL_TYPE
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|FCTTV
comma
id|shared-&gt;fc_pause_time
)paren
suffix:semicolon
multiline_comment|/* Set the flow control receive threshold registers.  Normally,&n;     * these registers will be set to a default threshold that may be&n;     * adjusted later by the driver&squot;s runtime code.  However, if the&n;     * ability to transmit pause frames in not enabled, then these&n;     * registers will be set to 0. &n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|shared-&gt;fc
op_amp
id|e1000_fc_tx_pause
)paren
)paren
(brace
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|FCRTL
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|FCRTH
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We need to set up the Receive Threshold high and low water marks&n;         * as well as (optionally) enabling the transmission of XON frames.&n;         */
r_if
c_cond
(paren
id|shared-&gt;fc_send_xon
)paren
(brace
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|FCRTL
comma
(paren
id|shared-&gt;fc_low_water
op_or
id|E1000_FCRTL_XONE
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|FCRTH
comma
id|shared-&gt;fc_high_water
)paren
suffix:semicolon
)brace
r_else
(brace
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|FCRTL
comma
id|shared-&gt;fc_low_water
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|FCRTH
comma
id|shared-&gt;fc_high_water
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Sets up link for a fiber based adapter&n; *&n; * shared - Struct containing variables accessed by shared code&n; * ctrl_reg - Current value of the device control register&n; *&n; * Manipulates Physical Coding Sublayer functions in order to configure&n; * link. Assumes the hardware has been previously reset and the transmitter&n; * and receiver are not enabled.&n; *****************************************************************************/
id|boolean_t
DECL|function|e1000_setup_pcs_link
id|e1000_setup_pcs_link
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint32
id|ctrl_reg
)paren
(brace
r_uint32
id|status_reg
suffix:semicolon
r_uint32
id|tctl_reg
suffix:semicolon
r_uint32
id|txcw_reg
op_assign
l_int|0
suffix:semicolon
r_uint32
id|i
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_setup_pcs_link&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup the collsion distance.  Since this is configuring the&n;     * TBI it is assumed that we are in Full Duplex.&n;     */
id|tctl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TCTL
)paren
suffix:semicolon
id|i
op_assign
id|E1000_FDX_COLLISION_DISTANCE
suffix:semicolon
id|i
op_lshift_assign
id|E1000_COLD_SHIFT
suffix:semicolon
id|tctl_reg
op_or_assign
id|i
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|TCTL
comma
id|tctl_reg
)paren
suffix:semicolon
multiline_comment|/* Check for a software override of the flow control settings, and&n;     * setup the device accordingly.  If auto-negotiation is enabled,&n;     * then software will have to set the &quot;PAUSE&quot; bits to the correct&n;     * value in the Tranmsit Config Word Register (TXCW) and re-start&n;     * auto-negotiation.  However, if auto-negotiation is disabled,&n;     * then software will have to manually configure the two flow&n;     * control enable bits in the CTRL register.&n;     *&n;     * The possible values of the &quot;fc&quot; parameter are:&n;     *      0:  Flow control is completely disabled&n;     *      1:  Rx flow control is enabled (we can receive pause frames&n;     *          but not send pause frames).&n;     *      2:  Tx flow control is enabled (we can send pause frames&n;     *          but we do not support receiving pause frames).&n;     *      3:  Both Rx and TX flow control (symmetric) are enabled.&n;     *  other:  No software override.  The flow control configuration&n;     *          in the EEPROM is used.&n;     */
r_switch
c_cond
(paren
id|shared-&gt;fc
)paren
(brace
r_case
id|e1000_fc_none
suffix:colon
multiline_comment|/* 0 */
multiline_comment|/* Flow control (RX &amp; TX) is completely disabled by a&n;         * software over-ride.&n;         */
id|txcw_reg
op_assign
(paren
id|E1000_TXCW_ANE
op_or
id|E1000_TXCW_FD
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_rx_pause
suffix:colon
multiline_comment|/* 1 */
multiline_comment|/* RX Flow control is enabled, and TX Flow control is&n;         * disabled, by a software over-ride.&n;         */
multiline_comment|/* Since there really isn&squot;t a way to advertise that we are&n;         * capable of RX Pause ONLY, we will advertise that we&n;         * support both symmetric and asymmetric RX PAUSE.  Later&n;         * we will disable the adapter&squot;s ability to send PAUSE&n;         * frames.&n;         */
id|txcw_reg
op_assign
(paren
id|E1000_TXCW_ANE
op_or
id|E1000_TXCW_FD
op_or
id|E1000_TXCW_PAUSE_MASK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_tx_pause
suffix:colon
multiline_comment|/* 2 */
multiline_comment|/* TX Flow control is enabled, and RX Flow control is&n;         * disabled, by a software over-ride.&n;         */
id|txcw_reg
op_assign
(paren
id|E1000_TXCW_ANE
op_or
id|E1000_TXCW_FD
op_or
id|E1000_TXCW_ASM_DIR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_full
suffix:colon
multiline_comment|/* 3 */
multiline_comment|/* Flow control (both RX and TX) is enabled by a software&n;         * over-ride.&n;         */
id|txcw_reg
op_assign
(paren
id|E1000_TXCW_ANE
op_or
id|E1000_TXCW_FD
op_or
id|E1000_TXCW_PAUSE_MASK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* We should never get here.  The value should be 0-3. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow control param set incorrectly&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Since auto-negotiation is enabled, take the link out of reset.&n;     * (the link will be in reset, because we previously reset the&n;     * chip). This will restart auto-negotiation.  If auto-neogtiation&n;     * is successful then the link-up status bit will be set and the&n;     * flow control enable bits (RFCE and TFCE) will be set according&n;     * to their negotiated value.&n;     */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Auto-negotiation enabled&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|TXCW
comma
id|txcw_reg
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
id|ctrl_reg
)paren
suffix:semicolon
id|shared-&gt;txcw_reg
op_assign
id|txcw_reg
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If we have a signal then poll for a &quot;Link-Up&quot; indication in the&n;     * Device Status Register.   Time-out if a link isn&squot;t seen in 500&n;     * milliseconds seconds (Auto-negotiation should complete in less&n;     * than 500 milliseconds even if the other end is doing it in SW).&n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL
)paren
op_amp
id|E1000_CTRL_SWDPIN1
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Looking for Link&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|LINK_UP_TIMEOUT
op_div
l_int|10
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|msec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|status_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_reg
op_amp
id|E1000_STATUS_LU
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
(paren
id|LINK_UP_TIMEOUT
op_div
l_int|10
)paren
)paren
(brace
multiline_comment|/* AutoNeg failed to achieve a link, so we&squot;ll call the&n;             * &quot;CheckForLink&quot; routine.  This routine will force the link&n;             * up if we have &quot;signal-detect&quot;.  This will allow us to&n;             * communicate with non-autonegotiating link partners.&n;             */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Never got a valid link from auto-neg!!!&bslash;n&quot;
)paren
suffix:semicolon
id|shared-&gt;autoneg_failed
op_assign
l_int|1
suffix:semicolon
id|e1000_check_for_link
c_func
(paren
id|shared
)paren
suffix:semicolon
id|shared-&gt;autoneg_failed
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|shared-&gt;autoneg_failed
op_assign
l_int|0
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Valid Link Found&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;No Signal Detected&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Configures flow control settings after link is established&n; * &n; * shared - Struct containing variables accessed by shared code&n; *&n; * Should be called immediately after a valid link has been established.&n; * Forces MAC flow control settings if link was forced. When in MII/GMII mode&n; * and autonegotiation is enabled, the MAC flow control settings will be set&n; * based on the flow control negotiated by the PHY. In TBI mode, the TFCE&n; * and RFCE bits will be automaticaly set to the negotiated flow control mode.&n; *****************************************************************************/
r_void
DECL|function|e1000_config_fc_after_link_up
id|e1000_config_fc_after_link_up
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint16
id|mii_status_reg
suffix:semicolon
r_uint16
id|mii_nway_adv_reg
suffix:semicolon
r_uint16
id|mii_nway_lp_ability_reg
suffix:semicolon
r_uint16
id|speed
suffix:semicolon
r_uint16
id|duplex
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_config_fc_after_link_up&quot;
)paren
suffix:semicolon
multiline_comment|/* Check for the case where we have fiber media and auto-neg failed&n;     * so we had to force link.  In this case, we need to force the&n;     * configuration of the MAC to match the &quot;fc&quot; parameter.&n;     */
r_if
c_cond
(paren
(paren
(paren
id|shared-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
op_logical_and
(paren
id|shared-&gt;autoneg_failed
)paren
)paren
op_logical_or
(paren
(paren
id|shared-&gt;media_type
op_eq
id|e1000_media_type_copper
)paren
op_logical_and
(paren
op_logical_neg
id|shared-&gt;autoneg
)paren
)paren
)paren
(brace
id|e1000_force_mac_fc
c_func
(paren
id|shared
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for the case where we have copper media and auto-neg is&n;     * enabled.  In this case, we need to check and see if Auto-Neg&n;     * has completed, and if so, how the PHY and link partner has&n;     * flow control configured.&n;     */
r_if
c_cond
(paren
(paren
id|shared-&gt;media_type
op_eq
id|e1000_media_type_copper
)paren
op_logical_and
id|shared-&gt;autoneg
)paren
(brace
multiline_comment|/* Read the MII Status Register and check to see if AutoNeg&n;         * has completed.  We read this twice because this reg has&n;         * some &quot;sticky&quot; (latched) bits.&n;         */
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_AUTONEG_COMPLETE
)paren
(brace
multiline_comment|/* The AutoNeg process has completed, so we now need to&n;             * read both the Auto Negotiation Advertisement Register&n;             * (Address 4) and the Auto_Negotiation Base Page Ability&n;             * Register (Address 5) to determine how flow control was&n;             * negotiated.&n;             */
id|mii_nway_adv_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_AUTONEG_ADV
)paren
suffix:semicolon
id|mii_nway_lp_ability_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_LP_ABILITY
)paren
suffix:semicolon
multiline_comment|/* Two bits in the Auto Negotiation Advertisement Register&n;             * (Address 4) and two bits in the Auto Negotiation Base&n;             * Page Ability Register (Address 5) determine flow control&n;             * for both the PHY and the link partner.  The following&n;             * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,&n;             * 1999, describes these PAUSE resolution bits and how flow&n;             * control is determined based upon these settings.&n;             * NOTE:  DC = Don&squot;t Care&n;             *&n;             *   LOCAL DEVICE  |   LINK PARTNER&n;             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution&n;             *-------|---------|-------|---------|--------------------&n;             *   0   |    0    |  DC   |   DC    | e1000_fc_none&n;             *   0   |    1    |   0   |   DC    | e1000_fc_none&n;             *   0   |    1    |   1   |    0    | e1000_fc_none&n;             *   0   |    1    |   1   |    1    | e1000_fc_tx_pause&n;             *   1   |    0    |   0   |   DC    | e1000_fc_none&n;             *   1   |   DC    |   1   |   DC    | e1000_fc_full&n;             *   1   |    1    |   0   |    0    | e1000_fc_none&n;             *   1   |    1    |   0   |    1    | e1000_fc_rx_pause&n;             *&n;             */
multiline_comment|/* Are both PAUSE bits set to 1?  If so, this implies&n;             * Symmetric Flow Control is enabled at both ends.  The&n;             * ASM_DIR bits are irrelevant per the spec.&n;             *&n;             * For Symmetric Flow Control:&n;             *&n;             *   LOCAL DEVICE  |   LINK PARTNER&n;             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result&n;             *-------|---------|-------|---------|--------------------&n;             *   1   |   DC    |   1   |   DC    | e1000_fc_full&n;             *&n;             */
r_if
c_cond
(paren
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_PAUSE
)paren
)paren
(brace
multiline_comment|/* Now we need to check if the user selected RX ONLY&n;                 * of pause frames.  In this case, we had to advertise&n;                 * FULL flow control because we could not advertise RX&n;                 * ONLY. Hence, we must now check to see if we need to&n;                 * turn OFF  the TRANSMISSION of PAUSE frames.&n;                 */
r_if
c_cond
(paren
id|shared-&gt;original_fc
op_eq
id|e1000_fc_full
)paren
(brace
id|shared-&gt;fc
op_assign
id|e1000_fc_full
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = FULL.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|shared-&gt;fc
op_assign
id|e1000_fc_rx_pause
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = RX PAUSE frames only.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* For receiving PAUSE frames ONLY.&n;             *&n;             *   LOCAL DEVICE  |   LINK PARTNER&n;             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result&n;             *-------|---------|-------|---------|--------------------&n;             *   0   |    1    |   1   |    1    | e1000_fc_tx_pause&n;             *&n;             */
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_ASM_DIR
)paren
op_logical_and
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_ASM_DIR
)paren
)paren
(brace
id|shared-&gt;fc
op_assign
id|e1000_fc_tx_pause
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = TX PAUSE frames only.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* For transmitting PAUSE frames ONLY.&n;             *&n;             *   LOCAL DEVICE  |   LINK PARTNER&n;             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result&n;             *-------|---------|-------|---------|--------------------&n;             *   1   |    1    |   0   |    1    | e1000_fc_rx_pause&n;             *&n;             */
r_else
r_if
c_cond
(paren
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_ASM_DIR
)paren
op_logical_and
op_logical_neg
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_ASM_DIR
)paren
)paren
(brace
id|shared-&gt;fc
op_assign
id|e1000_fc_rx_pause
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = RX PAUSE frames only.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Per the IEEE spec, at this point flow control should be&n;             * disabled.  However, we want to consider that we could&n;             * be connected to a legacy switch that doesn&squot;t advertise&n;             * desired flow control, but can be forced on the link&n;             * partner.  So if we advertised no flow control, that is&n;             * what we will resolve to.  If we advertised some kind of&n;             * receive capability (Rx Pause Only or Full Flow Control)&n;             * and the link partner advertised none, we will configure&n;             * ourselves to enable Rx Flow Control only.  We can do&n;             * this safely for two reasons:  If the link partner really&n;             * didn&squot;t want flow control enabled, and we enable Rx, no&n;             * harm done since we won&squot;t be receiving any PAUSE frames&n;             * anyway.  If the intent on the link partner was to have&n;             * flow control enabled, then by us enabling RX only, we&n;             * can at least receive pause frames and process them.&n;             * This is a good idea because in most cases, since we are&n;             * predominantly a server NIC, more times than not we will&n;             * be asked to delay transmission of packets than asking&n;             * our link partner to pause transmission of frames.&n;             */
r_else
r_if
c_cond
(paren
id|shared-&gt;original_fc
op_eq
id|e1000_fc_none
op_logical_or
id|shared-&gt;original_fc
op_eq
id|e1000_fc_tx_pause
)paren
(brace
id|shared-&gt;fc
op_assign
id|e1000_fc_none
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = NONE.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|shared-&gt;fc
op_assign
id|e1000_fc_rx_pause
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = RX PAUSE frames only.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we need to do one last check...  If we auto-&n;             * negotiated to HALF DUPLEX, flow control should not be&n;             * enabled per IEEE 802.3 spec.&n;             */
id|e1000_get_speed_and_duplex
c_func
(paren
id|shared
comma
op_amp
id|speed
comma
op_amp
id|duplex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|duplex
op_eq
id|HALF_DUPLEX
)paren
(brace
id|shared-&gt;fc
op_assign
id|e1000_fc_none
suffix:semicolon
)brace
multiline_comment|/* Now we call a subroutine to actually force the MAC&n;             * controller to use the correct flow control settings.&n;             */
id|e1000_force_mac_fc
c_func
(paren
id|shared
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Copper PHY and Auto Neg has not completed.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Checks to see if the link status of the hardware has changed.&n; *&n; * shared - Struct containing variables accessed by shared code&n; *&n; * Called by any function that needs to check the link status of the adapter.&n; *****************************************************************************/
r_void
DECL|function|e1000_check_for_link
id|e1000_check_for_link
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|rxcw_reg
suffix:semicolon
r_uint32
id|ctrl_reg
suffix:semicolon
r_uint32
id|status_reg
suffix:semicolon
r_uint32
id|rctl_reg
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
r_uint16
id|lp_capability
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_check_for_link&quot;
)paren
suffix:semicolon
id|ctrl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL
)paren
suffix:semicolon
id|status_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|STATUS
)paren
suffix:semicolon
id|rxcw_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|RXCW
)paren
suffix:semicolon
multiline_comment|/* If we have a copper PHY then we only want to go out to the PHY&n;     * registers to see if Auto-Neg has completed and/or if our link&n;     * status has changed.  The get_link_status flag will be set if we&n;     * receive a Link Status Change interrupt or we have Rx Sequence&n;     * Errors.&n;     */
r_if
c_cond
(paren
id|shared-&gt;media_type
op_eq
id|e1000_media_type_copper
op_logical_and
id|shared-&gt;get_link_status
)paren
(brace
multiline_comment|/* First we want to see if the MII Status Register reports&n;         * link.  If so, then we want to get the current speed/duplex&n;         * of the PHY.&n;         * Read the register twice since the link bit is sticky.&n;         */
id|phy_data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
id|phy_data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phy_data
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
id|shared-&gt;get_link_status
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;**** CFL - No link detected. ****&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If we are forcing speed/duplex, then we simply return since&n;         * we have already determined whether we have link or not.&n;         */
r_if
c_cond
(paren
op_logical_neg
id|shared-&gt;autoneg
)paren
(brace
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|shared-&gt;phy_id
)paren
(brace
r_case
id|M88E1000_12_PHY_ID
suffix:colon
r_case
id|M88E1000_14_PHY_ID
suffix:colon
r_case
id|M88E1000_I_PHY_ID
suffix:colon
multiline_comment|/* We have a M88E1000 PHY and Auto-Neg is enabled.  If we&n;             * have Si on board that is 82544 or newer, Auto&n;             * Speed Detection takes care of MAC speed/duplex&n;             * configuration.  So we only need to configure Collision&n;             * Distance in the MAC.  Otherwise, we need to force&n;             * speed/duplex on the MAC to the current PHY speed/duplex&n;             * settings.&n;             */
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_ge
id|e1000_82544
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;CFL - Auto-Neg complete.&quot;
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Configuring Collision Distance.&quot;
)paren
suffix:semicolon
id|e1000_config_collision_dist
c_func
(paren
id|shared
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Read the Phy Specific Status register to get the&n;                 * resolved speed/duplex settings.  Then call&n;                 * e1000_config_mac_to_phy which will retrieve&n;                 * PHY register information and configure the MAC to&n;                 * equal the negotiated speed/duplex.&n;                 */
id|phy_data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_STATUS
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;CFL - Auto-Neg complete.  phy_data = %x&bslash;r&bslash;n&quot;
comma
id|phy_data
)paren
suffix:semicolon
id|e1000_config_mac_to_phy
c_func
(paren
id|shared
comma
id|phy_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Configure Flow Control now that Auto-Neg has completed.&n;             * We need to first restore the users desired Flow&n;             * Control setting since we may have had to re-autoneg&n;             * with a different link partner.&n;             */
id|e1000_config_fc_after_link_up
c_func
(paren
id|shared
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;CFL - Invalid PHY detected.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* end switch statement */
multiline_comment|/* At this point we know that we are on copper, link is up, &n;         * and we are auto-neg&squot;d.  These are pre-conditions for checking&n;         * the link parter capabilities register.  We use the link partner&n;         * capabilities to determine if TBI Compatibility needs to be turned on&n;         * or turned off.  If the link partner advertises any speed in addition&n;         * to Gigabit, then we assume that they are GMII-based and TBI &n;         * compatibility is not needed.&n;         * If no other speeds are advertised, then we assume the link partner&n;         * is TBI-based and we turn on TBI Compatibility.&n;         */
r_if
c_cond
(paren
id|shared-&gt;tbi_compatibility_en
)paren
(brace
id|lp_capability
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_LP_ABILITY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp_capability
op_amp
(paren
id|NWAY_LPAR_10T_HD_CAPS
op_or
id|NWAY_LPAR_10T_FD_CAPS
op_or
id|NWAY_LPAR_100TX_HD_CAPS
op_or
id|NWAY_LPAR_100TX_FD_CAPS
op_or
id|NWAY_LPAR_100T4_CAPS
)paren
)paren
(brace
multiline_comment|/* If our link partner advertises below Gig, then they do not&n;                 * need the special Tbi Compatibility mode. &n;                 */
r_if
c_cond
(paren
id|shared-&gt;tbi_compatibility_on
)paren
(brace
multiline_comment|/* If we previously were in the mode, turn it off, now. */
id|rctl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|RCTL
)paren
suffix:semicolon
id|rctl_reg
op_and_assign
op_complement
id|E1000_RCTL_SBP
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|RCTL
comma
id|rctl_reg
)paren
suffix:semicolon
id|shared-&gt;tbi_compatibility_on
op_assign
id|FALSE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* If the mode is was previously off, turn it on. &n;                 * For compatibility with a suspected Tbi link partners, &n;                 * we will store bad packets.&n;                 * (Certain frames have an additional byte on the end and will &n;                 * look like CRC errors to to the hardware).&n;                 */
r_if
c_cond
(paren
op_logical_neg
id|shared-&gt;tbi_compatibility_on
)paren
(brace
id|shared-&gt;tbi_compatibility_on
op_assign
id|TRUE
suffix:semicolon
id|rctl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|RCTL
)paren
suffix:semicolon
id|rctl_reg
op_or_assign
id|E1000_RCTL_SBP
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|RCTL
comma
id|rctl_reg
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* end if e1000_media_type_copper statement */
multiline_comment|/* If we don&squot;t have link (auto-negotiation failed or link partner&n;     * cannot auto-negotiate) and the cable is plugged in since we don&squot;t&n;     * have Loss-Of-Signal (we HAVE a signal) and our link partner is&n;     * not trying to AutoNeg with us (we are receiving idles/data&n;     * then we need to force our link to connect to a non&n;     * auto-negotiating link partner.  We also need to give&n;     * auto-negotiation time to complete in case the cable was just&n;     * plugged in.  The autoneg_failed flag does this.&n;     */
r_else
r_if
c_cond
(paren
(paren
id|shared-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
op_logical_and
multiline_comment|/* Fiber PHY */
(paren
op_logical_neg
(paren
id|status_reg
op_amp
id|E1000_STATUS_LU
)paren
)paren
op_logical_and
multiline_comment|/* no link and    */
(paren
op_logical_neg
(paren
id|ctrl_reg
op_amp
id|E1000_CTRL_SWDPIN1
)paren
)paren
op_logical_and
multiline_comment|/* we have signal */
(paren
op_logical_neg
(paren
id|rxcw_reg
op_amp
id|E1000_RXCW_C
)paren
)paren
)paren
(brace
multiline_comment|/* and rxing idle/data */
r_if
c_cond
(paren
id|shared-&gt;autoneg_failed
op_eq
l_int|0
)paren
(brace
multiline_comment|/* given AutoNeg time */
id|shared-&gt;autoneg_failed
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;NOT RXing /C/, disable AutoNeg and force link.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Disable auto-negotiation in the TXCW register */
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|TXCW
comma
(paren
id|shared-&gt;txcw_reg
op_amp
op_complement
id|E1000_TXCW_ANE
)paren
)paren
suffix:semicolon
multiline_comment|/* Force link-up and also force full-duplex. */
id|ctrl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL
)paren
suffix:semicolon
id|ctrl_reg
op_or_assign
(paren
id|E1000_CTRL_SLU
op_or
id|E1000_CTRL_FD
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
id|ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* Configure Flow Control after forcing link up. */
id|e1000_config_fc_after_link_up
c_func
(paren
id|shared
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|shared-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
op_logical_and
multiline_comment|/* Fiber */
(paren
id|ctrl_reg
op_amp
id|E1000_CTRL_SLU
)paren
op_logical_and
multiline_comment|/* we have forced link */
(paren
id|rxcw_reg
op_amp
id|E1000_RXCW_C
)paren
)paren
(brace
multiline_comment|/* and Rxing /C/ ordered sets */
multiline_comment|/* If we are forcing link and we are receiving /C/ ordered sets,&n;         * then re-enable auto-negotiation in the RXCW register and&n;         * disable forced link in the Device Control register in an attempt&n;         * to AutoNeg with our link partner.&n;         */
id|DEBUGOUT
c_func
(paren
l_string|&quot;RXing /C/, enable AutoNeg and stop forcing link.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Enable auto-negotiation in the TXCW register and stop&n;         * forcing link.&n;         */
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|TXCW
comma
id|shared-&gt;txcw_reg
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
(paren
id|ctrl_reg
op_amp
op_complement
id|E1000_CTRL_SLU
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Clears all hardware statistics counters. &n; *&n; * shared - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|e1000_clear_hw_cntrs
id|e1000_clear_hw_cntrs
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_volatile
r_uint32
id|temp_reg
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_clear_hw_cntrs&quot;
)paren
suffix:semicolon
multiline_comment|/* if we are stopped or resetting exit gracefully */
r_if
c_cond
(paren
id|shared-&gt;adapter_stopped
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Exiting because the adapter is stopped!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CRCERRS
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|SYMERRS
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|MPC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|SCC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|ECOL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|MCC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|LATECOL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|COLC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|DC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|SEC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|RLEC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|XONRXC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|XONTXC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|XOFFRXC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|XOFFTXC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|FCRUC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|PRC64
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|PRC127
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|PRC255
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|PRC511
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|PRC1023
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|PRC1522
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|GPRC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|BPRC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|MPRC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|GPTC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|GORCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|GORCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|GOTCL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|GOTCH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|RNBC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|RUC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|RFC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|ROC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|RJC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TORL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TORH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TOTL
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TOTH
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TPR
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TPT
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|PTC64
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|PTC127
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|PTC255
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|PTC511
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|PTC1023
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|PTC1522
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|MPTC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|BPTC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shared-&gt;mac_type
OL
id|e1000_82543
)paren
(brace
r_return
suffix:semicolon
)brace
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|ALGNERRC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|RXERRC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TNCRS
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CEXTERR
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TSCTC
)paren
suffix:semicolon
id|temp_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TSCTFC
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Detects the current speed and duplex settings of the hardware.&n; *&n; * shared - Struct containing variables accessed by shared code&n; * speed - Speed of the connection&n; * duplex - Duplex setting of the connection&n; *****************************************************************************/
r_void
DECL|function|e1000_get_speed_and_duplex
id|e1000_get_speed_and_duplex
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint16
op_star
id|speed
comma
r_uint16
op_star
id|duplex
)paren
(brace
r_uint32
id|status_reg
suffix:semicolon
macro_line|#if DBG
r_uint16
id|phy_data
suffix:semicolon
macro_line|#endif
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_get_speed_and_duplex&quot;
)paren
suffix:semicolon
multiline_comment|/* If the adapter is stopped we don&squot;t have a speed or duplex */
r_if
c_cond
(paren
id|shared-&gt;adapter_stopped
)paren
(brace
op_star
id|speed
op_assign
l_int|0
suffix:semicolon
op_star
id|duplex
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_ge
id|e1000_82543
)paren
(brace
id|status_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_reg
op_amp
id|E1000_STATUS_SPEED_1000
)paren
(brace
op_star
id|speed
op_assign
id|SPEED_1000
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;1000 Mbs, &quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status_reg
op_amp
id|E1000_STATUS_SPEED_100
)paren
(brace
op_star
id|speed
op_assign
id|SPEED_100
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;100 Mbs, &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|speed
op_assign
id|SPEED_10
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;10 Mbs, &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status_reg
op_amp
id|E1000_STATUS_FD
)paren
(brace
op_star
id|duplex
op_assign
id|FULL_DUPLEX
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Full Duplex&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|duplex
op_assign
id|HALF_DUPLEX
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot; Half Duplex&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;1000 Mbs, Full Duplex&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|speed
op_assign
id|SPEED_1000
suffix:semicolon
op_star
id|duplex
op_assign
id|FULL_DUPLEX
suffix:semicolon
)brace
macro_line|#if DBG
r_if
c_cond
(paren
id|shared-&gt;phy_id
op_eq
id|M88E1000_12_PHY_ID
op_logical_or
id|shared-&gt;phy_id
op_eq
id|M88E1000_14_PHY_ID
op_logical_or
id|shared-&gt;phy_id
op_eq
id|M88E1000_I_PHY_ID
)paren
(brace
multiline_comment|/* read the phy specific status register */
id|phy_data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_STATUS
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;M88E1000 Phy Specific Status Reg contents = %x&bslash;n&quot;
comma
id|phy_data
)paren
suffix:semicolon
id|phy_data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Phy MII Status Reg contents = %x&bslash;n&quot;
comma
id|phy_data
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Device Status Reg contents = %x&bslash;n&quot;
comma
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|STATUS
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Reads a 16 bit word from the EEPROM.&n; *&n; * shared - Struct containing variables accessed by shared code&n; * offset - offset of 16 bit word in the EEPROM to read&n; *****************************************************************************/
r_uint16
DECL|function|e1000_read_eeprom
id|e1000_read_eeprom
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint16
id|offset
)paren
(brace
r_uint16
id|data
suffix:semicolon
multiline_comment|/*  Prepare the EEPROM for reading  */
id|e1000_setup_eeprom
c_func
(paren
id|shared
)paren
suffix:semicolon
multiline_comment|/*  Send the READ command (opcode + addr)  */
id|e1000_shift_out_bits
c_func
(paren
id|shared
comma
id|EEPROM_READ_OPCODE
comma
l_int|3
)paren
suffix:semicolon
id|e1000_shift_out_bits
c_func
(paren
id|shared
comma
id|offset
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Read the data */
id|data
op_assign
id|e1000_shift_in_bits
c_func
(paren
id|shared
)paren
suffix:semicolon
multiline_comment|/* End this read operation */
id|e1000_standby_eeprom
c_func
(paren
id|shared
)paren
suffix:semicolon
r_return
(paren
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Verifies that the EEPROM has a valid checksum&n; * &n; * shared - Struct containing variables accessed by shared code&n; *&n; * Reads the first 64 16 bit words of the EEPROM and sums the values read.&n; * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM&squot;s checksum is&n; * valid.&n; *****************************************************************************/
id|boolean_t
DECL|function|e1000_validate_eeprom_checksum
id|e1000_validate_eeprom_checksum
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint16
id|checksum
op_assign
l_int|0
suffix:semicolon
r_uint16
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|EEPROM_CHECKSUM_REG
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|checksum
op_add_assign
id|e1000_read_eeprom
c_func
(paren
id|shared
comma
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|checksum
op_eq
(paren
r_uint16
)paren
id|EEPROM_SUM
)paren
(brace
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
r_else
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Reads the adapter&squot;s part number from the EEPROM&n; *&n; * shared - Struct containing variables accessed by shared code&n; * part_num - Adapter&squot;s part number&n; *****************************************************************************/
id|boolean_t
DECL|function|e1000_read_part_num
id|e1000_read_part_num
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint32
op_star
id|part_num
)paren
(brace
r_uint16
id|eeprom_word
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_read_part_num&quot;
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t read the EEPROM if we are stopped */
r_if
c_cond
(paren
id|shared-&gt;adapter_stopped
)paren
(brace
op_star
id|part_num
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/* Get word 0 from EEPROM */
id|eeprom_word
op_assign
id|e1000_read_eeprom
c_func
(paren
id|shared
comma
(paren
r_uint16
)paren
(paren
id|EEPROM_PBA_BYTE_1
)paren
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Read first part number word&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Save word 0 in upper half is PartNumber */
op_star
id|part_num
op_assign
(paren
r_uint32
)paren
id|eeprom_word
suffix:semicolon
op_star
id|part_num
op_assign
op_star
id|part_num
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* Get word 1 from EEPROM */
id|eeprom_word
op_assign
id|e1000_read_eeprom
c_func
(paren
id|shared
comma
(paren
r_uint16
)paren
(paren
id|EEPROM_PBA_BYTE_1
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Read second part number word&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Save word 1 in lower half of PartNumber */
op_star
id|part_num
op_or_assign
id|eeprom_word
suffix:semicolon
multiline_comment|/* read a valid part number */
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
r_void
DECL|function|e1000_read_mac_addr
id|e1000_read_mac_addr
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint16
id|temp
comma
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|NODE_ADDRESS_SIZE
suffix:semicolon
id|x
op_add_assign
l_int|2
)paren
(brace
id|temp
op_assign
id|e1000_read_eeprom
c_func
(paren
id|shared
comma
(paren
r_uint16
)paren
(paren
id|EEPROM_NODE_ADDRESS_BYTE_0
op_plus
(paren
id|x
op_div
l_int|2
)paren
)paren
)paren
suffix:semicolon
id|shared-&gt;perm_mac_addr
(braket
id|x
)braket
op_assign
(paren
r_uint8
)paren
(paren
id|temp
op_amp
l_int|0x00FF
)paren
suffix:semicolon
id|shared-&gt;perm_mac_addr
(braket
id|x
op_plus
l_int|1
)braket
op_assign
(paren
r_uint8
)paren
(paren
id|temp
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|NODE_ADDRESS_SIZE
suffix:semicolon
id|x
op_increment
)paren
(brace
id|shared-&gt;mac_addr
(braket
id|x
)braket
op_assign
id|shared-&gt;perm_mac_addr
(braket
id|x
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Adjusts the statistic counters when a frame is accepted by TBI_ACCEPT&n; * &n; * shared - Struct containing variables accessed by shared code&n; * frame_len - The length of the frame in question&n; * mac_addr - The Ethernet destination address of the frame in question&n; *****************************************************************************/
r_uint32
DECL|function|e1000_tbi_adjust_stats
id|e1000_tbi_adjust_stats
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_struct
id|e1000_shared_stats
op_star
id|stats
comma
r_uint32
id|frame_len
comma
r_uint8
op_star
id|mac_addr
)paren
(brace
r_uint64
id|carry_bit
suffix:semicolon
multiline_comment|/* First adjust the frame length. */
id|frame_len
op_decrement
suffix:semicolon
multiline_comment|/* We need to adjust the statistics counters, since the hardware&n;     * counters overcount this packet as a CRC error and undercount&n;     * the packet as a good packet&n;     */
multiline_comment|/* This packet should not be counted as a CRC error.    */
id|stats-&gt;crcerrs
op_decrement
suffix:semicolon
multiline_comment|/* This packet does count as a Good Packet Received.    */
id|stats-&gt;gprc
op_increment
suffix:semicolon
multiline_comment|/* Adjust the Good Octets received counters             */
id|carry_bit
op_assign
l_int|0x80000000
op_amp
id|stats-&gt;gorcl
suffix:semicolon
id|stats-&gt;gorcl
op_add_assign
id|frame_len
suffix:semicolon
multiline_comment|/* If the high bit of Gorcl (the low 32 bits of the Good Octets&n;     * Received Count) was one before the addition, &n;     * AND it is zero after, then we lost the carry out, &n;     * need to add one to Gorch (Good Octets Received Count High).&n;     * This could be simplified if all environments supported &n;     * 64-bit integers.&n;     */
r_if
c_cond
(paren
id|carry_bit
op_logical_and
(paren
(paren
id|stats-&gt;gorcl
op_amp
l_int|0x80000000
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|stats-&gt;gorch
op_increment
suffix:semicolon
)brace
multiline_comment|/* Is this a broadcast or multicast?  Check broadcast first,&n;     * since the test for a multicast frame will test positive on &n;     * a broadcast frame.&n;     */
r_if
c_cond
(paren
(paren
id|mac_addr
(braket
l_int|0
)braket
op_eq
(paren
r_uint8
)paren
l_int|0xff
)paren
op_logical_and
(paren
id|mac_addr
(braket
l_int|1
)braket
op_eq
(paren
r_uint8
)paren
l_int|0xff
)paren
)paren
(brace
multiline_comment|/* Broadcast packet */
id|stats-&gt;bprc
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|mac_addr
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* Multicast packet */
id|stats-&gt;mprc
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frame_len
op_eq
id|shared-&gt;max_frame_size
)paren
(brace
multiline_comment|/* In this case, the hardware has overcounted the number of&n;         * oversize frames.&n;         */
r_if
c_cond
(paren
id|stats-&gt;roc
OG
l_int|0
)paren
(brace
id|stats-&gt;roc
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* Adjust the bin counters when the extra byte put the frame in the&n;     * wrong bin. Remember that the frame_len was adjusted above.&n;     */
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|64
)paren
(brace
id|stats-&gt;prc64
op_increment
suffix:semicolon
id|stats-&gt;prc127
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|127
)paren
(brace
id|stats-&gt;prc127
op_increment
suffix:semicolon
id|stats-&gt;prc255
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|255
)paren
(brace
id|stats-&gt;prc255
op_increment
suffix:semicolon
id|stats-&gt;prc511
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|511
)paren
(brace
id|stats-&gt;prc511
op_increment
suffix:semicolon
id|stats-&gt;prc1023
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|1023
)paren
(brace
id|stats-&gt;prc1023
op_increment
suffix:semicolon
id|stats-&gt;prc1522
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|1522
)paren
(brace
id|stats-&gt;prc1522
op_increment
suffix:semicolon
)brace
r_return
id|frame_len
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Gets the current PCI bus type, speed, and width of the hardware&n; *&n; * shared - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|e1000_get_bus_info
id|e1000_get_bus_info
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|status_reg
suffix:semicolon
r_if
c_cond
(paren
id|shared-&gt;mac_type
OL
id|e1000_82543
)paren
(brace
id|shared-&gt;bus_type
op_assign
id|e1000_bus_type_unknown
suffix:semicolon
id|shared-&gt;bus_speed
op_assign
id|e1000_bus_speed_unknown
suffix:semicolon
id|shared-&gt;bus_width
op_assign
id|e1000_bus_width_unknown
suffix:semicolon
r_return
suffix:semicolon
)brace
id|status_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|STATUS
)paren
suffix:semicolon
id|shared-&gt;bus_type
op_assign
(paren
id|status_reg
op_amp
id|E1000_STATUS_PCIX_MODE
)paren
ques
c_cond
id|e1000_bus_type_pcix
suffix:colon
id|e1000_bus_type_pci
suffix:semicolon
r_if
c_cond
(paren
id|shared-&gt;bus_type
op_eq
id|e1000_bus_type_pci
)paren
(brace
id|shared-&gt;bus_speed
op_assign
(paren
id|status_reg
op_amp
id|E1000_STATUS_PCI66
)paren
ques
c_cond
id|e1000_bus_speed_66
suffix:colon
id|e1000_bus_speed_33
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|status_reg
op_amp
id|E1000_STATUS_PCIX_SPEED
)paren
(brace
r_case
id|E1000_STATUS_PCIX_SPEED_66
suffix:colon
id|shared-&gt;bus_speed
op_assign
id|e1000_bus_speed_66
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_STATUS_PCIX_SPEED_100
suffix:colon
id|shared-&gt;bus_speed
op_assign
id|e1000_bus_speed_100
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_STATUS_PCIX_SPEED_133
suffix:colon
id|shared-&gt;bus_speed
op_assign
id|e1000_bus_speed_133
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|shared-&gt;bus_speed
op_assign
id|e1000_bus_speed_reserved
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|shared-&gt;bus_width
op_assign
(paren
id|status_reg
op_amp
id|E1000_STATUS_BUS64
)paren
ques
c_cond
id|e1000_bus_width_64
suffix:colon
id|e1000_bus_width_32
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
