multiline_comment|/*******************************************************************************&n;&n;  This software program is available to you under a choice of one of two&n;  licenses. You may choose to be licensed under either the GNU General Public&n;  License 2.0, June 1991, available at http://www.fsf.org/copyleft/gpl.html,&n;  or the Intel BSD + Patent License, the text of which follows:&n;  &n;  Recipient has requested a license and Intel Corporation (&quot;Intel&quot;) is willing&n;  to grant a license for the software entitled Linux Base Driver for the&n;  Intel(R) PRO/1000 Family of Adapters (e1000) (the &quot;Software&quot;) being provided&n;  by Intel Corporation. The following definitions apply to this license:&n;  &n;  &quot;Licensed Patents&quot; means patent claims licensable by Intel Corporation which&n;  are necessarily infringed by the use of sale of the Software alone or when&n;  combined with the operating system referred to below.&n;  &n;  &quot;Recipient&quot; means the party to whom Intel delivers this Software.&n;  &n;  &quot;Licensee&quot; means Recipient and those third parties that receive a license to&n;  any operating system available under the GNU General Public License 2.0 or&n;  later.&n;  &n;  Copyright (c) 1999 - 2002 Intel Corporation.&n;  All rights reserved.&n;  &n;  The license is provided to Recipient and Recipient&squot;s Licensees under the&n;  following terms.&n;  &n;  Redistribution and use in source and binary forms of the Software, with or&n;  without modification, are permitted provided that the following conditions&n;  are met:&n;  &n;  Redistributions of source code of the Software may retain the above&n;  copyright notice, this list of conditions and the following disclaimer.&n;  &n;  Redistributions in binary form of the Software may reproduce the above&n;  copyright notice, this list of conditions and the following disclaimer in&n;  the documentation and/or materials provided with the distribution.&n;  &n;  Neither the name of Intel Corporation nor the names of its contributors&n;  shall be used to endorse or promote products derived from this Software&n;  without specific prior written permission.&n;  &n;  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide,&n;  royalty-free patent license under Licensed Patents to make, use, sell, offer&n;  to sell, import and otherwise transfer the Software, if any, in source code&n;  and object code form. This license shall include changes to the Software&n;  that are error corrections or other minor changes to the Software that do&n;  not add functionality or features when the Software is incorporated in any&n;  version of an operating system that has been distributed under the GNU&n;  General Public License 2.0 or later. This patent license shall apply to the&n;  combination of the Software and any operating system licensed under the GNU&n;  General Public License 2.0 or later if, at the time Intel provides the&n;  Software to Recipient, such addition of the Software to the then publicly&n;  available versions of such operating systems available under the GNU General&n;  Public License 2.0 or later (whether in gold, beta or alpha form) causes&n;  such combination to be covered by the Licensed Patents. The patent license&n;  shall not apply to any other combinations which include the Software. NO&n;  hardware per se is licensed hereunder.&n;  &n;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;&n;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n;  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n;  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY&n;  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES&n;  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;&n;  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED&n;  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR&n;  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&n;  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n;&n;*******************************************************************************/
multiline_comment|/* e1000_hw.c&n; * Shared functions for accessing and configuring the MAC&n; */
macro_line|#include &quot;e1000_hw.h&quot;
r_static
r_int32
id|e1000_setup_fiber_link
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_setup_copper_link
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_phy_force_speed_duplex
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_config_mac_to_phy
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_force_mac_fc
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_void
id|e1000_raise_mdi_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|ctrl
)paren
suffix:semicolon
r_static
r_void
id|e1000_lower_mdi_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|ctrl
)paren
suffix:semicolon
r_static
r_void
id|e1000_shift_out_mdi_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|data
comma
r_uint16
id|count
)paren
suffix:semicolon
r_static
r_uint16
id|e1000_shift_in_mdi_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_phy_reset_dsp
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_void
id|e1000_raise_ee_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|eecd
)paren
suffix:semicolon
r_static
r_void
id|e1000_lower_ee_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|eecd
)paren
suffix:semicolon
r_static
r_void
id|e1000_shift_out_ee_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|data
comma
r_uint16
id|count
)paren
suffix:semicolon
r_static
r_uint16
id|e1000_shift_in_ee_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_void
id|e1000_setup_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_void
id|e1000_standby_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
multiline_comment|/******************************************************************************&n; * Reset the transmit and receive units; mask and clear all interrupts.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|e1000_reset_hw
id|e1000_reset_hw
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|ctrl_ext
suffix:semicolon
r_uint32
id|icr
suffix:semicolon
r_uint32
id|manc
suffix:semicolon
r_uint16
id|pci_cmd_word
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_reset_hw&quot;
)paren
suffix:semicolon
multiline_comment|/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;pci_cmd_word
op_amp
id|CMD_MEM_WRT_INVALIDATE
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Disabling MWI on 82542 rev 2.0&bslash;n&quot;
)paren
suffix:semicolon
id|pci_cmd_word
op_assign
id|hw-&gt;pci_cmd_word
op_amp
op_complement
id|CMD_MEM_WRT_INVALIDATE
suffix:semicolon
id|e1000_write_pci_cfg
c_func
(paren
id|hw
comma
id|PCI_COMMAND_REGISTER
comma
op_amp
id|pci_cmd_word
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Clear interrupt mask to stop board from generating interrupts */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Masking off all interrupts&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|IMC
comma
l_int|0xffffffff
)paren
suffix:semicolon
multiline_comment|/* Disable the Transmit and Receive units.  Then delay to allow&n;     * any pending transactions to complete before we hit the MAC with&n;     * the global reset.&n;     */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|RCTL
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|TCTL
comma
id|E1000_TCTL_PSP
)paren
suffix:semicolon
multiline_comment|/* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
id|hw-&gt;tbi_compatibility_on
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Delay to allow any outstanding PCI transactions to complete before&n;     * resetting the device&n;     */
id|msec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Issue a global reset to the MAC.  This will reset the chip&squot;s&n;     * transmit, receive, DMA, and link units.  It will not effect&n;     * the current PCI configuration.  The global reset bit is self-&n;     * clearing, and should clear within a microsecond.&n;     */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Issuing a global reset to MAC&bslash;n&quot;
)paren
suffix:semicolon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
(paren
id|ctrl
op_or
id|E1000_CTRL_RST
)paren
)paren
suffix:semicolon
multiline_comment|/* Force a reload from the EEPROM if necessary */
r_if
c_cond
(paren
id|hw-&gt;mac_type
OL
id|e1000_82540
)paren
(brace
multiline_comment|/* Wait for reset to complete */
id|usec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ctrl_ext
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL_EXT
)paren
suffix:semicolon
id|ctrl_ext
op_or_assign
id|E1000_CTRL_EXT_EE_RST
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL_EXT
comma
id|ctrl_ext
)paren
suffix:semicolon
multiline_comment|/* Wait for EEPROM reload */
id|msec_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Wait for EEPROM reload (it happens automatically) */
id|msec_delay
c_func
(paren
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Dissable HW ARPs on ASF enabled adapters */
id|manc
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MANC
)paren
suffix:semicolon
id|manc
op_and_assign
op_complement
(paren
id|E1000_MANC_ARP_EN
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|MANC
comma
id|manc
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear interrupt mask to stop board from generating interrupts */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Masking off all interrupts&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|IMC
comma
l_int|0xffffffff
)paren
suffix:semicolon
multiline_comment|/* Clear any pending interrupt events. */
id|icr
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|ICR
)paren
suffix:semicolon
multiline_comment|/* If MWI was previously enabled, reenable it. */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;pci_cmd_word
op_amp
id|CMD_MEM_WRT_INVALIDATE
)paren
(brace
id|e1000_write_pci_cfg
c_func
(paren
id|hw
comma
id|PCI_COMMAND_REGISTER
comma
op_amp
id|hw-&gt;pci_cmd_word
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/******************************************************************************&n; * Performs basic configuration of the adapter.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * &n; * Assumes that the controller has previously been reset and is in a &n; * post-reset uninitialized state. Initializes the receive address registers,&n; * multicast table, and VLAN filter table. Calls routines to setup link&n; * configuration and flow control settings. Clears all on-chip counters. Leaves&n; * the transmit and receive units disabled and uninitialized.&n; *****************************************************************************/
r_int32
DECL|function|e1000_init_hw
id|e1000_init_hw
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
comma
id|status
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|pci_cmd_word
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_init_hw&quot;
)paren
suffix:semicolon
multiline_comment|/* Set the Media Type and exit with error if it is not valid. */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_ne
id|e1000_82543
)paren
(brace
multiline_comment|/* tbi_compatibility is only valid on 82543 */
id|hw-&gt;tbi_compatibility_en
op_assign
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_ge
id|e1000_82543
)paren
(brace
id|status
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|E1000_STATUS_TBIMODE
)paren
(brace
id|hw-&gt;media_type
op_assign
id|e1000_media_type_fiber
suffix:semicolon
multiline_comment|/* tbi_compatibility not valid on fiber */
id|hw-&gt;tbi_compatibility_en
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|hw-&gt;media_type
op_assign
id|e1000_media_type_copper
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* This is an 82542 (fiber only) */
id|hw-&gt;media_type
op_assign
id|e1000_media_type_fiber
suffix:semicolon
)brace
multiline_comment|/* Disabling VLAN filtering. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Initializing the IEEE VLAN&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|VET
comma
l_int|0
)paren
suffix:semicolon
id|e1000_clear_vfta
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;pci_cmd_word
op_amp
id|CMD_MEM_WRT_INVALIDATE
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Disabling MWI on 82542 rev 2.0&bslash;n&quot;
)paren
suffix:semicolon
id|pci_cmd_word
op_assign
id|hw-&gt;pci_cmd_word
op_amp
op_complement
id|CMD_MEM_WRT_INVALIDATE
suffix:semicolon
id|e1000_write_pci_cfg
c_func
(paren
id|hw
comma
id|PCI_COMMAND_REGISTER
comma
op_amp
id|pci_cmd_word
)paren
suffix:semicolon
)brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|RCTL
comma
id|E1000_RCTL_RST
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
multiline_comment|/* Setup the receive address. This involves initializing all of the Receive&n;     * Address Registers (RARs 0 - 15).&n;     */
id|e1000_init_rx_addrs
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|RCTL
comma
l_int|0
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;pci_cmd_word
op_amp
id|CMD_MEM_WRT_INVALIDATE
)paren
(brace
id|e1000_write_pci_cfg
c_func
(paren
id|hw
comma
id|PCI_COMMAND_REGISTER
comma
op_amp
id|hw-&gt;pci_cmd_word
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Zero out the Multicast HASH table */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Zeroing the MTA&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|E1000_MC_TBL_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the PCI priority bit correctly in the CTRL register.  This&n;     * determines if the adapter gives priority to receives, or if it&n;     * gives equal priority to transmits and receives.&n;     */
r_if
c_cond
(paren
id|hw-&gt;dma_fairness
)paren
(brace
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
op_or
id|E1000_CTRL_PRIOR
)paren
suffix:semicolon
)brace
multiline_comment|/* Call a subroutine to configure the link and setup flow control. */
id|ret_val
op_assign
id|e1000_setup_link
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Clear all of the statistics registers (clear on read).  It is&n;     * important that we do this after we have tried to establish link&n;     * because the symbol error count will increment wildly if there&n;     * is no link.&n;     */
id|e1000_clear_hw_cntrs
c_func
(paren
id|hw
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Configures flow control and link settings.&n; * &n; * hw - Struct containing variables accessed by shared code&n; * &n; * Determines which flow control settings to use. Calls the apropriate media-&n; * specific link configuration function. Configures the flow control settings.&n; * Assuming the adapter has a valid link partner, a valid link should be&n; * established. Assumes the hardware has previously been reset and the &n; * transmitter and receiver are not enabled.&n; *****************************************************************************/
r_int32
DECL|function|e1000_setup_link
id|e1000_setup_link
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl_ext
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|eeprom_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_setup_link&quot;
)paren
suffix:semicolon
multiline_comment|/* Read and store word 0x0F of the EEPROM. This word contains bits&n;     * that determine the hardware&squot;s default PAUSE (flow control) mode,&n;     * a bit that determines whether the HW defaults to enabling or&n;     * disabling auto-negotiation, and the direction of the&n;     * SW defined pins. If there is no SW over-ride of the flow&n;     * control setting, then the variable hw-&gt;fc will&n;     * be initialized based on a value in the EEPROM.&n;     */
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
id|EEPROM_INIT_CONTROL2_REG
comma
op_amp
id|eeprom_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;fc
op_eq
id|e1000_fc_default
)paren
(brace
r_if
c_cond
(paren
(paren
id|eeprom_data
op_amp
id|EEPROM_WORD0F_PAUSE_MASK
)paren
op_eq
l_int|0
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_none
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|eeprom_data
op_amp
id|EEPROM_WORD0F_PAUSE_MASK
)paren
op_eq
id|EEPROM_WORD0F_ASM_DIR
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_tx_pause
suffix:semicolon
)brace
r_else
id|hw-&gt;fc
op_assign
id|e1000_fc_full
suffix:semicolon
)brace
multiline_comment|/* We want to save off the original Flow Control configuration just&n;     * in case we get disconnected and then reconnected into a different&n;     * hub or switch with different Flow Control capabilities.&n;     */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
id|hw-&gt;fc
op_and_assign
(paren
op_complement
id|e1000_fc_tx_pause
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|hw-&gt;mac_type
OL
id|e1000_82543
)paren
op_logical_and
(paren
id|hw-&gt;report_tx_early
op_eq
l_int|1
)paren
)paren
(brace
id|hw-&gt;fc
op_and_assign
(paren
op_complement
id|e1000_fc_rx_pause
)paren
suffix:semicolon
)brace
id|hw-&gt;original_fc
op_assign
id|hw-&gt;fc
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;After fix-ups FlowControl is now = %x&bslash;n&quot;
comma
id|hw-&gt;fc
)paren
suffix:semicolon
multiline_comment|/* Take the 4 bits from EEPROM word 0x0F that determine the initial&n;     * polarity value for the SW controlled pins, and setup the&n;     * Extended Device Control reg with that info.&n;     * This is needed because one of the SW controlled pins is used for&n;     * signal detection.  So this should be done before e1000_setup_pcs_link()&n;     * or e1000_phy_setup() is called.&n;     */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82543
)paren
(brace
id|ctrl_ext
op_assign
(paren
(paren
id|eeprom_data
op_amp
id|EEPROM_WORD0F_SWPDIO_EXT
)paren
op_lshift
id|SWDPIO__EXT_SHIFT
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL_EXT
comma
id|ctrl_ext
)paren
suffix:semicolon
)brace
multiline_comment|/* Call the necessary subroutine to configure the link. */
id|ret_val
op_assign
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
ques
c_cond
id|e1000_setup_fiber_link
c_func
(paren
id|hw
)paren
suffix:colon
id|e1000_setup_copper_link
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Initialize the flow control address, type, and PAUSE timer&n;     * registers to their default values.  This is done even if flow&n;     * control is disabled, because it does not hurt anything to&n;     * initialize these registers.&n;     */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Initializing the Flow Control address, type and timer regs&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCAL
comma
id|FLOW_CONTROL_ADDRESS_LOW
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCAH
comma
id|FLOW_CONTROL_ADDRESS_HIGH
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCT
comma
id|FLOW_CONTROL_TYPE
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCTTV
comma
id|hw-&gt;fc_pause_time
)paren
suffix:semicolon
multiline_comment|/* Set the flow control receive threshold registers.  Normally,&n;     * these registers will be set to a default threshold that may be&n;     * adjusted later by the driver&squot;s runtime code.  However, if the&n;     * ability to transmit pause frames in not enabled, then these&n;     * registers will be set to 0. &n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hw-&gt;fc
op_amp
id|e1000_fc_tx_pause
)paren
)paren
(brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTL
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTH
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We need to set up the Receive Threshold high and low water marks&n;         * as well as (optionally) enabling the transmission of XON frames.&n;         */
r_if
c_cond
(paren
id|hw-&gt;fc_send_xon
)paren
(brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTL
comma
(paren
id|hw-&gt;fc_low_water
op_or
id|E1000_FCRTL_XONE
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTH
comma
id|hw-&gt;fc_high_water
)paren
suffix:semicolon
)brace
r_else
(brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTL
comma
id|hw-&gt;fc_low_water
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTH
comma
id|hw-&gt;fc_high_water
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Sets up link for a fiber based adapter&n; *&n; * hw - Struct containing variables accessed by shared code&n; * ctrl - Current value of the device control register&n; *&n; * Manipulates Physical Coding Sublayer functions in order to configure&n; * link. Assumes the hardware has been previously reset and the transmitter&n; * and receiver are not enabled.&n; *****************************************************************************/
r_static
r_int32
DECL|function|e1000_setup_fiber_link
id|e1000_setup_fiber_link
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|status
suffix:semicolon
r_uint32
id|txcw
op_assign
l_int|0
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_uint32
id|signal
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_setup_fiber_link&quot;
)paren
suffix:semicolon
multiline_comment|/* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be &n;     * set when the optics detect a signal. On older adapters, it will be &n;     * cleared when there is a signal&n;     */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82544
)paren
(brace
id|signal
op_assign
id|E1000_CTRL_SWDPIN1
suffix:semicolon
)brace
r_else
id|signal
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Take the link out of reset */
id|ctrl
op_and_assign
op_complement
(paren
id|E1000_CTRL_LRST
)paren
suffix:semicolon
id|e1000_config_collision_dist
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Check for a software override of the flow control settings, and setup&n;     * the device accordingly.  If auto-negotiation is enabled, then software&n;     * will have to set the &quot;PAUSE&quot; bits to the correct value in the Tranmsit&n;     * Config Word Register (TXCW) and re-start auto-negotiation.  However, if&n;     * auto-negotiation is disabled, then software will have to manually &n;     * configure the two flow control enable bits in the CTRL register.&n;     *&n;     * The possible values of the &quot;fc&quot; parameter are:&n;     *      0:  Flow control is completely disabled&n;     *      1:  Rx flow control is enabled (we can receive pause frames, but &n;     *          not send pause frames).&n;     *      2:  Tx flow control is enabled (we can send pause frames but we do&n;     *          not support receiving pause frames).&n;     *      3:  Both Rx and TX flow control (symmetric) are enabled.&n;     */
r_switch
c_cond
(paren
id|hw-&gt;fc
)paren
(brace
r_case
id|e1000_fc_none
suffix:colon
multiline_comment|/* Flow control is completely disabled by a software over-ride. */
id|txcw
op_assign
(paren
id|E1000_TXCW_ANE
op_or
id|E1000_TXCW_FD
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_rx_pause
suffix:colon
multiline_comment|/* RX Flow control is enabled and TX Flow control is disabled by a &n;         * software over-ride. Since there really isn&squot;t a way to advertise &n;         * that we are capable of RX Pause ONLY, we will advertise that we&n;         * support both symmetric and asymmetric RX PAUSE. Later, we will&n;         *  disable the adapter&squot;s ability to send PAUSE frames.&n;         */
id|txcw
op_assign
(paren
id|E1000_TXCW_ANE
op_or
id|E1000_TXCW_FD
op_or
id|E1000_TXCW_PAUSE_MASK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_tx_pause
suffix:colon
multiline_comment|/* TX Flow control is enabled, and RX Flow control is disabled, by a &n;         * software over-ride.&n;         */
id|txcw
op_assign
(paren
id|E1000_TXCW_ANE
op_or
id|E1000_TXCW_FD
op_or
id|E1000_TXCW_ASM_DIR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_full
suffix:colon
multiline_comment|/* Flow control (both RX and TX) is enabled by a software over-ride. */
id|txcw
op_assign
(paren
id|E1000_TXCW_ANE
op_or
id|E1000_TXCW_FD
op_or
id|E1000_TXCW_PAUSE_MASK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow control param set incorrectly&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Since auto-negotiation is enabled, take the link out of reset (the link&n;     * will be in reset, because we previously reset the chip). This will&n;     * restart auto-negotiation.  If auto-neogtiation is successful then the&n;     * link-up status bit will be set and the flow control enable bits (RFCE&n;     * and TFCE) will be set according to their negotiated value.&n;     */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Auto-negotiation enabled&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|TXCW
comma
id|txcw
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
id|hw-&gt;txcw
op_assign
id|txcw
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If we have a signal (the cable is plugged in) then poll for a &quot;Link-Up&quot;&n;     * indication in the Device Status Register.  Time-out if a link isn&squot;t &n;     * seen in 500 milliseconds seconds (Auto-negotiation should complete in &n;     * less than 500 milliseconds even if the other end is doing it in SW).&n;     */
r_if
c_cond
(paren
(paren
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
op_amp
id|E1000_CTRL_SWDPIN1
)paren
op_eq
id|signal
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Looking for Link&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|LINK_UP_TIMEOUT
op_div
l_int|10
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|msec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|status
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|E1000_STATUS_LU
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
(paren
id|LINK_UP_TIMEOUT
op_div
l_int|10
)paren
)paren
(brace
multiline_comment|/* AutoNeg failed to achieve a link, so we&squot;ll call &n;             * e1000_check_for_link. This routine will force the link up if we&n;             * detect a signal. This will allow us to communicate with&n;             * non-autonegotiating link partners.&n;             */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Never got a valid link from auto-neg!!!&bslash;n&quot;
)paren
suffix:semicolon
id|hw-&gt;autoneg_failed
op_assign
l_int|1
suffix:semicolon
id|ret_val
op_assign
id|e1000_check_for_link
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error while checking for link&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
id|hw-&gt;autoneg_failed
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|hw-&gt;autoneg_failed
op_assign
l_int|0
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Valid Link Found&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;No Signal Detected&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Detects which PHY is present and the speed and duplex&n;*&n;* hw - Struct containing variables accessed by shared code&n;* ctrl - current value of the device control register&n;******************************************************************************/
r_static
r_int32
DECL|function|e1000_setup_copper_link
id|e1000_setup_copper_link
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|i
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_setup_copper_link&quot;
)paren
suffix:semicolon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* With 82543, we need to force speed and duplex on the MAC equal to what&n;     * the PHY speed and duplex configuration is. In addition, we need to&n;     * perform a hardware reset on the PHY to take it out of reset.&n;     */
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82543
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_SLU
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
)brace
r_else
(brace
id|ctrl
op_or_assign
(paren
id|E1000_CTRL_FRCSPD
op_or
id|E1000_CTRL_FRCDPX
op_or
id|E1000_CTRL_SLU
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
id|e1000_phy_hw_reset
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
multiline_comment|/* Make sure we have a valid PHY */
id|ret_val
op_assign
id|e1000_detect_gig_phy
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error, did not detect valid phy.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Phy ID = %x &bslash;n&quot;
comma
id|hw-&gt;phy_id
)paren
suffix:semicolon
multiline_comment|/* Enable CRS on TX. This must be set for half-duplex operation. */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|phy_data
op_or_assign
id|M88E1000_PSCR_ASSERT_CRS_ON_TX
suffix:semicolon
multiline_comment|/* Options:&n;     *   MDI/MDI-X = 0 (default)&n;     *   0 - Auto for all speeds&n;     *   1 - MDI mode&n;     *   2 - MDI-X mode&n;     *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)&n;     */
id|phy_data
op_and_assign
op_complement
id|M88E1000_PSCR_AUTO_X_MODE
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;mdix
)paren
(brace
r_case
l_int|1
suffix:colon
id|phy_data
op_or_assign
id|M88E1000_PSCR_MDI_MANUAL_MODE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|phy_data
op_or_assign
id|M88E1000_PSCR_MDIX_MANUAL_MODE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|phy_data
op_or_assign
id|M88E1000_PSCR_AUTO_X_1000T
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_default
suffix:colon
id|phy_data
op_or_assign
id|M88E1000_PSCR_AUTO_X_MODE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Options:&n;     *   disable_polarity_correction = 0 (default)&n;     *       Automatic Correction for Reversed Cable Polarity&n;     *   0 - Disabled&n;     *   1 - Enabled&n;     */
id|phy_data
op_and_assign
op_complement
id|M88E1000_PSCR_POLARITY_REVERSAL
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;disable_polarity_correction
op_eq
l_int|1
)paren
(brace
id|phy_data
op_or_assign
id|M88E1000_PSCR_POLARITY_REVERSAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Write Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
multiline_comment|/* Force TX_CLK in the Extended PHY Specific Control Register&n;     * to 25MHz clock.&n;     */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|phy_data
op_or_assign
id|M88E1000_EPSCR_TX_CLK_25
suffix:semicolon
multiline_comment|/* Configure Master and Slave downshift values */
id|phy_data
op_and_assign
op_complement
(paren
id|M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK
op_or
id|M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK
)paren
suffix:semicolon
id|phy_data
op_or_assign
(paren
id|M88E1000_EPSCR_MASTER_DOWNSHIFT_1X
op_or
id|M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
comma
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Write Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
multiline_comment|/* SW Reset the PHY so all changes take effect */
id|ret_val
op_assign
id|e1000_phy_reset
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Resetting the PHY&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Options:&n;     *   autoneg = 1 (default)&n;     *      PHY will advertise value(s) parsed from&n;     *      autoneg_advertised and fc&n;     *   autoneg = 0&n;     *      PHY will be set to 10H, 10F, 100H, or 100F&n;     *      depending on value parsed from forced_speed_duplex.&n;     */
multiline_comment|/* Is autoneg enabled?  This is enabled by default or by software override.&n;     * If so, call e1000_phy_setup_autoneg routine to parse the&n;     * autoneg_advertised and fc options. If autoneg is NOT enabled, then the&n;     * user should have provided a speed/duplex override.  If so, then call&n;     * e1000_phy_force_speed_duplex to parse and set this up.&n;     */
r_if
c_cond
(paren
id|hw-&gt;autoneg
)paren
(brace
multiline_comment|/* Perform some bounds checking on the hw-&gt;autoneg_advertised&n;         * parameter.  If this variable is zero, then set it to the default.&n;         */
id|hw-&gt;autoneg_advertised
op_and_assign
id|AUTONEG_ADVERTISE_SPEED_DEFAULT
suffix:semicolon
multiline_comment|/* If autoneg_advertised is zero, we assume it was not defaulted&n;         * by the calling code so we set to advertise full capability.&n;         */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_eq
l_int|0
)paren
(brace
id|hw-&gt;autoneg_advertised
op_assign
id|AUTONEG_ADVERTISE_SPEED_DEFAULT
suffix:semicolon
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Reconfiguring auto-neg advertisement params&bslash;n&quot;
)paren
suffix:semicolon
id|ret_val
op_assign
id|e1000_phy_setup_autoneg
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Setting up Auto-Negotiation&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Restarting Auto-Neg&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Restart auto-negotiation by setting the Auto Neg Enable bit and&n;         * the Auto Neg Restart bit in the PHY control register.&n;         */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_CTRL
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|phy_data
op_or_assign
(paren
id|MII_CR_AUTO_NEG_EN
op_or
id|MII_CR_RESTART_AUTO_NEG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|PHY_CTRL
comma
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Write Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
multiline_comment|/* Does the user want to wait for Auto-Neg to complete here, or&n;         * check at a later time (for example, callback routine).&n;         */
r_if
c_cond
(paren
id|hw-&gt;wait_autoneg_complete
)paren
(brace
id|ret_val
op_assign
id|e1000_wait_autoneg
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error while waiting for autoneg to complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Forcing speed and duplex&bslash;n&quot;
)paren
suffix:semicolon
id|ret_val
op_assign
id|e1000_phy_force_speed_duplex
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Forcing Speed and Duplex&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
multiline_comment|/* Check link status. Wait up to 100 microseconds for link to become&n;     * valid.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|phy_data
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
multiline_comment|/* We have link, so we need to finish the config process:&n;             *   1) Set up the MAC to the current PHY speed/duplex&n;             *      if we are on 82543.  If we&n;             *      are on newer silicon, we only need to configure&n;             *      collision distance in the Transmit Control Register.&n;             *   2) Set up flow control on the MAC to that established with&n;             *      the link partner.&n;             */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_ge
id|e1000_82544
)paren
(brace
id|e1000_config_collision_dist
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret_val
op_assign
id|e1000_config_mac_to_phy
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error configuring MAC to PHY settings&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
id|ret_val
op_assign
id|e1000_config_fc_after_link_up
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Configuring Flow Control&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Valid link established!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|usec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Unable to establish link!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Configures PHY autoneg and flow control advertisement settings&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_int32
DECL|function|e1000_phy_setup_autoneg
id|e1000_phy_setup_autoneg
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint16
id|mii_autoneg_adv_reg
suffix:semicolon
r_uint16
id|mii_1000t_ctrl_reg
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_setup_autoneg&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the MII Auto-Neg Advertisement Register (Address 4). */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_AUTONEG_ADV
comma
op_amp
id|mii_autoneg_adv_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
multiline_comment|/* Read the MII 1000Base-T Control Register (Address 9). */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_CTRL
comma
op_amp
id|mii_1000t_ctrl_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
multiline_comment|/* Need to parse both autoneg_advertised and fc and set up&n;     * the appropriate PHY registers.  First we will parse for&n;     * autoneg_advertised software override.  Since we can advertise&n;     * a plethora of combinations, we need to check each bit&n;     * individually.&n;     */
multiline_comment|/* First we clear all the 10/100 mb speed bits in the Auto-Neg&n;     * Advertisement Register (Address 4) and the 1000 mb speed bits in&n;     * the  1000Base-T Control Register (Address 9).&n;     */
id|mii_autoneg_adv_reg
op_and_assign
op_complement
id|REG4_SPEED_MASK
suffix:semicolon
id|mii_1000t_ctrl_reg
op_and_assign
op_complement
id|REG9_SPEED_MASK
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;autoneg_advertised %x&bslash;n&quot;
comma
id|hw-&gt;autoneg_advertised
)paren
suffix:semicolon
multiline_comment|/* Do we want to advertise 10 Mb Half Duplex? */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_amp
id|ADVERTISE_10_HALF
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 10mb Half duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_10T_HD_CAPS
suffix:semicolon
)brace
multiline_comment|/* Do we want to advertise 10 Mb Full Duplex? */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_amp
id|ADVERTISE_10_FULL
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 10mb Full duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_10T_FD_CAPS
suffix:semicolon
)brace
multiline_comment|/* Do we want to advertise 100 Mb Half Duplex? */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_amp
id|ADVERTISE_100_HALF
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 100mb Half duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_100TX_HD_CAPS
suffix:semicolon
)brace
multiline_comment|/* Do we want to advertise 100 Mb Full Duplex? */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_amp
id|ADVERTISE_100_FULL
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 100mb Full duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_100TX_FD_CAPS
suffix:semicolon
)brace
multiline_comment|/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_amp
id|ADVERTISE_1000_HALF
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 1000mb Half duplex requested, request denied!&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Do we want to advertise 1000 Mb Full Duplex? */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_amp
id|ADVERTISE_1000_FULL
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 1000mb Full duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_1000t_ctrl_reg
op_or_assign
id|CR_1000T_FD_CAPS
suffix:semicolon
)brace
multiline_comment|/* Check for a software override of the flow control settings, and&n;     * setup the PHY advertisement registers accordingly.  If&n;     * auto-negotiation is enabled, then software will have to set the&n;     * &quot;PAUSE&quot; bits to the correct value in the Auto-Negotiation&n;     * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.&n;     *&n;     * The possible values of the &quot;fc&quot; parameter are:&n;     *      0:  Flow control is completely disabled&n;     *      1:  Rx flow control is enabled (we can receive pause frames&n;     *          but not send pause frames).&n;     *      2:  Tx flow control is enabled (we can send pause frames&n;     *          but we do not support receiving pause frames).&n;     *      3:  Both Rx and TX flow control (symmetric) are enabled.&n;     *  other:  No software override.  The flow control configuration&n;     *          in the EEPROM is used.&n;     */
r_switch
c_cond
(paren
id|hw-&gt;fc
)paren
(brace
r_case
id|e1000_fc_none
suffix:colon
multiline_comment|/* 0 */
multiline_comment|/* Flow control (RX &amp; TX) is completely disabled by a&n;         * software over-ride.&n;         */
id|mii_autoneg_adv_reg
op_and_assign
op_complement
(paren
id|NWAY_AR_ASM_DIR
op_or
id|NWAY_AR_PAUSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_rx_pause
suffix:colon
multiline_comment|/* 1 */
multiline_comment|/* RX Flow control is enabled, and TX Flow control is&n;         * disabled, by a software over-ride.&n;         */
multiline_comment|/* Since there really isn&squot;t a way to advertise that we are&n;         * capable of RX Pause ONLY, we will advertise that we&n;         * support both symmetric and asymmetric RX PAUSE.  Later&n;         * (in e1000_config_fc_after_link_up) we will disable the&n;         *hw&squot;s ability to send PAUSE frames.&n;         */
id|mii_autoneg_adv_reg
op_or_assign
(paren
id|NWAY_AR_ASM_DIR
op_or
id|NWAY_AR_PAUSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_tx_pause
suffix:colon
multiline_comment|/* 2 */
multiline_comment|/* TX Flow control is enabled, and RX Flow control is&n;         * disabled, by a software over-ride.&n;         */
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_ASM_DIR
suffix:semicolon
id|mii_autoneg_adv_reg
op_and_assign
op_complement
id|NWAY_AR_PAUSE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_full
suffix:colon
multiline_comment|/* 3 */
multiline_comment|/* Flow control (both RX and TX) is enabled by a software&n;         * over-ride.&n;         */
id|mii_autoneg_adv_reg
op_or_assign
(paren
id|NWAY_AR_ASM_DIR
op_or
id|NWAY_AR_PAUSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow control param set incorrectly&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|PHY_AUTONEG_ADV
comma
id|mii_autoneg_adv_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Write Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Auto-Neg Advertising %x&bslash;n&quot;
comma
id|mii_autoneg_adv_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_CTRL
comma
id|mii_1000t_ctrl_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Write Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Force PHY speed and duplex settings to hw-&gt;forced_speed_duplex&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_static
r_int32
DECL|function|e1000_phy_force_speed_duplex
id|e1000_phy_force_speed_duplex
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|mii_ctrl_reg
suffix:semicolon
r_uint16
id|mii_status_reg
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
r_uint16
id|i
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_force_speed_duplex&quot;
)paren
suffix:semicolon
multiline_comment|/* Turn off Flow control if we are forcing speed and duplex. */
id|hw-&gt;fc
op_assign
id|e1000_fc_none
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;hw-&gt;fc = %d&bslash;n&quot;
comma
id|hw-&gt;fc
)paren
suffix:semicolon
multiline_comment|/* Read the Device Control Register. */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */
id|ctrl
op_or_assign
(paren
id|E1000_CTRL_FRCSPD
op_or
id|E1000_CTRL_FRCDPX
)paren
suffix:semicolon
id|ctrl
op_and_assign
op_complement
(paren
id|DEVICE_SPEED_MASK
)paren
suffix:semicolon
multiline_comment|/* Clear the Auto Speed Detect Enable bit. */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_ASDE
suffix:semicolon
multiline_comment|/* Read the MII Control Register. */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_CTRL
comma
op_amp
id|mii_ctrl_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
multiline_comment|/* We need to disable autoneg in order to force link and duplex. */
id|mii_ctrl_reg
op_and_assign
op_complement
id|MII_CR_AUTO_NEG_EN
suffix:semicolon
multiline_comment|/* Are we forcing Full or Half Duplex? */
r_if
c_cond
(paren
id|hw-&gt;forced_speed_duplex
op_eq
id|e1000_100_full
op_logical_or
id|hw-&gt;forced_speed_duplex
op_eq
id|e1000_10_full
)paren
(brace
multiline_comment|/* We want to force full duplex so we SET the full duplex bits in the&n;         * Device and MII Control Registers.&n;         */
id|ctrl
op_or_assign
id|E1000_CTRL_FD
suffix:semicolon
id|mii_ctrl_reg
op_or_assign
id|MII_CR_FULL_DUPLEX
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Full Duplex&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We want to force half duplex so we CLEAR the full duplex bits in&n;         * the Device and MII Control Registers.&n;         */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_FD
suffix:semicolon
id|mii_ctrl_reg
op_and_assign
op_complement
id|MII_CR_FULL_DUPLEX
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Half Duplex&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Are we forcing 100Mbps??? */
r_if
c_cond
(paren
id|hw-&gt;forced_speed_duplex
op_eq
id|e1000_100_full
op_logical_or
id|hw-&gt;forced_speed_duplex
op_eq
id|e1000_100_half
)paren
(brace
multiline_comment|/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
id|ctrl
op_or_assign
id|E1000_CTRL_SPD_100
suffix:semicolon
id|mii_ctrl_reg
op_or_assign
id|MII_CR_SPEED_100
suffix:semicolon
id|mii_ctrl_reg
op_and_assign
op_complement
(paren
id|MII_CR_SPEED_1000
op_or
id|MII_CR_SPEED_10
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Forcing 100mb &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
id|ctrl
op_and_assign
op_complement
(paren
id|E1000_CTRL_SPD_1000
op_or
id|E1000_CTRL_SPD_100
)paren
suffix:semicolon
id|mii_ctrl_reg
op_or_assign
id|MII_CR_SPEED_10
suffix:semicolon
id|mii_ctrl_reg
op_and_assign
op_complement
(paren
id|MII_CR_SPEED_1000
op_or
id|MII_CR_SPEED_100
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Forcing 10mb &quot;
)paren
suffix:semicolon
)brace
id|e1000_config_collision_dist
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Write the configured values back to the Device Control Reg. */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Write the MII Control Register with the new PHY configuration. */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
multiline_comment|/* Clear Auto-Crossover to force MDI manually. M88E1000 requires MDI&n;     * forced whenever speed are duplex are forced.&n;     */
id|phy_data
op_and_assign
op_complement
id|M88E1000_PSCR_AUTO_X_MODE
suffix:semicolon
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Write Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;M88E1000 PSCR: %x &bslash;n&quot;
comma
id|phy_data
)paren
suffix:semicolon
multiline_comment|/* Need to reset the PHY or these changes will be ignored */
id|mii_ctrl_reg
op_or_assign
id|MII_CR_RESET
suffix:semicolon
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|PHY_CTRL
comma
id|mii_ctrl_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Write Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|usec_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* The wait_autoneg_complete flag may be a little misleading here.&n;     * Since we are forcing speed and duplex, Auto-Neg is not enabled.&n;     * But we do want to delay for a period while forcing only so we&n;     * don&squot;t generate false No Link messages.  So we will wait here&n;     * only if the user has set wait_autoneg_complete to 1, which is&n;     * the default.&n;     */
r_if
c_cond
(paren
id|hw-&gt;wait_autoneg_complete
)paren
(brace
multiline_comment|/* We will wait for autoneg to complete. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Waiting for forced speed/duplex link.&bslash;n&quot;
)paren
suffix:semicolon
id|mii_status_reg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
r_for
c_loop
(paren
id|i
op_assign
id|PHY_FORCE_TIME
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
multiline_comment|/* Read the MII Status Register and wait for Auto-Neg Complete bit&n;             * to be set.&n;             */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|mii_status_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|mii_status_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
r_break
suffix:semicolon
)brace
id|msec_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We didn&squot;t get link */
multiline_comment|/* Reset the DSP and wait again for link. */
id|ret_val
op_assign
id|e1000_phy_reset_dsp
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Resetting PHY DSP&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
multiline_comment|/* This loop will early-out if the link condition has been met.  */
r_for
c_loop
(paren
id|i
op_assign
id|PHY_FORCE_TIME
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
r_break
suffix:semicolon
)brace
id|msec_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Read the MII Status Register and wait for Auto-Neg Complete bit&n;             * to be set.&n;             */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|mii_status_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|mii_status_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Because we reset the PHY above, we need to re-force TX_CLK in the&n;     * Extended PHY Specific Control Register to 25MHz clock.  This value&n;     * defaults back to a 2.5MHz clock when the PHY is reset.&n;     */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|phy_data
op_or_assign
id|M88E1000_EPSCR_TX_CLK_25
suffix:semicolon
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
comma
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Write Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
multiline_comment|/* In addition, because of the s/w reset above, we need to enable CRS on&n;     * TX.  This must be set for both full and half duplex operation.&n;     */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|phy_data
op_or_assign
id|M88E1000_PSCR_ASSERT_CRS_ON_TX
suffix:semicolon
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Write Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Sets the collision distance in the Transmit Control register&n;*&n;* hw - Struct containing variables accessed by shared code&n;*&n;* Link should have been established previously. Reads the speed and duplex&n;* information from the Device Status register.&n;******************************************************************************/
r_void
DECL|function|e1000_config_collision_dist
id|e1000_config_collision_dist
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|tctl
suffix:semicolon
id|tctl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TCTL
)paren
suffix:semicolon
id|tctl
op_and_assign
op_complement
id|E1000_TCTL_COLD
suffix:semicolon
id|tctl
op_or_assign
id|E1000_COLLISION_DISTANCE
op_lshift
id|E1000_COLD_SHIFT
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|TCTL
comma
id|tctl
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Sets MAC speed and duplex settings to reflect the those in the PHY&n;*&n;* hw - Struct containing variables accessed by shared code&n;* mii_reg - data to write to the MII control register&n;*&n;* The contents of the PHY register containing the needed information need to&n;* be passed in.&n;******************************************************************************/
r_static
r_int32
DECL|function|e1000_config_mac_to_phy
id|e1000_config_mac_to_phy
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_config_mac_to_phy&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the Device Control Register and set the bits to Force Speed&n;     * and Duplex.&n;     */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|ctrl
op_or_assign
(paren
id|E1000_CTRL_FRCSPD
op_or
id|E1000_CTRL_FRCDPX
)paren
suffix:semicolon
id|ctrl
op_and_assign
op_complement
(paren
id|E1000_CTRL_SPD_SEL
op_or
id|E1000_CTRL_ILOS
)paren
suffix:semicolon
multiline_comment|/* Set up duplex in the Device Control and Transmit Control&n;     * registers depending on negotiated values.&n;     */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_STATUS
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_DPLX
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_FD
suffix:semicolon
)brace
r_else
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_FD
suffix:semicolon
id|e1000_config_collision_dist
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Set up speed in the Device Control register depending on&n;     * negotiated values.&n;     */
r_if
c_cond
(paren
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_SPEED
)paren
op_eq
id|M88E1000_PSSR_1000MBS
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_SPD_1000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_SPEED
)paren
op_eq
id|M88E1000_PSSR_100MBS
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_SPD_100
suffix:semicolon
)brace
multiline_comment|/* Write the configured values back to the Device Control Reg. */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Forces the MAC&squot;s flow control settings.&n; * &n; * hw - Struct containing variables accessed by shared code&n; *&n; * Sets the TFCE and RFCE bits in the device control register to reflect&n; * the adapter settings. TFCE and RFCE need to be explicitly set by&n; * software when a Copper PHY is used because autonegotiation is managed&n; * by the PHY rather than the MAC. Software must also configure these&n; * bits when link is forced on a fiber connection.&n; *****************************************************************************/
r_static
r_int32
DECL|function|e1000_force_mac_fc
id|e1000_force_mac_fc
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_force_mac_fc&quot;
)paren
suffix:semicolon
multiline_comment|/* Get the current configuration of the Device Control Register */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Because we didn&squot;t get link via the internal auto-negotiation&n;     * mechanism (we either forced link or we got link via PHY&n;     * auto-neg), we have to manually enable/disable transmit an&n;     * receive flow control.&n;     *&n;     * The &quot;Case&quot; statement below enables/disable flow control&n;     * according to the &quot;hw-&gt;fc&quot; parameter.&n;     *&n;     * The possible values of the &quot;fc&quot; parameter are:&n;     *      0:  Flow control is completely disabled&n;     *      1:  Rx flow control is enabled (we can receive pause&n;     *          frames but not send pause frames).&n;     *      2:  Tx flow control is enabled (we can send pause frames&n;     *          frames but we do not receive pause frames).&n;     *      3:  Both Rx and TX flow control (symmetric) is enabled.&n;     *  other:  No other values should be possible at this point.&n;     */
r_switch
c_cond
(paren
id|hw-&gt;fc
)paren
(brace
r_case
id|e1000_fc_none
suffix:colon
id|ctrl
op_and_assign
(paren
op_complement
(paren
id|E1000_CTRL_TFCE
op_or
id|E1000_CTRL_RFCE
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_rx_pause
suffix:colon
id|ctrl
op_and_assign
(paren
op_complement
id|E1000_CTRL_TFCE
)paren
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_RFCE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_tx_pause
suffix:colon
id|ctrl
op_and_assign
(paren
op_complement
id|E1000_CTRL_RFCE
)paren
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_TFCE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_full
suffix:colon
id|ctrl
op_or_assign
(paren
id|E1000_CTRL_TFCE
op_or
id|E1000_CTRL_RFCE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow control param set incorrectly&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
multiline_comment|/* Disable TX Flow Control for 82542 (rev 2.0) */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
id|ctrl
op_and_assign
(paren
op_complement
id|E1000_CTRL_TFCE
)paren
suffix:semicolon
)brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Configures flow control settings after link is established&n; * &n; * hw - Struct containing variables accessed by shared code&n; *&n; * Should be called immediately after a valid link has been established.&n; * Forces MAC flow control settings if link was forced. When in MII/GMII mode&n; * and autonegotiation is enabled, the MAC flow control settings will be set&n; * based on the flow control negotiated by the PHY. In TBI mode, the TFCE&n; * and RFCE bits will be automaticaly set to the negotiated flow control mode.&n; *****************************************************************************/
r_int32
DECL|function|e1000_config_fc_after_link_up
id|e1000_config_fc_after_link_up
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|mii_status_reg
suffix:semicolon
r_uint16
id|mii_nway_adv_reg
suffix:semicolon
r_uint16
id|mii_nway_lp_ability_reg
suffix:semicolon
r_uint16
id|speed
suffix:semicolon
r_uint16
id|duplex
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_config_fc_after_link_up&quot;
)paren
suffix:semicolon
multiline_comment|/* Check for the case where we have fiber media and auto-neg failed&n;     * so we had to force link.  In this case, we need to force the&n;     * configuration of the MAC to match the &quot;fc&quot; parameter.&n;     */
r_if
c_cond
(paren
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
op_logical_and
(paren
id|hw-&gt;autoneg_failed
)paren
)paren
op_logical_or
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_copper
)paren
op_logical_and
(paren
op_logical_neg
id|hw-&gt;autoneg
)paren
)paren
)paren
(brace
id|ret_val
op_assign
id|e1000_force_mac_fc
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error forcing flow control settings&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
multiline_comment|/* Check for the case where we have copper media and auto-neg is&n;     * enabled.  In this case, we need to check and see if Auto-Neg&n;     * has completed, and if so, how the PHY and link partner has&n;     * flow control configured.&n;     */
r_if
c_cond
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_copper
)paren
op_logical_and
id|hw-&gt;autoneg
)paren
(brace
multiline_comment|/* Read the MII Status Register and check to see if AutoNeg&n;         * has completed.  We read this twice because this reg has&n;         * some &quot;sticky&quot; (latched) bits.&n;         */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|mii_status_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|mii_status_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_AUTONEG_COMPLETE
)paren
(brace
multiline_comment|/* The AutoNeg process has completed, so we now need to&n;             * read both the Auto Negotiation Advertisement Register&n;             * (Address 4) and the Auto_Negotiation Base Page Ability&n;             * Register (Address 5) to determine how flow control was&n;             * negotiated.&n;             */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_AUTONEG_ADV
comma
op_amp
id|mii_nway_adv_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_LP_ABILITY
comma
op_amp
id|mii_nway_lp_ability_reg
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
multiline_comment|/* Two bits in the Auto Negotiation Advertisement Register&n;             * (Address 4) and two bits in the Auto Negotiation Base&n;             * Page Ability Register (Address 5) determine flow control&n;             * for both the PHY and the link partner.  The following&n;             * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,&n;             * 1999, describes these PAUSE resolution bits and how flow&n;             * control is determined based upon these settings.&n;             * NOTE:  DC = Don&squot;t Care&n;             *&n;             *   LOCAL DEVICE  |   LINK PARTNER&n;             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution&n;             *-------|---------|-------|---------|--------------------&n;             *   0   |    0    |  DC   |   DC    | e1000_fc_none&n;             *   0   |    1    |   0   |   DC    | e1000_fc_none&n;             *   0   |    1    |   1   |    0    | e1000_fc_none&n;             *   0   |    1    |   1   |    1    | e1000_fc_tx_pause&n;             *   1   |    0    |   0   |   DC    | e1000_fc_none&n;             *   1   |   DC    |   1   |   DC    | e1000_fc_full&n;             *   1   |    1    |   0   |    0    | e1000_fc_none&n;             *   1   |    1    |   0   |    1    | e1000_fc_rx_pause&n;             *&n;             */
multiline_comment|/* Are both PAUSE bits set to 1?  If so, this implies&n;             * Symmetric Flow Control is enabled at both ends.  The&n;             * ASM_DIR bits are irrelevant per the spec.&n;             *&n;             * For Symmetric Flow Control:&n;             *&n;             *   LOCAL DEVICE  |   LINK PARTNER&n;             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result&n;             *-------|---------|-------|---------|--------------------&n;             *   1   |   DC    |   1   |   DC    | e1000_fc_full&n;             *&n;             */
r_if
c_cond
(paren
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_PAUSE
)paren
)paren
(brace
multiline_comment|/* Now we need to check if the user selected RX ONLY&n;                 * of pause frames.  In this case, we had to advertise&n;                 * FULL flow control because we could not advertise RX&n;                 * ONLY. Hence, we must now check to see if we need to&n;                 * turn OFF  the TRANSMISSION of PAUSE frames.&n;                 */
r_if
c_cond
(paren
id|hw-&gt;original_fc
op_eq
id|e1000_fc_full
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_full
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = FULL.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_rx_pause
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = RX PAUSE frames only.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* For receiving PAUSE frames ONLY.&n;             *&n;             *   LOCAL DEVICE  |   LINK PARTNER&n;             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result&n;             *-------|---------|-------|---------|--------------------&n;             *   0   |    1    |   1   |    1    | e1000_fc_tx_pause&n;             *&n;             */
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_ASM_DIR
)paren
op_logical_and
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_ASM_DIR
)paren
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_tx_pause
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = TX PAUSE frames only.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* For transmitting PAUSE frames ONLY.&n;             *&n;             *   LOCAL DEVICE  |   LINK PARTNER&n;             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result&n;             *-------|---------|-------|---------|--------------------&n;             *   1   |    1    |   0   |    1    | e1000_fc_rx_pause&n;             *&n;             */
r_else
r_if
c_cond
(paren
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_ASM_DIR
)paren
op_logical_and
op_logical_neg
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_ASM_DIR
)paren
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_rx_pause
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = RX PAUSE frames only.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Per the IEEE spec, at this point flow control should be&n;             * disabled.  However, we want to consider that we could&n;             * be connected to a legacy switch that doesn&squot;t advertise&n;             * desired flow control, but can be forced on the link&n;             * partner.  So if we advertised no flow control, that is&n;             * what we will resolve to.  If we advertised some kind of&n;             * receive capability (Rx Pause Only or Full Flow Control)&n;             * and the link partner advertised none, we will configure&n;             * ourselves to enable Rx Flow Control only.  We can do&n;             * this safely for two reasons:  If the link partner really&n;             * didn&squot;t want flow control enabled, and we enable Rx, no&n;             * harm done since we won&squot;t be receiving any PAUSE frames&n;             * anyway.  If the intent on the link partner was to have&n;             * flow control enabled, then by us enabling RX only, we&n;             * can at least receive pause frames and process them.&n;             * This is a good idea because in most cases, since we are&n;             * predominantly a server NIC, more times than not we will&n;             * be asked to delay transmission of packets than asking&n;             * our link partner to pause transmission of frames.&n;             */
r_else
r_if
c_cond
(paren
id|hw-&gt;original_fc
op_eq
id|e1000_fc_none
op_logical_or
id|hw-&gt;original_fc
op_eq
id|e1000_fc_tx_pause
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_none
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = NONE.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_rx_pause
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = RX PAUSE frames only.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we need to do one last check...  If we auto-&n;             * negotiated to HALF DUPLEX, flow control should not be&n;             * enabled per IEEE 802.3 spec.&n;             */
id|e1000_get_speed_and_duplex
c_func
(paren
id|hw
comma
op_amp
id|speed
comma
op_amp
id|duplex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|duplex
op_eq
id|HALF_DUPLEX
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_none
suffix:semicolon
)brace
multiline_comment|/* Now we call a subroutine to actually force the MAC&n;             * controller to use the correct flow control settings.&n;             */
id|ret_val
op_assign
id|e1000_force_mac_fc
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error forcing flow control settings&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Copper PHY and Auto Neg has not completed.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Checks to see if the link status of the hardware has changed.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Called by any function that needs to check the link status of the adapter.&n; *****************************************************************************/
r_int32
DECL|function|e1000_check_for_link
id|e1000_check_for_link
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|rxcw
suffix:semicolon
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|status
suffix:semicolon
r_uint32
id|rctl
suffix:semicolon
r_uint32
id|signal
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
r_uint16
id|lp_capability
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_check_for_link&quot;
)paren
suffix:semicolon
multiline_comment|/* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be &n;     * set when the optics detect a signal. On older adapters, it will be &n;     * cleared when there is a signal&n;     */
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82544
)paren
(brace
id|signal
op_assign
id|E1000_CTRL_SWDPIN1
suffix:semicolon
)brace
r_else
id|signal
op_assign
l_int|0
suffix:semicolon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|status
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
suffix:semicolon
id|rxcw
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RXCW
)paren
suffix:semicolon
multiline_comment|/* If we have a copper PHY then we only want to go out to the PHY&n;     * registers to see if Auto-Neg has completed and/or if our link&n;     * status has changed.  The get_link_status flag will be set if we&n;     * receive a Link Status Change interrupt or we have Rx Sequence&n;     * Errors.&n;     */
r_if
c_cond
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_copper
)paren
op_logical_and
id|hw-&gt;get_link_status
)paren
(brace
multiline_comment|/* First we want to see if the MII Status Register reports&n;         * link.  If so, then we want to get the current speed/duplex&n;         * of the PHY.&n;         * Read the register twice since the link bit is sticky.&n;         */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|phy_data
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
id|hw-&gt;get_link_status
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No link detected */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If we are forcing speed/duplex, then we simply return since&n;         * we have already determined whether we have link or not.&n;         */
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;autoneg
)paren
(brace
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
multiline_comment|/* We have a M88E1000 PHY and Auto-Neg is enabled.  If we&n;         * have Si on board that is 82544 or newer, Auto&n;         * Speed Detection takes care of MAC speed/duplex&n;         * configuration.  So we only need to configure Collision&n;         * Distance in the MAC.  Otherwise, we need to force&n;         * speed/duplex on the MAC to the current PHY speed/duplex&n;         * settings.&n;         */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_ge
id|e1000_82544
)paren
(brace
id|e1000_config_collision_dist
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret_val
op_assign
id|e1000_config_mac_to_phy
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error configuring MAC to PHY settings&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
multiline_comment|/* Configure Flow Control now that Auto-Neg has completed. First, we &n;         * need to restore the desired flow control settings because we may&n;         * have had to re-autoneg with a different link partner.&n;         */
id|ret_val
op_assign
id|e1000_config_fc_after_link_up
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error configuring flow control&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* At this point we know that we are on copper and we have&n;         * auto-negotiated link.  These are conditions for checking the link&n;         * parter capability register.  We use the link partner capability to&n;         * determine if TBI Compatibility needs to be turned on or off.  If&n;         * the link partner advertises any speed in addition to Gigabit, then&n;         * we assume that they are GMII-based, and TBI compatibility is not&n;         * needed. If no other speeds are advertised, we assume the link&n;         * partner is TBI-based, and we turn on TBI Compatibility.&n;         */
r_if
c_cond
(paren
id|hw-&gt;tbi_compatibility_en
)paren
(brace
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_LP_ABILITY
comma
op_amp
id|lp_capability
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp_capability
op_amp
(paren
id|NWAY_LPAR_10T_HD_CAPS
op_or
id|NWAY_LPAR_10T_FD_CAPS
op_or
id|NWAY_LPAR_100TX_HD_CAPS
op_or
id|NWAY_LPAR_100TX_FD_CAPS
op_or
id|NWAY_LPAR_100T4_CAPS
)paren
)paren
(brace
multiline_comment|/* If our link partner advertises anything in addition to &n;                 * gigabit, we do not need to enable TBI compatibility.&n;                 */
r_if
c_cond
(paren
id|hw-&gt;tbi_compatibility_on
)paren
(brace
multiline_comment|/* If we previously were in the mode, turn it off. */
id|rctl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RCTL
)paren
suffix:semicolon
id|rctl
op_and_assign
op_complement
id|E1000_RCTL_SBP
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|RCTL
comma
id|rctl
)paren
suffix:semicolon
id|hw-&gt;tbi_compatibility_on
op_assign
id|FALSE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* If TBI compatibility is was previously off, turn it on. For&n;                 * compatibility with a TBI link partner, we will store bad&n;                 * packets. Some frames have an additional byte on the end and&n;                 * will look like CRC errors to to the hardware.&n;                 */
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;tbi_compatibility_on
)paren
(brace
id|hw-&gt;tbi_compatibility_on
op_assign
id|TRUE
suffix:semicolon
id|rctl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RCTL
)paren
suffix:semicolon
id|rctl
op_or_assign
id|E1000_RCTL_SBP
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|RCTL
comma
id|rctl
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* If we don&squot;t have link (auto-negotiation failed or link partner cannot&n;     * auto-negotiate), the cable is plugged in (we have signal), and our&n;     * link partner is not trying to auto-negotiate with us (we are receiving&n;     * idles or data), we need to force link up. We also need to give&n;     * auto-negotiation time to complete, in case the cable was just plugged&n;     * in. The autoneg_failed flag does this.&n;     */
r_else
r_if
c_cond
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|status
op_amp
id|E1000_STATUS_LU
)paren
)paren
op_logical_and
(paren
(paren
id|ctrl
op_amp
id|E1000_CTRL_SWDPIN1
)paren
op_eq
id|signal
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|rxcw
op_amp
id|E1000_RXCW_C
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;autoneg_failed
op_eq
l_int|0
)paren
(brace
id|hw-&gt;autoneg_failed
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;NOT RXing /C/, disable AutoNeg and force link.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Disable auto-negotiation in the TXCW register */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|TXCW
comma
(paren
id|hw-&gt;txcw
op_amp
op_complement
id|E1000_TXCW_ANE
)paren
)paren
suffix:semicolon
multiline_comment|/* Force link-up and also force full-duplex. */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|ctrl
op_or_assign
(paren
id|E1000_CTRL_SLU
op_or
id|E1000_CTRL_FD
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Configure Flow Control after forcing link up. */
id|ret_val
op_assign
id|e1000_config_fc_after_link_up
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error configuring flow control&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
multiline_comment|/* If we are forcing link and we are receiving /C/ ordered sets, re-enable&n;     * auto-negotiation in the TXCW register and disable forced link in the&n;     * Device Control register in an attempt to auto-negotiate with our link&n;     * partner.&n;     */
r_else
r_if
c_cond
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
op_logical_and
(paren
id|ctrl
op_amp
id|E1000_CTRL_SLU
)paren
op_logical_and
(paren
id|rxcw
op_amp
id|E1000_RXCW_C
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;RXing /C/, enable AutoNeg and stop forcing link.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|TXCW
comma
id|hw-&gt;txcw
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
(paren
id|ctrl
op_amp
op_complement
id|E1000_CTRL_SLU
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Detects the current speed and duplex settings of the hardware.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * speed - Speed of the connection&n; * duplex - Duplex setting of the connection&n; *****************************************************************************/
r_void
DECL|function|e1000_get_speed_and_duplex
id|e1000_get_speed_and_duplex
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
op_star
id|speed
comma
r_uint16
op_star
id|duplex
)paren
(brace
r_uint32
id|status
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_get_speed_and_duplex&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_ge
id|e1000_82543
)paren
(brace
id|status
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|E1000_STATUS_SPEED_1000
)paren
(brace
op_star
id|speed
op_assign
id|SPEED_1000
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;1000 Mbs, &quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|E1000_STATUS_SPEED_100
)paren
(brace
op_star
id|speed
op_assign
id|SPEED_100
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;100 Mbs, &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|speed
op_assign
id|SPEED_10
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;10 Mbs, &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|E1000_STATUS_FD
)paren
(brace
op_star
id|duplex
op_assign
id|FULL_DUPLEX
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Full Duplex&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|duplex
op_assign
id|HALF_DUPLEX
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot; Half Duplex&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;1000 Mbs, Full Duplex&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|speed
op_assign
id|SPEED_1000
suffix:semicolon
op_star
id|duplex
op_assign
id|FULL_DUPLEX
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n;* Blocks until autoneg completes or times out (~4.5 seconds)&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_int32
DECL|function|e1000_wait_autoneg
id|e1000_wait_autoneg
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint16
id|i
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_wait_autoneg&quot;
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Waiting for Auto-Neg to complete.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
r_for
c_loop
(paren
id|i
op_assign
id|PHY_AUTO_NEG_TIME
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
multiline_comment|/* Read the MII Status Register and wait for Auto-Neg&n;         * Complete bit to be set.&n;         */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|phy_data
op_amp
id|MII_SR_AUTONEG_COMPLETE
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|msec_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Raises the Management Data Clock&n;*&n;* hw - Struct containing variables accessed by shared code&n;* ctrl - Device control register&squot;s current value&n;******************************************************************************/
r_static
r_void
DECL|function|e1000_raise_mdi_clk
id|e1000_raise_mdi_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|ctrl
)paren
(brace
multiline_comment|/* Raise the clock input to the Management Data Clock (by setting the MDC&n;     * bit), and then delay 2 microseconds.&n;     */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
(paren
op_star
id|ctrl
op_or
id|E1000_CTRL_MDC
)paren
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Lowers the Management Data Clock&n;*&n;* hw - Struct containing variables accessed by shared code&n;* ctrl - Device control register&squot;s current value&n;******************************************************************************/
r_static
r_void
DECL|function|e1000_lower_mdi_clk
id|e1000_lower_mdi_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|ctrl
)paren
(brace
multiline_comment|/* Lower the clock input to the Management Data Clock (by clearing the MDC&n;     * bit), and then delay 2 microseconds.&n;     */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
(paren
op_star
id|ctrl
op_amp
op_complement
id|E1000_CTRL_MDC
)paren
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Shifts data bits out to the PHY&n;*&n;* hw - Struct containing variables accessed by shared code&n;* data - Data to send out to the PHY&n;* count - Number of bits to shift out&n;*&n;* Bits are shifted out in MSB to LSB order.&n;******************************************************************************/
r_static
r_void
DECL|function|e1000_shift_out_mdi_bits
id|e1000_shift_out_mdi_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|data
comma
r_uint16
id|count
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|mask
suffix:semicolon
multiline_comment|/* We need to shift &quot;count&quot; number of bits out to the PHY. So, the value&n;     * in the &quot;data&quot; parameter will be shifted out to the PHY one bit at a &n;     * time. In order to do this, &quot;data&quot; must be broken down into bits.&n;     */
id|mask
op_assign
l_int|0x01
suffix:semicolon
id|mask
op_lshift_assign
(paren
id|count
op_minus
l_int|1
)paren
suffix:semicolon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
id|ctrl
op_or_assign
(paren
id|E1000_CTRL_MDIO_DIR
op_or
id|E1000_CTRL_MDC_DIR
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mask
)paren
(brace
multiline_comment|/* A &quot;1&quot; is shifted out to the PHY by setting the MDIO bit to &quot;1&quot; and&n;         * then raising and lowering the Management Data Clock. A &quot;0&quot; is&n;         * shifted out to the PHY by setting the MDIO bit to &quot;0&quot; and then&n;         * raising and lowering the clock.&n;         */
r_if
c_cond
(paren
id|data
op_amp
id|mask
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_MDIO
suffix:semicolon
)brace
r_else
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_MDIO
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|e1000_raise_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
id|e1000_lower_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
id|mask
op_assign
id|mask
op_rshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Clear the data bit just before leaving this routine. */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_MDIO
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Shifts data bits in from the PHY&n;*&n;* hw - Struct containing variables accessed by shared code&n;*&n;* Bits are shifted in in MSB to LSB order. &n;******************************************************************************/
r_static
r_uint16
DECL|function|e1000_shift_in_mdi_bits
id|e1000_shift_in_mdi_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint16
id|data
op_assign
l_int|0
suffix:semicolon
r_uint8
id|i
suffix:semicolon
multiline_comment|/* In order to read a register from the PHY, we need to shift in a total&n;     * of 18 bits from the PHY. The first two bit (turnaround) times are used&n;     * to avoid contention on the MDIO pin when a read operation is performed.&n;     * These two bits are ignored by us and thrown away. Bits are &quot;shifted in&quot;&n;     * by raising the input to the Management Data Clock (setting the MDC bit),&n;     * and then reading the value of the MDIO bit.&n;     */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as input. */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_MDIO_DIR
suffix:semicolon
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_MDIO
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Raise and Lower the clock before reading in the data. This accounts for&n;     * the turnaround bits. The first clock occurred when we clocked out the&n;     * last bit of the Register Address.&n;     */
id|e1000_raise_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
id|e1000_lower_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
r_for
c_loop
(paren
id|data
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|data
op_lshift
l_int|1
suffix:semicolon
id|e1000_raise_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Check to see if we shifted in a &quot;1&quot;. */
r_if
c_cond
(paren
id|ctrl
op_amp
id|E1000_CTRL_MDIO
)paren
(brace
id|data
op_or_assign
l_int|1
suffix:semicolon
)brace
id|e1000_lower_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
)brace
id|e1000_raise_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
id|e1000_lower_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Clear the MDIO bit just before leaving this routine. */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_MDIO
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n;* Reads the value from a PHY register&n;*&n;* hw - Struct containing variables accessed by shared code&n;* reg_addr - address of the PHY register to read&n;******************************************************************************/
r_int32
DECL|function|e1000_read_phy_reg
id|e1000_read_phy_reg
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|reg_addr
comma
r_uint16
op_star
id|phy_data
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_uint32
id|mdic
op_assign
l_int|0
suffix:semicolon
r_const
r_uint32
id|phy_addr
op_assign
l_int|1
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_read_phy_reg&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_addr
OG
id|MAX_PHY_REG_ADDRESS
)paren
(brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;PHY Address %d is out of range&bslash;n&quot;
comma
id|reg_addr
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PARAM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82543
)paren
(brace
multiline_comment|/* Set up Op-code, Phy Address, and register address in the MDI&n;         * Control register.  The MAC will take care of interfacing with the&n;         * PHY to retrieve the desired data.&n;         */
id|mdic
op_assign
(paren
(paren
id|reg_addr
op_lshift
id|E1000_MDIC_REG_SHIFT
)paren
op_or
(paren
id|phy_addr
op_lshift
id|E1000_MDIC_PHY_SHIFT
)paren
op_or
(paren
id|E1000_MDIC_OP_READ
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|MDIC
comma
id|mdic
)paren
suffix:semicolon
multiline_comment|/* Poll the ready bit to see if the MDI read completed */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
(brace
id|usec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|mdic
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MDIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mdic
op_amp
id|E1000_MDIC_READY
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mdic
op_amp
id|E1000_MDIC_READY
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MDI Read did not complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mdic
op_amp
id|E1000_MDIC_ERROR
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MDI Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
op_star
id|phy_data
op_assign
(paren
r_uint16
)paren
id|mdic
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We must first send a preamble through the MDIO pin to signal the&n;         * beginning of an MII instruction.  This is done by sending 32&n;         * consecutive &quot;1&quot; bits.&n;         */
id|e1000_shift_out_mdi_bits
c_func
(paren
id|hw
comma
id|PHY_PREAMBLE
comma
id|PHY_PREAMBLE_SIZE
)paren
suffix:semicolon
multiline_comment|/* Now combine the next few fields that are required for a read&n;         * operation.  We use this method instead of calling the&n;         * e1000_shift_out_mdi_bits routine five different times. The format of&n;         * a MII read instruction consists of a shift out of 14 bits and is&n;         * defined as follows:&n;         *    &lt;Preamble&gt;&lt;SOF&gt;&lt;Op Code&gt;&lt;Phy Addr&gt;&lt;Reg Addr&gt;&n;         * followed by a shift in of 18 bits.  This first two bits shifted in&n;         * are TurnAround bits used to avoid contention on the MDIO pin when a&n;         * READ operation is performed.  These two bits are thrown away&n;         * followed by a shift in of 16 bits which contains the desired data.&n;         */
id|mdic
op_assign
(paren
(paren
id|reg_addr
)paren
op_or
(paren
id|phy_addr
op_lshift
l_int|5
)paren
op_or
(paren
id|PHY_OP_READ
op_lshift
l_int|10
)paren
op_or
(paren
id|PHY_SOF
op_lshift
l_int|12
)paren
)paren
suffix:semicolon
id|e1000_shift_out_mdi_bits
c_func
(paren
id|hw
comma
id|mdic
comma
l_int|14
)paren
suffix:semicolon
multiline_comment|/* Now that we&squot;ve shifted out the read command to the MII, we need to&n;         * &quot;shift in&quot; the 16-bit value (18 total bits) of the requested PHY&n;         * register address.&n;         */
op_star
id|phy_data
op_assign
id|e1000_shift_in_mdi_bits
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Writes a value to a PHY register&n;*&n;* hw - Struct containing variables accessed by shared code&n;* reg_addr - address of the PHY register to write&n;* data - data to write to the PHY&n;******************************************************************************/
r_int32
DECL|function|e1000_write_phy_reg
id|e1000_write_phy_reg
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|reg_addr
comma
r_uint16
id|phy_data
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_uint32
id|mdic
op_assign
l_int|0
suffix:semicolon
r_const
r_uint32
id|phy_addr
op_assign
l_int|1
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_write_phy_reg&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_addr
OG
id|MAX_PHY_REG_ADDRESS
)paren
(brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;PHY Address %d is out of range&bslash;n&quot;
comma
id|reg_addr
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PARAM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82543
)paren
(brace
multiline_comment|/* Set up Op-code, Phy Address, register address, and data intended&n;         * for the PHY register in the MDI Control register.  The MAC will take&n;         * care of interfacing with the PHY to send the desired data.&n;         */
id|mdic
op_assign
(paren
(paren
(paren
r_uint32
)paren
id|phy_data
)paren
op_or
(paren
id|reg_addr
op_lshift
id|E1000_MDIC_REG_SHIFT
)paren
op_or
(paren
id|phy_addr
op_lshift
id|E1000_MDIC_PHY_SHIFT
)paren
op_or
(paren
id|E1000_MDIC_OP_WRITE
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|MDIC
comma
id|mdic
)paren
suffix:semicolon
multiline_comment|/* Poll the ready bit to see if the MDI read completed */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
(brace
id|usec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|mdic
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MDIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mdic
op_amp
id|E1000_MDIC_READY
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mdic
op_amp
id|E1000_MDIC_READY
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MDI Write did not complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* We&squot;ll need to use the SW defined pins to shift the write command&n;         * out to the PHY. We first send a preamble to the PHY to signal the&n;         * beginning of the MII instruction.  This is done by sending 32 &n;         * consecutive &quot;1&quot; bits.&n;         */
id|e1000_shift_out_mdi_bits
c_func
(paren
id|hw
comma
id|PHY_PREAMBLE
comma
id|PHY_PREAMBLE_SIZE
)paren
suffix:semicolon
multiline_comment|/* Now combine the remaining required fields that will indicate a &n;         * write operation. We use this method instead of calling the&n;         * e1000_shift_out_mdi_bits routine for each field in the command. The&n;         * format of a MII write instruction is as follows:&n;         * &lt;Preamble&gt;&lt;SOF&gt;&lt;Op Code&gt;&lt;Phy Addr&gt;&lt;Reg Addr&gt;&lt;Turnaround&gt;&lt;Data&gt;.&n;         */
id|mdic
op_assign
(paren
(paren
id|PHY_TURNAROUND
)paren
op_or
(paren
id|reg_addr
op_lshift
l_int|2
)paren
op_or
(paren
id|phy_addr
op_lshift
l_int|7
)paren
op_or
(paren
id|PHY_OP_WRITE
op_lshift
l_int|12
)paren
op_or
(paren
id|PHY_SOF
op_lshift
l_int|14
)paren
)paren
suffix:semicolon
id|mdic
op_lshift_assign
l_int|16
suffix:semicolon
id|mdic
op_or_assign
(paren
r_uint32
)paren
id|phy_data
suffix:semicolon
id|e1000_shift_out_mdi_bits
c_func
(paren
id|hw
comma
id|mdic
comma
l_int|32
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Returns the PHY to the power-on reset state&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_void
DECL|function|e1000_phy_hw_reset
id|e1000_phy_hw_reset
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|ctrl_ext
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_hw_reset&quot;
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Resetting Phy...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82543
)paren
(brace
multiline_comment|/* Read the device control register and assert the E1000_CTRL_PHY_RST&n;         * bit. Then, take it out of reset.&n;         */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
op_or
id|E1000_CTRL_PHY_RST
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Read the Extended Device Control Register, assert the PHY_RESET_DIR&n;         * bit to put the PHY into reset. Then, take it out of reset.&n;         */
id|ctrl_ext
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL_EXT
)paren
suffix:semicolon
id|ctrl_ext
op_or_assign
id|E1000_CTRL_EXT_SDP4_DIR
suffix:semicolon
id|ctrl_ext
op_and_assign
op_complement
id|E1000_CTRL_EXT_SDP4_DATA
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL_EXT
comma
id|ctrl_ext
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ctrl_ext
op_or_assign
id|E1000_CTRL_EXT_SDP4_DATA
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL_EXT
comma
id|ctrl_ext
)paren
suffix:semicolon
)brace
id|usec_delay
c_func
(paren
l_int|150
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Resets the PHY&n;*&n;* hw - Struct containing variables accessed by shared code&n;*&n;* Sets bit 15 of the MII Control regiser&n;******************************************************************************/
r_int32
DECL|function|e1000_phy_reset
id|e1000_phy_reset
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_reset&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_CTRL
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|phy_data
op_or_assign
id|MII_CR_RESET
suffix:semicolon
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|PHY_CTRL
comma
id|phy_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Write Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|usec_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Probes the expected PHY address for known PHY IDs&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_int32
DECL|function|e1000_detect_gig_phy
id|e1000_detect_gig_phy
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint16
id|phy_id_high
comma
id|phy_id_low
suffix:semicolon
id|boolean_t
id|match
op_assign
id|FALSE
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_detect_gig_phy&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the PHY ID Registers to identify which PHY is onboard. */
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_ID1
comma
op_amp
id|phy_id_high
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|hw-&gt;phy_id
op_assign
(paren
r_uint32
)paren
(paren
id|phy_id_high
op_lshift
l_int|16
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_ID2
comma
op_amp
id|phy_id_low
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|hw-&gt;phy_id
op_or_assign
(paren
r_uint32
)paren
(paren
id|phy_id_low
op_amp
id|PHY_REVISION_MASK
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;mac_type
)paren
(brace
r_case
id|e1000_82543
suffix:colon
r_if
c_cond
(paren
id|hw-&gt;phy_id
op_eq
id|M88E1000_E_PHY_ID
)paren
(brace
id|match
op_assign
id|TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|e1000_82544
suffix:colon
r_if
c_cond
(paren
id|hw-&gt;phy_id
op_eq
id|M88E1000_I_PHY_ID
)paren
(brace
id|match
op_assign
id|TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|e1000_82540
suffix:colon
r_if
c_cond
(paren
id|hw-&gt;phy_id
op_eq
id|M88E1011_I_PHY_ID
)paren
(brace
id|match
op_assign
id|TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Invalid MAC type %d&bslash;n&quot;
comma
id|hw-&gt;mac_type
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_if
c_cond
(paren
id|match
)paren
(brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;PHY ID 0x%X detected&bslash;n&quot;
comma
id|hw-&gt;phy_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Invalid PHY ID 0x%X&bslash;n&quot;
comma
id|hw-&gt;phy_id
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Resets the PHY&squot;s DSP&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_static
r_int32
DECL|function|e1000_phy_reset_dsp
id|e1000_phy_reset_dsp
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_int32
id|ret_val
op_assign
op_minus
id|E1000_ERR_PHY
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_reset_dsp&quot;
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|29
comma
l_int|0x1d
)paren
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|30
comma
l_int|0xc1
)paren
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|30
comma
l_int|0x00
)paren
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|ret_val
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Write Error&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Get PHY information from various PHY registers&n;*&n;* hw - Struct containing variables accessed by shared code&n;* phy_info - PHY information structure&n;******************************************************************************/
r_int32
DECL|function|e1000_phy_get_info
id|e1000_phy_get_info
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_struct
id|e1000_phy_info
op_star
id|phy_info
)paren
(brace
r_int32
id|ret_val
op_assign
op_minus
id|E1000_ERR_PHY
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_get_info&quot;
)paren
suffix:semicolon
id|phy_info-&gt;cable_length
op_assign
id|e1000_cable_length_undefined
suffix:semicolon
id|phy_info-&gt;extended_10bt_distance
op_assign
id|e1000_10bt_ext_dist_enable_undefined
suffix:semicolon
id|phy_info-&gt;cable_polarity
op_assign
id|e1000_rev_polarity_undefined
suffix:semicolon
id|phy_info-&gt;polarity_correction
op_assign
id|e1000_polarity_reversal_undefined
suffix:semicolon
id|phy_info-&gt;mdix_mode
op_assign
id|e1000_auto_x_mode_undefined
suffix:semicolon
id|phy_info-&gt;local_rx
op_assign
id|e1000_1000t_rx_status_undefined
suffix:semicolon
id|phy_info-&gt;remote_rx
op_assign
id|e1000_1000t_rx_status_undefined
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;media_type
op_ne
id|e1000_media_type_copper
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY info is only valid for copper media&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_do
(brace
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|phy_data
op_amp
id|MII_SR_LINK_STATUS
)paren
op_ne
id|MII_SR_LINK_STATUS
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY info is only valid if link is up&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|phy_info-&gt;extended_10bt_distance
op_assign
(paren
id|phy_data
op_amp
id|M88E1000_PSCR_10BT_EXT_DIST_ENABLE
)paren
op_rshift
id|M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT
suffix:semicolon
id|phy_info-&gt;polarity_correction
op_assign
(paren
id|phy_data
op_amp
id|M88E1000_PSCR_POLARITY_REVERSAL
)paren
op_rshift
id|M88E1000_PSCR_POLARITY_REVERSAL_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_STATUS
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|phy_info-&gt;cable_polarity
op_assign
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_REV_POLARITY
)paren
op_rshift
id|M88E1000_PSSR_REV_POLARITY_SHIFT
suffix:semicolon
id|phy_info-&gt;mdix_mode
op_assign
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_MDIX
)paren
op_rshift
id|M88E1000_PSSR_MDIX_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_1000MBS
)paren
(brace
multiline_comment|/* Cable Length Estimation and Local/Remote Receiver Informatoion&n;&t;     * are only valid at 1000 Mbps&n;&t;     */
id|phy_info-&gt;cable_length
op_assign
(paren
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_CABLE_LENGTH
)paren
op_rshift
id|M88E1000_PSSR_CABLE_LENGTH_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_STATUS
comma
op_amp
id|phy_data
)paren
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|phy_info-&gt;local_rx
op_assign
(paren
id|phy_data
op_amp
id|SR_1000T_LOCAL_RX_STATUS
)paren
op_rshift
id|SR_1000T_LOCAL_RX_STATUS_SHIFT
suffix:semicolon
id|phy_info-&gt;remote_rx
op_assign
(paren
id|phy_data
op_amp
id|SR_1000T_REMOTE_RX_STATUS
)paren
op_rshift
id|SR_1000T_REMOTE_RX_STATUS_SHIFT
suffix:semicolon
)brace
id|ret_val
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret_val
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY Read Error&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|ret_val
suffix:semicolon
)brace
r_int32
DECL|function|e1000_validate_mdi_setting
id|e1000_validate_mdi_setting
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_validate_mdi_settings&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;autoneg
op_logical_and
(paren
id|hw-&gt;mdix
op_eq
l_int|0
op_logical_or
id|hw-&gt;mdix
op_eq
l_int|3
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Invalid MDI setting detected&bslash;n&quot;
)paren
suffix:semicolon
id|hw-&gt;mdix
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Raises the EEPROM&squot;s clock input.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * eecd - EECD&squot;s current value&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_raise_ee_clk
id|e1000_raise_ee_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|eecd
)paren
(brace
multiline_comment|/* Raise the clock input to the EEPROM (by setting the SK bit), and then&n;     * wait 50 microseconds.&n;     */
op_star
id|eecd
op_assign
op_star
id|eecd
op_or
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
op_star
id|eecd
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Lowers the EEPROM&squot;s clock input.&n; *&n; * hw - Struct containing variables accessed by shared code &n; * eecd - EECD&squot;s current value&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_lower_ee_clk
id|e1000_lower_ee_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|eecd
)paren
(brace
multiline_comment|/* Lower the clock input to the EEPROM (by clearing the SK bit), and then &n;     * wait 50 microseconds. &n;     */
op_star
id|eecd
op_assign
op_star
id|eecd
op_amp
op_complement
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
op_star
id|eecd
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Shift data bits out to the EEPROM.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * data - data to send to the EEPROM&n; * count - number of bits to shift out&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_shift_out_ee_bits
id|e1000_shift_out_ee_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|data
comma
r_uint16
id|count
)paren
(brace
r_uint32
id|eecd
suffix:semicolon
r_uint32
id|mask
suffix:semicolon
multiline_comment|/* We need to shift &quot;count&quot; bits out to the EEPROM. So, value in the&n;     * &quot;data&quot; parameter will be shifted out to the EEPROM one bit at a time.&n;     * In order to do this, &quot;data&quot; must be broken down into bits. &n;     */
id|mask
op_assign
l_int|0x01
op_lshift
(paren
id|count
op_minus
l_int|1
)paren
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
id|eecd
op_and_assign
op_complement
(paren
id|E1000_EECD_DO
op_or
id|E1000_EECD_DI
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* A &quot;1&quot; is shifted out to the EEPROM by setting bit &quot;DI&quot; to a &quot;1&quot;,&n;         * and then raising and then lowering the clock (the SK bit controls&n;         * the clock input to the EEPROM).  A &quot;0&quot; is shifted out to the EEPROM&n;         * by setting &quot;DI&quot; to &quot;0&quot; and then raising and then lowering the clock.&n;         */
id|eecd
op_and_assign
op_complement
id|E1000_EECD_DI
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|mask
)paren
(brace
id|eecd
op_or_assign
id|E1000_EECD_DI
suffix:semicolon
)brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|e1000_raise_ee_clk
c_func
(paren
id|hw
comma
op_amp
id|eecd
)paren
suffix:semicolon
id|e1000_lower_ee_clk
c_func
(paren
id|hw
comma
op_amp
id|eecd
)paren
suffix:semicolon
id|mask
op_assign
id|mask
op_rshift
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mask
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* We leave the &quot;DI&quot; bit set to &quot;0&quot; when we leave this routine. */
id|eecd
op_and_assign
op_complement
id|E1000_EECD_DI
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Shift data bits in from the EEPROM&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_static
r_uint16
DECL|function|e1000_shift_in_ee_bits
id|e1000_shift_in_ee_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|eecd
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_uint16
id|data
suffix:semicolon
multiline_comment|/* In order to read a register from the EEPROM, we need to shift 16 bits &n;     * in from the EEPROM. Bits are &quot;shifted in&quot; by raising the clock input to&n;     * the EEPROM (setting the SK bit), and then reading the value of the &quot;DO&quot;&n;     * bit.  During this &quot;shifting in&quot; process the &quot;DI&quot; bit should always be &n;     * clear..&n;     */
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
id|eecd
op_and_assign
op_complement
(paren
id|E1000_EECD_DO
op_or
id|E1000_EECD_DI
)paren
suffix:semicolon
id|data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|data
op_lshift
l_int|1
suffix:semicolon
id|e1000_raise_ee_clk
c_func
(paren
id|hw
comma
op_amp
id|eecd
)paren
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
id|eecd
op_and_assign
op_complement
(paren
id|E1000_EECD_DI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eecd
op_amp
id|E1000_EECD_DO
)paren
(brace
id|data
op_or_assign
l_int|1
suffix:semicolon
)brace
id|e1000_lower_ee_clk
c_func
(paren
id|hw
comma
op_amp
id|eecd
)paren
suffix:semicolon
)brace
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Prepares EEPROM for access&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This &n; * function should be called before issuing a command to the EEPROM.&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_setup_eeprom
id|e1000_setup_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|eecd
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
multiline_comment|/* Clear SK and DI */
id|eecd
op_and_assign
op_complement
(paren
id|E1000_EECD_SK
op_or
id|E1000_EECD_DI
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
multiline_comment|/* Set CS */
id|eecd
op_or_assign
id|E1000_EECD_CS
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Returns EEPROM to a &quot;standby&quot; state&n; * &n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_standby_eeprom
id|e1000_standby_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|eecd
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
multiline_comment|/* Deselct EEPROM */
id|eecd
op_and_assign
op_complement
(paren
id|E1000_EECD_CS
op_or
id|E1000_EECD_SK
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* Clock high */
id|eecd
op_or_assign
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* Select EEPROM */
id|eecd
op_or_assign
id|E1000_EECD_CS
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* Clock low */
id|eecd
op_and_assign
op_complement
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Reads a 16 bit word from the EEPROM.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * offset - offset of  word in the EEPROM to read&n; * data - word read from the EEPROM &n; *****************************************************************************/
r_int32
DECL|function|e1000_read_eeprom
id|e1000_read_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|offset
comma
r_uint16
op_star
id|data
)paren
(brace
r_uint32
id|eecd
suffix:semicolon
r_uint32
id|i
op_assign
l_int|0
suffix:semicolon
id|boolean_t
id|large_eeprom
op_assign
id|FALSE
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_read_eeprom&quot;
)paren
suffix:semicolon
multiline_comment|/* Request EEPROM Access */
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82544
)paren
(brace
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eecd
op_amp
id|E1000_EECD_SIZE
)paren
(brace
id|large_eeprom
op_assign
id|TRUE
suffix:semicolon
)brace
id|eecd
op_or_assign
id|E1000_EECD_REQ
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
op_logical_neg
(paren
id|eecd
op_amp
id|E1000_EECD_GNT
)paren
)paren
op_logical_and
(paren
id|i
OL
l_int|100
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|eecd
op_amp
id|E1000_EECD_GNT
)paren
)paren
(brace
id|eecd
op_and_assign
op_complement
id|E1000_EECD_REQ
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Could not acquire EEPROM grant&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
)brace
multiline_comment|/*  Prepare the EEPROM for reading  */
id|e1000_setup_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/*  Send the READ command (opcode + addr)  */
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|EEPROM_READ_OPCODE
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|large_eeprom
)paren
(brace
multiline_comment|/* If we have a 256 word EEPROM, there are 8 address bits */
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|offset
comma
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If we have a 64 word EEPROM, there are 6 address bits */
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|offset
comma
l_int|6
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the data */
op_star
id|data
op_assign
id|e1000_shift_in_ee_bits
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* End this read operation */
id|e1000_standby_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Stop requesting EEPROM access */
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82544
)paren
(brace
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
id|eecd
op_and_assign
op_complement
id|E1000_EECD_REQ
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Verifies that the EEPROM has a valid checksum&n; * &n; * hw - Struct containing variables accessed by shared code&n; *&n; * Reads the first 64 16 bit words of the EEPROM and sums the values read.&n; * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM&squot;s checksum is&n; * valid.&n; *****************************************************************************/
r_int32
DECL|function|e1000_validate_eeprom_checksum
id|e1000_validate_eeprom_checksum
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint16
id|checksum
op_assign
l_int|0
suffix:semicolon
r_uint16
id|i
comma
id|eeprom_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_validate_eeprom_checksum&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|EEPROM_CHECKSUM_REG
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
id|i
comma
op_amp
id|eeprom_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
id|checksum
op_add_assign
id|eeprom_data
suffix:semicolon
)brace
r_if
c_cond
(paren
id|checksum
op_eq
(paren
r_uint16
)paren
id|EEPROM_SUM
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Checksum Invalid&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Reads the adapter&squot;s part number from the EEPROM&n; *&n; * hw - Struct containing variables accessed by shared code&n; * part_num - Adapter&squot;s part number&n; *****************************************************************************/
r_int32
DECL|function|e1000_read_part_num
id|e1000_read_part_num
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|part_num
)paren
(brace
r_uint16
id|offset
op_assign
id|EEPROM_PBA_BYTE_1
suffix:semicolon
r_uint16
id|eeprom_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_read_part_num&quot;
)paren
suffix:semicolon
multiline_comment|/* Get word 0 from EEPROM */
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
id|offset
comma
op_amp
id|eeprom_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
multiline_comment|/* Save word 0 in upper half of part_num */
op_star
id|part_num
op_assign
(paren
r_uint32
)paren
(paren
id|eeprom_data
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Get word 1 from EEPROM */
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
op_increment
id|offset
comma
op_amp
id|eeprom_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
multiline_comment|/* Save word 1 in lower half of part_num */
op_star
id|part_num
op_or_assign
id|eeprom_data
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Reads the adapter&squot;s MAC address from the EEPROM and inverts the LSB for the&n; * second function of dual function devices&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_read_mac_addr
id|e1000_read_mac_addr
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint16
id|offset
suffix:semicolon
r_uint16
id|eeprom_data
comma
id|i
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_read_mac_addr&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NODE_ADDRESS_SIZE
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|offset
op_assign
id|i
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
id|offset
comma
op_amp
id|eeprom_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
id|hw-&gt;perm_mac_addr
(braket
id|i
)braket
op_assign
(paren
r_uint8
)paren
(paren
id|eeprom_data
op_amp
l_int|0x00FF
)paren
suffix:semicolon
id|hw-&gt;perm_mac_addr
(braket
id|i
op_plus
l_int|1
)braket
op_assign
(paren
r_uint8
)paren
(paren
id|eeprom_data
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NODE_ADDRESS_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hw-&gt;mac_addr
(braket
id|i
)braket
op_assign
id|hw-&gt;perm_mac_addr
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Initializes receive address filters.&n; *&n; * hw - Struct containing variables accessed by shared code &n; *&n; * Places the MAC address in receive address register 0 and clears the rest&n; * of the receive addresss registers. Clears the multicast table. Assumes&n; * the receiver is in reset when the routine is called.&n; *****************************************************************************/
r_void
DECL|function|e1000_init_rx_addrs
id|e1000_init_rx_addrs
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_uint32
id|addr_low
suffix:semicolon
r_uint32
id|addr_high
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_init_rx_addrs&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup the receive address. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Programming MAC Address into RAR[0]&bslash;n&quot;
)paren
suffix:semicolon
id|addr_low
op_assign
(paren
id|hw-&gt;mac_addr
(braket
l_int|0
)braket
op_or
(paren
id|hw-&gt;mac_addr
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|hw-&gt;mac_addr
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|hw-&gt;mac_addr
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
)paren
suffix:semicolon
id|addr_high
op_assign
(paren
id|hw-&gt;mac_addr
(braket
l_int|4
)braket
op_or
(paren
id|hw-&gt;mac_addr
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_or
id|E1000_RAH_AV
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
l_int|0
comma
id|addr_low
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
l_int|1
comma
id|addr_high
)paren
suffix:semicolon
multiline_comment|/* Zero out the other 15 receive addresses. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Clearing RAR[1-15]&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|E1000_RAR_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
id|i
op_lshift
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
(paren
id|i
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Updates the MAC&squot;s list of multicast addresses.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * mc_addr_list - the list of new multicast addresses&n; * mc_addr_count - number of addresses&n; * pad - number of bytes between addresses in the list&n; *&n; * The given list replaces any existing list. Clears the last 15 receive&n; * address registers and the multicast table. Uses receive address registers&n; * for the first 15 multicast addresses, and hashes the rest into the &n; * multicast table.&n; *****************************************************************************/
r_void
DECL|function|e1000_mc_addr_list_update
id|e1000_mc_addr_list_update
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint8
op_star
id|mc_addr_list
comma
r_uint32
id|mc_addr_count
comma
r_uint32
id|pad
)paren
(brace
r_uint32
id|hash_value
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_uint32
id|rar_used_count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* RAR[0] is used for our MAC address */
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_mc_addr_list_update&quot;
)paren
suffix:semicolon
multiline_comment|/* Set the new number of MC addresses that we are being requested to use. */
id|hw-&gt;num_mc_addrs
op_assign
id|mc_addr_count
suffix:semicolon
multiline_comment|/* Clear RAR[1-15] */
id|DEBUGOUT
c_func
(paren
l_string|&quot; Clearing RAR[1-15]&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rar_used_count
suffix:semicolon
id|i
OL
id|E1000_RAR_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
id|i
op_lshift
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
(paren
id|i
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear the MTA */
id|DEBUGOUT
c_func
(paren
l_string|&quot; Clearing MTA&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|E1000_NUM_MTA_REGISTERS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Add the new addresses */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mc_addr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot; Adding the multicast addresses:&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUGOUT7
c_func
(paren
l_string|&quot; MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X&bslash;n&quot;
comma
id|i
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|1
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|2
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|3
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|4
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|5
)braket
)paren
suffix:semicolon
id|hash_value
op_assign
id|e1000_hash_mc_addr
c_func
(paren
id|hw
comma
id|mc_addr_list
op_plus
(paren
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
)paren
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot; Hash value = 0x%03X&bslash;n&quot;
comma
id|hash_value
)paren
suffix:semicolon
multiline_comment|/* Place this multicast address in the RAR if there is room, *&n;         * else put it in the MTA            &n;         */
r_if
c_cond
(paren
id|rar_used_count
OL
id|E1000_RAR_ENTRIES
)paren
(brace
id|e1000_rar_set
c_func
(paren
id|hw
comma
id|mc_addr_list
op_plus
(paren
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
)paren
comma
id|rar_used_count
)paren
suffix:semicolon
id|rar_used_count
op_increment
suffix:semicolon
)brace
r_else
(brace
id|e1000_mta_set
c_func
(paren
id|hw
comma
id|hash_value
)paren
suffix:semicolon
)brace
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MC Update Complete&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Hashes an address to determine its location in the multicast table&n; *&n; * hw - Struct containing variables accessed by shared code&n; * mc_addr - the multicast address to hash &n; *****************************************************************************/
r_uint32
DECL|function|e1000_hash_mc_addr
id|e1000_hash_mc_addr
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint8
op_star
id|mc_addr
)paren
(brace
r_uint32
id|hash_value
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The portion of the address that is used for the hash table is&n;     * determined by the mc_filter_type setting.  &n;     */
r_switch
c_cond
(paren
id|hw-&gt;mc_filter_type
)paren
(brace
multiline_comment|/* [0] [1] [2] [3] [4] [5]&n;     * 01  AA  00  12  34  56&n;     * LSB                 MSB&n;     */
r_case
l_int|0
suffix:colon
multiline_comment|/* [47:36] i.e. 0x563 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
op_rshift
l_int|4
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* [46:35] i.e. 0xAC6 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
op_rshift
l_int|3
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|5
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* [45:34] i.e. 0x5D8 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
op_rshift
l_int|2
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|6
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* [43:32] i.e. 0x634 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hash_value
op_and_assign
l_int|0xFFF
suffix:semicolon
r_return
id|hash_value
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Sets the bit in the multicast table corresponding to the hash value.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * hash_value - Multicast address hash value&n; *****************************************************************************/
r_void
DECL|function|e1000_mta_set
id|e1000_mta_set
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|hash_value
)paren
(brace
r_uint32
id|hash_bit
comma
id|hash_reg
suffix:semicolon
r_uint32
id|mta
suffix:semicolon
r_uint32
id|temp
suffix:semicolon
multiline_comment|/* The MTA is a register array of 128 32-bit registers.  &n;     * It is treated like an array of 4096 bits.  We want to set &n;     * bit BitArray[hash_value]. So we figure out what register&n;     * the bit is in, read it, OR in the new bit, then write&n;     * back the new value.  The register is determined by the &n;     * upper 7 bits of the hash value and the bit within that &n;     * register are determined by the lower 5 bits of the value.&n;     */
id|hash_reg
op_assign
(paren
id|hash_value
op_rshift
l_int|5
)paren
op_amp
l_int|0x7F
suffix:semicolon
id|hash_bit
op_assign
id|hash_value
op_amp
l_int|0x1F
suffix:semicolon
id|mta
op_assign
id|E1000_READ_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|hash_reg
)paren
suffix:semicolon
id|mta
op_or_assign
(paren
l_int|1
op_lshift
id|hash_bit
)paren
suffix:semicolon
multiline_comment|/* If we are on an 82544 and we are trying to write an odd offset&n;     * in the MTA, save off the previous entry before writing and&n;     * restore the old value after writing.&n;     */
r_if
c_cond
(paren
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82544
)paren
op_logical_and
(paren
(paren
id|hash_reg
op_amp
l_int|0x1
)paren
op_eq
l_int|1
)paren
)paren
(brace
id|temp
op_assign
id|E1000_READ_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
(paren
id|hash_reg
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|hash_reg
comma
id|mta
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
(paren
id|hash_reg
op_minus
l_int|1
)paren
comma
id|temp
)paren
suffix:semicolon
)brace
r_else
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|hash_reg
comma
id|mta
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Puts an ethernet address into a receive address register.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * addr - Address to put into receive address register&n; * index - Receive address register to write&n; *****************************************************************************/
r_void
DECL|function|e1000_rar_set
id|e1000_rar_set
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint8
op_star
id|addr
comma
r_uint32
id|index
)paren
(brace
r_uint32
id|rar_low
comma
id|rar_high
suffix:semicolon
multiline_comment|/* HW expects these in little endian so we reverse the byte order&n;     * from network order (big endian) to little endian              &n;     */
id|rar_low
op_assign
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|0
)braket
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
)paren
suffix:semicolon
id|rar_high
op_assign
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|4
)braket
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_or
id|E1000_RAH_AV
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
id|index
op_lshift
l_int|1
)paren
comma
id|rar_low
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
(paren
id|index
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
comma
id|rar_high
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Writes a value to the specified offset in the VLAN filter table.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * offset - Offset in VLAN filer table to write&n; * value - Value to write into VLAN filter table&n; *****************************************************************************/
r_void
DECL|function|e1000_write_vfta
id|e1000_write_vfta
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|offset
comma
r_uint32
id|value
)paren
(brace
r_uint32
id|temp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82544
)paren
op_logical_and
(paren
(paren
id|offset
op_amp
l_int|0x1
)paren
op_eq
l_int|1
)paren
)paren
(brace
id|temp
op_assign
id|E1000_READ_REG_ARRAY
c_func
(paren
id|hw
comma
id|VFTA
comma
(paren
id|offset
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|VFTA
comma
id|offset
comma
id|value
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|VFTA
comma
(paren
id|offset
op_minus
l_int|1
)paren
comma
id|temp
)paren
suffix:semicolon
)brace
r_else
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|VFTA
comma
id|offset
comma
id|value
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Clears the VLAN filer table&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|e1000_clear_vfta
id|e1000_clear_vfta
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|offset
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|E1000_VLAN_FILTER_TBL_SIZE
suffix:semicolon
id|offset
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|VFTA
comma
id|offset
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Prepares SW controlable LED for use and saves the current state of the LED.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_setup_led
id|e1000_setup_led
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ledctl
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_setup_led&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;device_id
)paren
(brace
r_case
id|E1000_DEV_ID_82542
suffix:colon
r_case
id|E1000_DEV_ID_82543GC_FIBER
suffix:colon
r_case
id|E1000_DEV_ID_82543GC_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544EI_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544EI_FIBER
suffix:colon
r_case
id|E1000_DEV_ID_82544GC_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544GC_LOM
suffix:colon
multiline_comment|/* No setup necessary */
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82540EM
suffix:colon
r_case
id|E1000_DEV_ID_82540EM_LOM
suffix:colon
id|ledctl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|LEDCTL
)paren
suffix:semicolon
multiline_comment|/* Save current LEDCTL settings */
id|hw-&gt;ledctl
op_assign
id|ledctl
suffix:semicolon
multiline_comment|/* Turn off LED2 and LED3 */
id|ledctl
op_and_assign
op_complement
(paren
id|E1000_LEDCTL_LED2_IVRT
op_or
id|E1000_LEDCTL_LED2_BLINK
op_or
id|E1000_LEDCTL_LED2_MODE_MASK
)paren
suffix:semicolon
id|ledctl
op_or_assign
(paren
id|E1000_LEDCTL_MODE_LED_OFF
op_lshift
id|E1000_LEDCTL_LED2_MODE_SHIFT
)paren
suffix:semicolon
id|ledctl
op_and_assign
op_complement
(paren
id|E1000_LEDCTL_LED3_IVRT
op_or
id|E1000_LEDCTL_LED3_BLINK
op_or
id|E1000_LEDCTL_LED3_MODE_MASK
)paren
suffix:semicolon
id|ledctl
op_or_assign
(paren
id|E1000_LEDCTL_MODE_LED_OFF
op_lshift
id|E1000_LEDCTL_LED3_MODE_SHIFT
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|LEDCTL
comma
id|ledctl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Invalid device ID&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Restores the saved state of the SW controlable LED.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_cleanup_led
id|e1000_cleanup_led
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_cleanup_led&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;device_id
)paren
(brace
r_case
id|E1000_DEV_ID_82542
suffix:colon
r_case
id|E1000_DEV_ID_82543GC_FIBER
suffix:colon
r_case
id|E1000_DEV_ID_82543GC_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544EI_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544EI_FIBER
suffix:colon
r_case
id|E1000_DEV_ID_82544GC_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544GC_LOM
suffix:colon
multiline_comment|/* No cleanup necessary */
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82540EM
suffix:colon
r_case
id|E1000_DEV_ID_82540EM_LOM
suffix:colon
multiline_comment|/* Restore LEDCTL settings */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|LEDCTL
comma
id|hw-&gt;ledctl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Invalid device ID&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Turns on the software controllable LED&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_led_on
id|e1000_led_on
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|ledctl
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_led_on&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;device_id
)paren
(brace
r_case
id|E1000_DEV_ID_82542
suffix:colon
r_case
id|E1000_DEV_ID_82543GC_FIBER
suffix:colon
r_case
id|E1000_DEV_ID_82543GC_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544EI_FIBER
suffix:colon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Set SW Defineable Pin 0 to turn on the LED */
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIN0
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIO0
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82544EI_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544GC_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544GC_LOM
suffix:colon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Clear SW Defineable Pin 0 to turn on the LED */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_SWDPIN0
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIO0
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82540EM
suffix:colon
r_case
id|E1000_DEV_ID_82540EM_LOM
suffix:colon
id|ledctl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|LEDCTL
)paren
suffix:semicolon
multiline_comment|/* Set LED 3 mode to on */
id|ledctl
op_and_assign
op_complement
id|E1000_LEDCTL_LED3_MODE_MASK
suffix:semicolon
id|ledctl
op_or_assign
(paren
id|E1000_LEDCTL_MODE_LED_ON
op_lshift
id|E1000_LEDCTL_LED3_MODE_SHIFT
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|LEDCTL
comma
id|ledctl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Invalid device ID&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Turns off the software controllable LED&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_led_off
id|e1000_led_off
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|ledctl
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_led_off&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;device_id
)paren
(brace
r_case
id|E1000_DEV_ID_82542
suffix:colon
r_case
id|E1000_DEV_ID_82543GC_FIBER
suffix:colon
r_case
id|E1000_DEV_ID_82543GC_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544EI_FIBER
suffix:colon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Clear SW Defineable Pin 0 to turn off the LED */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_SWDPIN0
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIO0
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82544EI_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544GC_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544GC_LOM
suffix:colon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Set SW Defineable Pin 0 to turn off the LED */
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIN0
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIO0
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82540EM
suffix:colon
r_case
id|E1000_DEV_ID_82540EM_LOM
suffix:colon
id|ledctl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|LEDCTL
)paren
suffix:semicolon
multiline_comment|/* Set LED 3 mode to off */
id|ledctl
op_and_assign
op_complement
id|E1000_LEDCTL_LED3_MODE_MASK
suffix:semicolon
id|ledctl
op_or_assign
(paren
id|E1000_LEDCTL_MODE_LED_OFF
op_lshift
id|E1000_LEDCTL_LED3_MODE_SHIFT
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|LEDCTL
comma
id|ledctl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Invalid device ID&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Clears all hardware statistics counters. &n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|e1000_clear_hw_cntrs
id|e1000_clear_hw_cntrs
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_volatile
r_uint32
id|temp
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CRCERRS
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|SYMERRS
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MPC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|SCC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|ECOL
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MCC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|LATECOL
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|COLC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|DC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|SEC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RLEC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|XONRXC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|XONTXC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|XOFFRXC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|XOFFTXC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|FCRUC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PRC64
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PRC127
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PRC255
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PRC511
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PRC1023
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PRC1522
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|GPRC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|BPRC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MPRC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|GPTC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|GORCL
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|GORCH
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|GOTCL
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|GOTCH
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RNBC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RUC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RFC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|ROC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RJC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TORL
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TORH
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TOTL
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TOTH
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TPR
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TPT
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PTC64
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PTC127
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PTC255
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PTC511
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PTC1023
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PTC1522
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MPTC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|BPTC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
OL
id|e1000_82543
)paren
(brace
r_return
suffix:semicolon
)brace
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|ALGNERRC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RXERRC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TNCRS
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CEXTERR
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TSCTC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TSCTFC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_le
id|e1000_82544
)paren
(brace
r_return
suffix:semicolon
)brace
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MGTPRC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MGTPDC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MGTPTC
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Resets Adaptive IFS to its default state.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Call this after e1000_init_hw. You may override the IFS defaults by setting&n; * hw-&gt;ifs_params_forced to TRUE. However, you must initialize hw-&gt;&n; * current_ifs_val, ifs_min_val, ifs_max_val, ifs_step_size, and ifs_ratio&n; * before calling this function.&n; *****************************************************************************/
r_void
DECL|function|e1000_reset_adaptive
id|e1000_reset_adaptive
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_reset_adaptive&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;adaptive_ifs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;ifs_params_forced
)paren
(brace
id|hw-&gt;current_ifs_val
op_assign
l_int|0
suffix:semicolon
id|hw-&gt;ifs_min_val
op_assign
id|IFS_MIN
suffix:semicolon
id|hw-&gt;ifs_max_val
op_assign
id|IFS_MAX
suffix:semicolon
id|hw-&gt;ifs_step_size
op_assign
id|IFS_STEP
suffix:semicolon
id|hw-&gt;ifs_ratio
op_assign
id|IFS_RATIO
suffix:semicolon
)brace
id|hw-&gt;in_ifs_mode
op_assign
id|FALSE
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|AIT
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Not in Adaptive IFS mode!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Called during the callback/watchdog routine to update IFS value based on&n; * the ratio of transmits to collisions.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * tx_packets - Number of transmits since last callback&n; * total_collisions - Number of collisions since last callback&n; *****************************************************************************/
r_void
DECL|function|e1000_update_adaptive
id|e1000_update_adaptive
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_update_adaptive&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;adaptive_ifs
)paren
(brace
r_if
c_cond
(paren
(paren
id|hw-&gt;collision_delta
op_star
id|hw-&gt;ifs_ratio
)paren
OG
id|hw-&gt;tx_packet_delta
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;tx_packet_delta
OG
id|MIN_NUM_XMITS
)paren
(brace
id|hw-&gt;in_ifs_mode
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;current_ifs_val
OL
id|hw-&gt;ifs_max_val
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;current_ifs_val
op_eq
l_int|0
)paren
(brace
id|hw-&gt;current_ifs_val
op_assign
id|hw-&gt;ifs_min_val
suffix:semicolon
)brace
r_else
id|hw-&gt;current_ifs_val
op_add_assign
id|hw-&gt;ifs_step_size
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|AIT
comma
id|hw-&gt;current_ifs_val
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|hw-&gt;in_ifs_mode
op_eq
id|TRUE
)paren
op_logical_and
(paren
id|hw-&gt;tx_packet_delta
op_le
id|MIN_NUM_XMITS
)paren
)paren
(brace
id|hw-&gt;current_ifs_val
op_assign
l_int|0
suffix:semicolon
id|hw-&gt;in_ifs_mode
op_assign
id|FALSE
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|AIT
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Not in Adaptive IFS mode!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Adjusts the statistic counters when a frame is accepted by TBI_ACCEPT&n; * &n; * hw - Struct containing variables accessed by shared code&n; * frame_len - The length of the frame in question&n; * mac_addr - The Ethernet destination address of the frame in question&n; *****************************************************************************/
r_void
DECL|function|e1000_tbi_adjust_stats
id|e1000_tbi_adjust_stats
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_struct
id|e1000_hw_stats
op_star
id|stats
comma
r_uint32
id|frame_len
comma
r_uint8
op_star
id|mac_addr
)paren
(brace
r_uint64
id|carry_bit
suffix:semicolon
multiline_comment|/* First adjust the frame length. */
id|frame_len
op_decrement
suffix:semicolon
multiline_comment|/* We need to adjust the statistics counters, since the hardware&n;     * counters overcount this packet as a CRC error and undercount&n;     * the packet as a good packet&n;     */
multiline_comment|/* This packet should not be counted as a CRC error.    */
id|stats-&gt;crcerrs
op_decrement
suffix:semicolon
multiline_comment|/* This packet does count as a Good Packet Received.    */
id|stats-&gt;gprc
op_increment
suffix:semicolon
multiline_comment|/* Adjust the Good Octets received counters             */
id|carry_bit
op_assign
l_int|0x80000000
op_amp
id|stats-&gt;gorcl
suffix:semicolon
id|stats-&gt;gorcl
op_add_assign
id|frame_len
suffix:semicolon
multiline_comment|/* If the high bit of Gorcl (the low 32 bits of the Good Octets&n;     * Received Count) was one before the addition, &n;     * AND it is zero after, then we lost the carry out, &n;     * need to add one to Gorch (Good Octets Received Count High).&n;     * This could be simplified if all environments supported &n;     * 64-bit integers.&n;     */
r_if
c_cond
(paren
id|carry_bit
op_logical_and
(paren
(paren
id|stats-&gt;gorcl
op_amp
l_int|0x80000000
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|stats-&gt;gorch
op_increment
suffix:semicolon
)brace
multiline_comment|/* Is this a broadcast or multicast?  Check broadcast first,&n;     * since the test for a multicast frame will test positive on &n;     * a broadcast frame.&n;     */
r_if
c_cond
(paren
(paren
id|mac_addr
(braket
l_int|0
)braket
op_eq
(paren
r_uint8
)paren
l_int|0xff
)paren
op_logical_and
(paren
id|mac_addr
(braket
l_int|1
)braket
op_eq
(paren
r_uint8
)paren
l_int|0xff
)paren
)paren
(brace
multiline_comment|/* Broadcast packet */
id|stats-&gt;bprc
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|mac_addr
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* Multicast packet */
id|stats-&gt;mprc
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frame_len
op_eq
id|hw-&gt;max_frame_size
)paren
(brace
multiline_comment|/* In this case, the hardware has overcounted the number of&n;         * oversize frames.&n;         */
r_if
c_cond
(paren
id|stats-&gt;roc
OG
l_int|0
)paren
(brace
id|stats-&gt;roc
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* Adjust the bin counters when the extra byte put the frame in the&n;     * wrong bin. Remember that the frame_len was adjusted above.&n;     */
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|64
)paren
(brace
id|stats-&gt;prc64
op_increment
suffix:semicolon
id|stats-&gt;prc127
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|127
)paren
(brace
id|stats-&gt;prc127
op_increment
suffix:semicolon
id|stats-&gt;prc255
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|255
)paren
(brace
id|stats-&gt;prc255
op_increment
suffix:semicolon
id|stats-&gt;prc511
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|511
)paren
(brace
id|stats-&gt;prc511
op_increment
suffix:semicolon
id|stats-&gt;prc1023
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|1023
)paren
(brace
id|stats-&gt;prc1023
op_increment
suffix:semicolon
id|stats-&gt;prc1522
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|1522
)paren
(brace
id|stats-&gt;prc1522
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Gets the current PCI bus type, speed, and width of the hardware&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|e1000_get_bus_info
id|e1000_get_bus_info
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|status
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
OL
id|e1000_82543
)paren
(brace
id|hw-&gt;bus_type
op_assign
id|e1000_bus_type_unknown
suffix:semicolon
id|hw-&gt;bus_speed
op_assign
id|e1000_bus_speed_unknown
suffix:semicolon
id|hw-&gt;bus_width
op_assign
id|e1000_bus_width_unknown
suffix:semicolon
r_return
suffix:semicolon
)brace
id|status
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
suffix:semicolon
id|hw-&gt;bus_type
op_assign
(paren
id|status
op_amp
id|E1000_STATUS_PCIX_MODE
)paren
ques
c_cond
id|e1000_bus_type_pcix
suffix:colon
id|e1000_bus_type_pci
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;bus_type
op_eq
id|e1000_bus_type_pci
)paren
(brace
id|hw-&gt;bus_speed
op_assign
(paren
id|status
op_amp
id|E1000_STATUS_PCI66
)paren
ques
c_cond
id|e1000_bus_speed_66
suffix:colon
id|e1000_bus_speed_33
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|status
op_amp
id|E1000_STATUS_PCIX_SPEED
)paren
(brace
r_case
id|E1000_STATUS_PCIX_SPEED_66
suffix:colon
id|hw-&gt;bus_speed
op_assign
id|e1000_bus_speed_66
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_STATUS_PCIX_SPEED_100
suffix:colon
id|hw-&gt;bus_speed
op_assign
id|e1000_bus_speed_100
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_STATUS_PCIX_SPEED_133
suffix:colon
id|hw-&gt;bus_speed
op_assign
id|e1000_bus_speed_133
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|hw-&gt;bus_speed
op_assign
id|e1000_bus_speed_reserved
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|hw-&gt;bus_width
op_assign
(paren
id|status
op_amp
id|E1000_STATUS_BUS64
)paren
ques
c_cond
id|e1000_bus_width_64
suffix:colon
id|e1000_bus_width_32
suffix:semicolon
)brace
eof
