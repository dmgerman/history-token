multiline_comment|/*******************************************************************************&n;&n;  &n;  Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.&n;  &n;  This program is free software; you can redistribute it and/or modify it &n;  under the terms of the GNU General Public License as published by the Free &n;  Software Foundation; either version 2 of the License, or (at your option) &n;  any later version.&n;  &n;  This program is distributed in the hope that it will be useful, but WITHOUT &n;  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or &n;  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for &n;  more details.&n;  &n;  You should have received a copy of the GNU General Public License along with&n;  this program; if not, write to the Free Software Foundation, Inc., 59 &n;  Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n;  &n;  The full GNU General Public License is included in this distribution in the&n;  file called LICENSE.&n;  &n;  Contact Information:&n;  Linux NICS &lt;linux.nics@intel.com&gt;&n;  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497&n;&n;*******************************************************************************/
multiline_comment|/* e1000_hw.c&n; * Shared functions for accessing and configuring the MAC&n; */
macro_line|#include &quot;e1000_hw.h&quot;
r_static
r_int32
id|e1000_set_phy_type
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_void
id|e1000_phy_init_script
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_setup_copper_link
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_setup_fiber_serdes_link
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_adjust_serdes_amplitude
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_phy_force_speed_duplex
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_config_mac_to_phy
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_void
id|e1000_raise_mdi_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|ctrl
)paren
suffix:semicolon
r_static
r_void
id|e1000_lower_mdi_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|ctrl
)paren
suffix:semicolon
r_static
r_void
id|e1000_shift_out_mdi_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|data
comma
r_uint16
id|count
)paren
suffix:semicolon
r_static
r_uint16
id|e1000_shift_in_mdi_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_phy_reset_dsp
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_write_eeprom_spi
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|offset
comma
r_uint16
id|words
comma
r_uint16
op_star
id|data
)paren
suffix:semicolon
r_static
r_int32
id|e1000_write_eeprom_microwire
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|offset
comma
r_uint16
id|words
comma
r_uint16
op_star
id|data
)paren
suffix:semicolon
r_static
r_int32
id|e1000_spi_eeprom_ready
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_void
id|e1000_raise_ee_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|eecd
)paren
suffix:semicolon
r_static
r_void
id|e1000_lower_ee_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|eecd
)paren
suffix:semicolon
r_static
r_void
id|e1000_shift_out_ee_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|data
comma
r_uint16
id|count
)paren
suffix:semicolon
r_static
r_int32
id|e1000_write_phy_reg_ex
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|reg_addr
comma
r_uint16
id|phy_data
)paren
suffix:semicolon
r_static
r_int32
id|e1000_read_phy_reg_ex
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|reg_addr
comma
r_uint16
op_star
id|phy_data
)paren
suffix:semicolon
r_static
r_uint16
id|e1000_shift_in_ee_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|count
)paren
suffix:semicolon
r_static
r_int32
id|e1000_acquire_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_void
id|e1000_release_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_void
id|e1000_standby_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_id_led_init
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int32
id|e1000_set_vco_speed
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
suffix:semicolon
multiline_comment|/* IGP cable length table */
r_static
r_const
DECL|variable|e1000_igp_cable_length_table
r_uint16
id|e1000_igp_cable_length_table
(braket
id|IGP01E1000_AGC_LENGTH_TABLE_SIZE
)braket
op_assign
(brace
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|10
comma
l_int|10
comma
l_int|10
comma
l_int|10
comma
l_int|10
comma
l_int|10
comma
l_int|10
comma
l_int|20
comma
l_int|20
comma
l_int|20
comma
l_int|20
comma
l_int|20
comma
l_int|25
comma
l_int|25
comma
l_int|25
comma
l_int|25
comma
l_int|25
comma
l_int|25
comma
l_int|25
comma
l_int|30
comma
l_int|30
comma
l_int|30
comma
l_int|30
comma
l_int|40
comma
l_int|40
comma
l_int|40
comma
l_int|40
comma
l_int|40
comma
l_int|40
comma
l_int|40
comma
l_int|40
comma
l_int|40
comma
l_int|50
comma
l_int|50
comma
l_int|50
comma
l_int|50
comma
l_int|50
comma
l_int|50
comma
l_int|50
comma
l_int|60
comma
l_int|60
comma
l_int|60
comma
l_int|60
comma
l_int|60
comma
l_int|60
comma
l_int|60
comma
l_int|60
comma
l_int|60
comma
l_int|70
comma
l_int|70
comma
l_int|70
comma
l_int|70
comma
l_int|70
comma
l_int|70
comma
l_int|80
comma
l_int|80
comma
l_int|80
comma
l_int|80
comma
l_int|80
comma
l_int|80
comma
l_int|90
comma
l_int|90
comma
l_int|90
comma
l_int|90
comma
l_int|90
comma
l_int|90
comma
l_int|90
comma
l_int|90
comma
l_int|90
comma
l_int|100
comma
l_int|100
comma
l_int|100
comma
l_int|100
comma
l_int|100
comma
l_int|100
comma
l_int|100
comma
l_int|100
comma
l_int|100
comma
l_int|100
comma
l_int|100
comma
l_int|100
comma
l_int|100
comma
l_int|100
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|110
comma
l_int|120
comma
l_int|120
comma
l_int|120
comma
l_int|120
comma
l_int|120
comma
l_int|120
comma
l_int|120
comma
l_int|120
comma
l_int|120
comma
l_int|120
)brace
suffix:semicolon
multiline_comment|/******************************************************************************&n; * Set the phy type member in the hw struct.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_set_phy_type
id|e1000_set_phy_type
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_set_phy_type&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;phy_id
)paren
(brace
r_case
id|M88E1000_E_PHY_ID
suffix:colon
r_case
id|M88E1000_I_PHY_ID
suffix:colon
r_case
id|M88E1011_I_PHY_ID
suffix:colon
id|hw-&gt;phy_type
op_assign
id|e1000_phy_m88
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IGP01E1000_I_PHY_ID
suffix:colon
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82541
op_logical_or
id|hw-&gt;mac_type
op_eq
id|e1000_82541_rev_2
op_logical_or
id|hw-&gt;mac_type
op_eq
id|e1000_82547
op_logical_or
id|hw-&gt;mac_type
op_eq
id|e1000_82547_rev_2
)paren
(brace
id|hw-&gt;phy_type
op_assign
id|e1000_phy_igp
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Fall Through */
r_default
suffix:colon
multiline_comment|/* Should never have loaded on this device */
id|hw-&gt;phy_type
op_assign
id|e1000_phy_undefined
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY_TYPE
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * IGP phy init script - initializes the GbE PHY&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_phy_init_script
id|e1000_phy_init_script
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_init_script&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;phy_init_script
)paren
(brace
id|msec_delay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x0000
comma
l_int|0x0140
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82541
op_logical_or
id|hw-&gt;mac_type
op_eq
id|e1000_82547
)paren
(brace
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x1F95
comma
l_int|0x0001
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x1F71
comma
l_int|0xBD21
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x1F79
comma
l_int|0x0018
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x1F30
comma
l_int|0x1600
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x1F31
comma
l_int|0x0014
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x1F32
comma
l_int|0x161C
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x1F94
comma
l_int|0x0003
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x1F96
comma
l_int|0x003F
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x2010
comma
l_int|0x0008
)paren
suffix:semicolon
)brace
r_else
(brace
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x1F73
comma
l_int|0x0099
)paren
suffix:semicolon
)brace
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x0000
comma
l_int|0x3300
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82547
)paren
(brace
r_uint16
id|fused
comma
id|fine
comma
id|coarse
suffix:semicolon
multiline_comment|/* Move to analog registers page */
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_ANALOG_SPARE_FUSE_STATUS
comma
op_amp
id|fused
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fused
op_amp
id|IGP01E1000_ANALOG_SPARE_FUSE_ENABLED
)paren
)paren
(brace
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_ANALOG_FUSE_STATUS
comma
op_amp
id|fused
)paren
suffix:semicolon
id|fine
op_assign
id|fused
op_amp
id|IGP01E1000_ANALOG_FUSE_FINE_MASK
suffix:semicolon
id|coarse
op_assign
id|fused
op_amp
id|IGP01E1000_ANALOG_FUSE_COARSE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|coarse
OG
id|IGP01E1000_ANALOG_FUSE_COARSE_THRESH
)paren
(brace
id|coarse
op_sub_assign
id|IGP01E1000_ANALOG_FUSE_COARSE_10
suffix:semicolon
id|fine
op_sub_assign
id|IGP01E1000_ANALOG_FUSE_FINE_1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|coarse
op_eq
id|IGP01E1000_ANALOG_FUSE_COARSE_THRESH
)paren
(brace
id|fine
op_sub_assign
id|IGP01E1000_ANALOG_FUSE_FINE_10
suffix:semicolon
)brace
id|fused
op_assign
(paren
id|fused
op_amp
id|IGP01E1000_ANALOG_FUSE_POLY_MASK
)paren
op_or
(paren
id|fine
op_amp
id|IGP01E1000_ANALOG_FUSE_FINE_MASK
)paren
op_or
(paren
id|coarse
op_amp
id|IGP01E1000_ANALOG_FUSE_COARSE_MASK
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_ANALOG_FUSE_CONTROL
comma
id|fused
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_ANALOG_FUSE_BYPASS
comma
id|IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/******************************************************************************&n; * Set the mac type member in the hw struct.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_set_mac_type
id|e1000_set_mac_type
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_set_mac_type&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;device_id
)paren
(brace
r_case
id|E1000_DEV_ID_82542
suffix:colon
r_switch
c_cond
(paren
id|hw-&gt;revision_id
)paren
(brace
r_case
id|E1000_82542_2_0_REV_ID
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82542_rev2_0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_82542_2_1_REV_ID
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82542_rev2_1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Invalid 82542 revision ID */
r_return
op_minus
id|E1000_ERR_MAC_TYPE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82543GC_FIBER
suffix:colon
r_case
id|E1000_DEV_ID_82543GC_COPPER
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82543
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82544EI_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544EI_FIBER
suffix:colon
r_case
id|E1000_DEV_ID_82544GC_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82544GC_LOM
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82544
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82540EM
suffix:colon
r_case
id|E1000_DEV_ID_82540EM_LOM
suffix:colon
r_case
id|E1000_DEV_ID_82540EP
suffix:colon
r_case
id|E1000_DEV_ID_82540EP_LOM
suffix:colon
r_case
id|E1000_DEV_ID_82540EP_LP
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82540
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82545EM_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82545EM_FIBER
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82545
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82545GM_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82545GM_FIBER
suffix:colon
r_case
id|E1000_DEV_ID_82545GM_SERDES
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82545_rev_3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82546EB_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82546EB_FIBER
suffix:colon
r_case
id|E1000_DEV_ID_82546EB_QUAD_COPPER
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82546
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82546GB_COPPER
suffix:colon
r_case
id|E1000_DEV_ID_82546GB_FIBER
suffix:colon
r_case
id|E1000_DEV_ID_82546GB_SERDES
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82546_rev_3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82541EI
suffix:colon
r_case
id|E1000_DEV_ID_82541EI_MOBILE
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82541
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82541ER
suffix:colon
r_case
id|E1000_DEV_ID_82541GI
suffix:colon
r_case
id|E1000_DEV_ID_82541GI_MOBILE
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82541_rev_2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82547EI
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82547
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_DEV_ID_82547GI
suffix:colon
id|hw-&gt;mac_type
op_assign
id|e1000_82547_rev_2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Should never have loaded on this device */
r_return
op_minus
id|E1000_ERR_MAC_TYPE
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; * Set media type and TBI compatibility.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * **************************************************************************/
r_void
DECL|function|e1000_set_media_type
id|e1000_set_media_type
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|status
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_set_media_type&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_ne
id|e1000_82543
)paren
(brace
multiline_comment|/* tbi_compatibility is only valid on 82543 */
id|hw-&gt;tbi_compatibility_en
op_assign
id|FALSE
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|hw-&gt;device_id
)paren
(brace
r_case
id|E1000_DEV_ID_82545GM_SERDES
suffix:colon
r_case
id|E1000_DEV_ID_82546GB_SERDES
suffix:colon
id|hw-&gt;media_type
op_assign
id|e1000_media_type_internal_serdes
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_ge
id|e1000_82543
)paren
(brace
id|status
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|E1000_STATUS_TBIMODE
)paren
(brace
id|hw-&gt;media_type
op_assign
id|e1000_media_type_fiber
suffix:semicolon
multiline_comment|/* tbi_compatibility not valid on fiber */
id|hw-&gt;tbi_compatibility_en
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|hw-&gt;media_type
op_assign
id|e1000_media_type_copper
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* This is an 82542 (fiber only) */
id|hw-&gt;media_type
op_assign
id|e1000_media_type_fiber
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/******************************************************************************&n; * Reset the transmit and receive units; mask and clear all interrupts.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_reset_hw
id|e1000_reset_hw
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|ctrl_ext
suffix:semicolon
r_uint32
id|icr
suffix:semicolon
r_uint32
id|manc
suffix:semicolon
r_uint32
id|led_ctrl
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_reset_hw&quot;
)paren
suffix:semicolon
multiline_comment|/* For 82542 (rev 2.0), disable MWI before issuing a device reset */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Disabling MWI on 82542 rev 2.0&bslash;n&quot;
)paren
suffix:semicolon
id|e1000_pci_clear_mwi
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear interrupt mask to stop board from generating interrupts */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Masking off all interrupts&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|IMC
comma
l_int|0xffffffff
)paren
suffix:semicolon
multiline_comment|/* Disable the Transmit and Receive units.  Then delay to allow&n;     * any pending transactions to complete before we hit the MAC with&n;     * the global reset.&n;     */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|RCTL
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|TCTL
comma
id|E1000_TCTL_PSP
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */
id|hw-&gt;tbi_compatibility_on
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Delay to allow any outstanding PCI transactions to complete before&n;     * resetting the device&n;     */
id|msec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Must reset the PHY before resetting the MAC */
r_if
c_cond
(paren
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82541
)paren
op_logical_or
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82547
)paren
)paren
(brace
id|E1000_WRITE_REG_IO
c_func
(paren
id|hw
comma
id|CTRL
comma
(paren
id|ctrl
op_or
id|E1000_CTRL_PHY_RST
)paren
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
multiline_comment|/* Issue a global reset to the MAC.  This will reset the chip&squot;s&n;     * transmit, receive, DMA, and link units.  It will not effect&n;     * the current PCI configuration.  The global reset bit is self-&n;     * clearing, and should clear within a microsecond.&n;     */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Issuing a global reset to MAC&bslash;n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;mac_type
)paren
(brace
r_case
id|e1000_82544
suffix:colon
r_case
id|e1000_82540
suffix:colon
r_case
id|e1000_82545
suffix:colon
r_case
id|e1000_82546
suffix:colon
r_case
id|e1000_82541
suffix:colon
r_case
id|e1000_82541_rev_2
suffix:colon
multiline_comment|/* These controllers can&squot;t ack the 64-bit write when issuing the&n;             * reset, so use IO-mapping as a workaround to issue the reset */
id|E1000_WRITE_REG_IO
c_func
(paren
id|hw
comma
id|CTRL
comma
(paren
id|ctrl
op_or
id|E1000_CTRL_RST
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_82545_rev_3
suffix:colon
r_case
id|e1000_82546_rev_3
suffix:colon
multiline_comment|/* Reset is performed on a shadow of the control register */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL_DUP
comma
(paren
id|ctrl
op_or
id|E1000_CTRL_RST
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
(paren
id|ctrl
op_or
id|E1000_CTRL_RST
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* After MAC reset, force reload of EEPROM to restore power-on settings to&n;     * device.  Later controllers reload the EEPROM automatically, so just wait&n;     * for reload to complete.&n;     */
r_switch
c_cond
(paren
id|hw-&gt;mac_type
)paren
(brace
r_case
id|e1000_82542_rev2_0
suffix:colon
r_case
id|e1000_82542_rev2_1
suffix:colon
r_case
id|e1000_82543
suffix:colon
r_case
id|e1000_82544
suffix:colon
multiline_comment|/* Wait for reset to complete */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ctrl_ext
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL_EXT
)paren
suffix:semicolon
id|ctrl_ext
op_or_assign
id|E1000_CTRL_EXT_EE_RST
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL_EXT
comma
id|ctrl_ext
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Wait for EEPROM reload */
id|msec_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_82541
suffix:colon
r_case
id|e1000_82541_rev_2
suffix:colon
r_case
id|e1000_82547
suffix:colon
r_case
id|e1000_82547_rev_2
suffix:colon
multiline_comment|/* Wait for EEPROM reload */
id|msec_delay
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Wait for EEPROM reload (it happens automatically) */
id|msec_delay
c_func
(paren
l_int|5
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Disable HW ARPs on ASF enabled adapters */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_ge
id|e1000_82540
)paren
(brace
id|manc
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MANC
)paren
suffix:semicolon
id|manc
op_and_assign
op_complement
(paren
id|E1000_MANC_ARP_EN
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|MANC
comma
id|manc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82541
)paren
op_logical_or
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82547
)paren
)paren
(brace
id|e1000_phy_init_script
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Configure activity LED after PHY reset */
id|led_ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|LEDCTL
)paren
suffix:semicolon
id|led_ctrl
op_and_assign
id|IGP_ACTIVITY_LED_MASK
suffix:semicolon
id|led_ctrl
op_or_assign
(paren
id|IGP_ACTIVITY_LED_ENABLE
op_or
id|IGP_LED3_MODE
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|LEDCTL
comma
id|led_ctrl
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear interrupt mask to stop board from generating interrupts */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Masking off all interrupts&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|IMC
comma
l_int|0xffffffff
)paren
suffix:semicolon
multiline_comment|/* Clear any pending interrupt events. */
id|icr
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|ICR
)paren
suffix:semicolon
multiline_comment|/* If MWI was previously enabled, reenable it. */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;pci_cmd_word
op_amp
id|CMD_MEM_WRT_INVALIDATE
)paren
(brace
id|e1000_pci_set_mwi
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Performs basic configuration of the adapter.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Assumes that the controller has previously been reset and is in a&n; * post-reset uninitialized state. Initializes the receive address registers,&n; * multicast table, and VLAN filter table. Calls routines to setup link&n; * configuration and flow control settings. Clears all on-chip counters. Leaves&n; * the transmit and receive units disabled and uninitialized.&n; *****************************************************************************/
r_int32
DECL|function|e1000_init_hw
id|e1000_init_hw
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|pcix_cmd_word
suffix:semicolon
r_uint16
id|pcix_stat_hi_word
suffix:semicolon
r_uint16
id|cmd_mmrbc
suffix:semicolon
r_uint16
id|stat_mmrbc
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_init_hw&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize Identification LED */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_id_led_init
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Initializing Identification LED&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Set the media type and TBI compatibility */
id|e1000_set_media_type
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Disabling VLAN filtering. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Initializing the IEEE VLAN&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|VET
comma
l_int|0
)paren
suffix:semicolon
id|e1000_clear_vfta
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Disabling MWI on 82542 rev 2.0&bslash;n&quot;
)paren
suffix:semicolon
id|e1000_pci_clear_mwi
c_func
(paren
id|hw
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|RCTL
comma
id|E1000_RCTL_RST
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
multiline_comment|/* Setup the receive address. This involves initializing all of the Receive&n;     * Address Registers (RARs 0 - 15).&n;     */
id|e1000_init_rx_addrs
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|RCTL
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;pci_cmd_word
op_amp
id|CMD_MEM_WRT_INVALIDATE
)paren
(brace
id|e1000_pci_set_mwi
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Zero out the Multicast HASH table */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Zeroing the MTA&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|E1000_MC_TBL_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the PCI priority bit correctly in the CTRL register.  This&n;     * determines if the adapter gives priority to receives, or if it&n;     * gives equal priority to transmits and receives.&n;     */
r_if
c_cond
(paren
id|hw-&gt;dma_fairness
)paren
(brace
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
op_or
id|E1000_CTRL_PRIOR
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|hw-&gt;mac_type
)paren
(brace
r_case
id|e1000_82545_rev_3
suffix:colon
r_case
id|e1000_82546_rev_3
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */
r_if
c_cond
(paren
id|hw-&gt;bus_type
op_eq
id|e1000_bus_type_pcix
)paren
(brace
id|e1000_read_pci_cfg
c_func
(paren
id|hw
comma
id|PCIX_COMMAND_REGISTER
comma
op_amp
id|pcix_cmd_word
)paren
suffix:semicolon
id|e1000_read_pci_cfg
c_func
(paren
id|hw
comma
id|PCIX_STATUS_REGISTER_HI
comma
op_amp
id|pcix_stat_hi_word
)paren
suffix:semicolon
id|cmd_mmrbc
op_assign
(paren
id|pcix_cmd_word
op_amp
id|PCIX_COMMAND_MMRBC_MASK
)paren
op_rshift
id|PCIX_COMMAND_MMRBC_SHIFT
suffix:semicolon
id|stat_mmrbc
op_assign
(paren
id|pcix_stat_hi_word
op_amp
id|PCIX_STATUS_HI_MMRBC_MASK
)paren
op_rshift
id|PCIX_STATUS_HI_MMRBC_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|stat_mmrbc
op_eq
id|PCIX_STATUS_HI_MMRBC_4K
)paren
(brace
id|stat_mmrbc
op_assign
id|PCIX_STATUS_HI_MMRBC_2K
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd_mmrbc
OG
id|stat_mmrbc
)paren
(brace
id|pcix_cmd_word
op_and_assign
op_complement
id|PCIX_COMMAND_MMRBC_MASK
suffix:semicolon
id|pcix_cmd_word
op_or_assign
id|stat_mmrbc
op_lshift
id|PCIX_COMMAND_MMRBC_SHIFT
suffix:semicolon
id|e1000_write_pci_cfg
c_func
(paren
id|hw
comma
id|PCIX_COMMAND_REGISTER
comma
op_amp
id|pcix_cmd_word
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Call a subroutine to configure the link and setup flow control. */
id|ret_val
op_assign
id|e1000_setup_link
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Set the transmit descriptor write-back policy */
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82544
)paren
(brace
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TXDCTL
)paren
suffix:semicolon
id|ctrl
op_assign
(paren
id|ctrl
op_amp
op_complement
id|E1000_TXDCTL_WTHRESH
)paren
op_or
id|E1000_TXDCTL_FULL_TX_DESC_WB
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|TXDCTL
comma
id|ctrl
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear all of the statistics registers (clear on read).  It is&n;     * important that we do this after we have tried to establish link&n;     * because the symbol error count will increment wildly if there&n;     * is no link.&n;     */
id|e1000_clear_hw_cntrs
c_func
(paren
id|hw
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Adjust SERDES output amplitude based on EEPROM setting.&n; *&n; * hw - Struct containing variables accessed by shared code.&n; *****************************************************************************/
r_static
r_int32
DECL|function|e1000_adjust_serdes_amplitude
id|e1000_adjust_serdes_amplitude
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint16
id|eeprom_data
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_adjust_serdes_amplitude&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;media_type
op_ne
id|e1000_media_type_internal_serdes
)paren
(brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|hw-&gt;mac_type
)paren
(brace
r_case
id|e1000_82545_rev_3
suffix:colon
r_case
id|e1000_82546_rev_3
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
id|EEPROM_SERDES_AMPLITUDE
comma
l_int|1
comma
op_amp
id|eeprom_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eeprom_data
op_ne
id|EEPROM_RESERVED_WORD
)paren
(brace
multiline_comment|/* Adjust SERDES output amplitude only. */
id|eeprom_data
op_and_assign
id|EEPROM_SERDES_AMPLITUDE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_EXT_CTRL
comma
id|eeprom_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Configures flow control and link settings.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Determines which flow control settings to use. Calls the apropriate media-&n; * specific link configuration function. Configures the flow control settings.&n; * Assuming the adapter has a valid link partner, a valid link should be&n; * established. Assumes the hardware has previously been reset and the&n; * transmitter and receiver are not enabled.&n; *****************************************************************************/
r_int32
DECL|function|e1000_setup_link
id|e1000_setup_link
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl_ext
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|eeprom_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_setup_link&quot;
)paren
suffix:semicolon
multiline_comment|/* Read and store word 0x0F of the EEPROM. This word contains bits&n;     * that determine the hardware&squot;s default PAUSE (flow control) mode,&n;     * a bit that determines whether the HW defaults to enabling or&n;     * disabling auto-negotiation, and the direction of the&n;     * SW defined pins. If there is no SW over-ride of the flow&n;     * control setting, then the variable hw-&gt;fc will&n;     * be initialized based on a value in the EEPROM.&n;     */
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
id|EEPROM_INIT_CONTROL2_REG
comma
l_int|1
comma
op_amp
id|eeprom_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;fc
op_eq
id|e1000_fc_default
)paren
(brace
r_if
c_cond
(paren
(paren
id|eeprom_data
op_amp
id|EEPROM_WORD0F_PAUSE_MASK
)paren
op_eq
l_int|0
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_none
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|eeprom_data
op_amp
id|EEPROM_WORD0F_PAUSE_MASK
)paren
op_eq
id|EEPROM_WORD0F_ASM_DIR
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_tx_pause
suffix:semicolon
)brace
r_else
id|hw-&gt;fc
op_assign
id|e1000_fc_full
suffix:semicolon
)brace
multiline_comment|/* We want to save off the original Flow Control configuration just&n;     * in case we get disconnected and then reconnected into a different&n;     * hub or switch with different Flow Control capabilities.&n;     */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
id|hw-&gt;fc
op_and_assign
(paren
op_complement
id|e1000_fc_tx_pause
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|hw-&gt;mac_type
OL
id|e1000_82543
)paren
op_logical_and
(paren
id|hw-&gt;report_tx_early
op_eq
l_int|1
)paren
)paren
(brace
id|hw-&gt;fc
op_and_assign
(paren
op_complement
id|e1000_fc_rx_pause
)paren
suffix:semicolon
)brace
id|hw-&gt;original_fc
op_assign
id|hw-&gt;fc
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;After fix-ups FlowControl is now = %x&bslash;n&quot;
comma
id|hw-&gt;fc
)paren
suffix:semicolon
multiline_comment|/* Take the 4 bits from EEPROM word 0x0F that determine the initial&n;     * polarity value for the SW controlled pins, and setup the&n;     * Extended Device Control reg with that info.&n;     * This is needed because one of the SW controlled pins is used for&n;     * signal detection.  So this should be done before e1000_setup_pcs_link()&n;     * or e1000_phy_setup() is called.&n;     */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82543
)paren
(brace
id|ctrl_ext
op_assign
(paren
(paren
id|eeprom_data
op_amp
id|EEPROM_WORD0F_SWPDIO_EXT
)paren
op_lshift
id|SWDPIO__EXT_SHIFT
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL_EXT
comma
id|ctrl_ext
)paren
suffix:semicolon
)brace
multiline_comment|/* Call the necessary subroutine to configure the link. */
id|ret_val
op_assign
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_copper
)paren
ques
c_cond
id|e1000_setup_copper_link
c_func
(paren
id|hw
)paren
suffix:colon
id|e1000_setup_fiber_serdes_link
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Initialize the flow control address, type, and PAUSE timer&n;     * registers to their default values.  This is done even if flow&n;     * control is disabled, because it does not hurt anything to&n;     * initialize these registers.&n;     */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Initializing the Flow Control address, type and timer regs&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCAL
comma
id|FLOW_CONTROL_ADDRESS_LOW
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCAH
comma
id|FLOW_CONTROL_ADDRESS_HIGH
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCT
comma
id|FLOW_CONTROL_TYPE
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCTTV
comma
id|hw-&gt;fc_pause_time
)paren
suffix:semicolon
multiline_comment|/* Set the flow control receive threshold registers.  Normally,&n;     * these registers will be set to a default threshold that may be&n;     * adjusted later by the driver&squot;s runtime code.  However, if the&n;     * ability to transmit pause frames in not enabled, then these&n;     * registers will be set to 0.&n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hw-&gt;fc
op_amp
id|e1000_fc_tx_pause
)paren
)paren
(brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTL
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTH
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We need to set up the Receive Threshold high and low water marks&n;         * as well as (optionally) enabling the transmission of XON frames.&n;         */
r_if
c_cond
(paren
id|hw-&gt;fc_send_xon
)paren
(brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTL
comma
(paren
id|hw-&gt;fc_low_water
op_or
id|E1000_FCRTL_XONE
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTH
comma
id|hw-&gt;fc_high_water
)paren
suffix:semicolon
)brace
r_else
(brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTL
comma
id|hw-&gt;fc_low_water
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|FCRTH
comma
id|hw-&gt;fc_high_water
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Sets up link for a fiber based or serdes based adapter&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Manipulates Physical Coding Sublayer functions in order to configure&n; * link. Assumes the hardware has been previously reset and the transmitter&n; * and receiver are not enabled.&n; *****************************************************************************/
r_static
r_int32
DECL|function|e1000_setup_fiber_serdes_link
id|e1000_setup_fiber_serdes_link
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|status
suffix:semicolon
r_uint32
id|txcw
op_assign
l_int|0
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_uint32
id|signal
op_assign
l_int|0
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_setup_fiber_serdes_link&quot;
)paren
suffix:semicolon
multiline_comment|/* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be&n;     * set when the optics detect a signal. On older adapters, it will be&n;     * cleared when there is a signal.  This applies to fiber media only.&n;     * If we&squot;re on serdes media, adjust the output amplitude to value set in&n;     * the EEPROM.&n;     */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
(brace
id|signal
op_assign
(paren
id|hw-&gt;mac_type
OG
id|e1000_82544
)paren
ques
c_cond
id|E1000_CTRL_SWDPIN1
suffix:colon
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_adjust_serdes_amplitude
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Take the link out of reset */
id|ctrl
op_and_assign
op_complement
(paren
id|E1000_CTRL_LRST
)paren
suffix:semicolon
multiline_comment|/* Adjust VCO speed to improve BER performance */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_set_vco_speed
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|e1000_config_collision_dist
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Check for a software override of the flow control settings, and setup&n;     * the device accordingly.  If auto-negotiation is enabled, then software&n;     * will have to set the &quot;PAUSE&quot; bits to the correct value in the Tranmsit&n;     * Config Word Register (TXCW) and re-start auto-negotiation.  However, if&n;     * auto-negotiation is disabled, then software will have to manually&n;     * configure the two flow control enable bits in the CTRL register.&n;     *&n;     * The possible values of the &quot;fc&quot; parameter are:&n;     *      0:  Flow control is completely disabled&n;     *      1:  Rx flow control is enabled (we can receive pause frames, but&n;     *          not send pause frames).&n;     *      2:  Tx flow control is enabled (we can send pause frames but we do&n;     *          not support receiving pause frames).&n;     *      3:  Both Rx and TX flow control (symmetric) are enabled.&n;     */
r_switch
c_cond
(paren
id|hw-&gt;fc
)paren
(brace
r_case
id|e1000_fc_none
suffix:colon
multiline_comment|/* Flow control is completely disabled by a software over-ride. */
id|txcw
op_assign
(paren
id|E1000_TXCW_ANE
op_or
id|E1000_TXCW_FD
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_rx_pause
suffix:colon
multiline_comment|/* RX Flow control is enabled and TX Flow control is disabled by a&n;         * software over-ride. Since there really isn&squot;t a way to advertise&n;         * that we are capable of RX Pause ONLY, we will advertise that we&n;         * support both symmetric and asymmetric RX PAUSE. Later, we will&n;         *  disable the adapter&squot;s ability to send PAUSE frames.&n;         */
id|txcw
op_assign
(paren
id|E1000_TXCW_ANE
op_or
id|E1000_TXCW_FD
op_or
id|E1000_TXCW_PAUSE_MASK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_tx_pause
suffix:colon
multiline_comment|/* TX Flow control is enabled, and RX Flow control is disabled, by a&n;         * software over-ride.&n;         */
id|txcw
op_assign
(paren
id|E1000_TXCW_ANE
op_or
id|E1000_TXCW_FD
op_or
id|E1000_TXCW_ASM_DIR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_full
suffix:colon
multiline_comment|/* Flow control (both RX and TX) is enabled by a software over-ride. */
id|txcw
op_assign
(paren
id|E1000_TXCW_ANE
op_or
id|E1000_TXCW_FD
op_or
id|E1000_TXCW_PAUSE_MASK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow control param set incorrectly&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Since auto-negotiation is enabled, take the link out of reset (the link&n;     * will be in reset, because we previously reset the chip). This will&n;     * restart auto-negotiation.  If auto-neogtiation is successful then the&n;     * link-up status bit will be set and the flow control enable bits (RFCE&n;     * and TFCE) will be set according to their negotiated value.&n;     */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Auto-negotiation enabled&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|TXCW
comma
id|txcw
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|hw-&gt;txcw
op_assign
id|txcw
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If we have a signal (the cable is plugged in) then poll for a &quot;Link-Up&quot;&n;     * indication in the Device Status Register.  Time-out if a link isn&squot;t&n;     * seen in 500 milliseconds seconds (Auto-negotiation should complete in&n;     * less than 500 milliseconds even if the other end is doing it in SW).&n;     * For internal serdes, we just assume a signal is present, then poll.&n;     */
r_if
c_cond
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_internal_serdes
op_logical_or
(paren
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
op_amp
id|E1000_CTRL_SWDPIN1
)paren
op_eq
id|signal
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Looking for Link&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|LINK_UP_TIMEOUT
op_div
l_int|10
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|msec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|status
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|E1000_STATUS_LU
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
(paren
id|LINK_UP_TIMEOUT
op_div
l_int|10
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Never got a valid link from auto-neg!!!&bslash;n&quot;
)paren
suffix:semicolon
id|hw-&gt;autoneg_failed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* AutoNeg failed to achieve a link, so we&squot;ll call&n;             * e1000_check_for_link. This routine will force the link up if&n;             * we detect a signal. This will allow us to communicate with&n;             * non-autonegotiating link partners.&n;             */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_check_for_link
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error while checking for link&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
id|hw-&gt;autoneg_failed
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|hw-&gt;autoneg_failed
op_assign
l_int|0
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Valid Link Found&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;No Signal Detected&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Detects which PHY is present and the speed and duplex&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_static
r_int32
DECL|function|e1000_setup_copper_link
id|e1000_setup_copper_link
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|led_ctrl
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|i
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_setup_copper_link&quot;
)paren
suffix:semicolon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* With 82543, we need to force speed and duplex on the MAC equal to what&n;     * the PHY speed and duplex configuration is. In addition, we need to&n;     * perform a hardware reset on the PHY to take it out of reset.&n;     */
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82543
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_SLU
suffix:semicolon
id|ctrl
op_and_assign
op_complement
(paren
id|E1000_CTRL_FRCSPD
op_or
id|E1000_CTRL_FRCDPX
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
)brace
r_else
(brace
id|ctrl
op_or_assign
(paren
id|E1000_CTRL_FRCSPD
op_or
id|E1000_CTRL_FRCDPX
op_or
id|E1000_CTRL_SLU
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
id|e1000_phy_hw_reset
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
multiline_comment|/* Make sure we have a valid PHY */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_detect_gig_phy
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error, did not detect valid phy.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Phy ID = %x &bslash;n&quot;
comma
id|hw-&gt;phy_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_le
id|e1000_82543
op_logical_or
id|hw-&gt;mac_type
op_eq
id|e1000_82541
op_logical_or
id|hw-&gt;mac_type
op_eq
id|e1000_82547
op_logical_or
id|hw-&gt;mac_type
op_eq
id|e1000_82541_rev_2
op_logical_or
id|hw-&gt;mac_type
op_eq
id|e1000_82547_rev_2
)paren
(brace
id|hw-&gt;phy_reset_disable
op_assign
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;phy_reset_disable
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_igp
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_phy_reset
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Resetting the PHY&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Wait 10ms for MAC to configure PHY from eeprom settings */
id|msec_delay
c_func
(paren
l_int|15
)paren
suffix:semicolon
multiline_comment|/* Configure activity LED after PHY reset */
id|led_ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|LEDCTL
)paren
suffix:semicolon
id|led_ctrl
op_and_assign
id|IGP_ACTIVITY_LED_MASK
suffix:semicolon
id|led_ctrl
op_or_assign
(paren
id|IGP_ACTIVITY_LED_ENABLE
op_or
id|IGP_LED3_MODE
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|LEDCTL
comma
id|led_ctrl
)paren
suffix:semicolon
multiline_comment|/* disable lplu d3 during driver init */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_set_d3_lplu_state
c_func
(paren
id|hw
comma
id|FALSE
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Disabling LPLU D3&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Configure mdi-mdix settings */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_CTRL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82541
)paren
op_logical_or
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82547
)paren
)paren
(brace
id|hw-&gt;dsp_config_state
op_assign
id|e1000_dsp_config_disabled
suffix:semicolon
multiline_comment|/* Force MDI for IGP B-0 PHY */
id|phy_data
op_and_assign
op_complement
(paren
id|IGP01E1000_PSCR_AUTO_MDIX
op_or
id|IGP01E1000_PSCR_FORCE_MDI_MDIX
)paren
suffix:semicolon
id|hw-&gt;mdix
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|hw-&gt;dsp_config_state
op_assign
id|e1000_dsp_config_enabled
suffix:semicolon
id|phy_data
op_and_assign
op_complement
id|IGP01E1000_PSCR_AUTO_MDIX
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;mdix
)paren
(brace
r_case
l_int|1
suffix:colon
id|phy_data
op_and_assign
op_complement
id|IGP01E1000_PSCR_FORCE_MDI_MDIX
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|phy_data
op_or_assign
id|IGP01E1000_PSCR_FORCE_MDI_MDIX
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_default
suffix:colon
id|phy_data
op_or_assign
id|IGP01E1000_PSCR_AUTO_MDIX
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_CTRL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* set auto-master slave resolution settings */
r_if
c_cond
(paren
id|hw-&gt;autoneg
)paren
(brace
id|e1000_ms_type
id|phy_ms_setting
op_assign
id|hw-&gt;master_slave
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;ffe_config_state
op_eq
id|e1000_ffe_config_active
)paren
(brace
id|hw-&gt;ffe_config_state
op_assign
id|e1000_ffe_config_enabled
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;dsp_config_state
op_eq
id|e1000_dsp_config_activated
)paren
(brace
id|hw-&gt;dsp_config_state
op_assign
id|e1000_dsp_config_enabled
suffix:semicolon
)brace
multiline_comment|/* when autonegotiation advertisment is only 1000Mbps then we&n;                 * should disable SmartSpeed and enable Auto MasterSlave&n;                 * resolution as hardware default. */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_eq
id|ADVERTISE_1000_FULL
)paren
(brace
multiline_comment|/* Disable SmartSpeed */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_CONFIG
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_and_assign
op_complement
id|IGP01E1000_PSCFR_SMART_SPEED
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_CONFIG
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Set auto Master/Slave resolution process */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_CTRL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_and_assign
op_complement
id|CR_1000T_MS_ENABLE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_CTRL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_CTRL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* load defaults for future use */
id|hw-&gt;original_master_slave
op_assign
(paren
id|phy_data
op_amp
id|CR_1000T_MS_ENABLE
)paren
ques
c_cond
(paren
(paren
id|phy_data
op_amp
id|CR_1000T_MS_VALUE
)paren
ques
c_cond
id|e1000_ms_force_master
suffix:colon
id|e1000_ms_force_slave
)paren
suffix:colon
id|e1000_ms_auto
suffix:semicolon
r_switch
c_cond
(paren
id|phy_ms_setting
)paren
(brace
r_case
id|e1000_ms_force_master
suffix:colon
id|phy_data
op_or_assign
(paren
id|CR_1000T_MS_ENABLE
op_or
id|CR_1000T_MS_VALUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_ms_force_slave
suffix:colon
id|phy_data
op_or_assign
id|CR_1000T_MS_ENABLE
suffix:semicolon
id|phy_data
op_and_assign
op_complement
(paren
id|CR_1000T_MS_VALUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_ms_auto
suffix:colon
id|phy_data
op_and_assign
op_complement
id|CR_1000T_MS_ENABLE
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_CTRL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Enable CRS on TX. This must be set for half-duplex operation. */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_or_assign
id|M88E1000_PSCR_ASSERT_CRS_ON_TX
suffix:semicolon
multiline_comment|/* Options:&n;             *   MDI/MDI-X = 0 (default)&n;             *   0 - Auto for all speeds&n;             *   1 - MDI mode&n;             *   2 - MDI-X mode&n;             *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)&n;             */
id|phy_data
op_and_assign
op_complement
id|M88E1000_PSCR_AUTO_X_MODE
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;mdix
)paren
(brace
r_case
l_int|1
suffix:colon
id|phy_data
op_or_assign
id|M88E1000_PSCR_MDI_MANUAL_MODE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|phy_data
op_or_assign
id|M88E1000_PSCR_MDIX_MANUAL_MODE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|phy_data
op_or_assign
id|M88E1000_PSCR_AUTO_X_1000T
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_default
suffix:colon
id|phy_data
op_or_assign
id|M88E1000_PSCR_AUTO_X_MODE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Options:&n;             *   disable_polarity_correction = 0 (default)&n;             *       Automatic Correction for Reversed Cable Polarity&n;             *   0 - Disabled&n;             *   1 - Enabled&n;             */
id|phy_data
op_and_assign
op_complement
id|M88E1000_PSCR_POLARITY_REVERSAL
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;disable_polarity_correction
op_eq
l_int|1
)paren
(brace
id|phy_data
op_or_assign
id|M88E1000_PSCR_POLARITY_REVERSAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Force TX_CLK in the Extended PHY Specific Control Register&n;             * to 25MHz clock.&n;             */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_or_assign
id|M88E1000_EPSCR_TX_CLK_25
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;phy_revision
OL
id|M88E1011_I_REV_4
)paren
(brace
multiline_comment|/* Configure Master and Slave downshift values */
id|phy_data
op_and_assign
op_complement
(paren
id|M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK
op_or
id|M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK
)paren
suffix:semicolon
id|phy_data
op_or_assign
(paren
id|M88E1000_EPSCR_MASTER_DOWNSHIFT_1X
op_or
id|M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
multiline_comment|/* SW Reset the PHY so all changes take effect */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_phy_reset
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Resetting the PHY&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
multiline_comment|/* Options:&n;         *   autoneg = 1 (default)&n;         *      PHY will advertise value(s) parsed from&n;         *      autoneg_advertised and fc&n;         *   autoneg = 0&n;         *      PHY will be set to 10H, 10F, 100H, or 100F&n;         *      depending on value parsed from forced_speed_duplex.&n;         */
multiline_comment|/* Is autoneg enabled?  This is enabled by default or by software&n;         * override.  If so, call e1000_phy_setup_autoneg routine to parse the&n;         * autoneg_advertised and fc options. If autoneg is NOT enabled, then&n;         * the user should have provided a speed/duplex override.  If so, then&n;         * call e1000_phy_force_speed_duplex to parse and set this up.&n;         */
r_if
c_cond
(paren
id|hw-&gt;autoneg
)paren
(brace
multiline_comment|/* Perform some bounds checking on the hw-&gt;autoneg_advertised&n;             * parameter.  If this variable is zero, then set it to the default.&n;             */
id|hw-&gt;autoneg_advertised
op_and_assign
id|AUTONEG_ADVERTISE_SPEED_DEFAULT
suffix:semicolon
multiline_comment|/* If autoneg_advertised is zero, we assume it was not defaulted&n;             * by the calling code so we set to advertise full capability.&n;             */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_eq
l_int|0
)paren
(brace
id|hw-&gt;autoneg_advertised
op_assign
id|AUTONEG_ADVERTISE_SPEED_DEFAULT
suffix:semicolon
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Reconfiguring auto-neg advertisement params&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_phy_setup_autoneg
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Setting up Auto-Negotiation&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Restarting Auto-Neg&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Restart auto-negotiation by setting the Auto Neg Enable bit and&n;             * the Auto Neg Restart bit in the PHY control register.&n;             */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_CTRL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_or_assign
(paren
id|MII_CR_AUTO_NEG_EN
op_or
id|MII_CR_RESTART_AUTO_NEG
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|PHY_CTRL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Does the user want to wait for Auto-Neg to complete here, or&n;             * check at a later time (for example, callback routine).&n;             */
r_if
c_cond
(paren
id|hw-&gt;wait_autoneg_complete
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_wait_autoneg
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error while waiting for autoneg to complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
id|hw-&gt;get_link_status
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Forcing speed and duplex&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_phy_force_speed_duplex
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Forcing Speed and Duplex&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* !hw-&gt;phy_reset_disable */
multiline_comment|/* Check link status. Wait up to 100 microseconds for link to become&n;     * valid.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|phy_data
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
multiline_comment|/* We have link, so we need to finish the config process:&n;             *   1) Set up the MAC to the current PHY speed/duplex&n;             *      if we are on 82543.  If we&n;             *      are on newer silicon, we only need to configure&n;             *      collision distance in the Transmit Control Register.&n;             *   2) Set up flow control on the MAC to that established with&n;             *      the link partner.&n;             */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_ge
id|e1000_82544
)paren
(brace
id|e1000_config_collision_dist
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_config_mac_to_phy
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error configuring MAC to PHY settings&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_config_fc_after_link_up
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Configuring Flow Control&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Valid link established!!!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_igp
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_config_dsp_after_link_change
c_func
(paren
id|hw
comma
id|TRUE
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Configuring DSP after link up&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Valid link established!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Unable to establish link!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Configures PHY autoneg and flow control advertisement settings&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_int32
DECL|function|e1000_phy_setup_autoneg
id|e1000_phy_setup_autoneg
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|mii_autoneg_adv_reg
suffix:semicolon
r_uint16
id|mii_1000t_ctrl_reg
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_setup_autoneg&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the MII Auto-Neg Advertisement Register (Address 4). */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_AUTONEG_ADV
comma
op_amp
id|mii_autoneg_adv_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Read the MII 1000Base-T Control Register (Address 9). */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_CTRL
comma
op_amp
id|mii_1000t_ctrl_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Need to parse both autoneg_advertised and fc and set up&n;     * the appropriate PHY registers.  First we will parse for&n;     * autoneg_advertised software override.  Since we can advertise&n;     * a plethora of combinations, we need to check each bit&n;     * individually.&n;     */
multiline_comment|/* First we clear all the 10/100 mb speed bits in the Auto-Neg&n;     * Advertisement Register (Address 4) and the 1000 mb speed bits in&n;     * the  1000Base-T Control Register (Address 9).&n;     */
id|mii_autoneg_adv_reg
op_and_assign
op_complement
id|REG4_SPEED_MASK
suffix:semicolon
id|mii_1000t_ctrl_reg
op_and_assign
op_complement
id|REG9_SPEED_MASK
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;autoneg_advertised %x&bslash;n&quot;
comma
id|hw-&gt;autoneg_advertised
)paren
suffix:semicolon
multiline_comment|/* Do we want to advertise 10 Mb Half Duplex? */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_amp
id|ADVERTISE_10_HALF
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 10mb Half duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_10T_HD_CAPS
suffix:semicolon
)brace
multiline_comment|/* Do we want to advertise 10 Mb Full Duplex? */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_amp
id|ADVERTISE_10_FULL
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 10mb Full duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_10T_FD_CAPS
suffix:semicolon
)brace
multiline_comment|/* Do we want to advertise 100 Mb Half Duplex? */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_amp
id|ADVERTISE_100_HALF
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 100mb Half duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_100TX_HD_CAPS
suffix:semicolon
)brace
multiline_comment|/* Do we want to advertise 100 Mb Full Duplex? */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_amp
id|ADVERTISE_100_FULL
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 100mb Full duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_100TX_FD_CAPS
suffix:semicolon
)brace
multiline_comment|/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_amp
id|ADVERTISE_1000_HALF
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 1000mb Half duplex requested, request denied!&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Do we want to advertise 1000 Mb Full Duplex? */
r_if
c_cond
(paren
id|hw-&gt;autoneg_advertised
op_amp
id|ADVERTISE_1000_FULL
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 1000mb Full duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_1000t_ctrl_reg
op_or_assign
id|CR_1000T_FD_CAPS
suffix:semicolon
)brace
multiline_comment|/* Check for a software override of the flow control settings, and&n;     * setup the PHY advertisement registers accordingly.  If&n;     * auto-negotiation is enabled, then software will have to set the&n;     * &quot;PAUSE&quot; bits to the correct value in the Auto-Negotiation&n;     * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.&n;     *&n;     * The possible values of the &quot;fc&quot; parameter are:&n;     *      0:  Flow control is completely disabled&n;     *      1:  Rx flow control is enabled (we can receive pause frames&n;     *          but not send pause frames).&n;     *      2:  Tx flow control is enabled (we can send pause frames&n;     *          but we do not support receiving pause frames).&n;     *      3:  Both Rx and TX flow control (symmetric) are enabled.&n;     *  other:  No software override.  The flow control configuration&n;     *          in the EEPROM is used.&n;     */
r_switch
c_cond
(paren
id|hw-&gt;fc
)paren
(brace
r_case
id|e1000_fc_none
suffix:colon
multiline_comment|/* 0 */
multiline_comment|/* Flow control (RX &amp; TX) is completely disabled by a&n;         * software over-ride.&n;         */
id|mii_autoneg_adv_reg
op_and_assign
op_complement
(paren
id|NWAY_AR_ASM_DIR
op_or
id|NWAY_AR_PAUSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_rx_pause
suffix:colon
multiline_comment|/* 1 */
multiline_comment|/* RX Flow control is enabled, and TX Flow control is&n;         * disabled, by a software over-ride.&n;         */
multiline_comment|/* Since there really isn&squot;t a way to advertise that we are&n;         * capable of RX Pause ONLY, we will advertise that we&n;         * support both symmetric and asymmetric RX PAUSE.  Later&n;         * (in e1000_config_fc_after_link_up) we will disable the&n;         *hw&squot;s ability to send PAUSE frames.&n;         */
id|mii_autoneg_adv_reg
op_or_assign
(paren
id|NWAY_AR_ASM_DIR
op_or
id|NWAY_AR_PAUSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_tx_pause
suffix:colon
multiline_comment|/* 2 */
multiline_comment|/* TX Flow control is enabled, and RX Flow control is&n;         * disabled, by a software over-ride.&n;         */
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_ASM_DIR
suffix:semicolon
id|mii_autoneg_adv_reg
op_and_assign
op_complement
id|NWAY_AR_PAUSE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_full
suffix:colon
multiline_comment|/* 3 */
multiline_comment|/* Flow control (both RX and TX) is enabled by a software&n;         * over-ride.&n;         */
id|mii_autoneg_adv_reg
op_or_assign
(paren
id|NWAY_AR_ASM_DIR
op_or
id|NWAY_AR_PAUSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow control param set incorrectly&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|PHY_AUTONEG_ADV
comma
id|mii_autoneg_adv_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Auto-Neg Advertising %x&bslash;n&quot;
comma
id|mii_autoneg_adv_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_CTRL
comma
id|mii_1000t_ctrl_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Force PHY speed and duplex settings to hw-&gt;forced_speed_duplex&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_static
r_int32
DECL|function|e1000_phy_force_speed_duplex
id|e1000_phy_force_speed_duplex
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|mii_ctrl_reg
suffix:semicolon
r_uint16
id|mii_status_reg
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
r_uint16
id|i
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_force_speed_duplex&quot;
)paren
suffix:semicolon
multiline_comment|/* Turn off Flow control if we are forcing speed and duplex. */
id|hw-&gt;fc
op_assign
id|e1000_fc_none
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;hw-&gt;fc = %d&bslash;n&quot;
comma
id|hw-&gt;fc
)paren
suffix:semicolon
multiline_comment|/* Read the Device Control Register. */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */
id|ctrl
op_or_assign
(paren
id|E1000_CTRL_FRCSPD
op_or
id|E1000_CTRL_FRCDPX
)paren
suffix:semicolon
id|ctrl
op_and_assign
op_complement
(paren
id|DEVICE_SPEED_MASK
)paren
suffix:semicolon
multiline_comment|/* Clear the Auto Speed Detect Enable bit. */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_ASDE
suffix:semicolon
multiline_comment|/* Read the MII Control Register. */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_CTRL
comma
op_amp
id|mii_ctrl_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* We need to disable autoneg in order to force link and duplex. */
id|mii_ctrl_reg
op_and_assign
op_complement
id|MII_CR_AUTO_NEG_EN
suffix:semicolon
multiline_comment|/* Are we forcing Full or Half Duplex? */
r_if
c_cond
(paren
id|hw-&gt;forced_speed_duplex
op_eq
id|e1000_100_full
op_logical_or
id|hw-&gt;forced_speed_duplex
op_eq
id|e1000_10_full
)paren
(brace
multiline_comment|/* We want to force full duplex so we SET the full duplex bits in the&n;         * Device and MII Control Registers.&n;         */
id|ctrl
op_or_assign
id|E1000_CTRL_FD
suffix:semicolon
id|mii_ctrl_reg
op_or_assign
id|MII_CR_FULL_DUPLEX
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Full Duplex&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We want to force half duplex so we CLEAR the full duplex bits in&n;         * the Device and MII Control Registers.&n;         */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_FD
suffix:semicolon
id|mii_ctrl_reg
op_and_assign
op_complement
id|MII_CR_FULL_DUPLEX
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Half Duplex&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Are we forcing 100Mbps??? */
r_if
c_cond
(paren
id|hw-&gt;forced_speed_duplex
op_eq
id|e1000_100_full
op_logical_or
id|hw-&gt;forced_speed_duplex
op_eq
id|e1000_100_half
)paren
(brace
multiline_comment|/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
id|ctrl
op_or_assign
id|E1000_CTRL_SPD_100
suffix:semicolon
id|mii_ctrl_reg
op_or_assign
id|MII_CR_SPEED_100
suffix:semicolon
id|mii_ctrl_reg
op_and_assign
op_complement
(paren
id|MII_CR_SPEED_1000
op_or
id|MII_CR_SPEED_10
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Forcing 100mb &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
id|ctrl
op_and_assign
op_complement
(paren
id|E1000_CTRL_SPD_1000
op_or
id|E1000_CTRL_SPD_100
)paren
suffix:semicolon
id|mii_ctrl_reg
op_or_assign
id|MII_CR_SPEED_10
suffix:semicolon
id|mii_ctrl_reg
op_and_assign
op_complement
(paren
id|MII_CR_SPEED_1000
op_or
id|MII_CR_SPEED_100
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Forcing 10mb &quot;
)paren
suffix:semicolon
)brace
id|e1000_config_collision_dist
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Write the configured values back to the Device Control Reg. */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_m88
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Clear Auto-Crossover to force MDI manually. M88E1000 requires MDI&n;         * forced whenever speed are duplex are forced.&n;         */
id|phy_data
op_and_assign
op_complement
id|M88E1000_PSCR_AUTO_X_MODE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;M88E1000 PSCR: %x &bslash;n&quot;
comma
id|phy_data
)paren
suffix:semicolon
multiline_comment|/* Need to reset the PHY or these changes will be ignored */
id|mii_ctrl_reg
op_or_assign
id|MII_CR_RESET
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Clear Auto-Crossover to force MDI manually.  IGP requires MDI&n;         * forced whenever speed or duplex are forced.&n;         */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_CTRL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_and_assign
op_complement
id|IGP01E1000_PSCR_AUTO_MDIX
suffix:semicolon
id|phy_data
op_and_assign
op_complement
id|IGP01E1000_PSCR_FORCE_MDI_MDIX
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_CTRL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
multiline_comment|/* Write back the modified PHY MII control register. */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|PHY_CTRL
comma
id|mii_ctrl_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* The wait_autoneg_complete flag may be a little misleading here.&n;     * Since we are forcing speed and duplex, Auto-Neg is not enabled.&n;     * But we do want to delay for a period while forcing only so we&n;     * don&squot;t generate false No Link messages.  So we will wait here&n;     * only if the user has set wait_autoneg_complete to 1, which is&n;     * the default.&n;     */
r_if
c_cond
(paren
id|hw-&gt;wait_autoneg_complete
)paren
(brace
multiline_comment|/* We will wait for autoneg to complete. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Waiting for forced speed/duplex link.&bslash;n&quot;
)paren
suffix:semicolon
id|mii_status_reg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
r_for
c_loop
(paren
id|i
op_assign
id|PHY_FORCE_TIME
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
multiline_comment|/* Read the MII Status Register and wait for Auto-Neg Complete bit&n;             * to be set.&n;             */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|mii_status_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|mii_status_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
r_break
suffix:semicolon
)brace
id|msec_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_eq
l_int|0
)paren
op_logical_and
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_m88
)paren
)paren
(brace
multiline_comment|/* We didn&squot;t get link.  Reset the DSP and wait again for link. */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_phy_reset_dsp
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error Resetting PHY DSP&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
multiline_comment|/* This loop will early-out if the link condition has been met.  */
r_for
c_loop
(paren
id|i
op_assign
id|PHY_FORCE_TIME
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
r_break
suffix:semicolon
)brace
id|msec_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Read the MII Status Register and wait for Auto-Neg Complete bit&n;             * to be set.&n;             */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|mii_status_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|mii_status_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_m88
)paren
(brace
multiline_comment|/* Because we reset the PHY above, we need to re-force TX_CLK in the&n;         * Extended PHY Specific Control Register to 25MHz clock.  This value&n;         * defaults back to a 2.5MHz clock when the PHY is reset.&n;         */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_or_assign
id|M88E1000_EPSCR_TX_CLK_25
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* In addition, because of the s/w reset above, we need to enable CRS on&n;         * TX.  This must be set for both full and half duplex operation.&n;         */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_or_assign
id|M88E1000_PSCR_ASSERT_CRS_ON_TX
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Polarity reversal workaround for forced 10F/10H links. */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_le
id|e1000_82544
op_logical_and
(paren
id|hw-&gt;forced_speed_duplex
op_eq
id|e1000_10_full
op_logical_or
id|hw-&gt;forced_speed_duplex
op_eq
id|e1000_10_half
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_PAGE_SELECT
comma
l_int|0x0019
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_GEN_CONTROL
comma
l_int|0x8F0F
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* IEEE requirement is 150ms */
id|msec_delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_PAGE_SELECT
comma
l_int|0x0019
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_GEN_CONTROL
comma
l_int|0x8F00
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Sets the collision distance in the Transmit Control register&n;*&n;* hw - Struct containing variables accessed by shared code&n;*&n;* Link should have been established previously. Reads the speed and duplex&n;* information from the Device Status register.&n;******************************************************************************/
r_void
DECL|function|e1000_config_collision_dist
id|e1000_config_collision_dist
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|tctl
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_config_collision_dist&quot;
)paren
suffix:semicolon
id|tctl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TCTL
)paren
suffix:semicolon
id|tctl
op_and_assign
op_complement
id|E1000_TCTL_COLD
suffix:semicolon
id|tctl
op_or_assign
id|E1000_COLLISION_DISTANCE
op_lshift
id|E1000_COLD_SHIFT
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|TCTL
comma
id|tctl
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Sets MAC speed and duplex settings to reflect the those in the PHY&n;*&n;* hw - Struct containing variables accessed by shared code&n;* mii_reg - data to write to the MII control register&n;*&n;* The contents of the PHY register containing the needed information need to&n;* be passed in.&n;******************************************************************************/
r_static
r_int32
DECL|function|e1000_config_mac_to_phy
id|e1000_config_mac_to_phy
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_config_mac_to_phy&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the Device Control Register and set the bits to Force Speed&n;     * and Duplex.&n;     */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|ctrl
op_or_assign
(paren
id|E1000_CTRL_FRCSPD
op_or
id|E1000_CTRL_FRCDPX
)paren
suffix:semicolon
id|ctrl
op_and_assign
op_complement
(paren
id|E1000_CTRL_SPD_SEL
op_or
id|E1000_CTRL_ILOS
)paren
suffix:semicolon
multiline_comment|/* Set up duplex in the Device Control and Transmit Control&n;     * registers depending on negotiated values.&n;     */
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_igp
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|phy_data
op_amp
id|IGP01E1000_PSSR_FULL_DUPLEX
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_FD
suffix:semicolon
)brace
r_else
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_FD
suffix:semicolon
id|e1000_config_collision_dist
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Set up speed in the Device Control register depending on&n;         * negotiated values.&n;         */
r_if
c_cond
(paren
(paren
id|phy_data
op_amp
id|IGP01E1000_PSSR_SPEED_MASK
)paren
op_eq
id|IGP01E1000_PSSR_SPEED_1000MBPS
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_SPD_1000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|phy_data
op_amp
id|IGP01E1000_PSSR_SPEED_MASK
)paren
op_eq
id|IGP01E1000_PSSR_SPEED_100MBPS
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_SPD_100
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_DPLX
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_FD
suffix:semicolon
)brace
r_else
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_FD
suffix:semicolon
id|e1000_config_collision_dist
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Set up speed in the Device Control register depending on&n;         * negotiated values.&n;         */
r_if
c_cond
(paren
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_SPEED
)paren
op_eq
id|M88E1000_PSSR_1000MBS
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_SPD_1000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_SPEED
)paren
op_eq
id|M88E1000_PSSR_100MBS
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_SPD_100
suffix:semicolon
)brace
)brace
multiline_comment|/* Write the configured values back to the Device Control Reg. */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Forces the MAC&squot;s flow control settings.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Sets the TFCE and RFCE bits in the device control register to reflect&n; * the adapter settings. TFCE and RFCE need to be explicitly set by&n; * software when a Copper PHY is used because autonegotiation is managed&n; * by the PHY rather than the MAC. Software must also configure these&n; * bits when link is forced on a fiber connection.&n; *****************************************************************************/
r_int32
DECL|function|e1000_force_mac_fc
id|e1000_force_mac_fc
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_force_mac_fc&quot;
)paren
suffix:semicolon
multiline_comment|/* Get the current configuration of the Device Control Register */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Because we didn&squot;t get link via the internal auto-negotiation&n;     * mechanism (we either forced link or we got link via PHY&n;     * auto-neg), we have to manually enable/disable transmit an&n;     * receive flow control.&n;     *&n;     * The &quot;Case&quot; statement below enables/disable flow control&n;     * according to the &quot;hw-&gt;fc&quot; parameter.&n;     *&n;     * The possible values of the &quot;fc&quot; parameter are:&n;     *      0:  Flow control is completely disabled&n;     *      1:  Rx flow control is enabled (we can receive pause&n;     *          frames but not send pause frames).&n;     *      2:  Tx flow control is enabled (we can send pause frames&n;     *          frames but we do not receive pause frames).&n;     *      3:  Both Rx and TX flow control (symmetric) is enabled.&n;     *  other:  No other values should be possible at this point.&n;     */
r_switch
c_cond
(paren
id|hw-&gt;fc
)paren
(brace
r_case
id|e1000_fc_none
suffix:colon
id|ctrl
op_and_assign
(paren
op_complement
(paren
id|E1000_CTRL_TFCE
op_or
id|E1000_CTRL_RFCE
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_rx_pause
suffix:colon
id|ctrl
op_and_assign
(paren
op_complement
id|E1000_CTRL_TFCE
)paren
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_RFCE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_tx_pause
suffix:colon
id|ctrl
op_and_assign
(paren
op_complement
id|E1000_CTRL_RFCE
)paren
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_TFCE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_full
suffix:colon
id|ctrl
op_or_assign
(paren
id|E1000_CTRL_TFCE
op_or
id|E1000_CTRL_RFCE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow control param set incorrectly&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
multiline_comment|/* Disable TX Flow Control for 82542 (rev 2.0) */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82542_rev2_0
)paren
(brace
id|ctrl
op_and_assign
(paren
op_complement
id|E1000_CTRL_TFCE
)paren
suffix:semicolon
)brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Configures flow control settings after link is established&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Should be called immediately after a valid link has been established.&n; * Forces MAC flow control settings if link was forced. When in MII/GMII mode&n; * and autonegotiation is enabled, the MAC flow control settings will be set&n; * based on the flow control negotiated by the PHY. In TBI mode, the TFCE&n; * and RFCE bits will be automaticaly set to the negotiated flow control mode.&n; *****************************************************************************/
r_int32
DECL|function|e1000_config_fc_after_link_up
id|e1000_config_fc_after_link_up
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|mii_status_reg
suffix:semicolon
r_uint16
id|mii_nway_adv_reg
suffix:semicolon
r_uint16
id|mii_nway_lp_ability_reg
suffix:semicolon
r_uint16
id|speed
suffix:semicolon
r_uint16
id|duplex
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_config_fc_after_link_up&quot;
)paren
suffix:semicolon
multiline_comment|/* Check for the case where we have fiber media and auto-neg failed&n;     * so we had to force link.  In this case, we need to force the&n;     * configuration of the MAC to match the &quot;fc&quot; parameter.&n;     */
r_if
c_cond
(paren
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
op_logical_and
(paren
id|hw-&gt;autoneg_failed
)paren
)paren
op_logical_or
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_internal_serdes
)paren
op_logical_and
(paren
id|hw-&gt;autoneg_failed
)paren
)paren
op_logical_or
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_copper
)paren
op_logical_and
(paren
op_logical_neg
id|hw-&gt;autoneg
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_force_mac_fc
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error forcing flow control settings&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
multiline_comment|/* Check for the case where we have copper media and auto-neg is&n;     * enabled.  In this case, we need to check and see if Auto-Neg&n;     * has completed, and if so, how the PHY and link partner has&n;     * flow control configured.&n;     */
r_if
c_cond
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_copper
)paren
op_logical_and
id|hw-&gt;autoneg
)paren
(brace
multiline_comment|/* Read the MII Status Register and check to see if AutoNeg&n;         * has completed.  We read this twice because this reg has&n;         * some &quot;sticky&quot; (latched) bits.&n;         */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|mii_status_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|mii_status_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_AUTONEG_COMPLETE
)paren
(brace
multiline_comment|/* The AutoNeg process has completed, so we now need to&n;             * read both the Auto Negotiation Advertisement Register&n;             * (Address 4) and the Auto_Negotiation Base Page Ability&n;             * Register (Address 5) to determine how flow control was&n;             * negotiated.&n;             */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_AUTONEG_ADV
comma
op_amp
id|mii_nway_adv_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_LP_ABILITY
comma
op_amp
id|mii_nway_lp_ability_reg
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Two bits in the Auto Negotiation Advertisement Register&n;             * (Address 4) and two bits in the Auto Negotiation Base&n;             * Page Ability Register (Address 5) determine flow control&n;             * for both the PHY and the link partner.  The following&n;             * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,&n;             * 1999, describes these PAUSE resolution bits and how flow&n;             * control is determined based upon these settings.&n;             * NOTE:  DC = Don&squot;t Care&n;             *&n;             *   LOCAL DEVICE  |   LINK PARTNER&n;             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution&n;             *-------|---------|-------|---------|--------------------&n;             *   0   |    0    |  DC   |   DC    | e1000_fc_none&n;             *   0   |    1    |   0   |   DC    | e1000_fc_none&n;             *   0   |    1    |   1   |    0    | e1000_fc_none&n;             *   0   |    1    |   1   |    1    | e1000_fc_tx_pause&n;             *   1   |    0    |   0   |   DC    | e1000_fc_none&n;             *   1   |   DC    |   1   |   DC    | e1000_fc_full&n;             *   1   |    1    |   0   |    0    | e1000_fc_none&n;             *   1   |    1    |   0   |    1    | e1000_fc_rx_pause&n;             *&n;             */
multiline_comment|/* Are both PAUSE bits set to 1?  If so, this implies&n;             * Symmetric Flow Control is enabled at both ends.  The&n;             * ASM_DIR bits are irrelevant per the spec.&n;             *&n;             * For Symmetric Flow Control:&n;             *&n;             *   LOCAL DEVICE  |   LINK PARTNER&n;             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result&n;             *-------|---------|-------|---------|--------------------&n;             *   1   |   DC    |   1   |   DC    | e1000_fc_full&n;             *&n;             */
r_if
c_cond
(paren
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_PAUSE
)paren
)paren
(brace
multiline_comment|/* Now we need to check if the user selected RX ONLY&n;                 * of pause frames.  In this case, we had to advertise&n;                 * FULL flow control because we could not advertise RX&n;                 * ONLY. Hence, we must now check to see if we need to&n;                 * turn OFF  the TRANSMISSION of PAUSE frames.&n;                 */
r_if
c_cond
(paren
id|hw-&gt;original_fc
op_eq
id|e1000_fc_full
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_full
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = FULL.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_rx_pause
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = RX PAUSE frames only.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* For receiving PAUSE frames ONLY.&n;             *&n;             *   LOCAL DEVICE  |   LINK PARTNER&n;             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result&n;             *-------|---------|-------|---------|--------------------&n;             *   0   |    1    |   1   |    1    | e1000_fc_tx_pause&n;             *&n;             */
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_ASM_DIR
)paren
op_logical_and
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_ASM_DIR
)paren
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_tx_pause
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = TX PAUSE frames only.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* For transmitting PAUSE frames ONLY.&n;             *&n;             *   LOCAL DEVICE  |   LINK PARTNER&n;             * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result&n;             *-------|---------|-------|---------|--------------------&n;             *   1   |    1    |   0   |    1    | e1000_fc_rx_pause&n;             *&n;             */
r_else
r_if
c_cond
(paren
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_adv_reg
op_amp
id|NWAY_AR_ASM_DIR
)paren
op_logical_and
op_logical_neg
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_PAUSE
)paren
op_logical_and
(paren
id|mii_nway_lp_ability_reg
op_amp
id|NWAY_LPAR_ASM_DIR
)paren
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_rx_pause
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = RX PAUSE frames only.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Per the IEEE spec, at this point flow control should be&n;             * disabled.  However, we want to consider that we could&n;             * be connected to a legacy switch that doesn&squot;t advertise&n;             * desired flow control, but can be forced on the link&n;             * partner.  So if we advertised no flow control, that is&n;             * what we will resolve to.  If we advertised some kind of&n;             * receive capability (Rx Pause Only or Full Flow Control)&n;             * and the link partner advertised none, we will configure&n;             * ourselves to enable Rx Flow Control only.  We can do&n;             * this safely for two reasons:  If the link partner really&n;             * didn&squot;t want flow control enabled, and we enable Rx, no&n;             * harm done since we won&squot;t be receiving any PAUSE frames&n;             * anyway.  If the intent on the link partner was to have&n;             * flow control enabled, then by us enabling RX only, we&n;             * can at least receive pause frames and process them.&n;             * This is a good idea because in most cases, since we are&n;             * predominantly a server NIC, more times than not we will&n;             * be asked to delay transmission of packets than asking&n;             * our link partner to pause transmission of frames.&n;             */
r_else
r_if
c_cond
(paren
(paren
id|hw-&gt;original_fc
op_eq
id|e1000_fc_none
op_logical_or
id|hw-&gt;original_fc
op_eq
id|e1000_fc_tx_pause
)paren
op_logical_or
id|hw-&gt;fc_strict_ieee
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_none
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = NONE.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_rx_pause
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow Control = RX PAUSE frames only.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we need to do one last check...  If we auto-&n;             * negotiated to HALF DUPLEX, flow control should not be&n;             * enabled per IEEE 802.3 spec.&n;             */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_get_speed_and_duplex
c_func
(paren
id|hw
comma
op_amp
id|speed
comma
op_amp
id|duplex
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error getting link speed and duplex&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|duplex
op_eq
id|HALF_DUPLEX
)paren
(brace
id|hw-&gt;fc
op_assign
id|e1000_fc_none
suffix:semicolon
)brace
multiline_comment|/* Now we call a subroutine to actually force the MAC&n;             * controller to use the correct flow control settings.&n;             */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_force_mac_fc
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error forcing flow control settings&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Copper PHY and Auto Neg has not completed.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Checks to see if the link status of the hardware has changed.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Called by any function that needs to check the link status of the adapter.&n; *****************************************************************************/
r_int32
DECL|function|e1000_check_for_link
id|e1000_check_for_link
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|rxcw
suffix:semicolon
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|status
suffix:semicolon
r_uint32
id|rctl
suffix:semicolon
r_uint32
id|signal
op_assign
l_int|0
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_check_for_link&quot;
)paren
suffix:semicolon
multiline_comment|/* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be&n;     * set when the optics detect a signal. On older adapters, it will be&n;     * cleared when there is a signal.  This applies to fiber media only.&n;     */
r_if
c_cond
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
(brace
id|signal
op_assign
(paren
id|hw-&gt;mac_type
OG
id|e1000_82544
)paren
ques
c_cond
id|E1000_CTRL_SWDPIN1
suffix:colon
l_int|0
suffix:semicolon
)brace
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|status
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
suffix:semicolon
id|rxcw
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RXCW
)paren
suffix:semicolon
multiline_comment|/* If we have a copper PHY then we only want to go out to the PHY&n;     * registers to see if Auto-Neg has completed and/or if our link&n;     * status has changed.  The get_link_status flag will be set if we&n;     * receive a Link Status Change interrupt or we have Rx Sequence&n;     * Errors.&n;     */
r_if
c_cond
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_copper
)paren
op_logical_and
id|hw-&gt;get_link_status
)paren
(brace
multiline_comment|/* First we want to see if the MII Status Register reports&n;         * link.  If so, then we want to get the current speed/duplex&n;         * of the PHY.&n;         * Read the register twice since the link bit is sticky.&n;         */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|phy_data
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
id|hw-&gt;get_link_status
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Check if there was DownShift, must be checked immediately after&n;             * link-up */
id|e1000_check_downshift
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No link detected */
id|e1000_config_dsp_after_link_change
c_func
(paren
id|hw
comma
id|FALSE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If we are forcing speed/duplex, then we simply return since&n;         * we have already determined whether we have link or not.&n;         */
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;autoneg
)paren
(brace
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
multiline_comment|/* optimize the dsp settings for the igp phy */
id|e1000_config_dsp_after_link_change
c_func
(paren
id|hw
comma
id|TRUE
)paren
suffix:semicolon
multiline_comment|/* We have a M88E1000 PHY and Auto-Neg is enabled.  If we&n;         * have Si on board that is 82544 or newer, Auto&n;         * Speed Detection takes care of MAC speed/duplex&n;         * configuration.  So we only need to configure Collision&n;         * Distance in the MAC.  Otherwise, we need to force&n;         * speed/duplex on the MAC to the current PHY speed/duplex&n;         * settings.&n;         */
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_ge
id|e1000_82544
)paren
(brace
id|e1000_config_collision_dist
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_config_mac_to_phy
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error configuring MAC to PHY settings&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
multiline_comment|/* Configure Flow Control now that Auto-Neg has completed. First, we&n;         * need to restore the desired flow control settings because we may&n;         * have had to re-autoneg with a different link partner.&n;         */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_config_fc_after_link_up
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error configuring flow control&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* At this point we know that we are on copper and we have&n;         * auto-negotiated link.  These are conditions for checking the link&n;         * partner capability register.  We use the link speed to determine if&n;         * TBI compatibility needs to be turned on or off.  If the link is not&n;         * at gigabit speed, then TBI compatibility is not needed.  If we are&n;         * at gigabit speed, we turn on TBI compatibility.&n;         */
r_if
c_cond
(paren
id|hw-&gt;tbi_compatibility_en
)paren
(brace
r_uint16
id|speed
comma
id|duplex
suffix:semicolon
id|e1000_get_speed_and_duplex
c_func
(paren
id|hw
comma
op_amp
id|speed
comma
op_amp
id|duplex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|speed
op_ne
id|SPEED_1000
)paren
(brace
multiline_comment|/* If link speed is not set to gigabit speed, we do not need&n;                 * to enable TBI compatibility.&n;                 */
r_if
c_cond
(paren
id|hw-&gt;tbi_compatibility_on
)paren
(brace
multiline_comment|/* If we previously were in the mode, turn it off. */
id|rctl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RCTL
)paren
suffix:semicolon
id|rctl
op_and_assign
op_complement
id|E1000_RCTL_SBP
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|RCTL
comma
id|rctl
)paren
suffix:semicolon
id|hw-&gt;tbi_compatibility_on
op_assign
id|FALSE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* If TBI compatibility is was previously off, turn it on. For&n;                 * compatibility with a TBI link partner, we will store bad&n;                 * packets. Some frames have an additional byte on the end and&n;                 * will look like CRC errors to to the hardware.&n;                 */
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;tbi_compatibility_on
)paren
(brace
id|hw-&gt;tbi_compatibility_on
op_assign
id|TRUE
suffix:semicolon
id|rctl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RCTL
)paren
suffix:semicolon
id|rctl
op_or_assign
id|E1000_RCTL_SBP
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|RCTL
comma
id|rctl
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* If we don&squot;t have link (auto-negotiation failed or link partner cannot&n;     * auto-negotiate), the cable is plugged in (we have signal), and our&n;     * link partner is not trying to auto-negotiate with us (we are receiving&n;     * idles or data), we need to force link up. We also need to give&n;     * auto-negotiation time to complete, in case the cable was just plugged&n;     * in. The autoneg_failed flag does this.&n;     */
r_else
r_if
c_cond
(paren
(paren
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
op_logical_and
(paren
(paren
id|ctrl
op_amp
id|E1000_CTRL_SWDPIN1
)paren
op_eq
id|signal
)paren
)paren
op_logical_or
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_internal_serdes
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|status
op_amp
id|E1000_STATUS_LU
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|rxcw
op_amp
id|E1000_RXCW_C
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;autoneg_failed
op_eq
l_int|0
)paren
(brace
id|hw-&gt;autoneg_failed
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;NOT RXing /C/, disable AutoNeg and force link.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Disable auto-negotiation in the TXCW register */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|TXCW
comma
(paren
id|hw-&gt;txcw
op_amp
op_complement
id|E1000_TXCW_ANE
)paren
)paren
suffix:semicolon
multiline_comment|/* Force link-up and also force full-duplex. */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|ctrl
op_or_assign
(paren
id|E1000_CTRL_SLU
op_or
id|E1000_CTRL_FD
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Configure Flow Control after forcing link up. */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_config_fc_after_link_up
c_func
(paren
id|hw
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error configuring flow control&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
)brace
multiline_comment|/* If we are forcing link and we are receiving /C/ ordered sets, re-enable&n;     * auto-negotiation in the TXCW register and disable forced link in the&n;     * Device Control register in an attempt to auto-negotiate with our link&n;     * partner.&n;     */
r_else
r_if
c_cond
(paren
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
op_logical_or
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_internal_serdes
)paren
)paren
op_logical_and
(paren
id|ctrl
op_amp
id|E1000_CTRL_SLU
)paren
op_logical_and
(paren
id|rxcw
op_amp
id|E1000_RXCW_C
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;RXing /C/, enable AutoNeg and stop forcing link.&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|TXCW
comma
id|hw-&gt;txcw
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
(paren
id|ctrl
op_amp
op_complement
id|E1000_CTRL_SLU
)paren
)paren
suffix:semicolon
id|hw-&gt;serdes_link_down
op_assign
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* If we force link for non-auto-negotiation switch, check link status&n;     * based on MAC synchronization for internal serdes media type.&n;     */
r_else
r_if
c_cond
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_internal_serdes
)paren
op_logical_and
op_logical_neg
(paren
id|E1000_TXCW_ANE
op_amp
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TXCW
)paren
)paren
)paren
(brace
multiline_comment|/* SYNCH bit and IV bit are sticky. */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|E1000_RXCW_SYNCH
op_amp
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RXCW
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|rxcw
op_amp
id|E1000_RXCW_IV
)paren
)paren
(brace
id|hw-&gt;serdes_link_down
op_assign
id|FALSE
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;SERDES: Link is up.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|hw-&gt;serdes_link_down
op_assign
id|TRUE
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;SERDES: Link is down.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_internal_serdes
)paren
op_logical_and
(paren
id|E1000_TXCW_ANE
op_amp
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TXCW
)paren
)paren
)paren
(brace
id|hw-&gt;serdes_link_down
op_assign
op_logical_neg
(paren
id|E1000_STATUS_LU
op_amp
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
)paren
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Detects the current speed and duplex settings of the hardware.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * speed - Speed of the connection&n; * duplex - Duplex setting of the connection&n; *****************************************************************************/
r_int32
DECL|function|e1000_get_speed_and_duplex
id|e1000_get_speed_and_duplex
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
op_star
id|speed
comma
r_uint16
op_star
id|duplex
)paren
(brace
r_uint32
id|status
suffix:semicolon
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_get_speed_and_duplex&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_ge
id|e1000_82543
)paren
(brace
id|status
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|E1000_STATUS_SPEED_1000
)paren
(brace
op_star
id|speed
op_assign
id|SPEED_1000
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;1000 Mbs, &quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|E1000_STATUS_SPEED_100
)paren
(brace
op_star
id|speed
op_assign
id|SPEED_100
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;100 Mbs, &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|speed
op_assign
id|SPEED_10
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;10 Mbs, &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|E1000_STATUS_FD
)paren
(brace
op_star
id|duplex
op_assign
id|FULL_DUPLEX
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Full Duplex&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|duplex
op_assign
id|HALF_DUPLEX
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot; Half Duplex&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;1000 Mbs, Full Duplex&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|speed
op_assign
id|SPEED_1000
suffix:semicolon
op_star
id|duplex
op_assign
id|FULL_DUPLEX
suffix:semicolon
)brace
multiline_comment|/* IGP01 PHY may advertise full duplex operation after speed downgrade even&n;     * if it is operating at half duplex.  Here we set the duplex settings to&n;     * match the duplex in the link partner&squot;s capabilities.&n;     */
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_igp
op_logical_and
id|hw-&gt;speed_downgraded
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_AUTONEG_EXP
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|phy_data
op_amp
id|NWAY_ER_LP_NWAY_CAPS
)paren
)paren
(brace
op_star
id|duplex
op_assign
id|HALF_DUPLEX
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_eq
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_LP_ABILITY
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|speed
op_eq
id|SPEED_100
op_logical_and
op_logical_neg
(paren
id|phy_data
op_amp
id|NWAY_LPAR_100TX_FD_CAPS
)paren
)paren
op_logical_or
(paren
op_star
id|speed
op_eq
id|SPEED_10
op_logical_and
op_logical_neg
(paren
id|phy_data
op_amp
id|NWAY_LPAR_10T_FD_CAPS
)paren
)paren
)paren
(brace
op_star
id|duplex
op_assign
id|HALF_DUPLEX
suffix:semicolon
)brace
)brace
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Blocks until autoneg completes or times out (~4.5 seconds)&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_int32
DECL|function|e1000_wait_autoneg
id|e1000_wait_autoneg
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|i
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_wait_autoneg&quot;
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Waiting for Auto-Neg to complete.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
r_for
c_loop
(paren
id|i
op_assign
id|PHY_AUTO_NEG_TIME
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
multiline_comment|/* Read the MII Status Register and wait for Auto-Neg&n;         * Complete bit to be set.&n;         */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|phy_data
op_amp
id|MII_SR_AUTONEG_COMPLETE
)paren
(brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
id|msec_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Raises the Management Data Clock&n;*&n;* hw - Struct containing variables accessed by shared code&n;* ctrl - Device control register&squot;s current value&n;******************************************************************************/
r_static
r_void
DECL|function|e1000_raise_mdi_clk
id|e1000_raise_mdi_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|ctrl
)paren
(brace
multiline_comment|/* Raise the clock input to the Management Data Clock (by setting the MDC&n;     * bit), and then delay 10 microseconds.&n;     */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
(paren
op_star
id|ctrl
op_or
id|E1000_CTRL_MDC
)paren
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Lowers the Management Data Clock&n;*&n;* hw - Struct containing variables accessed by shared code&n;* ctrl - Device control register&squot;s current value&n;******************************************************************************/
r_static
r_void
DECL|function|e1000_lower_mdi_clk
id|e1000_lower_mdi_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|ctrl
)paren
(brace
multiline_comment|/* Lower the clock input to the Management Data Clock (by clearing the MDC&n;     * bit), and then delay 10 microseconds.&n;     */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
(paren
op_star
id|ctrl
op_amp
op_complement
id|E1000_CTRL_MDC
)paren
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Shifts data bits out to the PHY&n;*&n;* hw - Struct containing variables accessed by shared code&n;* data - Data to send out to the PHY&n;* count - Number of bits to shift out&n;*&n;* Bits are shifted out in MSB to LSB order.&n;******************************************************************************/
r_static
r_void
DECL|function|e1000_shift_out_mdi_bits
id|e1000_shift_out_mdi_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|data
comma
r_uint16
id|count
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint32
id|mask
suffix:semicolon
multiline_comment|/* We need to shift &quot;count&quot; number of bits out to the PHY. So, the value&n;     * in the &quot;data&quot; parameter will be shifted out to the PHY one bit at a&n;     * time. In order to do this, &quot;data&quot; must be broken down into bits.&n;     */
id|mask
op_assign
l_int|0x01
suffix:semicolon
id|mask
op_lshift_assign
(paren
id|count
op_minus
l_int|1
)paren
suffix:semicolon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */
id|ctrl
op_or_assign
(paren
id|E1000_CTRL_MDIO_DIR
op_or
id|E1000_CTRL_MDC_DIR
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mask
)paren
(brace
multiline_comment|/* A &quot;1&quot; is shifted out to the PHY by setting the MDIO bit to &quot;1&quot; and&n;         * then raising and lowering the Management Data Clock. A &quot;0&quot; is&n;         * shifted out to the PHY by setting the MDIO bit to &quot;0&quot; and then&n;         * raising and lowering the clock.&n;         */
r_if
c_cond
(paren
id|data
op_amp
id|mask
)paren
(brace
id|ctrl
op_or_assign
id|E1000_CTRL_MDIO
suffix:semicolon
)brace
r_else
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_MDIO
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|e1000_raise_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
id|e1000_lower_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
id|mask
op_assign
id|mask
op_rshift
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n;* Shifts data bits in from the PHY&n;*&n;* hw - Struct containing variables accessed by shared code&n;*&n;* Bits are shifted in in MSB to LSB order.&n;******************************************************************************/
r_static
r_uint16
DECL|function|e1000_shift_in_mdi_bits
id|e1000_shift_in_mdi_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
suffix:semicolon
r_uint16
id|data
op_assign
l_int|0
suffix:semicolon
r_uint8
id|i
suffix:semicolon
multiline_comment|/* In order to read a register from the PHY, we need to shift in a total&n;     * of 18 bits from the PHY. The first two bit (turnaround) times are used&n;     * to avoid contention on the MDIO pin when a read operation is performed.&n;     * These two bits are ignored by us and thrown away. Bits are &quot;shifted in&quot;&n;     * by raising the input to the Management Data Clock (setting the MDC bit),&n;     * and then reading the value of the MDIO bit.&n;     */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as input. */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_MDIO_DIR
suffix:semicolon
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_MDIO
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Raise and Lower the clock before reading in the data. This accounts for&n;     * the turnaround bits. The first clock occurred when we clocked out the&n;     * last bit of the Register Address.&n;     */
id|e1000_raise_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
id|e1000_lower_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
r_for
c_loop
(paren
id|data
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|data
op_lshift
l_int|1
suffix:semicolon
id|e1000_raise_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Check to see if we shifted in a &quot;1&quot;. */
r_if
c_cond
(paren
id|ctrl
op_amp
id|E1000_CTRL_MDIO
)paren
(brace
id|data
op_or_assign
l_int|1
suffix:semicolon
)brace
id|e1000_lower_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
)brace
id|e1000_raise_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
id|e1000_lower_mdi_clk
c_func
(paren
id|hw
comma
op_amp
id|ctrl
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n;* Reads the value from a PHY register, if the value is on a specific non zero&n;* page, sets the page first.&n;* hw - Struct containing variables accessed by shared code&n;* reg_addr - address of the PHY register to read&n;******************************************************************************/
r_int32
DECL|function|e1000_read_phy_reg
id|e1000_read_phy_reg
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|reg_addr
comma
r_uint16
op_star
id|phy_data
)paren
(brace
r_uint32
id|ret_val
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_read_phy_reg&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_igp
op_logical_and
(paren
id|reg_addr
OG
id|MAX_PHY_MULTI_PAGE_REG
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg_ex
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PAGE_SELECT
comma
(paren
r_uint16
)paren
id|reg_addr
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
id|ret_val
op_assign
id|e1000_read_phy_reg_ex
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PAGE_SELECT
op_amp
id|reg_addr
comma
id|phy_data
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
r_int32
DECL|function|e1000_read_phy_reg_ex
id|e1000_read_phy_reg_ex
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|reg_addr
comma
r_uint16
op_star
id|phy_data
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_uint32
id|mdic
op_assign
l_int|0
suffix:semicolon
r_const
r_uint32
id|phy_addr
op_assign
l_int|1
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_read_phy_reg_ex&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_addr
OG
id|MAX_PHY_REG_ADDRESS
)paren
(brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;PHY Address %d is out of range&bslash;n&quot;
comma
id|reg_addr
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PARAM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82543
)paren
(brace
multiline_comment|/* Set up Op-code, Phy Address, and register address in the MDI&n;         * Control register.  The MAC will take care of interfacing with the&n;         * PHY to retrieve the desired data.&n;         */
id|mdic
op_assign
(paren
(paren
id|reg_addr
op_lshift
id|E1000_MDIC_REG_SHIFT
)paren
op_or
(paren
id|phy_addr
op_lshift
id|E1000_MDIC_PHY_SHIFT
)paren
op_or
(paren
id|E1000_MDIC_OP_READ
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|MDIC
comma
id|mdic
)paren
suffix:semicolon
multiline_comment|/* Poll the ready bit to see if the MDI read completed */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|mdic
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MDIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mdic
op_amp
id|E1000_MDIC_READY
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mdic
op_amp
id|E1000_MDIC_READY
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MDI Read did not complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mdic
op_amp
id|E1000_MDIC_ERROR
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MDI Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
op_star
id|phy_data
op_assign
(paren
r_uint16
)paren
id|mdic
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We must first send a preamble through the MDIO pin to signal the&n;         * beginning of an MII instruction.  This is done by sending 32&n;         * consecutive &quot;1&quot; bits.&n;         */
id|e1000_shift_out_mdi_bits
c_func
(paren
id|hw
comma
id|PHY_PREAMBLE
comma
id|PHY_PREAMBLE_SIZE
)paren
suffix:semicolon
multiline_comment|/* Now combine the next few fields that are required for a read&n;         * operation.  We use this method instead of calling the&n;         * e1000_shift_out_mdi_bits routine five different times. The format of&n;         * a MII read instruction consists of a shift out of 14 bits and is&n;         * defined as follows:&n;         *    &lt;Preamble&gt;&lt;SOF&gt;&lt;Op Code&gt;&lt;Phy Addr&gt;&lt;Reg Addr&gt;&n;         * followed by a shift in of 18 bits.  This first two bits shifted in&n;         * are TurnAround bits used to avoid contention on the MDIO pin when a&n;         * READ operation is performed.  These two bits are thrown away&n;         * followed by a shift in of 16 bits which contains the desired data.&n;         */
id|mdic
op_assign
(paren
(paren
id|reg_addr
)paren
op_or
(paren
id|phy_addr
op_lshift
l_int|5
)paren
op_or
(paren
id|PHY_OP_READ
op_lshift
l_int|10
)paren
op_or
(paren
id|PHY_SOF
op_lshift
l_int|12
)paren
)paren
suffix:semicolon
id|e1000_shift_out_mdi_bits
c_func
(paren
id|hw
comma
id|mdic
comma
l_int|14
)paren
suffix:semicolon
multiline_comment|/* Now that we&squot;ve shifted out the read command to the MII, we need to&n;         * &quot;shift in&quot; the 16-bit value (18 total bits) of the requested PHY&n;         * register address.&n;         */
op_star
id|phy_data
op_assign
id|e1000_shift_in_mdi_bits
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Writes a value to a PHY register&n;*&n;* hw - Struct containing variables accessed by shared code&n;* reg_addr - address of the PHY register to write&n;* data - data to write to the PHY&n;******************************************************************************/
r_int32
DECL|function|e1000_write_phy_reg
id|e1000_write_phy_reg
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|reg_addr
comma
r_uint16
id|phy_data
)paren
(brace
r_uint32
id|ret_val
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_write_phy_reg&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_igp
op_logical_and
(paren
id|reg_addr
OG
id|MAX_PHY_MULTI_PAGE_REG
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg_ex
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PAGE_SELECT
comma
(paren
r_uint16
)paren
id|reg_addr
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
id|ret_val
op_assign
id|e1000_write_phy_reg_ex
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PAGE_SELECT
op_amp
id|reg_addr
comma
id|phy_data
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
r_int32
DECL|function|e1000_write_phy_reg_ex
id|e1000_write_phy_reg_ex
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|reg_addr
comma
r_uint16
id|phy_data
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_uint32
id|mdic
op_assign
l_int|0
suffix:semicolon
r_const
r_uint32
id|phy_addr
op_assign
l_int|1
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_write_phy_reg_ex&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_addr
OG
id|MAX_PHY_REG_ADDRESS
)paren
(brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;PHY Address %d is out of range&bslash;n&quot;
comma
id|reg_addr
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PARAM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82543
)paren
(brace
multiline_comment|/* Set up Op-code, Phy Address, register address, and data intended&n;         * for the PHY register in the MDI Control register.  The MAC will take&n;         * care of interfacing with the PHY to send the desired data.&n;         */
id|mdic
op_assign
(paren
(paren
(paren
r_uint32
)paren
id|phy_data
)paren
op_or
(paren
id|reg_addr
op_lshift
id|E1000_MDIC_REG_SHIFT
)paren
op_or
(paren
id|phy_addr
op_lshift
id|E1000_MDIC_PHY_SHIFT
)paren
op_or
(paren
id|E1000_MDIC_OP_WRITE
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|MDIC
comma
id|mdic
)paren
suffix:semicolon
multiline_comment|/* Poll the ready bit to see if the MDI read completed */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|640
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|mdic
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MDIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mdic
op_amp
id|E1000_MDIC_READY
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mdic
op_amp
id|E1000_MDIC_READY
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MDI Write did not complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* We&squot;ll need to use the SW defined pins to shift the write command&n;         * out to the PHY. We first send a preamble to the PHY to signal the&n;         * beginning of the MII instruction.  This is done by sending 32&n;         * consecutive &quot;1&quot; bits.&n;         */
id|e1000_shift_out_mdi_bits
c_func
(paren
id|hw
comma
id|PHY_PREAMBLE
comma
id|PHY_PREAMBLE_SIZE
)paren
suffix:semicolon
multiline_comment|/* Now combine the remaining required fields that will indicate a&n;         * write operation. We use this method instead of calling the&n;         * e1000_shift_out_mdi_bits routine for each field in the command. The&n;         * format of a MII write instruction is as follows:&n;         * &lt;Preamble&gt;&lt;SOF&gt;&lt;Op Code&gt;&lt;Phy Addr&gt;&lt;Reg Addr&gt;&lt;Turnaround&gt;&lt;Data&gt;.&n;         */
id|mdic
op_assign
(paren
(paren
id|PHY_TURNAROUND
)paren
op_or
(paren
id|reg_addr
op_lshift
l_int|2
)paren
op_or
(paren
id|phy_addr
op_lshift
l_int|7
)paren
op_or
(paren
id|PHY_OP_WRITE
op_lshift
l_int|12
)paren
op_or
(paren
id|PHY_SOF
op_lshift
l_int|14
)paren
)paren
suffix:semicolon
id|mdic
op_lshift_assign
l_int|16
suffix:semicolon
id|mdic
op_or_assign
(paren
r_uint32
)paren
id|phy_data
suffix:semicolon
id|e1000_shift_out_mdi_bits
c_func
(paren
id|hw
comma
id|mdic
comma
l_int|32
)paren
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Returns the PHY to the power-on reset state&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_void
DECL|function|e1000_phy_hw_reset
id|e1000_phy_hw_reset
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
comma
id|ctrl_ext
suffix:semicolon
r_uint32
id|led_ctrl
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_hw_reset&quot;
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Resetting Phy...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82543
)paren
(brace
multiline_comment|/* Read the device control register and assert the E1000_CTRL_PHY_RST&n;         * bit. Then, take it out of reset.&n;         */
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
op_or
id|E1000_CTRL_PHY_RST
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Read the Extended Device Control Register, assert the PHY_RESET_DIR&n;         * bit to put the PHY into reset. Then, take it out of reset.&n;         */
id|ctrl_ext
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL_EXT
)paren
suffix:semicolon
id|ctrl_ext
op_or_assign
id|E1000_CTRL_EXT_SDP4_DIR
suffix:semicolon
id|ctrl_ext
op_and_assign
op_complement
id|E1000_CTRL_EXT_SDP4_DATA
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL_EXT
comma
id|ctrl_ext
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|ctrl_ext
op_or_assign
id|E1000_CTRL_EXT_SDP4_DATA
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL_EXT
comma
id|ctrl_ext
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|150
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82541
)paren
op_logical_or
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82547
)paren
)paren
(brace
multiline_comment|/* Configure activity LED after PHY reset */
id|led_ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|LEDCTL
)paren
suffix:semicolon
id|led_ctrl
op_and_assign
id|IGP_ACTIVITY_LED_MASK
suffix:semicolon
id|led_ctrl
op_or_assign
(paren
id|IGP_ACTIVITY_LED_ENABLE
op_or
id|IGP_LED3_MODE
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|LEDCTL
comma
id|led_ctrl
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n;* Resets the PHY&n;*&n;* hw - Struct containing variables accessed by shared code&n;*&n;* Sets bit 15 of the MII Control regiser&n;******************************************************************************/
r_int32
DECL|function|e1000_phy_reset
id|e1000_phy_reset
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_reset&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_ne
id|e1000_82541_rev_2
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_CTRL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_or_assign
id|MII_CR_RESET
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|PHY_CTRL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|e1000_phy_hw_reset
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_igp
)paren
(brace
id|e1000_phy_init_script
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Probes the expected PHY address for known PHY IDs&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_int32
DECL|function|e1000_detect_gig_phy
id|e1000_detect_gig_phy
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_int32
id|phy_init_status
comma
id|ret_val
suffix:semicolon
r_uint16
id|phy_id_high
comma
id|phy_id_low
suffix:semicolon
id|boolean_t
id|match
op_assign
id|FALSE
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_detect_gig_phy&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the PHY ID Registers to identify which PHY is onboard. */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_ID1
comma
op_amp
id|phy_id_high
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|hw-&gt;phy_id
op_assign
(paren
r_uint32
)paren
(paren
id|phy_id_high
op_lshift
l_int|16
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_ID2
comma
op_amp
id|phy_id_low
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|hw-&gt;phy_id
op_or_assign
(paren
r_uint32
)paren
(paren
id|phy_id_low
op_amp
id|PHY_REVISION_MASK
)paren
suffix:semicolon
id|hw-&gt;phy_revision
op_assign
(paren
r_uint32
)paren
id|phy_id_low
op_amp
op_complement
id|PHY_REVISION_MASK
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;mac_type
)paren
(brace
r_case
id|e1000_82543
suffix:colon
r_if
c_cond
(paren
id|hw-&gt;phy_id
op_eq
id|M88E1000_E_PHY_ID
)paren
(brace
id|match
op_assign
id|TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|e1000_82544
suffix:colon
r_if
c_cond
(paren
id|hw-&gt;phy_id
op_eq
id|M88E1000_I_PHY_ID
)paren
(brace
id|match
op_assign
id|TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|e1000_82540
suffix:colon
r_case
id|e1000_82545
suffix:colon
r_case
id|e1000_82545_rev_3
suffix:colon
r_case
id|e1000_82546
suffix:colon
r_case
id|e1000_82546_rev_3
suffix:colon
r_if
c_cond
(paren
id|hw-&gt;phy_id
op_eq
id|M88E1011_I_PHY_ID
)paren
(brace
id|match
op_assign
id|TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|e1000_82541
suffix:colon
r_case
id|e1000_82541_rev_2
suffix:colon
r_case
id|e1000_82547
suffix:colon
r_case
id|e1000_82547_rev_2
suffix:colon
r_if
c_cond
(paren
id|hw-&gt;phy_id
op_eq
id|IGP01E1000_I_PHY_ID
)paren
(brace
id|match
op_assign
id|TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Invalid MAC type %d&bslash;n&quot;
comma
id|hw-&gt;mac_type
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
id|phy_init_status
op_assign
id|e1000_set_phy_type
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|match
)paren
op_logical_and
(paren
id|phy_init_status
op_eq
id|E1000_SUCCESS
)paren
)paren
(brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;PHY ID 0x%X detected&bslash;n&quot;
comma
id|hw-&gt;phy_id
)paren
suffix:semicolon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Invalid PHY ID 0x%X&bslash;n&quot;
comma
id|hw-&gt;phy_id
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Resets the PHY&squot;s DSP&n;*&n;* hw - Struct containing variables accessed by shared code&n;******************************************************************************/
r_static
r_int32
DECL|function|e1000_phy_reset_dsp
id|e1000_phy_reset_dsp
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_reset_dsp&quot;
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|29
comma
l_int|0x001d
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|30
comma
l_int|0x00c1
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|30
comma
l_int|0x0000
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|ret_val
op_assign
id|E1000_SUCCESS
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
)paren
(brace
suffix:semicolon
)brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Get PHY information from various PHY registers for igp PHY only.&n;*&n;* hw - Struct containing variables accessed by shared code&n;* phy_info - PHY information structure&n;******************************************************************************/
r_int32
DECL|function|e1000_phy_igp_get_info
id|e1000_phy_igp_get_info
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_struct
id|e1000_phy_info
op_star
id|phy_info
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|phy_data
comma
id|polarity
comma
id|min_length
comma
id|max_length
comma
id|average
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_igp_get_info&quot;
)paren
suffix:semicolon
multiline_comment|/* The downshift status is checked only once, after link is established,&n;     * and it stored in the hw-&gt;speed_downgraded parameter. */
id|phy_info-&gt;downshift
op_assign
id|hw-&gt;speed_downgraded
suffix:semicolon
multiline_comment|/* IGP01E1000 does not need to support it. */
id|phy_info-&gt;extended_10bt_distance
op_assign
id|e1000_10bt_ext_dist_enable_normal
suffix:semicolon
multiline_comment|/* IGP01E1000 always correct polarity reversal */
id|phy_info-&gt;polarity_correction
op_assign
id|e1000_polarity_reversal_enabled
suffix:semicolon
multiline_comment|/* Check polarity status */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_check_polarity
c_func
(paren
id|hw
comma
op_amp
id|polarity
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_info-&gt;cable_polarity
op_assign
id|polarity
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_info-&gt;mdix_mode
op_assign
(paren
id|phy_data
op_amp
id|IGP01E1000_PSSR_MDIX
)paren
op_rshift
id|IGP01E1000_PSSR_MDIX_SHIFT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|phy_data
op_amp
id|IGP01E1000_PSSR_SPEED_MASK
)paren
op_eq
id|IGP01E1000_PSSR_SPEED_1000MBPS
)paren
(brace
multiline_comment|/* Local/Remote Receiver Information are only valid at 1000 Mbps */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_info-&gt;local_rx
op_assign
(paren
id|phy_data
op_amp
id|SR_1000T_LOCAL_RX_STATUS
)paren
op_rshift
id|SR_1000T_LOCAL_RX_STATUS_SHIFT
suffix:semicolon
id|phy_info-&gt;remote_rx
op_assign
(paren
id|phy_data
op_amp
id|SR_1000T_REMOTE_RX_STATUS
)paren
op_rshift
id|SR_1000T_REMOTE_RX_STATUS_SHIFT
suffix:semicolon
multiline_comment|/* Get cable length */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_get_cable_length
c_func
(paren
id|hw
comma
op_amp
id|min_length
comma
op_amp
id|max_length
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* transalte to old method */
id|average
op_assign
(paren
id|max_length
op_plus
id|min_length
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|average
op_le
id|e1000_igp_cable_length_50
)paren
(brace
id|phy_info-&gt;cable_length
op_assign
id|e1000_cable_length_50
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|average
op_le
id|e1000_igp_cable_length_80
)paren
(brace
id|phy_info-&gt;cable_length
op_assign
id|e1000_cable_length_50_80
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|average
op_le
id|e1000_igp_cable_length_110
)paren
(brace
id|phy_info-&gt;cable_length
op_assign
id|e1000_cable_length_80_110
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|average
op_le
id|e1000_igp_cable_length_140
)paren
(brace
id|phy_info-&gt;cable_length
op_assign
id|e1000_cable_length_110_140
suffix:semicolon
)brace
r_else
id|phy_info-&gt;cable_length
op_assign
id|e1000_cable_length_140
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Get PHY information from various PHY registers fot m88 PHY only.&n;*&n;* hw - Struct containing variables accessed by shared code&n;* phy_info - PHY information structure&n;******************************************************************************/
r_int32
DECL|function|e1000_phy_m88_get_info
id|e1000_phy_m88_get_info
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_struct
id|e1000_phy_info
op_star
id|phy_info
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|phy_data
comma
id|polarity
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_m88_get_info&quot;
)paren
suffix:semicolon
multiline_comment|/* The downshift status is checked only once, after link is established,&n;     * and it stored in the hw-&gt;speed_downgraded parameter. */
id|phy_info-&gt;downshift
op_assign
id|hw-&gt;speed_downgraded
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_CTRL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_info-&gt;extended_10bt_distance
op_assign
(paren
id|phy_data
op_amp
id|M88E1000_PSCR_10BT_EXT_DIST_ENABLE
)paren
op_rshift
id|M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT
suffix:semicolon
id|phy_info-&gt;polarity_correction
op_assign
(paren
id|phy_data
op_amp
id|M88E1000_PSCR_POLARITY_REVERSAL
)paren
op_rshift
id|M88E1000_PSCR_POLARITY_REVERSAL_SHIFT
suffix:semicolon
multiline_comment|/* Check polarity status */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_check_polarity
c_func
(paren
id|hw
comma
op_amp
id|polarity
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_info-&gt;cable_polarity
op_assign
id|polarity
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_info-&gt;mdix_mode
op_assign
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_MDIX
)paren
op_rshift
id|M88E1000_PSSR_MDIX_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_1000MBS
)paren
(brace
multiline_comment|/* Cable Length Estimation and Local/Remote Receiver Informatoion&n;         * are only valid at 1000 Mbps&n;         */
id|phy_info-&gt;cable_length
op_assign
(paren
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_CABLE_LENGTH
)paren
op_rshift
id|M88E1000_PSSR_CABLE_LENGTH_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_info-&gt;local_rx
op_assign
(paren
id|phy_data
op_amp
id|SR_1000T_LOCAL_RX_STATUS
)paren
op_rshift
id|SR_1000T_LOCAL_RX_STATUS_SHIFT
suffix:semicolon
id|phy_info-&gt;remote_rx
op_assign
(paren
id|phy_data
op_amp
id|SR_1000T_REMOTE_RX_STATUS
)paren
op_rshift
id|SR_1000T_REMOTE_RX_STATUS_SHIFT
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Get PHY information from various PHY registers&n;*&n;* hw - Struct containing variables accessed by shared code&n;* phy_info - PHY information structure&n;******************************************************************************/
r_int32
DECL|function|e1000_phy_get_info
id|e1000_phy_get_info
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_struct
id|e1000_phy_info
op_star
id|phy_info
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_get_info&quot;
)paren
suffix:semicolon
id|phy_info-&gt;cable_length
op_assign
id|e1000_cable_length_undefined
suffix:semicolon
id|phy_info-&gt;extended_10bt_distance
op_assign
id|e1000_10bt_ext_dist_enable_undefined
suffix:semicolon
id|phy_info-&gt;cable_polarity
op_assign
id|e1000_rev_polarity_undefined
suffix:semicolon
id|phy_info-&gt;downshift
op_assign
id|e1000_downshift_undefined
suffix:semicolon
id|phy_info-&gt;polarity_correction
op_assign
id|e1000_polarity_reversal_undefined
suffix:semicolon
id|phy_info-&gt;mdix_mode
op_assign
id|e1000_auto_x_mode_undefined
suffix:semicolon
id|phy_info-&gt;local_rx
op_assign
id|e1000_1000t_rx_status_undefined
suffix:semicolon
id|phy_info-&gt;remote_rx
op_assign
id|e1000_1000t_rx_status_undefined
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;media_type
op_ne
id|e1000_media_type_copper
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY info is only valid for copper media&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|phy_data
op_amp
id|MII_SR_LINK_STATUS
)paren
op_ne
id|MII_SR_LINK_STATUS
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;PHY info is only valid if link is up&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_igp
)paren
(brace
r_return
id|e1000_phy_igp_get_info
c_func
(paren
id|hw
comma
id|phy_info
)paren
suffix:semicolon
)brace
r_else
r_return
id|e1000_phy_m88_get_info
c_func
(paren
id|hw
comma
id|phy_info
)paren
suffix:semicolon
)brace
r_int32
DECL|function|e1000_validate_mdi_setting
id|e1000_validate_mdi_setting
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_validate_mdi_settings&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;autoneg
op_logical_and
(paren
id|hw-&gt;mdix
op_eq
l_int|0
op_logical_or
id|hw-&gt;mdix
op_eq
l_int|3
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Invalid MDI setting detected&bslash;n&quot;
)paren
suffix:semicolon
id|hw-&gt;mdix
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
id|E1000_ERR_CONFIG
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Sets up eeprom variables in the hw struct.  Must be called after mac_type&n; * is configured.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|e1000_init_eeprom_params
id|e1000_init_eeprom_params
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_struct
id|e1000_eeprom_info
op_star
id|eeprom
op_assign
op_amp
id|hw-&gt;eeprom
suffix:semicolon
r_uint32
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
r_uint16
id|eeprom_size
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_init_eeprom_params&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;mac_type
)paren
(brace
r_case
id|e1000_82542_rev2_0
suffix:colon
r_case
id|e1000_82542_rev2_1
suffix:colon
r_case
id|e1000_82543
suffix:colon
r_case
id|e1000_82544
suffix:colon
id|eeprom-&gt;type
op_assign
id|e1000_eeprom_microwire
suffix:semicolon
id|eeprom-&gt;word_size
op_assign
l_int|64
suffix:semicolon
id|eeprom-&gt;opcode_bits
op_assign
l_int|3
suffix:semicolon
id|eeprom-&gt;address_bits
op_assign
l_int|6
suffix:semicolon
id|eeprom-&gt;delay_usec
op_assign
l_int|50
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_82540
suffix:colon
r_case
id|e1000_82545
suffix:colon
r_case
id|e1000_82545_rev_3
suffix:colon
r_case
id|e1000_82546
suffix:colon
r_case
id|e1000_82546_rev_3
suffix:colon
id|eeprom-&gt;type
op_assign
id|e1000_eeprom_microwire
suffix:semicolon
id|eeprom-&gt;opcode_bits
op_assign
l_int|3
suffix:semicolon
id|eeprom-&gt;delay_usec
op_assign
l_int|50
suffix:semicolon
r_if
c_cond
(paren
id|eecd
op_amp
id|E1000_EECD_SIZE
)paren
(brace
id|eeprom-&gt;word_size
op_assign
l_int|256
suffix:semicolon
id|eeprom-&gt;address_bits
op_assign
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|eeprom-&gt;word_size
op_assign
l_int|64
suffix:semicolon
id|eeprom-&gt;address_bits
op_assign
l_int|6
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|e1000_82541
suffix:colon
r_case
id|e1000_82541_rev_2
suffix:colon
r_case
id|e1000_82547
suffix:colon
r_case
id|e1000_82547_rev_2
suffix:colon
r_if
c_cond
(paren
id|eecd
op_amp
id|E1000_EECD_TYPE
)paren
(brace
id|eeprom-&gt;type
op_assign
id|e1000_eeprom_spi
suffix:semicolon
id|eeprom-&gt;opcode_bits
op_assign
l_int|8
suffix:semicolon
id|eeprom-&gt;delay_usec
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|eecd
op_amp
id|E1000_EECD_ADDR_BITS
)paren
(brace
id|eeprom-&gt;page_size
op_assign
l_int|32
suffix:semicolon
id|eeprom-&gt;address_bits
op_assign
l_int|16
suffix:semicolon
)brace
r_else
(brace
id|eeprom-&gt;page_size
op_assign
l_int|8
suffix:semicolon
id|eeprom-&gt;address_bits
op_assign
l_int|8
suffix:semicolon
)brace
)brace
r_else
(brace
id|eeprom-&gt;type
op_assign
id|e1000_eeprom_microwire
suffix:semicolon
id|eeprom-&gt;opcode_bits
op_assign
l_int|3
suffix:semicolon
id|eeprom-&gt;delay_usec
op_assign
l_int|50
suffix:semicolon
r_if
c_cond
(paren
id|eecd
op_amp
id|E1000_EECD_ADDR_BITS
)paren
(brace
id|eeprom-&gt;word_size
op_assign
l_int|256
suffix:semicolon
id|eeprom-&gt;address_bits
op_assign
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|eeprom-&gt;word_size
op_assign
l_int|64
suffix:semicolon
id|eeprom-&gt;address_bits
op_assign
l_int|6
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|eeprom-&gt;type
op_assign
id|e1000_eeprom_spi
suffix:semicolon
id|eeprom-&gt;opcode_bits
op_assign
l_int|8
suffix:semicolon
id|eeprom-&gt;delay_usec
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|eecd
op_amp
id|E1000_EECD_ADDR_BITS
)paren
(brace
id|eeprom-&gt;page_size
op_assign
l_int|32
suffix:semicolon
id|eeprom-&gt;address_bits
op_assign
l_int|16
suffix:semicolon
)brace
r_else
(brace
id|eeprom-&gt;page_size
op_assign
l_int|8
suffix:semicolon
id|eeprom-&gt;address_bits
op_assign
l_int|8
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eeprom-&gt;type
op_eq
id|e1000_eeprom_spi
)paren
(brace
id|eeprom-&gt;word_size
op_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
id|EEPROM_CFG
comma
l_int|1
comma
op_amp
id|eeprom_size
)paren
op_eq
l_int|0
)paren
(brace
id|eeprom_size
op_and_assign
id|EEPROM_SIZE_MASK
suffix:semicolon
r_switch
c_cond
(paren
id|eeprom_size
)paren
(brace
r_case
id|EEPROM_SIZE_16KB
suffix:colon
id|eeprom-&gt;word_size
op_assign
l_int|8192
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EEPROM_SIZE_8KB
suffix:colon
id|eeprom-&gt;word_size
op_assign
l_int|4096
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EEPROM_SIZE_4KB
suffix:colon
id|eeprom-&gt;word_size
op_assign
l_int|2048
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EEPROM_SIZE_2KB
suffix:colon
id|eeprom-&gt;word_size
op_assign
l_int|1024
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EEPROM_SIZE_1KB
suffix:colon
id|eeprom-&gt;word_size
op_assign
l_int|512
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EEPROM_SIZE_512B
suffix:colon
id|eeprom-&gt;word_size
op_assign
l_int|256
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EEPROM_SIZE_128B
suffix:colon
r_default
suffix:colon
id|eeprom-&gt;word_size
op_assign
l_int|64
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/******************************************************************************&n; * Raises the EEPROM&squot;s clock input.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * eecd - EECD&squot;s current value&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_raise_ee_clk
id|e1000_raise_ee_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|eecd
)paren
(brace
multiline_comment|/* Raise the clock input to the EEPROM (by setting the SK bit), and then&n;     * wait &lt;delay&gt; microseconds.&n;     */
op_star
id|eecd
op_assign
op_star
id|eecd
op_or
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
op_star
id|eecd
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|hw-&gt;eeprom.delay_usec
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Lowers the EEPROM&squot;s clock input.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * eecd - EECD&squot;s current value&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_lower_ee_clk
id|e1000_lower_ee_clk
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|eecd
)paren
(brace
multiline_comment|/* Lower the clock input to the EEPROM (by clearing the SK bit), and then&n;     * wait 50 microseconds.&n;     */
op_star
id|eecd
op_assign
op_star
id|eecd
op_amp
op_complement
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
op_star
id|eecd
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|hw-&gt;eeprom.delay_usec
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Shift data bits out to the EEPROM.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * data - data to send to the EEPROM&n; * count - number of bits to shift out&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_shift_out_ee_bits
id|e1000_shift_out_ee_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|data
comma
r_uint16
id|count
)paren
(brace
r_struct
id|e1000_eeprom_info
op_star
id|eeprom
op_assign
op_amp
id|hw-&gt;eeprom
suffix:semicolon
r_uint32
id|eecd
suffix:semicolon
r_uint32
id|mask
suffix:semicolon
multiline_comment|/* We need to shift &quot;count&quot; bits out to the EEPROM. So, value in the&n;     * &quot;data&quot; parameter will be shifted out to the EEPROM one bit at a time.&n;     * In order to do this, &quot;data&quot; must be broken down into bits.&n;     */
id|mask
op_assign
l_int|0x01
op_lshift
(paren
id|count
op_minus
l_int|1
)paren
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom-&gt;type
op_eq
id|e1000_eeprom_microwire
)paren
(brace
id|eecd
op_and_assign
op_complement
id|E1000_EECD_DO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|eeprom-&gt;type
op_eq
id|e1000_eeprom_spi
)paren
(brace
id|eecd
op_or_assign
id|E1000_EECD_DO
suffix:semicolon
)brace
r_do
(brace
multiline_comment|/* A &quot;1&quot; is shifted out to the EEPROM by setting bit &quot;DI&quot; to a &quot;1&quot;,&n;         * and then raising and then lowering the clock (the SK bit controls&n;         * the clock input to the EEPROM).  A &quot;0&quot; is shifted out to the EEPROM&n;         * by setting &quot;DI&quot; to &quot;0&quot; and then raising and then lowering the clock.&n;         */
id|eecd
op_and_assign
op_complement
id|E1000_EECD_DI
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|mask
)paren
(brace
id|eecd
op_or_assign
id|E1000_EECD_DI
suffix:semicolon
)brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|eeprom-&gt;delay_usec
)paren
suffix:semicolon
id|e1000_raise_ee_clk
c_func
(paren
id|hw
comma
op_amp
id|eecd
)paren
suffix:semicolon
id|e1000_lower_ee_clk
c_func
(paren
id|hw
comma
op_amp
id|eecd
)paren
suffix:semicolon
id|mask
op_assign
id|mask
op_rshift
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mask
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* We leave the &quot;DI&quot; bit set to &quot;0&quot; when we leave this routine. */
id|eecd
op_and_assign
op_complement
id|E1000_EECD_DI
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Shift data bits in from the EEPROM&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_static
r_uint16
DECL|function|e1000_shift_in_ee_bits
id|e1000_shift_in_ee_bits
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|count
)paren
(brace
r_uint32
id|eecd
suffix:semicolon
r_uint32
id|i
suffix:semicolon
r_uint16
id|data
suffix:semicolon
multiline_comment|/* In order to read a register from the EEPROM, we need to shift &squot;count&squot;&n;     * bits in from the EEPROM. Bits are &quot;shifted in&quot; by raising the clock&n;     * input to the EEPROM (setting the SK bit), and then reading the value of&n;     * the &quot;DO&quot; bit.  During this &quot;shifting in&quot; process the &quot;DI&quot; bit should&n;     * always be clear.&n;     */
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
id|eecd
op_and_assign
op_complement
(paren
id|E1000_EECD_DO
op_or
id|E1000_EECD_DI
)paren
suffix:semicolon
id|data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|data
op_lshift
l_int|1
suffix:semicolon
id|e1000_raise_ee_clk
c_func
(paren
id|hw
comma
op_amp
id|eecd
)paren
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
id|eecd
op_and_assign
op_complement
(paren
id|E1000_EECD_DI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eecd
op_amp
id|E1000_EECD_DO
)paren
(brace
id|data
op_or_assign
l_int|1
suffix:semicolon
)brace
id|e1000_lower_ee_clk
c_func
(paren
id|hw
comma
op_amp
id|eecd
)paren
suffix:semicolon
)brace
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Prepares EEPROM for access&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This&n; * function should be called before issuing a command to the EEPROM.&n; *****************************************************************************/
r_static
r_int32
DECL|function|e1000_acquire_eeprom
id|e1000_acquire_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_struct
id|e1000_eeprom_info
op_star
id|eeprom
op_assign
op_amp
id|hw-&gt;eeprom
suffix:semicolon
r_uint32
id|eecd
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_acquire_eeprom&quot;
)paren
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
multiline_comment|/* Request EEPROM Access */
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82544
)paren
(brace
id|eecd
op_or_assign
id|E1000_EECD_REQ
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
op_logical_neg
(paren
id|eecd
op_amp
id|E1000_EECD_GNT
)paren
)paren
op_logical_and
(paren
id|i
OL
id|E1000_EEPROM_GRANT_ATTEMPTS
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|eecd
op_amp
id|E1000_EECD_GNT
)paren
)paren
(brace
id|eecd
op_and_assign
op_complement
id|E1000_EECD_REQ
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Could not acquire EEPROM grant&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
)brace
multiline_comment|/* Setup EEPROM for Read/Write */
r_if
c_cond
(paren
id|eeprom-&gt;type
op_eq
id|e1000_eeprom_microwire
)paren
(brace
multiline_comment|/* Clear SK and DI */
id|eecd
op_and_assign
op_complement
(paren
id|E1000_EECD_DI
op_or
id|E1000_EECD_SK
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
multiline_comment|/* Set CS */
id|eecd
op_or_assign
id|E1000_EECD_CS
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|eeprom-&gt;type
op_eq
id|e1000_eeprom_spi
)paren
(brace
multiline_comment|/* Clear SK and CS */
id|eecd
op_and_assign
op_complement
(paren
id|E1000_EECD_CS
op_or
id|E1000_EECD_SK
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Returns EEPROM to a &quot;standby&quot; state&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_standby_eeprom
id|e1000_standby_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_struct
id|e1000_eeprom_info
op_star
id|eeprom
op_assign
op_amp
id|hw-&gt;eeprom
suffix:semicolon
r_uint32
id|eecd
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom-&gt;type
op_eq
id|e1000_eeprom_microwire
)paren
(brace
id|eecd
op_and_assign
op_complement
(paren
id|E1000_EECD_CS
op_or
id|E1000_EECD_SK
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|eeprom-&gt;delay_usec
)paren
suffix:semicolon
multiline_comment|/* Clock high */
id|eecd
op_or_assign
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|eeprom-&gt;delay_usec
)paren
suffix:semicolon
multiline_comment|/* Select EEPROM */
id|eecd
op_or_assign
id|E1000_EECD_CS
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|eeprom-&gt;delay_usec
)paren
suffix:semicolon
multiline_comment|/* Clock low */
id|eecd
op_and_assign
op_complement
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|eeprom-&gt;delay_usec
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|eeprom-&gt;type
op_eq
id|e1000_eeprom_spi
)paren
(brace
multiline_comment|/* Toggle CS to flush commands */
id|eecd
op_or_assign
id|E1000_EECD_CS
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|eeprom-&gt;delay_usec
)paren
suffix:semicolon
id|eecd
op_and_assign
op_complement
id|E1000_EECD_CS
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|eeprom-&gt;delay_usec
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Terminates a command by inverting the EEPROM&squot;s chip select pin&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_static
r_void
DECL|function|e1000_release_eeprom
id|e1000_release_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|eecd
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_release_eeprom&quot;
)paren
suffix:semicolon
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;eeprom.type
op_eq
id|e1000_eeprom_spi
)paren
(brace
id|eecd
op_or_assign
id|E1000_EECD_CS
suffix:semicolon
multiline_comment|/* Pull CS high */
id|eecd
op_and_assign
op_complement
id|E1000_EECD_SK
suffix:semicolon
multiline_comment|/* Lower SCK */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|hw-&gt;eeprom.delay_usec
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hw-&gt;eeprom.type
op_eq
id|e1000_eeprom_microwire
)paren
(brace
multiline_comment|/* cleanup eeprom */
multiline_comment|/* CS on Microwire is active-high */
id|eecd
op_and_assign
op_complement
(paren
id|E1000_EECD_CS
op_or
id|E1000_EECD_DI
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
multiline_comment|/* Rising edge of clock */
id|eecd
op_or_assign
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|hw-&gt;eeprom.delay_usec
)paren
suffix:semicolon
multiline_comment|/* Falling edge of clock */
id|eecd
op_and_assign
op_complement
id|E1000_EECD_SK
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
id|E1000_WRITE_FLUSH
c_func
(paren
id|hw
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|hw-&gt;eeprom.delay_usec
)paren
suffix:semicolon
)brace
multiline_comment|/* Stop requesting EEPROM access */
r_if
c_cond
(paren
id|hw-&gt;mac_type
OG
id|e1000_82544
)paren
(brace
id|eecd
op_and_assign
op_complement
id|E1000_EECD_REQ
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|EECD
comma
id|eecd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Reads a 16 bit word from the EEPROM.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_spi_eeprom_ready
id|e1000_spi_eeprom_ready
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint16
id|retry_count
op_assign
l_int|0
suffix:semicolon
r_uint8
id|spi_stat_reg
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_spi_eeprom_ready&quot;
)paren
suffix:semicolon
multiline_comment|/* Read &quot;Status Register&quot; repeatedly until the LSB is cleared.  The&n;     * EEPROM will signal that the command has been completed by clearing&n;     * bit 0 of the internal status register.  If it&squot;s not cleared within&n;     * 5 milliseconds, then error out.&n;     */
id|retry_count
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|EEPROM_RDSR_OPCODE_SPI
comma
id|hw-&gt;eeprom.opcode_bits
)paren
suffix:semicolon
id|spi_stat_reg
op_assign
(paren
r_uint8
)paren
id|e1000_shift_in_ee_bits
c_func
(paren
id|hw
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|spi_stat_reg
op_amp
id|EEPROM_STATUS_RDY_SPI
)paren
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|retry_count
op_add_assign
l_int|5
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retry_count
OL
id|EEPROM_MAX_RETRY_SPI
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and&n;     * only 0-5mSec on 5V devices)&n;     */
r_if
c_cond
(paren
id|retry_count
op_ge
id|EEPROM_MAX_RETRY_SPI
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;SPI EEPROM Status error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Reads a 16 bit word from the EEPROM.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * offset - offset of  word in the EEPROM to read&n; * data - word read from the EEPROM&n; * words - number of words to read&n; *****************************************************************************/
r_int32
DECL|function|e1000_read_eeprom
id|e1000_read_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|offset
comma
r_uint16
id|words
comma
r_uint16
op_star
id|data
)paren
(brace
r_struct
id|e1000_eeprom_info
op_star
id|eeprom
op_assign
op_amp
id|hw-&gt;eeprom
suffix:semicolon
r_uint32
id|i
op_assign
l_int|0
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_read_eeprom&quot;
)paren
suffix:semicolon
multiline_comment|/* A check for invalid values:  offset too large, too many words, and not&n;     * enough words.&n;     */
r_if
c_cond
(paren
(paren
id|offset
OG
id|eeprom-&gt;word_size
)paren
op_logical_or
(paren
id|words
OG
id|eeprom-&gt;word_size
op_minus
id|offset
)paren
op_logical_or
(paren
id|words
op_eq
l_int|0
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;&bslash;&quot;words&bslash;&quot; parameter out of bounds&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
multiline_comment|/* Prepare the EEPROM for reading  */
r_if
c_cond
(paren
id|e1000_acquire_eeprom
c_func
(paren
id|hw
)paren
op_ne
id|E1000_SUCCESS
)paren
(brace
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eeprom-&gt;type
op_eq
id|e1000_eeprom_spi
)paren
(brace
r_uint16
id|word_in
suffix:semicolon
r_uint8
id|read_opcode
op_assign
id|EEPROM_READ_OPCODE_SPI
suffix:semicolon
r_if
c_cond
(paren
id|e1000_spi_eeprom_ready
c_func
(paren
id|hw
)paren
)paren
(brace
id|e1000_release_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
id|e1000_standby_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Some SPI eeproms use the 8th address bit embedded in the opcode */
r_if
c_cond
(paren
(paren
id|eeprom-&gt;address_bits
op_eq
l_int|8
)paren
op_logical_and
(paren
id|offset
op_ge
l_int|128
)paren
)paren
(brace
id|read_opcode
op_or_assign
id|EEPROM_A8_OPCODE_SPI
suffix:semicolon
)brace
multiline_comment|/* Send the READ command (opcode + addr)  */
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|read_opcode
comma
id|eeprom-&gt;opcode_bits
)paren
suffix:semicolon
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
(paren
r_uint16
)paren
(paren
id|offset
op_star
l_int|2
)paren
comma
id|eeprom-&gt;address_bits
)paren
suffix:semicolon
multiline_comment|/* Read the data.  The address of the eeprom internally increments with&n;         * each byte (spi) being read, saving on the overhead of eeprom setup&n;         * and tear-down.  The address counter will roll over if reading beyond&n;         * the size of the eeprom, thus allowing the entire memory to be read&n;         * starting from any offset. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|words
suffix:semicolon
id|i
op_increment
)paren
(brace
id|word_in
op_assign
id|e1000_shift_in_ee_bits
c_func
(paren
id|hw
comma
l_int|16
)paren
suffix:semicolon
id|data
(braket
id|i
)braket
op_assign
(paren
id|word_in
op_rshift
l_int|8
)paren
op_or
(paren
id|word_in
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|eeprom-&gt;type
op_eq
id|e1000_eeprom_microwire
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|words
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Send the READ command (opcode + addr)  */
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|EEPROM_READ_OPCODE_MICROWIRE
comma
id|eeprom-&gt;opcode_bits
)paren
suffix:semicolon
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
(paren
r_uint16
)paren
(paren
id|offset
op_plus
id|i
)paren
comma
id|eeprom-&gt;address_bits
)paren
suffix:semicolon
multiline_comment|/* Read the data.  For microwire, each word requires the overhead&n;             * of eeprom setup and tear-down. */
id|data
(braket
id|i
)braket
op_assign
id|e1000_shift_in_ee_bits
c_func
(paren
id|hw
comma
l_int|16
)paren
suffix:semicolon
id|e1000_standby_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* End this read operation */
id|e1000_release_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Verifies that the EEPROM has a valid checksum&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Reads the first 64 16 bit words of the EEPROM and sums the values read.&n; * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM&squot;s checksum is&n; * valid.&n; *****************************************************************************/
r_int32
DECL|function|e1000_validate_eeprom_checksum
id|e1000_validate_eeprom_checksum
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint16
id|checksum
op_assign
l_int|0
suffix:semicolon
r_uint16
id|i
comma
id|eeprom_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_validate_eeprom_checksum&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|EEPROM_CHECKSUM_REG
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
id|i
comma
l_int|1
comma
op_amp
id|eeprom_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
id|checksum
op_add_assign
id|eeprom_data
suffix:semicolon
)brace
r_if
c_cond
(paren
id|checksum
op_eq
(paren
r_uint16
)paren
id|EEPROM_SUM
)paren
(brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Checksum Invalid&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Calculates the EEPROM checksum and writes it to the EEPROM&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Sums the first 63 16 bit words of the EEPROM. Subtracts the sum from 0xBABA.&n; * Writes the difference to word offset 63 of the EEPROM.&n; *****************************************************************************/
r_int32
DECL|function|e1000_update_eeprom_checksum
id|e1000_update_eeprom_checksum
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint16
id|checksum
op_assign
l_int|0
suffix:semicolon
r_uint16
id|i
comma
id|eeprom_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_update_eeprom_checksum&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EEPROM_CHECKSUM_REG
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
id|i
comma
l_int|1
comma
op_amp
id|eeprom_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
id|checksum
op_add_assign
id|eeprom_data
suffix:semicolon
)brace
id|checksum
op_assign
(paren
r_uint16
)paren
id|EEPROM_SUM
op_minus
id|checksum
suffix:semicolon
r_if
c_cond
(paren
id|e1000_write_eeprom
c_func
(paren
id|hw
comma
id|EEPROM_CHECKSUM_REG
comma
l_int|1
comma
op_amp
id|checksum
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Write Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Parent function for writing words to the different EEPROM types.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * offset - offset within the EEPROM to be written to&n; * words - number of words to write&n; * data - 16 bit word to be written to the EEPROM&n; *&n; * If e1000_update_eeprom_checksum is not called after this function, the&n; * EEPROM will most likely contain an invalid checksum.&n; *****************************************************************************/
r_int32
DECL|function|e1000_write_eeprom
id|e1000_write_eeprom
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|offset
comma
r_uint16
id|words
comma
r_uint16
op_star
id|data
)paren
(brace
r_struct
id|e1000_eeprom_info
op_star
id|eeprom
op_assign
op_amp
id|hw-&gt;eeprom
suffix:semicolon
r_int32
id|status
op_assign
l_int|0
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_write_eeprom&quot;
)paren
suffix:semicolon
multiline_comment|/* A check for invalid values:  offset too large, too many words, and not&n;     * enough words.&n;     */
r_if
c_cond
(paren
(paren
id|offset
OG
id|eeprom-&gt;word_size
)paren
op_logical_or
(paren
id|words
OG
id|eeprom-&gt;word_size
op_minus
id|offset
)paren
op_logical_or
(paren
id|words
op_eq
l_int|0
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;&bslash;&quot;words&bslash;&quot; parameter out of bounds&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
multiline_comment|/* Prepare the EEPROM for writing  */
r_if
c_cond
(paren
id|e1000_acquire_eeprom
c_func
(paren
id|hw
)paren
op_ne
id|E1000_SUCCESS
)paren
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
r_if
c_cond
(paren
id|eeprom-&gt;type
op_eq
id|e1000_eeprom_microwire
)paren
(brace
id|status
op_assign
id|e1000_write_eeprom_microwire
c_func
(paren
id|hw
comma
id|offset
comma
id|words
comma
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
id|e1000_write_eeprom_spi
c_func
(paren
id|hw
comma
id|offset
comma
id|words
comma
id|data
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/* Done with writing */
id|e1000_release_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Writes a 16 bit word to a given offset in an SPI EEPROM.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * offset - offset within the EEPROM to be written to&n; * words - number of words to write&n; * data - pointer to array of 8 bit words to be written to the EEPROM&n; *&n; *****************************************************************************/
r_int32
DECL|function|e1000_write_eeprom_spi
id|e1000_write_eeprom_spi
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|offset
comma
r_uint16
id|words
comma
r_uint16
op_star
id|data
)paren
(brace
r_struct
id|e1000_eeprom_info
op_star
id|eeprom
op_assign
op_amp
id|hw-&gt;eeprom
suffix:semicolon
r_uint16
id|widx
op_assign
l_int|0
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_write_eeprom_spi&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|widx
OL
id|words
)paren
(brace
r_uint8
id|write_opcode
op_assign
id|EEPROM_WRITE_OPCODE_SPI
suffix:semicolon
r_if
c_cond
(paren
id|e1000_spi_eeprom_ready
c_func
(paren
id|hw
)paren
)paren
(brace
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
id|e1000_standby_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/*  Send the WRITE ENABLE command (8 bit opcode )  */
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|EEPROM_WREN_OPCODE_SPI
comma
id|eeprom-&gt;opcode_bits
)paren
suffix:semicolon
id|e1000_standby_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Some SPI eeproms use the 8th address bit embedded in the opcode */
r_if
c_cond
(paren
(paren
id|eeprom-&gt;address_bits
op_eq
l_int|8
)paren
op_logical_and
(paren
id|offset
op_ge
l_int|128
)paren
)paren
(brace
id|write_opcode
op_or_assign
id|EEPROM_A8_OPCODE_SPI
suffix:semicolon
)brace
multiline_comment|/* Send the Write command (8-bit opcode + addr) */
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|write_opcode
comma
id|eeprom-&gt;opcode_bits
)paren
suffix:semicolon
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
(paren
r_uint16
)paren
(paren
(paren
id|offset
op_plus
id|widx
)paren
op_star
l_int|2
)paren
comma
id|eeprom-&gt;address_bits
)paren
suffix:semicolon
multiline_comment|/* Send the data */
multiline_comment|/* Loop to allow for up to whole page write (32 bytes) of eeprom */
r_while
c_loop
(paren
id|widx
OL
id|words
)paren
(brace
r_uint16
id|word_out
op_assign
id|data
(braket
id|widx
)braket
suffix:semicolon
id|word_out
op_assign
(paren
id|word_out
op_rshift
l_int|8
)paren
op_or
(paren
id|word_out
op_lshift
l_int|8
)paren
suffix:semicolon
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|word_out
comma
l_int|16
)paren
suffix:semicolon
id|widx
op_increment
suffix:semicolon
multiline_comment|/* Some larger eeprom sizes are capable of a 32-byte PAGE WRITE&n;             * operation, while the smaller eeproms are capable of an 8-byte&n;             * PAGE WRITE operation.  Break the inner loop to pass new address&n;             */
r_if
c_cond
(paren
(paren
(paren
(paren
id|offset
op_plus
id|widx
)paren
op_star
l_int|2
)paren
op_mod
id|eeprom-&gt;page_size
)paren
op_eq
l_int|0
)paren
(brace
id|e1000_standby_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Writes a 16 bit word to a given offset in a Microwire EEPROM.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * offset - offset within the EEPROM to be written to&n; * words - number of words to write&n; * data - pointer to array of 16 bit words to be written to the EEPROM&n; *&n; *****************************************************************************/
r_int32
DECL|function|e1000_write_eeprom_microwire
id|e1000_write_eeprom_microwire
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
id|offset
comma
r_uint16
id|words
comma
r_uint16
op_star
id|data
)paren
(brace
r_struct
id|e1000_eeprom_info
op_star
id|eeprom
op_assign
op_amp
id|hw-&gt;eeprom
suffix:semicolon
r_uint32
id|eecd
suffix:semicolon
r_uint16
id|words_written
op_assign
l_int|0
suffix:semicolon
r_uint16
id|i
op_assign
l_int|0
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_write_eeprom_microwire&quot;
)paren
suffix:semicolon
multiline_comment|/* Send the write enable command to the EEPROM (3-bit opcode plus&n;     * 6/8-bit dummy address beginning with 11).  It&squot;s less work to include&n;     * the 11 of the dummy address as part of the opcode than it is to shift&n;     * it over the correct number of bits for the address.  This puts the&n;     * EEPROM into write/erase mode.&n;     */
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|EEPROM_EWEN_OPCODE_MICROWIRE
comma
(paren
r_uint16
)paren
(paren
id|eeprom-&gt;opcode_bits
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
l_int|0
comma
(paren
r_uint16
)paren
(paren
id|eeprom-&gt;address_bits
op_minus
l_int|2
)paren
)paren
suffix:semicolon
multiline_comment|/* Prepare the EEPROM */
id|e1000_standby_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
r_while
c_loop
(paren
id|words_written
OL
id|words
)paren
(brace
multiline_comment|/* Send the Write command (3-bit opcode + addr) */
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|EEPROM_WRITE_OPCODE_MICROWIRE
comma
id|eeprom-&gt;opcode_bits
)paren
suffix:semicolon
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
(paren
r_uint16
)paren
(paren
id|offset
op_plus
id|words_written
)paren
comma
id|eeprom-&gt;address_bits
)paren
suffix:semicolon
multiline_comment|/* Send the data */
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|data
(braket
id|words_written
)braket
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Toggle the CS line.  This in effect tells the EEPROM to execute&n;         * the previous command.&n;         */
id|e1000_standby_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* Read DO repeatedly until it is high (equal to &squot;1&squot;).  The EEPROM will&n;         * signal that the command has been completed by raising the DO signal.&n;         * If DO does not go high in 10 milliseconds, then error out.&n;         */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|200
suffix:semicolon
id|i
op_increment
)paren
(brace
id|eecd
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|EECD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eecd
op_amp
id|E1000_EECD_DO
)paren
(brace
r_break
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|200
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Write did not complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
multiline_comment|/* Recover from write */
id|e1000_standby_eeprom
c_func
(paren
id|hw
)paren
suffix:semicolon
id|words_written
op_increment
suffix:semicolon
)brace
multiline_comment|/* Send the write disable command to the EEPROM (3-bit opcode plus&n;     * 6/8-bit dummy address beginning with 10).  It&squot;s less work to include&n;     * the 10 of the dummy address as part of the opcode than it is to shift&n;     * it over the correct number of bits for the address.  This takes the&n;     * EEPROM out of write/erase mode.&n;     */
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
id|EEPROM_EWDS_OPCODE_MICROWIRE
comma
(paren
r_uint16
)paren
(paren
id|eeprom-&gt;opcode_bits
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|e1000_shift_out_ee_bits
c_func
(paren
id|hw
comma
l_int|0
comma
(paren
r_uint16
)paren
(paren
id|eeprom-&gt;address_bits
op_minus
l_int|2
)paren
)paren
suffix:semicolon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Reads the adapter&squot;s part number from the EEPROM&n; *&n; * hw - Struct containing variables accessed by shared code&n; * part_num - Adapter&squot;s part number&n; *****************************************************************************/
r_int32
DECL|function|e1000_read_part_num
id|e1000_read_part_num
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
op_star
id|part_num
)paren
(brace
r_uint16
id|offset
op_assign
id|EEPROM_PBA_BYTE_1
suffix:semicolon
r_uint16
id|eeprom_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_read_part_num&quot;
)paren
suffix:semicolon
multiline_comment|/* Get word 0 from EEPROM */
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
id|offset
comma
l_int|1
comma
op_amp
id|eeprom_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
multiline_comment|/* Save word 0 in upper half of part_num */
op_star
id|part_num
op_assign
(paren
r_uint32
)paren
(paren
id|eeprom_data
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Get word 1 from EEPROM */
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
op_increment
id|offset
comma
l_int|1
comma
op_amp
id|eeprom_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
multiline_comment|/* Save word 1 in lower half of part_num */
op_star
id|part_num
op_or_assign
id|eeprom_data
suffix:semicolon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Reads the adapter&squot;s MAC address from the EEPROM and inverts the LSB for the&n; * second function of dual function devices&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_read_mac_addr
id|e1000_read_mac_addr
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint16
id|offset
suffix:semicolon
r_uint16
id|eeprom_data
comma
id|i
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_read_mac_addr&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NODE_ADDRESS_SIZE
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|offset
op_assign
id|i
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
id|offset
comma
l_int|1
comma
op_amp
id|eeprom_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
id|hw-&gt;perm_mac_addr
(braket
id|i
)braket
op_assign
(paren
r_uint8
)paren
(paren
id|eeprom_data
op_amp
l_int|0x00FF
)paren
suffix:semicolon
id|hw-&gt;perm_mac_addr
(braket
id|i
op_plus
l_int|1
)braket
op_assign
(paren
r_uint8
)paren
(paren
id|eeprom_data
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82546
)paren
op_logical_or
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82546_rev_3
)paren
)paren
op_logical_and
(paren
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
op_amp
id|E1000_STATUS_FUNC_1
)paren
)paren
(brace
id|hw-&gt;perm_mac_addr
(braket
l_int|5
)braket
op_xor_assign
l_int|0x01
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NODE_ADDRESS_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hw-&gt;mac_addr
(braket
id|i
)braket
op_assign
id|hw-&gt;perm_mac_addr
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Initializes receive address filters.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Places the MAC address in receive address register 0 and clears the rest&n; * of the receive addresss registers. Clears the multicast table. Assumes&n; * the receiver is in reset when the routine is called.&n; *****************************************************************************/
r_void
DECL|function|e1000_init_rx_addrs
id|e1000_init_rx_addrs
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|i
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_init_rx_addrs&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup the receive address. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Programming MAC Address into RAR[0]&bslash;n&quot;
)paren
suffix:semicolon
id|e1000_rar_set
c_func
(paren
id|hw
comma
id|hw-&gt;mac_addr
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Zero out the other 15 receive addresses. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Clearing RAR[1-15]&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|E1000_RAR_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
id|i
op_lshift
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
(paren
id|i
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Updates the MAC&squot;s list of multicast addresses.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * mc_addr_list - the list of new multicast addresses&n; * mc_addr_count - number of addresses&n; * pad - number of bytes between addresses in the list&n; * rar_used_count - offset where to start adding mc addresses into the RAR&squot;s&n; *&n; * The given list replaces any existing list. Clears the last 15 receive&n; * address registers and the multicast table. Uses receive address registers&n; * for the first 15 multicast addresses, and hashes the rest into the&n; * multicast table.&n; *****************************************************************************/
r_void
DECL|function|e1000_mc_addr_list_update
id|e1000_mc_addr_list_update
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint8
op_star
id|mc_addr_list
comma
r_uint32
id|mc_addr_count
comma
r_uint32
id|pad
comma
r_uint32
id|rar_used_count
)paren
(brace
r_uint32
id|hash_value
suffix:semicolon
r_uint32
id|i
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_mc_addr_list_update&quot;
)paren
suffix:semicolon
multiline_comment|/* Set the new number of MC addresses that we are being requested to use. */
id|hw-&gt;num_mc_addrs
op_assign
id|mc_addr_count
suffix:semicolon
multiline_comment|/* Clear RAR[1-15] */
id|DEBUGOUT
c_func
(paren
l_string|&quot; Clearing RAR[1-15]&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rar_used_count
suffix:semicolon
id|i
OL
id|E1000_RAR_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
id|i
op_lshift
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
(paren
id|i
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear the MTA */
id|DEBUGOUT
c_func
(paren
l_string|&quot; Clearing MTA&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|E1000_NUM_MTA_REGISTERS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Add the new addresses */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mc_addr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot; Adding the multicast addresses:&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUGOUT7
c_func
(paren
l_string|&quot; MC Addr #%d =%.2X %.2X %.2X %.2X %.2X %.2X&bslash;n&quot;
comma
id|i
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|1
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|2
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|3
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|4
)braket
comma
id|mc_addr_list
(braket
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
op_plus
l_int|5
)braket
)paren
suffix:semicolon
id|hash_value
op_assign
id|e1000_hash_mc_addr
c_func
(paren
id|hw
comma
id|mc_addr_list
op_plus
(paren
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
)paren
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot; Hash value = 0x%03X&bslash;n&quot;
comma
id|hash_value
)paren
suffix:semicolon
multiline_comment|/* Place this multicast address in the RAR if there is room, *&n;         * else put it in the MTA&n;         */
r_if
c_cond
(paren
id|rar_used_count
OL
id|E1000_RAR_ENTRIES
)paren
(brace
id|e1000_rar_set
c_func
(paren
id|hw
comma
id|mc_addr_list
op_plus
(paren
id|i
op_star
(paren
id|ETH_LENGTH_OF_ADDRESS
op_plus
id|pad
)paren
)paren
comma
id|rar_used_count
)paren
suffix:semicolon
id|rar_used_count
op_increment
suffix:semicolon
)brace
r_else
(brace
id|e1000_mta_set
c_func
(paren
id|hw
comma
id|hash_value
)paren
suffix:semicolon
)brace
)brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;MC Update Complete&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Hashes an address to determine its location in the multicast table&n; *&n; * hw - Struct containing variables accessed by shared code&n; * mc_addr - the multicast address to hash&n; *****************************************************************************/
r_uint32
DECL|function|e1000_hash_mc_addr
id|e1000_hash_mc_addr
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint8
op_star
id|mc_addr
)paren
(brace
r_uint32
id|hash_value
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The portion of the address that is used for the hash table is&n;     * determined by the mc_filter_type setting.&n;     */
r_switch
c_cond
(paren
id|hw-&gt;mc_filter_type
)paren
(brace
multiline_comment|/* [0] [1] [2] [3] [4] [5]&n;     * 01  AA  00  12  34  56&n;     * LSB                 MSB&n;     */
r_case
l_int|0
suffix:colon
multiline_comment|/* [47:36] i.e. 0x563 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
op_rshift
l_int|4
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* [46:35] i.e. 0xAC6 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
op_rshift
l_int|3
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|5
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* [45:34] i.e. 0x5D8 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
op_rshift
l_int|2
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|6
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* [43:32] i.e. 0x634 for above example address */
id|hash_value
op_assign
(paren
(paren
id|mc_addr
(braket
l_int|4
)braket
)paren
op_or
(paren
(paren
(paren
r_uint16
)paren
id|mc_addr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hash_value
op_and_assign
l_int|0xFFF
suffix:semicolon
r_return
id|hash_value
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Sets the bit in the multicast table corresponding to the hash value.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * hash_value - Multicast address hash value&n; *****************************************************************************/
r_void
DECL|function|e1000_mta_set
id|e1000_mta_set
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|hash_value
)paren
(brace
r_uint32
id|hash_bit
comma
id|hash_reg
suffix:semicolon
r_uint32
id|mta
suffix:semicolon
r_uint32
id|temp
suffix:semicolon
multiline_comment|/* The MTA is a register array of 128 32-bit registers.&n;     * It is treated like an array of 4096 bits.  We want to set&n;     * bit BitArray[hash_value]. So we figure out what register&n;     * the bit is in, read it, OR in the new bit, then write&n;     * back the new value.  The register is determined by the&n;     * upper 7 bits of the hash value and the bit within that&n;     * register are determined by the lower 5 bits of the value.&n;     */
id|hash_reg
op_assign
(paren
id|hash_value
op_rshift
l_int|5
)paren
op_amp
l_int|0x7F
suffix:semicolon
id|hash_bit
op_assign
id|hash_value
op_amp
l_int|0x1F
suffix:semicolon
id|mta
op_assign
id|E1000_READ_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|hash_reg
)paren
suffix:semicolon
id|mta
op_or_assign
(paren
l_int|1
op_lshift
id|hash_bit
)paren
suffix:semicolon
multiline_comment|/* If we are on an 82544 and we are trying to write an odd offset&n;     * in the MTA, save off the previous entry before writing and&n;     * restore the old value after writing.&n;     */
r_if
c_cond
(paren
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82544
)paren
op_logical_and
(paren
(paren
id|hash_reg
op_amp
l_int|0x1
)paren
op_eq
l_int|1
)paren
)paren
(brace
id|temp
op_assign
id|E1000_READ_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
(paren
id|hash_reg
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|hash_reg
comma
id|mta
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
(paren
id|hash_reg
op_minus
l_int|1
)paren
comma
id|temp
)paren
suffix:semicolon
)brace
r_else
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|MTA
comma
id|hash_reg
comma
id|mta
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Puts an ethernet address into a receive address register.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * addr - Address to put into receive address register&n; * index - Receive address register to write&n; *****************************************************************************/
r_void
DECL|function|e1000_rar_set
id|e1000_rar_set
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint8
op_star
id|addr
comma
r_uint32
id|index
)paren
(brace
r_uint32
id|rar_low
comma
id|rar_high
suffix:semicolon
multiline_comment|/* HW expects these in little endian so we reverse the byte order&n;     * from network order (big endian) to little endian&n;     */
id|rar_low
op_assign
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|0
)braket
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
)paren
suffix:semicolon
id|rar_high
op_assign
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|4
)braket
op_or
(paren
(paren
r_uint32
)paren
id|addr
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_or
id|E1000_RAH_AV
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
id|index
op_lshift
l_int|1
)paren
comma
id|rar_low
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|RA
comma
(paren
(paren
id|index
op_lshift
l_int|1
)paren
op_plus
l_int|1
)paren
comma
id|rar_high
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Writes a value to the specified offset in the VLAN filter table.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * offset - Offset in VLAN filer table to write&n; * value - Value to write into VLAN filter table&n; *****************************************************************************/
r_void
DECL|function|e1000_write_vfta
id|e1000_write_vfta
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|offset
comma
r_uint32
id|value
)paren
(brace
r_uint32
id|temp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82544
)paren
op_logical_and
(paren
(paren
id|offset
op_amp
l_int|0x1
)paren
op_eq
l_int|1
)paren
)paren
(brace
id|temp
op_assign
id|E1000_READ_REG_ARRAY
c_func
(paren
id|hw
comma
id|VFTA
comma
(paren
id|offset
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|VFTA
comma
id|offset
comma
id|value
)paren
suffix:semicolon
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|VFTA
comma
(paren
id|offset
op_minus
l_int|1
)paren
comma
id|temp
)paren
suffix:semicolon
)brace
r_else
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|VFTA
comma
id|offset
comma
id|value
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Clears the VLAN filer table&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|e1000_clear_vfta
id|e1000_clear_vfta
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|offset
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|E1000_VLAN_FILTER_TBL_SIZE
suffix:semicolon
id|offset
op_increment
)paren
(brace
id|E1000_WRITE_REG_ARRAY
c_func
(paren
id|hw
comma
id|VFTA
comma
id|offset
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_static
r_int32
DECL|function|e1000_id_led_init
id|e1000_id_led_init
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ledctl
suffix:semicolon
r_const
r_uint32
id|ledctl_mask
op_assign
l_int|0x000000FF
suffix:semicolon
r_const
r_uint32
id|ledctl_on
op_assign
id|E1000_LEDCTL_MODE_LED_ON
suffix:semicolon
r_const
r_uint32
id|ledctl_off
op_assign
id|E1000_LEDCTL_MODE_LED_OFF
suffix:semicolon
r_uint16
id|eeprom_data
comma
id|i
comma
id|temp
suffix:semicolon
r_const
r_uint16
id|led_mask
op_assign
l_int|0x0F
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_id_led_init&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
OL
id|e1000_82540
)paren
(brace
multiline_comment|/* Nothing to do */
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
id|ledctl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|LEDCTL
)paren
suffix:semicolon
id|hw-&gt;ledctl_default
op_assign
id|ledctl
suffix:semicolon
id|hw-&gt;ledctl_mode1
op_assign
id|hw-&gt;ledctl_default
suffix:semicolon
id|hw-&gt;ledctl_mode2
op_assign
id|hw-&gt;ledctl_default
suffix:semicolon
r_if
c_cond
(paren
id|e1000_read_eeprom
c_func
(paren
id|hw
comma
id|EEPROM_ID_LED_SETTINGS
comma
l_int|1
comma
op_amp
id|eeprom_data
)paren
OL
l_int|0
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;EEPROM Read Error&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|E1000_ERR_EEPROM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|eeprom_data
op_eq
id|ID_LED_RESERVED_0000
)paren
op_logical_or
(paren
id|eeprom_data
op_eq
id|ID_LED_RESERVED_FFFF
)paren
)paren
(brace
id|eeprom_data
op_assign
id|ID_LED_DEFAULT
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp
op_assign
(paren
id|eeprom_data
op_rshift
(paren
id|i
op_lshift
l_int|2
)paren
)paren
op_amp
id|led_mask
suffix:semicolon
r_switch
c_cond
(paren
id|temp
)paren
(brace
r_case
id|ID_LED_ON1_DEF2
suffix:colon
r_case
id|ID_LED_ON1_ON2
suffix:colon
r_case
id|ID_LED_ON1_OFF2
suffix:colon
id|hw-&gt;ledctl_mode1
op_and_assign
op_complement
(paren
id|ledctl_mask
op_lshift
(paren
id|i
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|hw-&gt;ledctl_mode1
op_or_assign
id|ledctl_on
op_lshift
(paren
id|i
op_lshift
l_int|3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ID_LED_OFF1_DEF2
suffix:colon
r_case
id|ID_LED_OFF1_ON2
suffix:colon
r_case
id|ID_LED_OFF1_OFF2
suffix:colon
id|hw-&gt;ledctl_mode1
op_and_assign
op_complement
(paren
id|ledctl_mask
op_lshift
(paren
id|i
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|hw-&gt;ledctl_mode1
op_or_assign
id|ledctl_off
op_lshift
(paren
id|i
op_lshift
l_int|3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Do nothing */
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|temp
)paren
(brace
r_case
id|ID_LED_DEF1_ON2
suffix:colon
r_case
id|ID_LED_ON1_ON2
suffix:colon
r_case
id|ID_LED_OFF1_ON2
suffix:colon
id|hw-&gt;ledctl_mode2
op_and_assign
op_complement
(paren
id|ledctl_mask
op_lshift
(paren
id|i
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|hw-&gt;ledctl_mode2
op_or_assign
id|ledctl_on
op_lshift
(paren
id|i
op_lshift
l_int|3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ID_LED_DEF1_OFF2
suffix:colon
r_case
id|ID_LED_ON1_OFF2
suffix:colon
r_case
id|ID_LED_OFF1_OFF2
suffix:colon
id|hw-&gt;ledctl_mode2
op_and_assign
op_complement
(paren
id|ledctl_mask
op_lshift
(paren
id|i
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|hw-&gt;ledctl_mode2
op_or_assign
id|ledctl_off
op_lshift
(paren
id|i
op_lshift
l_int|3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Do nothing */
r_break
suffix:semicolon
)brace
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Prepares SW controlable LED for use and saves the current state of the LED.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_setup_led
id|e1000_setup_led
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ledctl
suffix:semicolon
r_int32
id|ret_val
op_assign
id|E1000_SUCCESS
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_setup_led&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;mac_type
)paren
(brace
r_case
id|e1000_82542_rev2_0
suffix:colon
r_case
id|e1000_82542_rev2_1
suffix:colon
r_case
id|e1000_82543
suffix:colon
r_case
id|e1000_82544
suffix:colon
multiline_comment|/* No setup necessary */
r_break
suffix:semicolon
r_case
id|e1000_82541
suffix:colon
r_case
id|e1000_82547
suffix:colon
r_case
id|e1000_82541_rev_2
suffix:colon
r_case
id|e1000_82547_rev_2
suffix:colon
multiline_comment|/* Turn off PHY Smart Power Down (if enabled) */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_GMII_FIFO
comma
op_amp
id|hw-&gt;phy_spd_default
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_GMII_FIFO
comma
(paren
r_uint16
)paren
(paren
id|hw-&gt;phy_spd_default
op_amp
op_complement
id|IGP01E1000_GMII_SPD
)paren
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Fall Through */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
(brace
id|ledctl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|LEDCTL
)paren
suffix:semicolon
multiline_comment|/* Save current LEDCTL settings */
id|hw-&gt;ledctl_default
op_assign
id|ledctl
suffix:semicolon
multiline_comment|/* Turn off LED0 */
id|ledctl
op_and_assign
op_complement
(paren
id|E1000_LEDCTL_LED0_IVRT
op_or
id|E1000_LEDCTL_LED0_BLINK
op_or
id|E1000_LEDCTL_LED0_MODE_MASK
)paren
suffix:semicolon
id|ledctl
op_or_assign
(paren
id|E1000_LEDCTL_MODE_LED_OFF
op_lshift
id|E1000_LEDCTL_LED0_MODE_SHIFT
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|LEDCTL
comma
id|ledctl
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_copper
)paren
(brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|LEDCTL
comma
id|hw-&gt;ledctl_mode1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Restores the saved state of the SW controlable LED.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_cleanup_led
id|e1000_cleanup_led
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_int32
id|ret_val
op_assign
id|E1000_SUCCESS
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_cleanup_led&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;mac_type
)paren
(brace
r_case
id|e1000_82542_rev2_0
suffix:colon
r_case
id|e1000_82542_rev2_1
suffix:colon
r_case
id|e1000_82543
suffix:colon
r_case
id|e1000_82544
suffix:colon
multiline_comment|/* No cleanup necessary */
r_break
suffix:semicolon
r_case
id|e1000_82541
suffix:colon
r_case
id|e1000_82547
suffix:colon
r_case
id|e1000_82541_rev_2
suffix:colon
r_case
id|e1000_82547_rev_2
suffix:colon
multiline_comment|/* Turn on PHY Smart Power Down (if previously enabled) */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_GMII_FIFO
comma
id|hw-&gt;phy_spd_default
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Fall Through */
r_default
suffix:colon
multiline_comment|/* Restore LEDCTL settings */
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|LEDCTL
comma
id|hw-&gt;ledctl_default
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Turns on the software controllable LED&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_led_on
id|e1000_led_on
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_led_on&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;mac_type
)paren
(brace
r_case
id|e1000_82542_rev2_0
suffix:colon
r_case
id|e1000_82542_rev2_1
suffix:colon
r_case
id|e1000_82543
suffix:colon
multiline_comment|/* Set SW Defineable Pin 0 to turn on the LED */
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIN0
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIO0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_82544
suffix:colon
r_if
c_cond
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
(brace
multiline_comment|/* Set SW Defineable Pin 0 to turn on the LED */
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIN0
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIO0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Clear SW Defineable Pin 0 to turn on the LED */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_SWDPIN0
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIO0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
(brace
multiline_comment|/* Clear SW Defineable Pin 0 to turn on the LED */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_SWDPIN0
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIO0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_copper
)paren
(brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|LEDCTL
comma
id|hw-&gt;ledctl_mode2
)paren
suffix:semicolon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Turns off the software controllable LED&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_int32
DECL|function|e1000_led_off
id|e1000_led_off
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|ctrl
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CTRL
)paren
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_led_off&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;mac_type
)paren
(brace
r_case
id|e1000_82542_rev2_0
suffix:colon
r_case
id|e1000_82542_rev2_1
suffix:colon
r_case
id|e1000_82543
suffix:colon
multiline_comment|/* Clear SW Defineable Pin 0 to turn off the LED */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_SWDPIN0
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIO0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_82544
suffix:colon
r_if
c_cond
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
(brace
multiline_comment|/* Clear SW Defineable Pin 0 to turn off the LED */
id|ctrl
op_and_assign
op_complement
id|E1000_CTRL_SWDPIN0
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIO0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Set SW Defineable Pin 0 to turn off the LED */
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIN0
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIO0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_fiber
)paren
(brace
multiline_comment|/* Set SW Defineable Pin 0 to turn off the LED */
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIN0
suffix:semicolon
id|ctrl
op_or_assign
id|E1000_CTRL_SWDPIO0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hw-&gt;media_type
op_eq
id|e1000_media_type_copper
)paren
(brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|LEDCTL
comma
id|hw-&gt;ledctl_mode1
)paren
suffix:semicolon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|CTRL
comma
id|ctrl
)paren
suffix:semicolon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Clears all hardware statistics counters.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|e1000_clear_hw_cntrs
id|e1000_clear_hw_cntrs
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_volatile
r_uint32
id|temp
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CRCERRS
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|SYMERRS
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MPC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|SCC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|ECOL
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MCC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|LATECOL
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|COLC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|DC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|SEC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RLEC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|XONRXC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|XONTXC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|XOFFRXC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|XOFFTXC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|FCRUC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PRC64
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PRC127
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PRC255
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PRC511
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PRC1023
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PRC1522
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|GPRC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|BPRC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MPRC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|GPTC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|GORCL
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|GORCH
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|GOTCL
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|GOTCH
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RNBC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RUC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RFC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|ROC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RJC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TORL
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TORH
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TOTL
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TOTH
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TPR
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TPT
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PTC64
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PTC127
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PTC255
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PTC511
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PTC1023
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|PTC1522
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MPTC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|BPTC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
OL
id|e1000_82543
)paren
(brace
r_return
suffix:semicolon
)brace
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|ALGNERRC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|RXERRC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TNCRS
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|CEXTERR
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TSCTC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|TSCTFC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
op_le
id|e1000_82544
)paren
(brace
r_return
suffix:semicolon
)brace
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MGTPRC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MGTPDC
)paren
suffix:semicolon
id|temp
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|MGTPTC
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Resets Adaptive IFS to its default state.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *&n; * Call this after e1000_init_hw. You may override the IFS defaults by setting&n; * hw-&gt;ifs_params_forced to TRUE. However, you must initialize hw-&gt;&n; * current_ifs_val, ifs_min_val, ifs_max_val, ifs_step_size, and ifs_ratio&n; * before calling this function.&n; *****************************************************************************/
r_void
DECL|function|e1000_reset_adaptive
id|e1000_reset_adaptive
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_reset_adaptive&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;adaptive_ifs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hw-&gt;ifs_params_forced
)paren
(brace
id|hw-&gt;current_ifs_val
op_assign
l_int|0
suffix:semicolon
id|hw-&gt;ifs_min_val
op_assign
id|IFS_MIN
suffix:semicolon
id|hw-&gt;ifs_max_val
op_assign
id|IFS_MAX
suffix:semicolon
id|hw-&gt;ifs_step_size
op_assign
id|IFS_STEP
suffix:semicolon
id|hw-&gt;ifs_ratio
op_assign
id|IFS_RATIO
suffix:semicolon
)brace
id|hw-&gt;in_ifs_mode
op_assign
id|FALSE
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|AIT
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Not in Adaptive IFS mode!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Called during the callback/watchdog routine to update IFS value based on&n; * the ratio of transmits to collisions.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * tx_packets - Number of transmits since last callback&n; * total_collisions - Number of collisions since last callback&n; *****************************************************************************/
r_void
DECL|function|e1000_update_adaptive
id|e1000_update_adaptive
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_update_adaptive&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;adaptive_ifs
)paren
(brace
r_if
c_cond
(paren
(paren
id|hw-&gt;collision_delta
op_star
id|hw-&gt;ifs_ratio
)paren
OG
id|hw-&gt;tx_packet_delta
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;tx_packet_delta
OG
id|MIN_NUM_XMITS
)paren
(brace
id|hw-&gt;in_ifs_mode
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;current_ifs_val
OL
id|hw-&gt;ifs_max_val
)paren
(brace
r_if
c_cond
(paren
id|hw-&gt;current_ifs_val
op_eq
l_int|0
)paren
(brace
id|hw-&gt;current_ifs_val
op_assign
id|hw-&gt;ifs_min_val
suffix:semicolon
)brace
r_else
id|hw-&gt;current_ifs_val
op_add_assign
id|hw-&gt;ifs_step_size
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|AIT
comma
id|hw-&gt;current_ifs_val
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|hw-&gt;in_ifs_mode
op_logical_and
(paren
id|hw-&gt;tx_packet_delta
op_le
id|MIN_NUM_XMITS
)paren
)paren
(brace
id|hw-&gt;current_ifs_val
op_assign
l_int|0
suffix:semicolon
id|hw-&gt;in_ifs_mode
op_assign
id|FALSE
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|hw
comma
id|AIT
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Not in Adaptive IFS mode!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Adjusts the statistic counters when a frame is accepted by TBI_ACCEPT&n; *&n; * hw - Struct containing variables accessed by shared code&n; * frame_len - The length of the frame in question&n; * mac_addr - The Ethernet destination address of the frame in question&n; *****************************************************************************/
r_void
DECL|function|e1000_tbi_adjust_stats
id|e1000_tbi_adjust_stats
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_struct
id|e1000_hw_stats
op_star
id|stats
comma
r_uint32
id|frame_len
comma
r_uint8
op_star
id|mac_addr
)paren
(brace
r_uint64
id|carry_bit
suffix:semicolon
multiline_comment|/* First adjust the frame length. */
id|frame_len
op_decrement
suffix:semicolon
multiline_comment|/* We need to adjust the statistics counters, since the hardware&n;     * counters overcount this packet as a CRC error and undercount&n;     * the packet as a good packet&n;     */
multiline_comment|/* This packet should not be counted as a CRC error.    */
id|stats-&gt;crcerrs
op_decrement
suffix:semicolon
multiline_comment|/* This packet does count as a Good Packet Received.    */
id|stats-&gt;gprc
op_increment
suffix:semicolon
multiline_comment|/* Adjust the Good Octets received counters             */
id|carry_bit
op_assign
l_int|0x80000000
op_amp
id|stats-&gt;gorcl
suffix:semicolon
id|stats-&gt;gorcl
op_add_assign
id|frame_len
suffix:semicolon
multiline_comment|/* If the high bit of Gorcl (the low 32 bits of the Good Octets&n;     * Received Count) was one before the addition,&n;     * AND it is zero after, then we lost the carry out,&n;     * need to add one to Gorch (Good Octets Received Count High).&n;     * This could be simplified if all environments supported&n;     * 64-bit integers.&n;     */
r_if
c_cond
(paren
id|carry_bit
op_logical_and
(paren
(paren
id|stats-&gt;gorcl
op_amp
l_int|0x80000000
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|stats-&gt;gorch
op_increment
suffix:semicolon
)brace
multiline_comment|/* Is this a broadcast or multicast?  Check broadcast first,&n;     * since the test for a multicast frame will test positive on&n;     * a broadcast frame.&n;     */
r_if
c_cond
(paren
(paren
id|mac_addr
(braket
l_int|0
)braket
op_eq
(paren
r_uint8
)paren
l_int|0xff
)paren
op_logical_and
(paren
id|mac_addr
(braket
l_int|1
)braket
op_eq
(paren
r_uint8
)paren
l_int|0xff
)paren
)paren
(brace
multiline_comment|/* Broadcast packet */
id|stats-&gt;bprc
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|mac_addr
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* Multicast packet */
id|stats-&gt;mprc
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frame_len
op_eq
id|hw-&gt;max_frame_size
)paren
(brace
multiline_comment|/* In this case, the hardware has overcounted the number of&n;         * oversize frames.&n;         */
r_if
c_cond
(paren
id|stats-&gt;roc
OG
l_int|0
)paren
(brace
id|stats-&gt;roc
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* Adjust the bin counters when the extra byte put the frame in the&n;     * wrong bin. Remember that the frame_len was adjusted above.&n;     */
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|64
)paren
(brace
id|stats-&gt;prc64
op_increment
suffix:semicolon
id|stats-&gt;prc127
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|127
)paren
(brace
id|stats-&gt;prc127
op_increment
suffix:semicolon
id|stats-&gt;prc255
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|255
)paren
(brace
id|stats-&gt;prc255
op_increment
suffix:semicolon
id|stats-&gt;prc511
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|511
)paren
(brace
id|stats-&gt;prc511
op_increment
suffix:semicolon
id|stats-&gt;prc1023
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|1023
)paren
(brace
id|stats-&gt;prc1023
op_increment
suffix:semicolon
id|stats-&gt;prc1522
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|frame_len
op_eq
l_int|1522
)paren
(brace
id|stats-&gt;prc1522
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n; * Gets the current PCI bus type, speed, and width of the hardware&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_void
DECL|function|e1000_get_bus_info
id|e1000_get_bus_info
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_uint32
id|status
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;mac_type
OL
id|e1000_82543
)paren
(brace
id|hw-&gt;bus_type
op_assign
id|e1000_bus_type_unknown
suffix:semicolon
id|hw-&gt;bus_speed
op_assign
id|e1000_bus_speed_unknown
suffix:semicolon
id|hw-&gt;bus_width
op_assign
id|e1000_bus_width_unknown
suffix:semicolon
r_return
suffix:semicolon
)brace
id|status
op_assign
id|E1000_READ_REG
c_func
(paren
id|hw
comma
id|STATUS
)paren
suffix:semicolon
id|hw-&gt;bus_type
op_assign
(paren
id|status
op_amp
id|E1000_STATUS_PCIX_MODE
)paren
ques
c_cond
id|e1000_bus_type_pcix
suffix:colon
id|e1000_bus_type_pci
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;device_id
op_eq
id|E1000_DEV_ID_82546EB_QUAD_COPPER
)paren
(brace
id|hw-&gt;bus_speed
op_assign
(paren
id|hw-&gt;bus_type
op_eq
id|e1000_bus_type_pci
)paren
ques
c_cond
id|e1000_bus_speed_66
suffix:colon
id|e1000_bus_speed_120
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hw-&gt;bus_type
op_eq
id|e1000_bus_type_pci
)paren
(brace
id|hw-&gt;bus_speed
op_assign
(paren
id|status
op_amp
id|E1000_STATUS_PCI66
)paren
ques
c_cond
id|e1000_bus_speed_66
suffix:colon
id|e1000_bus_speed_33
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|status
op_amp
id|E1000_STATUS_PCIX_SPEED
)paren
(brace
r_case
id|E1000_STATUS_PCIX_SPEED_66
suffix:colon
id|hw-&gt;bus_speed
op_assign
id|e1000_bus_speed_66
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_STATUS_PCIX_SPEED_100
suffix:colon
id|hw-&gt;bus_speed
op_assign
id|e1000_bus_speed_100
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E1000_STATUS_PCIX_SPEED_133
suffix:colon
id|hw-&gt;bus_speed
op_assign
id|e1000_bus_speed_133
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|hw-&gt;bus_speed
op_assign
id|e1000_bus_speed_reserved
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|hw-&gt;bus_width
op_assign
(paren
id|status
op_amp
id|E1000_STATUS_BUS64
)paren
ques
c_cond
id|e1000_bus_width_64
suffix:colon
id|e1000_bus_width_32
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Reads a value from one of the devices registers using port I/O (as opposed&n; * memory mapped I/O). Only 82544 and newer devices support port I/O.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * offset - offset to read from&n; *****************************************************************************/
r_uint32
DECL|function|e1000_read_reg_io
id|e1000_read_reg_io
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|offset
)paren
(brace
r_int
r_int
id|io_addr
op_assign
id|hw-&gt;io_base
suffix:semicolon
r_int
r_int
id|io_data
op_assign
id|hw-&gt;io_base
op_plus
l_int|4
suffix:semicolon
id|e1000_io_write
c_func
(paren
id|hw
comma
id|io_addr
comma
id|offset
)paren
suffix:semicolon
r_return
id|e1000_io_read
c_func
(paren
id|hw
comma
id|io_data
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Writes a value to one of the devices registers using port I/O (as opposed to&n; * memory mapped I/O). Only 82544 and newer devices support port I/O.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * offset - offset to write to&n; * value - value to write&n; *****************************************************************************/
r_void
DECL|function|e1000_write_reg_io
id|e1000_write_reg_io
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint32
id|offset
comma
r_uint32
id|value
)paren
(brace
r_int
r_int
id|io_addr
op_assign
id|hw-&gt;io_base
suffix:semicolon
r_int
r_int
id|io_data
op_assign
id|hw-&gt;io_base
op_plus
l_int|4
suffix:semicolon
id|e1000_io_write
c_func
(paren
id|hw
comma
id|io_addr
comma
id|offset
)paren
suffix:semicolon
id|e1000_io_write
c_func
(paren
id|hw
comma
id|io_data
comma
id|value
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Estimates the cable length.&n; *&n; * hw - Struct containing variables accessed by shared code&n; * min_length - The estimated minimum length&n; * max_length - The estimated maximum length&n; *&n; * returns: - E1000_ERR_XXX&n; *            E1000_SUCCESS&n; *&n; * This function always returns a ranged length (minimum &amp; maximum).&n; * So for M88 phy&squot;s, this function interprets the one value returned from the&n; * register to the minimum and maximum range.&n; * For IGP phy&squot;s, the function calculates the range by the AGC registers.&n; *****************************************************************************/
r_int32
DECL|function|e1000_get_cable_length
id|e1000_get_cable_length
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
op_star
id|min_length
comma
r_uint16
op_star
id|max_length
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|agc_value
op_assign
l_int|0
suffix:semicolon
r_uint16
id|cur_agc
comma
id|min_agc
op_assign
id|IGP01E1000_AGC_LENGTH_TABLE_SIZE
suffix:semicolon
r_uint16
id|i
comma
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_get_cable_length&quot;
)paren
suffix:semicolon
op_star
id|min_length
op_assign
op_star
id|max_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Use old method for Phy older than IGP */
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_m88
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Convert the enum value to ranged values */
r_switch
c_cond
(paren
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_CABLE_LENGTH
)paren
op_rshift
id|M88E1000_PSSR_CABLE_LENGTH_SHIFT
)paren
(brace
r_case
id|e1000_cable_length_50
suffix:colon
op_star
id|min_length
op_assign
l_int|0
suffix:semicolon
op_star
id|max_length
op_assign
id|e1000_igp_cable_length_50
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_cable_length_50_80
suffix:colon
op_star
id|min_length
op_assign
id|e1000_igp_cable_length_50
suffix:semicolon
op_star
id|max_length
op_assign
id|e1000_igp_cable_length_80
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_cable_length_80_110
suffix:colon
op_star
id|min_length
op_assign
id|e1000_igp_cable_length_80
suffix:semicolon
op_star
id|max_length
op_assign
id|e1000_igp_cable_length_110
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_cable_length_110_140
suffix:colon
op_star
id|min_length
op_assign
id|e1000_igp_cable_length_110
suffix:semicolon
op_star
id|max_length
op_assign
id|e1000_igp_cable_length_140
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_cable_length_140
suffix:colon
op_star
id|min_length
op_assign
id|e1000_igp_cable_length_140
suffix:semicolon
op_star
id|max_length
op_assign
id|e1000_igp_cable_length_170
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_igp
)paren
(brace
multiline_comment|/* For IGP PHY */
r_uint16
id|agc_reg_array
(braket
id|IGP01E1000_PHY_CHANNEL_NUM
)braket
op_assign
(brace
id|IGP01E1000_PHY_AGC_A
comma
id|IGP01E1000_PHY_AGC_B
comma
id|IGP01E1000_PHY_AGC_C
comma
id|IGP01E1000_PHY_AGC_D
)brace
suffix:semicolon
multiline_comment|/* Read the AGC registers for all channels */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IGP01E1000_PHY_CHANNEL_NUM
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|agc_reg_array
(braket
id|i
)braket
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|cur_agc
op_assign
id|phy_data
op_rshift
id|IGP01E1000_AGC_LENGTH_SHIFT
suffix:semicolon
multiline_comment|/* Array bound check. */
r_if
c_cond
(paren
(paren
id|cur_agc
op_ge
id|IGP01E1000_AGC_LENGTH_TABLE_SIZE
op_minus
l_int|1
)paren
op_logical_or
(paren
id|cur_agc
op_eq
l_int|0
)paren
)paren
(brace
r_return
op_minus
id|E1000_ERR_PHY
suffix:semicolon
)brace
id|agc_value
op_add_assign
id|cur_agc
suffix:semicolon
multiline_comment|/* Update minimal AGC value. */
r_if
c_cond
(paren
id|min_agc
OG
id|cur_agc
)paren
(brace
id|min_agc
op_assign
id|cur_agc
suffix:semicolon
)brace
)brace
multiline_comment|/* Remove the minimal AGC result for length &lt; 50m */
r_if
c_cond
(paren
id|agc_value
OL
id|IGP01E1000_PHY_CHANNEL_NUM
op_star
id|e1000_igp_cable_length_50
)paren
(brace
id|agc_value
op_sub_assign
id|min_agc
suffix:semicolon
multiline_comment|/* Get the average length of the remaining 3 channels */
id|agc_value
op_div_assign
(paren
id|IGP01E1000_PHY_CHANNEL_NUM
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get the average length of all the 4 channels. */
id|agc_value
op_div_assign
id|IGP01E1000_PHY_CHANNEL_NUM
suffix:semicolon
)brace
multiline_comment|/* Set the range of the calculated length. */
op_star
id|min_length
op_assign
(paren
(paren
id|e1000_igp_cable_length_table
(braket
id|agc_value
)braket
op_minus
id|IGP01E1000_AGC_RANGE
)paren
OG
l_int|0
)paren
ques
c_cond
(paren
id|e1000_igp_cable_length_table
(braket
id|agc_value
)braket
op_minus
id|IGP01E1000_AGC_RANGE
)paren
suffix:colon
l_int|0
suffix:semicolon
op_star
id|max_length
op_assign
id|e1000_igp_cable_length_table
(braket
id|agc_value
)braket
op_plus
id|IGP01E1000_AGC_RANGE
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Check the cable polarity&n; *&n; * hw - Struct containing variables accessed by shared code&n; * polarity - output parameter : 0 - Polarity is not reversed&n; *                               1 - Polarity is reversed.&n; *&n; * returns: - E1000_ERR_XXX&n; *            E1000_SUCCESS&n; *&n; * For phy&squot;s older then IGP, this function simply reads the polarity bit in the&n; * Phy Status register.  For IGP phy&squot;s, this bit is valid only if link speed is&n; * 10 Mbps.  If the link speed is 100 Mbps there is no polarity so this bit will&n; * return 0.  If the link speed is 1000 Mbps the polarity status is in the&n; * IGP01E1000_PHY_PCS_INIT_REG.&n; *****************************************************************************/
r_int32
DECL|function|e1000_check_polarity
id|e1000_check_polarity
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
r_uint16
op_star
id|polarity
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_check_polarity&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_m88
)paren
(brace
multiline_comment|/* return the Polarity bit in the Status register. */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
op_star
id|polarity
op_assign
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_REV_POLARITY
)paren
op_rshift
id|M88E1000_PSSR_REV_POLARITY_SHIFT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_igp
)paren
(brace
multiline_comment|/* Read the Status register to check the speed */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* If speed is 1000 Mbps, must read the IGP01E1000_PHY_PCS_INIT_REG to&n;         * find the polarity status */
r_if
c_cond
(paren
(paren
id|phy_data
op_amp
id|IGP01E1000_PSSR_SPEED_MASK
)paren
op_eq
id|IGP01E1000_PSSR_SPEED_1000MBPS
)paren
(brace
multiline_comment|/* Read the GIG initialization PCS register (0x00B4) */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PCS_INIT_REG
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Check the polarity bits */
op_star
id|polarity
op_assign
(paren
id|phy_data
op_amp
id|IGP01E1000_PHY_POLARITY_MASK
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* For 10 Mbps, read the polarity bit in the status register. (for&n;             * 100 Mbps this bit is always 0) */
op_star
id|polarity
op_assign
id|phy_data
op_amp
id|IGP01E1000_PSSR_POLARITY_REVERSED
suffix:semicolon
)brace
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Check if Downshift occured&n; *&n; * hw - Struct containing variables accessed by shared code&n; * downshift - output parameter : 0 - No Downshift ocured.&n; *                                1 - Downshift ocured.&n; *&n; * returns: - E1000_ERR_XXX&n; *            E1000_SUCCESS &n; *&n; * For phy&squot;s older then IGP, this function reads the Downshift bit in the Phy&n; * Specific Status register.  For IGP phy&squot;s, it reads the Downgrade bit in the&n; * Link Health register.  In IGP this bit is latched high, so the driver must&n; * read it immediately after link is established.&n; *****************************************************************************/
r_int32
DECL|function|e1000_check_downshift
id|e1000_check_downshift
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_check_downshift&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_igp
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_LINK_HEALTH
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|hw-&gt;speed_downgraded
op_assign
(paren
id|phy_data
op_amp
id|IGP01E1000_PLHR_SS_DOWNGRADE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_eq
id|e1000_phy_m88
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_SPEC_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|hw-&gt;speed_downgraded
op_assign
(paren
id|phy_data
op_amp
id|M88E1000_PSSR_DOWNSHIFT
)paren
op_rshift
id|M88E1000_PSSR_DOWNSHIFT_SHIFT
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * 82541_rev_2 &amp; 82547_rev_2 have the capability to configure the DSP when a&n; * gigabit link is achieved to improve link quality.&n; *&n; * hw: Struct containing variables accessed by shared code&n; *&n; * returns: - E1000_ERR_PHY if fail to read/write the PHY&n; *            E1000_SUCCESS at any other case.&n; *&n; ****************************************************************************/
r_int32
DECL|function|e1000_config_dsp_after_link_change
id|e1000_config_dsp_after_link_change
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
id|boolean_t
id|link_up
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|phy_data
comma
id|speed
comma
id|duplex
comma
id|i
suffix:semicolon
r_uint16
id|dsp_reg_array
(braket
id|IGP01E1000_PHY_CHANNEL_NUM
)braket
op_assign
(brace
id|IGP01E1000_PHY_AGC_PARAM_A
comma
id|IGP01E1000_PHY_AGC_PARAM_B
comma
id|IGP01E1000_PHY_AGC_PARAM_C
comma
id|IGP01E1000_PHY_AGC_PARAM_D
)brace
suffix:semicolon
r_uint16
id|min_length
comma
id|max_length
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_config_dsp_after_link_change&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;phy_type
op_ne
id|e1000_phy_igp
)paren
(brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|link_up
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_get_speed_and_duplex
c_func
(paren
id|hw
comma
op_amp
id|speed
comma
op_amp
id|duplex
)paren
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Error getting link speed and duplex&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|speed
op_eq
id|SPEED_1000
)paren
(brace
id|e1000_get_cable_length
c_func
(paren
id|hw
comma
op_amp
id|min_length
comma
op_amp
id|max_length
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hw-&gt;dsp_config_state
op_eq
id|e1000_dsp_config_enabled
)paren
op_logical_and
id|min_length
op_ge
id|e1000_igp_cable_length_50
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IGP01E1000_PHY_CHANNEL_NUM
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|dsp_reg_array
(braket
id|i
)braket
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_and_assign
op_complement
id|IGP01E1000_PHY_EDAC_MU_INDEX
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|dsp_reg_array
(braket
id|i
)braket
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
id|hw-&gt;dsp_config_state
op_assign
id|e1000_dsp_config_activated
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|hw-&gt;ffe_config_state
op_eq
id|e1000_ffe_config_enabled
)paren
op_logical_and
(paren
id|min_length
OL
id|e1000_igp_cable_length_50
)paren
)paren
(brace
r_uint16
id|ffe_idle_err_timeout
op_assign
id|FFE_IDLE_ERR_COUNT_TIMEOUT_20
suffix:semicolon
r_uint32
id|idle_errs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear previous idle error counts */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ffe_idle_err_timeout
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|PHY_1000T_STATUS
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|idle_errs
op_add_assign
(paren
id|phy_data
op_amp
id|SR_1000T_IDLE_ERROR_CNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idle_errs
OG
id|SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT
)paren
(brace
id|hw-&gt;ffe_config_state
op_assign
id|e1000_ffe_config_active
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_DSP_FFE
comma
id|IGP01E1000_PHY_DSP_FFE_CM_CP
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|idle_errs
)paren
(brace
id|ffe_idle_err_timeout
op_assign
id|FFE_IDLE_ERR_COUNT_TIMEOUT_100
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|hw-&gt;dsp_config_state
op_eq
id|e1000_dsp_config_activated
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x0000
comma
id|IGP01E1000_IEEE_FORCE_GIGA
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IGP01E1000_PHY_CHANNEL_NUM
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|dsp_reg_array
(braket
id|i
)braket
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_and_assign
op_complement
id|IGP01E1000_PHY_EDAC_MU_INDEX
suffix:semicolon
id|phy_data
op_or_assign
id|IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|dsp_reg_array
(braket
id|i
)braket
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x0000
comma
id|IGP01E1000_IEEE_RESTART_AUTONEG
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|hw-&gt;dsp_config_state
op_assign
id|e1000_dsp_config_enabled
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw-&gt;ffe_config_state
op_eq
id|e1000_ffe_config_active
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x0000
comma
id|IGP01E1000_IEEE_FORCE_GIGA
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_DSP_FFE
comma
id|IGP01E1000_PHY_DSP_FFE_DEFAULT
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
l_int|0x0000
comma
id|IGP01E1000_IEEE_RESTART_AUTONEG
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|hw-&gt;ffe_config_state
op_assign
id|e1000_ffe_config_enabled
suffix:semicolon
)brace
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * This function sets the lplu state according to the active flag.  When&n; * activating lplu this function also disables smart speed and vise versa.&n; * lplu will not be activated unless the device autonegotiation advertisment&n; * meets standards of either 10 or 10/100 or 10/100/1000 at all duplexes.&n; * hw: Struct containing variables accessed by shared code&n; * active - true to enable lplu false to disable lplu.&n; *&n; * returns: - E1000_ERR_PHY if fail to read/write the PHY&n; *            E1000_SUCCESS at any other case.&n; *&n; ****************************************************************************/
r_int32
DECL|function|e1000_set_d3_lplu_state
id|e1000_set_d3_lplu_state
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
comma
id|boolean_t
id|active
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_set_d3_lplu_state&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82541_rev_2
)paren
op_logical_or
(paren
id|hw-&gt;mac_type
op_eq
id|e1000_82547_rev_2
)paren
)paren
)paren
(brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* During driver activity LPLU should not be used or it will attain link&n;     * from the lowest speeds starting from 10Mbps. The capability is used for&n;     * Dx transitions and states */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_GMII_FIFO
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|active
)paren
(brace
id|phy_data
op_and_assign
op_complement
id|IGP01E1000_GMII_FLEX_SPD
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_GMII_FIFO
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used during&n;         * Dx states where the power conservation is most important.  During&n;         * driver activity we should enable SmartSpeed, so performance is&n;         * maintained. */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_CONFIG
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_or_assign
id|IGP01E1000_PSCFR_SMART_SPEED
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_CONFIG
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|hw-&gt;autoneg_advertised
op_eq
id|AUTONEG_ADVERTISE_SPEED_DEFAULT
)paren
op_logical_or
(paren
id|hw-&gt;autoneg_advertised
op_eq
id|AUTONEG_ADVERTISE_10_ALL
)paren
op_logical_or
(paren
id|hw-&gt;autoneg_advertised
op_eq
id|AUTONEG_ADVERTISE_10_100_ALL
)paren
)paren
(brace
id|phy_data
op_or_assign
id|IGP01E1000_GMII_FLEX_SPD
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_GMII_FIFO
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* When LPLU is enabled we should disable SmartSpeed */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_CONFIG
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_and_assign
op_complement
id|IGP01E1000_PSCFR_SMART_SPEED
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|IGP01E1000_PHY_PORT_CONFIG
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; * Change VCO speed register to improve Bit Error Rate performance of SERDES.&n; *&n; * hw - Struct containing variables accessed by shared code&n; *****************************************************************************/
r_static
r_int32
DECL|function|e1000_set_vco_speed
id|e1000_set_vco_speed
c_func
(paren
r_struct
id|e1000_hw
op_star
id|hw
)paren
(brace
r_int32
id|ret_val
suffix:semicolon
r_uint16
id|default_page
op_assign
l_int|0
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_set_vco_speed&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;mac_type
)paren
(brace
r_case
id|e1000_82545_rev_3
suffix:colon
r_case
id|e1000_82546_rev_3
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
multiline_comment|/* Set PHY register 30, page 5, bit 8 to 0 */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_PAGE_SELECT
comma
op_amp
id|default_page
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_PAGE_SELECT
comma
l_int|0x0005
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_GEN_CONTROL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_and_assign
op_complement
id|M88E1000_PHY_VCO_REG_BIT8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_GEN_CONTROL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* Set PHY register 30, page 4, bit 11 to 1 */
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_PAGE_SELECT
comma
l_int|0x0004
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_GEN_CONTROL
comma
op_amp
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
id|phy_data
op_or_assign
id|M88E1000_PHY_VCO_REG_BIT11
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_GEN_CONTROL
comma
id|phy_data
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret_val
op_assign
id|e1000_write_phy_reg
c_func
(paren
id|hw
comma
id|M88E1000_PHY_PAGE_SELECT
comma
id|default_page
)paren
)paren
)paren
(brace
r_return
id|ret_val
suffix:semicolon
)brace
r_return
id|E1000_SUCCESS
suffix:semicolon
)brace
eof
