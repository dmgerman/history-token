multiline_comment|/*******************************************************************************&n;&n;  This software program is available to you under a choice of one of two&n;  licenses. You may choose to be licensed under either the GNU General Public&n;  License (GPL) Version 2, June 1991, available at&n;  http://www.fsf.org/copyleft/gpl.html, or the Intel BSD + Patent License, the&n;  text of which follows:&n;  &n;  Recipient has requested a license and Intel Corporation (&quot;Intel&quot;) is willing&n;  to grant a license for the software entitled Linux Base Driver for the&n;  Intel(R) PRO/1000 Family of Adapters (e1000) (the &quot;Software&quot;) being provided&n;  by Intel Corporation. The following definitions apply to this license:&n;  &n;  &quot;Licensed Patents&quot; means patent claims licensable by Intel Corporation which&n;  are necessarily infringed by the use of sale of the Software alone or when&n;  combined with the operating system referred to below.&n;  &n;  &quot;Recipient&quot; means the party to whom Intel delivers this Software.&n;  &n;  &quot;Licensee&quot; means Recipient and those third parties that receive a license to&n;  any operating system available under the GNU Public License version 2.0 or&n;  later.&n;  &n;  Copyright (c) 1999 - 2002 Intel Corporation.&n;  All rights reserved.&n;  &n;  The license is provided to Recipient and Recipient&squot;s Licensees under the&n;  following terms.&n;  &n;  Redistribution and use in source and binary forms of the Software, with or&n;  without modification, are permitted provided that the following conditions&n;  are met:&n;  &n;  Redistributions of source code of the Software may retain the above&n;  copyright notice, this list of conditions and the following disclaimer.&n;  &n;  Redistributions in binary form of the Software may reproduce the above&n;  copyright notice, this list of conditions and the following disclaimer in&n;  the documentation and/or materials provided with the distribution.&n;  &n;  Neither the name of Intel Corporation nor the names of its contributors&n;  shall be used to endorse or promote products derived from this Software&n;  without specific prior written permission.&n;  &n;  Intel hereby grants Recipient and Licensees a non-exclusive, worldwide,&n;  royalty-free patent license under Licensed Patents to make, use, sell, offer&n;  to sell, import and otherwise transfer the Software, if any, in source code&n;  and object code form. This license shall include changes to the Software&n;  that are error corrections or other minor changes to the Software that do&n;  not add functionality or features when the Software is incorporated in any&n;  version of an operating system that has been distributed under the GNU&n;  General Public License 2.0 or later. This patent license shall apply to the&n;  combination of the Software and any operating system licensed under the GNU&n;  Public License version 2.0 or later if, at the time Intel provides the&n;  Software to Recipient, such addition of the Software to the then publicly&n;  available versions of such operating systems available under the GNU Public&n;  License version 2.0 or later (whether in gold, beta or alpha form) causes&n;  such combination to be covered by the Licensed Patents. The patent license&n;  shall not apply to any other combinations which include the Software. NO&n;  hardware per se is licensed hereunder.&n;  &n;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;&n;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n;  IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n;  ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY&n;  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES&n;  (INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;&n;  ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED&n;  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR&n;  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&n;  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n;&n;*******************************************************************************/
multiline_comment|/* e1000_phy.c&n; * Shared functions for accessing and configuring the PHY&n; */
macro_line|#include &quot;e1000_mac.h&quot;
macro_line|#include &quot;e1000_phy.h&quot;
multiline_comment|/******************************************************************************&n;* Raises the Management Data Clock&n;*&n;* shared - Struct containing variables accessed by shared code&n;* ctrl_reg - Device control register&squot;s current value&n;******************************************************************************/
r_static
r_void
DECL|function|e1000_raise_mdc
id|e1000_raise_mdc
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint32
op_star
id|ctrl_reg
)paren
(brace
multiline_comment|/* Raise the clock input to the Management Data Clock (by setting&n;     * the MDC bit), and then delay 2 microseconds.&n;     */
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
(paren
op_star
id|ctrl_reg
op_or
id|E1000_CTRL_MDC
)paren
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Lowers the Management Data Clock&n;*&n;* shared - Struct containing variables accessed by shared code&n;* ctrl_reg - Device control register&squot;s current value&n;******************************************************************************/
r_static
r_void
DECL|function|e1000_lower_mdc
id|e1000_lower_mdc
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint32
op_star
id|ctrl_reg
)paren
(brace
multiline_comment|/* Lower the clock input to the Management Data Clock (by clearing&n;     * the MDC bit), and then delay 2 microseconds.&n;     */
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
(paren
op_star
id|ctrl_reg
op_amp
op_complement
id|E1000_CTRL_MDC
)paren
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Shifts data bits out to the PHY&n;*&n;* shared - Struct containing variables accessed by shared code&n;* data - Data to send out to the PHY&n;* count - Number of bits to shift out&n;*&n;* Bits are shifted out in MSB to LSB order.&n;******************************************************************************/
r_static
r_void
DECL|function|e1000_phy_shift_out
id|e1000_phy_shift_out
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint32
id|data
comma
r_uint16
id|count
)paren
(brace
r_uint32
id|ctrl_reg
suffix:semicolon
r_uint32
id|mask
suffix:semicolon
id|ASSERT
c_func
(paren
id|count
op_le
l_int|32
)paren
suffix:semicolon
multiline_comment|/* We need to shift &quot;count&quot; number of bits out to the PHY.  So, the&n;     * value in the &quot;Data&quot; parameter will be shifted out to the PHY&n;     * one bit at a time.  In order to do this, &quot;Data&quot; must be broken&n;     * down into bits, which is what the &quot;while&quot; logic does below.&n;     */
id|mask
op_assign
l_int|0x01
suffix:semicolon
id|mask
op_lshift_assign
(paren
id|count
op_minus
l_int|1
)paren
suffix:semicolon
id|ctrl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Set MDIO_DIR (SWDPIO1) and MDC_DIR (SWDPIO2) direction bits to&n;     * be used as output pins.&n;     */
id|ctrl_reg
op_or_assign
(paren
id|E1000_CTRL_MDIO_DIR
op_or
id|E1000_CTRL_MDC_DIR
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mask
)paren
(brace
multiline_comment|/* A &quot;1&quot; is shifted out to the PHY by setting the MDIO bit to&n;         * &quot;1&quot; and then raising and lowering the Management Data Clock&n;         * (MDC).  A &quot;0&quot; is shifted out to the PHY by setting the MDIO&n;         * bit to &quot;0&quot; and then raising and lowering the clock.&n;         */
r_if
c_cond
(paren
id|data
op_amp
id|mask
)paren
(brace
id|ctrl_reg
op_or_assign
id|E1000_CTRL_MDIO
suffix:semicolon
)brace
r_else
id|ctrl_reg
op_and_assign
op_complement
id|E1000_CTRL_MDIO
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
id|ctrl_reg
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|e1000_raise_mdc
c_func
(paren
id|shared
comma
op_amp
id|ctrl_reg
)paren
suffix:semicolon
id|e1000_lower_mdc
c_func
(paren
id|shared
comma
op_amp
id|ctrl_reg
)paren
suffix:semicolon
id|mask
op_assign
id|mask
op_rshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Clear the data bit just before leaving this routine. */
id|ctrl_reg
op_and_assign
op_complement
id|E1000_CTRL_MDIO
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Shifts data bits in from the PHY&n;*&n;* shared - Struct containing variables accessed by shared code&n;*&n;* Bits are shifted in in MSB to LSB order. &n;******************************************************************************/
r_static
r_uint16
DECL|function|e1000_phy_shift_in
id|e1000_phy_shift_in
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|ctrl_reg
suffix:semicolon
r_uint16
id|data
op_assign
l_int|0
suffix:semicolon
r_uint8
id|i
suffix:semicolon
multiline_comment|/* In order to read a register from the PHY, we need to shift in a&n;     * total of 18 bits from the PHY.  The first two bit (TurnAround)&n;     * times are used to avoid contention on the MDIO pin when a read&n;     * operation is performed.  These two bits are ignored by us and&n;     * thrown away.  Bits are &quot;shifted in&quot; by raising the clock input&n;     * to the Management Data Clock (setting the MDC bit), and then&n;     * reading the value of the MDIO bit.&n;     */
id|ctrl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as&n;     * input.&n;     */
id|ctrl_reg
op_and_assign
op_complement
id|E1000_CTRL_MDIO_DIR
suffix:semicolon
id|ctrl_reg
op_and_assign
op_complement
id|E1000_CTRL_MDIO
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
id|ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* Raise and Lower the clock before reading in the data.  This&n;     * accounts for the TurnAround bits.  The first clock occurred&n;     * when we clocked out the last bit of the Register Address.&n;     */
id|e1000_raise_mdc
c_func
(paren
id|shared
comma
op_amp
id|ctrl_reg
)paren
suffix:semicolon
id|e1000_lower_mdc
c_func
(paren
id|shared
comma
op_amp
id|ctrl_reg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|data
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|data
op_lshift
l_int|1
suffix:semicolon
id|e1000_raise_mdc
c_func
(paren
id|shared
comma
op_amp
id|ctrl_reg
)paren
suffix:semicolon
id|ctrl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Check to see if we shifted in a &quot;1&quot;. */
r_if
c_cond
(paren
id|ctrl_reg
op_amp
id|E1000_CTRL_MDIO
)paren
(brace
id|data
op_or_assign
l_int|1
suffix:semicolon
)brace
id|e1000_lower_mdc
c_func
(paren
id|shared
comma
op_amp
id|ctrl_reg
)paren
suffix:semicolon
)brace
id|e1000_raise_mdc
c_func
(paren
id|shared
comma
op_amp
id|ctrl_reg
)paren
suffix:semicolon
id|e1000_lower_mdc
c_func
(paren
id|shared
comma
op_amp
id|ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* Clear the MDIO bit just before leaving this routine. */
id|ctrl_reg
op_and_assign
op_complement
id|E1000_CTRL_MDIO
suffix:semicolon
r_return
(paren
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Force PHY speed and duplex settings to shared-&gt;forced_speed_duplex&n;*&n;* shared - Struct containing variables accessed by shared code&n;******************************************************************************/
r_static
r_void
DECL|function|e1000_phy_force_speed_duplex
id|e1000_phy_force_speed_duplex
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|tctl_reg
suffix:semicolon
r_uint32
id|ctrl_reg
suffix:semicolon
r_uint32
id|shift
suffix:semicolon
r_uint16
id|mii_ctrl_reg
suffix:semicolon
r_uint16
id|mii_status_reg
suffix:semicolon
r_uint16
id|phy_data
suffix:semicolon
r_uint16
id|i
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_force_speed_duplex&quot;
)paren
suffix:semicolon
multiline_comment|/* Turn off Flow control if we are forcing speed and duplex. */
id|shared-&gt;fc
op_assign
id|e1000_fc_none
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;shared-&gt;fc = %d&bslash;n&quot;
comma
id|shared-&gt;fc
)paren
suffix:semicolon
multiline_comment|/* Read the Device Control Register. */
id|ctrl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL
)paren
suffix:semicolon
multiline_comment|/* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */
id|ctrl_reg
op_or_assign
(paren
id|E1000_CTRL_FRCSPD
op_or
id|E1000_CTRL_FRCDPX
)paren
suffix:semicolon
id|ctrl_reg
op_and_assign
op_complement
(paren
id|DEVICE_SPEED_MASK
)paren
suffix:semicolon
multiline_comment|/* Clear the Auto Speed Detect Enable bit. */
id|ctrl_reg
op_and_assign
op_complement
id|E1000_CTRL_ASDE
suffix:semicolon
multiline_comment|/* Read the MII Control Register. */
id|mii_ctrl_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_CTRL
)paren
suffix:semicolon
multiline_comment|/* We need to disable autoneg in order to force link and duplex. */
id|mii_ctrl_reg
op_and_assign
op_complement
id|MII_CR_AUTO_NEG_EN
suffix:semicolon
multiline_comment|/* Are we forcing Full or Half Duplex? */
r_if
c_cond
(paren
id|shared-&gt;forced_speed_duplex
op_eq
id|e1000_100_full
op_logical_or
id|shared-&gt;forced_speed_duplex
op_eq
id|e1000_10_full
)paren
(brace
multiline_comment|/* We want to force full duplex so we SET the full duplex bits&n;         * in the Device and MII Control Registers.&n;         */
id|ctrl_reg
op_or_assign
id|E1000_CTRL_FD
suffix:semicolon
id|mii_ctrl_reg
op_or_assign
id|MII_CR_FULL_DUPLEX
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Full Duplex&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We want to force half duplex so we CLEAR the full duplex&n;         * bits in the Device and MII Control Registers.&n;         */
id|ctrl_reg
op_and_assign
op_complement
id|E1000_CTRL_FD
suffix:semicolon
id|mii_ctrl_reg
op_and_assign
op_complement
id|MII_CR_FULL_DUPLEX
suffix:semicolon
multiline_comment|/* Do this implies HALF */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Half Duplex&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Are we forcing 100Mbps??? */
r_if
c_cond
(paren
id|shared-&gt;forced_speed_duplex
op_eq
id|e1000_100_full
op_logical_or
id|shared-&gt;forced_speed_duplex
op_eq
id|e1000_100_half
)paren
(brace
multiline_comment|/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */
id|ctrl_reg
op_or_assign
id|E1000_CTRL_SPD_100
suffix:semicolon
id|mii_ctrl_reg
op_or_assign
id|MII_CR_SPEED_100
suffix:semicolon
id|mii_ctrl_reg
op_and_assign
op_complement
(paren
id|MII_CR_SPEED_1000
op_or
id|MII_CR_SPEED_10
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Forcing 100mb &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Force 10MB Full or Half */
multiline_comment|/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */
id|ctrl_reg
op_and_assign
op_complement
(paren
id|E1000_CTRL_SPD_1000
op_or
id|E1000_CTRL_SPD_100
)paren
suffix:semicolon
id|mii_ctrl_reg
op_or_assign
id|MII_CR_SPEED_10
suffix:semicolon
id|mii_ctrl_reg
op_and_assign
op_complement
(paren
id|MII_CR_SPEED_1000
op_or
id|MII_CR_SPEED_100
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Forcing 10mb &quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we need to configure the Collision Distance.  We need to read&n;     * the Transmit Control Register to do this.&n;     * Note: This must be done for both Half or Full Duplex.&n;     */
id|tctl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TCTL
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;tctl_reg = %x&bslash;n&quot;
comma
id|tctl_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mii_ctrl_reg
op_amp
id|MII_CR_FULL_DUPLEX
)paren
)paren
(brace
multiline_comment|/* We are in Half Duplex mode so we need to set up our collision&n;        * distance for 10/100.&n;        */
id|tctl_reg
op_and_assign
op_complement
id|E1000_TCTL_COLD
suffix:semicolon
id|shift
op_assign
id|E1000_HDX_COLLISION_DISTANCE
suffix:semicolon
id|shift
op_lshift_assign
id|E1000_COLD_SHIFT
suffix:semicolon
id|tctl_reg
op_or_assign
id|shift
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We are in Full Duplex mode.  We have the same collision&n;         * distance regardless of speed.&n;         */
id|tctl_reg
op_and_assign
op_complement
id|E1000_TCTL_COLD
suffix:semicolon
id|shift
op_assign
id|E1000_FDX_COLLISION_DISTANCE
suffix:semicolon
id|shift
op_lshift_assign
id|E1000_COLD_SHIFT
suffix:semicolon
id|tctl_reg
op_or_assign
id|shift
suffix:semicolon
)brace
multiline_comment|/* Write the configured values back to the Transmit Control Reg. */
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|TCTL
comma
id|tctl_reg
)paren
suffix:semicolon
multiline_comment|/* Write the configured values back to the Device Control Reg. */
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
id|ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* Write the MII Control Register with the new PHY configuration. */
id|phy_data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_CTRL
)paren
suffix:semicolon
multiline_comment|/* Clear Auto-Crossover to force MDI manually.&n;     * M88E1000 requires MDI forced whenever speed/duplex is forced&n;     */
id|phy_data
op_and_assign
op_complement
id|M88E1000_PSCR_AUTO_X_MODE
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_CTRL
comma
id|phy_data
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;M88E1000 PSCR: %x &bslash;n&quot;
comma
id|phy_data
)paren
suffix:semicolon
multiline_comment|/* Need to reset the PHY or these bits will get ignored. */
id|mii_ctrl_reg
op_or_assign
id|MII_CR_RESET
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|PHY_CTRL
comma
id|mii_ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* The wait_autoneg_complete flag may be a little misleading here.&n;     * Since we are forcing speed and duplex, Auto-Neg is not enabled.&n;     * But we do want to delay for a period while forcing only so we&n;     * don&squot;t generate false No Link messages.  So we will wait here&n;     * only if the user has set wait_autoneg_complete to 1, which is&n;     * the default.&n;     */
r_if
c_cond
(paren
id|shared-&gt;wait_autoneg_complete
)paren
(brace
multiline_comment|/* We will wait for autoneg to complete. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Waiting for forced speed/duplex link.&bslash;n&quot;
)paren
suffix:semicolon
id|mii_status_reg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
r_for
c_loop
(paren
id|i
op_assign
id|PHY_FORCE_TIME
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
multiline_comment|/* Read the MII Status Register and wait for Auto-Neg&n;             * Complete bit to be set.&n;             */
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
r_break
suffix:semicolon
)brace
id|msec_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
multiline_comment|/* end for loop */
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We didn&squot;t get link   */
multiline_comment|/* Reset the DSP and wait again for link.   */
id|e1000_phy_reset_dsp
c_func
(paren
id|shared
)paren
suffix:semicolon
)brace
multiline_comment|/* This loop will early-out if the link condition has been met.  */
r_for
c_loop
(paren
id|i
op_assign
id|PHY_FORCE_TIME
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
r_break
suffix:semicolon
)brace
id|msec_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Read the MII Status Register and wait for Auto-Neg&n;             * Complete bit to be set.&n;             */
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
)brace
multiline_comment|/* end for loop */
)brace
multiline_comment|/* end if wait_autoneg_complete */
multiline_comment|/*&n;     * Because we reset the PHY above, we need to re-force TX_CLK in the&n;     * Extended PHY Specific Control Register to 25MHz clock.  This&n;     * value defaults back to a 2.5MHz clock when the PHY is reset.&n;     */
id|phy_data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
)paren
suffix:semicolon
id|phy_data
op_or_assign
id|M88E1000_EPSCR_TX_CLK_25
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
comma
id|phy_data
)paren
suffix:semicolon
multiline_comment|/* In addition, because of the s/w reset above, we need to enable&n;     * CRS on TX.  This must be set for both full and half duplex&n;     * operation.&n;     */
id|phy_data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_CTRL
)paren
suffix:semicolon
id|phy_data
op_or_assign
id|M88E1000_PSCR_ASSERT_CRS_ON_TX
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_CTRL
comma
id|phy_data
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;M88E1000 Phy Specific Ctrl Reg = %4x&bslash;r&bslash;n&quot;
comma
id|phy_data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n;* Reads the value from a PHY register&n;*&n;* shared - Struct containing variables accessed by shared code&n;* reg_addr - address of the PHY register to read&n;******************************************************************************/
r_uint16
DECL|function|e1000_read_phy_reg
id|e1000_read_phy_reg
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint32
id|reg_addr
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_uint32
id|data
op_assign
l_int|0
suffix:semicolon
r_uint32
id|command
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|reg_addr
op_le
id|MAX_PHY_REG_ADDRESS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shared-&gt;mac_type
OG
id|e1000_82543
)paren
(brace
multiline_comment|/* Set up Op-code, Phy Address, and&n;         * register address in the MDI Control register.  The MAC will&n;         * take care of interfacing with the PHY to retrieve the&n;         * desired data.&n;         */
id|command
op_assign
(paren
(paren
id|reg_addr
op_lshift
id|E1000_MDIC_REG_SHIFT
)paren
op_or
(paren
id|shared-&gt;phy_addr
op_lshift
id|E1000_MDIC_PHY_SHIFT
)paren
op_or
(paren
id|E1000_MDIC_OP_READ
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|MDIC
comma
id|command
)paren
suffix:semicolon
multiline_comment|/* Check every 10 usec to see if the read completed.  The read&n;         * may take as long as 64 usecs (we&squot;ll wait 100 usecs max)&n;         * from the CPU Write to the Ready bit assertion.&n;         */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
(brace
id|usec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|data
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|MDIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|E1000_MDIC_READY
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* We must first send a preamble through the MDIO pin to signal the&n;         * beginning of an MII instruction.  This is done by sending 32&n;         * consecutive &quot;1&quot; bits.&n;         */
id|e1000_phy_shift_out
c_func
(paren
id|shared
comma
id|PHY_PREAMBLE
comma
id|PHY_PREAMBLE_SIZE
)paren
suffix:semicolon
multiline_comment|/* Now combine the next few fields that are required for a read&n;         * operation.  We use this method instead of calling the&n;         * e1000_phy_shift_out routine five different times.  The format of&n;         * a MII read instruction consists of a shift out of 14 bits and is&n;         * defined as follows:&n;         *    &lt;Preamble&gt;&lt;SOF&gt;&lt;Op Code&gt;&lt;Phy Addr&gt;&lt;Reg Addr&gt;&n;         * followed by a shift in of 18 bits.  This first two bits shifted&n;         * in are TurnAround bits used to avoid contention on the MDIO pin&n;         * when a READ operation is performed.  These two bits are thrown&n;         * away followed by a shift in of 16 bits which contains the&n;         * desired data.&n;         */
id|command
op_assign
(paren
(paren
id|reg_addr
)paren
op_or
(paren
id|shared-&gt;phy_addr
op_lshift
l_int|5
)paren
op_or
(paren
id|PHY_OP_READ
op_lshift
l_int|10
)paren
op_or
(paren
id|PHY_SOF
op_lshift
l_int|12
)paren
)paren
suffix:semicolon
id|e1000_phy_shift_out
c_func
(paren
id|shared
comma
id|command
comma
l_int|14
)paren
suffix:semicolon
multiline_comment|/* Now that we&squot;ve shifted out the read command to the MII, we need&n;         * to &quot;shift in&quot; the 16-bit value (18 total bits) of the requested&n;         * PHY register address.&n;         */
id|data
op_assign
(paren
r_uint32
)paren
id|e1000_phy_shift_in
c_func
(paren
id|shared
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|data
op_amp
id|E1000_MDIC_ERROR
)paren
)paren
suffix:semicolon
r_return
(paren
(paren
r_uint16
)paren
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Writes a value to a PHY register&n;*&n;* shared - Struct containing variables accessed by shared code&n;* reg_addr - address of the PHY register to write&n;* data - data to write to the PHY&n;******************************************************************************/
r_void
DECL|function|e1000_write_phy_reg
id|e1000_write_phy_reg
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint32
id|reg_addr
comma
r_uint16
id|data
)paren
(brace
r_uint32
id|i
suffix:semicolon
r_uint32
id|command
op_assign
l_int|0
suffix:semicolon
r_uint32
id|mdic_reg
suffix:semicolon
id|ASSERT
c_func
(paren
id|reg_addr
op_le
id|MAX_PHY_REG_ADDRESS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shared-&gt;mac_type
OG
id|e1000_82543
)paren
(brace
multiline_comment|/* Set up Op-code, Phy Address, register&n;         * address, and data intended for the PHY register in the MDI&n;         * Control register.  The MAC will take care of interfacing&n;         * with the PHY to send the desired data.&n;         */
id|command
op_assign
(paren
(paren
(paren
r_uint32
)paren
id|data
)paren
op_or
(paren
id|reg_addr
op_lshift
id|E1000_MDIC_REG_SHIFT
)paren
op_or
(paren
id|shared-&gt;phy_addr
op_lshift
id|E1000_MDIC_PHY_SHIFT
)paren
op_or
(paren
id|E1000_MDIC_OP_WRITE
)paren
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|MDIC
comma
id|command
)paren
suffix:semicolon
multiline_comment|/* Check every 10 usec to see if the read completed.  The read&n;         * may take as long as 64 usecs (we&squot;ll wait 100 usecs max)&n;         * from the CPU Write to the Ready bit assertion.&n;         */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|usec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|mdic_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|MDIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mdic_reg
op_amp
id|E1000_MDIC_READY
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* We&squot;ll need to use the SW defined pins to shift the write command&n;         *  out to the PHY. We first send a preamble to the PHY to signal the&n;         * beginning of the MII instruction.  This is done by sending 32 &n;         * consecutive &quot;1&quot; bits.&n;         */
id|e1000_phy_shift_out
c_func
(paren
id|shared
comma
id|PHY_PREAMBLE
comma
id|PHY_PREAMBLE_SIZE
)paren
suffix:semicolon
multiline_comment|/* Now combine the remaining required fields that will indicate&n;         * a write operation.  We use this method instead of calling the&n;         * e1000_phy_shift_out routine for each field in the command.  The&n;         * format of a MII write instruction is as follows:&n;         * &lt;Preamble&gt;&lt;SOF&gt;&lt;Op Code&gt;&lt;Phy Addr&gt;&lt;Reg Addr&gt;&lt;Turnaround&gt;&lt;Data&gt;.&n;         */
id|command
op_assign
(paren
(paren
id|PHY_TURNAROUND
)paren
op_or
(paren
id|reg_addr
op_lshift
l_int|2
)paren
op_or
(paren
id|shared-&gt;phy_addr
op_lshift
l_int|7
)paren
op_or
(paren
id|PHY_OP_WRITE
op_lshift
l_int|12
)paren
op_or
(paren
id|PHY_SOF
op_lshift
l_int|14
)paren
)paren
suffix:semicolon
id|command
op_lshift_assign
l_int|16
suffix:semicolon
id|command
op_or_assign
(paren
(paren
r_uint32
)paren
id|data
)paren
suffix:semicolon
id|e1000_phy_shift_out
c_func
(paren
id|shared
comma
id|command
comma
l_int|32
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Returns the PHY to the power-on reset state&n;*&n;* shared - Struct containing variables accessed by shared code&n;******************************************************************************/
r_void
DECL|function|e1000_phy_hw_reset
id|e1000_phy_hw_reset
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|ctrl_reg
suffix:semicolon
r_uint32
id|ctrl_ext_reg
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_hw_reset&quot;
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Resetting Phy...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shared-&gt;mac_type
OG
id|e1000_82543
)paren
(brace
multiline_comment|/* Read the device control register and assert the&n;         * E1000_CTRL_PHY_RST bit.  Hold for 20ms and then take it out&n;         * of reset.&n;         */
id|ctrl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL
)paren
suffix:semicolon
id|ctrl_reg
op_or_assign
id|E1000_CTRL_PHY_RST
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
id|ctrl_reg
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|ctrl_reg
op_and_assign
op_complement
id|E1000_CTRL_PHY_RST
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
id|ctrl_reg
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|20
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Read the Extended Device Control Register, assert the&n;         * PHY_RESET_DIR bit.  Then clock it out to the PHY.&n;         */
id|ctrl_ext_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL_EXT
)paren
suffix:semicolon
id|ctrl_ext_reg
op_or_assign
id|E1000_CTRL_PHY_RESET_DIR4
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL_EXT
comma
id|ctrl_ext_reg
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|20
)paren
suffix:semicolon
multiline_comment|/* Set the reset bit in the device control register and clock&n;         * it out to the PHY.&n;         */
id|ctrl_ext_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL_EXT
)paren
suffix:semicolon
id|ctrl_ext_reg
op_and_assign
op_complement
id|E1000_CTRL_PHY_RESET4
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL_EXT
comma
id|ctrl_ext_reg
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|ctrl_ext_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL_EXT
)paren
suffix:semicolon
id|ctrl_ext_reg
op_or_assign
id|E1000_CTRL_PHY_RESET4
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL_EXT
comma
id|ctrl_ext_reg
)paren
suffix:semicolon
id|msec_delay
c_func
(paren
l_int|20
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Resets the PHY&n;*&n;* shared - Struct containing variables accessed by shared code&n;*&n;* Sets bit 15 of the MII Control regiser&n;******************************************************************************/
id|boolean_t
DECL|function|e1000_phy_reset
id|e1000_phy_reset
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint16
id|reg_data
suffix:semicolon
r_uint16
id|i
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_reset&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the MII control register, set the reset bit and write the&n;     * value back by clocking it out to the PHY.&n;     */
id|reg_data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_CTRL
)paren
suffix:semicolon
id|reg_data
op_or_assign
id|MII_CR_RESET
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|PHY_CTRL
comma
id|reg_data
)paren
suffix:semicolon
multiline_comment|/* Wait for bit 15 of the MII Control Register to be cleared&n;     * indicating the PHY has been reset.&n;     */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|reg_data
op_amp
id|MII_CR_RESET
)paren
op_logical_and
id|i
op_increment
OL
l_int|500
)paren
(brace
id|reg_data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_CTRL
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
l_int|500
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Timeout waiting for PHY to reset.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Detects which PHY is present and the speed and duplex&n;*&n;* shared - Struct containing variables accessed by shared code&n;* ctrl_reg - current value of the device control register&n;******************************************************************************/
id|boolean_t
DECL|function|e1000_phy_setup
id|e1000_phy_setup
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint32
id|ctrl_reg
)paren
(brace
r_uint16
id|mii_ctrl_reg
suffix:semicolon
r_uint16
id|mii_status_reg
suffix:semicolon
r_uint16
id|phy_specific_ctrl_reg
suffix:semicolon
r_uint16
id|mii_autoneg_adv_reg
suffix:semicolon
r_uint16
id|mii_1000t_ctrl_reg
suffix:semicolon
r_uint16
id|i
suffix:semicolon
r_uint16
id|data
suffix:semicolon
r_uint16
id|autoneg_hw_setting
suffix:semicolon
r_uint16
id|autoneg_fc_setting
suffix:semicolon
id|boolean_t
id|restart_autoneg
op_assign
id|FALSE
suffix:semicolon
id|boolean_t
id|force_autoneg_restart
op_assign
id|FALSE
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_setup&quot;
)paren
suffix:semicolon
multiline_comment|/* We want to enable the Auto-Speed Detection bit in the Device&n;     * Control Register.  When set to 1, the MAC automatically detects&n;     * the resolved speed of the link and self-configures appropriately.&n;     * The Set Link Up bit must also be set for this behavior work&n;     * properly.&n;     */
multiline_comment|/* Nothing but 82543 and newer */
id|ASSERT
c_func
(paren
id|shared-&gt;mac_type
op_ge
id|e1000_82543
)paren
suffix:semicolon
multiline_comment|/* With 82543, we need to force speed/duplex&n;     * on the MAC equal to what the PHY speed/duplex configuration is.&n;     * In addition, on 82543, we need to perform a hardware reset&n;     * on the PHY to take it out of reset.&n;     */
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_ge
id|e1000_82544
)paren
(brace
id|ctrl_reg
op_or_assign
id|E1000_CTRL_SLU
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
id|ctrl_reg
)paren
suffix:semicolon
)brace
r_else
(brace
id|ctrl_reg
op_or_assign
(paren
id|E1000_CTRL_FRCSPD
op_or
id|E1000_CTRL_FRCDPX
op_or
id|E1000_CTRL_SLU
)paren
suffix:semicolon
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
id|ctrl_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_eq
id|e1000_82543
)paren
(brace
id|e1000_phy_hw_reset
c_func
(paren
id|shared
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|e1000_detect_gig_phy
c_func
(paren
id|shared
)paren
)paren
(brace
multiline_comment|/* No PHY detected, return FALSE */
id|DEBUGOUT
c_func
(paren
l_string|&quot;PhySetup failure, did not detect valid phy.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Phy ID = %x &bslash;n&quot;
comma
id|shared-&gt;phy_id
)paren
suffix:semicolon
multiline_comment|/* Read the MII Control Register. */
id|mii_ctrl_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_CTRL
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;MII Ctrl Reg contents = %x&bslash;n&quot;
comma
id|mii_ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* Check to see if the Auto Neg Enable bit is set in the MII Control&n;     * Register.  If not, we could be in a situation where a driver was&n;     * loaded previously and was forcing speed and duplex.  Then the&n;     * driver was unloaded but a e1000_phy_hw_reset was not performed, so&n;     * link was still being forced and link was still achieved.  Then&n;     * the driver was reloaded with the intention to auto-negotiate, but&n;     * since link is already established we end up not restarting&n;     * auto-neg.  So if the auto-neg bit is not enabled and the driver&n;     * is being loaded with the desire to auto-neg, we set this flag to&n;     * to ensure the restart of the auto-neg engine later in the logic.&n;     */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mii_ctrl_reg
op_amp
id|MII_CR_AUTO_NEG_EN
)paren
)paren
(brace
id|force_autoneg_restart
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* Clear the isolate bit for normal operation and write it back to&n;     * the MII Control Reg.  Although the spec says this doesn&squot;t need&n;     * to be done when the PHY address is not equal to zero, we do it&n;     * anyway just to be safe.&n;     */
id|mii_ctrl_reg
op_and_assign
op_complement
(paren
id|MII_CR_ISOLATE
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|PHY_CTRL
comma
id|mii_ctrl_reg
)paren
suffix:semicolon
id|data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_CTRL
)paren
suffix:semicolon
multiline_comment|/* Enable CRS on TX.  This must be set for half-duplex operation. */
id|data
op_or_assign
id|M88E1000_PSCR_ASSERT_CRS_ON_TX
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;M88E1000 PSCR: %x &bslash;n&quot;
comma
id|data
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_CTRL
comma
id|data
)paren
suffix:semicolon
id|data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
)paren
suffix:semicolon
multiline_comment|/* Force TX_CLK in the Extended PHY Specific Control Register&n;     * to 25MHz clock.&n;     */
id|data
op_or_assign
id|M88E1000_EPSCR_TX_CLK_25
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* Certain PHYs will set the default of MII register 4 differently.&n;     * We need to check this against our fc value.  If it is&n;     * different, we need to setup up register 4 correctly and restart&n;     * autonegotiation.&n;     */
multiline_comment|/* Read the MII Auto-Neg Advertisement Register (Address 4). */
id|mii_autoneg_adv_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_AUTONEG_ADV
)paren
suffix:semicolon
multiline_comment|/* Shift right to put 10T-Half bit in bit 0&n;     * Isolate the four bits for 100/10 Full/Half.&n;     */
id|autoneg_hw_setting
op_assign
(paren
id|mii_autoneg_adv_reg
op_rshift
l_int|5
)paren
op_amp
l_int|0xF
suffix:semicolon
multiline_comment|/* Get the 1000T settings. */
id|mii_1000t_ctrl_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_1000T_CTRL
)paren
suffix:semicolon
multiline_comment|/* Isolate and OR in the 1000T settings. */
id|autoneg_hw_setting
op_or_assign
(paren
(paren
id|mii_1000t_ctrl_reg
op_amp
l_int|0x0300
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
multiline_comment|/* mask all bits in the MII Auto-Neg Advertisement Register&n;     * except for ASM_DIR and PAUSE and shift.  This value&n;     * will be used later to see if we need to restart Auto-Negotiation.&n;     */
id|autoneg_fc_setting
op_assign
(paren
(paren
id|mii_autoneg_adv_reg
op_amp
l_int|0x0C00
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Perform some bounds checking on the shared-&gt;autoneg_advertised&n;     * parameter.  If this variable is zero, then set it to the default.&n;     */
id|shared-&gt;autoneg_advertised
op_and_assign
id|AUTONEG_ADVERTISE_SPEED_DEFAULT
suffix:semicolon
multiline_comment|/* If autoneg_advertised is zero, we assume it was not defaulted&n;     * by the calling code so we set to advertise full capability.&n;     */
r_if
c_cond
(paren
id|shared-&gt;autoneg_advertised
op_eq
l_int|0
)paren
(brace
id|shared-&gt;autoneg_advertised
op_assign
id|AUTONEG_ADVERTISE_SPEED_DEFAULT
suffix:semicolon
)brace
multiline_comment|/* We could be in the situation where Auto-Neg has already completed&n;     * and the user has not indicated any overrides.  In this case we&n;     * simply need to call e1000_get_speed_and_duplex to obtain the Auto-&n;     * Negotiated speed and duplex, then return.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|force_autoneg_restart
op_logical_and
id|shared-&gt;autoneg
op_logical_and
(paren
id|shared-&gt;autoneg_advertised
op_eq
id|autoneg_hw_setting
)paren
op_logical_and
(paren
id|shared-&gt;fc
op_eq
id|autoneg_fc_setting
)paren
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;No overrides - Reading MII Status Reg..&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the MII Status Register.  We read this twice because&n;         * certain bits are &quot;sticky&quot; and need to be read twice.&n;         */
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;MII Status Reg contents = %x&bslash;n&quot;
comma
id|mii_status_reg
)paren
suffix:semicolon
multiline_comment|/* Do we have link now? (if so, auto-neg has completed) */
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
id|data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_STATUS
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;M88E1000 Phy Specific Status Reg contents = %x&bslash;n&quot;
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* We have link, so we need to finish the config process:&n;             *   1) Set up the MAC to the current PHY speed/duplex&n;             *      if we are on 82543.  If we&n;             *      are on newer silicon, we only need to configure&n;             *      collision distance in the Transmit Control Register.&n;             *   2) Set up flow control on the MAC to that established&n;             *      with the link partner.&n;             */
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_ge
id|e1000_82544
)paren
(brace
id|e1000_config_collision_dist
c_func
(paren
id|shared
)paren
suffix:semicolon
)brace
r_else
id|e1000_config_mac_to_phy
c_func
(paren
id|shared
comma
id|data
)paren
suffix:semicolon
id|e1000_config_fc_after_link_up
c_func
(paren
id|shared
)paren
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Options:&n;     *   MDI/MDI-X = 0 (default)&n;     *   0 - Auto for all speeds&n;     *   1 - MDI mode&n;     *   2 - MDI-X mode&n;     *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)&n;     */
id|phy_specific_ctrl_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_CTRL
)paren
suffix:semicolon
id|phy_specific_ctrl_reg
op_and_assign
op_complement
id|M88E1000_PSCR_AUTO_X_MODE
suffix:semicolon
r_switch
c_cond
(paren
id|shared-&gt;mdix
)paren
(brace
r_case
l_int|1
suffix:colon
id|phy_specific_ctrl_reg
op_or_assign
id|M88E1000_PSCR_MDI_MANUAL_MODE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|phy_specific_ctrl_reg
op_or_assign
id|M88E1000_PSCR_MDIX_MANUAL_MODE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|phy_specific_ctrl_reg
op_or_assign
id|M88E1000_PSCR_AUTO_X_1000T
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_default
suffix:colon
id|phy_specific_ctrl_reg
op_or_assign
id|M88E1000_PSCR_AUTO_X_MODE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_CTRL
comma
id|phy_specific_ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* Options:&n;     *   disable_polarity_correction = 0 (default)&n;     *       Automatic Correction for Reversed Cable Polarity&n;     *   0 - Disabled&n;     *   1 - Enabled&n;     */
id|phy_specific_ctrl_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_CTRL
)paren
suffix:semicolon
id|phy_specific_ctrl_reg
op_and_assign
op_complement
id|M88E1000_PSCR_POLARITY_REVERSAL
suffix:semicolon
r_if
c_cond
(paren
id|shared-&gt;disable_polarity_correction
op_eq
l_int|1
)paren
(brace
id|phy_specific_ctrl_reg
op_or_assign
id|M88E1000_PSCR_POLARITY_REVERSAL
suffix:semicolon
)brace
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_CTRL
comma
id|phy_specific_ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* Options:&n;     *   autoneg = 1 (default)&n;     *      PHY will advertise value(s) parsed from&n;     *      autoneg_advertised and fc&n;     *   autoneg = 0&n;     *      PHY will be set to 10H, 10F, 100H, or 100F&n;     *      depending on value parsed from forced_speed_duplex.&n;     */
multiline_comment|/* Is autoneg enabled?  This is enabled by default or by software override.&n;     * If so, call e1000_phy_setup_autoneg routine to parse the&n;     * autoneg_advertised and fc options. If autoneg is NOT enabled, then the&n;     * user should have provided a speed/duplex override.  If so, then call&n;     * e1000_phy_force_speed_duplex to parse and set this up.  Otherwise,&n;     * we are in an error situation and need to bail.&n;     */
r_if
c_cond
(paren
id|shared-&gt;autoneg
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Reconfiguring auto-neg advertisement params&bslash;n&quot;
)paren
suffix:semicolon
id|restart_autoneg
op_assign
id|e1000_phy_setup_autoneg
c_func
(paren
id|shared
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Forcing speed and duplex&bslash;n&quot;
)paren
suffix:semicolon
id|e1000_phy_force_speed_duplex
c_func
(paren
id|shared
)paren
suffix:semicolon
)brace
multiline_comment|/* Based on information parsed above, check the flag to indicate&n;     * whether we need to restart Auto-Neg.&n;     */
r_if
c_cond
(paren
id|restart_autoneg
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Restarting Auto-Neg&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the MII Control Register. */
id|mii_ctrl_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_CTRL
)paren
suffix:semicolon
multiline_comment|/* Restart auto-negotiation by setting the Auto Neg Enable bit and&n;         * the Auto Neg Restart bit.&n;         */
id|mii_ctrl_reg
op_or_assign
(paren
id|MII_CR_AUTO_NEG_EN
op_or
id|MII_CR_RESTART_AUTO_NEG
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|PHY_CTRL
comma
id|mii_ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* Does the user want to wait for Auto-Neg to complete here, or&n;         * check at a later time (for example, callback routine).&n;         */
r_if
c_cond
(paren
id|shared-&gt;wait_autoneg_complete
)paren
(brace
id|e1000_wait_autoneg
c_func
(paren
id|shared
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end if restart_autoneg */
multiline_comment|/* Read the MII Status Register. */
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Checking for link status - MII Status Reg contents = %x&bslash;n&quot;
comma
id|mii_status_reg
)paren
suffix:semicolon
multiline_comment|/* Check link status.  Wait up to 100 microseconds for link to&n;     * become valid.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
r_break
suffix:semicolon
)brace
id|usec_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;. &quot;
)paren
suffix:semicolon
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_LINK_STATUS
)paren
(brace
multiline_comment|/* Yes, so configure MAC to PHY settings as well as flow control&n;         * registers.&n;         */
id|data
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_STATUS
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;M88E1000 Phy Specific Status Reg contents = %x&bslash;n&quot;
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* We have link, so we need to finish the config process:&n;         *   1) Set up the MAC to the current PHY speed/duplex&n;         *      if we are on 82543.  If we&n;         *      are on newer silicon, we only need to configure&n;         *      collision distance in the Transmit Control Register.&n;         *   2) Set up flow control on the MAC to that established with&n;         *      the link partner.&n;         */
r_if
c_cond
(paren
id|shared-&gt;mac_type
op_ge
id|e1000_82544
)paren
(brace
id|e1000_config_collision_dist
c_func
(paren
id|shared
)paren
suffix:semicolon
)brace
r_else
id|e1000_config_mac_to_phy
c_func
(paren
id|shared
comma
id|data
)paren
suffix:semicolon
id|e1000_config_fc_after_link_up
c_func
(paren
id|shared
)paren
suffix:semicolon
id|DEBUGOUT
c_func
(paren
l_string|&quot;Valid link established!!!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Unable to establish link!!!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Configures PHY autoneg and flow control advertisement settings&n;*&n;* shared - Struct containing variables accessed by shared code&n;******************************************************************************/
id|boolean_t
DECL|function|e1000_phy_setup_autoneg
id|e1000_phy_setup_autoneg
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint16
id|mii_autoneg_adv_reg
suffix:semicolon
r_uint16
id|mii_1000t_ctrl_reg
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_phy_setup_autoneg&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the MII Auto-Neg Advertisement Register (Address 4). */
id|mii_autoneg_adv_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_AUTONEG_ADV
)paren
suffix:semicolon
multiline_comment|/* Read the MII 1000Base-T Control Register (Address 9). */
id|mii_1000t_ctrl_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_1000T_CTRL
)paren
suffix:semicolon
multiline_comment|/* Need to parse both autoneg_advertised and fc and set up&n;     * the appropriate PHY registers.  First we will parse for&n;     * autoneg_advertised software override.  Since we can advertise&n;     * a plethora of combinations, we need to check each bit&n;     * individually.&n;     */
multiline_comment|/* First we clear all the 10/100 mb speed bits in the Auto-Neg&n;     * Advertisement Register (Address 4) and the 1000 mb speed bits in&n;     * the  1000Base-T Control Register (Address 9).&n;     */
id|mii_autoneg_adv_reg
op_and_assign
op_complement
id|REG4_SPEED_MASK
suffix:semicolon
id|mii_1000t_ctrl_reg
op_and_assign
op_complement
id|REG9_SPEED_MASK
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;autoneg_advertised %x&bslash;n&quot;
comma
id|shared-&gt;autoneg_advertised
)paren
suffix:semicolon
multiline_comment|/* Do we want to advertise 10 Mb Half Duplex? */
r_if
c_cond
(paren
id|shared-&gt;autoneg_advertised
op_amp
id|ADVERTISE_10_HALF
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 10mb Half duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_10T_HD_CAPS
suffix:semicolon
)brace
multiline_comment|/* Do we want to advertise 10 Mb Full Duplex? */
r_if
c_cond
(paren
id|shared-&gt;autoneg_advertised
op_amp
id|ADVERTISE_10_FULL
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 10mb Full duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_10T_FD_CAPS
suffix:semicolon
)brace
multiline_comment|/* Do we want to advertise 100 Mb Half Duplex? */
r_if
c_cond
(paren
id|shared-&gt;autoneg_advertised
op_amp
id|ADVERTISE_100_HALF
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 100mb Half duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_100TX_HD_CAPS
suffix:semicolon
)brace
multiline_comment|/* Do we want to advertise 100 Mb Full Duplex? */
r_if
c_cond
(paren
id|shared-&gt;autoneg_advertised
op_amp
id|ADVERTISE_100_FULL
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 100mb Full duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_100TX_FD_CAPS
suffix:semicolon
)brace
multiline_comment|/* We do not allow the Phy to advertise 1000 Mb Half Duplex */
r_if
c_cond
(paren
id|shared-&gt;autoneg_advertised
op_amp
id|ADVERTISE_1000_HALF
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 1000mb Half duplex requested, request denied!&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Do we want to advertise 1000 Mb Full Duplex? */
r_if
c_cond
(paren
id|shared-&gt;autoneg_advertised
op_amp
id|ADVERTISE_1000_FULL
)paren
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Advertise 1000mb Full duplex&bslash;n&quot;
)paren
suffix:semicolon
id|mii_1000t_ctrl_reg
op_or_assign
id|CR_1000T_FD_CAPS
suffix:semicolon
)brace
multiline_comment|/* Check for a software override of the flow control settings, and&n;     * setup the PHY advertisement registers accordingly.  If&n;     * auto-negotiation is enabled, then software will have to set the&n;     * &quot;PAUSE&quot; bits to the correct value in the Auto-Negotiation&n;     * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.&n;     *&n;     * The possible values of the &quot;fc&quot; parameter are:&n;     *      0:  Flow control is completely disabled&n;     *      1:  Rx flow control is enabled (we can receive pause frames&n;     *          but not send pause frames).&n;     *      2:  Tx flow control is enabled (we can send pause frames&n;     *          but we do not support receiving pause frames).&n;     *      3:  Both Rx and TX flow control (symmetric) are enabled.&n;     *  other:  No software override.  The flow control configuration&n;     *          in the EEPROM is used.&n;     */
r_switch
c_cond
(paren
id|shared-&gt;fc
)paren
(brace
r_case
id|e1000_fc_none
suffix:colon
multiline_comment|/* 0 */
multiline_comment|/* Flow control (RX &amp; TX) is completely disabled by a&n;             * software over-ride.&n;             */
id|mii_autoneg_adv_reg
op_and_assign
op_complement
(paren
id|NWAY_AR_ASM_DIR
op_or
id|NWAY_AR_PAUSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_rx_pause
suffix:colon
multiline_comment|/* 1 */
multiline_comment|/* RX Flow control is enabled, and TX Flow control is&n;             * disabled, by a software over-ride.&n;             */
multiline_comment|/* Since there really isn&squot;t a way to advertise that we are&n;             * capable of RX Pause ONLY, we will advertise that we&n;             * support both symmetric and asymmetric RX PAUSE.  Later&n;             * (in e1000_config_fc_after_link_up) we will disable the&n;             *shared&squot;s ability to send PAUSE frames.&n;             */
id|mii_autoneg_adv_reg
op_or_assign
(paren
id|NWAY_AR_ASM_DIR
op_or
id|NWAY_AR_PAUSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_tx_pause
suffix:colon
multiline_comment|/* 2 */
multiline_comment|/* TX Flow control is enabled, and RX Flow control is&n;             * disabled, by a software over-ride.&n;             */
id|mii_autoneg_adv_reg
op_or_assign
id|NWAY_AR_ASM_DIR
suffix:semicolon
id|mii_autoneg_adv_reg
op_and_assign
op_complement
id|NWAY_AR_PAUSE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|e1000_fc_full
suffix:colon
multiline_comment|/* 3 */
multiline_comment|/* Flow control (both RX and TX) is enabled by a software&n;             * over-ride.&n;             */
id|mii_autoneg_adv_reg
op_or_assign
(paren
id|NWAY_AR_ASM_DIR
op_or
id|NWAY_AR_PAUSE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* We should never get here.  The value should be 0-3. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Flow control param set incorrectly&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Write the MII Auto-Neg Advertisement Register (Address 4). */
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|PHY_AUTONEG_ADV
comma
id|mii_autoneg_adv_reg
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;Auto-Neg Advertising %x&bslash;n&quot;
comma
id|mii_autoneg_adv_reg
)paren
suffix:semicolon
multiline_comment|/* Write the MII 1000Base-T Control Register (Address 9). */
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
id|PHY_1000T_CTRL
comma
id|mii_1000t_ctrl_reg
)paren
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Sets MAC speed and duplex settings to reflect the those in the PHY&n;*&n;* shared - Struct containing variables accessed by shared code&n;* mii_reg - data to write to the MII control register&n;*&n;* The contents of the PHY register containing the needed information need to&n;* be passed in.&n;******************************************************************************/
r_void
DECL|function|e1000_config_mac_to_phy
id|e1000_config_mac_to_phy
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_uint16
id|mii_reg
)paren
(brace
r_uint32
id|ctrl_reg
suffix:semicolon
r_uint32
id|tctl_reg
suffix:semicolon
r_uint32
id|shift
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_config_mac_to_phy&quot;
)paren
suffix:semicolon
multiline_comment|/* We need to read the Transmit Control register to configure the&n;     * collision distance.&n;     * Note: This must be done for both Half or Full Duplex.&n;     */
id|tctl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TCTL
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;tctl_reg = %x&bslash;n&quot;
comma
id|tctl_reg
)paren
suffix:semicolon
multiline_comment|/* Read the Device Control Register and set the bits to Force Speed&n;     * and Duplex.&n;     */
id|ctrl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|CTRL
)paren
suffix:semicolon
id|ctrl_reg
op_or_assign
(paren
id|E1000_CTRL_FRCSPD
op_or
id|E1000_CTRL_FRCDPX
)paren
suffix:semicolon
id|ctrl_reg
op_and_assign
op_complement
(paren
id|DEVICE_SPEED_MASK
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;MII Register Data = %x&bslash;r&bslash;n&quot;
comma
id|mii_reg
)paren
suffix:semicolon
multiline_comment|/* Clear the ILOS bit. */
id|ctrl_reg
op_and_assign
op_complement
id|E1000_CTRL_ILOS
suffix:semicolon
multiline_comment|/* Set up duplex in the Device Control and Transmit Control&n;     * registers depending on negotiated values.&n;     */
r_if
c_cond
(paren
id|mii_reg
op_amp
id|M88E1000_PSSR_DPLX
)paren
(brace
id|ctrl_reg
op_or_assign
id|E1000_CTRL_FD
suffix:semicolon
multiline_comment|/* We are in Full Duplex mode.  We have the same collision&n;         * distance regardless of speed.&n;         */
id|tctl_reg
op_and_assign
op_complement
id|E1000_TCTL_COLD
suffix:semicolon
id|shift
op_assign
id|E1000_FDX_COLLISION_DISTANCE
suffix:semicolon
id|shift
op_lshift_assign
id|E1000_COLD_SHIFT
suffix:semicolon
id|tctl_reg
op_or_assign
id|shift
suffix:semicolon
)brace
r_else
(brace
id|ctrl_reg
op_and_assign
op_complement
id|E1000_CTRL_FD
suffix:semicolon
multiline_comment|/* We are in Half Duplex mode.  Our Half Duplex collision&n;         * distance is different for Gigabit than for 10/100 so we will&n;         * set accordingly.&n;         */
r_if
c_cond
(paren
(paren
id|mii_reg
op_amp
id|M88E1000_PSSR_SPEED
)paren
op_eq
id|M88E1000_PSSR_1000MBS
)paren
(brace
multiline_comment|/* 1000Mbs HDX */
id|tctl_reg
op_and_assign
op_complement
id|E1000_TCTL_COLD
suffix:semicolon
id|shift
op_assign
id|E1000_GB_HDX_COLLISION_DISTANCE
suffix:semicolon
id|shift
op_lshift_assign
id|E1000_COLD_SHIFT
suffix:semicolon
id|tctl_reg
op_or_assign
id|shift
suffix:semicolon
id|tctl_reg
op_or_assign
id|E1000_TCTL_PBE
suffix:semicolon
multiline_comment|/* Enable Packet Bursting */
)brace
r_else
(brace
multiline_comment|/* 10/100Mbs HDX */
id|tctl_reg
op_and_assign
op_complement
id|E1000_TCTL_COLD
suffix:semicolon
id|shift
op_assign
id|E1000_HDX_COLLISION_DISTANCE
suffix:semicolon
id|shift
op_lshift_assign
id|E1000_COLD_SHIFT
suffix:semicolon
id|tctl_reg
op_or_assign
id|shift
suffix:semicolon
)brace
)brace
multiline_comment|/* Set up speed in the Device Control register depending on&n;     * negotiated values.&n;     */
r_if
c_cond
(paren
(paren
id|mii_reg
op_amp
id|M88E1000_PSSR_SPEED
)paren
op_eq
id|M88E1000_PSSR_1000MBS
)paren
(brace
id|ctrl_reg
op_or_assign
id|E1000_CTRL_SPD_1000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|mii_reg
op_amp
id|M88E1000_PSSR_SPEED
)paren
op_eq
id|M88E1000_PSSR_100MBS
)paren
(brace
id|ctrl_reg
op_or_assign
id|E1000_CTRL_SPD_100
suffix:semicolon
)brace
r_else
id|ctrl_reg
op_and_assign
op_complement
(paren
id|E1000_CTRL_SPD_1000
op_or
id|E1000_CTRL_SPD_100
)paren
suffix:semicolon
multiline_comment|/* Write the configured values back to the Transmit Control Reg. */
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|TCTL
comma
id|tctl_reg
)paren
suffix:semicolon
multiline_comment|/* Write the configured values back to the Device Control Reg. */
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|CTRL
comma
id|ctrl_reg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Sets the collision distance in the Transmit Control register&n;*&n;* shared - Struct containing variables accessed by shared code&n;*&n;* Link should have been established previously. Reads the speed and duplex&n;* information from the Device Status register.&n;******************************************************************************/
r_void
DECL|function|e1000_config_collision_dist
id|e1000_config_collision_dist
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|tctl_reg
suffix:semicolon
r_uint16
id|speed
suffix:semicolon
r_uint16
id|duplex
suffix:semicolon
r_uint32
id|shift
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_config_collision_dist&quot;
)paren
suffix:semicolon
multiline_comment|/* Get our current speed and duplex from the Device Status Register. */
id|e1000_get_speed_and_duplex
c_func
(paren
id|shared
comma
op_amp
id|speed
comma
op_amp
id|duplex
)paren
suffix:semicolon
multiline_comment|/* We need to configure the Collision Distance for both Full or&n;     * Half Duplex.&n;     */
id|tctl_reg
op_assign
id|E1000_READ_REG
c_func
(paren
id|shared
comma
id|TCTL
)paren
suffix:semicolon
id|DEBUGOUT1
c_func
(paren
l_string|&quot;tctl_reg = %x&bslash;n&quot;
comma
id|tctl_reg
)paren
suffix:semicolon
multiline_comment|/* mask the Collision Distance bits in the Transmit Control Reg. */
id|tctl_reg
op_and_assign
op_complement
id|E1000_TCTL_COLD
suffix:semicolon
r_if
c_cond
(paren
id|duplex
op_eq
id|FULL_DUPLEX
)paren
(brace
multiline_comment|/* We are in Full Duplex mode.  Therefore, the collision distance&n;         * is the same regardless of speed.&n;         */
id|shift
op_assign
id|E1000_FDX_COLLISION_DISTANCE
suffix:semicolon
id|shift
op_lshift_assign
id|E1000_COLD_SHIFT
suffix:semicolon
id|tctl_reg
op_or_assign
id|shift
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We are in Half Duplex mode.  Half Duplex collision distance is&n;         * different for Gigabit vs. 10/100, so we will set accordingly.&n;         */
r_if
c_cond
(paren
id|speed
op_eq
id|SPEED_1000
)paren
(brace
multiline_comment|/* 1000Mbs HDX */
id|shift
op_assign
id|E1000_GB_HDX_COLLISION_DISTANCE
suffix:semicolon
id|shift
op_lshift_assign
id|E1000_COLD_SHIFT
suffix:semicolon
id|tctl_reg
op_or_assign
id|shift
suffix:semicolon
id|tctl_reg
op_or_assign
id|E1000_TCTL_PBE
suffix:semicolon
multiline_comment|/* Enable Packet Bursting */
)brace
r_else
(brace
multiline_comment|/* 10/100Mbs HDX */
id|shift
op_assign
id|E1000_HDX_COLLISION_DISTANCE
suffix:semicolon
id|shift
op_lshift_assign
id|E1000_COLD_SHIFT
suffix:semicolon
id|tctl_reg
op_or_assign
id|shift
suffix:semicolon
)brace
)brace
multiline_comment|/* Write the configured values back to the Transmit Control Reg. */
id|E1000_WRITE_REG
c_func
(paren
id|shared
comma
id|TCTL
comma
id|tctl_reg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Probes the expected PHY address for known PHY IDs&n;*&n;* shared - Struct containing variables accessed by shared code&n;******************************************************************************/
id|boolean_t
DECL|function|e1000_detect_gig_phy
id|e1000_detect_gig_phy
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint32
id|phy_id_high
suffix:semicolon
r_uint16
id|phy_id_low
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_detect_gig_phy&quot;
)paren
suffix:semicolon
multiline_comment|/* Read the PHY ID Registers to identify which PHY is onboard. */
id|shared-&gt;phy_addr
op_assign
l_int|1
suffix:semicolon
id|phy_id_high
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_ID1
)paren
suffix:semicolon
id|usec_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|phy_id_low
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_ID2
)paren
suffix:semicolon
id|shared-&gt;phy_id
op_assign
(paren
id|phy_id_low
op_or
(paren
id|phy_id_high
op_lshift
l_int|16
)paren
)paren
op_amp
id|PHY_REVISION_MASK
suffix:semicolon
r_if
c_cond
(paren
id|shared-&gt;phy_id
op_eq
id|M88E1000_12_PHY_ID
op_logical_or
id|shared-&gt;phy_id
op_eq
id|M88E1000_14_PHY_ID
op_logical_or
id|shared-&gt;phy_id
op_eq
id|M88E1000_I_PHY_ID
)paren
(brace
id|DEBUGOUT2
c_func
(paren
l_string|&quot;phy_id 0x%x detected at address 0x%x&bslash;n&quot;
comma
id|shared-&gt;phy_id
comma
id|shared-&gt;phy_addr
)paren
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUGOUT
c_func
(paren
l_string|&quot;Could not auto-detect Phy!&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/******************************************************************************&n;* Resets the PHY&squot;s DSP&n;*&n;* shared - Struct containing variables accessed by shared code&n;******************************************************************************/
r_void
DECL|function|e1000_phy_reset_dsp
id|e1000_phy_reset_dsp
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
l_int|29
comma
l_int|0x1d
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
l_int|30
comma
l_int|0xc1
)paren
suffix:semicolon
id|e1000_write_phy_reg
c_func
(paren
id|shared
comma
l_int|30
comma
l_int|0x00
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Blocks until autoneg completes or times out (~4.5 seconds)&n;*&n;* shared - Struct containing variables accessed by shared code&n;******************************************************************************/
id|boolean_t
DECL|function|e1000_wait_autoneg
id|e1000_wait_autoneg
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_uint16
id|i
suffix:semicolon
r_uint16
id|mii_status_reg
suffix:semicolon
id|boolean_t
id|autoneg_complete
op_assign
id|FALSE
suffix:semicolon
id|DEBUGFUNC
c_func
(paren
l_string|&quot;e1000_wait_autoneg&quot;
)paren
suffix:semicolon
multiline_comment|/* We will wait for autoneg to complete. */
id|DEBUGOUT
c_func
(paren
l_string|&quot;Waiting for Auto-Neg to complete.&bslash;n&quot;
)paren
suffix:semicolon
id|mii_status_reg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We will wait for autoneg to complete or 4.5 seconds to expire. */
r_for
c_loop
(paren
id|i
op_assign
id|PHY_AUTO_NEG_TIME
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
multiline_comment|/* Read the MII Status Register and wait for Auto-Neg&n;         * Complete bit to be set.&n;         */
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
id|mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_status_reg
op_amp
id|MII_SR_AUTONEG_COMPLETE
)paren
(brace
id|autoneg_complete
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|msec_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_return
(paren
id|autoneg_complete
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;* Get PHY information from various PHY registers&n;*&n;* shared - Struct containing variables accessed by shared code&n;* phy_status_info - PHY information structure&n;******************************************************************************/
id|boolean_t
DECL|function|e1000_phy_get_info
id|e1000_phy_get_info
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
comma
r_struct
id|e1000_phy_info
op_star
id|phy_status_info
)paren
(brace
r_uint16
id|phy_mii_status_reg
suffix:semicolon
r_uint16
id|phy_specific_ctrl_reg
suffix:semicolon
r_uint16
id|phy_specific_status_reg
suffix:semicolon
r_uint16
id|phy_specific_ext_ctrl_reg
suffix:semicolon
r_uint16
id|phy_1000t_stat_reg
suffix:semicolon
id|phy_status_info-&gt;cable_length
op_assign
id|e1000_cable_length_undefined
suffix:semicolon
id|phy_status_info-&gt;extended_10bt_distance
op_assign
id|e1000_10bt_ext_dist_enable_undefined
suffix:semicolon
id|phy_status_info-&gt;cable_polarity
op_assign
id|e1000_rev_polarity_undefined
suffix:semicolon
id|phy_status_info-&gt;polarity_correction
op_assign
id|e1000_polarity_reversal_undefined
suffix:semicolon
id|phy_status_info-&gt;link_reset
op_assign
id|e1000_down_no_idle_undefined
suffix:semicolon
id|phy_status_info-&gt;mdix_mode
op_assign
id|e1000_auto_x_mode_undefined
suffix:semicolon
id|phy_status_info-&gt;local_rx
op_assign
id|e1000_1000t_rx_status_undefined
suffix:semicolon
id|phy_status_info-&gt;remote_rx
op_assign
id|e1000_1000t_rx_status_undefined
suffix:semicolon
multiline_comment|/* PHY info only valid for copper media. */
r_if
c_cond
(paren
id|shared
op_eq
l_int|NULL
op_logical_or
id|shared-&gt;media_type
op_ne
id|e1000_media_type_copper
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* PHY info only valid for LINK UP.  Read MII status reg &n;     * back-to-back to get link status.&n;     */
id|phy_mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
id|phy_mii_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|phy_mii_status_reg
op_amp
id|MII_SR_LINK_STATUS
)paren
op_ne
id|MII_SR_LINK_STATUS
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Read various PHY registers to get the PHY info. */
id|phy_specific_ctrl_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_CTRL
)paren
suffix:semicolon
id|phy_specific_status_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_PHY_SPEC_STATUS
)paren
suffix:semicolon
id|phy_specific_ext_ctrl_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|M88E1000_EXT_PHY_SPEC_CTRL
)paren
suffix:semicolon
id|phy_1000t_stat_reg
op_assign
id|e1000_read_phy_reg
c_func
(paren
id|shared
comma
id|PHY_1000T_STATUS
)paren
suffix:semicolon
id|phy_status_info-&gt;cable_length
op_assign
(paren
(paren
id|phy_specific_status_reg
op_amp
id|M88E1000_PSSR_CABLE_LENGTH
)paren
op_rshift
id|M88E1000_PSSR_CABLE_LENGTH_SHIFT
)paren
suffix:semicolon
id|phy_status_info-&gt;extended_10bt_distance
op_assign
(paren
id|phy_specific_ctrl_reg
op_amp
id|M88E1000_PSCR_10BT_EXT_DIST_ENABLE
)paren
op_rshift
id|M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT
suffix:semicolon
id|phy_status_info-&gt;cable_polarity
op_assign
(paren
id|phy_specific_status_reg
op_amp
id|M88E1000_PSSR_REV_POLARITY
)paren
op_rshift
id|M88E1000_PSSR_REV_POLARITY_SHIFT
suffix:semicolon
id|phy_status_info-&gt;polarity_correction
op_assign
(paren
id|phy_specific_ctrl_reg
op_amp
id|M88E1000_PSCR_POLARITY_REVERSAL
)paren
op_rshift
id|M88E1000_PSCR_POLARITY_REVERSAL_SHIFT
suffix:semicolon
id|phy_status_info-&gt;link_reset
op_assign
(paren
id|phy_specific_ext_ctrl_reg
op_amp
id|M88E1000_EPSCR_DOWN_NO_IDLE
)paren
op_rshift
id|M88E1000_EPSCR_DOWN_NO_IDLE_SHIFT
suffix:semicolon
id|phy_status_info-&gt;mdix_mode
op_assign
(paren
id|phy_specific_status_reg
op_amp
id|M88E1000_PSSR_MDIX
)paren
op_rshift
id|M88E1000_PSSR_MDIX_SHIFT
suffix:semicolon
id|phy_status_info-&gt;local_rx
op_assign
(paren
id|phy_1000t_stat_reg
op_amp
id|SR_1000T_LOCAL_RX_STATUS
)paren
op_rshift
id|SR_1000T_LOCAL_RX_STATUS_SHIFT
suffix:semicolon
id|phy_status_info-&gt;remote_rx
op_assign
(paren
id|phy_1000t_stat_reg
op_amp
id|SR_1000T_REMOTE_RX_STATUS
)paren
op_rshift
id|SR_1000T_REMOTE_RX_STATUS_SHIFT
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|boolean_t
DECL|function|e1000_validate_mdi_setting
id|e1000_validate_mdi_setting
c_func
(paren
r_struct
id|e1000_shared_adapter
op_star
id|shared
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|shared-&gt;autoneg
op_logical_and
(paren
id|shared-&gt;mdix
op_eq
l_int|0
op_logical_or
id|shared-&gt;mdix
op_eq
l_int|3
)paren
)paren
(brace
id|shared-&gt;mdix
op_assign
l_int|1
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
eof
