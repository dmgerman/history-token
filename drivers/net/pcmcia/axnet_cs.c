multiline_comment|/*======================================================================&n;&n;    A PCMCIA ethernet driver for Asix AX88190-based cards&n;&n;    The Asix AX88190 is a NS8390-derived chipset with a few nasty&n;    idiosyncracies that make it very inconvenient to support with a&n;    standard 8390 driver.  This driver is based on pcnet_cs, with the&n;    tweaked 8390 code grafted on the end.  Much of what I did was to&n;    clean up and update a similar driver supplied by Asix, which was&n;    adapted by William Lee, william@asix.com.tw.&n;&n;    Copyright (C) 2001 David A. Hinds -- dahinds@users.sourceforge.net&n;&n;    axnet_cs.c 1.11 2001/06/12 12:42:40&n;    &n;    The network driver code is based on Donald Becker&squot;s NE2000 code:&n;&n;    Written 1992,1993 by Donald Becker.&n;    Copyright 1993 United States Government as represented by the&n;    Director, National Security Agency.  This software may be used and&n;    distributed according to the terms of the GNU General Public License,&n;    incorporated herein by reference.&n;    Donald Becker may be reached at becker@cesdis1.gsfc.nasa.gov&n;&n;======================================================================*/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &quot;ax8390.h&quot;
macro_line|#include &lt;pcmcia/version.h&gt;
macro_line|#include &lt;pcmcia/cs_types.h&gt;
macro_line|#include &lt;pcmcia/cs.h&gt;
macro_line|#include &lt;pcmcia/cistpl.h&gt;
macro_line|#include &lt;pcmcia/ciscode.h&gt;
macro_line|#include &lt;pcmcia/ds.h&gt;
macro_line|#include &lt;pcmcia/cisreg.h&gt;
DECL|macro|AXNET_CMD
mdefine_line|#define AXNET_CMD&t;0x00
DECL|macro|AXNET_DATAPORT
mdefine_line|#define AXNET_DATAPORT&t;0x10&t;/* NatSemi-defined port window offset. */
DECL|macro|AXNET_RESET
mdefine_line|#define AXNET_RESET&t;0x1f&t;/* Issue a read to reset, a write to clear. */
DECL|macro|AXNET_MISC
mdefine_line|#define AXNET_MISC&t;0x18&t;/* For IBM CCAE and Socket EA cards */
DECL|macro|AXNET_MII_EEP
mdefine_line|#define AXNET_MII_EEP&t;0x14&t;/* Offset of MII access port */
DECL|macro|AXNET_START_PG
mdefine_line|#define AXNET_START_PG&t;0x40&t;/* First page of TX buffer */
DECL|macro|AXNET_STOP_PG
mdefine_line|#define AXNET_STOP_PG&t;0x80&t;/* Last page +1 of RX ring */
DECL|macro|AXNET_RDC_TIMEOUT
mdefine_line|#define AXNET_RDC_TIMEOUT 0x02&t;/* Max wait in jiffies for Tx RDC */
macro_line|#ifdef PCMCIA_DEBUG
DECL|variable|pc_debug
r_static
r_int
id|pc_debug
op_assign
id|PCMCIA_DEBUG
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|pc_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|macro|DEBUG
mdefine_line|#define DEBUG(n, args...) if (pc_debug&gt;(n)) printk(KERN_DEBUG args)
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;axnet_cs.c 1.11 2001/06/12 12:42:40 (David Hinds)&quot;
suffix:semicolon
macro_line|#else
DECL|macro|DEBUG
mdefine_line|#define DEBUG(n, args...)
macro_line|#endif
DECL|macro|DEV_KFREE_SKB
mdefine_line|#define DEV_KFREE_SKB(skb) dev_kfree_skb(skb);
DECL|macro|skb_tx_check
mdefine_line|#define skb_tx_check(dev, skb)
DECL|macro|add_rx_bytes
mdefine_line|#define add_rx_bytes(stats, n) (stats)-&gt;rx_bytes += n;
DECL|macro|add_tx_bytes
mdefine_line|#define add_tx_bytes(stats, n) (stats)-&gt;tx_bytes += n;
DECL|macro|netif_mark_up
mdefine_line|#define netif_mark_up(dev)&t;do { } while (0)
DECL|macro|netif_mark_down
mdefine_line|#define netif_mark_down(dev)&t;do { } while (0)
multiline_comment|/*====================================================================*/
multiline_comment|/* Parameters that can be set with &squot;insmod&squot; */
DECL|macro|INT_MODULE_PARM
mdefine_line|#define INT_MODULE_PARM(n, v) static int n = v; MODULE_PARM(n, &quot;i&quot;)
multiline_comment|/* Bit map of interrupts to choose from */
id|INT_MODULE_PARM
c_func
(paren
id|irq_mask
comma
l_int|0xdeb8
)paren
suffix:semicolon
DECL|variable|irq_list
r_static
r_int
id|irq_list
(braket
l_int|4
)braket
op_assign
(brace
op_minus
l_int|1
)brace
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq_list
comma
l_string|&quot;1-4i&quot;
)paren
suffix:semicolon
multiline_comment|/* Ugh!  Let the user hardwire the hardware address for queer cards */
DECL|variable|hw_addr
r_static
r_int
id|hw_addr
(braket
l_int|6
)braket
op_assign
(brace
l_int|0
comma
multiline_comment|/* ... */
)brace
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|hw_addr
comma
l_string|&quot;6i&quot;
)paren
suffix:semicolon
multiline_comment|/*====================================================================*/
r_static
r_void
id|axnet_config
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
suffix:semicolon
r_static
r_void
id|axnet_release
c_func
(paren
id|u_long
id|arg
)paren
suffix:semicolon
r_static
r_int
id|axnet_event
c_func
(paren
id|event_t
id|event
comma
r_int
id|priority
comma
id|event_callback_args_t
op_star
id|args
)paren
suffix:semicolon
r_static
r_int
id|axnet_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|axnet_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|axnet_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ei_irq_wrapper
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|ei_watchdog
c_func
(paren
id|u_long
id|arg
)paren
suffix:semicolon
r_static
r_void
id|axnet_reset_8390
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|mdio_read
c_func
(paren
id|ioaddr_t
id|addr
comma
r_int
id|phy_id
comma
r_int
id|loc
)paren
suffix:semicolon
r_static
r_void
id|mdio_write
c_func
(paren
id|ioaddr_t
id|addr
comma
r_int
id|phy_id
comma
r_int
id|loc
comma
r_int
id|value
)paren
suffix:semicolon
r_static
r_void
id|get_8390_hdr
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|e8390_pkt_hdr
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|block_input
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
suffix:semicolon
r_static
r_void
id|block_output
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_const
id|u_char
op_star
id|buf
comma
r_const
r_int
id|start_page
)paren
suffix:semicolon
r_static
id|dev_link_t
op_star
id|axnet_attach
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|axnet_detach
c_func
(paren
id|dev_link_t
op_star
)paren
suffix:semicolon
DECL|variable|dev_info
r_static
id|dev_info_t
id|dev_info
op_assign
l_string|&quot;axnet_cs&quot;
suffix:semicolon
DECL|variable|dev_list
r_static
id|dev_link_t
op_star
id|dev_list
suffix:semicolon
multiline_comment|/*====================================================================*/
DECL|struct|axnet_dev_t
r_typedef
r_struct
id|axnet_dev_t
(brace
DECL|member|dev
r_struct
id|net_device
id|dev
suffix:semicolon
multiline_comment|/* so &amp;dev == &amp;axnet_dev_t */
DECL|member|link
id|dev_link_t
id|link
suffix:semicolon
DECL|member|node
id|dev_node_t
id|node
suffix:semicolon
DECL|member|base
id|caddr_t
id|base
suffix:semicolon
DECL|member|watchdog
r_struct
id|timer_list
id|watchdog
suffix:semicolon
DECL|member|stale
DECL|member|fast_poll
r_int
id|stale
comma
id|fast_poll
suffix:semicolon
DECL|member|link_status
id|u_short
id|link_status
suffix:semicolon
DECL|member|duplex_flag
id|u_char
id|duplex_flag
suffix:semicolon
DECL|member|phy_id
r_int
id|phy_id
suffix:semicolon
DECL|typedef|axnet_dev_t
)brace
id|axnet_dev_t
suffix:semicolon
multiline_comment|/*======================================================================&n;&n;    This bit of code is used to avoid unregistering network devices&n;    at inappropriate times.  2.2 and later kernels are fairly picky&n;    about when this can happen.&n;    &n;======================================================================*/
DECL|function|flush_stale_links
r_static
r_void
id|flush_stale_links
c_func
(paren
r_void
)paren
(brace
id|dev_link_t
op_star
id|link
comma
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|link
op_assign
id|dev_list
suffix:semicolon
id|link
suffix:semicolon
id|link
op_assign
id|next
)paren
(brace
id|next
op_assign
id|link-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_STALE_LINK
)paren
id|axnet_detach
c_func
(paren
id|link
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*====================================================================*/
DECL|function|cs_error
r_static
r_void
id|cs_error
c_func
(paren
id|client_handle_t
id|handle
comma
r_int
id|func
comma
r_int
id|ret
)paren
(brace
id|error_info_t
id|err
op_assign
(brace
id|func
comma
id|ret
)brace
suffix:semicolon
id|CardServices
c_func
(paren
id|ReportError
comma
id|handle
comma
op_amp
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n;&n;    We never need to do anything when a axnet device is &quot;initialized&quot;&n;    by the net software, because we only register already-found cards.&n;&n;======================================================================*/
DECL|function|axnet_init
r_static
r_int
id|axnet_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n;&n;    axnet_attach() creates an &quot;instance&quot; of the driver, allocating&n;    local data structures for one device.  The device is registered&n;    with Card Services.&n;&n;======================================================================*/
DECL|function|axnet_attach
r_static
id|dev_link_t
op_star
id|axnet_attach
c_func
(paren
r_void
)paren
(brace
id|axnet_dev_t
op_star
id|info
suffix:semicolon
id|dev_link_t
op_star
id|link
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|client_reg_t
id|client_reg
suffix:semicolon
r_int
id|i
comma
id|ret
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;axnet_attach()&bslash;n&quot;
)paren
suffix:semicolon
id|flush_stale_links
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Create new ethernet device */
id|info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|info
)paren
)paren
suffix:semicolon
id|link
op_assign
op_amp
id|info-&gt;link
suffix:semicolon
id|dev
op_assign
op_amp
id|info-&gt;dev
suffix:semicolon
id|link-&gt;priv
op_assign
id|info
suffix:semicolon
id|link-&gt;release.function
op_assign
op_amp
id|axnet_release
suffix:semicolon
id|link-&gt;release.data
op_assign
(paren
id|u_long
)paren
id|link
suffix:semicolon
id|link-&gt;irq.Attributes
op_assign
id|IRQ_TYPE_EXCLUSIVE
suffix:semicolon
id|link-&gt;irq.IRQInfo1
op_assign
id|IRQ_INFO2_VALID
op_or
id|IRQ_LEVEL_ID
suffix:semicolon
r_if
c_cond
(paren
id|irq_list
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
)paren
id|link-&gt;irq.IRQInfo2
op_assign
id|irq_mask
suffix:semicolon
r_else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|link-&gt;irq.IRQInfo2
op_or_assign
l_int|1
op_lshift
id|irq_list
(braket
id|i
)braket
suffix:semicolon
id|link-&gt;conf.Attributes
op_assign
id|CONF_ENABLE_IRQ
suffix:semicolon
id|link-&gt;conf.IntType
op_assign
id|INT_MEMORY_AND_IO
suffix:semicolon
id|ethdev_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;init
op_assign
op_amp
id|axnet_init
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|axnet_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|axnet_close
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
op_amp
id|axnet_ioctl
suffix:semicolon
multiline_comment|/* Register with Card Services */
id|link-&gt;next
op_assign
id|dev_list
suffix:semicolon
id|dev_list
op_assign
id|link
suffix:semicolon
id|client_reg.dev_info
op_assign
op_amp
id|dev_info
suffix:semicolon
id|client_reg.Attributes
op_assign
id|INFO_IO_CLIENT
op_or
id|INFO_CARD_SHARE
suffix:semicolon
id|client_reg.EventMask
op_assign
id|CS_EVENT_CARD_INSERTION
op_or
id|CS_EVENT_CARD_REMOVAL
op_or
id|CS_EVENT_RESET_PHYSICAL
op_or
id|CS_EVENT_CARD_RESET
op_or
id|CS_EVENT_PM_SUSPEND
op_or
id|CS_EVENT_PM_RESUME
suffix:semicolon
id|client_reg.event_handler
op_assign
op_amp
id|axnet_event
suffix:semicolon
id|client_reg.Version
op_assign
l_int|0x0210
suffix:semicolon
id|client_reg.event_callback_args.client_data
op_assign
id|link
suffix:semicolon
id|ret
op_assign
id|CardServices
c_func
(paren
id|RegisterClient
comma
op_amp
id|link-&gt;handle
comma
op_amp
id|client_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|CS_SUCCESS
)paren
(brace
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|RegisterClient
comma
id|ret
)paren
suffix:semicolon
id|axnet_detach
c_func
(paren
id|link
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|link
suffix:semicolon
)brace
multiline_comment|/* axnet_attach */
multiline_comment|/*======================================================================&n;&n;    This deletes a driver &quot;instance&quot;.  The device is de-registered&n;    with Card Services.  If it has been released, all local data&n;    structures are freed.  Otherwise, the structures will be freed&n;    when the device is released.&n;&n;======================================================================*/
DECL|function|axnet_detach
r_static
r_void
id|axnet_detach
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
(brace
id|axnet_dev_t
op_star
id|info
op_assign
id|link-&gt;priv
suffix:semicolon
id|dev_link_t
op_star
op_star
id|linkp
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;axnet_detach(0x%p)&bslash;n&quot;
comma
id|link
)paren
suffix:semicolon
multiline_comment|/* Locate device structure */
r_for
c_loop
(paren
id|linkp
op_assign
op_amp
id|dev_list
suffix:semicolon
op_star
id|linkp
suffix:semicolon
id|linkp
op_assign
op_amp
(paren
op_star
id|linkp
)paren
op_member_access_from_pointer
id|next
)paren
r_if
c_cond
(paren
op_star
id|linkp
op_eq
id|link
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|linkp
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|link-&gt;release
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_CONFIG
)paren
(brace
id|axnet_release
c_func
(paren
(paren
id|u_long
)paren
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_STALE_CONFIG
)paren
(brace
id|link-&gt;state
op_or_assign
id|DEV_STALE_LINK
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|link-&gt;handle
)paren
id|CardServices
c_func
(paren
id|DeregisterClient
comma
id|link-&gt;handle
)paren
suffix:semicolon
multiline_comment|/* Unlink device structure, free bits */
op_star
id|linkp
op_assign
id|link-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;dev
)paren
id|unregister_netdev
c_func
(paren
op_amp
id|info-&gt;dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/* axnet_detach */
multiline_comment|/*======================================================================&n;&n;    This probes for a card&squot;s hardware address by reading the PROM.&n;&n;======================================================================*/
DECL|function|get_prom
r_static
r_int
id|get_prom
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|link-&gt;priv
suffix:semicolon
id|ioaddr_t
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* This is based on drivers/net/ne.c */
r_struct
(brace
id|u_char
id|value
comma
id|offset
suffix:semicolon
)brace
id|program_seq
(braket
)braket
op_assign
(brace
(brace
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_STOP
comma
id|E8390_CMD
)brace
comma
multiline_comment|/* Select page 0*/
(brace
l_int|0x01
comma
id|EN0_DCFG
)brace
comma
multiline_comment|/* Set word-wide access. */
(brace
l_int|0x00
comma
id|EN0_RCNTLO
)brace
comma
multiline_comment|/* Clear the count regs. */
(brace
l_int|0x00
comma
id|EN0_RCNTHI
)brace
comma
(brace
l_int|0x00
comma
id|EN0_IMR
)brace
comma
multiline_comment|/* Mask completion irq. */
(brace
l_int|0xFF
comma
id|EN0_ISR
)brace
comma
(brace
id|E8390_RXOFF
comma
id|EN0_RXCR
)brace
comma
multiline_comment|/* 0x20  Set to monitor */
(brace
id|E8390_TXOFF
comma
id|EN0_TXCR
)brace
comma
multiline_comment|/* 0x02  and loopback mode. */
(brace
l_int|0x10
comma
id|EN0_RCNTLO
)brace
comma
(brace
l_int|0x00
comma
id|EN0_RCNTHI
)brace
comma
(brace
l_int|0x00
comma
id|EN0_RSARLO
)brace
comma
multiline_comment|/* DMA starting at 0x0400. */
(brace
l_int|0x04
comma
id|EN0_RSARHI
)brace
comma
(brace
id|E8390_RREAD
op_plus
id|E8390_START
comma
id|E8390_CMD
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* Not much of a test, but the alternatives are messy */
r_if
c_cond
(paren
id|link-&gt;conf.ConfigBase
op_ne
l_int|0x03c0
)paren
r_return
l_int|0
suffix:semicolon
id|axnet_reset_8390
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|program_seq
)paren
op_div
r_sizeof
(paren
id|program_seq
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
id|outb_p
c_func
(paren
id|program_seq
(braket
id|i
)braket
dot
id|value
comma
id|ioaddr
op_plus
id|program_seq
(braket
id|i
)braket
dot
id|offset
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|j
op_assign
id|inw
c_func
(paren
id|ioaddr
op_plus
id|AXNET_DATAPORT
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|j
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|j
op_rshift
l_int|8
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* get_prom */
multiline_comment|/*======================================================================&n;&n;    This should be totally unnecessary... but when we can&squot;t figure&n;    out the hardware address any other way, we&squot;ll let the user hard&n;    wire it when the module is initialized.&n;&n;======================================================================*/
DECL|function|get_hwired
r_static
r_int
id|get_hwired
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|link-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|hw_addr
(braket
id|i
)braket
op_ne
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|6
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|hw_addr
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* get_hwired */
multiline_comment|/*======================================================================&n;&n;    axnet_config() is scheduled to run after a CARD_INSERTION event&n;    is received, to configure the PCMCIA socket, and to make the&n;    ethernet device available to the system.&n;&n;======================================================================*/
DECL|macro|CS_CHECK
mdefine_line|#define CS_CHECK(fn, args...) &bslash;&n;while ((last_ret=CardServices(last_fn=(fn), args))!=0) goto cs_failed
DECL|macro|CFG_CHECK
mdefine_line|#define CFG_CHECK(fn, args...) &bslash;&n;if (CardServices(fn, args) != 0) goto next_entry
DECL|function|try_io_port
r_static
r_int
id|try_io_port
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
(brace
r_int
id|j
comma
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;io.NumPorts1
op_eq
l_int|32
)paren
(brace
id|link-&gt;io.Attributes1
op_assign
id|IO_DATA_PATH_WIDTH_AUTO
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;io.NumPorts2
OG
l_int|0
)paren
(brace
multiline_comment|/* for master/slave multifunction cards */
id|link-&gt;io.Attributes2
op_assign
id|IO_DATA_PATH_WIDTH_8
suffix:semicolon
id|link-&gt;irq.Attributes
op_assign
id|IRQ_TYPE_DYNAMIC_SHARING
op_or
id|IRQ_FIRST_SHARED
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* This should be two 16-port windows */
id|link-&gt;io.Attributes1
op_assign
id|IO_DATA_PATH_WIDTH_8
suffix:semicolon
id|link-&gt;io.Attributes2
op_assign
id|IO_DATA_PATH_WIDTH_16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|link-&gt;io.BasePort1
op_eq
l_int|0
)paren
(brace
id|link-&gt;io.IOAddrLines
op_assign
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|0x400
suffix:semicolon
id|j
op_add_assign
l_int|0x20
)paren
(brace
id|link-&gt;io.BasePort1
op_assign
id|j
op_xor
l_int|0x300
suffix:semicolon
id|link-&gt;io.BasePort2
op_assign
(paren
id|j
op_xor
l_int|0x300
)paren
op_plus
l_int|0x10
suffix:semicolon
id|ret
op_assign
id|CardServices
c_func
(paren
id|RequestIO
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|CS_SUCCESS
)paren
r_return
id|ret
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_else
(brace
r_return
id|CardServices
c_func
(paren
id|RequestIO
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;io
)paren
suffix:semicolon
)brace
)brace
DECL|function|axnet_config
r_static
r_void
id|axnet_config
c_func
(paren
id|dev_link_t
op_star
id|link
)paren
(brace
id|client_handle_t
id|handle
op_assign
id|link-&gt;handle
suffix:semicolon
id|axnet_dev_t
op_star
id|info
op_assign
id|link-&gt;priv
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
op_amp
id|info-&gt;dev
suffix:semicolon
id|tuple_t
id|tuple
suffix:semicolon
id|cisparse_t
id|parse
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|last_ret
comma
id|last_fn
suffix:semicolon
id|u_short
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|config_info_t
id|conf
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;axnet_config(0x%p)&bslash;n&quot;
comma
id|link
)paren
suffix:semicolon
id|tuple.Attributes
op_assign
l_int|0
suffix:semicolon
id|tuple.TupleData
op_assign
(paren
id|cisdata_t
op_star
)paren
id|buf
suffix:semicolon
id|tuple.TupleDataMax
op_assign
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
id|tuple.TupleOffset
op_assign
l_int|0
suffix:semicolon
id|tuple.DesiredTuple
op_assign
id|CISTPL_CONFIG
suffix:semicolon
id|CS_CHECK
c_func
(paren
id|GetFirstTuple
comma
id|handle
comma
op_amp
id|tuple
)paren
suffix:semicolon
id|CS_CHECK
c_func
(paren
id|GetTupleData
comma
id|handle
comma
op_amp
id|tuple
)paren
suffix:semicolon
id|CS_CHECK
c_func
(paren
id|ParseTuple
comma
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
suffix:semicolon
id|link-&gt;conf.ConfigBase
op_assign
id|parse.config.base
suffix:semicolon
id|link-&gt;conf.Present
op_assign
id|parse.config.rmask
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Configure card */
id|link-&gt;state
op_or_assign
id|DEV_CONFIG
suffix:semicolon
multiline_comment|/* Look up current Vcc */
id|CS_CHECK
c_func
(paren
id|GetConfigurationInfo
comma
id|handle
comma
op_amp
id|conf
)paren
suffix:semicolon
id|link-&gt;conf.Vcc
op_assign
id|conf.Vcc
suffix:semicolon
id|tuple.DesiredTuple
op_assign
id|CISTPL_CFTABLE_ENTRY
suffix:semicolon
id|tuple.Attributes
op_assign
l_int|0
suffix:semicolon
id|CS_CHECK
c_func
(paren
id|GetFirstTuple
comma
id|handle
comma
op_amp
id|tuple
)paren
suffix:semicolon
r_while
c_loop
(paren
id|last_ret
op_eq
id|CS_SUCCESS
)paren
(brace
id|cistpl_cftable_entry_t
op_star
id|cfg
op_assign
op_amp
(paren
id|parse.cftable_entry
)paren
suffix:semicolon
id|cistpl_io_t
op_star
id|io
op_assign
op_amp
(paren
id|parse.cftable_entry.io
)paren
suffix:semicolon
id|CFG_CHECK
c_func
(paren
id|GetTupleData
comma
id|handle
comma
op_amp
id|tuple
)paren
suffix:semicolon
id|CFG_CHECK
c_func
(paren
id|ParseTuple
comma
id|handle
comma
op_amp
id|tuple
comma
op_amp
id|parse
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cfg-&gt;index
op_eq
l_int|0
)paren
op_logical_or
(paren
id|cfg-&gt;io.nwin
op_eq
l_int|0
)paren
)paren
r_goto
id|next_entry
suffix:semicolon
id|link-&gt;conf.ConfigIndex
op_assign
id|cfg-&gt;index
suffix:semicolon
multiline_comment|/* For multifunction cards, by convention, we configure the&n;&t;   network function with window 0, and serial with window 1 */
r_if
c_cond
(paren
id|io-&gt;nwin
OG
l_int|1
)paren
(brace
id|i
op_assign
(paren
id|io-&gt;win
(braket
l_int|1
)braket
dot
id|len
OG
id|io-&gt;win
(braket
l_int|0
)braket
dot
id|len
)paren
suffix:semicolon
id|link-&gt;io.BasePort2
op_assign
id|io-&gt;win
(braket
l_int|1
op_minus
id|i
)braket
dot
id|base
suffix:semicolon
id|link-&gt;io.NumPorts2
op_assign
id|io-&gt;win
(braket
l_int|1
op_minus
id|i
)braket
dot
id|len
suffix:semicolon
)brace
r_else
(brace
id|i
op_assign
id|link-&gt;io.NumPorts2
op_assign
l_int|0
suffix:semicolon
)brace
id|link-&gt;io.BasePort1
op_assign
id|io-&gt;win
(braket
id|i
)braket
dot
id|base
suffix:semicolon
id|link-&gt;io.NumPorts1
op_assign
id|io-&gt;win
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|link-&gt;io.IOAddrLines
op_assign
id|io-&gt;flags
op_amp
id|CISTPL_IO_LINES_MASK
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;io.NumPorts1
op_plus
id|link-&gt;io.NumPorts2
op_ge
l_int|32
)paren
(brace
id|last_ret
op_assign
id|try_io_port
c_func
(paren
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_ret
op_eq
id|CS_SUCCESS
)paren
r_break
suffix:semicolon
)brace
id|next_entry
suffix:colon
id|last_ret
op_assign
id|CardServices
c_func
(paren
id|GetNextTuple
comma
id|handle
comma
op_amp
id|tuple
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last_ret
op_ne
id|CS_SUCCESS
)paren
(brace
id|cs_error
c_func
(paren
id|handle
comma
id|RequestIO
comma
id|last_ret
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|CS_CHECK
c_func
(paren
id|RequestIRQ
comma
id|handle
comma
op_amp
id|link-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;io.NumPorts2
op_eq
l_int|8
)paren
(brace
id|link-&gt;conf.Attributes
op_or_assign
id|CONF_ENABLE_SPKR
suffix:semicolon
id|link-&gt;conf.Status
op_assign
id|CCSR_AUDIO_ENA
suffix:semicolon
)brace
id|CS_CHECK
c_func
(paren
id|RequestConfiguration
comma
id|handle
comma
op_amp
id|link-&gt;conf
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|link-&gt;irq.AssignedIRQ
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|link-&gt;io.BasePort1
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;axnet_cs: register_netdev() failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|get_prom
c_func
(paren
id|link
)paren
op_logical_and
op_logical_neg
id|get_hwired
c_func
(paren
id|link
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;axnet_cs: unable to read hardware net&quot;
l_string|&quot; address for io base %#3lx&bslash;n&quot;
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|ei_status.name
op_assign
l_string|&quot;AX88190&quot;
suffix:semicolon
id|ei_status.word16
op_assign
l_int|1
suffix:semicolon
id|ei_status.tx_start_page
op_assign
id|AXNET_START_PG
suffix:semicolon
id|ei_status.rx_start_page
op_assign
id|AXNET_START_PG
op_plus
id|TX_PAGES
suffix:semicolon
id|ei_status.stop_page
op_assign
id|AXNET_STOP_PG
suffix:semicolon
id|ei_status.reset_8390
op_assign
op_amp
id|axnet_reset_8390
suffix:semicolon
id|ei_status.get_8390_hdr
op_assign
op_amp
id|get_8390_hdr
suffix:semicolon
id|ei_status.block_input
op_assign
op_amp
id|block_input
suffix:semicolon
id|ei_status.block_output
op_assign
op_amp
id|block_output
suffix:semicolon
id|strcpy
c_func
(paren
id|info-&gt;node.dev_name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|link-&gt;dev
op_assign
op_amp
id|info-&gt;node
suffix:semicolon
id|link-&gt;state
op_and_assign
op_complement
id|DEV_CONFIG_PENDING
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Asix AX88190: io %#3lx, irq %d, hw_addr &quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02X%s&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
(paren
(paren
id|i
OL
l_int|5
)paren
ques
c_cond
l_string|&quot;:&quot;
suffix:colon
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_assign
id|mdio_read
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|AXNET_MII_EEP
comma
id|i
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|j
op_ne
l_int|0
)paren
op_logical_and
(paren
id|j
op_ne
l_int|0xffff
)paren
)paren
r_break
suffix:semicolon
)brace
id|info-&gt;phy_id
op_assign
(paren
id|i
OL
l_int|32
)paren
ques
c_cond
id|i
suffix:colon
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|32
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;  MII transceiver at index %d, status %x.&bslash;n&quot;
comma
id|i
comma
id|j
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  No MII transceivers found!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|cs_failed
suffix:colon
id|cs_error
c_func
(paren
id|link-&gt;handle
comma
id|last_fn
comma
id|last_ret
)paren
suffix:semicolon
id|failed
suffix:colon
id|axnet_release
c_func
(paren
(paren
id|u_long
)paren
id|link
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* axnet_config */
multiline_comment|/*======================================================================&n;&n;    After a card is removed, axnet_release() will unregister the net&n;    device, and release the PCMCIA configuration.  If the device is&n;    still open, this will be postponed until it is closed.&n;&n;======================================================================*/
DECL|function|axnet_release
r_static
r_void
id|axnet_release
c_func
(paren
id|u_long
id|arg
)paren
(brace
id|dev_link_t
op_star
id|link
op_assign
(paren
id|dev_link_t
op_star
)paren
id|arg
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;axnet_release(0x%p)&bslash;n&quot;
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;open
)paren
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;axnet_cs: release postponed, &squot;%s&squot; still open&bslash;n&quot;
comma
id|info-&gt;node.dev_name
)paren
suffix:semicolon
id|link-&gt;state
op_or_assign
id|DEV_STALE_CONFIG
suffix:semicolon
r_return
suffix:semicolon
)brace
id|CardServices
c_func
(paren
id|ReleaseConfiguration
comma
id|link-&gt;handle
)paren
suffix:semicolon
id|CardServices
c_func
(paren
id|ReleaseIO
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;io
)paren
suffix:semicolon
id|CardServices
c_func
(paren
id|ReleaseIRQ
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;irq
)paren
suffix:semicolon
id|link-&gt;state
op_and_assign
op_complement
id|DEV_CONFIG
suffix:semicolon
)brace
multiline_comment|/* axnet_release */
multiline_comment|/*======================================================================&n;&n;    The card status event handler.  Mostly, this schedules other&n;    stuff to run after an event is received.  A CARD_REMOVAL event&n;    also sets some flags to discourage the net drivers from trying&n;    to talk to the card any more.&n;&n;======================================================================*/
DECL|function|axnet_event
r_static
r_int
id|axnet_event
c_func
(paren
id|event_t
id|event
comma
r_int
id|priority
comma
id|event_callback_args_t
op_star
id|args
)paren
(brace
id|dev_link_t
op_star
id|link
op_assign
id|args-&gt;client_data
suffix:semicolon
id|axnet_dev_t
op_star
id|info
op_assign
id|link-&gt;priv
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;axnet_event(0x%06x)&bslash;n&quot;
comma
id|event
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|CS_EVENT_CARD_REMOVAL
suffix:colon
id|link-&gt;state
op_and_assign
op_complement
id|DEV_PRESENT
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_CONFIG
)paren
(brace
id|netif_device_detach
c_func
(paren
op_amp
id|info-&gt;dev
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|link-&gt;release
comma
id|jiffies
op_plus
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CS_EVENT_CARD_INSERTION
suffix:colon
id|link-&gt;state
op_or_assign
id|DEV_PRESENT
suffix:semicolon
id|axnet_config
c_func
(paren
id|link
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_EVENT_PM_SUSPEND
suffix:colon
id|link-&gt;state
op_or_assign
id|DEV_SUSPEND
suffix:semicolon
multiline_comment|/* Fall through... */
r_case
id|CS_EVENT_RESET_PHYSICAL
suffix:colon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_CONFIG
)paren
(brace
r_if
c_cond
(paren
id|link-&gt;open
)paren
id|netif_device_detach
c_func
(paren
op_amp
id|info-&gt;dev
)paren
suffix:semicolon
id|CardServices
c_func
(paren
id|ReleaseConfiguration
comma
id|link-&gt;handle
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CS_EVENT_PM_RESUME
suffix:colon
id|link-&gt;state
op_and_assign
op_complement
id|DEV_SUSPEND
suffix:semicolon
multiline_comment|/* Fall through... */
r_case
id|CS_EVENT_CARD_RESET
suffix:colon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_CONFIG
)paren
(brace
id|CardServices
c_func
(paren
id|RequestConfiguration
comma
id|link-&gt;handle
comma
op_amp
id|link-&gt;conf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;open
)paren
(brace
id|axnet_reset_8390
c_func
(paren
op_amp
id|info-&gt;dev
)paren
suffix:semicolon
id|NS8390_init
c_func
(paren
op_amp
id|info-&gt;dev
comma
l_int|1
)paren
suffix:semicolon
id|netif_device_attach
c_func
(paren
op_amp
id|info-&gt;dev
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* axnet_event */
multiline_comment|/*======================================================================&n;&n;    MII interface support&n;&n;======================================================================*/
DECL|macro|MDIO_SHIFT_CLK
mdefine_line|#define MDIO_SHIFT_CLK&t;&t;0x01
DECL|macro|MDIO_DATA_WRITE0
mdefine_line|#define MDIO_DATA_WRITE0&t;0x00
DECL|macro|MDIO_DATA_WRITE1
mdefine_line|#define MDIO_DATA_WRITE1&t;0x08
DECL|macro|MDIO_DATA_READ
mdefine_line|#define MDIO_DATA_READ&t;&t;0x04
DECL|macro|MDIO_MASK
mdefine_line|#define MDIO_MASK&t;&t;0x0f
DECL|macro|MDIO_ENB_IN
mdefine_line|#define MDIO_ENB_IN&t;&t;0x02
DECL|function|mdio_sync
r_static
r_void
id|mdio_sync
c_func
(paren
id|ioaddr_t
id|addr
)paren
(brace
r_int
id|bits
suffix:semicolon
r_for
c_loop
(paren
id|bits
op_assign
l_int|0
suffix:semicolon
id|bits
OL
l_int|32
suffix:semicolon
id|bits
op_increment
)paren
(brace
id|outb_p
c_func
(paren
id|MDIO_DATA_WRITE1
comma
id|addr
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|MDIO_DATA_WRITE1
op_or
id|MDIO_SHIFT_CLK
comma
id|addr
)paren
suffix:semicolon
)brace
)brace
DECL|function|mdio_read
r_static
r_int
id|mdio_read
c_func
(paren
id|ioaddr_t
id|addr
comma
r_int
id|phy_id
comma
r_int
id|loc
)paren
(brace
id|u_int
id|cmd
op_assign
(paren
l_int|0xf6
op_lshift
l_int|10
)paren
op_or
(paren
id|phy_id
op_lshift
l_int|5
)paren
op_or
id|loc
suffix:semicolon
r_int
id|i
comma
id|retval
op_assign
l_int|0
suffix:semicolon
id|mdio_sync
c_func
(paren
id|addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|14
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|dat
op_assign
(paren
id|cmd
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
ques
c_cond
id|MDIO_DATA_WRITE1
suffix:colon
id|MDIO_DATA_WRITE0
suffix:semicolon
id|outb_p
c_func
(paren
id|dat
comma
id|addr
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|dat
op_or
id|MDIO_SHIFT_CLK
comma
id|addr
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|19
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outb_p
c_func
(paren
id|MDIO_ENB_IN
comma
id|addr
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|retval
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|inb_p
c_func
(paren
id|addr
)paren
op_amp
id|MDIO_DATA_READ
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|MDIO_ENB_IN
op_or
id|MDIO_SHIFT_CLK
comma
id|addr
)paren
suffix:semicolon
)brace
r_return
(paren
id|retval
op_rshift
l_int|1
)paren
op_amp
l_int|0xffff
suffix:semicolon
)brace
DECL|function|mdio_write
r_static
r_void
id|mdio_write
c_func
(paren
id|ioaddr_t
id|addr
comma
r_int
id|phy_id
comma
r_int
id|loc
comma
r_int
id|value
)paren
(brace
id|u_int
id|cmd
op_assign
(paren
l_int|0x05
op_lshift
l_int|28
)paren
op_or
(paren
id|phy_id
op_lshift
l_int|23
)paren
op_or
(paren
id|loc
op_lshift
l_int|18
)paren
op_or
(paren
l_int|1
op_lshift
l_int|17
)paren
op_or
id|value
suffix:semicolon
r_int
id|i
suffix:semicolon
id|mdio_sync
c_func
(paren
id|addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|31
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|dat
op_assign
(paren
id|cmd
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
ques
c_cond
id|MDIO_DATA_WRITE1
suffix:colon
id|MDIO_DATA_WRITE0
suffix:semicolon
id|outb_p
c_func
(paren
id|dat
comma
id|addr
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|dat
op_or
id|MDIO_SHIFT_CLK
comma
id|addr
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outb_p
c_func
(paren
id|MDIO_ENB_IN
comma
id|addr
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|MDIO_ENB_IN
op_or
id|MDIO_SHIFT_CLK
comma
id|addr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*====================================================================*/
DECL|function|axnet_open
r_static
r_int
id|axnet_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|axnet_dev_t
op_star
id|info
op_assign
(paren
id|axnet_dev_t
op_star
)paren
id|dev
suffix:semicolon
id|dev_link_t
op_star
id|link
op_assign
op_amp
id|info-&gt;link
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;axnet_open(&squot;%s&squot;)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DEV_OK
c_func
(paren
id|link
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|link-&gt;open
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|ei_irq_wrapper
comma
id|SA_SHIRQ
comma
id|dev_info
comma
id|dev
)paren
suffix:semicolon
id|info-&gt;link_status
op_assign
l_int|0x00
suffix:semicolon
id|info-&gt;watchdog.function
op_assign
op_amp
id|ei_watchdog
suffix:semicolon
id|info-&gt;watchdog.data
op_assign
(paren
id|u_long
)paren
id|info
suffix:semicolon
id|info-&gt;watchdog.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|info-&gt;watchdog
)paren
suffix:semicolon
r_return
id|ei_open
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* axnet_open */
multiline_comment|/*====================================================================*/
DECL|function|axnet_close
r_static
r_int
id|axnet_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|axnet_dev_t
op_star
id|info
op_assign
(paren
id|axnet_dev_t
op_star
)paren
id|dev
suffix:semicolon
id|dev_link_t
op_star
id|link
op_assign
op_amp
id|info-&gt;link
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;axnet_close(&squot;%s&squot;)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|link-&gt;open
op_decrement
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_mark_down
c_func
(paren
id|dev
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|info-&gt;watchdog
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link-&gt;state
op_amp
id|DEV_STALE_CONFIG
)paren
id|mod_timer
c_func
(paren
op_amp
id|link-&gt;release
comma
id|jiffies
op_plus
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* axnet_close */
multiline_comment|/*======================================================================&n;&n;    Hard reset the card.  This used to pause for the same period that&n;    a 8390 reset command required, but that shouldn&squot;t be necessary.&n;&n;======================================================================*/
DECL|function|axnet_reset_8390
r_static
r_void
id|axnet_reset_8390
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|ioaddr_t
id|nic_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ei_status.txing
op_assign
id|ei_status.dmaing
op_assign
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_STOP
comma
id|nic_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|nic_base
op_plus
id|AXNET_RESET
)paren
comma
id|nic_base
op_plus
id|AXNET_RESET
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
id|nic_base
op_plus
id|EN0_ISR
)paren
op_amp
id|ENISR_RESET
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|ENISR_RESET
comma
id|nic_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack intr. */
r_if
c_cond
(paren
id|i
op_eq
l_int|100
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: axnet_reset_8390() did not complete.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* axnet_reset_8390 */
multiline_comment|/*====================================================================*/
DECL|function|ei_irq_wrapper
r_static
r_void
id|ei_irq_wrapper
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|axnet_dev_t
op_star
id|info
op_assign
id|dev_id
suffix:semicolon
id|info-&gt;stale
op_assign
l_int|0
suffix:semicolon
id|ei_interrupt
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
DECL|function|ei_watchdog
r_static
r_void
id|ei_watchdog
c_func
(paren
id|u_long
id|arg
)paren
(brace
id|axnet_dev_t
op_star
id|info
op_assign
(paren
id|axnet_dev_t
op_star
)paren
(paren
id|arg
)paren
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
op_amp
id|info-&gt;dev
suffix:semicolon
id|ioaddr_t
id|nic_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ioaddr_t
id|mii_addr
op_assign
id|nic_base
op_plus
id|AXNET_MII_EEP
suffix:semicolon
id|u_short
id|link
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|dev
)paren
)paren
r_goto
id|reschedule
suffix:semicolon
multiline_comment|/* Check for pending interrupt with expired latency timer: with&n;       this, we can limp along even if the interrupt is blocked */
r_if
c_cond
(paren
id|info-&gt;stale
op_increment
op_logical_and
(paren
id|inb_p
c_func
(paren
id|nic_base
op_plus
id|EN0_ISR
)paren
op_amp
id|ENISR_ALL
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;fast_poll
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: interrupt(s) dropped!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ei_irq_wrapper
c_func
(paren
id|dev-&gt;irq
comma
id|dev
comma
l_int|NULL
)paren
suffix:semicolon
id|info-&gt;fast_poll
op_assign
id|HZ
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;fast_poll
)paren
(brace
id|info-&gt;fast_poll
op_decrement
suffix:semicolon
id|info-&gt;watchdog.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|info-&gt;watchdog
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;phy_id
OL
l_int|0
)paren
r_goto
id|reschedule
suffix:semicolon
id|link
op_assign
id|mdio_read
c_func
(paren
id|mii_addr
comma
id|info-&gt;phy_id
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|link
op_logical_or
(paren
id|link
op_eq
l_int|0xffff
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: MII is missing!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|info-&gt;phy_id
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|reschedule
suffix:semicolon
)brace
id|link
op_and_assign
l_int|0x0004
suffix:semicolon
r_if
c_cond
(paren
id|link
op_ne
id|info-&gt;link_status
)paren
(brace
id|u_short
id|p
op_assign
id|mdio_read
c_func
(paren
id|mii_addr
comma
id|info-&gt;phy_id
comma
l_int|5
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s link beat&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|link
)paren
ques
c_cond
l_string|&quot;found&quot;
suffix:colon
l_string|&quot;lost&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
)paren
(brace
id|info-&gt;duplex_flag
op_assign
(paren
id|p
op_amp
l_int|0x0140
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0x00
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: autonegotiation complete: &quot;
l_string|&quot;%sbaseT-%cD selected&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
(paren
id|p
op_amp
l_int|0x0180
)paren
ques
c_cond
l_string|&quot;100&quot;
suffix:colon
l_string|&quot;10&quot;
)paren
comma
(paren
(paren
id|p
op_amp
l_int|0x0140
)paren
ques
c_cond
l_char|&squot;F&squot;
suffix:colon
l_char|&squot;H&squot;
)paren
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link partner did not autonegotiate&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
id|info-&gt;link_status
op_assign
id|link
suffix:semicolon
)brace
id|reschedule
suffix:colon
id|info-&gt;watchdog.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|info-&gt;watchdog
)paren
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|axnet_ioctl
r_static
r_int
id|axnet_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
id|axnet_dev_t
op_star
id|info
op_assign
(paren
id|axnet_dev_t
op_star
)paren
id|dev
suffix:semicolon
id|u16
op_star
id|data
op_assign
(paren
id|u16
op_star
)paren
op_amp
id|rq-&gt;ifr_data
suffix:semicolon
id|ioaddr_t
id|mii_addr
op_assign
id|dev-&gt;base_addr
op_plus
id|AXNET_MII_EEP
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDEVPRIVATE
suffix:colon
id|data
(braket
l_int|0
)braket
op_assign
id|info-&gt;phy_id
suffix:semicolon
r_case
id|SIOCDEVPRIVATE
op_plus
l_int|1
suffix:colon
id|data
(braket
l_int|3
)braket
op_assign
id|mdio_read
c_func
(paren
id|mii_addr
comma
id|data
(braket
l_int|0
)braket
comma
id|data
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCDEVPRIVATE
op_plus
l_int|2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|mdio_write
c_func
(paren
id|mii_addr
comma
id|data
(braket
l_int|0
)braket
comma
id|data
(braket
l_int|1
)braket
op_amp
l_int|0x1f
comma
id|data
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|get_8390_hdr
r_static
r_void
id|get_8390_hdr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
(brace
id|ioaddr_t
id|nic_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|nic_base
op_plus
id|EN0_RSARLO
)paren
suffix:semicolon
multiline_comment|/* On page boundary */
id|outb_p
c_func
(paren
id|ring_page
comma
id|nic_base
op_plus
id|EN0_RSARHI
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_RREAD
op_plus
id|E8390_START
comma
id|nic_base
op_plus
id|AXNET_CMD
)paren
suffix:semicolon
id|insw
c_func
(paren
id|nic_base
op_plus
id|AXNET_DATAPORT
comma
id|hdr
comma
r_sizeof
(paren
r_struct
id|e8390_pkt_hdr
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Fix for big endian systems */
id|hdr-&gt;count
op_assign
id|le16_to_cpu
c_func
(paren
id|hdr-&gt;count
)paren
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|block_input
r_static
r_void
id|block_input
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
(brace
id|ioaddr_t
id|nic_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|xfer_count
op_assign
id|count
suffix:semicolon
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
macro_line|#ifdef PCMCIA_DEBUG
r_if
c_cond
(paren
(paren
id|ei_debug
OG
l_int|4
)paren
op_logical_and
(paren
id|count
op_ne
l_int|4
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: [bi=%d]&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|count
op_plus
l_int|4
)paren
suffix:semicolon
macro_line|#endif
id|outb_p
c_func
(paren
id|ring_offset
op_amp
l_int|0xff
comma
id|nic_base
op_plus
id|EN0_RSARLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ring_offset
op_rshift
l_int|8
comma
id|nic_base
op_plus
id|EN0_RSARHI
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_RREAD
op_plus
id|E8390_START
comma
id|nic_base
op_plus
id|AXNET_CMD
)paren
suffix:semicolon
id|insw
c_func
(paren
id|nic_base
op_plus
id|AXNET_DATAPORT
comma
id|buf
comma
id|count
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_amp
l_int|0x01
)paren
id|buf
(braket
id|count
op_minus
l_int|1
)braket
op_assign
id|inb
c_func
(paren
id|nic_base
op_plus
id|AXNET_DATAPORT
)paren
comma
id|xfer_count
op_increment
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|block_output
r_static
r_void
id|block_output
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|count
comma
r_const
id|u_char
op_star
id|buf
comma
r_const
r_int
id|start_page
)paren
(brace
id|ioaddr_t
id|nic_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
macro_line|#ifdef PCMCIA_DEBUG
r_if
c_cond
(paren
id|ei_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: [bo=%d]&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Round the count up for word writes.  Do we need to do this?&n;       What effect will an odd byte count have on the 8390?&n;       I should check someday. */
r_if
c_cond
(paren
id|count
op_amp
l_int|0x01
)paren
id|count
op_increment
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|nic_base
op_plus
id|EN0_RSARLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|start_page
comma
id|nic_base
op_plus
id|EN0_RSARHI
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_RWRITE
op_plus
id|E8390_START
comma
id|nic_base
op_plus
id|AXNET_CMD
)paren
suffix:semicolon
id|outsw
c_func
(paren
id|nic_base
op_plus
id|AXNET_DATAPORT
comma
id|buf
comma
id|count
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|init_axnet_cs
r_static
r_int
id|__init
id|init_axnet_cs
c_func
(paren
r_void
)paren
(brace
id|servinfo_t
id|serv
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|version
)paren
suffix:semicolon
id|CardServices
c_func
(paren
id|GetCardServicesInfo
comma
op_amp
id|serv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serv.Revision
op_ne
id|CS_RELEASE_CODE
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;axnet_cs: Card Services release &quot;
l_string|&quot;does not match!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|register_pccard_driver
c_func
(paren
op_amp
id|dev_info
comma
op_amp
id|axnet_attach
comma
op_amp
id|axnet_detach
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|exit_axnet_cs
r_static
r_void
id|__exit
id|exit_axnet_cs
c_func
(paren
r_void
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;axnet_cs: unloading&bslash;n&quot;
)paren
suffix:semicolon
id|unregister_pccard_driver
c_func
(paren
op_amp
id|dev_info
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dev_list
op_ne
l_int|NULL
)paren
id|axnet_detach
c_func
(paren
id|dev_list
)paren
suffix:semicolon
)brace
DECL|variable|init_axnet_cs
id|module_init
c_func
(paren
id|init_axnet_cs
)paren
suffix:semicolon
DECL|variable|exit_axnet_cs
id|module_exit
c_func
(paren
id|exit_axnet_cs
)paren
suffix:semicolon
multiline_comment|/*====================================================================*/
multiline_comment|/* 8390.c: A general NS8390 ethernet driver core for linux. */
multiline_comment|/*&n;&t;Written 1992-94 by Donald Becker.&n;  &n;&t;Copyright 1993 United States Government as represented by the&n;&t;Director, National Security Agency.&n;&n;&t;This software may be used and distributed according to the terms&n;&t;of the GNU General Public License, incorporated herein by reference.&n;&n;&t;The author may be reached as becker@CESDIS.gsfc.nasa.gov, or C/O&n;&t;Center of Excellence in Space Data and Information Sciences&n;&t;   Code 930.5, Goddard Space Flight Center, Greenbelt MD 20771&n;  &n;  This is the chip-specific code for many 8390-based ethernet adaptors.&n;  This is not a complete driver, it must be combined with board-specific&n;  code such as ne.c, wd.c, 3c503.c, etc.&n;&n;  Seeing how at least eight drivers use this code, (not counting the&n;  PCMCIA ones either) it is easy to break some card by what seems like&n;  a simple innocent change. Please contact me or Donald if you think&n;  you have found something that needs changing. -- PG&n;&n;&n;  Changelog:&n;&n;  Paul Gortmaker&t;: remove set_bit lock, other cleanups.&n;  Paul Gortmaker&t;: add ei_get_8390_hdr() so we can pass skb&squot;s to &n;&t;&t;&t;  ei_block_input() for eth_io_copy_and_sum().&n;  Paul Gortmaker&t;: exchange static int ei_pingpong for a #define,&n;&t;&t;&t;  also add better Tx error handling.&n;  Paul Gortmaker&t;: rewrite Rx overrun handling as per NS specs.&n;  Alexey Kuznetsov&t;: use the 8390&squot;s six bit hash multicast filter.&n;  Paul Gortmaker&t;: tweak ANK&squot;s above multicast changes a bit.&n;  Paul Gortmaker&t;: update packet statistics for v2.1.x&n;  Alan Cox&t;&t;: support arbitary stupid port mappings on the&n;  &t;&t;&t;  68K Macintosh. Support &gt;16bit I/O spaces&n;  Paul Gortmaker&t;: add kmod support for auto-loading of the 8390&n;&t;&t;&t;  module by all drivers that require it.&n;  Alan Cox&t;&t;: Spinlocking work, added &squot;BUG_83C690&squot;&n;  Paul Gortmaker&t;: Separate out Tx timeout code from Tx path.&n;&n;  Sources:&n;  The National Semiconductor LAN Databook, and the 3Com 3c503 databook.&n;&n;  */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;8390.c:v1.10cvs 9/23/94 Donald Becker (becker@cesdis.gsfc.nasa.gov)&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
DECL|macro|BUG_83C690
mdefine_line|#define BUG_83C690
multiline_comment|/* These are the operational function interfaces to board-specific&n;   routines.&n;&t;void reset_8390(struct net_device *dev)&n;&t;&t;Resets the board associated with DEV, including a hardware reset of&n;&t;&t;the 8390.  This is only called when there is a transmit timeout, and&n;&t;&t;it is always followed by 8390_init().&n;&t;void block_output(struct net_device *dev, int count, const unsigned char *buf,&n;&t;&t;&t;&t;&t;  int start_page)&n;&t;&t;Write the COUNT bytes of BUF to the packet buffer at START_PAGE.  The&n;&t;&t;&quot;page&quot; value uses the 8390&squot;s 256-byte pages.&n;&t;void get_8390_hdr(struct net_device *dev, struct e8390_hdr *hdr, int ring_page)&n;&t;&t;Read the 4 byte, page aligned 8390 header. *If* there is a&n;&t;&t;subsequent read, it will be of the rest of the packet.&n;&t;void block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)&n;&t;&t;Read COUNT bytes from the packet buffer into the skb data area. Start &n;&t;&t;reading from RING_OFFSET, the address as the 8390 sees it.  This will always&n;&t;&t;follow the read of the 8390 header. &n;*/
DECL|macro|ei_reset_8390
mdefine_line|#define ei_reset_8390 (ei_local-&gt;reset_8390)
DECL|macro|ei_block_output
mdefine_line|#define ei_block_output (ei_local-&gt;block_output)
DECL|macro|ei_block_input
mdefine_line|#define ei_block_input (ei_local-&gt;block_input)
DECL|macro|ei_get_8390_hdr
mdefine_line|#define ei_get_8390_hdr (ei_local-&gt;get_8390_hdr)
multiline_comment|/* use 0 for production, 1 for verification, &gt;2 for debug */
macro_line|#ifndef ei_debug
DECL|variable|ei_debug
r_int
id|ei_debug
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* Index to functions. */
r_static
r_void
id|ei_tx_intr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ei_tx_err
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ei_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ei_receive
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ei_rx_overrun
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Routines generic to NS8390-based boards. */
r_static
r_void
id|NS8390_trigger_send
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|length
comma
r_int
id|start_page
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|do_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;SMP and the 8390 setup.&n; *&n; *&t;The 8390 isnt exactly designed to be multithreaded on RX/TX. There is&n; *&t;a page register that controls bank and packet buffer access. We guard&n; *&t;this with ei_local-&gt;page_lock. Nobody should assume or set the page other&n; *&t;than zero when the lock is not held. Lock holders must restore page 0&n; *&t;before unlocking. Even pure readers must take the lock to protect in &n; *&t;page 0.&n; *&n; *&t;To make life difficult the chip can also be very slow. We therefore can&squot;t&n; *&t;just use spinlocks. For the longer lockups we disable the irq the device&n; *&t;sits on and hold the lock. We must hold the lock because there is a dual&n; *&t;processor case other than interrupts (get stats/set multicast list in&n; *&t;parallel with each other and transmit).&n; *&n; *&t;Note: in theory we can just disable the irq on the card _but_ there is&n; *&t;a latency on SMP irq delivery. So we can easily go &quot;disable irq&quot; &quot;sync irqs&quot;&n; *&t;enter lock, take the queued irq. So we waddle instead of flying.&n; *&n; *&t;Finally by special arrangement for the purpose of being generally &n; *&t;annoying the transmit function is called bh atomic. That places&n; *&t;restrictions on the user context callers as disable_irq won&squot;t save&n; *&t;them.&n; */
"&f;"
multiline_comment|/**&n; * ei_open - Open/initialize the board.&n; * @dev: network device to initialize&n; *&n; * This routine goes all-out, setting everything&n; * up anew at each open, even though many of these registers should only&n; * need to be set once at boot.&n; */
DECL|function|ei_open
r_static
r_int
id|ei_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* This can&squot;t happen unless somebody forgot to call ethdev_init(). */
r_if
c_cond
(paren
id|ei_local
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%s: ei_open passed a non-existent device!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
macro_line|#ifdef HAVE_TX_TIMEOUT
multiline_comment|/* The card I/O part of the driver (e.g. 3c503) can hook a Tx timeout&n;&t;    wrapper that does e.g. media check &amp; then calls ei_tx_timeout. */
r_if
c_cond
(paren
id|dev-&gt;tx_timeout
op_eq
l_int|NULL
)paren
id|dev-&gt;tx_timeout
op_assign
id|ei_tx_timeout
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;watchdog_timeo
op_le
l_int|0
)paren
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Grab the page lock so we own the register set, then call&n;&t; *&t;the init function.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Set the flag before we drop the lock, That way the IRQ arrives&n;&t;   after its set and we get no silly warnings */
id|netif_mark_up
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|ei_local-&gt;irqlock
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ei_close - shut down network device&n; * @dev: network device to close&n; *&n; * Opposite of ei_open(). Only used when &quot;ifconfig &lt;devname&gt; down&quot; is done.&n; */
DECL|function|ei_close
r_static
r_int
id|ei_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Hold the page lock during close&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|page_lock
comma
id|flags
)paren
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|page_lock
comma
id|flags
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ei_tx_timeout - handle transmit time out condition&n; * @dev: network device which has apparently fallen asleep&n; *&n; * Called by kernel when device never acknowledges a transmit has&n; * completed (or failed) - i.e. never posted a Tx related interrupt.&n; */
DECL|function|ei_tx_timeout
r_void
id|ei_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|txsr
comma
id|isr
comma
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ei_local-&gt;stat.tx_errors
op_increment
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|txsr
op_assign
id|inb
c_func
(paren
id|e8390_base
op_plus
id|EN0_TSR
)paren
suffix:semicolon
id|isr
op_assign
id|inb
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Tx timed out, %s TSR=%#2x, ISR=%#2x, t=%d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|txsr
op_amp
id|ENTSR_ABT
)paren
ques
c_cond
l_string|&quot;excess collisions.&quot;
suffix:colon
(paren
id|isr
)paren
ques
c_cond
l_string|&quot;lost interrupt?&quot;
suffix:colon
l_string|&quot;cable problem?&quot;
comma
id|txsr
comma
id|isr
comma
id|tickssofar
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isr
op_logical_and
op_logical_neg
id|ei_local-&gt;stat.tx_packets
)paren
(brace
multiline_comment|/* The 8390 probably hasn&squot;t gotten on the cable yet. */
id|ei_local-&gt;interface_num
op_xor_assign
l_int|1
suffix:semicolon
multiline_comment|/* Try a different xcvr.  */
)brace
multiline_comment|/* Ugly but a reset can be slow, yet must be protected */
id|disable_irq_nosync
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
multiline_comment|/* Try to restart the card.  Perhaps the user has fixed something. */
id|ei_reset_8390
c_func
(paren
id|dev
)paren
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ei_start_xmit - begin packet transmission&n; * @skb: packet to be sent&n; * @dev: network device to which packet is sent&n; *&n; * Sends a packet to an 8390 network device.&n; */
DECL|function|ei_start_xmit
r_static
r_int
id|ei_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|length
comma
id|send_length
comma
id|output_page
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|skb_tx_check
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
id|length
op_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/* Mask interrupts from the ethercard. &n;&t;   SMP: We have to grab the lock here otherwise the IRQ handler&n;&t;   on another CPU can flip window and race the IRQ mask set. We end&n;&t;   up trashing the mcast filter not disabling irqs if we dont lock */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Slow phase with lock held.&n;&t; */
id|disable_irq_nosync
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
id|ei_local-&gt;irqlock
op_assign
l_int|1
suffix:semicolon
id|send_length
op_assign
id|ETH_ZLEN
OL
id|length
ques
c_cond
id|length
suffix:colon
id|ETH_ZLEN
suffix:semicolon
macro_line|#ifdef EI_PINGPONG
multiline_comment|/*&n;&t; * We have two Tx slots available for use. Find the first free&n;&t; * slot, and then perform some sanity checks. With two Tx bufs,&n;&t; * you get very close to transmitting back-to-back packets. With&n;&t; * only one Tx buf, the transmitter sits idle while you reload the&n;&t; * card, leaving a substantial gap between each transmitted packet.&n;&t; */
r_if
c_cond
(paren
id|ei_local-&gt;tx1
op_eq
l_int|0
)paren
(brace
id|output_page
op_assign
id|ei_local-&gt;tx_start_page
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
id|send_length
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
op_logical_and
id|ei_local-&gt;tx2
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: idle transmitter tx2=%d, lasttx=%d, txing=%d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ei_local-&gt;tx2
comma
id|ei_local-&gt;lasttx
comma
id|ei_local-&gt;txing
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ei_local-&gt;tx2
op_eq
l_int|0
)paren
(brace
id|output_page
op_assign
id|ei_local-&gt;tx_start_page
op_plus
id|TX_1X_PAGES
suffix:semicolon
id|ei_local-&gt;tx2
op_assign
id|send_length
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
op_logical_and
id|ei_local-&gt;tx1
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: idle transmitter, tx1=%d, lasttx=%d, txing=%d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ei_local-&gt;tx1
comma
id|ei_local-&gt;lasttx
comma
id|ei_local-&gt;txing
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We should never get here. */
r_if
c_cond
(paren
id|ei_debug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: No Tx buffers free! tx1=%d tx2=%d last=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ei_local-&gt;tx1
comma
id|ei_local-&gt;tx2
comma
id|ei_local-&gt;lasttx
)paren
suffix:semicolon
id|ei_local-&gt;irqlock
op_assign
l_int|0
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|ei_local-&gt;stat.tx_errors
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Okay, now upload the packet and trigger a send if the transmitter&n;&t; * isn&squot;t already sending. If it is busy, the interrupt handler will&n;&t; * trigger the send later, upon receiving a Tx done interrupt.&n;&t; */
id|ei_block_output
c_func
(paren
id|dev
comma
id|length
comma
id|skb-&gt;data
comma
id|output_page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ei_local-&gt;txing
)paren
(brace
id|ei_local-&gt;txing
op_assign
l_int|1
suffix:semicolon
id|NS8390_trigger_send
c_func
(paren
id|dev
comma
id|send_length
comma
id|output_page
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|output_page
op_eq
id|ei_local-&gt;tx_start_page
)paren
(brace
id|ei_local-&gt;tx1
op_assign
op_minus
l_int|1
suffix:semicolon
id|ei_local-&gt;lasttx
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ei_local-&gt;tx2
op_assign
op_minus
l_int|1
suffix:semicolon
id|ei_local-&gt;lasttx
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
)brace
r_else
id|ei_local-&gt;txqueue
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;tx1
op_logical_and
id|ei_local-&gt;tx2
)paren
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else&t;/* EI_PINGPONG */
multiline_comment|/*&n;&t; * Only one Tx buffer in use. You need two Tx bufs to come close to&n;&t; * back-to-back transmits. Expect a 20 -&gt; 25% performance hit on&n;&t; * reasonable hardware if you only use one Tx buffer.&n;&t; */
id|ei_block_output
c_func
(paren
id|dev
comma
id|length
comma
id|skb-&gt;data
comma
id|ei_local-&gt;tx_start_page
)paren
suffix:semicolon
id|ei_local-&gt;txing
op_assign
l_int|1
suffix:semicolon
id|NS8390_trigger_send
c_func
(paren
id|dev
comma
id|send_length
comma
id|ei_local-&gt;tx_start_page
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif&t;/* EI_PINGPONG */
multiline_comment|/* Turn 8390 interrupts back on. */
id|ei_local-&gt;irqlock
op_assign
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|DEV_KFREE_SKB
(paren
id|skb
)paren
suffix:semicolon
id|add_tx_bytes
c_func
(paren
op_amp
id|ei_local-&gt;stat
comma
id|send_length
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/**&n; * ei_interrupt - handle the interrupts from an 8390&n; * @irq: interrupt number&n; * @dev_id: a pointer to the net_device&n; * @regs: unused&n; *&n; * Handle the ether interface interrupts. We pull packets from&n; * the 8390 via the card specific functions and fire them at the networking&n; * stack. We also handle transmit completions and wake the transmit path if&n; * neccessary. We also update the counters and do other housekeeping as&n; * needed.&n; */
DECL|function|ei_interrupt
r_static
r_void
id|ei_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_int
id|e8390_base
suffix:semicolon
r_int
id|interrupts
comma
id|nr_serviced
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;net_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Protect the irq test too.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;irqlock
)paren
(brace
macro_line|#if 1 /* This might just be an interrupt for a PCI device sharing this line */
multiline_comment|/* The &quot;irqlock&quot; check is only for testing. */
id|printk
c_func
(paren
id|ei_local-&gt;irqlock
ques
c_cond
l_string|&quot;%s: Interrupted while interrupts are masked! isr=%#2x imr=%#2x.&bslash;n&quot;
suffix:colon
l_string|&quot;%s: Reentering the interrupt handler! isr=%#2x imr=%#2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
comma
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_IMR
)paren
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ei_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: interrupt(isr=%#2.2x).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
id|ei_local-&gt;irqlock
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* !!Assumption!! -- we stay in page 0.&t; Don&squot;t break this. */
r_while
c_loop
(paren
(paren
id|interrupts
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
)paren
op_ne
l_int|0
op_logical_and
op_increment
id|nr_serviced
OL
id|MAX_SERVICE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|netif_running
c_func
(paren
id|dev
)paren
op_logical_or
(paren
id|interrupts
op_eq
l_int|0xff
)paren
)paren
(brace
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: interrupt from stopped card&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|interrupts
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
id|interrupts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* AX88190 bug fix. */
id|outb_p
c_func
(paren
id|interrupts
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
op_amp
id|interrupts
)paren
)paren
r_break
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|interrupts
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_OVER
)paren
id|ei_rx_overrun
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|interrupts
op_amp
(paren
id|ENISR_RX
op_plus
id|ENISR_RX_ERR
)paren
)paren
(brace
multiline_comment|/* Got a good (?) packet. */
id|ei_receive
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Push the next to-transmit packet through. */
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_TX
)paren
id|ei_tx_intr
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_TX_ERR
)paren
id|ei_tx_err
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interrupts
op_amp
id|ENISR_COUNTERS
)paren
(brace
id|ei_local-&gt;stat.rx_frame_errors
op_add_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_COUNTER0
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_crc_errors
op_add_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_COUNTER1
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_missed_errors
op_add_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_COUNTER2
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|interrupts
op_logical_and
id|ei_debug
)paren
(brace
r_if
c_cond
(paren
id|nr_serviced
op_ge
id|MAX_SERVICE
)paren
(brace
multiline_comment|/* 0xFF is valid for a card removal */
r_if
c_cond
(paren
id|interrupts
op_ne
l_int|0xFF
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Too much work at interrupt, status %#2.2x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|interrupts
)paren
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack. most intrs. */
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: unknown interrupt %#2x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|interrupts
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0xff
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
multiline_comment|/* Ack. all intrs. */
)brace
)brace
multiline_comment|/* Turn 8390 interrupts back on. */
id|ei_local-&gt;irqlock
op_assign
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ei_tx_err - handle transmitter error&n; * @dev: network device which threw the exception&n; *&n; * A transmitter error has happened. Most likely excess collisions (which&n; * is a fairly normal condition). If the error is one where the Tx will&n; * have been aborted, we try and send another one right away, instead of&n; * letting the failed packet sit and collect dust in the Tx buffer. This&n; * is a much better solution as it avoids kernel based Tx timeouts, and&n; * an unnecessary card reset.&n; *&n; * Called with lock held.&n; */
DECL|function|ei_tx_err
r_static
r_void
id|ei_tx_err
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_char
id|txsr
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_TSR
)paren
suffix:semicolon
r_int
r_char
id|tx_was_aborted
op_assign
id|txsr
op_amp
(paren
id|ENTSR_ABT
op_plus
id|ENTSR_FU
)paren
suffix:semicolon
macro_line|#ifdef VERBOSE_ERROR_DUMP
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: transmitter error (%#2x): &quot;
comma
id|dev-&gt;name
comma
id|txsr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_ABT
)paren
id|printk
c_func
(paren
l_string|&quot;excess-collisions &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_ND
)paren
id|printk
c_func
(paren
l_string|&quot;non-deferral &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_CRS
)paren
id|printk
c_func
(paren
l_string|&quot;lost-carrier &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_FU
)paren
id|printk
c_func
(paren
l_string|&quot;FIFO-underrun &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_CDH
)paren
id|printk
c_func
(paren
l_string|&quot;lost-heartbeat &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tx_was_aborted
)paren
id|ei_tx_intr
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
(brace
id|ei_local-&gt;stat.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_CRS
)paren
id|ei_local-&gt;stat.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_CDH
)paren
id|ei_local-&gt;stat.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|txsr
op_amp
id|ENTSR_OWC
)paren
id|ei_local-&gt;stat.tx_window_errors
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * ei_tx_intr - transmit interrupt handler&n; * @dev: network device for which tx intr is handled&n; *&n; * We have finished a transmit: check for errors and then trigger the next&n; * packet to be sent. Called with lock held.&n; */
DECL|function|ei_tx_intr
r_static
r_void
id|ei_tx_intr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|status
op_assign
id|inb
c_func
(paren
id|e8390_base
op_plus
id|EN0_TSR
)paren
suffix:semicolon
macro_line|#ifdef EI_PINGPONG
multiline_comment|/*&n;&t; * There are two Tx buffers, see which one finished, and trigger&n;&t; * the send of another one if it exists.&n;&t; */
id|ei_local-&gt;txqueue
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;tx1
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ei_local-&gt;lasttx
op_ne
l_int|1
op_logical_and
id|ei_local-&gt;lasttx
op_ne
op_minus
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: bogus last_tx_buffer %d, tx1=%d.&bslash;n&quot;
comma
id|ei_local-&gt;name
comma
id|ei_local-&gt;lasttx
comma
id|ei_local-&gt;tx1
)paren
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;tx2
OG
l_int|0
)paren
(brace
id|ei_local-&gt;txing
op_assign
l_int|1
suffix:semicolon
id|NS8390_trigger_send
c_func
(paren
id|dev
comma
id|ei_local-&gt;tx2
comma
id|ei_local-&gt;tx_start_page
op_plus
l_int|6
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|ei_local-&gt;tx2
op_assign
op_minus
l_int|1
comma
id|ei_local-&gt;lasttx
op_assign
l_int|2
suffix:semicolon
)brace
r_else
id|ei_local-&gt;lasttx
op_assign
l_int|20
comma
id|ei_local-&gt;txing
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ei_local-&gt;tx2
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ei_local-&gt;lasttx
op_ne
l_int|2
op_logical_and
id|ei_local-&gt;lasttx
op_ne
op_minus
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: bogus last_tx_buffer %d, tx2=%d.&bslash;n&quot;
comma
id|ei_local-&gt;name
comma
id|ei_local-&gt;lasttx
comma
id|ei_local-&gt;tx2
)paren
suffix:semicolon
id|ei_local-&gt;tx2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ei_local-&gt;tx1
OG
l_int|0
)paren
(brace
id|ei_local-&gt;txing
op_assign
l_int|1
suffix:semicolon
id|NS8390_trigger_send
c_func
(paren
id|dev
comma
id|ei_local-&gt;tx1
comma
id|ei_local-&gt;tx_start_page
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
op_minus
l_int|1
suffix:semicolon
id|ei_local-&gt;lasttx
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|ei_local-&gt;lasttx
op_assign
l_int|10
comma
id|ei_local-&gt;txing
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|//&t;else printk(KERN_WARNING &quot;%s: unexpected TX-done interrupt, lasttx=%d.&bslash;n&quot;,
singleline_comment|//&t;&t;&t;dev-&gt;name, ei_local-&gt;lasttx);
macro_line|#else&t;/* EI_PINGPONG */
multiline_comment|/*&n;&t; *  Single Tx buffer: mark it free so another packet can be loaded.&n;&t; */
id|ei_local-&gt;txing
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Minimize Tx latency: update the statistics after we restart TXing. */
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_COL
)paren
id|ei_local-&gt;stat.collisions
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_PTX
)paren
id|ei_local-&gt;stat.tx_packets
op_increment
suffix:semicolon
r_else
(brace
id|ei_local-&gt;stat.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_ABT
)paren
(brace
id|ei_local-&gt;stat.tx_aborted_errors
op_increment
suffix:semicolon
id|ei_local-&gt;stat.collisions
op_add_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_CRS
)paren
id|ei_local-&gt;stat.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_FU
)paren
id|ei_local-&gt;stat.tx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_CDH
)paren
id|ei_local-&gt;stat.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ENTSR_OWC
)paren
id|ei_local-&gt;stat.tx_window_errors
op_increment
suffix:semicolon
)brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ei_receive - receive some packets&n; * @dev: network device with which receive will be run&n; *&n; * We have a good packet(s), get it/them out of the buffers. &n; * Called with lock held.&n; */
DECL|function|ei_receive
r_static
r_void
id|ei_receive
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_char
id|rxing_page
comma
id|this_frame
comma
id|next_frame
suffix:semicolon
r_int
r_int
id|current_offset
suffix:semicolon
r_int
id|rx_pkt_count
op_assign
l_int|0
suffix:semicolon
r_struct
id|e8390_pkt_hdr
id|rx_frame
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|rx_pkt_count
OL
l_int|10
)paren
(brace
r_int
id|pkt_len
comma
id|pkt_stat
suffix:semicolon
multiline_comment|/* Get the rx page (incoming packet pointer). */
id|rxing_page
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN1_CURPAG
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Remove one frame from the ring.  Boundary is always a page behind. */
id|this_frame
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_BOUNDARY
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|this_frame
op_ge
id|ei_local-&gt;stop_page
)paren
id|this_frame
op_assign
id|ei_local-&gt;rx_start_page
suffix:semicolon
multiline_comment|/* Someday we&squot;ll omit the previous, iff we never get this message.&n;&t;&t;   (There is at least one clone claimed to have a problem.)  &n;&t;&t;   &n;&t;&t;   Keep quiet if it looks like a card removal. One problem here&n;&t;&t;   is that some clones crash in roughly the same way.&n;&t;&t; */
r_if
c_cond
(paren
id|ei_debug
OG
l_int|0
op_logical_and
id|this_frame
op_ne
id|ei_local-&gt;current_page
op_logical_and
(paren
id|this_frame
op_ne
l_int|0x0
op_logical_or
id|rxing_page
op_ne
l_int|0xFF
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: mismatched read page pointers %2x vs %2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|this_frame
comma
id|ei_local-&gt;current_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this_frame
op_eq
id|rxing_page
)paren
multiline_comment|/* Read all the frames? */
r_break
suffix:semicolon
multiline_comment|/* Done for now */
id|current_offset
op_assign
id|this_frame
op_lshift
l_int|8
suffix:semicolon
id|ei_get_8390_hdr
c_func
(paren
id|dev
comma
op_amp
id|rx_frame
comma
id|this_frame
)paren
suffix:semicolon
id|pkt_len
op_assign
id|rx_frame.count
op_minus
r_sizeof
(paren
r_struct
id|e8390_pkt_hdr
)paren
suffix:semicolon
id|pkt_stat
op_assign
id|rx_frame.status
suffix:semicolon
id|next_frame
op_assign
id|this_frame
op_plus
l_int|1
op_plus
(paren
(paren
id|pkt_len
op_plus
l_int|4
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_len
template_param
l_int|1518
)paren
(brace
r_if
c_cond
(paren
id|ei_debug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: bogus packet size: %d, status=%#2x nxpg=%#2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_frame.count
comma
id|rx_frame.status
comma
id|rx_frame.next
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_errors
op_increment
suffix:semicolon
id|ei_local-&gt;stat.rx_length_errors
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|pkt_stat
op_amp
l_int|0x0F
)paren
op_eq
id|ENRSR_RXOK
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Couldn&squot;t allocate a sk_buff of size %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pkt_len
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* IP headers on 16 byte boundaries */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
multiline_comment|/* Make room */
id|ei_block_input
c_func
(paren
id|dev
comma
id|pkt_len
comma
id|skb
comma
id|current_offset
op_plus
r_sizeof
(paren
id|rx_frame
)paren
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|ei_local-&gt;stat.rx_packets
op_increment
suffix:semicolon
id|add_rx_bytes
c_func
(paren
op_amp
id|ei_local-&gt;stat
comma
id|pkt_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_stat
op_amp
id|ENRSR_PHY
)paren
id|ei_local-&gt;stat.multicast
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|ei_debug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: bogus packet: status=%#2x nxpg=%#2x size=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_frame.status
comma
id|rx_frame.next
comma
id|rx_frame.count
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_errors
op_increment
suffix:semicolon
multiline_comment|/* NB: The NIC counts CRC, frame and missed errors. */
r_if
c_cond
(paren
id|pkt_stat
op_amp
id|ENRSR_FO
)paren
id|ei_local-&gt;stat.rx_fifo_errors
op_increment
suffix:semicolon
)brace
id|next_frame
op_assign
id|rx_frame.next
suffix:semicolon
multiline_comment|/* This _should_ never happen: it&squot;s here for avoiding bad clones. */
r_if
c_cond
(paren
id|next_frame
op_ge
id|ei_local-&gt;stop_page
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: next frame inconsistency, %#2x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|next_frame
)paren
suffix:semicolon
id|next_frame
op_assign
id|ei_local-&gt;rx_start_page
suffix:semicolon
)brace
id|ei_local-&gt;current_page
op_assign
id|next_frame
suffix:semicolon
id|outb_p
c_func
(paren
id|next_frame
op_minus
l_int|1
comma
id|e8390_base
op_plus
id|EN0_BOUNDARY
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ei_rx_overrun - handle receiver overrun&n; * @dev: network device which threw exception&n; *&n; * We have a receiver overrun: we have to kick the 8390 to get it started&n; * again. Problem is that you have to kick it exactly as NS prescribes in&n; * the updated datasheets, or &quot;the NIC may act in an unpredictable manner.&quot;&n; * This includes causing &quot;the NIC to defer indefinitely when it is stopped&n; * on a busy network.&quot;  Ugh.&n; * Called with lock held. Don&squot;t call this with the interrupts off or your&n; * computer will hate you - it takes 10ms or so. &n; */
DECL|function|ei_rx_overrun
r_static
r_void
id|ei_rx_overrun
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|axnet_dev_t
op_star
id|info
op_assign
(paren
id|axnet_dev_t
op_star
)paren
id|dev
suffix:semicolon
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_char
id|was_txing
comma
id|must_resend
op_assign
l_int|0
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/*&n;&t; * Record whether a Tx was in progress and then issue the&n;&t; * stop command.&n;&t; */
id|was_txing
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|E8390_CMD
)paren
op_amp
id|E8390_TRANS
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_STOP
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Receiver overrun.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_over_errors
op_increment
suffix:semicolon
multiline_comment|/* &n;&t; * Wait a full Tx time (1.2ms) + some guard time, NS says 1.6ms total.&n;&t; * Early datasheets said to poll the reset bit, but now they say that&n;&t; * it &quot;is not a reliable indicator and subsequently should be ignored.&quot;&n;&t; * We wait at least 10ms.&n;&t; */
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset RBCR[01] back to zero as per magic incantation.&n;&t; */
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_RCNTLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_RCNTHI
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * See if any Tx was interrupted or not. According to NS, this&n;&t; * step is vital, and skipping it will cause no end of havoc.&n;&t; */
r_if
c_cond
(paren
id|was_txing
)paren
(brace
r_int
r_char
id|tx_completed
op_assign
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN0_ISR
)paren
op_amp
(paren
id|ENISR_TX
op_plus
id|ENISR_TX_ERR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tx_completed
)paren
id|must_resend
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Have to enter loopback mode and then restart the NIC before&n;&t; * you are allowed to slurp packets up off the ring.&n;&t; */
id|outb_p
c_func
(paren
id|E8390_TXOFF
comma
id|e8390_base
op_plus
id|EN0_TXCR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the Rx ring of all the debris, and ack the interrupt.&n;&t; */
id|ei_receive
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Leave loopback mode, and resend any packet that got stopped.&n;&t; */
id|outb_p
c_func
(paren
id|E8390_TXCONFIG
op_or
id|info-&gt;duplex_flag
comma
id|e8390_base
op_plus
id|EN0_TXCR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|must_resend
)paren
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
op_plus
id|E8390_TRANS
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Collect the stats. This is called unlocked and from several contexts.&n; */
DECL|function|get_stats
r_static
r_struct
id|net_device_stats
op_star
id|get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* If the card is stopped, just return the present stats. */
r_if
c_cond
(paren
op_logical_neg
id|netif_running
c_func
(paren
id|dev
)paren
)paren
r_return
op_amp
id|ei_local-&gt;stat
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Read the counter registers, assuming we are in page 0. */
id|ei_local-&gt;stat.rx_frame_errors
op_add_assign
id|inb_p
c_func
(paren
id|ioaddr
op_plus
id|EN0_COUNTER0
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_crc_errors
op_add_assign
id|inb_p
c_func
(paren
id|ioaddr
op_plus
id|EN0_COUNTER1
)paren
suffix:semicolon
id|ei_local-&gt;stat.rx_missed_errors
op_add_assign
id|inb_p
c_func
(paren
id|ioaddr
op_plus
id|EN0_COUNTER2
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_amp
id|ei_local-&gt;stat
suffix:semicolon
)brace
multiline_comment|/**&n; * do_set_multicast_list - set/clear multicast filter&n; * @dev: net device for which multicast filter is adjusted&n; *&n; *&t;Set or clear the multicast filter for this adaptor. May be called&n; *&t;from a BH in 2.1.x. Must be called with lock held. &n; */
DECL|function|do_set_multicast_list
r_static
r_void
id|do_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
op_or
l_int|0x18
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
op_logical_or
id|dev-&gt;mc_list
)paren
(brace
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
op_or
l_int|0x08
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
)brace
r_else
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Called without lock held. This is invoked from user context and may&n; *&t;be parallel to just about everything else. Its also fairly quick and&n; *&t;not called too often. Must protect against both bh and irq users&n; */
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|page_lock
comma
id|flags
)paren
suffix:semicolon
id|do_set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|page_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ethdev_init - init rest of 8390 device struct&n; * @dev: network device structure to init&n; *&n; * Initialize the rest of the 8390 device structure.  Do NOT __init&n; * this, as it is used by 8390 based modular drivers too.&n; */
DECL|function|ethdev_init
r_static
r_int
id|ethdev_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
r_struct
id|ei_device
op_star
id|ei_local
suffix:semicolon
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ei_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ei_device
)paren
)paren
suffix:semicolon
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ei_local-&gt;page_lock
)paren
suffix:semicolon
)brace
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|ei_start_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* This page of functions should be 8390 generic */
multiline_comment|/* Follow National Semi&squot;s recommendations for initializing the &quot;NIC&quot;. */
multiline_comment|/**&n; * NS8390_init - initialize 8390 hardware&n; * @dev: network device to initialize&n; * @startp: boolean.  non-zero value to initiate chip processing&n; *&n; *&t;Must be called with lock held.&n; */
DECL|function|NS8390_init
r_static
r_void
id|NS8390_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|startp
)paren
(brace
id|axnet_dev_t
op_star
id|info
op_assign
(paren
id|axnet_dev_t
op_star
)paren
id|dev
suffix:semicolon
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|endcfg
op_assign
id|ei_local-&gt;word16
ques
c_cond
(paren
l_int|0x48
op_or
id|ENDCFG_WTS
)paren
suffix:colon
l_int|0x48
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|e8390_pkt_hdr
)paren
op_ne
l_int|4
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;8390.c: header struct mispacked&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Follow National Semi&squot;s recommendations for initing the DP83902. */
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_STOP
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
multiline_comment|/* 0x21 */
id|outb_p
c_func
(paren
id|endcfg
comma
id|e8390_base
op_plus
id|EN0_DCFG
)paren
suffix:semicolon
multiline_comment|/* 0x48 or 0x49 */
multiline_comment|/* Clear the remote byte count registers. */
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_RCNTLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_RCNTHI
)paren
suffix:semicolon
multiline_comment|/* Set to monitor and loopback mode -- this is vital!. */
id|outb_p
c_func
(paren
id|E8390_RXOFF
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
multiline_comment|/* 0x20 */
id|outb_p
c_func
(paren
id|E8390_TXOFF
comma
id|e8390_base
op_plus
id|EN0_TXCR
)paren
suffix:semicolon
multiline_comment|/* 0x02 */
multiline_comment|/* Set the transmit page and receive ring. */
id|outb_p
c_func
(paren
id|ei_local-&gt;tx_start_page
comma
id|e8390_base
op_plus
id|EN0_TPSR
)paren
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
id|ei_local-&gt;tx2
op_assign
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|ei_local-&gt;rx_start_page
comma
id|e8390_base
op_plus
id|EN0_STARTPG
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ei_local-&gt;stop_page
op_minus
l_int|1
comma
id|e8390_base
op_plus
id|EN0_BOUNDARY
)paren
suffix:semicolon
multiline_comment|/* 3c503 says 0x3f,NS0x26*/
id|ei_local-&gt;current_page
op_assign
id|ei_local-&gt;rx_start_page
suffix:semicolon
multiline_comment|/* assert boundary+1 */
id|outb_p
c_func
(paren
id|ei_local-&gt;stop_page
comma
id|e8390_base
op_plus
id|EN0_STOPPG
)paren
suffix:semicolon
multiline_comment|/* Clear the pending interrupts and mask. */
id|outb_p
c_func
(paren
l_int|0xFF
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
multiline_comment|/* Copy the station address into the DS8390 registers. */
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE1
op_plus
id|E8390_STOP
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
multiline_comment|/* 0x61 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb_p
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|e8390_base
op_plus
id|EN1_PHYS_SHIFT
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|e8390_base
op_plus
id|EN1_PHYS_SHIFT
c_func
(paren
id|i
)paren
)paren
op_ne
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Hw. address read/write mismap %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Initialize the multicast list to accept-all.  If we enable multicast&n;&t; * the higher levels can do the filtering.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|outb_p
c_func
(paren
l_int|0xff
comma
id|e8390_base
op_plus
id|EN1_MULT
op_plus
id|i
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ei_local-&gt;rx_start_page
comma
id|e8390_base
op_plus
id|EN1_CURPAG
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_STOP
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ei_local-&gt;tx1
op_assign
id|ei_local-&gt;tx2
op_assign
l_int|0
suffix:semicolon
id|ei_local-&gt;txing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|startp
)paren
(brace
id|outb_p
c_func
(paren
l_int|0xff
comma
id|e8390_base
op_plus
id|EN0_ISR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENISR_ALL
comma
id|e8390_base
op_plus
id|EN0_IMR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_PAGE0
op_plus
id|E8390_START
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_TXCONFIG
op_or
id|info-&gt;duplex_flag
comma
id|e8390_base
op_plus
id|EN0_TXCR
)paren
suffix:semicolon
multiline_comment|/* xmit on. */
multiline_comment|/* 3c503 TechMan says rxconfig only after the NIC is started. */
id|outb_p
c_func
(paren
id|E8390_RXCONFIG
comma
id|e8390_base
op_plus
id|EN0_RXCR
)paren
suffix:semicolon
multiline_comment|/* rx on,  */
id|do_set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* (re)load the mcast table */
)brace
)brace
multiline_comment|/* Trigger a transmit start, assuming the length is valid. &n;   Always called with the page lock held */
DECL|function|NS8390_trigger_send
r_static
r_void
id|NS8390_trigger_send
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|length
comma
r_int
id|start_page
)paren
(brace
r_int
id|e8390_base
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|ei_device
op_star
id|ei_local
id|__attribute
c_func
(paren
(paren
id|unused
)paren
)paren
op_assign
(paren
r_struct
id|ei_device
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|e8390_base
)paren
op_amp
id|E8390_TRANS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: trigger_send() called with the transmitter busy.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|length
op_amp
l_int|0xff
comma
id|e8390_base
op_plus
id|EN0_TCNTLO
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|length
op_rshift
l_int|8
comma
id|e8390_base
op_plus
id|EN0_TCNTHI
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|start_page
comma
id|e8390_base
op_plus
id|EN0_TPSR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|E8390_NODMA
op_plus
id|E8390_TRANS
op_plus
id|E8390_START
comma
id|e8390_base
op_plus
id|E8390_CMD
)paren
suffix:semicolon
)brace
eof
