multiline_comment|/*&n; * xircom_cb: A driver for the (tulip-like) Xircom Cardbus ethernet cards &n; *&n; * This software is Copyright 2001 by the respective authors, and licensed under the GPL&n; * License.&n; *&n; * Written by Arjan van de Ven for Red Hat, Inc.&n; * Based on work by Jeff Garzik, Doug Ledford, Donald Becker and Ion Badulescu&n; *&n; *  &t;This software may be used and distributed according to the terms&n; *      of the GNU General Public License, incorporated herein by reference.&n; *&n; *&n; * &t;$Id: xircom_cb.c,v 1.11 2001/06/05 09:50:57 fenrus Exp $&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#ifdef DEBUG
DECL|macro|enter
mdefine_line|#define enter()   printk(&quot;Enter: %s, %s line %i&bslash;n&quot;,__FUNCTION__,__FILE__,__LINE__)
DECL|macro|leave
mdefine_line|#define leave()   printk(&quot;Leave: %s, %s line %i&bslash;n&quot;,__FUNCTION__,__FILE__,__LINE__)
macro_line|#else
DECL|macro|enter
mdefine_line|#define enter()   do {} while (0)
DECL|macro|leave
mdefine_line|#define leave()   do {} while (0)
macro_line|#endif
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Xircom Cardbus ethernet driver&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Arjan van de Ven &lt;arjanv@redhat.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/* IO registers on the card, offsets */
DECL|macro|CSR0
mdefine_line|#define CSR0&t;0x00
DECL|macro|CSR1
mdefine_line|#define CSR1&t;0x08
DECL|macro|CSR2
mdefine_line|#define CSR2&t;0x10
DECL|macro|CSR3
mdefine_line|#define CSR3&t;0x18
DECL|macro|CSR4
mdefine_line|#define CSR4&t;0x20
DECL|macro|CSR5
mdefine_line|#define CSR5&t;0x28
DECL|macro|CSR6
mdefine_line|#define CSR6&t;0x30
DECL|macro|CSR7
mdefine_line|#define CSR7&t;0x38
DECL|macro|CSR8
mdefine_line|#define CSR8&t;0x40
DECL|macro|CSR9
mdefine_line|#define CSR9&t;0x48
DECL|macro|CSR10
mdefine_line|#define CSR10&t;0x50
DECL|macro|CSR11
mdefine_line|#define CSR11&t;0x58
DECL|macro|CSR12
mdefine_line|#define CSR12&t;0x60
DECL|macro|CSR13
mdefine_line|#define CSR13&t;0x68
DECL|macro|CSR14
mdefine_line|#define CSR14&t;0x70
DECL|macro|CSR15
mdefine_line|#define CSR15&t;0x78
DECL|macro|CSR16
mdefine_line|#define CSR16&t;0x80
multiline_comment|/* PCI registers */
DECL|macro|PCI_POWERMGMT
mdefine_line|#define PCI_POWERMGMT &t;0x40
multiline_comment|/* Offsets of the buffers within the descriptor pages, in bytes */
DECL|macro|NUMDESCRIPTORS
mdefine_line|#define NUMDESCRIPTORS 4
DECL|macro|RXTXBUFSIZE
mdefine_line|#define RXTXBUFSIZE 8192
DECL|macro|MAX_PACKETSIZE
mdefine_line|#define MAX_PACKETSIZE 1536
DECL|macro|DescOwnedCard
mdefine_line|#define DescOwnedCard&t;0x80000000
DECL|macro|DescOwnedDriver
mdefine_line|#define DescOwnedDriver&t;0x00000000
DECL|macro|PromiscBit
mdefine_line|#define PromiscBit&t;&t;(1&lt;&lt;6)
DECL|macro|CollisionBit
mdefine_line|#define CollisionBit &t;&t;(1&lt;&lt;8)
DECL|macro|TxActiveBit
mdefine_line|#define TxActiveBit&t;&t;(1&lt;&lt;13)
DECL|macro|RxActiveBit
mdefine_line|#define RxActiveBit&t;&t;(1&lt;&lt;1)
DECL|macro|LastDescBit
mdefine_line|#define LastDescBit&t; &t;(1&lt;&lt;25)
DECL|macro|LinkStatusBit
mdefine_line|#define LinkStatusBit &t;&t;(1&lt;&lt;27)
DECL|macro|PowerMgmtBits
mdefine_line|#define PowerMgmtBits&t;&t;( (1&lt;&lt;31)|(1&lt;&lt;30) )
DECL|variable|bufferoffsets
r_static
r_const
r_int
r_int
id|bufferoffsets
(braket
id|NUMDESCRIPTORS
)braket
op_assign
(brace
l_int|128
comma
l_int|2048
comma
l_int|4096
comma
l_int|6144
)brace
suffix:semicolon
multiline_comment|/* note: this struct is assumed to be packed as this is the &quot;hardware&quot; layout */
DECL|struct|descriptor
r_struct
id|descriptor
(brace
DECL|member|status
id|u32
id|status
suffix:semicolon
DECL|member|control
id|u32
id|control
suffix:semicolon
DECL|member|address1
id|u32
id|address1
suffix:semicolon
DECL|member|address2
id|u32
id|address2
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|xircom_private
r_struct
id|xircom_private
(brace
multiline_comment|/* Send and receive buffers, kernel-addressable and dma addressable forms */
DECL|member|rx_buffer
r_int
r_char
op_star
id|rx_buffer
suffix:semicolon
DECL|member|tx_buffer
r_int
r_char
op_star
id|tx_buffer
suffix:semicolon
DECL|member|rx_desc
r_struct
id|descriptor
op_star
id|rx_desc
suffix:semicolon
DECL|member|tx_desc
r_struct
id|descriptor
op_star
id|tx_desc
suffix:semicolon
DECL|member|rx_dma_handle
id|dma_addr_t
id|rx_dma_handle
suffix:semicolon
DECL|member|tx_dma_handle
id|dma_addr_t
id|tx_dma_handle
suffix:semicolon
DECL|member|tx_skb
r_struct
id|sk_buff
op_star
id|tx_skb
(braket
id|NUMDESCRIPTORS
)braket
suffix:semicolon
DECL|member|io_port
r_int
r_int
id|io_port
suffix:semicolon
multiline_comment|/* transmit_used is the rotating counter that indicates which transmit&n;&t;   descriptor has to be used next */
DECL|member|transmit_used
r_int
r_int
id|transmit_used
suffix:semicolon
multiline_comment|/* Spinlock to serialize register operations.&n;&t;   It must be helt while manipulating the following registers:&n;&t;   CSR0, CSR6, CSR7, CSR9, CSR10, CSR15&n;&t; */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|pdev
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
DECL|member|dev
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Function prototypes */
r_static
r_int
id|xircom_probe
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|id
)paren
suffix:semicolon
r_static
r_void
id|xircom_remove
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
suffix:semicolon
r_static
r_void
id|xircom_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|xircom_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|xircom_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|xircom_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|xircom_up
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|xircom_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|investigate_rx_descriptor
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|xircom_private
op_star
id|card
comma
r_int
id|descnr
comma
r_int
r_int
id|bufferoffset
)paren
suffix:semicolon
r_static
r_int
r_int
id|investigate_tx_descriptor
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|xircom_private
op_star
id|card
comma
r_int
r_int
id|descnr
comma
r_int
r_int
id|bufferoffset
)paren
suffix:semicolon
r_static
r_void
id|read_mac_address
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|tranceiver_voodoo
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|initialize_card
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_inline
r_void
id|trigger_transmit
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_inline
r_void
id|trigger_receive
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|setup_descriptors
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_inline
r_void
id|remove_descriptors
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_inline
r_int
r_int
id|link_status_changed
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|activate_receiver
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|deactivate_receiver
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|activate_transmitter
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|deactivate_transmitter
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|enable_transmit_interrupt
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|enable_receive_interrupt
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|enable_link_interrupt
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_void
id|disable_all_interrupts
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_inline
r_int
r_int
id|link_status
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
suffix:semicolon
r_static
r_int
id|mdio_read
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
comma
r_int
id|phy_id
comma
r_int
id|location
)paren
suffix:semicolon
r_static
r_void
id|mdio_write
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
comma
r_int
id|phy_id
comma
r_int
id|location
comma
r_int
id|value
)paren
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|xircom_pci_table
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
l_int|0x115D
comma
l_int|0x0003
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
)brace
comma
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|xircom_pci_table
)paren
suffix:semicolon
DECL|variable|xircom_ops
r_static
r_struct
id|pci_driver
id|xircom_ops
op_assign
(brace
id|name
suffix:colon
l_string|&quot;xircom_cb&quot;
comma
id|id_table
suffix:colon
id|xircom_pci_table
comma
id|probe
suffix:colon
id|xircom_probe
comma
id|remove
suffix:colon
id|xircom_remove
comma
)brace
suffix:semicolon
macro_line|#ifdef DEBUG
DECL|function|print_binary
r_static
r_void
id|print_binary
c_func
(paren
r_int
r_int
id|number
)paren
(brace
r_int
id|i
comma
id|i2
suffix:semicolon
r_char
id|buffer
(braket
l_int|64
)braket
suffix:semicolon
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
l_int|64
)paren
suffix:semicolon
id|i2
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|31
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|number
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|buffer
(braket
id|i2
op_increment
)braket
op_assign
l_char|&squot;1&squot;
suffix:semicolon
r_else
id|buffer
(braket
id|i2
op_increment
)braket
op_assign
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
id|buffer
(braket
id|i2
op_increment
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* xircom_probe is the code that gets called on device insertion.&n;   it sets up the hardware and registers the device to the networklayer.&n;   &n;   TODO: Send 1 or 2 &quot;dummy&quot; packets here as the card seems to discard the&n;         first two packets that get send, and pump hates that.&n;         &n; */
DECL|function|xircom_probe
r_static
r_int
id|__devinit
id|xircom_probe
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|id
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|xircom_private
op_star
r_private
suffix:semicolon
id|u8
id|chip_rev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u32
id|tmp32
suffix:semicolon
id|u16
id|tmp16
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* First do the PCI initialisation */
id|ret
op_assign
id|pci_enable_device
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* disable all powermanagement */
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_POWERMGMT
comma
op_amp
id|tmp32
)paren
suffix:semicolon
id|tmp32
op_and_assign
op_complement
id|PowerMgmtBits
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|PCI_POWERMGMT
comma
id|tmp32
)paren
suffix:semicolon
id|pci_set_master
c_func
(paren
id|pdev
)paren
suffix:semicolon
multiline_comment|/* clear PCI status, if any */
id|pci_read_config_word
(paren
id|pdev
comma
id|PCI_STATUS
comma
op_amp
id|tmp16
)paren
suffix:semicolon
id|pci_write_config_word
(paren
id|pdev
comma
id|PCI_STATUS
comma
id|tmp16
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_REVISION_ID
comma
op_amp
id|chip_rev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
comma
l_int|128
comma
l_string|&quot;xircom_cb&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_probe: failed to allocate io-region&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dev
op_assign
id|init_etherdev
c_func
(paren
id|dev
comma
r_sizeof
(paren
op_star
r_private
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_probe: failed to allocate etherdev&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_private
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
r_private
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_probe: failed to allocate private device struct&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Allocate the send/receive buffers */
r_private
op_member_access_from_pointer
id|rx_buffer
op_assign
id|pci_alloc_consistent
c_func
(paren
id|pdev
comma
id|RXTXBUFSIZE
comma
op_amp
r_private
op_member_access_from_pointer
id|rx_dma_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
r_private
op_member_access_from_pointer
id|rx_buffer
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_probe: no memory for rx buffer &bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
r_private
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* the descriptors are stored in the first bytes of the rx_buffer, hence the ugly cast */
r_private
op_member_access_from_pointer
id|rx_desc
op_assign
(paren
r_struct
id|descriptor
op_star
)paren
r_private
op_member_access_from_pointer
id|rx_buffer
suffix:semicolon
r_private
op_member_access_from_pointer
id|tx_buffer
op_assign
id|pci_alloc_consistent
c_func
(paren
id|pdev
comma
id|RXTXBUFSIZE
comma
op_amp
r_private
op_member_access_from_pointer
id|tx_dma_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
r_private
op_member_access_from_pointer
id|tx_buffer
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_probe: no memory for tx buffer &bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
r_private
op_member_access_from_pointer
id|rx_buffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
r_private
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* the descriptors are stored in the first bytes of the tx_buffer, hence the ugly cast */
r_private
op_member_access_from_pointer
id|tx_desc
op_assign
(paren
r_struct
id|descriptor
op_star
)paren
r_private
op_member_access_from_pointer
id|tx_buffer
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Xircom cardbus revision %i at irq %i &bslash;n&quot;
comma
id|dev-&gt;name
comma
id|chip_rev
comma
id|pdev-&gt;irq
)paren
suffix:semicolon
r_private
op_member_access_from_pointer
id|dev
op_assign
id|dev
suffix:semicolon
r_private
op_member_access_from_pointer
id|pdev
op_assign
id|pdev
suffix:semicolon
r_private
op_member_access_from_pointer
id|io_port
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
r_private
op_member_access_from_pointer
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|dev-&gt;irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|dev-&gt;base_addr
op_assign
r_private
op_member_access_from_pointer
id|io_port
suffix:semicolon
id|initialize_card
c_func
(paren
r_private
)paren
suffix:semicolon
id|read_mac_address
c_func
(paren
r_private
)paren
suffix:semicolon
id|setup_descriptors
c_func
(paren
r_private
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|xircom_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|xircom_start_xmit
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|xircom_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|xircom_get_stats
suffix:semicolon
id|dev-&gt;priv
op_assign
r_private
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* start the transmitter to get a heartbeat; don&squot;t do&n;&t;   that when there already is one though; Cisco&squot;s &n;&t;   really don&squot;t like that. */
r_if
c_cond
(paren
op_logical_neg
id|link_status
c_func
(paren
r_private
)paren
)paren
id|tranceiver_voodoo
c_func
(paren
r_private
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
r_private
op_member_access_from_pointer
id|lock
comma
id|flags
)paren
suffix:semicolon
id|activate_transmitter
c_func
(paren
r_private
)paren
suffix:semicolon
id|activate_receiver
c_func
(paren
r_private
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
r_private
op_member_access_from_pointer
id|lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* TODO: send 2 dummy packets here */
id|trigger_receive
c_func
(paren
r_private
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; xircom_remove is called on module-unload or on device-eject.&n; it unregisters the irq, io-region and network device.&n; Interrupts and such are already stopped in the &quot;ifconfig ethX down&quot;&n; code.&n; */
DECL|function|xircom_remove
r_static
r_void
id|__devexit
id|xircom_remove
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_struct
id|xircom_private
op_star
id|card
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|card
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;rx_buffer
op_ne
l_int|NULL
)paren
id|pci_free_consistent
c_func
(paren
id|pdev
comma
id|RXTXBUFSIZE
comma
id|card-&gt;rx_buffer
comma
id|card-&gt;rx_dma_handle
)paren
suffix:semicolon
id|card-&gt;rx_buffer
op_assign
l_int|NULL
suffix:semicolon
id|card-&gt;rx_desc
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;tx_buffer
op_ne
l_int|NULL
)paren
id|pci_free_consistent
c_func
(paren
id|pdev
comma
id|RXTXBUFSIZE
comma
id|card-&gt;tx_buffer
comma
id|card-&gt;tx_dma_handle
)paren
suffix:semicolon
id|card-&gt;tx_buffer
op_assign
l_int|NULL
suffix:semicolon
id|card-&gt;tx_desc
op_assign
l_int|NULL
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
l_int|128
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
l_int|NULL
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|xircom_interrupt
r_static
r_void
id|xircom_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_instance
suffix:semicolon
r_struct
id|xircom_private
op_star
id|card
op_assign
id|dev-&gt;priv
suffix:semicolon
id|u32
id|status
suffix:semicolon
r_int
r_int
id|xmit_free_count
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|status
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0xffffffff
)paren
(brace
multiline_comment|/* card has been ejected / powered down */
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Todo: check if there were any events at all; to speed up&n;&t;   returning if we&squot;re on a shared interrupt */
r_if
c_cond
(paren
id|link_status_changed
c_func
(paren
id|card
)paren
)paren
(brace
r_int
id|newlink
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;xircom_cb: Link status has changed &bslash;n&quot;
)paren
suffix:semicolon
id|newlink
op_assign
id|link_status
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newlink
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;xircom_cb: Link is %i mbit &bslash;n&quot;
comma
id|newlink
)paren
suffix:semicolon
id|netif_carrier_on
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;xircom_cb: Link is absent &bslash;n&quot;
)paren
suffix:semicolon
id|netif_carrier_off
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Clear all remaining interrupt events */
id|status
op_or_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* FIXME: make this clear only the&n;&t;&t;&t;&t;        real existing bits */
id|outl
c_func
(paren
id|status
comma
id|card-&gt;io_port
op_plus
id|CSR5
)paren
suffix:semicolon
id|xmit_free_count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMDESCRIPTORS
suffix:semicolon
id|i
op_increment
)paren
id|xmit_free_count
op_add_assign
id|investigate_tx_descriptor
c_func
(paren
id|dev
comma
id|card
comma
id|i
comma
id|bufferoffsets
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMDESCRIPTORS
suffix:semicolon
id|i
op_increment
)paren
id|investigate_rx_descriptor
c_func
(paren
id|dev
comma
id|card
comma
id|i
comma
id|bufferoffsets
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmit_free_count
)paren
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|xircom_start_xmit
r_static
r_int
id|xircom_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|xircom_private
op_star
id|card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|nextdescriptor
suffix:semicolon
r_int
r_int
id|desc
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|card
op_assign
(paren
r_struct
id|xircom_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|nextdescriptor
op_assign
(paren
id|card-&gt;transmit_used
op_plus
l_int|1
)paren
op_mod
(paren
id|NUMDESCRIPTORS
)paren
suffix:semicolon
id|desc
op_assign
id|card-&gt;transmit_used
suffix:semicolon
multiline_comment|/* only send the packet if the descriptor is free */
r_if
c_cond
(paren
id|card-&gt;tx_desc
(braket
id|desc
)braket
dot
id|status
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Copy the packet data; zero the memory first as the card&n;&t;&t;&t;   sometimes sends more than you ask it to. */
id|memset
c_func
(paren
op_amp
id|card-&gt;tx_buffer
(braket
id|bufferoffsets
(braket
id|desc
)braket
)braket
comma
l_int|0
comma
id|MAX_PACKETSIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|card-&gt;tx_buffer
(braket
id|bufferoffsets
(braket
id|desc
)braket
)braket
)paren
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* FIXME: The specification tells us that the length we send HAS to be a multiple of&n;&t;&t;&t;   4 bytes. */
id|card-&gt;tx_desc
(braket
id|desc
)braket
dot
id|control
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|desc
op_eq
id|NUMDESCRIPTORS
op_minus
l_int|1
)paren
id|card-&gt;tx_desc
(braket
id|desc
)braket
dot
id|control
op_or_assign
id|LastDescBit
suffix:semicolon
multiline_comment|/* bit 25: last descriptor of the ring */
id|card-&gt;tx_desc
(braket
id|desc
)braket
dot
id|control
op_or_assign
l_int|0xF0000000
suffix:semicolon
multiline_comment|/* 0xF0... means want interrupts*/
id|card-&gt;tx_skb
(braket
id|desc
)braket
op_assign
id|skb
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This gives the descriptor to the card */
id|card-&gt;tx_desc
(braket
id|desc
)braket
dot
id|status
op_assign
id|DescOwnedCard
suffix:semicolon
id|trigger_transmit
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|card-&gt;tx_desc
(braket
id|nextdescriptor
)braket
dot
id|status
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* next descriptor is occupied... */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|card-&gt;transmit_used
op_assign
id|nextdescriptor
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Uh oh... no free descriptor... drop the packet */
multiline_comment|/* This should not happen in theory...*/
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|trigger_transmit
c_func
(paren
id|card
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|xircom_open
r_static
r_int
id|xircom_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|xircom_private
op_star
id|xp
op_assign
(paren
r_struct
id|xircom_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Xircom cardbus adaptor found, registering as %s, using irq %i &bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|retval
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|xircom_interrupt
comma
id|SA_SHIRQ
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_cb: Unable to aquire IRQ %i, aborting.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|xircom_up
c_func
(paren
id|xp
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|xircom_close
r_static
r_int
id|xircom_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|xircom_private
op_star
id|card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|card
op_assign
id|dev-&gt;priv
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t want to send new packets */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|disable_all_interrupts
c_func
(paren
id|card
)paren
suffix:semicolon
macro_line|#if 0&t;
multiline_comment|/* We can enable this again once we send dummy packets on ifconfig ethX up */
id|deactivate_receiver
c_func
(paren
id|card
)paren
suffix:semicolon
id|deactivate_transmitter
c_func
(paren
id|card
)paren
suffix:semicolon
macro_line|#endif&t;
id|remove_descriptors
c_func
(paren
id|card
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|xircom_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|xircom_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|xircom_private
op_star
id|card
op_assign
(paren
r_struct
id|xircom_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|card-&gt;stats
suffix:semicolon
)brace
DECL|function|initialize_card
r_static
r_void
id|initialize_card
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* First: reset the card */
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR0
)paren
suffix:semicolon
id|val
op_or_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* Software reset */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR0
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* give the card some time to reset */
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR0
)paren
suffix:semicolon
id|val
op_and_assign
op_complement
l_int|0x01
suffix:semicolon
multiline_comment|/* disable Software reset */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR0
)paren
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Value 0x00 is a safe and conservative value &n;&t;&t;&t;&t;   for the PCI configuration settings */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR0
)paren
suffix:semicolon
id|disable_all_interrupts
c_func
(paren
id|card
)paren
suffix:semicolon
id|deactivate_receiver
c_func
(paren
id|card
)paren
suffix:semicolon
id|deactivate_transmitter
c_func
(paren
id|card
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;trigger_transmit causes the card to check for frames to be transmitted.&n;This is accomplished by writing to the CSR1 port. The documentation&n;claims that the act of writing is sufficient and that the value is&n;ignored; I chose zero.&n;*/
DECL|function|trigger_transmit
r_static
r_inline
r_void
id|trigger_transmit
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
id|enter
c_func
(paren
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0
comma
id|card-&gt;io_port
op_plus
id|CSR1
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;trigger_receive causes the card to check for empty frames in the&n;descriptor list in which packets can be received.&n;This is accomplished by writing to the CSR2 port. The documentation&n;claims that the act of writing is sufficient and that the value is&n;ignored; I chose zero.&n;*/
DECL|function|trigger_receive
r_static
r_inline
r_void
id|trigger_receive
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
id|enter
c_func
(paren
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0
comma
id|card-&gt;io_port
op_plus
id|CSR2
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;setup_descriptors initializes the send and receive buffers to be valid&n;descriptors and programs the addresses into the card.&n;*/
DECL|function|setup_descriptors
r_static
r_void
id|setup_descriptors
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|u32
id|address
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;rx_buffer
op_eq
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;tx_buffer
op_eq
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Receive descriptors */
id|memset
c_func
(paren
id|card-&gt;rx_desc
comma
l_int|0
comma
l_int|128
)paren
suffix:semicolon
multiline_comment|/* clear the descriptors */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMDESCRIPTORS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Rx Descr0: It&squot;s empty, let the card own it, no errors -&gt; 0x80000000 */
id|card-&gt;rx_desc
(braket
id|i
)braket
dot
id|status
op_assign
id|DescOwnedCard
suffix:semicolon
multiline_comment|/* Rx Descr1: buffer 1 is 1536 bytes, buffer 2 is 0 bytes */
id|card-&gt;rx_desc
(braket
id|i
)braket
dot
id|control
op_assign
id|MAX_PACKETSIZE
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NUMDESCRIPTORS
op_minus
l_int|1
)paren
id|card-&gt;rx_desc
(braket
id|i
)braket
dot
id|control
op_or_assign
id|LastDescBit
suffix:semicolon
multiline_comment|/* bit 25 is &quot;last descriptor&quot; */
multiline_comment|/* Rx Descr2: address of the buffer&n;&t;&t;   we store the buffer at the 2nd half of the page */
id|address
op_assign
id|card-&gt;rx_dma_handle
suffix:semicolon
id|card-&gt;rx_desc
(braket
id|i
)braket
dot
id|address1
op_assign
id|cpu_to_le32
c_func
(paren
id|address
op_plus
id|bufferoffsets
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Rx Desc3: address of 2nd buffer -&gt; 0 */
id|card-&gt;rx_desc
(braket
id|i
)braket
dot
id|address2
op_assign
l_int|0
suffix:semicolon
)brace
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Write the receive descriptor ring address to the card */
id|address
op_assign
id|card-&gt;rx_dma_handle
suffix:semicolon
id|val
op_assign
id|cpu_to_le32
c_func
(paren
id|address
)paren
suffix:semicolon
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR3
)paren
suffix:semicolon
multiline_comment|/* Receive descr list address */
multiline_comment|/* transmit descriptors */
id|memset
c_func
(paren
id|card-&gt;tx_desc
comma
l_int|0
comma
l_int|128
)paren
suffix:semicolon
multiline_comment|/* clear the descriptors */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMDESCRIPTORS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Tx Descr0: Empty, we own it, no errors -&gt; 0x00000000 */
id|card-&gt;tx_desc
(braket
id|i
)braket
dot
id|status
op_assign
id|DescOwnedDriver
suffix:semicolon
multiline_comment|/* Tx Descr1: buffer 1 is 1536 bytes, buffer 2 is 0 bytes */
id|card-&gt;tx_desc
(braket
id|i
)braket
dot
id|control
op_assign
id|MAX_PACKETSIZE
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NUMDESCRIPTORS
op_minus
l_int|1
)paren
id|card-&gt;tx_desc
(braket
id|i
)braket
dot
id|control
op_or_assign
id|LastDescBit
suffix:semicolon
multiline_comment|/* bit 25 is &quot;last descriptor&quot; */
multiline_comment|/* Tx Descr2: address of the buffer&n;&t;&t;   we store the buffer at the 2nd half of the page */
id|address
op_assign
id|card-&gt;tx_dma_handle
suffix:semicolon
id|card-&gt;tx_desc
(braket
id|i
)braket
dot
id|address1
op_assign
id|cpu_to_le32
c_func
(paren
id|address
op_plus
id|bufferoffsets
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Tx Desc3: address of 2nd buffer -&gt; 0 */
id|card-&gt;tx_desc
(braket
id|i
)braket
dot
id|address2
op_assign
l_int|0
suffix:semicolon
)brace
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wite the transmit descriptor ring to the card */
id|address
op_assign
id|card-&gt;tx_dma_handle
suffix:semicolon
id|val
op_assign
id|cpu_to_le32
c_func
(paren
id|address
)paren
suffix:semicolon
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR4
)paren
suffix:semicolon
multiline_comment|/* xmit descr list address */
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;remove_descriptors informs the card the descriptors are no longer&n;valid by setting the address in the card to 0x00.&n;*/
DECL|function|remove_descriptors
r_static
r_inline
r_void
id|remove_descriptors
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR3
)paren
suffix:semicolon
multiline_comment|/* Receive descriptor address */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR4
)paren
suffix:semicolon
multiline_comment|/* Send descriptor address */
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;link_status_changed returns 1 if the card has indicated that&n;the link status has changed. The new link status has to be read from CSR12.&n;&n;This function also clears the status-bit.&n;*/
DECL|function|link_status_changed
r_static
r_inline
r_int
r_int
id|link_status_changed
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR5
)paren
suffix:semicolon
multiline_comment|/* Status register */
r_if
c_cond
(paren
(paren
id|val
op_amp
id|LinkStatusBit
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* no change */
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* clear the event by writing a 1 to the bit in the&n;&t;   status register. */
id|val
op_assign
id|LinkStatusBit
suffix:semicolon
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR5
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;transmit_active returns 1 if the transmitter on the card is&n;in a non-stopped state.&n;*/
DECL|function|transmit_active
r_static
r_inline
r_int
id|transmit_active
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR5
)paren
suffix:semicolon
multiline_comment|/* Status register */
r_if
c_cond
(paren
(paren
id|val
op_amp
(paren
l_int|7
op_lshift
l_int|20
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* transmitter disabled */
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;receive_active returns 1 if the receiver on the card is&n;in a non-stopped state.&n;*/
DECL|function|receive_active
r_static
r_inline
r_int
r_int
id|receive_active
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR5
)paren
suffix:semicolon
multiline_comment|/* Status register */
r_if
c_cond
(paren
(paren
id|val
op_amp
(paren
l_int|7
op_lshift
l_int|17
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* receiver disabled */
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;activate_receiver enables the receiver on the card.&n;Before being allowed to active the receiver, the receiver&n;must be completely de-activated. To achieve this,&n;this code actually disables the receiver first; then it waits for the &n;receiver to become inactive, then it activates the receiver and then&n;it waits for the receiver to be active.&n;&n;must be called with the lock held and interrupts disabled.&n;*/
DECL|function|activate_receiver
r_static
r_void
id|activate_receiver
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_int
id|counter
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
multiline_comment|/* Operation mode */
multiline_comment|/* If the &quot;active&quot; bit (1) is set and the receiver is already&n;&t;   active, no need to do the expensive thing */
r_if
c_cond
(paren
(paren
id|val
op_amp
id|RxActiveBit
)paren
op_logical_and
(paren
id|receive_active
c_func
(paren
id|card
)paren
)paren
)paren
r_return
suffix:semicolon
id|val
op_assign
id|val
op_amp
op_complement
id|RxActiveBit
suffix:semicolon
multiline_comment|/* disable the receiver */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
id|counter
op_assign
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|counter
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|receive_active
c_func
(paren
id|card
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* wait a while */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|counter
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_cb: Receiver failed to deactivate&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* enable the receiver */
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
multiline_comment|/* Operation mode */
id|val
op_assign
id|val
op_or
id|RxActiveBit
suffix:semicolon
multiline_comment|/* enable the receiver */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
multiline_comment|/* now wait for the card to activate again */
id|counter
op_assign
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|counter
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|receive_active
c_func
(paren
id|card
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* wait a while */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|counter
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_cb: Receiver failed to re-activate&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;deactivate_receiver disables the receiver on the card.&n;To achieve this this code disables the receiver first; &n;then it waits for the receiver to become inactive.&n;&n;must be called with the lock held and interrupts disabled.&n;*/
DECL|function|deactivate_receiver
r_static
r_void
id|deactivate_receiver
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_int
id|counter
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
multiline_comment|/* Operation mode */
id|val
op_assign
id|val
op_amp
op_complement
id|RxActiveBit
suffix:semicolon
multiline_comment|/* disable the receiver */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
id|counter
op_assign
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|counter
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|receive_active
c_func
(paren
id|card
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* wait a while */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|counter
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_cb: Receiver failed to deactivate&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;activate_transmitter enables the transmitter on the card.&n;Before being allowed to active the transmitter, the transmitter&n;must be completely de-activated. To achieve this,&n;this code actually disables the transmitter first; then it waits for the &n;transmitter to become inactive, then it activates the transmitter and then&n;it waits for the transmitter to be active again.&n;&n;must be called with the lock held and interrupts disabled.&n;*/
DECL|function|activate_transmitter
r_static
r_void
id|activate_transmitter
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_int
id|counter
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
multiline_comment|/* Operation mode */
multiline_comment|/* If the &quot;active&quot; bit (13) is set and the receiver is already&n;&t;   active, no need to do the expensive thing */
r_if
c_cond
(paren
(paren
id|val
op_amp
id|TxActiveBit
)paren
op_logical_and
(paren
id|transmit_active
c_func
(paren
id|card
)paren
)paren
)paren
r_return
suffix:semicolon
id|val
op_assign
id|val
op_amp
op_complement
id|TxActiveBit
suffix:semicolon
multiline_comment|/* disable the transmitter */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
id|counter
op_assign
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|counter
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|transmit_active
c_func
(paren
id|card
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* wait a while */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|counter
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_cb: Transmitter failed to deactivate&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* enable the transmitter */
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
multiline_comment|/* Operation mode */
id|val
op_assign
id|val
op_or
id|TxActiveBit
suffix:semicolon
multiline_comment|/* enable the transmitter */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
multiline_comment|/* now wait for the card to activate again */
id|counter
op_assign
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|counter
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|transmit_active
c_func
(paren
id|card
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* wait a while */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|counter
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_cb: Transmitter failed to re-activate&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;deactivate_transmitter disables the transmitter on the card.&n;To achieve this this code disables the transmitter first; &n;then it waits for the transmitter to become inactive.&n;&n;must be called with the lock held and interrupts disabled.&n;*/
DECL|function|deactivate_transmitter
r_static
r_void
id|deactivate_transmitter
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_int
id|counter
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
multiline_comment|/* Operation mode */
id|val
op_assign
id|val
op_amp
op_complement
id|TxActiveBit
suffix:semicolon
multiline_comment|/* disable the transmitter */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
id|counter
op_assign
l_int|20
suffix:semicolon
r_while
c_loop
(paren
id|counter
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|transmit_active
c_func
(paren
id|card
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* wait a while */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|counter
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_cb: Transmitter failed to deactivate&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;enable_transmit_interrupt enables the transmit interrupt&n;&n;must be called with the lock held and interrupts disabled.&n;*/
DECL|function|enable_transmit_interrupt
r_static
r_void
id|enable_transmit_interrupt
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR7
)paren
suffix:semicolon
multiline_comment|/* Interrupt enable register */
id|val
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* enable the transmit interrupt */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR7
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;enable_receive_interrupt enables the receive interrupt&n;&n;must be called with the lock held and interrupts disabled.&n;*/
DECL|function|enable_receive_interrupt
r_static
r_void
id|enable_receive_interrupt
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR7
)paren
suffix:semicolon
multiline_comment|/* Interrupt enable register */
id|val
op_assign
id|val
op_or
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
multiline_comment|/* enable the receive interrupt */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR7
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;enable_link_interrupt enables the link status change interrupt&n;&n;must be called with the lock held and interrupts disabled.&n;*/
DECL|function|enable_link_interrupt
r_static
r_void
id|enable_link_interrupt
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR7
)paren
suffix:semicolon
multiline_comment|/* Interrupt enable register */
id|val
op_assign
id|val
op_or
id|LinkStatusBit
suffix:semicolon
multiline_comment|/* enable the link status chage interrupt */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR7
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;disable_all_interrupts disables all interrupts&n;&n;must be called with the lock held and interrupts disabled.&n;*/
DECL|function|disable_all_interrupts
r_static
r_void
id|disable_all_interrupts
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* disable all interrupts */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR7
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;enable_common_interrupts enables several weird interrupts&n;&n;must be called with the lock held and interrupts disabled.&n;*/
DECL|function|enable_common_interrupts
r_static
r_void
id|enable_common_interrupts
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR7
)paren
suffix:semicolon
multiline_comment|/* Interrupt enable register */
id|val
op_or_assign
(paren
l_int|1
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Normal Interrupt Summary */
id|val
op_or_assign
(paren
l_int|1
op_lshift
l_int|15
)paren
suffix:semicolon
multiline_comment|/* Abnormal Interrupt Summary */
id|val
op_or_assign
(paren
l_int|1
op_lshift
l_int|13
)paren
suffix:semicolon
multiline_comment|/* Fatal bus error */
id|val
op_or_assign
(paren
l_int|1
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Receive Process Stopped */
id|val
op_or_assign
(paren
l_int|1
op_lshift
l_int|7
)paren
suffix:semicolon
multiline_comment|/* Receive Buffer Unavailable */
id|val
op_or_assign
(paren
l_int|1
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Transmit Underflow */
id|val
op_or_assign
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Transmit Buffer Unavailable */
id|val
op_or_assign
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Transmit Process Stopped */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR7
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;enable_promisc starts promisc mode&n;&n;must be called with the lock held and interrupts disabled.&n;*/
DECL|function|enable_promisc
r_static
r_inline
r_void
id|enable_promisc
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
id|val
op_assign
id|val
op_or
id|PromiscBit
suffix:semicolon
multiline_comment|/* Bit 6 */
id|outl
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;xircom_cb: enabling promiscuous mode &bslash;n&quot;
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;link_status() checks the the links status and will return 0 for no link, &n;10 for 10mbit link and 100 for.. guess what.&n;&n;Must be called in locked state with interrupts disabled&n;*/
DECL|function|link_status
r_static
r_inline
r_int
r_int
id|link_status
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|inb
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR12
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|val
op_amp
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
)paren
multiline_comment|/* bit 2 is 0 for 10mbit link, 1 for not an 10mbit link */
r_return
l_int|10
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|val
op_amp
(paren
l_int|1
op_lshift
l_int|1
)paren
)paren
)paren
multiline_comment|/* bit 1 is 0 for 100mbit link, 1 for not an 100mbit link */
r_return
l_int|100
suffix:semicolon
multiline_comment|/* If we get here -&gt; no link at all */
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;&n;set_half_duplex() sets the card to half duplex mode. In order to do this,&n;set_half_duplex() has to deactivate the transmitter and receiver first. It&n;will re-enable the transmitter and receiver if those were active from the&n;beginning.&n;&n;Update: the above is not enough. It doesn&squot;t touch the MII, in fact it ensures&n;the main chipset and the MII are never in sync if a full-duplex connection&n;is negotiated. The proper fix is to tell the MII to force a half-duplex&n;connection. -Ion&n;&n;Must be called in locked state&n;*/
DECL|function|set_half_duplex
r_static
r_void
id|set_half_duplex
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_int
id|rx
comma
id|tx
comma
id|tmp
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|rx
op_assign
id|receive_active
c_func
(paren
id|card
)paren
suffix:semicolon
id|tx
op_assign
id|transmit_active
c_func
(paren
id|card
)paren
suffix:semicolon
id|deactivate_transmitter
c_func
(paren
id|card
)paren
suffix:semicolon
id|deactivate_receiver
c_func
(paren
id|card
)paren
suffix:semicolon
id|val
op_assign
id|inb
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
id|val
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|9
)paren
suffix:semicolon
id|outb
c_func
(paren
id|val
comma
id|card-&gt;io_port
op_plus
id|CSR6
)paren
suffix:semicolon
multiline_comment|/* tell the MII not to advertise 10/100FDX */
id|tmp
op_assign
id|mdio_read
c_func
(paren
id|card
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;xircom_cb: capabilities changed from %#x to %#x&bslash;n&quot;
comma
id|tmp
comma
id|tmp
op_amp
op_complement
l_int|0x140
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
l_int|0x140
suffix:semicolon
id|mdio_write
c_func
(paren
id|card
comma
l_int|0
comma
l_int|4
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* restart autonegotiation */
id|tmp
op_assign
id|mdio_read
c_func
(paren
id|card
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|mdio_write
c_func
(paren
id|card
comma
l_int|0
comma
l_int|0
comma
id|tmp
op_or
l_int|0x1200
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rx
)paren
id|activate_receiver
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tx
)paren
id|activate_transmitter
c_func
(paren
id|card
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  read_mac_address() reads the MAC address from the NIC and stores it in the &quot;dev&quot; structure.&n; &n;  This function will take the spinlock itself and can, as a result, not be called with the lock helt.&n; */
DECL|function|read_mac_address
r_static
r_void
id|read_mac_address
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_char
id|j
comma
id|tuple
comma
id|link
comma
id|data_id
comma
id|data_count
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|1
op_lshift
l_int|12
comma
id|card-&gt;io_port
op_plus
id|CSR9
)paren
suffix:semicolon
multiline_comment|/* enable boot rom access */
r_for
c_loop
(paren
id|i
op_assign
l_int|0x100
suffix:semicolon
id|i
OL
l_int|0x1f7
suffix:semicolon
id|i
op_add_assign
id|link
op_plus
l_int|2
)paren
(brace
id|outl
c_func
(paren
id|i
comma
id|card-&gt;io_port
op_plus
id|CSR10
)paren
suffix:semicolon
id|tuple
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR9
)paren
op_amp
l_int|0xff
suffix:semicolon
id|outl
c_func
(paren
id|i
op_plus
l_int|1
comma
id|card-&gt;io_port
op_plus
id|CSR10
)paren
suffix:semicolon
id|link
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR9
)paren
op_amp
l_int|0xff
suffix:semicolon
id|outl
c_func
(paren
id|i
op_plus
l_int|2
comma
id|card-&gt;io_port
op_plus
id|CSR10
)paren
suffix:semicolon
id|data_id
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR9
)paren
op_amp
l_int|0xff
suffix:semicolon
id|outl
c_func
(paren
id|i
op_plus
l_int|3
comma
id|card-&gt;io_port
op_plus
id|CSR10
)paren
suffix:semicolon
id|data_count
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR9
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tuple
op_eq
l_int|0x22
)paren
op_logical_and
(paren
id|data_id
op_eq
l_int|0x04
)paren
op_logical_and
(paren
id|data_count
op_eq
l_int|0x06
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * This is it.  We have the data we want.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|6
suffix:semicolon
id|j
op_increment
)paren
(brace
id|outl
c_func
(paren
id|i
op_plus
id|j
op_plus
l_int|4
comma
id|card-&gt;io_port
op_plus
id|CSR10
)paren
suffix:semicolon
id|card-&gt;dev-&gt;dev_addr
(braket
id|j
)braket
op_assign
id|inl
c_func
(paren
id|card-&gt;io_port
op_plus
id|CSR9
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|link
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c%2.2X&quot;
comma
id|i
ques
c_cond
l_char|&squot;:&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|card-&gt;dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* MII transceiver control section.&n;   Read and write the MII registers using software-generated serial&n;   MDIO protocol.  See the MII specifications or DP83840A data sheet&n;   for details. */
multiline_comment|/* The maximum data clock rate is 2.5 Mhz.  The minimum timing is usually&n;   met by back-to-back PCI I/O cycles, but we insert a delay to avoid&n;   &quot;overclocking&quot; issues or future 66Mhz PCI. */
DECL|macro|mdio_delay
mdefine_line|#define mdio_delay() inl(mdio_addr)
multiline_comment|/* Read and write the MII registers using software-generated serial&n;   MDIO protocol.  It is just different enough from the EEPROM protocol&n;   to not share code.  The maxium data clock rate is 2.5 Mhz. */
DECL|macro|MDIO_SHIFT_CLK
mdefine_line|#define MDIO_SHIFT_CLK&t;0x10000
DECL|macro|MDIO_DATA_WRITE0
mdefine_line|#define MDIO_DATA_WRITE0 0x00000
DECL|macro|MDIO_DATA_WRITE1
mdefine_line|#define MDIO_DATA_WRITE1 0x20000
DECL|macro|MDIO_ENB
mdefine_line|#define MDIO_ENB&t;0x00000&t;&t;/* Ignore the 0x02000 databook setting. */
DECL|macro|MDIO_ENB_IN
mdefine_line|#define MDIO_ENB_IN&t;0x40000
DECL|macro|MDIO_DATA_READ
mdefine_line|#define MDIO_DATA_READ&t;0x80000
DECL|function|mdio_read
r_static
r_int
id|mdio_read
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
comma
r_int
id|phy_id
comma
r_int
id|location
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|read_cmd
op_assign
(paren
l_int|0xf6
op_lshift
l_int|10
)paren
op_or
(paren
id|phy_id
op_lshift
l_int|5
)paren
op_or
id|location
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|mdio_addr
op_assign
id|card-&gt;io_port
op_plus
id|CSR9
suffix:semicolon
multiline_comment|/* Establish sync by sending at least 32 logic ones. */
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outl
c_func
(paren
id|MDIO_ENB
op_or
id|MDIO_DATA_WRITE1
comma
id|mdio_addr
)paren
suffix:semicolon
id|mdio_delay
c_func
(paren
)paren
suffix:semicolon
id|outl
c_func
(paren
id|MDIO_ENB
op_or
id|MDIO_DATA_WRITE1
op_or
id|MDIO_SHIFT_CLK
comma
id|mdio_addr
)paren
suffix:semicolon
id|mdio_delay
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Shift the read command bits out. */
r_for
c_loop
(paren
id|i
op_assign
l_int|15
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|dataval
op_assign
(paren
id|read_cmd
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
ques
c_cond
id|MDIO_DATA_WRITE1
suffix:colon
l_int|0
suffix:semicolon
id|outl
c_func
(paren
id|MDIO_ENB
op_or
id|dataval
comma
id|mdio_addr
)paren
suffix:semicolon
id|mdio_delay
c_func
(paren
)paren
suffix:semicolon
id|outl
c_func
(paren
id|MDIO_ENB
op_or
id|dataval
op_or
id|MDIO_SHIFT_CLK
comma
id|mdio_addr
)paren
suffix:semicolon
id|mdio_delay
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the two transition, 16 data, and wire-idle bits. */
r_for
c_loop
(paren
id|i
op_assign
l_int|19
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outl
c_func
(paren
id|MDIO_ENB_IN
comma
id|mdio_addr
)paren
suffix:semicolon
id|mdio_delay
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|retval
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|inl
c_func
(paren
id|mdio_addr
)paren
op_amp
id|MDIO_DATA_READ
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|outl
c_func
(paren
id|MDIO_ENB_IN
op_or
id|MDIO_SHIFT_CLK
comma
id|mdio_addr
)paren
suffix:semicolon
id|mdio_delay
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
(paren
id|retval
op_rshift
l_int|1
)paren
op_amp
l_int|0xffff
suffix:semicolon
)brace
DECL|function|mdio_write
r_static
r_void
id|mdio_write
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
comma
r_int
id|phy_id
comma
r_int
id|location
comma
r_int
id|value
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|cmd
op_assign
(paren
l_int|0x5002
op_lshift
l_int|16
)paren
op_or
(paren
id|phy_id
op_lshift
l_int|23
)paren
op_or
(paren
id|location
op_lshift
l_int|18
)paren
op_or
id|value
suffix:semicolon
r_int
id|mdio_addr
op_assign
id|card-&gt;io_port
op_plus
id|CSR9
suffix:semicolon
multiline_comment|/* Establish sync by sending 32 logic ones. */
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outl
c_func
(paren
id|MDIO_ENB
op_or
id|MDIO_DATA_WRITE1
comma
id|mdio_addr
)paren
suffix:semicolon
id|mdio_delay
c_func
(paren
)paren
suffix:semicolon
id|outl
c_func
(paren
id|MDIO_ENB
op_or
id|MDIO_DATA_WRITE1
op_or
id|MDIO_SHIFT_CLK
comma
id|mdio_addr
)paren
suffix:semicolon
id|mdio_delay
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Shift the command bits out. */
r_for
c_loop
(paren
id|i
op_assign
l_int|31
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|dataval
op_assign
(paren
id|cmd
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
ques
c_cond
id|MDIO_DATA_WRITE1
suffix:colon
l_int|0
suffix:semicolon
id|outl
c_func
(paren
id|MDIO_ENB
op_or
id|dataval
comma
id|mdio_addr
)paren
suffix:semicolon
id|mdio_delay
c_func
(paren
)paren
suffix:semicolon
id|outl
c_func
(paren
id|MDIO_ENB
op_or
id|dataval
op_or
id|MDIO_SHIFT_CLK
comma
id|mdio_addr
)paren
suffix:semicolon
id|mdio_delay
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear out extra bits. */
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outl
c_func
(paren
id|MDIO_ENB_IN
comma
id|mdio_addr
)paren
suffix:semicolon
id|mdio_delay
c_func
(paren
)paren
suffix:semicolon
id|outl
c_func
(paren
id|MDIO_ENB_IN
op_or
id|MDIO_SHIFT_CLK
comma
id|mdio_addr
)paren
suffix:semicolon
id|mdio_delay
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; tranceiver_voodoo() enables the external UTP plug thingy.&n; it&squot;s called voodoo as I stole this code and cannot cross-reference&n; it with the specification.&n; */
DECL|function|tranceiver_voodoo
r_static
r_void
id|tranceiver_voodoo
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|u32
id|tmp32
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* disable all powermanagement */
id|pci_read_config_dword
c_func
(paren
id|card-&gt;pdev
comma
id|PCI_POWERMGMT
comma
op_amp
id|tmp32
)paren
suffix:semicolon
id|tmp32
op_and_assign
op_complement
id|PowerMgmtBits
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|card-&gt;pdev
comma
id|PCI_POWERMGMT
comma
id|tmp32
)paren
suffix:semicolon
id|setup_descriptors
c_func
(paren
id|card
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0x0008
comma
id|card-&gt;io_port
op_plus
id|CSR15
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0xa8050000
comma
id|card-&gt;io_port
op_plus
id|CSR15
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0xa00f0000
comma
id|card-&gt;io_port
op_plus
id|CSR15
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|card-&gt;dev
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|xircom_up
r_static
r_void
id|xircom_up
c_func
(paren
r_struct
id|xircom_private
op_star
id|card
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u32
id|tmp32
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* disable all powermanagement */
id|pci_read_config_dword
c_func
(paren
id|card-&gt;pdev
comma
id|PCI_POWERMGMT
comma
op_amp
id|tmp32
)paren
suffix:semicolon
id|tmp32
op_and_assign
op_complement
id|PowerMgmtBits
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|card-&gt;pdev
comma
id|PCI_POWERMGMT
comma
id|tmp32
)paren
suffix:semicolon
id|setup_descriptors
c_func
(paren
id|card
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|enable_link_interrupt
c_func
(paren
id|card
)paren
suffix:semicolon
id|enable_transmit_interrupt
c_func
(paren
id|card
)paren
suffix:semicolon
id|enable_receive_interrupt
c_func
(paren
id|card
)paren
suffix:semicolon
id|enable_common_interrupts
c_func
(paren
id|card
)paren
suffix:semicolon
id|enable_promisc
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* The card can have received packets already, read them away now */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMDESCRIPTORS
suffix:semicolon
id|i
op_increment
)paren
id|investigate_rx_descriptor
c_func
(paren
id|card-&gt;dev
comma
id|card
comma
id|i
comma
id|bufferoffsets
(braket
id|i
)braket
)paren
suffix:semicolon
id|set_half_duplex
c_func
(paren
id|card
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|trigger_receive
c_func
(paren
id|card
)paren
suffix:semicolon
id|trigger_transmit
c_func
(paren
id|card
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|card-&gt;dev
)paren
suffix:semicolon
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|investigate_rx_descriptor
r_static
r_void
id|investigate_rx_descriptor
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|xircom_private
op_star
id|card
comma
r_int
id|descnr
comma
r_int
r_int
id|bufferoffset
)paren
(brace
r_int
id|status
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|card-&gt;rx_desc
(braket
id|descnr
)braket
dot
id|status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
OG
l_int|0
)paren
)paren
(brace
multiline_comment|/* packet received */
multiline_comment|/* TODO: discard error packets */
r_int
id|pkt_len
op_assign
(paren
(paren
id|status
op_rshift
l_int|16
)paren
op_amp
l_int|0x7ff
)paren
op_minus
l_int|4
suffix:semicolon
multiline_comment|/* minus 4, we don&squot;t want the CRC */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|pkt_len
OG
l_int|1518
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;xircom_cb: Packet length %i is bogus &bslash;n&quot;
comma
id|pkt_len
)paren
suffix:semicolon
id|pkt_len
op_assign
l_int|1518
suffix:semicolon
)brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|card-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
id|eth_copy_and_sum
c_func
(paren
id|skb
comma
op_amp
id|card-&gt;rx_buffer
(braket
id|bufferoffset
)braket
comma
id|pkt_len
comma
l_int|0
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|card-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|card-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* give the buffer back to the card */
id|card-&gt;rx_desc
(braket
id|descnr
)braket
dot
id|status
op_assign
id|DescOwnedCard
suffix:semicolon
id|trigger_receive
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
id|leave
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns 1 if the descriptor is free or became free */
DECL|function|investigate_tx_descriptor
r_static
r_int
r_int
id|investigate_tx_descriptor
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|xircom_private
op_star
id|card
comma
r_int
r_int
id|descnr
comma
r_int
r_int
id|bufferoffset
)paren
(brace
r_int
id|status
comma
id|retval
op_assign
l_int|0
suffix:semicolon
id|enter
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|card-&gt;tx_desc
(braket
id|descnr
)braket
dot
id|status
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|DescOwnedDriver
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#if 0&t;&t;
r_if
c_cond
(paren
id|status
op_amp
l_int|0x8000
)paren
(brace
multiline_comment|/* Major error */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Major transmit error status %x &bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|card-&gt;tx_desc
(braket
id|descnr
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|status
OG
l_int|0
)paren
(brace
multiline_comment|/* bit 31 is 0 when done */
id|card-&gt;stats.tx_packets
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;tx_skb
(braket
id|descnr
)braket
op_ne
l_int|NULL
)paren
(brace
id|card-&gt;stats.tx_bytes
op_add_assign
id|card-&gt;tx_skb
(braket
id|descnr
)braket
op_member_access_from_pointer
id|len
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|card-&gt;tx_skb
(braket
id|descnr
)braket
)paren
suffix:semicolon
)brace
id|card-&gt;tx_skb
(braket
id|descnr
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Bit 8 in the status field is 1 if there was a collision */
r_if
c_cond
(paren
id|status
op_amp
id|CollisionBit
)paren
id|card-&gt;stats.collisions
op_increment
suffix:semicolon
id|card-&gt;tx_desc
(braket
id|descnr
)braket
dot
id|status
op_assign
id|DescOwnedDriver
suffix:semicolon
multiline_comment|/* descriptor is free again */
id|retval
op_assign
l_int|1
suffix:semicolon
)brace
id|leave
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|xircom_init
r_static
r_int
id|__init
id|xircom_init
c_func
(paren
r_void
)paren
(brace
id|pci_register_driver
c_func
(paren
op_amp
id|xircom_ops
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|xircom_exit
r_static
r_void
id|__exit
id|xircom_exit
c_func
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|xircom_ops
)paren
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|xircom_init
)paren
id|module_exit
c_func
(paren
id|xircom_exit
)paren
eof
