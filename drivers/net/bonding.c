multiline_comment|/*&n; * originally based on the dummy device.&n; *&n; * Copyright 1999, Thomas Davis, tadavis@lbl.gov.  &n; * Licensed under the GPL. Based on dummy.c, and eql.c devices.&n; *&n; * bonding.c: an Ethernet Bonding driver&n; *&n; * This is useful to talk to a Cisco EtherChannel compatible equipment:&n; *&t;Cisco 5500&n; *&t;Sun Trunking (Solaris)&n; *&t;Alteon AceDirector Trunks&n; *&t;Linux Bonding&n; *&t;and probably many L2 switches ...&n; *&n; * How it works:&n; *    ifconfig bond0 ipaddress netmask up&n; *      will setup a network device, with an ip address.  No mac address &n; *&t;will be assigned at this time.  The hw mac address will come from &n; *&t;the first slave bonded to the channel.  All slaves will then use &n; *&t;this hw mac address.&n; *&n; *    ifconfig bond0 down&n; *         will release all slaves, marking them as down.&n; *&n; *    ifenslave bond0 eth0&n; *&t;will attach eth0 to bond0 as a slave.  eth0 hw mac address will either&n; *&t;a: be used as initial mac address&n; *&t;b: if a hw mac address already is there, eth0&squot;s hw mac address &n; *&t;   will then be set from bond0.&n; *&n; * v0.1 - first working version.&n; * v0.2 - changed stats to be calculated by summing slaves stats.&n; *&n; * Changes:&n; * Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;&n; * - fix leaks on failure at bond_init&n; *&n; * 2000/09/30 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - added trivial code to release a slave device.&n; *     - fixed security bug (CAP_NET_ADMIN not checked)&n; *     - implemented MII link monitoring to disable dead links :&n; *       All MII capable slaves are checked every &lt;miimon&gt; milliseconds&n; *       (100 ms seems good). This value can be changed by passing it to&n; *       insmod. A value of zero disables the monitoring (default).&n; *     - fixed an infinite loop in bond_xmit_roundrobin() when there&squot;s no&n; *       good slave.&n; *     - made the code hopefully SMP safe&n; *&n; * 2000/10/03 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - optimized slave lists based on relevant suggestions from Thomas Davis&n; *     - implemented active-backup method to obtain HA with two switches:&n; *       stay as long as possible on the same active interface, while we&n; *       also monitor the backup one (MII link status) because we want to know&n; *       if we are able to switch at any time. ( pass &quot;mode=1&quot; to insmod )&n; *     - lots of stress testings because we need it to be more robust than the&n; *       wires ! :-&gt;&n; *&n; * 2000/10/09 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - added up and down delays after link state change.&n; *     - optimized the slaves chaining so that when we run forward, we never&n; *       repass through the bond itself, but we can find it by searching&n; *       backwards. Renders the deletion more difficult, but accelerates the&n; *       scan.&n; *     - smarter enslaving and releasing.&n; *     - finer and more robust SMP locking&n; *&n; * 2000/10/17 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - fixed two potential SMP race conditions&n; *&n; * 2000/10/18 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - small fixes to the monitoring FSM in case of zero delays&n; * 2000/11/01 - Willy Tarreau &lt;willy at meta-x.org&gt;&n; *     - fixed first slave not automatically used in trunk mode.&n; * 2000/11/10 : spelling of &quot;EtherChannel&quot; corrected.&n; * 2000/11/13 : fixed a race condition in case of concurrent accesses to ioctl().&n; * 2000/12/16 : fixed improper usage of rtnl_exlock_nowait().&n; *&n; * 2001/1/3 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - The bonding driver now simulates MII status monitoring, just like&n; *       a normal network device.  It will show that the link is down iff&n; *       every slave in the bond shows that their links are down.  If at least&n; *       one slave is up, the bond&squot;s MII status will appear as up.&n; *&n; * 2001/2/7 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Applications can now query the bond from user space to get&n; *       information which may be useful.  They do this by calling&n; *       the BOND_INFO_QUERY ioctl.  Once the app knows how many slaves&n; *       are in the bond, it can call the BOND_SLAVE_INFO_QUERY ioctl to&n; *       get slave specific information (# link failures, etc).  See&n; *       &lt;linux/if_bonding.h&gt; for more details.  The structs of interest&n; *       are ifbond and ifslave.&n; *&n; * 2001/4/5 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Ported to 2.4 Kernel&n; * &n; * 2001/5/2 - Jeffrey E. Mast &lt;jeff at mastfamily dot com&gt;&n; *     - When a device is detached from a bond, the slave device is no longer&n; *       left thinking that is has a master.&n; *&n; * 2001/5/16 - Jeffrey E. Mast &lt;jeff at mastfamily dot com&gt;&n; *     - memset did not appropriately initialized the bond rw_locks. Used &n; *       rwlock_init to initialize to unlocked state to prevent deadlock when &n; *       first attempting a lock&n; *     - Called SET_MODULE_OWNER for bond device&n; *&n; * 2001/5/17 - Tim Anderson &lt;tsa at mvista.com&gt;&n; *     - 2 paths for releasing for slave release; 1 through ioctl&n; *       and 2) through close. Both paths need to release the same way.&n; *     - the free slave in bond release is changing slave status before&n; *       the free. The netdev_set_master() is intended to change slave state&n; *       so it should not be done as part of the release process.&n; *     - Simple rule for slave state at release: only the active in A/B and&n; *       only one in the trunked case.&n; *&n; * 2001/6/01 - Tim Anderson &lt;tsa at mvista.com&gt;&n; *     - Now call dev_close when releasing a slave so it doesn&squot;t screw up&n; *       out routing table.&n; *&n; * 2001/6/01 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Added /proc support for getting bond and slave information.&n; *       Information is in /proc/net/&lt;bond device&gt;/info. &n; *     - Changed the locking when calling bond_close to prevent deadlock.&n; *&n; * 2001/8/05 - Janice Girouard &lt;girouard at us.ibm.com&gt;&n; *     - correct problem where refcnt of slave is not incremented in bond_ioctl&n; *       so the system hangs when halting.&n; *     - correct locking problem when unable to malloc in bond_enslave.&n; *     - adding bond_xmit_xor logic.&n; *     - adding multiple bond device support.&n; *&n; * 2001/8/13 - Erik Habbinga &lt;erik_habbinga at hp dot com&gt;&n; *     - correct locking problem with rtnl_exlock_nowait&n; *&n; * 2001/8/23 - Janice Girouard &lt;girouard at us.ibm.com&gt;&n; *     - bzero initial dev_bonds, to correct oops&n; *     - convert SIOCDEVPRIVATE to new MII ioctl calls&n; *&n; * 2001/9/13 - Takao Indoh &lt;indou dot takao at jp dot fujitsu dot com&gt;&n; *     - Add the BOND_CHANGE_ACTIVE ioctl implementation&n; *&n; * 2001/9/14 - Mark Huth &lt;mhuth at mvista dot com&gt;&n; *     - Change MII_LINK_READY to not check for end of auto-negotiation,&n; *       but only for an up link.&n; *&n; * 2001/9/20 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Add the device field to bonding_t.  Previously the net_device &n; *       corresponding to a bond wasn&squot;t available from the bonding_t &n; *       structure.&n; *&n; * 2001/9/25 - Janice Girouard &lt;girouard at us.ibm.com&gt;&n; *     - add arp_monitor for active backup mode&n; *&n; * 2001/10/23 - Takao Indoh &lt;indou dot takao at jp dot fujitsu dot com&gt;&n; *     - Various memory leak fixes&n; *&n; * 2001/11/5 - Mark Huth &lt;mark dot huth at mvista dot com&gt;&n; *     - Don&squot;t take rtnl lock in bond_mii_monitor as it deadlocks under &n; *       certain hotswap conditions.  &n; *       Note:  this same change may be required in bond_arp_monitor ???&n; *     - Remove possibility of calling bond_sethwaddr with NULL slave_dev ptr &n; *     - Handle hot swap ethernet interface deregistration events to remove&n; *       kernel oops following hot swap of enslaved interface&n; *&n; * 2002/1/2 - Chad N. Tindel &lt;ctindel at ieee dot org&gt;&n; *     - Restore original slave flags at release time.&n; *&n; * 2002/02/18 - Erik Habbinga &lt;erik_habbinga at hp dot com&gt;&n; *     - bond_release(): calling kfree on our_slave after call to&n; *       bond_restore_slave_flags, not before&n; *     - bond_enslave(): saving slave flags into original_flags before&n; *       call to netdev_set_master, so the IFF_SLAVE flag doesn&squot;t end&n; *       up in original_flags&n; *&n; * 2002/04/05 - Mark Smith &lt;mark.smith at comdev dot cc&gt; and&n; *              Steve Mead &lt;steve.mead at comdev dot cc&gt;&n; *     - Port Gleb Natapov&squot;s multicast support patchs from 2.4.12&n; *       to 2.4.18 adding support for multicast.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/if_bonding.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
multiline_comment|/* monitor all links that often (in milliseconds). &lt;=0 disables monitoring */
macro_line|#ifndef BOND_LINK_MON_INTERV
DECL|macro|BOND_LINK_MON_INTERV
mdefine_line|#define BOND_LINK_MON_INTERV&t;0
macro_line|#endif
DECL|macro|MII_LINK_UP
macro_line|#undef  MII_LINK_UP
DECL|macro|MII_LINK_UP
mdefine_line|#define MII_LINK_UP&t;0x04
DECL|macro|MII_ENDOF_NWAY
macro_line|#undef  MII_ENDOF_NWAY
DECL|macro|MII_ENDOF_NWAY
mdefine_line|#define MII_ENDOF_NWAY&t;0x20
DECL|macro|MII_LINK_READY
macro_line|#undef  MII_LINK_READY
DECL|macro|MII_LINK_READY
mdefine_line|#define MII_LINK_READY&t;(MII_LINK_UP)
macro_line|#ifndef BOND_LINK_ARP_INTERV
DECL|macro|BOND_LINK_ARP_INTERV
mdefine_line|#define BOND_LINK_ARP_INTERV&t;0
macro_line|#endif
DECL|variable|arp_interval
r_static
r_int
id|arp_interval
op_assign
id|BOND_LINK_ARP_INTERV
suffix:semicolon
DECL|variable|arp_ip_target
r_static
r_char
op_star
id|arp_ip_target
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|arp_target
r_static
r_int
r_int
id|arp_target
op_assign
l_int|0
suffix:semicolon
DECL|variable|my_ip
r_static
id|u32
id|my_ip
op_assign
l_int|0
suffix:semicolon
DECL|variable|arp_target_hw_addr
r_char
op_star
id|arp_target_hw_addr
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|max_bonds
r_static
r_int
id|max_bonds
op_assign
id|BOND_DEFAULT_MAX_BONDS
suffix:semicolon
DECL|variable|miimon
r_static
r_int
id|miimon
op_assign
id|BOND_LINK_MON_INTERV
suffix:semicolon
DECL|variable|mode
r_static
r_int
id|mode
op_assign
id|BOND_MODE_ROUNDROBIN
suffix:semicolon
DECL|variable|updelay
r_static
r_int
id|updelay
op_assign
l_int|0
suffix:semicolon
DECL|variable|downdelay
r_static
r_int
id|downdelay
op_assign
l_int|0
suffix:semicolon
DECL|variable|first_pass
r_static
r_int
id|first_pass
op_assign
l_int|1
suffix:semicolon
DECL|variable|bond_cnt
r_int
id|bond_cnt
suffix:semicolon
DECL|variable|these_bonds
r_static
r_struct
id|bonding
op_star
id|these_bonds
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|dev_bonds
r_static
r_struct
id|net_device
op_star
id|dev_bonds
op_assign
l_int|NULL
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_bonds
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_bonds
comma
l_string|&quot;Max number of bonded devices&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|miimon
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|miimon
comma
l_string|&quot;Link check interval in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|mode
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|arp_interval
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|arp_interval
comma
l_string|&quot;arp interval in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|arp_ip_target
comma
l_string|&quot;1-12s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|arp_ip_target
comma
l_string|&quot;arp target in n.n.n.n form&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|mode
comma
l_string|&quot;Mode of operation : 0 for round robin, 1 for active-backup, 2 for xor&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|updelay
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|updelay
comma
l_string|&quot;Delay before considering link up, in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|downdelay
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|downdelay
comma
l_string|&quot;Delay before considering link down, in milliseconds&quot;
)paren
suffix:semicolon
r_extern
r_void
id|arp_send
c_func
(paren
r_int
id|type
comma
r_int
id|ptype
comma
id|u32
id|dest_ip
comma
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|src_ip
comma
r_int
r_char
op_star
id|dest_hw
comma
r_int
r_char
op_star
id|src_hw
comma
r_int
r_char
op_star
id|target_hw
)paren
suffix:semicolon
r_static
r_int
id|bond_xmit_roundrobin
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|bond_xmit_xor
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|bond_xmit_activebackup
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|bond_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|bond_mii_monitor
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|bond_arp_monitor
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|bond_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|bond_restore_slave_flags
c_func
(paren
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
r_static
r_void
id|bond_mc_list_destroy
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
suffix:semicolon
r_static
r_void
id|bond_mc_add
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_void
op_star
id|addr
comma
r_int
id|alen
)paren
suffix:semicolon
r_static
r_void
id|bond_mc_delete
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_void
op_star
id|addr
comma
r_int
id|alen
)paren
suffix:semicolon
r_static
r_int
id|bond_mc_list_copy
(paren
r_struct
id|dev_mc_list
op_star
id|src
comma
r_struct
id|bonding
op_star
id|dst
comma
r_int
id|gpf_flag
)paren
suffix:semicolon
r_static
r_inline
r_int
id|dmi_same
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|dmi1
comma
r_struct
id|dev_mc_list
op_star
id|dmi2
)paren
suffix:semicolon
r_static
r_void
id|bond_set_promiscuity
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_int
id|inc
)paren
suffix:semicolon
r_static
r_void
id|bond_set_allmulti
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_int
id|inc
)paren
suffix:semicolon
r_static
r_struct
id|dev_mc_list
op_star
id|bond_mc_list_find_dmi
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|dmi
comma
r_struct
id|dev_mc_list
op_star
id|mc_list
)paren
suffix:semicolon
r_static
r_void
id|bond_set_slave_inactive_flags
c_func
(paren
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
r_static
r_void
id|bond_set_slave_active_flags
c_func
(paren
id|slave_t
op_star
id|slave
)paren
suffix:semicolon
r_static
r_int
id|bond_enslave
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|net_device
op_star
id|slave
)paren
suffix:semicolon
r_static
r_int
id|bond_release
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|net_device
op_star
id|slave
)paren
suffix:semicolon
r_static
r_int
id|bond_release_all
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
suffix:semicolon
r_static
r_int
id|bond_sethwaddr
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|net_device
op_star
id|slave
)paren
suffix:semicolon
multiline_comment|/*&n; * bond_get_info is the interface into the /proc filesystem.  This is&n; * a different interface than the BOND_INFO_QUERY ioctl.  That is done&n; * through the generic networking ioctl interface, and bond_info_query&n; * is the internal function which provides that information.&n; */
r_static
r_int
id|bond_get_info
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
suffix:semicolon
multiline_comment|/* #define BONDING_DEBUG 1 */
multiline_comment|/* several macros */
DECL|macro|IS_UP
mdefine_line|#define IS_UP(dev)&t;((((dev)-&gt;flags &amp; (IFF_UP)) == (IFF_UP)) &amp;&amp; &bslash;&n;&t;&t;&t;(netif_running(dev) &amp;&amp; netif_carrier_ok(dev)))
DECL|function|bond_restore_slave_flags
r_static
r_void
id|bond_restore_slave_flags
c_func
(paren
id|slave_t
op_star
id|slave
)paren
(brace
id|slave-&gt;dev-&gt;flags
op_assign
id|slave-&gt;original_flags
suffix:semicolon
)brace
DECL|function|bond_set_slave_inactive_flags
r_static
r_void
id|bond_set_slave_inactive_flags
c_func
(paren
id|slave_t
op_star
id|slave
)paren
(brace
id|slave-&gt;state
op_assign
id|BOND_STATE_BACKUP
suffix:semicolon
id|slave-&gt;dev-&gt;flags
op_or_assign
id|IFF_NOARP
suffix:semicolon
)brace
DECL|function|bond_set_slave_active_flags
r_static
r_void
id|bond_set_slave_active_flags
c_func
(paren
id|slave_t
op_star
id|slave
)paren
(brace
id|slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
id|slave-&gt;dev-&gt;flags
op_and_assign
op_complement
id|IFF_NOARP
suffix:semicolon
)brace
multiline_comment|/* &n; * This function detaches the slave &lt;slave&gt; from the list &lt;bond&gt;.&n; * WARNING: no check is made to verify if the slave effectively&n; * belongs to &lt;bond&gt;. It returns &lt;slave&gt; in case it&squot;s needed.&n; * Nothing is freed on return, structures are just unchained.&n; * If the bond-&gt;current_slave pointer was pointing to &lt;slave&gt;,&n; * it&squot;s replaced with slave-&gt;next, or &lt;bond&gt; if not applicable.&n; */
DECL|function|bond_detach_slave
r_static
id|slave_t
op_star
id|bond_detach_slave
c_func
(paren
id|bonding_t
op_star
id|bond
comma
id|slave_t
op_star
id|slave
)paren
(brace
r_if
c_cond
(paren
(paren
id|bond
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|slave
op_eq
l_int|NULL
)paren
op_logical_or
(paren
(paren
r_void
op_star
)paren
id|bond
op_eq
(paren
r_void
op_star
)paren
id|slave
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;bond_detach_slave(): trying to detach &quot;
l_string|&quot;slave %p from bond %p&bslash;n&quot;
comma
id|bond
comma
id|slave
)paren
suffix:semicolon
r_return
id|slave
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bond-&gt;next
op_eq
id|slave
)paren
(brace
multiline_comment|/* is the slave at the head ? */
r_if
c_cond
(paren
id|bond-&gt;prev
op_eq
id|slave
)paren
(brace
multiline_comment|/* is the slave alone ? */
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond-&gt;current_slave
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* no slave anymore */
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond-&gt;prev
op_assign
id|bond-&gt;next
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* not alone */
id|bond-&gt;next
op_assign
id|slave-&gt;next
suffix:semicolon
id|slave-&gt;next-&gt;prev
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|bond-&gt;prev-&gt;next
op_assign
id|slave-&gt;next
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_eq
id|slave
)paren
(brace
id|bond-&gt;current_slave
op_assign
id|slave-&gt;next
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|slave-&gt;prev-&gt;next
op_assign
id|slave-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;prev
op_eq
id|slave
)paren
(brace
multiline_comment|/* is this slave the last one ? */
id|bond-&gt;prev
op_assign
id|slave-&gt;prev
suffix:semicolon
)brace
r_else
(brace
id|slave-&gt;next-&gt;prev
op_assign
id|slave-&gt;prev
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_eq
id|slave
)paren
(brace
id|bond-&gt;current_slave
op_assign
id|slave-&gt;next
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
r_return
id|slave
suffix:semicolon
)brace
multiline_comment|/* &n; * if &lt;dev&gt; supports MII link status reporting, check its link&n; * and report it as a bit field in a short int :&n; *   - 0x04 means link is up,&n; *   - 0x20 means end of autonegociation&n; * If the device doesn&squot;t support MII, then we only report 0x24,&n; * meaning that the link is up and running since we can&squot;t check it.&n; */
DECL|function|bond_check_dev_link
r_static
id|u16
id|bond_check_dev_link
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_static
r_int
(paren
op_star
id|ioctl
)paren
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
comma
r_int
)paren
suffix:semicolon
r_struct
id|ifreq
id|ifr
suffix:semicolon
id|u16
op_star
id|data
op_assign
(paren
id|u16
op_star
)paren
op_amp
id|ifr.ifr_data
suffix:semicolon
multiline_comment|/* data[0] automagically filled by the ioctl */
id|data
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* MII location 1 reports Link Status */
r_if
c_cond
(paren
(paren
(paren
id|ioctl
op_assign
id|dev-&gt;do_ioctl
)paren
op_ne
l_int|NULL
)paren
op_logical_and
multiline_comment|/* ioctl to access MII */
(paren
id|ioctl
c_func
(paren
id|dev
comma
op_amp
id|ifr
comma
id|SIOCGMIIPHY
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* now, data[3] contains info about link status :&n;&t;&t;   - data[3] &amp; 0x04 means link up&n;&t;&t;   - data[3] &amp; 0x20 means end of auto-negociation&n;&t;&t;*/
r_return
id|data
(braket
l_int|3
)braket
suffix:semicolon
)brace
r_else
(brace
r_return
id|MII_LINK_READY
suffix:semicolon
multiline_comment|/* spoof link up ( we can&squot;t check it) */
)brace
)brace
DECL|function|bond_check_mii_link
r_static
id|u16
id|bond_check_mii_link
c_func
(paren
id|bonding_t
op_star
id|bond
)paren
(brace
r_int
id|has_active_interface
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|read_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|has_active_interface
op_assign
(paren
id|bond-&gt;current_slave
op_ne
l_int|NULL
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
id|has_active_interface
ques
c_cond
id|MII_LINK_READY
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|bond_open
r_static
r_int
id|bond_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|timer_list
op_star
id|timer
op_assign
op_amp
(paren
(paren
r_struct
id|bonding
op_star
)paren
(paren
id|dev-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|mii_timer
suffix:semicolon
r_struct
id|timer_list
op_star
id|arp_timer
op_assign
op_amp
(paren
(paren
r_struct
id|bonding
op_star
)paren
(paren
id|dev-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|arp_timer
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|miimon
OG
l_int|0
)paren
(brace
multiline_comment|/* link check interval, in milliseconds. */
id|init_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|timer-&gt;expires
op_assign
id|jiffies
op_plus
(paren
id|miimon
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|timer-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|timer-&gt;function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|bond_mii_monitor
suffix:semicolon
id|add_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp_interval
OG
l_int|0
)paren
(brace
multiline_comment|/* arp interval, in milliseconds. */
id|init_timer
c_func
(paren
id|arp_timer
)paren
suffix:semicolon
id|arp_timer-&gt;expires
op_assign
id|jiffies
op_plus
(paren
id|arp_interval
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|arp_timer-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|arp_timer-&gt;function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|bond_arp_monitor
suffix:semicolon
id|add_timer
c_func
(paren
id|arp_timer
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_close
r_static
r_int
id|bond_close
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|miimon
OG
l_int|0
)paren
(brace
multiline_comment|/* link check interval, in milliseconds. */
id|del_timer
c_func
(paren
op_amp
id|bond-&gt;mii_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arp_interval
OG
l_int|0
)paren
(brace
multiline_comment|/* arp interval, in milliseconds. */
id|del_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* Release the bonded slaves */
id|bond_release_all
c_func
(paren
id|master
)paren
suffix:semicolon
id|bond_mc_list_destroy
(paren
id|bond
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * flush all members of flush-&gt;mc_list from device dev-&gt;mc_list&n; */
DECL|function|bond_mc_list_flush
r_static
r_void
id|bond_mc_list_flush
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device
op_star
id|flush
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
r_for
c_loop
(paren
id|dmi
op_assign
id|flush-&gt;mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
id|dev_mc_delete
c_func
(paren
id|dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Totally destroys the mc_list in bond&n; */
DECL|function|bond_mc_list_destroy
r_static
r_void
id|bond_mc_list_destroy
c_func
(paren
r_struct
id|bonding
op_star
id|bond
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
id|dmi
op_assign
id|bond-&gt;mc_list
suffix:semicolon
r_while
c_loop
(paren
id|dmi
)paren
(brace
id|bond-&gt;mc_list
op_assign
id|dmi-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|dmi
)paren
suffix:semicolon
id|dmi
op_assign
id|bond-&gt;mc_list
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Add a Multicast address to every slave in the bonding group&n; */
DECL|function|bond_mc_add
r_static
r_void
id|bond_mc_add
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_void
op_star
id|addr
comma
r_int
id|alen
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
(brace
id|dev_mc_add
c_func
(paren
id|slave-&gt;dev
comma
id|addr
comma
id|alen
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove a multicast address from every slave in the bonding group&n; */
DECL|function|bond_mc_delete
r_static
r_void
id|bond_mc_delete
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_void
op_star
id|addr
comma
r_int
id|alen
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
id|dev_mc_delete
c_func
(paren
id|slave-&gt;dev
comma
id|addr
comma
id|alen
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy all the Multicast addresses from src to the bonding device dst&n; */
DECL|function|bond_mc_list_copy
r_static
r_int
id|bond_mc_list_copy
(paren
r_struct
id|dev_mc_list
op_star
id|src
comma
r_struct
id|bonding
op_star
id|dst
comma
r_int
id|gpf_flag
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
comma
op_star
id|new_dmi
suffix:semicolon
r_for
c_loop
(paren
id|dmi
op_assign
id|src
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
id|new_dmi
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dev_mc_list
)paren
comma
id|gpf_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_dmi
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|new_dmi-&gt;next
op_assign
id|dst-&gt;mc_list
suffix:semicolon
id|dst-&gt;mc_list
op_assign
id|new_dmi
suffix:semicolon
id|new_dmi-&gt;dmi_addrlen
op_assign
id|dmi-&gt;dmi_addrlen
suffix:semicolon
id|memcpy
c_func
(paren
id|new_dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
)paren
suffix:semicolon
id|new_dmi-&gt;dmi_users
op_assign
id|dmi-&gt;dmi_users
suffix:semicolon
id|new_dmi-&gt;dmi_gusers
op_assign
id|dmi-&gt;dmi_gusers
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns 0 if dmi1 and dmi2 are the same, non-0 otherwise&n; */
DECL|function|dmi_same
r_static
r_inline
r_int
id|dmi_same
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|dmi1
comma
r_struct
id|dev_mc_list
op_star
id|dmi2
)paren
(brace
r_return
id|memcmp
c_func
(paren
id|dmi1-&gt;dmi_addr
comma
id|dmi2-&gt;dmi_addr
comma
id|dmi1-&gt;dmi_addrlen
)paren
op_eq
l_int|0
op_logical_and
id|dmi1-&gt;dmi_addrlen
op_eq
id|dmi2-&gt;dmi_addrlen
suffix:semicolon
)brace
multiline_comment|/*&n; * Push the promiscuity flag down to all slaves&n; */
DECL|function|bond_set_promiscuity
r_static
r_void
id|bond_set_promiscuity
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_int
id|inc
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
id|dev_set_promiscuity
c_func
(paren
id|slave-&gt;dev
comma
id|inc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Push the allmulti flag down to all slaves&n; */
DECL|function|bond_set_allmulti
r_static
r_void
id|bond_set_allmulti
c_func
(paren
id|bonding_t
op_star
id|bond
comma
r_int
id|inc
)paren
(brace
id|slave_t
op_star
id|slave
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
id|dev_set_allmulti
c_func
(paren
id|slave-&gt;dev
comma
id|inc
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * returns dmi entry if found, NULL otherwise &n; */
DECL|function|bond_mc_list_find_dmi
r_static
r_struct
id|dev_mc_list
op_star
id|bond_mc_list_find_dmi
c_func
(paren
r_struct
id|dev_mc_list
op_star
id|dmi
comma
r_struct
id|dev_mc_list
op_star
id|mc_list
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|idmi
suffix:semicolon
r_for
c_loop
(paren
id|idmi
op_assign
id|mc_list
suffix:semicolon
id|idmi
op_ne
l_int|NULL
suffix:semicolon
id|idmi
op_assign
id|idmi-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dmi_same
c_func
(paren
id|dmi
comma
id|idmi
)paren
)paren
(brace
r_return
id|idmi
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
id|master-&gt;priv
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Lock the private data for the master&n;&t; */
id|write_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Lock the master device so that noone trys to transmit&n;&t; * while we&squot;re changing things&n;&t; */
id|spin_lock_bh
c_func
(paren
op_amp
id|master-&gt;xmit_lock
)paren
suffix:semicolon
multiline_comment|/* set promiscuity flag to slaves */
r_if
c_cond
(paren
(paren
id|master-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
op_logical_neg
(paren
id|bond-&gt;flags
op_amp
id|IFF_PROMISC
)paren
)paren
id|bond_set_promiscuity
c_func
(paren
id|bond
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|master-&gt;flags
op_amp
id|IFF_PROMISC
)paren
op_logical_and
(paren
id|bond-&gt;flags
op_amp
id|IFF_PROMISC
)paren
)paren
id|bond_set_promiscuity
c_func
(paren
id|bond
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* set allmulti flag to slaves */
r_if
c_cond
(paren
(paren
id|master-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_and
op_logical_neg
(paren
id|bond-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
id|bond_set_allmulti
c_func
(paren
id|bond
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|master-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_and
(paren
id|bond-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
id|bond_set_allmulti
c_func
(paren
id|bond
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|bond-&gt;flags
op_assign
id|master-&gt;flags
suffix:semicolon
multiline_comment|/* looking for addresses to add to slaves&squot; mc list */
r_for
c_loop
(paren
id|dmi
op_assign
id|master-&gt;mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|bond_mc_list_find_dmi
c_func
(paren
id|dmi
comma
id|bond-&gt;mc_list
)paren
op_eq
l_int|NULL
)paren
id|bond_mc_add
c_func
(paren
id|bond
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
)paren
suffix:semicolon
)brace
multiline_comment|/* looking for addresses to delete from slaves&squot; list */
r_for
c_loop
(paren
id|dmi
op_assign
id|bond-&gt;mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|bond_mc_list_find_dmi
c_func
(paren
id|dmi
comma
id|master-&gt;mc_list
)paren
op_eq
l_int|NULL
)paren
id|bond_mc_delete
c_func
(paren
id|bond
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
)paren
suffix:semicolon
)brace
multiline_comment|/* save master&squot;s multicast list */
id|bond_mc_list_destroy
(paren
id|bond
)paren
suffix:semicolon
id|bond_mc_list_copy
(paren
id|master-&gt;mc_list
comma
id|bond
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|master-&gt;xmit_lock
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function counts the the number of attached &n; * slaves for use by bond_xmit_xor.&n; */
DECL|function|update_slave_cnt
r_static
r_void
id|update_slave_cnt
c_func
(paren
id|bonding_t
op_star
id|bond
)paren
(brace
id|slave_t
op_star
id|slave
op_assign
l_int|NULL
suffix:semicolon
id|bond-&gt;slave_cnt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
(brace
id|bond-&gt;slave_cnt
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* enslave device &lt;slave&gt; to bond device &lt;master&gt; */
DECL|function|bond_enslave
r_static
r_int
id|bond_enslave
c_func
(paren
r_struct
id|net_device
op_star
id|master_dev
comma
r_struct
id|net_device
op_star
id|slave_dev
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
l_int|NULL
suffix:semicolon
id|slave_t
op_star
id|new_slave
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_int
id|ndx
op_assign
l_int|0
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
r_if
c_cond
(paren
id|master_dev
op_eq
l_int|NULL
op_logical_or
id|slave_dev
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master_dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|slave_dev-&gt;do_ioctl
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Warning : no link monitoring support for %s&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
)brace
id|write_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* not running. */
r_if
c_cond
(paren
(paren
id|slave_dev-&gt;flags
op_amp
id|IFF_UP
)paren
op_ne
id|IFF_UP
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Error, slave_dev is not running&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* already enslaved */
r_if
c_cond
(paren
id|master_dev-&gt;flags
op_amp
id|IFF_SLAVE
op_logical_or
id|slave_dev-&gt;flags
op_amp
id|IFF_SLAVE
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Error, Device was already enslaved&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|new_slave
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|slave_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|new_slave
comma
l_int|0
comma
r_sizeof
(paren
id|slave_t
)paren
)paren
suffix:semicolon
multiline_comment|/* save flags before call to netdev_set_master */
id|new_slave-&gt;original_flags
op_assign
id|slave_dev-&gt;flags
suffix:semicolon
id|err
op_assign
id|netdev_set_master
c_func
(paren
id|slave_dev
comma
id|master_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Error %d calling netdev_set_master&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
macro_line|#endif
id|kfree
c_func
(paren
id|new_slave
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|new_slave-&gt;dev
op_assign
id|slave_dev
suffix:semicolon
multiline_comment|/* set promiscuity level to new slave */
r_if
c_cond
(paren
id|master_dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
id|dev_set_promiscuity
c_func
(paren
id|slave_dev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* set allmulti level to new slave */
r_if
c_cond
(paren
id|master_dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
id|dev_set_allmulti
c_func
(paren
id|slave_dev
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* upload master&squot;s mc_list to new slave */
r_for
c_loop
(paren
id|dmi
op_assign
id|master_dev-&gt;mc_list
suffix:semicolon
id|dmi
op_ne
l_int|NULL
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
)paren
id|dev_mc_add
(paren
id|slave_dev
comma
id|dmi-&gt;dmi_addr
comma
id|dmi-&gt;dmi_addrlen
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * queue to the end of the slaves list, make the first element its&n;&t; * successor, the last one its predecessor, and make it the bond&squot;s&n;&t; * predecessor. &n;&t; *&n;&t; * Just to clarify, so future bonding driver hackers don&squot;t go through&n;&t; * the same confusion stage I did trying to figure this out, the&n;&t; * slaves are stored in a double linked circular list, sortof.&n;&t; * In the -&gt;next direction, the last slave points to the first slave,&n;&t; * bypassing bond; only the slaves are in the -&gt;next direction.&n;&t; * In the -&gt;prev direction, however, the first slave points to bond&n;&t; * and bond points to the last slave.&n;&t; *&n;&t; * It looks like a circle with a little bubble hanging off one side&n;&t; * in the -&gt;prev direction only.&n;&t; *&n;&t; * When going through the list once, its best to start at bond-&gt;prev&n;&t; * and go in the -&gt;prev direction, testing for bond.  Doing this&n;&t; * in the -&gt;next direction doesn&squot;t work.  Trust me, I know this now.&n;&t; * :)  -mts 2002.03.14&n;&t; */
id|new_slave-&gt;prev
op_assign
id|bond-&gt;prev
suffix:semicolon
id|new_slave-&gt;prev-&gt;next
op_assign
id|new_slave
suffix:semicolon
id|bond-&gt;prev
op_assign
id|new_slave
suffix:semicolon
id|new_slave-&gt;next
op_assign
id|bond-&gt;next
suffix:semicolon
id|new_slave-&gt;delay
op_assign
l_int|0
suffix:semicolon
id|new_slave-&gt;link_failure_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check for initial state */
r_if
c_cond
(paren
(paren
id|miimon
op_le
l_int|0
)paren
op_logical_or
(paren
(paren
id|bond_check_dev_link
c_func
(paren
id|slave_dev
)paren
op_amp
id|MII_LINK_READY
)paren
op_eq
id|MII_LINK_READY
)paren
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Initial state of slave_dev is BOND_LINK_UP&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|new_slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Initial state of slave_dev is BOND_LINK_DOWN&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|new_slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
)brace
multiline_comment|/* if we&squot;re in active-backup mode, we need one and only one active&n;&t; * interface. The backup interfaces will have their NOARP flag set&n;&t; * because we need them to be completely deaf and not to respond to&n;&t; * any ARP request on the network to avoid fooling a switch. Thus,&n;&t; * since we guarantee that current_slave always point to the last&n;&t; * usable interface, we just have to verify this interface&squot;s flag.&n;&t; */
r_if
c_cond
(paren
id|mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|bond-&gt;current_slave
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|bond-&gt;current_slave-&gt;dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
)paren
op_logical_and
(paren
id|new_slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;This is the first active slave&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* first slave or no active slave yet, and this link&n;&t;&t;&t;   is OK, so make this interface the active one */
id|bond-&gt;current_slave
op_assign
id|new_slave
suffix:semicolon
id|bond_set_slave_active_flags
c_func
(paren
id|new_slave
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;This is just a backup slave&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|bond_set_slave_inactive_flags
c_func
(paren
id|new_slave
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;This slave is always active in trunk mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* always active in trunk mode */
id|new_slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_eq
l_int|NULL
)paren
(brace
id|bond-&gt;current_slave
op_assign
id|new_slave
suffix:semicolon
)brace
)brace
id|update_slave_cnt
c_func
(paren
id|bond
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * !!! This is to support old versions of ifenslave.  We can remove&n;&t; * this in 2.5 because our ifenslave takes care of this for us.&n;&t; * We check to see if the master has a mac address yet.  If not,&n;&t; * we&squot;ll give it the mac address of our slave device.&n;&t; */
r_for
c_loop
(paren
id|ndx
op_assign
l_int|0
suffix:semicolon
id|ndx
OL
id|slave_dev-&gt;addr_len
suffix:semicolon
id|ndx
op_increment
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Checking ndx=%d of master_dev-&gt;dev_addr&bslash;n&quot;
comma
id|ndx
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|master_dev-&gt;dev_addr
(braket
id|ndx
)braket
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Found non-zero byte at ndx=%d&bslash;n&quot;
comma
id|ndx
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ndx
op_eq
id|slave_dev-&gt;addr_len
)paren
(brace
multiline_comment|/*&n;&t;&t; * We got all the way through the address and it was&n;&t;&t; * all 0&squot;s.&n;&t;&t; */
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s doesn&squot;t have a MAC address yet.  &quot;
comma
id|master_dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Going to give assign it from %s.&bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|bond_sethwaddr
c_func
(paren
id|master_dev
comma
id|slave_dev
)paren
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: enslaving %s as a%s interface with a%s link.&bslash;n&quot;
comma
id|master_dev-&gt;name
comma
id|slave_dev-&gt;name
comma
id|new_slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
ques
c_cond
l_string|&quot;n active&quot;
suffix:colon
l_string|&quot; backup&quot;
comma
id|new_slave-&gt;link
op_eq
id|BOND_LINK_UP
ques
c_cond
l_string|&quot;n up&quot;
suffix:colon
l_string|&quot; down&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * This function changes the active slave to slave &lt;slave_dev&gt;.&n; * It returns -EINVAL in the following cases.&n; *  - &lt;slave_dev&gt; is not found in the list.&n; *  - There is not active slave now.&n; *  - &lt;slave_dev&gt; is already active.&n; *  - The link state of &lt;slave_dev&gt; is not BOND_LINK_UP.&n; *  - &lt;slave_dev&gt; is not running.&n; * In these cases, this fuction does nothing.&n; * In the other cases, currnt_slave pointer is changed and 0 is returned.&n; */
DECL|function|bond_change_active
r_static
r_int
id|bond_change_active
c_func
(paren
r_struct
id|net_device
op_star
id|master_dev
comma
r_struct
id|net_device
op_star
id|slave_dev
)paren
(brace
id|bonding_t
op_star
id|bond
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
id|slave_t
op_star
id|oldactive
op_assign
l_int|NULL
suffix:semicolon
id|slave_t
op_star
id|newactive
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|master_dev
op_eq
l_int|NULL
op_logical_or
id|slave_dev
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master_dev-&gt;priv
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|slave
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|oldactive
op_assign
id|bond-&gt;current_slave
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;prev
)paren
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
r_if
c_cond
(paren
id|slave_dev
op_eq
id|slave-&gt;dev
)paren
(brace
id|newactive
op_assign
id|slave
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|newactive
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|oldactive
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|newactive
op_ne
id|oldactive
)paren
op_logical_and
(paren
id|newactive-&gt;link
op_eq
id|BOND_LINK_UP
)paren
op_logical_and
id|IS_UP
c_func
(paren
id|newactive-&gt;dev
)paren
)paren
(brace
id|bond_set_slave_inactive_flags
c_func
(paren
id|oldactive
)paren
suffix:semicolon
id|bond_set_slave_active_flags
c_func
(paren
id|newactive
)paren
suffix:semicolon
id|bond-&gt;current_slave
op_assign
id|newactive
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s : activate %s(old : %s)&bslash;n&quot;
comma
id|master_dev-&gt;name
comma
id|newactive-&gt;dev-&gt;name
comma
id|oldactive-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Choose a new valid interface from the pool, set it active&n; * and make it the current slave. If no valid interface is&n; * found, the oldest slave in BACK state is choosen and&n; * activated. If none is found, it&squot;s considered as no&n; * interfaces left so the current slave is set to NULL.&n; * The result is a pointer to the current slave.&n; *&n; * Since this function sends messages tails through printk, the caller&n; * must have started something like `printk(KERN_INFO &quot;xxxx &quot;);&squot;.&n; *&n; * Warning: must put locks around the call to this function if needed.&n; */
DECL|function|change_active_interface
id|slave_t
op_star
id|change_active_interface
c_func
(paren
id|bonding_t
op_star
id|bond
)paren
(brace
id|slave_t
op_star
id|newslave
comma
op_star
id|oldslave
suffix:semicolon
id|slave_t
op_star
id|bestslave
op_assign
l_int|NULL
suffix:semicolon
r_int
id|mintime
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|newslave
op_assign
id|oldslave
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newslave
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* there were no active slaves left */
r_if
c_cond
(paren
id|bond-&gt;next
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
multiline_comment|/* found one slave */
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|newslave
op_assign
id|bond-&gt;current_slave
op_assign
id|bond-&gt;next
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot; but could not find any %s interface.&bslash;n&quot;
comma
(paren
id|mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
ques
c_cond
l_string|&quot;backup&quot;
suffix:colon
l_string|&quot;other&quot;
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond-&gt;current_slave
op_assign
(paren
id|slave_t
op_star
)paren
l_int|NULL
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* still no slave, return NULL */
)brace
)brace
id|mintime
op_assign
id|updelay
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|newslave-&gt;dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|newslave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
(brace
multiline_comment|/* this one is immediately usable */
r_if
c_cond
(paren
id|mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
id|bond_set_slave_active_flags
c_func
(paren
id|newslave
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot; and making interface %s the active one.&bslash;n&quot;
comma
id|newslave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot; and setting pointer to interface %s.&bslash;n&quot;
comma
id|newslave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond-&gt;current_slave
op_assign
id|newslave
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_return
id|newslave
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|newslave-&gt;link
op_eq
id|BOND_LINK_BACK
)paren
(brace
multiline_comment|/* link up, but waiting for stabilization */
r_if
c_cond
(paren
id|newslave-&gt;delay
OL
id|mintime
)paren
(brace
id|mintime
op_assign
id|newslave-&gt;delay
suffix:semicolon
id|bestslave
op_assign
id|newslave
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
(paren
id|newslave
op_assign
id|newslave-&gt;next
)paren
op_ne
id|oldslave
)paren
suffix:semicolon
multiline_comment|/* no usable backup found, we&squot;ll see if we at least got a link that was&n;&t;   coming back for a long time, and could possibly already be usable.&n;&t;*/
r_if
c_cond
(paren
id|bestslave
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* early take-over. */
id|printk
(paren
l_string|&quot; and making interface %s the active one %d ms earlier.&bslash;n&quot;
comma
id|bestslave-&gt;dev-&gt;name
comma
(paren
id|updelay
op_minus
id|bestslave-&gt;delay
)paren
op_star
id|miimon
)paren
suffix:semicolon
id|bestslave-&gt;delay
op_assign
l_int|0
suffix:semicolon
id|bestslave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
id|bond_set_slave_active_flags
c_func
(paren
id|bestslave
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond-&gt;current_slave
op_assign
id|bestslave
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_return
id|bestslave
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot; but could not find any %s interface.&bslash;n&quot;
comma
(paren
id|mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
ques
c_cond
l_string|&quot;backup&quot;
suffix:colon
l_string|&quot;other&quot;
)paren
suffix:semicolon
multiline_comment|/* absolutely nothing found. let&squot;s return NULL */
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond-&gt;current_slave
op_assign
(paren
id|slave_t
op_star
)paren
l_int|NULL
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to release the slave device &lt;slave&gt; from the bond device &lt;master&gt;&n; * It is legal to access current_slave without a lock because all the function&n; * is write-locked.&n; *&n; * The rules for slave state should be:&n; *   for Active/Backup:&n; *     Active stays on all backups go down&n; *   for Bonded connections:&n; *     The first up interface should be left on and all others downed.&n; */
DECL|function|bond_release
r_static
r_int
id|bond_release
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|net_device
op_star
id|slave
)paren
(brace
id|bonding_t
op_star
id|bond
suffix:semicolon
id|slave_t
op_star
id|our_slave
comma
op_star
id|old_current
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|master
op_eq
l_int|NULL
op_logical_or
id|slave
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* master already enslaved, or slave not enslaved,&n;&t;   or no slave for this master */
r_if
c_cond
(paren
(paren
id|master-&gt;flags
op_amp
id|IFF_SLAVE
)paren
op_logical_or
op_logical_neg
(paren
id|slave-&gt;flags
op_amp
id|IFF_SLAVE
)paren
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: cannot release %s.&bslash;n&quot;
comma
id|master-&gt;name
comma
id|slave-&gt;name
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|our_slave
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|old_current
op_assign
id|bond-&gt;current_slave
suffix:semicolon
r_while
c_loop
(paren
(paren
id|our_slave
op_assign
id|our_slave-&gt;prev
)paren
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
r_if
c_cond
(paren
id|our_slave-&gt;dev
op_eq
id|slave
)paren
(brace
id|bond_detach_slave
c_func
(paren
id|bond
comma
id|our_slave
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: releasing %s interface %s&quot;
comma
id|master-&gt;name
comma
(paren
id|our_slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
)paren
ques
c_cond
l_string|&quot;active&quot;
suffix:colon
l_string|&quot;backup&quot;
comma
id|slave-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|our_slave
op_eq
id|old_current
)paren
(brace
multiline_comment|/* find a new interface and be verbose */
id|change_active_interface
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* release the slave from its bond */
multiline_comment|/* flush master&squot;s mc_list from slave */
id|bond_mc_list_flush
(paren
id|slave
comma
id|master
)paren
suffix:semicolon
multiline_comment|/* unset promiscuity level from slave */
r_if
c_cond
(paren
id|master-&gt;flags
op_amp
id|IFF_PROMISC
)paren
id|dev_set_promiscuity
c_func
(paren
id|slave
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* unset allmulti level from slave */
r_if
c_cond
(paren
id|master-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
id|dev_set_allmulti
c_func
(paren
id|slave
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|netdev_set_master
c_func
(paren
id|slave
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* only restore its RUNNING flag if monitoring set it down */
r_if
c_cond
(paren
id|slave-&gt;flags
op_amp
id|IFF_UP
)paren
(brace
id|slave-&gt;flags
op_or_assign
id|IFF_RUNNING
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slave-&gt;flags
op_amp
id|IFF_NOARP
op_logical_or
id|bond-&gt;current_slave
op_ne
l_int|NULL
)paren
(brace
id|dev_close
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
id|bond_restore_slave_flags
c_func
(paren
id|our_slave
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|our_slave
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: now running without any active interface !&bslash;n&quot;
comma
id|master-&gt;name
)paren
suffix:semicolon
)brace
id|update_slave_cnt
c_func
(paren
id|bond
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* deletion OK */
)brace
)brace
multiline_comment|/* if we get here, it&squot;s because the device was not found */
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: %s not enslaved&bslash;n&quot;
comma
id|master-&gt;name
comma
id|slave-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* &n; * This function releases all slaves.&n; * Warning: must put write-locks around the call to this function.&n; */
DECL|function|bond_release_all
r_static
r_int
id|bond_release_all
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
(brace
id|bonding_t
op_star
id|bond
suffix:semicolon
id|slave_t
op_star
id|our_slave
suffix:semicolon
r_struct
id|net_device
op_star
id|slave_dev
suffix:semicolon
r_if
c_cond
(paren
id|master
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|master-&gt;flags
op_amp
id|IFF_SLAVE
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
id|bond-&gt;current_slave
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|our_slave
op_assign
id|bond-&gt;prev
)paren
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
id|slave_dev
op_assign
id|our_slave-&gt;dev
suffix:semicolon
id|bond-&gt;prev
op_assign
id|our_slave-&gt;prev
suffix:semicolon
id|kfree
c_func
(paren
id|our_slave
)paren
suffix:semicolon
id|netdev_set_master
c_func
(paren
id|slave_dev
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* only restore its RUNNING flag if monitoring set it down */
r_if
c_cond
(paren
id|slave_dev-&gt;flags
op_amp
id|IFF_UP
)paren
id|slave_dev-&gt;flags
op_or_assign
id|IFF_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|slave_dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
id|dev_close
c_func
(paren
id|slave_dev
)paren
suffix:semicolon
)brace
id|bond-&gt;next
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|bond-&gt;slave_cnt
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: releases all slaves&bslash;n&quot;
comma
id|master-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this function is called regularly to monitor each slave&squot;s link. */
DECL|function|bond_mii_monitor
r_static
r_void
id|bond_mii_monitor
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
id|slave_t
op_star
id|slave
comma
op_star
id|bestslave
comma
op_star
id|oldcurrent
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|slave_died
op_assign
l_int|0
suffix:semicolon
id|read_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* we will try to read the link status of each of our slaves, and&n;&t; * set their IFF_RUNNING flag appropriately. For each slave not&n;&t; * supporting MII status, we won&squot;t do anything so that a user-space&n;&t; * program could monitor the link itself if needed.&n;&t; */
id|bestslave
op_assign
l_int|NULL
suffix:semicolon
id|slave
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|oldcurrent
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;prev
)paren
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
multiline_comment|/* use updelay+1 to match an UP slave even when updelay is 0 */
r_int
id|mindelay
op_assign
id|updelay
op_plus
l_int|1
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|slave-&gt;dev
suffix:semicolon
id|u16
id|link_state
suffix:semicolon
id|link_state
op_assign
id|bond_check_dev_link
c_func
(paren
id|dev
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|slave-&gt;link
)paren
(brace
r_case
id|BOND_LINK_UP
suffix:colon
multiline_comment|/* the link was up */
r_if
c_cond
(paren
(paren
id|link_state
op_amp
id|MII_LINK_UP
)paren
op_eq
id|MII_LINK_UP
)paren
(brace
multiline_comment|/* link stays up, tell that this one&n;&t;&t;&t;&t;   is immediately available */
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|dev
)paren
op_logical_and
(paren
id|mindelay
OG
op_minus
l_int|2
)paren
)paren
(brace
multiline_comment|/* -2 is the best case :&n;&t;&t;&t;&t;&t;   this slave was already up */
id|mindelay
op_assign
op_minus
l_int|2
suffix:semicolon
id|bestslave
op_assign
id|slave
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* link going down */
id|slave-&gt;link
op_assign
id|BOND_LINK_FAIL
suffix:semicolon
id|slave-&gt;delay
op_assign
id|downdelay
suffix:semicolon
r_if
c_cond
(paren
id|slave-&gt;link_failure_count
OL
id|UINT_MAX
)paren
(brace
id|slave-&gt;link_failure_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|downdelay
OG
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: link status down for %sinterface &quot;
l_string|&quot;%s, disabling it in %d ms.&bslash;n&quot;
comma
id|master-&gt;name
comma
id|IS_UP
c_func
(paren
id|dev
)paren
ques
c_cond
(paren
(paren
id|mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
ques
c_cond
(paren
(paren
id|slave
op_eq
id|oldcurrent
)paren
ques
c_cond
l_string|&quot;active &quot;
suffix:colon
l_string|&quot;backup &quot;
)paren
suffix:colon
l_string|&quot;&quot;
)paren
suffix:colon
l_string|&quot;idle &quot;
comma
id|dev-&gt;name
comma
id|downdelay
op_star
id|miimon
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* no break ! fall through the BOND_LINK_FAIL test to&n;&t;&t;&t;   ensure proper action to be taken&n;&t;&t;&t;*/
r_case
id|BOND_LINK_FAIL
suffix:colon
multiline_comment|/* the link has just gone down */
r_if
c_cond
(paren
(paren
id|link_state
op_amp
id|MII_LINK_UP
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* link stays down */
r_if
c_cond
(paren
id|slave-&gt;delay
op_le
l_int|0
)paren
(brace
multiline_comment|/* link down for too long time */
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
multiline_comment|/* in active/backup mode, we must&n;&t;&t;&t;&t;&t;   completely disable this interface */
r_if
c_cond
(paren
id|mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
id|bond_set_slave_inactive_flags
c_func
(paren
id|slave
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link status definitely down &quot;
l_string|&quot;for interface %s, disabling it&quot;
comma
id|master-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_eq
id|bond-&gt;current_slave
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
multiline_comment|/* find a new interface and be verbose */
id|change_active_interface
c_func
(paren
id|bond
)paren
suffix:semicolon
)brace
r_else
(brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|slave_died
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|slave-&gt;delay
op_decrement
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|link_state
op_amp
id|MII_LINK_READY
)paren
op_eq
id|MII_LINK_READY
)paren
(brace
multiline_comment|/* link up again */
id|slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link status up again after %d ms &quot;
l_string|&quot;for interface %s.&bslash;n&quot;
comma
id|master-&gt;name
comma
(paren
id|downdelay
op_minus
id|slave-&gt;delay
)paren
op_star
id|miimon
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|dev
)paren
op_logical_and
(paren
id|mindelay
OG
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* -1 is a good case : this slave went&n;&t;&t;&t;&t;&t;   down only for a short time */
id|mindelay
op_assign
op_minus
l_int|1
suffix:semicolon
id|bestslave
op_assign
id|slave
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|BOND_LINK_DOWN
suffix:colon
multiline_comment|/* the link was down */
r_if
c_cond
(paren
(paren
id|link_state
op_amp
id|MII_LINK_READY
)paren
op_ne
id|MII_LINK_READY
)paren
(brace
multiline_comment|/* the link stays down, nothing more to do */
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* link going up */
id|slave-&gt;link
op_assign
id|BOND_LINK_BACK
suffix:semicolon
id|slave-&gt;delay
op_assign
id|updelay
suffix:semicolon
r_if
c_cond
(paren
id|updelay
OG
l_int|0
)paren
(brace
multiline_comment|/* if updelay == 0, no need to&n;&t;&t;&t;&t;&t;   advertise about a 0 ms delay */
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: link status up for interface&quot;
l_string|&quot; %s, enabling it in %d ms.&bslash;n&quot;
comma
id|master-&gt;name
comma
id|dev-&gt;name
comma
id|updelay
op_star
id|miimon
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* no break ! fall through the BOND_LINK_BACK state in&n;&t;&t;&t;   case there&squot;s something to do.&n;&t;&t;&t;*/
r_case
id|BOND_LINK_BACK
suffix:colon
multiline_comment|/* the link has just come back */
r_if
c_cond
(paren
(paren
id|link_state
op_amp
id|MII_LINK_UP
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* link down again */
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link status down again after %d ms &quot;
l_string|&quot;for interface %s.&bslash;n&quot;
comma
id|master-&gt;name
comma
(paren
id|updelay
op_minus
id|slave-&gt;delay
)paren
op_star
id|miimon
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|link_state
op_amp
id|MII_LINK_READY
)paren
op_eq
id|MII_LINK_READY
)paren
(brace
multiline_comment|/* link stays up */
r_if
c_cond
(paren
id|slave-&gt;delay
op_eq
l_int|0
)paren
(brace
multiline_comment|/* now the link has been up for long time enough */
id|slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
multiline_comment|/* prevent it from being the active one */
id|slave-&gt;state
op_assign
id|BOND_STATE_BACKUP
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* make it immediately active */
id|slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link status definitely up &quot;
l_string|&quot;for interface %s.&bslash;n&quot;
comma
id|master-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
id|slave-&gt;delay
op_decrement
suffix:semicolon
multiline_comment|/* we&squot;ll also look for the mostly eligible slave */
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|dev
)paren
op_logical_and
(paren
id|slave-&gt;delay
OL
id|mindelay
)paren
)paren
(brace
id|mindelay
op_assign
id|slave-&gt;delay
suffix:semicolon
id|bestslave
op_assign
id|slave
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* end of switch */
)brace
multiline_comment|/* end of while */
multiline_comment|/* &n;&t; * if there&squot;s no active interface and we discovered that one&n;&t; * of the slaves could be activated earlier, so we do it.&n;&t; */
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|oldcurrent
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldcurrent
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* no active interface at the moment */
r_if
c_cond
(paren
id|bestslave
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* last chance to find one ? */
r_if
c_cond
(paren
id|bestslave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: making interface %s the new active one.&bslash;n&quot;
comma
id|master-&gt;name
comma
id|bestslave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: making interface %s the new &quot;
l_string|&quot;active one %d ms earlier.&bslash;n&quot;
comma
id|master-&gt;name
comma
id|bestslave-&gt;dev-&gt;name
comma
(paren
id|updelay
op_minus
id|bestslave-&gt;delay
)paren
op_star
id|miimon
)paren
suffix:semicolon
id|bestslave-&gt;delay
op_assign
l_int|0
suffix:semicolon
id|bestslave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
id|bond_set_slave_active_flags
c_func
(paren
id|bestslave
)paren
suffix:semicolon
)brace
r_else
(brace
id|bestslave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond-&gt;current_slave
op_assign
id|bestslave
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|slave_died
)paren
(brace
multiline_comment|/* print this message only once a slave has just died */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: now running without any active interface !&bslash;n&quot;
comma
id|master-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* re-arm the timer */
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;mii_timer
comma
id|jiffies
op_plus
(paren
id|miimon
op_star
id|HZ
op_div
l_int|1000
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * this function is called regularly to monitor each slave&squot;s link &n; * insuring that traffic is being sent and received.  If the adapter&n; * has been dormant, then an arp is transmitted to generate traffic &n; */
DECL|function|bond_arp_monitor
r_static
r_void
id|bond_arp_monitor
c_func
(paren
r_struct
id|net_device
op_star
id|master
)paren
(brace
id|bonding_t
op_star
id|bond
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
r_int
id|the_delta_in_ticks
op_assign
id|arp_interval
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
r_int
id|next_timer
op_assign
id|jiffies
op_plus
(paren
id|arp_interval
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|master-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
comma
id|next_timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|read_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_UP
c_func
(paren
id|master
)paren
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
comma
id|next_timer
)paren
suffix:semicolon
r_goto
id|arp_monitor_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtnl_shlock_nowait
c_func
(paren
)paren
)paren
(brace
r_goto
id|arp_monitor_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtnl_exlock_nowait
c_func
(paren
)paren
)paren
(brace
id|rtnl_shunlock
c_func
(paren
)paren
suffix:semicolon
r_goto
id|arp_monitor_out
suffix:semicolon
)brace
multiline_comment|/* see if any of the previous devices are up now (i.e. they have seen a &n;&t; * response from an arp request sent by another adapter, since they &n;&t; * have the same hardware address).&n;&t; */
id|slave
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;prev
)paren
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
)paren
op_logical_and
(paren
id|slave
op_ne
id|bond-&gt;current_slave
)paren
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;trans_start
)paren
op_le
id|the_delta_in_ticks
)paren
op_logical_and
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_le
id|the_delta_in_ticks
)paren
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_UP
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_eq
l_int|NULL
)paren
(brace
id|slave-&gt;state
op_assign
id|BOND_STATE_ACTIVE
suffix:semicolon
id|bond-&gt;current_slave
op_assign
id|slave
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slave
op_ne
id|bond-&gt;current_slave
)paren
(brace
id|slave-&gt;dev-&gt;flags
op_or_assign
id|IFF_NOARP
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_le
id|the_delta_in_ticks
)paren
(brace
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|arp_target
comma
id|slave-&gt;dev
comma
id|my_ip
comma
id|arp_target_hw_addr
comma
id|slave-&gt;dev-&gt;dev_addr
comma
id|arp_target_hw_addr
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|slave
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_ne
l_int|0
)paren
(brace
multiline_comment|/* see if you need to take down the current_slave, since&n;&t;   * you haven&squot;t seen an arp in 2*arp_intervals&n;&t;   */
r_if
c_cond
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;trans_start
)paren
op_ge
(paren
l_int|2
op_star
id|the_delta_in_ticks
)paren
)paren
op_logical_or
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_ge
(paren
l_int|2
op_star
id|the_delta_in_ticks
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
(brace
id|slave-&gt;link
op_assign
id|BOND_LINK_DOWN
suffix:semicolon
id|slave-&gt;state
op_assign
id|BOND_STATE_BACKUP
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * we want to see arps, otherwise we couldn&squot;t &n;&t;&t;&t;&t; * bring the adapter back online...  &n;&t;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: link status definitely &quot;
l_string|&quot;down for interface %s, &quot;
l_string|&quot;disabling it&quot;
comma
id|slave-&gt;dev-&gt;master-&gt;name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* find a new interface and be verbose */
id|change_active_interface
c_func
(paren
id|bond
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|slave
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;&t;&t; * ok, we know up/down, so just send a arp out if there has&n;&t;&t; * been no activity for a while &n;&t;&t; */
r_if
c_cond
(paren
id|slave
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;trans_start
)paren
op_ge
id|the_delta_in_ticks
)paren
op_logical_or
(paren
(paren
id|jiffies
op_minus
id|slave-&gt;dev-&gt;last_rx
)paren
op_ge
id|the_delta_in_ticks
)paren
)paren
(brace
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|arp_target
comma
id|slave-&gt;dev
comma
id|my_ip
comma
id|arp_target_hw_addr
comma
id|slave-&gt;dev-&gt;dev_addr
comma
id|arp_target_hw_addr
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* if we have no current slave.. try sending &n;&t; * an arp on all of the interfaces &n;&t; */
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_eq
l_int|NULL
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|slave
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;prev
)paren
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
(brace
id|arp_send
c_func
(paren
id|ARPOP_REQUEST
comma
id|ETH_P_ARP
comma
id|arp_target
comma
id|slave-&gt;dev
comma
id|my_ip
comma
id|arp_target_hw_addr
comma
id|slave-&gt;dev-&gt;dev_addr
comma
id|arp_target_hw_addr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
id|rtnl_exunlock
c_func
(paren
)paren
suffix:semicolon
id|rtnl_shunlock
c_func
(paren
)paren
suffix:semicolon
id|arp_monitor_out
suffix:colon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* re-arm the timer */
id|mod_timer
c_func
(paren
op_amp
id|bond-&gt;arp_timer
comma
id|next_timer
)paren
suffix:semicolon
)brace
DECL|macro|isdigit
mdefine_line|#define isdigit(c) (c &gt;= &squot;0&squot; &amp;&amp; c &lt;= &squot;9&squot;)
DECL|function|atoi
id|__inline
r_static
r_int
id|atoi
c_func
(paren
r_char
op_star
op_star
id|s
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|isdigit
c_func
(paren
op_star
op_star
id|s
)paren
)paren
id|i
op_assign
id|i
op_star
l_int|20
op_plus
op_star
(paren
(paren
op_star
id|s
)paren
op_increment
)paren
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|macro|isascii
mdefine_line|#define isascii(c) (((unsigned char)(c))&lt;=0x7f)
DECL|macro|LF
mdefine_line|#define LF 0xA
DECL|macro|isspace
mdefine_line|#define isspace(c) (c==&squot; &squot; || c==&squot;&t;&squot;|| c==LF)   
DECL|typedef|in_addr_t
r_typedef
r_uint32
id|in_addr_t
suffix:semicolon
r_int
DECL|function|my_inet_aton
id|my_inet_aton
c_func
(paren
r_char
op_star
id|cp
comma
r_int
r_int
op_star
id|the_addr
)paren
(brace
r_static
r_const
id|in_addr_t
id|max
(braket
l_int|4
)braket
op_assign
(brace
l_int|0xffffffff
comma
l_int|0xffffff
comma
l_int|0xffff
comma
l_int|0xff
)brace
suffix:semicolon
id|in_addr_t
id|val
suffix:semicolon
r_char
id|c
suffix:semicolon
r_union
id|iaddr
(brace
r_uint8
id|bytes
(braket
l_int|4
)braket
suffix:semicolon
r_uint32
id|word
suffix:semicolon
)brace
id|res
suffix:semicolon
r_uint8
op_star
id|pp
op_assign
id|res.bytes
suffix:semicolon
r_int
id|digit
comma
id|base
suffix:semicolon
id|res.word
op_assign
l_int|0
suffix:semicolon
id|c
op_assign
op_star
id|cp
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * Collect number up to ``.&squot;&squot;.&n;&t;&t; * Values are specified as for C:&n;&t;&t; * 0x=hex, 0=octal, isdigit=decimal.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|isdigit
c_func
(paren
id|c
)paren
)paren
r_goto
id|ret_0
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
id|base
op_assign
l_int|10
suffix:semicolon
id|digit
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|isdigit
c_func
(paren
id|c
)paren
)paren
(brace
id|val
op_assign
(paren
id|val
op_star
id|base
)paren
op_plus
(paren
id|c
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|cp
suffix:semicolon
id|digit
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;.&squot;
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Internet format:&n;&t;&t;&t; *&t;a.b.c.d&n;&t;&t;&t; *&t;a.b.c&t;(with c treated as 16 bits)&n;&t;&t;&t; *&t;a.b&t;(with b treated as 24 bits)&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pp
OG
id|res.bytes
op_plus
l_int|2
op_logical_or
id|val
OG
l_int|0xff
)paren
(brace
r_goto
id|ret_0
suffix:semicolon
)brace
op_star
id|pp
op_increment
op_assign
id|val
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|cp
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for trailing characters.&n;&t; */
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
(paren
op_logical_neg
id|isascii
c_func
(paren
id|c
)paren
op_logical_or
op_logical_neg
id|isspace
c_func
(paren
id|c
)paren
)paren
)paren
(brace
r_goto
id|ret_0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Did we get a valid digit?&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|digit
)paren
(brace
r_goto
id|ret_0
suffix:semicolon
)brace
multiline_comment|/* Check whether the last part is in its limits depending on&n;&t;   the number of parts in total.  */
r_if
c_cond
(paren
id|val
OG
id|max
(braket
id|pp
op_minus
id|res.bytes
)braket
)paren
(brace
r_goto
id|ret_0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|the_addr
op_ne
l_int|NULL
)paren
(brace
op_star
id|the_addr
op_assign
id|res.word
op_or
id|htonl
(paren
id|val
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
id|ret_0
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|bond_sethwaddr
r_static
r_int
id|bond_sethwaddr
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|net_device
op_star
id|slave
)paren
(brace
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;bond_sethwaddr: master=%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|master
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;bond_sethwaddr: slave=%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|slave
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;bond_sethwaddr: slave-&gt;addr_len=%d&bslash;n&quot;
comma
id|slave-&gt;addr_len
)paren
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|master-&gt;dev_addr
comma
id|slave-&gt;dev_addr
comma
id|slave-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_info_query
r_static
r_int
id|bond_info_query
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|ifbond
op_star
id|info
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|info-&gt;bond_mode
op_assign
id|mode
suffix:semicolon
id|info-&gt;num_slaves
op_assign
l_int|0
suffix:semicolon
id|info-&gt;miimon
op_assign
id|miimon
suffix:semicolon
id|read_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
(brace
id|info-&gt;num_slaves
op_increment
suffix:semicolon
)brace
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_slave_info_query
r_static
r_int
id|bond_slave_info_query
c_func
(paren
r_struct
id|net_device
op_star
id|master
comma
r_struct
id|ifslave
op_star
id|info
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|master-&gt;priv
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
r_int
id|cur_ndx
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;slave_id
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|read_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
op_logical_and
id|cur_ndx
OL
id|info-&gt;slave_id
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
(brace
id|cur_ndx
op_increment
suffix:semicolon
)brace
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_ndx
op_eq
id|info-&gt;slave_id
)paren
(brace
id|strcpy
c_func
(paren
id|info-&gt;slave_name
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
id|info-&gt;link
op_assign
id|slave-&gt;link
suffix:semicolon
id|info-&gt;state
op_assign
id|slave-&gt;state
suffix:semicolon
id|info-&gt;link_failure_count
op_assign
id|slave-&gt;link_failure_count
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_ioctl
r_static
r_int
id|bond_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|master_dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_struct
id|net_device
op_star
id|slave_dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ifbond
op_star
id|u_binfo
op_assign
l_int|NULL
comma
id|k_binfo
suffix:semicolon
r_struct
id|ifslave
op_star
id|u_sinfo
op_assign
l_int|NULL
comma
id|k_sinfo
suffix:semicolon
id|u16
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;bond_ioctl: master=%s, cmd=%d&bslash;n&quot;
comma
id|master_dev-&gt;name
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGMIIPHY
suffix:colon
id|data
op_assign
(paren
id|u16
op_star
)paren
op_amp
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|data
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fall Through */
r_case
id|SIOCGMIIREG
suffix:colon
multiline_comment|/* &n;&t;&t; * We do this again just in case we were called by SIOCGMIIREG&n;&t;&t; * instead of SIOCGMIIPHY.&n;&t;&t; */
id|data
op_assign
(paren
id|u16
op_star
)paren
op_amp
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data
(braket
l_int|1
)braket
op_eq
l_int|1
)paren
(brace
id|data
(braket
l_int|3
)braket
op_assign
id|bond_check_mii_link
c_func
(paren
(paren
r_struct
id|bonding
op_star
)paren
id|master_dev-&gt;priv
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|BOND_INFO_QUERY_OLD
suffix:colon
r_case
id|SIOCBONDINFOQUERY
suffix:colon
id|u_binfo
op_assign
(paren
r_struct
id|ifbond
op_star
)paren
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|k_binfo
comma
id|u_binfo
comma
r_sizeof
(paren
id|ifbond
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|ret
op_assign
id|bond_info_query
c_func
(paren
id|master_dev
comma
op_amp
id|k_binfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|u_binfo
comma
op_amp
id|k_binfo
comma
r_sizeof
(paren
id|ifbond
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
r_case
id|BOND_SLAVE_INFO_QUERY_OLD
suffix:colon
r_case
id|SIOCBONDSLAVEINFOQUERY
suffix:colon
id|u_sinfo
op_assign
(paren
r_struct
id|ifslave
op_star
)paren
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|k_sinfo
comma
id|u_sinfo
comma
r_sizeof
(paren
id|ifslave
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|ret
op_assign
id|bond_slave_info_query
c_func
(paren
id|master_dev
comma
op_amp
id|k_sinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|u_sinfo
comma
op_amp
id|k_sinfo
comma
r_sizeof
(paren
id|ifslave
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|slave_dev
op_assign
id|dev_get_by_name
c_func
(paren
id|ifr-&gt;ifr_slave
)paren
suffix:semicolon
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;slave_dev=%x: &bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|slave_dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;slave_dev-&gt;name=%s: &bslash;n&quot;
comma
id|slave_dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|slave_dev
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BOND_ENSLAVE_OLD
suffix:colon
r_case
id|SIOCBONDENSLAVE
suffix:colon
id|ret
op_assign
id|bond_enslave
c_func
(paren
id|master_dev
comma
id|slave_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_RELEASE_OLD
suffix:colon
r_case
id|SIOCBONDRELEASE
suffix:colon
id|ret
op_assign
id|bond_release
c_func
(paren
id|master_dev
comma
id|slave_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_SETHWADDR_OLD
suffix:colon
r_case
id|SIOCBONDSETHWADDR
suffix:colon
id|ret
op_assign
id|bond_sethwaddr
c_func
(paren
id|master_dev
comma
id|slave_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOND_CHANGE_ACTIVE_OLD
suffix:colon
r_case
id|SIOCBONDCHANGEACTIVE
suffix:colon
r_if
c_cond
(paren
id|mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
id|ret
op_assign
id|bond_change_active
c_func
(paren
id|master_dev
comma
id|slave_dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|dev_put
c_func
(paren
id|slave_dev
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET_FASTROUTE
DECL|function|bond_accept_fastpath
r_static
r_int
id|bond_accept_fastpath
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|bond_xmit_roundrobin
r_static
r_int
id|bond_xmit_roundrobin
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|slave_t
op_star
id|slave
comma
op_star
id|start_at
suffix:semicolon
r_struct
id|bonding
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_UP
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* bond down */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|read_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|slave
op_assign
id|start_at
op_assign
id|bond-&gt;current_slave
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* we&squot;re at the root, get the first slave */
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_do
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|slave-&gt;dev
)paren
op_logical_and
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
op_logical_and
(paren
id|slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
)paren
)paren
(brace
id|skb-&gt;dev
op_assign
id|slave-&gt;dev
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond-&gt;current_slave
op_assign
id|slave-&gt;next
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;next
)paren
op_ne
id|start_at
)paren
suffix:semicolon
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * in XOR mode, we determine the output device by performing xor on&n; * the source and destination hw adresses.  If this device is not &n; * enabled, find the next slave following this xor slave. &n; */
DECL|function|bond_xmit_xor
r_static
r_int
id|bond_xmit_xor
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|slave_t
op_star
id|slave
comma
op_star
id|start_at
suffix:semicolon
r_struct
id|bonding
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ethhdr
op_star
id|data
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
r_int
id|slave_no
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_UP
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* bond down */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|read_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
multiline_comment|/* we&squot;re at the root, get the first slave */
r_if
c_cond
(paren
(paren
id|slave
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|slave-&gt;dev
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|slave_no
op_assign
(paren
id|data-&gt;h_dest
(braket
l_int|5
)braket
op_xor
id|slave-&gt;dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
op_mod
id|bond-&gt;slave_cnt
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slave_no
OG
l_int|0
)paren
op_logical_and
(paren
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
)paren
)paren
(brace
id|slave
op_assign
id|slave-&gt;prev
suffix:semicolon
id|slave_no
op_decrement
suffix:semicolon
)brace
id|start_at
op_assign
id|slave
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|IS_UP
c_func
(paren
id|slave-&gt;dev
)paren
op_logical_and
(paren
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
)paren
op_logical_and
(paren
id|slave-&gt;state
op_eq
id|BOND_STATE_ACTIVE
)paren
)paren
(brace
id|skb-&gt;dev
op_assign
id|slave-&gt;dev
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|slave
op_assign
id|slave-&gt;next
)paren
op_ne
id|start_at
)paren
suffix:semicolon
multiline_comment|/* no suitable interface, frame not sent */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * in active-backup mode, we know that bond-&gt;current_slave is always valid if&n; * the bond has a usable interface.&n; */
DECL|function|bond_xmit_activebackup
r_static
r_int
id|bond_xmit_activebackup
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|bonding
op_star
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_UP
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* bond down */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if we are sending arp packets, try to at least &n;&t;   identify our own ip address */
r_if
c_cond
(paren
(paren
id|arp_interval
OG
l_int|0
)paren
op_logical_and
(paren
id|my_ip
op_eq
l_int|0
)paren
op_logical_and
(paren
id|skb-&gt;protocol
op_eq
id|__constant_htons
c_func
(paren
id|ETH_P_ARP
)paren
)paren
)paren
(brace
r_char
op_star
id|the_ip
op_assign
(paren
(paren
(paren
r_char
op_star
)paren
id|skb-&gt;data
)paren
)paren
op_plus
r_sizeof
(paren
r_struct
id|ethhdr
)paren
op_plus
r_sizeof
(paren
r_struct
id|arphdr
)paren
op_plus
id|ETH_ALEN
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|my_ip
comma
id|the_ip
comma
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* if we are sending arp packets and don&squot;t know &n;&t;   the target hw address, save it so we don&squot;t need &n;&t;   to use a broadcast address */
r_if
c_cond
(paren
(paren
id|arp_interval
OG
l_int|0
)paren
op_logical_and
(paren
id|arp_target_hw_addr
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|skb-&gt;protocol
op_eq
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
)paren
(brace
r_struct
id|ethhdr
op_star
id|eth_hdr
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|skb-&gt;data
)paren
)paren
suffix:semicolon
id|arp_target_hw_addr
op_assign
id|kmalloc
c_func
(paren
id|ETH_ALEN
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|arp_target_hw_addr
comma
id|eth_hdr-&gt;h_dest
comma
id|ETH_ALEN
)paren
suffix:semicolon
)brace
id|read_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* one usable interface */
id|skb-&gt;dev
op_assign
id|bond-&gt;current_slave-&gt;dev
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|skb-&gt;priority
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|dev_queue_xmit
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
)brace
multiline_comment|/* no suitable interface, frame not sent */
macro_line|#ifdef BONDING_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;There was no suitable interface, so we don&squot;t transmit&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bond_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|bond_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|stats
op_assign
id|bond-&gt;stats
comma
op_star
id|sstats
suffix:semicolon
id|slave_t
op_star
id|slave
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|memset
c_func
(paren
id|bond-&gt;stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
)paren
suffix:semicolon
id|read_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
(brace
id|sstats
op_assign
id|slave-&gt;dev
op_member_access_from_pointer
id|get_stats
c_func
(paren
id|slave-&gt;dev
)paren
suffix:semicolon
id|stats-&gt;rx_packets
op_add_assign
id|sstats-&gt;rx_packets
suffix:semicolon
id|stats-&gt;rx_bytes
op_add_assign
id|sstats-&gt;rx_bytes
suffix:semicolon
id|stats-&gt;rx_errors
op_add_assign
id|sstats-&gt;rx_errors
suffix:semicolon
id|stats-&gt;rx_dropped
op_add_assign
id|sstats-&gt;rx_dropped
suffix:semicolon
id|stats-&gt;tx_packets
op_add_assign
id|sstats-&gt;tx_packets
suffix:semicolon
id|stats-&gt;tx_bytes
op_add_assign
id|sstats-&gt;tx_bytes
suffix:semicolon
id|stats-&gt;tx_errors
op_add_assign
id|sstats-&gt;tx_errors
suffix:semicolon
id|stats-&gt;tx_dropped
op_add_assign
id|sstats-&gt;tx_dropped
suffix:semicolon
id|stats-&gt;multicast
op_add_assign
id|sstats-&gt;multicast
suffix:semicolon
id|stats-&gt;collisions
op_add_assign
id|sstats-&gt;collisions
suffix:semicolon
id|stats-&gt;rx_length_errors
op_add_assign
id|sstats-&gt;rx_length_errors
suffix:semicolon
id|stats-&gt;rx_over_errors
op_add_assign
id|sstats-&gt;rx_over_errors
suffix:semicolon
id|stats-&gt;rx_crc_errors
op_add_assign
id|sstats-&gt;rx_crc_errors
suffix:semicolon
id|stats-&gt;rx_frame_errors
op_add_assign
id|sstats-&gt;rx_frame_errors
suffix:semicolon
id|stats-&gt;rx_fifo_errors
op_add_assign
id|sstats-&gt;rx_fifo_errors
suffix:semicolon
id|stats-&gt;rx_missed_errors
op_add_assign
id|sstats-&gt;rx_missed_errors
suffix:semicolon
id|stats-&gt;tx_aborted_errors
op_add_assign
id|sstats-&gt;tx_aborted_errors
suffix:semicolon
id|stats-&gt;tx_carrier_errors
op_add_assign
id|sstats-&gt;tx_carrier_errors
suffix:semicolon
id|stats-&gt;tx_fifo_errors
op_add_assign
id|sstats-&gt;tx_fifo_errors
suffix:semicolon
id|stats-&gt;tx_heartbeat_errors
op_add_assign
id|sstats-&gt;tx_heartbeat_errors
suffix:semicolon
id|stats-&gt;tx_window_errors
op_add_assign
id|sstats-&gt;tx_window_errors
suffix:semicolon
)brace
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|stats
suffix:semicolon
)brace
DECL|function|bond_get_info
r_static
r_int
id|bond_get_info
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
id|bonding_t
op_star
id|bond
op_assign
id|these_bonds
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|u16
id|link
suffix:semicolon
id|slave_t
op_star
id|slave
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_while
c_loop
(paren
id|bond
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * This function locks the mutex, so we can&squot;t lock it until &n;&t;&t; * afterwards&n;&t;&t; */
id|link
op_assign
id|bond_check_mii_link
c_func
(paren
id|bond
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Bonding Mode: &quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|mode
ques
c_cond
l_string|&quot;active-backup&quot;
suffix:colon
l_string|&quot;load balancing&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
id|read_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;current_slave
op_ne
l_int|NULL
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Currently Active Slave: %s&bslash;n&quot;
comma
id|bond-&gt;current_slave-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;MII Status: &quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
id|link
op_eq
id|MII_LINK_READY
ques
c_cond
l_string|&quot;up&bslash;n&quot;
suffix:colon
l_string|&quot;down&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;MII Polling Interval (ms): %d&bslash;n&quot;
comma
id|miimon
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Up Delay (ms): %d&bslash;n&quot;
comma
id|updelay
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Down Delay (ms): %d&bslash;n&quot;
comma
id|downdelay
)paren
suffix:semicolon
id|read_lock_irqsave
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|bond-&gt;prev
suffix:semicolon
id|slave
op_ne
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|slave
op_assign
id|slave-&gt;prev
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;nSlave Interface: %s&bslash;n&quot;
comma
id|slave-&gt;dev-&gt;name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;MII Status: &quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
id|slave-&gt;link
op_eq
id|BOND_LINK_UP
ques
c_cond
l_string|&quot;up&bslash;n&quot;
suffix:colon
l_string|&quot;down&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Link Failure Count: %d&bslash;n&quot;
comma
id|slave-&gt;link_failure_count
)paren
suffix:semicolon
)brace
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|bond-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Figure out the calcs for the /proc/net interface&n;&t;&t; */
op_star
id|start
op_assign
id|buf
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
)brace
id|bond
op_assign
id|bond-&gt;next_bond
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|bond_event
r_static
r_int
id|bond_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|bonding
op_star
id|this_bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|these_bonds
suffix:semicolon
r_struct
id|bonding
op_star
id|last_bond
suffix:semicolon
r_struct
id|net_device
op_star
id|event_dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|ptr
suffix:semicolon
multiline_comment|/* while there are bonds configured */
r_while
c_loop
(paren
id|this_bond
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|this_bond
op_eq
id|event_dev-&gt;priv
)paren
(brace
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|NETDEV_UNREGISTER
suffix:colon
multiline_comment|/* &n;&t;&t;&t;&t; * remove this bond from a linked list of &n;&t;&t;&t;&t; * bonds &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|this_bond
op_eq
id|these_bonds
)paren
(brace
id|these_bonds
op_assign
id|this_bond-&gt;next_bond
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|last_bond
op_assign
id|these_bonds
suffix:semicolon
id|last_bond
op_ne
l_int|NULL
suffix:semicolon
id|last_bond
op_assign
id|last_bond-&gt;next_bond
)paren
(brace
r_if
c_cond
(paren
id|last_bond-&gt;next_bond
op_eq
id|this_bond
)paren
(brace
id|last_bond-&gt;next_bond
op_assign
id|this_bond-&gt;next_bond
suffix:semicolon
)brace
)brace
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
r_default
suffix:colon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|this_bond-&gt;device
op_eq
id|event_dev-&gt;master
)paren
(brace
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|NETDEV_UNREGISTER
suffix:colon
id|bond_release
c_func
(paren
id|this_bond-&gt;device
comma
id|event_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
id|this_bond
op_assign
id|this_bond-&gt;next_bond
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|bond_netdev_notifier
r_static
r_struct
id|notifier_block
id|bond_netdev_notifier
op_assign
(brace
id|notifier_call
suffix:colon
id|bond_event
comma
)brace
suffix:semicolon
DECL|function|bond_init
r_static
r_int
id|__init
id|bond_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|bonding_t
op_star
id|bond
comma
op_star
id|this_bond
comma
op_star
id|last_bond
suffix:semicolon
macro_line|#ifdef BONDING_DEBUG
id|printk
(paren
id|KERN_INFO
l_string|&quot;Begin bond_init for %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|bond
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|bonding
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|bond
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|bonding
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize rwlocks */
id|rwlock_init
c_func
(paren
op_amp
id|bond-&gt;lock
)paren
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
id|bond-&gt;ptrlock
)paren
suffix:semicolon
id|bond-&gt;stats
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;stats
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|bond-&gt;stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
)paren
suffix:semicolon
id|bond-&gt;next
op_assign
id|bond-&gt;prev
op_assign
(paren
id|slave_t
op_star
)paren
id|bond
suffix:semicolon
id|bond-&gt;current_slave
op_assign
l_int|NULL
suffix:semicolon
id|bond-&gt;device
op_assign
id|dev
suffix:semicolon
id|dev-&gt;priv
op_assign
id|bond
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
r_if
c_cond
(paren
id|mode
op_eq
id|BOND_MODE_ACTIVEBACKUP
)paren
(brace
id|dev-&gt;hard_start_xmit
op_assign
id|bond_xmit_activebackup
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mode
op_eq
id|BOND_MODE_ROUNDROBIN
)paren
(brace
id|dev-&gt;hard_start_xmit
op_assign
id|bond_xmit_roundrobin
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mode
op_eq
id|BOND_MODE_XOR
)paren
(brace
id|dev-&gt;hard_start_xmit
op_assign
id|bond_xmit_xor
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unknown bonding mode %d&bslash;n&quot;
comma
id|mode
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bond-&gt;stats
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev-&gt;get_stats
op_assign
id|bond_get_stats
suffix:semicolon
id|dev-&gt;open
op_assign
id|bond_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|bond_close
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|set_multicast_list
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|bond_ioctl
suffix:semicolon
multiline_comment|/* &n;&t; * Fill in the fields of the device structure with ethernet-generic &n;&t; * values. &n;&t; */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_MASTER
op_or
id|IFF_MULTICAST
suffix:semicolon
macro_line|#ifdef CONFIG_NET_FASTROUTE
id|dev-&gt;accept_fastpath
op_assign
id|bond_accept_fastpath
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s registered with&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|miimon
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; MII link monitoring set to %d ms&quot;
comma
id|miimon
)paren
suffix:semicolon
id|updelay
op_div_assign
id|miimon
suffix:semicolon
id|downdelay
op_div_assign
id|miimon
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;out MII link monitoring&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;, in %s mode.&bslash;n&quot;
comma
id|mode
ques
c_cond
l_string|&quot;active-backup&quot;
suffix:colon
l_string|&quot;bonding&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|bond-&gt;bond_proc_dir
op_assign
id|proc_mkdir
c_func
(paren
id|dev-&gt;name
comma
id|proc_net
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;bond_proc_dir
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Cannot init /proc/net/%s/&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bond-&gt;stats
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|bond-&gt;bond_proc_info_file
op_assign
id|create_proc_info_entry
c_func
(paren
l_string|&quot;info&quot;
comma
l_int|0
comma
id|bond-&gt;bond_proc_dir
comma
id|bond_get_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bond-&gt;bond_proc_info_file
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Cannot init /proc/net/%s/info&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|dev-&gt;name
comma
id|proc_net
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bond-&gt;stats
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bond
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
r_if
c_cond
(paren
id|first_pass
op_eq
l_int|1
)paren
(brace
id|these_bonds
op_assign
id|bond
suffix:semicolon
id|register_netdevice_notifier
c_func
(paren
op_amp
id|bond_netdev_notifier
)paren
suffix:semicolon
id|first_pass
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|last_bond
op_assign
id|these_bonds
suffix:semicolon
id|this_bond
op_assign
id|these_bonds-&gt;next_bond
suffix:semicolon
r_while
c_loop
(paren
id|this_bond
op_ne
l_int|NULL
)paren
(brace
id|last_bond
op_assign
id|this_bond
suffix:semicolon
id|this_bond
op_assign
id|this_bond-&gt;next_bond
suffix:semicolon
)brace
id|last_bond-&gt;next_bond
op_assign
id|bond
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;static int __init bond_probe(struct net_device *dev)&n;{&n;&t;bond_init(dev);&n;&t;return 0;&n;}&n; */
DECL|function|bonding_init
r_static
r_int
id|__init
id|bonding_init
c_func
(paren
r_void
)paren
(brace
r_int
id|no
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* Find a name for this unit */
r_static
r_struct
id|net_device
op_star
id|dev_bond
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|max_bonds
template_param
id|INT_MAX
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bonding_init(): max_bonds (%d) not in range %d-%d, &quot;
l_string|&quot;so it was reset to BOND_DEFAULT_MAX_BONDS (%d)&quot;
comma
id|max_bonds
comma
l_int|1
comma
id|INT_MAX
comma
id|BOND_DEFAULT_MAX_BONDS
)paren
suffix:semicolon
id|max_bonds
op_assign
id|BOND_DEFAULT_MAX_BONDS
suffix:semicolon
)brace
id|dev_bond
op_assign
id|dev_bonds
op_assign
id|kmalloc
c_func
(paren
id|max_bonds
op_star
r_sizeof
(paren
r_struct
id|net_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_bond
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev_bonds
comma
l_int|0
comma
id|max_bonds
op_star
r_sizeof
(paren
r_struct
id|net_device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arp_ip_target
)paren
(brace
r_if
c_cond
(paren
id|my_inet_aton
c_func
(paren
id|arp_ip_target
comma
op_amp
id|arp_target
)paren
op_eq
l_int|0
)paren
(brace
id|arp_interval
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|no
op_assign
l_int|0
suffix:semicolon
id|no
OL
id|max_bonds
suffix:semicolon
id|no
op_increment
)paren
(brace
id|dev_bond-&gt;init
op_assign
id|bond_init
suffix:semicolon
id|err
op_assign
id|dev_alloc_name
c_func
(paren
id|dev_bond
comma
l_string|&quot;bond%d&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|dev_bonds
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|SET_MODULE_OWNER
c_func
(paren
id|dev_bond
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|dev_bond
)paren
op_ne
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|dev_bonds
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|dev_bond
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bonding_exit
r_static
r_void
id|__exit
id|bonding_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|dev_bond
op_assign
id|dev_bonds
suffix:semicolon
r_struct
id|bonding
op_star
id|bond
suffix:semicolon
r_int
id|no
suffix:semicolon
id|unregister_netdevice_notifier
c_func
(paren
op_amp
id|bond_netdev_notifier
)paren
suffix:semicolon
r_for
c_loop
(paren
id|no
op_assign
l_int|0
suffix:semicolon
id|no
OL
id|max_bonds
suffix:semicolon
id|no
op_increment
)paren
(brace
macro_line|#ifdef CONFIG_PROC_FS
id|bond
op_assign
(paren
r_struct
id|bonding
op_star
)paren
id|dev_bond-&gt;priv
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;info&quot;
comma
id|bond-&gt;bond_proc_dir
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|dev_bond-&gt;name
comma
id|proc_net
)paren
suffix:semicolon
macro_line|#endif
id|unregister_netdev
c_func
(paren
id|dev_bond
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bond-&gt;stats
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev_bond-&gt;priv
)paren
suffix:semicolon
id|dev_bond-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
id|dev_bond
op_increment
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|dev_bonds
)paren
suffix:semicolon
)brace
DECL|variable|bonding_init
id|module_init
c_func
(paren
id|bonding_init
)paren
suffix:semicolon
DECL|variable|bonding_exit
id|module_exit
c_func
(paren
id|bonding_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Local variables:&n; *  c-indent-level: 8&n; *  c-basic-offset: 8&n; *  tab-width: 8&n; * End:&n; */
eof
