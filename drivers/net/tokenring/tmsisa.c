multiline_comment|/*&n; *  tmsisa.c: A generic network driver for TMS380-based ISA token ring cards.&n; *&n; *  Based on tmspci written 1999 by Adam Fritzler&n; *  &n; *  Written 2000 by Jochen Friedrich&n; *  Dedicated to my girlfriend Steffi Bopp&n; *&n; *  This software may be used and distributed according to the terms&n; *  of the GNU General Public License, incorporated herein by reference.&n; *&n; *  This driver module supports the following cards:&n; *&t;- SysKonnect TR4/16(+) ISA&t;(SK-4190)&n; *&n; *  Maintainer(s):&n; *    AF        Adam Fritzler           mid@auk.cx&n; *    JF&t;Jochen Friedrich&t;jochen@scram.de&n; *&n; *  TODO:&n; *&t;1. Add support for Proteon TR ISA adapters (1392, 1392+)&n; */
DECL|variable|version
r_static
r_const
r_char
id|version
(braket
)braket
op_assign
l_string|&quot;tmsisa.c: v1.00 14/01/2001 by Jochen Friedrich&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/pci.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/trdevice.h&gt;
macro_line|#include &quot;tms380tr.h&quot;
DECL|macro|TMS_ISA_IO_EXTENT
mdefine_line|#define TMS_ISA_IO_EXTENT 32
multiline_comment|/* A zero-terminated list of I/O addresses to be probed. */
DECL|variable|__initdata
r_static
r_int
r_int
id|portlist
(braket
)braket
id|__initdata
op_assign
(brace
l_int|0x0A20
comma
l_int|0x1A20
comma
l_int|0x0B20
comma
l_int|0x1B20
comma
l_int|0x0980
comma
l_int|0x1980
comma
l_int|0x0900
comma
l_int|0x1900
comma
singleline_comment|// SK
l_int|0
)brace
suffix:semicolon
multiline_comment|/* A zero-terminated list of IRQs to be probed. &n; * Used again after initial probe for sktr_chipset_init, called from sktr_open.&n; */
DECL|variable|irqlist
r_static
r_int
r_int
id|irqlist
(braket
)braket
op_assign
(brace
l_int|3
comma
l_int|5
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|15
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* A zero-terminated list of DMAs to be probed. */
DECL|variable|__initdata
r_static
r_int
id|dmalist
(braket
)braket
id|__initdata
op_assign
(brace
l_int|5
comma
l_int|6
comma
l_int|7
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|isa_cardname
r_static
r_char
id|isa_cardname
(braket
)braket
op_assign
l_string|&quot;SK NET TR 4/16 ISA&bslash;0&quot;
suffix:semicolon
r_int
id|tms_isa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|tms_isa_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|tms_isa_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|tms_isa_read_eeprom
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
r_int
id|tms_isa_setnselout_pins
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
DECL|function|tms_isa_sifreadb
r_static
r_int
r_int
id|tms_isa_sifreadb
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|reg
)paren
(brace
r_return
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|reg
)paren
suffix:semicolon
)brace
DECL|function|tms_isa_sifreadw
r_static
r_int
r_int
id|tms_isa_sifreadw
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|reg
)paren
(brace
r_return
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|reg
)paren
suffix:semicolon
)brace
DECL|function|tms_isa_sifwriteb
r_static
r_void
id|tms_isa_sifwriteb
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|val
comma
r_int
r_int
id|reg
)paren
(brace
id|outb
c_func
(paren
id|val
comma
id|dev-&gt;base_addr
op_plus
id|reg
)paren
suffix:semicolon
)brace
DECL|function|tms_isa_sifwritew
r_static
r_void
id|tms_isa_sifwritew
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|val
comma
r_int
r_int
id|reg
)paren
(brace
id|outw
c_func
(paren
id|val
comma
id|dev-&gt;base_addr
op_plus
id|reg
)paren
suffix:semicolon
)brace
DECL|struct|tms_isa_card
r_struct
id|tms_isa_card
(brace
DECL|member|dev
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
DECL|member|next
r_struct
id|tms_isa_card
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|tms_isa_card_list
r_static
r_struct
id|tms_isa_card
op_star
id|tms_isa_card_list
suffix:semicolon
DECL|function|tms_isa_probe1
r_static
r_int
id|__init
id|tms_isa_probe1
c_func
(paren
r_int
id|ioaddr
)paren
(brace
r_int
r_char
id|old
comma
id|chk1
comma
id|chk2
suffix:semicolon
id|old
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|SIFADR
)paren
suffix:semicolon
multiline_comment|/* Get the old SIFADR value */
id|chk1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Begin with check value 0 */
r_do
(brace
multiline_comment|/* Write new SIFADR value */
id|outb
c_func
(paren
id|chk1
comma
id|ioaddr
op_plus
id|SIFADR
)paren
suffix:semicolon
multiline_comment|/* Read, invert and write */
id|chk2
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|SIFADD
)paren
suffix:semicolon
id|chk2
op_xor_assign
l_int|0x0FE
suffix:semicolon
id|outb
c_func
(paren
id|chk2
comma
id|ioaddr
op_plus
id|SIFADR
)paren
suffix:semicolon
multiline_comment|/* Read, invert and compare */
id|chk2
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|SIFADD
)paren
suffix:semicolon
id|chk2
op_xor_assign
l_int|0x0FE
suffix:semicolon
r_if
c_cond
(paren
id|chk1
op_ne
id|chk2
)paren
(brace
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* No adapter */
id|chk1
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_while
c_loop
(paren
id|chk1
op_ne
l_int|0
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Repeat 128 times (all byte values) */
multiline_comment|/* Restore the SIFADR value */
id|outb
c_func
(paren
id|old
comma
id|ioaddr
op_plus
id|SIFADR
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|tms_isa_probe
r_int
id|__init
id|tms_isa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_static
r_int
id|versionprinted
suffix:semicolon
r_struct
id|net_local
op_star
id|tp
suffix:semicolon
r_int
id|j
suffix:semicolon
r_struct
id|tms_isa_card
op_star
id|card
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|TMS_ISA_IO_EXTENT
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tms_isa_probe1
c_func
(paren
id|dev-&gt;base_addr
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|versionprinted
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
multiline_comment|/* At this point we have found a valid card. */
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|TMS_ISA_IO_EXTENT
comma
id|isa_cardname
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tmsdev_init
c_func
(paren
id|dev
comma
id|ISA_MAX_ADDRESS
comma
l_int|NULL
)paren
)paren
(brace
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|TMS_ISA_IO_EXTENT
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dev-&gt;base_addr
op_and_assign
op_complement
l_int|3
suffix:semicolon
id|tms_isa_read_eeprom
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s:    Ring Station Address: &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
l_int|6
suffix:semicolon
id|j
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;:%2.2x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|j
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|tp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|tp-&gt;setnselout
op_assign
id|tms_isa_setnselout_pins
suffix:semicolon
id|tp-&gt;sifreadb
op_assign
id|tms_isa_sifreadb
suffix:semicolon
id|tp-&gt;sifreadw
op_assign
id|tms_isa_sifreadw
suffix:semicolon
id|tp-&gt;sifwriteb
op_assign
id|tms_isa_sifwriteb
suffix:semicolon
id|tp-&gt;sifwritew
op_assign
id|tms_isa_sifwritew
suffix:semicolon
id|memcpy
c_func
(paren
id|tp-&gt;ProductID
comma
id|isa_cardname
comma
id|PROD_ID_SIZE
op_plus
l_int|1
)paren
suffix:semicolon
id|tp-&gt;tmspriv
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;open
op_assign
id|tms_isa_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|tms_isa_close
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|irqlist
(braket
id|j
)braket
op_ne
l_int|0
suffix:semicolon
id|j
op_increment
)paren
(brace
id|dev-&gt;irq
op_assign
id|irqlist
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|tms380tr_interrupt
comma
l_int|0
comma
id|isa_cardname
comma
id|dev
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irqlist
(braket
id|j
)braket
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: AutoSelect no IRQ available&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|TMS_ISA_IO_EXTENT
)paren
suffix:semicolon
id|tmsdev_term
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|irqlist
(braket
id|j
)braket
op_ne
l_int|0
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|irqlist
(braket
id|j
)braket
op_eq
id|dev-&gt;irq
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|irqlist
(braket
id|j
)braket
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Illegal IRQ %d specified&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|TMS_ISA_IO_EXTENT
)paren
suffix:semicolon
id|tmsdev_term
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|tms380tr_interrupt
comma
l_int|0
comma
id|isa_cardname
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Selected IRQ %d not available&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|TMS_ISA_IO_EXTENT
)paren
suffix:semicolon
id|tmsdev_term
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dev-&gt;dma
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|dmalist
(braket
id|j
)braket
op_ne
l_int|0
suffix:semicolon
id|j
op_increment
)paren
(brace
id|dev-&gt;dma
op_assign
id|dmalist
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_dma
c_func
(paren
id|dev-&gt;dma
comma
id|isa_cardname
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmalist
(braket
id|j
)braket
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: AutoSelect no DMA available&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|TMS_ISA_IO_EXTENT
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|tmsdev_term
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|dmalist
(braket
id|j
)braket
op_ne
l_int|0
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|dmalist
(braket
id|j
)braket
op_eq
id|dev-&gt;dma
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dmalist
(braket
id|j
)braket
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Illegal DMA %d specified&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;dma
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|TMS_ISA_IO_EXTENT
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|tmsdev_term
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|dev-&gt;dma
comma
id|isa_cardname
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Selected DMA %d not available&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;dma
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|TMS_ISA_IO_EXTENT
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|tmsdev_term
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;%s:    IO: %#4lx  IRQ: %d  DMA: %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;irq
comma
id|dev-&gt;dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_trdev
c_func
(paren
id|dev
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Enlist in the card list */
id|card
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|tms_isa_card
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
(brace
id|unregister_trdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|TMS_ISA_IO_EXTENT
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|dev-&gt;dma
)paren
suffix:semicolon
id|tmsdev_term
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|card-&gt;next
op_assign
id|tms_isa_card_list
suffix:semicolon
id|tms_isa_card_list
op_assign
id|card
suffix:semicolon
id|card-&gt;dev
op_assign
id|dev
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: register_trdev() returned non-zero.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|TMS_ISA_IO_EXTENT
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|dev-&gt;dma
)paren
suffix:semicolon
id|tmsdev_term
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Reads MAC address from adapter RAM, which should&squot;ve read it from&n; * the onboard ROM.  &n; *&n; * Calling this on a board that does not support it can be a very&n; * dangerous thing.  The Madge board, for instance, will lock your&n; * machine hard when this is called.  Luckily, its supported in a&n; * seperate driver.  --ASF&n; */
DECL|function|tms_isa_read_eeprom
r_static
r_void
id|tms_isa_read_eeprom
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Address: 0000:0000 */
id|tms_isa_sifwritew
c_func
(paren
id|dev
comma
l_int|0
comma
id|SIFADX
)paren
suffix:semicolon
id|tms_isa_sifwritew
c_func
(paren
id|dev
comma
l_int|0
comma
id|SIFADR
)paren
suffix:semicolon
multiline_comment|/* Read six byte MAC address data */
id|dev-&gt;addr_len
op_assign
l_int|6
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|tms_isa_sifreadw
c_func
(paren
id|dev
comma
id|SIFINC
)paren
op_rshift
l_int|8
suffix:semicolon
)brace
)brace
DECL|function|tms_isa_setnselout_pins
r_int
r_int
id|tms_isa_setnselout_pins
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tms_isa_open
r_static
r_int
id|tms_isa_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|tp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|val
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|oldval
suffix:semicolon
r_int
id|i
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|irqlist
(braket
id|i
)braket
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irqlist
(braket
id|i
)braket
op_eq
id|dev-&gt;irq
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|val
op_or_assign
id|CYCLE_TIME
op_lshift
l_int|2
suffix:semicolon
id|val
op_or_assign
id|i
op_lshift
l_int|4
suffix:semicolon
id|i
op_assign
id|dev-&gt;dma
op_minus
l_int|5
suffix:semicolon
id|val
op_or_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;DataRate
op_eq
id|SPEED_4
)paren
(brace
id|val
op_or_assign
id|LINE_SPEED_BIT
suffix:semicolon
)brace
r_else
id|val
op_and_assign
op_complement
id|LINE_SPEED_BIT
suffix:semicolon
id|oldval
op_assign
id|tms_isa_sifreadb
c_func
(paren
id|dev
comma
id|POSREG
)paren
suffix:semicolon
multiline_comment|/* Leave cycle bits alone */
id|oldval
op_or_assign
l_int|0xf3
suffix:semicolon
id|val
op_and_assign
id|oldval
suffix:semicolon
id|tms_isa_sifwriteb
c_func
(paren
id|dev
comma
id|val
comma
id|POSREG
)paren
suffix:semicolon
id|tms380tr_open
c_func
(paren
id|dev
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tms_isa_close
r_static
r_int
id|tms_isa_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|tms380tr_close
c_func
(paren
id|dev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|macro|ISATR_MAX_ADAPTERS
mdefine_line|#define ISATR_MAX_ADAPTERS 3
DECL|variable|io
r_static
r_int
id|io
(braket
id|ISATR_MAX_ADAPTERS
)braket
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
(braket
id|ISATR_MAX_ADAPTERS
)braket
suffix:semicolon
DECL|variable|dma
r_static
r_int
id|dma
(braket
id|ISATR_MAX_ADAPTERS
)braket
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|ISATR_MAX_ADAPTERS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|ISATR_MAX_ADAPTERS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dma
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|ISATR_MAX_ADAPTERS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|num
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
id|num
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|io
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* Only probe addresses from command line */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ISATR_MAX_ADAPTERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|io
(braket
id|i
)braket
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|dev
op_assign
id|init_trdev
c_func
(paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|io
(braket
id|i
)braket
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
(braket
id|i
)braket
suffix:semicolon
id|dev-&gt;dma
op_assign
id|dma
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tms_isa_probe
c_func
(paren
id|dev
)paren
)paren
(brace
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
id|num
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|portlist
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|num
op_ge
id|ISATR_MAX_ADAPTERS
)paren
r_continue
suffix:semicolon
id|dev
op_assign
id|init_trdev
c_func
(paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|portlist
(braket
id|i
)braket
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
(braket
id|num
)braket
suffix:semicolon
id|dev-&gt;dma
op_assign
id|dma
(braket
id|num
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tms_isa_probe
c_func
(paren
id|dev
)paren
)paren
(brace
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
id|num
op_increment
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;tmsisa.c: %d cards found.&bslash;n&quot;
comma
id|num
)paren
suffix:semicolon
multiline_comment|/* Probe for cards. */
r_if
c_cond
(paren
id|num
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;tmsisa.c: No cards found.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|tms_isa_card
op_star
id|this_card
suffix:semicolon
r_while
c_loop
(paren
id|tms_isa_card_list
)paren
(brace
id|dev
op_assign
id|tms_isa_card_list-&gt;dev
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|TMS_ISA_IO_EXTENT
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|dev-&gt;dma
)paren
suffix:semicolon
id|tmsdev_term
c_func
(paren
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
id|this_card
op_assign
id|tms_isa_card_list
suffix:semicolon
id|tms_isa_card_list
op_assign
id|this_card-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|this_card
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -DMODVERSIONS  -DMODULE -D__KERNEL__ -Wall -Wstrict-prototypes -O6 -fomit-frame-pointer -I/usr/src/linux/drivers/net/tokenring/ -c tmsisa.c&quot;&n; *  alt-compile-command: &quot;gcc -DMODULE -D__KERNEL__ -Wall -Wstrict-prototypes -O6 -fomit-frame-pointer -I/usr/src/linux/drivers/net/tokenring/ -c tmsisa.c&quot;&n; *  c-set-style &quot;K&amp;R&quot;&n; *  c-indent-level: 8&n; *  c-basic-offset: 8&n; *  tab-width: 8&n; * End:&n; */
eof
