multiline_comment|/*******************************************************************************&n;&n;This software program is available to you under a choice of one of two &n;licenses. You may choose to be licensed under either the GNU General Public &n;License 2.0, June 1991, available at http://www.fsf.org/copyleft/gpl.html, &n;or the Intel BSD + Patent License, the text of which follows:&n;&n;Recipient has requested a license and Intel Corporation (&quot;Intel&quot;) is willing&n;to grant a license for the software entitled Linux Base Driver for the &n;Intel(R) PRO/100 Family of Adapters (e100) (the &quot;Software&quot;) being provided &n;by Intel Corporation. The following definitions apply to this license:&n;&n;&quot;Licensed Patents&quot; means patent claims licensable by Intel Corporation which &n;are necessarily infringed by the use of sale of the Software alone or when &n;combined with the operating system referred to below.&n;&n;&quot;Recipient&quot; means the party to whom Intel delivers this Software.&n;&n;&quot;Licensee&quot; means Recipient and those third parties that receive a license to &n;any operating system available under the GNU General Public License 2.0 or &n;later.&n;&n;Copyright (c) 1999 - 2002 Intel Corporation.&n;All rights reserved.&n;&n;The license is provided to Recipient and Recipient&squot;s Licensees under the &n;following terms.&n;&n;Redistribution and use in source and binary forms of the Software, with or &n;without modification, are permitted provided that the following conditions &n;are met:&n;&n;Redistributions of source code of the Software may retain the above &n;copyright notice, this list of conditions and the following disclaimer.&n;&n;Redistributions in binary form of the Software may reproduce the above &n;copyright notice, this list of conditions and the following disclaimer in &n;the documentation and/or materials provided with the distribution.&n;&n;Neither the name of Intel Corporation nor the names of its contributors &n;shall be used to endorse or promote products derived from this Software &n;without specific prior written permission.&n;&n;Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, &n;royalty-free patent license under Licensed Patents to make, use, sell, offer &n;to sell, import and otherwise transfer the Software, if any, in source code &n;and object code form. This license shall include changes to the Software &n;that are error corrections or other minor changes to the Software that do &n;not add functionality or features when the Software is incorporated in any &n;version of an operating system that has been distributed under the GNU &n;General Public License 2.0 or later. This patent license shall apply to the &n;combination of the Software and any operating system licensed under the GNU &n;General Public License 2.0 or later if, at the time Intel provides the &n;Software to Recipient, such addition of the Software to the then publicly &n;available versions of such operating systems available under the GNU General &n;Public License 2.0 or later (whether in gold, beta or alpha form) causes &n;such combination to be covered by the Licensed Patents. The patent license &n;shall not apply to any other combinations which include the Software. NO &n;hardware per se is licensed hereunder.&n;&n;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; &n;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE &n;IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE &n;ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY &n;DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES &n;(INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; &n;ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED &n;AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR &n;TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE &n;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n;*******************************************************************************/
macro_line|#include &quot;e100_phy.h&quot;
r_void
id|e100_handle_zlock
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
suffix:semicolon
multiline_comment|/* &n; * Procedure:&t;e100_mdi_write&n; *&n; * Description: This routine will write a value to the specified MII register&n; *&t;&t;of an external MDI compliant device (e.g. PHY 100).  The&n; *&t;&t;command will execute in polled mode.&n; *&n; * Arguments:&n; *&t;bdp - Ptr to this card&squot;s e100_bdconfig structure&n; *&t;reg_addr - The MII register that we are writing to&n; *&t;phy_addr - The MDI address of the Phy component.&n; *&t;data - The value that we are writing to the MII register.&n; *&n; * Returns:&n; *&t;NOTHING&n; */
r_void
DECL|function|e100_mdi_write
id|e100_mdi_write
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u32
id|reg_addr
comma
id|u32
id|phy_addr
comma
id|u16
id|data
)paren
(brace
r_int
id|e100_retry
suffix:semicolon
id|u32
id|temp_val
suffix:semicolon
id|temp_val
op_assign
(paren
(paren
(paren
id|u32
)paren
id|data
)paren
op_or
(paren
id|reg_addr
op_lshift
l_int|16
)paren
op_or
(paren
id|phy_addr
op_lshift
l_int|21
)paren
op_or
(paren
id|MDI_WRITE
op_lshift
l_int|26
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|temp_val
comma
op_amp
id|bdp-&gt;scb-&gt;scb_mdi_cntrl
)paren
suffix:semicolon
multiline_comment|/* wait 20usec before checking status */
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
multiline_comment|/* poll for the mdi write to complete */
id|e100_retry
op_assign
id|E100_CMD_WAIT
suffix:semicolon
r_while
c_loop
(paren
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
op_amp
id|bdp-&gt;scb-&gt;scb_mdi_cntrl
)paren
op_amp
id|MDI_PHY_READY
)paren
)paren
op_logical_and
(paren
id|e100_retry
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|e100_retry
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Procedure:&t;e100_mdi_read&n; *&n; * Description: This routine will read a value from the specified MII register&n; *&t;&t;of an external MDI compliant device (e.g. PHY 100), and return&n; *&t;&t;it to the calling routine.  The command will execute in polled&n; *&t;&t;mode.&n; *&n; * Arguments:&n; *&t;bdp - Ptr to this card&squot;s e100_bdconfig structure&n; *&t;reg_addr - The MII register that we are reading from&n; *&t;phy_addr - The MDI address of the Phy component.&n; *&n; * Results:&n; *&t;data - The value that we read from the MII register.&n; *&n; * Returns:&n; *&t;NOTHING&n; */
r_void
DECL|function|e100_mdi_read
id|e100_mdi_read
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u32
id|reg_addr
comma
id|u32
id|phy_addr
comma
id|u16
op_star
id|data
)paren
(brace
r_int
id|e100_retry
suffix:semicolon
id|u32
id|temp_val
suffix:semicolon
multiline_comment|/* Issue the read command to the MDI control register. */
id|temp_val
op_assign
(paren
(paren
id|reg_addr
op_lshift
l_int|16
)paren
op_or
(paren
id|phy_addr
op_lshift
l_int|21
)paren
op_or
(paren
id|MDI_READ
op_lshift
l_int|26
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|temp_val
comma
op_amp
id|bdp-&gt;scb-&gt;scb_mdi_cntrl
)paren
suffix:semicolon
multiline_comment|/* wait 20usec before checking status */
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
multiline_comment|/* poll for the mdi read to complete */
id|e100_retry
op_assign
id|E100_CMD_WAIT
suffix:semicolon
r_while
c_loop
(paren
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
op_amp
id|bdp-&gt;scb-&gt;scb_mdi_cntrl
)paren
op_amp
id|MDI_PHY_READY
)paren
)paren
op_logical_and
(paren
id|e100_retry
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|e100_retry
op_decrement
suffix:semicolon
)brace
singleline_comment|// return the lower word
op_star
id|data
op_assign
(paren
id|u16
)paren
id|readl
c_func
(paren
op_amp
id|bdp-&gt;scb-&gt;scb_mdi_cntrl
)paren
suffix:semicolon
)brace
r_static
r_int
r_char
id|__devinit
DECL|function|e100_phy_valid
id|e100_phy_valid
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
r_int
r_int
id|phy_address
)paren
(brace
id|u16
id|ctrl_reg
comma
id|stat_reg
suffix:semicolon
multiline_comment|/* Read the MDI control register */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMCR
comma
id|phy_address
comma
op_amp
id|ctrl_reg
)paren
suffix:semicolon
multiline_comment|/* Read the status register twice, bacause of sticky bits */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMSR
comma
id|phy_address
comma
op_amp
id|stat_reg
)paren
suffix:semicolon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMSR
comma
id|phy_address
comma
op_amp
id|stat_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ctrl_reg
op_eq
l_int|0xffff
)paren
op_logical_or
(paren
(paren
id|stat_reg
op_eq
l_int|0
)paren
op_logical_and
(paren
id|ctrl_reg
op_eq
l_int|0
)paren
)paren
)paren
r_return
l_bool|false
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
r_static
r_void
id|__devinit
DECL|function|e100_phy_address_detect
id|e100_phy_address_detect
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
r_char
id|valid_phy_found
op_assign
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|IS_NC3133
c_func
(paren
id|bdp
)paren
)paren
(brace
id|bdp-&gt;phy_addr
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e100_phy_valid
c_func
(paren
id|bdp
comma
id|PHY_DEFAULT_ADDRESS
)paren
)paren
(brace
id|bdp-&gt;phy_addr
op_assign
id|PHY_DEFAULT_ADDRESS
suffix:semicolon
id|valid_phy_found
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|addr
op_assign
id|MIN_PHY_ADDR
suffix:semicolon
id|addr
op_le
id|MAX_PHY_ADDR
suffix:semicolon
id|addr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|e100_phy_valid
c_func
(paren
id|bdp
comma
id|addr
)paren
)paren
(brace
id|bdp-&gt;phy_addr
op_assign
id|addr
suffix:semicolon
id|valid_phy_found
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|valid_phy_found
)paren
(brace
id|bdp-&gt;phy_addr
op_assign
id|PHY_ADDRESS_503
suffix:semicolon
)brace
)brace
r_static
r_void
id|__devinit
DECL|function|e100_phy_id_detect
id|e100_phy_id_detect
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|u16
id|low_id_reg
comma
id|high_id_reg
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;phy_addr
op_eq
id|PHY_ADDRESS_503
)paren
(brace
id|bdp-&gt;PhyId
op_assign
id|PHY_503
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bdp-&gt;flags
op_amp
id|IS_ICH
)paren
)paren
(brace
r_if
c_cond
(paren
id|bdp-&gt;rev_id
op_ge
id|D102_REV_ID
)paren
(brace
id|bdp-&gt;PhyId
op_assign
id|PHY_82562ET
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Read phy id from the MII register */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_PHYSID1
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|low_id_reg
)paren
suffix:semicolon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_PHYSID2
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|high_id_reg
)paren
suffix:semicolon
id|bdp-&gt;PhyId
op_assign
(paren
(paren
r_int
r_int
)paren
id|low_id_reg
op_or
(paren
(paren
r_int
r_int
)paren
id|high_id_reg
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
id|__devinit
DECL|function|e100_phy_isolate
id|e100_phy_isolate
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
r_int
id|phy_address
suffix:semicolon
id|u16
id|ctrl_reg
suffix:semicolon
multiline_comment|/* Go over all phy addresses. Deisolate the selected one, and isolate&n;&t; * all the rest */
r_for
c_loop
(paren
id|phy_address
op_assign
l_int|0
suffix:semicolon
id|phy_address
op_le
id|MAX_PHY_ADDR
suffix:semicolon
id|phy_address
op_increment
)paren
(brace
r_if
c_cond
(paren
id|phy_address
op_ne
id|bdp-&gt;phy_addr
)paren
(brace
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|MII_BMCR
comma
id|phy_address
comma
id|BMCR_ISOLATE
)paren
suffix:semicolon
)brace
r_else
(brace
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMCR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|ctrl_reg
)paren
suffix:semicolon
id|ctrl_reg
op_and_assign
op_complement
id|BMCR_ISOLATE
suffix:semicolon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|MII_BMCR
comma
id|bdp-&gt;phy_addr
comma
id|ctrl_reg
)paren
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
r_char
id|__devinit
DECL|function|e100_phy_specific_setup
id|e100_phy_specific_setup
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|u16
id|misc_reg
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;phy_addr
op_eq
id|PHY_ADDRESS_503
)paren
(brace
r_switch
c_cond
(paren
id|bdp-&gt;params.e100_speed_duplex
)paren
(brace
r_case
id|E100_AUTONEG
suffix:colon
multiline_comment|/* The adapter can&squot;t autoneg. so set to 10/HALF */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;503 serial component detected which &quot;
l_string|&quot;cannot autonegotiate&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;speed/duplex forced to 10Mbps / Half duplex&bslash;n&quot;
)paren
suffix:semicolon
id|bdp-&gt;params.e100_speed_duplex
op_assign
id|E100_SPEED_10_HALF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E100_SPEED_100_HALF
suffix:colon
r_case
id|E100_SPEED_100_FULL
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;503 serial component detected which does not &quot;
l_string|&quot;support 100Mbps&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Change the forced speed/duplex to a supported &quot;
l_string|&quot;setting&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_NC3133
c_func
(paren
id|bdp
)paren
)paren
(brace
id|u16
id|int_reg
suffix:semicolon
multiline_comment|/* enable 100BASE fiber interface */
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|MDI_NC3133_CONFIG_REG
comma
id|bdp-&gt;phy_addr
comma
id|MDI_NC3133_100FX_ENABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bdp-&gt;params.e100_speed_duplex
op_ne
id|E100_AUTONEG
)paren
op_logical_and
(paren
id|bdp-&gt;params.e100_speed_duplex
op_ne
id|E100_SPEED_100_FULL
)paren
)paren
(brace
multiline_comment|/* just inform user about 100 full */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NC3133 NIC can only run &quot;
l_string|&quot;at 100Mbps full duplex&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|bdp-&gt;params.e100_speed_duplex
op_assign
id|E100_SPEED_100_FULL
suffix:semicolon
multiline_comment|/* enable interrupts */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MDI_NC3133_INT_ENABLE_REG
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|int_reg
)paren
suffix:semicolon
id|int_reg
op_or_assign
id|MDI_NC3133_INT_ENABLE
suffix:semicolon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|MDI_NC3133_INT_ENABLE_REG
comma
id|bdp-&gt;phy_addr
comma
id|int_reg
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle the National TX */
r_if
c_cond
(paren
(paren
id|bdp-&gt;PhyId
op_amp
id|PHY_MODEL_REV_ID_MASK
)paren
op_eq
id|PHY_NSC_TX
)paren
(brace
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|NSC_CONG_CONTROL_REG
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|misc_reg
)paren
suffix:semicolon
id|misc_reg
op_or_assign
id|NSC_TX_CONG_TXREADY
suffix:semicolon
multiline_comment|/* disable the congestion control bit in the National Phy */
id|misc_reg
op_and_assign
op_complement
id|NSC_TX_CONG_ENABLE
suffix:semicolon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|NSC_CONG_CONTROL_REG
comma
id|bdp-&gt;phy_addr
comma
id|misc_reg
)paren
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/* &n; * Procedure:&t;e100_phy_fix_squelch&n; *&n; * Description:&n; *&t;Help find link on certain rare scenarios.&n; *&t;NOTE: This routine must be called once per watchdog,&n; *&t;      and *after* setting the current link state.&n; *&n; * Arguments:&n; *&t;bdp - Ptr to this card&squot;s e100_bdconfig structure&n; *&n; * Returns:&n; *&t;NOTHING&n; */
r_static
r_void
DECL|function|e100_phy_fix_squelch
id|e100_phy_fix_squelch
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_if
c_cond
(paren
(paren
id|bdp-&gt;PhyId
op_ne
id|PHY_82555_TX
)paren
op_logical_or
(paren
id|bdp-&gt;flags
op_amp
id|DF_SPEED_FORCED
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|netif_carrier_ok
c_func
(paren
id|bdp-&gt;device
)paren
)paren
(brace
r_switch
c_cond
(paren
id|bdp-&gt;PhyState
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_SPECIAL_CONTROL
comma
id|bdp-&gt;phy_addr
comma
l_int|0x0000
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_MDI_EQUALIZER_CSR
comma
id|bdp-&gt;phy_addr
comma
l_int|0x3000
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bdp-&gt;PhyState
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;PhyDelay
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|bdp-&gt;PhyDelay
op_decrement
)paren
(brace
r_switch
c_cond
(paren
id|bdp-&gt;PhyState
)paren
(brace
r_case
l_int|0
suffix:colon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_SPECIAL_CONTROL
comma
id|bdp-&gt;phy_addr
comma
id|EXTENDED_SQUELCH_BIT
)paren
suffix:semicolon
id|bdp-&gt;PhyState
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_SPECIAL_CONTROL
comma
id|bdp-&gt;phy_addr
comma
l_int|0x0000
)paren
suffix:semicolon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_MDI_EQUALIZER_CSR
comma
id|bdp-&gt;phy_addr
comma
l_int|0x2010
)paren
suffix:semicolon
id|bdp-&gt;PhyState
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_MDI_EQUALIZER_CSR
comma
id|bdp-&gt;phy_addr
comma
l_int|0x3000
)paren
suffix:semicolon
id|bdp-&gt;PhyState
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|MII_BMCR
comma
id|bdp-&gt;phy_addr
comma
id|BMCR_ANENABLE
op_or
id|BMCR_ANRESTART
)paren
suffix:semicolon
id|bdp-&gt;PhyDelay
op_assign
l_int|3
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Procedure:&t;e100_fix_polarity&n; *&n; * Description:&n; *&t;Fix for 82555 auto-polarity toggle problem. With a short cable &n; *&t;connecting an 82555 with an 840A link partner, if the medium is noisy,&n; *&t;the 82555 sometime thinks that the polarity might be wrong and so &n; *&t;toggles polarity. This happens repeatedly and results in a high bit &n; *&t;error rate.&n; *&t;NOTE: This happens only at 10 Mbps&n; *&n; * Arguments:&n; *&t;bdp - Ptr to this card&squot;s e100_bdconfig structure&n; *&n; * Returns:&n; *&t;NOTHING&n; */
r_static
r_void
id|__devinit
DECL|function|e100_fix_polarity
id|e100_fix_polarity
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|u16
id|status
suffix:semicolon
id|u16
id|errors
suffix:semicolon
id|u16
id|misc_reg
suffix:semicolon
r_int
id|speed
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bdp-&gt;PhyId
op_ne
id|PHY_82555_TX
)paren
op_logical_and
(paren
id|bdp-&gt;PhyId
op_ne
id|PHY_82562ET
)paren
op_logical_and
(paren
id|bdp-&gt;PhyId
op_ne
id|PHY_82562EM
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* If the user wants auto-polarity disabled, do only that and nothing *&n;&t; * else. * e100_autopolarity == 0 means disable --- we do just the&n;&t; * disabling * e100_autopolarity == 1 means enable  --- we do nothing at&n;&t; * all * e100_autopolarity &gt;= 2 means we do the workaround code. */
multiline_comment|/* Change for 82558 enhancement */
r_switch
c_cond
(paren
id|E100_AUTOPOLARITY
)paren
(brace
r_case
l_int|0
suffix:colon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|PHY_82555_SPECIAL_CONTROL
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|misc_reg
)paren
suffix:semicolon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_SPECIAL_CONTROL
comma
id|bdp-&gt;phy_addr
comma
(paren
id|u16
)paren
(paren
id|misc_reg
op_or
id|DISABLE_AUTO_POLARITY
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|PHY_82555_SPECIAL_CONTROL
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|misc_reg
)paren
suffix:semicolon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_SPECIAL_CONTROL
comma
id|bdp-&gt;phy_addr
comma
(paren
id|u16
)paren
(paren
id|misc_reg
op_amp
op_complement
id|DISABLE_AUTO_POLARITY
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* we do this only if link is up */
r_if
c_cond
(paren
op_logical_neg
id|netif_carrier_ok
c_func
(paren
id|bdp-&gt;device
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|PHY_82555_CSR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|status
)paren
suffix:semicolon
id|speed
op_assign
(paren
id|status
op_amp
id|PHY_82555_SPEED_BIT
)paren
ques
c_cond
l_int|100
suffix:colon
l_int|10
suffix:semicolon
multiline_comment|/* we need to do this only if speed is 10 */
r_if
c_cond
(paren
id|speed
op_ne
l_int|10
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* see if we have any end of frame errors */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|PHY_82555_EOF_COUNTER
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|errors
)paren
suffix:semicolon
multiline_comment|/* if non-zero, wait for 100 ms before reading again */
r_if
c_cond
(paren
id|errors
)paren
(brace
id|udelay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|PHY_82555_EOF_COUNTER
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|errors
)paren
suffix:semicolon
multiline_comment|/* if non-zero again, we disable polarity */
r_if
c_cond
(paren
id|errors
)paren
(brace
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|PHY_82555_SPECIAL_CONTROL
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|misc_reg
)paren
suffix:semicolon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_SPECIAL_CONTROL
comma
id|bdp-&gt;phy_addr
comma
(paren
id|u16
)paren
(paren
id|misc_reg
op_or
id|DISABLE_AUTO_POLARITY
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|errors
)paren
(brace
multiline_comment|/* it is safe to read the polarity now */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|PHY_82555_CSR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|status
)paren
suffix:semicolon
multiline_comment|/* if polarity is normal, disable polarity */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|PHY_82555_POLARITY_BIT
)paren
)paren
(brace
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|PHY_82555_SPECIAL_CONTROL
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|misc_reg
)paren
suffix:semicolon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_SPECIAL_CONTROL
comma
id|bdp-&gt;phy_addr
comma
(paren
id|u16
)paren
(paren
id|misc_reg
op_or
id|DISABLE_AUTO_POLARITY
)paren
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Procedure:&t;e100_find_speed_duplex&n; *&n; * Description: This routine will figure out what line speed and duplex mode&n; *&t;&t;the PHY is currently using.&n; *&n; * Arguments:&n; *&t;bdp - Ptr to this card&squot;s e100_bdconfig structure&n; *&n; * Returns:&n; *&t;NOTHING&n; */
r_static
r_void
DECL|function|e100_find_speed_duplex
id|e100_find_speed_duplex
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
r_int
id|PhyId
suffix:semicolon
id|u16
id|stat_reg
comma
id|misc_reg
suffix:semicolon
id|u16
id|ad_reg
comma
id|lp_ad_reg
suffix:semicolon
id|PhyId
op_assign
id|bdp-&gt;PhyId
op_amp
id|PHY_MODEL_REV_ID_MASK
suffix:semicolon
multiline_comment|/* First we should check to see if we have link */
multiline_comment|/* If we don&squot;t have a link no reason to print a speed and duplex */
r_if
c_cond
(paren
op_logical_neg
id|e100_update_link_state
c_func
(paren
id|bdp
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bdp-&gt;flags
op_amp
id|DF_SPEED_FORCED
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* On the 82559 and later controllers, speed/duplex is part of the *&n;&t; * SCB. So, we save an mdi_read and get these from the SCB. * */
r_if
c_cond
(paren
id|bdp-&gt;rev_id
op_ge
id|D101MA_REV_ID
)paren
(brace
multiline_comment|/* Read speed */
r_if
c_cond
(paren
id|readb
c_func
(paren
op_amp
id|bdp-&gt;scb-&gt;scb_ext.d101m_scb.scb_gen_stat
)paren
op_amp
id|BIT_1
)paren
id|bdp-&gt;cur_line_speed
op_assign
l_int|100
suffix:semicolon
r_else
id|bdp-&gt;cur_line_speed
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* Read duplex */
r_if
c_cond
(paren
id|readb
c_func
(paren
op_amp
id|bdp-&gt;scb-&gt;scb_ext.d101m_scb.scb_gen_stat
)paren
op_amp
id|BIT_2
)paren
id|bdp-&gt;cur_dplx_mode
op_assign
id|FULL_DUPLEX
suffix:semicolon
r_else
id|bdp-&gt;cur_dplx_mode
op_assign
id|HALF_DUPLEX
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If this is a Phy 100, then read bits 1 and 0 of extended register 0,&n;&t; * to get the current speed and duplex settings. */
r_if
c_cond
(paren
(paren
id|PhyId
op_eq
id|PHY_100_A
)paren
op_logical_or
(paren
id|PhyId
op_eq
id|PHY_100_C
)paren
op_logical_or
(paren
id|PhyId
op_eq
id|PHY_82555_TX
)paren
)paren
(brace
multiline_comment|/* Read Phy 100 extended register 0 */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|EXTENDED_REG_0
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|misc_reg
)paren
suffix:semicolon
multiline_comment|/* Get current speed setting */
r_if
c_cond
(paren
id|misc_reg
op_amp
id|PHY_100_ER0_SPEED_INDIC
)paren
id|bdp-&gt;cur_line_speed
op_assign
l_int|100
suffix:semicolon
r_else
id|bdp-&gt;cur_line_speed
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* Get current duplex setting -- FDX enabled if bit is set */
r_if
c_cond
(paren
id|misc_reg
op_amp
id|PHY_100_ER0_FDX_INDIC
)paren
id|bdp-&gt;cur_dplx_mode
op_assign
id|FULL_DUPLEX
suffix:semicolon
r_else
id|bdp-&gt;cur_dplx_mode
op_assign
id|HALF_DUPLEX
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* See if link partner is capable of Auto-Negotiation (bit 0, reg 6) */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_EXPANSION
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|misc_reg
)paren
suffix:semicolon
multiline_comment|/* See if Auto-Negotiation was complete (bit 5, reg 1) */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMSR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|stat_reg
)paren
suffix:semicolon
multiline_comment|/* If a True NWAY connection was made, then we can detect speed/dplx&n;&t; * by ANDing our adapter&squot;s advertised abilities with our link partner&squot;s&n;&t; * advertised ablilities, and then assuming that the highest common&n;&t; * denominator was chosed by NWAY. */
r_if
c_cond
(paren
(paren
id|misc_reg
op_amp
id|EXPANSION_NWAY
)paren
op_logical_and
(paren
id|stat_reg
op_amp
id|BMSR_ANEGCOMPLETE
)paren
)paren
(brace
multiline_comment|/* Read our advertisement register */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_ADVERTISE
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|ad_reg
)paren
suffix:semicolon
multiline_comment|/* Read our link partner&squot;s advertisement register */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_LPA
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|lp_ad_reg
)paren
suffix:semicolon
multiline_comment|/* AND the two advertisement registers together, and get rid&n;&t;&t; * of any extraneous bits. */
id|ad_reg
op_and_assign
(paren
id|lp_ad_reg
op_amp
id|NWAY_LP_ABILITY
)paren
suffix:semicolon
multiline_comment|/* Get speed setting */
r_if
c_cond
(paren
id|ad_reg
op_amp
(paren
id|ADVERTISE_100HALF
op_or
id|ADVERTISE_100FULL
op_or
id|ADVERTISE_100BASE4
)paren
)paren
id|bdp-&gt;cur_line_speed
op_assign
l_int|100
suffix:semicolon
r_else
id|bdp-&gt;cur_line_speed
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* Get duplex setting -- use priority resolution algorithm */
r_if
c_cond
(paren
id|ad_reg
op_amp
id|ADVERTISE_100BASE4
)paren
(brace
id|bdp-&gt;cur_dplx_mode
op_assign
id|HALF_DUPLEX
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ad_reg
op_amp
id|ADVERTISE_100FULL
)paren
(brace
id|bdp-&gt;cur_dplx_mode
op_assign
id|FULL_DUPLEX
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ad_reg
op_amp
id|ADVERTISE_100HALF
)paren
(brace
id|bdp-&gt;cur_dplx_mode
op_assign
id|HALF_DUPLEX
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ad_reg
op_amp
id|ADVERTISE_10FULL
)paren
(brace
id|bdp-&gt;cur_dplx_mode
op_assign
id|FULL_DUPLEX
suffix:semicolon
)brace
r_else
(brace
id|bdp-&gt;cur_dplx_mode
op_assign
id|HALF_DUPLEX
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* If we are connected to a dumb (non-NWAY) repeater or hub, and the&n;&t; * line speed was determined automatically by parallel detection, then&n;&t; * we have no way of knowing exactly what speed the PHY is set to&n;&t; * unless that PHY has a propietary register which indicates speed in&n;&t; * this situation. The NSC TX PHY does have such a register. Also,&n;&t; * since NWAY didn&squot;t establish the connection, the duplex setting&n;&t; * should HALF duplex. */
id|bdp-&gt;cur_dplx_mode
op_assign
id|HALF_DUPLEX
suffix:semicolon
r_if
c_cond
(paren
id|PhyId
op_eq
id|PHY_NSC_TX
)paren
(brace
multiline_comment|/* Read register 25 to get the SPEED_10 bit */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|NSC_SPEED_IND_REG
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|misc_reg
)paren
suffix:semicolon
multiline_comment|/* If bit 6 was set then we&squot;re at 10Mbps */
r_if
c_cond
(paren
id|misc_reg
op_amp
id|NSC_TX_SPD_INDC_SPEED
)paren
id|bdp-&gt;cur_line_speed
op_assign
l_int|10
suffix:semicolon
r_else
id|bdp-&gt;cur_line_speed
op_assign
l_int|100
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If we don&squot;t know the line speed, default to 10Mbps */
id|bdp-&gt;cur_line_speed
op_assign
l_int|10
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Procedure: e100_force_speed_duplex&n; *&n; * Description: This routine forces line speed and duplex mode of the&n; * adapter based on the values the user has set in e100.c.&n; *&n; * Arguments:  bdp - Pointer to the e100_private structure for the board&n; *&n; * Returns: void&n; *&n; */
r_static
r_void
DECL|function|e100_force_speed_duplex
id|e100_force_speed_duplex
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|u16
id|control
suffix:semicolon
r_int
id|neg_timeout
op_assign
l_int|2
op_star
id|HZ
suffix:semicolon
singleline_comment|//2 sec in jiffies
id|bdp-&gt;flags
op_or_assign
id|DF_SPEED_FORCED
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMCR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|control
)paren
suffix:semicolon
id|control
op_and_assign
op_complement
id|BMCR_ANENABLE
suffix:semicolon
multiline_comment|/* Check e100.c values */
r_switch
c_cond
(paren
id|bdp-&gt;params.e100_speed_duplex
)paren
(brace
r_case
id|E100_SPEED_10_HALF
suffix:colon
id|control
op_and_assign
op_complement
id|BMCR_SPEED100
suffix:semicolon
id|control
op_and_assign
op_complement
id|BMCR_FULLDPLX
suffix:semicolon
id|bdp-&gt;cur_line_speed
op_assign
l_int|10
suffix:semicolon
id|bdp-&gt;cur_dplx_mode
op_assign
id|HALF_DUPLEX
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E100_SPEED_10_FULL
suffix:colon
id|control
op_and_assign
op_complement
id|BMCR_SPEED100
suffix:semicolon
id|control
op_or_assign
id|BMCR_FULLDPLX
suffix:semicolon
id|bdp-&gt;cur_line_speed
op_assign
l_int|10
suffix:semicolon
id|bdp-&gt;cur_dplx_mode
op_assign
id|FULL_DUPLEX
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E100_SPEED_100_HALF
suffix:colon
id|control
op_or_assign
id|BMCR_SPEED100
suffix:semicolon
id|control
op_and_assign
op_complement
id|BMCR_FULLDPLX
suffix:semicolon
id|bdp-&gt;cur_line_speed
op_assign
l_int|100
suffix:semicolon
id|bdp-&gt;cur_dplx_mode
op_assign
id|HALF_DUPLEX
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E100_SPEED_100_FULL
suffix:colon
id|control
op_or_assign
id|BMCR_SPEED100
suffix:semicolon
id|control
op_or_assign
id|BMCR_FULLDPLX
suffix:semicolon
id|bdp-&gt;cur_line_speed
op_assign
l_int|100
suffix:semicolon
id|bdp-&gt;cur_dplx_mode
op_assign
id|FULL_DUPLEX
suffix:semicolon
r_break
suffix:semicolon
)brace
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|MII_BMCR
comma
id|bdp-&gt;phy_addr
comma
id|control
)paren
suffix:semicolon
multiline_comment|/* loop must run at least once */
r_do
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|SLEEP_TIME
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e100_update_link_state
c_func
(paren
id|bdp
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|neg_timeout
op_sub_assign
id|SLEEP_TIME
suffix:semicolon
)brace
r_while
c_loop
(paren
id|neg_timeout
OG
l_int|0
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Procedure: e100_set_fc&n; *&n; * Description: Checks the link&squot;s capability for flow control.&n; * &n; * Arguments:  bdp - Pointer to the e100_private structure for the board&n; *&t;&t;    &n; * Returns: void&n; *&n; */
r_static
r_void
DECL|function|e100_set_fc
id|e100_set_fc
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|u16
id|ad_reg
suffix:semicolon
id|u16
id|lp_ad_reg
suffix:semicolon
id|u16
id|exp_reg
suffix:semicolon
multiline_comment|/* no flow control for 82557, forced links or half duplex */
r_if
c_cond
(paren
op_logical_neg
id|netif_carrier_ok
c_func
(paren
id|bdp-&gt;device
)paren
op_logical_or
(paren
id|bdp-&gt;flags
op_amp
id|DF_SPEED_FORCED
)paren
op_logical_or
(paren
id|bdp-&gt;cur_dplx_mode
op_eq
id|HALF_DUPLEX
)paren
op_logical_or
op_logical_neg
(paren
id|bdp-&gt;flags
op_amp
id|IS_BACHELOR
)paren
)paren
(brace
id|bdp-&gt;flags
op_and_assign
op_complement
id|DF_LINK_FC_CAP
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* See if link partner is capable of Auto-Negotiation (bit 0, reg 6) */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_EXPANSION
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|exp_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp_reg
op_amp
id|EXPANSION_NWAY
)paren
(brace
multiline_comment|/* Read our advertisement register */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_ADVERTISE
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|ad_reg
)paren
suffix:semicolon
multiline_comment|/* Read our link partner&squot;s advertisement register */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_LPA
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|lp_ad_reg
)paren
suffix:semicolon
id|ad_reg
op_and_assign
id|lp_ad_reg
suffix:semicolon
multiline_comment|/* AND the 2 ad registers */
r_if
c_cond
(paren
id|ad_reg
op_amp
id|NWAY_AD_FC_SUPPORTED
)paren
id|bdp-&gt;flags
op_or_assign
id|DF_LINK_FC_CAP
suffix:semicolon
r_else
id|bdp-&gt;flags
op_and_assign
op_complement
id|DF_LINK_FC_CAP
suffix:semicolon
)brace
r_else
(brace
id|bdp-&gt;flags
op_and_assign
op_complement
id|DF_LINK_FC_CAP
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Procedure: e100_phy_check&n; * &n; * Arguments:  bdp - Pointer to the e100_private structure for the board&n; *&n; * Returns: true if link state was changed&n; *&t;   false otherwise&n; *&n; */
r_int
r_char
DECL|function|e100_phy_check
id|e100_phy_check
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
r_char
id|old_link
suffix:semicolon
r_int
r_char
id|changed
op_assign
l_bool|false
suffix:semicolon
id|old_link
op_assign
id|netif_carrier_ok
c_func
(paren
id|bdp-&gt;device
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|e100_find_speed_duplex
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_link
op_logical_and
id|netif_carrier_ok
c_func
(paren
id|bdp-&gt;device
)paren
)paren
(brace
id|e100_set_fc
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|changed
op_assign
l_bool|true
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_link
op_logical_and
op_logical_neg
id|netif_carrier_ok
c_func
(paren
id|bdp-&gt;device
)paren
)paren
(brace
multiline_comment|/* reset the zero lock state */
id|bdp-&gt;zlock_state
op_assign
id|ZLOCK_INITIAL
suffix:semicolon
singleline_comment|// set auto lock for phy auto-negotiation on link up
r_if
c_cond
(paren
(paren
id|bdp-&gt;PhyId
op_amp
id|PHY_MODEL_REV_ID_MASK
)paren
op_eq
id|PHY_82555_TX
)paren
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_MDI_EQUALIZER_CSR
comma
id|bdp-&gt;phy_addr
comma
l_int|0
)paren
suffix:semicolon
id|changed
op_assign
l_bool|true
suffix:semicolon
)brace
id|e100_phy_fix_squelch
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|e100_handle_zlock
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_return
id|changed
suffix:semicolon
)brace
multiline_comment|/* &n; * Procedure:&t;e100_auto_neg&n; *&n; * Description: This routine will start autonegotiation and wait&n; *&t;&t;     for it to complete&n; *&n; * Arguments:&n; *&t;bdp&t;&t;- pointer to this card&squot;s e100_bdconfig structure&n; *&t;force_restart&t;- defines if autoneg should be restarted even if it&n; *&t;&t;&t;has been completed before&n; * Returns:&n; *&t;NOTHING&n; */
r_static
r_void
DECL|function|e100_auto_neg
id|e100_auto_neg
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
r_int
r_char
id|force_restart
)paren
(brace
id|u16
id|stat_reg
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|bdp-&gt;flags
op_and_assign
op_complement
id|DF_SPEED_FORCED
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMSR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|stat_reg
)paren
suffix:semicolon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMSR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|stat_reg
)paren
suffix:semicolon
multiline_comment|/* if we are capable of performing autoneg then we restart if needed */
r_if
c_cond
(paren
(paren
id|stat_reg
op_ne
l_int|0xFFFF
)paren
op_logical_and
(paren
id|stat_reg
op_amp
id|BMSR_ANEGCAPABLE
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|force_restart
)paren
op_logical_and
(paren
id|stat_reg
op_amp
id|BMSR_ANEGCOMPLETE
)paren
)paren
(brace
r_goto
m_exit
suffix:semicolon
)brace
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|MII_BMCR
comma
id|bdp-&gt;phy_addr
comma
id|BMCR_ANENABLE
op_or
id|BMCR_ANRESTART
)paren
suffix:semicolon
multiline_comment|/* wait for autoneg to complete (up to 3 seconds) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|60
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* now re-read the value. Sticky so read twice */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMSR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|stat_reg
)paren
suffix:semicolon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMSR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|stat_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat_reg
op_amp
id|BMSR_ANEGCOMPLETE
)paren
r_goto
m_exit
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|SLEEP_TIME
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
)brace
)brace
m_exit
suffix:colon
id|e100_find_speed_duplex
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|e100_phy_set_speed_duplex
id|e100_phy_set_speed_duplex
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
r_int
r_char
id|force_restart
)paren
(brace
r_if
c_cond
(paren
id|bdp-&gt;params.e100_speed_duplex
op_eq
id|E100_AUTONEG
)paren
(brace
id|e100_auto_neg
c_func
(paren
id|bdp
comma
id|force_restart
)paren
suffix:semicolon
)brace
r_else
(brace
id|e100_force_speed_duplex
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
id|e100_set_fc
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
r_void
id|__devexit
DECL|function|e100_phy_reset
id|e100_phy_reset
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|u16
id|ctrl_reg
suffix:semicolon
id|ctrl_reg
op_assign
id|BMCR_ANENABLE
op_or
id|BMCR_ANRESTART
op_or
id|BMCR_RESET
suffix:semicolon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|MII_BMCR
comma
id|bdp-&gt;phy_addr
comma
id|ctrl_reg
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_int
r_char
id|__devinit
DECL|function|e100_phy_init
id|e100_phy_init
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|e100_phy_address_detect
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|e100_phy_isolate
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|e100_phy_id_detect
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_phy_specific_setup
c_func
(paren
id|bdp
)paren
)paren
r_return
l_bool|false
suffix:semicolon
id|bdp-&gt;PhyState
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;PhyDelay
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;zlock_state
op_assign
id|ZLOCK_INITIAL
suffix:semicolon
id|e100_phy_set_speed_duplex
c_func
(paren
id|bdp
comma
l_bool|false
)paren
suffix:semicolon
id|e100_fix_polarity
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/* &n; * Procedure: e100_get_link_state&n; * &n; * Description: This routine checks the link status of the adapter&n; *&n; * Arguments:  bdp - Pointer to the e100_private structure for the board&n; *&t;&t;    &n; *&n; * Returns: true - If a link is found&n; *&t;&t;false - If there is no link&n; *&n; */
r_int
r_char
DECL|function|e100_get_link_state
id|e100_get_link_state
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
r_char
id|link
op_assign
l_bool|false
suffix:semicolon
id|u16
id|status
suffix:semicolon
multiline_comment|/* Check link status */
multiline_comment|/* If the controller is a 82559 or later one, link status is available&n;&t; * from the CSR. This avoids the mdi_read. */
r_if
c_cond
(paren
id|bdp-&gt;rev_id
op_ge
id|D101MA_REV_ID
)paren
(brace
r_if
c_cond
(paren
id|readb
c_func
(paren
op_amp
id|bdp-&gt;scb-&gt;scb_ext.d101m_scb.scb_gen_stat
)paren
op_amp
id|BIT_0
)paren
(brace
id|link
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
(brace
id|link
op_assign
l_bool|false
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Read the status register twice because of sticky bits */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMSR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|status
)paren
suffix:semicolon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMSR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|BMSR_LSTATUS
)paren
(brace
id|link
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
(brace
id|link
op_assign
l_bool|false
suffix:semicolon
)brace
)brace
r_return
id|link
suffix:semicolon
)brace
multiline_comment|/* &n; * Procedure: e100_update_link_state&n; * &n; * Description: This routine updates the link status of the adapter&n; *&n; * Arguments:  bdp - Pointer to the e100_private structure for the board&n; *&t;&t;    &n; *&n; * Returns: true - If a link is found&n; *&t;&t;false - If there is no link&n; *&n; */
r_int
r_char
DECL|function|e100_update_link_state
id|e100_update_link_state
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
r_char
id|link
suffix:semicolon
id|link
op_assign
id|e100_get_link_state
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|link
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|netif_carrier_ok
c_func
(paren
id|bdp-&gt;device
)paren
)paren
id|netif_carrier_on
c_func
(paren
id|bdp-&gt;device
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|netif_carrier_ok
c_func
(paren
id|bdp-&gt;device
)paren
)paren
id|netif_carrier_off
c_func
(paren
id|bdp-&gt;device
)paren
suffix:semicolon
)brace
r_return
id|link
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&bslash;&n; **&n; ** PROC NAME:     e100_handle_zlock&n; **    This function manages a state machine that controls&n; **    the driver&squot;s zero locking algorithm.&n; **    This function is called by e100_watchdog() every ~2 second.&n; ** States:&n; **    The current link handling state is stored in &n; **    bdp-&gt;zlock_state, and is one of:&n; **    ZLOCK_INITIAL, ZLOCK_READING, ZLOCK_SLEEPING&n; **    Detailed description of the states and the transitions&n; **    between states is found below.&n; **    Note that any time the link is down / there is a reset&n; **    state will be changed outside this function to ZLOCK_INITIAL&n; ** Algorithm:&n; **    1. If link is up &amp; 100 Mbps continue else stay in #1:&n; **    2. Set &squot;auto lock&squot;&n; **    3. Read &amp; Store 100 times &squot;Zero&squot; locked in 1 sec interval&n; **    4. If max zero read &gt;= 0xB continue else goto 1&n; **    5. Set most popular &squot;Zero&squot; read in #3&n; **    6. Sleep 5 minutes&n; **    7. Read number of errors, if it is &gt; 300 goto 2 else goto 6&n; ** Data Structures (in DRIVER_DATA):&n; **    zlock_state           - current state of the algorithm&n; **    zlock_read_cnt        - counts number of reads (up to 100)&n; **    zlock_read_data[i]    - counts number of times &squot;Zero&squot; read was i, 0 &lt;= i &lt;= 15&n; **    zlock_sleep_cnt       - keeps track of &quot;sleep&quot; time (up to 300 secs = 5 minutes)&n; **                                &n; ** Parameters:    DRIVER_DATA    *bdp&n; **&n; **                bdp  - Pointer to HSM&squot;s adapter data space&n; **&n; ** Return Value:  NONE&n; **&n; ** See Also:      e100_watchdog()&n; **&n; &bslash;**************************************************************************/
r_void
DECL|function|e100_handle_zlock
id|e100_handle_zlock
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|u16
id|pos
suffix:semicolon
id|u16
id|eq_reg
suffix:semicolon
id|u16
id|err_cnt
suffix:semicolon
id|u8
id|mpz
suffix:semicolon
multiline_comment|/* Most Popular Zero */
r_switch
c_cond
(paren
id|bdp-&gt;zlock_state
)paren
(brace
r_case
id|ZLOCK_INITIAL
suffix:colon
r_if
c_cond
(paren
(paren
(paren
id|u8
)paren
id|bdp-&gt;rev_id
op_le
id|D102_REV_ID
)paren
op_logical_or
op_logical_neg
(paren
id|bdp-&gt;cur_line_speed
op_eq
l_int|100
)paren
op_logical_or
op_logical_neg
id|netif_carrier_ok
c_func
(paren
id|bdp-&gt;device
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* initialize hw and sw and start reading */
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_MDI_EQUALIZER_CSR
comma
id|bdp-&gt;phy_addr
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset read counters: */
id|bdp-&gt;zlock_read_cnt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
l_int|16
suffix:semicolon
id|pos
op_increment
)paren
id|bdp-&gt;zlock_read_data
(braket
id|pos
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* start reading in the next call back: */
id|bdp-&gt;zlock_state
op_assign
id|ZLOCK_READING
suffix:semicolon
multiline_comment|/* FALL THROUGH !! */
r_case
id|ZLOCK_READING
suffix:colon
multiline_comment|/* state: reading (100 times) zero locked in 1 sec interval&n;&t;&t; * prev states: ZLOCK_INITIAL&n;&t;&t; * next states: ZLOCK_INITIAL, ZLOCK_SLEEPING */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|PHY_82555_MDI_EQUALIZER_CSR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|eq_reg
)paren
suffix:semicolon
id|pos
op_assign
(paren
id|eq_reg
op_amp
id|ZLOCK_ZERO_MASK
)paren
op_rshift
l_int|4
suffix:semicolon
id|bdp-&gt;zlock_read_data
(braket
id|pos
)braket
op_increment
suffix:semicolon
id|bdp-&gt;zlock_read_cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;zlock_read_cnt
op_eq
id|ZLOCK_MAX_READS
)paren
(brace
multiline_comment|/* check if we read a &squot;Zero&squot; value of 0xB or greater */
r_if
c_cond
(paren
(paren
id|bdp-&gt;zlock_read_data
(braket
l_int|0xB
)braket
)paren
op_logical_or
(paren
id|bdp-&gt;zlock_read_data
(braket
l_int|0xC
)braket
)paren
op_logical_or
(paren
id|bdp-&gt;zlock_read_data
(braket
l_int|0xD
)braket
)paren
op_logical_or
(paren
id|bdp-&gt;zlock_read_data
(braket
l_int|0xE
)braket
)paren
op_logical_or
(paren
id|bdp-&gt;zlock_read_data
(braket
l_int|0xF
)braket
)paren
)paren
(brace
multiline_comment|/* we&squot;ve read &squot;Zero&squot; value of 0xB or greater,&n;&t;&t;&t;&t; * find most popular &squot;Zero&squot; value and lock it */
id|mpz
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* this loop finds the most popular &squot;Zero&squot;: */
r_for
c_loop
(paren
id|pos
op_assign
l_int|1
suffix:semicolon
id|pos
OL
l_int|16
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bdp-&gt;zlock_read_data
(braket
id|pos
)braket
OG
id|bdp-&gt;zlock_read_data
(braket
id|mpz
)braket
)paren
id|mpz
op_assign
id|pos
suffix:semicolon
)brace
multiline_comment|/* now lock the most popular &squot;Zero&squot;: */
id|eq_reg
op_assign
(paren
id|ZLOCK_SET_ZERO
op_or
id|mpz
)paren
suffix:semicolon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|PHY_82555_MDI_EQUALIZER_CSR
comma
id|bdp-&gt;phy_addr
comma
id|eq_reg
)paren
suffix:semicolon
multiline_comment|/* sleep for 5 minutes: */
id|bdp-&gt;zlock_sleep_cnt
op_assign
id|jiffies
suffix:semicolon
id|bdp-&gt;zlock_state
op_assign
id|ZLOCK_SLEEPING
suffix:semicolon
multiline_comment|/* we will be reading the # of errors after 5&n;&t;&t;&t;&t; * minutes, so we need to reset the error&n;&t;&t;&t;&t; * counters - these registers are self clearing&n;&t;&t;&t;&t; * on read, so read them */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|PHY_82555_SYMBOL_ERR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|err_cnt
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we did not read a &squot;Zero&squot; value of 0xB or&n;&t;&t;&t;&t; * above. go back to the start */
id|bdp-&gt;zlock_state
op_assign
id|ZLOCK_INITIAL
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|ZLOCK_SLEEPING
suffix:colon
multiline_comment|/* state: sleeping for 5 minutes&n;&t;&t; * prev states: ZLOCK_READING&n;&t;&t; * next states: ZLOCK_READING, ZLOCK_SLEEPING */
multiline_comment|/* if 5 minutes have passed: */
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|bdp-&gt;zlock_sleep_cnt
)paren
op_ge
id|ZLOCK_MAX_SLEEP
)paren
(brace
multiline_comment|/* read and sum up the number of errors:  */
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|PHY_82555_SYMBOL_ERR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|err_cnt
)paren
suffix:semicolon
multiline_comment|/* if we&squot;ve more than 300 errors (this number was&n;&t;&t;&t; * calculated according to the spec max allowed errors&n;&t;&t;&t; * (80 errors per 1 million frames) for 5 minutes in&n;&t;&t;&t; * 100 Mbps (or the user specified max BER number) */
r_if
c_cond
(paren
id|err_cnt
OG
id|bdp-&gt;params.ber
)paren
(brace
multiline_comment|/* start again in the next callback: */
id|bdp-&gt;zlock_state
op_assign
id|ZLOCK_INITIAL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we don&squot;t have more errors than allowed,&n;&t;&t;&t;&t; * sleep for 5 minutes */
id|bdp-&gt;zlock_sleep_cnt
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
eof
