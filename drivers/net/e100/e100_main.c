multiline_comment|/*******************************************************************************&n;&n;This software program is available to you under a choice of one of two &n;licenses. You may choose to be licensed under either the GNU General Public &n;License 2.0, June 1991, available at http://www.fsf.org/copyleft/gpl.html, &n;or the Intel BSD + Patent License, the text of which follows:&n;&n;Recipient has requested a license and Intel Corporation (&quot;Intel&quot;) is willing&n;to grant a license for the software entitled Linux Base Driver for the &n;Intel(R) PRO/100 Family of Adapters (e100) (the &quot;Software&quot;) being provided &n;by Intel Corporation. The following definitions apply to this license:&n;&n;&quot;Licensed Patents&quot; means patent claims licensable by Intel Corporation which &n;are necessarily infringed by the use of sale of the Software alone or when &n;combined with the operating system referred to below.&n;&n;&quot;Recipient&quot; means the party to whom Intel delivers this Software.&n;&n;&quot;Licensee&quot; means Recipient and those third parties that receive a license to &n;any operating system available under the GNU General Public License 2.0 or &n;later.&n;&n;Copyright (c) 1999 - 2002 Intel Corporation.&n;All rights reserved.&n;&n;The license is provided to Recipient and Recipient&squot;s Licensees under the &n;following terms.&n;&n;Redistribution and use in source and binary forms of the Software, with or &n;without modification, are permitted provided that the following conditions &n;are met:&n;&n;Redistributions of source code of the Software may retain the above &n;copyright notice, this list of conditions and the following disclaimer.&n;&n;Redistributions in binary form of the Software may reproduce the above &n;copyright notice, this list of conditions and the following disclaimer in &n;the documentation and/or materials provided with the distribution.&n;&n;Neither the name of Intel Corporation nor the names of its contributors &n;shall be used to endorse or promote products derived from this Software &n;without specific prior written permission.&n;&n;Intel hereby grants Recipient and Licensees a non-exclusive, worldwide, &n;royalty-free patent license under Licensed Patents to make, use, sell, offer &n;to sell, import and otherwise transfer the Software, if any, in source code &n;and object code form. This license shall include changes to the Software &n;that are error corrections or other minor changes to the Software that do &n;not add functionality or features when the Software is incorporated in any &n;version of an operating system that has been distributed under the GNU &n;General Public License 2.0 or later. This patent license shall apply to the &n;combination of the Software and any operating system licensed under the GNU &n;General Public License 2.0 or later if, at the time Intel provides the &n;Software to Recipient, such addition of the Software to the then publicly &n;available versions of such operating systems available under the GNU General &n;Public License 2.0 or later (whether in gold, beta or alpha form) causes &n;such combination to be covered by the Licensed Patents. The patent license &n;shall not apply to any other combinations which include the Software. NO &n;hardware per se is licensed hereunder.&n;&n;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; &n;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE &n;IMPLIED WARRANTIES OF MECHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE &n;ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR IT CONTRIBUTORS BE LIABLE FOR ANY &n;DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES &n;(INCLUDING, BUT NOT LIMITED, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; &n;ANY LOSS OF USE; DATA, OR PROFITS; OR BUSINESS INTERUPTION) HOWEVER CAUSED &n;AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR &n;TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE &n;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n;*******************************************************************************&n;&n;Portions (C) 2002 Red Hat, Inc. under the terms of the GNU GPL v2.&n;&n;*******************************************************************************/
multiline_comment|/**********************************************************************&n;*                                                                     *&n;* INTEL CORPORATION                                                   *&n;*                                                                     *&n;* This software is supplied under the terms of the license included   *&n;* above.  All use of this driver must be in accordance with the terms *&n;* of that license.                                                    *&n;*                                                                     *&n;* Module Name:  e100_main.c                                           *&n;*                                                                     *&n;* Abstract:     Functions for the driver entry points like load,      *&n;*               unload, open and close. All board specific calls made *&n;*               by the network interface section of the driver.       *&n;*                                                                     *&n;* Environment:  This file is intended to be specific to the Linux     *&n;*               operating system.                                     *&n;*                                                                     *&n;**********************************************************************/
DECL|macro|__NO_VERSION__
macro_line|#undef __NO_VERSION__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/udp.h&gt;
macro_line|#include &quot;e100.h&quot;
macro_line|#include &quot;e100_ucode.h&quot;
macro_line|#include &quot;e100_config.h&quot;
macro_line|#include &quot;e100_phy.h&quot;
macro_line|#include &quot;e100_vendor.h&quot;
macro_line|#ifndef CONFIG_PROC_FS
DECL|macro|E100_CONFIG_PROC_FS
macro_line|#undef E100_CONFIG_PROC_FS
macro_line|#endif
macro_line|#ifdef E100_CONFIG_PROC_FS
r_extern
r_int
id|e100_create_proc_subdir
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_extern
r_void
id|e100_remove_proc_subdir
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
macro_line|#else
DECL|macro|e100_create_proc_subdir
mdefine_line|#define e100_create_proc_subdir(X) 0
DECL|macro|e100_remove_proc_subdir
mdefine_line|#define e100_remove_proc_subdir(X) do {} while(0)
macro_line|#endif
macro_line|#ifdef SIOCETHTOOL
DECL|macro|E100_ETHTOOL_IOCTL
mdefine_line|#define E100_ETHTOOL_IOCTL
macro_line|#endif
macro_line|#ifdef E100_ETHTOOL_IOCTL
r_static
r_int
id|e100_do_ethtool_ioctl
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_get_speed_duplex_caps
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_int
id|e100_ethtool_get_settings
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
)paren
suffix:semicolon
r_static
r_int
id|e100_ethtool_set_settings
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
)paren
suffix:semicolon
macro_line|#ifdef ETHTOOL_GDRVINFO
r_static
r_int
id|e100_ethtool_get_drvinfo
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ETHTOOL_GEEPROM
r_static
r_int
id|e100_ethtool_eeprom
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
)paren
suffix:semicolon
DECL|macro|E100_EEPROM_MAGIC
mdefine_line|#define E100_EEPROM_MAGIC 0x1234
macro_line|#endif
macro_line|#ifdef ETHTOOL_GLINK
r_static
r_int
id|e100_ethtool_glink
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ETHTOOL_NWAY_RST
r_static
r_int
id|e100_ethtool_nway_rst
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ETHTOOL_GWOL
r_static
r_int
id|e100_ethtool_wol
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
)paren
suffix:semicolon
r_static
r_int
r_char
id|e100_setup_filter
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
suffix:semicolon
r_static
r_void
id|e100_do_wol
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
comma
r_struct
id|e100_private
op_star
id|bdp
)paren
suffix:semicolon
r_static
id|u16
id|e100_get_ip_lbytes
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_extern
r_void
id|e100_config_wol
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ETHTOOL_TEST
r_extern
id|u32
id|e100_run_diag
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u64
op_star
id|test_info
comma
id|u32
id|flags
)paren
suffix:semicolon
r_static
r_int
id|e100_ethtool_test
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ETHTOOL_GSTRINGS
r_static
r_int
id|e100_ethtool_gstrings
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
)paren
suffix:semicolon
DECL|variable|test_strings
r_static
r_char
op_star
id|test_strings
(braket
)braket
op_assign
(brace
l_string|&quot;E100_EEPROM_TEST_FAIL&quot;
comma
l_string|&quot;E100_CHIP_TIMEOUT&quot;
comma
l_string|&quot;E100_ROM_TEST_FAIL&quot;
comma
l_string|&quot;E100_REG_TEST_FAIL&quot;
comma
l_string|&quot;E100_MAC_TEST_FAIL&quot;
comma
l_string|&quot;E100_LPBK_MAC_FAIL&quot;
comma
l_string|&quot;E100_LPBK_PHY_FAIL&quot;
)brace
suffix:semicolon
macro_line|#endif
macro_line|#endif /*E100_ETHTOOL_IOCTL */
macro_line|#ifdef SIOCGMIIPHY
DECL|macro|E100_MII_IOCTL
mdefine_line|#define E100_MII_IOCTL
macro_line|#endif
macro_line|#ifdef E100_MII_IOCTL
macro_line|#include &lt;linux/mii.h&gt;
r_static
r_int
id|e100_mii_ioctl
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
comma
r_int
)paren
suffix:semicolon
macro_line|#endif /*E100_MII_IOCTL */
r_static
r_int
r_char
id|e100_delayed_exec_non_cu_cmd
c_func
(paren
r_struct
id|e100_private
op_star
comma
id|nxmit_cb_entry_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_free_nontx_list
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_non_tx_background
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* Global Data structures and variables */
DECL|variable|__devinitdata
r_char
id|e100_copyright
(braket
)braket
id|__devinitdata
op_assign
l_string|&quot;Copyright (c) 2002 Intel Corporation&quot;
suffix:semicolon
DECL|macro|E100_VERSION
mdefine_line|#define E100_VERSION  &quot;2.0.27-pre3&quot;
DECL|macro|E100_FULL_DRIVER_NAME
mdefine_line|#define E100_FULL_DRIVER_NAME &t;&quot;Intel(R) PRO/100 Fast Ethernet Adapter - Loadable driver, ver &quot;
DECL|variable|e100_version
r_const
r_char
op_star
id|e100_version
op_assign
id|E100_VERSION
suffix:semicolon
DECL|variable|e100_full_driver_name
r_const
r_char
op_star
id|e100_full_driver_name
op_assign
id|E100_FULL_DRIVER_NAME
id|E100_VERSION
suffix:semicolon
DECL|variable|e100_short_driver_name
r_char
op_star
id|e100_short_driver_name
op_assign
l_string|&quot;e100&quot;
suffix:semicolon
DECL|variable|e100nics
r_static
r_int
id|e100nics
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_PM
r_static
r_int
id|e100_save_state
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
comma
id|u32
id|state
)paren
suffix:semicolon
r_static
r_int
id|e100_suspend
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
comma
id|u32
id|state
)paren
suffix:semicolon
r_static
r_int
id|e100_enable_wake
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
comma
id|u32
id|state
comma
r_int
id|enable
)paren
suffix:semicolon
r_static
r_int
id|e100_resume
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*********************************************************************/
multiline_comment|/*! This is a GCC extension to ANSI C.&n; *  See the item &quot;Labeled Elements in Initializers&quot; in the section&n; *  &quot;Extensions to the C Language Family&quot; of the GCC documentation.&n; *********************************************************************/
DECL|macro|E100_PARAM_INIT
mdefine_line|#define E100_PARAM_INIT { [0 ... E100_MAX_NIC] = -1 }
multiline_comment|/* All parameters are treated the same, as an integer array of values.&n; * This macro just reduces the need to repeat the same declaration code&n; * over and over (plus this helps to avoid typo bugs).&n; */
DECL|macro|E100_PARAM
mdefine_line|#define E100_PARAM(X, S)                                        &bslash;&n;        static const int X[E100_MAX_NIC + 1] = E100_PARAM_INIT; &bslash;&n;        MODULE_PARM(X, &quot;1-&quot; __MODULE_STRING(E100_MAX_NIC) &quot;i&quot;); &bslash;&n;        MODULE_PARM_DESC(X, S);
multiline_comment|/* ====================================================================== */
r_static
id|u8
id|e100_D101M_checksum
c_func
(paren
r_struct
id|e100_private
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
id|u8
id|e100_D102_check_checksum
c_func
(paren
id|rfd_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|e100_ioctl
c_func
(paren
r_struct
id|net_device
op_star
comma
r_struct
id|ifreq
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|e100_open
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_int
id|e100_close
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_int
id|e100_change_mtu
c_func
(paren
r_struct
id|net_device
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|e100_xmit_frame
c_func
(paren
r_struct
id|sk_buff
op_star
comma
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_int
r_char
id|e100_init
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_int
id|e100_set_mac
c_func
(paren
r_struct
id|net_device
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|e100_get_stats
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100intr
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_print_brd_conf
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_set_multi
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_void
id|e100_set_speed_duplex
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_char
op_star
id|e100_get_brand_msg
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
id|u8
id|e100_pci_setup
c_func
(paren
r_struct
id|pci_dev
op_star
comma
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
id|u8
id|e100_sw_init
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_int
r_char
id|e100_alloc_space
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_dealloc_space
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_int
id|e100_alloc_tcb_pool
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_setup_tcb_pool
c_func
(paren
id|tcb_t
op_star
comma
r_int
r_int
comma
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_free_tcb_pool
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_int
id|e100_alloc_rfd_pool
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_free_rfd_pool
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_rd_eaddr
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_rd_pwa_no
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_extern
id|u16
id|e100_eeprom_read
c_func
(paren
r_struct
id|e100_private
op_star
comma
id|u16
)paren
suffix:semicolon
r_extern
r_void
id|e100_eeprom_write_block
c_func
(paren
r_struct
id|e100_private
op_star
comma
id|u16
comma
id|u16
op_star
comma
id|u16
)paren
suffix:semicolon
r_extern
id|u16
id|e100_eeprom_size
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_int
r_char
id|e100_clr_cntrs
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_int
r_char
id|e100_load_microcode
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_int
r_char
id|e100_hw_init
c_func
(paren
r_struct
id|e100_private
op_star
comma
id|u32
)paren
suffix:semicolon
r_static
r_int
r_char
id|e100_setup_iaaddr
c_func
(paren
r_struct
id|e100_private
op_star
comma
id|u8
op_star
)paren
suffix:semicolon
r_static
r_int
r_char
id|e100_update_stats
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
suffix:semicolon
r_static
r_void
id|e100_start_ru
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_dump_stats_cntrs
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_check_options
c_func
(paren
r_int
id|board
comma
r_struct
id|e100_private
op_star
id|bdp
)paren
suffix:semicolon
r_static
r_void
id|e100_set_int_option
c_func
(paren
r_int
op_star
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_char
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_set_bool_option
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
r_int
comma
id|u32
comma
r_int
comma
r_char
op_star
)paren
suffix:semicolon
r_int
r_char
id|e100_wait_exec_cmplx
c_func
(paren
r_struct
id|e100_private
op_star
comma
id|u32
comma
id|u8
)paren
suffix:semicolon
r_void
id|e100_exec_cmplx
c_func
(paren
r_struct
id|e100_private
op_star
comma
id|u32
comma
id|u8
)paren
suffix:semicolon
multiline_comment|/**&n; * e100_get_rx_struct - retrieve cell to hold skb buff from the pool&n; * @bdp: atapter&squot;s private data struct&n; *&n; * Returns the new cell to hold sk_buff or %NULL.&n; */
r_static
r_inline
r_struct
id|rx_list_elem
op_star
DECL|function|e100_get_rx_struct
id|e100_get_rx_struct
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_struct
id|rx_list_elem
op_star
id|rx_struct
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
(paren
id|bdp-&gt;rx_struct_pool
)paren
)paren
)paren
(brace
id|rx_struct
op_assign
id|list_entry
c_func
(paren
id|bdp-&gt;rx_struct_pool.next
comma
r_struct
id|rx_list_elem
comma
id|list_elem
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
(paren
id|rx_struct-&gt;list_elem
)paren
)paren
suffix:semicolon
)brace
r_return
id|rx_struct
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_alloc_skb - allocate an skb for the adapter&n; * @bdp: atapter&squot;s private data struct&n; *&n; * Allocates skb with enough room for rfd, and data, and reserve non-data space.&n; * Returns the new cell with sk_buff or %NULL.&n; */
r_static
r_inline
r_struct
id|rx_list_elem
op_star
DECL|function|e100_alloc_skb
id|e100_alloc_skb
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_struct
id|sk_buff
op_star
id|new_skb
suffix:semicolon
id|u32
id|skb_size
op_assign
r_sizeof
(paren
id|rfd_t
)paren
suffix:semicolon
r_struct
id|rx_list_elem
op_star
id|rx_struct
suffix:semicolon
id|new_skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|dev_alloc_skb
c_func
(paren
id|skb_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_skb
)paren
(brace
multiline_comment|/* The IP data should be &n;&t;&t;   DWORD aligned. since the ethernet header is 14 bytes long, &n;&t;&t;   we need to reserve 2 extra bytes so that the TCP/IP headers&n;&t;&t;   will be DWORD aligned. */
id|skb_reserve
c_func
(paren
id|new_skb
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rx_struct
op_assign
id|e100_get_rx_struct
c_func
(paren
id|bdp
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|err
suffix:semicolon
id|rx_struct-&gt;skb
op_assign
id|new_skb
suffix:semicolon
id|rx_struct-&gt;dma_addr
op_assign
id|pci_map_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|new_skb-&gt;data
comma
r_sizeof
(paren
id|rfd_t
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rx_struct-&gt;dma_addr
)paren
r_goto
id|err
suffix:semicolon
id|skb_reserve
c_func
(paren
id|new_skb
comma
id|bdp-&gt;rfd_size
)paren
suffix:semicolon
r_return
id|rx_struct
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|err
suffix:colon
id|dev_kfree_skb_irq
c_func
(paren
id|new_skb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_add_skb_to_end - add an skb to the end of our rfd list&n; * @bdp: atapter&squot;s private data struct&n; * @rx_struct: rx_list_elem with the new skb&n; *&n; * Adds a newly allocated skb to the end of our rfd list.&n; */
r_inline
r_void
DECL|function|e100_add_skb_to_end
id|e100_add_skb_to_end
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
r_struct
id|rx_list_elem
op_star
id|rx_struct
)paren
(brace
id|rfd_t
op_star
id|rfdn
suffix:semicolon
multiline_comment|/* The new rfd */
id|rfd_t
op_star
id|rfd
suffix:semicolon
multiline_comment|/* The old rfd */
r_struct
id|rx_list_elem
op_star
id|rx_struct_last
suffix:semicolon
(paren
id|rx_struct-&gt;skb
)paren
op_member_access_from_pointer
id|dev
op_assign
id|bdp-&gt;device
suffix:semicolon
id|rfdn
op_assign
id|RFD_POINTER
c_func
(paren
id|rx_struct-&gt;skb
comma
id|bdp
)paren
suffix:semicolon
id|rfdn-&gt;rfd_header.cb_status
op_assign
l_int|0
suffix:semicolon
id|rfdn-&gt;rfd_header.cb_cmd
op_assign
id|__constant_cpu_to_le16
c_func
(paren
id|RFD_EL_BIT
)paren
suffix:semicolon
id|rfdn-&gt;rfd_act_cnt
op_assign
l_int|0
suffix:semicolon
id|rfdn-&gt;rfd_sz
op_assign
id|__constant_cpu_to_le16
c_func
(paren
id|RFD_DATA_SIZE
)paren
suffix:semicolon
id|pci_dma_sync_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|rx_struct-&gt;dma_addr
comma
id|bdp-&gt;rfd_size
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
(paren
id|bdp-&gt;active_rx_list
)paren
)paren
)paren
(brace
id|rx_struct_last
op_assign
id|list_entry
c_func
(paren
id|bdp-&gt;active_rx_list.prev
comma
r_struct
id|rx_list_elem
comma
id|list_elem
)paren
suffix:semicolon
id|rfd
op_assign
id|RFD_POINTER
c_func
(paren
id|rx_struct_last-&gt;skb
comma
id|bdp
)paren
suffix:semicolon
id|pci_dma_sync_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|rx_struct_last-&gt;dma_addr
comma
l_int|4
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|put_unaligned
c_func
(paren
id|cpu_to_le32
c_func
(paren
id|rx_struct-&gt;dma_addr
)paren
comma
(paren
(paren
id|u32
op_star
)paren
(paren
op_amp
(paren
id|rfd-&gt;rfd_header.cb_lnk_ptr
)paren
)paren
)paren
)paren
suffix:semicolon
id|pci_dma_sync_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|rx_struct_last-&gt;dma_addr
comma
l_int|8
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|rfd-&gt;rfd_header.cb_cmd
op_and_assign
id|__constant_cpu_to_le16
c_func
(paren
(paren
id|u16
)paren
op_complement
id|RFD_EL_BIT
)paren
suffix:semicolon
id|pci_dma_sync_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|rx_struct_last-&gt;dma_addr
comma
l_int|4
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
(paren
id|rx_struct-&gt;list_elem
)paren
comma
op_amp
(paren
id|bdp-&gt;active_rx_list
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|e100_alloc_skbs
id|e100_alloc_skbs
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|bdp-&gt;skb_req
OG
l_int|0
suffix:semicolon
id|bdp-&gt;skb_req
op_decrement
)paren
(brace
r_struct
id|rx_list_elem
op_star
id|rx_struct
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rx_struct
op_assign
id|e100_alloc_skb
c_func
(paren
id|bdp
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|e100_add_skb_to_end
c_func
(paren
id|bdp
comma
id|rx_struct
)paren
suffix:semicolon
)brace
)brace
r_void
id|e100_tx_srv
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
id|u32
id|e100_rx_srv
c_func
(paren
r_struct
id|e100_private
op_star
comma
id|u32
comma
r_int
op_star
)paren
suffix:semicolon
r_void
id|e100_polling_tasklet
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_void
id|e100_watchdog
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_void
id|e100_refresh_txthld
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_void
id|e100_manage_adaptive_ifs
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_void
id|e100_clear_pools
c_func
(paren
r_struct
id|e100_private
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_clear_structs
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_inline
id|tcb_t
op_star
id|e100_prepare_xmit_buff
c_func
(paren
r_struct
id|e100_private
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_static
r_void
id|e100_set_multi_exec
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Intel Corporation, &lt;linux.nics@intel.com&gt;&quot;
)paren
suffix:semicolon
DECL|variable|E100_VERSION
id|MODULE_DESCRIPTION
c_func
(paren
id|E100_FULL_DRIVER_NAME
id|E100_VERSION
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;Dual BSD/GPL&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|TxDescriptors
comma
l_string|&quot;Number of transmit descriptors&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|RxDescriptors
comma
l_string|&quot;Number of receive descriptors&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|XsumRX
comma
l_string|&quot;Disable or enable Receive Checksum offload&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|e100_speed_duplex
comma
l_string|&quot;Speed and Duplex settings&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|ucode
comma
l_string|&quot;Disable or enable microcode loading&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|ber
comma
l_string|&quot;Value for the BER correction algorithm&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|flow_control
comma
l_string|&quot;Disable or enable Ethernet PAUSE frames processing&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|IntDelay
comma
l_string|&quot;Value for CPU saver&squot;s interrupt delay&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|BundleSmallFr
comma
l_string|&quot;Disable or enable interrupt bundling of small frames&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|BundleMax
comma
l_string|&quot;Maximum number for CPU saver&squot;s packet bundling&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|IFS
comma
l_string|&quot;Disable or enable the adaptive IFS algorithm&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|RxCongestionControl
comma
l_string|&quot;Disable or enable switch to polling mode&quot;
)paren
suffix:semicolon
id|E100_PARAM
c_func
(paren
id|PollingMaxWork
comma
l_string|&quot;Max number of receive packets processed on single &quot;
l_string|&quot;polling call&quot;
)paren
suffix:semicolon
multiline_comment|/**&n; * e100_exec_cmd - issue a comand&n; * @bdp: atapter&squot;s private data struct&n; * @scb_cmd_low: the command that is to be issued&n; *&n; * This general routine will issue a command to the e100.&n; */
r_static
r_inline
r_void
DECL|function|e100_exec_cmd
id|e100_exec_cmd
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u8
id|cmd_low
)paren
(brace
id|writeb
c_func
(paren
id|cmd_low
comma
op_amp
(paren
id|bdp-&gt;scb-&gt;scb_cmd_low
)paren
)paren
suffix:semicolon
id|readw
c_func
(paren
op_amp
(paren
id|bdp-&gt;scb-&gt;scb_status
)paren
)paren
suffix:semicolon
multiline_comment|/* flashes last write, read-safe */
)brace
multiline_comment|/**&n; * e100_wait_scb - wait for SCB to clear&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine checks to see if the e100 has accepted a command.&n; * It does so by checking the command field in the SCB, which will&n; * be zeroed by the e100 upon accepting a command.  The loop waits&n; * for up to 1 millisecond for command acceptance.&n; *&n; * Returns:&n; *      true if the SCB cleared within 1 millisecond.&n; *      false if it didn&squot;t clear within 1 millisecond&n; */
r_int
r_char
DECL|function|e100_wait_scb
id|e100_wait_scb
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* loop on the scb for a few times */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|readb
c_func
(paren
op_amp
id|bdp-&gt;scb-&gt;scb_cmd_low
)paren
)paren
r_return
l_bool|true
suffix:semicolon
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* it didn&squot;t work. do it the slow way using udelay()s */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|E100_MAX_SCB_WAIT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|readb
c_func
(paren
op_amp
id|bdp-&gt;scb-&gt;scb_cmd_low
)paren
)paren
r_return
l_bool|true
suffix:semicolon
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_wait_exec_simple - issue a command&n; * @bdp: atapter&squot;s private data struct&n; * @scb_cmd_low: the command that is to be issued&n; *&n; * This general routine will issue a command to the e100 after waiting for&n; * the previous command to finish.&n; *&n; * Returns:&n; *      true if the command was issued to the chip successfully&n; *      false if the command was not issued to the chip&n; */
r_inline
r_int
r_char
DECL|function|e100_wait_exec_simple
id|e100_wait_exec_simple
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u8
id|scb_cmd_low
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_scb
c_func
(paren
id|bdp
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s e100_wait_exec_simple: Wait failed&bslash;n&quot;
comma
id|bdp-&gt;device-&gt;name
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
id|e100_exec_cmd
c_func
(paren
id|bdp
comma
id|scb_cmd_low
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
r_void
DECL|function|e100_exec_cmplx
id|e100_exec_cmplx
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u32
id|phys_addr
comma
id|u8
id|cmd
)paren
(brace
id|writel
c_func
(paren
id|phys_addr
comma
op_amp
(paren
id|bdp-&gt;scb-&gt;scb_gen_ptr
)paren
)paren
suffix:semicolon
id|readw
c_func
(paren
op_amp
(paren
id|bdp-&gt;scb-&gt;scb_status
)paren
)paren
suffix:semicolon
multiline_comment|/* flashes last write, read-safe */
id|e100_exec_cmd
c_func
(paren
id|bdp
comma
id|cmd
)paren
suffix:semicolon
)brace
r_int
r_char
DECL|function|e100_wait_exec_cmplx
id|e100_wait_exec_cmplx
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u32
id|phys_addr
comma
id|u8
id|cmd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_scb
c_func
(paren
id|bdp
)paren
)paren
(brace
r_return
l_bool|false
suffix:semicolon
)brace
id|e100_exec_cmplx
c_func
(paren
id|bdp
comma
id|phys_addr
comma
id|cmd
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
r_inline
id|u8
DECL|function|e100_wait_cus_idle
id|e100_wait_cus_idle
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* loop on the scb for a few times */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|readw
c_func
(paren
op_amp
(paren
id|bdp-&gt;scb-&gt;scb_status
)paren
)paren
op_amp
id|SCB_CUS_MASK
)paren
op_ne
id|SCB_CUS_ACTIVE
)paren
)paren
(brace
r_return
l_bool|true
suffix:semicolon
)brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|E100_MAX_CU_IDLE_WAIT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|readw
c_func
(paren
op_amp
(paren
id|bdp-&gt;scb-&gt;scb_status
)paren
)paren
op_amp
id|SCB_CUS_MASK
)paren
op_ne
id|SCB_CUS_ACTIVE
)paren
)paren
(brace
r_return
l_bool|true
suffix:semicolon
)brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_dis_intr - disable interrupts&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine disables interrupts at the hardware, by setting&n; * the M (mask) bit in the adapter&squot;s CSR SCB command word.&n; */
r_static
r_inline
r_void
DECL|function|e100_dis_intr
id|e100_dis_intr
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
multiline_comment|/* Disable interrupts on our PCI board by setting the mask bit */
id|writeb
c_func
(paren
id|SCB_INT_MASK
comma
op_amp
id|bdp-&gt;scb-&gt;scb_cmd_hi
)paren
suffix:semicolon
id|readw
c_func
(paren
op_amp
(paren
id|bdp-&gt;scb-&gt;scb_status
)paren
)paren
suffix:semicolon
multiline_comment|/* flushes last write, read-safe */
)brace
multiline_comment|/**&n; * e100_set_intr_mask - set interrupts&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine sets interrupts at the hardware, by resetting&n; * the M (mask) bit in the adapter&squot;s CSR SCB command word&n; */
r_static
r_inline
r_void
DECL|function|e100_set_intr_mask
id|e100_set_intr_mask
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|writeb
c_func
(paren
id|bdp-&gt;intr_mask
comma
op_amp
id|bdp-&gt;scb-&gt;scb_cmd_hi
)paren
suffix:semicolon
id|readw
c_func
(paren
op_amp
(paren
id|bdp-&gt;scb-&gt;scb_status
)paren
)paren
suffix:semicolon
multiline_comment|/* flushes last write, read-safe */
)brace
r_static
r_inline
r_void
DECL|function|e100_trigger_SWI
id|e100_trigger_SWI
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
multiline_comment|/* Trigger interrupt on our PCI board by asserting SWI bit */
id|writeb
c_func
(paren
id|SCB_SOFT_INT
comma
op_amp
id|bdp-&gt;scb-&gt;scb_cmd_hi
)paren
suffix:semicolon
id|readw
c_func
(paren
op_amp
(paren
id|bdp-&gt;scb-&gt;scb_status
)paren
)paren
suffix:semicolon
multiline_comment|/* flushes last write, read-safe */
)brace
r_static
r_int
id|__devinit
DECL|function|e100_found1
id|e100_found1
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
comma
r_const
r_struct
id|pci_device_id
op_star
id|ent
)paren
(brace
r_static
r_int
id|first_time
op_assign
l_bool|true
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|e100_private
op_star
id|bdp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|dev
op_assign
id|alloc_etherdev
c_func
(paren
r_sizeof
(paren
r_struct
id|e100_private
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Not able to alloc etherdev struct&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|first_time
op_assign
l_bool|false
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s&bslash;n&quot;
comma
id|e100_full_driver_name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s&bslash;n&quot;
comma
id|e100_copyright
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|bdp-&gt;pdev
op_assign
id|pcid
suffix:semicolon
id|bdp-&gt;device
op_assign
id|dev
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|pcid
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|e100_alloc_space
c_func
(paren
id|bdp
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|err_dev
suffix:semicolon
)brace
id|bdp-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;ifs_state
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;ifs_value
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;scb
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|bdp-&gt;nontx_timer_id
)paren
suffix:semicolon
id|bdp-&gt;nontx_timer_id.data
op_assign
(paren
r_int
r_int
)paren
id|bdp
suffix:semicolon
id|bdp-&gt;nontx_timer_id.function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|e100_non_tx_background
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|bdp-&gt;non_tx_cmd_list
)paren
)paren
suffix:semicolon
id|bdp-&gt;non_tx_command_state
op_assign
id|E100_NON_TX_IDLE
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|bdp-&gt;watchdog_timer
)paren
suffix:semicolon
id|bdp-&gt;watchdog_timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|bdp-&gt;watchdog_timer.function
op_assign
(paren
r_void
op_star
)paren
op_amp
id|e100_watchdog
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|e100_pci_setup
c_func
(paren
id|pcid
comma
id|bdp
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|err_dealloc
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|bdp-&gt;pdev-&gt;device
OG
l_int|0x1030
)paren
op_logical_and
(paren
id|bdp-&gt;pdev-&gt;device
OL
l_int|0x103F
)paren
)paren
op_logical_or
(paren
id|bdp-&gt;pdev-&gt;device
op_eq
l_int|0x2449
)paren
op_logical_or
(paren
id|bdp-&gt;pdev-&gt;device
op_eq
l_int|0x2459
)paren
op_logical_or
(paren
id|bdp-&gt;pdev-&gt;device
op_eq
l_int|0x245D
)paren
)paren
(brace
id|bdp-&gt;rev_id
op_assign
id|D101MA_REV_ID
suffix:semicolon
multiline_comment|/* workaround for ICH3 */
id|bdp-&gt;flags
op_or_assign
id|IS_ICH
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bdp-&gt;rev_id
op_eq
l_int|0xff
)paren
id|bdp-&gt;rev_id
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u8
)paren
id|bdp-&gt;rev_id
op_ge
id|D101A4_REV_ID
)paren
id|bdp-&gt;flags
op_or_assign
id|IS_BACHELOR
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u8
)paren
id|bdp-&gt;rev_id
op_ge
id|D102_REV_ID
)paren
(brace
id|bdp-&gt;flags
op_or_assign
id|USE_IPCB
suffix:semicolon
id|bdp-&gt;rfd_size
op_assign
l_int|32
suffix:semicolon
)brace
r_else
(brace
id|bdp-&gt;rfd_size
op_assign
l_int|16
suffix:semicolon
)brace
id|e100_check_options
c_func
(paren
id|e100nics
comma
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_init
c_func
(paren
id|bdp
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Failed to initialize e100, instance #%d&bslash;n&quot;
comma
id|e100nics
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_pci
suffix:semicolon
)brace
id|dev-&gt;irq
op_assign
id|pcid-&gt;irq
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|e100_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|e100_xmit_frame
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|e100_close
suffix:semicolon
id|dev-&gt;change_mtu
op_assign
op_amp
id|e100_change_mtu
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|e100_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|e100_set_multi
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
op_amp
id|e100_set_mac
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
op_amp
id|e100_ioctl
suffix:semicolon
macro_line|#ifdef E100_ZEROCOPY
r_if
c_cond
(paren
id|bdp-&gt;flags
op_amp
id|USE_IPCB
)paren
(brace
id|dev-&gt;features
op_or_assign
id|NETIF_F_SG
op_or
id|NETIF_F_IP_CSUM
suffix:semicolon
)brace
macro_line|#endif
id|e100nics
op_increment
suffix:semicolon
macro_line|#ifdef E100_ETHTOOL_IOCTL
id|e100_get_speed_duplex_caps
c_func
(paren
id|bdp
)paren
suffix:semicolon
macro_line|#endif /*E100_ETHTOOL_IOCTL */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|register_netdev
c_func
(paren
id|dev
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|err_pci
suffix:semicolon
)brace
id|bdp-&gt;device_type
op_assign
id|ent-&gt;driver_data
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|bdp-&gt;device-&gt;name
comma
id|e100_get_brand_msg
c_func
(paren
id|bdp
)paren
)paren
suffix:semicolon
id|e100_print_brd_conf
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e100_create_proc_subdir
c_func
(paren
id|bdp
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Failed to create proc directory for %s&bslash;n&quot;
comma
id|bdp-&gt;device-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#ifdef ETHTOOL_GWOL
multiline_comment|/* Disabling all WOLs as initialization */
id|bdp-&gt;wolsupported
op_assign
id|bdp-&gt;wolopts
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;rev_id
op_ge
id|D101MA_REV_ID
)paren
(brace
id|bdp-&gt;wolsupported
op_assign
id|WAKE_PHY
op_or
id|WAKE_UCAST
op_or
id|WAKE_ARP
op_or
id|WAKE_MAGIC
suffix:semicolon
id|bdp-&gt;wolopts
op_assign
id|WAKE_MAGIC
suffix:semicolon
)brace
macro_line|#endif
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|err_pci
suffix:colon
id|iounmap
c_func
(paren
id|bdp-&gt;scb
)paren
suffix:semicolon
id|pci_release_regions
c_func
(paren
id|pcid
)paren
suffix:semicolon
id|pci_disable_device
c_func
(paren
id|pcid
)paren
suffix:semicolon
id|err_dealloc
suffix:colon
id|e100_dealloc_space
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|err_dev
suffix:colon
id|pci_set_drvdata
c_func
(paren
id|pcid
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_clear_structs - free resources&n; * @dev: adapter&squot;s net_device struct&n; *&n; * Free all device specific structs, unmap i/o address, etc.&n; */
r_static
r_void
id|__devexit
DECL|function|e100_clear_structs
id|e100_clear_structs
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|iounmap
c_func
(paren
id|bdp-&gt;scb
)paren
suffix:semicolon
id|pci_release_regions
c_func
(paren
id|bdp-&gt;pdev
)paren
suffix:semicolon
id|pci_disable_device
c_func
(paren
id|bdp-&gt;pdev
)paren
suffix:semicolon
id|e100_dealloc_space
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|bdp-&gt;pdev
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_void
id|__devexit
DECL|function|e100_remove1
id|e100_remove1
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|pci_get_drvdata
c_func
(paren
id|pcid
)paren
)paren
)paren
r_return
suffix:semicolon
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|e100_remove_proc_subdir
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|e100_sw_reset
c_func
(paren
id|bdp
comma
id|PORT_SELECTIVE_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;non_tx_command_state
op_ne
id|E100_NON_TX_IDLE
)paren
(brace
id|del_timer_sync
c_func
(paren
op_amp
id|bdp-&gt;nontx_timer_id
)paren
suffix:semicolon
id|e100_free_nontx_list
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|bdp-&gt;non_tx_command_state
op_assign
id|E100_NON_TX_IDLE
suffix:semicolon
)brace
macro_line|#ifdef ETHTOOL_GWOL
multiline_comment|/* Set up wol options and enable PME if wol is enabled */
r_if
c_cond
(paren
id|bdp-&gt;wolopts
)paren
(brace
id|e100_do_wol
c_func
(paren
id|pcid
comma
id|bdp
)paren
suffix:semicolon
multiline_comment|/* Enable PME for power state D3 */
id|pci_enable_wake
c_func
(paren
id|pcid
comma
l_int|3
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Set power state to D1 in case driver is RELOADED */
multiline_comment|/* If system powers down, device is switched from D1 to D3 */
id|pci_set_power_state
c_func
(paren
id|pcid
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
id|e100_clear_structs
c_func
(paren
id|dev
)paren
suffix:semicolon
op_decrement
id|e100nics
suffix:semicolon
)brace
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|e100_id_table
)paren
suffix:semicolon
DECL|variable|e100_driver
r_static
r_struct
id|pci_driver
id|e100_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;e100&quot;
comma
id|id_table
suffix:colon
id|e100_id_table
comma
id|probe
suffix:colon
id|e100_found1
comma
id|remove
suffix:colon
id|__devexit_p
c_func
(paren
id|e100_remove1
)paren
comma
macro_line|#ifdef CONFIG_PM
id|suspend
suffix:colon
id|e100_suspend
comma
id|resume
suffix:colon
id|e100_resume
comma
id|save_state
suffix:colon
id|e100_save_state
comma
id|enable_wake
suffix:colon
id|e100_enable_wake
comma
macro_line|#else
id|suspend
suffix:colon
l_int|NULL
comma
id|resume
suffix:colon
l_int|NULL
comma
macro_line|#endif
)brace
suffix:semicolon
r_static
r_int
id|__init
DECL|function|e100_init_module
id|e100_init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|pci_module_init
c_func
(paren
op_amp
id|e100_driver
)paren
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|e100_cleanup_module
id|e100_cleanup_module
c_func
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|e100_driver
)paren
suffix:semicolon
)brace
DECL|variable|e100_init_module
id|module_init
c_func
(paren
id|e100_init_module
)paren
suffix:semicolon
DECL|variable|e100_cleanup_module
id|module_exit
c_func
(paren
id|e100_cleanup_module
)paren
suffix:semicolon
multiline_comment|/**&n; * e100_check_options - check command line options&n; * @board: board number&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine does range checking on command-line options&n; */
r_void
id|__devinit
DECL|function|e100_check_options
id|e100_check_options
c_func
(paren
r_int
id|board
comma
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_if
c_cond
(paren
id|board
op_ge
id|E100_MAX_NIC
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;No configuration available for board #%d&bslash;n&quot;
comma
id|board
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Using defaults for all values&bslash;n&quot;
)paren
suffix:semicolon
id|board
op_assign
id|E100_MAX_NIC
suffix:semicolon
)brace
id|e100_set_int_option
c_func
(paren
op_amp
(paren
id|bdp-&gt;params.TxDescriptors
)paren
comma
id|TxDescriptors
(braket
id|board
)braket
comma
id|E100_MIN_TCB
comma
id|E100_MAX_TCB
comma
id|E100_DEFAULT_TCB
comma
l_string|&quot;TxDescriptor count&quot;
)paren
suffix:semicolon
id|e100_set_int_option
c_func
(paren
op_amp
(paren
id|bdp-&gt;params.RxDescriptors
)paren
comma
id|RxDescriptors
(braket
id|board
)braket
comma
id|E100_MIN_RFD
comma
id|E100_MAX_RFD
comma
id|E100_DEFAULT_RFD
comma
l_string|&quot;RxDescriptor count&quot;
)paren
suffix:semicolon
id|e100_set_int_option
c_func
(paren
op_amp
(paren
id|bdp-&gt;params.e100_speed_duplex
)paren
comma
id|e100_speed_duplex
(braket
id|board
)braket
comma
l_int|0
comma
l_int|4
comma
id|E100_DEFAULT_SPEED_DUPLEX
comma
l_string|&quot;speed/duplex mode&quot;
)paren
suffix:semicolon
id|e100_set_int_option
c_func
(paren
op_amp
(paren
id|bdp-&gt;params.ber
)paren
comma
id|ber
(braket
id|board
)braket
comma
l_int|0
comma
id|ZLOCK_MAX_ERRORS
comma
id|E100_DEFAULT_BER
comma
l_string|&quot;Bit Error Rate count&quot;
)paren
suffix:semicolon
id|e100_set_bool_option
c_func
(paren
id|bdp
comma
id|XsumRX
(braket
id|board
)braket
comma
id|PRM_XSUMRX
comma
id|E100_DEFAULT_XSUM
comma
l_string|&quot;XsumRX value&quot;
)paren
suffix:semicolon
multiline_comment|/* Default ucode value depended on controller revision */
r_if
c_cond
(paren
id|bdp-&gt;rev_id
op_ge
id|D101MA_REV_ID
)paren
(brace
id|e100_set_bool_option
c_func
(paren
id|bdp
comma
id|ucode
(braket
id|board
)braket
comma
id|PRM_UCODE
comma
id|E100_DEFAULT_UCODE
comma
l_string|&quot;ucode value&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|e100_set_bool_option
c_func
(paren
id|bdp
comma
id|ucode
(braket
id|board
)braket
comma
id|PRM_UCODE
comma
l_bool|false
comma
l_string|&quot;ucode value&quot;
)paren
suffix:semicolon
)brace
id|e100_set_bool_option
c_func
(paren
id|bdp
comma
id|flow_control
(braket
id|board
)braket
comma
id|PRM_FC
comma
id|E100_DEFAULT_FC
comma
l_string|&quot;flow control value&quot;
)paren
suffix:semicolon
id|e100_set_bool_option
c_func
(paren
id|bdp
comma
id|IFS
(braket
id|board
)braket
comma
id|PRM_IFS
comma
id|E100_DEFAULT_IFS
comma
l_string|&quot;IFS value&quot;
)paren
suffix:semicolon
id|e100_set_bool_option
c_func
(paren
id|bdp
comma
id|BundleSmallFr
(braket
id|board
)braket
comma
id|PRM_BUNDLE_SMALL
comma
id|E100_DEFAULT_BUNDLE_SMALL_FR
comma
l_string|&quot;CPU saver bundle small frames value&quot;
)paren
suffix:semicolon
id|e100_set_int_option
c_func
(paren
op_amp
(paren
id|bdp-&gt;params.IntDelay
)paren
comma
id|IntDelay
(braket
id|board
)braket
comma
l_int|0x0
comma
l_int|0xFFFF
comma
id|E100_DEFAULT_CPUSAVER_INTERRUPT_DELAY
comma
l_string|&quot;CPU saver interrupt delay value&quot;
)paren
suffix:semicolon
id|e100_set_int_option
c_func
(paren
op_amp
(paren
id|bdp-&gt;params.BundleMax
)paren
comma
id|BundleMax
(braket
id|board
)braket
comma
l_int|0x1
comma
l_int|0xFFFF
comma
id|E100_DEFAULT_CPUSAVER_BUNDLE_MAX
comma
l_string|&quot;CPU saver bundle max value&quot;
)paren
suffix:semicolon
id|e100_set_bool_option
c_func
(paren
id|bdp
comma
id|RxCongestionControl
(braket
id|board
)braket
comma
id|PRM_RX_CONG
comma
id|E100_DEFAULT_RX_CONGESTION_CONTROL
comma
l_string|&quot;Rx Congestion Control value&quot;
)paren
suffix:semicolon
id|e100_set_int_option
c_func
(paren
op_amp
(paren
id|bdp-&gt;params.PollingMaxWork
)paren
comma
id|PollingMaxWork
(braket
id|board
)braket
comma
l_int|1
comma
id|E100_MAX_RFD
comma
id|bdp-&gt;params.RxDescriptors
comma
l_string|&quot;Polling Max Work value&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_set_int_option - check and set an integer option&n; * @option: a pointer to the relevant option field&n; * @val: the value specified&n; * @min: the minimum valid value&n; * @max: the maximum valid value&n; * @default_val: the default value&n; * @name: the name of the option&n; *&n; * This routine does range checking on a command-line option.&n; * If the option&squot;s value is &squot;-1&squot; use the specified default.&n; * Otherwise, if the value is invalid, change it to the default.&n; */
r_void
id|__devinit
DECL|function|e100_set_int_option
id|e100_set_int_option
c_func
(paren
r_int
op_star
id|option
comma
r_int
id|val
comma
r_int
id|min
comma
r_int
id|max
comma
r_int
id|default_val
comma
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|val
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* no value specified. use default */
op_star
id|option
op_assign
id|default_val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|val
OL
id|min
)paren
op_logical_or
(paren
id|val
OG
id|max
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Invalid %s specified (%i). Valid range is %i-%i&bslash;n&quot;
comma
id|name
comma
id|val
comma
id|min
comma
id|max
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Using default %s of %i&bslash;n&quot;
comma
id|name
comma
id|default_val
)paren
suffix:semicolon
op_star
id|option
op_assign
id|default_val
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Using specified %s of %i&bslash;n&quot;
comma
id|name
comma
id|val
)paren
suffix:semicolon
op_star
id|option
op_assign
id|val
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * e100_set_bool_option - check and set a boolean option&n; * @bdp: atapter&squot;s private data struct&n; * @val: the value specified&n; * @mask: the mask for the relevant option&n; * @default_val: the default value&n; * @name: the name of the option&n; *&n; * This routine checks a boolean command-line option.&n; * If the option&squot;s value is &squot;-1&squot; use the specified default.&n; * Otherwise, if the value is invalid (not 0 or 1), &n; * change it to the default.&n; */
r_void
id|__devinit
DECL|function|e100_set_bool_option
id|e100_set_bool_option
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
r_int
id|val
comma
id|u32
id|mask
comma
r_int
id|default_val
comma
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|val
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|default_val
)paren
id|bdp-&gt;params.b_params
op_or_assign
id|mask
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|val
op_ne
l_bool|true
)paren
op_logical_and
(paren
id|val
op_ne
l_bool|false
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Invalid %s specified (%i). Valid values are %i/%i&bslash;n&quot;
comma
id|name
comma
id|val
comma
l_bool|false
comma
l_bool|true
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Using default %s of %i&bslash;n&quot;
comma
id|name
comma
id|default_val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|default_val
)paren
id|bdp-&gt;params.b_params
op_or_assign
id|mask
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Using specified %s of %i&bslash;n&quot;
comma
id|name
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
id|bdp-&gt;params.b_params
op_or_assign
id|mask
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|e100_open
id|e100_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;driver_isolated
)paren
(brace
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* setup the tcb pool */
r_if
c_cond
(paren
op_logical_neg
id|e100_alloc_tcb_pool
c_func
(paren
id|bdp
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_exit
suffix:semicolon
)brace
id|bdp-&gt;last_tcb
op_assign
l_int|NULL
suffix:semicolon
id|bdp-&gt;tcb_pool.head
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;tcb_pool.tail
op_assign
l_int|1
suffix:semicolon
id|e100_setup_tcb_pool
c_func
(paren
(paren
id|tcb_t
op_star
)paren
id|bdp-&gt;tcb_pool.data
comma
id|bdp-&gt;params.TxDescriptors
comma
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_alloc_rfd_pool
c_func
(paren
id|bdp
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_exec_cmplx
c_func
(paren
id|bdp
comma
l_int|0
comma
id|SCB_CUC_LOAD_BASE
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|err_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_exec_cmplx
c_func
(paren
id|bdp
comma
l_int|0
comma
id|SCB_RUC_LOAD_BASE
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|err_exit
suffix:semicolon
)brace
id|mod_timer
c_func
(paren
op_amp
(paren
id|bdp-&gt;watchdog_timer
)paren
comma
id|jiffies
op_plus
(paren
l_int|2
op_star
id|HZ
)paren
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|e100_start_ru
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|e100intr
comma
id|SA_SHIRQ
comma
id|e100_short_driver_name
comma
id|dev
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|del_timer_sync
c_func
(paren
op_amp
id|bdp-&gt;watchdog_timer
)paren
suffix:semicolon
r_goto
id|err_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bdp-&gt;params.b_params
op_amp
id|PRM_RX_CONG
)paren
(brace
id|DECLARE_TASKLET
c_func
(paren
id|polling_tasklet
comma
id|e100_polling_tasklet
comma
(paren
r_int
r_int
)paren
id|bdp
)paren
suffix:semicolon
id|bdp-&gt;polling_tasklet
op_assign
id|polling_tasklet
suffix:semicolon
)brace
id|bdp-&gt;intr_mask
op_assign
l_int|0
suffix:semicolon
id|e100_set_intr_mask
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|e100_force_config
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
id|err_exit
suffix:colon
id|e100_clear_pools
c_func
(paren
id|bdp
)paren
suffix:semicolon
m_exit
suffix:colon
id|read_unlock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|e100_close
id|e100_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|bdp-&gt;intr_mask
op_assign
id|SCB_INT_MASK
suffix:semicolon
id|e100_isolate_driver
c_func
(paren
id|bdp
)paren
suffix:semicolon
macro_line|#ifdef ETHTOOL_GWOL
id|bdp-&gt;ip_lbytes
op_assign
id|e100_get_ip_lbytes
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|e100_clear_pools
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;params.b_params
op_amp
id|PRM_RX_CONG
)paren
(brace
id|tasklet_kill
c_func
(paren
op_amp
(paren
id|bdp-&gt;polling_tasklet
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* set the isolate flag to false, so e100_open can be called */
id|bdp-&gt;driver_isolated
op_assign
l_bool|false
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|e100_change_mtu
id|e100_change_mtu
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|new_mtu
)paren
(brace
r_if
c_cond
(paren
(paren
id|new_mtu
OL
l_int|68
)paren
op_logical_or
(paren
id|new_mtu
OG
(paren
id|ETH_DATA_LEN
op_plus
id|VLAN_SIZE
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|e100_xmit_frame
id|e100_xmit_frame
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|notify_stop
op_assign
l_bool|false
suffix:semicolon
r_struct
id|e100_private
op_star
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;driver_isolated
)paren
(brace
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|exit2
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|bdp-&gt;bd_non_tx_lock
)paren
)paren
(brace
id|notify_stop
op_assign
l_bool|true
suffix:semicolon
id|rc
op_assign
l_int|1
suffix:semicolon
r_goto
id|exit2
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|TCBS_AVAIL
c_func
(paren
id|bdp-&gt;tcb_pool
)paren
op_logical_or
(paren
id|bdp-&gt;non_tx_command_state
op_ne
id|E100_NON_TX_IDLE
)paren
)paren
(brace
id|notify_stop
op_assign
l_bool|true
suffix:semicolon
id|rc
op_assign
l_int|1
suffix:semicolon
r_goto
id|exit1
suffix:semicolon
)brace
id|e100_prepare_xmit_buff
c_func
(paren
id|bdp
comma
id|skb
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|exit1
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|bdp-&gt;bd_non_tx_lock
)paren
suffix:semicolon
id|exit2
suffix:colon
id|read_unlock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|notify_stop
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_get_stats - get driver statistics&n; * @dev: adapter&squot;s net_device struct&n; *&n; * This routine is called when the OS wants the adapter&squot;s stats returned.&n; * It returns the address of the net_device_stats stucture for the device.&n; * If the statistics are currently being updated, then they might be incorrect&n; * for a short while. However, since this cannot actually cause damage, no&n; * locking is used.&n; */
r_struct
id|net_device_stats
op_star
DECL|function|e100_get_stats
id|e100_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.tx_errors
op_assign
id|bdp-&gt;drv_stats.net_stats.tx_carrier_errors
op_plus
id|bdp-&gt;drv_stats.net_stats.tx_aborted_errors
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.rx_errors
op_assign
id|bdp-&gt;drv_stats.net_stats.rx_crc_errors
op_plus
id|bdp-&gt;drv_stats.net_stats.rx_frame_errors
op_plus
id|bdp-&gt;drv_stats.net_stats.rx_length_errors
op_plus
id|bdp-&gt;drv_stats.rcv_cdt_frames
suffix:semicolon
r_return
op_amp
(paren
id|bdp-&gt;drv_stats.net_stats
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_set_mac - set the MAC address&n; * @dev: adapter&squot;s net_device struct&n; * @addr: the new address&n; *&n; * This routine sets the ethernet address of the board&n; * Returns:&n; * 0  - if successful&n; * -1 - otherwise&n; */
r_static
r_int
DECL|function|e100_set_mac
id|e100_set_mac
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
r_int
id|rc
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|sockaddr
op_star
id|p_sockaddr
op_assign
(paren
r_struct
id|sockaddr
op_star
)paren
id|addr
suffix:semicolon
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;driver_isolated
)paren
(brace
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e100_setup_iaaddr
c_func
(paren
id|bdp
comma
(paren
id|u8
op_star
)paren
(paren
id|p_sockaddr-&gt;sa_data
)paren
)paren
)paren
(brace
id|memcpy
c_func
(paren
op_amp
(paren
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
comma
id|p_sockaddr-&gt;sa_data
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
m_exit
suffix:colon
id|read_unlock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_set_multi_exec
id|e100_set_multi_exec
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|mltcst_cb_t
op_star
id|mcast_buff
suffix:semicolon
id|cb_header_t
op_star
id|cb_hdr
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|mc_list
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|nxmit_cb_entry_t
op_star
id|cmd
op_assign
id|e100_alloc_non_tx_cmd
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_int|NULL
)paren
(brace
id|mcast_buff
op_assign
op_amp
(paren
(paren
id|cmd-&gt;non_tx_cmd
)paren
op_member_access_from_pointer
id|ntcb.multicast
)paren
suffix:semicolon
id|cb_hdr
op_assign
op_amp
(paren
(paren
id|cmd-&gt;non_tx_cmd
)paren
op_member_access_from_pointer
id|ntcb.multicast.mc_cbhdr
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* initialize the multi cast command */
id|cb_hdr-&gt;cb_cmd
op_assign
id|__constant_cpu_to_le16
c_func
(paren
id|CB_MULTICAST
)paren
suffix:semicolon
multiline_comment|/* now fill in the rest of the multicast command */
op_star
(paren
id|u16
op_star
)paren
(paren
op_amp
(paren
id|mcast_buff-&gt;mc_count
)paren
)paren
op_assign
id|cpu_to_le16
c_func
(paren
id|dev-&gt;mc_count
op_star
l_int|6
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mc_list
op_assign
id|dev-&gt;mc_list
suffix:semicolon
(paren
id|i
OL
id|dev-&gt;mc_count
)paren
op_logical_and
(paren
id|i
OL
id|MAX_MULTICAST_ADDRS
)paren
suffix:semicolon
id|i
op_increment
comma
id|mc_list
op_assign
id|mc_list-&gt;next
)paren
(brace
multiline_comment|/* copy into the command */
id|memcpy
c_func
(paren
op_amp
(paren
id|mcast_buff-&gt;mc_addr
(braket
id|i
op_star
id|ETH_ALEN
)braket
)paren
comma
(paren
id|u8
op_star
)paren
op_amp
(paren
id|mc_list-&gt;dmi_addr
)paren
comma
id|ETH_ALEN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|e100_exec_non_cu_cmd
c_func
(paren
id|bdp
comma
id|cmd
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Multicast setup failed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * e100_set_multi - set multicast status&n; * @dev: adapter&squot;s net_device struct&n; *&n; * This routine is called to add or remove multicast addresses, and/or to&n; * change the adapter&squot;s promiscuous state.&n; */
r_static
r_void
DECL|function|e100_set_multi
id|e100_set_multi
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
r_char
id|promisc_enbl
suffix:semicolon
r_int
r_char
id|mulcast_enbl
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;driver_isolated
)paren
(brace
r_goto
m_exit
suffix:semicolon
)brace
id|promisc_enbl
op_assign
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
suffix:semicolon
id|mulcast_enbl
op_assign
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
(paren
id|dev-&gt;mc_count
OG
id|MAX_MULTICAST_ADDRS
)paren
)paren
suffix:semicolon
id|e100_config_promisc
c_func
(paren
id|bdp
comma
id|promisc_enbl
)paren
suffix:semicolon
id|e100_config_mulcast_enbl
c_func
(paren
id|bdp
comma
id|mulcast_enbl
)paren
suffix:semicolon
multiline_comment|/* reconfigure the chip if something has changed in its config space */
id|e100_config
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|promisc_enbl
op_logical_or
id|mulcast_enbl
)paren
(brace
r_goto
m_exit
suffix:semicolon
multiline_comment|/* no need for Multicast Cmd */
)brace
multiline_comment|/* get the multicast CB */
id|e100_set_multi_exec
c_func
(paren
id|dev
)paren
suffix:semicolon
m_exit
suffix:colon
id|read_unlock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|e100_ioctl
id|e100_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
macro_line|#ifdef E100_ETHTOOL_IOCTL
r_case
id|SIOCETHTOOL
suffix:colon
r_return
id|e100_do_ethtool_ioctl
c_func
(paren
id|dev
comma
id|ifr
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /*E100_ETHTOOL_IOCTL */
macro_line|#ifdef E100_MII_IOCTL
r_case
id|SIOCGMIIPHY
suffix:colon
multiline_comment|/* Get address of MII PHY in use. */
r_case
id|SIOCGMIIREG
suffix:colon
multiline_comment|/* Read MII PHY register. */
r_case
id|SIOCSMIIREG
suffix:colon
multiline_comment|/* Write to MII PHY register. */
r_return
id|e100_mii_ioctl
c_func
(paren
id|dev
comma
id|ifr
comma
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /*E100_MII_IOCTL */
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * e100init - initialize the adapter&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine is called when this driver is loaded. This is the initialization&n; * routine which allocates memory, configures the adapter and determines the&n; * system resources.&n; *&n; * Returns:&n; *      true: if successful&n; *      false: otherwise&n; */
r_static
r_int
r_char
id|__devinit
DECL|function|e100_init
id|e100_init
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|e100_sw_init
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_selftest
c_func
(paren
id|bdp
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;selftest failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/* read the MAC address from the eprom */
id|e100_rd_eaddr
c_func
(paren
id|bdp
)paren
suffix:semicolon
multiline_comment|/* read NIC&squot;s part number */
id|e100_rd_pwa_no
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_hw_init
c_func
(paren
id|bdp
comma
id|PORT_SOFTWARE_RESET
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;hw init failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
id|e100_dis_intr
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_sw_init - initialize software structs&n; * @bdp: atapter&squot;s private data struct&n; * &n; * This routine initializes all software structures. Sets up the&n; * circular structures for the RFD&squot;s &amp; TCB&squot;s. Allocates the per board&n; * structure for storing adapter information. The CSR is also memory &n; * mapped in this routine.&n; *&n; * Returns :&n; *      true: if S/W was successfully initialized&n; *      false: otherwise&n; */
r_static
r_int
r_char
id|__devinit
DECL|function|e100_sw_init
id|e100_sw_init
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|bdp-&gt;next_cu_cmd
op_assign
id|START_WAIT
suffix:semicolon
singleline_comment|// init the next cu state
multiline_comment|/* &n;&t; * Set the value for # of good xmits per underrun. the value assigned&n;&t; * here is an intelligent  suggested default. Nothing magical about it.&n;&t; */
id|bdp-&gt;tx_per_underrun
op_assign
id|DEFAULT_TX_PER_UNDERRUN
suffix:semicolon
multiline_comment|/* get the default transmit threshold value */
id|bdp-&gt;tx_thld
op_assign
id|TX_THRSHLD
suffix:semicolon
multiline_comment|/* get the EPROM size */
id|bdp-&gt;eeprom_size
op_assign
id|e100_eeprom_size
c_func
(paren
id|bdp
)paren
suffix:semicolon
multiline_comment|/* Initialize our spinlocks */
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_lock
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_non_tx_lock
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|bdp-&gt;config_lock
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
id|bdp-&gt;isolate_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|bdp-&gt;driver_isolated
op_assign
l_bool|false
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_hw_init - initialized tthe hardware&n; * @bdp: atapter&squot;s private data struct&n; * @reset_cmd: s/w reset or selective reset&n; *&n; * This routine performs a reset on the adapter, and configures the adapter.&n; * This includes configuring the 82557 LAN controller, validating and setting&n; * the node address, detecting and configuring the Phy chip on the adapter,&n; * and initializing all of the on chip counters.&n; *&n; * Returns:&n; *      true - If the adapter was initialized&n; *      false - If the adapter failed initialization&n; */
r_int
r_char
id|__devinit
DECL|function|e100_hw_init
id|e100_hw_init
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u32
id|reset_cmd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|e100_phy_init
c_func
(paren
id|bdp
)paren
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/* Issue a software reset to the e100 */
id|e100_sw_reset
c_func
(paren
id|bdp
comma
id|reset_cmd
)paren
suffix:semicolon
multiline_comment|/* Load the CU BASE (set to 0, because we use linear mode) */
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_exec_cmplx
c_func
(paren
id|bdp
comma
l_int|0
comma
id|SCB_CUC_LOAD_BASE
)paren
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_exec_cmplx
c_func
(paren
id|bdp
comma
l_int|0
comma
id|SCB_RUC_LOAD_BASE
)paren
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/* Load interrupt microcode  */
r_if
c_cond
(paren
id|e100_load_microcode
c_func
(paren
id|bdp
)paren
)paren
(brace
id|bdp-&gt;flags
op_or_assign
id|DF_UCODE_LOADED
suffix:semicolon
)brace
id|e100_config_init
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_config
c_func
(paren
id|bdp
)paren
)paren
(brace
r_return
l_bool|false
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|e100_setup_iaaddr
c_func
(paren
id|bdp
comma
id|bdp-&gt;device-&gt;dev_addr
)paren
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/* Clear the internal counters */
r_if
c_cond
(paren
op_logical_neg
id|e100_clr_cntrs
c_func
(paren
id|bdp
)paren
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/* Change for 82558 enhancement */
multiline_comment|/* If 82558/9 and if the user has enabled flow control, set up the&n;&t; * Flow Control Reg. in the CSR */
r_if
c_cond
(paren
(paren
id|bdp-&gt;flags
op_amp
id|IS_BACHELOR
)paren
op_logical_and
(paren
id|bdp-&gt;params.b_params
op_amp
id|PRM_FC
)paren
)paren
(brace
id|writeb
c_func
(paren
id|DFLT_FC_THLD
comma
op_amp
id|bdp-&gt;scb-&gt;scb_ext.d101_scb.scb_fc_thld
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|DFLT_FC_CMD
comma
op_amp
id|bdp-&gt;scb-&gt;scb_ext.d101_scb.scb_fc_xon_xoff
)paren
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_setup_tcb_pool - setup TCB circular list&n; * @head: Pointer to head of the allocated TCBs&n; * @qlen: Number of elements in the queue&n; * @bdp: atapter&squot;s private data struct&n; * &n; * This routine arranges the contigiously allocated TCB&squot;s in a circular list.&n; * Also does the one time initialization of the TCBs.&n; */
r_static
r_void
DECL|function|e100_setup_tcb_pool
id|e100_setup_tcb_pool
c_func
(paren
id|tcb_t
op_star
id|head
comma
r_int
r_int
id|qlen
comma
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
id|ele_no
suffix:semicolon
id|tcb_t
op_star
id|pcurr_tcb
suffix:semicolon
multiline_comment|/* point to current tcb */
id|u32
id|next_phys
suffix:semicolon
multiline_comment|/* the next phys addr */
id|u16
id|txcommand
op_assign
id|CB_S_BIT
op_or
id|CB_TX_SF_BIT
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;flags
op_amp
id|USE_IPCB
)paren
(brace
id|txcommand
op_or_assign
id|CB_IPCB_TRANSMIT
op_or
id|CB_CID_DEFAULT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bdp-&gt;flags
op_amp
id|IS_BACHELOR
)paren
(brace
id|txcommand
op_or_assign
id|CB_TRANSMIT
op_or
id|CB_CID_DEFAULT
suffix:semicolon
)brace
r_else
(brace
id|txcommand
op_or_assign
id|CB_TRANSMIT
suffix:semicolon
)brace
r_for
c_loop
(paren
id|ele_no
op_assign
l_int|0
comma
id|next_phys
op_assign
id|bdp-&gt;tcb_phys
comma
id|pcurr_tcb
op_assign
id|head
suffix:semicolon
id|ele_no
OL
id|qlen
suffix:semicolon
id|ele_no
op_increment
comma
id|pcurr_tcb
op_increment
)paren
(brace
multiline_comment|/* set the phys addr for this TCB, next_phys has not incr. yet */
id|pcurr_tcb-&gt;tcb_phys
op_assign
id|next_phys
suffix:semicolon
id|next_phys
op_add_assign
r_sizeof
(paren
id|tcb_t
)paren
suffix:semicolon
multiline_comment|/* set the link to next tcb */
r_if
c_cond
(paren
id|ele_no
op_eq
(paren
id|qlen
op_minus
l_int|1
)paren
)paren
id|pcurr_tcb-&gt;tcb_hdr.cb_lnk_ptr
op_assign
id|cpu_to_le32
c_func
(paren
id|bdp-&gt;tcb_phys
)paren
suffix:semicolon
r_else
id|pcurr_tcb-&gt;tcb_hdr.cb_lnk_ptr
op_assign
id|cpu_to_le32
c_func
(paren
id|next_phys
)paren
suffix:semicolon
id|pcurr_tcb-&gt;tcb_hdr.cb_status
op_assign
l_int|0
suffix:semicolon
id|pcurr_tcb-&gt;tcb_hdr.cb_cmd
op_assign
id|cpu_to_le16
c_func
(paren
id|txcommand
)paren
suffix:semicolon
id|pcurr_tcb-&gt;tcb_cnt
op_assign
l_int|0
suffix:semicolon
id|pcurr_tcb-&gt;tcb_thrshld
op_assign
id|bdp-&gt;tx_thld
suffix:semicolon
r_if
c_cond
(paren
id|ele_no
OL
l_int|2
)paren
(brace
id|pcurr_tcb-&gt;tcb_hdr.cb_status
op_assign
id|cpu_to_le16
c_func
(paren
id|CB_STATUS_COMPLETE
)paren
suffix:semicolon
)brace
id|pcurr_tcb-&gt;tcb_tbd_num
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;flags
op_amp
id|IS_BACHELOR
)paren
(brace
id|pcurr_tcb-&gt;tcb_tbd_ptr
op_assign
id|__constant_cpu_to_le32
c_func
(paren
l_int|0xFFFFFFFF
)paren
suffix:semicolon
)brace
r_else
(brace
id|pcurr_tcb-&gt;tcb_tbd_ptr
op_assign
id|cpu_to_le32
c_func
(paren
id|pcurr_tcb-&gt;tcb_phys
op_plus
l_int|0x10
)paren
suffix:semicolon
)brace
macro_line|#ifdef E100_ZEROCOPY
r_if
c_cond
(paren
id|bdp-&gt;flags
op_amp
id|IS_BACHELOR
)paren
(brace
id|pcurr_tcb-&gt;tcb_tbd_expand_ptr
op_assign
id|cpu_to_le32
c_func
(paren
id|pcurr_tcb-&gt;tcb_phys
op_plus
l_int|0x20
)paren
suffix:semicolon
)brace
r_else
(brace
id|pcurr_tcb-&gt;tcb_tbd_expand_ptr
op_assign
id|cpu_to_le32
c_func
(paren
id|pcurr_tcb-&gt;tcb_phys
op_plus
l_int|0x10
)paren
suffix:semicolon
)brace
id|pcurr_tcb-&gt;tcb_tbd_dflt_ptr
op_assign
id|pcurr_tcb-&gt;tcb_tbd_ptr
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|bdp-&gt;flags
op_amp
id|USE_IPCB
)paren
(brace
id|pcurr_tcb-&gt;tbd_ptr
op_assign
op_amp
(paren
id|pcurr_tcb-&gt;tcbu.tbd_array
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|pcurr_tcb-&gt;tcbu.ipcb.ip_activation_high
op_assign
id|IPCB_IP_ACTIVATION_DEFAULT
suffix:semicolon
id|pcurr_tcb-&gt;tcbu.ipcb.vlan
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|pcurr_tcb-&gt;tbd_ptr
op_assign
op_amp
(paren
id|pcurr_tcb-&gt;tcbu.tbd_array
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
id|pcurr_tcb-&gt;tcb_skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/***************************************************************************/
multiline_comment|/***************************************************************************/
multiline_comment|/*       Memory Management Routines                                        */
multiline_comment|/***************************************************************************/
multiline_comment|/**&n; * e100_alloc_space - allocate private driver data&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine allocates memory for the driver. Memory allocated is for the&n; * selftest and statistics structures.&n; *&n; * Returns:&n; *      0: if the operation was successful&n; *      %-ENOMEM: if memory allocation failed&n; */
r_int
r_char
id|__devinit
DECL|function|e100_alloc_space
id|e100_alloc_space
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
r_int
id|off
suffix:semicolon
multiline_comment|/* allocate all the dma-able structures in one call:&n;&t; * selftest results, adapter stats, and non-tx cb commands */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bdp-&gt;dma_able
op_assign
id|pci_alloc_consistent
c_func
(paren
id|bdp-&gt;pdev
comma
r_sizeof
(paren
id|bd_dma_able_t
)paren
comma
op_amp
(paren
id|bdp-&gt;dma_able_phys
)paren
)paren
)paren
)paren
(brace
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* now assign the various pointers into the struct we&squot;ve just allocated */
id|off
op_assign
m_offsetof
(paren
id|bd_dma_able_t
comma
id|selftest
)paren
suffix:semicolon
id|bdp-&gt;selftest
op_assign
(paren
id|self_test_t
op_star
)paren
(paren
id|bdp-&gt;dma_able
op_plus
id|off
)paren
suffix:semicolon
id|bdp-&gt;selftest_phys
op_assign
id|bdp-&gt;dma_able_phys
op_plus
id|off
suffix:semicolon
id|off
op_assign
m_offsetof
(paren
id|bd_dma_able_t
comma
id|stats_counters
)paren
suffix:semicolon
id|bdp-&gt;stats_counters
op_assign
(paren
id|max_counters_t
op_star
)paren
(paren
id|bdp-&gt;dma_able
op_plus
id|off
)paren
suffix:semicolon
id|bdp-&gt;stat_cnt_phys
op_assign
id|bdp-&gt;dma_able_phys
op_plus
id|off
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s - Failed to allocate memory&bslash;n&quot;
comma
id|e100_short_driver_name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_alloc_tcb_pool - allocate TCB circular list&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine allocates memory for the circular list of transmit descriptors.&n; *&n; * Returns:&n; *       0: if allocation has failed.&n; *       1: Otherwise. &n; */
r_int
DECL|function|e100_alloc_tcb_pool
id|e100_alloc_tcb_pool
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
id|stcb
op_assign
r_sizeof
(paren
id|tcb_t
)paren
op_star
id|bdp-&gt;params.TxDescriptors
suffix:semicolon
multiline_comment|/* allocate space for the TCBs */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bdp-&gt;tcb_pool.data
op_assign
id|pci_alloc_consistent
c_func
(paren
id|bdp-&gt;pdev
comma
id|stcb
comma
op_amp
id|bdp-&gt;tcb_phys
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|bdp-&gt;tcb_pool.data
comma
l_int|0x00
comma
id|stcb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|e100_free_tcb_pool
id|e100_free_tcb_pool
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|bdp-&gt;pdev
comma
r_sizeof
(paren
id|tcb_t
)paren
op_star
id|bdp-&gt;params.TxDescriptors
comma
id|bdp-&gt;tcb_pool.data
comma
id|bdp-&gt;tcb_phys
)paren
suffix:semicolon
id|bdp-&gt;tcb_phys
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_dealloc_space
id|e100_dealloc_space
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_if
c_cond
(paren
id|bdp-&gt;dma_able
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|bdp-&gt;pdev
comma
r_sizeof
(paren
id|bd_dma_able_t
)paren
comma
id|bdp-&gt;dma_able
comma
id|bdp-&gt;dma_able_phys
)paren
suffix:semicolon
)brace
id|bdp-&gt;selftest_phys
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;stat_cnt_phys
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;dma_able_phys
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;dma_able
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_free_rfd_pool
id|e100_free_rfd_pool
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_struct
id|rx_list_elem
op_star
id|rx_struct
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
(paren
id|bdp-&gt;active_rx_list
)paren
)paren
)paren
(brace
id|rx_struct
op_assign
id|list_entry
c_func
(paren
id|bdp-&gt;active_rx_list.next
comma
r_struct
id|rx_list_elem
comma
id|list_elem
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
(paren
id|rx_struct-&gt;list_elem
)paren
)paren
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|rx_struct-&gt;dma_addr
comma
r_sizeof
(paren
id|rfd_t
)paren
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|rx_struct-&gt;skb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rx_struct
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
(paren
id|bdp-&gt;rx_struct_pool
)paren
)paren
)paren
(brace
id|rx_struct
op_assign
id|list_entry
c_func
(paren
id|bdp-&gt;rx_struct_pool.next
comma
r_struct
id|rx_list_elem
comma
id|list_elem
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
(paren
id|rx_struct-&gt;list_elem
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rx_struct
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * e100_alloc_rfd_pool - allocate RFDs&n; * @bdp: atapter&squot;s private data struct&n; *&n; * Allocates initial pool of skb which holds both rfd and data,&n; * and return a pointer to the head of the list&n; */
r_static
r_int
DECL|function|e100_alloc_rfd_pool
id|e100_alloc_rfd_pool
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_struct
id|rx_list_elem
op_star
id|rx_struct
suffix:semicolon
r_int
id|i
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|bdp-&gt;active_rx_list
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|bdp-&gt;rx_struct_pool
)paren
)paren
suffix:semicolon
id|bdp-&gt;skb_req
op_assign
id|bdp-&gt;params.RxDescriptors
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bdp-&gt;skb_req
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rx_struct
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|rx_list_elem
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
(paren
id|rx_struct-&gt;list_elem
)paren
comma
op_amp
(paren
id|bdp-&gt;rx_struct_pool
)paren
)paren
suffix:semicolon
)brace
id|e100_alloc_skbs
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_return
op_logical_neg
id|list_empty
c_func
(paren
op_amp
(paren
id|bdp-&gt;active_rx_list
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|e100_clear_pools
id|e100_clear_pools
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|bdp-&gt;last_tcb
op_assign
l_int|NULL
suffix:semicolon
id|e100_free_rfd_pool
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|e100_free_tcb_pool
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*****************************************************************************/
multiline_comment|/*      Run Time Functions                                                   */
multiline_comment|/*****************************************************************************/
multiline_comment|/**&n; * e100_watchdog&n; * @dev: adapter&squot;s net_device struct&n; *&n; * This routine runs every 2 seconds and updates our statitics and link state,&n; * and refreshs txthld value.&n; */
r_void
DECL|function|e100_watchdog
id|e100_watchdog
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;driver_isolated
)paren
(brace
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|netif_running
c_func
(paren
id|dev
)paren
)paren
(brace
r_goto
m_exit
suffix:semicolon
)brace
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
multiline_comment|/* check if link state has changed */
r_if
c_cond
(paren
id|e100_phy_check
c_func
(paren
id|bdp
)paren
)paren
(brace
r_if
c_cond
(paren
id|netif_carrier_ok
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;e100: %s NIC Link is Up %d Mbps %s duplex&bslash;n&quot;
comma
id|bdp-&gt;device-&gt;name
comma
id|bdp-&gt;cur_line_speed
comma
(paren
id|bdp-&gt;cur_dplx_mode
op_eq
id|HALF_DUPLEX
)paren
ques
c_cond
l_string|&quot;Half&quot;
suffix:colon
l_string|&quot;Full&quot;
)paren
suffix:semicolon
id|e100_config_fc
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|e100_config
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;e100: %s NIC Link is Down&bslash;n&quot;
comma
id|bdp-&gt;device-&gt;name
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// toggle the tx queue according to link status
singleline_comment|// this also resolves a race condition between tx &amp; non-cu cmd flows
r_if
c_cond
(paren
id|netif_carrier_ok
c_func
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|rmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e100_update_stats
c_func
(paren
id|bdp
)paren
)paren
(brace
multiline_comment|/* Check if a change in the IFS parameter is needed,&n;&t;&t;   and configure the device accordingly */
r_if
c_cond
(paren
id|bdp-&gt;params.b_params
op_amp
id|PRM_IFS
)paren
id|e100_manage_adaptive_ifs
c_func
(paren
id|bdp
)paren
suffix:semicolon
multiline_comment|/* Now adjust our dynamic tx threshold value */
id|e100_refresh_txthld
c_func
(paren
id|bdp
)paren
suffix:semicolon
multiline_comment|/* Now if we are on a 557 and we havn&squot;t received any frames then we&n;&t;&t; * should issue a multicast command to reset the RU */
r_if
c_cond
(paren
id|bdp-&gt;rev_id
OL
id|D101A4_REV_ID
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bdp-&gt;stats_counters-&gt;basic_stats.rcv_gd_frames
)paren
)paren
(brace
id|e100_set_multi
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Update the statistics needed by the upper interface */
multiline_comment|/* This should be the last statistic related command&n;&t;&t; * as it&squot;s async. now */
id|e100_dump_stats_cntrs
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
multiline_comment|/* relaunch watchdog timer in 2 sec */
id|mod_timer
c_func
(paren
op_amp
(paren
id|bdp-&gt;watchdog_timer
)paren
comma
id|jiffies
op_plus
(paren
l_int|2
op_star
id|HZ
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|bdp-&gt;active_rx_list
)paren
)paren
id|e100_trigger_SWI
c_func
(paren
id|bdp
)paren
suffix:semicolon
m_exit
suffix:colon
id|read_unlock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_manage_adaptive_ifs&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine manages the adaptive Inter-Frame Spacing algorithm&n; * using a state machine.&n; */
r_void
DECL|function|e100_manage_adaptive_ifs
id|e100_manage_adaptive_ifs
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_static
id|u16
id|state_table
(braket
l_int|9
)braket
(braket
l_int|4
)braket
op_assign
(brace
singleline_comment|// rows are states
(brace
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
singleline_comment|// state0   // column0: next state if increasing
(brace
l_int|2
comma
l_int|0
comma
l_int|5
comma
l_int|30
)brace
comma
singleline_comment|// state1   // column1: next state if decreasing
(brace
l_int|5
comma
l_int|1
comma
l_int|5
comma
l_int|30
)brace
comma
singleline_comment|// state2   // column2: IFS value for 100 mbit
(brace
l_int|5
comma
l_int|3
comma
l_int|0
comma
l_int|0
)brace
comma
singleline_comment|// state3   // column3: IFS value for 10 mbit
(brace
l_int|5
comma
l_int|3
comma
l_int|10
comma
l_int|60
)brace
comma
singleline_comment|// state4
(brace
l_int|8
comma
l_int|4
comma
l_int|10
comma
l_int|60
)brace
comma
singleline_comment|// state5
(brace
l_int|8
comma
l_int|6
comma
l_int|0
comma
l_int|0
)brace
comma
singleline_comment|// state6
(brace
l_int|8
comma
l_int|6
comma
l_int|20
comma
l_int|60
)brace
comma
singleline_comment|// state7
(brace
l_int|8
comma
l_int|7
comma
l_int|20
comma
l_int|60
)brace
singleline_comment|// state8
)brace
suffix:semicolon
id|u32
id|transmits
op_assign
id|le32_to_cpu
c_func
(paren
id|bdp-&gt;stats_counters-&gt;basic_stats.xmt_gd_frames
)paren
suffix:semicolon
id|u32
id|collisions
op_assign
id|le32_to_cpu
c_func
(paren
id|bdp-&gt;stats_counters-&gt;basic_stats.xmt_ttl_coll
)paren
suffix:semicolon
id|u32
id|state
op_assign
id|bdp-&gt;ifs_state
suffix:semicolon
id|u32
id|old_value
op_assign
id|bdp-&gt;ifs_value
suffix:semicolon
r_int
id|next_col
suffix:semicolon
id|u32
id|min_transmits
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cur_dplx_mode
op_eq
id|FULL_DUPLEX
)paren
(brace
id|bdp-&gt;ifs_state
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;ifs_value
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Half Duplex */
multiline_comment|/* Set speed specific parameters */
r_if
c_cond
(paren
id|bdp-&gt;cur_line_speed
op_eq
l_int|100
)paren
(brace
id|next_col
op_assign
l_int|2
suffix:semicolon
id|min_transmits
op_assign
id|MIN_NUMBER_OF_TRANSMITS_100
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 10 Mbps */
id|next_col
op_assign
l_int|3
suffix:semicolon
id|min_transmits
op_assign
id|MIN_NUMBER_OF_TRANSMITS_10
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|transmits
op_div
l_int|32
OL
id|collisions
)paren
op_logical_and
(paren
id|transmits
OG
id|min_transmits
)paren
)paren
(brace
id|state
op_assign
id|state_table
(braket
id|state
)braket
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* increment */
)brace
r_else
r_if
c_cond
(paren
id|transmits
OL
id|min_transmits
)paren
(brace
id|state
op_assign
id|state_table
(braket
id|state
)braket
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* decrement */
)brace
id|bdp-&gt;ifs_value
op_assign
id|state_table
(braket
id|state
)braket
(braket
id|next_col
)braket
suffix:semicolon
id|bdp-&gt;ifs_state
op_assign
id|state
suffix:semicolon
)brace
multiline_comment|/* If the IFS value has changed, configure the device */
r_if
c_cond
(paren
id|bdp-&gt;ifs_value
op_ne
id|old_value
)paren
(brace
id|e100_config_ifs
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|e100_config
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|e100_polling_tasklet
id|e100_polling_tasklet
c_func
(paren
r_int
r_int
id|ptr
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
op_assign
(paren
r_struct
id|e100_private
op_star
)paren
id|ptr
suffix:semicolon
r_int
r_int
id|rx_congestion
op_assign
l_int|0
suffix:semicolon
id|u32
id|skb_cnt
suffix:semicolon
multiline_comment|/* the device is closed, don&squot;t continue or else bad things may happen. */
r_if
c_cond
(paren
op_logical_neg
id|netif_running
c_func
(paren
id|bdp-&gt;device
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;driver_isolated
)paren
(brace
id|tasklet_schedule
c_func
(paren
op_amp
(paren
id|bdp-&gt;polling_tasklet
)paren
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|e100_alloc_skbs
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|skb_cnt
op_assign
id|e100_rx_srv
c_func
(paren
id|bdp
comma
id|bdp-&gt;params.PollingMaxWork
comma
op_amp
id|rx_congestion
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.rx_tasklet_pkts
op_add_assign
id|skb_cnt
suffix:semicolon
r_if
c_cond
(paren
id|rx_congestion
op_logical_or
id|skb_cnt
)paren
(brace
id|tasklet_schedule
c_func
(paren
op_amp
(paren
id|bdp-&gt;polling_tasklet
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|bdp-&gt;intr_mask
op_and_assign
op_complement
id|SCB_INT_MASK
suffix:semicolon
id|bdp-&gt;drv_stats.poll_intr_switch
op_increment
suffix:semicolon
)brace
id|bdp-&gt;tx_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* restart tx interrupt batch count */
id|e100_tx_srv
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|e100_set_intr_mask
c_func
(paren
id|bdp
)paren
suffix:semicolon
m_exit
suffix:colon
id|read_unlock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * e100intr - interrupt handler&n; * @irq: the IRQ number&n; * @dev_inst: the net_device struct&n; * @regs: registers (unused)&n; *&n; * This routine is the ISR for the e100 board. It services&n; * the RX &amp; TX queues &amp; starts the RU if it has stopped due&n; * to no resources.&n; */
r_void
DECL|function|e100intr
id|e100intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_inst
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
id|u16
id|intr_status
suffix:semicolon
id|dev
op_assign
id|dev_inst
suffix:semicolon
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|intr_status
op_assign
id|readw
c_func
(paren
op_amp
id|bdp-&gt;scb-&gt;scb_status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|intr_status
op_logical_or
(paren
id|intr_status
op_eq
l_int|0xffff
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* disable intr before we ack &amp; after identifying the intr as ours */
id|e100_dis_intr
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|writew
c_func
(paren
id|intr_status
comma
op_amp
id|bdp-&gt;scb-&gt;scb_status
)paren
suffix:semicolon
multiline_comment|/* ack intrs */
multiline_comment|/* the device is closed, don&squot;t continue or else bad things may happen. */
r_if
c_cond
(paren
op_logical_neg
id|netif_running
c_func
(paren
id|dev
)paren
)paren
(brace
id|e100_set_intr_mask
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;driver_isolated
)paren
(brace
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* SWI intr (triggered by watchdog) is signal to allocate new skb buffers */
r_if
c_cond
(paren
id|intr_status
op_amp
id|SCB_STATUS_ACK_SWI
)paren
(brace
id|e100_alloc_skbs
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
multiline_comment|/* do recv work if any */
r_if
c_cond
(paren
id|intr_status
op_amp
(paren
id|SCB_STATUS_ACK_FR
op_or
id|SCB_STATUS_ACK_RNR
op_or
id|SCB_STATUS_ACK_SWI
)paren
)paren
(brace
r_int
id|rx_congestion
suffix:semicolon
id|bdp-&gt;drv_stats.rx_intr_pkts
op_add_assign
id|e100_rx_srv
c_func
(paren
id|bdp
comma
l_int|0
comma
op_amp
id|rx_congestion
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bdp-&gt;params.b_params
op_amp
id|PRM_RX_CONG
)paren
op_logical_and
id|rx_congestion
)paren
(brace
id|bdp-&gt;intr_mask
op_or_assign
id|SCB_INT_MASK
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
(paren
id|bdp-&gt;polling_tasklet
)paren
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.poll_intr_switch
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* clean up after tx&squot;ed packets */
r_if
c_cond
(paren
id|intr_status
op_amp
(paren
id|SCB_STATUS_ACK_CNA
op_or
id|SCB_STATUS_ACK_CX
)paren
)paren
(brace
id|bdp-&gt;tx_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* restart tx interrupt batch count */
id|e100_tx_srv
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
m_exit
suffix:colon
id|e100_set_intr_mask
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_tx_skb_free - free TX skbs resources&n; * @bdp: atapter&squot;s private data struct&n; * @tcb: associated tcb of the freed skb&n; *&n; * This routine frees resources of TX skbs.&n; */
r_static
r_void
r_inline
DECL|function|e100_tx_skb_free
id|e100_tx_skb_free
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|tcb_t
op_star
id|tcb
)paren
(brace
r_if
c_cond
(paren
id|tcb-&gt;tcb_skb
)paren
(brace
macro_line|#ifdef E100_ZEROCOPY
r_int
id|i
suffix:semicolon
id|tbd_t
op_star
id|tbd_arr
op_assign
id|tcb-&gt;tbd_ptr
suffix:semicolon
r_int
id|frags
op_assign
id|skb_shinfo
c_func
(paren
id|tcb-&gt;tcb_skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|frags
suffix:semicolon
id|i
op_increment
comma
id|tbd_arr
op_increment
)paren
(brace
id|pci_unmap_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|le32_to_cpu
c_func
(paren
id|tbd_arr-&gt;tbd_buf_addr
)paren
comma
id|le16_to_cpu
c_func
(paren
id|tbd_arr-&gt;tbd_buf_cnt
)paren
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
)brace
macro_line|#else
id|pci_unmap_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|le32_to_cpu
c_func
(paren
(paren
id|tcb-&gt;tbd_ptr
)paren
op_member_access_from_pointer
id|tbd_buf_addr
)paren
comma
id|tcb-&gt;tcb_skb-&gt;len
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
macro_line|#endif
id|dev_kfree_skb_irq
c_func
(paren
id|tcb-&gt;tcb_skb
)paren
suffix:semicolon
id|tcb-&gt;tcb_skb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * e100_tx_srv - service TX queues&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine services the TX queues. It reclaims the TCB&squot;s &amp; TBD&squot;s &amp; other&n; * resources used during the transmit of this buffer. It is called from the ISR.&n; * We don&squot;t need a tx_lock since we always access buffers which were already&n; * prepared.&n; */
r_void
DECL|function|e100_tx_srv
id|e100_tx_srv
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|tcb_t
op_star
id|tcb
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* go over at most TxDescriptors buffers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bdp-&gt;params.TxDescriptors
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcb
op_assign
id|bdp-&gt;tcb_pool.data
suffix:semicolon
id|tcb
op_add_assign
id|bdp-&gt;tcb_pool.head
suffix:semicolon
id|rmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* if the buffer at &squot;head&squot; is not complete, break */
r_if
c_cond
(paren
op_logical_neg
(paren
id|tcb-&gt;tcb_hdr.cb_status
op_amp
id|__constant_cpu_to_le16
c_func
(paren
id|CB_STATUS_COMPLETE
)paren
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* service next buffer, clear the out of resource condition */
id|e100_tx_skb_free
c_func
(paren
id|bdp
comma
id|tcb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|bdp-&gt;device
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|bdp-&gt;device
)paren
suffix:semicolon
multiline_comment|/* if we&squot;ve caught up with &squot;tail&squot;, break */
r_if
c_cond
(paren
id|NEXT_TCB_TOUSE
c_func
(paren
id|bdp-&gt;tcb_pool.head
)paren
op_eq
id|bdp-&gt;tcb_pool.tail
)paren
(brace
r_break
suffix:semicolon
)brace
id|bdp-&gt;tcb_pool.head
op_assign
id|NEXT_TCB_TOUSE
c_func
(paren
id|bdp-&gt;tcb_pool.head
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * e100_rx_srv - service RX queue&n; * @bdp: atapter&squot;s private data struct&n; * @max_number_of_rfds: max number of RFDs to process&n; * @rx_congestion: flag pointer, to inform the calling function of congestion.&n; *&n; * This routine processes the RX interrupt &amp; services the RX queues.&n; * For each successful RFD, it allocates a new msg block, links that&n; * into the RFD list, and sends the old msg upstream.&n; * The new RFD is then put at the end of the free list of RFD&squot;s.&n; * It returns the number of serviced RFDs.&n; */
id|u32
DECL|function|e100_rx_srv
id|e100_rx_srv
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u32
id|max_number_of_rfds
comma
r_int
op_star
id|rx_congestion
)paren
(brace
id|rfd_t
op_star
id|rfd
suffix:semicolon
multiline_comment|/* new rfd, received rfd */
r_int
id|i
suffix:semicolon
id|u16
id|rfd_status
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_int
r_int
id|data_sz
suffix:semicolon
r_struct
id|rx_list_elem
op_star
id|rx_struct
suffix:semicolon
id|u32
id|rfd_cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rx_congestion
)paren
(brace
op_star
id|rx_congestion
op_assign
l_int|0
suffix:semicolon
)brace
id|dev
op_assign
id|bdp-&gt;device
suffix:semicolon
multiline_comment|/* current design of rx is as following:&n;&t; * 1. socket buffer (skb) used to pass network packet to upper layer&n;&t; * 2. all HW host memory structures (like RFDs, RBDs and data buffers)&n;&t; *    are placed in a skb&squot;s data room&n;&t; * 3. when rx process is complete, we change skb internal pointers to exclude&n;&t; *    from data area all unrelated things (RFD, RDB) and to leave&n;&t; *    just rx&squot;ed packet netto&n;&t; * 4. for each skb passed to upper layer, new one is allocated instead.&n;&t; * 5. if no skb left, in 2 sec another atempt to allocate skbs will be made&n;&t; *    (watchdog trigger SWI intr and isr should allocate new skbs)&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bdp-&gt;params.RxDescriptors
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|max_number_of_rfds
op_logical_and
(paren
id|rfd_cnt
op_ge
id|max_number_of_rfds
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
(paren
id|bdp-&gt;active_rx_list
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|rx_struct
op_assign
id|list_entry
c_func
(paren
id|bdp-&gt;active_rx_list.next
comma
r_struct
id|rx_list_elem
comma
id|list_elem
)paren
suffix:semicolon
id|skb
op_assign
id|rx_struct-&gt;skb
suffix:semicolon
id|rfd
op_assign
id|RFD_POINTER
c_func
(paren
id|skb
comma
id|bdp
)paren
suffix:semicolon
multiline_comment|/* locate RFD within skb */
singleline_comment|// sync only the RFD header
id|pci_dma_sync_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|rx_struct-&gt;dma_addr
comma
id|bdp-&gt;rfd_size
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|rfd_status
op_assign
id|le16_to_cpu
c_func
(paren
id|rfd-&gt;rfd_header.cb_status
)paren
suffix:semicolon
multiline_comment|/* get RFD&squot;s status */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rfd_status
op_amp
id|RFD_STATUS_COMPLETE
)paren
)paren
multiline_comment|/* does not contains data yet - exit */
r_break
suffix:semicolon
multiline_comment|/* to allow manipulation with current skb we need to unlink it */
id|list_del
c_func
(paren
op_amp
(paren
id|rx_struct-&gt;list_elem
)paren
)paren
suffix:semicolon
multiline_comment|/* do not free &amp; unmap badly recieved packet.&n;&t;&t; * move it to the end of skb list for reuse */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rfd_status
op_amp
id|RFD_STATUS_OK
)paren
)paren
(brace
id|e100_add_skb_to_end
c_func
(paren
id|bdp
comma
id|rx_struct
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|data_sz
op_assign
id|min_t
c_func
(paren
id|u16
comma
(paren
id|le16_to_cpu
c_func
(paren
id|rfd-&gt;rfd_act_cnt
)paren
op_amp
l_int|0x3fff
)paren
comma
(paren
r_sizeof
(paren
id|rfd_t
)paren
op_minus
id|bdp-&gt;rfd_size
)paren
)paren
suffix:semicolon
multiline_comment|/* now sync all the data */
id|pci_dma_sync_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|rx_struct-&gt;dma_addr
comma
(paren
id|data_sz
op_plus
id|bdp-&gt;rfd_size
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|rx_struct-&gt;dma_addr
comma
r_sizeof
(paren
id|rfd_t
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
(paren
id|rx_struct-&gt;list_elem
)paren
comma
op_amp
(paren
id|bdp-&gt;rx_struct_pool
)paren
)paren
suffix:semicolon
multiline_comment|/* end of dma access to rfd */
id|bdp-&gt;skb_req
op_increment
suffix:semicolon
multiline_comment|/* incr number of requested skbs */
id|e100_alloc_skbs
c_func
(paren
id|bdp
)paren
suffix:semicolon
multiline_comment|/* and get them */
multiline_comment|/* set packet size, excluding checksum (2 last bytes) if it is present */
r_if
c_cond
(paren
(paren
id|bdp-&gt;flags
op_amp
id|DF_CSUM_OFFLOAD
)paren
op_logical_and
(paren
id|bdp-&gt;rev_id
OL
id|D102_REV_ID
)paren
)paren
id|skb_put
c_func
(paren
id|skb
comma
(paren
r_int
)paren
id|data_sz
op_minus
l_int|2
)paren
suffix:semicolon
r_else
id|skb_put
c_func
(paren
id|skb
comma
(paren
r_int
)paren
id|data_sz
)paren
suffix:semicolon
multiline_comment|/* set the protocol */
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* set the checksum info */
r_if
c_cond
(paren
id|bdp-&gt;flags
op_amp
id|DF_CSUM_OFFLOAD
)paren
(brace
r_if
c_cond
(paren
id|bdp-&gt;rev_id
op_ge
id|D102_REV_ID
)paren
(brace
id|skb-&gt;ip_summed
op_assign
id|e100_D102_check_checksum
c_func
(paren
id|rfd
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;ip_summed
op_assign
id|e100_D101M_checksum
c_func
(paren
id|bdp
comma
id|skb
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_NONE
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|netif_rx
c_func
(paren
id|skb
)paren
)paren
(brace
r_case
id|NET_RX_BAD
suffix:colon
r_break
suffix:semicolon
r_case
id|NET_RX_DROP
suffix:colon
r_case
id|NET_RX_CN_MOD
suffix:colon
r_case
id|NET_RX_CN_HIGH
suffix:colon
r_if
c_cond
(paren
id|bdp-&gt;params.b_params
op_amp
id|PRM_RX_CONG
)paren
(brace
r_if
c_cond
(paren
id|rx_congestion
)paren
(brace
op_star
id|rx_congestion
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* FALL THROUGH TO STATISTICS UPDATE */
r_default
suffix:colon
id|bdp-&gt;drv_stats.net_stats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
r_break
suffix:semicolon
)brace
id|rfd_cnt
op_increment
suffix:semicolon
)brace
multiline_comment|/* end of rfd loop */
multiline_comment|/* restart the RU if it has stopped */
r_if
c_cond
(paren
(paren
id|readw
c_func
(paren
op_amp
id|bdp-&gt;scb-&gt;scb_status
)paren
op_amp
id|SCB_RUS_MASK
)paren
op_ne
id|SCB_RUS_READY
)paren
(brace
id|e100_start_ru
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
r_return
id|rfd_cnt
suffix:semicolon
)brace
r_void
DECL|function|e100_refresh_txthld
id|e100_refresh_txthld
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|basic_cntr_t
op_star
id|pstat
op_assign
op_amp
(paren
id|bdp-&gt;stats_counters-&gt;basic_stats
)paren
suffix:semicolon
multiline_comment|/* as long as tx_per_underrun is not 0, we can go about dynamically *&n;&t; * adjusting the xmit threshold. we stop doing that &amp; resort to defaults&n;&t; * * once the adjustments become meaningless. the value is adjusted by *&n;&t; * dumping the error counters &amp; checking the # of xmit underrun errors *&n;&t; * we&squot;ve had. */
r_if
c_cond
(paren
id|bdp-&gt;tx_per_underrun
)paren
(brace
multiline_comment|/* We are going to last values dumped from the dump statistics&n;&t;&t; * command */
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_gd_frames
)paren
)paren
(brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_uruns
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t; * if we have had more than one underrun per &quot;DEFAULT #&n;&t;&t;&t;&t; * OF XMITS ALLOWED PER UNDERRUN&quot; good xmits, raise the&n;&t;&t;&t;&t; * THRESHOLD.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_gd_frames
)paren
op_div
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_uruns
)paren
)paren
OL
id|bdp-&gt;tx_per_underrun
)paren
(brace
id|bdp-&gt;tx_thld
op_add_assign
l_int|3
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;&t;&t;&t; * if we&squot;ve had less than one underrun per the DEFAULT number of&n;&t;&t;&t; * of good xmits allowed, lower the THOLD but not less than 0 &n;&t;&t;&t; */
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_gd_frames
)paren
OG
id|bdp-&gt;tx_per_underrun
)paren
(brace
id|bdp-&gt;tx_thld
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;tx_thld
OL
l_int|6
)paren
id|bdp-&gt;tx_thld
op_assign
l_int|6
suffix:semicolon
)brace
)brace
multiline_comment|/* end good xmits */
multiline_comment|/* &n;&t;&t; * * if our adjustments are becoming unresonable, stop adjusting &amp;&n;&t;&t; * resort * to defaults &amp; pray. A THOLD value &gt; 190 means that the&n;&t;&t; * adapter will * wait for 190*8=1520 bytes in TX FIFO before it&n;&t;&t; * starts xmit. Since * MTU is 1514, it doesn&squot;t make any sense for&n;&t;&t; * further increase. */
r_if
c_cond
(paren
id|bdp-&gt;tx_thld
op_ge
l_int|190
)paren
(brace
id|bdp-&gt;tx_per_underrun
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;tx_thld
op_assign
l_int|189
suffix:semicolon
)brace
)brace
multiline_comment|/* end underrun check */
)brace
macro_line|#ifdef E100_ZEROCOPY
multiline_comment|/**&n; * e100_pseudo_hdr_csum - compute IP pseudo-header checksum&n; * @ip: points to the header of the IP packet&n; *&n; * Return the 16 bit checksum of the IP pseudo-header.,which is computed&n; * on the fields: IP src, IP dst, next protocol, payload length.&n; * The checksum vaule is returned in network byte order.&n; */
r_static
r_inline
id|u16
DECL|function|e100_pseudo_hdr_csum
id|e100_pseudo_hdr_csum
c_func
(paren
r_const
r_struct
id|iphdr
op_star
id|ip
)paren
(brace
id|u32
id|pseudo
op_assign
l_int|0
suffix:semicolon
id|u32
id|payload_len
op_assign
l_int|0
suffix:semicolon
id|payload_len
op_assign
id|ntohs
c_func
(paren
id|ip-&gt;tot_len
)paren
op_minus
(paren
id|ip-&gt;ihl
op_star
l_int|4
)paren
suffix:semicolon
id|pseudo
op_add_assign
id|htons
c_func
(paren
id|payload_len
)paren
suffix:semicolon
id|pseudo
op_add_assign
(paren
id|ip-&gt;protocol
op_lshift
l_int|8
)paren
suffix:semicolon
id|pseudo
op_add_assign
id|ip-&gt;saddr
op_amp
l_int|0x0000ffff
suffix:semicolon
id|pseudo
op_add_assign
(paren
id|ip-&gt;saddr
op_amp
l_int|0xffff0000
)paren
op_rshift
l_int|16
suffix:semicolon
id|pseudo
op_add_assign
id|ip-&gt;daddr
op_amp
l_int|0x0000ffff
suffix:semicolon
id|pseudo
op_add_assign
(paren
id|ip-&gt;daddr
op_amp
l_int|0xffff0000
)paren
op_rshift
l_int|16
suffix:semicolon
r_return
id|FOLD_CSUM
c_func
(paren
id|pseudo
)paren
suffix:semicolon
)brace
macro_line|#endif /* E100_ZEROCOPY */
multiline_comment|/**&n; * e100_prepare_xmit_buff - prepare a buffer for transmission&n; * @bdp: atapter&squot;s private data struct&n; * @skb: skb to send&n; *&n; * This routine prepare a buffer for transmission. It checks&n; * the message length for the appropiate size. It picks up a&n; * free tcb from the TCB pool and sets up the corresponding&n; * TBD&squot;s. If the number of fragments are more than the number&n; * of TBD/TCB it copies all the fragments in a coalesce buffer.&n; * It returns a pointer to the prepared TCB.&n; */
r_static
r_inline
id|tcb_t
op_star
DECL|function|e100_prepare_xmit_buff
id|e100_prepare_xmit_buff
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|tcb_t
op_star
id|tcb
comma
op_star
id|prev_tcb
suffix:semicolon
id|tcb
op_assign
id|bdp-&gt;tcb_pool.data
suffix:semicolon
id|tcb
op_add_assign
id|TCB_TO_USE
c_func
(paren
id|bdp-&gt;tcb_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;flags
op_amp
id|USE_IPCB
)paren
(brace
id|tcb-&gt;tcbu.ipcb.ip_activation_high
op_assign
id|IPCB_IP_ACTIVATION_DEFAULT
suffix:semicolon
id|tcb-&gt;tcbu.ipcb.ip_schedule
op_and_assign
op_complement
id|IPCB_TCP_PACKET
suffix:semicolon
id|tcb-&gt;tcbu.ipcb.ip_schedule
op_and_assign
op_complement
id|IPCB_TCPUDP_CHECKSUM_ENABLE
suffix:semicolon
)brace
id|tcb-&gt;tcb_hdr.cb_status
op_assign
l_int|0
suffix:semicolon
id|tcb-&gt;tcb_thrshld
op_assign
id|bdp-&gt;tx_thld
suffix:semicolon
id|tcb-&gt;tcb_hdr.cb_cmd
op_or_assign
id|__constant_cpu_to_le16
c_func
(paren
id|CB_S_BIT
)paren
suffix:semicolon
multiline_comment|/* set the I bit on the modulo tcbs, so we will get an interrupt * to&n;&t; * clean things up */
r_if
c_cond
(paren
op_logical_neg
(paren
op_increment
id|bdp-&gt;tx_count
op_mod
id|TX_FRAME_CNT
)paren
)paren
(brace
id|tcb-&gt;tcb_hdr.cb_cmd
op_or_assign
id|__constant_cpu_to_le16
c_func
(paren
id|CB_I_BIT
)paren
suffix:semicolon
)brace
id|tcb-&gt;tcb_skb
op_assign
id|skb
suffix:semicolon
macro_line|#ifdef E100_ZEROCOPY
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_eq
id|CHECKSUM_HW
)paren
(brace
r_const
r_struct
id|iphdr
op_star
id|ip
op_assign
id|skb-&gt;nh.iph
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip-&gt;protocol
op_eq
id|IPPROTO_TCP
)paren
op_logical_or
(paren
id|ip-&gt;protocol
op_eq
id|IPPROTO_UDP
)paren
)paren
(brace
id|u16
op_star
id|chksum
suffix:semicolon
id|tcb-&gt;tcbu.ipcb.ip_activation_high
op_assign
id|IPCB_HARDWAREPARSING_ENABLE
suffix:semicolon
id|tcb-&gt;tcbu.ipcb.ip_schedule
op_or_assign
id|IPCB_TCPUDP_CHECKSUM_ENABLE
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;protocol
op_eq
id|IPPROTO_TCP
)paren
(brace
r_struct
id|tcphdr
op_star
id|tcp
suffix:semicolon
id|tcp
op_assign
(paren
r_struct
id|tcphdr
op_star
)paren
(paren
(paren
id|u32
op_star
)paren
id|ip
op_plus
id|ip-&gt;ihl
)paren
suffix:semicolon
id|chksum
op_assign
op_amp
(paren
id|tcp-&gt;check
)paren
suffix:semicolon
id|tcb-&gt;tcbu.ipcb.ip_schedule
op_or_assign
id|IPCB_TCP_PACKET
suffix:semicolon
)brace
r_else
(brace
r_struct
id|udphdr
op_star
id|udp
suffix:semicolon
id|udp
op_assign
(paren
r_struct
id|udphdr
op_star
)paren
(paren
(paren
id|u32
op_star
)paren
id|ip
op_plus
id|ip-&gt;ihl
)paren
suffix:semicolon
id|chksum
op_assign
op_amp
(paren
id|udp-&gt;check
)paren
suffix:semicolon
)brace
op_star
id|chksum
op_assign
id|e100_pseudo_hdr_csum
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
)paren
(brace
(paren
id|tcb-&gt;tbd_ptr
)paren
op_member_access_from_pointer
id|tbd_buf_addr
op_assign
id|cpu_to_le32
c_func
(paren
id|pci_map_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|skb-&gt;data
comma
id|skb-&gt;len
comma
id|PCI_DMA_TODEVICE
)paren
)paren
suffix:semicolon
(paren
id|tcb-&gt;tbd_ptr
)paren
op_member_access_from_pointer
id|tbd_buf_cnt
op_assign
id|cpu_to_le16
c_func
(paren
id|skb-&gt;len
)paren
suffix:semicolon
id|tcb-&gt;tcb_tbd_num
op_assign
l_int|1
suffix:semicolon
id|tcb-&gt;tcb_tbd_ptr
op_assign
id|tcb-&gt;tcb_tbd_dflt_ptr
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_void
op_star
id|addr
suffix:semicolon
id|tbd_t
op_star
id|tbd_arr_ptr
op_assign
op_amp
(paren
id|tcb-&gt;tbd_ptr
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|skb_frag_t
op_star
id|frag
op_assign
op_amp
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
l_int|0
)braket
suffix:semicolon
(paren
id|tcb-&gt;tbd_ptr
)paren
op_member_access_from_pointer
id|tbd_buf_addr
op_assign
id|cpu_to_le32
c_func
(paren
id|pci_map_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|skb-&gt;data
comma
(paren
id|skb-&gt;len
op_minus
id|skb-&gt;data_len
)paren
comma
id|PCI_DMA_TODEVICE
)paren
)paren
suffix:semicolon
(paren
id|tcb-&gt;tbd_ptr
)paren
op_member_access_from_pointer
id|tbd_buf_cnt
op_assign
id|cpu_to_le16
c_func
(paren
id|skb-&gt;len
op_minus
id|skb-&gt;data_len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|i
op_increment
comma
id|tbd_arr_ptr
op_increment
comma
id|frag
op_increment
)paren
(brace
id|addr
op_assign
(paren
(paren
r_void
op_star
)paren
id|page_address
c_func
(paren
id|frag-&gt;page
)paren
op_plus
id|frag-&gt;page_offset
)paren
suffix:semicolon
id|tbd_arr_ptr-&gt;tbd_buf_addr
op_assign
id|cpu_to_le32
c_func
(paren
id|pci_map_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|addr
comma
id|frag-&gt;size
comma
id|PCI_DMA_TODEVICE
)paren
)paren
suffix:semicolon
id|tbd_arr_ptr-&gt;tbd_buf_cnt
op_assign
id|cpu_to_le16
c_func
(paren
id|frag-&gt;size
)paren
suffix:semicolon
)brace
id|tcb-&gt;tcb_tbd_num
op_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_plus
l_int|1
suffix:semicolon
id|tcb-&gt;tcb_tbd_ptr
op_assign
id|tcb-&gt;tcb_tbd_expand_ptr
suffix:semicolon
)brace
macro_line|#else
(paren
id|tcb-&gt;tbd_ptr
)paren
op_member_access_from_pointer
id|tbd_buf_addr
op_assign
id|cpu_to_le32
c_func
(paren
id|pci_map_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|skb-&gt;data
comma
id|skb-&gt;len
comma
id|PCI_DMA_TODEVICE
)paren
)paren
suffix:semicolon
(paren
id|tcb-&gt;tbd_ptr
)paren
op_member_access_from_pointer
id|tbd_buf_cnt
op_assign
id|cpu_to_le16
c_func
(paren
id|skb-&gt;len
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* clear the S-BIT on the previous tcb */
id|prev_tcb
op_assign
id|bdp-&gt;tcb_pool.data
suffix:semicolon
id|prev_tcb
op_add_assign
id|PREV_TCB_USED
c_func
(paren
id|bdp-&gt;tcb_pool
)paren
suffix:semicolon
id|prev_tcb-&gt;tcb_hdr.cb_cmd
op_and_assign
id|__constant_cpu_to_le16
c_func
(paren
(paren
id|u16
)paren
op_complement
id|CB_S_BIT
)paren
suffix:semicolon
id|bdp-&gt;tcb_pool.tail
op_assign
id|NEXT_TCB_TOUSE
c_func
(paren
id|bdp-&gt;tcb_pool.tail
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|e100_start_cu
c_func
(paren
id|bdp
comma
id|tcb
)paren
suffix:semicolon
r_return
id|tcb
suffix:semicolon
)brace
multiline_comment|/* Changed for 82558 enhancement */
multiline_comment|/**&n; * e100_start_cu - start the adapter&squot;s CU&n; * @bdp: atapter&squot;s private data struct&n; * @tcb: TCB to be transmitted&n; *&n; * This routine issues a CU Start or CU Resume command to the 82558/9.&n; * This routine was added because the prepare_ext_xmit_buff takes advantage&n; * of the 82558/9&squot;s Dynamic TBD chaining feature and has to start the CU as&n; * soon as the first TBD is ready. &n; *&n; * e100_start_cu must be called while holding the tx_lock ! &n; */
r_void
DECL|function|e100_start_cu
id|e100_start_cu
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|tcb_t
op_star
id|tcb
)paren
(brace
r_int
r_int
id|lock_flag
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_lock
)paren
comma
id|lock_flag
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bdp-&gt;next_cu_cmd
)paren
(brace
r_case
id|RESUME_NO_WAIT
suffix:colon
multiline_comment|/*last cu command was a CU_RESMUE if this is a 558 or newer we dont need to&n;&t;&t; * wait for command word to clear, we reach here only if we are bachlor&n;&t;&t; */
id|e100_exec_cmd
c_func
(paren
id|bdp
comma
id|SCB_CUC_RESUME
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESUME_WAIT
suffix:colon
r_if
c_cond
(paren
(paren
id|bdp-&gt;flags
op_amp
id|IS_ICH
)paren
op_logical_and
(paren
id|bdp-&gt;cur_line_speed
op_eq
l_int|10
)paren
op_logical_and
(paren
id|bdp-&gt;cur_dplx_mode
op_eq
id|HALF_DUPLEX
)paren
)paren
(brace
id|e100_wait_exec_simple
c_func
(paren
id|bdp
comma
id|SCB_CUC_NOOP
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|e100_wait_exec_simple
c_func
(paren
id|bdp
comma
id|SCB_CUC_RESUME
)paren
)paren
op_logical_and
(paren
id|bdp-&gt;flags
op_amp
id|IS_BACHELOR
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|bdp-&gt;flags
op_amp
id|IS_ICH
)paren
)paren
)paren
(brace
id|bdp-&gt;next_cu_cmd
op_assign
id|RESUME_NO_WAIT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|START_WAIT
suffix:colon
singleline_comment|// The last command was a non_tx CU command
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_cus_idle
c_func
(paren
id|bdp
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s cu_start: timeout waiting for cu&bslash;n&quot;
comma
id|bdp-&gt;device-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_exec_cmplx
c_func
(paren
id|bdp
comma
(paren
id|u32
)paren
(paren
id|tcb-&gt;tcb_phys
)paren
comma
id|SCB_CUC_START
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s cu_start: timeout waiting for scb&bslash;n&quot;
comma
id|bdp-&gt;device-&gt;name
)paren
suffix:semicolon
id|e100_exec_cmplx
c_func
(paren
id|bdp
comma
(paren
id|u32
)paren
(paren
id|tcb-&gt;tcb_phys
)paren
comma
id|SCB_CUC_START
)paren
suffix:semicolon
)brace
id|bdp-&gt;next_cu_cmd
op_assign
id|RESUME_WAIT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* save the last tcb */
id|bdp-&gt;last_tcb
op_assign
id|tcb
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_lock
)paren
comma
id|lock_flag
)paren
suffix:semicolon
)brace
multiline_comment|/* ====================================================================== */
multiline_comment|/* hw                                                                     */
multiline_comment|/* ====================================================================== */
multiline_comment|/**&n; * e100_selftest - perform H/W self test&n; * @bdp: atapter&squot;s private data struct&n; * @st_timeout: address to return timeout value, if fails&n; * @st_result: address to return selftest result, if fails&n; *&n; * This routine will issue PORT Self-test command to test the e100.&n; * The self-test will fail if the adapter&squot;s master-enable bit is not&n; * set in the PCI Command Register, or if the adapter is not seated&n; * in a PCI master-enabled slot. we also disable interrupts when the&n; * command is completed.&n; *&n; * Returns:&n; *      true: if adapter passes self_test&n; *      false: otherwise&n; */
r_int
r_char
DECL|function|e100_selftest
id|e100_selftest
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u32
op_star
id|st_timeout
comma
id|u32
op_star
id|st_result
)paren
(brace
id|u32
id|selftest_cmd
suffix:semicolon
multiline_comment|/* initialize the nic state before running test */
id|e100_sw_reset
c_func
(paren
id|bdp
comma
id|PORT_SOFTWARE_RESET
)paren
suffix:semicolon
multiline_comment|/* Setup the address of the self_test area */
id|selftest_cmd
op_assign
id|bdp-&gt;selftest_phys
suffix:semicolon
multiline_comment|/* Setup SELF TEST Command Code in D3 - D0 */
id|selftest_cmd
op_or_assign
id|PORT_SELFTEST
suffix:semicolon
multiline_comment|/* Initialize the self-test signature and results DWORDS */
id|bdp-&gt;selftest-&gt;st_sign
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;selftest-&gt;st_result
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* Do the port command */
id|writel
c_func
(paren
id|selftest_cmd
comma
op_amp
id|bdp-&gt;scb-&gt;scb_port
)paren
suffix:semicolon
id|readw
c_func
(paren
op_amp
(paren
id|bdp-&gt;scb-&gt;scb_status
)paren
)paren
suffix:semicolon
multiline_comment|/* flushes last write, read-safe */
multiline_comment|/* Wait at least 10 milliseconds for the self-test to complete */
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|100
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* disable interrupts since the&squot;re now enabled */
id|e100_dis_intr
c_func
(paren
id|bdp
)paren
suffix:semicolon
multiline_comment|/* if The First Self Test DWORD Still Zero, We&squot;ve timed out. If the&n;&t; * second DWORD is not zero then we have an error. */
r_if
c_cond
(paren
(paren
id|bdp-&gt;selftest-&gt;st_sign
op_eq
l_int|0
)paren
op_logical_or
(paren
id|bdp-&gt;selftest-&gt;st_result
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|st_timeout
)paren
op_star
id|st_timeout
op_assign
op_logical_neg
(paren
id|le32_to_cpu
c_func
(paren
id|bdp-&gt;selftest-&gt;st_sign
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st_result
)paren
op_star
id|st_result
op_assign
id|le32_to_cpu
c_func
(paren
id|bdp-&gt;selftest-&gt;st_result
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_setup_iaaddr - issue IA setup sommand&n; * @bdp: atapter&squot;s private data struct&n; * @eaddr: new ethernet address&n; *&n; * This routine will issue the IA setup command. This command&n; * will notify the 82557 (e100) of what its individual (node)&n; * address is. This command will be executed in polled mode.&n; *&n; * Returns:&n; *      true: if the IA setup command was successfully issued and completed&n; *      false: otherwise&n; */
r_int
r_char
DECL|function|e100_setup_iaaddr
id|e100_setup_iaaddr
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u8
op_star
id|eaddr
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|cb_header_t
op_star
id|ntcb_hdr
suffix:semicolon
r_int
r_char
id|res
suffix:semicolon
id|nxmit_cb_entry_t
op_star
id|cmd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_assign
id|e100_alloc_non_tx_cmd
c_func
(paren
id|bdp
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|res
op_assign
l_bool|false
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|ntcb_hdr
op_assign
(paren
id|cb_header_t
op_star
)paren
id|cmd-&gt;non_tx_cmd
suffix:semicolon
id|ntcb_hdr-&gt;cb_cmd
op_assign
id|__constant_cpu_to_le16
c_func
(paren
id|CB_IA_ADDRESS
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
(paren
id|cmd-&gt;non_tx_cmd
)paren
op_member_access_from_pointer
id|ntcb.setup.ia_addr
(braket
id|i
)braket
op_assign
id|eaddr
(braket
id|i
)braket
suffix:semicolon
)brace
id|res
op_assign
id|e100_exec_non_cu_cmd
c_func
(paren
id|bdp
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s IA setup failed&bslash;n&quot;
comma
id|bdp-&gt;device-&gt;name
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_start_ru - start the RU if needed&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine checks the status of the 82557&squot;s receive unit(RU),&n; * and starts the RU if it was not already active.  However,&n; * before restarting the RU, the driver gives the RU the buffers&n; * it freed up during the servicing of the ISR. If there are&n; * no free buffers to give to the RU, (i.e. we have reached a&n; * no resource condition) the RU will not be started till the&n; * next ISR.&n; */
r_void
DECL|function|e100_start_ru
id|e100_start_ru
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_struct
id|rx_list_elem
op_star
id|rx_struct
op_assign
l_int|NULL
suffix:semicolon
r_int
id|buffer_found
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|entry_ptr
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry_ptr
comma
op_amp
(paren
id|bdp-&gt;active_rx_list
)paren
)paren
(brace
id|rx_struct
op_assign
id|list_entry
c_func
(paren
id|entry_ptr
comma
r_struct
id|rx_list_elem
comma
id|list_elem
)paren
suffix:semicolon
id|pci_dma_sync_single
c_func
(paren
id|bdp-&gt;pdev
comma
id|rx_struct-&gt;dma_addr
comma
id|bdp-&gt;rfd_size
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|SKB_RFD_STATUS
c_func
(paren
id|rx_struct-&gt;skb
comma
id|bdp
)paren
op_amp
id|__constant_cpu_to_le16
c_func
(paren
id|RFD_STATUS_COMPLETE
)paren
)paren
)paren
)paren
(brace
id|buffer_found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* No available buffers */
r_if
c_cond
(paren
op_logical_neg
id|buffer_found
)paren
(brace
r_return
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|bdp-&gt;bd_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_exec_cmplx
c_func
(paren
id|bdp
comma
id|rx_struct-&gt;dma_addr
comma
id|SCB_RUC_START
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s start_ru: wait_scb failed&bslash;n&quot;
comma
id|bdp-&gt;device-&gt;name
)paren
suffix:semicolon
id|e100_exec_cmplx
c_func
(paren
id|bdp
comma
id|rx_struct-&gt;dma_addr
comma
id|SCB_RUC_START
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bdp-&gt;next_cu_cmd
op_eq
id|RESUME_NO_WAIT
)paren
(brace
id|bdp-&gt;next_cu_cmd
op_assign
id|RESUME_WAIT
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|bdp-&gt;bd_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_cmd_complete_location&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine returns a pointer to the location of the command-complete&n; * DWord in the dump statistical counters area, according to the statistical&n; * counters mode (557 - basic, 558 - extended, or 559 - TCO mode).&n; * See e100_config_init() for the setting of the statistical counters mode.&n; */
r_static
id|u32
op_star
DECL|function|e100_cmd_complete_location
id|e100_cmd_complete_location
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|u32
op_star
id|cmd_complete
suffix:semicolon
id|max_counters_t
op_star
id|stats
op_assign
id|bdp-&gt;stats_counters
suffix:semicolon
r_switch
c_cond
(paren
id|bdp-&gt;stat_mode
)paren
(brace
r_case
id|E100_EXTENDED_STATS
suffix:colon
id|cmd_complete
op_assign
(paren
id|u32
op_star
)paren
op_amp
(paren
(paren
(paren
id|err_cntr_558_t
op_star
)paren
(paren
id|stats
)paren
)paren
op_member_access_from_pointer
id|cmd_complete
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E100_TCO_STATS
suffix:colon
id|cmd_complete
op_assign
(paren
id|u32
op_star
)paren
op_amp
(paren
(paren
(paren
id|err_cntr_559_t
op_star
)paren
(paren
id|stats
)paren
)paren
op_member_access_from_pointer
id|cmd_complete
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E100_BASIC_STATS
suffix:colon
r_default
suffix:colon
id|cmd_complete
op_assign
(paren
id|u32
op_star
)paren
op_amp
(paren
(paren
(paren
id|err_cntr_557_t
op_star
)paren
(paren
id|stats
)paren
)paren
op_member_access_from_pointer
id|cmd_complete
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|cmd_complete
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_clr_cntrs - clear statistics counters&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine will clear the adapter error statistic counters.&n; *&n; * Returns:&n; *      true: if successfully cleared stat counters&n; *      false: otherwise&n; */
r_static
r_int
r_char
id|__devinit
DECL|function|e100_clr_cntrs
id|e100_clr_cntrs
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_volatile
id|u32
op_star
id|pcmd_complete
suffix:semicolon
multiline_comment|/* clear the dump counter complete word */
id|pcmd_complete
op_assign
id|e100_cmd_complete_location
c_func
(paren
id|bdp
)paren
suffix:semicolon
op_star
id|pcmd_complete
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_exec_cmplx
c_func
(paren
id|bdp
comma
id|bdp-&gt;stat_cnt_phys
comma
id|SCB_CUC_DUMP_ADDR
)paren
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/* wait 10 microseconds for the command to complete */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_exec_simple
c_func
(paren
id|bdp
comma
id|SCB_CUC_DUMP_RST_STAT
)paren
)paren
r_return
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;next_cu_cmd
op_eq
id|RESUME_NO_WAIT
)paren
(brace
id|bdp-&gt;next_cu_cmd
op_assign
id|RESUME_WAIT
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
r_static
r_int
r_char
DECL|function|e100_update_stats
id|e100_update_stats
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|u32
op_star
id|pcmd_complete
suffix:semicolon
id|basic_cntr_t
op_star
id|pstat
op_assign
op_amp
(paren
id|bdp-&gt;stats_counters-&gt;basic_stats
)paren
suffix:semicolon
singleline_comment|// check if last dump command completed
id|pcmd_complete
op_assign
id|e100_cmd_complete_location
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pcmd_complete
op_ne
id|le32_to_cpu
c_func
(paren
id|DUMP_RST_STAT_COMPLETED
)paren
op_logical_and
op_star
id|pcmd_complete
op_ne
id|le32_to_cpu
c_func
(paren
id|DUMP_STAT_COMPLETED
)paren
)paren
(brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/* increment the statistics */
id|bdp-&gt;drv_stats.net_stats.rx_packets
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;rcv_gd_frames
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.tx_packets
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_gd_frames
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.rx_dropped
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;rcv_rsrc_err
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.collisions
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_ttl_coll
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.rx_length_errors
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;rcv_shrt_frames
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.rx_over_errors
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;rcv_rsrc_err
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.rx_crc_errors
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;rcv_crc_errs
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.rx_frame_errors
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;rcv_algn_errs
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.rx_fifo_errors
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;rcv_oruns
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.tx_aborted_errors
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_max_coll
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.tx_carrier_errors
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_lost_crs
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.net_stats.tx_fifo_errors
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_uruns
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.tx_late_col
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_late_coll
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.tx_ok_defrd
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_deferred
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.tx_one_retry
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_sngl_coll
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.tx_mt_one_retry
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;xmt_mlt_coll
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.rcv_cdt_frames
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pstat-&gt;rcv_err_coll
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;stat_mode
op_ne
id|E100_BASIC_STATS
)paren
(brace
id|ext_cntr_t
op_star
id|pex_stat
op_assign
op_amp
id|bdp-&gt;stats_counters-&gt;extended_stats
suffix:semicolon
id|bdp-&gt;drv_stats.xmt_fc_pkts
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pex_stat-&gt;xmt_fc_frames
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.rcv_fc_pkts
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pex_stat-&gt;rcv_fc_frames
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.rcv_fc_unsupported
op_add_assign
id|le32_to_cpu
c_func
(paren
id|pex_stat-&gt;rcv_fc_unsupported
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bdp-&gt;stat_mode
op_eq
id|E100_TCO_STATS
)paren
(brace
id|tco_cntr_t
op_star
id|ptco_stat
op_assign
op_amp
id|bdp-&gt;stats_counters-&gt;tco_stats
suffix:semicolon
id|bdp-&gt;drv_stats.xmt_tco_pkts
op_add_assign
id|le16_to_cpu
c_func
(paren
id|ptco_stat-&gt;xmt_tco_frames
)paren
suffix:semicolon
id|bdp-&gt;drv_stats.rcv_tco_pkts
op_add_assign
id|le16_to_cpu
c_func
(paren
id|ptco_stat-&gt;rcv_tco_frames
)paren
suffix:semicolon
)brace
op_star
id|pcmd_complete
op_assign
l_int|0
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_dump_stat_cntrs&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine will dump the board statistical counters without waiting&n; * for stat_dump to complete. Any access to this stats should verify the completion&n; * of the command&n; */
r_void
DECL|function|e100_dump_stats_cntrs
id|e100_dump_stats_cntrs
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
r_int
id|lock_flag_bd
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_lock
)paren
comma
id|lock_flag_bd
)paren
suffix:semicolon
multiline_comment|/* dump h/w stats counters */
r_if
c_cond
(paren
id|e100_wait_exec_simple
c_func
(paren
id|bdp
comma
id|SCB_CUC_DUMP_RST_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|bdp-&gt;next_cu_cmd
op_eq
id|RESUME_NO_WAIT
)paren
(brace
id|bdp-&gt;next_cu_cmd
op_assign
id|RESUME_WAIT
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_lock
)paren
comma
id|lock_flag_bd
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_exec_non_cu_cmd&n; * @bdp: atapter&squot;s private data struct&n; * @command: the non-cu command to execute&n; *&n; * This routine will submit a command block to be executed,&n; */
r_int
r_char
DECL|function|e100_exec_non_cu_cmd
id|e100_exec_non_cu_cmd
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|nxmit_cb_entry_t
op_star
id|command
)paren
(brace
id|cb_header_t
op_star
id|ntcb_hdr
suffix:semicolon
r_int
r_int
id|lock_flag
suffix:semicolon
r_int
r_int
id|expiration_time
suffix:semicolon
r_int
r_char
id|rc
op_assign
l_bool|true
suffix:semicolon
id|ntcb_hdr
op_assign
(paren
id|cb_header_t
op_star
)paren
id|command-&gt;non_tx_cmd
suffix:semicolon
multiline_comment|/* get hdr of non tcb cmd */
multiline_comment|/* Set the Command Block to be the last command block */
id|ntcb_hdr-&gt;cb_cmd
op_or_assign
id|__constant_cpu_to_le16
c_func
(paren
id|CB_EL_BIT
)paren
suffix:semicolon
id|ntcb_hdr-&gt;cb_status
op_assign
l_int|0
suffix:semicolon
id|ntcb_hdr-&gt;cb_lnk_ptr
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
r_return
id|e100_delayed_exec_non_cu_cmd
c_func
(paren
id|bdp
comma
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|bdp-&gt;device
)paren
op_logical_and
(paren
op_logical_neg
id|bdp-&gt;driver_isolated
)paren
)paren
r_return
id|e100_delayed_exec_non_cu_cmd
c_func
(paren
id|bdp
comma
id|command
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_non_tx_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;non_tx_command_state
op_ne
id|E100_NON_TX_IDLE
)paren
(brace
r_goto
id|delayed_exec
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bdp-&gt;last_tcb
)paren
(brace
id|rmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bdp-&gt;last_tcb-&gt;tcb_hdr.cb_status
op_amp
id|__constant_cpu_to_le16
c_func
(paren
id|CB_STATUS_COMPLETE
)paren
)paren
op_eq
l_int|0
)paren
r_goto
id|delayed_exec
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|readw
c_func
(paren
op_amp
id|bdp-&gt;scb-&gt;scb_status
)paren
op_amp
id|SCB_CUS_MASK
)paren
op_eq
id|SCB_CUS_ACTIVE
)paren
(brace
r_goto
id|delayed_exec
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|bdp-&gt;bd_lock
comma
id|lock_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_exec_cmplx
c_func
(paren
id|bdp
comma
id|command-&gt;dma_addr
comma
id|SCB_CUC_START
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_lock
)paren
comma
id|lock_flag
)paren
suffix:semicolon
id|rc
op_assign
l_bool|false
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|bdp-&gt;next_cu_cmd
op_assign
id|START_WAIT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_lock
)paren
comma
id|lock_flag
)paren
suffix:semicolon
multiline_comment|/* now wait for completion of non-cu CB up to 20 msec */
id|expiration_time
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|50
op_plus
l_int|1
suffix:semicolon
id|rmb
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|ntcb_hdr-&gt;cb_status
op_amp
id|__constant_cpu_to_le16
c_func
(paren
id|CB_STATUS_COMPLETE
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|expiration_time
)paren
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_non_tx_lock
)paren
)paren
suffix:semicolon
id|yield
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_non_tx_lock
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|rc
op_assign
l_bool|false
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|rmb
c_func
(paren
)paren
suffix:semicolon
)brace
m_exit
suffix:colon
id|e100_free_non_tx_cmd
c_func
(paren
id|bdp
comma
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|bdp-&gt;device
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|bdp-&gt;device
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_non_tx_lock
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
id|delayed_exec
suffix:colon
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_non_tx_lock
)paren
)paren
suffix:semicolon
r_return
id|e100_delayed_exec_non_cu_cmd
c_func
(paren
id|bdp
comma
id|command
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_sw_reset&n; * @bdp: atapter&squot;s private data struct&n; * @reset_cmd: s/w reset or selective reset&n; *&n; * This routine will issue a software reset to the adapter. It &n; * will also disable interrupts, as the are enabled after reset.&n; */
r_void
DECL|function|e100_sw_reset
id|e100_sw_reset
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u32
id|reset_cmd
)paren
(brace
multiline_comment|/* Do  a selective reset first to avoid a potential PCI hang */
id|writel
c_func
(paren
id|PORT_SELECTIVE_RESET
comma
op_amp
id|bdp-&gt;scb-&gt;scb_port
)paren
suffix:semicolon
id|readw
c_func
(paren
op_amp
(paren
id|bdp-&gt;scb-&gt;scb_status
)paren
)paren
suffix:semicolon
multiline_comment|/* flushes last write, read-safe */
multiline_comment|/* wait for the reset to take effect */
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset_cmd
op_eq
id|PORT_SOFTWARE_RESET
)paren
(brace
id|writel
c_func
(paren
id|PORT_SOFTWARE_RESET
comma
op_amp
id|bdp-&gt;scb-&gt;scb_port
)paren
suffix:semicolon
multiline_comment|/* wait 20 micro seconds for the reset to take effect */
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
)brace
multiline_comment|/* Mask off our interrupt line -- its unmasked after reset */
id|e100_dis_intr
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_load_microcode - Download microsocde to controller.&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine downloads microcode on to the controller. This&n; * microcode is available for the 82558/9, 82550. Currently the&n; * microcode handles interrupt bundling and TCO workaround.&n; *&n; * Returns:&n; *      true: if successfull&n; *      false: otherwise&n; */
r_static
r_int
r_char
DECL|function|e100_load_microcode
id|e100_load_microcode
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_static
r_struct
(brace
id|u8
id|rev_id
suffix:semicolon
id|u32
id|ucode
(braket
id|UCODE_MAX_DWORDS
op_plus
l_int|1
)braket
suffix:semicolon
r_int
id|timer_dword
suffix:semicolon
r_int
id|bundle_dword
suffix:semicolon
r_int
id|min_size_dword
suffix:semicolon
)brace
id|ucode_opts
(braket
)braket
op_assign
(brace
(brace
id|D101A4_REV_ID
comma
id|D101_A_RCVBUNDLE_UCODE
comma
id|D101_CPUSAVER_TIMER_DWORD
comma
id|D101_CPUSAVER_BUNDLE_DWORD
comma
id|D101_CPUSAVER_MIN_SIZE_DWORD
)brace
comma
(brace
id|D101B0_REV_ID
comma
id|D101_B0_RCVBUNDLE_UCODE
comma
id|D101_CPUSAVER_TIMER_DWORD
comma
id|D101_CPUSAVER_BUNDLE_DWORD
comma
id|D101_CPUSAVER_MIN_SIZE_DWORD
)brace
comma
(brace
id|D101MA_REV_ID
comma
id|D101M_B_RCVBUNDLE_UCODE
comma
id|D101M_CPUSAVER_TIMER_DWORD
comma
id|D101M_CPUSAVER_BUNDLE_DWORD
comma
id|D101M_CPUSAVER_MIN_SIZE_DWORD
)brace
comma
(brace
id|D101S_REV_ID
comma
id|D101S_RCVBUNDLE_UCODE
comma
id|D101S_CPUSAVER_TIMER_DWORD
comma
id|D101S_CPUSAVER_BUNDLE_DWORD
comma
id|D101S_CPUSAVER_MIN_SIZE_DWORD
)brace
comma
(brace
id|D102_REV_ID
comma
id|D102_B_RCVBUNDLE_UCODE
comma
id|D102_B_CPUSAVER_TIMER_DWORD
comma
id|D102_B_CPUSAVER_BUNDLE_DWORD
comma
id|D102_B_CPUSAVER_MIN_SIZE_DWORD
)brace
comma
(brace
id|D102C_REV_ID
comma
id|D102_C_RCVBUNDLE_UCODE
comma
id|D102_C_CPUSAVER_TIMER_DWORD
comma
id|D102_C_CPUSAVER_BUNDLE_DWORD
comma
id|D102_C_CPUSAVER_MIN_SIZE_DWORD
)brace
comma
(brace
id|D102E_REV_ID
comma
id|D102_E_RCVBUNDLE_UCODE
comma
id|D102_E_CPUSAVER_TIMER_DWORD
comma
id|D102_E_CPUSAVER_BUNDLE_DWORD
comma
id|D102_E_CPUSAVER_MIN_SIZE_DWORD
)brace
comma
(brace
l_int|0
comma
(brace
l_int|0
)brace
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
comma
op_star
id|opts
suffix:semicolon
id|opts
op_assign
id|ucode_opts
suffix:semicolon
multiline_comment|/* User turned ucode loading off */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bdp-&gt;params.b_params
op_amp
id|PRM_UCODE
)paren
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/* These controllers do not need ucode */
r_if
c_cond
(paren
id|bdp-&gt;flags
op_amp
id|IS_ICH
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/* Search for ucode match against h/w rev_id */
r_while
c_loop
(paren
id|opts-&gt;rev_id
)paren
(brace
r_if
c_cond
(paren
id|bdp-&gt;rev_id
op_eq
id|opts-&gt;rev_id
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
op_star
id|ucode_dword
suffix:semicolon
id|load_ucode_cb_t
op_star
id|ucode_cmd_ptr
suffix:semicolon
id|nxmit_cb_entry_t
op_star
id|cmd
op_assign
id|e100_alloc_non_tx_cmd
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_int|NULL
)paren
(brace
id|ucode_cmd_ptr
op_assign
(paren
id|load_ucode_cb_t
op_star
)paren
id|cmd-&gt;non_tx_cmd
suffix:semicolon
id|ucode_dword
op_assign
id|ucode_cmd_ptr-&gt;ucode_dword
suffix:semicolon
)brace
r_else
(brace
r_return
l_bool|false
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|ucode_dword
comma
id|opts-&gt;ucode
comma
r_sizeof
(paren
id|opts-&gt;ucode
)paren
)paren
suffix:semicolon
multiline_comment|/* Insert user-tunable settings */
id|ucode_dword
(braket
id|opts-&gt;timer_dword
)braket
op_and_assign
l_int|0xFFFF0000
suffix:semicolon
id|ucode_dword
(braket
id|opts-&gt;timer_dword
)braket
op_or_assign
(paren
id|u16
)paren
id|bdp-&gt;params.IntDelay
suffix:semicolon
id|ucode_dword
(braket
id|opts-&gt;bundle_dword
)braket
op_and_assign
l_int|0xFFFF0000
suffix:semicolon
id|ucode_dword
(braket
id|opts-&gt;bundle_dword
)braket
op_or_assign
(paren
id|u16
)paren
id|bdp-&gt;params.BundleMax
suffix:semicolon
id|ucode_dword
(braket
id|opts-&gt;min_size_dword
)braket
op_and_assign
l_int|0xFFFF0000
suffix:semicolon
id|ucode_dword
(braket
id|opts-&gt;min_size_dword
)braket
op_or_assign
(paren
id|bdp-&gt;params.b_params
op_amp
id|PRM_BUNDLE_SMALL
)paren
ques
c_cond
l_int|0xFFFF
suffix:colon
l_int|0xFF80
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UCODE_MAX_DWORDS
suffix:semicolon
id|i
op_increment
)paren
id|cpu_to_le32s
c_func
(paren
op_amp
(paren
id|ucode_dword
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|ucode_cmd_ptr-&gt;load_ucode_cbhdr.cb_cmd
op_assign
id|__constant_cpu_to_le16
c_func
(paren
id|CB_LOAD_MICROCODE
)paren
suffix:semicolon
r_return
id|e100_exec_non_cu_cmd
c_func
(paren
id|bdp
comma
id|cmd
)paren
suffix:semicolon
)brace
id|opts
op_increment
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/***************************************************************************/
multiline_comment|/***************************************************************************/
multiline_comment|/*       EEPROM  Functions                                                 */
multiline_comment|/***************************************************************************/
multiline_comment|/* Read PWA (printed wired assembly) number */
r_void
id|__devinit
DECL|function|e100_rd_pwa_no
id|e100_rd_pwa_no
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|bdp-&gt;pwa_no
op_assign
id|e100_eeprom_read
c_func
(paren
id|bdp
comma
id|EEPROM_PWA_NO
)paren
suffix:semicolon
id|bdp-&gt;pwa_no
op_lshift_assign
l_int|16
suffix:semicolon
id|bdp-&gt;pwa_no
op_or_assign
id|e100_eeprom_read
c_func
(paren
id|bdp
comma
id|EEPROM_PWA_NO
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the permanent ethernet address from the eprom. */
r_void
id|__devinit
DECL|function|e100_rd_eaddr
id|e100_rd_eaddr
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
id|i
suffix:semicolon
id|u16
id|eeprom_word
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|eeprom_word
op_assign
id|e100_eeprom_read
c_func
(paren
id|bdp
comma
id|EEPROM_NODE_ADDRESS_BYTE_0
op_plus
(paren
id|i
op_div
l_int|2
)paren
)paren
suffix:semicolon
id|bdp-&gt;device-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|bdp-&gt;perm_node_address
(braket
id|i
)braket
op_assign
(paren
id|u8
)paren
id|eeprom_word
suffix:semicolon
id|bdp-&gt;device-&gt;dev_addr
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|bdp-&gt;perm_node_address
(braket
id|i
op_plus
l_int|1
)braket
op_assign
(paren
id|u8
)paren
(paren
id|eeprom_word
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Check the D102 RFD flags to see if the checksum passed */
r_static
r_int
r_char
DECL|function|e100_D102_check_checksum
id|e100_D102_check_checksum
c_func
(paren
id|rfd_t
op_star
id|rfd
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|rfd-&gt;rfd_header.cb_status
)paren
)paren
op_amp
id|RFD_PARSE_BIT
)paren
op_logical_and
(paren
(paren
(paren
id|rfd-&gt;rcvparserstatus
op_amp
id|CHECKSUM_PROTOCOL_MASK
)paren
op_eq
id|RFD_TCP_PACKET
)paren
op_logical_or
(paren
(paren
id|rfd-&gt;rcvparserstatus
op_amp
id|CHECKSUM_PROTOCOL_MASK
)paren
op_eq
id|RFD_UDP_PACKET
)paren
)paren
op_logical_and
(paren
id|rfd-&gt;checksumstatus
op_amp
id|TCPUDP_CHECKSUM_BIT_VALID
)paren
op_logical_and
(paren
id|rfd-&gt;checksumstatus
op_amp
id|TCPUDP_CHECKSUM_VALID
)paren
)paren
(brace
r_return
id|CHECKSUM_UNNECESSARY
suffix:semicolon
)brace
r_return
id|CHECKSUM_NONE
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_D101M_checksum&n; * @bdp: atapter&squot;s private data struct&n; * @skb: skb received&n; *&n; * Sets the skb-&gt;csum value from D101 csum found at the end of the Rx frame. The&n; * D101M sums all words in frame excluding the ethernet II header (14 bytes) so&n; * in case the packet is ethernet II and the protocol is IP, all is need is to&n; * assign this value to skb-&gt;csum.&n; */
r_static
r_int
r_char
DECL|function|e100_D101M_checksum
id|e100_D101M_checksum
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_int
id|proto
op_assign
(paren
id|skb-&gt;protocol
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proto
op_eq
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
)paren
(brace
id|skb-&gt;csum
op_assign
id|get_unaligned
c_func
(paren
(paren
id|u16
op_star
)paren
(paren
id|skb-&gt;tail
)paren
)paren
suffix:semicolon
r_return
id|CHECKSUM_HW
suffix:semicolon
)brace
r_return
id|CHECKSUM_NONE
suffix:semicolon
)brace
multiline_comment|/***************************************************************************/
multiline_comment|/***************************************************************************/
multiline_comment|/***************************************************************************/
multiline_comment|/***************************************************************************/
multiline_comment|/*       Auxilary Functions                                                */
multiline_comment|/***************************************************************************/
multiline_comment|/* Print the board&squot;s configuration */
r_void
id|__devinit
DECL|function|e100_print_brd_conf
id|e100_print_brd_conf
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_if
c_cond
(paren
id|netif_carrier_ok
c_func
(paren
id|bdp-&gt;device
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Mem:0x%08lx  IRQ:%d  Speed:%d Mbps  Dx:%s&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|bdp-&gt;device-&gt;mem_start
comma
id|bdp-&gt;device-&gt;irq
comma
id|bdp-&gt;cur_line_speed
comma
(paren
id|bdp-&gt;cur_dplx_mode
op_eq
id|FULL_DUPLEX
)paren
ques
c_cond
l_string|&quot;Full&quot;
suffix:colon
l_string|&quot;Half&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Mem:0x%08lx  IRQ:%d  Speed:%d Mbps  Dx:%s&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|bdp-&gt;device-&gt;mem_start
comma
id|bdp-&gt;device-&gt;irq
comma
l_int|0
comma
l_string|&quot;N/A&quot;
)paren
suffix:semicolon
multiline_comment|/* Auto negotiation failed so we should display an error */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Failed to detect cable link&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Speed and duplex will be determined &quot;
l_string|&quot;at time of connection&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Print the string if checksum Offloading was enabled */
r_if
c_cond
(paren
id|bdp-&gt;flags
op_amp
id|DF_CSUM_OFFLOAD
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Hardware receive checksums enabled&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Hardware receive checksums disabled&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bdp-&gt;flags
op_amp
id|DF_UCODE_LOADED
)paren
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  cpu cycle saver enabled&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_get_brand_msg&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine checks if there is specified branding message for a given board&n; * type and returns a pointer to the string containing the branding message.&n; */
r_char
op_star
DECL|function|e100_get_brand_msg
id|e100_get_brand_msg
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|e100_vendor_info_array
(braket
id|i
)braket
dot
id|idstr
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|e100_vendor_info_array
(braket
id|i
)braket
dot
id|device_type
op_eq
id|bdp-&gt;device_type
)paren
(brace
r_return
id|e100_vendor_info_array
(braket
id|i
)braket
dot
id|idstr
suffix:semicolon
)brace
)brace
r_return
id|e100_vendor_info_array
(braket
id|E100_ALL_BOARDS
)braket
dot
id|idstr
suffix:semicolon
)brace
multiline_comment|/**&n; * e100_pci_setup - setup the adapter&squot;s PCI information&n; * @pcid: adapter&squot;s pci_dev struct&n; * @bdp: atapter&squot;s private data struct&n; *&n; * This routine sets up all PCI information for the adapter. It enables the bus&n; * master bit (some BIOS don&squot;t do this), requests memory ans I/O regions, and&n; * calls ioremap() on the adapter&squot;s memory region.&n; *&n; * Returns:&n; *      true: if successfull&n; *      false: otherwise&n; */
r_static
r_int
r_char
id|__devinit
DECL|function|e100_pci_setup
id|e100_pci_setup
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
comma
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|bdp-&gt;device
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|pci_enable_device
c_func
(paren
id|pcid
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* dev and ven ID have already been checked so it is our device */
id|pci_read_config_byte
c_func
(paren
id|pcid
comma
id|PCI_REVISION_ID
comma
(paren
id|u8
op_star
)paren
op_amp
(paren
id|bdp-&gt;rev_id
)paren
)paren
suffix:semicolon
multiline_comment|/* address #0 is a memory region */
id|dev-&gt;mem_start
op_assign
id|pci_resource_start
c_func
(paren
id|pcid
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
r_sizeof
(paren
id|scb_t
)paren
suffix:semicolon
multiline_comment|/* address #1 is a IO region */
id|dev-&gt;base_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pcid
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|pci_request_regions
c_func
(paren
id|pcid
comma
id|e100_short_driver_name
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|err_disable
suffix:semicolon
)brace
id|pci_enable_wake
c_func
(paren
id|pcid
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* if Bus Mastering is off, turn it on! */
id|pci_set_master
c_func
(paren
id|pcid
)paren
suffix:semicolon
multiline_comment|/* address #0 is a memory mapping */
id|bdp-&gt;scb
op_assign
(paren
id|scb_t
op_star
)paren
id|ioremap_nocache
c_func
(paren
id|dev-&gt;mem_start
comma
r_sizeof
(paren
id|scb_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdp-&gt;scb
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s - %s: Failed to map PCI address 0x%lX&bslash;n&quot;
comma
id|e100_short_driver_name
comma
id|dev-&gt;name
comma
id|pci_resource_start
c_func
(paren
id|pcid
comma
l_int|0
)paren
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_region
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|err_region
suffix:colon
id|pci_release_regions
c_func
(paren
id|pcid
)paren
suffix:semicolon
id|err_disable
suffix:colon
id|pci_disable_device
c_func
(paren
id|pcid
)paren
suffix:semicolon
id|err
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
r_void
DECL|function|e100_isolate_driver
id|e100_isolate_driver
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|write_lock_irq
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
id|bdp-&gt;driver_isolated
op_assign
l_bool|true
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
(paren
id|bdp-&gt;isolate_lock
)paren
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|bdp-&gt;watchdog_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|bdp-&gt;device
)paren
)paren
id|netif_stop_queue
c_func
(paren
id|bdp-&gt;device
)paren
suffix:semicolon
id|bdp-&gt;last_tcb
op_assign
l_int|NULL
suffix:semicolon
id|e100_sw_reset
c_func
(paren
id|bdp
comma
id|PORT_SELECTIVE_RESET
)paren
suffix:semicolon
)brace
r_void
DECL|function|e100_set_speed_duplex
id|e100_set_speed_duplex
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|e100_phy_set_speed_duplex
c_func
(paren
id|bdp
comma
l_bool|true
)paren
suffix:semicolon
id|e100_config_fc
c_func
(paren
id|bdp
)paren
suffix:semicolon
multiline_comment|/* re-config flow-control if necessary */
id|e100_config
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_tcb_add_C_bit
id|e100_tcb_add_C_bit
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|tcb_t
op_star
id|tcb
op_assign
(paren
id|tcb_t
op_star
)paren
id|bdp-&gt;tcb_pool.data
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bdp-&gt;params.TxDescriptors
suffix:semicolon
id|i
op_increment
comma
id|tcb
op_increment
)paren
(brace
id|tcb-&gt;tcb_hdr.cb_status
op_or_assign
id|cpu_to_le16
c_func
(paren
id|CB_STATUS_COMPLETE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Procedure:   e100_hw_reset_recover&n; *&n; * Description: This routine will recover the hw after reset.&n; *&n; * Arguments:&n; *      bdp - Ptr to this card&squot;s e100_bdconfig structure&n; *        reset_cmd - s/w reset or selective reset. &n; *&n; * Returns:&n; *        true upon success&n; *        false upon failure&n; */
r_int
r_char
DECL|function|e100_hw_reset_recover
id|e100_hw_reset_recover
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u32
id|reset_cmd
)paren
(brace
id|bdp-&gt;last_tcb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|reset_cmd
op_eq
id|PORT_SOFTWARE_RESET
)paren
(brace
multiline_comment|/*load CU &amp; RU base */
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_exec_cmplx
c_func
(paren
id|bdp
comma
l_int|0
comma
id|SCB_CUC_LOAD_BASE
)paren
)paren
(brace
r_return
l_bool|false
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e100_load_microcode
c_func
(paren
id|bdp
)paren
)paren
(brace
id|bdp-&gt;flags
op_or_assign
id|DF_UCODE_LOADED
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_exec_cmplx
c_func
(paren
id|bdp
comma
l_int|0
comma
id|SCB_RUC_LOAD_BASE
)paren
)paren
(brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/* Issue the load dump counters address command */
r_if
c_cond
(paren
op_logical_neg
id|e100_wait_exec_cmplx
c_func
(paren
id|bdp
comma
id|bdp-&gt;stat_cnt_phys
comma
id|SCB_CUC_DUMP_ADDR
)paren
)paren
(brace
r_return
l_bool|false
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|e100_setup_iaaddr
c_func
(paren
id|bdp
comma
id|bdp-&gt;device-&gt;dev_addr
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;e100_hw_reset_recover: setup iaaddr failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
id|e100_set_multi_exec
c_func
(paren
id|bdp-&gt;device
)paren
suffix:semicolon
multiline_comment|/* Change for 82558 enhancement */
multiline_comment|/* If 82558/9 and if the user has enabled flow control, set up * the&n;&t;&t; * Flow Control Reg. in the CSR */
r_if
c_cond
(paren
(paren
id|bdp-&gt;flags
op_amp
id|IS_BACHELOR
)paren
op_logical_and
(paren
id|bdp-&gt;params.b_params
op_amp
id|PRM_FC
)paren
)paren
(brace
id|writeb
c_func
(paren
id|DFLT_FC_THLD
comma
op_amp
id|bdp-&gt;scb-&gt;scb_ext.d101_scb.scb_fc_thld
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|DFLT_FC_CMD
comma
op_amp
id|bdp-&gt;scb-&gt;scb_ext.d101_scb.scb_fc_xon_xoff
)paren
suffix:semicolon
)brace
)brace
id|e100_force_config
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
r_void
DECL|function|e100_deisolate_driver
id|e100_deisolate_driver
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|u8
id|recover
comma
id|u8
id|full_init
)paren
(brace
r_if
c_cond
(paren
id|full_init
)paren
(brace
id|e100_sw_reset
c_func
(paren
id|bdp
comma
id|PORT_SOFTWARE_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_hw_reset_recover
c_func
(paren
id|bdp
comma
id|PORT_SOFTWARE_RESET
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;e100_deisolate_driver:&quot;
l_string|&quot; HW SOFTWARE reset recover failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|recover
)paren
(brace
id|bdp-&gt;next_cu_cmd
op_assign
id|START_WAIT
suffix:semicolon
id|bdp-&gt;last_tcb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* lets reset the chip */
r_if
c_cond
(paren
op_logical_neg
id|full_init
)paren
(brace
id|e100_sw_reset
c_func
(paren
id|bdp
comma
id|PORT_SELECTIVE_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e100_hw_reset_recover
c_func
(paren
id|bdp
comma
id|PORT_SELECTIVE_RESET
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;e100_deisolate_driver:&quot;
l_string|&quot; HW reset recover failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|e100_start_ru
c_func
(paren
id|bdp
)paren
suffix:semicolon
multiline_comment|/* relaunch watchdog timer in 2 sec */
id|mod_timer
c_func
(paren
op_amp
(paren
id|bdp-&gt;watchdog_timer
)paren
comma
id|jiffies
op_plus
(paren
l_int|2
op_star
id|HZ
)paren
)paren
suffix:semicolon
singleline_comment|// we must clear tcbs since we may have lost Tx intrrupt
singleline_comment|// or have unsent frames on the tcb chain
id|e100_tcb_add_C_bit
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|e100_tx_srv
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|e100_set_intr_mask
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|bdp-&gt;device
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|bdp-&gt;device
)paren
suffix:semicolon
)brace
id|bdp-&gt;driver_isolated
op_assign
l_bool|false
suffix:semicolon
)brace
macro_line|#ifdef E100_ETHTOOL_IOCTL
r_static
r_int
DECL|function|e100_do_ethtool_ioctl
id|e100_do_ethtool_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_struct
id|ethtool_cmd
id|ecmd
suffix:semicolon
r_int
id|rc
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ecmd
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
id|ecmd.cmd
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|ecmd.cmd
)paren
(brace
r_case
id|ETHTOOL_GSET
suffix:colon
id|rc
op_assign
id|e100_ethtool_get_settings
c_func
(paren
id|dev
comma
id|ifr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETHTOOL_SSET
suffix:colon
id|rc
op_assign
id|e100_ethtool_set_settings
c_func
(paren
id|dev
comma
id|ifr
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef ETHTOOL_GDRVINFO
r_case
id|ETHTOOL_GDRVINFO
suffix:colon
id|rc
op_assign
id|e100_ethtool_get_drvinfo
c_func
(paren
id|dev
comma
id|ifr
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ETHTOOL_NWAY_RST
r_case
id|ETHTOOL_NWAY_RST
suffix:colon
id|rc
op_assign
id|e100_ethtool_nway_rst
c_func
(paren
id|dev
comma
id|ifr
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ETHTOOL_GLINK
r_case
id|ETHTOOL_GLINK
suffix:colon
id|rc
op_assign
id|e100_ethtool_glink
c_func
(paren
id|dev
comma
id|ifr
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ETHTOOL_GEEPROM
r_case
id|ETHTOOL_GEEPROM
suffix:colon
r_case
id|ETHTOOL_SEEPROM
suffix:colon
id|rc
op_assign
id|e100_ethtool_eeprom
c_func
(paren
id|dev
comma
id|ifr
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ETHTOOL_GWOL
r_case
id|ETHTOOL_GWOL
suffix:colon
r_case
id|ETHTOOL_SWOL
suffix:colon
id|rc
op_assign
id|e100_ethtool_wol
c_func
(paren
id|dev
comma
id|ifr
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ETHTOOL_TEST
r_case
id|ETHTOOL_TEST
suffix:colon
id|rc
op_assign
id|e100_ethtool_test
c_func
(paren
id|dev
comma
id|ifr
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ETHTOOL_GSTRINGS
r_case
id|ETHTOOL_GSTRINGS
suffix:colon
id|rc
op_assign
id|e100_ethtool_gstrings
c_func
(paren
id|dev
comma
id|ifr
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_break
suffix:semicolon
)brace
singleline_comment|//switch
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|e100_ethtool_get_settings
id|e100_ethtool_get_settings
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
r_struct
id|ethtool_cmd
id|ecmd
suffix:semicolon
id|u16
id|advert
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|ecmd
comma
l_int|0
comma
r_sizeof
(paren
id|ecmd
)paren
)paren
suffix:semicolon
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ecmd.supported
op_assign
id|bdp-&gt;speed_duplex_caps
suffix:semicolon
id|ecmd.port
op_assign
(paren
id|bdp-&gt;speed_duplex_caps
op_amp
id|SUPPORTED_TP
)paren
ques
c_cond
id|PORT_TP
suffix:colon
id|PORT_FIBRE
suffix:semicolon
id|ecmd.transceiver
op_assign
id|XCVR_INTERNAL
suffix:semicolon
id|ecmd.phy_address
op_assign
id|bdp-&gt;phy_addr
suffix:semicolon
id|ecmd.speed
op_assign
id|bdp-&gt;cur_line_speed
suffix:semicolon
id|ecmd.duplex
op_assign
(paren
id|bdp-&gt;cur_dplx_mode
op_eq
id|HALF_DUPLEX
)paren
ques
c_cond
id|DUPLEX_HALF
suffix:colon
id|DUPLEX_FULL
suffix:semicolon
id|ecmd.advertising
op_assign
id|ADVERTISED_TP
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;params.e100_speed_duplex
op_eq
id|E100_AUTONEG
)paren
(brace
id|ecmd.autoneg
op_assign
id|AUTONEG_ENABLE
suffix:semicolon
id|ecmd.advertising
op_or_assign
id|ADVERTISED_Autoneg
suffix:semicolon
)brace
r_else
(brace
id|ecmd.autoneg
op_assign
id|AUTONEG_DISABLE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bdp-&gt;speed_duplex_caps
op_amp
id|SUPPORTED_MII
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_ADVERTISE
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|advert
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|advert
op_amp
id|ADVERTISE_10HALF
)paren
id|ecmd.advertising
op_or_assign
id|ADVERTISED_10baseT_Half
suffix:semicolon
r_if
c_cond
(paren
id|advert
op_amp
id|ADVERTISE_10FULL
)paren
id|ecmd.advertising
op_or_assign
id|ADVERTISED_10baseT_Full
suffix:semicolon
r_if
c_cond
(paren
id|advert
op_amp
id|ADVERTISE_100HALF
)paren
id|ecmd.advertising
op_or_assign
id|ADVERTISED_100baseT_Half
suffix:semicolon
r_if
c_cond
(paren
id|advert
op_amp
id|ADVERTISE_100FULL
)paren
id|ecmd.advertising
op_or_assign
id|ADVERTISED_100baseT_Full
suffix:semicolon
)brace
r_else
(brace
id|ecmd.autoneg
op_assign
id|AUTONEG_DISABLE
suffix:semicolon
id|ecmd.advertising
op_and_assign
op_complement
id|ADVERTISED_Autoneg
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|ecmd
comma
r_sizeof
(paren
id|ecmd
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|e100_ethtool_set_settings
id|e100_ethtool_set_settings
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
r_int
id|current_duplex
suffix:semicolon
r_int
id|e100_new_speed_duplex
suffix:semicolon
r_int
id|ethtool_new_speed_duplex
suffix:semicolon
r_int
id|speed_duplex_change_required
suffix:semicolon
r_struct
id|ethtool_cmd
id|ecmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ecmd
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
id|ecmd
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|current_duplex
op_assign
(paren
id|bdp-&gt;cur_dplx_mode
op_eq
id|HALF_DUPLEX
)paren
ques
c_cond
id|DUPLEX_HALF
suffix:colon
id|DUPLEX_FULL
suffix:semicolon
id|speed_duplex_change_required
op_assign
(paren
id|ecmd.speed
op_ne
id|bdp-&gt;cur_line_speed
)paren
op_logical_or
(paren
id|ecmd.duplex
op_ne
id|current_duplex
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ecmd.autoneg
op_eq
id|AUTONEG_ENABLE
)paren
op_logical_and
id|speed_duplex_change_required
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ecmd.autoneg
op_eq
id|AUTONEG_ENABLE
)paren
op_logical_and
(paren
id|bdp-&gt;speed_duplex_caps
op_amp
id|SUPPORTED_Autoneg
)paren
)paren
(brace
id|bdp-&gt;params.e100_speed_duplex
op_assign
id|E100_AUTONEG
suffix:semicolon
id|e100_set_speed_duplex
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|speed_duplex_change_required
)paren
(brace
r_if
c_cond
(paren
id|ecmd.speed
op_eq
id|SPEED_10
)paren
(brace
r_if
c_cond
(paren
id|ecmd.duplex
op_eq
id|DUPLEX_HALF
)paren
(brace
id|e100_new_speed_duplex
op_assign
id|E100_SPEED_10_HALF
suffix:semicolon
id|ethtool_new_speed_duplex
op_assign
id|SUPPORTED_10baseT_Half
suffix:semicolon
)brace
r_else
(brace
id|e100_new_speed_duplex
op_assign
id|E100_SPEED_10_FULL
suffix:semicolon
id|ethtool_new_speed_duplex
op_assign
id|SUPPORTED_10baseT_Full
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|ecmd.duplex
op_eq
id|DUPLEX_HALF
)paren
(brace
id|e100_new_speed_duplex
op_assign
id|E100_SPEED_100_HALF
suffix:semicolon
id|ethtool_new_speed_duplex
op_assign
id|SUPPORTED_100baseT_Half
suffix:semicolon
)brace
r_else
(brace
id|e100_new_speed_duplex
op_assign
id|E100_SPEED_100_FULL
suffix:semicolon
id|ethtool_new_speed_duplex
op_assign
id|SUPPORTED_100baseT_Full
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bdp-&gt;speed_duplex_caps
op_amp
id|ethtool_new_speed_duplex
)paren
(brace
id|bdp-&gt;params.e100_speed_duplex
op_assign
id|e100_new_speed_duplex
suffix:semicolon
id|e100_set_speed_duplex
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef ETHTOOL_GLINK
r_static
r_int
DECL|function|e100_ethtool_glink
id|e100_ethtool_glink
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
r_struct
id|ethtool_value
id|info
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|info
comma
l_int|0
comma
r_sizeof
(paren
id|info
)paren
)paren
suffix:semicolon
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|info.cmd
op_assign
id|ETHTOOL_GLINK
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
id|info.data
op_assign
id|e100_get_link_state
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef ETHTOOL_TEST
r_static
r_int
DECL|function|e100_ethtool_test
id|e100_ethtool_test
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_struct
id|ethtool_test
op_star
id|info
suffix:semicolon
r_int
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|info
)paren
op_plus
id|E100_MAX_TEST_RES
op_star
r_sizeof
(paren
id|u64
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|info
)paren
op_plus
id|E100_MAX_TEST_RES
op_star
r_sizeof
(paren
id|u64
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|info
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
op_star
id|info
)paren
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|info-&gt;flags
op_assign
id|e100_run_diag
c_func
(paren
id|dev
comma
id|info-&gt;data
comma
id|info-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
id|ifr-&gt;ifr_data
comma
id|info
comma
r_sizeof
(paren
op_star
id|info
)paren
op_plus
id|E100_MAX_TEST_RES
op_star
r_sizeof
(paren
id|u64
)paren
)paren
)paren
id|rc
op_assign
l_int|0
suffix:semicolon
m_exit
suffix:colon
id|kfree
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef ETHTOOL_NWAY_RST
r_static
r_int
DECL|function|e100_ethtool_nway_rst
id|e100_ethtool_nway_rst
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bdp-&gt;speed_duplex_caps
op_amp
id|SUPPORTED_Autoneg
)paren
op_logical_and
(paren
id|bdp-&gt;params.e100_speed_duplex
op_eq
id|E100_AUTONEG
)paren
)paren
(brace
id|e100_set_speed_duplex
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef ETHTOOL_GDRVINFO
r_static
r_int
DECL|function|e100_ethtool_get_drvinfo
id|e100_ethtool_get_drvinfo
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
r_struct
id|ethtool_drvinfo
id|info
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|info
comma
l_int|0
comma
r_sizeof
(paren
id|info
)paren
)paren
suffix:semicolon
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|strncpy
c_func
(paren
id|info.driver
comma
id|e100_short_driver_name
comma
r_sizeof
(paren
id|info.driver
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info.version
comma
id|e100_version
comma
r_sizeof
(paren
id|info.version
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info.fw_version
comma
id|e100_get_brand_msg
c_func
(paren
id|bdp
)paren
comma
r_sizeof
(paren
id|info.fw_version
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info.bus_info
comma
id|bdp-&gt;pdev-&gt;slot_name
comma
r_sizeof
(paren
id|info.bus_info
)paren
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef ETHTOOL_GEEPROM
id|info.eedump_len
op_assign
(paren
id|bdp-&gt;eeprom_size
op_lshift
l_int|1
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef ETHTOOL_TEST
id|info.testinfo_len
op_assign
id|E100_MAX_TEST_RES
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif 
singleline_comment|//ETHTOOL_GDRVINFO
macro_line|#ifdef ETHTOOL_GEEPROM
r_static
r_int
DECL|function|e100_ethtool_eeprom
id|e100_ethtool_eeprom
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
r_struct
id|ethtool_eeprom
id|ecmd
suffix:semicolon
id|u16
id|eeprom_data
(braket
l_int|256
)braket
suffix:semicolon
id|u16
op_star
id|usr_eeprom_ptr
suffix:semicolon
id|u16
id|word_length
comma
id|word_offset
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ecmd
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
id|ecmd
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|usr_eeprom_ptr
op_assign
(paren
id|u16
op_star
)paren
(paren
id|ifr-&gt;ifr_data
op_plus
m_offsetof
(paren
r_struct
id|ethtool_eeprom
comma
id|data
)paren
)paren
suffix:semicolon
id|word_offset
op_assign
(paren
id|ecmd.offset
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|word_offset
op_ge
id|bdp-&gt;eeprom_size
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|word_length
op_assign
id|min_t
c_func
(paren
id|u32
comma
(paren
id|ecmd.len
op_rshift
l_int|1
)paren
comma
(paren
id|bdp-&gt;eeprom_size
op_minus
id|word_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecmd.cmd
op_eq
id|ETHTOOL_GEEPROM
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|word_offset
suffix:semicolon
id|i
OL
(paren
id|word_length
op_plus
id|word_offset
)paren
suffix:semicolon
id|i
op_increment
)paren
id|eeprom_data
(braket
id|i
)braket
op_assign
id|e100_eeprom_read
c_func
(paren
id|bdp
comma
id|i
)paren
suffix:semicolon
id|ecmd.len
op_assign
(paren
id|word_length
op_lshift
l_int|1
)paren
suffix:semicolon
id|ecmd.magic
op_assign
id|E100_EEPROM_MAGIC
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|ecmd
comma
r_sizeof
(paren
id|ecmd
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|usr_eeprom_ptr
comma
op_amp
(paren
id|eeprom_data
(braket
id|word_offset
)braket
)paren
comma
(paren
id|ecmd.len
op_lshift
l_int|1
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ecmd.magic
op_ne
id|E100_EEPROM_MAGIC
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
(paren
id|eeprom_data
(braket
id|word_offset
)braket
)paren
comma
id|usr_eeprom_ptr
comma
(paren
id|ecmd.len
op_lshift
l_int|1
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|e100_eeprom_write_block
c_func
(paren
id|bdp
comma
id|word_offset
comma
op_amp
(paren
id|eeprom_data
(braket
id|word_offset
)braket
)paren
comma
id|word_length
)paren
suffix:semicolon
id|ecmd.len
op_assign
(paren
id|word_length
op_lshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|ecmd
comma
r_sizeof
(paren
id|ecmd
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_static
r_inline
r_int
id|__devinit
DECL|function|e100_10BaseT_adapter
id|e100_10BaseT_adapter
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
r_return
(paren
(paren
id|bdp-&gt;pdev-&gt;device
op_eq
l_int|0x1229
)paren
op_logical_and
(paren
id|bdp-&gt;pdev-&gt;subsystem_vendor
op_eq
l_int|0x8086
)paren
op_logical_and
(paren
id|bdp-&gt;pdev-&gt;subsystem_device
op_eq
l_int|0x0003
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
id|__devinit
DECL|function|e100_get_speed_duplex_caps
id|e100_get_speed_duplex_caps
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|u16
id|status
suffix:semicolon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|MII_BMSR
comma
id|bdp-&gt;phy_addr
comma
op_amp
id|status
)paren
suffix:semicolon
id|bdp-&gt;speed_duplex_caps
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;speed_duplex_caps
op_or_assign
(paren
id|status
op_amp
id|BMSR_ANEGCAPABLE
)paren
ques
c_cond
id|SUPPORTED_Autoneg
suffix:colon
l_int|0
suffix:semicolon
id|bdp-&gt;speed_duplex_caps
op_or_assign
(paren
id|status
op_amp
id|BMSR_10HALF
)paren
ques
c_cond
id|SUPPORTED_10baseT_Half
suffix:colon
l_int|0
suffix:semicolon
id|bdp-&gt;speed_duplex_caps
op_or_assign
(paren
id|status
op_amp
id|BMSR_10FULL
)paren
ques
c_cond
id|SUPPORTED_10baseT_Full
suffix:colon
l_int|0
suffix:semicolon
id|bdp-&gt;speed_duplex_caps
op_or_assign
(paren
id|status
op_amp
id|BMSR_100HALF
)paren
ques
c_cond
id|SUPPORTED_100baseT_Half
suffix:colon
l_int|0
suffix:semicolon
id|bdp-&gt;speed_duplex_caps
op_or_assign
(paren
id|status
op_amp
id|BMSR_100FULL
)paren
ques
c_cond
id|SUPPORTED_100baseT_Full
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|IS_NC3133
c_func
(paren
id|bdp
)paren
)paren
id|bdp-&gt;speed_duplex_caps
op_assign
(paren
id|SUPPORTED_FIBRE
op_or
id|SUPPORTED_100baseT_Full
)paren
suffix:semicolon
r_else
id|bdp-&gt;speed_duplex_caps
op_or_assign
id|SUPPORTED_TP
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_eq
l_int|0xFFFF
)paren
op_logical_and
id|e100_10BaseT_adapter
c_func
(paren
id|bdp
)paren
)paren
(brace
id|bdp-&gt;speed_duplex_caps
op_assign
(paren
id|SUPPORTED_10baseT_Half
op_or
id|SUPPORTED_TP
)paren
suffix:semicolon
)brace
r_else
(brace
id|bdp-&gt;speed_duplex_caps
op_or_assign
id|SUPPORTED_MII
suffix:semicolon
)brace
)brace
macro_line|#ifdef ETHTOOL_GWOL
r_static
r_int
r_char
DECL|function|e100_setup_filter
id|e100_setup_filter
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|cb_header_t
op_star
id|ntcb_hdr
suffix:semicolon
r_int
r_char
id|res
op_assign
l_bool|false
suffix:semicolon
id|nxmit_cb_entry_t
op_star
id|cmd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_assign
id|e100_alloc_non_tx_cmd
c_func
(paren
id|bdp
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_goto
m_exit
suffix:semicolon
)brace
id|ntcb_hdr
op_assign
(paren
id|cb_header_t
op_star
)paren
id|cmd-&gt;non_tx_cmd
suffix:semicolon
id|ntcb_hdr-&gt;cb_cmd
op_assign
id|__constant_cpu_to_le16
c_func
(paren
id|CB_LOAD_FILTER
)paren
suffix:semicolon
multiline_comment|/* Set EL and FIX bit */
(paren
id|cmd-&gt;non_tx_cmd
)paren
op_member_access_from_pointer
id|ntcb.filter.filter_data
(braket
l_int|0
)braket
op_assign
id|__constant_cpu_to_le32
c_func
(paren
id|CB_FILTER_EL
op_or
id|CB_FILTER_FIX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;wolopts
op_amp
id|WAKE_UCAST
)paren
(brace
(paren
id|cmd-&gt;non_tx_cmd
)paren
op_member_access_from_pointer
id|ntcb.filter.filter_data
(braket
l_int|0
)braket
op_or_assign
id|__constant_cpu_to_le32
c_func
(paren
id|CB_FILTER_IA_MATCH
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bdp-&gt;wolopts
op_amp
id|WAKE_ARP
)paren
(brace
multiline_comment|/* Setup ARP bit and lower IP parts */
multiline_comment|/* bdp-&gt;ip_lbytes contains 2 lower bytes of IP address in network byte order */
(paren
id|cmd-&gt;non_tx_cmd
)paren
op_member_access_from_pointer
id|ntcb.filter.filter_data
(braket
l_int|0
)braket
op_or_assign
id|cpu_to_le32
c_func
(paren
id|CB_FILTER_ARP
op_or
id|bdp-&gt;ip_lbytes
)paren
suffix:semicolon
)brace
id|res
op_assign
id|e100_exec_non_cu_cmd
c_func
(paren
id|bdp
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s Filter setup failed&bslash;n&quot;
comma
id|bdp-&gt;device-&gt;name
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|res
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_do_wol
id|e100_do_wol
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
comma
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|e100_config_wol
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e100_config
c_func
(paren
id|bdp
)paren
)paren
(brace
r_if
c_cond
(paren
id|bdp-&gt;wolopts
op_amp
(paren
id|WAKE_UCAST
op_or
id|WAKE_ARP
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|e100_setup_filter
c_func
(paren
id|bdp
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;e100_config WOL options failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;e100_config WOL failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_static
id|u16
DECL|function|e100_get_ip_lbytes
id|e100_get_ip_lbytes
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|in_ifaddr
op_star
id|ifa
suffix:semicolon
r_struct
id|in_device
op_star
id|in_dev
suffix:semicolon
id|u32
id|res
op_assign
l_int|0
suffix:semicolon
id|in_dev
op_assign
(paren
r_struct
id|in_device
op_star
)paren
id|dev-&gt;ip_ptr
suffix:semicolon
multiline_comment|/* Check if any in_device bound to interface */
r_if
c_cond
(paren
id|in_dev
)paren
(brace
multiline_comment|/* Check if any IP address is bound to interface */
r_if
c_cond
(paren
(paren
id|ifa
op_assign
id|in_dev-&gt;ifa_list
)paren
op_ne
l_int|NULL
)paren
(brace
id|res
op_assign
id|__constant_ntohl
c_func
(paren
id|ifa-&gt;ifa_address
)paren
suffix:semicolon
id|res
op_assign
id|__constant_htons
c_func
(paren
id|res
op_amp
l_int|0x0000ffff
)paren
suffix:semicolon
)brace
)brace
r_return
id|res
suffix:semicolon
)brace
r_static
r_int
DECL|function|e100_ethtool_wol
id|e100_ethtool_wol
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
r_struct
id|ethtool_wolinfo
id|wolinfo
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|wolinfo
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
id|wolinfo
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|wolinfo.cmd
)paren
(brace
r_case
id|ETHTOOL_GWOL
suffix:colon
id|wolinfo.supported
op_assign
id|bdp-&gt;wolsupported
suffix:semicolon
id|wolinfo.wolopts
op_assign
id|bdp-&gt;wolopts
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|wolinfo
comma
r_sizeof
(paren
id|wolinfo
)paren
)paren
)paren
id|res
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ETHTOOL_SWOL
suffix:colon
multiline_comment|/* If ALL requests are supported or request is DISABLE wol */
r_if
c_cond
(paren
(paren
(paren
id|wolinfo.wolopts
op_amp
id|bdp-&gt;wolsupported
)paren
op_eq
id|wolinfo.wolopts
)paren
op_logical_or
(paren
id|wolinfo.wolopts
op_eq
l_int|0
)paren
)paren
(brace
id|bdp-&gt;wolopts
op_assign
id|wolinfo.wolopts
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef ETHTOOL_GSTRINGS
DECL|function|e100_ethtool_gstrings
r_static
r_int
id|e100_ethtool_gstrings
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
)paren
(brace
r_struct
id|ethtool_gstrings
id|info
suffix:semicolon
r_char
op_star
id|strings
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|usr_strings
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|info
comma
l_int|0
comma
r_sizeof
(paren
id|info
)paren
)paren
suffix:semicolon
id|usr_strings
op_assign
(paren
id|u8
op_star
)paren
(paren
id|ifr-&gt;ifr_data
op_plus
m_offsetof
(paren
r_struct
id|ethtool_gstrings
comma
id|data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
id|ifr-&gt;ifr_data
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|info.string_set
)paren
(brace
r_case
id|ETH_SS_TEST
suffix:colon
r_if
c_cond
(paren
id|info.len
OG
id|E100_MAX_TEST_RES
)paren
id|info.len
op_assign
id|E100_MAX_TEST_RES
suffix:semicolon
id|strings
op_assign
id|kmalloc
c_func
(paren
id|info.len
op_star
id|ETH_GSTRING_LEN
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strings
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
id|strings
comma
l_int|0
comma
id|info.len
op_star
id|ETH_GSTRING_LEN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info.len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|strings
op_plus
id|i
op_star
id|ETH_GSTRING_LEN
comma
l_string|&quot;%-31s&quot;
comma
id|test_strings
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ifr-&gt;ifr_data
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|usr_strings
comma
id|strings
comma
id|info.len
op_star
id|ETH_GSTRING_LEN
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|kfree
c_func
(paren
id|strings
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif /*E100_ETHTOOL_IOCTL */
macro_line|#ifdef E100_MII_IOCTL
r_static
r_int
DECL|function|e100_mii_ioctl
id|e100_mii_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
r_struct
id|mii_ioctl_data
op_star
id|data_ptr
op_assign
(paren
r_struct
id|mii_ioctl_data
op_star
)paren
op_amp
(paren
id|ifr-&gt;ifr_data
)paren
suffix:semicolon
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGMIIPHY
suffix:colon
id|data_ptr-&gt;phy_id
op_assign
id|bdp-&gt;phy_addr
op_amp
l_int|0x1f
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGMIIREG
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
id|e100_mdi_read
c_func
(paren
id|bdp
comma
id|data_ptr-&gt;reg_num
op_amp
l_int|0x1f
comma
id|bdp-&gt;phy_addr
comma
op_amp
(paren
id|data_ptr-&gt;val_out
)paren
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSMIIREG
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
id|e100_mdi_write
c_func
(paren
id|bdp
comma
id|data_ptr-&gt;reg_num
op_amp
l_int|0x1f
comma
id|bdp-&gt;phy_addr
comma
id|data_ptr-&gt;val_in
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;mdi_access_lock
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif 
singleline_comment|//E100_MII_IOCTL
id|nxmit_cb_entry_t
op_star
DECL|function|e100_alloc_non_tx_cmd
id|e100_alloc_non_tx_cmd
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|nxmit_cb_entry_t
op_star
id|non_tx_cmd_elem
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|non_tx_cmd_elem
op_assign
(paren
id|nxmit_cb_entry_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|nxmit_cb_entry_t
)paren
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|non_tx_cmd_elem-&gt;non_tx_cmd
op_assign
id|pci_alloc_consistent
c_func
(paren
id|bdp-&gt;pdev
comma
r_sizeof
(paren
id|nxmit_cb_t
)paren
comma
op_amp
(paren
id|non_tx_cmd_elem-&gt;dma_addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|non_tx_cmd_elem-&gt;non_tx_cmd
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|non_tx_cmd_elem
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|non_tx_cmd_elem
suffix:semicolon
)brace
r_void
DECL|function|e100_free_non_tx_cmd
id|e100_free_non_tx_cmd
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|nxmit_cb_entry_t
op_star
id|non_tx_cmd_elem
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|bdp-&gt;pdev
comma
r_sizeof
(paren
id|nxmit_cb_t
)paren
comma
id|non_tx_cmd_elem-&gt;non_tx_cmd
comma
id|non_tx_cmd_elem-&gt;dma_addr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|non_tx_cmd_elem
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_free_nontx_list
id|e100_free_nontx_list
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
)paren
(brace
id|nxmit_cb_entry_t
op_star
id|command
suffix:semicolon
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|bdp-&gt;non_tx_cmd_list
)paren
)paren
(brace
id|command
op_assign
id|list_entry
c_func
(paren
id|bdp-&gt;non_tx_cmd_list.next
comma
id|nxmit_cb_entry_t
comma
id|list_elem
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
(paren
id|command-&gt;list_elem
)paren
)paren
suffix:semicolon
id|e100_free_non_tx_cmd
c_func
(paren
id|bdp
comma
id|command
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CB_MAX_NONTX_CMD
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bdp-&gt;same_cmd_entry
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_static
r_int
r_char
DECL|function|e100_delayed_exec_non_cu_cmd
id|e100_delayed_exec_non_cu_cmd
c_func
(paren
r_struct
id|e100_private
op_star
id|bdp
comma
id|nxmit_cb_entry_t
op_star
id|command
)paren
(brace
id|nxmit_cb_entry_t
op_star
id|same_command
suffix:semicolon
id|cb_header_t
op_star
id|ntcb_hdr
suffix:semicolon
id|u16
id|cmd
suffix:semicolon
id|ntcb_hdr
op_assign
(paren
id|cb_header_t
op_star
)paren
id|command-&gt;non_tx_cmd
suffix:semicolon
id|cmd
op_assign
id|CB_CMD_MASK
op_amp
id|le16_to_cpu
c_func
(paren
id|ntcb_hdr-&gt;cb_cmd
)paren
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_non_tx_lock
)paren
)paren
suffix:semicolon
id|same_command
op_assign
id|bdp-&gt;same_cmd_entry
(braket
id|cmd
)braket
suffix:semicolon
r_if
c_cond
(paren
id|same_command
op_ne
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|same_command-&gt;non_tx_cmd
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|command-&gt;non_tx_cmd
)paren
comma
r_sizeof
(paren
id|nxmit_cb_t
)paren
)paren
suffix:semicolon
id|e100_free_non_tx_cmd
c_func
(paren
id|bdp
comma
id|command
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add_tail
c_func
(paren
op_amp
(paren
id|command-&gt;list_elem
)paren
comma
op_amp
(paren
id|bdp-&gt;non_tx_cmd_list
)paren
)paren
suffix:semicolon
id|bdp-&gt;same_cmd_entry
(braket
id|cmd
)braket
op_assign
id|command
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bdp-&gt;non_tx_command_state
op_eq
id|E100_NON_TX_IDLE
)paren
(brace
id|bdp-&gt;non_tx_command_state
op_assign
id|E100_WAIT_TX_FINISH
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
(paren
id|bdp-&gt;nontx_timer_id
)paren
comma
id|jiffies
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_non_tx_lock
)paren
)paren
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
r_static
r_void
DECL|function|e100_non_tx_background
id|e100_non_tx_background
c_func
(paren
r_int
r_int
id|ptr
)paren
(brace
r_struct
id|e100_private
op_star
id|bdp
op_assign
(paren
r_struct
id|e100_private
op_star
)paren
id|ptr
suffix:semicolon
id|nxmit_cb_entry_t
op_star
id|active_command
suffix:semicolon
r_int
id|restart
op_assign
l_bool|true
suffix:semicolon
id|spin_lock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_non_tx_lock
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bdp-&gt;non_tx_command_state
)paren
(brace
r_case
id|E100_WAIT_TX_FINISH
suffix:colon
r_if
c_cond
(paren
id|bdp-&gt;last_tcb
op_ne
l_int|NULL
)paren
(brace
id|rmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bdp-&gt;last_tcb-&gt;tcb_hdr.cb_status
op_amp
id|__constant_cpu_to_le16
c_func
(paren
id|CB_STATUS_COMPLETE
)paren
)paren
op_eq
l_int|0
)paren
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|readw
c_func
(paren
op_amp
id|bdp-&gt;scb-&gt;scb_status
)paren
op_amp
id|SCB_CUS_MASK
)paren
op_eq
id|SCB_CUS_ACTIVE
)paren
(brace
r_goto
m_exit
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|E100_WAIT_NON_TX_FINISH
suffix:colon
id|active_command
op_assign
id|list_entry
c_func
(paren
id|bdp-&gt;non_tx_cmd_list.next
comma
id|nxmit_cb_entry_t
comma
id|list_elem
)paren
suffix:semicolon
id|rmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
(paren
id|cb_header_t
op_star
)paren
(paren
id|active_command-&gt;non_tx_cmd
)paren
)paren
op_member_access_from_pointer
id|cb_status
op_amp
id|__constant_cpu_to_le16
c_func
(paren
id|CB_STATUS_COMPLETE
)paren
)paren
op_eq
l_int|0
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|active_command-&gt;expiration_time
)paren
)paren
(brace
r_goto
m_exit
suffix:semicolon
)brace
r_else
(brace
id|list_del
c_func
(paren
op_amp
(paren
id|active_command-&gt;list_elem
)paren
)paren
suffix:semicolon
id|e100_free_non_tx_cmd
c_func
(paren
id|bdp
comma
id|active_command
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
singleline_comment|//switch
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|bdp-&gt;non_tx_cmd_list
)paren
)paren
(brace
id|bdp-&gt;non_tx_command_state
op_assign
id|E100_NON_TX_IDLE
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_lock
)paren
)paren
suffix:semicolon
id|bdp-&gt;next_cu_cmd
op_assign
id|START_WAIT
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_lock
)paren
)paren
suffix:semicolon
id|restart
op_assign
l_bool|false
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
r_else
(brace
id|u16
id|cmd_type
suffix:semicolon
id|bdp-&gt;non_tx_command_state
op_assign
id|E100_WAIT_NON_TX_FINISH
suffix:semicolon
id|active_command
op_assign
id|list_entry
c_func
(paren
id|bdp-&gt;non_tx_cmd_list.next
comma
id|nxmit_cb_entry_t
comma
id|list_elem
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_lock
)paren
)paren
suffix:semicolon
id|e100_wait_exec_cmplx
c_func
(paren
id|bdp
comma
id|active_command-&gt;dma_addr
comma
id|SCB_CUC_START
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_lock
)paren
)paren
suffix:semicolon
id|active_command-&gt;expiration_time
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|cmd_type
op_assign
id|CB_CMD_MASK
op_amp
id|le16_to_cpu
c_func
(paren
(paren
(paren
id|cb_header_t
op_star
)paren
(paren
id|active_command-&gt;non_tx_cmd
)paren
)paren
op_member_access_from_pointer
id|cb_cmd
)paren
suffix:semicolon
id|bdp-&gt;same_cmd_entry
(braket
id|cmd_type
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
m_exit
suffix:colon
r_if
c_cond
(paren
id|restart
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
(paren
id|bdp-&gt;nontx_timer_id
)paren
comma
id|jiffies
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|bdp-&gt;device
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|bdp-&gt;device
)paren
suffix:semicolon
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
(paren
id|bdp-&gt;bd_non_tx_lock
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PM
r_static
r_int
DECL|function|e100_save_state
id|e100_save_state
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
comma
id|u32
id|state
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|e100_private
op_star
id|bdp
suffix:semicolon
multiline_comment|/* Actually, PCI PM does NOT call this entry */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|pci_get_drvdata
c_func
(paren
id|pcid
)paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|bdp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|pci_save_state
c_func
(paren
id|pcid
comma
id|bdp-&gt;pci_state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|e100_suspend
id|e100_suspend
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
comma
id|u32
id|state
)paren
(brace
r_struct
id|net_device
op_star
id|netdev
op_assign
id|pci_get_drvdata
c_func
(paren
id|pcid
)paren
suffix:semicolon
r_struct
id|e100_private
op_star
id|bdp
op_assign
id|netdev-&gt;priv
suffix:semicolon
id|e100_isolate_driver
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|e100_save_state
c_func
(paren
id|pcid
comma
id|state
)paren
suffix:semicolon
multiline_comment|/* If wol is enabled */
macro_line|#ifdef ETHTOOL_GWOL
r_if
c_cond
(paren
id|bdp-&gt;wolopts
)paren
(brace
id|bdp-&gt;ip_lbytes
op_assign
id|e100_get_ip_lbytes
c_func
(paren
id|netdev
)paren
suffix:semicolon
id|e100_do_wol
c_func
(paren
id|pcid
comma
id|bdp
)paren
suffix:semicolon
id|pci_enable_wake
c_func
(paren
id|pcid
comma
l_int|3
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Enable PME for power state D3 */
id|pci_set_power_state
c_func
(paren
id|pcid
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Set power state to D3.        */
)brace
r_else
(brace
multiline_comment|/* Disable bus mastering */
id|pci_disable_device
c_func
(paren
id|pcid
)paren
suffix:semicolon
id|pci_set_power_state
c_func
(paren
id|pcid
comma
id|state
)paren
suffix:semicolon
)brace
macro_line|#else
id|pci_disable_device
c_func
(paren
id|pcid
)paren
suffix:semicolon
id|pci_set_power_state
c_func
(paren
id|pcid
comma
id|state
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|e100_resume
id|e100_resume
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
)paren
(brace
r_struct
id|net_device
op_star
id|netdev
op_assign
id|pci_get_drvdata
c_func
(paren
id|pcid
)paren
suffix:semicolon
r_struct
id|e100_private
op_star
id|bdp
op_assign
id|netdev-&gt;priv
suffix:semicolon
id|u8
id|recover
op_assign
l_bool|false
suffix:semicolon
id|u8
id|full_init
op_assign
l_bool|false
suffix:semicolon
id|pci_set_power_state
c_func
(paren
id|pcid
comma
l_int|0
)paren
suffix:semicolon
id|pci_enable_wake
c_func
(paren
id|pcid
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Clear PME status and disable PME */
id|pci_restore_state
c_func
(paren
id|pcid
comma
id|bdp-&gt;pci_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|netdev
)paren
)paren
(brace
id|recover
op_assign
l_bool|true
suffix:semicolon
)brace
macro_line|#ifdef ETHTOOL_GWOL
r_if
c_cond
(paren
id|bdp-&gt;wolopts
op_amp
(paren
id|WAKE_UCAST
op_or
id|WAKE_ARP
)paren
)paren
(brace
id|full_init
op_assign
l_bool|true
suffix:semicolon
)brace
macro_line|#endif
id|e100_deisolate_driver
c_func
(paren
id|bdp
comma
id|recover
comma
id|full_init
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|e100_enable_wake
id|e100_enable_wake
c_func
(paren
r_struct
id|pci_dev
op_star
id|pcid
comma
id|u32
id|state
comma
r_int
id|enable
)paren
(brace
multiline_comment|/* Driver doesn&squot;t need to do anything because it will enable */
multiline_comment|/* wol when suspended.                                       */
multiline_comment|/* Actually, PCI PM does NOT call this entry.                */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PM */
eof
