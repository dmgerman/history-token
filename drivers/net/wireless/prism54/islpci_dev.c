multiline_comment|/*&n; *  &n; *  Copyright (C) 2002 Intersil Americas Inc.&n; *  Copyright (C) 2003 Herbert Valerio Riedel &lt;hvr@gnu.org&gt;&n; *  Copyright (C) 2003 Luis R. Rodriguez &lt;mcgrof@ruslug.rutgers.edu&gt;&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;prismcompat.h&quot;
macro_line|#include &quot;isl_38xx.h&quot;
macro_line|#include &quot;isl_ioctl.h&quot;
macro_line|#include &quot;islpci_dev.h&quot;
macro_line|#include &quot;islpci_mgt.h&quot;
macro_line|#include &quot;islpci_eth.h&quot;
macro_line|#include &quot;oid_mgt.h&quot;
DECL|macro|ISL3877_IMAGE_FILE
mdefine_line|#define ISL3877_IMAGE_FILE&t;&quot;isl3877&quot;
DECL|macro|ISL3886_IMAGE_FILE
mdefine_line|#define ISL3886_IMAGE_FILE&t;&quot;isl3886&quot;
DECL|macro|ISL3890_IMAGE_FILE
mdefine_line|#define ISL3890_IMAGE_FILE&t;&quot;isl3890&quot;
r_static
r_int
id|prism54_bring_down
c_func
(paren
id|islpci_private
op_star
)paren
suffix:semicolon
r_static
r_int
id|islpci_alloc_memory
c_func
(paren
id|islpci_private
op_star
)paren
suffix:semicolon
multiline_comment|/* Temporary dummy MAC address to use until firmware is loaded.&n; * The idea there is that some tools (such as nameif) may query&n; * the MAC address before the netdev is &squot;open&squot;. By using a valid&n; * OUI prefix, they can process the netdev properly.&n; * Of course, this is not the final/real MAC address. It doesn&squot;t&n; * matter, as you are suppose to be able to change it anytime via&n; * ndev-&gt;set_mac_address. Jean II */
DECL|variable|dummy_mac
r_const
r_int
r_char
id|dummy_mac
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x30
comma
l_int|0xB4
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_static
r_int
DECL|function|isl_upload_firmware
id|isl_upload_firmware
c_func
(paren
id|islpci_private
op_star
id|priv
)paren
(brace
id|u32
id|reg
comma
id|rc
suffix:semicolon
r_void
id|__iomem
op_star
id|device_base
op_assign
id|priv-&gt;device_base
suffix:semicolon
multiline_comment|/* clear the RAMBoot and the Reset bit */
id|reg
op_assign
id|readl
c_func
(paren
id|device_base
op_plus
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
id|reg
op_and_assign
op_complement
id|ISL38XX_CTRL_STAT_RESET
suffix:semicolon
id|reg
op_and_assign
op_complement
id|ISL38XX_CTRL_STAT_RAMBOOT
suffix:semicolon
id|writel
c_func
(paren
id|reg
comma
id|device_base
op_plus
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ISL38XX_WRITEIO_DELAY
)paren
suffix:semicolon
multiline_comment|/* set the Reset bit without reading the register ! */
id|reg
op_or_assign
id|ISL38XX_CTRL_STAT_RESET
suffix:semicolon
id|writel
c_func
(paren
id|reg
comma
id|device_base
op_plus
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ISL38XX_WRITEIO_DELAY
)paren
suffix:semicolon
multiline_comment|/* clear the Reset bit */
id|reg
op_and_assign
op_complement
id|ISL38XX_CTRL_STAT_RESET
suffix:semicolon
id|writel
c_func
(paren
id|reg
comma
id|device_base
op_plus
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a while for the device to reboot */
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
(brace
r_const
r_struct
id|firmware
op_star
id|fw_entry
op_assign
l_int|NULL
suffix:semicolon
r_int
id|fw_len
suffix:semicolon
r_const
id|u32
op_star
id|fw_ptr
suffix:semicolon
id|rc
op_assign
id|request_firmware
c_func
(paren
op_amp
id|fw_entry
comma
id|priv-&gt;firmware
comma
id|PRISM_FW_PDEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: request_firmware() failed for &squot;%s&squot;&bslash;n&quot;
comma
l_string|&quot;prism54&quot;
comma
id|priv-&gt;firmware
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* prepare the Direct Memory Base register */
id|reg
op_assign
id|ISL38XX_DEV_FIRMWARE_ADDRES
suffix:semicolon
id|fw_ptr
op_assign
(paren
id|u32
op_star
)paren
id|fw_entry-&gt;data
suffix:semicolon
id|fw_len
op_assign
id|fw_entry-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|fw_len
op_mod
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: firmware &squot;%s&squot; size is not multiple of 32bit, aborting!&bslash;n&quot;
comma
l_string|&quot;prism54&quot;
comma
id|priv-&gt;firmware
)paren
suffix:semicolon
id|release_firmware
c_func
(paren
id|fw_entry
)paren
suffix:semicolon
r_return
op_minus
id|EILSEQ
suffix:semicolon
multiline_comment|/* Illegal byte sequence  */
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fw_len
OG
l_int|0
)paren
(brace
r_int
id|_fw_len
op_assign
(paren
id|fw_len
OG
id|ISL38XX_MEMORY_WINDOW_SIZE
)paren
ques
c_cond
id|ISL38XX_MEMORY_WINDOW_SIZE
suffix:colon
id|fw_len
suffix:semicolon
id|u32
id|__iomem
op_star
id|dev_fw_ptr
op_assign
id|device_base
op_plus
id|ISL38XX_DIRECT_MEM_WIN
suffix:semicolon
multiline_comment|/* set the cards base address for writting the data */
id|isl38xx_w32_flush
c_func
(paren
id|device_base
comma
id|reg
comma
id|ISL38XX_DIR_MEM_BASE_REG
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* be paranoid */
multiline_comment|/* increment the write address for next iteration */
id|reg
op_add_assign
id|_fw_len
suffix:semicolon
id|fw_len
op_sub_assign
id|_fw_len
suffix:semicolon
multiline_comment|/* write the data to the Direct Memory Window 32bit-wise */
multiline_comment|/* memcpy_toio() doesn&squot;t guarantee 32bit writes :-| */
r_while
c_loop
(paren
id|_fw_len
OG
l_int|0
)paren
(brace
multiline_comment|/* use non-swapping writel() */
id|__raw_writel
c_func
(paren
op_star
id|fw_ptr
comma
id|dev_fw_ptr
)paren
suffix:semicolon
id|fw_ptr
op_increment
comma
id|dev_fw_ptr
op_increment
suffix:semicolon
id|_fw_len
op_sub_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* flush PCI posting */
(paren
r_void
)paren
id|readl
c_func
(paren
id|device_base
op_plus
id|ISL38XX_PCI_POSTING_FLUSH
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* be paranoid again */
id|BUG_ON
c_func
(paren
id|_fw_len
op_ne
l_int|0
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|fw_len
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Firmware version is at offset 40 (also for &quot;newmac&quot;) */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: firmware version: %.8s&bslash;n&quot;
comma
id|priv-&gt;ndev-&gt;name
comma
id|fw_entry-&gt;data
op_plus
l_int|40
)paren
suffix:semicolon
id|release_firmware
c_func
(paren
id|fw_entry
)paren
suffix:semicolon
)brace
multiline_comment|/* now reset the device&n;&t; * clear the Reset &amp; ClkRun bit, set the RAMBoot bit */
id|reg
op_assign
id|readl
c_func
(paren
id|device_base
op_plus
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
id|reg
op_and_assign
op_complement
id|ISL38XX_CTRL_STAT_CLKRUN
suffix:semicolon
id|reg
op_and_assign
op_complement
id|ISL38XX_CTRL_STAT_RESET
suffix:semicolon
id|reg
op_or_assign
id|ISL38XX_CTRL_STAT_RAMBOOT
suffix:semicolon
id|isl38xx_w32_flush
c_func
(paren
id|device_base
comma
id|reg
comma
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ISL38XX_WRITEIO_DELAY
)paren
suffix:semicolon
multiline_comment|/* set the reset bit latches the host override and RAMBoot bits&n;&t; * into the device for operation when the reset bit is reset */
id|reg
op_or_assign
id|ISL38XX_CTRL_STAT_RESET
suffix:semicolon
id|writel
c_func
(paren
id|reg
comma
id|device_base
op_plus
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
multiline_comment|/* don&squot;t do flush PCI posting here! */
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ISL38XX_WRITEIO_DELAY
)paren
suffix:semicolon
multiline_comment|/* clear the reset bit should start the whole circus */
id|reg
op_and_assign
op_complement
id|ISL38XX_CTRL_STAT_RESET
suffix:semicolon
id|writel
c_func
(paren
id|reg
comma
id|device_base
op_plus
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
multiline_comment|/* don&squot;t do flush PCI posting here! */
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ISL38XX_WRITEIO_DELAY
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;    Device Interrupt Handler&n;******************************************************************************/
id|irqreturn_t
DECL|function|islpci_interrupt
id|islpci_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|config
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u32
id|reg
suffix:semicolon
id|islpci_private
op_star
id|priv
op_assign
id|config
suffix:semicolon
r_struct
id|net_device
op_star
id|ndev
op_assign
id|priv-&gt;ndev
suffix:semicolon
r_void
id|__iomem
op_star
id|device
op_assign
id|priv-&gt;device_base
suffix:semicolon
r_int
id|powerstate
op_assign
id|ISL38XX_PSM_POWERSAVE_STATE
suffix:semicolon
multiline_comment|/* lock the interrupt handler */
id|spin_lock
c_func
(paren
op_amp
id|priv-&gt;slock
)paren
suffix:semicolon
multiline_comment|/* received an interrupt request on a shared IRQ line&n;&t; * first check whether the device is in sleep mode */
id|reg
op_assign
id|readl
c_func
(paren
id|device
op_plus
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_amp
id|ISL38XX_CTRL_STAT_SLEEPMODE
)paren
multiline_comment|/* device is in sleep mode, IRQ was generated by someone else */
(brace
macro_line|#if VERBOSE &gt; SHOW_ERROR_MESSAGES
id|DEBUG
c_func
(paren
id|SHOW_TRACING
comma
l_string|&quot;Assuming someone else called the IRQ&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock
c_func
(paren
op_amp
id|priv-&gt;slock
)paren
suffix:semicolon
r_return
id|IRQ_NONE
suffix:semicolon
)brace
multiline_comment|/* check whether there is any source of interrupt on the device */
id|reg
op_assign
id|readl
c_func
(paren
id|device
op_plus
id|ISL38XX_INT_IDENT_REG
)paren
suffix:semicolon
multiline_comment|/* also check the contents of the Interrupt Enable Register, because this&n;&t; * will filter out interrupt sources from other devices on the same irq ! */
id|reg
op_and_assign
id|readl
c_func
(paren
id|device
op_plus
id|ISL38XX_INT_EN_REG
)paren
suffix:semicolon
id|reg
op_and_assign
id|ISL38XX_INT_SOURCES
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|islpci_get_state
c_func
(paren
id|priv
)paren
op_ne
id|PRV_STATE_SLEEP
)paren
id|powerstate
op_assign
id|ISL38XX_PSM_ACTIVE_STATE
suffix:semicolon
multiline_comment|/* reset the request bits in the Identification register */
id|isl38xx_w32_flush
c_func
(paren
id|device
comma
id|reg
comma
id|ISL38XX_INT_ACK_REG
)paren
suffix:semicolon
macro_line|#if VERBOSE &gt; SHOW_ERROR_MESSAGES
id|DEBUG
c_func
(paren
id|SHOW_FUNCTION_CALLS
comma
l_string|&quot;IRQ: Identification register 0x%p 0x%x &bslash;n&quot;
comma
id|device
comma
id|reg
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* check for each bit in the register separately */
r_if
c_cond
(paren
id|reg
op_amp
id|ISL38XX_INT_IDENT_UPDATE
)paren
(brace
macro_line|#if VERBOSE &gt; SHOW_ERROR_MESSAGES
multiline_comment|/* Queue has been updated */
id|DEBUG
c_func
(paren
id|SHOW_TRACING
comma
l_string|&quot;IRQ: Update flag &bslash;n&quot;
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|SHOW_QUEUE_INDEXES
comma
l_string|&quot;CB drv Qs: [%i][%i][%i][%i][%i][%i]&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|priv-&gt;control_block
op_member_access_from_pointer
id|driver_curr_frag
(braket
l_int|0
)braket
)paren
comma
id|le32_to_cpu
c_func
(paren
id|priv-&gt;control_block
op_member_access_from_pointer
id|driver_curr_frag
(braket
l_int|1
)braket
)paren
comma
id|le32_to_cpu
c_func
(paren
id|priv-&gt;control_block
op_member_access_from_pointer
id|driver_curr_frag
(braket
l_int|2
)braket
)paren
comma
id|le32_to_cpu
c_func
(paren
id|priv-&gt;control_block
op_member_access_from_pointer
id|driver_curr_frag
(braket
l_int|3
)braket
)paren
comma
id|le32_to_cpu
c_func
(paren
id|priv-&gt;control_block
op_member_access_from_pointer
id|driver_curr_frag
(braket
l_int|4
)braket
)paren
comma
id|le32_to_cpu
c_func
(paren
id|priv-&gt;control_block
op_member_access_from_pointer
id|driver_curr_frag
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|SHOW_QUEUE_INDEXES
comma
l_string|&quot;CB dev Qs: [%i][%i][%i][%i][%i][%i]&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|priv-&gt;control_block
op_member_access_from_pointer
id|device_curr_frag
(braket
l_int|0
)braket
)paren
comma
id|le32_to_cpu
c_func
(paren
id|priv-&gt;control_block
op_member_access_from_pointer
id|device_curr_frag
(braket
l_int|1
)braket
)paren
comma
id|le32_to_cpu
c_func
(paren
id|priv-&gt;control_block
op_member_access_from_pointer
id|device_curr_frag
(braket
l_int|2
)braket
)paren
comma
id|le32_to_cpu
c_func
(paren
id|priv-&gt;control_block
op_member_access_from_pointer
id|device_curr_frag
(braket
l_int|3
)braket
)paren
comma
id|le32_to_cpu
c_func
(paren
id|priv-&gt;control_block
op_member_access_from_pointer
id|device_curr_frag
(braket
l_int|4
)braket
)paren
comma
id|le32_to_cpu
c_func
(paren
id|priv-&gt;control_block
op_member_access_from_pointer
id|device_curr_frag
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* cleanup the data low transmit queue */
id|islpci_eth_cleanup_transmit
c_func
(paren
id|priv
comma
id|priv-&gt;control_block
)paren
suffix:semicolon
multiline_comment|/* device is in active state, update the&n;&t;&t;&t; * powerstate flag if necessary */
id|powerstate
op_assign
id|ISL38XX_PSM_ACTIVE_STATE
suffix:semicolon
multiline_comment|/* check all three queues in priority order&n;&t;&t;&t; * call the PIMFOR receive function until the&n;&t;&t;&t; * queue is empty */
r_if
c_cond
(paren
id|isl38xx_in_queue
c_func
(paren
id|priv-&gt;control_block
comma
id|ISL38XX_CB_RX_MGMTQ
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#if VERBOSE &gt; SHOW_ERROR_MESSAGES
id|DEBUG
c_func
(paren
id|SHOW_TRACING
comma
l_string|&quot;Received frame in Management Queue&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|islpci_mgt_receive
c_func
(paren
id|ndev
)paren
suffix:semicolon
id|islpci_mgt_cleanup_transmit
c_func
(paren
id|ndev
)paren
suffix:semicolon
multiline_comment|/* Refill slots in receive queue */
id|islpci_mgmt_rx_fill
c_func
(paren
id|ndev
)paren
suffix:semicolon
multiline_comment|/* no need to trigger the device, next&n;                                   islpci_mgt_transaction does it */
)brace
r_while
c_loop
(paren
id|isl38xx_in_queue
c_func
(paren
id|priv-&gt;control_block
comma
id|ISL38XX_CB_RX_DATA_LQ
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#if VERBOSE &gt; SHOW_ERROR_MESSAGES
id|DEBUG
c_func
(paren
id|SHOW_TRACING
comma
l_string|&quot;Received frame in Data Low Queue &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|islpci_eth_receive
c_func
(paren
id|priv
)paren
suffix:semicolon
)brace
multiline_comment|/* check whether the data transmit queues were full */
r_if
c_cond
(paren
id|priv-&gt;data_low_tx_full
)paren
(brace
multiline_comment|/* check whether the transmit is not full anymore */
r_if
c_cond
(paren
id|ISL38XX_CB_TX_QSIZE
op_minus
id|isl38xx_in_queue
c_func
(paren
id|priv-&gt;control_block
comma
id|ISL38XX_CB_TX_DATA_LQ
)paren
op_ge
id|ISL38XX_MIN_QTHRESHOLD
)paren
(brace
multiline_comment|/* nope, the driver is ready for more network frames */
id|netif_wake_queue
c_func
(paren
id|priv-&gt;ndev
)paren
suffix:semicolon
multiline_comment|/* reset the full flag */
id|priv-&gt;data_low_tx_full
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|reg
op_amp
id|ISL38XX_INT_IDENT_INIT
)paren
(brace
multiline_comment|/* Device has been initialized */
macro_line|#if VERBOSE &gt; SHOW_ERROR_MESSAGES
id|DEBUG
c_func
(paren
id|SHOW_TRACING
comma
l_string|&quot;IRQ: Init flag, device initialized &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|wake_up
c_func
(paren
op_amp
id|priv-&gt;reset_done
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg
op_amp
id|ISL38XX_INT_IDENT_SLEEP
)paren
(brace
multiline_comment|/* Device intends to move to powersave state */
macro_line|#if VERBOSE &gt; SHOW_ERROR_MESSAGES
id|DEBUG
c_func
(paren
id|SHOW_TRACING
comma
l_string|&quot;IRQ: Sleep flag &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|isl38xx_handle_sleep_request
c_func
(paren
id|priv-&gt;control_block
comma
op_amp
id|powerstate
comma
id|priv-&gt;device_base
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg
op_amp
id|ISL38XX_INT_IDENT_WAKEUP
)paren
(brace
multiline_comment|/* Device has been woken up to active state */
macro_line|#if VERBOSE &gt; SHOW_ERROR_MESSAGES
id|DEBUG
c_func
(paren
id|SHOW_TRACING
comma
l_string|&quot;IRQ: Wakeup flag &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|isl38xx_handle_wakeup
c_func
(paren
id|priv-&gt;control_block
comma
op_amp
id|powerstate
comma
id|priv-&gt;device_base
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#if VERBOSE &gt; SHOW_ERROR_MESSAGES
id|DEBUG
c_func
(paren
id|SHOW_TRACING
comma
l_string|&quot;Assuming someone else called the IRQ&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock
c_func
(paren
op_amp
id|priv-&gt;slock
)paren
suffix:semicolon
r_return
id|IRQ_NONE
suffix:semicolon
)brace
multiline_comment|/* sleep -&gt; ready */
r_if
c_cond
(paren
id|islpci_get_state
c_func
(paren
id|priv
)paren
op_eq
id|PRV_STATE_SLEEP
op_logical_and
id|powerstate
op_eq
id|ISL38XX_PSM_ACTIVE_STATE
)paren
id|islpci_set_state
c_func
(paren
id|priv
comma
id|PRV_STATE_READY
)paren
suffix:semicolon
multiline_comment|/* !sleep -&gt; sleep */
r_if
c_cond
(paren
id|islpci_get_state
c_func
(paren
id|priv
)paren
op_ne
id|PRV_STATE_SLEEP
op_logical_and
id|powerstate
op_eq
id|ISL38XX_PSM_POWERSAVE_STATE
)paren
id|islpci_set_state
c_func
(paren
id|priv
comma
id|PRV_STATE_SLEEP
)paren
suffix:semicolon
multiline_comment|/* unlock the interrupt handler */
id|spin_unlock
c_func
(paren
op_amp
id|priv-&gt;slock
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;    Network Interface Control &amp; Statistical functions&n;******************************************************************************/
r_static
r_int
DECL|function|islpci_open
id|islpci_open
c_func
(paren
r_struct
id|net_device
op_star
id|ndev
)paren
(brace
id|u32
id|rc
suffix:semicolon
id|islpci_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|ndev
)paren
suffix:semicolon
multiline_comment|/* reset data structures, upload firmware and reset device */
id|rc
op_assign
id|islpci_reset
c_func
(paren
id|priv
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|prism54_bring_down
c_func
(paren
id|priv
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
multiline_comment|/* Returns informative message */
)brace
id|netif_start_queue
c_func
(paren
id|ndev
)paren
suffix:semicolon
multiline_comment|/*      netif_mark_up( ndev ); */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|islpci_close
id|islpci_close
c_func
(paren
r_struct
id|net_device
op_star
id|ndev
)paren
(brace
id|islpci_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|ndev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: islpci_close ()&bslash;n&quot;
comma
id|ndev-&gt;name
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|ndev
)paren
suffix:semicolon
r_return
id|prism54_bring_down
c_func
(paren
id|priv
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|prism54_bring_down
id|prism54_bring_down
c_func
(paren
id|islpci_private
op_star
id|priv
)paren
(brace
r_void
id|__iomem
op_star
id|device_base
op_assign
id|priv-&gt;device_base
suffix:semicolon
id|u32
id|reg
suffix:semicolon
multiline_comment|/* we are going to shutdown the device */
id|islpci_set_state
c_func
(paren
id|priv
comma
id|PRV_STATE_PREBOOT
)paren
suffix:semicolon
multiline_comment|/* disable all device interrupts in case they weren&squot;t */
id|isl38xx_disable_interrupts
c_func
(paren
id|priv-&gt;device_base
)paren
suffix:semicolon
multiline_comment|/* For safety reasons, we may want to ensure that no DMA transfer is&n;&t; * currently in progress by emptying the TX and RX queues. */
multiline_comment|/* wait until interrupts have finished executing on other CPUs */
id|synchronize_irq
c_func
(paren
id|priv-&gt;pdev-&gt;irq
)paren
suffix:semicolon
id|reg
op_assign
id|readl
c_func
(paren
id|device_base
op_plus
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
id|reg
op_and_assign
op_complement
(paren
id|ISL38XX_CTRL_STAT_RESET
op_or
id|ISL38XX_CTRL_STAT_RAMBOOT
)paren
suffix:semicolon
id|writel
c_func
(paren
id|reg
comma
id|device_base
op_plus
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ISL38XX_WRITEIO_DELAY
)paren
suffix:semicolon
id|reg
op_or_assign
id|ISL38XX_CTRL_STAT_RESET
suffix:semicolon
id|writel
c_func
(paren
id|reg
comma
id|device_base
op_plus
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ISL38XX_WRITEIO_DELAY
)paren
suffix:semicolon
multiline_comment|/* clear the Reset bit */
id|reg
op_and_assign
op_complement
id|ISL38XX_CTRL_STAT_RESET
suffix:semicolon
id|writel
c_func
(paren
id|reg
comma
id|device_base
op_plus
id|ISL38XX_CTRL_STAT_REG
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a while for the device to reset */
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|50
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|islpci_upload_fw
id|islpci_upload_fw
c_func
(paren
id|islpci_private
op_star
id|priv
)paren
(brace
id|islpci_state_t
id|old_state
suffix:semicolon
id|u32
id|rc
suffix:semicolon
id|old_state
op_assign
id|islpci_set_state
c_func
(paren
id|priv
comma
id|PRV_STATE_BOOT
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: uploading firmware...&bslash;n&quot;
comma
id|priv-&gt;ndev-&gt;name
)paren
suffix:semicolon
id|rc
op_assign
id|isl_upload_firmware
c_func
(paren
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
multiline_comment|/* error uploading the firmware */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: could not upload firmware (&squot;%s&squot;)&bslash;n&quot;
comma
id|priv-&gt;ndev-&gt;name
comma
id|priv-&gt;firmware
)paren
suffix:semicolon
id|islpci_set_state
c_func
(paren
id|priv
comma
id|old_state
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: firmware upload complete&bslash;n&quot;
comma
id|priv-&gt;ndev-&gt;name
)paren
suffix:semicolon
id|islpci_set_state
c_func
(paren
id|priv
comma
id|PRV_STATE_POSTBOOT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|islpci_reset_if
id|islpci_reset_if
c_func
(paren
id|islpci_private
op_star
id|priv
)paren
(brace
r_int
id|remaining
suffix:semicolon
r_int
id|result
op_assign
op_minus
id|ETIME
suffix:semicolon
r_int
id|count
suffix:semicolon
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
id|prepare_to_wait
c_func
(paren
op_amp
id|priv-&gt;reset_done
comma
op_amp
id|wait
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/* now the last step is to reset the interface */
id|isl38xx_interface_reset
c_func
(paren
id|priv-&gt;device_base
comma
id|priv-&gt;device_host_address
)paren
suffix:semicolon
id|islpci_set_state
c_func
(paren
id|priv
comma
id|PRV_STATE_PREINIT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|2
op_logical_and
id|result
suffix:semicolon
id|count
op_increment
)paren
(brace
multiline_comment|/* The software reset acknowledge needs about 220 msec here.&n;&t;&t; * Be conservative and wait for up to one second. */
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|remaining
op_assign
id|schedule_timeout
c_func
(paren
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remaining
OG
l_int|0
)paren
(brace
id|result
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* If we&squot;re here it&squot;s because our IRQ hasn&squot;t yet gone through. &n;&t;&t; * Retry a bit more...&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no &squot;reset complete&squot; IRQ seen - retrying&bslash;n&quot;
comma
id|priv-&gt;ndev-&gt;name
)paren
suffix:semicolon
)brace
id|finish_wait
c_func
(paren
op_amp
id|priv-&gt;reset_done
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: interface reset failure&bslash;n&quot;
comma
id|priv-&gt;ndev-&gt;name
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|islpci_set_state
c_func
(paren
id|priv
comma
id|PRV_STATE_INIT
)paren
suffix:semicolon
multiline_comment|/* Now that the device is 100% up, let&squot;s allow&n;&t; * for the other interrupts --&n;&t; * NOTE: this is not *yet* true since we&squot;ve only allowed the &n;&t; * INIT interrupt on the IRQ line. We can perhaps poll&n;&t; * the IRQ line until we know for sure the reset went through */
id|isl38xx_enable_common_interrupts
c_func
(paren
id|priv-&gt;device_base
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|priv-&gt;mib_sem
)paren
suffix:semicolon
id|result
op_assign
id|mgt_commit
c_func
(paren
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: interface reset failure&bslash;n&quot;
comma
id|priv-&gt;ndev-&gt;name
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|priv-&gt;mib_sem
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|priv-&gt;mib_sem
)paren
suffix:semicolon
id|islpci_set_state
c_func
(paren
id|priv
comma
id|PRV_STATE_READY
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: interface reset complete&bslash;n&quot;
comma
id|priv-&gt;ndev-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|islpci_reset
id|islpci_reset
c_func
(paren
id|islpci_private
op_star
id|priv
comma
r_int
id|reload_firmware
)paren
(brace
id|isl38xx_control_block
op_star
id|cb
op_assign
multiline_comment|/* volatile not needed */
(paren
id|isl38xx_control_block
op_star
)paren
id|priv-&gt;control_block
suffix:semicolon
r_int
id|counter
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|reload_firmware
)paren
id|islpci_set_state
c_func
(paren
id|priv
comma
id|PRV_STATE_PREBOOT
)paren
suffix:semicolon
r_else
id|islpci_set_state
c_func
(paren
id|priv
comma
id|PRV_STATE_POSTBOOT
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: resetting device...&bslash;n&quot;
comma
id|priv-&gt;ndev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* disable all device interrupts in case they weren&squot;t */
id|isl38xx_disable_interrupts
c_func
(paren
id|priv-&gt;device_base
)paren
suffix:semicolon
multiline_comment|/* flush all management queues */
id|priv-&gt;index_mgmt_tx
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;index_mgmt_rx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear the indexes in the frame pointer */
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
id|ISL38XX_CB_QCOUNT
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|cb-&gt;driver_curr_frag
(braket
id|counter
)braket
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|cb-&gt;device_curr_frag
(braket
id|counter
)braket
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* reset the mgmt receive queue */
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
id|ISL38XX_CB_MGMT_QSIZE
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|isl38xx_fragment
op_star
id|frag
op_assign
op_amp
id|cb-&gt;rx_data_mgmt
(braket
id|counter
)braket
suffix:semicolon
id|frag-&gt;size
op_assign
id|cpu_to_le16
c_func
(paren
id|MGMT_FRAME_SIZE
)paren
suffix:semicolon
id|frag-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|frag-&gt;address
op_assign
id|cpu_to_le32
c_func
(paren
id|priv-&gt;mgmt_rx
(braket
id|counter
)braket
dot
id|pci_addr
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
id|ISL38XX_CB_RX_QSIZE
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|cb-&gt;rx_data_low
(braket
id|counter
)braket
dot
id|address
op_assign
id|cpu_to_le32
c_func
(paren
(paren
id|u32
)paren
id|priv-&gt;pci_map_rx_address
(braket
id|counter
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* since the receive queues are filled with empty fragments, now we can&n;&t; * set the corresponding indexes in the Control Block */
id|priv-&gt;control_block-&gt;driver_curr_frag
(braket
id|ISL38XX_CB_RX_DATA_LQ
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|ISL38XX_CB_RX_QSIZE
)paren
suffix:semicolon
id|priv-&gt;control_block-&gt;driver_curr_frag
(braket
id|ISL38XX_CB_RX_MGMTQ
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|ISL38XX_CB_MGMT_QSIZE
)paren
suffix:semicolon
multiline_comment|/* reset the remaining real index registers and full flags */
id|priv-&gt;free_data_rx
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;free_data_tx
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;data_low_tx_full
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|reload_firmware
)paren
(brace
multiline_comment|/* Should we load the firmware ? */
multiline_comment|/* now that the data structures are cleaned up, upload&n;&t; * firmware and reset interface */
id|rc
op_assign
id|islpci_upload_fw
c_func
(paren
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: islpci_reset: failure&bslash;n&quot;
comma
id|priv-&gt;ndev-&gt;name
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
)brace
multiline_comment|/* finally reset interface */
id|rc
op_assign
id|islpci_reset_if
c_func
(paren
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;prism54: Your card/socket may be faulty, or IRQ line too busy :(&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_struct
id|net_device_stats
op_star
DECL|function|islpci_statistics
id|islpci_statistics
c_func
(paren
r_struct
id|net_device
op_star
id|ndev
)paren
(brace
id|islpci_private
op_star
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|ndev
)paren
suffix:semicolon
macro_line|#if VERBOSE &gt; SHOW_ERROR_MESSAGES
id|DEBUG
c_func
(paren
id|SHOW_FUNCTION_CALLS
comma
l_string|&quot;islpci_statistics&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_amp
id|priv-&gt;statistics
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n;    Network device configuration functions&n;******************************************************************************/
r_static
r_int
DECL|function|islpci_alloc_memory
id|islpci_alloc_memory
c_func
(paren
id|islpci_private
op_star
id|priv
)paren
(brace
r_int
id|counter
suffix:semicolon
macro_line|#if VERBOSE &gt; SHOW_ERROR_MESSAGES
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;islpci_alloc_memory&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* remap the PCI device base address to accessable */
r_if
c_cond
(paren
op_logical_neg
(paren
id|priv-&gt;device_base
op_assign
id|ioremap
c_func
(paren
id|pci_resource_start
c_func
(paren
id|priv-&gt;pdev
comma
l_int|0
)paren
comma
id|ISL38XX_PCI_MEM_SIZE
)paren
)paren
)paren
(brace
multiline_comment|/* error in remapping the PCI device memory address range */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PCI memory remapping failed &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* memory layout for consistent DMA region:&n;&t; *&n;&t; * Area 1: Control Block for the device interface&n;&t; * Area 2: Power Save Mode Buffer for temporary frame storage. Be aware that&n;&t; *         the number of supported stations in the AP determines the minimal&n;&t; *         size of the buffer !&n;&t; */
multiline_comment|/* perform the allocation */
id|priv-&gt;driver_mem_address
op_assign
id|pci_alloc_consistent
c_func
(paren
id|priv-&gt;pdev
comma
id|HOST_MEM_BLOCK
comma
op_amp
id|priv
op_member_access_from_pointer
id|device_host_address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;driver_mem_address
)paren
(brace
multiline_comment|/* error allocating the block of PCI memory */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: could not allocate DMA memory, aborting!&quot;
comma
l_string|&quot;prism54&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* assign the Control Block to the first address of the allocated area */
id|priv-&gt;control_block
op_assign
(paren
id|isl38xx_control_block
op_star
)paren
id|priv-&gt;driver_mem_address
suffix:semicolon
multiline_comment|/* set the Power Save Buffer pointer directly behind the CB */
id|priv-&gt;device_psm_buffer
op_assign
id|priv-&gt;device_host_address
op_plus
id|CONTROL_BLOCK_SIZE
suffix:semicolon
multiline_comment|/* make sure all buffer pointers are initialized */
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
id|ISL38XX_CB_QCOUNT
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|priv-&gt;control_block-&gt;driver_curr_frag
(braket
id|counter
)braket
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|priv-&gt;control_block-&gt;device_curr_frag
(braket
id|counter
)braket
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|priv-&gt;index_mgmt_rx
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|priv-&gt;mgmt_rx
comma
l_int|0
comma
r_sizeof
(paren
id|priv-&gt;mgmt_rx
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|priv-&gt;mgmt_tx
comma
l_int|0
comma
r_sizeof
(paren
id|priv-&gt;mgmt_tx
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate rx queue for management frames */
r_if
c_cond
(paren
id|islpci_mgmt_rx_fill
c_func
(paren
id|priv-&gt;ndev
)paren
OL
l_int|0
)paren
r_goto
id|out_free
suffix:semicolon
multiline_comment|/* now get the data rx skb&squot;s */
id|memset
c_func
(paren
id|priv-&gt;data_low_rx
comma
l_int|0
comma
r_sizeof
(paren
id|priv-&gt;data_low_rx
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|priv-&gt;pci_map_rx_address
comma
l_int|0
comma
r_sizeof
(paren
id|priv-&gt;pci_map_rx_address
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
id|ISL38XX_CB_RX_QSIZE
suffix:semicolon
id|counter
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* allocate an sk_buff for received data frames storage&n;&t;&t; * each frame on receive size consists of 1 fragment&n;&t;&t; * include any required allignment operations */
r_if
c_cond
(paren
op_logical_neg
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|MAX_FRAGMENT_SIZE_RX
op_plus
l_int|2
)paren
)paren
)paren
(brace
multiline_comment|/* error allocating an sk_buff structure elements */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Error allocating skb.&bslash;n&quot;
)paren
suffix:semicolon
id|skb
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
(paren
l_int|4
op_minus
(paren
r_int
)paren
id|skb-&gt;data
)paren
op_amp
l_int|0x03
)paren
suffix:semicolon
multiline_comment|/* add the new allocated sk_buff to the buffer array */
id|priv-&gt;data_low_rx
(braket
id|counter
)braket
op_assign
id|skb
suffix:semicolon
multiline_comment|/* map the allocated skb data area to pci */
id|priv-&gt;pci_map_rx_address
(braket
id|counter
)braket
op_assign
id|pci_map_single
c_func
(paren
id|priv-&gt;pdev
comma
(paren
r_void
op_star
)paren
id|skb-&gt;data
comma
id|MAX_FRAGMENT_SIZE_RX
op_plus
l_int|2
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;pci_map_rx_address
(braket
id|counter
)braket
)paren
(brace
multiline_comment|/* error mapping the buffer to device&n;&t;&t;&t;   accessable memory address */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;failed to map skb DMA&squot;able&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
)brace
id|prism54_acl_init
c_func
(paren
op_amp
id|priv-&gt;acl
)paren
suffix:semicolon
id|prism54_wpa_ie_init
c_func
(paren
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgt_init
c_func
(paren
id|priv
)paren
)paren
r_goto
id|out_free
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_free
suffix:colon
id|islpci_free_memory
c_func
(paren
id|priv
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|islpci_free_memory
id|islpci_free_memory
c_func
(paren
id|islpci_private
op_star
id|priv
)paren
(brace
r_int
id|counter
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;device_base
)paren
id|iounmap
c_func
(paren
id|priv-&gt;device_base
)paren
suffix:semicolon
id|priv-&gt;device_base
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* free consistent DMA area... */
r_if
c_cond
(paren
id|priv-&gt;driver_mem_address
)paren
id|pci_free_consistent
c_func
(paren
id|priv-&gt;pdev
comma
id|HOST_MEM_BLOCK
comma
id|priv-&gt;driver_mem_address
comma
id|priv-&gt;device_host_address
)paren
suffix:semicolon
multiline_comment|/* clear some dangling pointers */
id|priv-&gt;driver_mem_address
op_assign
l_int|NULL
suffix:semicolon
id|priv-&gt;device_host_address
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;device_psm_buffer
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;control_block
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* clean up mgmt rx buffers */
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
id|ISL38XX_CB_MGMT_QSIZE
suffix:semicolon
id|counter
op_increment
)paren
(brace
r_struct
id|islpci_membuf
op_star
id|buf
op_assign
op_amp
id|priv-&gt;mgmt_rx
(braket
id|counter
)braket
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;pci_addr
)paren
id|pci_unmap_single
c_func
(paren
id|priv-&gt;pdev
comma
id|buf-&gt;pci_addr
comma
id|buf-&gt;size
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|buf-&gt;pci_addr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;mem
)paren
id|kfree
c_func
(paren
id|buf-&gt;mem
)paren
suffix:semicolon
id|buf-&gt;size
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;mem
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* clean up data rx buffers */
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
id|ISL38XX_CB_RX_QSIZE
suffix:semicolon
id|counter
op_increment
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;pci_map_rx_address
(braket
id|counter
)braket
)paren
id|pci_unmap_single
c_func
(paren
id|priv-&gt;pdev
comma
id|priv-&gt;pci_map_rx_address
(braket
id|counter
)braket
comma
id|MAX_FRAGMENT_SIZE_RX
op_plus
l_int|2
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|priv-&gt;pci_map_rx_address
(braket
id|counter
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;data_low_rx
(braket
id|counter
)braket
)paren
id|dev_kfree_skb
c_func
(paren
id|priv-&gt;data_low_rx
(braket
id|counter
)braket
)paren
suffix:semicolon
id|priv-&gt;data_low_rx
(braket
id|counter
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Free the acces control list and the WPA list */
id|prism54_acl_clean
c_func
(paren
op_amp
id|priv-&gt;acl
)paren
suffix:semicolon
id|prism54_wpa_ie_clean
c_func
(paren
id|priv
)paren
suffix:semicolon
id|mgt_clean
c_func
(paren
id|priv
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|islpci_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* put device into promisc mode and let network layer handle it */
)brace
macro_line|#endif
r_struct
id|net_device
op_star
DECL|function|islpci_setup
id|islpci_setup
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
id|islpci_private
op_star
id|priv
suffix:semicolon
r_struct
id|net_device
op_star
id|ndev
op_assign
id|alloc_etherdev
c_func
(paren
r_sizeof
(paren
id|islpci_private
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ndev
)paren
r_return
id|ndev
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|ndev
)paren
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
id|ndev
)paren
suffix:semicolon
macro_line|#if defined(SET_NETDEV_DEV)
id|SET_NETDEV_DEV
c_func
(paren
id|ndev
comma
op_amp
id|pdev-&gt;dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* setup the structure members */
id|ndev-&gt;base_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|ndev-&gt;irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
multiline_comment|/* initialize the function pointers */
id|ndev-&gt;open
op_assign
op_amp
id|islpci_open
suffix:semicolon
id|ndev-&gt;stop
op_assign
op_amp
id|islpci_close
suffix:semicolon
id|ndev-&gt;get_stats
op_assign
op_amp
id|islpci_statistics
suffix:semicolon
id|ndev-&gt;get_wireless_stats
op_assign
op_amp
id|prism54_get_wireless_stats
suffix:semicolon
id|ndev-&gt;do_ioctl
op_assign
op_amp
id|prism54_ioctl
suffix:semicolon
id|ndev-&gt;wireless_handlers
op_assign
(paren
r_struct
id|iw_handler_def
op_star
)paren
op_amp
id|prism54_handler_def
suffix:semicolon
id|ndev-&gt;hard_start_xmit
op_assign
op_amp
id|islpci_eth_transmit
suffix:semicolon
multiline_comment|/* ndev-&gt;set_multicast_list = &amp;islpci_set_multicast_list; */
id|ndev-&gt;addr_len
op_assign
id|ETH_ALEN
suffix:semicolon
id|ndev-&gt;set_mac_address
op_assign
op_amp
id|prism54_set_mac_address
suffix:semicolon
multiline_comment|/* Get a non-zero dummy MAC address for nameif. Jean II */
id|memcpy
c_func
(paren
id|ndev-&gt;dev_addr
comma
id|dummy_mac
comma
l_int|6
)paren
suffix:semicolon
macro_line|#ifdef HAVE_TX_TIMEOUT
id|ndev-&gt;watchdog_timeo
op_assign
id|ISLPCI_TX_TIMEOUT
suffix:semicolon
id|ndev-&gt;tx_timeout
op_assign
op_amp
id|islpci_eth_tx_timeout
suffix:semicolon
macro_line|#endif
multiline_comment|/* allocate a private device structure to the network device  */
id|priv
op_assign
id|netdev_priv
c_func
(paren
id|ndev
)paren
suffix:semicolon
id|priv-&gt;ndev
op_assign
id|ndev
suffix:semicolon
id|priv-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|priv-&gt;monitor_type
op_assign
id|ARPHRD_IEEE80211
suffix:semicolon
id|priv-&gt;ndev-&gt;type
op_assign
(paren
id|priv-&gt;iw_mode
op_eq
id|IW_MODE_MONITOR
)paren
ques
c_cond
id|priv-&gt;monitor_type
suffix:colon
id|ARPHRD_ETHER
suffix:semicolon
macro_line|#if WIRELESS_EXT &gt; 16
multiline_comment|/* Add pointers to enable iwspy support. */
id|priv-&gt;wireless_data.spy_data
op_assign
op_amp
id|priv-&gt;spy_data
suffix:semicolon
id|ndev-&gt;wireless_data
op_assign
op_amp
id|priv-&gt;wireless_data
suffix:semicolon
macro_line|#endif /* WIRELESS_EXT &gt; 16 */
multiline_comment|/* save the start and end address of the PCI memory area */
id|ndev-&gt;mem_start
op_assign
(paren
r_int
r_int
)paren
id|priv-&gt;device_base
suffix:semicolon
id|ndev-&gt;mem_end
op_assign
id|ndev-&gt;mem_start
op_plus
id|ISL38XX_PCI_MEM_SIZE
suffix:semicolon
macro_line|#if VERBOSE &gt; SHOW_ERROR_MESSAGES
id|DEBUG
c_func
(paren
id|SHOW_TRACING
comma
l_string|&quot;PCI Memory remapped to 0x%p&bslash;n&quot;
comma
id|priv-&gt;device_base
)paren
suffix:semicolon
macro_line|#endif
id|init_waitqueue_head
c_func
(paren
op_amp
id|priv-&gt;reset_done
)paren
suffix:semicolon
multiline_comment|/* init the queue read locks, process wait counter */
id|sema_init
c_func
(paren
op_amp
id|priv-&gt;mgmt_sem
comma
l_int|1
)paren
suffix:semicolon
id|priv-&gt;mgmt_received
op_assign
l_int|NULL
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|priv-&gt;mgmt_wqueue
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|priv-&gt;stats_sem
comma
l_int|1
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|priv-&gt;slock
)paren
suffix:semicolon
multiline_comment|/* init state machine with off#1 state */
id|priv-&gt;state
op_assign
id|PRV_STATE_OFF
suffix:semicolon
id|priv-&gt;state_off
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* initialize workqueue&squot;s */
id|INIT_WORK
c_func
(paren
op_amp
id|priv-&gt;stats_work
comma
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|prism54_update_stats
comma
id|priv
)paren
suffix:semicolon
id|priv-&gt;stats_timestamp
op_assign
l_int|0
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|priv-&gt;reset_task
comma
id|islpci_do_reset_and_wake
comma
id|priv
)paren
suffix:semicolon
id|priv-&gt;reset_task_pending
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* allocate various memory areas */
r_if
c_cond
(paren
id|islpci_alloc_memory
c_func
(paren
id|priv
)paren
)paren
r_goto
id|do_free_netdev
suffix:semicolon
multiline_comment|/* select the firmware file depending on the device id */
r_switch
c_cond
(paren
id|pdev-&gt;device
)paren
(brace
r_case
l_int|0x3877
suffix:colon
id|strcpy
c_func
(paren
id|priv-&gt;firmware
comma
id|ISL3877_IMAGE_FILE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3886
suffix:colon
id|strcpy
c_func
(paren
id|priv-&gt;firmware
comma
id|ISL3886_IMAGE_FILE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|strcpy
c_func
(paren
id|priv-&gt;firmware
comma
id|ISL3890_IMAGE_FILE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|ndev
)paren
)paren
(brace
id|DEBUG
c_func
(paren
id|SHOW_ERROR_MESSAGES
comma
l_string|&quot;ERROR: register_netdev() failed &bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|do_islpci_free_memory
suffix:semicolon
)brace
r_return
id|ndev
suffix:semicolon
id|do_islpci_free_memory
suffix:colon
id|islpci_free_memory
c_func
(paren
id|priv
)paren
suffix:semicolon
id|do_free_netdev
suffix:colon
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
l_int|NULL
)paren
suffix:semicolon
id|free_netdev
c_func
(paren
id|ndev
)paren
suffix:semicolon
id|priv
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|islpci_state_t
DECL|function|islpci_set_state
id|islpci_set_state
c_func
(paren
id|islpci_private
op_star
id|priv
comma
id|islpci_state_t
id|new_state
)paren
(brace
id|islpci_state_t
id|old_state
suffix:semicolon
multiline_comment|/* lock */
id|old_state
op_assign
id|priv-&gt;state
suffix:semicolon
multiline_comment|/* this means either a race condition or some serious error in&n;&t; * the driver code */
r_switch
c_cond
(paren
id|new_state
)paren
(brace
r_case
id|PRV_STATE_OFF
suffix:colon
id|priv-&gt;state_off
op_increment
suffix:semicolon
r_default
suffix:colon
id|priv-&gt;state
op_assign
id|new_state
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PRV_STATE_PREBOOT
suffix:colon
multiline_comment|/* there are actually many off-states, enumerated by&n;&t;&t; * state_off */
r_if
c_cond
(paren
id|old_state
op_eq
id|PRV_STATE_OFF
)paren
id|priv-&gt;state_off
op_decrement
suffix:semicolon
multiline_comment|/* only if hw_unavailable is zero now it means we either&n;&t;&t; * were in off#1 state, or came here from&n;&t;&t; * somewhere else */
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;state_off
)paren
id|priv-&gt;state
op_assign
id|new_state
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: state transition %d -&gt; %d (off#%d)&bslash;n&quot;
comma
id|priv-&gt;ndev-&gt;name
comma
id|old_state
comma
id|new_state
comma
id|priv-&gt;state_off
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* invariants */
id|BUG_ON
c_func
(paren
id|priv-&gt;state_off
OL
l_int|0
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|priv-&gt;state_off
op_logical_and
(paren
id|priv-&gt;state
op_ne
id|PRV_STATE_OFF
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|priv-&gt;state_off
op_logical_and
(paren
id|priv-&gt;state
op_eq
id|PRV_STATE_OFF
)paren
)paren
suffix:semicolon
multiline_comment|/* unlock */
r_return
id|old_state
suffix:semicolon
)brace
eof
