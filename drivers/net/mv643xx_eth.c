multiline_comment|/*&n; * drivers/net/mv64340_eth.c - Driver for MV64340X ethernet ports&n; * Copyright (C) 2002 Matthew Dharm &lt;mdharm@momenco.com&gt;&n; *&n; * Based on the 64360 driver from:&n; * Copyright (C) 2002 rabeeh@galileo.co.il&n; *&n; * Copyright (C) 2003 PMC-Sierra, Inc.,&n; *&t;written by Manish Lachwani (lachwani@pmc-sierra.com)&n; *&n; * Copyright (C) 2003 Ralf Baechle &lt;ralf@linux-mips.org&gt;&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version 2&n; * of the License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;mv643xx_eth.h&quot;
multiline_comment|/*&n; * The first part is the high level driver of the gigE ethernet ports. &n; */
multiline_comment|/* Definition for configuring driver */
DECL|macro|MV64340_RX_QUEUE_FILL_ON_TASK
macro_line|#undef MV64340_RX_QUEUE_FILL_ON_TASK
multiline_comment|/* Constants */
DECL|macro|EXTRA_BYTES
mdefine_line|#define EXTRA_BYTES 32
DECL|macro|WRAP
mdefine_line|#define WRAP       ETH_HLEN + 2 + 4 + 16
DECL|macro|BUFFER_MTU
mdefine_line|#define BUFFER_MTU dev-&gt;mtu + WRAP
DECL|macro|INT_CAUSE_UNMASK_ALL
mdefine_line|#define INT_CAUSE_UNMASK_ALL&t;&t;0x0007ffff
DECL|macro|INT_CAUSE_UNMASK_ALL_EXT
mdefine_line|#define INT_CAUSE_UNMASK_ALL_EXT&t;0x0011ffff
macro_line|#ifdef MV64340_RX_FILL_ON_TASK
DECL|macro|INT_CAUSE_MASK_ALL
mdefine_line|#define INT_CAUSE_MASK_ALL&t;&t;0x00000000
DECL|macro|INT_CAUSE_CHECK_BITS
mdefine_line|#define INT_CAUSE_CHECK_BITS&t;&t;INT_CAUSE_UNMASK_ALL
DECL|macro|INT_CAUSE_CHECK_BITS_EXT
mdefine_line|#define INT_CAUSE_CHECK_BITS_EXT&t;INT_CAUSE_UNMASK_ALL_EXT
macro_line|#endif
multiline_comment|/* Static function declarations */
r_static
r_int
id|mv64340_eth_real_open
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_int
id|mv64340_eth_real_stop
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_int
id|mv64340_eth_change_mtu
c_func
(paren
r_struct
id|net_device
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|mv64340_eth_get_stats
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|eth_port_init_mac_tables
c_func
(paren
r_int
r_int
id|eth_port_num
)paren
suffix:semicolon
macro_line|#ifdef MV64340_NAPI
r_static
r_int
id|mv64340_poll
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
op_star
id|budget
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|prom_mac_addr_base
r_int
r_char
id|prom_mac_addr_base
(braket
l_int|6
)braket
suffix:semicolon
DECL|variable|mv64340_sram_base
r_int
r_int
id|mv64340_sram_base
suffix:semicolon
multiline_comment|/*&n; * Changes MTU (maximum transfer unit) of the gigabit ethenret port&n; *&n; * Input : pointer to ethernet interface network device structure&n; *         new mtu size &n; * Output : 0 upon success, -EINVAL upon failure&n; */
DECL|function|mv64340_eth_change_mtu
r_static
r_int
id|mv64340_eth_change_mtu
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|new_mtu
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|mp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_mtu
OG
l_int|9500
)paren
op_logical_or
(paren
id|new_mtu
OL
l_int|64
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
multiline_comment|/* &n;&t; * Stop then re-open the interface. This will allocate RX skb&squot;s with&n;&t; * the new MTU.&n;&t; * There is a possible danger that the open will not successed, due&n;&t; * to memory is full, which might fail the open function.&n;&t; */
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|mv64340_eth_real_stop
c_func
(paren
id|dev
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Fatal error on stopping device&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mv64340_eth_real_open
c_func
(paren
id|dev
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Fatal error on opening device&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * mv64340_eth_rx_task&n; *&t;&t;&t;&t;&t;&t;&t;&t;       &n; * Fills / refills RX queue on a certain gigabit ethernet port&n; *&n; * Input : pointer to ethernet interface network device structure&n; * Output : N/A&n; */
DECL|function|mv64340_eth_rx_task
r_static
r_void
id|mv64340_eth_rx_task
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|pkt_info
id|pkt_info
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|mp-&gt;rx_task_busy
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;%s: Error in test_set_bit / clear_bit&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mp-&gt;rx_ring_skbs
OL
(paren
id|mp-&gt;rx_ring_size
op_minus
l_int|5
)paren
)paren
(brace
multiline_comment|/* The +8 for buffer allignment and another 32 byte extra */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|BUFFER_MTU
op_plus
l_int|8
op_plus
id|EXTRA_BYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
multiline_comment|/* Better luck next time */
r_break
suffix:semicolon
id|mp-&gt;rx_ring_skbs
op_increment
suffix:semicolon
id|pkt_info.cmd_sts
op_assign
id|ETH_RX_ENABLE_INTERRUPT
suffix:semicolon
id|pkt_info.byte_cnt
op_assign
id|dev-&gt;mtu
op_plus
id|ETH_HLEN
op_plus
l_int|4
op_plus
l_int|2
op_plus
id|EXTRA_BYTES
suffix:semicolon
multiline_comment|/* Allign buffer to 8 bytes */
r_if
c_cond
(paren
id|pkt_info.byte_cnt
op_amp
op_complement
l_int|0x7
)paren
(brace
id|pkt_info.byte_cnt
op_and_assign
op_complement
l_int|0x7
suffix:semicolon
id|pkt_info.byte_cnt
op_add_assign
l_int|8
suffix:semicolon
)brace
id|pkt_info.buf_ptr
op_assign
id|pci_map_single
c_func
(paren
l_int|0
comma
id|skb-&gt;data
comma
id|dev-&gt;mtu
op_plus
id|ETH_HLEN
op_plus
l_int|4
op_plus
l_int|2
op_plus
id|EXTRA_BYTES
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|pkt_info.return_info
op_assign
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|eth_rx_return_buff
c_func
(paren
id|mp
comma
op_amp
id|pkt_info
)paren
op_ne
id|ETH_OK
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Error allocating RX Ring&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|mp-&gt;rx_task_busy
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If RX ring is empty of SKB, set a timer to try allocating&n;&t; * again in a later time .&n;&t; */
r_if
c_cond
(paren
(paren
id|mp-&gt;rx_ring_skbs
op_eq
l_int|0
)paren
op_logical_and
(paren
id|mp-&gt;rx_timer_flag
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Rx ring is empty&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* After 100mSec */
id|mp-&gt;timeout.expires
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|mp-&gt;timeout
)paren
suffix:semicolon
id|mp-&gt;rx_timer_flag
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#if MV64340_RX_QUEUE_FILL_ON_TASK
r_else
(brace
multiline_comment|/* Return interrupts */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_MASK_REG
c_func
(paren
id|mp-&gt;port_num
)paren
comma
id|INT_CAUSE_UNMASK_ALL
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * mv64340_eth_rx_task_timer_wrapper&n; *&t;&t;&t;&t;&t;&t;&t;&t;       &n; * Timer routine to wake up RX queue filling task. This function is&n; * used only in case the RX queue is empty, and all alloc_skb has&n; * failed (due to out of memory event).&n; *&n; * Input : pointer to ethernet interface network device structure&n; * Output : N/A&n; */
DECL|function|mv64340_eth_rx_task_timer_wrapper
r_static
r_void
id|mv64340_eth_rx_task_timer_wrapper
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mp-&gt;rx_timer_flag
op_assign
l_int|0
suffix:semicolon
id|mv64340_eth_rx_task
c_func
(paren
(paren
r_void
op_star
)paren
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * mv64340_eth_update_mac_address&n; *&t;&t;&t;&t;&t;&t;&t;&t;       &n; * Update the MAC address of the port in the address table&n; *&n; * Input : pointer to ethernet interface network device structure&n; * Output : N/A&n; */
DECL|function|mv64340_eth_update_mac_address
r_static
r_void
id|mv64340_eth_update_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|port_num
op_assign
id|mp-&gt;port_num
suffix:semicolon
id|eth_port_init_mac_tables
c_func
(paren
id|port_num
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mp-&gt;port_mac_addr
comma
id|dev-&gt;dev_addr
comma
l_int|6
)paren
suffix:semicolon
id|eth_port_uc_addr_set
c_func
(paren
id|port_num
comma
id|mp-&gt;port_mac_addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * mv64340_eth_set_rx_mode&n; *&t;&t;&t;&t;&t;&t;&t;&t;       &n; * Change from promiscuos to regular rx mode&n; *&n; * Input : pointer to ethernet interface network device structure&n; * Output : N/A&n; */
DECL|function|mv64340_eth_set_rx_mode
r_static
r_void
id|mv64340_eth_set_rx_mode
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|ethernet_set_config_reg
(paren
id|mp-&gt;port_num
comma
id|ethernet_get_config_reg
c_func
(paren
id|mp-&gt;port_num
)paren
op_or
id|ETH_UNICAST_PROMISCUOUS_MODE
)paren
suffix:semicolon
)brace
r_else
(brace
id|ethernet_set_config_reg
(paren
id|mp-&gt;port_num
comma
id|ethernet_get_config_reg
c_func
(paren
id|mp-&gt;port_num
)paren
op_amp
op_complement
(paren
r_int
r_int
)paren
id|ETH_UNICAST_PROMISCUOUS_MODE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * mv64340_eth_set_mac_address&n; *&t;&t;&t;&t;&t;&t;&t;&t;       &n; * Change the interface&squot;s mac address.&n; * No special hardware thing should be done because interface is always&n; * put in promiscuous mode.&n; *&n; * Input : pointer to ethernet interface network device structure and&n; *         a pointer to the designated entry to be added to the cache.&n; * Output : zero upon success, negative upon failure&n; */
DECL|function|mv64340_eth_set_mac_address
r_static
r_int
id|mv64340_eth_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* +2 is for the offset of the HW addr type */
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|addr
)paren
(braket
id|i
op_plus
l_int|2
)braket
suffix:semicolon
id|mv64340_eth_update_mac_address
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * mv64340_eth_tx_timeout&n; *&t;&t;&t;&t;&t;&t;&t;&t;       &n; * Called upon a timeout on transmitting a packet&n; *&n; * Input : pointer to ethernet interface network device structure.&n; * Output : N/A&n; */
DECL|function|mv64340_eth_tx_timeout
r_static
r_void
id|mv64340_eth_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: TX timeout  &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Do the reset outside of interrupt context */
id|schedule_work
c_func
(paren
op_amp
id|mp-&gt;tx_timeout_task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * mv64340_eth_tx_timeout_task&n; *&n; * Actual routine to reset the adapter when a timeout on Tx has occurred&n; */
DECL|function|mv64340_eth_tx_timeout_task
r_static
r_void
id|mv64340_eth_tx_timeout_task
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_device_detach
c_func
(paren
id|dev
)paren
suffix:semicolon
id|eth_port_reset
c_func
(paren
id|mp-&gt;port_num
)paren
suffix:semicolon
id|eth_port_start
c_func
(paren
id|mp
)paren
suffix:semicolon
id|netif_device_attach
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * mv64340_eth_free_tx_queue&n; *&n; * Input : dev - a pointer to the required interface&n; *&n; * Output : 0 if was able to release skb , nonzero otherwise&n; */
DECL|function|mv64340_eth_free_tx_queue
r_static
r_int
id|mv64340_eth_free_tx_queue
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|eth_int_cause_ext
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|stats
op_assign
op_amp
id|mp-&gt;stats
suffix:semicolon
r_struct
id|pkt_info
id|pkt_info
suffix:semicolon
r_int
id|released
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|eth_int_cause_ext
op_amp
(paren
id|BIT0
op_or
id|BIT8
)paren
)paren
)paren
r_return
id|released
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Check only queue 0 */
r_while
c_loop
(paren
id|eth_tx_return_desc
c_func
(paren
id|mp
comma
op_amp
id|pkt_info
)paren
op_eq
id|ETH_OK
)paren
(brace
r_if
c_cond
(paren
id|pkt_info.cmd_sts
op_amp
id|BIT0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Error in TX&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|stats-&gt;tx_errors
op_increment
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * If return_info is different than 0, release the skb.&n;&t;&t; * The case where return_info is not 0 is only in case&n;&t;&t; * when transmitted a scatter/gather packet, where only&n;&t;&t; * last skb releases the whole chain.&n;&t;&t; */
r_if
c_cond
(paren
id|pkt_info.return_info
)paren
(brace
id|dev_kfree_skb_irq
c_func
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|pkt_info.return_info
)paren
suffix:semicolon
id|released
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|pkt_info.return_info
)paren
op_member_access_from_pointer
id|nr_frags
)paren
id|pci_unmap_page
c_func
(paren
l_int|NULL
comma
id|pkt_info.buf_ptr
comma
id|pkt_info.byte_cnt
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;tx_ring_skbs
op_ne
l_int|1
)paren
id|mp-&gt;tx_ring_skbs
op_decrement
suffix:semicolon
)brace
r_else
id|pci_unmap_page
c_func
(paren
l_int|NULL
comma
id|pkt_info.buf_ptr
comma
id|pkt_info.byte_cnt
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Decrement the number of outstanding skbs counter on&n;&t;&t; * the TX queue.&n;&t;&t; */
r_if
c_cond
(paren
id|mp-&gt;tx_ring_skbs
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;ERROR - TX outstanding SKBs counter is corrupted&quot;
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mp-&gt;lock
)paren
suffix:semicolon
r_return
id|released
suffix:semicolon
)brace
multiline_comment|/*&n; * mv64340_eth_receive&n; *&n; * This function is forward packets that are received from the port&squot;s&n; * queues toward kernel core or FastRoute them to another interface.&n; *&n; * Input : dev - a pointer to the required interface&n; *         max - maximum number to receive (0 means unlimted)&n; *&n; * Output : number of served packets&n; */
macro_line|#ifdef MV64340_NAPI
DECL|function|mv64340_eth_receive_queue
r_static
r_int
id|mv64340_eth_receive_queue
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|max
comma
r_int
id|budget
)paren
macro_line|#else
r_static
r_int
id|mv64340_eth_receive_queue
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|max
)paren
macro_line|#endif
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|stats
op_assign
op_amp
id|mp-&gt;stats
suffix:semicolon
r_int
r_int
id|received_packets
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|pkt_info
id|pkt_info
suffix:semicolon
macro_line|#ifdef MV64340_NAPI
r_while
c_loop
(paren
id|eth_port_receive
c_func
(paren
id|mp
comma
op_amp
id|pkt_info
)paren
op_eq
id|ETH_OK
op_logical_and
id|budget
OG
l_int|0
)paren
(brace
macro_line|#else
r_while
c_loop
(paren
(paren
op_decrement
id|max
)paren
op_logical_and
id|eth_port_receive
c_func
(paren
id|mp
comma
op_amp
id|pkt_info
)paren
op_eq
id|ETH_OK
)paren
(brace
macro_line|#endif
id|mp-&gt;rx_ring_skbs
op_decrement
suffix:semicolon
id|received_packets
op_increment
suffix:semicolon
macro_line|#ifdef MV64340_NAPI
id|budget
op_decrement
suffix:semicolon
macro_line|#endif
multiline_comment|/* Update statistics. Note byte count includes 4 byte CRC count */
id|stats-&gt;rx_packets
op_increment
suffix:semicolon
id|stats-&gt;rx_bytes
op_add_assign
id|pkt_info.byte_cnt
suffix:semicolon
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|pkt_info.return_info
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In case received a packet without first / last bits on OR&n;&t;&t; * the error summary bit is on, the packets needs to be dropeed.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|pkt_info.cmd_sts
op_amp
(paren
id|ETH_RX_FIRST_DESC
op_or
id|ETH_RX_LAST_DESC
)paren
)paren
op_ne
(paren
id|ETH_RX_FIRST_DESC
op_or
id|ETH_RX_LAST_DESC
)paren
)paren
op_logical_or
(paren
id|pkt_info.cmd_sts
op_amp
id|ETH_ERROR_SUMMARY
)paren
)paren
(brace
id|stats-&gt;rx_dropped
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pkt_info.cmd_sts
op_amp
(paren
id|ETH_RX_FIRST_DESC
op_or
id|ETH_RX_LAST_DESC
)paren
)paren
op_ne
(paren
id|ETH_RX_FIRST_DESC
op_or
id|ETH_RX_LAST_DESC
)paren
)paren
(brace
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Received packet spread on multiple&quot;
l_string|&quot; descriptors&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pkt_info.cmd_sts
op_amp
id|ETH_ERROR_SUMMARY
)paren
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * The -4 is for the CRC in the trailer of the&n;&t;&t;&t; * received packet&n;&t;&t;&t; */
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_info.byte_cnt
op_minus
l_int|4
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|pkt_info.cmd_sts
op_amp
id|ETH_LAYER_4_CHECKSUM_OK
)paren
(brace
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
id|skb-&gt;csum
op_assign
id|htons
c_func
(paren
(paren
id|pkt_info.cmd_sts
op_amp
l_int|0x0007fff8
)paren
op_rshift
l_int|3
)paren
suffix:semicolon
)brace
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
macro_line|#ifdef MV64340_NAPI
id|netif_receive_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#else
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_return
id|received_packets
suffix:semicolon
)brace
multiline_comment|/*&n; * mv64340_eth_int_handler&n; *&n; * Main interrupt handler for the gigbit ethernet ports&n; *&n; * Input : irq - irq number (not used)&n; *         dev_id - a pointer to the required interface&squot;s data structure&n; *         regs   - not used&n; * Output : N/A&n; */
DECL|function|mv64340_eth_int_handler
r_static
id|irqreturn_t
id|mv64340_eth_int_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|u32
id|eth_int_cause
comma
id|eth_int_cause_ext
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|port_num
op_assign
id|mp-&gt;port_num
suffix:semicolon
multiline_comment|/* Read interrupt cause registers */
id|eth_int_cause
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_INTERRUPT_CAUSE_REG
c_func
(paren
id|port_num
)paren
)paren
op_amp
id|INT_CAUSE_UNMASK_ALL
suffix:semicolon
r_if
c_cond
(paren
id|eth_int_cause
op_amp
id|BIT1
)paren
id|eth_int_cause_ext
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_INTERRUPT_CAUSE_EXTEND_REG
c_func
(paren
id|port_num
)paren
)paren
op_amp
id|INT_CAUSE_UNMASK_ALL_EXT
suffix:semicolon
macro_line|#ifdef MV64340_NAPI
r_if
c_cond
(paren
op_logical_neg
(paren
id|eth_int_cause
op_amp
l_int|0x0007fffd
)paren
)paren
(brace
multiline_comment|/* Dont ack the Rx interrupt */
macro_line|#endif
multiline_comment|/*&n;&t; &t; * Clear specific ethernet port intrerrupt registers by&n;&t;&t; * acknowleding relevant bits.&n;&t;&t; */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_CAUSE_REG
c_func
(paren
id|port_num
)paren
comma
op_complement
id|eth_int_cause
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eth_int_cause_ext
op_ne
l_int|0x0
)paren
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_CAUSE_EXTEND_REG
c_func
(paren
id|port_num
)paren
comma
op_complement
id|eth_int_cause_ext
)paren
suffix:semicolon
multiline_comment|/* UDP change : We may need this */
r_if
c_cond
(paren
(paren
id|eth_int_cause_ext
op_amp
l_int|0x0000ffff
)paren
op_logical_and
(paren
id|mv64340_eth_free_tx_queue
c_func
(paren
id|dev
comma
id|eth_int_cause_ext
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|MV64340_TX_QUEUE_SIZE
OG
id|mp-&gt;tx_ring_skbs
op_plus
l_int|1
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef MV64340_NAPI
)brace
r_else
(brace
r_if
c_cond
(paren
id|netif_rx_schedule_prep
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* Mask all the interrupts */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_MASK_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_EXTEND_MASK_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0
)paren
suffix:semicolon
id|__netif_rx_schedule
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#else
(brace
r_if
c_cond
(paren
id|eth_int_cause
op_amp
(paren
id|BIT2
op_or
id|BIT11
)paren
)paren
id|mv64340_eth_receive_queue
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * After forwarded received packets to upper layer,  add a task&n;&t;&t; * in an interrupts enabled context that refills the RX ring&n;&t;&t; * with skb&squot;s.&n;&t;&t; */
macro_line|#if MV64340_RX_QUEUE_FILL_ON_TASK
multiline_comment|/* Unmask all interrupts on ethernet port */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_MASK_REG
c_func
(paren
id|port_num
)paren
comma
id|INT_CAUSE_MASK_ALL
)paren
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|mp-&gt;rx_task
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
macro_line|#else
id|mp-&gt;rx_task
dot
id|func
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
multiline_comment|/* PHY status changed */
r_if
c_cond
(paren
id|eth_int_cause_ext
op_amp
(paren
id|BIT16
op_or
id|BIT20
)paren
)paren
(brace
r_int
r_int
id|phy_reg_data
suffix:semicolon
multiline_comment|/* Check Link status on ethernet port */
id|eth_port_read_smi_reg
c_func
(paren
id|port_num
comma
l_int|1
comma
op_amp
id|phy_reg_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|phy_reg_data
op_amp
l_int|0x20
)paren
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Start all TX queues on ethernet port. This is good in&n;&t;&t;&t; * case of previous packets where not transmitted, due&n;&t;&t;&t; * to link down and this command re-enables all TX&n;&t;&t;&t; * queues.&n;&t;&t;&t; * Note that it is possible to get a TX resource error&n;&t;&t;&t; * interrupt after issuing this, since not all TX queues&n;&t;&t;&t; * are enabled, or has anything to send.&n;&t;&t;&t; */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG
c_func
(paren
id|port_num
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If no real interrupt occured, exit.&n;&t; * This can happen when using gigE interrupt coalescing mechanism.&n;&t; */
r_if
c_cond
(paren
(paren
id|eth_int_cause
op_eq
l_int|0x0
)paren
op_logical_and
(paren
id|eth_int_cause_ext
op_eq
l_int|0x0
)paren
)paren
r_return
id|IRQ_NONE
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
macro_line|#ifdef MV64340_COAL
multiline_comment|/*&n; * eth_port_set_rx_coal - Sets coalescing interrupt mechanism on RX path&n; *&n; * DESCRIPTION:&n; *&t;This routine sets the RX coalescing interrupt mechanism parameter.&n; *&t;This parameter is a timeout counter, that counts in 64 t_clk&n; *&t;chunks ; that when timeout event occurs a maskable interrupt&n; *&t;occurs.&n; *&t;The parameter is calculated using the tClk of the MV-643xx chip&n; *&t;, and the required delay of the interrupt in usec.&n; *&n; * INPUT:&n; *&t;unsigned int eth_port_num      Ethernet port number&n; *&t;unsigned int t_clk        t_clk of the MV-643xx chip in HZ units&n; *&t;unsigned int delay       Delay in usec&n; *&n; * OUTPUT:&n; *&t;Interrupt coalescing mechanism value is set in MV-643xx chip.&n; *&n; * RETURN:&n; *&t;The interrupt coalescing value set in the gigE port.&n; *&n; */
DECL|function|eth_port_set_rx_coal
r_static
r_int
r_int
id|eth_port_set_rx_coal
c_func
(paren
r_int
r_int
id|eth_port_num
comma
r_int
r_int
id|t_clk
comma
r_int
r_int
id|delay
)paren
(brace
r_int
r_int
id|coal
op_assign
(paren
(paren
id|t_clk
op_div
l_int|1000000
)paren
op_star
id|delay
)paren
op_div
l_int|64
suffix:semicolon
multiline_comment|/* Set RX Coalescing mechanism */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_SDMA_CONFIG_REG
c_func
(paren
id|eth_port_num
)paren
comma
(paren
(paren
id|coal
op_amp
l_int|0x3fff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|MV_READ
c_func
(paren
id|MV64340_ETH_SDMA_CONFIG_REG
c_func
(paren
id|eth_port_num
)paren
)paren
op_amp
l_int|0xffc000ff
)paren
)paren
suffix:semicolon
r_return
id|coal
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * eth_port_set_tx_coal - Sets coalescing interrupt mechanism on TX path&n; *&n; * DESCRIPTION:&n; *&t;This routine sets the TX coalescing interrupt mechanism parameter.&n; *&t;This parameter is a timeout counter, that counts in 64 t_clk&n; *&t;chunks ; that when timeout event occurs a maskable interrupt&n; *&t;occurs.&n; *&t;The parameter is calculated using the t_cLK frequency of the &n; *&t;MV-643xx chip and the required delay in the interrupt in uSec&n; *&n; * INPUT:&n; *&t;unsigned int eth_port_num      Ethernet port number&n; *&t;unsigned int t_clk        t_clk of the MV-643xx chip in HZ units&n; *&t;unsigned int delay       Delay in uSeconds&n; *&n; * OUTPUT:&n; *&t;Interrupt coalescing mechanism value is set in MV-643xx chip.&n; *&n; * RETURN:&n; *&t;The interrupt coalescing value set in the gigE port.&n; *&n; */
DECL|function|eth_port_set_tx_coal
r_static
r_int
r_int
id|eth_port_set_tx_coal
c_func
(paren
r_int
r_int
id|eth_port_num
comma
r_int
r_int
id|t_clk
comma
r_int
r_int
id|delay
)paren
(brace
r_int
r_int
id|coal
suffix:semicolon
id|coal
op_assign
(paren
(paren
id|t_clk
op_div
l_int|1000000
)paren
op_star
id|delay
)paren
op_div
l_int|64
suffix:semicolon
multiline_comment|/* Set TX Coalescing mechanism */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_TX_FIFO_URGENT_THRESHOLD_REG
c_func
(paren
id|eth_port_num
)paren
comma
id|coal
op_lshift
l_int|4
)paren
suffix:semicolon
r_return
id|coal
suffix:semicolon
)brace
multiline_comment|/*&n; * mv64340_eth_open&n; *&n; * This function is called when openning the network device. The function&n; * should initialize all the hardware, initialize cyclic Rx/Tx&n; * descriptors chain and buffers and allocate an IRQ to the network&n; * device.&n; *&n; * Input : a pointer to the network device structure&n; *&n; * Output : zero of success , nonzero if fails.&n; */
DECL|function|mv64340_eth_open
r_static
r_int
id|mv64340_eth_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|port_num
op_assign
id|mp-&gt;port_num
suffix:semicolon
r_int
id|err
op_assign
id|err
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|mp-&gt;lock
)paren
suffix:semicolon
id|err
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|mv64340_eth_int_handler
comma
id|SA_INTERRUPT
op_or
id|SA_SAMPLE_RANDOM
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Can not assign IRQ number to MV64340_eth%d&bslash;n&quot;
comma
id|port_num
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mv64340_eth_real_open
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Error opening interface&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|mp-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_free
suffix:colon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|mp-&gt;lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * ether_init_rx_desc_ring - Curve a Rx chain desc list and buffer in memory.&n; *&n; * DESCRIPTION:&n; *       This function prepares a Rx chained list of descriptors and packet &n; *       buffers in a form of a ring. The routine must be called after port &n; *       initialization routine and before port start routine. &n; *       The Ethernet SDMA engine uses CPU bus addresses to access the various &n; *       devices in the system (i.e. DRAM). This function uses the ethernet &n; *       struct &squot;virtual to physical&squot; routine (set by the user) to set the ring &n; *       with physical addresses.&n; *&n; * INPUT:&n; *&t;struct mv64340_private   *mp   Ethernet Port Control srtuct. &n; *      int &t;&t;&t;rx_desc_num       Number of Rx descriptors&n; *      int &t;&t;&t;rx_buff_size      Size of Rx buffer&n; *      unsigned int    rx_desc_base_addr  Rx descriptors memory area base addr.&n; *      unsigned int    rx_buff_base_addr  Rx buffer memory area base addr.&n; *&n; * OUTPUT:&n; *      The routine updates the Ethernet port control struct with information &n; *      regarding the Rx descriptors and buffers.&n; *&n; * RETURN:&n; *      false if the given descriptors memory area is not aligned according to&n; *      Ethernet SDMA specifications.&n; *      true otherwise.&n; */
DECL|function|ether_init_rx_desc_ring
r_static
r_int
id|ether_init_rx_desc_ring
c_func
(paren
r_struct
id|mv64340_private
op_star
id|mp
comma
r_int
r_int
id|rx_buff_base_addr
)paren
(brace
r_int
r_int
id|buffer_addr
op_assign
id|rx_buff_base_addr
suffix:semicolon
r_volatile
r_struct
id|eth_rx_desc
op_star
id|p_rx_desc
suffix:semicolon
r_int
id|rx_desc_num
op_assign
id|mp-&gt;rx_ring_size
suffix:semicolon
r_int
r_int
id|rx_desc_base_addr
op_assign
(paren
r_int
r_int
)paren
id|mp-&gt;p_rx_desc_area
suffix:semicolon
r_int
id|rx_buff_size
op_assign
l_int|1536
suffix:semicolon
multiline_comment|/* Dummy, will be replaced later */
r_int
id|i
suffix:semicolon
id|p_rx_desc
op_assign
(paren
r_struct
id|eth_rx_desc
op_star
)paren
id|rx_desc_base_addr
suffix:semicolon
multiline_comment|/* Rx desc Must be 4LW aligned (i.e. Descriptor_Address[3:0]=0000). */
r_if
c_cond
(paren
id|rx_buff_base_addr
op_amp
l_int|0xf
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Rx buffers are limited to 64K bytes and Minimum size is 8 bytes  */
r_if
c_cond
(paren
(paren
id|rx_buff_size
OL
l_int|8
)paren
op_logical_or
(paren
id|rx_buff_size
OG
id|RX_BUFFER_MAX_SIZE
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Rx buffers must be 64-bit aligned.       */
r_if
c_cond
(paren
(paren
id|rx_buff_base_addr
op_plus
id|rx_buff_size
)paren
op_amp
l_int|0x7
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* initialize the Rx descriptors ring */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rx_desc_num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p_rx_desc
(braket
id|i
)braket
dot
id|buf_size
op_assign
id|rx_buff_size
suffix:semicolon
id|p_rx_desc
(braket
id|i
)braket
dot
id|byte_cnt
op_assign
l_int|0x0000
suffix:semicolon
id|p_rx_desc
(braket
id|i
)braket
dot
id|cmd_sts
op_assign
id|ETH_BUFFER_OWNED_BY_DMA
op_or
id|ETH_RX_ENABLE_INTERRUPT
suffix:semicolon
id|p_rx_desc
(braket
id|i
)braket
dot
id|next_desc_ptr
op_assign
id|mp-&gt;rx_desc_dma
op_plus
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|rx_desc_num
)paren
op_star
r_sizeof
(paren
r_struct
id|eth_rx_desc
)paren
suffix:semicolon
id|p_rx_desc
(braket
id|i
)braket
dot
id|buf_ptr
op_assign
id|buffer_addr
suffix:semicolon
id|mp-&gt;rx_skb
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|buffer_addr
op_add_assign
id|rx_buff_size
suffix:semicolon
)brace
multiline_comment|/* Save Rx desc pointer to driver struct. */
id|mp-&gt;rx_curr_desc_q
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;rx_used_desc_q
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;rx_desc_area_size
op_assign
id|rx_desc_num
op_star
r_sizeof
(paren
r_struct
id|eth_rx_desc
)paren
suffix:semicolon
id|mp-&gt;port_rx_queue_command
op_or_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * ether_init_tx_desc_ring - Curve a Tx chain desc list and buffer in memory.&n; *&n; * DESCRIPTION:&n; *       This function prepares a Tx chained list of descriptors and packet &n; *       buffers in a form of a ring. The routine must be called after port &n; *       initialization routine and before port start routine. &n; *       The Ethernet SDMA engine uses CPU bus addresses to access the various &n; *       devices in the system (i.e. DRAM). This function uses the ethernet &n; *       struct &squot;virtual to physical&squot; routine (set by the user) to set the ring &n; *       with physical addresses.&n; *&n; * INPUT:&n; *&t;struct mv64340_private   *mp   Ethernet Port Control srtuct. &n; *      int &t;&t;tx_desc_num        Number of Tx descriptors&n; *      int &t;&t;tx_buff_size&t;   Size of Tx buffer&n; *      unsigned int    tx_desc_base_addr  Tx descriptors memory area base addr.&n; *&n; * OUTPUT:&n; *      The routine updates the Ethernet port control struct with information &n; *      regarding the Tx descriptors and buffers.&n; *&n; * RETURN:&n; *      false if the given descriptors memory area is not aligned according to&n; *      Ethernet SDMA specifications.&n; *      true otherwise.&n; */
DECL|function|ether_init_tx_desc_ring
r_static
r_int
id|ether_init_tx_desc_ring
c_func
(paren
r_struct
id|mv64340_private
op_star
id|mp
)paren
(brace
r_int
r_int
id|tx_desc_base_addr
op_assign
(paren
r_int
r_int
)paren
id|mp-&gt;p_tx_desc_area
suffix:semicolon
r_int
id|tx_desc_num
op_assign
id|mp-&gt;tx_ring_size
suffix:semicolon
r_struct
id|eth_tx_desc
op_star
id|p_tx_desc
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Tx desc Must be 4LW aligned (i.e. Descriptor_Address[3:0]=0000). */
r_if
c_cond
(paren
id|tx_desc_base_addr
op_amp
l_int|0xf
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* save the first desc pointer to link with the last descriptor */
id|p_tx_desc
op_assign
(paren
r_struct
id|eth_tx_desc
op_star
)paren
id|tx_desc_base_addr
suffix:semicolon
multiline_comment|/* Initialize the Tx descriptors ring */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|tx_desc_num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p_tx_desc
(braket
id|i
)braket
dot
id|byte_cnt
op_assign
l_int|0x0000
suffix:semicolon
id|p_tx_desc
(braket
id|i
)braket
dot
id|l4i_chk
op_assign
l_int|0x0000
suffix:semicolon
id|p_tx_desc
(braket
id|i
)braket
dot
id|cmd_sts
op_assign
l_int|0x00000000
suffix:semicolon
id|p_tx_desc
(braket
id|i
)braket
dot
id|next_desc_ptr
op_assign
id|mp-&gt;tx_desc_dma
op_plus
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|tx_desc_num
)paren
op_star
r_sizeof
(paren
r_struct
id|eth_tx_desc
)paren
suffix:semicolon
id|p_tx_desc
(braket
id|i
)braket
dot
id|buf_ptr
op_assign
l_int|0x00000000
suffix:semicolon
id|mp-&gt;tx_skb
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Set Tx desc pointer in driver struct. */
id|mp-&gt;tx_curr_desc_q
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;tx_used_desc_q
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef MV64340_CHECKSUM_OFFLOAD_TX
id|mp-&gt;tx_first_desc_q
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Init Tx ring base and size parameters */
id|mp-&gt;tx_desc_area_size
op_assign
id|tx_desc_num
op_star
r_sizeof
(paren
r_struct
id|eth_tx_desc
)paren
suffix:semicolon
multiline_comment|/* Add the queue to the list of Tx queues of this port */
id|mp-&gt;port_tx_queue_command
op_or_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Helper function for mv64340_eth_open */
DECL|function|mv64340_eth_real_open
r_static
r_int
id|mv64340_eth_real_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|port_num
op_assign
id|mp-&gt;port_num
suffix:semicolon
id|u32
id|phy_reg_data
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* Stop RX Queues */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0x0000ff00
)paren
suffix:semicolon
multiline_comment|/* Clear the ethernet port interrupts */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_CAUSE_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_CAUSE_EXTEND_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Unmask RX buffer and TX end interrupt */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_MASK_REG
c_func
(paren
id|port_num
)paren
comma
id|INT_CAUSE_UNMASK_ALL
)paren
suffix:semicolon
multiline_comment|/* Unmask phy and link status changes interrupts */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_EXTEND_MASK_REG
c_func
(paren
id|port_num
)paren
comma
id|INT_CAUSE_UNMASK_ALL_EXT
)paren
suffix:semicolon
multiline_comment|/* Set the MAC Address */
id|memcpy
c_func
(paren
id|mp-&gt;port_mac_addr
comma
id|dev-&gt;dev_addr
comma
l_int|6
)paren
suffix:semicolon
id|eth_port_init
c_func
(paren
id|mp
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|mp-&gt;rx_task
comma
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|mv64340_eth_rx_task
comma
id|dev
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|mp-&gt;timeout
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|timer_list
)paren
)paren
suffix:semicolon
id|mp-&gt;timeout.function
op_assign
id|mv64340_eth_rx_task_timer_wrapper
suffix:semicolon
id|mp-&gt;timeout.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|mp-&gt;rx_task_busy
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;rx_timer_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Allocate TX ring */
id|mp-&gt;tx_ring_skbs
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;tx_ring_size
op_assign
id|MV64340_TX_QUEUE_SIZE
suffix:semicolon
id|size
op_assign
id|mp-&gt;tx_ring_size
op_star
r_sizeof
(paren
r_struct
id|eth_tx_desc
)paren
suffix:semicolon
id|mp-&gt;tx_desc_area_size
op_assign
id|size
suffix:semicolon
multiline_comment|/* Assumes allocated ring is 16 bytes alligned */
id|mp-&gt;p_tx_desc_area
op_assign
id|pci_alloc_consistent
c_func
(paren
l_int|NULL
comma
id|size
comma
op_amp
id|mp-&gt;tx_desc_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp-&gt;p_tx_desc_area
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Cannot allocate Tx Ring (size %d bytes)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|mp-&gt;p_tx_desc_area
comma
l_int|0
comma
id|mp-&gt;tx_desc_area_size
)paren
suffix:semicolon
multiline_comment|/* Dummy will be replaced upon real tx */
id|ether_init_tx_desc_ring
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* Allocate RX ring */
multiline_comment|/* Meantime RX Ring are fixed - but must be configurable by user */
id|mp-&gt;rx_ring_size
op_assign
id|MV64340_RX_QUEUE_SIZE
suffix:semicolon
id|mp-&gt;rx_ring_skbs
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
id|mp-&gt;rx_ring_size
op_star
r_sizeof
(paren
r_struct
id|eth_rx_desc
)paren
suffix:semicolon
id|mp-&gt;rx_desc_area_size
op_assign
id|size
suffix:semicolon
multiline_comment|/* Assumes allocated ring is 16 bytes aligned */
id|mp-&gt;p_rx_desc_area
op_assign
id|pci_alloc_consistent
c_func
(paren
l_int|NULL
comma
id|size
comma
op_amp
id|mp-&gt;rx_desc_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp-&gt;p_rx_desc_area
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Cannot allocate Rx ring (size %d bytes)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|size
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Freeing previously allocated TX queues...&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
l_int|0
comma
id|mp-&gt;tx_desc_area_size
comma
(paren
r_void
op_star
)paren
id|mp-&gt;p_tx_desc_area
comma
id|mp-&gt;tx_desc_dma
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mp-&gt;p_rx_desc_area
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ether_init_rx_desc_ring
c_func
(paren
id|mp
comma
l_int|0
)paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;%s: Error initializing RX Ring&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|mv64340_eth_rx_task
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Fill RX ring with skb&squot;s */
id|eth_port_start
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* Interrupt Coalescing */
macro_line|#ifdef MV64340_COAL
id|mp-&gt;rx_int_coal
op_assign
id|eth_port_set_rx_coal
c_func
(paren
id|port_num
comma
l_int|133000000
comma
id|MV64340_RX_COAL
)paren
suffix:semicolon
macro_line|#endif
id|mp-&gt;tx_int_coal
op_assign
id|eth_port_set_tx_coal
(paren
id|port_num
comma
l_int|133000000
comma
id|MV64340_TX_COAL
)paren
suffix:semicolon
multiline_comment|/* Increase the Rx side buffer size */
id|MV_WRITE
(paren
id|MV64340_ETH_PORT_SERIAL_CONTROL_REG
c_func
(paren
id|port_num
)paren
comma
(paren
l_int|0x5
op_lshift
l_int|17
)paren
op_or
(paren
id|MV_READ
c_func
(paren
id|MV64340_ETH_PORT_SERIAL_CONTROL_REG
c_func
(paren
id|port_num
)paren
)paren
op_amp
l_int|0xfff1ffff
)paren
)paren
suffix:semicolon
multiline_comment|/* Check Link status on phy */
id|eth_port_read_smi_reg
c_func
(paren
id|port_num
comma
l_int|1
comma
op_amp
id|phy_reg_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|phy_reg_data
op_amp
l_int|0x20
)paren
)paren
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mv64340_eth_free_tx_rings
r_static
r_void
id|mv64340_eth_free_tx_rings
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|port_num
op_assign
id|mp-&gt;port_num
suffix:semicolon
r_int
r_int
id|curr
suffix:semicolon
multiline_comment|/* Stop Tx Queues */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0x0000ff00
)paren
suffix:semicolon
multiline_comment|/* Free TX rings */
multiline_comment|/* Free outstanding skb&squot;s on TX rings */
r_for
c_loop
(paren
id|curr
op_assign
l_int|0
suffix:semicolon
(paren
id|mp-&gt;tx_ring_skbs
)paren
op_logical_and
(paren
id|curr
OL
id|MV64340_TX_QUEUE_SIZE
)paren
suffix:semicolon
id|curr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;tx_skb
(braket
id|curr
)braket
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|mp-&gt;tx_skb
(braket
id|curr
)braket
)paren
suffix:semicolon
id|mp-&gt;tx_ring_skbs
op_decrement
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mp-&gt;tx_ring_skbs
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Error on Tx descriptor free - could not free %d&quot;
l_string|&quot; descriptors&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|mp-&gt;tx_ring_skbs
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
l_int|0
comma
id|mp-&gt;tx_desc_area_size
comma
(paren
r_void
op_star
)paren
id|mp-&gt;p_tx_desc_area
comma
id|mp-&gt;tx_desc_dma
)paren
suffix:semicolon
)brace
DECL|function|mv64340_eth_free_rx_rings
r_static
r_void
id|mv64340_eth_free_rx_rings
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|port_num
op_assign
id|mp-&gt;port_num
suffix:semicolon
r_int
id|curr
suffix:semicolon
multiline_comment|/* Stop RX Queues */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0x0000ff00
)paren
suffix:semicolon
multiline_comment|/* Free RX rings */
multiline_comment|/* Free preallocated skb&squot;s on RX rings */
r_for
c_loop
(paren
id|curr
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;rx_ring_skbs
op_logical_and
(paren
id|curr
OL
id|MV64340_RX_QUEUE_SIZE
)paren
suffix:semicolon
id|curr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;rx_skb
(braket
id|curr
)braket
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|mp-&gt;rx_skb
(braket
id|curr
)braket
)paren
suffix:semicolon
id|mp-&gt;rx_ring_skbs
op_decrement
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mp-&gt;rx_ring_skbs
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Error in freeing Rx Ring. %d skb&squot;s still&quot;
l_string|&quot; stuck in RX Ring - ignoring them&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|mp-&gt;rx_ring_skbs
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
l_int|0
comma
id|mp-&gt;rx_desc_area_size
comma
(paren
r_void
op_star
)paren
id|mp-&gt;p_rx_desc_area
comma
id|mp-&gt;rx_desc_dma
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * mv64340_eth_stop&n; *&n; * This function is used when closing the network device. &n; * It updates the hardware, &n; * release all memory that holds buffers and descriptors and release the IRQ.&n; * Input : a pointer to the device structure&n; * Output : zero if success , nonzero if fails&n; */
multiline_comment|/* Helper function for mv64340_eth_stop */
DECL|function|mv64340_eth_real_stop
r_static
r_int
id|mv64340_eth_real_stop
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|port_num
op_assign
id|mp-&gt;port_num
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mv64340_eth_free_tx_rings
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mv64340_eth_free_rx_rings
c_func
(paren
id|dev
)paren
suffix:semicolon
id|eth_port_reset
c_func
(paren
id|mp-&gt;port_num
)paren
suffix:semicolon
multiline_comment|/* Disable ethernet port interrupts */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_CAUSE_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_CAUSE_EXTEND_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Mask RX buffer and TX end interrupt */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_MASK_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Mask phy and link status changes interrupts */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_EXTEND_MASK_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mv64340_eth_stop
r_static
r_int
id|mv64340_eth_stop
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|mp-&gt;lock
)paren
suffix:semicolon
id|mv64340_eth_real_stop
c_func
(paren
id|dev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|mp-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MV64340_NAPI
DECL|function|mv64340_tx
r_static
r_void
id|mv64340_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|pkt_info
id|pkt_info
suffix:semicolon
r_while
c_loop
(paren
id|eth_tx_return_desc
c_func
(paren
id|mp
comma
op_amp
id|pkt_info
)paren
op_eq
id|ETH_OK
)paren
(brace
r_if
c_cond
(paren
id|pkt_info.return_info
)paren
(brace
id|dev_kfree_skb_irq
c_func
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|pkt_info.return_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_shinfo
c_func
(paren
id|pkt_info.return_info
)paren
op_member_access_from_pointer
id|nr_frags
)paren
id|pci_unmap_page
c_func
(paren
l_int|NULL
comma
id|pkt_info.buf_ptr
comma
id|pkt_info.byte_cnt
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;tx_ring_skbs
op_ne
l_int|1
)paren
id|mp-&gt;tx_ring_skbs
op_decrement
suffix:semicolon
)brace
r_else
id|pci_unmap_page
c_func
(paren
l_int|NULL
comma
id|pkt_info.buf_ptr
comma
id|pkt_info.byte_cnt
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
op_logical_and
id|MV64340_TX_QUEUE_SIZE
OG
id|mp-&gt;tx_ring_skbs
op_plus
l_int|1
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * mv64340_poll&n; *&n; * This function is used in case of NAPI&n; */
DECL|function|mv64340_poll
r_static
r_int
id|mv64340_poll
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
op_star
id|budget
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|done
op_assign
l_int|1
comma
id|orig_budget
comma
id|work_done
suffix:semicolon
r_int
r_int
id|port_num
op_assign
id|mp-&gt;port_num
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef MV64340_TX_FAST_REFILL
r_if
c_cond
(paren
op_increment
id|mp-&gt;tx_clean_threshold
OG
l_int|5
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|mp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|mv64340_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|mp-&gt;tx_clean_threshold
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|u32
)paren
(paren
id|MV_READ
c_func
(paren
id|MV64340_ETH_RX_CURRENT_QUEUE_DESC_PTR_0
c_func
(paren
id|port_num
)paren
)paren
)paren
op_ne
(paren
id|u32
)paren
id|mp-&gt;rx_used_desc_q
)paren
(brace
id|orig_budget
op_assign
op_star
id|budget
suffix:semicolon
r_if
c_cond
(paren
id|orig_budget
OG
id|dev-&gt;quota
)paren
id|orig_budget
op_assign
id|dev-&gt;quota
suffix:semicolon
id|work_done
op_assign
id|mv64340_eth_receive_queue
c_func
(paren
id|dev
comma
l_int|0
comma
id|orig_budget
)paren
suffix:semicolon
id|mp-&gt;rx_task
dot
id|func
c_func
(paren
id|dev
)paren
suffix:semicolon
op_star
id|budget
op_sub_assign
id|work_done
suffix:semicolon
id|dev-&gt;quota
op_sub_assign
id|work_done
suffix:semicolon
r_if
c_cond
(paren
id|work_done
op_ge
id|orig_budget
)paren
id|done
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|done
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|mp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__netif_rx_complete
c_func
(paren
id|dev
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_CAUSE_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_CAUSE_EXTEND_REG
c_func
(paren
id|port_num
)paren
comma
l_int|0
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_MASK_REG
c_func
(paren
id|port_num
)paren
comma
id|INT_CAUSE_UNMASK_ALL
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_INTERRUPT_EXTEND_MASK_REG
c_func
(paren
id|port_num
)paren
comma
id|INT_CAUSE_UNMASK_ALL_EXT
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|done
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * mv64340_eth_start_xmit&n; *&n; * This function is queues a packet in the Tx descriptor for &n; * required port.&n; *&n; * Input : skb - a pointer to socket buffer&n; *         dev - a pointer to the required port&n; *&n; * Output : zero upon success&n; */
DECL|function|mv64340_eth_start_xmit
r_static
r_int
id|mv64340_eth_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|stats
op_assign
op_amp
id|mp-&gt;stats
suffix:semicolon
id|ETH_FUNC_RET_STATUS
id|status
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|pkt_info
id|pkt_info
suffix:semicolon
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Tried sending packet when interface is stopped&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This is a hard error, log it. */
r_if
c_cond
(paren
(paren
id|MV64340_TX_QUEUE_SIZE
op_minus
id|mp-&gt;tx_ring_skbs
)paren
op_le
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_plus
l_int|1
)paren
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Bug in mv64340_eth - Trying to transmit when&quot;
l_string|&quot; queue full !&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Paranoid check - this shouldn&squot;t happen */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|stats-&gt;tx_dropped
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|mp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Update packet info data structure -- DMA owned, first last */
macro_line|#ifdef MV64340_CHECKSUM_OFFLOAD_TX
r_if
c_cond
(paren
op_logical_neg
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_logical_or
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
OG
l_int|3
)paren
)paren
(brace
macro_line|#endif
id|pkt_info.cmd_sts
op_assign
id|ETH_TX_ENABLE_INTERRUPT
op_or
id|ETH_TX_FIRST_DESC
op_or
id|ETH_TX_LAST_DESC
suffix:semicolon
id|pkt_info.byte_cnt
op_assign
id|skb-&gt;len
suffix:semicolon
id|pkt_info.buf_ptr
op_assign
id|pci_map_single
c_func
(paren
l_int|0
comma
id|skb-&gt;data
comma
id|skb-&gt;len
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|pkt_info.return_info
op_assign
id|skb
suffix:semicolon
id|status
op_assign
id|eth_port_send
c_func
(paren
id|mp
comma
op_amp
id|pkt_info
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_eq
id|ETH_ERROR
)paren
op_logical_or
(paren
id|status
op_eq
id|ETH_QUEUE_FULL
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Error on transmitting packet&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|mp-&gt;tx_ring_skbs
op_increment
suffix:semicolon
macro_line|#ifdef MV64340_CHECKSUM_OFFLOAD_TX
)brace
r_else
(brace
r_int
r_int
id|frag
suffix:semicolon
id|u32
id|ipheader
suffix:semicolon
multiline_comment|/* first frag which is skb header */
id|pkt_info.byte_cnt
op_assign
id|skb_headlen
c_func
(paren
id|skb
)paren
suffix:semicolon
id|pkt_info.buf_ptr
op_assign
id|pci_map_single
c_func
(paren
l_int|0
comma
id|skb-&gt;data
comma
id|skb_headlen
c_func
(paren
id|skb
)paren
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|pkt_info.return_info
op_assign
l_int|0
suffix:semicolon
id|ipheader
op_assign
id|skb-&gt;nh.iph-&gt;ihl
op_lshift
l_int|11
suffix:semicolon
id|pkt_info.cmd_sts
op_assign
id|ETH_TX_FIRST_DESC
op_or
id|ETH_GEN_TCP_UDP_CHECKSUM
op_or
id|ETH_GEN_IP_V_4_CHECKSUM
op_or
id|ipheader
suffix:semicolon
multiline_comment|/* CPU already calculated pseudo header checksum. So, use it */
id|pkt_info.l4i_chk
op_assign
id|skb-&gt;h.th-&gt;check
suffix:semicolon
id|status
op_assign
id|eth_port_send
c_func
(paren
id|mp
comma
op_amp
id|pkt_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|ETH_OK
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_eq
id|ETH_ERROR
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Error on transmitting packet&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|ETH_QUEUE_FULL
)paren
id|printk
c_func
(paren
l_string|&quot;Error on Queue Full &bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|ETH_QUEUE_LAST_RESOURCE
)paren
id|printk
c_func
(paren
l_string|&quot;Tx resource error &bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for the remaining frags */
r_for
c_loop
(paren
id|frag
op_assign
l_int|0
suffix:semicolon
id|frag
OL
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
suffix:semicolon
id|frag
op_increment
)paren
(brace
id|skb_frag_t
op_star
id|this_frag
op_assign
op_amp
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|frag
)braket
suffix:semicolon
id|pkt_info.l4i_chk
op_assign
l_int|0x0000
suffix:semicolon
id|pkt_info.cmd_sts
op_assign
l_int|0x00000000
suffix:semicolon
multiline_comment|/* Last Frag enables interrupt and frees the skb */
r_if
c_cond
(paren
id|frag
op_eq
(paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_minus
l_int|1
)paren
)paren
(brace
id|pkt_info.cmd_sts
op_or_assign
id|ETH_TX_ENABLE_INTERRUPT
op_or
id|ETH_TX_LAST_DESC
suffix:semicolon
id|pkt_info.return_info
op_assign
id|skb
suffix:semicolon
id|mp-&gt;tx_ring_skbs
op_increment
suffix:semicolon
)brace
r_else
(brace
id|pkt_info.return_info
op_assign
l_int|0
suffix:semicolon
)brace
id|pkt_info.byte_cnt
op_assign
id|this_frag-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|this_frag-&gt;size
OL
l_int|8
)paren
id|printk
c_func
(paren
l_string|&quot;%d : &bslash;n&quot;
comma
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
)paren
suffix:semicolon
id|pkt_info.buf_ptr
op_assign
id|pci_map_page
c_func
(paren
l_int|NULL
comma
id|this_frag-&gt;page
comma
id|this_frag-&gt;page_offset
comma
id|this_frag-&gt;size
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|status
op_assign
id|eth_port_send
c_func
(paren
id|mp
comma
op_amp
id|pkt_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|ETH_OK
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_eq
id|ETH_ERROR
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Error on transmitting packet&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|ETH_QUEUE_LAST_RESOURCE
)paren
id|printk
c_func
(paren
l_string|&quot;Tx resource error &bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|ETH_QUEUE_FULL
)paren
id|printk
c_func
(paren
l_string|&quot;Queue is full &bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/* Check if TX queue can handle another skb. If not, then&n;&t; * signal higher layers to stop requesting TX&n;&t; */
r_if
c_cond
(paren
id|MV64340_TX_QUEUE_SIZE
op_le
(paren
id|mp-&gt;tx_ring_skbs
op_plus
l_int|1
)paren
)paren
multiline_comment|/* &n;&t;&t; * Stop getting skb&squot;s from upper layers.&n;&t;&t; * Getting skb&squot;s from upper layers will be enabled again after&n;&t;&t; * packets are released.&n;&t;&t; */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Update statistics and start of transmittion time */
id|stats-&gt;tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|stats-&gt;tx_packets
op_increment
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* success */
)brace
multiline_comment|/*&n; * mv64340_eth_get_stats&n; *&n; * Returns a pointer to the interface statistics.&n; *&n; * Input : dev - a pointer to the required interface&n; *&n; * Output : a pointer to the interface&squot;s statistics&n; */
DECL|function|mv64340_eth_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|mv64340_eth_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_amp
id|mp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*/&n; * mv64340_eth_init&n; *&t;&t;&t;&t;&t;&t;&t;&t;       &n; * First function called after registering the network device. &n; * It&squot;s purpose is to initialize the device as an ethernet device, &n; * fill the structure that was given in registration with pointers&n; * to functions, and setting the MAC address of the interface&n; *&n; * Input : number of port to initialize&n; * Output : -ENONMEM if failed , 0 if success&n; */
DECL|function|mv64340_eth_init
r_static
r_struct
id|net_device
op_star
id|mv64340_eth_init
c_func
(paren
r_int
id|port_num
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_int
id|err
suffix:semicolon
id|dev
op_assign
id|alloc_etherdev
c_func
(paren
r_sizeof
(paren
r_struct
id|mv64340_private
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|ETH_PORT0_IRQ_NUM
op_plus
id|port_num
suffix:semicolon
id|dev-&gt;open
op_assign
id|mv64340_eth_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|mv64340_eth_stop
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|mv64340_eth_start_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|mv64340_eth_get_stats
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
id|mv64340_eth_set_mac_address
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|mv64340_eth_set_rx_mode
suffix:semicolon
multiline_comment|/* No need to Tx Timeout */
id|dev-&gt;tx_timeout
op_assign
id|mv64340_eth_tx_timeout
suffix:semicolon
macro_line|#ifdef MV64340_NAPI
id|dev-&gt;poll
op_assign
id|mv64340_poll
suffix:semicolon
id|dev-&gt;weight
op_assign
l_int|64
suffix:semicolon
macro_line|#endif
id|dev-&gt;watchdog_timeo
op_assign
l_int|2
op_star
id|HZ
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
id|MV64340_TX_QUEUE_SIZE
suffix:semicolon
id|dev-&gt;base_addr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;change_mtu
op_assign
id|mv64340_eth_change_mtu
suffix:semicolon
macro_line|#ifdef MV64340_CHECKSUM_OFFLOAD_TX
macro_line|#ifdef MAX_SKB_FRAGS
multiline_comment|/*&n;         * Zero copy can only work if we use Discovery II memory. Else, we will&n;         * have to map the buffers to ISA memory which is only 16 MB&n;         */
id|dev-&gt;features
op_assign
id|NETIF_F_SG
op_or
id|NETIF_F_IP_CSUM
op_or
id|NETIF_F_HW_CSUM
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|mp-&gt;port_num
op_assign
id|port_num
suffix:semicolon
multiline_comment|/* Configure the timeout task */
id|INIT_WORK
c_func
(paren
op_amp
id|mp-&gt;tx_timeout_task
comma
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|mv64340_eth_tx_timeout_task
comma
id|dev
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|mp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* set MAC addresses */
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|prom_mac_addr_base
comma
l_int|6
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
op_add_assign
id|port_num
suffix:semicolon
id|err
op_assign
id|register_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_free_dev
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: port %d with MAC address %02x:%02x:%02x:%02x:%02x:%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|port_num
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;features
op_amp
id|NETIF_F_SG
)paren
id|printk
c_func
(paren
l_string|&quot;Scatter Gather Enabled  &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;features
op_amp
id|NETIF_F_IP_CSUM
)paren
id|printk
c_func
(paren
l_string|&quot;TX TCP/IP Checksumming Supported  &bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RX TCP/UDP Checksum Offload ON, &bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TX and RX Interrupt Coalescing ON &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef MV64340_NAPI
id|printk
c_func
(paren
l_string|&quot;RX NAPI Enabled &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|dev
suffix:semicolon
id|out_free_dev
suffix:colon
id|free_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|mv64340_eth_remove
r_static
r_void
id|mv64340_eth_remove
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mv64340_private
op_star
id|mp
op_assign
id|netdev_priv
c_func
(paren
id|dev
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
id|free_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|variable|mv64340_dev0
r_static
r_struct
id|net_device
op_star
id|mv64340_dev0
suffix:semicolon
DECL|variable|mv64340_dev1
r_static
r_struct
id|net_device
op_star
id|mv64340_dev1
suffix:semicolon
DECL|variable|mv64340_dev2
r_static
r_struct
id|net_device
op_star
id|mv64340_dev2
suffix:semicolon
multiline_comment|/*&n; * mv64340_init_module&n; *&n; * Registers the network drivers into the Linux kernel&n; *&n; * Input : N/A&n; *&n; * Output : N/A&n; */
DECL|function|mv64340_init_module
r_static
r_int
id|__init
id|mv64340_init_module
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;MV-643xx 10/100/1000 Ethernet Driver&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MV643XX_ETH_0
id|mv64340_dev0
op_assign
id|mv64340_eth_init
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mv64340_dev0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Error registering MV-64360 ethernet port 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_MV643XX_ETH_1
id|mv64340_dev1
op_assign
id|mv64340_eth_init
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mv64340_dev1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Error registering MV-64360 ethernet port 1&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_MV643XX_ETH_2
id|mv64340_dev2
op_assign
id|mv64340_eth_init
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mv64340_dev2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Error registering MV-64360 ethernet port 2&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * mv64340_cleanup_module&n; *&n; * Registers the network drivers into the Linux kernel&n; *&n; * Input : N/A&n; *&n; * Output : N/A&n; */
DECL|function|mv64340_cleanup_module
r_static
r_void
id|__exit
id|mv64340_cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|mv64340_dev2
)paren
id|mv64340_eth_remove
c_func
(paren
id|mv64340_dev2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mv64340_dev1
)paren
id|mv64340_eth_remove
c_func
(paren
id|mv64340_dev1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mv64340_dev0
)paren
id|mv64340_eth_remove
c_func
(paren
id|mv64340_dev0
)paren
suffix:semicolon
)brace
DECL|variable|mv64340_init_module
id|module_init
c_func
(paren
id|mv64340_init_module
)paren
suffix:semicolon
DECL|variable|mv64340_cleanup_module
id|module_exit
c_func
(paren
id|mv64340_cleanup_module
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Rabeeh Khoury, Assaf Hoffman, Matthew Dharm and Manish Lachwani&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Ethernet driver for Marvell MV64340&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; *  The second part is the low level driver of the gigE ethernet ports.&n; */
multiline_comment|/*&n; * Marvell&squot;s Gigabit Ethernet controller low level driver&n; *&n; * DESCRIPTION:&n; *       This file introduce low level API to Marvell&squot;s Gigabit Ethernet&n; *&t;&t;controller. This Gigabit Ethernet Controller driver API controls&n; *&t;&t;1) Operations (i.e. port init, start, reset etc&squot;).&n; *&t;&t;2) Data flow (i.e. port send, receive etc&squot;).&n; *&t;&t;Each Gigabit Ethernet port is controlled via&n; *              struct mv64340_private.&n; *&t;&t;This struct includes user configuration information as well as&n; *&t;&t;driver internal data needed for its operations.&n; *&n; *&t;&t;Supported Features:  &n; *&t;&t;- This low level driver is OS independent. Allocating memory for&n; *&t;&t;  the descriptor rings and buffers are not within the scope of&n; *&t;&t;  this driver.&n; *&t;&t;- The user is free from Rx/Tx queue managing.&n; *&t;&t;- This low level driver introduce functionality API that enable&n; *&t;&t;  the to operate Marvell&squot;s Gigabit Ethernet Controller in a&n; *&t;&t;  convenient way.&n; *&t;&t;- Simple Gigabit Ethernet port operation API.&n; *&t;&t;- Simple Gigabit Ethernet port data flow API.&n; *&t;&t;- Data flow and operation API support per queue functionality.&n; *&t;&t;- Support cached descriptors for better performance.&n; *&t;&t;- Enable access to all four DRAM banks and internal SRAM memory&n; *&t;&t;  spaces.&n; *&t;&t;- PHY access and control API.&n; *&t;&t;- Port control register configuration API.&n; *&t;&t;- Full control over Unicast and Multicast MAC configurations.&n; *&t;&t;&t;&t;&t;&t;&t;&t;   &n; *&t;&t;Operation flow:&n; *&n; *&t;&t;Initialization phase&n; *&t;&t;This phase complete the initialization of the the mv64340_private&n; *&t;&t;struct. &n; *&t;&t;User information regarding port configuration has to be set&n; *&t;&t;prior to calling the port initialization routine.&n; *&n; *&t;&t;In this phase any port Tx/Rx activity is halted, MIB counters&n; *&t;&t;are cleared, PHY address is set according to user parameter and&n; *&t;&t;access to DRAM and internal SRAM memory spaces.&n; *&n; *&t;&t;Driver ring initialization&n; *&t;&t;Allocating memory for the descriptor rings and buffers is not &n; *&t;&t;within the scope of this driver. Thus, the user is required to&n; *&t;&t;allocate memory for the descriptors ring and buffers. Those&n; *&t;&t;memory parameters are used by the Rx and Tx ring initialization&n; *&t;&t;routines in order to curve the descriptor linked list in a form&n; *&t;&t;of a ring.&n; *&t;&t;Note: Pay special attention to alignment issues when using&n; *&t;&t;cached descriptors/buffers. In this phase the driver store&n; *&t;&t;information in the mv64340_private struct regarding each queue&n; *&t;&t;ring.&n; *&n; *&t;&t;Driver start &n; *&t;&t;This phase prepares the Ethernet port for Rx and Tx activity.&n; *&t;&t;It uses the information stored in the mv64340_private struct to &n; *&t;&t;initialize the various port registers.&n; *&n; *&t;&t;Data flow:&n; *&t;&t;All packet references to/from the driver are done using&n; *              struct pkt_info.&n; *&t;&t;This struct is a unified struct used with Rx and Tx operations. &n; *&t;&t;This way the user is not required to be familiar with neither&n; *&t;&t;Tx nor Rx descriptors structures.&n; *&t;&t;The driver&squot;s descriptors rings are management by indexes.&n; *&t;&t;Those indexes controls the ring resources and used to indicate&n; *&t;&t;a SW resource error:&n; *&t;&t;&squot;current&squot; &n; *&t;&t;This index points to the current available resource for use. For &n; *&t;&t;example in Rx process this index will point to the descriptor  &n; *&t;&t;that will be passed to the user upon calling the receive routine.&n; *&t;&t;In Tx process, this index will point to the descriptor&n; *&t;&t;that will be assigned with the user packet info and transmitted.&n; *&t;&t;&squot;used&squot;    &n; *&t;&t;This index points to the descriptor that need to restore its &n; *&t;&t;resources. For example in Rx process, using the Rx buffer return&n; *&t;&t;API will attach the buffer returned in packet info to the&n; *&t;&t;descriptor pointed by &squot;used&squot;. In Tx process, using the Tx&n; *&t;&t;descriptor return will merely return the user packet info with&n; *&t;&t;the command status of  the transmitted buffer pointed by the&n; *&t;&t;&squot;used&squot; index. Nevertheless, it is essential to use this routine&n; *&t;&t;to update the &squot;used&squot; index.&n; *&t;&t;&squot;first&squot;&n; *&t;&t;This index supports Tx Scatter-Gather. It points to the first &n; *&t;&t;descriptor of a packet assembled of multiple buffers. For example&n; *&t;&t;when in middle of Such packet we have a Tx resource error the &n; *&t;&t;&squot;curr&squot; index get the value of &squot;first&squot; to indicate that the ring &n; *&t;&t;returned to its state before trying to transmit this packet.&n; *&n; *&t;&t;Receive operation:&n; *&t;&t;The eth_port_receive API set the packet information struct,&n; *&t;&t;passed by the caller, with received information from the &n; *&t;&t;&squot;current&squot; SDMA descriptor. &n; *&t;&t;It is the user responsibility to return this resource back&n; *&t;&t;to the Rx descriptor ring to enable the reuse of this source.&n; *&t;&t;Return Rx resource is done using the eth_rx_return_buff API.&n; *&n; *&t;&t;Transmit operation:&n; *&t;&t;The eth_port_send API supports Scatter-Gather which enables to&n; *&t;&t;send a packet spanned over multiple buffers. This means that&n; *&t;&t;for each packet info structure given by the user and put into&n; *&t;&t;the Tx descriptors ring, will be transmitted only if the &squot;LAST&squot;&n; *&t;&t;bit will be set in the packet info command status field. This&n; *&t;&t;API also consider restriction regarding buffer alignments and&n; *&t;&t;sizes.&n; *&t;&t;The user must return a Tx resource after ensuring the buffer&n; *&t;&t;has been transmitted to enable the Tx ring indexes to update.&n; *&n; *&t;&t;BOARD LAYOUT&n; *&t;&t;This device is on-board.  No jumper diagram is necessary.&n; *&n; *&t;&t;EXTERNAL INTERFACE&n; *&n; *       Prior to calling the initialization routine eth_port_init() the user&n; *&t; must set the following fields under mv64340_private struct:&n; *       port_num             User Ethernet port number.&n; *       port_mac_addr[6]&t;    User defined port MAC address.&n; *       port_config          User port configuration value.&n; *       port_config_extend    User port config extend value.&n; *       port_sdma_config      User port SDMA config value.&n; *       port_serial_control   User port serial control value.&n; *&n; *       This driver introduce a set of default values:&n; *       PORT_CONFIG_VALUE           Default port configuration value&n; *       PORT_CONFIG_EXTEND_VALUE    Default port extend configuration value&n; *       PORT_SDMA_CONFIG_VALUE      Default sdma control value&n; *       PORT_SERIAL_CONTROL_VALUE   Default port serial control value&n; *&n; *&t;&t;This driver data flow is done using the struct pkt_info which&n; *              is a unified struct for Rx and Tx operations:&n; *&n; *&t;&t;byte_cnt&t;Tx/Rx descriptor buffer byte count.&n; *&t;&t;l4i_chk&t;&t;CPU provided TCP Checksum. For Tx operation&n; *                              only.&n; *&t;&t;cmd_sts&t;&t;Tx/Rx descriptor command status.&n; *&t;&t;buf_ptr&t;&t;Tx/Rx descriptor buffer pointer.&n; *&t;&t;return_info&t;Tx/Rx user resource return information.&n; */
multiline_comment|/* defines */
multiline_comment|/* SDMA command macros */
DECL|macro|ETH_ENABLE_TX_QUEUE
mdefine_line|#define ETH_ENABLE_TX_QUEUE(eth_port) &bslash;&n;&t;MV_WRITE(MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG(eth_port), 1)
DECL|macro|ETH_DISABLE_TX_QUEUE
mdefine_line|#define ETH_DISABLE_TX_QUEUE(eth_port) &bslash;&n;&t;MV_WRITE(MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG(eth_port),&t;&bslash;&n;&t;         (1 &lt;&lt; 8))
DECL|macro|ETH_ENABLE_RX_QUEUE
mdefine_line|#define ETH_ENABLE_RX_QUEUE(rx_queue, eth_port) &bslash;&n;&t;MV_WRITE(MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG(eth_port),&t;&bslash;&n;&t;         (1 &lt;&lt; rx_queue))
DECL|macro|ETH_DISABLE_RX_QUEUE
mdefine_line|#define ETH_DISABLE_RX_QUEUE(rx_queue, eth_port) &bslash;&n;&t;MV_WRITE(MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG(eth_port),&t;&bslash;&n;&t;         (1 &lt;&lt; (8 + rx_queue)))
DECL|macro|LINK_UP_TIMEOUT
mdefine_line|#define LINK_UP_TIMEOUT&t;&t;100000
DECL|macro|PHY_BUSY_TIMEOUT
mdefine_line|#define PHY_BUSY_TIMEOUT&t;10000000
multiline_comment|/* locals */
multiline_comment|/* PHY routines */
r_static
r_int
id|ethernet_phy_get
c_func
(paren
r_int
r_int
id|eth_port_num
)paren
suffix:semicolon
multiline_comment|/* Ethernet Port routines */
r_static
r_int
id|eth_port_uc_addr
c_func
(paren
r_int
r_int
id|eth_port_num
comma
r_int
r_char
id|uc_nibble
comma
r_int
id|option
)paren
suffix:semicolon
multiline_comment|/*&n; * eth_port_init - Initialize the Ethernet port driver&n; *&n; * DESCRIPTION:&n; *       This function prepares the ethernet port to start its activity:&n; *       1) Completes the ethernet port driver struct initialization toward port&n; *           start routine.&n; *       2) Resets the device to a quiescent state in case of warm reboot.&n; *       3) Enable SDMA access to all four DRAM banks as well as internal SRAM.&n; *       4) Clean MAC tables. The reset status of those tables is unknown.&n; *       5) Set PHY address. &n; *       Note: Call this routine prior to eth_port_start routine and after&n; *       setting user values in the user fields of Ethernet port control&n; *       struct.&n; *&n; * INPUT:&n; *       struct mv64340_private *mp   Ethernet port control struct&n; *&n; * OUTPUT:&n; *       See description.&n; *&n; * RETURN:&n; *       None.&n; */
DECL|function|eth_port_init
r_static
r_void
id|eth_port_init
c_func
(paren
r_struct
id|mv64340_private
op_star
id|mp
)paren
(brace
id|mp-&gt;port_config
op_assign
id|PORT_CONFIG_VALUE
suffix:semicolon
id|mp-&gt;port_config_extend
op_assign
id|PORT_CONFIG_EXTEND_VALUE
suffix:semicolon
macro_line|#if defined(__BIG_ENDIAN)
id|mp-&gt;port_sdma_config
op_assign
id|PORT_SDMA_CONFIG_VALUE
suffix:semicolon
macro_line|#elif defined(__LITTLE_ENDIAN)
id|mp-&gt;port_sdma_config
op_assign
id|PORT_SDMA_CONFIG_VALUE
op_or
id|ETH_BLM_RX_NO_SWAP
op_or
id|ETH_BLM_TX_NO_SWAP
suffix:semicolon
macro_line|#else
macro_line|#error One of __LITTLE_ENDIAN or __BIG_ENDIAN must be defined!
macro_line|#endif
id|mp-&gt;port_serial_control
op_assign
id|PORT_SERIAL_CONTROL_VALUE
suffix:semicolon
id|mp-&gt;port_rx_queue_command
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;port_tx_queue_command
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;rx_resource_err
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;tx_resource_err
op_assign
l_int|0
suffix:semicolon
id|eth_port_reset
c_func
(paren
id|mp-&gt;port_num
)paren
suffix:semicolon
id|eth_port_init_mac_tables
c_func
(paren
id|mp-&gt;port_num
)paren
suffix:semicolon
id|ethernet_phy_reset
c_func
(paren
id|mp-&gt;port_num
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * eth_port_start - Start the Ethernet port activity.&n; *&n; * DESCRIPTION:&n; *       This routine prepares the Ethernet port for Rx and Tx activity:&n; *       1. Initialize Tx and Rx Current Descriptor Pointer for each queue that&n; *          has been initialized a descriptor&squot;s ring (using&n; *          ether_init_tx_desc_ring for Tx and ether_init_rx_desc_ring for Rx)&n; *       2. Initialize and enable the Ethernet configuration port by writing to&n; *          the port&squot;s configuration and command registers.&n; *       3. Initialize and enable the SDMA by writing to the SDMA&squot;s &n; *          configuration and command registers.  After completing these steps,&n; *          the ethernet port SDMA can starts to perform Rx and Tx activities.&n; *&n; *       Note: Each Rx and Tx queue descriptor&squot;s list must be initialized prior&n; *       to calling this function (use ether_init_tx_desc_ring for Tx queues&n; *       and ether_init_rx_desc_ring for Rx queues).&n; *&n; * INPUT:&n; *       struct mv64340_private &t;*mp   Ethernet port control struct&n; *&n; * OUTPUT:&n; *       Ethernet port is ready to receive and transmit.&n; *&n; * RETURN:&n; *       false if the port PHY is not up.&n; *       true otherwise.&n; */
DECL|function|eth_port_start
r_static
r_int
id|eth_port_start
c_func
(paren
r_struct
id|mv64340_private
op_star
id|mp
)paren
(brace
r_int
r_int
id|eth_port_num
op_assign
id|mp-&gt;port_num
suffix:semicolon
r_int
id|tx_curr_desc
comma
id|rx_curr_desc
suffix:semicolon
r_int
r_int
id|phy_reg_data
suffix:semicolon
multiline_comment|/* Assignment of Tx CTRP of given queue */
id|tx_curr_desc
op_assign
id|mp-&gt;tx_curr_desc_q
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_TX_CURRENT_QUEUE_DESC_PTR_0
c_func
(paren
id|eth_port_num
)paren
comma
(paren
r_struct
id|eth_tx_desc
op_star
)paren
id|mp-&gt;tx_desc_dma
op_plus
id|tx_curr_desc
)paren
suffix:semicolon
multiline_comment|/* Assignment of Rx CRDP of given queue */
id|rx_curr_desc
op_assign
id|mp-&gt;rx_curr_desc_q
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_RX_CURRENT_QUEUE_DESC_PTR_0
c_func
(paren
id|eth_port_num
)paren
comma
(paren
r_struct
id|eth_rx_desc
op_star
)paren
id|mp-&gt;rx_desc_dma
op_plus
id|rx_curr_desc
)paren
suffix:semicolon
multiline_comment|/* Add the assigned Ethernet address to the port&squot;s address table */
id|eth_port_uc_addr_set
c_func
(paren
id|mp-&gt;port_num
comma
id|mp-&gt;port_mac_addr
)paren
suffix:semicolon
multiline_comment|/* Assign port configuration and command. */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_PORT_CONFIG_REG
c_func
(paren
id|eth_port_num
)paren
comma
id|mp-&gt;port_config
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_PORT_CONFIG_EXTEND_REG
c_func
(paren
id|eth_port_num
)paren
comma
id|mp-&gt;port_config_extend
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_PORT_SERIAL_CONTROL_REG
c_func
(paren
id|eth_port_num
)paren
comma
id|mp-&gt;port_serial_control
)paren
suffix:semicolon
id|MV_SET_REG_BITS
c_func
(paren
id|MV64340_ETH_PORT_SERIAL_CONTROL_REG
c_func
(paren
id|eth_port_num
)paren
comma
id|ETH_SERIAL_PORT_ENABLE
)paren
suffix:semicolon
multiline_comment|/* Assign port SDMA configuration */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_SDMA_CONFIG_REG
c_func
(paren
id|eth_port_num
)paren
comma
id|mp-&gt;port_sdma_config
)paren
suffix:semicolon
multiline_comment|/* Enable port Rx. */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG
c_func
(paren
id|eth_port_num
)paren
comma
id|mp-&gt;port_rx_queue_command
)paren
suffix:semicolon
multiline_comment|/* Check if link is up */
id|eth_port_read_smi_reg
c_func
(paren
id|eth_port_num
comma
l_int|1
comma
op_amp
id|phy_reg_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|phy_reg_data
op_amp
l_int|0x20
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * eth_port_uc_addr_set - This function Set the port Unicast address.&n; *&n; * DESCRIPTION:&n; *&t;&t;This function Set the port Ethernet MAC address.&n; *&n; * INPUT:&n; *&t;unsigned int eth_port_num     Port number.&n; *&t;char *        p_addr&t;&t;Address to be set &n; *&n; * OUTPUT:&n; *&t;Set MAC address low and high registers. also calls eth_port_uc_addr() &n; *       To set the unicast table with the proper information.&n; *&n; * RETURN:&n; *&t;N/A.&n; *&n; */
DECL|function|eth_port_uc_addr_set
r_static
r_void
id|eth_port_uc_addr_set
c_func
(paren
r_int
r_int
id|eth_port_num
comma
r_int
r_char
op_star
id|p_addr
)paren
(brace
r_int
r_int
id|mac_h
suffix:semicolon
r_int
r_int
id|mac_l
suffix:semicolon
id|mac_l
op_assign
(paren
id|p_addr
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|p_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|mac_h
op_assign
(paren
id|p_addr
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|p_addr
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|p_addr
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|p_addr
(braket
l_int|3
)braket
op_lshift
l_int|0
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_MAC_ADDR_LOW
c_func
(paren
id|eth_port_num
)paren
comma
id|mac_l
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_MAC_ADDR_HIGH
c_func
(paren
id|eth_port_num
)paren
comma
id|mac_h
)paren
suffix:semicolon
multiline_comment|/* Accept frames of this address */
id|eth_port_uc_addr
c_func
(paren
id|eth_port_num
comma
id|p_addr
(braket
l_int|5
)braket
comma
id|ACCEPT_MAC_ADDR
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * eth_port_uc_addr - This function Set the port unicast address table&n; *&n; * DESCRIPTION:&n; *&t;This function locates the proper entry in the Unicast table for the &n; *&t;specified MAC nibble and sets its properties according to function &n; *&t;parameters.&n; *&n; * INPUT:&n; *&t;unsigned int &t;eth_port_num      Port number.&n; *&t;unsigned char uc_nibble&t;&t;Unicast MAC Address last nibble. &n; *&t;int &t;&t;&t;option      0 = Add, 1 = remove address.&n; *&n; * OUTPUT:&n; *&t;This function add/removes MAC addresses from the port unicast address&n; *&t;table. &n; *&n; * RETURN:&n; *&t;true is output succeeded.&n; *&t;false if option parameter is invalid.&n; *&n; */
DECL|function|eth_port_uc_addr
r_static
r_int
id|eth_port_uc_addr
c_func
(paren
r_int
r_int
id|eth_port_num
comma
r_int
r_char
id|uc_nibble
comma
r_int
id|option
)paren
(brace
r_int
r_int
id|unicast_reg
suffix:semicolon
r_int
r_int
id|tbl_offset
suffix:semicolon
r_int
r_int
id|reg_offset
suffix:semicolon
multiline_comment|/* Locate the Unicast table entry */
id|uc_nibble
op_assign
(paren
l_int|0xf
op_amp
id|uc_nibble
)paren
suffix:semicolon
id|tbl_offset
op_assign
(paren
id|uc_nibble
op_div
l_int|4
)paren
op_star
l_int|4
suffix:semicolon
multiline_comment|/* Register offset from unicast table base */
id|reg_offset
op_assign
id|uc_nibble
op_mod
l_int|4
suffix:semicolon
multiline_comment|/* Entry offset within the above register */
r_switch
c_cond
(paren
id|option
)paren
(brace
r_case
id|REJECT_MAC_ADDR
suffix:colon
multiline_comment|/* Clear accepts frame bit at specified unicast DA table entry */
id|unicast_reg
op_assign
id|MV_READ
c_func
(paren
(paren
id|MV64340_ETH_DA_FILTER_UNICAST_TABLE_BASE
(paren
id|eth_port_num
)paren
op_plus
id|tbl_offset
)paren
)paren
suffix:semicolon
id|unicast_reg
op_and_assign
(paren
l_int|0x0E
op_lshift
(paren
l_int|8
op_star
id|reg_offset
)paren
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
(paren
id|MV64340_ETH_DA_FILTER_UNICAST_TABLE_BASE
(paren
id|eth_port_num
)paren
op_plus
id|tbl_offset
)paren
comma
id|unicast_reg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACCEPT_MAC_ADDR
suffix:colon
multiline_comment|/* Set accepts frame bit at unicast DA filter table entry */
id|unicast_reg
op_assign
id|MV_READ
c_func
(paren
(paren
id|MV64340_ETH_DA_FILTER_UNICAST_TABLE_BASE
(paren
id|eth_port_num
)paren
op_plus
id|tbl_offset
)paren
)paren
suffix:semicolon
id|unicast_reg
op_or_assign
(paren
l_int|0x01
op_lshift
(paren
l_int|8
op_star
id|reg_offset
)paren
)paren
suffix:semicolon
id|MV_WRITE
c_func
(paren
(paren
id|MV64340_ETH_DA_FILTER_UNICAST_TABLE_BASE
(paren
id|eth_port_num
)paren
op_plus
id|tbl_offset
)paren
comma
id|unicast_reg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * eth_port_init_mac_tables - Clear all entrance in the UC, SMC and OMC tables&n; *&n; * DESCRIPTION:&n; *       Go through all the DA filter tables (Unicast, Special Multicast &amp;&n; *       Other Multicast) and set each entry to 0.&n; *&n; * INPUT:&n; *&t;unsigned int    eth_port_num   Ethernet Port number.&n; *&n; * OUTPUT:&n; *       Multicast and Unicast packets are rejected.&n; *&n; * RETURN:&n; *       None.&n; */
DECL|function|eth_port_init_mac_tables
r_static
r_void
id|eth_port_init_mac_tables
c_func
(paren
r_int
r_int
id|eth_port_num
)paren
(brace
r_int
id|table_index
suffix:semicolon
multiline_comment|/* Clear DA filter unicast table (Ex_dFUT) */
r_for
c_loop
(paren
id|table_index
op_assign
l_int|0
suffix:semicolon
id|table_index
op_le
l_int|0xC
suffix:semicolon
id|table_index
op_add_assign
l_int|4
)paren
id|MV_WRITE
c_func
(paren
(paren
id|MV64340_ETH_DA_FILTER_UNICAST_TABLE_BASE
(paren
id|eth_port_num
)paren
op_plus
id|table_index
)paren
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|table_index
op_assign
l_int|0
suffix:semicolon
id|table_index
op_le
l_int|0xFC
suffix:semicolon
id|table_index
op_add_assign
l_int|4
)paren
(brace
multiline_comment|/* Clear DA filter special multicast table (Ex_dFSMT) */
id|MV_WRITE
c_func
(paren
(paren
id|MV64340_ETH_DA_FILTER_SPECIAL_MULTICAST_TABLE_BASE
(paren
id|eth_port_num
)paren
op_plus
id|table_index
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Clear DA filter other multicast table (Ex_dFOMT) */
id|MV_WRITE
c_func
(paren
(paren
id|MV64340_ETH_DA_FILTER_OTHER_MULTICAST_TABLE_BASE
(paren
id|eth_port_num
)paren
op_plus
id|table_index
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * eth_clear_mib_counters - Clear all MIB counters&n; *&n; * DESCRIPTION:&n; *       This function clears all MIB counters of a specific ethernet port.&n; *       A read from the MIB counter will reset the counter.&n; *&n; * INPUT:&n; *&t;unsigned int    eth_port_num   Ethernet Port number.&n; *&n; * OUTPUT:&n; *       After reading all MIB counters, the counters resets.&n; *&n; * RETURN:&n; *       MIB counter value.&n; *&n; */
DECL|function|eth_clear_mib_counters
r_static
r_void
id|eth_clear_mib_counters
c_func
(paren
r_int
r_int
id|eth_port_num
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Perform dummy reads from MIB counters */
r_for
c_loop
(paren
id|i
op_assign
id|ETH_MIB_GOOD_OCTETS_RECEIVED_LOW
suffix:semicolon
id|i
OL
id|ETH_MIB_LATE_COLLISION
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
id|MV_READ
c_func
(paren
id|MV64340_ETH_MIB_COUNTERS_BASE
c_func
(paren
id|eth_port_num
)paren
op_plus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ethernet_phy_get - Get the ethernet port PHY address.&n; *&n; * DESCRIPTION:&n; *       This routine returns the given ethernet port PHY address.&n; *&n; * INPUT:&n; *&t;&t;unsigned int   eth_port_num   Ethernet Port number.&n; *&n; * OUTPUT:&n; *       None.&n; *&n; * RETURN:&n; *       PHY address.&n; *&n; */
DECL|function|ethernet_phy_get
r_static
r_int
id|ethernet_phy_get
c_func
(paren
r_int
r_int
id|eth_port_num
)paren
(brace
r_int
r_int
id|reg_data
suffix:semicolon
id|reg_data
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_PHY_ADDR_REG
)paren
suffix:semicolon
r_return
(paren
(paren
id|reg_data
op_rshift
(paren
l_int|5
op_star
id|eth_port_num
)paren
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ethernet_phy_reset - Reset Ethernet port PHY.&n; *&n; * DESCRIPTION:&n; *       This routine utilize the SMI interface to reset the ethernet port PHY.&n; *       The routine waits until the link is up again or link up is timeout.&n; *&n; * INPUT:&n; *&t;unsigned int   eth_port_num   Ethernet Port number.&n; *&n; * OUTPUT:&n; *       The ethernet port PHY renew its link.&n; *&n; * RETURN:&n; *       None.&n; *&n; */
DECL|function|ethernet_phy_reset
r_static
r_int
id|ethernet_phy_reset
c_func
(paren
r_int
r_int
id|eth_port_num
)paren
(brace
r_int
r_int
id|time_out
op_assign
l_int|50
suffix:semicolon
r_int
r_int
id|phy_reg_data
suffix:semicolon
multiline_comment|/* Reset the PHY */
id|eth_port_read_smi_reg
c_func
(paren
id|eth_port_num
comma
l_int|0
comma
op_amp
id|phy_reg_data
)paren
suffix:semicolon
id|phy_reg_data
op_or_assign
l_int|0x8000
suffix:semicolon
multiline_comment|/* Set bit 15 to reset the PHY */
id|eth_port_write_smi_reg
c_func
(paren
id|eth_port_num
comma
l_int|0
comma
id|phy_reg_data
)paren
suffix:semicolon
multiline_comment|/* Poll on the PHY LINK */
r_do
(brace
id|eth_port_read_smi_reg
c_func
(paren
id|eth_port_num
comma
l_int|1
comma
op_amp
id|phy_reg_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_out
op_decrement
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|phy_reg_data
op_amp
l_int|0x20
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * eth_port_reset - Reset Ethernet port&n; *&n; * DESCRIPTION:&n; * &t;This routine resets the chip by aborting any SDMA engine activity and&n; *      clearing the MIB counters. The Receiver and the Transmit unit are in &n; *      idle state after this command is performed and the port is disabled.&n; *&n; * INPUT:&n; *&t;unsigned int   eth_port_num   Ethernet Port number.&n; *&n; * OUTPUT:&n; *       Channel activity is halted.&n; *&n; * RETURN:&n; *       None.&n; *&n; */
DECL|function|eth_port_reset
r_static
r_void
id|eth_port_reset
c_func
(paren
r_int
r_int
id|eth_port_num
)paren
(brace
r_int
r_int
id|reg_data
suffix:semicolon
multiline_comment|/* Stop Tx port activity. Check port Tx activity. */
id|reg_data
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG
c_func
(paren
id|eth_port_num
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_data
op_amp
l_int|0xFF
)paren
(brace
multiline_comment|/* Issue stop command for active channels only */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG
(paren
id|eth_port_num
)paren
comma
(paren
id|reg_data
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/* Wait for all Tx activity to terminate. */
r_do
(brace
multiline_comment|/* Check port cause register that all Tx queues are stopped */
id|reg_data
op_assign
id|MV_READ
(paren
id|MV64340_ETH_TRANSMIT_QUEUE_COMMAND_REG
(paren
id|eth_port_num
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|reg_data
op_amp
l_int|0xFF
)paren
suffix:semicolon
)brace
multiline_comment|/* Stop Rx port activity. Check port Rx activity. */
id|reg_data
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG
(paren
id|eth_port_num
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_data
op_amp
l_int|0xFF
)paren
(brace
multiline_comment|/* Issue stop command for active channels only */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG
(paren
id|eth_port_num
)paren
comma
(paren
id|reg_data
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/* Wait for all Rx activity to terminate. */
r_do
(brace
multiline_comment|/* Check port cause register that all Rx queues are stopped */
id|reg_data
op_assign
id|MV_READ
(paren
id|MV64340_ETH_RECEIVE_QUEUE_COMMAND_REG
(paren
id|eth_port_num
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|reg_data
op_amp
l_int|0xFF
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear all MIB counters */
id|eth_clear_mib_counters
c_func
(paren
id|eth_port_num
)paren
suffix:semicolon
multiline_comment|/* Reset the Enable bit in the Configuration Register */
id|reg_data
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_PORT_SERIAL_CONTROL_REG
(paren
id|eth_port_num
)paren
)paren
suffix:semicolon
id|reg_data
op_and_assign
op_complement
id|ETH_SERIAL_PORT_ENABLE
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_PORT_SERIAL_CONTROL_REG
c_func
(paren
id|eth_port_num
)paren
comma
id|reg_data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * ethernet_set_config_reg - Set specified bits in configuration register.&n; *&n; * DESCRIPTION:&n; *       This function sets specified bits in the given ethernet &n; *       configuration register. &n; *&n; * INPUT:&n; *&t;unsigned int   eth_port_num   Ethernet Port number.&n; *      unsigned int    value   32 bit value.&n; *&n; * OUTPUT:&n; *      The set bits in the value parameter are set in the configuration &n; *      register.&n; *&n; * RETURN:&n; *      None.&n; *&n; */
DECL|function|ethernet_set_config_reg
r_static
r_void
id|ethernet_set_config_reg
c_func
(paren
r_int
r_int
id|eth_port_num
comma
r_int
r_int
id|value
)paren
(brace
r_int
r_int
id|eth_config_reg
suffix:semicolon
id|eth_config_reg
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_PORT_CONFIG_REG
c_func
(paren
id|eth_port_num
)paren
)paren
suffix:semicolon
id|eth_config_reg
op_or_assign
id|value
suffix:semicolon
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_PORT_CONFIG_REG
c_func
(paren
id|eth_port_num
)paren
comma
id|eth_config_reg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ethernet_get_config_reg - Get the port configuration register&n; *&n; * DESCRIPTION:&n; *       This function returns the configuration register value of the given &n; *       ethernet port.&n; *&n; * INPUT:&n; *&t;unsigned int   eth_port_num   Ethernet Port number.&n; *&n; * OUTPUT:&n; *       None.&n; *&n; * RETURN:&n; *       Port configuration register value.&n; */
DECL|function|ethernet_get_config_reg
r_static
r_int
r_int
id|ethernet_get_config_reg
c_func
(paren
r_int
r_int
id|eth_port_num
)paren
(brace
r_int
r_int
id|eth_config_reg
suffix:semicolon
id|eth_config_reg
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_PORT_CONFIG_EXTEND_REG
(paren
id|eth_port_num
)paren
)paren
suffix:semicolon
r_return
id|eth_config_reg
suffix:semicolon
)brace
multiline_comment|/*&n; * eth_port_read_smi_reg - Read PHY registers&n; *&n; * DESCRIPTION:&n; *       This routine utilize the SMI interface to interact with the PHY in &n; *       order to perform PHY register read.&n; *&n; * INPUT:&n; *&t;unsigned int   eth_port_num   Ethernet Port number.&n; *       unsigned int   phy_reg   PHY register address offset.&n; *       unsigned int   *value   Register value buffer.&n; *&n; * OUTPUT:&n; *       Write the value of a specified PHY register into given buffer.&n; *&n; * RETURN:&n; *       false if the PHY is busy or read data is not in valid state.&n; *       true otherwise.&n; *&n; */
DECL|function|eth_port_read_smi_reg
r_static
r_int
id|eth_port_read_smi_reg
c_func
(paren
r_int
r_int
id|eth_port_num
comma
r_int
r_int
id|phy_reg
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
id|phy_addr
op_assign
id|ethernet_phy_get
c_func
(paren
id|eth_port_num
)paren
suffix:semicolon
r_int
r_int
id|time_out
op_assign
id|PHY_BUSY_TIMEOUT
suffix:semicolon
r_int
r_int
id|reg_value
suffix:semicolon
multiline_comment|/* first check that it is not busy */
r_do
(brace
id|reg_value
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_SMI_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_out
op_decrement
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|reg_value
op_amp
id|ETH_SMI_BUSY
)paren
suffix:semicolon
multiline_comment|/* not busy */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_SMI_REG
comma
(paren
id|phy_addr
op_lshift
l_int|16
)paren
op_or
(paren
id|phy_reg
op_lshift
l_int|21
)paren
op_or
id|ETH_SMI_OPCODE_READ
)paren
suffix:semicolon
id|time_out
op_assign
id|PHY_BUSY_TIMEOUT
suffix:semicolon
multiline_comment|/* initialize the time out var again */
r_do
(brace
id|reg_value
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_SMI_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_out
op_decrement
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|reg_value
op_amp
id|ETH_SMI_READ_VALID
)paren
suffix:semicolon
multiline_comment|/* Wait for the data to update in the SMI register */
r_for
c_loop
(paren
id|time_out
op_assign
l_int|0
suffix:semicolon
id|time_out
OL
id|PHY_BUSY_TIMEOUT
suffix:semicolon
id|time_out
op_increment
)paren
suffix:semicolon
id|reg_value
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_SMI_REG
)paren
suffix:semicolon
op_star
id|value
op_assign
id|reg_value
op_amp
l_int|0xffff
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * eth_port_write_smi_reg - Write to PHY registers&n; *&n; * DESCRIPTION:&n; *       This routine utilize the SMI interface to interact with the PHY in &n; *       order to perform writes to PHY registers.&n; *&n; * INPUT:&n; *&t;unsigned int   eth_port_num   Ethernet Port number.&n; *      unsigned int   phy_reg   PHY register address offset.&n; *      unsigned int    value   Register value.&n; *&n; * OUTPUT:&n; *      Write the given value to the specified PHY register.&n; *&n; * RETURN:&n; *      false if the PHY is busy.&n; *      true otherwise.&n; *&n; */
DECL|function|eth_port_write_smi_reg
r_static
r_int
id|eth_port_write_smi_reg
c_func
(paren
r_int
r_int
id|eth_port_num
comma
r_int
r_int
id|phy_reg
comma
r_int
r_int
id|value
)paren
(brace
r_int
r_int
id|time_out
op_assign
id|PHY_BUSY_TIMEOUT
suffix:semicolon
r_int
r_int
id|reg_value
suffix:semicolon
r_int
id|phy_addr
suffix:semicolon
id|phy_addr
op_assign
id|ethernet_phy_get
c_func
(paren
id|eth_port_num
)paren
suffix:semicolon
multiline_comment|/* first check that it is not busy */
r_do
(brace
id|reg_value
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_SMI_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_out
op_decrement
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|reg_value
op_amp
id|ETH_SMI_BUSY
)paren
suffix:semicolon
multiline_comment|/* not busy */
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_SMI_REG
comma
(paren
id|phy_addr
op_lshift
l_int|16
)paren
op_or
(paren
id|phy_reg
op_lshift
l_int|21
)paren
op_or
id|ETH_SMI_OPCODE_WRITE
op_or
(paren
id|value
op_amp
l_int|0xffff
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * eth_port_send - Send an Ethernet packet&n; *&n; * DESCRIPTION:&n; *&t;This routine send a given packet described by p_pktinfo parameter. It &n; *      supports transmitting of a packet spaned over multiple buffers. The &n; *      routine updates &squot;curr&squot; and &squot;first&squot; indexes according to the packet &n; *      segment passed to the routine. In case the packet segment is first, &n; *      the &squot;first&squot; index is update. In any case, the &squot;curr&squot; index is updated. &n; *      If the routine get into Tx resource error it assigns &squot;curr&squot; index as &n; *      &squot;first&squot;. This way the function can abort Tx process of multiple &n; *      descriptors per packet.&n; *&n; * INPUT:&n; *&t;struct mv64340_private   *mp   Ethernet Port Control srtuct. &n; *&t;struct pkt_info        *p_pkt_info       User packet buffer.&n; *&n; * OUTPUT:&n; *&t;Tx ring &squot;curr&squot; and &squot;first&squot; indexes are updated. &n; *&n; * RETURN:&n; *      ETH_QUEUE_FULL in case of Tx resource error.&n; *&t;ETH_ERROR in case the routine can not access Tx desc ring.&n; *&t;ETH_QUEUE_LAST_RESOURCE if the routine uses the last Tx resource.&n; *      ETH_OK otherwise.&n; *&n; */
macro_line|#ifdef  MV64340_CHECKSUM_OFFLOAD_TX
multiline_comment|/*&n; * Modified to include the first descriptor pointer in case of SG&n; */
DECL|function|eth_port_send
r_static
id|ETH_FUNC_RET_STATUS
id|eth_port_send
c_func
(paren
r_struct
id|mv64340_private
op_star
id|mp
comma
r_struct
id|pkt_info
op_star
id|p_pkt_info
)paren
(brace
r_int
id|tx_desc_curr
comma
id|tx_desc_used
comma
id|tx_first_desc
comma
id|tx_next_desc
suffix:semicolon
r_volatile
r_struct
id|eth_tx_desc
op_star
id|current_descriptor
suffix:semicolon
r_volatile
r_struct
id|eth_tx_desc
op_star
id|first_descriptor
suffix:semicolon
id|u32
id|command_status
comma
id|first_chip_ptr
suffix:semicolon
multiline_comment|/* Do not process Tx ring in case of Tx ring resource error */
r_if
c_cond
(paren
id|mp-&gt;tx_resource_err
)paren
r_return
id|ETH_QUEUE_FULL
suffix:semicolon
multiline_comment|/* Get the Tx Desc ring indexes */
id|tx_desc_curr
op_assign
id|mp-&gt;tx_curr_desc_q
suffix:semicolon
id|tx_desc_used
op_assign
id|mp-&gt;tx_used_desc_q
suffix:semicolon
id|current_descriptor
op_assign
op_amp
id|mp-&gt;p_tx_desc_area
(braket
id|tx_desc_curr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|current_descriptor
op_eq
l_int|NULL
)paren
r_return
id|ETH_ERROR
suffix:semicolon
id|tx_next_desc
op_assign
(paren
id|tx_desc_curr
op_plus
l_int|1
)paren
op_mod
id|MV64340_TX_QUEUE_SIZE
suffix:semicolon
id|command_status
op_assign
id|p_pkt_info-&gt;cmd_sts
op_or
id|ETH_ZERO_PADDING
op_or
id|ETH_GEN_CRC
suffix:semicolon
r_if
c_cond
(paren
id|command_status
op_amp
id|ETH_TX_FIRST_DESC
)paren
(brace
id|tx_first_desc
op_assign
id|tx_desc_curr
suffix:semicolon
id|mp-&gt;tx_first_desc_q
op_assign
id|tx_first_desc
suffix:semicolon
multiline_comment|/* fill first descriptor */
id|first_descriptor
op_assign
op_amp
id|mp-&gt;p_tx_desc_area
(braket
id|tx_desc_curr
)braket
suffix:semicolon
id|first_descriptor-&gt;l4i_chk
op_assign
id|p_pkt_info-&gt;l4i_chk
suffix:semicolon
id|first_descriptor-&gt;cmd_sts
op_assign
id|command_status
suffix:semicolon
id|first_descriptor-&gt;byte_cnt
op_assign
id|p_pkt_info-&gt;byte_cnt
suffix:semicolon
id|first_descriptor-&gt;buf_ptr
op_assign
id|p_pkt_info-&gt;buf_ptr
suffix:semicolon
id|first_descriptor-&gt;next_desc_ptr
op_assign
id|mp-&gt;tx_desc_dma
op_plus
id|tx_next_desc
op_star
r_sizeof
(paren
r_struct
id|eth_tx_desc
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|tx_first_desc
op_assign
id|mp-&gt;tx_first_desc_q
suffix:semicolon
id|first_descriptor
op_assign
op_amp
id|mp-&gt;p_tx_desc_area
(braket
id|tx_first_desc
)braket
suffix:semicolon
r_if
c_cond
(paren
id|first_descriptor
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;First desc is NULL !!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ETH_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|command_status
op_amp
id|ETH_TX_LAST_DESC
)paren
id|current_descriptor-&gt;next_desc_ptr
op_assign
l_int|0x00000000
suffix:semicolon
r_else
(brace
id|command_status
op_or_assign
id|ETH_BUFFER_OWNED_BY_DMA
suffix:semicolon
id|current_descriptor-&gt;next_desc_ptr
op_assign
id|mp-&gt;tx_desc_dma
op_plus
id|tx_next_desc
op_star
r_sizeof
(paren
r_struct
id|eth_tx_desc
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p_pkt_info-&gt;byte_cnt
OL
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; &lt; 8 problem &bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ETH_ERROR
suffix:semicolon
)brace
id|current_descriptor-&gt;buf_ptr
op_assign
id|p_pkt_info-&gt;buf_ptr
suffix:semicolon
id|current_descriptor-&gt;byte_cnt
op_assign
id|p_pkt_info-&gt;byte_cnt
suffix:semicolon
id|current_descriptor-&gt;l4i_chk
op_assign
id|p_pkt_info-&gt;l4i_chk
suffix:semicolon
id|current_descriptor-&gt;cmd_sts
op_assign
id|command_status
suffix:semicolon
id|mp-&gt;tx_skb
(braket
id|tx_desc_curr
)braket
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|p_pkt_info-&gt;return_info
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Set last desc with DMA ownership and interrupt enable. */
r_if
c_cond
(paren
id|command_status
op_amp
id|ETH_TX_LAST_DESC
)paren
(brace
id|current_descriptor-&gt;cmd_sts
op_assign
id|command_status
op_or
id|ETH_TX_ENABLE_INTERRUPT
op_or
id|ETH_BUFFER_OWNED_BY_DMA
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|command_status
op_amp
id|ETH_TX_FIRST_DESC
)paren
)paren
id|first_descriptor-&gt;cmd_sts
op_or_assign
id|ETH_BUFFER_OWNED_BY_DMA
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|first_chip_ptr
op_assign
id|MV_READ
c_func
(paren
id|MV64340_ETH_CURRENT_SERVED_TX_DESC_PTR
c_func
(paren
id|mp-&gt;port_num
)paren
)paren
suffix:semicolon
multiline_comment|/* Apply send command */
r_if
c_cond
(paren
id|first_chip_ptr
op_eq
l_int|0x00000000
)paren
id|MV_WRITE
c_func
(paren
id|MV64340_ETH_TX_CURRENT_QUEUE_DESC_PTR_0
c_func
(paren
id|mp-&gt;port_num
)paren
comma
(paren
r_struct
id|eth_tx_desc
op_star
)paren
id|mp-&gt;tx_desc_dma
op_plus
id|tx_first_desc
)paren
suffix:semicolon
id|ETH_ENABLE_TX_QUEUE
c_func
(paren
id|mp-&gt;port_num
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Finish Tx packet. Update first desc in case of Tx resource&n;&t;&t; * error */
id|tx_first_desc
op_assign
id|tx_next_desc
suffix:semicolon
id|mp-&gt;tx_first_desc_q
op_assign
id|tx_first_desc
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|command_status
op_amp
id|ETH_TX_FIRST_DESC
)paren
)paren
(brace
id|current_descriptor-&gt;cmd_sts
op_assign
id|command_status
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Check for ring index overlap in the Tx desc ring */
r_if
c_cond
(paren
id|tx_next_desc
op_eq
id|tx_desc_used
)paren
(brace
id|mp-&gt;tx_resource_err
op_assign
l_int|1
suffix:semicolon
id|mp-&gt;tx_curr_desc_q
op_assign
id|tx_first_desc
suffix:semicolon
r_return
id|ETH_QUEUE_LAST_RESOURCE
suffix:semicolon
)brace
id|mp-&gt;tx_curr_desc_q
op_assign
id|tx_next_desc
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
r_return
id|ETH_OK
suffix:semicolon
)brace
macro_line|#else
DECL|function|eth_port_send
r_static
id|ETH_FUNC_RET_STATUS
id|eth_port_send
c_func
(paren
r_struct
id|mv64340_private
op_star
id|mp
comma
r_struct
id|pkt_info
op_star
id|p_pkt_info
)paren
(brace
r_int
id|tx_desc_curr
suffix:semicolon
r_int
id|tx_desc_used
suffix:semicolon
r_volatile
r_struct
id|eth_tx_desc
op_star
id|current_descriptor
suffix:semicolon
r_int
r_int
id|command_status
suffix:semicolon
multiline_comment|/* Do not process Tx ring in case of Tx ring resource error */
r_if
c_cond
(paren
id|mp-&gt;tx_resource_err
)paren
r_return
id|ETH_QUEUE_FULL
suffix:semicolon
multiline_comment|/* Get the Tx Desc ring indexes */
id|tx_desc_curr
op_assign
id|mp-&gt;tx_curr_desc_q
suffix:semicolon
id|tx_desc_used
op_assign
id|mp-&gt;tx_used_desc_q
suffix:semicolon
id|current_descriptor
op_assign
op_amp
id|mp-&gt;p_tx_desc_area
(braket
id|tx_desc_curr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|current_descriptor
op_eq
l_int|NULL
)paren
r_return
id|ETH_ERROR
suffix:semicolon
id|command_status
op_assign
id|p_pkt_info-&gt;cmd_sts
op_or
id|ETH_ZERO_PADDING
op_or
id|ETH_GEN_CRC
suffix:semicolon
multiline_comment|/* XXX Is this for real ?!?!? */
multiline_comment|/* Buffers with a payload smaller than 8 bytes must be aligned to a&n;&t; * 64-bit boundary. We use the memory allocated for Tx descriptor.&n;&t; * This memory is located in TX_BUF_OFFSET_IN_DESC offset within the&n;&t; * Tx descriptor. */
r_if
c_cond
(paren
id|p_pkt_info-&gt;byte_cnt
op_le
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;You have failed in the &lt; 8 bytes errata - fixme&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ETH_ERROR
suffix:semicolon
)brace
id|current_descriptor-&gt;buf_ptr
op_assign
id|p_pkt_info-&gt;buf_ptr
suffix:semicolon
id|current_descriptor-&gt;byte_cnt
op_assign
id|p_pkt_info-&gt;byte_cnt
suffix:semicolon
id|mp-&gt;tx_skb
(braket
id|tx_desc_curr
)braket
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|p_pkt_info-&gt;return_info
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Set last desc with DMA ownership and interrupt enable. */
id|current_descriptor-&gt;cmd_sts
op_assign
id|command_status
op_or
id|ETH_BUFFER_OWNED_BY_DMA
op_or
id|ETH_TX_ENABLE_INTERRUPT
suffix:semicolon
multiline_comment|/* Apply send command */
id|ETH_ENABLE_TX_QUEUE
c_func
(paren
id|mp-&gt;port_num
)paren
suffix:semicolon
multiline_comment|/* Finish Tx packet. Update first desc in case of Tx resource error */
id|tx_desc_curr
op_assign
(paren
id|tx_desc_curr
op_plus
l_int|1
)paren
op_mod
id|MV64340_TX_QUEUE_SIZE
suffix:semicolon
multiline_comment|/* Update the current descriptor */
id|mp-&gt;tx_curr_desc_q
op_assign
id|tx_desc_curr
suffix:semicolon
multiline_comment|/* Check for ring index overlap in the Tx desc ring */
r_if
c_cond
(paren
id|tx_desc_curr
op_eq
id|tx_desc_used
)paren
(brace
id|mp-&gt;tx_resource_err
op_assign
l_int|1
suffix:semicolon
r_return
id|ETH_QUEUE_LAST_RESOURCE
suffix:semicolon
)brace
r_return
id|ETH_OK
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * eth_tx_return_desc - Free all used Tx descriptors&n; *&n; * DESCRIPTION:&n; *&t;This routine returns the transmitted packet information to the caller.&n; *      It uses the &squot;first&squot; index to support Tx desc return in case a transmit &n; *      of a packet spanned over multiple buffer still in process.&n; *      In case the Tx queue was in &quot;resource error&quot; condition, where there are &n; *      no available Tx resources, the function resets the resource error flag.&n; *&n; * INPUT:&n; *&t;struct mv64340_private   *mp   Ethernet Port Control srtuct. &n; *&t;struct pkt_info        *p_pkt_info       User packet buffer.&n; *&n; * OUTPUT:&n; *&t;Tx ring &squot;first&squot; and &squot;used&squot; indexes are updated. &n; *&n; * RETURN:&n; *&t;ETH_ERROR in case the routine can not access Tx desc ring.&n; *      ETH_RETRY in case there is transmission in process.&n; *&t;ETH_END_OF_JOB if the routine has nothing to release.&n; *      ETH_OK otherwise.&n; *&n; */
DECL|function|eth_tx_return_desc
r_static
id|ETH_FUNC_RET_STATUS
id|eth_tx_return_desc
c_func
(paren
r_struct
id|mv64340_private
op_star
id|mp
comma
r_struct
id|pkt_info
op_star
id|p_pkt_info
)paren
(brace
r_int
id|tx_desc_used
comma
id|tx_desc_curr
suffix:semicolon
macro_line|#ifdef MV64340_CHECKSUM_OFFLOAD_TX
r_int
id|tx_first_desc
suffix:semicolon
macro_line|#endif
r_volatile
r_struct
id|eth_tx_desc
op_star
id|p_tx_desc_used
suffix:semicolon
r_int
r_int
id|command_status
suffix:semicolon
multiline_comment|/* Get the Tx Desc ring indexes */
id|tx_desc_curr
op_assign
id|mp-&gt;tx_curr_desc_q
suffix:semicolon
id|tx_desc_used
op_assign
id|mp-&gt;tx_used_desc_q
suffix:semicolon
macro_line|#ifdef MV64340_CHECKSUM_OFFLOAD_TX
id|tx_first_desc
op_assign
id|mp-&gt;tx_first_desc_q
suffix:semicolon
macro_line|#endif
id|p_tx_desc_used
op_assign
op_amp
id|mp-&gt;p_tx_desc_area
(braket
id|tx_desc_used
)braket
suffix:semicolon
multiline_comment|/* XXX Sanity check */
r_if
c_cond
(paren
id|p_tx_desc_used
op_eq
l_int|NULL
)paren
r_return
id|ETH_ERROR
suffix:semicolon
id|command_status
op_assign
id|p_tx_desc_used-&gt;cmd_sts
suffix:semicolon
multiline_comment|/* Still transmitting... */
macro_line|#ifndef MV64340_CHECKSUM_OFFLOAD_TX
r_if
c_cond
(paren
id|command_status
op_amp
(paren
id|ETH_BUFFER_OWNED_BY_DMA
)paren
)paren
r_return
id|ETH_RETRY
suffix:semicolon
macro_line|#endif
multiline_comment|/* Stop release. About to overlap the current available Tx descriptor */
macro_line|#ifdef MV64340_CHECKSUM_OFFLOAD_TX
r_if
c_cond
(paren
id|tx_desc_used
op_eq
id|tx_first_desc
op_logical_and
op_logical_neg
id|mp-&gt;tx_resource_err
)paren
r_return
id|ETH_END_OF_JOB
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|tx_desc_used
op_eq
id|tx_desc_curr
op_logical_and
op_logical_neg
id|mp-&gt;tx_resource_err
)paren
r_return
id|ETH_END_OF_JOB
suffix:semicolon
macro_line|#endif
multiline_comment|/* Pass the packet information to the caller */
id|p_pkt_info-&gt;cmd_sts
op_assign
id|command_status
suffix:semicolon
id|p_pkt_info-&gt;return_info
op_assign
id|mp-&gt;tx_skb
(braket
id|tx_desc_used
)braket
suffix:semicolon
id|mp-&gt;tx_skb
(braket
id|tx_desc_used
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Update the next descriptor to release. */
id|mp-&gt;tx_used_desc_q
op_assign
(paren
id|tx_desc_used
op_plus
l_int|1
)paren
op_mod
id|MV64340_TX_QUEUE_SIZE
suffix:semicolon
multiline_comment|/* Any Tx return cancels the Tx resource error status */
id|mp-&gt;tx_resource_err
op_assign
l_int|0
suffix:semicolon
r_return
id|ETH_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * eth_port_receive - Get received information from Rx ring.&n; *&n; * DESCRIPTION:&n; * &t;This routine returns the received data to the caller. There is no &n; *&t;data copying during routine operation. All information is returned &n; *&t;using pointer to packet information struct passed from the caller. &n; *      If the routine exhausts&t;Rx ring resources then the resource error flag &n; *      is set.  &n; *&n; * INPUT:&n; *&t;struct mv64340_private   *mp   Ethernet Port Control srtuct. &n; *&t;struct pkt_info        *p_pkt_info       User packet buffer.&n; *&n; * OUTPUT:&n; *&t;Rx ring current and used indexes are updated. &n; *&n; * RETURN:&n; *&t;ETH_ERROR in case the routine can not access Rx desc ring.&n; *&t;ETH_QUEUE_FULL if Rx ring resources are exhausted.&n; *&t;ETH_END_OF_JOB if there is no received data.&n; *      ETH_OK otherwise.&n; */
DECL|function|eth_port_receive
r_static
id|ETH_FUNC_RET_STATUS
id|eth_port_receive
c_func
(paren
r_struct
id|mv64340_private
op_star
id|mp
comma
r_struct
id|pkt_info
op_star
id|p_pkt_info
)paren
(brace
r_int
id|rx_next_curr_desc
comma
id|rx_curr_desc
comma
id|rx_used_desc
suffix:semicolon
r_volatile
r_struct
id|eth_rx_desc
op_star
id|p_rx_desc
suffix:semicolon
r_int
r_int
id|command_status
suffix:semicolon
multiline_comment|/* Do not process Rx ring in case of Rx ring resource error */
r_if
c_cond
(paren
id|mp-&gt;rx_resource_err
)paren
r_return
id|ETH_QUEUE_FULL
suffix:semicolon
multiline_comment|/* Get the Rx Desc ring &squot;curr and &squot;used&squot; indexes */
id|rx_curr_desc
op_assign
id|mp-&gt;rx_curr_desc_q
suffix:semicolon
id|rx_used_desc
op_assign
id|mp-&gt;rx_used_desc_q
suffix:semicolon
id|p_rx_desc
op_assign
op_amp
id|mp-&gt;p_rx_desc_area
(braket
id|rx_curr_desc
)braket
suffix:semicolon
multiline_comment|/* The following parameters are used to save readings from memory */
id|command_status
op_assign
id|p_rx_desc-&gt;cmd_sts
suffix:semicolon
multiline_comment|/* Nothing to receive... */
r_if
c_cond
(paren
id|command_status
op_amp
(paren
id|ETH_BUFFER_OWNED_BY_DMA
)paren
)paren
r_return
id|ETH_END_OF_JOB
suffix:semicolon
id|p_pkt_info-&gt;byte_cnt
op_assign
(paren
id|p_rx_desc-&gt;byte_cnt
)paren
op_minus
id|RX_BUF_OFFSET
suffix:semicolon
id|p_pkt_info-&gt;cmd_sts
op_assign
id|command_status
suffix:semicolon
id|p_pkt_info-&gt;buf_ptr
op_assign
(paren
id|p_rx_desc-&gt;buf_ptr
)paren
op_plus
id|RX_BUF_OFFSET
suffix:semicolon
id|p_pkt_info-&gt;return_info
op_assign
id|mp-&gt;rx_skb
(braket
id|rx_curr_desc
)braket
suffix:semicolon
id|p_pkt_info-&gt;l4i_chk
op_assign
id|p_rx_desc-&gt;buf_size
suffix:semicolon
multiline_comment|/* Clean the return info field to indicate that the packet has been */
multiline_comment|/* moved to the upper layers                                        */
id|mp-&gt;rx_skb
(braket
id|rx_curr_desc
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Update current index in data structure */
id|rx_next_curr_desc
op_assign
(paren
id|rx_curr_desc
op_plus
l_int|1
)paren
op_mod
id|MV64340_RX_QUEUE_SIZE
suffix:semicolon
id|mp-&gt;rx_curr_desc_q
op_assign
id|rx_next_curr_desc
suffix:semicolon
multiline_comment|/* Rx descriptors exhausted. Set the Rx ring resource error flag */
r_if
c_cond
(paren
id|rx_next_curr_desc
op_eq
id|rx_used_desc
)paren
id|mp-&gt;rx_resource_err
op_assign
l_int|1
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_return
id|ETH_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * eth_rx_return_buff - Returns a Rx buffer back to the Rx ring.&n; *&n; * DESCRIPTION:&n; *&t;This routine returns a Rx buffer back to the Rx ring. It retrieves the &n; *      next &squot;used&squot; descriptor and attached the returned buffer to it.&n; *      In case the Rx ring was in &quot;resource error&quot; condition, where there are &n; *      no available Rx resources, the function resets the resource error flag.&n; *&n; * INPUT:&n; *&t;struct mv64340_private *mp   Ethernet Port Control srtuct. &n; *      struct pkt_info        *p_pkt_info   Information on the returned buffer.&n; *&n; * OUTPUT:&n; *&t;New available Rx resource in Rx descriptor ring.&n; *&n; * RETURN:&n; *&t;ETH_ERROR in case the routine can not access Rx desc ring.&n; *      ETH_OK otherwise.&n; */
DECL|function|eth_rx_return_buff
r_static
id|ETH_FUNC_RET_STATUS
id|eth_rx_return_buff
c_func
(paren
r_struct
id|mv64340_private
op_star
id|mp
comma
r_struct
id|pkt_info
op_star
id|p_pkt_info
)paren
(brace
r_int
id|used_rx_desc
suffix:semicolon
multiline_comment|/* Where to return Rx resource */
r_volatile
r_struct
id|eth_rx_desc
op_star
id|p_used_rx_desc
suffix:semicolon
multiline_comment|/* Get &squot;used&squot; Rx descriptor */
id|used_rx_desc
op_assign
id|mp-&gt;rx_used_desc_q
suffix:semicolon
id|p_used_rx_desc
op_assign
op_amp
id|mp-&gt;p_rx_desc_area
(braket
id|used_rx_desc
)braket
suffix:semicolon
id|p_used_rx_desc-&gt;buf_ptr
op_assign
id|p_pkt_info-&gt;buf_ptr
suffix:semicolon
id|p_used_rx_desc-&gt;buf_size
op_assign
id|p_pkt_info-&gt;byte_cnt
suffix:semicolon
id|mp-&gt;rx_skb
(braket
id|used_rx_desc
)braket
op_assign
id|p_pkt_info-&gt;return_info
suffix:semicolon
multiline_comment|/* Flush the write pipe */
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Return the descriptor to DMA ownership */
id|p_used_rx_desc-&gt;cmd_sts
op_assign
id|ETH_BUFFER_OWNED_BY_DMA
op_or
id|ETH_RX_ENABLE_INTERRUPT
suffix:semicolon
multiline_comment|/* Flush descriptor and CPU pipe */
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Move the used descriptor pointer to the next descriptor */
id|mp-&gt;rx_used_desc_q
op_assign
(paren
id|used_rx_desc
op_plus
l_int|1
)paren
op_mod
id|MV64340_RX_QUEUE_SIZE
suffix:semicolon
multiline_comment|/* Any Rx return cancels the Rx resource error status */
id|mp-&gt;rx_resource_err
op_assign
l_int|0
suffix:semicolon
r_return
id|ETH_OK
suffix:semicolon
)brace
eof
