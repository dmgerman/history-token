multiline_comment|/*****************************************************************************&n;*&n;* Filename:      stir4200.c&n;* Version:       0.4&n;* Description:   Irda SigmaTel USB Dongle&n;* Status:        Experimental&n;* Author:        Stephen Hemminger &lt;shemminger@osdl.org&gt;&n;*&n;*  &t;Based on earlier driver by Paul Stewart &lt;stewart@parc.com&gt;&n;*&n;*&t;Copyright (C) 2000, Roman Weissgaerber &lt;weissg@vienna.at&gt;&n;*&t;Copyright (C) 2001, Dag Brattli &lt;dag@brattli.net&gt;&n;*&t;Copyright (C) 2001, Jean Tourrilhes &lt;jt@hpl.hp.com&gt;&n;*&t;Copyright (C) 2004, Stephen Hemminger &lt;shemminger@osdl.org&gt;&n;*&n;*&t;This program is free software; you can redistribute it and/or modify&n;*&t;it under the terms of the GNU General Public License as published by&n;*&t;the Free Software Foundation; either version 2 of the License, or&n;*&t;(at your option) any later version.&n;*&n;*&t;This program is distributed in the hope that it will be useful,&n;*&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n;*&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;*&t;GNU General Public License for more details.&n;*&n;*&t;You should have received a copy of the GNU General Public License&n;*&t;along with this program; if not, write to the Free Software&n;*&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;*&n;*****************************************************************************/
multiline_comment|/*&n; * This dongle does no framing, and requires polling to receive the&n; * data.  The STIr4200 has bulk in and out endpoints just like&n; * usr-irda devices, but the data it sends and receives is raw; like&n; * irtty, it needs to call the wrap and unwrap functions to add and&n; * remove SOF/BOF and escape characters to/from the frame.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/irda_device.h&gt;
macro_line|#include &lt;net/irda/wrapper.h&gt;
macro_line|#include &lt;net/irda/crc.h&gt;
macro_line|#include &lt;linux/crc32.h&gt;
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Stephen Hemminger &lt;shemminger@osdl.org&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;IrDA-USB Dongle Driver for SigmaTel STIr4200&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|qos_mtt_bits
r_static
r_int
id|qos_mtt_bits
op_assign
l_int|0x07
suffix:semicolon
multiline_comment|/* 1 ms or more */
id|module_param
c_func
(paren
id|qos_mtt_bits
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|qos_mtt_bits
comma
l_string|&quot;Minimum Turn Time&quot;
)paren
suffix:semicolon
DECL|variable|rx_sensitivity
r_static
r_int
id|rx_sensitivity
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* FIR 0..4, SIR 0..6 */
id|module_param
c_func
(paren
id|rx_sensitivity
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|rx_sensitivity
comma
l_string|&quot;Set Receiver sensitivity (0-6, 0 is most sensitive)&quot;
)paren
suffix:semicolon
DECL|variable|tx_power
r_static
r_int
id|tx_power
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0 = highest ... 3 = lowest */
id|module_param
c_func
(paren
id|tx_power
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|tx_power
comma
l_string|&quot;Set Transmitter power (0-3, 0 is highest power)&quot;
)paren
suffix:semicolon
DECL|variable|rx_interval
r_static
r_int
id|rx_interval
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* milliseconds */
id|module_param
c_func
(paren
id|rx_interval
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|rx_interval
comma
l_string|&quot;Receive polling interval (ms)&quot;
)paren
suffix:semicolon
DECL|macro|STIR_IRDA_HEADER
mdefine_line|#define STIR_IRDA_HEADER  &t;4
DECL|macro|CTRL_TIMEOUT
mdefine_line|#define CTRL_TIMEOUT&t;&t;100&t;   /* milliseconds */
DECL|macro|TRANSMIT_TIMEOUT
mdefine_line|#define TRANSMIT_TIMEOUT&t;200&t;   /* milliseconds */
DECL|macro|STIR_FIFO_SIZE
mdefine_line|#define STIR_FIFO_SIZE&t;&t;4096
DECL|macro|NUM_RX_URBS
mdefine_line|#define NUM_RX_URBS&t;&t;2
DECL|enum|FirChars
r_enum
id|FirChars
(brace
DECL|enumerator|FIR_CE
id|FIR_CE
op_assign
l_int|0x7d
comma
DECL|enumerator|FIR_XBOF
id|FIR_XBOF
op_assign
l_int|0x7f
comma
DECL|enumerator|FIR_EOF
id|FIR_EOF
op_assign
l_int|0x7e
comma
)brace
suffix:semicolon
DECL|enum|StirRequests
r_enum
id|StirRequests
(brace
DECL|enumerator|REQ_WRITE_REG
id|REQ_WRITE_REG
op_assign
l_int|0x00
comma
DECL|enumerator|REQ_READ_REG
id|REQ_READ_REG
op_assign
l_int|0x01
comma
DECL|enumerator|REQ_READ_ROM
id|REQ_READ_ROM
op_assign
l_int|0x02
comma
DECL|enumerator|REQ_WRITE_SINGLE
id|REQ_WRITE_SINGLE
op_assign
l_int|0x03
comma
)brace
suffix:semicolon
multiline_comment|/* Register offsets */
DECL|enum|StirRegs
r_enum
id|StirRegs
(brace
DECL|enumerator|REG_RSVD
id|REG_RSVD
op_assign
l_int|0
comma
DECL|enumerator|REG_MODE
id|REG_MODE
comma
DECL|enumerator|REG_PDCLK
id|REG_PDCLK
comma
DECL|enumerator|REG_CTRL1
id|REG_CTRL1
comma
DECL|enumerator|REG_CTRL2
id|REG_CTRL2
comma
DECL|enumerator|REG_FIFOCTL
id|REG_FIFOCTL
comma
DECL|enumerator|REG_FIFOLSB
id|REG_FIFOLSB
comma
DECL|enumerator|REG_FIFOMSB
id|REG_FIFOMSB
comma
DECL|enumerator|REG_DPLL
id|REG_DPLL
comma
DECL|enumerator|REG_IRDIG
id|REG_IRDIG
comma
DECL|enumerator|REG_TEST
id|REG_TEST
op_assign
l_int|15
comma
)brace
suffix:semicolon
DECL|enum|StirModeMask
r_enum
id|StirModeMask
(brace
DECL|enumerator|MODE_FIR
id|MODE_FIR
op_assign
l_int|0x80
comma
DECL|enumerator|MODE_SIR
id|MODE_SIR
op_assign
l_int|0x20
comma
DECL|enumerator|MODE_ASK
id|MODE_ASK
op_assign
l_int|0x10
comma
DECL|enumerator|MODE_FASTRX
id|MODE_FASTRX
op_assign
l_int|0x08
comma
DECL|enumerator|MODE_FFRSTEN
id|MODE_FFRSTEN
op_assign
l_int|0x04
comma
DECL|enumerator|MODE_NRESET
id|MODE_NRESET
op_assign
l_int|0x02
comma
DECL|enumerator|MODE_2400
id|MODE_2400
op_assign
l_int|0x01
comma
)brace
suffix:semicolon
DECL|enum|StirPdclkMask
r_enum
id|StirPdclkMask
(brace
DECL|enumerator|PDCLK_4000000
id|PDCLK_4000000
op_assign
l_int|0x02
comma
DECL|enumerator|PDCLK_115200
id|PDCLK_115200
op_assign
l_int|0x09
comma
DECL|enumerator|PDCLK_57600
id|PDCLK_57600
op_assign
l_int|0x13
comma
DECL|enumerator|PDCLK_38400
id|PDCLK_38400
op_assign
l_int|0x1D
comma
DECL|enumerator|PDCLK_19200
id|PDCLK_19200
op_assign
l_int|0x3B
comma
DECL|enumerator|PDCLK_9600
id|PDCLK_9600
op_assign
l_int|0x77
comma
DECL|enumerator|PDCLK_2400
id|PDCLK_2400
op_assign
l_int|0xDF
comma
)brace
suffix:semicolon
DECL|enum|StirCtrl1Mask
r_enum
id|StirCtrl1Mask
(brace
DECL|enumerator|CTRL1_SDMODE
id|CTRL1_SDMODE
op_assign
l_int|0x80
comma
DECL|enumerator|CTRL1_RXSLOW
id|CTRL1_RXSLOW
op_assign
l_int|0x40
comma
DECL|enumerator|CTRL1_TXPWD
id|CTRL1_TXPWD
op_assign
l_int|0x10
comma
DECL|enumerator|CTRL1_RXPWD
id|CTRL1_RXPWD
op_assign
l_int|0x08
comma
DECL|enumerator|CTRL1_SRESET
id|CTRL1_SRESET
op_assign
l_int|0x01
comma
)brace
suffix:semicolon
DECL|enum|StirCtrl2Mask
r_enum
id|StirCtrl2Mask
(brace
DECL|enumerator|CTRL2_SPWIDTH
id|CTRL2_SPWIDTH
op_assign
l_int|0x08
comma
DECL|enumerator|CTRL2_REVID
id|CTRL2_REVID
op_assign
l_int|0x03
comma
)brace
suffix:semicolon
DECL|enum|StirFifoCtlMask
r_enum
id|StirFifoCtlMask
(brace
DECL|enumerator|FIFOCTL_EOF
id|FIFOCTL_EOF
op_assign
l_int|0x80
comma
DECL|enumerator|FIFOCTL_UNDER
id|FIFOCTL_UNDER
op_assign
l_int|0x40
comma
DECL|enumerator|FIFOCTL_OVER
id|FIFOCTL_OVER
op_assign
l_int|0x20
comma
DECL|enumerator|FIFOCTL_DIR
id|FIFOCTL_DIR
op_assign
l_int|0x10
comma
DECL|enumerator|FIFOCTL_CLR
id|FIFOCTL_CLR
op_assign
l_int|0x08
comma
DECL|enumerator|FIFOCTL_EMPTY
id|FIFOCTL_EMPTY
op_assign
l_int|0x04
comma
DECL|enumerator|FIFOCTL_RXERR
id|FIFOCTL_RXERR
op_assign
l_int|0x02
comma
DECL|enumerator|FIFOCTL_TXERR
id|FIFOCTL_TXERR
op_assign
l_int|0x01
comma
)brace
suffix:semicolon
DECL|enum|StirDiagMask
r_enum
id|StirDiagMask
(brace
DECL|enumerator|IRDIG_RXHIGH
id|IRDIG_RXHIGH
op_assign
l_int|0x80
comma
DECL|enumerator|IRDIG_RXLOW
id|IRDIG_RXLOW
op_assign
l_int|0x40
comma
)brace
suffix:semicolon
DECL|enum|StirTestMask
r_enum
id|StirTestMask
(brace
DECL|enumerator|TEST_PLLDOWN
id|TEST_PLLDOWN
op_assign
l_int|0x80
comma
DECL|enumerator|TEST_LOOPIR
id|TEST_LOOPIR
op_assign
l_int|0x40
comma
DECL|enumerator|TEST_LOOPUSB
id|TEST_LOOPUSB
op_assign
l_int|0x20
comma
DECL|enumerator|TEST_TSTENA
id|TEST_TSTENA
op_assign
l_int|0x10
comma
DECL|enumerator|TEST_TSTOSC
id|TEST_TSTOSC
op_assign
l_int|0x0F
comma
)brace
suffix:semicolon
DECL|enum|StirState
r_enum
id|StirState
(brace
DECL|enumerator|STIR_STATE_RECEIVING
id|STIR_STATE_RECEIVING
op_assign
l_int|0
comma
DECL|enumerator|STIR_STATE_TXREADY
id|STIR_STATE_TXREADY
comma
)brace
suffix:semicolon
DECL|struct|stir_cb
r_struct
id|stir_cb
(brace
DECL|member|usbdev
r_struct
id|usb_device
op_star
id|usbdev
suffix:semicolon
multiline_comment|/* init: probe_irda */
DECL|member|netdev
r_struct
id|net_device
op_star
id|netdev
suffix:semicolon
multiline_comment|/* network layer */
DECL|member|irlap
r_struct
id|irlap_cb
op_star
id|irlap
suffix:semicolon
multiline_comment|/* The link layer we are binded to */
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
multiline_comment|/* network statistics */
DECL|member|qos
r_struct
id|qos_info
id|qos
suffix:semicolon
DECL|member|state
r_int
r_int
id|state
suffix:semicolon
DECL|member|speed
r_int
id|speed
suffix:semicolon
multiline_comment|/* Current speed */
DECL|member|thr_wait
id|wait_queue_head_t
id|thr_wait
suffix:semicolon
multiline_comment|/* transmit thread wakeup */
DECL|member|thr_exited
r_struct
id|completion
id|thr_exited
suffix:semicolon
DECL|member|thr_pid
id|pid_t
id|thr_pid
suffix:semicolon
DECL|member|tx_bulkpipe
r_int
r_int
id|tx_bulkpipe
suffix:semicolon
DECL|member|tx_data
r_void
op_star
id|tx_data
suffix:semicolon
multiline_comment|/* wrapped data out */
DECL|member|tx_len
r_int
id|tx_len
suffix:semicolon
DECL|member|tx_newspeed
r_int
id|tx_newspeed
suffix:semicolon
DECL|member|tx_mtt
r_int
id|tx_mtt
suffix:semicolon
DECL|member|rx_intpipe
r_int
r_int
id|rx_intpipe
suffix:semicolon
DECL|member|rx_buff
id|iobuff_t
id|rx_buff
suffix:semicolon
multiline_comment|/* receive unwrap state machine */
DECL|member|rx_time
r_struct
id|timespec
id|rx_time
suffix:semicolon
DECL|member|rx_urbs
r_struct
id|urb
op_star
id|rx_urbs
(braket
id|NUM_RX_URBS
)braket
suffix:semicolon
DECL|member|rx_data
r_void
op_star
id|rx_data
(braket
id|NUM_RX_URBS
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* These are the currently known USB ids */
DECL|variable|dongles
r_static
r_struct
id|usb_device_id
id|dongles
(braket
)braket
op_assign
(brace
multiline_comment|/* SigmaTel, Inc,  STIr4200 IrDA/USB Bridge */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x066f
comma
l_int|0x4200
)paren
)brace
comma
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|usb
comma
id|dongles
)paren
suffix:semicolon
r_static
r_int
id|fifo_txwait
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
comma
r_int
id|space
)paren
suffix:semicolon
r_static
r_void
id|stir_usb_receive
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/* Send control message to set dongle register */
DECL|function|write_reg
r_static
r_int
id|write_reg
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
comma
id|__u16
id|reg
comma
id|__u8
id|value
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|stir-&gt;usbdev
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;%s: write reg %d = 0x%x&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|reg
comma
id|value
)paren
suffix:semicolon
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|REQ_WRITE_SINGLE
comma
id|USB_DIR_OUT
op_or
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_DEVICE
comma
id|value
comma
id|reg
comma
l_int|NULL
comma
l_int|0
comma
id|MSECS_TO_JIFFIES
c_func
(paren
id|CTRL_TIMEOUT
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Send control message to read multiple registers */
DECL|function|read_reg
r_static
r_inline
r_int
id|read_reg
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
comma
id|__u16
id|reg
comma
id|__u8
op_star
id|data
comma
id|__u16
id|count
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|stir-&gt;usbdev
suffix:semicolon
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|REQ_READ_REG
comma
id|USB_DIR_IN
op_or
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_DEVICE
comma
l_int|0
comma
id|reg
comma
id|data
comma
id|count
comma
id|MSECS_TO_JIFFIES
c_func
(paren
id|CTRL_TIMEOUT
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare a FIR IrDA frame for transmission to the USB dongle.  The&n; * FIR transmit frame is documented in the datasheet.  It consists of&n; * a two byte 0x55 0xAA sequence, two little-endian length bytes, a&n; * sequence of exactly 16 XBOF bytes of 0x7E, two BOF bytes of 0x7E,&n; * then the data escaped as follows:&n; *&n; *    0x7D -&gt; 0x7D 0x5D&n; *    0x7E -&gt; 0x7D 0x5E&n; *    0x7F -&gt; 0x7D 0x5F&n; *&n; * Then, 4 bytes of little endian (stuffed) FCS follow, then two&n; * trailing EOF bytes of 0x7E.&n; */
DECL|function|stuff_fir
r_static
r_inline
id|__u8
op_star
id|stuff_fir
c_func
(paren
id|__u8
op_star
id|p
comma
id|__u8
id|c
)paren
(brace
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_int|0x7d
suffix:colon
r_case
l_int|0x7e
suffix:colon
r_case
l_int|0x7f
suffix:colon
op_star
id|p
op_increment
op_assign
l_int|0x7d
suffix:semicolon
id|c
op_xor_assign
id|IRDA_TRANS
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/* Take raw data in skb and put it wrapped into buf */
DECL|function|wrap_fir_skb
r_static
r_int
id|wrap_fir_skb
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
id|__u8
op_star
id|buf
)paren
(brace
id|__u8
op_star
id|ptr
op_assign
id|buf
suffix:semicolon
id|__u32
id|fcs
op_assign
op_complement
(paren
id|crc32_le
c_func
(paren
op_complement
l_int|0
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
)paren
suffix:semicolon
id|__u16
id|wraplen
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Header */
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0x55
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
l_int|0xAA
suffix:semicolon
id|ptr
op_assign
id|buf
op_plus
id|STIR_IRDA_HEADER
suffix:semicolon
id|memset
c_func
(paren
id|ptr
comma
l_int|0x7f
comma
l_int|16
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|16
suffix:semicolon
multiline_comment|/* BOF */
op_star
id|ptr
op_increment
op_assign
l_int|0x7e
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_int|0x7e
suffix:semicolon
multiline_comment|/* Address / Control / Information */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
id|ptr
op_assign
id|stuff_fir
c_func
(paren
id|ptr
comma
id|skb-&gt;data
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* FCS */
id|ptr
op_assign
id|stuff_fir
c_func
(paren
id|ptr
comma
id|fcs
op_amp
l_int|0xff
)paren
suffix:semicolon
id|ptr
op_assign
id|stuff_fir
c_func
(paren
id|ptr
comma
(paren
id|fcs
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|ptr
op_assign
id|stuff_fir
c_func
(paren
id|ptr
comma
(paren
id|fcs
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|ptr
op_assign
id|stuff_fir
c_func
(paren
id|ptr
comma
(paren
id|fcs
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* EOFs */
op_star
id|ptr
op_increment
op_assign
l_int|0x7e
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_int|0x7e
suffix:semicolon
multiline_comment|/* Total length, minus the header */
id|wraplen
op_assign
(paren
id|ptr
op_minus
id|buf
)paren
op_minus
id|STIR_IRDA_HEADER
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|wraplen
op_amp
l_int|0xff
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
(paren
id|wraplen
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_return
id|wraplen
op_plus
id|STIR_IRDA_HEADER
suffix:semicolon
)brace
DECL|function|wrap_sir_skb
r_static
r_int
id|wrap_sir_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|__u8
op_star
id|buf
)paren
(brace
id|__u16
id|wraplen
suffix:semicolon
id|wraplen
op_assign
id|async_wrap_skb
c_func
(paren
id|skb
comma
id|buf
op_plus
id|STIR_IRDA_HEADER
comma
id|STIR_FIFO_SIZE
op_minus
id|STIR_IRDA_HEADER
)paren
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0x55
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
l_int|0xAA
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|wraplen
op_amp
l_int|0xff
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
(paren
id|wraplen
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_return
id|wraplen
op_plus
id|STIR_IRDA_HEADER
suffix:semicolon
)brace
multiline_comment|/*&n; * Frame is fully formed in the rx_buff so check crc&n; * and pass up to irlap&n; * setup for next receive&n; */
DECL|function|fir_eof
r_static
r_void
id|fir_eof
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
)paren
(brace
id|iobuff_t
op_star
id|rx_buff
op_assign
op_amp
id|stir-&gt;rx_buff
suffix:semicolon
r_int
id|len
op_assign
id|rx_buff-&gt;len
op_minus
l_int|4
suffix:semicolon
id|__u32
id|fcs
suffix:semicolon
r_struct
id|sk_buff
op_star
id|nskb
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|len
op_le
l_int|0
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;%s: short frame len %d&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|len
)paren
suffix:semicolon
op_increment
id|stir-&gt;stats.rx_errors
suffix:semicolon
op_increment
id|stir-&gt;stats.rx_length_errors
suffix:semicolon
r_return
suffix:semicolon
)brace
id|fcs
op_assign
id|rx_buff-&gt;data
(braket
id|len
)braket
op_or
id|rx_buff-&gt;data
(braket
id|len
op_plus
l_int|1
)braket
op_lshift
l_int|8
op_or
id|rx_buff-&gt;data
(braket
id|len
op_plus
l_int|2
)braket
op_lshift
l_int|16
op_or
id|rx_buff-&gt;data
(braket
id|len
op_plus
l_int|3
)braket
op_lshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|fcs
op_ne
op_complement
(paren
id|crc32_le
c_func
(paren
op_complement
l_int|0
comma
id|rx_buff-&gt;data
comma
id|len
)paren
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;%s: crc error&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
)paren
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|stir-&gt;netdev
comma
id|TRUE
)paren
suffix:semicolon
id|stir-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|stir-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If can&squot;t get new buffer, just drop and reuse */
id|nskb
op_assign
id|dev_alloc_skb
c_func
(paren
id|IRDA_SKB_MAX_MTU
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|nskb
)paren
)paren
op_increment
id|stir-&gt;stats.rx_dropped
suffix:semicolon
r_else
(brace
r_struct
id|sk_buff
op_star
id|oskb
op_assign
id|rx_buff-&gt;skb
suffix:semicolon
id|skb_reserve
c_func
(paren
id|nskb
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Set correct length in socket buffer */
id|skb_put
c_func
(paren
id|oskb
comma
id|len
)paren
suffix:semicolon
id|oskb-&gt;mac.raw
op_assign
id|oskb-&gt;data
suffix:semicolon
id|oskb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IRDA
)paren
suffix:semicolon
id|oskb-&gt;dev
op_assign
id|stir-&gt;netdev
suffix:semicolon
id|netif_rx
c_func
(paren
id|oskb
)paren
suffix:semicolon
id|stir-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|stir-&gt;stats.rx_bytes
op_add_assign
id|len
suffix:semicolon
id|rx_buff-&gt;skb
op_assign
id|nskb
suffix:semicolon
id|rx_buff-&gt;head
op_assign
id|nskb-&gt;data
suffix:semicolon
)brace
id|rx_buff-&gt;data
op_assign
id|rx_buff-&gt;head
suffix:semicolon
id|rx_buff-&gt;len
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Unwrap FIR stuffed data and bump it to IrLAP */
DECL|function|stir_fir_chars
r_static
r_void
id|stir_fir_chars
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
comma
r_const
id|__u8
op_star
id|bytes
comma
r_int
id|len
)paren
(brace
id|iobuff_t
op_star
id|rx_buff
op_assign
op_amp
id|stir-&gt;rx_buff
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|__u8
id|byte
op_assign
id|bytes
(braket
id|i
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|rx_buff-&gt;state
)paren
(brace
r_case
id|OUTSIDE_FRAME
suffix:colon
multiline_comment|/* ignore garbage till start of frame */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|byte
op_ne
id|FIR_EOF
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Now receiving frame */
id|rx_buff-&gt;state
op_assign
id|BEGIN_FRAME
suffix:semicolon
id|rx_buff-&gt;in_frame
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Time to initialize receive buffer */
id|rx_buff-&gt;data
op_assign
id|rx_buff-&gt;head
suffix:semicolon
id|rx_buff-&gt;len
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|LINK_ESCAPE
suffix:colon
r_if
c_cond
(paren
id|byte
op_eq
id|FIR_EOF
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;%s: got EOF after escape&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
)paren
suffix:semicolon
r_goto
id|frame_error
suffix:semicolon
)brace
id|rx_buff-&gt;state
op_assign
id|INSIDE_FRAME
suffix:semicolon
id|byte
op_xor_assign
id|IRDA_TRANS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BEGIN_FRAME
suffix:colon
multiline_comment|/* ignore multiple BOF/EOF */
r_if
c_cond
(paren
id|byte
op_eq
id|FIR_EOF
)paren
r_continue
suffix:semicolon
id|rx_buff-&gt;state
op_assign
id|INSIDE_FRAME
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|INSIDE_FRAME
suffix:colon
r_switch
c_cond
(paren
id|byte
)paren
(brace
r_case
id|FIR_CE
suffix:colon
id|rx_buff-&gt;state
op_assign
id|LINK_ESCAPE
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|FIR_XBOF
suffix:colon
multiline_comment|/* 0x7f is not used in this framing */
id|pr_debug
c_func
(paren
l_string|&quot;%s: got XBOF without escape&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
)paren
suffix:semicolon
r_goto
id|frame_error
suffix:semicolon
r_case
id|FIR_EOF
suffix:colon
id|rx_buff-&gt;state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|rx_buff-&gt;in_frame
op_assign
id|FALSE
suffix:semicolon
id|fir_eof
c_func
(paren
id|stir
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* add byte to rx buffer */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|rx_buff-&gt;len
op_ge
id|rx_buff-&gt;truesize
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;%s: fir frame exceeds %d&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|rx_buff-&gt;truesize
)paren
suffix:semicolon
op_increment
id|stir-&gt;stats.rx_over_errors
suffix:semicolon
r_goto
id|error_recovery
suffix:semicolon
)brace
id|rx_buff-&gt;data
(braket
id|rx_buff-&gt;len
op_increment
)braket
op_assign
id|byte
suffix:semicolon
r_continue
suffix:semicolon
id|frame_error
suffix:colon
op_increment
id|stir-&gt;stats.rx_frame_errors
suffix:semicolon
id|error_recovery
suffix:colon
op_increment
id|stir-&gt;stats.rx_errors
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|stir-&gt;netdev
comma
id|TRUE
)paren
suffix:semicolon
id|rx_buff-&gt;state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|rx_buff-&gt;in_frame
op_assign
id|FALSE
suffix:semicolon
)brace
)brace
multiline_comment|/* Unwrap SIR stuffed data and bump it up to IrLAP */
DECL|function|stir_sir_chars
r_static
r_void
id|stir_sir_chars
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
comma
r_const
id|__u8
op_star
id|bytes
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|async_unwrap_char
c_func
(paren
id|stir-&gt;netdev
comma
op_amp
id|stir-&gt;stats
comma
op_amp
id|stir-&gt;rx_buff
comma
id|bytes
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|isfir
r_static
r_inline
r_int
id|isfir
c_func
(paren
id|u32
id|speed
)paren
(brace
r_return
(paren
id|speed
op_eq
l_int|4000000
)paren
suffix:semicolon
)brace
DECL|function|unwrap_chars
r_static
r_inline
r_void
id|unwrap_chars
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
comma
r_const
id|__u8
op_star
id|bytes
comma
r_int
id|length
)paren
(brace
r_if
c_cond
(paren
id|isfir
c_func
(paren
id|stir-&gt;speed
)paren
)paren
id|stir_fir_chars
c_func
(paren
id|stir
comma
id|bytes
comma
id|length
)paren
suffix:semicolon
r_else
id|stir_sir_chars
c_func
(paren
id|stir
comma
id|bytes
comma
id|length
)paren
suffix:semicolon
)brace
multiline_comment|/* Mode parameters for each speed */
r_static
r_const
r_struct
(brace
DECL|member|speed
r_int
id|speed
suffix:semicolon
DECL|member|pdclk
id|__u8
id|pdclk
suffix:semicolon
DECL|variable|stir_modes
)brace
id|stir_modes
(braket
)braket
op_assign
(brace
(brace
l_int|2400
comma
id|PDCLK_2400
)brace
comma
(brace
l_int|9600
comma
id|PDCLK_9600
)brace
comma
(brace
l_int|19200
comma
id|PDCLK_19200
)brace
comma
(brace
l_int|38400
comma
id|PDCLK_38400
)brace
comma
(brace
l_int|57600
comma
id|PDCLK_57600
)brace
comma
(brace
l_int|115200
comma
id|PDCLK_115200
)brace
comma
(brace
l_int|4000000
comma
id|PDCLK_4000000
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Setup chip for speed.&n; *  Called at startup to initialize the chip&n; *  and on speed changes.&n; *&n; * Note: Write multiple registers doesn&squot;t appear to work&n; */
DECL|function|change_speed
r_static
r_int
id|change_speed
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
comma
r_int
id|speed
)paren
(brace
r_int
id|i
comma
id|err
suffix:semicolon
id|__u8
id|mode
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;%s: change speed %d&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|speed
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|stir_modes
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|speed
op_eq
id|stir_modes
(braket
id|i
)braket
dot
id|speed
)paren
r_goto
id|found
suffix:semicolon
)brace
id|ERROR
c_func
(paren
l_string|&quot;%s: invalid speed %d&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|speed
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
id|found
suffix:colon
id|pr_debug
c_func
(paren
l_string|&quot;%s: speed change from %d to %d&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|stir-&gt;speed
comma
id|speed
)paren
suffix:semicolon
multiline_comment|/* Make sure any previous Tx is really finished. This happens&n;&t; * when we answer an incomming request ; the ua:rsp and the&n;&t; * speed change are bundled together, so we need to wait until&n;&t; * the packet we just submitted has been sent. Jean II */
r_if
c_cond
(paren
id|fifo_txwait
c_func
(paren
id|stir
comma
l_int|0
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Set clock */
id|err
op_assign
id|write_reg
c_func
(paren
id|stir
comma
id|REG_PDCLK
comma
id|stir_modes
(braket
id|i
)braket
dot
id|pdclk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|mode
op_assign
id|MODE_NRESET
op_or
id|MODE_FASTRX
suffix:semicolon
r_if
c_cond
(paren
id|isfir
c_func
(paren
id|speed
)paren
)paren
id|mode
op_or_assign
id|MODE_FIR
op_or
id|MODE_FFRSTEN
suffix:semicolon
r_else
id|mode
op_or_assign
id|MODE_SIR
suffix:semicolon
r_if
c_cond
(paren
id|speed
op_eq
l_int|2400
)paren
id|mode
op_or_assign
id|MODE_2400
suffix:semicolon
id|err
op_assign
id|write_reg
c_func
(paren
id|stir
comma
id|REG_MODE
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* This resets TEMIC style transceiver if any. */
id|err
op_assign
id|write_reg
c_func
(paren
id|stir
comma
id|REG_CTRL1
comma
id|CTRL1_SDMODE
op_or
(paren
id|tx_power
op_amp
l_int|3
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|write_reg
c_func
(paren
id|stir
comma
id|REG_CTRL1
comma
(paren
id|tx_power
op_amp
l_int|3
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
id|out
suffix:colon
id|stir-&gt;speed
op_assign
id|speed
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|stir_reset
r_static
r_int
id|stir_reset
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* reset state */
id|stir-&gt;rx_buff.in_frame
op_assign
id|FALSE
suffix:semicolon
id|stir-&gt;rx_buff.state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|stir-&gt;speed
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Undocumented magic to tweak the DPLL */
id|err
op_assign
id|write_reg
c_func
(paren
id|stir
comma
id|REG_DPLL
comma
l_int|0x15
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Reset sensitivity */
id|err
op_assign
id|write_reg
c_func
(paren
id|stir
comma
id|REG_CTRL2
comma
(paren
id|rx_sensitivity
op_amp
l_int|7
)paren
op_lshift
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|change_speed
c_func
(paren
id|stir
comma
l_int|9600
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from net/core when new frame is available.&n; */
DECL|function|stir_hard_xmit
r_static
r_int
id|stir_hard_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|netdev
)paren
(brace
r_struct
id|stir_cb
op_star
id|stir
op_assign
id|netdev-&gt;priv
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|netdev
)paren
suffix:semicolon
multiline_comment|/* the IRDA wrapping routines don&squot;t deal with non linear skb */
id|SKB_LINEAR_ASSERT
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|skb-&gt;len
)paren
op_eq
l_int|0
)paren
multiline_comment|/* speed change only */
id|stir-&gt;tx_len
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|isfir
c_func
(paren
id|stir-&gt;speed
)paren
)paren
id|stir-&gt;tx_len
op_assign
id|wrap_fir_skb
c_func
(paren
id|skb
comma
id|stir-&gt;tx_data
)paren
suffix:semicolon
r_else
id|stir-&gt;tx_len
op_assign
id|wrap_sir_skb
c_func
(paren
id|skb
comma
id|stir-&gt;tx_data
)paren
suffix:semicolon
id|stir-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|stir-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|stir-&gt;tx_mtt
op_assign
id|irda_get_mtt
c_func
(paren
id|skb
)paren
suffix:semicolon
id|stir-&gt;tx_newspeed
op_assign
id|irda_get_next_speed
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|STIR_STATE_TXREADY
comma
op_amp
id|stir-&gt;state
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|stir-&gt;thr_wait
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for the transmit FIFO to have space for next data&n; */
DECL|function|fifo_txwait
r_static
r_int
id|fifo_txwait
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
comma
r_int
id|space
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|count
suffix:semicolon
id|__u8
id|regs
(braket
l_int|3
)braket
suffix:semicolon
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Read FIFO status and count */
id|err
op_assign
id|read_reg
c_func
(paren
id|stir
comma
id|REG_FIFOCTL
comma
id|regs
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
op_ne
l_int|3
)paren
)paren
(brace
id|WARNING
c_func
(paren
l_string|&quot;%s: FIFO register read error: %d&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* is fifo receiving already, or empty */
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs
(braket
l_int|0
)braket
op_amp
id|FIFOCTL_DIR
)paren
op_logical_or
(paren
id|regs
(braket
l_int|0
)braket
op_amp
id|FIFOCTL_EMPTY
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
multiline_comment|/* shutting down? */
r_if
c_cond
(paren
op_logical_neg
id|netif_running
c_func
(paren
id|stir-&gt;netdev
)paren
op_logical_or
op_logical_neg
id|netif_device_present
c_func
(paren
id|stir-&gt;netdev
)paren
)paren
r_return
op_minus
id|ESHUTDOWN
suffix:semicolon
id|count
op_assign
(paren
r_int
)paren
(paren
id|regs
(braket
l_int|2
)braket
op_amp
l_int|0x1f
)paren
op_lshift
l_int|8
op_or
id|regs
(braket
l_int|1
)braket
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;%s: fifo status 0x%x count %u&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|regs
(braket
l_int|0
)braket
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* only waiting for some space */
r_if
c_cond
(paren
id|space
op_logical_and
id|STIR_FIFO_SIZE
op_minus
l_int|4
OG
id|space
op_plus
id|count
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|WARNING
c_func
(paren
l_string|&quot;%s: transmit fifo timeout status=0x%x count=%d&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|regs
(braket
l_int|0
)braket
comma
id|count
)paren
suffix:semicolon
op_increment
id|stir-&gt;stats.tx_errors
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|stir-&gt;netdev
comma
id|TRUE
)paren
suffix:semicolon
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
multiline_comment|/* estimate transfer time for remaining chars */
id|wait_ms
c_func
(paren
(paren
id|count
op_star
l_int|8000
)paren
op_div
id|stir-&gt;speed
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Wait for turnaround delay before starting transmit.  */
DECL|function|turnaround_delay
r_static
r_void
id|turnaround_delay
c_func
(paren
r_int
id|us
comma
r_const
r_struct
id|timespec
op_star
id|last
)paren
(brace
r_int
id|ticks
suffix:semicolon
r_struct
id|timespec
id|now
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|us
op_le
l_int|0
)paren
r_return
suffix:semicolon
id|us
op_sub_assign
(paren
id|now.tv_sec
op_minus
id|last-&gt;tv_sec
)paren
op_star
id|USEC_PER_SEC
suffix:semicolon
id|us
op_sub_assign
(paren
id|now.tv_nsec
op_minus
id|last-&gt;tv_nsec
)paren
op_div
id|NSEC_PER_USEC
suffix:semicolon
r_if
c_cond
(paren
id|us
OL
l_int|10
)paren
r_return
suffix:semicolon
id|ticks
op_assign
id|us
op_div
(paren
l_int|1000000
op_div
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ticks
OG
l_int|0
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
op_plus
id|ticks
)paren
suffix:semicolon
)brace
r_else
id|udelay
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start receiver by submitting a request to the receive pipe.&n; * If nothing is available it will return after rx_interval.&n; */
DECL|function|receive_start
r_static
r_void
id|receive_start
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|STIR_STATE_RECEIVING
comma
op_amp
id|stir-&gt;state
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|fifo_txwait
c_func
(paren
id|stir
comma
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|stir-&gt;rx_urbs
(braket
id|i
)braket
suffix:semicolon
id|usb_fill_int_urb
c_func
(paren
id|urb
comma
id|stir-&gt;usbdev
comma
id|stir-&gt;rx_intpipe
comma
id|stir-&gt;rx_data
(braket
id|i
)braket
comma
id|STIR_FIFO_SIZE
comma
id|stir_usb_receive
comma
id|stir
comma
id|rx_interval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_KERNEL
)paren
)paren
id|urb-&gt;status
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
multiline_comment|/* if nothing got queued, then just retry next time */
r_if
c_cond
(paren
id|net_ratelimit
c_func
(paren
)paren
)paren
id|WARNING
c_func
(paren
l_string|&quot;%s: no receive buffers avaiable&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|STIR_STATE_RECEIVING
comma
op_amp
id|stir-&gt;state
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Stop all pending receive Urb&squot;s */
DECL|function|receive_stop
r_static
r_void
id|receive_stop
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|stir-&gt;rx_urbs
(braket
id|i
)braket
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Send wrapped data (in tx_data) to device */
DECL|function|stir_send
r_static
r_void
id|stir_send
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
)paren
(brace
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|STIR_STATE_RECEIVING
comma
op_amp
id|stir-&gt;state
)paren
)paren
(brace
id|receive_stop
c_func
(paren
id|stir
)paren
suffix:semicolon
id|turnaround_delay
c_func
(paren
id|stir-&gt;tx_mtt
comma
op_amp
id|stir-&gt;rx_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stir-&gt;rx_buff.in_frame
)paren
op_increment
id|stir-&gt;stats.collisions
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fifo_txwait
c_func
(paren
id|stir
comma
id|stir-&gt;tx_len
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* shutdown or major errors */
id|stir-&gt;netdev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;%s: send %d&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|stir-&gt;tx_len
)paren
suffix:semicolon
id|rc
op_assign
id|usb_bulk_msg
c_func
(paren
id|stir-&gt;usbdev
comma
id|stir-&gt;tx_bulkpipe
comma
id|stir-&gt;tx_data
comma
id|stir-&gt;tx_len
comma
l_int|NULL
comma
id|MSECS_TO_JIFFIES
c_func
(paren
id|TRANSMIT_TIMEOUT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|rc
)paren
)paren
(brace
id|WARNING
c_func
(paren
l_string|&quot;%s: usb bulk message failed %d&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|rc
)paren
suffix:semicolon
id|stir-&gt;stats.tx_errors
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Transmit state machine thread&n; */
DECL|function|stir_transmit_thread
r_static
r_int
id|stir_transmit_thread
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_struct
id|stir_cb
op_star
id|stir
op_assign
id|arg
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|stir-&gt;netdev
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|daemonize
c_func
(paren
l_string|&quot;%s&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|allow_signal
c_func
(paren
id|SIGTERM
)paren
suffix:semicolon
r_while
c_loop
(paren
id|netif_running
c_func
(paren
id|dev
)paren
op_logical_and
id|netif_device_present
c_func
(paren
id|dev
)paren
op_logical_and
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
multiline_comment|/* make swsusp happy with our thread */
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
(brace
id|receive_stop
c_func
(paren
id|stir
)paren
suffix:semicolon
id|write_reg
c_func
(paren
id|stir
comma
id|REG_CTRL1
comma
id|CTRL1_TXPWD
op_or
id|CTRL1_RXPWD
)paren
suffix:semicolon
id|refrigerator
c_func
(paren
id|PF_IOTHREAD
)paren
suffix:semicolon
id|stir_reset
c_func
(paren
id|stir
)paren
suffix:semicolon
)brace
multiline_comment|/* if something to send? */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|STIR_STATE_TXREADY
comma
op_amp
id|stir-&gt;state
)paren
)paren
(brace
r_int
id|new_speed
op_assign
id|stir-&gt;tx_newspeed
suffix:semicolon
multiline_comment|/* Note that we may both send a packet and&n;&t;&t;&t; * change speed in some cases. Jean II */
r_if
c_cond
(paren
id|stir-&gt;tx_len
op_ne
l_int|0
)paren
id|stir_send
c_func
(paren
id|stir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stir-&gt;speed
op_ne
id|new_speed
)paren
id|change_speed
c_func
(paren
id|stir
comma
id|new_speed
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|stir-&gt;netdev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irda_device_txqueue_empty
c_func
(paren
id|dev
)paren
)paren
id|receive_start
c_func
(paren
id|stir
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|current
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|stir-&gt;thr_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|STIR_STATE_TXREADY
comma
op_amp
id|stir-&gt;state
)paren
)paren
id|__set_task_state
c_func
(paren
id|current
comma
id|TASK_RUNNING
)paren
suffix:semicolon
r_else
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|stir-&gt;thr_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
id|complete_and_exit
(paren
op_amp
id|stir-&gt;thr_exited
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive wrapped data into rx_data buffer.&n; * This chip doesn&squot;t block until data is available, we just have&n; * to read the FIFO perodically (ugh).&n; */
DECL|function|stir_usb_receive
r_static
r_void
id|stir_usb_receive
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|stir_cb
op_star
id|stir
op_assign
id|urb-&gt;context
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_running
c_func
(paren
id|stir-&gt;netdev
)paren
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|urb-&gt;status
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|urb-&gt;actual_length
OG
l_int|0
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;%s: receive %d&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
id|unwrap_chars
c_func
(paren
id|stir
comma
id|urb-&gt;transfer_buffer
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
id|stir-&gt;netdev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|stir-&gt;rx_time
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
op_minus
id|ECONNRESET
suffix:colon
multiline_comment|/* killed but pending */
r_case
op_minus
id|ENOENT
suffix:colon
multiline_comment|/* killed but not in use */
r_case
op_minus
id|ESHUTDOWN
suffix:colon
multiline_comment|/* These are normal errors when URB is cancelled */
id|stir-&gt;rx_buff.in_frame
op_assign
id|FALSE
suffix:semicolon
id|stir-&gt;rx_buff.state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
id|WARNING
c_func
(paren
l_string|&quot;%s: received status %d&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|urb-&gt;status
)paren
suffix:semicolon
id|stir-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* kernel thread is stopping receiver don&squot;t resubmit */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|STIR_STATE_RECEIVING
comma
op_amp
id|stir-&gt;state
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* resubmit existing urb */
id|err
op_assign
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* in case of error, the kernel thread will restart us */
r_if
c_cond
(paren
id|err
)paren
(brace
id|WARNING
c_func
(paren
l_string|&quot;%s: usb receive submit error: %d&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
comma
id|err
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|stir-&gt;thr_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function stir_net_open (dev)&n; *&n; *    Network device is taken up. Usually this is done by &quot;ifconfig irda0 up&quot;&n; */
DECL|function|stir_net_open
r_static
r_int
id|stir_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|netdev
)paren
(brace
r_struct
id|stir_cb
op_star
id|stir
op_assign
id|netdev-&gt;priv
suffix:semicolon
r_int
id|i
comma
id|err
suffix:semicolon
r_char
id|hwname
(braket
l_int|16
)braket
suffix:semicolon
id|err
op_assign
id|stir_reset
c_func
(paren
id|stir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_out1
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Note: Max SIR frame possible is 4273 */
id|stir-&gt;tx_data
op_assign
id|kmalloc
c_func
(paren
id|STIR_FIFO_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stir-&gt;tx_data
)paren
(brace
id|ERROR
c_func
(paren
l_string|&quot;%s(), alloc failed for rxbuf!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
id|err_out1
suffix:semicolon
)brace
multiline_comment|/* Initialize for SIR/FIR to copy data directly into skb.  */
id|stir-&gt;rx_buff.truesize
op_assign
id|IRDA_SKB_MAX_MTU
suffix:semicolon
id|stir-&gt;rx_buff.skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|IRDA_SKB_MAX_MTU
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stir-&gt;rx_buff.skb
)paren
(brace
id|ERROR
c_func
(paren
l_string|&quot;%s(), dev_alloc_skb() failed for rxbuf!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
id|err_out2
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|stir-&gt;rx_buff.skb
comma
l_int|1
)paren
suffix:semicolon
id|stir-&gt;rx_buff.head
op_assign
id|stir-&gt;rx_buff.skb-&gt;data
suffix:semicolon
id|stir-&gt;rx_time
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* Allocate N receive buffer&squot;s and urbs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|stir-&gt;rx_urbs
(braket
id|i
)braket
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stir-&gt;rx_urbs
(braket
id|i
)braket
)paren
(brace
id|ERROR
c_func
(paren
l_string|&quot;%s(), usb_alloc_urb failed&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
id|err_out3
suffix:semicolon
)brace
id|stir-&gt;rx_data
(braket
id|i
)braket
op_assign
id|kmalloc
c_func
(paren
id|STIR_FIFO_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stir-&gt;rx_data
)paren
(brace
id|usb_free_urb
c_func
(paren
id|stir-&gt;rx_urbs
(braket
id|i
)braket
)paren
suffix:semicolon
id|ERROR
c_func
(paren
l_string|&quot;%s(), alloc failed for rxbuf!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
id|err_out3
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now that everything should be initialized properly,&n;&t; * Open new IrLAP layer instance to take care of us...&n;&t; * Note : will send immediately a speed change...&n;&t; */
id|sprintf
c_func
(paren
id|hwname
comma
l_string|&quot;usb#%d&quot;
comma
id|stir-&gt;usbdev-&gt;devnum
)paren
suffix:semicolon
id|stir-&gt;irlap
op_assign
id|irlap_open
c_func
(paren
id|netdev
comma
op_amp
id|stir-&gt;qos
comma
id|hwname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stir-&gt;irlap
)paren
(brace
id|ERROR
c_func
(paren
l_string|&quot;%s(): irlap_open failed&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
id|err_out3
suffix:semicolon
)brace
multiline_comment|/** Start kernel thread for transmit.  */
id|stir-&gt;thr_pid
op_assign
id|kernel_thread
c_func
(paren
id|stir_transmit_thread
comma
id|stir
comma
id|CLONE_FS
op_or
id|CLONE_FILES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stir-&gt;thr_pid
OL
l_int|0
)paren
(brace
id|err
op_assign
id|stir-&gt;thr_pid
suffix:semicolon
id|WARNING
c_func
(paren
l_string|&quot;%s: unable to start kernel thread&bslash;n&quot;
comma
id|stir-&gt;netdev-&gt;name
)paren
suffix:semicolon
r_goto
id|err_out4
suffix:semicolon
)brace
id|netif_start_queue
c_func
(paren
id|netdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out4
suffix:colon
id|irlap_close
c_func
(paren
id|stir-&gt;irlap
)paren
suffix:semicolon
id|err_out3
suffix:colon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
(brace
id|usb_free_urb
c_func
(paren
id|stir-&gt;rx_urbs
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stir-&gt;rx_data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|stir-&gt;rx_buff.skb
)paren
suffix:semicolon
id|err_out2
suffix:colon
id|kfree
c_func
(paren
id|stir-&gt;tx_data
)paren
suffix:semicolon
id|err_out1
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Function stir_net_close (stir)&n; *&n; *    Network device is taken down. Usually this is done by&n; *    &quot;ifconfig irda0 down&quot;&n; */
DECL|function|stir_net_close
r_static
r_int
id|stir_net_close
c_func
(paren
r_struct
id|net_device
op_star
id|netdev
)paren
(brace
r_struct
id|stir_cb
op_star
id|stir
op_assign
id|netdev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Stop transmit processing */
id|netif_stop_queue
c_func
(paren
id|netdev
)paren
suffix:semicolon
multiline_comment|/* Kill transmit thread */
id|kill_proc
c_func
(paren
id|stir-&gt;thr_pid
comma
id|SIGTERM
comma
l_int|1
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|stir-&gt;thr_exited
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stir-&gt;tx_data
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|STIR_STATE_RECEIVING
comma
op_amp
id|stir-&gt;state
)paren
suffix:semicolon
id|receive_stop
c_func
(paren
id|stir
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|usb_free_urb
c_func
(paren
id|stir-&gt;rx_urbs
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stir-&gt;rx_data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|stir-&gt;rx_buff.skb
)paren
suffix:semicolon
multiline_comment|/* Stop and remove instance of IrLAP */
r_if
c_cond
(paren
id|stir-&gt;irlap
)paren
id|irlap_close
c_func
(paren
id|stir-&gt;irlap
)paren
suffix:semicolon
id|stir-&gt;irlap
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * IOCTLs : Extra out-of-band network commands...&n; */
DECL|function|stir_net_ioctl
r_static
r_int
id|stir_net_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
r_struct
id|if_irda_req
op_star
id|irq
op_assign
(paren
r_struct
id|if_irda_req
op_star
)paren
id|rq
suffix:semicolon
r_struct
id|stir_cb
op_star
id|stir
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCSBANDWIDTH
suffix:colon
multiline_comment|/* Set bandwidth */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* Check if the device is still there */
r_if
c_cond
(paren
id|netif_device_present
c_func
(paren
id|stir-&gt;netdev
)paren
)paren
id|ret
op_assign
id|change_speed
c_func
(paren
id|stir
comma
id|irq-&gt;ifr_baudrate
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCSMEDIABUSY
suffix:colon
multiline_comment|/* Set media busy */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* Check if the IrDA stack is still there */
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|stir-&gt;netdev
)paren
)paren
id|irda_device_set_media_busy
c_func
(paren
id|stir-&gt;netdev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGRECEIVING
suffix:colon
multiline_comment|/* Only approximately true */
id|irq-&gt;ifr_receiving
op_assign
id|test_bit
c_func
(paren
id|STIR_STATE_RECEIVING
comma
op_amp
id|stir-&gt;state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Get device stats (for /proc/net/dev and ifconfig)&n; */
DECL|function|stir_net_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|stir_net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|stir_cb
op_star
id|stir
op_assign
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|stir-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n; *    Parse the various endpoints and find the one we need.&n; *&n; * The endpoint are the pipes used to communicate with the USB device.&n; * The spec defines 2 endpoints of type bulk transfer, one in, and one out.&n; * These are used to pass frames back and forth with the dongle.&n; */
DECL|function|stir_setup_usb
r_static
r_int
id|stir_setup_usb
c_func
(paren
r_struct
id|stir_cb
op_star
id|stir
comma
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usb_device
op_star
id|usbdev
op_assign
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
suffix:semicolon
r_const
r_struct
id|usb_host_interface
op_star
id|interface
op_assign
id|intf-&gt;cur_altsetting
suffix:semicolon
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_in
op_assign
l_int|NULL
suffix:semicolon
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_out
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;desc.bNumEndpoints
op_ne
l_int|2
)paren
(brace
id|WARNING
c_func
(paren
l_string|&quot;%s: expected two endpoints&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|interface-&gt;desc.bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|ep
op_assign
op_amp
id|interface-&gt;endpoint
(braket
id|i
)braket
dot
id|desc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ep-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_BULK
)paren
(brace
multiline_comment|/* We need to find an IN and an OUT */
r_if
c_cond
(paren
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_DIR_MASK
)paren
op_eq
id|USB_DIR_IN
)paren
id|ep_in
op_assign
id|ep
suffix:semicolon
r_else
id|ep_out
op_assign
id|ep
suffix:semicolon
)brace
r_else
id|WARNING
c_func
(paren
l_string|&quot;%s: unknown endpoint type 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ep-&gt;bmAttributes
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ep_in
op_logical_or
op_logical_neg
id|ep_out
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|stir-&gt;tx_bulkpipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|usbdev
comma
id|ep_out-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
id|stir-&gt;rx_intpipe
op_assign
id|usb_rcvintpipe
c_func
(paren
id|usbdev
comma
id|ep_in-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called by the USB subsystem for each new device&n; * in the system. We need to check if the device is ours, and in&n; * this case start handling it.&n; * Note : it might be worth protecting this function by a global&n; * spinlock... Or not, because maybe USB already deal with that...&n; */
DECL|function|stir_probe
r_static
r_int
id|stir_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
suffix:semicolon
r_struct
id|stir_cb
op_star
id|stir
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|net_device
op_star
id|net
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Allocate network device container. */
id|net
op_assign
id|alloc_irdadev
c_func
(paren
r_sizeof
(paren
op_star
id|stir
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|net
)paren
(brace
r_goto
id|err_out1
suffix:semicolon
)brace
id|SET_MODULE_OWNER
c_func
(paren
id|net
)paren
suffix:semicolon
id|SET_NETDEV_DEV
c_func
(paren
id|net
comma
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
id|stir
op_assign
id|net-&gt;priv
suffix:semicolon
id|stir-&gt;netdev
op_assign
id|net
suffix:semicolon
id|stir-&gt;usbdev
op_assign
id|dev
suffix:semicolon
id|ret
op_assign
id|stir_setup_usb
c_func
(paren
id|stir
comma
id|intf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|ERROR
c_func
(paren
l_string|&quot;%s(), Bogus endpoints...&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
id|err_out2
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SigmaTel STIr4200 IRDA/USB found at address %d, &quot;
l_string|&quot;Vendor: %x, Product: %x&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
multiline_comment|/* Initialize QoS for this device */
id|irda_init_max_qos_capabilies
c_func
(paren
op_amp
id|stir-&gt;qos
)paren
suffix:semicolon
multiline_comment|/* That&squot;s the Rx capability. */
id|stir-&gt;qos.baud_rate.bits
op_and_assign
id|IR_2400
op_or
id|IR_9600
op_or
id|IR_19200
op_or
id|IR_38400
op_or
id|IR_57600
op_or
id|IR_115200
op_or
(paren
id|IR_4000000
op_lshift
l_int|8
)paren
suffix:semicolon
id|stir-&gt;qos.min_turn_time.bits
op_and_assign
id|qos_mtt_bits
suffix:semicolon
id|irda_qos_bits_to_value
c_func
(paren
op_amp
id|stir-&gt;qos
)paren
suffix:semicolon
id|init_completion
(paren
op_amp
id|stir-&gt;thr_exited
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|stir-&gt;thr_wait
)paren
suffix:semicolon
multiline_comment|/* Override the network functions we need to use */
id|net-&gt;hard_start_xmit
op_assign
id|stir_hard_xmit
suffix:semicolon
id|net-&gt;open
op_assign
id|stir_net_open
suffix:semicolon
id|net-&gt;stop
op_assign
id|stir_net_close
suffix:semicolon
id|net-&gt;get_stats
op_assign
id|stir_net_get_stats
suffix:semicolon
id|net-&gt;do_ioctl
op_assign
id|stir_net_ioctl
suffix:semicolon
id|ret
op_assign
id|stir_reset
c_func
(paren
id|stir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|err_out2
suffix:semicolon
id|ret
op_assign
id|register_netdev
c_func
(paren
id|net
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|err_out2
suffix:semicolon
id|MESSAGE
c_func
(paren
l_string|&quot;IrDA: Registered SigmaTel device %s&bslash;n&quot;
comma
id|net-&gt;name
)paren
suffix:semicolon
id|usb_set_intfdata
c_func
(paren
id|intf
comma
id|stir
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out2
suffix:colon
id|free_netdev
c_func
(paren
id|net
)paren
suffix:semicolon
id|err_out1
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * The current device is removed, the USB layer tell us to shut it down...&n; */
DECL|function|stir_disconnect
r_static
r_void
id|stir_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|stir_cb
op_star
id|stir
op_assign
id|usb_get_intfdata
c_func
(paren
id|intf
)paren
suffix:semicolon
r_struct
id|net_device
op_star
id|net
suffix:semicolon
id|usb_set_intfdata
c_func
(paren
id|intf
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stir
)paren
r_return
suffix:semicolon
multiline_comment|/* Stop transmitter */
id|net
op_assign
id|stir-&gt;netdev
suffix:semicolon
id|netif_device_detach
c_func
(paren
id|net
)paren
suffix:semicolon
multiline_comment|/* Remove netdevice */
id|unregister_netdev
c_func
(paren
id|net
)paren
suffix:semicolon
multiline_comment|/* No longer attached to USB bus */
id|stir-&gt;usbdev
op_assign
l_int|NULL
suffix:semicolon
id|free_netdev
c_func
(paren
id|net
)paren
suffix:semicolon
)brace
multiline_comment|/* Power management suspend, so power off the transmitter/receiver */
DECL|function|stir_suspend
r_static
r_int
id|stir_suspend
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
id|u32
id|state
)paren
(brace
r_struct
id|stir_cb
op_star
id|stir
op_assign
id|usb_get_intfdata
c_func
(paren
id|intf
)paren
suffix:semicolon
id|netif_device_detach
c_func
(paren
id|stir-&gt;netdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Coming out of suspend, so reset hardware */
DECL|function|stir_resume
r_static
r_int
id|stir_resume
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|stir_cb
op_star
id|stir
op_assign
id|usb_get_intfdata
c_func
(paren
id|intf
)paren
suffix:semicolon
id|netif_device_attach
c_func
(paren
id|stir-&gt;netdev
)paren
suffix:semicolon
multiline_comment|/* receiver restarted when send thread wakes up */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * USB device callbacks&n; */
DECL|variable|irda_driver
r_static
r_struct
id|usb_driver
id|irda_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;stir4200&quot;
comma
dot
id|probe
op_assign
id|stir_probe
comma
dot
id|disconnect
op_assign
id|stir_disconnect
comma
dot
id|id_table
op_assign
id|dongles
comma
dot
id|suspend
op_assign
id|stir_suspend
comma
dot
id|resume
op_assign
id|stir_resume
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Module insertion&n; */
DECL|function|stir_init
r_static
r_int
id|__init
id|stir_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|irda_driver
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|MESSAGE
c_func
(paren
l_string|&quot;SigmaTel support registered&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|stir_init
id|module_init
c_func
(paren
id|stir_init
)paren
suffix:semicolon
multiline_comment|/*&n; * Module removal&n; */
DECL|function|stir_cleanup
r_static
r_void
id|__exit
id|stir_cleanup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Deregister the driver and remove all pending instances */
id|usb_deregister
c_func
(paren
op_amp
id|irda_driver
)paren
suffix:semicolon
)brace
DECL|variable|stir_cleanup
id|module_exit
c_func
(paren
id|stir_cleanup
)paren
suffix:semicolon
eof
