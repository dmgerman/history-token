multiline_comment|/*****************************************************************************&n; *&n; * Filename:      irda-usb.c&n; * Version:       0.9&n; * Description:   IrDA-USB Driver&n; * Status:        Experimental &n; * Author:        Dag Brattli &lt;dag@brattli.net&gt;&n; *&n; *      Copyright (C) 2001, Dag Brattli &lt;dag@brattli.net&gt;&n; *      Copyright (C) 2001, Jean Tourrilhes &lt;jt@hpl.hp.com&gt;&n; *&t;Copyright (C) 2000, Roman Weissgaerber &lt;weissg@vienna.at&gt;&n; *          &n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *****************************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/irda_device.h&gt;
macro_line|#include &lt;net/irda/wrapper.h&gt;
macro_line|#include &lt;net/irda/irda-usb.h&gt;
DECL|variable|min_turn_times
r_static
id|u32
id|min_turn_times
(braket
)braket
op_assign
(brace
l_int|10000
comma
l_int|5000
comma
l_int|1000
comma
l_int|500
comma
l_int|100
comma
l_int|50
comma
l_int|10
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* us */
DECL|variable|qos_mtt_bits
r_static
r_int
id|qos_mtt_bits
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|irda_usb_dump_class_desc
c_func
(paren
r_struct
id|irda_class_desc
op_star
id|desc
)paren
suffix:semicolon
r_static
r_struct
id|irda_class_desc
op_star
id|irda_usb_find_class_desc
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
suffix:semicolon
r_static
r_void
id|irda_usb_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|irda_usb_change_speed_xbofs
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_hard_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_open
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_close
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_void
id|irda_usb_write_bulk
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
comma
id|purb_t
id|purb
)paren
suffix:semicolon
r_static
r_void
id|write_bulk_callback
c_func
(paren
id|purb_t
id|purb
)paren
suffix:semicolon
r_static
r_void
id|irda_usb_receive
c_func
(paren
id|purb_t
id|purb
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_net_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|irda_usb_net_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|irda_usb_net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Master instance for each hardware found */
DECL|macro|NIRUSB
mdefine_line|#define NIRUSB 4&t;&t;/* Max number of USB-IrDA dongles */
DECL|variable|irda_instance
r_static
r_struct
id|irda_usb_cb
id|irda_instance
(braket
id|NIRUSB
)braket
suffix:semicolon
multiline_comment|/* These are the currently known IrDA USB dongles. Add new dongles here */
DECL|variable|dongles
r_static
r_struct
id|usb_device_id
id|dongles
(braket
)braket
op_assign
(brace
multiline_comment|/* ACTiSYS Corp,  ACT-IR2000U FIR-USB Adapter */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x9c4
comma
l_int|0x011
)paren
comma
id|driver_info
suffix:colon
id|IUC_SPEED_BUG
op_or
id|IUC_NO_WINDOW
)brace
comma
multiline_comment|/* KC Technology Inc.,  KC-180 USB IrDA Device */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x50f
comma
l_int|0x180
)paren
comma
id|driver_info
suffix:colon
id|IUC_SPEED_BUG
op_or
id|IUC_NO_WINDOW
)brace
comma
multiline_comment|/* Extended Systems, Inc.,  XTNDAccess IrDA USB (ESI-9685) */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x8e9
comma
l_int|0x100
)paren
comma
id|driver_info
suffix:colon
id|IUC_SPEED_BUG
op_or
id|IUC_NO_WINDOW
)brace
comma
(brace
id|match_flags
suffix:colon
id|USB_DEVICE_ID_MATCH_INT_CLASS
comma
id|bInterfaceClass
suffix:colon
id|USB_CLASS_APP_SPEC
comma
id|bInterfaceSubClass
suffix:colon
id|USB_CLASS_IRDA
comma
id|driver_info
suffix:colon
id|IUC_DEFAULT
comma
)brace
comma
(brace
)brace
comma
multiline_comment|/* The end */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|usb
comma
id|dongles
)paren
suffix:semicolon
multiline_comment|/*&n; * This routine is called by the USB subsystem for each new device&n; * in the system. We need to check if the device is ours, and in&n; * this case start handling it.&n; * Note : it might be worth protecting this function by a global&n; * spinlock...&n; */
DECL|function|irda_usb_probe
r_static
r_void
op_star
id|irda_usb_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|interface
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
suffix:semicolon
r_struct
id|irda_class_desc
op_star
id|irda_desc
suffix:semicolon
r_int
id|capability
op_assign
id|id-&gt;driver_info
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|ep
suffix:semicolon
r_int
id|i
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;Vendor: %x, Product: %x&bslash;n&quot;
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
id|MESSAGE
c_func
(paren
l_string|&quot;IRDA-USB found at address %d&bslash;n&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
multiline_comment|/* Try to cleanup all instance that have a pending disconnect&n;&t; * Instance will be in this state is the disconnect() occurs&n;&t; * before the net_close().&n;&t; * Jean II */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NIRUSB
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|irda
op_assign
op_amp
id|irda_instance
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irda-&gt;usbdev
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|irda-&gt;present
op_eq
l_int|0
)paren
op_logical_and
(paren
id|irda-&gt;netopen
op_eq
l_int|0
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), found a zombie instance !!!&bslash;n&quot;
)paren
suffix:semicolon
id|irda_usb_disconnect
c_func
(paren
id|irda-&gt;usbdev
comma
(paren
r_void
op_star
)paren
id|irda
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Find an free instance to handle this new device... */
id|self
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NIRUSB
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irda_instance
(braket
id|i
)braket
dot
id|usbdev
op_eq
l_int|NULL
)paren
(brace
id|self
op_assign
op_amp
id|irda_instance
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;Too many USB IrDA devices !!! (max = %d)&bslash;n&quot;
comma
id|NIRUSB
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Reset the instance */
id|self-&gt;present
op_assign
l_int|0
suffix:semicolon
id|self-&gt;netopen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is this really necessary? */
r_if
c_cond
(paren
id|usb_set_configuration
(paren
id|dev
comma
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|bConfigurationValue
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;set_configuration failed&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Is this really necessary? */
id|ret
op_assign
id|usb_set_interface
c_func
(paren
id|dev
comma
id|ifnum
comma
l_int|0
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;usb-irda: set interface result %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
id|USB_ST_NOERROR
suffix:colon
multiline_comment|/* 0 */
r_break
suffix:semicolon
r_case
id|USB_ST_STALL
suffix:colon
multiline_comment|/* -EPIPE = -32 */
id|usb_clear_halt
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Clearing stall on control interface&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown error %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Find our endpoints */
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|ifnum
)braket
dot
id|altsetting
(braket
l_int|0
)braket
suffix:semicolon
id|endpoint
op_assign
id|interface-&gt;endpoint
suffix:semicolon
id|ep
op_assign
id|endpoint
(braket
l_int|0
)braket
dot
id|bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|endpoint
(braket
l_int|0
)braket
dot
id|bEndpointAddress
op_amp
id|USB_ENDPOINT_DIR_MASK
)paren
op_eq
id|USB_DIR_IN
)paren
id|self-&gt;bulk_in_ep
op_assign
id|ep
suffix:semicolon
r_else
(brace
id|self-&gt;bulk_out_ep
op_assign
id|ep
suffix:semicolon
id|self-&gt;bulk_out_mtu
op_assign
id|endpoint
(braket
l_int|0
)braket
dot
id|wMaxPacketSize
suffix:semicolon
)brace
id|ep
op_assign
id|endpoint
(braket
l_int|1
)braket
dot
id|bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|endpoint
(braket
l_int|1
)braket
dot
id|bEndpointAddress
op_amp
id|USB_ENDPOINT_DIR_MASK
)paren
op_eq
id|USB_DIR_IN
)paren
id|self-&gt;bulk_in_ep
op_assign
id|ep
suffix:semicolon
r_else
(brace
id|self-&gt;bulk_out_ep
op_assign
id|ep
suffix:semicolon
id|self-&gt;bulk_out_mtu
op_assign
id|endpoint
(braket
l_int|1
)braket
dot
id|wMaxPacketSize
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;bulk_out_ep
op_eq
l_int|0
op_logical_or
id|self-&gt;bulk_in_ep
op_eq
l_int|0
op_logical_or
id|endpoint
(braket
l_int|0
)braket
dot
id|bmAttributes
op_ne
id|USB_ENDPOINT_XFER_BULK
op_logical_or
id|endpoint
(braket
l_int|1
)braket
dot
id|bmAttributes
op_ne
id|USB_ENDPOINT_XFER_BULK
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), Bogus endpoints&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Find IrDA class descriptor */
id|irda_desc
op_assign
id|irda_usb_find_class_desc
c_func
(paren
id|dev
comma
id|ifnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irda_desc
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|self-&gt;irda_desc
op_assign
id|irda_desc
suffix:semicolon
id|self-&gt;present
op_assign
l_int|1
suffix:semicolon
id|self-&gt;netopen
op_assign
l_int|0
suffix:semicolon
id|self-&gt;capability
op_assign
id|capability
suffix:semicolon
id|self-&gt;usbdev
op_assign
id|dev
suffix:semicolon
id|ret
op_assign
id|irda_usb_open
c_func
(paren
id|self
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|self
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_usb_find_class_desc(dev, ifnum)&n; *&n; *    Returns instance of IrDA class descriptor, or NULL if not found&n; *&n; */
DECL|function|irda_usb_find_class_desc
r_static
r_struct
id|irda_class_desc
op_star
id|irda_usb_find_class_desc
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
(brace
r_struct
id|usb_interface_descriptor
op_star
id|interface
suffix:semicolon
r_struct
id|irda_class_desc
op_star
id|desc
comma
op_star
id|ptr
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|desc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irda_class_desc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desc
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|desc
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|irda_class_desc
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|usb_get_class_descriptor
c_func
(paren
id|dev
comma
id|ifnum
comma
id|USB_DT_IRDA
comma
l_int|0
comma
(paren
r_void
op_star
)paren
id|desc
comma
r_sizeof
(paren
r_struct
id|irda_class_desc
)paren
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), ret=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|WARNING
c_func
(paren
l_string|&quot;usb-irda: usb_get_class_descriptor failed (0x%x)&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if we found it? */
r_if
c_cond
(paren
id|desc-&gt;bDescriptorType
op_eq
id|USB_DT_IRDA
)paren
r_return
id|desc
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), parsing extra descriptors ...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check if the class descriptor is interleaved with standard descriptors */
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|ifnum
)braket
dot
id|altsetting
(braket
l_int|0
)braket
suffix:semicolon
id|ret
op_assign
id|usb_get_extra_descriptor
c_func
(paren
id|interface
comma
id|USB_DT_IRDA
comma
op_amp
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|kfree
c_func
(paren
id|desc
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_star
id|desc
op_assign
op_star
id|ptr
suffix:semicolon
macro_line|#if 0
id|irda_usb_dump_class_desc
c_func
(paren
id|desc
)paren
suffix:semicolon
macro_line|#endif&t;
r_return
id|desc
suffix:semicolon
)brace
multiline_comment|/*&n; * Function usb_irda_dump_class_desc(desc)&n; *&n; *    Prints out the contents of the IrDA class descriptor&n; *&n; */
DECL|function|irda_usb_dump_class_desc
r_static
r_void
id|irda_usb_dump_class_desc
c_func
(paren
r_struct
id|irda_class_desc
op_star
id|desc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bLength=%x&bslash;n&quot;
comma
id|desc-&gt;bLength
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bDescriptorType=%x&bslash;n&quot;
comma
id|desc-&gt;bDescriptorType
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bcdSpecRevision=%x&bslash;n&quot;
comma
id|desc-&gt;bcdSpecRevision
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bmDataSize=%x&bslash;n&quot;
comma
id|desc-&gt;bmDataSize
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bmWindowSize=%x&bslash;n&quot;
comma
id|desc-&gt;bmWindowSize
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bmMinTurnaroundTime=%d&bslash;n&quot;
comma
id|desc-&gt;bmMinTurnaroundTime
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;wBaudRate=%x&bslash;n&quot;
comma
id|desc-&gt;wBaudRate
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bmAdditionalBOFs=%x&bslash;n&quot;
comma
id|desc-&gt;bmAdditionalBOFs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bIrdaRateSniff=%x&bslash;n&quot;
comma
id|desc-&gt;bIrdaRateSniff
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bMaxUnicastList=%x&bslash;n&quot;
comma
id|desc-&gt;bMaxUnicastList
)paren
suffix:semicolon
)brace
DECL|function|irda_usb_disconnect
r_static
r_void
id|irda_usb_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
(paren
r_struct
id|irda_usb_cb
op_star
)paren
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Oups ! We are not there any more */
id|self-&gt;present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Hum... Check if networking is still active */
r_if
c_cond
(paren
id|self-&gt;netopen
)paren
(brace
multiline_comment|/* Accept no more transmissions */
multiline_comment|/*netif_device_detach(self-&gt;netdev);*/
id|netif_stop_queue
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
multiline_comment|/* Stop all the receive URBs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IU_MAX_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
id|usb_unlink_urb
c_func
(paren
op_amp
(paren
id|self-&gt;rx_urb
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* Cancel Tx and speed URB */
id|usb_unlink_urb
c_func
(paren
op_amp
(paren
id|self-&gt;tx_urb
)paren
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
op_amp
(paren
id|self-&gt;speed_urb
)paren
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), postponing disconnect, network is still active...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* better not do anything just yet, usb_irda_cleanup()&n;&t;&t; * will do whats needed */
r_return
suffix:semicolon
)brace
multiline_comment|/* Cleanup the device stuff */
id|irda_usb_close
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* No longer attached to USB bus */
id|self-&gt;usbdev
op_assign
l_int|NULL
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), USB IrDA Disconnected&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|irda_driver
r_static
r_struct
id|usb_driver
id|irda_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;irda-usb&quot;
comma
id|probe
suffix:colon
id|irda_usb_probe
comma
id|disconnect
suffix:colon
id|irda_usb_disconnect
comma
id|id_table
suffix:colon
id|dongles
comma
)brace
suffix:semicolon
DECL|function|irda_usb_init_qos
r_static
r_void
id|irda_usb_init_qos
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
(brace
r_struct
id|irda_class_desc
op_star
id|desc
suffix:semicolon
id|desc
op_assign
id|self-&gt;irda_desc
suffix:semicolon
multiline_comment|/* Initialize QoS for this device */
id|irda_init_max_qos_capabilies
c_func
(paren
op_amp
id|self-&gt;qos
)paren
suffix:semicolon
id|self-&gt;qos.baud_rate.bits
op_assign
id|desc-&gt;wBaudRate
suffix:semicolon
id|self-&gt;qos.min_turn_time.bits
op_assign
id|desc-&gt;bmMinTurnaroundTime
suffix:semicolon
id|self-&gt;qos.additional_bofs.bits
op_assign
id|desc-&gt;bmAdditionalBOFs
suffix:semicolon
id|self-&gt;qos.window_size.bits
op_assign
id|desc-&gt;bmWindowSize
suffix:semicolon
id|self-&gt;qos.data_size.bits
op_assign
id|desc-&gt;bmDataSize
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), dongle says speed=0x%X, size=0x%X, window=0x%X, bofs=0x%X, turn=0x%X&bslash;n&quot;
comma
id|self-&gt;qos.baud_rate.bits
comma
id|self-&gt;qos.data_size.bits
comma
id|self-&gt;qos.window_size.bits
comma
id|self-&gt;qos.additional_bofs.bits
comma
id|self-&gt;qos.min_turn_time.bits
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t always trust what the dongle tell us */
r_if
c_cond
(paren
id|self-&gt;capability
op_amp
id|IUC_SIR_ONLY
)paren
id|self-&gt;qos.baud_rate.bits
op_and_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;capability
op_amp
id|IUC_SMALL_PKT
)paren
id|self-&gt;qos.data_size.bits
op_assign
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;capability
op_amp
id|IUC_NO_WINDOW
)paren
id|self-&gt;qos.window_size.bits
op_assign
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;capability
op_amp
id|IUC_MAX_WINDOW
)paren
id|self-&gt;qos.window_size.bits
op_assign
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;capability
op_amp
id|IUC_MAX_XBOFS
)paren
id|self-&gt;qos.additional_bofs.bits
op_assign
l_int|0x01
suffix:semicolon
macro_line|#if 1
multiline_comment|/* Module parameter can override the rx window size */
r_if
c_cond
(paren
id|qos_mtt_bits
)paren
id|self-&gt;qos.min_turn_time.bits
op_assign
id|qos_mtt_bits
suffix:semicolon
macro_line|#endif&t;    
multiline_comment|/* &n;&t; * Note : most of those values apply only for the receive path,&n;&t; * the transmit path will be set differently - Jean II &n;&t; */
id|irda_qos_bits_to_value
c_func
(paren
op_amp
id|self-&gt;qos
)paren
suffix:semicolon
id|self-&gt;flags
op_or_assign
id|IFF_SIR
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;qos.baud_rate.value
OG
l_int|115200
)paren
id|self-&gt;flags
op_or_assign
id|IFF_MIR
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;qos.baud_rate.value
OG
l_int|1152000
)paren
id|self-&gt;flags
op_or_assign
id|IFF_FIR
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;qos.baud_rate.value
OG
l_int|4000000
)paren
id|self-&gt;flags
op_or_assign
id|IFF_VFIR
suffix:semicolon
)brace
DECL|function|irda_usb_open
r_static
r_int
id|irda_usb_open
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
(brace
r_struct
id|net_device
op_star
id|netdev
suffix:semicolon
r_int
id|err
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|self-&gt;lock
)paren
suffix:semicolon
id|irda_usb_init_qos
c_func
(paren
id|self
)paren
suffix:semicolon
id|self-&gt;tx_list
op_assign
id|hashbin_new
c_func
(paren
id|HB_GLOBAL
)paren
suffix:semicolon
multiline_comment|/* Create a network device for us */
r_if
c_cond
(paren
op_logical_neg
(paren
id|netdev
op_assign
id|dev_alloc
c_func
(paren
l_string|&quot;irda%d&quot;
comma
op_amp
id|err
)paren
)paren
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), dev_alloc() failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|self-&gt;netdev
op_assign
id|netdev
suffix:semicolon
id|netdev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|self
suffix:semicolon
multiline_comment|/* Override the network functions we need to use */
id|netdev-&gt;init
op_assign
id|irda_usb_net_init
suffix:semicolon
id|netdev-&gt;hard_start_xmit
op_assign
id|irda_usb_hard_xmit
suffix:semicolon
id|netdev-&gt;tx_timeout
op_assign
id|irda_usb_net_timeout
suffix:semicolon
id|netdev-&gt;watchdog_timeo
op_assign
l_int|110
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
multiline_comment|/* 110 ms &gt; USB timeout */
id|netdev-&gt;open
op_assign
id|irda_usb_net_open
suffix:semicolon
id|netdev-&gt;stop
op_assign
id|irda_usb_net_close
suffix:semicolon
id|netdev-&gt;get_stats
op_assign
id|irda_usb_net_get_stats
suffix:semicolon
id|netdev-&gt;do_ioctl
op_assign
id|irda_usb_net_ioctl
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|register_netdevice
c_func
(paren
id|netdev
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), register_netdev() failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|MESSAGE
c_func
(paren
l_string|&quot;IrDA: Registered device %s&bslash;n&quot;
comma
id|netdev-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|irda_usb_close
r_static
r_int
id|irda_usb_close
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Remove netdevice */
r_if
c_cond
(paren
id|self-&gt;netdev
)paren
(brace
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|unregister_netdevice
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
id|self-&gt;netdev
op_assign
l_int|NULL
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
id|hashbin_delete
c_func
(paren
id|self-&gt;tx_list
comma
(paren
id|FREE_FUNC
)paren
op_amp
id|dev_kfree_skb_any
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_usb_build_header(self, skb, header)&n; *&n; *   Builds USB-IrDA outbound header&n; *&n; * Important note : the USB-IrDA spec 1.0 say very clearly in chapter 5.4.2.2&n; * that the setting of the link speed and xbof number in this outbound header&n; * should be applied *AFTER* the frame has been sent.&n; * Unfortunately, some devices are not compliant with that... It seems that&n; * reading the spec is far too difficult...&n; * Jean II&n; */
DECL|function|irda_usb_build_header
r_static
r_void
id|irda_usb_build_header
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
comma
id|u8
op_star
id|header
comma
r_int
id|force
)paren
(brace
multiline_comment|/* Set the negotiated link speed */
r_if
c_cond
(paren
id|self-&gt;new_speed
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Hum... Ugly hack :-(&n;&t;&t; * Some device are not compliant with the spec and change&n;&t;&t; * parameters *before* sending the frame. - Jean II&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;capability
op_amp
id|IUC_SPEED_BUG
)paren
op_logical_and
(paren
op_logical_neg
id|force
)paren
op_logical_and
(paren
id|self-&gt;speed
op_ne
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* No speed and xbofs change here&n;&t;&t;&t; * (we&squot;ll do it later in the write callback) */
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), not changing speed yet&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|header
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), changing speed to %d&bslash;n&quot;
comma
id|self-&gt;new_speed
)paren
suffix:semicolon
id|self-&gt;speed
op_assign
id|self-&gt;new_speed
suffix:semicolon
id|self-&gt;new_speed
op_assign
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|self-&gt;speed
)paren
(brace
r_case
l_int|2400
suffix:colon
op_star
id|header
op_assign
id|SPEED_2400
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
l_int|9600
suffix:colon
op_star
id|header
op_assign
id|SPEED_9600
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19200
suffix:colon
op_star
id|header
op_assign
id|SPEED_19200
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|38400
suffix:colon
op_star
id|header
op_assign
id|SPEED_38400
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|57600
suffix:colon
op_star
id|header
op_assign
id|SPEED_57600
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|115200
suffix:colon
op_star
id|header
op_assign
id|SPEED_115200
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|576000
suffix:colon
op_star
id|header
op_assign
id|SPEED_576000
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1152000
suffix:colon
op_star
id|header
op_assign
id|SPEED_1152000
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4000000
suffix:colon
op_star
id|header
op_assign
id|SPEED_4000000
suffix:semicolon
id|self-&gt;new_xbofs
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* No change */
op_star
id|header
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set the negotiated additional XBOFS */
r_if
c_cond
(paren
id|self-&gt;new_xbofs
op_ne
op_minus
l_int|1
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), changing xbofs to %d&bslash;n&quot;
comma
id|self-&gt;new_xbofs
)paren
suffix:semicolon
id|self-&gt;xbofs
op_assign
id|self-&gt;new_xbofs
suffix:semicolon
id|self-&gt;new_xbofs
op_assign
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|self-&gt;xbofs
)paren
(brace
r_case
l_int|48
suffix:colon
op_star
id|header
op_or_assign
l_int|0x10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|28
suffix:colon
r_case
l_int|24
suffix:colon
multiline_comment|/* USB spec 1.0 says 24 */
op_star
id|header
op_or_assign
l_int|0x20
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
l_int|12
suffix:colon
op_star
id|header
op_or_assign
l_int|0x30
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
multiline_comment|/* Bug in IrLAP spec? (should be 6) */
r_case
l_int|6
suffix:colon
op_star
id|header
op_or_assign
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
id|header
op_or_assign
l_int|0x50
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|header
op_or_assign
l_int|0x60
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
op_star
id|header
op_or_assign
l_int|0x70
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
op_star
id|header
op_or_assign
l_int|0x80
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|function|irda_usb_change_speed_xbofs
r_static
r_void
id|irda_usb_change_speed_xbofs
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|purb_t
id|purb
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), speed=%d, xbofs=%d&bslash;n&quot;
comma
id|self-&gt;new_speed
comma
id|self-&gt;new_xbofs
)paren
suffix:semicolon
id|purb
op_assign
op_amp
id|self-&gt;speed_urb
suffix:semicolon
r_if
c_cond
(paren
id|purb-&gt;status
op_ne
id|USB_ST_NOERROR
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), URB still in use!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|self-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Allocate the fake frame */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|IRDA_USB_SPEED_MTU
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
suffix:semicolon
(paren
(paren
r_struct
id|irda_skb_cb
op_star
)paren
id|skb-&gt;cb
)paren
op_member_access_from_pointer
id|context
op_assign
id|self
suffix:semicolon
multiline_comment|/* Set the new speed and xbofs in this fake frame */
id|irda_usb_build_header
c_func
(paren
id|self
comma
id|skb_put
c_func
(paren
id|skb
comma
id|USB_IRDA_HEADER
)paren
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Submit the 0 length IrDA frame to trigger new speed settings */
id|FILL_BULK_URB
c_func
(paren
id|purb
comma
id|self-&gt;usbdev
comma
id|usb_sndbulkpipe
c_func
(paren
id|self-&gt;usbdev
comma
id|self-&gt;bulk_out_ep
)paren
comma
id|skb-&gt;data
comma
id|IRDA_USB_MAX_MTU
comma
id|write_bulk_callback
comma
id|skb
)paren
suffix:semicolon
id|purb-&gt;transfer_buffer_length
op_assign
id|skb-&gt;len
suffix:semicolon
id|purb-&gt;transfer_flags
op_or_assign
id|USB_QUEUE_BULK
suffix:semicolon
id|purb-&gt;timeout
op_assign
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|purb
)paren
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), failed Speed URB&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|self-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|irda_usb_hard_xmit
r_static
r_int
id|irda_usb_hard_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|netdev
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
id|netdev-&gt;priv
suffix:semicolon
id|purb_t
id|purb
op_assign
op_amp
id|self-&gt;tx_urb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|s32
id|speed
suffix:semicolon
id|s16
id|xbofs
suffix:semicolon
r_int
id|mtt
suffix:semicolon
multiline_comment|/* Check if the device is still there */
r_if
c_cond
(paren
(paren
op_logical_neg
id|self
)paren
op_logical_or
(paren
op_logical_neg
id|self-&gt;present
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Device is gone...&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Failed */
)brace
id|netif_stop_queue
c_func
(paren
id|netdev
)paren
suffix:semicolon
multiline_comment|/* Check if we need to change the number of xbofs */
id|xbofs
op_assign
id|irda_get_next_xbofs
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xbofs
op_ne
id|self-&gt;xbofs
)paren
op_logical_and
(paren
id|xbofs
op_ne
op_minus
l_int|1
)paren
)paren
(brace
id|self-&gt;new_xbofs
op_assign
id|xbofs
suffix:semicolon
)brace
multiline_comment|/* Check if we need to change the speed */
id|speed
op_assign
id|irda_get_next_speed
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|speed
op_ne
id|self-&gt;speed
)paren
op_logical_and
(paren
id|speed
op_ne
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* Set the desired speed */
id|self-&gt;new_speed
op_assign
id|speed
suffix:semicolon
multiline_comment|/* Check for empty frame */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;len
)paren
(brace
multiline_comment|/* IrLAP send us an empty frame to make us change the&n;&t;&t;&t; * speed. Changing speed with the USB adapter is in&n;&t;&t;&t; * fact sending an empty frame to the adapter, so we&n;&t;&t;&t; * could just let the present function do its job.&n;&t;&t;&t; * However, we would wait for min turn time,&n;&t;&t;&t; * do an extra memcpy and increment packet counters...&n;&t;&t;&t; * Jean II */
id|irda_usb_change_speed_xbofs
c_func
(paren
id|self
)paren
suffix:semicolon
id|netdev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Will netif_wake_queue() in callback */
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|purb-&gt;status
op_ne
id|USB_ST_NOERROR
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), URB still in use!&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Make room for IrDA-USB header */
r_if
c_cond
(paren
id|skb_cow
c_func
(paren
id|skb
comma
id|USB_IRDA_HEADER
)paren
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|self-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Change setting for next frame */
id|irda_usb_build_header
c_func
(paren
id|self
comma
id|skb_push
c_func
(paren
id|skb
comma
id|USB_IRDA_HEADER
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* FIXME: Make macro out of this one */
(paren
(paren
r_struct
id|irda_skb_cb
op_star
)paren
id|skb-&gt;cb
)paren
op_member_access_from_pointer
id|context
op_assign
id|self
suffix:semicolon
id|FILL_BULK_URB
c_func
(paren
id|purb
comma
id|self-&gt;usbdev
comma
id|usb_sndbulkpipe
c_func
(paren
id|self-&gt;usbdev
comma
id|self-&gt;bulk_out_ep
)paren
comma
id|skb-&gt;data
comma
id|IRDA_USB_MAX_MTU
comma
id|write_bulk_callback
comma
id|skb
)paren
suffix:semicolon
id|purb-&gt;transfer_buffer_length
op_assign
id|skb-&gt;len
suffix:semicolon
id|purb-&gt;transfer_flags
op_or_assign
id|USB_QUEUE_BULK
suffix:semicolon
id|purb-&gt;timeout
op_assign
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Generate min turn time */
id|mtt
op_assign
id|irda_get_mtt
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtt
)paren
(brace
r_int
id|diff
suffix:semicolon
id|get_fast_time
c_func
(paren
op_amp
id|self-&gt;now
)paren
suffix:semicolon
id|diff
op_assign
id|self-&gt;now.tv_usec
op_minus
id|self-&gt;stamp.tv_usec
suffix:semicolon
r_if
c_cond
(paren
id|diff
OL
l_int|0
)paren
id|diff
op_add_assign
l_int|1000000
suffix:semicolon
multiline_comment|/* Check if the mtt is larger than the time we have&n;&t;&t; * already used by all the protocol processing&n;&t;&t; */
r_if
c_cond
(paren
id|mtt
OG
id|diff
)paren
(brace
id|mtt
op_sub_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|mtt
OG
l_int|1000
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;* FIXME: can we do better than this? Maybe call&n;&t;&t;&t;&t;* a function which sends a frame to a non &n;&t;&t;&t;&t;* existing device, or change the speed to the &n;&t;&t;&t;&t;* current one a number of times just to burn &n;&t;&t;&t;&t;* time a better way.&n;&t;&t;&t;&t;*/
id|mdelay
c_func
(paren
id|mtt
op_div
l_int|1000
)paren
suffix:semicolon
id|irda_usb_write_bulk
c_func
(paren
id|self
comma
id|purb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
id|udelay
c_func
(paren
id|mtt
)paren
suffix:semicolon
)brace
)brace
id|irda_usb_write_bulk
c_func
(paren
id|self
comma
id|purb
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|self-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|irda_usb_write_bulk
r_static
r_void
id|irda_usb_write_bulk
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
comma
id|purb_t
id|purb
)paren
(brace
r_int
id|len
op_assign
id|purb-&gt;transfer_buffer_length
suffix:semicolon
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res
op_assign
id|usb_submit_urb
c_func
(paren
id|purb
)paren
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), failed Tx URB&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|self-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|self-&gt;stats.tx_bytes
op_add_assign
id|len
suffix:semicolon
id|self-&gt;netdev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Send empty frame if size if a multiple of the USB max packet size */
id|ASSERT
c_func
(paren
id|self-&gt;bulk_out_mtu
op_eq
l_int|64
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_mod
id|self-&gt;bulk_out_mtu
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Borrow speed urb */
id|purb
op_assign
op_amp
id|self-&gt;speed_urb
suffix:semicolon
id|FILL_BULK_URB
c_func
(paren
id|purb
comma
id|self-&gt;usbdev
comma
id|usb_sndbulkpipe
c_func
(paren
id|self-&gt;usbdev
comma
id|self-&gt;bulk_out_ep
)paren
comma
id|self
comma
multiline_comment|/* Anything not on the stack will do */
id|IRDA_USB_MAX_MTU
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|purb-&gt;transfer_buffer_length
op_assign
l_int|0
suffix:semicolon
id|purb-&gt;transfer_flags
op_or_assign
id|USB_QUEUE_BULK
suffix:semicolon
id|res
op_assign
id|usb_submit_urb
c_func
(paren
id|purb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Note : this function will be called with both tx_urb and speed_urb...&n; */
DECL|function|write_bulk_callback
r_static
r_void
id|write_bulk_callback
c_func
(paren
id|purb_t
id|purb
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|purb-&gt;context
suffix:semicolon
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
(paren
(paren
r_struct
id|irda_skb_cb
op_star
)paren
id|skb-&gt;cb
)paren
op_member_access_from_pointer
id|context
suffix:semicolon
multiline_comment|/* We should always have a context */
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Bug : self == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* urb is now available */
id|purb-&gt;status
op_assign
id|USB_ST_NOERROR
suffix:semicolon
id|dev_kfree_skb_any
c_func
(paren
id|skb
)paren
suffix:semicolon
id|purb-&gt;context
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Check for timeout and other USB nasties */
r_if
c_cond
(paren
id|purb-&gt;status
op_ne
id|USB_ST_NOERROR
)paren
(brace
multiline_comment|/* I get a lot of -ECONNABORTED = -103 here - Jean II */
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), URB complete status %d, transfer_flags 0x%04X&bslash;n&quot;
comma
id|purb-&gt;status
comma
id|purb-&gt;transfer_flags
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t do anything here, that might confuse the USB layer,&n;&t;         * and we could go in recursion and blow the kernel stack...&n;&t;         * Instead, we will wait for irda_usb_net_timeout(), the&n;&t;         * network layer watchdog, to fix the situation.&n;&t;         * Jean II */
multiline_comment|/* A reset of the dongle might be welcomed here - Jean II */
r_return
suffix:semicolon
)brace
multiline_comment|/* URB is now available */
id|purb-&gt;status
op_assign
id|USB_ST_NOERROR
suffix:semicolon
multiline_comment|/* If the network is closed, stop everything */
r_if
c_cond
(paren
(paren
op_logical_neg
id|self-&gt;netopen
)paren
op_logical_or
(paren
op_logical_neg
id|self-&gt;present
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Network is gone...&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If we need to change the speed or xbofs, do it now */
r_if
c_cond
(paren
(paren
id|self-&gt;new_speed
op_ne
op_minus
l_int|1
)paren
op_logical_or
(paren
id|self-&gt;new_xbofs
op_ne
op_minus
l_int|1
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Changing speed now...&bslash;n&quot;
)paren
suffix:semicolon
id|irda_usb_change_speed_xbofs
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, allow the stack to send more packets */
id|netif_wake_queue
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
)brace
)brace
DECL|function|irda_usb_submit
r_static
r_void
id|irda_usb_submit
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
comma
id|purb_t
id|purb
)paren
(brace
r_struct
id|irda_skb_cb
op_star
id|cb
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check that we have an urb */
r_if
c_cond
(paren
op_logical_neg
id|purb
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Bug : purb == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Allocate new skb if it has not been recycled */
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|IRDA_USB_MAX_MTU
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
multiline_comment|/* If this ever happen, we are in deep s***.&n;&t;&t;&t; * Basically, the Rx path will stop... */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Failed to allocate Rx skb&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Reset recycled skb */
id|skb-&gt;data
op_assign
id|skb-&gt;tail
op_assign
id|skb-&gt;head
suffix:semicolon
id|skb-&gt;len
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Make sure IP header get aligned (IrDA header is 5 bytes ) */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Save ourselves */
id|cb
op_assign
(paren
r_struct
id|irda_skb_cb
op_star
)paren
id|skb-&gt;cb
suffix:semicolon
id|cb-&gt;context
op_assign
id|self
suffix:semicolon
multiline_comment|/* Reinitialize URB */
id|FILL_BULK_URB
c_func
(paren
id|purb
comma
id|self-&gt;usbdev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|self-&gt;usbdev
comma
id|self-&gt;bulk_in_ep
)paren
comma
id|skb-&gt;data
comma
id|skb-&gt;truesize
comma
id|irda_usb_receive
comma
id|skb
)paren
suffix:semicolon
id|purb-&gt;transfer_flags
op_or_assign
id|USB_QUEUE_BULK
suffix:semicolon
id|purb-&gt;status
op_assign
id|USB_ST_NOERROR
suffix:semicolon
id|purb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Make sure we don&squot;t auto resubmit */
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|purb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* If this ever happen, we are in deep s***.&n;&t;&t; * Basically, the Rx path will stop... */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Failed to submit Rx URB %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function irda_usb_receive(purb)&n; *&n; *     Called by the USB subsystem when a frame has been received&n; *&n; */
DECL|function|irda_usb_receive
r_static
r_void
id|irda_usb_receive
c_func
(paren
id|purb_t
id|purb
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|purb-&gt;context
suffix:semicolon
r_struct
id|irda_usb_cb
op_star
id|self
suffix:semicolon
r_struct
id|irda_skb_cb
op_star
id|cb
suffix:semicolon
r_struct
id|sk_buff
op_star
r_new
suffix:semicolon
multiline_comment|/* Find ourselves */
id|cb
op_assign
(paren
r_struct
id|irda_skb_cb
op_star
)paren
id|skb-&gt;cb
suffix:semicolon
id|ASSERT
c_func
(paren
id|cb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_usb_cb
op_star
)paren
id|cb-&gt;context
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* If the network is closed or the device gone, stop everything */
r_if
c_cond
(paren
(paren
op_logical_neg
id|self-&gt;netopen
)paren
op_logical_or
(paren
op_logical_neg
id|self-&gt;present
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Network is gone!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t re-submit the URB : will stall the Rx path */
r_return
suffix:semicolon
)brace
multiline_comment|/* Check the status */
r_if
c_cond
(paren
id|purb-&gt;status
op_ne
id|USB_ST_NOERROR
)paren
(brace
r_switch
c_cond
(paren
id|purb-&gt;status
)paren
(brace
r_case
id|USB_ST_CRC
suffix:colon
multiline_comment|/* -EILSEQ */
id|self-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|self-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ECONNRESET
suffix:colon
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), Connection Reset !!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* uhci_cleanup_unlink() is going to kill the Rx&n;&t;&t;&t; * URB just after we return. No problem, at this&n;&t;&t;&t; * point the URB will be idle ;-) - Jean II */
r_break
suffix:semicolon
r_default
suffix:colon
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), RX status %d&bslash;n&quot;
comma
id|purb-&gt;status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* Check for empty frames */
r_if
c_cond
(paren
id|purb-&gt;actual_length
op_le
id|USB_IRDA_HEADER
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), empty frame!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*  &n;&t; * Remember the time we received this frame, so we can&n;&t; * reduce the min turn time a bit since we will know&n;&t; * how much time we have used for protocol processing&n;&t; */
id|get_fast_time
c_func
(paren
op_amp
id|self-&gt;stamp
)paren
suffix:semicolon
multiline_comment|/* Fix skb, and remove USB-IrDA header */
id|skb_put
c_func
(paren
id|skb
comma
id|purb-&gt;actual_length
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|USB_IRDA_HEADER
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t waste a lot of memory on small IrDA frames */
r_if
c_cond
(paren
id|skb-&gt;len
OL
id|RX_COPY_THRESHOLD
)paren
(brace
r_new
op_assign
id|dev_alloc_skb
c_func
(paren
id|skb-&gt;len
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
(brace
id|self-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* Make sure IP header get aligned (IrDA header is 5 bytes) */
id|skb_reserve
c_func
(paren
r_new
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Copy packet, so we can recycle the original */
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
r_new
comma
id|skb-&gt;len
)paren
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* We will cleanup the skb in irda_usb_submit */
)brace
r_else
(brace
multiline_comment|/* Deliver the original skb */
r_new
op_assign
id|skb
suffix:semicolon
id|skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|self-&gt;stats.rx_bytes
op_add_assign
r_new
op_member_access_from_pointer
id|len
suffix:semicolon
id|self-&gt;stats.rx_packets
op_increment
suffix:semicolon
multiline_comment|/* Ask the networking layer to queue the packet for the IrDA stack */
r_new
op_member_access_from_pointer
id|dev
op_assign
id|self-&gt;netdev
suffix:semicolon
r_new
op_member_access_from_pointer
id|mac.raw
op_assign
r_new
op_member_access_from_pointer
id|data
suffix:semicolon
r_new
op_member_access_from_pointer
id|protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IRDA
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
r_new
)paren
suffix:semicolon
id|done
suffix:colon
multiline_comment|/* Recycle Rx URB (and possible the skb as well) */
id|irda_usb_submit
c_func
(paren
id|self
comma
id|skb
comma
id|self-&gt;rx_idle_urb
)paren
suffix:semicolon
multiline_comment|/* Recycle Rx URB : Now, the idle URB is the present one */
id|self-&gt;rx_idle_urb
op_assign
id|purb
suffix:semicolon
id|purb-&gt;context
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Prevent the USB layer playing games with our URBs */
id|purb-&gt;status
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
DECL|function|irda_usb_net_init
r_static
r_int
id|irda_usb_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Set up to be a normal IrDA network device driver */
id|irda_device_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Insert overrides below this line! */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_usb_net_open (dev)&n; *&n; *    Network device is taken up. Usually this is done by &quot;ifconfig irda0 up&quot; &n; *   &n; * Note : don&squot;t mess with self-&gt;netopen - Jean II&n; */
DECL|function|irda_usb_net_open
r_static
r_int
id|irda_usb_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|netdev
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
suffix:semicolon
r_int
id|i
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_usb_cb
op_star
)paren
id|netdev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Can only open the device if it&squot;s there */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;present
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), device not present!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Initialise default speed and xbofs value&n;&t; * (IrLAP will change that soon) */
id|self-&gt;speed
op_assign
op_minus
l_int|1
suffix:semicolon
id|self-&gt;xbofs
op_assign
op_minus
l_int|1
suffix:semicolon
id|self-&gt;new_speed
op_assign
op_minus
l_int|1
suffix:semicolon
id|self-&gt;new_xbofs
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* To do *before* submitting Rx urbs and starting net Tx queue&n;&t; * Jean II */
id|self-&gt;netopen
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;&t; * Now that everything should be initialized properly,&n;&t; * Open new IrLAP layer instance to take care of us...&n;&t; * Note : will send immediately a speed change...&n;&t; */
id|self-&gt;irlap
op_assign
id|irlap_open
c_func
(paren
id|netdev
comma
op_amp
id|self-&gt;qos
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;irlap
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Allow IrLAP to send data to us */
id|netif_start_queue
c_func
(paren
id|netdev
)paren
suffix:semicolon
multiline_comment|/* Now that we can pass data to IrLAP, allow the USB layer&n;&t; * to send us some data... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IU_MAX_ACTIVE_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
id|irda_usb_submit
c_func
(paren
id|self
comma
l_int|NULL
comma
op_amp
(paren
id|self-&gt;rx_urb
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* Note : we submit all the Rx URB except for one - Jean II */
id|self-&gt;rx_idle_urb
op_assign
op_amp
(paren
id|self-&gt;rx_urb
(braket
id|IU_MAX_ACTIVE_RX_URBS
)braket
)paren
suffix:semicolon
id|self-&gt;rx_idle_urb-&gt;context
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Ready to play !!! */
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function irda_usb_net_close (self)&n; *&n; *    Network device is taken down. Usually this is done by &n; *    &quot;ifconfig irda0 down&quot; &n; */
DECL|function|irda_usb_net_close
r_static
r_int
id|irda_usb_net_close
c_func
(paren
r_struct
id|net_device
op_star
id|netdev
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
suffix:semicolon
r_int
id|i
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_usb_cb
op_star
)paren
id|netdev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Clear this flag *before* unlinking the urbs and *before*&n;&t; * stopping the network Tx queue - Jean II */
id|self-&gt;netopen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Stop network Tx queue */
id|netif_stop_queue
c_func
(paren
id|netdev
)paren
suffix:semicolon
multiline_comment|/* Deallocate all the Rx path buffers (URBs and skb) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IU_MAX_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|purb_t
id|purb
op_assign
op_amp
(paren
id|self-&gt;rx_urb
(braket
id|i
)braket
)paren
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|purb-&gt;context
suffix:semicolon
multiline_comment|/* Cancel the receive command */
id|usb_unlink_urb
c_func
(paren
id|purb
)paren
suffix:semicolon
multiline_comment|/* The skb is ours, free it */
r_if
c_cond
(paren
id|skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|purb-&gt;context
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Cancel Tx and speed URB */
id|usb_unlink_urb
c_func
(paren
op_amp
id|self-&gt;tx_urb
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
op_amp
id|self-&gt;speed_urb
)paren
suffix:semicolon
multiline_comment|/* Stop and remove instance of IrLAP */
r_if
c_cond
(paren
id|self-&gt;irlap
)paren
id|irlap_close
c_func
(paren
id|self-&gt;irlap
)paren
suffix:semicolon
id|self-&gt;irlap
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|irda_usb_net_timeout
r_static
r_void
id|irda_usb_net_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|netdev
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
id|netdev-&gt;priv
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If we have made any progress */
id|purb_t
id|purb
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Network layer thinks we timed out!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self
op_logical_or
op_logical_neg
id|self-&gt;present
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), device not present!&bslash;n&quot;
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|netdev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|WARNING
c_func
(paren
l_string|&quot;%s: Tx timed out&bslash;n&quot;
comma
id|netdev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Check Tx URB */
id|purb
op_assign
op_amp
id|self-&gt;tx_urb
suffix:semicolon
r_switch
c_cond
(paren
id|purb-&gt;status
)paren
(brace
r_case
op_minus
id|ECONNABORTED
suffix:colon
multiline_comment|/* Can&squot;t find proper USB_ST_* code */
id|purb-&gt;status
op_assign
id|USB_ST_NOERROR
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_ST_URB_PENDING
suffix:colon
multiline_comment|/* -EINPROGRESS == -115 */
id|usb_unlink_urb
c_func
(paren
id|purb
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* Check speed URB */
id|purb
op_assign
op_amp
id|self-&gt;speed_urb
suffix:semicolon
r_switch
c_cond
(paren
id|purb-&gt;status
)paren
(brace
r_case
op_minus
id|ECONNABORTED
suffix:colon
multiline_comment|/* Can&squot;t find proper USB_ST_* code */
id|purb-&gt;status
op_assign
id|USB_ST_NOERROR
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_ST_URB_PENDING
suffix:colon
multiline_comment|/* -EINPROGRESS */
id|usb_unlink_urb
c_func
(paren
id|purb
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* Maybe we need a reset */
multiline_comment|/* if(done == 0) */
)brace
DECL|function|irda_usb_is_receiving
r_static
r_int
id|irda_usb_is_receiving
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* For now */
)brace
DECL|function|irda_usb_net_ioctl
r_static
r_int
id|irda_usb_net_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
r_struct
id|if_irda_req
op_star
id|irq
op_assign
(paren
r_struct
id|if_irda_req
op_star
)paren
id|rq
suffix:semicolon
r_struct
id|irda_usb_cb
op_star
id|self
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|dev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), %s, (cmd=0x%X)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* Check if the device is still there */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;present
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCSBANDWIDTH
suffix:colon
multiline_comment|/* Set bandwidth */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* Set the desired speed */
id|self-&gt;new_speed
op_assign
id|irq-&gt;ifr_baudrate
suffix:semicolon
id|irda_usb_change_speed_xbofs
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Note : will spinlock in above function */
r_break
suffix:semicolon
r_case
id|SIOCSMEDIABUSY
suffix:colon
multiline_comment|/* Set media busy */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|self-&gt;netdev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGRECEIVING
suffix:colon
multiline_comment|/* Check if we are receiving right now */
id|irq-&gt;ifr_receiving
op_assign
id|irda_usb_is_receiving
c_func
(paren
id|self
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|irda_usb_net_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|irda_usb_net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|self-&gt;stats
suffix:semicolon
)brace
DECL|function|usb_irda_init
r_int
id|__init
id|usb_irda_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|irda_driver
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|MESSAGE
c_func
(paren
l_string|&quot;USB IrDA support registered&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_irda_init
id|module_init
c_func
(paren
id|usb_irda_init
)paren
suffix:semicolon
DECL|function|usb_irda_cleanup
r_void
id|__exit
id|usb_irda_cleanup
c_func
(paren
r_void
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|irda
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Find zombie instances and kill them... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NIRUSB
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irda
op_assign
op_amp
id|irda_instance
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* If the Device is zombie */
r_if
c_cond
(paren
(paren
id|irda-&gt;usbdev
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|irda-&gt;present
op_eq
l_int|0
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), disconnect zombie now !&bslash;n&quot;
)paren
suffix:semicolon
id|irda_usb_disconnect
c_func
(paren
id|irda-&gt;usbdev
comma
(paren
r_void
op_star
)paren
id|irda
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Deregister the driver and remove all pending instances */
id|usb_deregister
c_func
(paren
op_amp
id|irda_driver
)paren
suffix:semicolon
)brace
DECL|variable|usb_irda_cleanup
id|module_exit
c_func
(paren
id|usb_irda_cleanup
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|qos_mtt_bits
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|qos_mtt_bits
comma
l_string|&quot;Minimum Turn Time&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Roman Weissgaerber &lt;weissg@vienna.at&gt;, Dag Brattli &lt;dag@brattli.net&gt; and Jean Tourrilhes &lt;jt@hpl.hp.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;IrDA-USB Dongle Driver&quot;
)paren
suffix:semicolon
eof
