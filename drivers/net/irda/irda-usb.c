multiline_comment|/*****************************************************************************&n; *&n; * Filename:      irda-usb.c&n; * Version:       0.9b&n; * Description:   IrDA-USB Driver&n; * Status:        Experimental &n; * Author:        Dag Brattli &lt;dag@brattli.net&gt;&n; *&n; *&t;Copyright (C) 2000, Roman Weissgaerber &lt;weissg@vienna.at&gt;&n; *      Copyright (C) 2001, Dag Brattli &lt;dag@brattli.net&gt;&n; *      Copyright (C) 2001, Jean Tourrilhes &lt;jt@hpl.hp.com&gt;&n; *          &n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *&t;&t;&t;    IMPORTANT NOTE&n; *&t;&t;&t;    --------------&n; *&n; * As of kernel 2.4.10, this is the state of compliance and testing of&n; * this driver (irda-usb) with regards to the USB low level drivers...&n; *&n; * This driver has been tested SUCCESSFULLY with the following drivers :&n; *&t;o usb-uhci&t;(For Intel/Via USB controllers)&n; *&t;o usb-ohci&t;(For other USB controllers)&n; *&n; * This driver has NOT been tested with the following drivers :&n; *&t;o usb-ehci&t;(USB 2.0 controllers)&n; *&n; * This driver WON&squot;T WORK with the following drivers :&n; *&t;o uhci&t;&t;(Alternate/JE driver for Intel/Via USB controllers)&n; * Amongst the reasons :&n; *&t;o uhci doesn&squot;t implement USB_ZERO_PACKET&n; *&t;o uhci non-compliant use of urb-&gt;timeout&n; *&n; * Jean II&n; */
multiline_comment|/*------------------------------------------------------------------*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irlap.h&gt;
macro_line|#include &lt;net/irda/irda_device.h&gt;
macro_line|#include &lt;net/irda/wrapper.h&gt;
macro_line|#include &lt;net/irda/irda-usb.h&gt;
multiline_comment|/*------------------------------------------------------------------*/
DECL|variable|qos_mtt_bits
r_static
r_int
id|qos_mtt_bits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Master instance for each hardware found */
DECL|macro|NIRUSB
mdefine_line|#define NIRUSB 4&t;&t;/* Max number of USB-IrDA dongles */
DECL|variable|irda_instance
r_static
r_struct
id|irda_usb_cb
id|irda_instance
(braket
id|NIRUSB
)braket
suffix:semicolon
multiline_comment|/* These are the currently known IrDA USB dongles. Add new dongles here */
DECL|variable|dongles
r_static
r_struct
id|usb_device_id
id|dongles
(braket
)braket
op_assign
(brace
multiline_comment|/* ACTiSYS Corp,  ACT-IR2000U FIR-USB Adapter */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x9c4
comma
l_int|0x011
)paren
comma
id|driver_info
suffix:colon
id|IUC_SPEED_BUG
op_or
id|IUC_NO_WINDOW
)brace
comma
multiline_comment|/* KC Technology Inc.,  KC-180 USB IrDA Device */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x50f
comma
l_int|0x180
)paren
comma
id|driver_info
suffix:colon
id|IUC_SPEED_BUG
op_or
id|IUC_NO_WINDOW
)brace
comma
multiline_comment|/* Extended Systems, Inc.,  XTNDAccess IrDA USB (ESI-9685) */
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x8e9
comma
l_int|0x100
)paren
comma
id|driver_info
suffix:colon
id|IUC_SPEED_BUG
op_or
id|IUC_NO_WINDOW
)brace
comma
(brace
id|match_flags
suffix:colon
id|USB_DEVICE_ID_MATCH_INT_CLASS
op_or
id|USB_DEVICE_ID_MATCH_INT_SUBCLASS
comma
id|bInterfaceClass
suffix:colon
id|USB_CLASS_APP_SPEC
comma
id|bInterfaceSubClass
suffix:colon
id|USB_CLASS_IRDA
comma
id|driver_info
suffix:colon
id|IUC_DEFAULT
comma
)brace
comma
(brace
)brace
comma
multiline_comment|/* The end */
)brace
suffix:semicolon
multiline_comment|/*&n; * Important note :&n; * Devices based on the SigmaTel chipset (0x66f, 0x4200) are not compliant&n; * with the USB-IrDA specification (and actually very very different), and&n; * there is no way this driver can support those devices, apart from&n; * a complete rewrite...&n; * Jean II&n; */
id|MODULE_DEVICE_TABLE
c_func
(paren
id|usb
comma
id|dongles
)paren
suffix:semicolon
multiline_comment|/*------------------------------------------------------------------*/
r_static
r_struct
id|irda_class_desc
op_star
id|irda_usb_find_class_desc
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
suffix:semicolon
r_static
r_void
id|irda_usb_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|irda_usb_change_speed_xbofs
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_hard_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_open
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_close
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
suffix:semicolon
r_static
r_void
id|speed_bulk_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|write_bulk_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|irda_usb_receive
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|irda_usb_net_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|irda_usb_net_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|irda_usb_net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/************************ TRANSMIT ROUTINES ************************/
multiline_comment|/*&n; * Receive packets from the IrDA stack and send them on the USB pipe.&n; * Handle speed change, timeout and lot&squot;s of uglyness...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_usb_build_header(self, skb, header)&n; *&n; *   Builds USB-IrDA outbound header&n; *&n; * When we send an IrDA frame over an USB pipe, we add to it a 1 byte&n; * header. This function create this header with the proper values.&n; *&n; * Important note : the USB-IrDA spec 1.0 say very clearly in chapter 5.4.2.2&n; * that the setting of the link speed and xbof number in this outbound header&n; * should be applied *AFTER* the frame has been sent.&n; * Unfortunately, some devices are not compliant with that... It seems that&n; * reading the spec is far too difficult...&n; * Jean II&n; */
DECL|function|irda_usb_build_header
r_static
r_void
id|irda_usb_build_header
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
comma
id|__u8
op_star
id|header
comma
r_int
id|force
)paren
(brace
multiline_comment|/* Set the negotiated link speed */
r_if
c_cond
(paren
id|self-&gt;new_speed
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Hum... Ugly hack :-(&n;&t;&t; * Some device are not compliant with the spec and change&n;&t;&t; * parameters *before* sending the frame. - Jean II&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|self-&gt;capability
op_amp
id|IUC_SPEED_BUG
)paren
op_logical_and
(paren
op_logical_neg
id|force
)paren
op_logical_and
(paren
id|self-&gt;speed
op_ne
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* No speed and xbofs change here&n;&t;&t;&t; * (we&squot;ll do it later in the write callback) */
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), not changing speed yet&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|header
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), changing speed to %d&bslash;n&quot;
comma
id|self-&gt;new_speed
)paren
suffix:semicolon
id|self-&gt;speed
op_assign
id|self-&gt;new_speed
suffix:semicolon
id|self-&gt;new_speed
op_assign
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|self-&gt;speed
)paren
(brace
r_case
l_int|2400
suffix:colon
op_star
id|header
op_assign
id|SPEED_2400
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
l_int|9600
suffix:colon
op_star
id|header
op_assign
id|SPEED_9600
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19200
suffix:colon
op_star
id|header
op_assign
id|SPEED_19200
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|38400
suffix:colon
op_star
id|header
op_assign
id|SPEED_38400
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|57600
suffix:colon
op_star
id|header
op_assign
id|SPEED_57600
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|115200
suffix:colon
op_star
id|header
op_assign
id|SPEED_115200
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|576000
suffix:colon
op_star
id|header
op_assign
id|SPEED_576000
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1152000
suffix:colon
op_star
id|header
op_assign
id|SPEED_1152000
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4000000
suffix:colon
op_star
id|header
op_assign
id|SPEED_4000000
suffix:semicolon
id|self-&gt;new_xbofs
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* No change */
op_star
id|header
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set the negotiated additional XBOFS */
r_if
c_cond
(paren
id|self-&gt;new_xbofs
op_ne
op_minus
l_int|1
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), changing xbofs to %d&bslash;n&quot;
comma
id|self-&gt;new_xbofs
)paren
suffix:semicolon
id|self-&gt;xbofs
op_assign
id|self-&gt;new_xbofs
suffix:semicolon
id|self-&gt;new_xbofs
op_assign
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|self-&gt;xbofs
)paren
(brace
r_case
l_int|48
suffix:colon
op_star
id|header
op_or_assign
l_int|0x10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|28
suffix:colon
r_case
l_int|24
suffix:colon
multiline_comment|/* USB spec 1.0 says 24 */
op_star
id|header
op_or_assign
l_int|0x20
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
l_int|12
suffix:colon
op_star
id|header
op_or_assign
l_int|0x30
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
multiline_comment|/* Bug in IrLAP spec? (should be 6) */
r_case
l_int|6
suffix:colon
op_star
id|header
op_or_assign
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
id|header
op_or_assign
l_int|0x50
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|header
op_or_assign
l_int|0x60
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
op_star
id|header
op_or_assign
l_int|0x70
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
op_star
id|header
op_or_assign
l_int|0x80
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Send a command to change the speed of the dongle&n; */
DECL|function|irda_usb_change_speed_xbofs
r_static
r_void
id|irda_usb_change_speed_xbofs
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__u8
op_star
id|frame
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), speed=%d, xbofs=%d&bslash;n&quot;
comma
id|self-&gt;new_speed
comma
id|self-&gt;new_xbofs
)paren
suffix:semicolon
multiline_comment|/* Grab the speed URB */
id|urb
op_assign
id|self-&gt;speed_urb
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
l_int|0
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), URB still in use!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|self-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Allocate the fake frame */
id|frame
op_assign
id|self-&gt;speed_buff
suffix:semicolon
multiline_comment|/* Set the new speed and xbofs in this fake frame */
id|irda_usb_build_header
c_func
(paren
id|self
comma
id|frame
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Submit the 0 length IrDA frame to trigger new speed settings */
id|FILL_BULK_URB
c_func
(paren
id|urb
comma
id|self-&gt;usbdev
comma
id|usb_sndbulkpipe
c_func
(paren
id|self-&gt;usbdev
comma
id|self-&gt;bulk_out_ep
)paren
comma
id|frame
comma
id|IRDA_USB_SPEED_MTU
comma
id|speed_bulk_callback
comma
id|self
)paren
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|USB_IRDA_HEADER
suffix:semicolon
id|urb-&gt;transfer_flags
op_assign
id|USB_QUEUE_BULK
op_or
id|USB_ASYNC_UNLINK
suffix:semicolon
id|urb-&gt;timeout
op_assign
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), failed Speed URB&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|self-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Note : this function will be called with both speed_urb and empty_urb...&n; */
DECL|function|speed_bulk_callback
r_static
r_void
id|speed_bulk_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
id|urb-&gt;context
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We should always have a context */
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), Bug : self == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check for timeout and other USB nasties */
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
l_int|0
)paren
(brace
multiline_comment|/* I get a lot of -ECONNABORTED = -103 here - Jean II */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), URB complete status %d, transfer_flags 0x%04X&bslash;n&quot;
comma
id|urb-&gt;status
comma
id|urb-&gt;transfer_flags
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t do anything here, that might confuse the USB layer.&n;&t;&t; * Instead, we will wait for irda_usb_net_timeout(), the&n;&t;&t; * network layer watchdog, to fix the situation.&n;&t;&t; * Jean II */
multiline_comment|/* A reset of the dongle might be welcomed here - Jean II */
r_return
suffix:semicolon
)brace
multiline_comment|/* urb is now available */
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If it was the speed URB, allow the stack to send more packets */
r_if
c_cond
(paren
id|urb
op_eq
id|self-&gt;speed_urb
)paren
(brace
id|netif_wake_queue
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Send an IrDA frame to the USB dongle (for transmission)&n; */
DECL|function|irda_usb_hard_xmit
r_static
r_int
id|irda_usb_hard_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|netdev
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
id|netdev-&gt;priv
suffix:semicolon
r_struct
id|urb
op_star
id|urb
op_assign
id|self-&gt;tx_urb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|s32
id|speed
suffix:semicolon
id|s16
id|xbofs
suffix:semicolon
r_int
id|res
comma
id|mtt
suffix:semicolon
multiline_comment|/* Check if the device is still there */
r_if
c_cond
(paren
(paren
op_logical_neg
id|self
)paren
op_logical_or
(paren
op_logical_neg
id|self-&gt;present
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Device is gone...&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Failed */
)brace
id|netif_stop_queue
c_func
(paren
id|netdev
)paren
suffix:semicolon
multiline_comment|/* Check if we need to change the number of xbofs */
id|xbofs
op_assign
id|irda_get_next_xbofs
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xbofs
op_ne
id|self-&gt;xbofs
)paren
op_logical_and
(paren
id|xbofs
op_ne
op_minus
l_int|1
)paren
)paren
(brace
id|self-&gt;new_xbofs
op_assign
id|xbofs
suffix:semicolon
)brace
multiline_comment|/* Check if we need to change the speed */
id|speed
op_assign
id|irda_get_next_speed
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|speed
op_ne
id|self-&gt;speed
)paren
op_logical_and
(paren
id|speed
op_ne
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* Set the desired speed */
id|self-&gt;new_speed
op_assign
id|speed
suffix:semicolon
multiline_comment|/* Check for empty frame */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;len
)paren
(brace
multiline_comment|/* IrLAP send us an empty frame to make us change the&n;&t;&t;&t; * speed. Changing speed with the USB adapter is in&n;&t;&t;&t; * fact sending an empty frame to the adapter, so we&n;&t;&t;&t; * could just let the present function do its job.&n;&t;&t;&t; * However, we would wait for min turn time,&n;&t;&t;&t; * do an extra memcpy and increment packet counters...&n;&t;&t;&t; * Jean II */
id|irda_usb_change_speed_xbofs
c_func
(paren
id|self
)paren
suffix:semicolon
id|netdev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Will netif_wake_queue() in callback */
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
l_int|0
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), URB still in use!&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Make sure there is room for IrDA-USB header. The actual&n;&t; * allocation will be done lower in skb_push().&n;&t; * Also, we don&squot;t use directly skb_cow(), because it require&n;&t; * headroom &gt;= 16, which force unnecessary copies - Jean II */
r_if
c_cond
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
id|USB_IRDA_HEADER
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Insuficient skb headroom.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_cow
c_func
(paren
id|skb
comma
id|USB_IRDA_HEADER
)paren
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), failed skb_cow() !!!&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|self-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Change setting for next frame */
id|irda_usb_build_header
c_func
(paren
id|self
comma
id|skb_push
c_func
(paren
id|skb
comma
id|USB_IRDA_HEADER
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* FIXME: Make macro out of this one */
(paren
(paren
r_struct
id|irda_skb_cb
op_star
)paren
id|skb-&gt;cb
)paren
op_member_access_from_pointer
id|context
op_assign
id|self
suffix:semicolon
id|FILL_BULK_URB
c_func
(paren
id|urb
comma
id|self-&gt;usbdev
comma
id|usb_sndbulkpipe
c_func
(paren
id|self-&gt;usbdev
comma
id|self-&gt;bulk_out_ep
)paren
comma
id|skb-&gt;data
comma
id|IRDA_USB_MAX_MTU
comma
id|write_bulk_callback
comma
id|skb
)paren
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/* Note : unlink *must* be Asynchronous because of the code in &n;&t; * irda_usb_net_timeout() -&gt; call in irq - Jean II */
id|urb-&gt;transfer_flags
op_assign
id|USB_QUEUE_BULK
op_or
id|USB_ASYNC_UNLINK
suffix:semicolon
multiline_comment|/* This flag (USB_ZERO_PACKET) indicates that what we send is not&n;&t; * a continuous stream of data but separate packets.&n;&t; * In this case, the USB layer will insert an empty USB frame (TD)&n;&t; * after each of our packets that is exact multiple of the frame size.&n;&t; * This is how the dongle will detect the end of packet - Jean II */
id|urb-&gt;transfer_flags
op_or_assign
id|USB_ZERO_PACKET
suffix:semicolon
multiline_comment|/* Timeout need to be shorter than NET watchdog timer */
id|urb-&gt;timeout
op_assign
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|200
)paren
suffix:semicolon
multiline_comment|/* Generate min turn time. FIXME: can we do better than this? */
multiline_comment|/* Trying to a turnaround time at this level is trying to measure&n;&t; * processor clock cycle with a wrist-watch, approximate at best...&n;&t; *&n;&t; * What we know is the last time we received a frame over USB.&n;&t; * Due to latency over USB that depend on the USB load, we don&squot;t&n;&t; * know when this frame was received over IrDA (a few ms before ?)&n;&t; * Then, same story for our outgoing frame...&n;&t; *&n;&t; * In theory, the USB dongle is supposed to handle the turnaround&n;&t; * by itself (spec 1.0, chater 4, page 6). Who knows ??? That&squot;s&n;&t; * why this code is enabled only for dongles that doesn&squot;t meet&n;&t; * the spec.&n;&t; * Jean II */
r_if
c_cond
(paren
id|self-&gt;capability
op_amp
id|IUC_NO_TURN
)paren
(brace
id|mtt
op_assign
id|irda_get_mtt
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtt
)paren
(brace
r_int
id|diff
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|self-&gt;now
)paren
suffix:semicolon
id|diff
op_assign
id|self-&gt;now.tv_usec
op_minus
id|self-&gt;stamp.tv_usec
suffix:semicolon
macro_line|#ifdef IU_USB_MIN_RTT
multiline_comment|/* Factor in USB delays -&gt; Get rid of udelay() that&n;&t;&t;&t; * would be lost in the noise - Jean II */
id|diff
op_add_assign
id|IU_USB_MIN_RTT
suffix:semicolon
macro_line|#endif /* IU_USB_MIN_RTT */
r_if
c_cond
(paren
id|diff
OL
l_int|0
)paren
id|diff
op_add_assign
l_int|1000000
suffix:semicolon
multiline_comment|/* Check if the mtt is larger than the time we have&n;&t;&t;&t; * already used by all the protocol processing&n;&t;&t;&t; */
r_if
c_cond
(paren
id|mtt
OG
id|diff
)paren
(brace
id|mtt
op_sub_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|mtt
OG
l_int|1000
)paren
id|mdelay
c_func
(paren
id|mtt
op_div
l_int|1000
)paren
suffix:semicolon
r_else
id|udelay
c_func
(paren
id|mtt
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Ask USB to send the packet */
r_if
c_cond
(paren
(paren
id|res
op_assign
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), failed Tx URB&bslash;n&quot;
)paren
suffix:semicolon
id|self-&gt;stats.tx_errors
op_increment
suffix:semicolon
multiline_comment|/* Let USB recover : We will catch that in the watchdog */
multiline_comment|/*netif_start_queue(netdev);*/
)brace
r_else
(brace
multiline_comment|/* Increment packet stats */
id|self-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|self-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|netdev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|self-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Note : this function will be called only for tx_urb...&n; */
DECL|function|write_bulk_callback
r_static
r_void
id|write_bulk_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|urb-&gt;context
suffix:semicolon
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
(paren
(paren
r_struct
id|irda_skb_cb
op_star
)paren
id|skb-&gt;cb
)paren
op_member_access_from_pointer
id|context
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We should always have a context */
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), Bug : self == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Free up the skb */
id|dev_kfree_skb_any
c_func
(paren
id|skb
)paren
suffix:semicolon
id|urb-&gt;context
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Check for timeout and other USB nasties */
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
l_int|0
)paren
(brace
multiline_comment|/* I get a lot of -ECONNABORTED = -103 here - Jean II */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), URB complete status %d, transfer_flags 0x%04X&bslash;n&quot;
comma
id|urb-&gt;status
comma
id|urb-&gt;transfer_flags
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t do anything here, that might confuse the USB layer,&n;&t;&t; * and we could go in recursion and blow the kernel stack...&n;&t;&t; * Instead, we will wait for irda_usb_net_timeout(), the&n;&t;&t; * network layer watchdog, to fix the situation.&n;&t;&t; * Jean II */
multiline_comment|/* A reset of the dongle might be welcomed here - Jean II */
r_return
suffix:semicolon
)brace
multiline_comment|/* urb is now available */
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If the network is closed, stop everything */
r_if
c_cond
(paren
(paren
op_logical_neg
id|self-&gt;netopen
)paren
op_logical_or
(paren
op_logical_neg
id|self-&gt;present
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Network is gone...&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If we need to change the speed or xbofs, do it now */
r_if
c_cond
(paren
(paren
id|self-&gt;new_speed
op_ne
op_minus
l_int|1
)paren
op_logical_or
(paren
id|self-&gt;new_xbofs
op_ne
op_minus
l_int|1
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), Changing speed now...&bslash;n&quot;
)paren
suffix:semicolon
id|irda_usb_change_speed_xbofs
c_func
(paren
id|self
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, allow the stack to send more packets */
id|netif_wake_queue
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Watchdog timer from the network layer.&n; * After a predetermined timeout, if we don&squot;t give confirmation that&n; * the packet has been sent (i.e. no call to netif_wake_queue()),&n; * the network layer will call this function.&n; * Note that URB that we submit have also a timeout. When the URB timeout&n; * expire, the normal URB callback is called (write_bulk_callback()).&n; */
DECL|function|irda_usb_net_timeout
r_static
r_void
id|irda_usb_net_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|netdev
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
id|netdev-&gt;priv
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If we have made any progress */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Network layer thinks we timed out!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|self
)paren
op_logical_or
(paren
op_logical_neg
id|self-&gt;present
)paren
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), device not present!&bslash;n&quot;
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|netdev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check speed URB */
id|urb
op_assign
id|self-&gt;speed_urb
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
l_int|0
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s: Speed change timed out, urb-&gt;status=%d, urb-&gt;transfer_flags=0x%04X&bslash;n&quot;
comma
id|netdev-&gt;name
comma
id|urb-&gt;status
comma
id|urb-&gt;transfer_flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|urb-&gt;status
)paren
(brace
r_case
op_minus
id|EINPROGRESS
suffix:colon
id|usb_unlink_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
multiline_comment|/* Note : above will  *NOT* call netif_wake_queue()&n;&t;&t;&t; * in completion handler, we will come back here.&n;&t;&t;&t; * Jean II */
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ECONNABORTED
suffix:colon
multiline_comment|/* -103 */
r_case
op_minus
id|ECONNRESET
suffix:colon
multiline_comment|/* -104 */
r_case
op_minus
id|ETIMEDOUT
suffix:colon
multiline_comment|/* -110 */
r_case
op_minus
id|ENOENT
suffix:colon
multiline_comment|/* -2 (urb unlinked by us)  */
r_default
suffix:colon
multiline_comment|/* ??? - Play safe */
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Check Tx URB */
id|urb
op_assign
id|self-&gt;tx_urb
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
l_int|0
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|urb-&gt;context
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;%s: Tx timed out, urb-&gt;status=%d, urb-&gt;transfer_flags=0x%04X&bslash;n&quot;
comma
id|netdev-&gt;name
comma
id|urb-&gt;status
comma
id|urb-&gt;transfer_flags
)paren
suffix:semicolon
multiline_comment|/* Increase error count */
id|self-&gt;stats.tx_errors
op_increment
suffix:semicolon
macro_line|#ifdef IU_BUG_KICK_TIMEOUT
multiline_comment|/* Can&squot;t be a bad idea to reset the speed ;-) - Jean II */
r_if
c_cond
(paren
id|self-&gt;new_speed
op_eq
op_minus
l_int|1
)paren
(brace
id|self-&gt;new_speed
op_assign
id|self-&gt;speed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;new_xbofs
op_eq
op_minus
l_int|1
)paren
(brace
id|self-&gt;new_xbofs
op_assign
id|self-&gt;xbofs
suffix:semicolon
)brace
id|irda_usb_change_speed_xbofs
c_func
(paren
id|self
)paren
suffix:semicolon
macro_line|#endif /* IU_BUG_KICK_TIMEOUT */
r_switch
c_cond
(paren
id|urb-&gt;status
)paren
(brace
r_case
op_minus
id|EINPROGRESS
suffix:colon
id|usb_unlink_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
multiline_comment|/* Note : above will  *NOT* call netif_wake_queue()&n;&t;&t;&t; * in completion handler, because urb-&gt;status will&n;&t;&t;&t; * be -ENOENT. We will fix that at the next watchdog,&n;&t;&t;&t; * leaving more time to USB to recover...&n;&t;&t;&t; * Also, we are in interrupt, so we need to have&n;&t;&t;&t; * USB_ASYNC_UNLINK to work properly...&n;&t;&t;&t; * Jean II */
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ECONNABORTED
suffix:colon
multiline_comment|/* -103 */
r_case
op_minus
id|ECONNRESET
suffix:colon
multiline_comment|/* -104 */
r_case
op_minus
id|ETIMEDOUT
suffix:colon
multiline_comment|/* -110 */
r_case
op_minus
id|ENOENT
suffix:colon
multiline_comment|/* -2 (urb unlinked by us)  */
r_default
suffix:colon
(brace
)brace
multiline_comment|/* ??? - Play safe */
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|dev_kfree_skb_any
c_func
(paren
id|skb
)paren
suffix:semicolon
id|urb-&gt;context
op_assign
l_int|NULL
suffix:semicolon
)brace
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Maybe we need a reset */
multiline_comment|/* Note : Some drivers seem to use a usb_set_interface() when they&n;&t; * need to reset the hardware. Hum...&n;&t; */
multiline_comment|/* if(done == 0) */
)brace
multiline_comment|/************************* RECEIVE ROUTINES *************************/
multiline_comment|/*&n; * Receive packets from the USB layer stack and pass them to the IrDA stack.&n; * Try to work around USB failures...&n; */
multiline_comment|/*&n; * Note :&n; * Some of you may have noticed that most dongle have an interrupt in pipe&n; * that we don&squot;t use. Here is the little secret...&n; * When we hang a Rx URB on the bulk in pipe, it generates some USB traffic&n; * in every USB frame. This is unnecessary overhead.&n; * The interrupt in pipe will generate an event every time a packet is&n; * received. Reading an interrupt pipe adds minimal overhead, but has some&n; * latency (~1ms).&n; * If we are connected (speed != 9600), we want to minimise latency, so&n; * we just always hang the Rx URB and ignore the interrupt.&n; * If we are not connected (speed == 9600), there is usually no Rx traffic,&n; * and we want to minimise the USB overhead. In this case we should wait&n; * on the interrupt pipe and hang the Rx URB only when an interrupt is&n; * received.&n; * Jean II&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Submit a Rx URB to the USB layer to handle reception of a frame&n; *&n; * Important note :&n; * The function process_urb() in usb-uhci.c contains the following code :&n; * &gt;&t;urb-&gt;complete ((struct urb *) urb);&n; * &gt;&t;// Re-submit the URB if ring-linked&n; * &gt;&t;if (is_ring &amp;&amp; (urb-&gt;status != -ENOENT) &amp;&amp; !contains_killed) {&n; * &gt;&t;&t;urb-&gt;dev=usb_dev;&n; * &gt;&t;&t;uhci_submit_urb (urb);&n; * &gt;&t;}&n; * The way I see it is that if we submit more than one Rx URB at a&n; * time, the Rx URB can be automatically re-submitted after the&n; * completion handler is called.&n; * We make sure to disable this feature by setting urb-&gt;next to NULL&n; *&n; * My take is that it&squot;s a questionable feature, and quite difficult&n; * to control and to make work effectively.&n; * The outcome (re-submited or not) depend on various complex&n; * test (&squot;is_ring&squot; and &squot;contains_killed&squot;), and the completion handler&n; * don&squot;t have this information, so basically the driver has no way&n; * to know if URB are resubmitted or not. Yuck !&n; * If everything is perfect, it&squot;s cool, but the problem is when&n; * an URB is killed (timeout, call to unlink_urb(), ...), things get&n; * messy...&n; * The other problem is that this scheme deal only with the URB&n; * and ignore everything about the associated buffer. So, it would&n; * resubmit URB even if the buffer is still in use or non-existent.&n; * On the other hand, submitting ourself in the completion callback&n; * is quite trivial and work well (this function).&n; * Moreover, this scheme doesn&squot;t allow to have an idle URB, which is&n; * necessary to overcome some URB failures.&n; *&n; * Jean II&n; */
DECL|function|irda_usb_submit
r_static
r_void
id|irda_usb_submit
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|irda_skb_cb
op_star
id|cb
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check that we have an urb */
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), Bug : urb == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Allocate new skb if it has not been recycled */
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|IRDA_USB_MAX_MTU
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
multiline_comment|/* If this ever happen, we are in deep s***.&n;&t;&t;&t; * Basically, the Rx path will stop... */
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), Failed to allocate Rx skb&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Reset recycled skb */
id|skb-&gt;data
op_assign
id|skb-&gt;tail
op_assign
id|skb-&gt;head
suffix:semicolon
id|skb-&gt;len
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Make sure IP header get aligned (IrDA header is 5 bytes ) */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Save ourselves */
id|cb
op_assign
(paren
r_struct
id|irda_skb_cb
op_star
)paren
id|skb-&gt;cb
suffix:semicolon
id|cb-&gt;context
op_assign
id|self
suffix:semicolon
multiline_comment|/* Reinitialize URB */
id|FILL_BULK_URB
c_func
(paren
id|urb
comma
id|self-&gt;usbdev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|self-&gt;usbdev
comma
id|self-&gt;bulk_in_ep
)paren
comma
id|skb-&gt;data
comma
id|skb-&gt;truesize
comma
id|irda_usb_receive
comma
id|skb
)paren
suffix:semicolon
id|urb-&gt;transfer_flags
op_assign
id|USB_QUEUE_BULK
suffix:semicolon
multiline_comment|/* Note : unlink *must* be synchronous because of the code in &n;&t; * irda_usb_net_close() -&gt; free the skb - Jean II */
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Don&squot;t auto resubmit URBs */
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* If this ever happen, we are in deep s***.&n;&t;&t; * Basically, the Rx path will stop... */
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), Failed to submit Rx URB %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_usb_receive(urb)&n; *&n; *     Called by the USB subsystem when a frame has been received&n; *&n; */
DECL|function|irda_usb_receive
r_static
r_void
id|irda_usb_receive
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|irda_usb_cb
op_star
id|self
suffix:semicolon
r_struct
id|irda_skb_cb
op_star
id|cb
suffix:semicolon
r_struct
id|sk_buff
op_star
r_new
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), len=%d&bslash;n&quot;
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
multiline_comment|/* Find ourselves */
id|cb
op_assign
(paren
r_struct
id|irda_skb_cb
op_star
)paren
id|skb-&gt;cb
suffix:semicolon
id|ASSERT
c_func
(paren
id|cb
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_usb_cb
op_star
)paren
id|cb-&gt;context
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* If the network is closed or the device gone, stop everything */
r_if
c_cond
(paren
(paren
op_logical_neg
id|self-&gt;netopen
)paren
op_logical_or
(paren
op_logical_neg
id|self-&gt;present
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Network is gone!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t re-submit the URB : will stall the Rx path */
r_return
suffix:semicolon
)brace
multiline_comment|/* Check the status */
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|urb-&gt;status
)paren
(brace
r_case
op_minus
id|EILSEQ
suffix:colon
id|self-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|self-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ECONNRESET
suffix:colon
multiline_comment|/* -104 */
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Connection Reset (-104), transfer_flags 0x%04X &bslash;n&quot;
comma
id|urb-&gt;transfer_flags
)paren
suffix:semicolon
multiline_comment|/* uhci_cleanup_unlink() is going to kill the Rx&n;&t;&t;&t; * URB just after we return. No problem, at this&n;&t;&t;&t; * point the URB will be idle ;-) - Jean II */
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), RX status %d,transfer_flags 0x%04X &bslash;n&quot;
comma
id|urb-&gt;status
comma
id|urb-&gt;transfer_flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* Check for empty frames */
r_if
c_cond
(paren
id|urb-&gt;actual_length
op_le
id|USB_IRDA_HEADER
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), empty frame!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*  &n;&t; * Remember the time we received this frame, so we can&n;&t; * reduce the min turn time a bit since we will know&n;&t; * how much time we have used for protocol processing&n;&t; */
id|do_gettimeofday
c_func
(paren
op_amp
id|self-&gt;stamp
)paren
suffix:semicolon
multiline_comment|/* Fix skb, and remove USB-IrDA header */
id|skb_put
c_func
(paren
id|skb
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|USB_IRDA_HEADER
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t waste a lot of memory on small IrDA frames */
r_if
c_cond
(paren
id|skb-&gt;len
OL
id|RX_COPY_THRESHOLD
)paren
(brace
r_new
op_assign
id|dev_alloc_skb
c_func
(paren
id|skb-&gt;len
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
(brace
id|self-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* Make sure IP header get aligned (IrDA header is 5 bytes) */
id|skb_reserve
c_func
(paren
r_new
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Copy packet, so we can recycle the original */
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
r_new
comma
id|skb-&gt;len
)paren
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* We will cleanup the skb in irda_usb_submit() */
)brace
r_else
(brace
multiline_comment|/* Deliver the original skb */
r_new
op_assign
id|skb
suffix:semicolon
id|skb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|self-&gt;stats.rx_bytes
op_add_assign
r_new
op_member_access_from_pointer
id|len
suffix:semicolon
id|self-&gt;stats.rx_packets
op_increment
suffix:semicolon
multiline_comment|/* Ask the networking layer to queue the packet for the IrDA stack */
r_new
op_member_access_from_pointer
id|dev
op_assign
id|self-&gt;netdev
suffix:semicolon
r_new
op_member_access_from_pointer
id|mac.raw
op_assign
r_new
op_member_access_from_pointer
id|data
suffix:semicolon
r_new
op_member_access_from_pointer
id|protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IRDA
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
r_new
)paren
suffix:semicolon
id|self-&gt;netdev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
id|done
suffix:colon
multiline_comment|/* Note : at this point, the URB we&squot;ve just received (urb)&n;&t; * is still referenced by the USB layer. For example, if we&n;&t; * have received a -ECONNRESET, uhci_cleanup_unlink() will&n;&t; * continue to process it (in fact, cleaning it up).&n;&t; * If we were to submit this URB, disaster would ensue.&n;&t; * Therefore, we submit our idle URB, and put this URB in our&n;&t; * idle slot....&n;&t; * Jean II */
multiline_comment|/* Note : with this scheme, we could submit the idle URB before&n;&t; * processing the Rx URB. Another time... Jean II */
multiline_comment|/* Submit the idle URB to replace the URB we&squot;ve just received */
id|irda_usb_submit
c_func
(paren
id|self
comma
id|skb
comma
id|self-&gt;idle_rx_urb
)paren
suffix:semicolon
multiline_comment|/* Recycle Rx URB : Now, the idle URB is the present one */
id|urb-&gt;context
op_assign
l_int|NULL
suffix:semicolon
id|self-&gt;idle_rx_urb
op_assign
id|urb
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Callbak from IrDA layer. IrDA wants to know if we have&n; * started receiving anything.&n; */
DECL|function|irda_usb_is_receiving
r_static
r_int
id|irda_usb_is_receiving
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
(brace
multiline_comment|/* Note : because of the way UHCI works, it&squot;s almost impossible&n;&t; * to get this info. The Controller DMA directly to memory and&n;&t; * signal only when the whole frame is finished. To know if the&n;&t; * first TD of the URB has been filled or not seems hard work...&n;&t; *&n;&t; * The other solution would be to use the &quot;receiving&quot; command&n;&t; * on the default decriptor with a usb_control_msg(), but that&n;&t; * would add USB traffic and would return result only in the&n;&t; * next USB frame (~1ms).&n;&t; *&n;&t; * I&squot;ve been told that current dongles send status info on their&n;&t; * interrupt endpoint, and that&squot;s what the Windows driver uses&n;&t; * to know this info. Unfortunately, this is not yet in the spec...&n;&t; *&n;&t; * Jean II&n;&t; */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* For now */
)brace
multiline_comment|/********************** IRDA DEVICE CALLBACKS **********************/
multiline_comment|/*&n; * Main calls from the IrDA/Network subsystem.&n; * Mostly registering a new irda-usb device and removing it....&n; * We only deal with the IrDA side of the business, the USB side will&n; * be dealt with below...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Callback when a new IrDA device is created.&n; */
DECL|function|irda_usb_net_init
r_static
r_int
id|irda_usb_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Set up to be a normal IrDA network device driver */
id|irda_device_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Insert overrides below this line! */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_usb_net_open (dev)&n; *&n; *    Network device is taken up. Usually this is done by &quot;ifconfig irda0 up&quot; &n; *   &n; * Note : don&squot;t mess with self-&gt;netopen - Jean II&n; */
DECL|function|irda_usb_net_open
r_static
r_int
id|irda_usb_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|netdev
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
suffix:semicolon
r_char
id|hwname
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_usb_cb
op_star
)paren
id|netdev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Can only open the device if it&squot;s there */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;present
)paren
(brace
id|WARNING
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), device not present!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Initialise default speed and xbofs value&n;&t; * (IrLAP will change that soon) */
id|self-&gt;speed
op_assign
op_minus
l_int|1
suffix:semicolon
id|self-&gt;xbofs
op_assign
op_minus
l_int|1
suffix:semicolon
id|self-&gt;new_speed
op_assign
op_minus
l_int|1
suffix:semicolon
id|self-&gt;new_xbofs
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* To do *before* submitting Rx urbs and starting net Tx queue&n;&t; * Jean II */
id|self-&gt;netopen
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;&t; * Now that everything should be initialized properly,&n;&t; * Open new IrLAP layer instance to take care of us...&n;&t; * Note : will send immediately a speed change...&n;&t; */
id|sprintf
c_func
(paren
id|hwname
comma
l_string|&quot;usb#%d&quot;
comma
id|self-&gt;usbdev-&gt;devnum
)paren
suffix:semicolon
id|self-&gt;irlap
op_assign
id|irlap_open
c_func
(paren
id|netdev
comma
op_amp
id|self-&gt;qos
comma
id|hwname
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self-&gt;irlap
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Allow IrLAP to send data to us */
id|netif_start_queue
c_func
(paren
id|netdev
)paren
suffix:semicolon
multiline_comment|/* We submit all the Rx URB except for one that we keep idle.&n;&t; * Need to be initialised before submitting other USBs, because&n;&t; * in some cases as soon as we submit the URBs the USB layer&n;&t; * will trigger a dummy receive - Jean II */
id|self-&gt;idle_rx_urb
op_assign
id|self-&gt;rx_urb
(braket
id|IU_MAX_ACTIVE_RX_URBS
)braket
suffix:semicolon
id|self-&gt;idle_rx_urb-&gt;context
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Now that we can pass data to IrLAP, allow the USB layer&n;&t; * to send us some data... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IU_MAX_ACTIVE_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
id|irda_usb_submit
c_func
(paren
id|self
comma
l_int|NULL
comma
id|self-&gt;rx_urb
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Ready to play !!! */
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_usb_net_close (self)&n; *&n; *    Network device is taken down. Usually this is done by &n; *    &quot;ifconfig irda0 down&quot; &n; */
DECL|function|irda_usb_net_close
r_static
r_int
id|irda_usb_net_close
c_func
(paren
r_struct
id|net_device
op_star
id|netdev
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
suffix:semicolon
r_int
id|i
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|netdev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
(paren
r_struct
id|irda_usb_cb
op_star
)paren
id|netdev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Clear this flag *before* unlinking the urbs and *before*&n;&t; * stopping the network Tx queue - Jean II */
id|self-&gt;netopen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Stop network Tx queue */
id|netif_stop_queue
c_func
(paren
id|netdev
)paren
suffix:semicolon
multiline_comment|/* Deallocate all the Rx path buffers (URBs and skb) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IU_MAX_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|self-&gt;rx_urb
(braket
id|i
)braket
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|urb-&gt;context
suffix:semicolon
multiline_comment|/* Cancel the receive command */
id|usb_unlink_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
multiline_comment|/* The skb is ours, free it */
r_if
c_cond
(paren
id|skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|urb-&gt;context
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Cancel Tx and speed URB */
id|usb_unlink_urb
c_func
(paren
id|self-&gt;tx_urb
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|self-&gt;speed_urb
)paren
suffix:semicolon
multiline_comment|/* Stop and remove instance of IrLAP */
r_if
c_cond
(paren
id|self-&gt;irlap
)paren
id|irlap_close
c_func
(paren
id|self-&gt;irlap
)paren
suffix:semicolon
id|self-&gt;irlap
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * IOCTLs : Extra out-of-band network commands...&n; */
DECL|function|irda_usb_net_ioctl
r_static
r_int
id|irda_usb_net_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
r_struct
id|if_irda_req
op_star
id|irq
op_assign
(paren
r_struct
id|if_irda_req
op_star
)paren
id|rq
suffix:semicolon
r_struct
id|irda_usb_cb
op_star
id|self
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|dev
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|self
op_assign
id|dev-&gt;priv
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|2
comma
id|__FUNCTION__
l_string|&quot;(), %s, (cmd=0x%X)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* Check if the device is still there */
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;present
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCSBANDWIDTH
suffix:colon
multiline_comment|/* Set bandwidth */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* Set the desired speed */
id|self-&gt;new_speed
op_assign
id|irq-&gt;ifr_baudrate
suffix:semicolon
id|irda_usb_change_speed_xbofs
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Note : will spinlock in above function */
r_break
suffix:semicolon
r_case
id|SIOCSMEDIABUSY
suffix:colon
multiline_comment|/* Set media busy */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|irda_device_set_media_busy
c_func
(paren
id|self-&gt;netdev
comma
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIOCGRECEIVING
suffix:colon
multiline_comment|/* Check if we are receiving right now */
id|irq-&gt;ifr_receiving
op_assign
id|irda_usb_is_receiving
c_func
(paren
id|self
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Get device stats (for /proc/net/dev and ifconfig)&n; */
DECL|function|irda_usb_net_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|irda_usb_net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|self-&gt;stats
suffix:semicolon
)brace
multiline_comment|/********************* IRDA CONFIG SUBROUTINES *********************/
multiline_comment|/*&n; * Various subroutines dealing with IrDA and network stuff we use to&n; * configure and initialise each irda-usb instance.&n; * These functions are used below in the main calls of the driver...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Set proper values in the IrDA QOS structure&n; */
DECL|function|irda_usb_init_qos
r_static
r_inline
r_void
id|irda_usb_init_qos
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
(brace
r_struct
id|irda_class_desc
op_star
id|desc
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|3
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|desc
op_assign
id|self-&gt;irda_desc
suffix:semicolon
multiline_comment|/* Initialize QoS for this device */
id|irda_init_max_qos_capabilies
c_func
(paren
op_amp
id|self-&gt;qos
)paren
suffix:semicolon
id|self-&gt;qos.baud_rate.bits
op_assign
id|desc-&gt;wBaudRate
suffix:semicolon
id|self-&gt;qos.min_turn_time.bits
op_assign
id|desc-&gt;bmMinTurnaroundTime
suffix:semicolon
id|self-&gt;qos.additional_bofs.bits
op_assign
id|desc-&gt;bmAdditionalBOFs
suffix:semicolon
id|self-&gt;qos.window_size.bits
op_assign
id|desc-&gt;bmWindowSize
suffix:semicolon
id|self-&gt;qos.data_size.bits
op_assign
id|desc-&gt;bmDataSize
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), dongle says speed=0x%X, size=0x%X, window=0x%X, bofs=0x%X, turn=0x%X&bslash;n&quot;
comma
id|self-&gt;qos.baud_rate.bits
comma
id|self-&gt;qos.data_size.bits
comma
id|self-&gt;qos.window_size.bits
comma
id|self-&gt;qos.additional_bofs.bits
comma
id|self-&gt;qos.min_turn_time.bits
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t always trust what the dongle tell us */
r_if
c_cond
(paren
id|self-&gt;capability
op_amp
id|IUC_SIR_ONLY
)paren
(brace
id|self-&gt;qos.baud_rate.bits
op_and_assign
l_int|0xff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;capability
op_amp
id|IUC_SMALL_PKT
)paren
(brace
id|self-&gt;qos.data_size.bits
op_assign
l_int|0x07
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;capability
op_amp
id|IUC_NO_WINDOW
)paren
(brace
id|self-&gt;qos.window_size.bits
op_assign
l_int|0x01
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;capability
op_amp
id|IUC_MAX_WINDOW
)paren
(brace
id|self-&gt;qos.window_size.bits
op_assign
l_int|0x7f
suffix:semicolon
)brace
r_if
c_cond
(paren
id|self-&gt;capability
op_amp
id|IUC_MAX_XBOFS
)paren
(brace
id|self-&gt;qos.additional_bofs.bits
op_assign
l_int|0x01
suffix:semicolon
)brace
macro_line|#if 1
multiline_comment|/* Module parameter can override the rx window size */
r_if
c_cond
(paren
id|qos_mtt_bits
)paren
id|self-&gt;qos.min_turn_time.bits
op_assign
id|qos_mtt_bits
suffix:semicolon
macro_line|#endif&t;    
multiline_comment|/* &n;&t; * Note : most of those values apply only for the receive path,&n;&t; * the transmit path will be set differently - Jean II &n;&t; */
id|irda_qos_bits_to_value
c_func
(paren
op_amp
id|self-&gt;qos
)paren
suffix:semicolon
id|self-&gt;flags
op_or_assign
id|IFF_SIR
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;qos.baud_rate.value
OG
l_int|115200
)paren
id|self-&gt;flags
op_or_assign
id|IFF_MIR
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;qos.baud_rate.value
OG
l_int|1152000
)paren
id|self-&gt;flags
op_or_assign
id|IFF_FIR
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;qos.baud_rate.value
OG
l_int|4000000
)paren
id|self-&gt;flags
op_or_assign
id|IFF_VFIR
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Initialise the network side of the irda-usb instance&n; * Called when a new USB instance is registered in irda_usb_probe()&n; */
DECL|function|irda_usb_open
r_static
r_inline
r_int
id|irda_usb_open
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
(brace
r_struct
id|net_device
op_star
id|netdev
suffix:semicolon
r_int
id|err
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|self-&gt;lock
)paren
suffix:semicolon
id|irda_usb_init_qos
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* Initialise list of skb beeing curently transmitted */
id|self-&gt;tx_list
op_assign
id|hashbin_new
c_func
(paren
id|HB_GLOBAL
)paren
suffix:semicolon
multiline_comment|/* Allocate the buffer for speed changes */
multiline_comment|/* Don&squot;t change this buffer size and allocation without doing&n;&t; * some heavy and complete testing. Don&squot;t ask why :-(&n;&t; * Jean II */
id|self-&gt;speed_buff
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|IRDA_USB_SPEED_MTU
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|self-&gt;speed_buff
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|self-&gt;speed_buff
comma
l_int|0
comma
id|IRDA_USB_SPEED_MTU
)paren
suffix:semicolon
multiline_comment|/* Create a network device for us */
r_if
c_cond
(paren
op_logical_neg
(paren
id|netdev
op_assign
id|dev_alloc
c_func
(paren
l_string|&quot;irda%d&quot;
comma
op_amp
id|err
)paren
)paren
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), dev_alloc() failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|self-&gt;netdev
op_assign
id|netdev
suffix:semicolon
id|netdev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|self
suffix:semicolon
multiline_comment|/* Override the network functions we need to use */
id|netdev-&gt;init
op_assign
id|irda_usb_net_init
suffix:semicolon
id|netdev-&gt;hard_start_xmit
op_assign
id|irda_usb_hard_xmit
suffix:semicolon
id|netdev-&gt;tx_timeout
op_assign
id|irda_usb_net_timeout
suffix:semicolon
id|netdev-&gt;watchdog_timeo
op_assign
l_int|250
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
multiline_comment|/* 250 ms &gt; USB timeout */
id|netdev-&gt;open
op_assign
id|irda_usb_net_open
suffix:semicolon
id|netdev-&gt;stop
op_assign
id|irda_usb_net_close
suffix:semicolon
id|netdev-&gt;get_stats
op_assign
id|irda_usb_net_get_stats
suffix:semicolon
id|netdev-&gt;do_ioctl
op_assign
id|irda_usb_net_ioctl
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|register_netdevice
c_func
(paren
id|netdev
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), register_netdev() failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|MESSAGE
c_func
(paren
l_string|&quot;IrDA: Registered device %s&bslash;n&quot;
comma
id|netdev-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Cleanup the network side of the irda-usb instance&n; * Called when a USB instance is removed in irda_usb_disconnect()&n; */
DECL|function|irda_usb_close
r_static
r_inline
r_int
id|irda_usb_close
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|self
op_ne
l_int|NULL
comma
r_return
op_minus
l_int|1
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Remove netdevice */
r_if
c_cond
(paren
id|self-&gt;netdev
)paren
(brace
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|unregister_netdevice
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
id|self-&gt;netdev
op_assign
l_int|NULL
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Delete all pending skbs */
id|hashbin_delete
c_func
(paren
id|self-&gt;tx_list
comma
(paren
id|FREE_FUNC
)paren
op_amp
id|dev_kfree_skb_any
)paren
suffix:semicolon
multiline_comment|/* Remove the speed buffer */
r_if
c_cond
(paren
id|self-&gt;speed_buff
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|self-&gt;speed_buff
)paren
suffix:semicolon
id|self-&gt;speed_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********************** USB CONFIG SUBROUTINES **********************/
multiline_comment|/*&n; * Various subroutines dealing with USB stuff we use to configure and&n; * initialise each irda-usb instance.&n; * These functions are used below in the main calls of the driver...&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_usb_parse_endpoints(dev, ifnum)&n; *&n; *    Parse the various endpoints and find the one we need.&n; *&n; * The endpoint are the pipes used to communicate with the USB device.&n; * The spec defines 2 endpoints of type bulk transfer, one in, and one out.&n; * These are used to pass frames back and forth with the dongle.&n; * Most dongle have also an interrupt endpoint, that will be probably&n; * documented in the next spec...&n; */
DECL|function|irda_usb_parse_endpoints
r_static
r_inline
r_int
id|irda_usb_parse_endpoints
c_func
(paren
r_struct
id|irda_usb_cb
op_star
id|self
comma
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
comma
r_int
id|ennum
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Endpoint index in table */
multiline_comment|/* Init : no endpoints */
id|self-&gt;bulk_in_ep
op_assign
l_int|0
suffix:semicolon
id|self-&gt;bulk_out_ep
op_assign
l_int|0
suffix:semicolon
id|self-&gt;bulk_int_ep
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Let&squot;s look at all those endpoints */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ennum
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* All those variables will get optimised by the compiler,&n;&t;&t; * so let&squot;s aim for clarity... - Jean II */
id|__u8
id|ep
suffix:semicolon
multiline_comment|/* Endpoint address */
id|__u8
id|dir
suffix:semicolon
multiline_comment|/* Endpoint direction */
id|__u8
id|attr
suffix:semicolon
multiline_comment|/* Endpoint attribute */
id|__u16
id|psize
suffix:semicolon
multiline_comment|/* Endpoint max packet size in bytes */
multiline_comment|/* Get endpoint address, direction and attribute */
id|ep
op_assign
id|endpoint
(braket
id|i
)braket
dot
id|bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
id|dir
op_assign
id|endpoint
(braket
id|i
)braket
dot
id|bEndpointAddress
op_amp
id|USB_ENDPOINT_DIR_MASK
suffix:semicolon
id|attr
op_assign
id|endpoint
(braket
id|i
)braket
dot
id|bmAttributes
suffix:semicolon
id|psize
op_assign
id|endpoint
(braket
id|i
)braket
dot
id|wMaxPacketSize
suffix:semicolon
multiline_comment|/* Is it a bulk endpoint ??? */
r_if
c_cond
(paren
id|attr
op_eq
id|USB_ENDPOINT_XFER_BULK
)paren
(brace
multiline_comment|/* We need to find an IN and an OUT */
r_if
c_cond
(paren
id|dir
op_eq
id|USB_DIR_IN
)paren
(brace
multiline_comment|/* This is our Rx endpoint */
id|self-&gt;bulk_in_ep
op_assign
id|ep
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is our Tx endpoint */
id|self-&gt;bulk_out_ep
op_assign
id|ep
suffix:semicolon
id|self-&gt;bulk_out_mtu
op_assign
id|psize
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|attr
op_eq
id|USB_ENDPOINT_XFER_INT
)paren
op_logical_and
(paren
id|dir
op_eq
id|USB_DIR_IN
)paren
)paren
(brace
multiline_comment|/* This is our interrupt endpoint */
id|self-&gt;bulk_int_ep
op_assign
id|ep
suffix:semicolon
)brace
r_else
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), Unrecognised endpoint %02X.&bslash;n&quot;
comma
id|ep
)paren
suffix:semicolon
)brace
)brace
)brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), And our endpoints are : in=%02X, out=%02X (%d), int=%02X&bslash;n&quot;
comma
id|self-&gt;bulk_in_ep
comma
id|self-&gt;bulk_out_ep
comma
id|self-&gt;bulk_out_mtu
comma
id|self-&gt;bulk_int_ep
)paren
suffix:semicolon
multiline_comment|/* Should be 8, 16, 32 or 64 bytes */
id|ASSERT
c_func
(paren
id|self-&gt;bulk_out_mtu
op_eq
l_int|64
comma
suffix:semicolon
)paren
suffix:semicolon
r_return
(paren
id|self-&gt;bulk_in_ep
op_ne
l_int|0
)paren
op_logical_and
(paren
id|self-&gt;bulk_out_ep
op_ne
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef IU_DUMP_CLASS_DESC
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function usb_irda_dump_class_desc(desc)&n; *&n; *    Prints out the contents of the IrDA class descriptor&n; *&n; */
DECL|function|irda_usb_dump_class_desc
r_static
r_inline
r_void
id|irda_usb_dump_class_desc
c_func
(paren
r_struct
id|irda_class_desc
op_star
id|desc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bLength=%x&bslash;n&quot;
comma
id|desc-&gt;bLength
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bDescriptorType=%x&bslash;n&quot;
comma
id|desc-&gt;bDescriptorType
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bcdSpecRevision=%x&bslash;n&quot;
comma
id|desc-&gt;bcdSpecRevision
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bmDataSize=%x&bslash;n&quot;
comma
id|desc-&gt;bmDataSize
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bmWindowSize=%x&bslash;n&quot;
comma
id|desc-&gt;bmWindowSize
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bmMinTurnaroundTime=%d&bslash;n&quot;
comma
id|desc-&gt;bmMinTurnaroundTime
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;wBaudRate=%x&bslash;n&quot;
comma
id|desc-&gt;wBaudRate
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bmAdditionalBOFs=%x&bslash;n&quot;
comma
id|desc-&gt;bmAdditionalBOFs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bIrdaRateSniff=%x&bslash;n&quot;
comma
id|desc-&gt;bIrdaRateSniff
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bMaxUnicastList=%x&bslash;n&quot;
comma
id|desc-&gt;bMaxUnicastList
)paren
suffix:semicolon
)brace
macro_line|#endif /* IU_DUMP_CLASS_DESC */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Function irda_usb_find_class_desc(dev, ifnum)&n; *&n; *    Returns instance of IrDA class descriptor, or NULL if not found&n; *&n; * The class descriptor is some extra info that IrDA USB devices will&n; * offer to us, describing their IrDA characteristics. We will use that in&n; * irda_usb_init_qos()&n; */
DECL|function|irda_usb_find_class_desc
r_static
r_inline
r_struct
id|irda_class_desc
op_star
id|irda_usb_find_class_desc
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
)paren
(brace
r_struct
id|irda_class_desc
op_star
id|desc
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|desc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|desc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desc
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|desc
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|desc
)paren
)paren
suffix:semicolon
multiline_comment|/* USB-IrDA class spec 1.0:&n;&t; *&t;6.1.3: Standard &quot;Get Descriptor&quot; Device Request is not&n;&t; *&t;       appropriate to retrieve class-specific descriptor&n;&t; *&t;6.2.5: Class Specific &quot;Get Class Descriptor&quot; Interface Request&n;&t; *&t;       is mandatory and returns the USB-IrDA class descriptor&n;&t; */
id|ret
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|IU_REQ_GET_CLASS_DESC
comma
id|USB_DIR_IN
op_or
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|ifnum
comma
id|desc
comma
r_sizeof
(paren
op_star
id|desc
)paren
comma
id|MSECS_TO_JIFFIES
c_func
(paren
l_int|500
)paren
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;(), ret=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
r_sizeof
(paren
op_star
id|desc
)paren
)paren
(brace
id|WARNING
c_func
(paren
l_string|&quot;usb-irda: class_descriptor read %s (%d)&bslash;n&quot;
comma
(paren
id|ret
OL
l_int|0
)paren
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;too short&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|desc-&gt;bDescriptorType
op_ne
id|USB_DT_IRDA
)paren
(brace
id|WARNING
c_func
(paren
l_string|&quot;usb-irda: bad class_descriptor type&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef IU_DUMP_CLASS_DESC
id|irda_usb_dump_class_desc
c_func
(paren
id|desc
)paren
suffix:semicolon
macro_line|#endif&t;/* IU_DUMP_CLASS_DESC */
r_return
id|desc
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|desc
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*********************** USB DEVICE CALLBACKS ***********************/
multiline_comment|/*&n; * Main calls from the USB subsystem.&n; * Mostly registering a new irda-usb device and removing it....&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * This routine is called by the USB subsystem for each new device&n; * in the system. We need to check if the device is ours, and in&n; * this case start handling it.&n; * Note : it might be worth protecting this function by a global&n; * spinlock... Or not, because maybe USB already deal with that...&n; */
DECL|function|irda_usb_probe
r_static
r_void
op_star
id|irda_usb_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|interface
suffix:semicolon
r_struct
id|irda_class_desc
op_star
id|irda_desc
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Note : the probe make sure to call us only for devices that&n;&t; * matches the list of dongle (top of the file). So, we&n;&t; * don&squot;t need to check if the dongle is really ours.&n;&t; * Jean II */
id|MESSAGE
c_func
(paren
l_string|&quot;IRDA-USB found at address %d, Vendor: %x, Product: %x&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
multiline_comment|/* Try to cleanup all instance that have a pending disconnect&n;&t; * Instance will be in this state is the disconnect() occurs&n;&t; * before the net_close().&n;&t; * Jean II */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NIRUSB
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|irda
op_assign
op_amp
id|irda_instance
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irda-&gt;usbdev
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|irda-&gt;present
op_eq
l_int|0
)paren
op_logical_and
(paren
id|irda-&gt;netopen
op_eq
l_int|0
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), found a zombie instance !!!&bslash;n&quot;
)paren
suffix:semicolon
id|irda_usb_disconnect
c_func
(paren
id|irda-&gt;usbdev
comma
(paren
r_void
op_star
)paren
id|irda
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Find an free instance to handle this new device... */
id|self
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NIRUSB
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irda_instance
(braket
id|i
)braket
dot
id|usbdev
op_eq
l_int|NULL
)paren
(brace
id|self
op_assign
op_amp
id|irda_instance
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|self
op_eq
l_int|NULL
)paren
(brace
id|WARNING
c_func
(paren
l_string|&quot;Too many USB IrDA devices !!! (max = %d)&bslash;n&quot;
comma
id|NIRUSB
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Reset the instance */
id|self-&gt;present
op_assign
l_int|0
suffix:semicolon
id|self-&gt;netopen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Create all of the needed urbs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IU_MAX_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|self-&gt;rx_urb
(braket
id|i
)braket
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;rx_urb
(braket
id|i
)braket
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
id|usb_free_urb
c_func
(paren
id|self-&gt;rx_urb
(braket
id|j
)braket
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|self-&gt;tx_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;tx_urb
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IU_MAX_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
id|usb_free_urb
c_func
(paren
id|self-&gt;rx_urb
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|self-&gt;speed_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|self-&gt;speed_urb
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IU_MAX_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
id|usb_free_urb
c_func
(paren
id|self-&gt;rx_urb
(braket
id|i
)braket
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|self-&gt;tx_urb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Is this really necessary? */
r_if
c_cond
(paren
id|usb_set_configuration
(paren
id|dev
comma
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|bConfigurationValue
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;set_configuration failed&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Is this really necessary? */
multiline_comment|/* Note : some driver do hardcode the interface number, some others&n;&t; * specify an alternate, but very few driver do like this.&n;&t; * Jean II */
id|ret
op_assign
id|usb_set_interface
c_func
(paren
id|dev
comma
id|ifnum
comma
l_int|0
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;usb-irda: set interface %d result %d&bslash;n&quot;
comma
id|ifnum
comma
id|ret
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
op_minus
id|EPIPE
suffix:colon
multiline_comment|/* -EPIPE = -32 */
id|usb_clear_halt
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Clearing stall on control interface&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), Unknown error %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Find our endpoints */
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|ifnum
)braket
dot
id|altsetting
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irda_usb_parse_endpoints
c_func
(paren
id|self
comma
id|interface-&gt;endpoint
comma
id|interface-&gt;bNumEndpoints
)paren
)paren
(brace
id|ERROR
c_func
(paren
id|__FUNCTION__
l_string|&quot;(), Bogus endpoints...&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Find IrDA class descriptor */
id|irda_desc
op_assign
id|irda_usb_find_class_desc
c_func
(paren
id|dev
comma
id|ifnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irda_desc
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|self-&gt;irda_desc
op_assign
id|irda_desc
suffix:semicolon
id|self-&gt;present
op_assign
l_int|1
suffix:semicolon
id|self-&gt;netopen
op_assign
l_int|0
suffix:semicolon
id|self-&gt;capability
op_assign
id|id-&gt;driver_info
suffix:semicolon
id|self-&gt;usbdev
op_assign
id|dev
suffix:semicolon
id|ret
op_assign
id|irda_usb_open
c_func
(paren
id|self
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|self
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * The current irda-usb device is removed, the USB layer tell us&n; * to shut it down...&n; */
DECL|function|irda_usb_disconnect
r_static
r_void
id|irda_usb_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|self
op_assign
(paren
r_struct
id|irda_usb_cb
op_star
)paren
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|1
comma
id|__FUNCTION__
l_string|&quot;()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Oups ! We are not there any more */
id|self-&gt;present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Hum... Check if networking is still active */
r_if
c_cond
(paren
id|self-&gt;netopen
)paren
(brace
multiline_comment|/* Accept no more transmissions */
multiline_comment|/*netif_device_detach(self-&gt;netdev);*/
id|netif_stop_queue
c_func
(paren
id|self-&gt;netdev
)paren
suffix:semicolon
multiline_comment|/* Stop all the receive URBs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IU_MAX_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
id|usb_unlink_urb
c_func
(paren
id|self-&gt;rx_urb
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Cancel Tx and speed URB */
id|usb_unlink_urb
c_func
(paren
id|self-&gt;tx_urb
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|self-&gt;speed_urb
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), postponing disconnect, network is still active...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* better not do anything just yet, usb_irda_cleanup()&n;&t;&t; * will do whats needed */
r_return
suffix:semicolon
)brace
multiline_comment|/* Cleanup the device stuff */
id|irda_usb_close
c_func
(paren
id|self
)paren
suffix:semicolon
multiline_comment|/* No longer attached to USB bus */
id|self-&gt;usbdev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Clean up our urbs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IU_MAX_RX_URBS
suffix:semicolon
id|i
op_increment
)paren
id|usb_free_urb
c_func
(paren
id|self-&gt;rx_urb
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Cancel Tx and speed URB */
id|usb_free_urb
c_func
(paren
id|self-&gt;tx_urb
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|self-&gt;speed_urb
)paren
suffix:semicolon
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), USB IrDA Disconnected&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * USB device callbacks&n; */
DECL|variable|irda_driver
r_static
r_struct
id|usb_driver
id|irda_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;irda-usb&quot;
comma
id|probe
suffix:colon
id|irda_usb_probe
comma
id|disconnect
suffix:colon
id|irda_usb_disconnect
comma
id|id_table
suffix:colon
id|dongles
comma
)brace
suffix:semicolon
multiline_comment|/************************* MODULE CALLBACKS *************************/
multiline_comment|/*&n; * Deal with module insertion/removal&n; * Mostly tell USB about our existence&n; */
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Module insertion&n; */
DECL|function|usb_irda_init
r_int
id|__init
id|usb_irda_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|irda_driver
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|MESSAGE
c_func
(paren
l_string|&quot;USB IrDA support registered&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_irda_init
id|module_init
c_func
(paren
id|usb_irda_init
)paren
suffix:semicolon
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Module removal&n; */
DECL|function|usb_irda_cleanup
r_void
id|__exit
id|usb_irda_cleanup
c_func
(paren
r_void
)paren
(brace
r_struct
id|irda_usb_cb
op_star
id|irda
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Find zombie instances and kill them... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NIRUSB
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irda
op_assign
op_amp
id|irda_instance
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* If the Device is zombie */
r_if
c_cond
(paren
(paren
id|irda-&gt;usbdev
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|irda-&gt;present
op_eq
l_int|0
)paren
)paren
(brace
id|IRDA_DEBUG
c_func
(paren
l_int|0
comma
id|__FUNCTION__
l_string|&quot;(), disconnect zombie now !&bslash;n&quot;
)paren
suffix:semicolon
id|irda_usb_disconnect
c_func
(paren
id|irda-&gt;usbdev
comma
(paren
r_void
op_star
)paren
id|irda
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Deregister the driver and remove all pending instances */
id|usb_deregister
c_func
(paren
op_amp
id|irda_driver
)paren
suffix:semicolon
)brace
DECL|variable|usb_irda_cleanup
id|module_exit
c_func
(paren
id|usb_irda_cleanup
)paren
suffix:semicolon
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Module parameters&n; */
id|MODULE_PARM
c_func
(paren
id|qos_mtt_bits
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|qos_mtt_bits
comma
l_string|&quot;Minimum Turn Time&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Roman Weissgaerber &lt;weissg@vienna.at&gt;, Dag Brattli &lt;dag@brattli.net&gt; and Jean Tourrilhes &lt;jt@hpl.hp.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;IrDA-USB Dongle Driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
