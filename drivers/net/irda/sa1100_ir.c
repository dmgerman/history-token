multiline_comment|/*&n; *  linux/drivers/net/irda/sa1100_ir.c&n; *&n; *  Copyright (C) 2000-2001 Russell King&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; *  Infra-red driver for the StrongARM SA1100 embedded microprocessor&n; *&n; *  Note that we don&squot;t have to worry about the SA1111&squot;s DMA bugs in here,&n; *  so we use the straight forward pci_map_* functions with a null pointer.&n; *  IMHO we should really be using our own machine specific set.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#include &lt;net/irda/irmod.h&gt;
macro_line|#include &lt;net/irda/wrapper.h&gt;
macro_line|#include &lt;net/irda/irda_device.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/mach-types.h&gt;
macro_line|#include &lt;asm/arch/assabet.h&gt;
macro_line|#ifndef CONFIG_SA1100_H3600
DECL|macro|clr_h3600_egpio
mdefine_line|#define clr_h3600_egpio(x)&t;do { } while (0)
DECL|macro|set_h3600_egpio
mdefine_line|#define set_h3600_egpio(x)&t;do { } while (0)
macro_line|#endif
macro_line|#ifndef GPIO_IRDA_FIR
DECL|macro|GPIO_IRDA_FIR
mdefine_line|#define GPIO_IRDA_FIR&t;&t;(0)
macro_line|#endif
macro_line|#ifndef GPIO_IRDA_POWER
DECL|macro|GPIO_IRDA_POWER
mdefine_line|#define GPIO_IRDA_POWER&t;&t;(0)
macro_line|#endif
DECL|variable|power_level
r_static
r_int
id|power_level
op_assign
l_int|3
suffix:semicolon
DECL|variable|tx_lpm
r_static
r_int
id|tx_lpm
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Our netdevice.  There is only ever one of these.&n; */
DECL|variable|netdev
r_static
r_struct
id|net_device
op_star
id|netdev
suffix:semicolon
DECL|struct|sa1100_irda
r_struct
id|sa1100_irda
(brace
DECL|member|hscr0
r_int
r_char
id|hscr0
suffix:semicolon
DECL|member|utcr4
r_int
r_char
id|utcr4
suffix:semicolon
DECL|member|power
r_int
r_char
id|power
suffix:semicolon
DECL|member|open
r_int
r_char
id|open
suffix:semicolon
DECL|member|speed
r_int
id|speed
suffix:semicolon
DECL|member|newspeed
r_int
id|newspeed
suffix:semicolon
DECL|member|txskb
r_struct
id|sk_buff
op_star
id|txskb
suffix:semicolon
DECL|member|rxskb
r_struct
id|sk_buff
op_star
id|rxskb
suffix:semicolon
DECL|member|txbuf_dma
id|dma_addr_t
id|txbuf_dma
suffix:semicolon
DECL|member|rxbuf_dma
id|dma_addr_t
id|rxbuf_dma
suffix:semicolon
DECL|member|txdma
r_int
id|txdma
suffix:semicolon
DECL|member|rxdma
r_int
id|rxdma
suffix:semicolon
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|irlap
r_struct
id|irlap_cb
op_star
id|irlap
suffix:semicolon
DECL|member|pmdev
r_struct
id|pm_dev
op_star
id|pmdev
suffix:semicolon
DECL|member|qos
r_struct
id|qos_info
id|qos
suffix:semicolon
DECL|member|tx_buff
id|iobuff_t
id|tx_buff
suffix:semicolon
DECL|member|rx_buff
id|iobuff_t
id|rx_buff
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|IS_FIR
mdefine_line|#define IS_FIR(si)&t;&t;((si)-&gt;speed &gt;= 4000000)
DECL|macro|HPSIR_MAX_RXLEN
mdefine_line|#define HPSIR_MAX_RXLEN&t;&t;2047
multiline_comment|/*&n; * Allocate and map the receive buffer, unless it is already allocated.&n; */
DECL|function|sa1100_irda_rx_alloc
r_static
r_int
id|sa1100_irda_rx_alloc
c_func
(paren
r_struct
id|sa1100_irda
op_star
id|si
)paren
(brace
r_if
c_cond
(paren
id|si-&gt;rxskb
)paren
r_return
l_int|0
suffix:semicolon
id|si-&gt;rxskb
op_assign
id|alloc_skb
c_func
(paren
id|HPSIR_MAX_RXLEN
op_plus
l_int|1
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|si-&gt;rxskb
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sa1100_ir: out of memory for RX SKB&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Align any IP headers that may be contained&n;&t; * within the frame.&n;&t; */
id|skb_reserve
c_func
(paren
id|si-&gt;rxskb
comma
l_int|1
)paren
suffix:semicolon
id|si-&gt;rxbuf_dma
op_assign
id|pci_map_single
c_func
(paren
l_int|NULL
comma
id|si-&gt;rxskb-&gt;data
comma
id|HPSIR_MAX_RXLEN
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We want to get here as soon as possible, and get the receiver setup.&n; * We use the existing buffer.&n; */
DECL|function|sa1100_irda_rx_dma_start
r_static
r_void
id|sa1100_irda_rx_dma_start
c_func
(paren
r_struct
id|sa1100_irda
op_star
id|si
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|si-&gt;rxskb
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sa1100_ir: rx buffer went missing&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * First empty receive FIFO&n;&t; */
id|Ser2HSCR0
op_assign
id|si-&gt;hscr0
op_or
id|HSCR0_HSSP
suffix:semicolon
multiline_comment|/*&n;&t; * Enable the DMA, receiver and recieve interrupt.&n;&t; */
id|sa1100_dma_flush_all
c_func
(paren
id|si-&gt;rxdma
)paren
suffix:semicolon
id|sa1100_dma_queue_buffer
c_func
(paren
id|si-&gt;rxdma
comma
l_int|NULL
comma
id|si-&gt;rxbuf_dma
comma
id|HPSIR_MAX_RXLEN
)paren
suffix:semicolon
id|Ser2HSCR0
op_assign
id|si-&gt;hscr0
op_or
id|HSCR0_HSSP
op_or
id|HSCR0_RXE
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the IrDA communications speed.&n; */
DECL|function|sa1100_irda_set_speed
r_static
r_int
id|sa1100_irda_set_speed
c_func
(paren
r_struct
id|sa1100_irda
op_star
id|si
comma
r_int
id|speed
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|brd
comma
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|speed
)paren
(brace
r_case
l_int|9600
suffix:colon
r_case
l_int|19200
suffix:colon
r_case
l_int|38400
suffix:colon
r_case
l_int|57600
suffix:colon
r_case
l_int|115200
suffix:colon
id|brd
op_assign
l_int|3686400
op_div
(paren
l_int|16
op_star
id|speed
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Stop the receive DMA.&n;&t;&t; */
r_if
c_cond
(paren
id|IS_FIR
c_func
(paren
id|si
)paren
)paren
id|sa1100_dma_stop
c_func
(paren
id|si-&gt;rxdma
)paren
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|Ser2UTCR3
op_assign
l_int|0
suffix:semicolon
id|Ser2HSCR0
op_assign
id|HSCR0_UART
suffix:semicolon
id|Ser2UTCR1
op_assign
id|brd
op_rshift
l_int|8
suffix:semicolon
id|Ser2UTCR2
op_assign
id|brd
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear status register&n;&t;&t; */
id|Ser2UTSR0
op_assign
id|UTSR0_REB
op_or
id|UTSR0_RBB
op_or
id|UTSR0_RID
suffix:semicolon
id|Ser2UTCR3
op_assign
id|UTCR3_RIE
op_or
id|UTCR3_RXE
op_or
id|UTCR3_TXE
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_assabet
c_func
(paren
)paren
)paren
id|ASSABET_BCR_clear
c_func
(paren
id|ASSABET_BCR_IRDA_FSEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_h3600
c_func
(paren
)paren
)paren
id|clr_h3600_egpio
c_func
(paren
id|EGPIO_H3600_IR_FSEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_yopy
c_func
(paren
)paren
)paren
id|PPSR
op_and_assign
op_complement
id|GPIO_IRDA_FIR
suffix:semicolon
id|si-&gt;speed
op_assign
id|speed
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4000000
suffix:colon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|si-&gt;hscr0
op_assign
l_int|0
suffix:semicolon
id|Ser2HSSR0
op_assign
l_int|0xff
suffix:semicolon
id|Ser2HSCR0
op_assign
id|si-&gt;hscr0
op_or
id|HSCR0_HSSP
suffix:semicolon
id|Ser2UTCR3
op_assign
l_int|0
suffix:semicolon
id|si-&gt;speed
op_assign
id|speed
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_assabet
c_func
(paren
)paren
)paren
id|ASSABET_BCR_set
c_func
(paren
id|ASSABET_BCR_IRDA_FSEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_h3600
c_func
(paren
)paren
)paren
id|set_h3600_egpio
c_func
(paren
id|EGPIO_H3600_IR_FSEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_yopy
c_func
(paren
)paren
)paren
id|PPSR
op_or_assign
id|GPIO_IRDA_FIR
suffix:semicolon
id|sa1100_irda_rx_alloc
c_func
(paren
id|si
)paren
suffix:semicolon
id|sa1100_irda_rx_dma_start
c_func
(paren
id|si
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This sets the IRDA power level on the Assabet.&n; */
r_static
r_inline
r_int
DECL|function|sa1100_irda_set_power_assabet
id|sa1100_irda_set_power_assabet
c_func
(paren
r_struct
id|sa1100_irda
op_star
id|si
comma
r_int
r_int
id|state
)paren
(brace
r_static
r_int
r_int
id|bcr_state
(braket
l_int|4
)braket
op_assign
(brace
id|ASSABET_BCR_IRDA_MD0
comma
id|ASSABET_BCR_IRDA_MD1
op_or
id|ASSABET_BCR_IRDA_MD0
comma
id|ASSABET_BCR_IRDA_MD1
comma
l_int|0
)brace
suffix:semicolon
r_if
c_cond
(paren
id|state
OL
l_int|4
)paren
(brace
id|state
op_assign
id|bcr_state
(braket
id|state
)braket
suffix:semicolon
id|ASSABET_BCR_clear
c_func
(paren
id|state
op_xor
(paren
id|ASSABET_BCR_IRDA_MD1
op_or
id|ASSABET_BCR_IRDA_MD0
)paren
)paren
suffix:semicolon
id|ASSABET_BCR_set
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This turns the IRDA power on or off on the Compaq H3600&n; */
r_static
r_inline
r_int
DECL|function|sa1100_irda_set_power_h3600
id|sa1100_irda_set_power_h3600
c_func
(paren
r_struct
id|sa1100_irda
op_star
id|si
comma
r_int
r_int
id|state
)paren
(brace
r_if
c_cond
(paren
id|state
)paren
id|set_h3600_egpio
c_func
(paren
id|EGPIO_H3600_IR_ON
)paren
suffix:semicolon
r_else
id|clr_h3600_egpio
c_func
(paren
id|EGPIO_H3600_IR_ON
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This turns the IRDA power on or off on the Yopy&n; */
r_static
r_inline
r_int
DECL|function|sa1100_irda_set_power_yopy
id|sa1100_irda_set_power_yopy
c_func
(paren
r_struct
id|sa1100_irda
op_star
id|si
comma
r_int
r_int
id|state
)paren
(brace
r_if
c_cond
(paren
id|state
)paren
id|PPSR
op_and_assign
op_complement
id|GPIO_IRDA_POWER
suffix:semicolon
r_else
id|PPSR
op_or_assign
id|GPIO_IRDA_POWER
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Control the power state of the IrDA transmitter.&n; * State:&n; *  0 - off&n; *  1 - short range, lowest power&n; *  2 - medium range, medium power&n; *  3 - maximum range, high power&n; *&n; * Currently, only assabet is known to support this.&n; */
r_static
r_int
DECL|function|__sa1100_irda_set_power
id|__sa1100_irda_set_power
c_func
(paren
r_struct
id|sa1100_irda
op_star
id|si
comma
r_int
r_int
id|state
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_assabet
c_func
(paren
)paren
)paren
id|ret
op_assign
id|sa1100_irda_set_power_assabet
c_func
(paren
id|si
comma
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_h3600
c_func
(paren
)paren
)paren
id|ret
op_assign
id|sa1100_irda_set_power_h3600
c_func
(paren
id|si
comma
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_yopy
c_func
(paren
)paren
)paren
id|ret
op_assign
id|sa1100_irda_set_power_yopy
c_func
(paren
id|si
comma
id|state
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|sa1100_set_power
id|sa1100_set_power
c_func
(paren
r_struct
id|sa1100_irda
op_star
id|si
comma
r_int
r_int
id|state
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|__sa1100_irda_set_power
c_func
(paren
id|si
comma
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|si-&gt;power
op_assign
id|state
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sa1100_irda_startup
r_static
r_int
id|sa1100_irda_startup
c_func
(paren
r_struct
id|sa1100_irda
op_star
id|si
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the ports for this device are setup correctly.&n;&t; */
r_if
c_cond
(paren
id|machine_is_yopy
c_func
(paren
)paren
)paren
(brace
id|PPDR
op_or_assign
id|GPIO_IRDA_POWER
op_or
id|GPIO_IRDA_FIR
suffix:semicolon
id|PPSR
op_or_assign
id|GPIO_IRDA_POWER
op_or
id|GPIO_IRDA_FIR
suffix:semicolon
id|PSDR
op_or_assign
id|GPIO_IRDA_POWER
op_or
id|GPIO_IRDA_FIR
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Configure PPC for IRDA - we want to drive TXD2 low.&n;&t; * We also want to drive this pin low during sleep.&n;&t; */
id|PPSR
op_and_assign
op_complement
id|PPC_TXD2
suffix:semicolon
id|PSDR
op_and_assign
op_complement
id|PPC_TXD2
suffix:semicolon
id|PPDR
op_or_assign
id|PPC_TXD2
suffix:semicolon
multiline_comment|/*&n;&t; * Enable HP-SIR modulation, and ensure that the port is disabled.&n;&t; */
id|Ser2UTCR3
op_assign
l_int|0
suffix:semicolon
id|Ser2HSCR0
op_assign
id|HSCR0_UART
suffix:semicolon
id|Ser2UTCR4
op_assign
id|si-&gt;utcr4
suffix:semicolon
id|Ser2UTCR0
op_assign
id|UTCR0_8BitData
suffix:semicolon
id|Ser2HSCR2
op_assign
id|HSCR2_TrDataH
op_or
id|HSCR2_RcDataL
suffix:semicolon
multiline_comment|/*&n;&t; * Clear status register&n;&t; */
id|Ser2UTSR0
op_assign
id|UTSR0_REB
op_or
id|UTSR0_RBB
op_or
id|UTSR0_RID
suffix:semicolon
id|ret
op_assign
id|sa1100_irda_set_speed
c_func
(paren
id|si
comma
id|si-&gt;speed
op_assign
l_int|9600
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sa1100_irda_shutdown
r_static
r_void
id|sa1100_irda_shutdown
c_func
(paren
r_struct
id|sa1100_irda
op_star
id|si
)paren
(brace
multiline_comment|/*&n;&t; * Stop all DMA activity.&n;&t; */
id|sa1100_dma_stop
c_func
(paren
id|si-&gt;rxdma
)paren
suffix:semicolon
id|sa1100_dma_stop
c_func
(paren
id|si-&gt;txdma
)paren
suffix:semicolon
multiline_comment|/* Disable the port. */
id|Ser2UTCR3
op_assign
l_int|0
suffix:semicolon
id|Ser2HSCR0
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PM
multiline_comment|/*&n; * Suspend the IrDA interface.&n; */
DECL|function|sa1100_irda_suspend
r_static
r_int
id|sa1100_irda_suspend
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|state
)paren
(brace
r_struct
id|sa1100_irda
op_star
id|si
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|si
op_logical_and
id|si-&gt;open
)paren
(brace
multiline_comment|/*&n;&t;&t; * Stop the transmit queue&n;&t;&t; */
id|netif_device_detach
c_func
(paren
id|dev
)paren
suffix:semicolon
id|disable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|sa1100_irda_shutdown
c_func
(paren
id|si
)paren
suffix:semicolon
id|__sa1100_irda_set_power
c_func
(paren
id|si
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Resume the IrDA interface.&n; */
DECL|function|sa1100_irda_resume
r_static
r_int
id|sa1100_irda_resume
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sa1100_irda
op_star
id|si
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|si
op_logical_and
id|si-&gt;open
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we missed a speed change, initialise at the new speed&n;&t;&t; * directly.  It is debatable whether this is actually&n;&t;&t; * required, but in the interests of continuing from where&n;&t;&t; * we left off it is desireable.  The converse argument is&n;&t;&t; * that we should re-negotiate at 9600 baud again.&n;&t;&t; */
r_if
c_cond
(paren
id|si-&gt;newspeed
)paren
(brace
id|si-&gt;speed
op_assign
id|si-&gt;newspeed
suffix:semicolon
id|si-&gt;newspeed
op_assign
l_int|0
suffix:semicolon
)brace
id|sa1100_irda_startup
c_func
(paren
id|si
)paren
suffix:semicolon
id|__sa1100_irda_set_power
c_func
(paren
id|si
comma
id|si-&gt;power
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This automatically wakes up the queue&n;&t;&t; */
id|netif_device_attach
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sa1100_irda_pmproc
r_static
r_int
id|sa1100_irda_pmproc
c_func
(paren
r_struct
id|pm_dev
op_star
id|dev
comma
id|pm_request_t
id|rqst
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;data
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|rqst
)paren
(brace
r_case
id|PM_SUSPEND
suffix:colon
id|ret
op_assign
id|sa1100_irda_suspend
c_func
(paren
(paren
r_struct
id|net_device
op_star
)paren
id|dev-&gt;data
comma
(paren
r_int
)paren
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PM_RESUME
suffix:colon
id|ret
op_assign
id|sa1100_irda_resume
c_func
(paren
(paren
r_struct
id|net_device
op_star
)paren
id|dev-&gt;data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * HP-SIR format interrupt service routines.&n; */
DECL|function|sa1100_irda_hpsir_irq
r_static
r_void
id|sa1100_irda_hpsir_irq
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sa1100_irda
op_star
id|si
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|status
suffix:semicolon
id|status
op_assign
id|Ser2UTSR0
suffix:semicolon
multiline_comment|/*&n;&t; * Deal with any receive errors first.  The bytes in error may be&n;&t; * the only bytes in the receive FIFO, so we do this first.&n;&t; */
r_while
c_loop
(paren
id|status
op_amp
id|UTSR0_EIF
)paren
(brace
r_int
id|stat
comma
id|data
suffix:semicolon
id|stat
op_assign
id|Ser2UTSR1
suffix:semicolon
id|data
op_assign
id|Ser2UTDR
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|UTSR1_FRE
op_or
id|UTSR1_ROR
)paren
)paren
(brace
id|si-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|UTSR1_FRE
)paren
id|si-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|UTSR1_ROR
)paren
id|si-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
)brace
r_else
id|async_unwrap_char
c_func
(paren
id|dev
comma
op_amp
id|si-&gt;stats
comma
op_amp
id|si-&gt;rx_buff
comma
id|data
)paren
suffix:semicolon
id|status
op_assign
id|Ser2UTSR0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must clear certain bits.&n;&t; */
id|Ser2UTSR0
op_assign
id|status
op_amp
(paren
id|UTSR0_RID
op_or
id|UTSR0_RBB
op_or
id|UTSR0_REB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|UTSR0_RFS
)paren
(brace
multiline_comment|/*&n;&t;&t; * There are at least 4 bytes in the FIFO.  Read 3 bytes&n;&t;&t; * and leave the rest to the block below.&n;&t;&t; */
id|async_unwrap_char
c_func
(paren
id|dev
comma
op_amp
id|si-&gt;stats
comma
op_amp
id|si-&gt;rx_buff
comma
id|Ser2UTDR
)paren
suffix:semicolon
id|async_unwrap_char
c_func
(paren
id|dev
comma
op_amp
id|si-&gt;stats
comma
op_amp
id|si-&gt;rx_buff
comma
id|Ser2UTDR
)paren
suffix:semicolon
id|async_unwrap_char
c_func
(paren
id|dev
comma
op_amp
id|si-&gt;stats
comma
op_amp
id|si-&gt;rx_buff
comma
id|Ser2UTDR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
(paren
id|UTSR0_RFS
op_or
id|UTSR0_RID
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Fifo contains more than 1 character.&n;&t;&t; */
r_do
(brace
id|async_unwrap_char
c_func
(paren
id|dev
comma
op_amp
id|si-&gt;stats
comma
op_amp
id|si-&gt;rx_buff
comma
id|Ser2UTDR
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|Ser2UTSR1
op_amp
id|UTSR1_RNE
)paren
suffix:semicolon
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|UTSR0_TFS
op_logical_and
id|si-&gt;tx_buff.len
)paren
(brace
multiline_comment|/*&n;&t;&t; * Transmitter FIFO is not full&n;&t;&t; */
r_do
(brace
id|Ser2UTDR
op_assign
op_star
id|si-&gt;tx_buff.data
op_increment
suffix:semicolon
id|si-&gt;tx_buff.len
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|Ser2UTSR1
op_amp
id|UTSR1_TNF
op_logical_and
id|si-&gt;tx_buff.len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|si-&gt;tx_buff.len
op_eq
l_int|0
)paren
(brace
id|si-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|si-&gt;stats.tx_bytes
op_add_assign
id|si-&gt;tx_buff.data
op_minus
id|si-&gt;tx_buff.head
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We need to ensure that the transmitter has&n;&t;&t;&t; * finished.&n;&t;&t;&t; */
r_do
id|rmb
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|Ser2UTSR1
op_amp
id|UTSR1_TBY
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Ok, we&squot;ve finished transmitting.  Now enable&n;&t;&t;&t; * the receiver.  Sometimes we get a receive IRQ&n;&t;&t;&t; * immediately after a transmit...&n;&t;&t;&t; */
id|Ser2UTSR0
op_assign
id|UTSR0_REB
op_or
id|UTSR0_RBB
op_or
id|UTSR0_RID
suffix:semicolon
id|Ser2UTCR3
op_assign
id|UTCR3_RIE
op_or
id|UTCR3_RXE
op_or
id|UTCR3_TXE
suffix:semicolon
r_if
c_cond
(paren
id|si-&gt;newspeed
)paren
(brace
id|sa1100_irda_set_speed
c_func
(paren
id|si
comma
id|si-&gt;newspeed
)paren
suffix:semicolon
id|si-&gt;newspeed
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* I&squot;m hungry! */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|sa1100_irda_fir_error
r_static
r_void
id|sa1100_irda_fir_error
c_func
(paren
r_struct
id|sa1100_irda
op_star
id|si
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|si-&gt;rxskb
suffix:semicolon
id|dma_addr_t
id|dma_addr
suffix:semicolon
r_int
r_int
id|len
comma
id|stat
comma
id|data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sa1100_ir: SKB is NULL!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the current data position.&n;&t; */
id|sa1100_dma_get_current
c_func
(paren
id|si-&gt;rxdma
comma
l_int|NULL
comma
op_amp
id|dma_addr
)paren
suffix:semicolon
id|len
op_assign
id|dma_addr
op_minus
id|si-&gt;rxbuf_dma
suffix:semicolon
id|pci_unmap_single
c_func
(paren
l_int|NULL
comma
id|si-&gt;rxbuf_dma
comma
id|len
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Read Status, and then Data.&n;&t;&t; */
id|stat
op_assign
id|Ser2HSSR1
suffix:semicolon
id|rmb
c_func
(paren
)paren
suffix:semicolon
id|data
op_assign
id|Ser2HSDR
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|HSSR1_CRE
op_or
id|HSSR1_ROR
)paren
)paren
(brace
id|si-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|HSSR1_CRE
)paren
id|si-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|HSSR1_ROR
)paren
id|si-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
)brace
r_else
id|skb-&gt;data
(braket
id|len
op_increment
)braket
op_assign
id|data
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we hit the end of frame, there&squot;s&n;&t;&t; * no point in continuing.&n;&t;&t; */
r_if
c_cond
(paren
id|stat
op_amp
id|HSSR1_EOF
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|Ser2HSSR0
op_amp
id|HSSR0_EIF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|HSSR1_EOF
)paren
(brace
id|si-&gt;rxskb
op_assign
l_int|NULL
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_IRDA
)paren
suffix:semicolon
id|si-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|si-&gt;stats.rx_bytes
op_add_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Before we pass the buffer up, allocate a new one.&n;&t;&t; */
id|sa1100_irda_rx_alloc
c_func
(paren
id|si
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Remap the buffer.&n;&t;&t; */
id|si-&gt;rxbuf_dma
op_assign
id|pci_map_single
c_func
(paren
l_int|NULL
comma
id|si-&gt;rxskb-&gt;data
comma
id|HPSIR_MAX_RXLEN
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * FIR format interrupt service routine.  We only have to&n; * handle RX events; transmit events go via the TX DMA handler.&n; *&n; * No matter what, we disable RX, process, and the restart RX.&n; */
DECL|function|sa1100_irda_fir_irq
r_static
r_void
id|sa1100_irda_fir_irq
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sa1100_irda
op_star
id|si
op_assign
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/*&n;&t; * Stop RX DMA&n;&t; */
id|sa1100_dma_stop
c_func
(paren
id|si-&gt;rxdma
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Framing error - we throw away the packet completely.&n;&t; * Clearing RXE flushes the error conditions and data&n;&t; * from the fifo.&n;&t; */
r_if
c_cond
(paren
id|Ser2HSSR0
op_amp
(paren
id|HSSR0_FRE
op_or
id|HSSR0_RAB
)paren
)paren
(brace
id|si-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|Ser2HSSR0
op_amp
id|HSSR0_FRE
)paren
id|si-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear out the DMA...&n;&t;&t; */
id|Ser2HSCR0
op_assign
id|si-&gt;hscr0
op_or
id|HSCR0_HSSP
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear selected status bits now, so we&n;&t;&t; * don&squot;t miss them next time around.&n;&t;&t; */
id|Ser2HSSR0
op_assign
id|HSSR0_FRE
op_or
id|HSSR0_RAB
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Deal with any receive errors.  The any of the lowest&n;&t; * 8 bytes in the FIFO may contain an error.  We must read&n;&t; * them one by one.  The &quot;error&quot; could even be the end of&n;&t; * packet!&n;&t; */
r_if
c_cond
(paren
id|Ser2HSSR0
op_amp
id|HSSR0_EIF
)paren
id|sa1100_irda_fir_error
c_func
(paren
id|si
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * No matter what happens, we must restart reception.&n;&t; */
id|sa1100_irda_rx_dma_start
c_func
(paren
id|si
)paren
suffix:semicolon
)brace
DECL|function|sa1100_irda_irq
r_static
r_void
id|sa1100_irda_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
id|IS_FIR
c_func
(paren
(paren
(paren
r_struct
id|sa1100_irda
op_star
)paren
id|dev-&gt;priv
)paren
)paren
)paren
id|sa1100_irda_fir_irq
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
id|sa1100_irda_hpsir_irq
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * TX DMA completion handler.&n; */
DECL|function|sa1100_irda_txdma_irq
r_static
r_void
id|sa1100_irda_txdma_irq
c_func
(paren
r_void
op_star
id|id
comma
r_int
id|len
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|id
suffix:semicolon
r_struct
id|sa1100_irda
op_star
id|si
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|si-&gt;txskb
suffix:semicolon
id|si-&gt;txskb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for the transmission to complete.  Unfortunately,&n;&t; * the hardware doesn&squot;t give us an interrupt to indicate&n;&t; * &quot;end of frame&quot;.&n;&t; */
r_do
id|rmb
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|Ser2HSSR0
op_amp
id|HSSR0_TUR
)paren
op_logical_or
id|Ser2HSSR1
op_amp
id|HSSR1_TBY
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the transmit underrun bit.&n;&t; */
id|Ser2HSSR0
op_assign
id|HSSR0_TUR
suffix:semicolon
multiline_comment|/*&n;&t; * Do we need to change speed?  Note that we&squot;re lazy&n;&t; * here - we don&squot;t free the old rxskb.  We don&squot;t need&n;&t; * to allocate a buffer either.&n;&t; */
r_if
c_cond
(paren
id|si-&gt;newspeed
)paren
(brace
id|sa1100_irda_set_speed
c_func
(paren
id|si
comma
id|si-&gt;newspeed
)paren
suffix:semicolon
id|si-&gt;newspeed
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Start reception.  This disables the transmitter for&n;&t; * us.  This will be using the existing RX buffer.&n;&t; */
id|sa1100_irda_rx_dma_start
c_func
(paren
id|si
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Account and free the packet.&n;&t; */
r_if
c_cond
(paren
id|skb
)paren
(brace
id|pci_unmap_single
c_func
(paren
l_int|NULL
comma
id|si-&gt;txbuf_dma
comma
id|len
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|si-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|si-&gt;stats.tx_bytes
op_add_assign
id|len
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make sure that the TX queue is available for sending&n;&t; * (for retries).  TX has priority over RX at all times.&n;&t; */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Note that we will never build up a backlog of frames; the protocol is a&n; * half duplex protocol which basically means we transmit a frame, we&n; * receive a frame, we transmit the next frame etc.&n; */
DECL|function|sa1100_irda_hard_xmit
r_static
r_int
id|sa1100_irda_hard_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sa1100_irda
op_star
id|si
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|speed
op_assign
id|irda_get_next_speed
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Does this packet contain a request to change the interface&n;&t; * speed?  If so, remember it until we complete the transmission&n;&t; * of this frame.&n;&t; */
r_if
c_cond
(paren
id|speed
op_ne
id|si-&gt;speed
op_logical_and
id|speed
op_ne
op_minus
l_int|1
)paren
id|si-&gt;newspeed
op_assign
id|speed
suffix:semicolon
multiline_comment|/*&n;&t; * If this is an empty frame, we can bypass a lot.&n;&t; */
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|si-&gt;newspeed
)paren
(brace
id|si-&gt;newspeed
op_assign
l_int|0
suffix:semicolon
id|sa1100_irda_set_speed
c_func
(paren
id|si
comma
id|speed
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|IS_FIR
c_func
(paren
id|si
)paren
)paren
(brace
id|si-&gt;tx_buff.data
op_assign
id|si-&gt;tx_buff.head
suffix:semicolon
id|si-&gt;tx_buff.len
op_assign
id|async_wrap_skb
c_func
(paren
id|skb
comma
id|si-&gt;tx_buff.data
comma
id|si-&gt;tx_buff.truesize
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the transmit interrupt enable.  This will fire&n;&t;&t; * off an interrupt immediately.  Note that we disable&n;&t;&t; * the receiver so we won&squot;t get spurious characteres&n;&t;&t; * received.&n;&t;&t; */
id|Ser2UTCR3
op_assign
id|UTCR3_TIE
op_or
id|UTCR3_TXE
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|mtt
op_assign
id|irda_get_mtt
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We must not be transmitting...&n;&t;&t; */
r_if
c_cond
(paren
id|si-&gt;txskb
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|si-&gt;txskb
op_assign
id|skb
suffix:semicolon
id|si-&gt;txbuf_dma
op_assign
id|pci_map_single
c_func
(paren
l_int|NULL
comma
id|skb-&gt;data
comma
id|skb-&gt;len
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|sa1100_dma_queue_buffer
c_func
(paren
id|si-&gt;txdma
comma
id|dev
comma
id|si-&gt;txbuf_dma
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we have a mean turn-around time, impose the specified&n;&t;&t; * specified delay.  We could shorten this by timing from&n;&t;&t; * the point we received the packet.&n;&t;&t; */
r_if
c_cond
(paren
id|mtt
)paren
id|udelay
c_func
(paren
id|mtt
)paren
suffix:semicolon
id|Ser2HSCR0
op_assign
id|si-&gt;hscr0
op_or
id|HSCR0_HSSP
op_or
id|HSCR0_TXE
suffix:semicolon
)brace
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|sa1100_irda_ioctl
id|sa1100_irda_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifreq
comma
r_int
id|cmd
)paren
(brace
r_struct
id|if_irda_req
op_star
id|rq
op_assign
(paren
r_struct
id|if_irda_req
op_star
)paren
id|ifreq
suffix:semicolon
r_struct
id|sa1100_irda
op_star
id|si
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCSBANDWIDTH
suffix:colon
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We are unable to set the speed if the&n;&t;&t;&t; * device is not running.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|si-&gt;open
)paren
(brace
id|ret
op_assign
id|sa1100_irda_set_speed
c_func
(paren
id|si
comma
id|rq-&gt;ifr_baudrate
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;sa1100_irda_ioctl: SIOCSBANDWIDTH: !netif_running&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|SIOCSMEDIABUSY
suffix:colon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|irda_device_set_media_busy
c_func
(paren
id|dev
comma
id|TRUE
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIOCGRECEIVING
suffix:colon
id|rq-&gt;ifr_receiving
op_assign
id|IS_FIR
c_func
(paren
id|si
)paren
ques
c_cond
l_int|0
suffix:colon
id|si-&gt;rx_buff.state
op_ne
id|OUTSIDE_FRAME
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sa1100_irda_stats
r_static
r_struct
id|net_device_stats
op_star
id|sa1100_irda_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sa1100_irda
op_star
id|si
op_assign
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|si-&gt;stats
suffix:semicolon
)brace
DECL|function|sa1100_irda_start
r_static
r_int
id|sa1100_irda_start
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sa1100_irda
op_star
id|si
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|err
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|si-&gt;speed
op_assign
l_int|9600
suffix:semicolon
id|err
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|sa1100_irda_irq
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_irq
suffix:semicolon
id|err
op_assign
id|sa1100_request_dma
c_func
(paren
op_amp
id|si-&gt;rxdma
comma
l_string|&quot;IrDA receive&quot;
comma
id|DMA_Ser2HSSPRd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_rx_dma
suffix:semicolon
id|err
op_assign
id|sa1100_request_dma
c_func
(paren
op_amp
id|si-&gt;txdma
comma
l_string|&quot;IrDA transmit&quot;
comma
id|DMA_Ser2HSSPWr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_tx_dma
suffix:semicolon
multiline_comment|/*&n;&t; * The interrupt must remain disabled for now.&n;&t; */
id|disable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup the serial port for the specified speed.&n;&t; */
id|err
op_assign
id|sa1100_irda_startup
c_func
(paren
id|si
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_startup
suffix:semicolon
multiline_comment|/*&n;&t; * Open a new IrLAP layer instance.&n;&t; */
id|si-&gt;irlap
op_assign
id|irlap_open
c_func
(paren
id|dev
comma
op_amp
id|si-&gt;qos
comma
l_string|&quot;sa1100&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|si-&gt;irlap
)paren
r_goto
id|err_irlap
suffix:semicolon
id|sa1100_dma_set_callback
c_func
(paren
id|si-&gt;txdma
comma
id|sa1100_irda_txdma_irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now enable the interrupt and start the queue&n;&t; */
id|si-&gt;open
op_assign
l_int|1
suffix:semicolon
id|sa1100_set_power
c_func
(paren
id|si
comma
id|power_level
)paren
suffix:semicolon
multiline_comment|/* low power mode */
id|enable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_irlap
suffix:colon
id|si-&gt;open
op_assign
l_int|0
suffix:semicolon
id|sa1100_irda_shutdown
c_func
(paren
id|si
)paren
suffix:semicolon
id|err_startup
suffix:colon
id|sa1100_free_dma
c_func
(paren
id|si-&gt;txdma
)paren
suffix:semicolon
id|err_tx_dma
suffix:colon
id|sa1100_free_dma
c_func
(paren
id|si-&gt;rxdma
)paren
suffix:semicolon
id|err_rx_dma
suffix:colon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|err_irq
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sa1100_irda_stop
r_static
r_int
id|sa1100_irda_stop
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sa1100_irda
op_star
id|si
op_assign
id|dev-&gt;priv
suffix:semicolon
id|disable_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|sa1100_irda_shutdown
c_func
(paren
id|si
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have been doing DMA receive, make sure we&n;&t; * tidy that up cleanly.&n;&t; */
r_if
c_cond
(paren
id|si-&gt;rxskb
)paren
(brace
id|pci_unmap_single
c_func
(paren
l_int|NULL
comma
id|si-&gt;rxbuf_dma
comma
id|HPSIR_MAX_RXLEN
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|si-&gt;rxskb
)paren
suffix:semicolon
id|si-&gt;rxskb
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Stop IrLAP */
r_if
c_cond
(paren
id|si-&gt;irlap
)paren
(brace
id|irlap_close
c_func
(paren
id|si-&gt;irlap
)paren
suffix:semicolon
id|si-&gt;irlap
op_assign
l_int|NULL
suffix:semicolon
)brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|si-&gt;open
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Free resources&n;&t; */
id|sa1100_free_dma
c_func
(paren
id|si-&gt;txdma
)paren
suffix:semicolon
id|sa1100_free_dma
c_func
(paren
id|si-&gt;rxdma
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|sa1100_set_power
c_func
(paren
id|si
comma
l_int|0
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sa1100_irda_init_iobuf
r_static
r_int
id|sa1100_irda_init_iobuf
c_func
(paren
id|iobuff_t
op_star
id|io
comma
r_int
id|size
)paren
(brace
id|io-&gt;head
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io-&gt;head
op_ne
l_int|NULL
)paren
(brace
id|io-&gt;truesize
op_assign
id|size
suffix:semicolon
id|io-&gt;in_frame
op_assign
id|FALSE
suffix:semicolon
id|io-&gt;state
op_assign
id|OUTSIDE_FRAME
suffix:semicolon
id|io-&gt;data
op_assign
id|io-&gt;head
suffix:semicolon
)brace
r_return
id|io-&gt;head
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|sa1100_irda_net_init
r_static
r_int
id|sa1100_irda_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sa1100_irda
op_star
id|si
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|baudrate_mask
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|si
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sa1100_irda
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|si
)paren
r_goto
id|out
suffix:semicolon
id|memset
c_func
(paren
id|si
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|si
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialise the HP-SIR buffers&n;&t; */
id|err
op_assign
id|sa1100_irda_init_iobuf
c_func
(paren
op_amp
id|si-&gt;rx_buff
comma
l_int|14384
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|sa1100_irda_init_iobuf
c_func
(paren
op_amp
id|si-&gt;tx_buff
comma
l_int|4000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_free_rx
suffix:semicolon
id|dev-&gt;priv
op_assign
id|si
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|sa1100_irda_hard_xmit
suffix:semicolon
id|dev-&gt;open
op_assign
id|sa1100_irda_start
suffix:semicolon
id|dev-&gt;stop
op_assign
id|sa1100_irda_stop
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|sa1100_irda_ioctl
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|sa1100_irda_stats
suffix:semicolon
id|irda_device_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|irda_init_max_qos_capabilies
c_func
(paren
op_amp
id|si-&gt;qos
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We support original IRDA up to 115k2. (we don&squot;t currently&n;&t; * support 4Mbps).  Min Turn Time set to 1ms or greater.&n;&t; */
id|baudrate_mask
op_assign
id|IR_9600
op_or
id|IR_19200
op_or
id|IR_38400
op_or
id|IR_57600
op_or
id|IR_115200
suffix:semicolon
id|baudrate_mask
op_or_assign
id|IR_4000000
op_lshift
l_int|8
suffix:semicolon
id|si-&gt;qos.baud_rate.bits
op_and_assign
id|baudrate_mask
suffix:semicolon
id|si-&gt;qos.min_turn_time.bits
op_assign
l_int|7
suffix:semicolon
id|irda_qos_bits_to_value
c_func
(paren
op_amp
id|si-&gt;qos
)paren
suffix:semicolon
id|si-&gt;utcr4
op_assign
id|UTCR4_HPSIR
suffix:semicolon
r_if
c_cond
(paren
id|tx_lpm
)paren
id|si-&gt;utcr4
op_or_assign
id|UTCR4_Z1_6us
suffix:semicolon
multiline_comment|/*&n;&t; * Initially enable HP-SIR modulation, and ensure that the port&n;&t; * is disabled.&n;&t; */
id|Ser2UTCR3
op_assign
l_int|0
suffix:semicolon
id|Ser2UTCR4
op_assign
id|si-&gt;utcr4
suffix:semicolon
id|Ser2HSCR0
op_assign
id|HSCR0_UART
suffix:semicolon
macro_line|#ifdef CONFIG_PM
multiline_comment|/*&n;&t; * Power-Management is optional.&n;&t; */
id|si-&gt;pmdev
op_assign
id|pm_register
c_func
(paren
id|PM_SYS_DEV
comma
id|PM_SYS_IRDA
comma
id|sa1100_irda_pmproc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|si-&gt;pmdev
)paren
id|si-&gt;pmdev-&gt;data
op_assign
id|dev
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|si-&gt;tx_buff.head
)paren
suffix:semicolon
id|out_free_rx
suffix:colon
id|kfree
c_func
(paren
id|si-&gt;rx_buff.head
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|si
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove all traces of this driver module from the kernel, so we can&squot;t be&n; * called.  Note that the device has already been stopped, so we don&squot;t have&n; * to worry about interrupts or dma.&n; */
DECL|function|sa1100_irda_net_uninit
r_static
r_void
id|sa1100_irda_net_uninit
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sa1100_irda
op_star
id|si
op_assign
id|dev-&gt;priv
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;open
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;stop
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;get_stats
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
id|pm_unregister
c_func
(paren
id|si-&gt;pmdev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|si-&gt;tx_buff.head
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|si-&gt;rx_buff.head
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|si
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
r_static
macro_line|#endif
DECL|function|sa1100_irda_init
r_int
id|__init
id|sa1100_irda_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * Limit power level a sensible range.&n;&t; */
r_if
c_cond
(paren
id|power_level
OL
l_int|1
)paren
id|power_level
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|power_level
OG
l_int|3
)paren
id|power_level
op_assign
l_int|3
suffix:semicolon
id|err
op_assign
id|request_mem_region
c_func
(paren
id|__PREG
c_func
(paren
id|Ser2UTCR0
)paren
comma
l_int|0x24
comma
l_string|&quot;IrDA&quot;
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_mem_1
suffix:semicolon
id|err
op_assign
id|request_mem_region
c_func
(paren
id|__PREG
c_func
(paren
id|Ser2HSCR0
)paren
comma
l_int|0x1c
comma
l_string|&quot;IrDA&quot;
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_mem_2
suffix:semicolon
id|err
op_assign
id|request_mem_region
c_func
(paren
id|__PREG
c_func
(paren
id|Ser2HSCR2
)paren
comma
l_int|0x04
comma
l_string|&quot;IrDA&quot;
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|err_mem_3
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|dev
op_assign
id|dev_alloc
c_func
(paren
l_string|&quot;irda%d&quot;
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
id|dev-&gt;irq
op_assign
id|IRQ_Ser2ICP
suffix:semicolon
id|dev-&gt;init
op_assign
id|sa1100_irda_net_init
suffix:semicolon
id|dev-&gt;uninit
op_assign
id|sa1100_irda_net_uninit
suffix:semicolon
id|err
op_assign
id|register_netdevice
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
id|netdev
op_assign
id|dev
suffix:semicolon
)brace
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|release_mem_region
c_func
(paren
id|__PREG
c_func
(paren
id|Ser2HSCR2
)paren
comma
l_int|0x04
)paren
suffix:semicolon
id|err_mem_3
suffix:colon
id|release_mem_region
c_func
(paren
id|__PREG
c_func
(paren
id|Ser2HSCR0
)paren
comma
l_int|0x1c
)paren
suffix:semicolon
id|err_mem_2
suffix:colon
id|release_mem_region
c_func
(paren
id|__PREG
c_func
(paren
id|Ser2UTCR0
)paren
comma
l_int|0x24
)paren
suffix:semicolon
)brace
id|err_mem_1
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sa1100_irda_exit
r_static
r_void
id|__exit
id|sa1100_irda_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|netdev
suffix:semicolon
id|netdev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|unregister_netdevice
c_func
(paren
id|dev
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
id|release_mem_region
c_func
(paren
id|__PREG
c_func
(paren
id|Ser2HSCR2
)paren
comma
l_int|0x04
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|__PREG
c_func
(paren
id|Ser2HSCR0
)paren
comma
l_int|0x1c
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|__PREG
c_func
(paren
id|Ser2UTCR0
)paren
comma
l_int|0x24
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We now know that the netdevice is no longer in use, and all&n;&t; * references to our driver have been removed.  The only structure&n;&t; * which may still be present is the netdevice, which will get&n;&t; * cleaned up by net/core/dev.c&n;&t; */
)brace
macro_line|#ifdef MODULE
DECL|variable|sa1100_irda_init
id|module_init
c_func
(paren
id|sa1100_irda_init
)paren
suffix:semicolon
DECL|variable|sa1100_irda_exit
id|module_exit
c_func
(paren
id|sa1100_irda_exit
)paren
suffix:semicolon
macro_line|#endif
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Russell King &lt;rmk@arm.linux.org.uk&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;StrongARM SA1100 IrDA driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|power_level
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|power_level
comma
l_string|&quot;IrDA power level, 1 (low) to 3 (high)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|tx_lpm
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|tx_lpm
comma
l_string|&quot;Enable transmitter low power (1.6us) mode&quot;
)paren
suffix:semicolon
id|EXPORT_NO_SYMBOLS
suffix:semicolon
eof
