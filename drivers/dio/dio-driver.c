multiline_comment|/*&n; *  DIO Driver Services&n; *&n; *  Copyright (C) 2004 Jochen Friedrich&n; *&n; *  Loosely based on drivers/pci/pci-driver.c and drivers/zorro/zorro-driver.c&n; *&n; *  This file is subject to the terms and conditions of the GNU General Public&n; *  License.  See the file COPYING in the main directory of this archive&n; *  for more details.&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/dio.h&gt;
multiline_comment|/**&n;&t; *  dio_match_device - Tell if a DIO device structure has a matching&n;&t; *                     DIO device id structure&n;&t; *  @ids: array of DIO device id structures to search in&n;&t; *  @dev: the DIO device structure to match against&n;&t; *&n;&t; *  Used by a driver to check whether a DIO device present in the&n;&t; *  system is in its list of supported devices. Returns the matching&n;&t; *  dio_device_id structure or %NULL if there is no match.&n;&t; */
r_const
r_struct
id|dio_device_id
op_star
DECL|function|dio_match_device
id|dio_match_device
c_func
(paren
r_const
r_struct
id|dio_device_id
op_star
id|ids
comma
r_const
r_struct
id|dio_dev
op_star
id|d
)paren
(brace
r_while
c_loop
(paren
id|ids-&gt;id
)paren
(brace
r_if
c_cond
(paren
id|ids-&gt;id
op_eq
id|DIO_WILDCARD
)paren
r_return
id|ids
suffix:semicolon
r_if
c_cond
(paren
id|DIO_NEEDSSECID
c_func
(paren
id|ids-&gt;id
op_amp
l_int|0xff
)paren
)paren
(brace
r_if
c_cond
(paren
id|ids-&gt;id
op_eq
id|d-&gt;id
)paren
r_return
id|ids
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|ids-&gt;id
op_amp
l_int|0xff
)paren
op_eq
(paren
id|d-&gt;id
op_amp
l_int|0xff
)paren
)paren
r_return
id|ids
suffix:semicolon
)brace
id|ids
op_increment
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|dio_device_probe
r_static
r_int
id|dio_device_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|dio_driver
op_star
id|drv
op_assign
id|to_dio_driver
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
r_struct
id|dio_dev
op_star
id|d
op_assign
id|to_dio_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d-&gt;driver
op_logical_and
id|drv-&gt;probe
)paren
(brace
r_const
r_struct
id|dio_device_id
op_star
id|id
suffix:semicolon
id|id
op_assign
id|dio_match_device
c_func
(paren
id|drv-&gt;id_table
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
)paren
id|error
op_assign
id|drv
op_member_access_from_pointer
id|probe
c_func
(paren
id|d
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ge
l_int|0
)paren
(brace
id|d-&gt;driver
op_assign
id|drv
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n;&t; *  dio_register_driver - register a new DIO driver&n;&t; *  @drv: the driver structure to register&n;&t; *&n;&t; *  Adds the driver structure to the list of registered drivers&n;&t; *  Returns the number of DIO devices which were claimed by the driver&n;&t; *  during registration.  The driver remains registered even if the&n;&t; *  return value is zero.&n;&t; */
DECL|function|dio_register_driver
r_int
id|dio_register_driver
c_func
(paren
r_struct
id|dio_driver
op_star
id|drv
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* initialize common driver fields */
id|drv-&gt;driver.name
op_assign
id|drv-&gt;name
suffix:semicolon
id|drv-&gt;driver.bus
op_assign
op_amp
id|dio_bus_type
suffix:semicolon
id|drv-&gt;driver.probe
op_assign
id|dio_device_probe
suffix:semicolon
multiline_comment|/* register with core */
id|count
op_assign
id|driver_register
c_func
(paren
op_amp
id|drv-&gt;driver
)paren
suffix:semicolon
r_return
id|count
ques
c_cond
id|count
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n;&t; *  dio_unregister_driver - unregister a DIO driver&n;&t; *  @drv: the driver structure to unregister&n;&t; *&n;&t; *  Deletes the driver structure from the list of registered DIO drivers,&n;&t; *  gives it a chance to clean up by calling its remove() function for&n;&t; *  each device it was responsible for, and marks those devices as&n;&t; *  driverless.&n;&t; */
DECL|function|dio_unregister_driver
r_void
id|dio_unregister_driver
c_func
(paren
r_struct
id|dio_driver
op_star
id|drv
)paren
(brace
id|driver_unregister
c_func
(paren
op_amp
id|drv-&gt;driver
)paren
suffix:semicolon
)brace
multiline_comment|/**&n;&t; *  dio_bus_match - Tell if a DIO device structure has a matching DIO&n;&t; *                  device id structure&n;&t; *  @ids: array of DIO device id structures to search in&n;&t; *  @dev: the DIO device structure to match against&n;&t; *&n;&t; *  Used by a driver to check whether a DIO device present in the&n;&t; *  system is in its list of supported devices. Returns the matching&n;&t; *  dio_device_id structure or %NULL if there is no match.&n;&t; */
DECL|function|dio_bus_match
r_static
r_int
id|dio_bus_match
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|device_driver
op_star
id|drv
)paren
(brace
r_struct
id|dio_dev
op_star
id|d
op_assign
id|to_dio_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|dio_driver
op_star
id|dio_drv
op_assign
id|to_dio_driver
c_func
(paren
id|drv
)paren
suffix:semicolon
r_const
r_struct
id|dio_device_id
op_star
id|ids
op_assign
id|dio_drv-&gt;id_table
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ids
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ids-&gt;id
)paren
(brace
r_if
c_cond
(paren
id|ids-&gt;id
op_eq
id|DIO_WILDCARD
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|DIO_NEEDSSECID
c_func
(paren
id|ids-&gt;id
op_amp
l_int|0xff
)paren
)paren
(brace
r_if
c_cond
(paren
id|ids-&gt;id
op_eq
id|d-&gt;id
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|ids-&gt;id
op_amp
l_int|0xff
)paren
op_eq
(paren
id|d-&gt;id
op_amp
l_int|0xff
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|ids
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|dio_bus_type
r_struct
id|bus_type
id|dio_bus_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;dio&quot;
comma
dot
id|match
op_assign
id|dio_bus_match
)brace
suffix:semicolon
DECL|function|dio_driver_init
r_static
r_int
id|__init
id|dio_driver_init
c_func
(paren
r_void
)paren
(brace
r_return
id|bus_register
c_func
(paren
op_amp
id|dio_bus_type
)paren
suffix:semicolon
)brace
DECL|variable|dio_driver_init
id|postcore_initcall
c_func
(paren
id|dio_driver_init
)paren
suffix:semicolon
DECL|variable|dio_match_device
id|EXPORT_SYMBOL
c_func
(paren
id|dio_match_device
)paren
suffix:semicolon
DECL|variable|dio_register_driver
id|EXPORT_SYMBOL
c_func
(paren
id|dio_register_driver
)paren
suffix:semicolon
DECL|variable|dio_unregister_driver
id|EXPORT_SYMBOL
c_func
(paren
id|dio_unregister_driver
)paren
suffix:semicolon
DECL|variable|dio_dev_driver
id|EXPORT_SYMBOL
c_func
(paren
id|dio_dev_driver
)paren
suffix:semicolon
DECL|variable|dio_bus_type
id|EXPORT_SYMBOL
c_func
(paren
id|dio_bus_type
)paren
suffix:semicolon
eof
