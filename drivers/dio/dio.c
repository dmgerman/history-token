multiline_comment|/* Code to support devices on the DIO and DIO-II bus&n; * Copyright (C) 05/1998 Peter Maydell &lt;pmaydell@chiark.greenend.org.uk&gt;&n; * Copyright (C) 2004 Jochen Friedrich &lt;jochen@scram.de&gt;&n; * &n; * This code has basically these routines at the moment:&n; * int dio_find(u_int deviceid)&n; *    Search the list of DIO devices and return the select code&n; *    of the next unconfigured device found that matches the given device ID.&n; *    Note that the deviceid parameter should be the encoded ID.&n; *    This means that framebuffers should pass it as &n; *    DIO_ENCODE_ID(DIO_ID_FBUFFER,DIO_ID2_TOPCAT)&n; *    (or whatever); everybody else just uses DIO_ID_FOOBAR.&n; * unsigned long dio_scodetophysaddr(int scode)&n; *    Return the physical address corresponding to the given select code.&n; * int dio_scodetoipl(int scode)&n; *    Every DIO card has a fixed interrupt priority level. This function &n; *    returns it, whatever it is.&n; * const char *dio_scodetoname(int scode)&n; *    Return a character string describing this board [might be &quot;&quot; if &n; *    not CONFIG_DIO_CONSTANTS]&n; * void dio_config_board(int scode)     mark board as configured in the list&n; * void dio_unconfig_board(int scode)   mark board as no longer configured&n; *&n; * This file is based on the way the Amiga port handles Zorro II cards, &n; * although we aren&squot;t so complicated...&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/dio.h&gt;
macro_line|#include &lt;linux/slab.h&gt;                         /* kmalloc() */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;                             /* readb() */
DECL|variable|dio_bus
r_struct
id|dio_bus
id|dio_bus
op_assign
(brace
dot
id|resources
op_assign
(brace
multiline_comment|/* DIO range */
(brace
dot
id|name
op_assign
l_string|&quot;DIO mem&quot;
comma
dot
id|start
op_assign
l_int|0x00600000
comma
dot
id|end
op_assign
l_int|0x007fffff
)brace
comma
multiline_comment|/* DIO-II range */
(brace
dot
id|name
op_assign
l_string|&quot;DIO-II mem&quot;
comma
dot
id|start
op_assign
l_int|0x01000000
comma
dot
id|end
op_assign
l_int|0x1fffffff
)brace
)brace
comma
dot
id|name
op_assign
l_string|&quot;DIO bus&quot;
)brace
suffix:semicolon
multiline_comment|/* not a real config option yet! */
DECL|macro|CONFIG_DIO_CONSTANTS
mdefine_line|#define CONFIG_DIO_CONSTANTS
macro_line|#ifdef CONFIG_DIO_CONSTANTS
multiline_comment|/* We associate each numeric ID with an appropriate descriptive string&n; * using a constant array of these structs.&n; * FIXME: we should be able to arrange to throw away most of the strings&n; * using the initdata stuff. Then we wouldn&squot;t need to worry about &n; * carrying them around...&n; * I think we do this by copying them into newly kmalloc()ed memory and &n; * marking the names[] array as .initdata ?&n; */
DECL|struct|dioname
r_struct
id|dioname
(brace
DECL|member|id
r_int
id|id
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* useful macro */
DECL|macro|DIONAME
mdefine_line|#define DIONAME(x) { DIO_ID_##x, DIO_DESC_##x }
DECL|macro|DIOFBNAME
mdefine_line|#define DIOFBNAME(x) { DIO_ENCODE_ID( DIO_ID_FBUFFER, DIO_ID2_##x), DIO_DESC2_##x }
DECL|variable|names
r_static
r_struct
id|dioname
id|names
(braket
)braket
op_assign
(brace
id|DIONAME
c_func
(paren
id|DCA0
)paren
comma
id|DIONAME
c_func
(paren
id|DCA0REM
)paren
comma
id|DIONAME
c_func
(paren
id|DCA1
)paren
comma
id|DIONAME
c_func
(paren
id|DCA1REM
)paren
comma
id|DIONAME
c_func
(paren
id|DCM
)paren
comma
id|DIONAME
c_func
(paren
id|DCMREM
)paren
comma
id|DIONAME
c_func
(paren
id|LAN
)paren
comma
id|DIONAME
c_func
(paren
id|FHPIB
)paren
comma
id|DIONAME
c_func
(paren
id|NHPIB
)paren
comma
id|DIONAME
c_func
(paren
id|SCSI0
)paren
comma
id|DIONAME
c_func
(paren
id|SCSI1
)paren
comma
id|DIONAME
c_func
(paren
id|SCSI2
)paren
comma
id|DIONAME
c_func
(paren
id|SCSI3
)paren
comma
id|DIONAME
c_func
(paren
id|FBUFFER
)paren
comma
id|DIONAME
c_func
(paren
id|PARALLEL
)paren
comma
id|DIONAME
c_func
(paren
id|VME
)paren
comma
id|DIONAME
c_func
(paren
id|DCL
)paren
comma
id|DIONAME
c_func
(paren
id|DCLREM
)paren
comma
id|DIONAME
c_func
(paren
id|MISC0
)paren
comma
id|DIONAME
c_func
(paren
id|MISC1
)paren
comma
id|DIONAME
c_func
(paren
id|MISC2
)paren
comma
id|DIONAME
c_func
(paren
id|MISC3
)paren
comma
id|DIONAME
c_func
(paren
id|MISC4
)paren
comma
id|DIONAME
c_func
(paren
id|MISC5
)paren
comma
id|DIONAME
c_func
(paren
id|MISC6
)paren
comma
id|DIONAME
c_func
(paren
id|MISC7
)paren
comma
id|DIONAME
c_func
(paren
id|MISC8
)paren
comma
id|DIONAME
c_func
(paren
id|MISC9
)paren
comma
id|DIONAME
c_func
(paren
id|MISC10
)paren
comma
id|DIONAME
c_func
(paren
id|MISC11
)paren
comma
id|DIONAME
c_func
(paren
id|MISC12
)paren
comma
id|DIONAME
c_func
(paren
id|MISC13
)paren
comma
id|DIOFBNAME
c_func
(paren
id|GATORBOX
)paren
comma
id|DIOFBNAME
c_func
(paren
id|TOPCAT
)paren
comma
id|DIOFBNAME
c_func
(paren
id|RENAISSANCE
)paren
comma
id|DIOFBNAME
c_func
(paren
id|LRCATSEYE
)paren
comma
id|DIOFBNAME
c_func
(paren
id|HRCCATSEYE
)paren
comma
id|DIOFBNAME
c_func
(paren
id|HRMCATSEYE
)paren
comma
id|DIOFBNAME
c_func
(paren
id|DAVINCI
)paren
comma
id|DIOFBNAME
c_func
(paren
id|XXXCATSEYE
)paren
comma
id|DIOFBNAME
c_func
(paren
id|HYPERION
)paren
comma
id|DIOFBNAME
c_func
(paren
id|XGENESIS
)paren
comma
id|DIOFBNAME
c_func
(paren
id|TIGER
)paren
comma
id|DIOFBNAME
c_func
(paren
id|YGENESIS
)paren
)brace
suffix:semicolon
DECL|macro|DIONAME
macro_line|#undef DIONAME
DECL|macro|DIOFBNAME
macro_line|#undef DIOFBNAME
DECL|macro|NUMNAMES
mdefine_line|#define NUMNAMES (sizeof(names) / sizeof(struct dioname))
DECL|variable|unknowndioname
r_static
r_const
r_char
op_star
id|unknowndioname
op_assign
l_string|&quot;unknown DIO board -- please email &lt;linux-m68k@lists.linux-m68k.org&gt;!&quot;
suffix:semicolon
DECL|function|dio_getname
r_static
r_const
r_char
op_star
id|dio_getname
c_func
(paren
r_int
id|id
)paren
(brace
multiline_comment|/* return pointer to a constant string describing the board with given ID */
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMNAMES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|names
(braket
id|i
)braket
dot
id|id
op_eq
id|id
)paren
r_return
id|names
(braket
id|i
)braket
dot
id|name
suffix:semicolon
r_return
id|unknowndioname
suffix:semicolon
)brace
macro_line|#else
DECL|variable|dio_no_name
r_static
r_char
id|dio_no_name
(braket
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|macro|dio_getname
mdefine_line|#define dio_getname(_id)&t;(dio_no_name)
macro_line|#endif /* CONFIG_DIO_CONSTANTS */
DECL|function|dio_find
r_int
id|__init
id|dio_find
c_func
(paren
r_int
id|deviceid
)paren
(brace
multiline_comment|/* Called to find a DIO device before the full bus scan has run.&n;&t; * Only used by the console driver.&n;&t; */
r_int
id|scode
comma
id|id
suffix:semicolon
id|u_char
id|prid
comma
id|secid
comma
id|i
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
r_for
c_loop
(paren
id|scode
op_assign
l_int|0
suffix:semicolon
id|scode
OL
id|DIO_SCMAX
suffix:semicolon
id|scode
op_increment
)paren
(brace
r_void
op_star
id|va
suffix:semicolon
r_int
r_int
id|pa
suffix:semicolon
r_if
c_cond
(paren
id|DIO_SCINHOLE
c_func
(paren
id|scode
)paren
)paren
r_continue
suffix:semicolon
id|pa
op_assign
id|dio_scodetophysaddr
c_func
(paren
id|scode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pa
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|scode
OL
id|DIOII_SCBASE
)paren
id|va
op_assign
(paren
r_void
op_star
)paren
(paren
id|pa
op_plus
id|DIO_VIRADDRBASE
)paren
suffix:semicolon
r_else
id|va
op_assign
id|ioremap
c_func
(paren
id|pa
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|i
comma
(paren
r_int
r_char
op_star
)paren
id|va
op_plus
id|DIO_IDOFF
)paren
)paren
(brace
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scode
op_ge
id|DIOII_SCBASE
)paren
id|iounmap
c_func
(paren
id|va
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* no board present at that select code */
)brace
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
id|prid
op_assign
id|DIO_ID
c_func
(paren
id|va
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DIO_NEEDSSECID
c_func
(paren
id|prid
)paren
)paren
(brace
id|secid
op_assign
id|DIO_SECID
c_func
(paren
id|va
)paren
suffix:semicolon
id|id
op_assign
id|DIO_ENCODE_ID
c_func
(paren
id|prid
comma
id|secid
)paren
suffix:semicolon
)brace
r_else
id|id
op_assign
id|prid
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
id|deviceid
)paren
(brace
r_if
c_cond
(paren
id|scode
op_ge
id|DIOII_SCBASE
)paren
id|iounmap
c_func
(paren
id|va
)paren
suffix:semicolon
r_return
id|scode
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This is the function that scans the DIO space and works out what&n; * hardware is actually present.&n; */
DECL|function|dio_init
r_static
r_int
id|__init
id|dio_init
c_func
(paren
r_void
)paren
(brace
r_int
id|scode
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|dio_dev
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_HP300
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Scanning for DIO devices...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize the DIO bus */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dio_bus.devices
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|dio_bus.dev.bus_id
comma
l_string|&quot;dio&quot;
)paren
suffix:semicolon
id|device_register
c_func
(paren
op_amp
id|dio_bus.dev
)paren
suffix:semicolon
multiline_comment|/* Request all resources */
id|dio_bus.num_resources
op_assign
(paren
id|hp300_model
op_eq
id|HP_320
ques
c_cond
l_int|1
suffix:colon
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dio_bus.num_resources
suffix:semicolon
id|i
op_increment
)paren
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
id|dio_bus.resources
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Register all devices */
r_for
c_loop
(paren
id|scode
op_assign
l_int|0
suffix:semicolon
id|scode
OL
id|DIO_SCMAX
suffix:semicolon
op_increment
id|scode
)paren
(brace
id|u_char
id|prid
comma
id|secid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* primary, secondary ID bytes */
id|u_char
op_star
id|va
suffix:semicolon
r_int
r_int
id|pa
suffix:semicolon
r_if
c_cond
(paren
id|DIO_SCINHOLE
c_func
(paren
id|scode
)paren
)paren
r_continue
suffix:semicolon
id|pa
op_assign
id|dio_scodetophysaddr
c_func
(paren
id|scode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pa
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|scode
OL
id|DIOII_SCBASE
)paren
id|va
op_assign
(paren
r_void
op_star
)paren
(paren
id|pa
op_plus
id|DIO_VIRADDRBASE
)paren
suffix:semicolon
r_else
id|va
op_assign
id|ioremap
c_func
(paren
id|pa
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|i
comma
(paren
r_int
r_char
op_star
)paren
id|va
op_plus
id|DIO_IDOFF
)paren
)paren
(brace
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scode
op_ge
id|DIOII_SCBASE
)paren
id|iounmap
c_func
(paren
id|va
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* no board present at that select code */
)brace
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
multiline_comment|/* Found a board, allocate it an entry in the list */
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dio_dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dio_dev
)paren
)paren
suffix:semicolon
id|dev-&gt;bus
op_assign
op_amp
id|dio_bus
suffix:semicolon
id|dev-&gt;dev.parent
op_assign
op_amp
id|dio_bus.dev
suffix:semicolon
id|dev-&gt;dev.bus
op_assign
op_amp
id|dio_bus_type
suffix:semicolon
id|dev-&gt;scode
op_assign
id|scode
suffix:semicolon
id|dev-&gt;resource.start
op_assign
id|pa
suffix:semicolon
id|dev-&gt;resource.end
op_assign
id|pa
op_plus
id|DIO_SIZE
c_func
(paren
id|scode
comma
id|va
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;dev.bus_id
comma
l_string|&quot;%02x&quot;
comma
id|scode
)paren
suffix:semicolon
multiline_comment|/* read the ID byte(s) and encode if necessary. */
id|prid
op_assign
id|DIO_ID
c_func
(paren
id|va
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DIO_NEEDSSECID
c_func
(paren
id|prid
)paren
)paren
(brace
id|secid
op_assign
id|DIO_SECID
c_func
(paren
id|va
)paren
suffix:semicolon
id|dev-&gt;id
op_assign
id|DIO_ENCODE_ID
c_func
(paren
id|prid
comma
id|secid
)paren
suffix:semicolon
)brace
r_else
id|dev-&gt;id
op_assign
id|prid
suffix:semicolon
id|dev-&gt;ipl
op_assign
id|DIO_IPL
c_func
(paren
id|va
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|dev-&gt;name
comma
id|dio_getname
c_func
(paren
id|dev-&gt;id
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;select code %3d: ipl %d: ID %02X&quot;
comma
id|dev-&gt;scode
comma
id|dev-&gt;ipl
comma
id|prid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DIO_NEEDSSECID
c_func
(paren
id|prid
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;:%02X&quot;
comma
id|secid
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;: %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scode
op_ge
id|DIOII_SCBASE
)paren
id|iounmap
c_func
(paren
id|va
)paren
suffix:semicolon
id|device_register
c_func
(paren
op_amp
id|dev-&gt;dev
)paren
suffix:semicolon
id|dio_create_sysfs_dev_files
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|dio_init
id|subsys_initcall
c_func
(paren
id|dio_init
)paren
suffix:semicolon
multiline_comment|/* Bear in mind that this is called in the very early stages of initialisation&n; * in order to get the address of the serial port for the console...&n; */
DECL|function|dio_scodetophysaddr
r_int
r_int
id|dio_scodetophysaddr
c_func
(paren
r_int
id|scode
)paren
(brace
r_if
c_cond
(paren
id|scode
op_ge
id|DIOII_SCBASE
)paren
(brace
r_return
(paren
id|DIOII_BASE
op_plus
(paren
id|scode
op_minus
l_int|132
)paren
op_star
id|DIOII_DEVSIZE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scode
OG
id|DIO_SCMAX
op_logical_or
id|scode
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|DIO_SCINHOLE
c_func
(paren
id|scode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|DIO_BASE
op_plus
id|scode
op_star
id|DIO_DEVSIZE
)paren
suffix:semicolon
)brace
eof
