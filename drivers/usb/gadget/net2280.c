multiline_comment|/*&n; * Driver for the NetChip 2280 USB device controller.&n; * Specs and errata are available from &lt;http://www.netchip.com&gt;.&n; *&n; * NetChip Technology Inc. supported the development of this driver.&n; *&n; *&n; * CODE STATUS HIGHLIGHTS&n; *&n; * Used with a gadget driver like &quot;zero.c&quot; this enumerates fine to Windows&n; * or Linux hosts; handles disconnect, reconnect, and reset, for full or&n; * high speed operation; and passes USB-IF &quot;chapter 9&quot; tests.&n; *&n; * Handles standard stress loads from the Linux &quot;usbtest&quot; driver, with&n; * either DMA (default) or PIO (use_dma=n) used for ep-{a,b,c,d}.  Testing&n; * with &quot;ttcp&quot; (and the &quot;ether.c&quot; driver) behaves nicely too.&n; *&n; * DMA is enabled by default.  Drivers using transfer queues might use&n; * DMA chaining to remove IRQ latencies between transfers.  (Except when&n; * short OUT transfers happen.)  Drivers can use the req-&gt;no_interrupt&n; * hint to completely eliminate some IRQs, if a later IRQ is guaranteed&n; * and DMA chaining is enabled.&n; */
singleline_comment|// #define NET2280_DMA_OUT_WORKAROUND
singleline_comment|// #define USE_DMA_CHAINING
multiline_comment|/*&n; * Copyright (C) 2003 David Brownell&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
DECL|macro|DEBUG
mdefine_line|#define DEBUG&t;1
singleline_comment|// #define&t;VERBOSE&t;&t;/* extra debug messages (success too) */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/usb_ch9.h&gt;
macro_line|#include &lt;linux/usb_gadget.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
DECL|macro|DRIVER_DESC
mdefine_line|#define&t;DRIVER_DESC&t;&t;&quot;NetChip 2280 USB Peripheral Controller&quot;
DECL|macro|DRIVER_VERSION
mdefine_line|#define&t;DRIVER_VERSION&t;&t;&quot;May Day 2003&quot;
DECL|macro|DMA_ADDR_INVALID
mdefine_line|#define&t;DMA_ADDR_INVALID&t;(~(dma_addr_t)0)
DECL|macro|EP_DONTUSE
mdefine_line|#define&t;EP_DONTUSE&t;&t;13&t;/* nonzero */
DECL|macro|USE_RDK_LEDS
mdefine_line|#define USE_RDK_LEDS&t;&t;/* GPIO pins control three LEDs */
DECL|macro|USE_SYSFS_DEBUG_FILES
mdefine_line|#define USE_SYSFS_DEBUG_FILES
DECL|variable|driver_name
r_static
r_const
r_char
id|driver_name
(braket
)braket
op_assign
l_string|&quot;net2280&quot;
suffix:semicolon
DECL|variable|driver_desc
r_static
r_const
r_char
id|driver_desc
(braket
)braket
op_assign
id|DRIVER_DESC
suffix:semicolon
DECL|variable|ep0name
r_static
r_const
r_char
id|ep0name
(braket
)braket
op_assign
l_string|&quot;ep0&quot;
suffix:semicolon
DECL|variable|ep_name
r_static
r_const
r_char
op_star
id|ep_name
(braket
)braket
op_assign
(brace
id|ep0name
comma
l_string|&quot;ep-a&quot;
comma
l_string|&quot;ep-b&quot;
comma
l_string|&quot;ep-c&quot;
comma
l_string|&quot;ep-d&quot;
comma
l_string|&quot;ep-e&quot;
comma
l_string|&quot;ep-f&quot;
comma
)brace
suffix:semicolon
DECL|variable|use_dma
r_static
r_int
id|use_dma
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &quot;modprobe net2280 use_dma=n&quot; etc */
id|module_param
(paren
id|use_dma
comma
r_bool
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
multiline_comment|/* mode 0 == ep-{a,b,c,d} 1K fifo each&n; * mode 1 == ep-{a,b} 2K fifo each, ep-{c,d} unavailable&n; * mode 2 == ep-a 2K fifo, ep-{b,c} 1K each, ep-d unavailable&n; */
DECL|variable|fifo_mode
r_static
id|ushort
id|fifo_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &quot;modprobe net2280 fifo_mode=1&quot; etc */
id|module_param
(paren
id|fifo_mode
comma
id|ushort
comma
l_int|0644
)paren
suffix:semicolon
DECL|macro|DIR_STRING
mdefine_line|#define&t;DIR_STRING(bAddress) (((bAddress) &amp; USB_DIR_IN) ? &quot;in&quot; : &quot;out&quot;)
macro_line|#if defined(USE_SYSFS_DEBUG_FILES) || defined (DEBUG)
DECL|function|type_string
r_static
r_char
op_star
id|type_string
(paren
id|u8
id|bmAttributes
)paren
(brace
r_switch
c_cond
(paren
(paren
id|bmAttributes
)paren
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
(brace
r_case
id|USB_ENDPOINT_XFER_BULK
suffix:colon
r_return
l_string|&quot;bulk&quot;
suffix:semicolon
r_case
id|USB_ENDPOINT_XFER_ISOC
suffix:colon
r_return
l_string|&quot;iso&quot;
suffix:semicolon
r_case
id|USB_ENDPOINT_XFER_INT
suffix:colon
r_return
l_string|&quot;intr&quot;
suffix:semicolon
)brace
suffix:semicolon
r_return
l_string|&quot;control&quot;
suffix:semicolon
)brace
macro_line|#endif
macro_line|#include &quot;net2280.h&quot;
DECL|macro|valid_bit
mdefine_line|#define valid_bit&t;__constant_cpu_to_le32 (1 &lt;&lt; VALID_BIT)
DECL|macro|dma_done_ie
mdefine_line|#define dma_done_ie&t;__constant_cpu_to_le32 (1 &lt;&lt; DMA_DONE_INTERRUPT_ENABLE)
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_int
DECL|function|net2280_enable
id|net2280_enable
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|desc
)paren
(brace
r_struct
id|net2280
op_star
id|dev
suffix:semicolon
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
id|u32
id|max
comma
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ep
op_assign
id|container_of
(paren
id|_ep
comma
r_struct
id|net2280_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
op_logical_neg
id|desc
op_logical_or
id|ep-&gt;desc
op_logical_or
id|_ep-&gt;name
op_eq
id|ep0name
op_logical_or
id|desc-&gt;bDescriptorType
op_ne
id|USB_DT_ENDPOINT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dev
op_assign
id|ep-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;driver
op_logical_or
id|dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
r_return
op_minus
id|ESHUTDOWN
suffix:semicolon
multiline_comment|/* erratum 0119 workaround ties up an endpoint number */
r_if
c_cond
(paren
(paren
id|desc-&gt;bEndpointAddress
op_amp
l_int|0x0f
)paren
op_eq
id|EP_DONTUSE
)paren
r_return
op_minus
id|EDOM
suffix:semicolon
multiline_comment|/* sanity check ep-e/ep-f since their fifos are small */
id|max
op_assign
id|le16_to_cpu
(paren
id|desc-&gt;wMaxPacketSize
)paren
op_amp
l_int|0x1fff
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;num
OG
l_int|4
op_logical_and
id|max
OG
l_int|64
)paren
r_return
op_minus
id|ERANGE
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|_ep-&gt;maxpacket
op_assign
id|max
op_amp
l_int|0x7ff
suffix:semicolon
id|ep-&gt;desc
op_assign
id|desc
suffix:semicolon
multiline_comment|/* ep_reset() has already been called */
id|ep-&gt;stopped
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set speed-dependent max packet; may kick in high bandwidth */
id|set_idx_reg
(paren
id|dev-&gt;regs
comma
id|REG_EP_MAXPKT
(paren
id|dev
comma
id|ep-&gt;num
)paren
comma
id|max
)paren
suffix:semicolon
multiline_comment|/* FIFO lines can&squot;t go to different packets.  PIO is ok, so&n;&t; * use it instead of troublesome (non-bulk) multi-packet DMA.&n;&t; */
r_if
c_cond
(paren
id|ep-&gt;is_in
op_logical_and
id|ep-&gt;dma
op_logical_and
(paren
id|max
op_mod
l_int|4
)paren
op_ne
l_int|0
)paren
(brace
id|DEBUG
(paren
id|ep-&gt;dev
comma
l_string|&quot;%s, no IN dma for maxpacket %d&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|ep-&gt;ep.maxpacket
)paren
suffix:semicolon
id|ep-&gt;dma
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set type, direction, address; reset fifo counters */
id|writel
(paren
(paren
l_int|1
op_lshift
id|FIFO_FLUSH
)paren
comma
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|desc-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
id|USB_ENDPOINT_XFER_INT
)paren
(brace
multiline_comment|/* not just because of erratum 0105; avoid ever&n;&t;&t; * kicking in the &quot;toggle-irrelevant&quot; mode.&n;&t;&t; */
id|tmp
op_assign
id|USB_ENDPOINT_XFER_BULK
suffix:semicolon
)brace
id|ep-&gt;is_iso
op_assign
(paren
id|tmp
op_eq
id|USB_ENDPOINT_XFER_ISOC
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|tmp
op_lshift_assign
id|ENDPOINT_TYPE
suffix:semicolon
id|tmp
op_or_assign
id|desc-&gt;bEndpointAddress
suffix:semicolon
id|tmp
op_or_assign
(paren
l_int|4
op_lshift
id|ENDPOINT_BYTE_COUNT
)paren
suffix:semicolon
multiline_comment|/* default full fifo lines */
id|tmp
op_or_assign
l_int|1
op_lshift
id|ENDPOINT_ENABLE
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
multiline_comment|/* for OUT transfers, block the rx fifo until a read is posted */
id|ep-&gt;is_in
op_assign
(paren
id|tmp
op_amp
id|USB_DIR_IN
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;is_in
)paren
id|writel
(paren
(paren
l_int|1
op_lshift
id|SET_NAK_OUT_PACKETS
)paren
comma
op_amp
id|ep-&gt;regs-&gt;ep_rsp
)paren
suffix:semicolon
id|writel
(paren
id|tmp
comma
op_amp
id|ep-&gt;regs-&gt;ep_cfg
)paren
suffix:semicolon
macro_line|#ifdef NET2280_DMA_OUT_WORKAROUND
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;is_in
)paren
id|ep-&gt;dma
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* enable irqs */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;dma
)paren
(brace
multiline_comment|/* pio, per-packet */
id|tmp
op_assign
(paren
l_int|1
op_lshift
id|ep-&gt;num
)paren
op_or
id|readl
(paren
op_amp
id|dev-&gt;regs-&gt;pciirqenb0
)paren
suffix:semicolon
id|writel
(paren
id|tmp
comma
op_amp
id|dev-&gt;regs-&gt;pciirqenb0
)paren
suffix:semicolon
id|tmp
op_assign
(paren
l_int|1
op_lshift
id|DATA_PACKET_RECEIVED_INTERRUPT_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE
)paren
op_or
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_irqenb
)paren
suffix:semicolon
id|writel
(paren
id|tmp
comma
op_amp
id|ep-&gt;regs-&gt;ep_irqenb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* dma, per-request */
id|tmp
op_assign
(paren
l_int|1
op_lshift
(paren
l_int|8
op_plus
id|ep-&gt;num
)paren
)paren
suffix:semicolon
multiline_comment|/* completion */
id|tmp
op_or_assign
id|readl
(paren
op_amp
id|dev-&gt;regs-&gt;pciirqenb1
)paren
suffix:semicolon
id|writel
(paren
id|tmp
comma
op_amp
id|dev-&gt;regs-&gt;pciirqenb1
)paren
suffix:semicolon
multiline_comment|/* for short OUT transfers, dma completions can&squot;t&n;&t;&t; * advance the queue; do it pio-style, by hand.&n;&t;&t; * NOTE erratum 0112 workaround #2&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|desc-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
op_eq
l_int|0
)paren
(brace
id|tmp
op_assign
(paren
l_int|1
op_lshift
id|SHORT_PACKET_TRANSFERRED_INTERRUPT_ENABLE
)paren
suffix:semicolon
id|writel
(paren
id|tmp
comma
op_amp
id|ep-&gt;regs-&gt;ep_irqenb
)paren
suffix:semicolon
id|tmp
op_assign
(paren
l_int|1
op_lshift
id|ep-&gt;num
)paren
op_or
id|readl
(paren
op_amp
id|dev-&gt;regs-&gt;pciirqenb0
)paren
suffix:semicolon
id|writel
(paren
id|tmp
comma
op_amp
id|dev-&gt;regs-&gt;pciirqenb0
)paren
suffix:semicolon
)brace
)brace
id|tmp
op_assign
id|desc-&gt;bEndpointAddress
suffix:semicolon
id|DEBUG
(paren
id|dev
comma
l_string|&quot;enabled %s (ep%d%s-%s) %s max %04x&bslash;n&quot;
comma
id|_ep-&gt;name
comma
id|tmp
op_amp
l_int|0x0f
comma
id|DIR_STRING
(paren
id|tmp
)paren
comma
id|type_string
(paren
id|desc-&gt;bmAttributes
)paren
comma
id|ep-&gt;dma
ques
c_cond
l_string|&quot;dma&quot;
suffix:colon
l_string|&quot;pio&quot;
comma
id|max
)paren
suffix:semicolon
multiline_comment|/* pci writes may still be posted */
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handshake
r_static
r_int
id|handshake
(paren
id|u32
op_star
id|ptr
comma
id|u32
id|mask
comma
id|u32
id|done
comma
r_int
id|usec
)paren
(brace
id|u32
id|result
suffix:semicolon
r_do
(brace
id|result
op_assign
id|readl
(paren
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_complement
(paren
id|u32
)paren
l_int|0
)paren
multiline_comment|/* &quot;device unplugged&quot; */
r_return
op_minus
id|ENODEV
suffix:semicolon
id|result
op_and_assign
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|done
)paren
r_return
l_int|0
suffix:semicolon
id|udelay
(paren
l_int|1
)paren
suffix:semicolon
id|usec
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|usec
OG
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|done
op_eq
l_int|0
)paren
id|dump_stack
(paren
)paren
suffix:semicolon
multiline_comment|/* ignore out_flush timeout */
macro_line|#endif
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
DECL|variable|net2280_ep_ops
r_static
r_struct
id|usb_ep_ops
id|net2280_ep_ops
suffix:semicolon
DECL|function|ep_reset
r_static
r_void
id|ep_reset
(paren
r_struct
id|net2280_regs
op_star
id|regs
comma
r_struct
id|net2280_ep
op_star
id|ep
)paren
(brace
id|u32
id|tmp
suffix:semicolon
id|ep-&gt;desc
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|ep-&gt;queue
)paren
suffix:semicolon
id|ep-&gt;ep.maxpacket
op_assign
op_complement
l_int|0
suffix:semicolon
id|ep-&gt;ep.ops
op_assign
op_amp
id|net2280_ep_ops
suffix:semicolon
multiline_comment|/* disable the dma, irqs, endpoint... */
r_if
c_cond
(paren
id|ep-&gt;dma
)paren
(brace
id|writel
(paren
l_int|0
comma
op_amp
id|ep-&gt;dma-&gt;dmactl
)paren
suffix:semicolon
id|writel
(paren
(paren
l_int|1
op_lshift
id|DMA_SCATTER_GATHER_DONE_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DMA_TRANSACTION_DONE_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DMA_ABORT
)paren
comma
op_amp
id|ep-&gt;dma-&gt;dmastat
)paren
suffix:semicolon
id|tmp
op_assign
id|readl
(paren
op_amp
id|regs-&gt;pciirqenb0
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|ep-&gt;num
)paren
suffix:semicolon
id|writel
(paren
id|tmp
comma
op_amp
id|regs-&gt;pciirqenb0
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_assign
id|readl
(paren
op_amp
id|regs-&gt;pciirqenb1
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
(paren
l_int|1
op_lshift
(paren
l_int|8
op_plus
id|ep-&gt;num
)paren
)paren
suffix:semicolon
multiline_comment|/* completion */
id|writel
(paren
id|tmp
comma
op_amp
id|regs-&gt;pciirqenb1
)paren
suffix:semicolon
)brace
id|writel
(paren
l_int|0
comma
op_amp
id|ep-&gt;regs-&gt;ep_irqenb
)paren
suffix:semicolon
multiline_comment|/* init to our chosen defaults, notably so that we NAK OUT&n;&t; * packets until the driver queues a read (+note erratum 0112)&n;&t; */
id|writel
(paren
(paren
l_int|1
op_lshift
id|SET_NAK_OUT_PACKETS_MODE
)paren
op_or
(paren
l_int|1
op_lshift
id|SET_NAK_OUT_PACKETS
)paren
op_or
(paren
l_int|1
op_lshift
id|CLEAR_EP_HIDE_STATUS_PHASE
)paren
op_or
(paren
l_int|1
op_lshift
id|CLEAR_INTERRUPT_MODE
)paren
op_or
(paren
l_int|1
op_lshift
id|CLEAR_CONTROL_STATUS_PHASE_HANDSHAKE
)paren
op_or
(paren
l_int|1
op_lshift
id|CLEAR_ENDPOINT_TOGGLE
)paren
op_or
(paren
l_int|1
op_lshift
id|CLEAR_ENDPOINT_HALT
)paren
comma
op_amp
id|ep-&gt;regs-&gt;ep_rsp
)paren
suffix:semicolon
multiline_comment|/* scrub most status bits, and flush any fifo state */
id|writel
(paren
(paren
l_int|1
op_lshift
id|TIMEOUT
)paren
op_or
(paren
l_int|1
op_lshift
id|USB_STALL_SENT
)paren
op_or
(paren
l_int|1
op_lshift
id|USB_IN_NAK_SENT
)paren
op_or
(paren
l_int|1
op_lshift
id|USB_IN_ACK_RCVD
)paren
op_or
(paren
l_int|1
op_lshift
id|USB_OUT_PING_NAK_SENT
)paren
op_or
(paren
l_int|1
op_lshift
id|USB_OUT_ACK_SENT
)paren
op_or
(paren
l_int|1
op_lshift
id|FIFO_OVERFLOW
)paren
op_or
(paren
l_int|1
op_lshift
id|FIFO_UNDERFLOW
)paren
op_or
(paren
l_int|1
op_lshift
id|FIFO_FLUSH
)paren
op_or
(paren
l_int|1
op_lshift
id|SHORT_PACKET_OUT_DONE_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|SHORT_PACKET_TRANSFERRED_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_PACKET_RECEIVED_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_PACKET_TRANSMITTED_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_OUT_PING_TOKEN_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_IN_TOKEN_INTERRUPT
)paren
comma
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
suffix:semicolon
multiline_comment|/* fifo size is handled separately */
)brace
r_static
r_void
id|nuke
(paren
r_struct
id|net2280_ep
op_star
)paren
suffix:semicolon
DECL|function|net2280_disable
r_static
r_int
id|net2280_disable
(paren
r_struct
id|usb_ep
op_star
id|_ep
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ep
op_assign
id|container_of
(paren
id|_ep
comma
r_struct
id|net2280_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
op_logical_neg
id|ep-&gt;desc
op_logical_or
id|_ep-&gt;name
op_eq
id|ep0name
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ep-&gt;dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|nuke
(paren
id|ep
)paren
suffix:semicolon
id|ep_reset
(paren
id|ep-&gt;dev-&gt;regs
comma
id|ep
)paren
suffix:semicolon
id|VDEBUG
(paren
id|ep-&gt;dev
comma
l_string|&quot;disabled %s %s&bslash;n&quot;
comma
id|ep-&gt;dma
ques
c_cond
l_string|&quot;dma&quot;
suffix:colon
l_string|&quot;pio&quot;
comma
id|_ep-&gt;name
)paren
suffix:semicolon
multiline_comment|/* synch memory views with the device */
(paren
r_void
)paren
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_cfg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_dma
op_logical_and
op_logical_neg
id|ep-&gt;dma
op_logical_and
id|ep-&gt;num
op_ge
l_int|1
op_logical_and
id|ep-&gt;num
op_le
l_int|4
)paren
id|ep-&gt;dma
op_assign
op_amp
id|ep-&gt;dev-&gt;dma
(braket
id|ep-&gt;num
op_minus
l_int|1
)braket
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ep-&gt;dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_struct
id|usb_request
op_star
DECL|function|net2280_alloc_request
id|net2280_alloc_request
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_int
id|gfp_flags
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
r_struct
id|net2280_request
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
)paren
r_return
l_int|0
suffix:semicolon
id|ep
op_assign
id|container_of
(paren
id|_ep
comma
r_struct
id|net2280_ep
comma
id|ep
)paren
suffix:semicolon
id|req
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|req
comma
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_return
l_int|0
suffix:semicolon
id|memset
(paren
id|req
comma
l_int|0
comma
r_sizeof
op_star
id|req
)paren
suffix:semicolon
id|req-&gt;req.dma
op_assign
id|DMA_ADDR_INVALID
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|req-&gt;queue
)paren
suffix:semicolon
multiline_comment|/* this dma descriptor may be swapped with the previous dummy */
r_if
c_cond
(paren
id|ep-&gt;dma
)paren
(brace
r_struct
id|net2280_dma
op_star
id|td
suffix:semicolon
id|td
op_assign
id|pci_pool_alloc
(paren
id|ep-&gt;dev-&gt;requests
comma
id|gfp_flags
comma
op_amp
id|req-&gt;td_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
(brace
id|kfree
(paren
id|req
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|td-&gt;dmacount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not VALID */
id|td-&gt;dmaaddr
op_assign
id|__constant_cpu_to_le32
(paren
id|DMA_ADDR_INVALID
)paren
suffix:semicolon
id|req-&gt;td
op_assign
id|td
suffix:semicolon
)brace
r_return
op_amp
id|req-&gt;req
suffix:semicolon
)brace
r_static
r_void
DECL|function|net2280_free_request
id|net2280_free_request
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_struct
id|usb_request
op_star
id|_req
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
r_struct
id|net2280_request
op_star
id|req
suffix:semicolon
id|ep
op_assign
id|container_of
(paren
id|_ep
comma
r_struct
id|net2280_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
op_logical_neg
id|_req
)paren
r_return
suffix:semicolon
id|req
op_assign
id|container_of
(paren
id|_req
comma
r_struct
id|net2280_request
comma
id|req
)paren
suffix:semicolon
id|WARN_ON
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|req-&gt;queue
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;td
)paren
id|pci_pool_free
(paren
id|ep-&gt;dev-&gt;requests
comma
id|req-&gt;td
comma
id|req-&gt;td_dma
)paren
suffix:semicolon
id|kfree
(paren
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|USE_KMALLOC
macro_line|#undef USE_KMALLOC
multiline_comment|/* many common platforms have dma-coherent caches, which means that it&squot;s&n; * safe to use kmalloc() memory for all i/o buffers without using any&n; * cache flushing calls.  (unless you&squot;re trying to share cache lines&n; * between dma and non-dma activities, which is a slow idea in any case.)&n; *&n; * other platforms need more care, with 2.5 having a moderately general&n; * solution (which falls down for allocations smaller than one page)&n; * that improves significantly on the 2.4 PCI allocators by removing&n; * the restriction that memory never be freed in_interrupt().&n; */
macro_line|#if&t;defined(CONFIG_X86)
DECL|macro|USE_KMALLOC
mdefine_line|#define USE_KMALLOC
macro_line|#elif&t;defined(CONFIG_PPC) &amp;&amp; !defined(CONFIG_NOT_COHERENT_CACHE)
DECL|macro|USE_KMALLOC
mdefine_line|#define USE_KMALLOC
multiline_comment|/* FIXME there are other cases, including an x86-64 one ...  */
macro_line|#endif
multiline_comment|/* allocating buffers this way eliminates dma mapping overhead, which&n; * on some platforms will mean eliminating a per-io buffer copy.  with&n; * some kinds of system caches, further tweaks may still be needed.&n; */
r_static
r_void
op_star
DECL|function|net2280_alloc_buffer
id|net2280_alloc_buffer
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_int
id|bytes
comma
id|dma_addr_t
op_star
id|dma
comma
r_int
id|gfp_flags
)paren
(brace
r_void
op_star
id|retval
suffix:semicolon
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
id|ep
op_assign
id|container_of
(paren
id|_ep
comma
r_struct
id|net2280_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
(paren
op_logical_neg
id|ep-&gt;desc
op_logical_and
id|ep-&gt;num
op_ne
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|dma
op_assign
id|DMA_ADDR_INVALID
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;dma
)paren
(brace
macro_line|#if&t;defined(USE_KMALLOC)
id|retval
op_assign
id|kmalloc
(paren
id|bytes
comma
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
op_star
id|dma
op_assign
id|virt_to_phys
(paren
id|retval
)paren
suffix:semicolon
macro_line|#elif&t;LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,58)
macro_line|#warning Using dma_alloc_consistent even with sub-page allocations
multiline_comment|/* the main problem with this call is that it wastes memory&n;&t;&t; * on typical 1/N page allocations: it allocates 1-N pages.&n;&t;&t; */
id|retval
op_assign
id|dma_alloc_coherent
(paren
op_amp
id|ep-&gt;dev-&gt;pdev-&gt;dev
comma
id|bytes
comma
id|dma
comma
id|gfp_flags
)paren
suffix:semicolon
macro_line|#else
macro_line|#error No dma-coherent memory allocator is available
multiline_comment|/* pci_alloc_consistent works, but pci_free_consistent()&n;&t;&t; * isn&squot;t safe in_interrupt().  plus, in addition to the&n;&t;&t; * 1/Nth page weakness, it doesn&squot;t understand gfp_flags.&n;&t;&t; */
macro_line|#endif
)brace
r_else
id|retval
op_assign
id|kmalloc
(paren
id|bytes
comma
id|gfp_flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_void
DECL|function|net2280_free_buffer
id|net2280_free_buffer
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_void
op_star
id|buf
comma
id|dma_addr_t
id|dma
comma
r_int
id|bytes
)paren
(brace
multiline_comment|/* free memory into the right allocator */
macro_line|#ifndef&t;USE_KMALLOC
r_if
c_cond
(paren
id|dma
op_ne
id|DMA_ADDR_INVALID
)paren
id|dma_free_coherent
(paren
id|ep-&gt;dev-&gt;pdev
comma
id|bytes
comma
id|dma
)paren
suffix:semicolon
r_else
macro_line|#endif
id|kfree
(paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* load a packet into the fifo we use for usb IN transfers.&n; * works for all endpoints.&n; *&n; * NOTE: pio with ep-a..ep-d could stuff multiple packets into the fifo&n; * at a time, but this code is simpler because it knows it only writes&n; * one packet.  ep-a..ep-d should use dma instead.&n; */
r_static
r_void
DECL|function|write_fifo
id|write_fifo
(paren
r_struct
id|net2280_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|net2280_ep_regs
op_star
id|regs
op_assign
id|ep-&gt;regs
suffix:semicolon
id|u8
op_star
id|buf
suffix:semicolon
id|u32
id|tmp
suffix:semicolon
r_int
id|count
comma
id|total
suffix:semicolon
multiline_comment|/* INVARIANT:  fifo is currently empty. (testable) */
r_if
c_cond
(paren
id|req
)paren
(brace
id|total
op_assign
id|req-&gt;length
op_minus
id|req-&gt;actual
suffix:semicolon
id|buf
op_assign
id|req-&gt;buf
op_plus
id|req-&gt;actual
suffix:semicolon
)brace
r_else
(brace
id|total
op_assign
l_int|0
suffix:semicolon
id|buf
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* write just one packet at a time */
id|count
op_assign
id|min
(paren
id|ep-&gt;ep.maxpacket
comma
id|total
)paren
suffix:semicolon
id|VDEBUG
(paren
id|ep-&gt;dev
comma
l_string|&quot;write %s fifo (IN) %d bytes%s req %p&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|count
comma
(paren
id|count
op_ne
id|ep-&gt;ep.maxpacket
)paren
ques
c_cond
l_string|&quot; (short)&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|req
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
op_ge
l_int|4
)paren
(brace
multiline_comment|/* NOTE be careful if you try to align these. fifo lines&n;&t;&t; * should normally be full (4 bytes) and successive partial&n;&t;&t; * lines are ok only in certain cases.&n;&t;&t; */
id|tmp
op_assign
id|get_unaligned
(paren
(paren
id|u32
op_star
)paren
id|buf
)paren
suffix:semicolon
id|cpu_to_le32s
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|writel
(paren
id|tmp
comma
op_amp
id|regs-&gt;ep_data
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|4
suffix:semicolon
id|count
op_sub_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* last fifo entry is &quot;short&quot; unless we wrote a full packet */
r_if
c_cond
(paren
id|total
OL
id|ep-&gt;ep.maxpacket
)paren
(brace
id|tmp
op_assign
id|count
ques
c_cond
id|get_unaligned
(paren
(paren
id|u32
op_star
)paren
id|buf
)paren
suffix:colon
id|count
suffix:semicolon
id|cpu_to_le32s
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|set_fifo_bytecount
(paren
id|ep
comma
id|count
op_amp
l_int|0x03
)paren
suffix:semicolon
id|writel
(paren
id|tmp
comma
op_amp
id|regs-&gt;ep_data
)paren
suffix:semicolon
)brace
multiline_comment|/* pci writes may still be posted */
)brace
multiline_comment|/* work around erratum 0106: PCI and USB race over the OUT fifo.&n; * caller guarantees chiprev 0100, out endpoint is NAKing, and&n; * there&squot;s no real data in the fifo.&n; */
DECL|function|out_flush
r_static
r_void
id|out_flush
(paren
r_struct
id|net2280_ep
op_star
id|ep
)paren
(brace
id|u32
op_star
id|statp
comma
id|tmp
suffix:semicolon
id|ASSERT_OUT_NAKING
(paren
id|ep
)paren
suffix:semicolon
id|statp
op_assign
op_amp
id|ep-&gt;regs-&gt;ep_stat
suffix:semicolon
id|writel
(paren
(paren
l_int|1
op_lshift
id|DATA_OUT_PING_TOKEN_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_PACKET_RECEIVED_INTERRUPT
)paren
comma
id|statp
)paren
suffix:semicolon
id|writel
(paren
(paren
l_int|1
op_lshift
id|FIFO_FLUSH
)paren
comma
id|statp
)paren
suffix:semicolon
id|mb
(paren
)paren
suffix:semicolon
id|tmp
op_assign
id|readl
(paren
id|statp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
(paren
l_int|1
op_lshift
id|DATA_OUT_PING_TOKEN_INTERRUPT
)paren
multiline_comment|/* high speed did bulk NYET; fifo isn&squot;t filling */
op_logical_and
id|ep-&gt;dev-&gt;gadget.speed
op_eq
id|USB_SPEED_FULL
)paren
(brace
r_int
id|usec
suffix:semicolon
id|usec
op_assign
l_int|50
suffix:semicolon
multiline_comment|/* 64 byte bulk/interrupt */
id|handshake
(paren
id|statp
comma
(paren
l_int|1
op_lshift
id|USB_OUT_PING_NAK_SENT
)paren
comma
(paren
l_int|1
op_lshift
id|USB_OUT_PING_NAK_SENT
)paren
comma
id|usec
)paren
suffix:semicolon
multiline_comment|/* NAK done; now CLEAR_NAK_OUT_PACKETS is safe */
)brace
)brace
multiline_comment|/* unload packet(s) from the fifo we use for usb OUT transfers.&n; * returns true iff the request completed, because of short packet&n; * or the request buffer having filled with full packets.&n; *&n; * for ep-a..ep-d this will read multiple packets out when they&n; * have been accepted.&n; */
r_static
r_int
DECL|function|read_fifo
id|read_fifo
(paren
r_struct
id|net2280_ep
op_star
id|ep
comma
r_struct
id|net2280_request
op_star
id|req
)paren
(brace
r_struct
id|net2280_ep_regs
op_star
id|regs
op_assign
id|ep-&gt;regs
suffix:semicolon
id|u8
op_star
id|buf
op_assign
id|req-&gt;req.buf
op_plus
id|req-&gt;req.actual
suffix:semicolon
r_int
id|count
comma
id|tmp
comma
id|is_short
suffix:semicolon
r_int
id|cleanup
op_assign
l_int|0
comma
id|prevent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* erratum 0106 ... packets coming in during fifo reads might&n;&t; * be incompletely rejected.  not all cases have workarounds.&n;&t; */
r_if
c_cond
(paren
id|ep-&gt;dev-&gt;chiprev
op_eq
l_int|0x0100
)paren
(brace
id|tmp
op_assign
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
(paren
l_int|1
op_lshift
id|NAK_OUT_PACKETS
)paren
)paren
)paren
multiline_comment|/* cleanup = 1 */
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|tmp
op_amp
(paren
l_int|1
op_lshift
id|FIFO_FULL
)paren
)paren
multiline_comment|/* don&squot;t break hs PING protocol ... */
op_logical_or
id|ep-&gt;dev-&gt;gadget.speed
op_eq
id|USB_SPEED_FULL
)paren
(brace
id|start_out_naking
(paren
id|ep
)paren
suffix:semicolon
id|prevent
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* else: hope we don&squot;t see the problem */
)brace
multiline_comment|/* never overflow the rx buffer. the fifo reads packets until&n;&t; * it sees a short one; we might not be ready for them all.&n;&t; */
id|count
op_assign
id|readl
(paren
op_amp
id|regs-&gt;ep_avail
)paren
suffix:semicolon
id|tmp
op_assign
id|req-&gt;req.length
op_minus
id|req-&gt;req.actual
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|tmp
)paren
(brace
multiline_comment|/* as with DMA, data overflow gets flushed */
r_if
c_cond
(paren
(paren
id|tmp
op_mod
id|ep-&gt;ep.maxpacket
)paren
op_ne
l_int|0
)paren
(brace
id|ERROR
(paren
id|ep-&gt;dev
comma
l_string|&quot;%s out fifo %d bytes, expected %d&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|count
comma
id|tmp
)paren
suffix:semicolon
id|req-&gt;req.status
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
id|cleanup
op_assign
l_int|1
suffix:semicolon
)brace
id|count
op_assign
id|tmp
suffix:semicolon
)brace
id|req-&gt;req.actual
op_add_assign
id|count
suffix:semicolon
id|is_short
op_assign
(paren
id|count
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|count
op_mod
id|ep-&gt;ep.maxpacket
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|VDEBUG
(paren
id|ep-&gt;dev
comma
l_string|&quot;read %s fifo (OUT) %d bytes%s%s%s req %p %d/%d&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|count
comma
id|is_short
ques
c_cond
l_string|&quot; (short)&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|cleanup
ques
c_cond
l_string|&quot; flush&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|prevent
ques
c_cond
l_string|&quot; nak&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|req
comma
id|req-&gt;req.actual
comma
id|req-&gt;req.length
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
op_ge
l_int|4
)paren
(brace
id|tmp
op_assign
id|readl
(paren
op_amp
id|regs-&gt;ep_data
)paren
suffix:semicolon
id|cpu_to_le32s
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|put_unaligned
(paren
id|tmp
comma
(paren
id|u32
op_star
)paren
id|buf
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|4
suffix:semicolon
id|count
op_sub_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
id|tmp
op_assign
id|readl
(paren
op_amp
id|regs-&gt;ep_data
)paren
suffix:semicolon
id|cpu_to_le32s
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_do
(brace
op_star
id|buf
op_increment
op_assign
(paren
id|u8
)paren
id|tmp
suffix:semicolon
id|tmp
op_rshift_assign
l_int|8
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cleanup
)paren
id|out_flush
(paren
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prevent
)paren
(brace
id|writel
(paren
(paren
l_int|1
op_lshift
id|CLEAR_NAK_OUT_PACKETS
)paren
comma
op_amp
id|ep-&gt;regs-&gt;ep_rsp
)paren
suffix:semicolon
(paren
r_void
)paren
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_rsp
)paren
suffix:semicolon
)brace
r_return
id|is_short
op_logical_or
(paren
(paren
id|req-&gt;req.actual
op_eq
id|req-&gt;req.length
)paren
op_logical_and
op_logical_neg
id|req-&gt;req.zero
)paren
suffix:semicolon
)brace
multiline_comment|/* fill out dma descriptor to match a given request */
r_static
r_inline
r_void
DECL|function|fill_dma_desc
id|fill_dma_desc
(paren
r_struct
id|net2280_ep
op_star
id|ep
comma
r_struct
id|net2280_request
op_star
id|req
comma
r_int
id|valid
)paren
(brace
r_struct
id|net2280_dma
op_star
id|td
op_assign
id|req-&gt;td
suffix:semicolon
id|u32
id|dmacount
op_assign
id|req-&gt;req.length
suffix:semicolon
multiline_comment|/* don&squot;t let DMA continue after a short OUT packet,&n;&t; * so overruns can&squot;t affect the next transfer.&n;&t; * in case of overruns on max-size packets, we can&squot;t&n;&t; * stop the fifo from filling but we can flush it.&n;&t; */
r_if
c_cond
(paren
id|ep-&gt;is_in
)paren
id|dmacount
op_or_assign
(paren
l_int|1
op_lshift
id|DMA_DIRECTION
)paren
suffix:semicolon
r_else
id|dmacount
op_or_assign
(paren
l_int|1
op_lshift
id|END_OF_CHAIN
)paren
suffix:semicolon
id|req-&gt;valid
op_assign
id|valid
suffix:semicolon
r_if
c_cond
(paren
id|valid
)paren
id|dmacount
op_or_assign
(paren
l_int|1
op_lshift
id|VALID_BIT
)paren
suffix:semicolon
macro_line|#ifdef USE_DMA_CHAINING
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;req.no_interrupt
)paren
macro_line|#endif
id|dmacount
op_or_assign
(paren
l_int|1
op_lshift
id|DMA_DONE_INTERRUPT_ENABLE
)paren
suffix:semicolon
multiline_comment|/* td-&gt;dmadesc = previously set by caller */
id|td-&gt;dmaaddr
op_assign
id|cpu_to_le32p
(paren
op_amp
id|req-&gt;req.dma
)paren
suffix:semicolon
multiline_comment|/* 2280 may be polling VALID_BIT through ep-&gt;dma-&gt;dmadesc */
id|wmb
(paren
)paren
suffix:semicolon
id|td-&gt;dmacount
op_assign
id|cpu_to_le32p
(paren
op_amp
id|dmacount
)paren
suffix:semicolon
)brace
DECL|variable|dmactl_default
r_static
r_const
id|u32
id|dmactl_default
op_assign
(paren
l_int|1
op_lshift
id|DMA_CLEAR_COUNT_ENABLE
)paren
multiline_comment|/* erratum 0116 workaround part 1 (use POLLING) */
op_or
(paren
id|POLL_100_USEC
op_lshift
id|DESCRIPTOR_POLLING_RATE
)paren
op_or
(paren
l_int|1
op_lshift
id|DMA_VALID_BIT_POLLING_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|DMA_VALID_BIT_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|DMA_SCATTER_GATHER_ENABLE
)paren
multiline_comment|/* erratum 0116 workaround part 2 (no AUTOSTART) */
op_or
(paren
l_int|1
op_lshift
id|DMA_ENABLE
)paren
suffix:semicolon
DECL|function|spin_stop_dma
r_static
r_inline
r_void
id|spin_stop_dma
(paren
r_struct
id|net2280_dma_regs
op_star
id|dma
)paren
(brace
id|handshake
(paren
op_amp
id|dma-&gt;dmactl
comma
(paren
l_int|1
op_lshift
id|DMA_ENABLE
)paren
comma
l_int|0
comma
l_int|50
)paren
suffix:semicolon
)brace
DECL|function|stop_dma
r_static
r_inline
r_void
id|stop_dma
(paren
r_struct
id|net2280_dma_regs
op_star
id|dma
)paren
(brace
id|writel
(paren
id|dmactl_default
op_amp
op_complement
(paren
l_int|1
op_lshift
id|DMA_ENABLE
)paren
comma
op_amp
id|dma-&gt;dmactl
)paren
suffix:semicolon
id|spin_stop_dma
(paren
id|dma
)paren
suffix:semicolon
)brace
DECL|function|start_dma
r_static
r_void
id|start_dma
(paren
r_struct
id|net2280_ep
op_star
id|ep
comma
r_struct
id|net2280_request
op_star
id|req
)paren
(brace
id|u32
id|tmp
suffix:semicolon
r_int
id|clear_nak
op_assign
l_int|0
suffix:semicolon
r_struct
id|net2280_dma_regs
op_star
id|dma
op_assign
id|ep-&gt;dma
suffix:semicolon
multiline_comment|/* FIXME can&squot;t use DMA for ZLPs */
multiline_comment|/* previous OUT packet might have been short */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;is_in
op_logical_and
(paren
(paren
id|tmp
op_assign
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
)paren
op_amp
(paren
l_int|1
op_lshift
id|NAK_OUT_PACKETS
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|writel
(paren
(paren
l_int|1
op_lshift
id|SHORT_PACKET_TRANSFERRED_INTERRUPT
)paren
comma
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
suffix:semicolon
id|tmp
op_assign
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
l_int|0
)paren
id|clear_nak
op_assign
l_int|1
suffix:semicolon
r_else
(brace
multiline_comment|/* transfer all/some fifo data */
id|writel
(paren
id|req-&gt;req.dma
comma
op_amp
id|dma-&gt;dmaaddr
)paren
suffix:semicolon
id|tmp
op_assign
id|min
(paren
id|tmp
comma
id|req-&gt;req.length
)paren
suffix:semicolon
multiline_comment|/* dma irq, faking scatterlist status */
id|req-&gt;td-&gt;dmacount
op_assign
id|cpu_to_le32
(paren
id|req-&gt;req.length
op_minus
id|tmp
)paren
suffix:semicolon
id|writel
(paren
(paren
l_int|1
op_lshift
id|DMA_DONE_INTERRUPT_ENABLE
)paren
op_or
id|tmp
comma
op_amp
id|dma-&gt;dmacount
)paren
suffix:semicolon
id|writel
(paren
(paren
l_int|1
op_lshift
id|DMA_ENABLE
)paren
comma
op_amp
id|dma-&gt;dmactl
)paren
suffix:semicolon
id|writel
(paren
(paren
l_int|1
op_lshift
id|DMA_START
)paren
comma
op_amp
id|dma-&gt;dmastat
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* on this path we know there&squot;s no dma queue (yet) */
id|WARN_ON
(paren
id|readl
(paren
op_amp
id|dma-&gt;dmactl
)paren
op_amp
(paren
l_int|1
op_lshift
id|DMA_ENABLE
)paren
)paren
suffix:semicolon
id|tmp
op_assign
id|dmactl_default
suffix:semicolon
multiline_comment|/* force packet boundaries between dma requests, but prevent the&n;&t; * controller from automagically writing a last &quot;short&quot; packet&n;&t; * (zero length) unless the driver explicitly said to do that.&n;&t; */
r_if
c_cond
(paren
id|ep-&gt;is_in
)paren
(brace
r_if
c_cond
(paren
id|likely
(paren
(paren
id|req-&gt;req.length
op_mod
id|ep-&gt;ep.maxpacket
)paren
op_ne
l_int|0
op_logical_or
id|req-&gt;req.zero
)paren
)paren
(brace
id|tmp
op_or_assign
(paren
l_int|1
op_lshift
id|DMA_FIFO_VALIDATE
)paren
suffix:semicolon
id|ep-&gt;in_fifo_validate
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|ep-&gt;in_fifo_validate
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* init req-&gt;td, pointing to the current dummy */
id|req-&gt;td-&gt;dmadesc
op_assign
id|cpu_to_le32
(paren
id|ep-&gt;td_dma
)paren
suffix:semicolon
id|fill_dma_desc
(paren
id|ep
comma
id|req
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef USE_DMA_CHAINING
id|writel
(paren
(paren
l_int|1
op_lshift
id|VALID_BIT
)paren
op_or
(paren
id|ep-&gt;is_in
op_lshift
id|DMA_DIRECTION
)paren
op_or
l_int|0
comma
op_amp
id|dma-&gt;dmacount
)paren
suffix:semicolon
macro_line|#else
id|req-&gt;td-&gt;dmacount
op_or_assign
id|__constant_cpu_to_le32
(paren
l_int|1
op_lshift
id|END_OF_CHAIN
)paren
suffix:semicolon
macro_line|#endif
id|writel
(paren
id|req-&gt;td_dma
comma
op_amp
id|dma-&gt;dmadesc
)paren
suffix:semicolon
id|writel
(paren
id|tmp
comma
op_amp
id|dma-&gt;dmactl
)paren
suffix:semicolon
multiline_comment|/* erratum 0116 workaround part 3:  pci arbiter away from net2280 */
(paren
r_void
)paren
id|readl
(paren
op_amp
id|ep-&gt;dev-&gt;pci-&gt;pcimstctl
)paren
suffix:semicolon
id|writel
(paren
(paren
l_int|1
op_lshift
id|DMA_START
)paren
comma
op_amp
id|dma-&gt;dmastat
)paren
suffix:semicolon
multiline_comment|/* recover from previous short read; erratum 0112 workaround #1 */
r_if
c_cond
(paren
id|clear_nak
)paren
id|writel
(paren
(paren
l_int|1
op_lshift
id|CLEAR_NAK_OUT_PACKETS
)paren
comma
op_amp
id|ep-&gt;regs-&gt;ep_rsp
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|queue_dma
id|queue_dma
(paren
r_struct
id|net2280_ep
op_star
id|ep
comma
r_struct
id|net2280_request
op_star
id|req
comma
r_int
id|valid
)paren
(brace
r_struct
id|net2280_dma
op_star
id|end
suffix:semicolon
id|dma_addr_t
id|tmp
suffix:semicolon
multiline_comment|/* swap new dummy for old, link; fill and maybe activate */
id|end
op_assign
id|ep-&gt;dummy
suffix:semicolon
id|ep-&gt;dummy
op_assign
id|req-&gt;td
suffix:semicolon
id|req-&gt;td
op_assign
id|end
suffix:semicolon
id|tmp
op_assign
id|ep-&gt;td_dma
suffix:semicolon
id|ep-&gt;td_dma
op_assign
id|req-&gt;td_dma
suffix:semicolon
id|req-&gt;td_dma
op_assign
id|tmp
suffix:semicolon
id|end-&gt;dmadesc
op_assign
id|cpu_to_le32
(paren
id|ep-&gt;td_dma
)paren
suffix:semicolon
id|fill_dma_desc
(paren
id|ep
comma
id|req
comma
id|valid
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|done
id|done
(paren
r_struct
id|net2280_ep
op_star
id|ep
comma
r_struct
id|net2280_request
op_star
id|req
comma
r_int
id|status
)paren
(brace
r_struct
id|net2280
op_star
id|dev
suffix:semicolon
r_int
id|stopped
op_assign
id|ep-&gt;stopped
suffix:semicolon
id|list_del_init
(paren
op_amp
id|req-&gt;queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;req.status
op_eq
op_minus
id|EINPROGRESS
)paren
id|req-&gt;req.status
op_assign
id|status
suffix:semicolon
r_else
id|status
op_assign
id|req-&gt;req.status
suffix:semicolon
id|dev
op_assign
id|ep-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;mapped
)paren
(brace
id|pci_unmap_single
(paren
id|dev-&gt;pdev
comma
id|req-&gt;req.dma
comma
id|req-&gt;req.length
comma
id|ep-&gt;is_in
ques
c_cond
id|PCI_DMA_TODEVICE
suffix:colon
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|req-&gt;req.dma
op_assign
id|DMA_ADDR_INVALID
suffix:semicolon
id|req-&gt;mapped
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_logical_and
id|status
op_ne
op_minus
id|ESHUTDOWN
)paren
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;complete %s req %p stat %d len %u/%u&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
op_amp
id|req-&gt;req
comma
id|status
comma
id|req-&gt;req.actual
comma
id|req-&gt;req.length
)paren
suffix:semicolon
multiline_comment|/* don&squot;t modify queue heads during completion callback */
id|ep-&gt;stopped
op_assign
l_int|1
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|req-&gt;req.complete
(paren
op_amp
id|ep-&gt;ep
comma
op_amp
id|req-&gt;req
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|ep-&gt;stopped
op_assign
id|stopped
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_int
DECL|function|net2280_queue
id|net2280_queue
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_struct
id|usb_request
op_star
id|_req
comma
r_int
id|gfp_flags
)paren
(brace
r_struct
id|net2280_request
op_star
id|req
suffix:semicolon
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
r_struct
id|net2280
op_star
id|dev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* we always require a cpu-view buffer, so that we can&n;&t; * always use pio (as fallback or whatever).&n;&t; */
id|req
op_assign
id|container_of
(paren
id|_req
comma
r_struct
id|net2280_request
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_req
op_logical_or
op_logical_neg
id|_req-&gt;complete
op_logical_or
op_logical_neg
id|_req-&gt;buf
op_logical_or
op_logical_neg
id|list_empty
(paren
op_amp
id|req-&gt;queue
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|_req-&gt;length
OG
(paren
op_complement
l_int|0
op_amp
id|DMA_BYTE_COUNT_MASK
)paren
)paren
r_return
op_minus
id|EDOM
suffix:semicolon
id|ep
op_assign
id|container_of
(paren
id|_ep
comma
r_struct
id|net2280_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
(paren
op_logical_neg
id|ep-&gt;desc
op_logical_and
id|ep-&gt;num
op_ne
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dev
op_assign
id|ep-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;driver
op_logical_or
id|dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
r_return
op_minus
id|ESHUTDOWN
suffix:semicolon
multiline_comment|/* FIXME implement PIO fallback for ZLPs with DMA */
r_if
c_cond
(paren
id|ep-&gt;dma
op_logical_and
id|_req-&gt;length
op_eq
l_int|0
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* set up dma mapping in case the caller didn&squot;t */
r_if
c_cond
(paren
id|ep-&gt;dma
op_logical_and
id|_req-&gt;dma
op_eq
id|DMA_ADDR_INVALID
)paren
(brace
id|_req-&gt;dma
op_assign
id|pci_map_single
(paren
id|dev-&gt;pdev
comma
id|_req-&gt;buf
comma
id|_req-&gt;length
comma
id|ep-&gt;is_in
ques
c_cond
id|PCI_DMA_TODEVICE
suffix:colon
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|req-&gt;mapped
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#if 0
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;%s queue req %p, len %d buf %p&bslash;n&quot;
comma
id|_ep-&gt;name
comma
id|_req
comma
id|_req-&gt;length
comma
id|_req-&gt;buf
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|_req-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
id|_req-&gt;actual
op_assign
l_int|0
suffix:semicolon
id|req-&gt;dma_done
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* kickstart this i/o queue? */
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|ep-&gt;queue
)paren
op_logical_and
op_logical_neg
id|ep-&gt;stopped
)paren
(brace
multiline_comment|/* use DMA if the endpoint supports it, else pio */
r_if
c_cond
(paren
id|ep-&gt;dma
)paren
id|start_dma
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* maybe there&squot;s no control data, just status ack */
r_if
c_cond
(paren
id|ep-&gt;num
op_eq
l_int|0
op_logical_and
id|_req-&gt;length
op_eq
l_int|0
)paren
(brace
id|allow_status
(paren
id|ep
)paren
suffix:semicolon
id|done
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;%s status ack&bslash;n&quot;
comma
id|ep-&gt;ep.name
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* PIO ... stuff the fifo, or unblock it.  */
r_if
c_cond
(paren
id|ep-&gt;is_in
)paren
id|write_fifo
(paren
id|ep
comma
id|_req
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
(brace
id|u32
id|s
suffix:semicolon
multiline_comment|/* OUT FIFO might have packet(s) buffered */
id|s
op_assign
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s
op_amp
(paren
l_int|1
op_lshift
id|FIFO_EMPTY
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* note:  _req-&gt;short_not_ok is&n;&t;&t;&t;&t;&t; * ignored here since PIO _always_&n;&t;&t;&t;&t;&t; * stops queue advance here, and&n;&t;&t;&t;&t;&t; * _req-&gt;status doesn&squot;t change for&n;&t;&t;&t;&t;&t; * short reads (only _req-&gt;actual)&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|read_fifo
(paren
id|ep
comma
id|req
)paren
)paren
(brace
id|done
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* don&squot;t queue it */
id|req
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|s
op_assign
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
suffix:semicolon
)brace
multiline_comment|/* don&squot;t NAK, let the fifo fill */
r_if
c_cond
(paren
id|req
op_logical_and
(paren
id|s
op_amp
(paren
l_int|1
op_lshift
id|NAK_OUT_PACKETS
)paren
)paren
)paren
id|writel
(paren
(paren
l_int|1
op_lshift
id|CLEAR_NAK_OUT_PACKETS
)paren
comma
op_amp
id|ep-&gt;regs-&gt;ep_rsp
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|ep-&gt;dma
)paren
(brace
r_int
id|valid
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;is_in
)paren
(brace
r_int
id|expect
suffix:semicolon
multiline_comment|/* preventing magic zlps is per-engine state, not&n;&t;&t;&t; * per-transfer; irq logic must recover hiccups.&n;&t;&t;&t; */
id|expect
op_assign
id|likely
(paren
id|req-&gt;req.zero
op_logical_or
(paren
id|req-&gt;req.length
op_mod
id|ep-&gt;ep.maxpacket
)paren
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expect
op_ne
id|ep-&gt;in_fifo_validate
)paren
id|valid
op_assign
l_int|0
suffix:semicolon
)brace
id|queue_dma
(paren
id|ep
comma
id|req
comma
id|valid
)paren
suffix:semicolon
)brace
multiline_comment|/* else the irq handler advances the queue. */
r_if
c_cond
(paren
id|req
)paren
id|list_add_tail
(paren
op_amp
id|req-&gt;queue
comma
op_amp
id|ep-&gt;queue
)paren
suffix:semicolon
id|done
suffix:colon
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* pci writes may still be posted */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|dma_done
id|dma_done
(paren
r_struct
id|net2280_ep
op_star
id|ep
comma
r_struct
id|net2280_request
op_star
id|req
comma
id|u32
id|dmacount
comma
r_int
id|status
)paren
(brace
id|req-&gt;req.actual
op_assign
id|req-&gt;req.length
op_minus
(paren
id|DMA_BYTE_COUNT_MASK
op_amp
id|dmacount
)paren
suffix:semicolon
id|rmb
(paren
)paren
suffix:semicolon
id|done
(paren
id|ep
comma
id|req
comma
id|status
)paren
suffix:semicolon
)brace
DECL|function|scan_dma_completions
r_static
r_void
id|scan_dma_completions
(paren
r_struct
id|net2280_ep
op_star
id|ep
)paren
(brace
multiline_comment|/* only look at descriptors that were &quot;naturally&quot; retired,&n;&t; * so fifo and list head state won&squot;t matter&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
(brace
r_struct
id|net2280_request
op_star
id|req
suffix:semicolon
id|u32
id|tmp
suffix:semicolon
id|req
op_assign
id|list_entry
(paren
id|ep-&gt;queue.next
comma
r_struct
id|net2280_request
comma
id|queue
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;valid
)paren
r_break
suffix:semicolon
id|rmb
(paren
)paren
suffix:semicolon
id|tmp
op_assign
id|le32_to_cpup
(paren
op_amp
id|req-&gt;td-&gt;dmacount
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
(paren
l_int|1
op_lshift
id|VALID_BIT
)paren
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* SHORT_PACKET_TRANSFERRED_INTERRUPT handles &quot;usb-short&quot;&n;&t;&t; * packets, including overruns, even when the transfer was&n;&t;&t; * exactly the length requested (dmacount now zero).&n;&t;&t; * FIXME there&squot;s an overrun case here too, where we expect&n;&t;&t; * a short packet but receive a max length one (won&squot;t NAK).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;is_in
op_logical_and
(paren
id|req-&gt;req.length
op_mod
id|ep-&gt;ep.maxpacket
)paren
op_ne
l_int|0
)paren
(brace
id|req-&gt;dma_done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dma_done
(paren
id|ep
comma
id|req
comma
id|tmp
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|restart_dma
r_static
r_void
id|restart_dma
(paren
r_struct
id|net2280_ep
op_star
id|ep
)paren
(brace
r_struct
id|net2280_request
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;stopped
)paren
r_return
suffix:semicolon
id|req
op_assign
id|list_entry
(paren
id|ep-&gt;queue.next
comma
r_struct
id|net2280_request
comma
id|queue
)paren
suffix:semicolon
macro_line|#ifdef USE_DMA_CHAINING
multiline_comment|/* the 2280 will be processing the queue unless queue hiccups after&n;&t; * the previous transfer:&n;&t; *  IN:   wanted automagic zlp, head doesn&squot;t (or vice versa)&n;&t; *  OUT:  was &quot;usb-short&quot;, we must restart.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;valid
)paren
(brace
r_struct
id|net2280_request
op_star
id|entry
comma
op_star
id|prev
op_assign
l_int|0
suffix:semicolon
r_int
id|qmode
comma
id|reqmode
comma
id|done
op_assign
l_int|0
suffix:semicolon
id|DEBUG
(paren
id|ep-&gt;dev
comma
l_string|&quot;%s dma hiccup td %p&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|req-&gt;td
)paren
suffix:semicolon
id|qmode
op_assign
id|likely
(paren
id|req-&gt;req.zero
op_logical_or
(paren
id|req-&gt;req.length
op_mod
id|ep-&gt;ep.maxpacket
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|list_for_each_entry
(paren
id|entry
comma
op_amp
id|ep-&gt;queue
comma
id|queue
)paren
(brace
id|u32
id|dmacount
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
id|req
)paren
r_continue
suffix:semicolon
id|dmacount
op_assign
id|entry-&gt;td-&gt;dmacount
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
id|reqmode
op_assign
id|likely
(paren
id|entry-&gt;req.zero
op_logical_or
(paren
id|entry-&gt;req.length
op_mod
id|ep-&gt;ep.maxpacket
)paren
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqmode
op_eq
id|qmode
)paren
(brace
id|entry-&gt;valid
op_assign
l_int|1
suffix:semicolon
id|dmacount
op_or_assign
id|valid_bit
suffix:semicolon
id|entry-&gt;td-&gt;dmacount
op_assign
id|dmacount
suffix:semicolon
id|prev
op_assign
id|entry
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
id|prev-&gt;td-&gt;dmacount
op_or_assign
id|dma_done_ie
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* walk the rest of the queue so unlinks behave */
id|entry-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|dmacount
op_and_assign
op_complement
id|valid_bit
suffix:semicolon
id|entry-&gt;td-&gt;dmacount
op_assign
id|dmacount
suffix:semicolon
id|prev
op_assign
id|entry
suffix:semicolon
)brace
id|start_dma
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;is_in
op_logical_and
(paren
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
op_amp
(paren
l_int|1
op_lshift
id|NAK_OUT_PACKETS
)paren
)paren
op_ne
l_int|0
)paren
id|start_dma
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
macro_line|#else
id|start_dma
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|abort_dma
r_static
r_inline
r_void
id|abort_dma
(paren
r_struct
id|net2280_ep
op_star
id|ep
)paren
(brace
multiline_comment|/* abort the current transfer */
id|writel
(paren
(paren
l_int|1
op_lshift
id|DMA_ABORT
)paren
comma
op_amp
id|ep-&gt;dma-&gt;dmastat
)paren
suffix:semicolon
multiline_comment|/* collect completed transfers (except the current one) */
id|scan_dma_completions
(paren
id|ep
)paren
suffix:semicolon
)brace
multiline_comment|/* dequeue ALL requests */
DECL|function|nuke
r_static
r_void
id|nuke
(paren
r_struct
id|net2280_ep
op_star
id|ep
)paren
(brace
r_struct
id|net2280_request
op_star
id|req
suffix:semicolon
multiline_comment|/* called with spinlock held */
id|ep-&gt;stopped
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;dma
)paren
id|abort_dma
(paren
id|ep
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
(brace
id|req
op_assign
id|list_entry
(paren
id|ep-&gt;queue.next
comma
r_struct
id|net2280_request
comma
id|queue
)paren
suffix:semicolon
id|done
(paren
id|ep
comma
id|req
comma
op_minus
id|ESHUTDOWN
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* dequeue JUST ONE request */
DECL|function|net2280_dequeue
r_static
r_int
id|net2280_dequeue
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_struct
id|usb_request
op_star
id|_req
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
r_struct
id|net2280_request
op_star
id|req
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u32
id|dmactl
suffix:semicolon
r_int
id|stopped
suffix:semicolon
id|ep
op_assign
id|container_of
(paren
id|_ep
comma
r_struct
id|net2280_ep
comma
id|ep
)paren
suffix:semicolon
id|req
op_assign
id|container_of
(paren
id|_req
comma
r_struct
id|net2280_request
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
(paren
op_logical_neg
id|ep-&gt;desc
op_logical_and
id|ep-&gt;num
op_ne
l_int|0
)paren
op_logical_or
op_logical_neg
id|_req
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ep-&gt;dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|stopped
op_assign
id|ep-&gt;stopped
suffix:semicolon
multiline_comment|/* pause dma while we scan the queue */
id|dmactl
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;stopped
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;dma
)paren
(brace
id|dmactl
op_assign
id|readl
(paren
op_amp
id|ep-&gt;dma-&gt;dmactl
)paren
suffix:semicolon
id|writel
(paren
id|dmactl
op_amp
op_complement
(paren
l_int|1
op_lshift
id|DMA_ENABLE
)paren
comma
op_amp
id|ep-&gt;dma-&gt;dmactl
)paren
suffix:semicolon
multiline_comment|/* force synch, clean any completed requests */
id|spin_stop_dma
(paren
id|ep-&gt;dma
)paren
suffix:semicolon
id|scan_dma_completions
(paren
id|ep
)paren
suffix:semicolon
)brace
multiline_comment|/* queue head may be partially complete. */
r_if
c_cond
(paren
id|ep-&gt;queue.next
op_eq
op_amp
id|req-&gt;queue
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;dma
)paren
(brace
id|DEBUG
(paren
id|ep-&gt;dev
comma
l_string|&quot;unlink (%s) dma&bslash;n&quot;
comma
id|_ep-&gt;name
)paren
suffix:semicolon
id|_req-&gt;status
op_assign
op_minus
id|ECONNRESET
suffix:semicolon
id|abort_dma
(paren
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|ep-&gt;queue.next
op_eq
op_amp
id|req-&gt;queue
)paren
)paren
id|dma_done
(paren
id|ep
comma
id|req
comma
id|le32_to_cpup
(paren
op_amp
id|req-&gt;td-&gt;dmacount
)paren
comma
op_minus
id|ECONNRESET
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUG
(paren
id|ep-&gt;dev
comma
l_string|&quot;unlink (%s) pio&bslash;n&quot;
comma
id|_ep-&gt;name
)paren
suffix:semicolon
id|done
(paren
id|ep
comma
id|req
comma
op_minus
id|ECONNRESET
)paren
suffix:semicolon
)brace
id|req
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef USE_DMA_CHAINING
multiline_comment|/* patch up hardware chaining data */
)brace
r_else
r_if
c_cond
(paren
id|ep-&gt;dma
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;queue.prev
op_eq
id|ep-&gt;queue.next
)paren
(brace
id|writel
(paren
id|le32_to_cpu
(paren
id|req-&gt;td-&gt;dmadesc
)paren
comma
op_amp
id|ep-&gt;dma-&gt;dmadesc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;td-&gt;dmacount
op_amp
id|dma_done_ie
)paren
id|writel
(paren
id|readl
(paren
op_amp
id|ep-&gt;dma-&gt;dmacount
)paren
op_or
id|dma_done_ie
comma
op_amp
id|ep-&gt;dma-&gt;dmacount
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|net2280_request
op_star
id|prev
suffix:semicolon
id|prev
op_assign
id|list_entry
(paren
id|req-&gt;queue.prev
comma
r_struct
id|net2280_request
comma
id|queue
)paren
suffix:semicolon
id|prev-&gt;td-&gt;dmadesc
op_assign
id|req-&gt;td-&gt;dmadesc
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;td-&gt;dmacount
op_amp
id|dma_done_ie
)paren
id|prev-&gt;td-&gt;dmacount
op_or_assign
id|dma_done_ie
suffix:semicolon
)brace
macro_line|#endif
)brace
r_if
c_cond
(paren
id|req
)paren
id|done
(paren
id|ep
comma
id|req
comma
op_minus
id|ECONNRESET
)paren
suffix:semicolon
id|ep-&gt;stopped
op_assign
id|stopped
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;dma
)paren
(brace
multiline_comment|/* turn off dma on inactive queues */
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
id|stop_dma
(paren
id|ep-&gt;dma
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;stopped
)paren
(brace
multiline_comment|/* resume current request, or start new one */
r_if
c_cond
(paren
id|req
)paren
id|writel
(paren
id|dmactl
comma
op_amp
id|ep-&gt;dma-&gt;dmactl
)paren
suffix:semicolon
r_else
id|start_dma
(paren
id|ep
comma
id|list_entry
(paren
id|ep-&gt;queue.next
comma
r_struct
id|net2280_request
comma
id|queue
)paren
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ep-&gt;dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|req
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_int
DECL|function|net2280_set_halt
id|net2280_set_halt
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_int
id|value
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
id|ep
op_assign
id|container_of
(paren
id|_ep
comma
r_struct
id|net2280_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
(paren
op_logical_neg
id|ep-&gt;desc
op_logical_and
id|ep-&gt;num
op_ne
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;dev-&gt;driver
op_logical_or
id|ep-&gt;dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
r_return
op_minus
id|ESHUTDOWN
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;desc
multiline_comment|/* not ep0 */
op_logical_and
(paren
id|ep-&gt;desc-&gt;bmAttributes
op_amp
l_int|0x03
)paren
op_eq
id|USB_ENDPOINT_XFER_ISOC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|VDEBUG
(paren
id|ep-&gt;dev
comma
l_string|&quot;%s %s halt&bslash;n&quot;
comma
id|_ep-&gt;name
comma
id|value
ques
c_cond
l_string|&quot;set&quot;
suffix:colon
l_string|&quot;clear&quot;
)paren
suffix:semicolon
multiline_comment|/* set/clear, then synch memory views with the device */
r_if
c_cond
(paren
id|value
)paren
id|set_halt
(paren
id|ep
)paren
suffix:semicolon
r_else
id|clear_halt
(paren
id|ep
)paren
suffix:semicolon
(paren
r_void
)paren
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_rsp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|net2280_fifo_status
id|net2280_fifo_status
(paren
r_struct
id|usb_ep
op_star
id|_ep
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
id|u32
id|avail
suffix:semicolon
id|ep
op_assign
id|container_of
(paren
id|_ep
comma
r_struct
id|net2280_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
(paren
op_logical_neg
id|ep-&gt;desc
op_logical_and
id|ep-&gt;num
op_ne
l_int|0
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;dev-&gt;driver
op_logical_or
id|ep-&gt;dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
r_return
op_minus
id|ESHUTDOWN
suffix:semicolon
id|avail
op_assign
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_avail
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|12
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avail
OG
id|ep-&gt;fifo_size
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;is_in
)paren
id|avail
op_assign
id|ep-&gt;fifo_size
op_minus
id|avail
suffix:semicolon
r_return
id|avail
suffix:semicolon
)brace
r_static
r_void
DECL|function|net2280_fifo_flush
id|net2280_fifo_flush
(paren
r_struct
id|usb_ep
op_star
id|_ep
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
id|ep
op_assign
id|container_of
(paren
id|_ep
comma
r_struct
id|net2280_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
(paren
op_logical_neg
id|ep-&gt;desc
op_logical_and
id|ep-&gt;num
op_ne
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;dev-&gt;driver
op_logical_or
id|ep-&gt;dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
r_return
suffix:semicolon
id|writel
(paren
(paren
l_int|1
op_lshift
id|FIFO_FLUSH
)paren
comma
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
suffix:semicolon
(paren
r_void
)paren
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_rsp
)paren
suffix:semicolon
)brace
DECL|variable|net2280_ep_ops
r_static
r_struct
id|usb_ep_ops
id|net2280_ep_ops
op_assign
(brace
dot
id|enable
op_assign
id|net2280_enable
comma
dot
id|disable
op_assign
id|net2280_disable
comma
dot
id|alloc_request
op_assign
id|net2280_alloc_request
comma
dot
id|free_request
op_assign
id|net2280_free_request
comma
dot
id|alloc_buffer
op_assign
id|net2280_alloc_buffer
comma
dot
id|free_buffer
op_assign
id|net2280_free_buffer
comma
dot
id|queue
op_assign
id|net2280_queue
comma
dot
id|dequeue
op_assign
id|net2280_dequeue
comma
dot
id|set_halt
op_assign
id|net2280_set_halt
comma
dot
id|fifo_status
op_assign
id|net2280_fifo_status
comma
dot
id|fifo_flush
op_assign
id|net2280_fifo_flush
comma
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|net2280_get_frame
r_static
r_int
id|net2280_get_frame
(paren
r_struct
id|usb_gadget
op_star
id|_gadget
)paren
(brace
r_struct
id|net2280
op_star
id|dev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u16
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_gadget
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dev
op_assign
id|container_of
(paren
id|_gadget
comma
r_struct
id|net2280
comma
id|gadget
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|get_idx_reg
(paren
id|dev-&gt;regs
comma
id|REG_FRAME
)paren
op_amp
l_int|0x03ff
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|net2280_wakeup
r_static
r_int
id|net2280_wakeup
(paren
r_struct
id|usb_gadget
op_star
id|_gadget
)paren
(brace
r_struct
id|net2280
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_gadget
)paren
r_return
l_int|0
suffix:semicolon
id|dev
op_assign
id|container_of
(paren
id|_gadget
comma
r_struct
id|net2280
comma
id|gadget
)paren
suffix:semicolon
id|writel
(paren
l_int|1
op_lshift
id|GENERATE_RESUME
comma
op_amp
id|dev-&gt;usb-&gt;usbstat
)paren
suffix:semicolon
multiline_comment|/* pci writes may still be posted */
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|net2280_ops
r_static
r_const
r_struct
id|usb_gadget_ops
id|net2280_ops
op_assign
(brace
dot
id|get_frame
op_assign
id|net2280_get_frame
comma
dot
id|wakeup
op_assign
id|net2280_wakeup
comma
singleline_comment|// .set_selfpowered = net2280_set_selfpowered,
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#ifdef&t;USE_SYSFS_DEBUG_FILES
multiline_comment|/* &quot;function&quot; sysfs attribute */
r_static
id|ssize_t
DECL|function|show_function
id|show_function
(paren
r_struct
id|device
op_star
id|_dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|net2280
op_star
id|dev
op_assign
id|dev_get_drvdata
(paren
id|_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;driver
op_logical_or
op_logical_neg
id|dev-&gt;driver-&gt;function
op_logical_or
id|strlen
(paren
id|dev-&gt;driver-&gt;function
)paren
OG
id|PAGE_SIZE
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|snprintf
(paren
id|buf
comma
id|PAGE_SIZE
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|dev-&gt;driver-&gt;function
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
(paren
id|function
comma
id|S_IRUGO
comma
id|show_function
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|ssize_t
DECL|function|show_registers
id|show_registers
(paren
r_struct
id|device
op_star
id|_dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|net2280
op_star
id|dev
suffix:semicolon
r_char
op_star
id|next
suffix:semicolon
r_int
id|size
comma
id|t
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u32
id|t1
comma
id|t2
suffix:semicolon
r_char
op_star
id|s
suffix:semicolon
id|dev
op_assign
id|dev_get_drvdata
(paren
id|_dev
)paren
suffix:semicolon
id|next
op_assign
id|buf
suffix:semicolon
id|size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;driver
)paren
id|s
op_assign
id|dev-&gt;driver-&gt;driver.name
suffix:semicolon
r_else
id|s
op_assign
l_string|&quot;(none)&quot;
suffix:semicolon
multiline_comment|/* Main Control Registers */
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot;%s &quot;
id|DRIVER_VERSION
l_string|&quot;&bslash;n&quot;
l_string|&quot;devinit %03x fifoctl %08x gadget &squot;%s&squot;&bslash;n&quot;
l_string|&quot;pci irqenb0 %02x irqenb1 %08x &quot;
l_string|&quot;irqstat0 %04x irqstat1 %08x&bslash;n&quot;
comma
id|driver_name
comma
id|readl
(paren
op_amp
id|dev-&gt;regs-&gt;devinit
)paren
comma
id|readl
(paren
op_amp
id|dev-&gt;regs-&gt;fifoctl
)paren
comma
id|s
comma
id|readl
(paren
op_amp
id|dev-&gt;regs-&gt;pciirqenb0
)paren
comma
id|readl
(paren
op_amp
id|dev-&gt;regs-&gt;pciirqenb1
)paren
comma
id|readl
(paren
op_amp
id|dev-&gt;regs-&gt;irqstat0
)paren
comma
id|readl
(paren
op_amp
id|dev-&gt;regs-&gt;irqstat1
)paren
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
multiline_comment|/* USB Control Registers */
id|t1
op_assign
id|readl
(paren
op_amp
id|dev-&gt;usb-&gt;usbctl
)paren
suffix:semicolon
id|t2
op_assign
id|readl
(paren
op_amp
id|dev-&gt;usb-&gt;usbstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t1
op_amp
(paren
l_int|1
op_lshift
id|VBUS_PIN
)paren
)paren
(brace
r_if
c_cond
(paren
id|t2
op_amp
(paren
l_int|1
op_lshift
id|HIGH_SPEED
)paren
)paren
id|s
op_assign
l_string|&quot;high speed&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
id|s
op_assign
l_string|&quot;powered&quot;
suffix:semicolon
r_else
id|s
op_assign
l_string|&quot;full speed&quot;
suffix:semicolon
multiline_comment|/* full speed bit (6) not working?? */
)brace
r_else
id|s
op_assign
l_string|&quot;not attached&quot;
suffix:semicolon
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot;stdrsp %08x usbctl %08x usbstat %08x &quot;
l_string|&quot;addr 0x%02x (%s)&bslash;n&quot;
comma
id|readl
(paren
op_amp
id|dev-&gt;usb-&gt;stdrsp
)paren
comma
id|t1
comma
id|t2
comma
id|readl
(paren
op_amp
id|dev-&gt;usb-&gt;ouraddr
)paren
comma
id|s
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
multiline_comment|/* PCI Master Control Registers */
multiline_comment|/* DMA Control Registers */
multiline_comment|/* Configurable EP Control Registers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
id|ep
op_assign
op_amp
id|dev-&gt;ep
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
op_logical_neg
id|ep-&gt;desc
)paren
r_continue
suffix:semicolon
id|t1
op_assign
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_cfg
)paren
suffix:semicolon
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot;%s&bslash;tcfg %05x rsp %02x enb %02x &quot;
comma
id|ep-&gt;ep.name
comma
id|t1
comma
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_rsp
)paren
op_amp
l_int|0xff
comma
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_irqenb
)paren
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot;stat %08x avail %04x &quot;
l_string|&quot;(ep%d%s-%s)%s&bslash;n&quot;
comma
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
comma
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_avail
)paren
comma
id|t1
op_amp
l_int|0x0f
comma
id|DIR_STRING
(paren
id|t1
)paren
comma
id|type_string
(paren
id|t1
op_rshift
l_int|8
)paren
comma
id|ep-&gt;stopped
ques
c_cond
l_string|&quot;*&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;dma
)paren
r_continue
suffix:semicolon
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot;  dma&bslash;tctl %08x stat %08x count %08x&bslash;n&quot;
l_string|&quot;&bslash;taddr %08x desc %08x&bslash;n&quot;
comma
id|readl
(paren
op_amp
id|ep-&gt;dma-&gt;dmactl
)paren
comma
id|readl
(paren
op_amp
id|ep-&gt;dma-&gt;dmastat
)paren
comma
id|readl
(paren
op_amp
id|ep-&gt;dma-&gt;dmacount
)paren
comma
id|readl
(paren
op_amp
id|ep-&gt;dma-&gt;dmaaddr
)paren
comma
id|readl
(paren
op_amp
id|ep-&gt;dma-&gt;dmadesc
)paren
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
)brace
multiline_comment|/* Indexed Registers */
singleline_comment|// none yet 
multiline_comment|/* Statistics */
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot;irqs:  &quot;
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
id|ep
op_assign
op_amp
id|dev-&gt;ep
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
op_logical_neg
id|ep-&gt;irqs
)paren
r_continue
suffix:semicolon
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot; %s/%ld&quot;
comma
id|ep-&gt;ep.name
comma
id|ep-&gt;irqs
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
)brace
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|PAGE_SIZE
op_minus
id|size
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
(paren
id|registers
comma
id|S_IRUGO
comma
id|show_registers
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|ssize_t
DECL|function|show_queues
id|show_queues
(paren
r_struct
id|device
op_star
id|_dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|net2280
op_star
id|dev
suffix:semicolon
r_char
op_star
id|next
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dev
op_assign
id|dev_get_drvdata
(paren
id|_dev
)paren
suffix:semicolon
id|next
op_assign
id|buf
suffix:semicolon
id|size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
op_assign
op_amp
id|dev-&gt;ep
(braket
id|i
)braket
suffix:semicolon
r_struct
id|net2280_request
op_star
id|req
suffix:semicolon
r_int
id|t
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
l_int|0
)paren
(brace
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|d
suffix:semicolon
id|d
op_assign
id|ep-&gt;desc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d
)paren
r_continue
suffix:semicolon
id|t
op_assign
id|d-&gt;bEndpointAddress
suffix:semicolon
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot;%s (ep%d%s-%s) max %04x %s&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|t
op_amp
id|USB_ENDPOINT_NUMBER_MASK
comma
(paren
id|t
op_amp
id|USB_DIR_IN
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
(paren
(brace
r_char
op_star
id|val
suffix:semicolon
r_switch
(paren
id|d-&gt;bmAttributes
op_amp
l_int|0x03
)paren
(brace
r_case
id|USB_ENDPOINT_XFER_BULK
suffix:colon
id|val
op_assign
l_string|&quot;bulk&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_ENDPOINT_XFER_INT
suffix:colon
id|val
op_assign
l_string|&quot;intr&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|val
op_assign
l_string|&quot;iso&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|val
suffix:semicolon
)brace
)paren
comma
id|le16_to_cpu
(paren
id|d-&gt;wMaxPacketSize
)paren
op_amp
l_int|0x1fff
comma
id|ep-&gt;dma
ques
c_cond
l_string|&quot;dma&quot;
suffix:colon
l_string|&quot;pio&quot;
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* ep0 should only have one transfer queued */
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot;ep0 max 64 pio %s&bslash;n&quot;
comma
id|ep-&gt;is_in
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_le
l_int|0
op_logical_or
id|t
OG
id|size
)paren
r_goto
id|done
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
(brace
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot;&bslash;t(nothing queued)&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_le
l_int|0
op_logical_or
id|t
OG
id|size
)paren
r_goto
id|done
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|list_for_each_entry
(paren
id|req
comma
op_amp
id|ep-&gt;queue
comma
id|queue
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;dma
op_logical_and
id|req-&gt;td_dma
op_eq
id|readl
(paren
op_amp
id|ep-&gt;dma-&gt;dmadesc
)paren
)paren
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot;&bslash;treq %p len %d/%d &quot;
l_string|&quot;buf %p (dmacount %08x)&bslash;n&quot;
comma
op_amp
id|req-&gt;req
comma
id|req-&gt;req.actual
comma
id|req-&gt;req.length
comma
id|req-&gt;req.buf
comma
id|readl
(paren
op_amp
id|ep-&gt;dma-&gt;dmacount
)paren
)paren
suffix:semicolon
r_else
id|t
op_assign
id|snprintf
(paren
id|next
comma
id|size
comma
l_string|&quot;&bslash;treq %p len %d/%d buf %p&bslash;n&quot;
comma
op_amp
id|req-&gt;req
comma
id|req-&gt;req.actual
comma
id|req-&gt;req.length
comma
id|req-&gt;req.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_le
l_int|0
op_logical_or
id|t
OG
id|size
)paren
r_goto
id|done
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
)brace
)brace
id|done
suffix:colon
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|PAGE_SIZE
op_minus
id|size
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
(paren
id|queues
comma
id|S_IRUGO
comma
id|show_queues
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#else
DECL|macro|device_create_file
mdefine_line|#define device_create_file(a,b)&t;do {} while (0)
DECL|macro|device_remove_file
mdefine_line|#define device_remove_file&t;device_create_file
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* another driver-specific mode might be a request type doing dma&n; * to/from another device fifo instead of to/from memory.&n; */
DECL|function|set_fifo_mode
r_static
r_void
id|set_fifo_mode
(paren
r_struct
id|net2280
op_star
id|dev
comma
r_int
id|mode
)paren
(brace
multiline_comment|/* keeping high bits preserves BAR2 */
id|writel
(paren
(paren
l_int|0xffff
op_lshift
id|PCI_BASE2_RANGE
)paren
op_or
id|mode
comma
op_amp
id|dev-&gt;regs-&gt;fifoctl
)paren
suffix:semicolon
multiline_comment|/* always ep-{a,b,e,f} ... maybe not ep-c or ep-d */
id|INIT_LIST_HEAD
(paren
op_amp
id|dev-&gt;gadget.ep_list
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|1
)braket
dot
id|ep.ep_list
comma
op_amp
id|dev-&gt;gadget.ep_list
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|2
)braket
dot
id|ep.ep_list
comma
op_amp
id|dev-&gt;gadget.ep_list
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
l_int|0
suffix:colon
id|list_add_tail
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|3
)braket
dot
id|ep.ep_list
comma
op_amp
id|dev-&gt;gadget.ep_list
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|4
)braket
dot
id|ep.ep_list
comma
op_amp
id|dev-&gt;gadget.ep_list
)paren
suffix:semicolon
id|dev-&gt;ep
(braket
l_int|1
)braket
dot
id|fifo_size
op_assign
id|dev-&gt;ep
(braket
l_int|2
)braket
dot
id|fifo_size
op_assign
l_int|1024
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dev-&gt;ep
(braket
l_int|1
)braket
dot
id|fifo_size
op_assign
id|dev-&gt;ep
(braket
l_int|2
)braket
dot
id|fifo_size
op_assign
l_int|2048
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|list_add_tail
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|3
)braket
dot
id|ep.ep_list
comma
op_amp
id|dev-&gt;gadget.ep_list
)paren
suffix:semicolon
id|dev-&gt;ep
(braket
l_int|1
)braket
dot
id|fifo_size
op_assign
l_int|2048
suffix:semicolon
id|dev-&gt;ep
(braket
l_int|2
)braket
dot
id|fifo_size
op_assign
l_int|1024
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fifo sizes for ep0, ep-c, ep-d, ep-e, and ep-f never change */
id|list_add_tail
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|5
)braket
dot
id|ep.ep_list
comma
op_amp
id|dev-&gt;gadget.ep_list
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|6
)braket
dot
id|ep.ep_list
comma
op_amp
id|dev-&gt;gadget.ep_list
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * net2280_set_fifo_mode - change allocation of fifo buffers&n; * @gadget: access to the net2280 device that will be updated&n; * @mode: 0 for default, four 1kB buffers (ep-a through ep-d);&n; * &t;1 for two 2kB buffers (ep-a and ep-b only);&n; * &t;2 for one 2kB buffer (ep-a) and two 1kB ones (ep-b, ep-c).&n; *&n; * returns zero on success, else negative errno.  when this succeeds,&n; * the contents of gadget-&gt;ep_list may have changed.&n; *&n; * you may only call this function when endpoints a-d are all disabled.&n; * use it whenever extra hardware buffering can help performance, such&n; * as before enabling &quot;high bandwidth&quot; interrupt endpoints that use&n; * maxpacket bigger than 512 (when double buffering would otherwise&n; * be unavailable).&n; */
DECL|function|net2280_set_fifo_mode
r_int
id|net2280_set_fifo_mode
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
r_int
id|mode
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|net2280
op_star
id|dev
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gadget
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dev
op_assign
id|container_of
(paren
id|gadget
comma
r_struct
id|net2280
comma
id|gadget
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|4
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;ep
(braket
id|i
)braket
dot
id|desc
)paren
(brace
id|status
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
template_param
l_int|2
)paren
id|status
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
id|set_fifo_mode
(paren
id|dev
comma
id|mode
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
l_int|1
)paren
id|DEBUG
(paren
id|dev
comma
l_string|&quot;fifo:  ep-a 2K, ep-b 2K&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mode
op_eq
l_int|2
)paren
id|DEBUG
(paren
id|dev
comma
l_string|&quot;fifo:  ep-a 2K, ep-b 1K, ep-c 1K&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* else all are 1K */
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|variable|net2280_set_fifo_mode
id|EXPORT_SYMBOL
(paren
id|net2280_set_fifo_mode
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* keeping it simple:&n; * - one bus driver, initted first;&n; * - one function driver, initted second&n; *&n; * most of the work to support multiple net2280 controllers would&n; * be to associate this gadget driver (yes?) with all of them, or&n; * perhaps to bind specific drivers to specific devices.&n; */
DECL|variable|the_controller
r_static
r_struct
id|net2280
op_star
id|the_controller
suffix:semicolon
DECL|function|usb_reset
r_static
r_void
id|usb_reset
(paren
r_struct
id|net2280
op_star
id|dev
)paren
(brace
id|u32
id|tmp
suffix:semicolon
multiline_comment|/* force immediate bus disconnect, and synch through pci */
id|writel
(paren
l_int|0
comma
op_amp
id|dev-&gt;usb-&gt;usbctl
)paren
suffix:semicolon
id|dev-&gt;gadget.speed
op_assign
id|USB_SPEED_UNKNOWN
suffix:semicolon
(paren
r_void
)paren
id|readl
(paren
op_amp
id|dev-&gt;usb-&gt;usbctl
)paren
suffix:semicolon
id|net2280_led_init
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* disable automatic responses, and irqs */
id|writel
(paren
l_int|0
comma
op_amp
id|dev-&gt;usb-&gt;stdrsp
)paren
suffix:semicolon
id|writel
(paren
l_int|0
comma
op_amp
id|dev-&gt;regs-&gt;pciirqenb0
)paren
suffix:semicolon
id|writel
(paren
l_int|0
comma
op_amp
id|dev-&gt;regs-&gt;pciirqenb1
)paren
suffix:semicolon
multiline_comment|/* clear old dma and irq state */
r_for
c_loop
(paren
id|tmp
op_assign
l_int|0
suffix:semicolon
id|tmp
OL
l_int|4
suffix:semicolon
id|tmp
op_increment
)paren
(brace
id|writel
(paren
(paren
l_int|1
op_lshift
id|DMA_ABORT
)paren
comma
op_amp
id|dev-&gt;dma
(braket
id|tmp
)braket
dot
id|dmastat
)paren
suffix:semicolon
id|stop_dma
(paren
op_amp
id|dev-&gt;dma
(braket
id|tmp
)braket
)paren
suffix:semicolon
)brace
id|writel
(paren
op_complement
l_int|0
comma
op_amp
id|dev-&gt;regs-&gt;irqstat0
)paren
comma
id|writel
(paren
op_complement
(paren
l_int|1
op_lshift
id|SUSPEND_REQUEST_INTERRUPT
)paren
comma
op_amp
id|dev-&gt;regs-&gt;irqstat1
)paren
comma
multiline_comment|/* reset, and enable pci */
id|tmp
op_assign
id|readl
(paren
op_amp
id|dev-&gt;regs-&gt;devinit
)paren
op_or
(paren
l_int|1
op_lshift
id|PCI_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|FIFO_SOFT_RESET
)paren
op_or
(paren
l_int|1
op_lshift
id|USB_SOFT_RESET
)paren
op_or
(paren
l_int|1
op_lshift
id|M8051_RESET
)paren
suffix:semicolon
id|writel
(paren
id|tmp
comma
op_amp
id|dev-&gt;regs-&gt;devinit
)paren
suffix:semicolon
multiline_comment|/* standard fifo and endpoint allocations */
id|set_fifo_mode
(paren
id|dev
comma
(paren
id|fifo_mode
op_le
l_int|2
)paren
ques
c_cond
id|fifo_mode
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|usb_reinit
r_static
r_void
id|usb_reinit
(paren
r_struct
id|net2280
op_star
id|dev
)paren
(brace
id|u32
id|tmp
suffix:semicolon
r_int
id|init_dma
suffix:semicolon
multiline_comment|/* use_dma changes are ignored till next device re-init */
id|init_dma
op_assign
id|use_dma
suffix:semicolon
multiline_comment|/* basic endpoint init */
r_for
c_loop
(paren
id|tmp
op_assign
l_int|0
suffix:semicolon
id|tmp
OL
l_int|7
suffix:semicolon
id|tmp
op_increment
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
op_assign
op_amp
id|dev-&gt;ep
(braket
id|tmp
)braket
suffix:semicolon
id|ep-&gt;ep.name
op_assign
id|ep_name
(braket
id|tmp
)braket
suffix:semicolon
id|ep-&gt;dev
op_assign
id|dev
suffix:semicolon
id|ep-&gt;num
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OG
l_int|0
op_logical_and
id|tmp
op_le
l_int|4
)paren
(brace
id|ep-&gt;fifo_size
op_assign
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|init_dma
)paren
id|ep-&gt;dma
op_assign
op_amp
id|dev-&gt;dma
(braket
id|tmp
op_minus
l_int|1
)braket
suffix:semicolon
)brace
r_else
id|ep-&gt;fifo_size
op_assign
l_int|64
suffix:semicolon
id|ep-&gt;regs
op_assign
op_amp
id|dev-&gt;epregs
(braket
id|tmp
)braket
suffix:semicolon
id|ep_reset
(paren
id|dev-&gt;regs
comma
id|ep
)paren
suffix:semicolon
)brace
id|dev-&gt;ep
(braket
l_int|0
)braket
dot
id|ep.maxpacket
op_assign
l_int|64
suffix:semicolon
id|dev-&gt;ep
(braket
l_int|5
)braket
dot
id|ep.maxpacket
op_assign
l_int|64
suffix:semicolon
id|dev-&gt;ep
(braket
l_int|6
)braket
dot
id|ep.maxpacket
op_assign
l_int|64
suffix:semicolon
id|dev-&gt;gadget.ep0
op_assign
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
dot
id|ep
suffix:semicolon
id|dev-&gt;ep
(braket
l_int|0
)braket
dot
id|stopped
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|dev-&gt;gadget.ep0-&gt;ep_list
)paren
suffix:semicolon
multiline_comment|/* we want to prevent lowlevel/insecure access from the USB host,&n;&t; * but erratum 0119 means this enable bit is ignored&n;&t; */
r_for
c_loop
(paren
id|tmp
op_assign
l_int|0
suffix:semicolon
id|tmp
OL
l_int|5
suffix:semicolon
id|tmp
op_increment
)paren
id|writel
(paren
id|EP_DONTUSE
comma
op_amp
id|dev-&gt;dep
(braket
id|tmp
)braket
dot
id|dep_cfg
)paren
suffix:semicolon
)brace
DECL|function|ep0_start
r_static
r_void
id|ep0_start
(paren
r_struct
id|net2280
op_star
id|dev
)paren
(brace
id|writel
(paren
(paren
l_int|1
op_lshift
id|CLEAR_EP_HIDE_STATUS_PHASE
)paren
op_or
(paren
l_int|1
op_lshift
id|CLEAR_NAK_OUT_PACKETS
)paren
op_or
(paren
l_int|1
op_lshift
id|CLEAR_CONTROL_STATUS_PHASE_HANDSHAKE
)paren
comma
op_amp
id|dev-&gt;epregs
(braket
l_int|0
)braket
dot
id|ep_rsp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * hardware optionally handles a bunch of standard requests&n;&t; * that the API hides from drivers anyway.  have it do so.&n;&t; * endpoint status/features are handled in software, to&n;&t; * help pass tests for some dubious behavior.&n;&t; */
id|writel
(paren
(paren
l_int|1
op_lshift
id|SET_TEST_MODE
)paren
op_or
(paren
l_int|1
op_lshift
id|SET_ADDRESS
)paren
op_or
(paren
l_int|1
op_lshift
id|DEVICE_SET_CLEAR_DEVICE_REMOTE_WAKEUP
)paren
op_or
(paren
l_int|1
op_lshift
id|GET_DEVICE_STATUS
)paren
op_or
(paren
l_int|1
op_lshift
id|GET_INTERFACE_STATUS
)paren
comma
op_amp
id|dev-&gt;usb-&gt;stdrsp
)paren
suffix:semicolon
id|writel
(paren
(paren
l_int|1
op_lshift
id|USB_ROOT_PORT_WAKEUP_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|SELF_POWERED_USB_DEVICE
)paren
op_or
(paren
l_int|1
op_lshift
id|REMOTE_WAKEUP_SUPPORT
)paren
op_or
(paren
l_int|1
op_lshift
id|USB_DETECT_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|DEVICE_REMOTE_WAKEUP_ENABLE
)paren
comma
op_amp
id|dev-&gt;usb-&gt;usbctl
)paren
suffix:semicolon
multiline_comment|/* enable irqs so we can see ep0 and general operation  */
id|writel
(paren
(paren
l_int|1
op_lshift
id|SETUP_PACKET_INTERRUPT_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|ENDPOINT_0_INTERRUPT_ENABLE
)paren
comma
op_amp
id|dev-&gt;regs-&gt;pciirqenb0
)paren
suffix:semicolon
id|writel
(paren
(paren
l_int|1
op_lshift
id|PCI_INTERRUPT_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|PCI_MASTER_ABORT_RECEIVED_INTERRUPT_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|PCI_TARGET_ABORT_RECEIVED_INTERRUPT_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|PCI_RETRY_ABORT_INTERRUPT_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|VBUS_INTERRUPT_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|ROOT_PORT_RESET_INTERRUPT_ENABLE
)paren
comma
op_amp
id|dev-&gt;regs-&gt;pciirqenb1
)paren
suffix:semicolon
multiline_comment|/* don&squot;t leave any writes posted */
(paren
r_void
)paren
id|readl
(paren
op_amp
id|dev-&gt;usb-&gt;usbctl
)paren
suffix:semicolon
)brace
multiline_comment|/* when a driver is successfully registered, it will receive&n; * control requests including set_configuration(), which enables&n; * non-control requests.  then usb traffic follows until a&n; * disconnect is reported.  then a host may connect again, or&n; * the driver might get unbound.&n; */
DECL|function|usb_gadget_register_driver
r_int
id|usb_gadget_register_driver
(paren
r_struct
id|usb_gadget_driver
op_star
id|driver
)paren
(brace
r_struct
id|net2280
op_star
id|dev
op_assign
id|the_controller
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* insist on high speed support from the driver, since&n;&t; * (dev-&gt;usb-&gt;xcvrdiag &amp; FORCE_FULL_SPEED_MODE)&n;&t; * &quot;must not be used in normal operation&quot;&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|driver
op_logical_or
id|driver-&gt;speed
op_ne
id|USB_SPEED_HIGH
op_logical_or
op_logical_neg
id|driver-&gt;bind
op_logical_or
op_logical_neg
id|driver-&gt;unbind
op_logical_or
op_logical_neg
id|driver-&gt;setup
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;driver
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;ep
(braket
id|i
)braket
dot
id|irqs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* hook up the driver ... */
id|dev-&gt;driver
op_assign
id|driver
suffix:semicolon
id|dev-&gt;gadget.dev.driver
op_assign
op_amp
id|driver-&gt;driver
suffix:semicolon
id|retval
op_assign
id|driver-&gt;bind
(paren
op_amp
id|dev-&gt;gadget
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|DEBUG
(paren
id|dev
comma
l_string|&quot;bind to driver %s --&gt; %d&bslash;n&quot;
comma
id|driver-&gt;driver.name
comma
id|retval
)paren
suffix:semicolon
id|dev-&gt;driver
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;gadget.dev.driver
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
singleline_comment|// FIXME
singleline_comment|// driver_register (&amp;driver-&gt;driver);
singleline_comment|// device_register (&amp;dev-&gt;gadget.dev);
id|device_create_file
(paren
op_amp
id|dev-&gt;pdev-&gt;dev
comma
op_amp
id|dev_attr_function
)paren
suffix:semicolon
id|device_create_file
(paren
op_amp
id|dev-&gt;pdev-&gt;dev
comma
op_amp
id|dev_attr_queues
)paren
suffix:semicolon
multiline_comment|/* ... then enable host detection and ep0; and we&squot;re ready&n;&t; * for set_configuration as well as eventual disconnect.&n;&t; */
id|net2280_led_active
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|ep0_start
(paren
id|dev
)paren
suffix:semicolon
id|DEBUG
(paren
id|dev
comma
l_string|&quot;%s ready, usbctl %08x stdrsp %08x&bslash;n&quot;
comma
id|driver-&gt;driver.name
comma
id|readl
(paren
op_amp
id|dev-&gt;usb-&gt;usbctl
)paren
comma
id|readl
(paren
op_amp
id|dev-&gt;usb-&gt;stdrsp
)paren
)paren
suffix:semicolon
multiline_comment|/* pci writes may still be posted */
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_gadget_register_driver
id|EXPORT_SYMBOL
(paren
id|usb_gadget_register_driver
)paren
suffix:semicolon
r_static
r_void
DECL|function|stop_activity
id|stop_activity
(paren
r_struct
id|net2280
op_star
id|dev
comma
r_struct
id|usb_gadget_driver
op_star
id|driver
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* don&squot;t disconnect if it&squot;s not connected */
r_if
c_cond
(paren
id|dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
id|driver
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* stop hardware; prevent new request submissions;&n;&t; * and kill any outstanding requests.&n;&t; */
id|usb_reset
(paren
id|dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
id|nuke
(paren
op_amp
id|dev-&gt;ep
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* report disconnect; the driver is already quiesced */
r_if
c_cond
(paren
id|driver
)paren
(brace
id|spin_unlock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|driver-&gt;disconnect
(paren
op_amp
id|dev-&gt;gadget
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
)brace
id|usb_reinit
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|usb_gadget_unregister_driver
r_int
id|usb_gadget_unregister_driver
(paren
r_struct
id|usb_gadget_driver
op_star
id|driver
)paren
(brace
r_struct
id|net2280
op_star
id|dev
op_assign
id|the_controller
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver
op_logical_or
id|driver
op_ne
id|dev-&gt;driver
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|stop_activity
(paren
id|dev
comma
id|driver
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|driver-&gt;unbind
(paren
op_amp
id|dev-&gt;gadget
)paren
suffix:semicolon
id|dev-&gt;driver
op_assign
l_int|0
suffix:semicolon
id|net2280_led_active
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|device_remove_file
(paren
op_amp
id|dev-&gt;pdev-&gt;dev
comma
op_amp
id|dev_attr_function
)paren
suffix:semicolon
id|device_remove_file
(paren
op_amp
id|dev-&gt;pdev-&gt;dev
comma
op_amp
id|dev_attr_queues
)paren
suffix:semicolon
singleline_comment|// FIXME
singleline_comment|// device_unregister()
singleline_comment|// driver_unregister (&amp;driver-&gt;driver);
id|DEBUG
(paren
id|dev
comma
l_string|&quot;unregistered driver &squot;%s&squot;&bslash;n&quot;
comma
id|driver-&gt;driver.name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_gadget_unregister_driver
id|EXPORT_SYMBOL
(paren
id|usb_gadget_unregister_driver
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* handle ep0, ep-e, ep-f with 64 byte packets: packet per irq.&n; * also works for dma-capable endpoints, in pio mode or just&n; * to manually advance the queue after short OUT transfers.&n; */
DECL|function|handle_ep_small
r_static
r_void
id|handle_ep_small
(paren
r_struct
id|net2280_ep
op_star
id|ep
)paren
(brace
r_struct
id|net2280_request
op_star
id|req
suffix:semicolon
id|u32
id|t
suffix:semicolon
multiline_comment|/* 0 error, 1 mid-data, 2 done */
r_int
id|mode
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
id|req
op_assign
id|list_entry
(paren
id|ep-&gt;queue.next
comma
r_struct
id|net2280_request
comma
id|queue
)paren
suffix:semicolon
r_else
id|req
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ack all, and handle what we care about */
id|t
op_assign
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
suffix:semicolon
id|ep-&gt;irqs
op_increment
suffix:semicolon
macro_line|#if 0
id|VDEBUG
(paren
id|ep-&gt;dev
comma
l_string|&quot;%s ack ep_stat %08x, req %p&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|t
comma
id|req
ques
c_cond
op_amp
id|req-&gt;req
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|writel
(paren
id|t
op_amp
op_complement
(paren
l_int|1
op_lshift
id|NAK_OUT_PACKETS
)paren
comma
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
suffix:semicolon
multiline_comment|/* for ep0, monitor token irqs to catch data stage length errors&n;&t; * and to synchronize on status.&n;&t; *&n;&t; * also, to defer reporting of protocol stalls ... here&squot;s where&n;&t; * data or status first appears, handling stalls here should never&n;&t; * cause trouble on the host side..&n;&t; *&n;&t; * control requests could be slightly faster without token synch for&n;&t; * status, but status can jam up that way.&n;&t; */
r_if
c_cond
(paren
id|unlikely
(paren
id|ep-&gt;num
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;is_in
)paren
(brace
multiline_comment|/* status; stop NAKing */
r_if
c_cond
(paren
id|t
op_amp
(paren
l_int|1
op_lshift
id|DATA_OUT_PING_TOKEN_INTERRUPT
)paren
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;dev-&gt;protocol_stall
)paren
(brace
id|ep-&gt;stopped
op_assign
l_int|1
suffix:semicolon
id|set_halt
(paren
id|ep
)paren
suffix:semicolon
)brace
id|mode
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* reply to extra IN data tokens with a zlp */
)brace
r_else
r_if
c_cond
(paren
id|t
op_amp
(paren
l_int|1
op_lshift
id|DATA_IN_TOKEN_INTERRUPT
)paren
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;dev-&gt;protocol_stall
)paren
(brace
id|ep-&gt;stopped
op_assign
l_int|1
suffix:semicolon
id|set_halt
(paren
id|ep
)paren
suffix:semicolon
id|mode
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|req
op_logical_and
id|ep-&gt;stopped
)paren
id|write_fifo
(paren
id|ep
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* status; stop NAKing */
r_if
c_cond
(paren
id|t
op_amp
(paren
l_int|1
op_lshift
id|DATA_IN_TOKEN_INTERRUPT
)paren
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;dev-&gt;protocol_stall
)paren
(brace
id|ep-&gt;stopped
op_assign
l_int|1
suffix:semicolon
id|set_halt
(paren
id|ep
)paren
suffix:semicolon
)brace
id|mode
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* an extra OUT token is an error */
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|t
op_amp
(paren
l_int|1
op_lshift
id|DATA_OUT_PING_TOKEN_INTERRUPT
)paren
)paren
op_logical_and
id|req
op_logical_and
id|req-&gt;req.actual
op_eq
id|req-&gt;req.length
)paren
op_logical_or
op_logical_neg
id|req
)paren
(brace
id|ep-&gt;dev-&gt;protocol_stall
op_assign
l_int|1
suffix:semicolon
id|set_halt
(paren
id|ep
)paren
suffix:semicolon
id|ep-&gt;stopped
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
id|done
(paren
id|ep
comma
id|req
comma
op_minus
id|EOVERFLOW
)paren
suffix:semicolon
id|req
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|req
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* manual DMA queue advance after short OUT */
r_if
c_cond
(paren
id|likely
(paren
id|ep-&gt;dma
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|t
op_amp
(paren
l_int|1
op_lshift
id|SHORT_PACKET_TRANSFERRED_INTERRUPT
)paren
)paren
(brace
id|u32
id|count
suffix:semicolon
multiline_comment|/* TRANSFERRED works around OUT_DONE erratum 0112.&n;&t;&t;&t; * we expect (N &lt;= maxpacket) bytes; host wrote M.&n;&t;&t;&t; * iff (M &lt; N) we won&squot;t ever see a DMA interrupt.&n;&t;&t;&t; */
id|count
op_assign
id|readl
(paren
op_amp
id|ep-&gt;dma-&gt;dmacount
)paren
suffix:semicolon
id|count
op_and_assign
id|DMA_BYTE_COUNT_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;dma_done
)paren
(brace
multiline_comment|/* dma can finish with the FIFO non-empty,&n;&t;&t;&t;&t; * on (M &gt; N) errors.&n;&t;&t;&t;&t; */
r_while
c_loop
(paren
id|count
op_logical_and
(paren
id|t
op_amp
(paren
l_int|1
op_lshift
id|FIFO_EMPTY
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|cpu_relax
(paren
)paren
suffix:semicolon
id|t
op_assign
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
suffix:semicolon
id|count
op_assign
id|readl
(paren
op_amp
id|ep-&gt;dma-&gt;dmacount
)paren
suffix:semicolon
id|count
op_and_assign
id|DMA_BYTE_COUNT_MASK
suffix:semicolon
)brace
)brace
multiline_comment|/* stop DMA, leave ep NAKing */
id|writel
(paren
(paren
l_int|1
op_lshift
id|DMA_ABORT
)paren
comma
op_amp
id|ep-&gt;dma-&gt;dmastat
)paren
suffix:semicolon
id|spin_stop_dma
(paren
id|ep-&gt;dma
)paren
suffix:semicolon
multiline_comment|/* buffer might have been too small */
id|t
op_assign
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ne
l_int|0
)paren
id|DEBUG
(paren
id|ep-&gt;dev
comma
l_string|&quot;%s dma, discard %d len %d&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|t
comma
id|count
)paren
suffix:semicolon
id|dma_done
(paren
id|ep
comma
id|req
comma
id|count
comma
id|t
ques
c_cond
op_minus
id|EOVERFLOW
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* also flush to prevent erratum 0106 trouble */
r_if
c_cond
(paren
id|t
op_logical_or
id|ep-&gt;dev-&gt;chiprev
op_eq
l_int|0x0100
)paren
id|out_flush
(paren
id|ep
)paren
suffix:semicolon
multiline_comment|/* restart dma (still NAKing OUT!) if needed */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
id|restart_dma
(paren
id|ep
)paren
suffix:semicolon
)brace
r_else
id|DEBUG
(paren
id|ep-&gt;dev
comma
l_string|&quot;%s dma ep_stat %08x ??&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|t
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* data packet(s) received (in the fifo, OUT) */
)brace
r_else
r_if
c_cond
(paren
id|t
op_amp
(paren
l_int|1
op_lshift
id|DATA_PACKET_RECEIVED_INTERRUPT
)paren
)paren
(brace
r_if
c_cond
(paren
id|read_fifo
(paren
id|ep
comma
id|req
)paren
op_logical_and
id|ep-&gt;num
op_ne
l_int|0
)paren
id|mode
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* data packet(s) transmitted (IN) */
)brace
r_else
r_if
c_cond
(paren
id|t
op_amp
(paren
l_int|1
op_lshift
id|DATA_PACKET_TRANSMITTED_INTERRUPT
)paren
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
id|req-&gt;req.length
op_minus
id|req-&gt;req.actual
suffix:semicolon
id|len
op_assign
id|min
(paren
id|ep-&gt;ep.maxpacket
comma
id|len
)paren
suffix:semicolon
id|req-&gt;req.actual
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* if we wrote it all, we&squot;re usually done */
r_if
c_cond
(paren
id|req-&gt;req.actual
op_eq
id|req-&gt;req.length
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;num
op_eq
l_int|0
)paren
(brace
multiline_comment|/* wait for control status */
r_if
c_cond
(paren
id|mode
op_ne
l_int|2
)paren
id|req
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;req.zero
op_logical_or
id|len
op_ne
id|ep-&gt;ep.maxpacket
)paren
id|mode
op_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* there was nothing to do ...  */
)brace
r_else
r_if
c_cond
(paren
id|mode
op_eq
l_int|1
)paren
r_return
suffix:semicolon
multiline_comment|/* done */
r_if
c_cond
(paren
id|mode
op_eq
l_int|2
)paren
(brace
multiline_comment|/* stream endpoints often resubmit/unlink in completion */
id|done
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* maybe advance queue to next request */
r_if
c_cond
(paren
id|ep-&gt;num
op_eq
l_int|0
)paren
(brace
multiline_comment|/* FIXME need mechanism (request flag?) so control OUT&n;&t;&t;&t; * can decide to stall ep0 after that done() returns,&n;&t;&t;&t; * from non-irq context&n;&t;&t;&t; */
id|allow_status
(paren
id|ep
)paren
suffix:semicolon
id|req
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|ep-&gt;queue
)paren
op_logical_and
op_logical_neg
id|ep-&gt;stopped
)paren
id|req
op_assign
id|list_entry
(paren
id|ep-&gt;queue.next
comma
r_struct
id|net2280_request
comma
id|queue
)paren
suffix:semicolon
r_else
id|req
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|req
op_logical_and
op_logical_neg
id|ep-&gt;is_in
)paren
id|stop_out_naking
(paren
id|ep
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* is there a buffer for the next packet?&n;&t; * for best streaming performance, make sure there is one.&n;&t; */
r_if
c_cond
(paren
id|req
op_logical_and
op_logical_neg
id|ep-&gt;stopped
)paren
(brace
multiline_comment|/* load IN fifo with next packet (may be zlp) */
r_if
c_cond
(paren
id|t
op_amp
(paren
l_int|1
op_lshift
id|DATA_PACKET_TRANSMITTED_INTERRUPT
)paren
)paren
id|write_fifo
(paren
id|ep
comma
op_amp
id|req-&gt;req
)paren
suffix:semicolon
)brace
)brace
r_static
r_struct
id|net2280_ep
op_star
DECL|function|get_ep_by_addr
id|get_ep_by_addr
(paren
r_struct
id|net2280
op_star
id|dev
comma
id|u16
id|wIndex
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wIndex
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
op_eq
l_int|0
)paren
r_return
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
suffix:semicolon
id|list_for_each_entry
(paren
id|ep
comma
op_amp
id|dev-&gt;gadget.ep_list
comma
id|ep.ep_list
)paren
(brace
id|u8
id|bEndpointAddress
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;desc
)paren
r_continue
suffix:semicolon
id|bEndpointAddress
op_assign
id|ep-&gt;desc-&gt;bEndpointAddress
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wIndex
op_xor
id|bEndpointAddress
)paren
op_amp
id|USB_DIR_IN
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wIndex
op_amp
l_int|0x0f
)paren
op_eq
(paren
id|bEndpointAddress
op_amp
l_int|0x0f
)paren
)paren
r_return
id|ep
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_stat0_irqs
r_static
r_void
id|handle_stat0_irqs
(paren
r_struct
id|net2280
op_star
id|dev
comma
id|u32
id|stat
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
id|u32
id|num
comma
id|scratch
suffix:semicolon
multiline_comment|/* most of these don&squot;t need individual acks */
id|stat
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|INTA_ASSERTED
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat
)paren
r_return
suffix:semicolon
singleline_comment|// DEBUG (dev, &quot;irqstat0 %04x&bslash;n&quot;, stat);
multiline_comment|/* starting a control request? */
r_if
c_cond
(paren
id|unlikely
(paren
id|stat
op_amp
(paren
l_int|1
op_lshift
id|SETUP_PACKET_INTERRUPT
)paren
)paren
)paren
(brace
r_union
(brace
id|u32
id|raw
(braket
l_int|2
)braket
suffix:semicolon
r_struct
id|usb_ctrlrequest
id|r
suffix:semicolon
)brace
id|u
suffix:semicolon
r_int
id|tmp
op_assign
l_int|0
suffix:semicolon
r_struct
id|net2280_request
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
(brace
r_if
c_cond
(paren
id|readl
(paren
op_amp
id|dev-&gt;usb-&gt;usbstat
)paren
op_amp
(paren
l_int|1
op_lshift
id|HIGH_SPEED
)paren
)paren
id|dev-&gt;gadget.speed
op_assign
id|USB_SPEED_HIGH
suffix:semicolon
r_else
id|dev-&gt;gadget.speed
op_assign
id|USB_SPEED_FULL
suffix:semicolon
id|net2280_led_speed
(paren
id|dev
comma
id|dev-&gt;gadget.speed
)paren
suffix:semicolon
id|DEBUG
(paren
id|dev
comma
l_string|&quot;%s speed&bslash;n&quot;
comma
(paren
id|dev-&gt;gadget.speed
op_eq
id|USB_SPEED_HIGH
)paren
ques
c_cond
l_string|&quot;high&quot;
suffix:colon
l_string|&quot;full&quot;
)paren
suffix:semicolon
)brace
id|ep
op_assign
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
suffix:semicolon
id|ep-&gt;irqs
op_increment
suffix:semicolon
multiline_comment|/* make sure any leftover request state is cleared */
id|stat
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|ENDPOINT_0_INTERRUPT
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
(brace
id|req
op_assign
id|list_entry
(paren
id|ep-&gt;queue.next
comma
r_struct
id|net2280_request
comma
id|queue
)paren
suffix:semicolon
id|done
(paren
id|ep
comma
id|req
comma
(paren
id|req-&gt;req.actual
op_eq
id|req-&gt;req.length
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EPROTO
)paren
suffix:semicolon
)brace
id|ep-&gt;stopped
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;protocol_stall
op_assign
l_int|0
suffix:semicolon
id|writel
(paren
(paren
l_int|1
op_lshift
id|TIMEOUT
)paren
op_or
(paren
l_int|1
op_lshift
id|USB_STALL_SENT
)paren
op_or
(paren
l_int|1
op_lshift
id|USB_IN_NAK_SENT
)paren
op_or
(paren
l_int|1
op_lshift
id|USB_IN_ACK_RCVD
)paren
op_or
(paren
l_int|1
op_lshift
id|USB_OUT_PING_NAK_SENT
)paren
op_or
(paren
l_int|1
op_lshift
id|USB_OUT_ACK_SENT
)paren
op_or
(paren
l_int|1
op_lshift
id|FIFO_OVERFLOW
)paren
op_or
(paren
l_int|1
op_lshift
id|FIFO_UNDERFLOW
)paren
op_or
(paren
l_int|1
op_lshift
id|SHORT_PACKET_OUT_DONE_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|SHORT_PACKET_TRANSFERRED_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_PACKET_RECEIVED_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_PACKET_TRANSMITTED_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_OUT_PING_TOKEN_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_IN_TOKEN_INTERRUPT
)paren
comma
op_amp
id|ep-&gt;regs-&gt;ep_stat
)paren
suffix:semicolon
id|u.raw
(braket
l_int|0
)braket
op_assign
id|readl
(paren
op_amp
id|dev-&gt;usb-&gt;setup0123
)paren
suffix:semicolon
id|u.raw
(braket
l_int|1
)braket
op_assign
id|readl
(paren
op_amp
id|dev-&gt;usb-&gt;setup4567
)paren
suffix:semicolon
id|cpu_to_le32s
(paren
op_amp
id|u.raw
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cpu_to_le32s
(paren
op_amp
id|u.raw
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|le16_to_cpus
(paren
op_amp
id|u.r.wValue
)paren
suffix:semicolon
id|le16_to_cpus
(paren
op_amp
id|u.r.wIndex
)paren
suffix:semicolon
id|le16_to_cpus
(paren
op_amp
id|u.r.wLength
)paren
suffix:semicolon
multiline_comment|/* ack the irq */
id|writel
(paren
l_int|1
op_lshift
id|SETUP_PACKET_INTERRUPT
comma
op_amp
id|dev-&gt;regs-&gt;irqstat0
)paren
suffix:semicolon
id|stat
op_xor_assign
(paren
l_int|1
op_lshift
id|SETUP_PACKET_INTERRUPT
)paren
suffix:semicolon
multiline_comment|/* watch control traffic at the token level, and force&n;&t;&t; * synchronization before letting the status stage happen.&n;&t;&t; */
id|ep-&gt;is_in
op_assign
(paren
id|u.r.bRequestType
op_amp
id|USB_DIR_IN
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;is_in
)paren
id|scratch
op_assign
(paren
l_int|1
op_lshift
id|DATA_PACKET_TRANSMITTED_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_OUT_PING_TOKEN_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_IN_TOKEN_INTERRUPT
)paren
suffix:semicolon
r_else
id|scratch
op_assign
(paren
l_int|1
op_lshift
id|DATA_PACKET_RECEIVED_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_OUT_PING_TOKEN_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|DATA_IN_TOKEN_INTERRUPT
)paren
suffix:semicolon
id|writel
(paren
id|scratch
comma
op_amp
id|dev-&gt;epregs
(braket
l_int|0
)braket
dot
id|ep_irqenb
)paren
suffix:semicolon
multiline_comment|/* we made the hardware handle most lowlevel requests;&n;&t;&t; * everything else goes uplevel to the gadget code.&n;&t;&t; */
r_switch
c_cond
(paren
id|u.r.bRequest
)paren
(brace
r_case
id|USB_REQ_GET_STATUS
suffix:colon
(brace
r_struct
id|net2280_ep
op_star
id|e
suffix:semicolon
id|u16
id|status
suffix:semicolon
multiline_comment|/* hw handles device and interface status */
r_if
c_cond
(paren
id|u.r.bRequestType
op_ne
(paren
id|USB_DIR_IN
op_or
id|USB_RECIP_ENDPOINT
)paren
)paren
r_goto
id|delegate
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e
op_assign
id|get_ep_by_addr
(paren
id|dev
comma
id|u.r.wIndex
)paren
)paren
op_eq
l_int|0
op_logical_or
id|u.r.wLength
OG
l_int|2
)paren
r_goto
id|do_stall
suffix:semicolon
r_if
c_cond
(paren
id|readl
(paren
op_amp
id|e-&gt;regs-&gt;ep_rsp
)paren
op_amp
(paren
l_int|1
op_lshift
id|SET_ENDPOINT_HALT
)paren
)paren
id|status
op_assign
id|__constant_cpu_to_le16
(paren
l_int|1
)paren
suffix:semicolon
r_else
id|status
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* don&squot;t bother with a request object! */
id|writel
(paren
l_int|0
comma
op_amp
id|dev-&gt;epregs
(braket
l_int|0
)braket
dot
id|ep_irqenb
)paren
suffix:semicolon
id|set_fifo_bytecount
(paren
id|ep
comma
id|u.r.wLength
)paren
suffix:semicolon
id|writel
(paren
id|status
comma
op_amp
id|dev-&gt;epregs
(braket
l_int|0
)braket
dot
id|ep_data
)paren
suffix:semicolon
id|allow_status
(paren
id|ep
)paren
suffix:semicolon
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;%s stat %02x&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|status
)paren
suffix:semicolon
r_goto
id|next_endpoints
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|USB_REQ_CLEAR_FEATURE
suffix:colon
(brace
r_struct
id|net2280_ep
op_star
id|e
suffix:semicolon
multiline_comment|/* hw handles device features */
r_if
c_cond
(paren
id|u.r.bRequestType
op_ne
id|USB_RECIP_ENDPOINT
)paren
r_goto
id|delegate
suffix:semicolon
r_if
c_cond
(paren
id|u.r.wIndex
op_ne
l_int|0
multiline_comment|/* HALT feature */
op_logical_or
id|u.r.wLength
op_ne
l_int|0
)paren
r_goto
id|do_stall
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e
op_assign
id|get_ep_by_addr
(paren
id|dev
comma
id|u.r.wIndex
)paren
)paren
op_eq
l_int|0
)paren
r_goto
id|do_stall
suffix:semicolon
id|clear_halt
(paren
id|e
)paren
suffix:semicolon
id|allow_status
(paren
id|ep
)paren
suffix:semicolon
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;%s clear halt&bslash;n&quot;
comma
id|ep-&gt;ep.name
)paren
suffix:semicolon
r_goto
id|next_endpoints
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|USB_REQ_SET_FEATURE
suffix:colon
(brace
r_struct
id|net2280_ep
op_star
id|e
suffix:semicolon
multiline_comment|/* hw handles device features */
r_if
c_cond
(paren
id|u.r.bRequestType
op_ne
id|USB_RECIP_ENDPOINT
)paren
r_goto
id|delegate
suffix:semicolon
r_if
c_cond
(paren
id|u.r.wIndex
op_ne
l_int|0
multiline_comment|/* HALT feature */
op_logical_or
id|u.r.wLength
op_ne
l_int|0
)paren
r_goto
id|do_stall
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e
op_assign
id|get_ep_by_addr
(paren
id|dev
comma
id|u.r.wIndex
)paren
)paren
op_eq
l_int|0
)paren
r_goto
id|do_stall
suffix:semicolon
id|set_halt
(paren
id|e
)paren
suffix:semicolon
id|allow_status
(paren
id|ep
)paren
suffix:semicolon
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;%s set halt&bslash;n&quot;
comma
id|ep-&gt;ep.name
)paren
suffix:semicolon
r_goto
id|next_endpoints
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|delegate
suffix:colon
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;setup %02x.%02x v%04x i%04x &quot;
l_string|&quot;ep_cfg %08x&bslash;n&quot;
comma
id|u.r.bRequestType
comma
id|u.r.bRequest
comma
id|u.r.wValue
comma
id|u.r.wIndex
comma
id|readl
(paren
op_amp
id|ep-&gt;regs-&gt;ep_cfg
)paren
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|tmp
op_assign
id|dev-&gt;driver-&gt;setup
(paren
op_amp
id|dev-&gt;gadget
comma
op_amp
id|u.r
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* stall ep0 on error */
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
id|do_stall
suffix:colon
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;req %02x.%02x protocol STALL; stat %d&bslash;n&quot;
comma
id|u.r.bRequestType
comma
id|u.r.bRequest
comma
id|tmp
)paren
suffix:semicolon
id|dev-&gt;protocol_stall
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* some in/out token irq should follow; maybe stall then.&n;&t;&t; * driver must queue a request (even zlp) or halt ep0&n;&t;&t; * before the host times out.&n;&t;&t; */
)brace
id|next_endpoints
suffix:colon
multiline_comment|/* endpoint data irq ? */
id|scratch
op_assign
id|stat
op_amp
l_int|0x7f
suffix:semicolon
id|stat
op_and_assign
op_complement
l_int|0x7f
suffix:semicolon
r_for
c_loop
(paren
id|num
op_assign
l_int|0
suffix:semicolon
id|scratch
suffix:semicolon
id|num
op_increment
)paren
(brace
id|u32
id|t
suffix:semicolon
multiline_comment|/* do this endpoint&squot;s FIFO and queue need tending? */
id|t
op_assign
l_int|1
op_lshift
id|num
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scratch
op_amp
id|t
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|scratch
op_xor_assign
id|t
suffix:semicolon
id|ep
op_assign
op_amp
id|dev-&gt;ep
(braket
id|num
)braket
suffix:semicolon
id|handle_ep_small
(paren
id|ep
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
)paren
id|DEBUG
(paren
id|dev
comma
l_string|&quot;unhandled irqstat0 %08x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
DECL|macro|DMA_INTERRUPTS
mdefine_line|#define DMA_INTERRUPTS ( &bslash;&n;&t;&t;  (1 &lt;&lt; DMA_D_INTERRUPT) &bslash;&n;&t;&t;| (1 &lt;&lt; DMA_C_INTERRUPT) &bslash;&n;&t;&t;| (1 &lt;&lt; DMA_B_INTERRUPT) &bslash;&n;&t;&t;| (1 &lt;&lt; DMA_A_INTERRUPT))
DECL|macro|PCI_ERROR_INTERRUPTS
mdefine_line|#define&t;PCI_ERROR_INTERRUPTS ( &bslash;&n;&t;&t;  (1 &lt;&lt; PCI_MASTER_ABORT_RECEIVED_INTERRUPT) &bslash;&n;&t;&t;| (1 &lt;&lt; PCI_TARGET_ABORT_RECEIVED_INTERRUPT) &bslash;&n;&t;&t;| (1 &lt;&lt; PCI_RETRY_ABORT_INTERRUPT))
DECL|function|handle_stat1_irqs
r_static
r_void
id|handle_stat1_irqs
(paren
r_struct
id|net2280
op_star
id|dev
comma
id|u32
id|stat
)paren
(brace
r_struct
id|net2280_ep
op_star
id|ep
suffix:semicolon
id|u32
id|tmp
comma
id|num
comma
id|scratch
suffix:semicolon
multiline_comment|/* after disconnect there&squot;s nothing else to do! */
id|tmp
op_assign
(paren
l_int|1
op_lshift
id|VBUS_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|ROOT_PORT_RESET_INTERRUPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|tmp
)paren
(brace
id|writel
(paren
id|tmp
comma
op_amp
id|dev-&gt;regs-&gt;irqstat1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|stat
op_amp
(paren
l_int|1
op_lshift
id|ROOT_PORT_RESET_INTERRUPT
)paren
)paren
op_ne
l_int|0
op_logical_or
(paren
id|readl
(paren
op_amp
id|dev-&gt;usb-&gt;usbctl
)paren
op_amp
(paren
l_int|1
op_lshift
id|VBUS_PIN
)paren
)paren
op_eq
l_int|0
)paren
op_logical_and
id|dev-&gt;gadget.speed
op_ne
id|USB_SPEED_UNKNOWN
)paren
(brace
id|DEBUG
(paren
id|dev
comma
l_string|&quot;disconnect %s&bslash;n&quot;
comma
id|dev-&gt;driver-&gt;driver.name
)paren
suffix:semicolon
id|stop_activity
(paren
id|dev
comma
id|dev-&gt;driver
)paren
suffix:semicolon
id|ep0_start
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|stat
op_and_assign
op_complement
id|tmp
suffix:semicolon
multiline_comment|/* vBUS can bounce ... one of many reasons to ignore the&n;&t;&t; * notion of hotplug events on bus connect/disconnect!&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|stat
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/* NOTE: we don&squot;t actually suspend the hardware; that starts to&n;&t; * interact with PCI power management, and needs something like a&n;&t; * controller-&gt;suspend() call to clear SUSPEND_REQUEST_INTERRUPT.&n;&t; * we shouldn&squot;t see resume interrupts.&n;&t; * for rev 0100, this also avoids erratum 0102.&n;&t; */
id|tmp
op_assign
(paren
l_int|1
op_lshift
id|SUSPEND_REQUEST_CHANGE_INTERRUPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;driver-&gt;suspend
)paren
id|dev-&gt;driver-&gt;suspend
(paren
op_amp
id|dev-&gt;gadget
)paren
suffix:semicolon
id|stat
op_and_assign
op_complement
id|tmp
suffix:semicolon
)brace
id|stat
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|SUSPEND_REQUEST_INTERRUPT
)paren
suffix:semicolon
multiline_comment|/* clear any other status/irqs */
r_if
c_cond
(paren
id|stat
)paren
id|writel
(paren
id|stat
comma
op_amp
id|dev-&gt;regs-&gt;irqstat1
)paren
suffix:semicolon
multiline_comment|/* some status we can just ignore */
id|stat
op_and_assign
op_complement
(paren
(paren
l_int|1
op_lshift
id|CONTROL_STATUS_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|RESUME_INTERRUPT
)paren
op_or
(paren
l_int|1
op_lshift
id|SOF_INTERRUPT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat
)paren
r_return
suffix:semicolon
singleline_comment|// DEBUG (dev, &quot;irqstat1 %08x&bslash;n&quot;, stat);
multiline_comment|/* DMA status, for ep-{a,b,c,d} */
id|scratch
op_assign
id|stat
op_amp
id|DMA_INTERRUPTS
suffix:semicolon
id|stat
op_and_assign
op_complement
id|DMA_INTERRUPTS
suffix:semicolon
id|scratch
op_rshift_assign
l_int|9
suffix:semicolon
r_for
c_loop
(paren
id|num
op_assign
l_int|0
suffix:semicolon
id|scratch
suffix:semicolon
id|num
op_increment
)paren
(brace
r_struct
id|net2280_dma_regs
op_star
id|dma
suffix:semicolon
id|tmp
op_assign
l_int|1
op_lshift
id|num
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|scratch
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|scratch
op_xor_assign
id|tmp
suffix:semicolon
id|ep
op_assign
op_amp
id|dev-&gt;ep
(braket
id|num
op_plus
l_int|1
)braket
suffix:semicolon
id|dma
op_assign
id|ep-&gt;dma
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma
)paren
r_continue
suffix:semicolon
multiline_comment|/* clear ep&squot;s dma status */
id|tmp
op_assign
id|readl
(paren
op_amp
id|dma-&gt;dmastat
)paren
suffix:semicolon
id|writel
(paren
id|tmp
comma
op_amp
id|dma-&gt;dmastat
)paren
suffix:semicolon
macro_line|#ifdef USE_DMA_CHAINING
multiline_comment|/* chaining should stop only on error (which?)&n;&t;&t; * or (stat0 codepath) short OUT transfer.&n;&t;&t; */
macro_line|#else
r_if
c_cond
(paren
(paren
id|tmp
op_amp
(paren
l_int|1
op_lshift
id|DMA_TRANSACTION_DONE_INTERRUPT
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|DEBUG
(paren
id|ep-&gt;dev
comma
l_string|&quot;%s no xact done? %08x&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|tmp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|stop_dma
(paren
id|ep-&gt;dma
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* OUT transfers terminate when the data from the&n;&t;&t; * host is in our memory.  Process whatever&squot;s done.&n;&t;&t; * On this path, we know transfer&squot;s last packet wasn&squot;t&n;&t;&t; * less than req-&gt;length. NAK_OUT_PACKETS may be set,&n;&t;&t; * or the FIFO may already be holding new packets.&n;&t;&t; *&n;&t;&t; * IN transfers can linger in the FIFO for a very&n;&t;&t; * long time ... we ignore that for now, accounting&n;&t;&t; * precisely (like PIO does) needs per-packet irqs&n;&t;&t; */
id|scan_dma_completions
(paren
id|ep
)paren
suffix:semicolon
multiline_comment|/* disable dma on inactive queues; else maybe restart */
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
(brace
macro_line|#ifdef USE_DMA_CHAINING
id|stop_dma
(paren
id|ep-&gt;dma
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|tmp
op_assign
id|readl
(paren
op_amp
id|dma-&gt;dmactl
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
(paren
l_int|1
op_lshift
id|DMA_SCATTER_GATHER_ENABLE
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|tmp
op_amp
(paren
l_int|1
op_lshift
id|DMA_ENABLE
)paren
)paren
op_eq
l_int|0
)paren
id|restart_dma
(paren
id|ep
)paren
suffix:semicolon
)brace
id|ep-&gt;irqs
op_increment
suffix:semicolon
)brace
multiline_comment|/* NOTE:  there are other PCI errors we might usefully notice.&n;&t; * if they appear very often, here&squot;s where to try recovering.&n;&t; */
r_if
c_cond
(paren
id|stat
op_amp
id|PCI_ERROR_INTERRUPTS
)paren
(brace
id|ERROR
(paren
id|dev
comma
l_string|&quot;pci dma error; stat %08x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
id|stat
op_and_assign
op_complement
id|PCI_ERROR_INTERRUPTS
suffix:semicolon
multiline_comment|/* these are fatal errors, but &quot;maybe&quot; they won&squot;t&n;&t;&t; * happen again ...&n;&t;&t; */
id|stop_activity
(paren
id|dev
comma
id|dev-&gt;driver
)paren
suffix:semicolon
id|ep0_start
(paren
id|dev
)paren
suffix:semicolon
id|stat
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
)paren
id|DEBUG
(paren
id|dev
comma
l_string|&quot;unhandled irqstat1 %08x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
DECL|function|net2280_irq
r_static
id|irqreturn_t
id|net2280_irq
(paren
r_int
id|irq
comma
r_void
op_star
id|_dev
comma
r_struct
id|pt_regs
op_star
id|r
)paren
(brace
r_struct
id|net2280
op_star
id|dev
op_assign
id|_dev
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* handle disconnect, dma, and more */
id|handle_stat1_irqs
(paren
id|dev
comma
id|readl
(paren
op_amp
id|dev-&gt;regs-&gt;irqstat1
)paren
)paren
suffix:semicolon
multiline_comment|/* control requests and PIO */
id|handle_stat0_irqs
(paren
id|dev
comma
id|readl
(paren
op_amp
id|dev-&gt;regs-&gt;irqstat0
)paren
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* tear down the binding between this driver and the pci device */
DECL|function|net2280_remove
r_static
r_void
id|net2280_remove
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|net2280
op_star
id|dev
op_assign
id|pci_get_drvdata
(paren
id|pdev
)paren
suffix:semicolon
multiline_comment|/* start with the driver above us */
r_if
c_cond
(paren
id|dev-&gt;driver
)paren
(brace
multiline_comment|/* should have been done already by driver model core */
id|WARN
(paren
id|dev
comma
l_string|&quot;pci remove, driver &squot;%s&squot; is still registered&bslash;n&quot;
comma
id|dev-&gt;driver-&gt;driver.name
)paren
suffix:semicolon
id|usb_gadget_unregister_driver
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
)brace
multiline_comment|/* then clean up the resources we allocated during probe() */
id|net2280_led_shutdown
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;requests
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;ep
(braket
id|i
)braket
dot
id|dummy
)paren
r_continue
suffix:semicolon
id|pci_pool_free
(paren
id|dev-&gt;requests
comma
id|dev-&gt;ep
(braket
id|i
)braket
dot
id|dummy
comma
id|dev-&gt;ep
(braket
id|i
)braket
dot
id|td_dma
)paren
suffix:semicolon
)brace
id|pci_pool_destroy
(paren
id|dev-&gt;requests
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;got_irq
)paren
id|free_irq
(paren
id|pdev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;regs
)paren
id|iounmap
(paren
id|dev-&gt;regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;region
)paren
id|release_mem_region
(paren
id|pci_resource_start
(paren
id|pdev
comma
l_int|0
)paren
comma
id|pci_resource_len
(paren
id|pdev
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;enabled
)paren
id|pci_disable_device
(paren
id|pdev
)paren
suffix:semicolon
id|device_remove_file
(paren
op_amp
id|pdev-&gt;dev
comma
op_amp
id|dev_attr_registers
)paren
suffix:semicolon
id|pci_set_drvdata
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|INFO
(paren
id|dev
comma
l_string|&quot;unbind from pci %s&bslash;n&quot;
comma
id|pdev-&gt;slot_name
)paren
suffix:semicolon
id|kfree
(paren
id|dev
)paren
suffix:semicolon
id|the_controller
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* wrap this driver around the specified device, but&n; * don&squot;t respond over USB until a gadget driver binds to us.&n; */
DECL|function|net2280_probe
r_static
r_int
id|net2280_probe
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|id
)paren
(brace
r_struct
id|net2280
op_star
id|dev
suffix:semicolon
r_int
r_int
id|resource
comma
id|len
suffix:semicolon
r_void
op_star
id|base
op_assign
l_int|0
suffix:semicolon
r_int
id|retval
comma
id|i
suffix:semicolon
r_char
id|buf
(braket
l_int|8
)braket
comma
op_star
id|bufp
suffix:semicolon
multiline_comment|/* if you want to support more than one controller in a system,&n;&t; * usb_gadget_driver_{register,unregister}() must change.&n;&t; */
r_if
c_cond
(paren
id|the_controller
)paren
(brace
id|WARN
(paren
id|the_controller
comma
l_string|&quot;ignoring %s&bslash;n&quot;
comma
id|pdev-&gt;slot_name
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* alloc, and start init */
id|dev
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|dev
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
op_star
id|dev
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|dev-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|dev-&gt;gadget.ops
op_assign
op_amp
id|net2280_ops
suffix:semicolon
id|strcpy
(paren
id|dev-&gt;gadget.dev.bus_id
comma
id|pdev-&gt;slot_name
)paren
suffix:semicolon
id|strcpy
(paren
id|dev-&gt;gadget.dev.name
comma
id|pdev-&gt;dev.name
)paren
suffix:semicolon
id|dev-&gt;gadget.dev.parent
op_assign
op_amp
id|pdev-&gt;dev
suffix:semicolon
id|dev-&gt;gadget.dev.dma_mask
op_assign
id|pdev-&gt;dev.dma_mask
suffix:semicolon
id|dev-&gt;gadget.name
op_assign
id|driver_name
suffix:semicolon
multiline_comment|/* now all the pci goodies ... */
r_if
c_cond
(paren
id|pci_enable_device
(paren
id|pdev
)paren
OL
l_int|0
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|dev-&gt;enabled
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* BAR 0 holds all the registers&n;&t; * BAR 1 is 8051 memory; unused here (note erratum 0103)&n;&t; * BAR 2 is fifo memory; unused here&n;&t; */
id|resource
op_assign
id|pci_resource_start
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|len
op_assign
id|pci_resource_len
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
(paren
id|resource
comma
id|len
comma
id|driver_name
)paren
)paren
(brace
id|DEBUG
(paren
id|dev
comma
l_string|&quot;controller already in use&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|dev-&gt;region
op_assign
l_int|1
suffix:semicolon
id|base
op_assign
id|ioremap_nocache
(paren
id|resource
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|NULL
)paren
(brace
id|DEBUG
(paren
id|dev
comma
l_string|&quot;can&squot;t map memory&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|dev-&gt;regs
op_assign
(paren
r_struct
id|net2280_regs
op_star
)paren
id|base
suffix:semicolon
id|dev-&gt;usb
op_assign
(paren
r_struct
id|net2280_usb_regs
op_star
)paren
(paren
id|base
op_plus
l_int|0x0080
)paren
suffix:semicolon
id|dev-&gt;pci
op_assign
(paren
r_struct
id|net2280_pci_regs
op_star
)paren
(paren
id|base
op_plus
l_int|0x0100
)paren
suffix:semicolon
id|dev-&gt;dma
op_assign
(paren
r_struct
id|net2280_dma_regs
op_star
)paren
(paren
id|base
op_plus
l_int|0x0180
)paren
suffix:semicolon
id|dev-&gt;dep
op_assign
(paren
r_struct
id|net2280_dep_regs
op_star
)paren
(paren
id|base
op_plus
l_int|0x0200
)paren
suffix:semicolon
id|dev-&gt;epregs
op_assign
(paren
r_struct
id|net2280_ep_regs
op_star
)paren
(paren
id|base
op_plus
l_int|0x0300
)paren
suffix:semicolon
multiline_comment|/* put into initial config, link up all endpoints */
id|usb_reset
(paren
id|dev
)paren
suffix:semicolon
id|usb_reinit
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* irq setup after old hardware is cleaned up */
r_if
c_cond
(paren
op_logical_neg
id|pdev-&gt;irq
)paren
(brace
id|ERROR
(paren
id|dev
comma
l_string|&quot;No IRQ.  Check PCI setup!&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#ifndef __sparc__
id|snprintf
(paren
id|buf
comma
r_sizeof
id|buf
comma
l_string|&quot;%d&quot;
comma
id|pdev-&gt;irq
)paren
suffix:semicolon
id|bufp
op_assign
id|buf
suffix:semicolon
macro_line|#else
id|bufp
op_assign
id|__irq_itoa
c_func
(paren
id|pdev-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|request_irq
(paren
id|pdev-&gt;irq
comma
id|net2280_irq
comma
id|SA_SHIRQ
comma
id|driver_name
comma
id|dev
)paren
op_ne
l_int|0
)paren
(brace
id|ERROR
(paren
id|dev
comma
l_string|&quot;request interrupt %s failed&bslash;n&quot;
comma
id|bufp
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|dev-&gt;got_irq
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* DMA setup */
id|dev-&gt;requests
op_assign
id|pci_pool_create
(paren
l_string|&quot;requests&quot;
comma
id|pdev
comma
r_sizeof
(paren
r_struct
id|net2280_dma
)paren
comma
l_int|0
multiline_comment|/* no alignment requirements */
comma
l_int|0
multiline_comment|/* or page-crossing issues */
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;requests
)paren
(brace
id|DEBUG
(paren
id|dev
comma
l_string|&quot;can&squot;t get request pool&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|net2280_dma
op_star
id|td
suffix:semicolon
id|td
op_assign
id|pci_pool_alloc
(paren
id|dev-&gt;requests
comma
id|GFP_KERNEL
comma
op_amp
id|dev-&gt;ep
(braket
id|i
)braket
dot
id|td_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
(brace
id|DEBUG
(paren
id|dev
comma
l_string|&quot;can&squot;t get dummy %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|td-&gt;dmacount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not VALID */
id|td-&gt;dmaaddr
op_assign
id|__constant_cpu_to_le32
(paren
id|DMA_ADDR_INVALID
)paren
suffix:semicolon
id|dev-&gt;ep
(braket
id|i
)braket
dot
id|dummy
op_assign
id|td
suffix:semicolon
)brace
multiline_comment|/* enable lower-overhead pci memory bursts during DMA */
id|writel
(paren
(paren
l_int|1
op_lshift
id|PCI_RETRY_ABORT_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|DMA_MEMORY_WRITE_AND_INVALIDATE_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|DMA_READ_MULTIPLE_ENABLE
)paren
op_or
(paren
l_int|1
op_lshift
id|DMA_READ_LINE_ENABLE
)paren
comma
op_amp
id|dev-&gt;pci-&gt;pcimstctl
)paren
suffix:semicolon
multiline_comment|/* erratum 0115 shouldn&squot;t appear: Linux inits PCI_LATENCY_TIMER */
id|pci_set_master
(paren
id|pdev
)paren
suffix:semicolon
id|pci_set_mwi
(paren
id|pdev
)paren
suffix:semicolon
multiline_comment|/* ... also flushes any posted pci writes */
id|dev-&gt;chiprev
op_assign
id|get_idx_reg
(paren
id|dev-&gt;regs
comma
id|REG_CHIPREV
)paren
op_amp
l_int|0xffff
suffix:semicolon
multiline_comment|/* done */
id|pci_set_drvdata
(paren
id|pdev
comma
id|dev
)paren
suffix:semicolon
id|INFO
(paren
id|dev
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|driver_desc
)paren
suffix:semicolon
id|INFO
(paren
id|dev
comma
l_string|&quot;irq %s, pci mem %p, chip rev %04x&bslash;n&quot;
comma
id|bufp
comma
id|base
comma
id|dev-&gt;chiprev
)paren
suffix:semicolon
id|bufp
op_assign
id|DRIVER_VERSION
macro_line|#ifndef USE_DMA_CHAINING
l_string|&quot; (no dma chain)&quot;
macro_line|#endif
macro_line|#ifdef NET2280_DMA_OUT_WORKAROUND
l_string|&quot; (no dma out)&quot;
macro_line|#endif
suffix:semicolon
id|INFO
(paren
id|dev
comma
l_string|&quot;version: %s&bslash;n&quot;
comma
id|bufp
)paren
suffix:semicolon
id|the_controller
op_assign
id|dev
suffix:semicolon
id|device_create_file
(paren
op_amp
id|pdev-&gt;dev
comma
op_amp
id|dev_attr_registers
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|dev
)paren
id|net2280_remove
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|variable|pci_ids
r_static
r_struct
id|pci_device_id
id|__devinitdata
id|pci_ids
(braket
)braket
op_assign
(brace
(brace
dot
r_class
op_assign
(paren
(paren
id|PCI_CLASS_SERIAL_USB
op_lshift
l_int|8
)paren
op_or
l_int|0xfe
)paren
comma
dot
id|class_mask
op_assign
op_complement
l_int|0
comma
dot
id|vendor
op_assign
l_int|0x17cc
comma
dot
id|device
op_assign
l_int|0x2280
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
)brace
comma
(brace
multiline_comment|/* end: all zeroes */
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|pci
comma
id|pci_ids
)paren
suffix:semicolon
multiline_comment|/* pci driver glue; this is a &quot;new style&quot; PCI driver module */
DECL|variable|net2280_pci_driver
r_static
r_struct
id|pci_driver
id|net2280_pci_driver
op_assign
(brace
dot
id|name
op_assign
(paren
r_char
op_star
)paren
id|driver_name
comma
dot
id|id_table
op_assign
id|pci_ids
comma
dot
id|probe
op_assign
id|net2280_probe
comma
dot
id|remove
op_assign
id|net2280_remove
comma
multiline_comment|/* FIXME add power management support */
)brace
suffix:semicolon
DECL|variable|DRIVER_DESC
id|MODULE_DESCRIPTION
(paren
id|DRIVER_DESC
)paren
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;David Brownell&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|function|init
r_static
r_int
id|__init
id|init
(paren
r_void
)paren
(brace
r_return
id|pci_module_init
(paren
op_amp
id|net2280_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|init
id|module_init
(paren
id|init
)paren
suffix:semicolon
DECL|function|cleanup
r_static
r_void
id|__exit
id|cleanup
(paren
r_void
)paren
(brace
id|pci_unregister_driver
(paren
op_amp
id|net2280_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|cleanup
id|module_exit
(paren
id|cleanup
)paren
suffix:semicolon
eof
