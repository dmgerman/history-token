multiline_comment|/*&n; * g_serial.c -- USB gadget serial driver&n; *&n; * Copyright 2003 (C) Al Borchers (alborchers@steinerpoint.com)&n; *&n; * This code is based in part on the Gadget Zero driver, which&n; * is Copyright (C) 2003 by David Brownell, all rights reserved.&n; *&n; * This code also borrows from usbserial.c, which is&n; * Copyright (C) 1999 - 2002 Greg Kroah-Hartman (greg@kroah.com)&n; * Copyright (C) 2000 Peter Berger (pberger@brimson.com)&n; * Copyright (C) 2000 Al Borchers (alborchers@steinerpoint.com)&n; *&n; * This software is distributed under the terms of the GNU General&n; * Public License (&quot;GPL&quot;) as published by the Free Software Foundation,&n; * either version 2 of that License or (at your option) any later version.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/uts.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/usb_ch9.h&gt;
macro_line|#include &lt;linux/usb_gadget.h&gt;
multiline_comment|/* Wait Cond */
DECL|macro|__wait_cond_interruptible
mdefine_line|#define __wait_cond_interruptible(wq, condition, lock, flags, ret)&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;wait_queue_t __wait;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;init_waitqueue_entry(&amp;__wait, current);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;add_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&t;&bslash;&n;&t;for (;;) {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;set_current_state(TASK_INTERRUPTIBLE);&t;&t;&t;&bslash;&n;&t;&t;if (condition)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!signal_pending(current)) {&t;&t;&t;&t;&bslash;&n;&t;&t;&t;spin_unlock_irqrestore(lock, flags);&t;&t;&bslash;&n;&t;&t;&t;schedule();&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;spin_lock_irqsave(lock, flags);&t;&t;&t;&bslash;&n;&t;&t;&t;continue;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;ret = -ERESTARTSYS;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;current-&gt;state = TASK_RUNNING;&t;&t;&t;&t;&t;&bslash;&n;&t;remove_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|wait_cond_interruptible
mdefine_line|#define wait_cond_interruptible(wq, condition, lock, flags)&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int __ret = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(condition))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__wait_cond_interruptible(wq, condition, lock, flags,&t;&bslash;&n;&t;&t;&t;&t;&t;&t;__ret);&t;&t;&t;&bslash;&n;&t;__ret;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|__wait_cond_interruptible_timeout
mdefine_line|#define __wait_cond_interruptible_timeout(wq, condition, lock, flags, &t;&bslash;&n;&t;&t;&t;&t;&t;&t;timeout, ret)&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;signed long __timeout = timeout;&t;&t;&t;&t;&bslash;&n;&t;wait_queue_t __wait;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;init_waitqueue_entry(&amp;__wait, current);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;add_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&t;&bslash;&n;&t;for (;;) {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;set_current_state(TASK_INTERRUPTIBLE);&t;&t;&t;&bslash;&n;&t;&t;if (__timeout == 0)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (condition)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!signal_pending(current)) {&t;&t;&t;&t;&bslash;&n;&t;&t;&t;spin_unlock_irqrestore(lock, flags);&t;&t;&bslash;&n;&t;&t;&t;__timeout = schedule_timeout(__timeout);&t;&bslash;&n;&t;&t;&t;spin_lock_irqsave(lock, flags);&t;&t;&t;&bslash;&n;&t;&t;&t;continue;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;ret = -ERESTARTSYS;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;current-&gt;state = TASK_RUNNING;&t;&t;&t;&t;&t;&bslash;&n;&t;remove_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|wait_cond_interruptible_timeout
mdefine_line|#define wait_cond_interruptible_timeout(wq, condition, lock, flags,&t;&bslash;&n;&t;&t;&t;&t;&t;&t;timeout)&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int __ret = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(condition))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__wait_cond_interruptible_timeout(wq, condition, lock,&t;&bslash;&n;&t;&t;&t;&t;&t;&t;flags, timeout, __ret);&t;&bslash;&n;&t;__ret;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
multiline_comment|/* Defines */
DECL|macro|GS_VERSION_STR
mdefine_line|#define GS_VERSION_STR&t;&t;&t;&quot;v0.1&quot;
DECL|macro|GS_VERSION_NUM
mdefine_line|#define GS_VERSION_NUM&t;&t;&t;0x0001
DECL|macro|GS_LONG_NAME
mdefine_line|#define GS_LONG_NAME&t;&t;&t;&quot;Gadget Serial&quot;
DECL|macro|GS_SHORT_NAME
mdefine_line|#define GS_SHORT_NAME&t;&t;&t;&quot;g_serial&quot;
DECL|macro|GS_MAJOR
mdefine_line|#define GS_MAJOR&t;&t;&t;127
DECL|macro|GS_MINOR_START
mdefine_line|#define GS_MINOR_START&t;&t;&t;0
DECL|macro|GS_NUM_PORTS
mdefine_line|#define GS_NUM_PORTS&t;&t;&t;16
DECL|macro|GS_NUM_CONFIGS
mdefine_line|#define GS_NUM_CONFIGS&t;&t;&t;1
DECL|macro|GS_NO_CONFIG_ID
mdefine_line|#define GS_NO_CONFIG_ID&t;&t;&t;0
DECL|macro|GS_BULK_CONFIG_ID
mdefine_line|#define GS_BULK_CONFIG_ID&t;&t;2
DECL|macro|GS_NUM_INTERFACES
mdefine_line|#define GS_NUM_INTERFACES&t;&t;1
DECL|macro|GS_INTERFACE_ID
mdefine_line|#define GS_INTERFACE_ID&t;&t;&t;0
DECL|macro|GS_ALT_INTERFACE_ID
mdefine_line|#define GS_ALT_INTERFACE_ID&t;&t;0
DECL|macro|GS_NUM_ENDPOINTS
mdefine_line|#define GS_NUM_ENDPOINTS&t;&t;2
DECL|macro|GS_MAX_DESC_LEN
mdefine_line|#define GS_MAX_DESC_LEN&t;&t;&t;256
DECL|macro|GS_DEFAULT_READ_Q_SIZE
mdefine_line|#define GS_DEFAULT_READ_Q_SIZE&t;&t;32
DECL|macro|GS_DEFAULT_WRITE_Q_SIZE
mdefine_line|#define GS_DEFAULT_WRITE_Q_SIZE&t;&t;32
DECL|macro|GS_DEFAULT_WRITE_BUF_SIZE
mdefine_line|#define GS_DEFAULT_WRITE_BUF_SIZE&t;8192
DECL|macro|GS_TMP_BUF_SIZE
mdefine_line|#define GS_TMP_BUF_SIZE&t;&t;&t;8192
DECL|macro|GS_CLOSE_TIMEOUT
mdefine_line|#define GS_CLOSE_TIMEOUT&t;&t;15
multiline_comment|/* debug macro */
macro_line|#if G_SERIAL_DEBUG
DECL|variable|debug
r_static
r_int
id|debug
op_assign
id|G_SERIAL_DEBUG
suffix:semicolon
macro_line|#else
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#if G_SERIAL_DEBUG
DECL|macro|gs_debug
mdefine_line|#define gs_debug(format, arg...) &bslash;&n;&t;do { if (debug) printk(KERN_DEBUG format, ## arg); } while(0)
DECL|macro|gs_debug_level
mdefine_line|#define gs_debug_level(level, format, arg...) &bslash;&n;&t;do { if (debug&gt;=level) printk(KERN_DEBUG format, ## arg); } while(0)
macro_line|#else
DECL|macro|gs_debug
mdefine_line|#define gs_debug(format, arg...) &bslash;&n;&t;do { } while(0)
DECL|macro|gs_debug_level
mdefine_line|#define gs_debug_level(level, format, arg...) &bslash;&n;&t;do { } while(0)
macro_line|#endif /* G_SERIAL_DEBUG */
multiline_comment|/* USB Controllers */
multiline_comment|/*&n; * NetChip 2280, PCI based.&n; *&n; * This has half a dozen configurable endpoints, four with dedicated&n; * DMA channels to manage their FIFOs.  It supports high speed.&n; * Those endpoints can be arranged in any desired configuration.&n; */
macro_line|#ifdef&t;CONFIG_USB_GADGET_NET2280
DECL|macro|CHIP
mdefine_line|#define CHIP&t;&t;&t;&t;&quot;net2280&quot;
DECL|macro|EP0_MAXPACKET
mdefine_line|#define EP0_MAXPACKET&t;&t;&t;64
DECL|variable|EP_OUT_NAME
r_static
r_const
r_char
id|EP_OUT_NAME
(braket
)braket
op_assign
l_string|&quot;ep-a&quot;
suffix:semicolon
DECL|macro|EP_OUT_NUM
mdefine_line|#define EP_OUT_NUM&t;&t;&t;2
DECL|variable|EP_IN_NAME
r_static
r_const
r_char
id|EP_IN_NAME
(braket
)braket
op_assign
l_string|&quot;ep-b&quot;
suffix:semicolon
DECL|macro|EP_IN_NUM
mdefine_line|#define EP_IN_NUM&t;&t;&t;2
DECL|macro|HIGHSPEED
mdefine_line|#define HIGHSPEED
DECL|macro|SELFPOWER
mdefine_line|#define SELFPOWER&t;&t;&t;USB_CONFIG_ATT_SELFPOWER
r_extern
r_int
id|net2280_set_fifo_mode
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
r_int
id|mode
)paren
suffix:semicolon
DECL|function|hw_optimize
r_static
r_inline
r_void
id|hw_optimize
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
multiline_comment|/* we can have bigger ep-a/ep-b fifos (2KB each, 4 packets&n;&t; * for highspeed bulk) because we&squot;re not using ep-c/ep-d.&n;&t; */
id|net2280_set_fifo_mode
(paren
id|gadget
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Dummy_hcd, software-based loopback controller.&n; *&n; * This imitates the abilities of the NetChip 2280, so we will use&n; * the same configuration.&n; */
macro_line|#ifdef&t;CONFIG_USB_GADGET_DUMMY_HCD
DECL|macro|CHIP
mdefine_line|#define CHIP&t;&t;&t;&t;&quot;dummy&quot;
DECL|macro|EP0_MAXPACKET
mdefine_line|#define EP0_MAXPACKET&t;&t;&t;64
DECL|variable|EP_OUT_NAME
r_static
r_const
r_char
id|EP_OUT_NAME
(braket
)braket
op_assign
l_string|&quot;ep-a&quot;
suffix:semicolon
DECL|macro|EP_OUT_NUM
mdefine_line|#define EP_OUT_NUM&t;&t;&t;2
DECL|variable|EP_IN_NAME
r_static
r_const
r_char
id|EP_IN_NAME
(braket
)braket
op_assign
l_string|&quot;ep-b&quot;
suffix:semicolon
DECL|macro|EP_IN_NUM
mdefine_line|#define EP_IN_NUM&t;&t;&t;2
DECL|macro|HIGHSPEED
mdefine_line|#define HIGHSPEED
DECL|macro|SELFPOWER
mdefine_line|#define SELFPOWER&t;&t;&t;USB_CONFIG_ATT_SELFPOWER
multiline_comment|/* no hw optimizations to apply */
DECL|macro|hw_optimize
mdefine_line|#define hw_optimize(g)&t;&t;&t;do {} while (0)
macro_line|#endif
multiline_comment|/*&n; * PXA-2xx UDC:  widely used in second gen Linux-capable PDAs.&n; *&n; * This has fifteen fixed-function full speed endpoints, and it&n; * can support all USB transfer types.&n; *&n; * These supports three or four configurations, with fixed numbers.&n; * The hardware interprets SET_INTERFACE, net effect is that you&n; * can&squot;t use altsettings or reset the interfaces independently.&n; * So stick to a single interface.&n; */
macro_line|#ifdef&t;CONFIG_USB_GADGET_PXA2XX
DECL|macro|CHIP
mdefine_line|#define CHIP&t;&t;&t;&t;&quot;pxa2xx&quot;
DECL|macro|EP0_MAXPACKET
mdefine_line|#define EP0_MAXPACKET&t;&t;&t;16
DECL|variable|EP_OUT_NAME
r_static
r_const
r_char
id|EP_OUT_NAME
(braket
)braket
op_assign
l_string|&quot;ep2out-bulk&quot;
suffix:semicolon
DECL|macro|EP_OUT_NUM
mdefine_line|#define EP_OUT_NUM&t;&t;&t;2
DECL|variable|EP_IN_NAME
r_static
r_const
r_char
id|EP_IN_NAME
(braket
)braket
op_assign
l_string|&quot;ep1in-bulk&quot;
suffix:semicolon
DECL|macro|EP_IN_NUM
mdefine_line|#define EP_IN_NUM&t;&t;&t;1
DECL|macro|SELFPOWER
mdefine_line|#define SELFPOWER &t;&t;&t;USB_CONFIG_ATT_SELFPOWER
multiline_comment|/* no hw optimizations to apply */
DECL|macro|hw_optimize
mdefine_line|#define hw_optimize(g)&t;&t;&t;do {} while (0)
macro_line|#endif
multiline_comment|/*&n; * SA-1100 UDC:  widely used in first gen Linux-capable PDAs.&n; *&n; * This has only two fixed function endpoints, which can only&n; * be used for bulk (or interrupt) transfers.  (Plus control.)&n; *&n; * Since it can&squot;t flush its TX fifos without disabling the UDC,&n; * the current configuration or altsettings can&squot;t change except&n; * in special situations.  So this is a case of &quot;choose it right&n; * during enumeration&quot; ...&n; */
macro_line|#ifdef&t;CONFIG_USB_GADGET_SA1100
DECL|macro|CHIP
mdefine_line|#define CHIP&t;&t;&t;&t;&quot;sa1100&quot;
DECL|macro|EP0_MAXPACKET
mdefine_line|#define EP0_MAXPACKET&t;&t;&t;8
DECL|variable|EP_OUT_NAME
r_static
r_const
r_char
id|EP_OUT_NAME
(braket
)braket
op_assign
l_string|&quot;ep1out-bulk&quot;
suffix:semicolon
DECL|macro|EP_OUT_NUM
mdefine_line|#define EP_OUT_NUM&t;&t;&t;1
DECL|variable|EP_IN_NAME
r_static
r_const
r_char
id|EP_IN_NAME
(braket
)braket
op_assign
l_string|&quot;ep2in-bulk&quot;
suffix:semicolon
DECL|macro|EP_IN_NUM
mdefine_line|#define EP_IN_NUM&t;&t;&t;2
DECL|macro|SELFPOWER
mdefine_line|#define SELFPOWER&t;&t;&t;USB_CONFIG_ATT_SELFPOWER
multiline_comment|/* no hw optimizations to apply */
DECL|macro|hw_optimize
mdefine_line|#define hw_optimize(g)&t;&t;&t;do {} while (0)
macro_line|#endif
multiline_comment|/*&n; * Toshiba TC86C001 (&quot;Goku-S&quot;) UDC&n; *&n; * This has three semi-configurable full speed bulk/interrupt endpoints.&n; */
macro_line|#ifdef&t;CONFIG_USB_GADGET_GOKU
DECL|macro|CHIP
mdefine_line|#define CHIP&t;&t;&t;&t;&quot;goku&quot;
DECL|macro|DRIVER_VERSION_NUM
mdefine_line|#define DRIVER_VERSION_NUM&t;&t;0x0116
DECL|macro|EP0_MAXPACKET
mdefine_line|#define EP0_MAXPACKET&t;&t;&t;8
DECL|variable|EP_OUT_NAME
r_static
r_const
r_char
id|EP_OUT_NAME
(braket
)braket
op_assign
l_string|&quot;ep1-bulk&quot;
suffix:semicolon
DECL|macro|EP_OUT_NUM
mdefine_line|#define EP_OUT_NUM&t;&t;&t;1
DECL|variable|EP_IN_NAME
r_static
r_const
r_char
id|EP_IN_NAME
(braket
)braket
op_assign
l_string|&quot;ep2-bulk&quot;
suffix:semicolon
DECL|macro|EP_IN_NUM
mdefine_line|#define EP_IN_NUM&t;&t;&t;2
DECL|macro|SELFPOWER
mdefine_line|#define SELFPOWER&t;&t;&t;USB_CONFIG_ATT_SELFPOWER
multiline_comment|/* no hw optimizations to apply */
DECL|macro|hw_optimize
mdefine_line|#define hw_optimize(g)&t;&t;&t;do {} while (0)
macro_line|#endif
multiline_comment|/*&n; * USB Controller Defaults&n; */
macro_line|#ifndef EP0_MAXPACKET
macro_line|#error Configure some USB peripheral controller for g_serial!
macro_line|#endif
macro_line|#ifndef SELFPOWER
multiline_comment|/* default: say we rely on bus power */
DECL|macro|SELFPOWER
mdefine_line|#define SELFPOWER   &t;&t;&t;0
multiline_comment|/* else value must be USB_CONFIG_ATT_SELFPOWER */
macro_line|#endif
macro_line|#ifndef&t;MAX_USB_POWER
multiline_comment|/* any hub supports this steady state bus power consumption */
DECL|macro|MAX_USB_POWER
mdefine_line|#define MAX_USB_POWER&t;&t;&t;100&t;/* mA */
macro_line|#endif
macro_line|#ifndef&t;WAKEUP
multiline_comment|/* default: this driver won&squot;t do remote wakeup */
DECL|macro|WAKEUP
mdefine_line|#define WAKEUP&t;&t;&t;&t;0
multiline_comment|/* else value must be USB_CONFIG_ATT_WAKEUP */
macro_line|#endif
multiline_comment|/* Thanks to NetChip Technologies for donating this product ID.&n; *&n; * DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!&n; * Instead:  allocate your own, using normal USB-IF procedures.&n; */
DECL|macro|GS_VENDOR_ID
mdefine_line|#define GS_VENDOR_ID&t;0x0525&t;&t;/* NetChip */
DECL|macro|GS_PRODUCT_ID
mdefine_line|#define GS_PRODUCT_ID&t;0xa4a6&t;&t;/* Linux-USB Serial Gadget */
multiline_comment|/* Structures */
r_struct
id|gs_dev
suffix:semicolon
multiline_comment|/* circular buffer */
DECL|struct|gs_buf
r_struct
id|gs_buf
(brace
DECL|member|buf_size
r_int
r_int
id|buf_size
suffix:semicolon
DECL|member|buf_buf
r_char
op_star
id|buf_buf
suffix:semicolon
DECL|member|buf_get
r_char
op_star
id|buf_get
suffix:semicolon
DECL|member|buf_put
r_char
op_star
id|buf_put
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* list of requests */
DECL|struct|gs_req_entry
r_struct
id|gs_req_entry
(brace
DECL|member|re_entry
r_struct
id|list_head
id|re_entry
suffix:semicolon
DECL|member|re_req
r_struct
id|usb_request
op_star
id|re_req
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* the port structure holds info for each port, one for each minor number */
DECL|struct|gs_port
r_struct
id|gs_port
(brace
DECL|member|port_dev
r_struct
id|gs_dev
op_star
id|port_dev
suffix:semicolon
multiline_comment|/* pointer to device struct */
DECL|member|port_tty
r_struct
id|tty_struct
op_star
id|port_tty
suffix:semicolon
multiline_comment|/* pointer to tty struct */
DECL|member|port_lock
id|spinlock_t
id|port_lock
suffix:semicolon
DECL|member|port_num
r_int
id|port_num
suffix:semicolon
DECL|member|port_open_count
r_int
id|port_open_count
suffix:semicolon
DECL|member|port_in_use
r_int
id|port_in_use
suffix:semicolon
multiline_comment|/* open/close in progress */
DECL|member|port_write_wait
id|wait_queue_head_t
id|port_write_wait
suffix:semicolon
multiline_comment|/* waiting to write */
DECL|member|port_write_buf
r_struct
id|gs_buf
op_star
id|port_write_buf
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* the device structure holds info for the USB device */
DECL|struct|gs_dev
r_struct
id|gs_dev
(brace
DECL|member|dev_gadget
r_struct
id|usb_gadget
op_star
id|dev_gadget
suffix:semicolon
multiline_comment|/* gadget device pointer */
DECL|member|dev_lock
id|spinlock_t
id|dev_lock
suffix:semicolon
multiline_comment|/* lock for set/reset config */
DECL|member|dev_config
r_int
id|dev_config
suffix:semicolon
multiline_comment|/* configuration number */
DECL|member|dev_in_ep
r_struct
id|usb_ep
op_star
id|dev_in_ep
suffix:semicolon
multiline_comment|/* address of in endpoint */
DECL|member|dev_out_ep
r_struct
id|usb_ep
op_star
id|dev_out_ep
suffix:semicolon
multiline_comment|/* address of out endpoint */
DECL|member|dev_ctrl_req
r_struct
id|usb_request
op_star
id|dev_ctrl_req
suffix:semicolon
multiline_comment|/* control request */
DECL|member|dev_req_list
r_struct
id|list_head
id|dev_req_list
suffix:semicolon
multiline_comment|/* list of write requests */
DECL|member|dev_sched_port
r_int
id|dev_sched_port
suffix:semicolon
multiline_comment|/* round robin port scheduled */
DECL|member|dev_port
r_struct
id|gs_port
op_star
id|dev_port
(braket
id|GS_NUM_PORTS
)braket
suffix:semicolon
multiline_comment|/* the ports */
)brace
suffix:semicolon
multiline_comment|/* Functions */
multiline_comment|/* module */
r_static
r_int
id|__init
id|gs_module_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|__exit
id|gs_module_exit
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* tty driver */
r_static
r_int
id|gs_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_void
id|gs_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|gs_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|gs_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
suffix:semicolon
r_static
r_void
id|gs_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|gs_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|gs_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|gs_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|gs_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|gs_break
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|break_state
)paren
suffix:semicolon
r_static
r_int
id|gs_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|gs_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old
)paren
suffix:semicolon
r_static
r_int
id|gs_send
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|gs_send_packet
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
comma
r_char
op_star
id|packet
comma
r_int
r_int
id|size
)paren
suffix:semicolon
r_static
r_int
id|gs_recv_packet
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
comma
r_char
op_star
id|packet
comma
r_int
r_int
id|size
)paren
suffix:semicolon
r_static
r_void
id|gs_read_complete
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
suffix:semicolon
r_static
r_void
id|gs_write_complete
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
suffix:semicolon
multiline_comment|/* gadget driver */
r_static
r_int
id|gs_bind
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
suffix:semicolon
r_static
r_void
id|gs_unbind
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
suffix:semicolon
r_static
r_int
id|gs_setup
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
r_const
r_struct
id|usb_ctrlrequest
op_star
id|ctrl
)paren
suffix:semicolon
r_static
r_void
id|gs_setup_complete
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
suffix:semicolon
r_static
r_void
id|gs_disconnect
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
suffix:semicolon
r_static
r_int
id|gs_set_config
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
comma
r_int
id|config
)paren
suffix:semicolon
r_static
r_void
id|gs_reset_config
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|gs_build_config_desc
c_func
(paren
id|u8
op_star
id|buf
comma
r_enum
id|usb_device_speed
id|speed
comma
id|u8
id|type
comma
r_int
r_int
id|index
)paren
suffix:semicolon
r_static
r_struct
id|usb_request
op_star
id|gs_alloc_req
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_int
r_int
id|len
comma
r_int
id|kmalloc_flags
)paren
suffix:semicolon
r_static
r_void
id|gs_free_req
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
suffix:semicolon
r_static
r_struct
id|gs_req_entry
op_star
id|gs_alloc_req_entry
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_int
id|len
comma
r_int
id|kmalloc_flags
)paren
suffix:semicolon
r_static
r_void
id|gs_free_req_entry
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|gs_req_entry
op_star
id|req
)paren
suffix:semicolon
r_static
r_int
id|gs_alloc_ports
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
comma
r_int
id|kmalloc_flags
)paren
suffix:semicolon
r_static
r_void
id|gs_free_ports
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* circular buffer */
r_static
r_struct
id|gs_buf
op_star
id|gs_buf_alloc
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|kmalloc_flags
)paren
suffix:semicolon
r_static
r_void
id|gs_buf_free
c_func
(paren
r_struct
id|gs_buf
op_star
id|gb
)paren
suffix:semicolon
r_static
r_void
id|gs_buf_clear
c_func
(paren
r_struct
id|gs_buf
op_star
id|gb
)paren
suffix:semicolon
r_static
r_int
r_int
id|gs_buf_data_avail
c_func
(paren
r_struct
id|gs_buf
op_star
id|gb
)paren
suffix:semicolon
r_static
r_int
r_int
id|gs_buf_space_avail
c_func
(paren
r_struct
id|gs_buf
op_star
id|gb
)paren
suffix:semicolon
r_static
r_int
r_int
id|gs_buf_put
c_func
(paren
r_struct
id|gs_buf
op_star
id|gb
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
r_int
id|gs_buf_get
c_func
(paren
r_struct
id|gs_buf
op_star
id|gb
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
suffix:semicolon
multiline_comment|/* Globals */
DECL|variable|gs_device
r_static
r_struct
id|gs_dev
op_star
id|gs_device
suffix:semicolon
DECL|variable|gs_open_close_sem
r_static
r_struct
id|semaphore
id|gs_open_close_sem
(braket
id|GS_NUM_PORTS
)braket
suffix:semicolon
DECL|variable|read_q_size
r_static
r_int
r_int
id|read_q_size
op_assign
id|GS_DEFAULT_READ_Q_SIZE
suffix:semicolon
DECL|variable|write_q_size
r_static
r_int
r_int
id|write_q_size
op_assign
id|GS_DEFAULT_WRITE_Q_SIZE
suffix:semicolon
DECL|variable|write_buf_size
r_static
r_int
r_int
id|write_buf_size
op_assign
id|GS_DEFAULT_WRITE_BUF_SIZE
suffix:semicolon
DECL|variable|gs_tmp_buf
r_static
r_int
r_char
id|gs_tmp_buf
(braket
id|GS_TMP_BUF_SIZE
)braket
suffix:semicolon
DECL|variable|gs_tmp_buf_sem
r_static
r_struct
id|semaphore
id|gs_tmp_buf_sem
suffix:semicolon
multiline_comment|/* tty driver struct */
DECL|variable|gs_tty_ops
r_static
r_struct
id|tty_operations
id|gs_tty_ops
op_assign
(brace
dot
id|open
op_assign
id|gs_open
comma
dot
id|close
op_assign
id|gs_close
comma
dot
id|write
op_assign
id|gs_write
comma
dot
id|put_char
op_assign
id|gs_put_char
comma
dot
id|flush_chars
op_assign
id|gs_flush_chars
comma
dot
id|write_room
op_assign
id|gs_write_room
comma
dot
id|ioctl
op_assign
id|gs_ioctl
comma
dot
id|set_termios
op_assign
id|gs_set_termios
comma
dot
id|throttle
op_assign
id|gs_throttle
comma
dot
id|unthrottle
op_assign
id|gs_unthrottle
comma
dot
id|break_ctl
op_assign
id|gs_break
comma
dot
id|chars_in_buffer
op_assign
id|gs_chars_in_buffer
comma
)brace
suffix:semicolon
DECL|variable|gs_tty_driver
r_static
r_struct
id|tty_driver
op_star
id|gs_tty_driver
suffix:semicolon
multiline_comment|/* gadget driver struct */
DECL|variable|gs_gadget_driver
r_static
r_struct
id|usb_gadget_driver
id|gs_gadget_driver
op_assign
(brace
macro_line|#ifdef HIGHSPEED
dot
id|speed
op_assign
id|USB_SPEED_HIGH
comma
macro_line|#else
dot
id|speed
op_assign
id|USB_SPEED_FULL
comma
macro_line|#endif
dot
id|function
op_assign
id|GS_LONG_NAME
comma
dot
id|bind
op_assign
id|gs_bind
comma
dot
id|unbind
op_assign
id|gs_unbind
comma
dot
id|setup
op_assign
id|gs_setup
comma
dot
id|disconnect
op_assign
id|gs_disconnect
comma
dot
id|driver
op_assign
(brace
dot
id|name
op_assign
id|GS_SHORT_NAME
comma
multiline_comment|/* .shutdown = ... */
multiline_comment|/* .suspend = ...  */
multiline_comment|/* .resume = ...   */
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* USB descriptors */
DECL|macro|GS_MANUFACTURER_STR_ID
mdefine_line|#define GS_MANUFACTURER_STR_ID&t;1
DECL|macro|GS_PRODUCT_STR_ID
mdefine_line|#define GS_PRODUCT_STR_ID&t;2
DECL|macro|GS_SERIAL_STR_ID
mdefine_line|#define GS_SERIAL_STR_ID&t;3
DECL|macro|GS_CONFIG_STR_ID
mdefine_line|#define GS_CONFIG_STR_ID&t;4
multiline_comment|/* static strings, in iso 8859/1 */
DECL|variable|gs_strings
r_static
r_struct
id|usb_string
id|gs_strings
(braket
)braket
op_assign
(brace
(brace
id|GS_MANUFACTURER_STR_ID
comma
id|UTS_SYSNAME
l_string|&quot; &quot;
id|UTS_RELEASE
l_string|&quot; with &quot;
id|CHIP
)brace
comma
(brace
id|GS_PRODUCT_STR_ID
comma
id|GS_LONG_NAME
)brace
comma
(brace
id|GS_SERIAL_STR_ID
comma
l_string|&quot;0&quot;
)brace
comma
(brace
id|GS_CONFIG_STR_ID
comma
l_string|&quot;Bulk&quot;
)brace
comma
(brace
)brace
multiline_comment|/* end of list */
)brace
suffix:semicolon
DECL|variable|gs_string_table
r_static
r_struct
id|usb_gadget_strings
id|gs_string_table
op_assign
(brace
dot
id|language
op_assign
l_int|0x0409
comma
multiline_comment|/* en-us */
dot
id|strings
op_assign
id|gs_strings
comma
)brace
suffix:semicolon
DECL|variable|gs_device_desc
r_static
r_const
r_struct
id|usb_device_descriptor
id|gs_device_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_DEVICE_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_DEVICE
comma
dot
id|bcdUSB
op_assign
id|__constant_cpu_to_le16
c_func
(paren
l_int|0x0200
)paren
comma
dot
id|bDeviceClass
op_assign
id|USB_CLASS_VENDOR_SPEC
comma
dot
id|bMaxPacketSize0
op_assign
id|EP0_MAXPACKET
comma
dot
id|idVendor
op_assign
id|__constant_cpu_to_le16
c_func
(paren
id|GS_VENDOR_ID
)paren
comma
dot
id|idProduct
op_assign
id|__constant_cpu_to_le16
c_func
(paren
id|GS_PRODUCT_ID
)paren
comma
dot
id|bcdDevice
op_assign
id|__constant_cpu_to_le16
c_func
(paren
id|GS_VERSION_NUM
)paren
comma
dot
id|iManufacturer
op_assign
id|GS_MANUFACTURER_STR_ID
comma
dot
id|iProduct
op_assign
id|GS_PRODUCT_STR_ID
comma
dot
id|iSerialNumber
op_assign
id|GS_SERIAL_STR_ID
comma
dot
id|bNumConfigurations
op_assign
id|GS_NUM_CONFIGS
comma
)brace
suffix:semicolon
DECL|variable|gs_config_desc
r_static
r_const
r_struct
id|usb_config_descriptor
id|gs_config_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_CONFIG_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_CONFIG
comma
multiline_comment|/* .wTotalLength set by gs_build_config_desc */
dot
id|bNumInterfaces
op_assign
id|GS_NUM_INTERFACES
comma
dot
id|bConfigurationValue
op_assign
id|GS_BULK_CONFIG_ID
comma
dot
id|iConfiguration
op_assign
id|GS_CONFIG_STR_ID
comma
dot
id|bmAttributes
op_assign
id|USB_CONFIG_ATT_ONE
op_or
id|SELFPOWER
op_or
id|WAKEUP
comma
dot
id|bMaxPower
op_assign
(paren
id|MAX_USB_POWER
op_plus
l_int|1
)paren
op_div
l_int|2
comma
)brace
suffix:semicolon
DECL|variable|gs_interface_desc
r_static
r_const
r_struct
id|usb_interface_descriptor
id|gs_interface_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_INTERFACE_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_INTERFACE
comma
dot
id|bNumEndpoints
op_assign
id|GS_NUM_ENDPOINTS
comma
dot
id|bInterfaceClass
op_assign
id|USB_CLASS_VENDOR_SPEC
comma
dot
id|iInterface
op_assign
id|GS_CONFIG_STR_ID
comma
)brace
suffix:semicolon
DECL|variable|gs_fullspeed_in_desc
r_static
r_const
r_struct
id|usb_endpoint_descriptor
id|gs_fullspeed_in_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|EP_IN_NUM
op_or
id|USB_DIR_IN
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
c_func
(paren
l_int|64
)paren
comma
)brace
suffix:semicolon
DECL|variable|gs_fullspeed_out_desc
r_static
r_const
r_struct
id|usb_endpoint_descriptor
id|gs_fullspeed_out_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|EP_OUT_NUM
op_or
id|USB_DIR_OUT
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
c_func
(paren
l_int|64
)paren
comma
)brace
suffix:semicolon
DECL|variable|gs_highspeed_in_desc
r_static
r_const
r_struct
id|usb_endpoint_descriptor
id|gs_highspeed_in_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|EP_IN_NUM
op_or
id|USB_DIR_IN
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
c_func
(paren
l_int|512
)paren
comma
)brace
suffix:semicolon
DECL|variable|gs_highspeed_out_desc
r_static
r_const
r_struct
id|usb_endpoint_descriptor
id|gs_highspeed_out_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|EP_OUT_NUM
op_or
id|USB_DIR_OUT
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
c_func
(paren
l_int|512
)paren
comma
)brace
suffix:semicolon
macro_line|#ifdef HIGHSPEED
DECL|variable|gs_qualifier_desc
r_static
r_const
r_struct
id|usb_qualifier_descriptor
id|gs_qualifier_desc
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
(paren
r_struct
id|usb_qualifier_descriptor
)paren
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_DEVICE_QUALIFIER
comma
dot
id|bcdUSB
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0200
)paren
comma
dot
id|bDeviceClass
op_assign
id|USB_CLASS_VENDOR_SPEC
comma
multiline_comment|/* assumes ep0 uses the same value for both speeds ... */
dot
id|bMaxPacketSize0
op_assign
id|EP0_MAXPACKET
comma
dot
id|bNumConfigurations
op_assign
id|GS_NUM_CONFIGS
comma
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* Module */
DECL|variable|GS_LONG_NAME
id|MODULE_DESCRIPTION
c_func
(paren
id|GS_LONG_NAME
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Al Borchers&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug
comma
l_string|&quot;Enable debugging, 0=off, 1=on&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|read_q_size
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|read_q_size
comma
l_string|&quot;Read request queue size, default=32&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|write_q_size
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|write_q_size
comma
l_string|&quot;Write request queue size, default=32&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|write_buf_size
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|write_buf_size
comma
l_string|&quot;Write buffer size, default=8192&quot;
)paren
suffix:semicolon
DECL|variable|gs_module_init
id|module_init
c_func
(paren
id|gs_module_init
)paren
suffix:semicolon
DECL|variable|gs_module_exit
id|module_exit
c_func
(paren
id|gs_module_exit
)paren
suffix:semicolon
multiline_comment|/*&n;*  gs_module_init&n;*&n;*  Register as a USB gadget driver and a tty driver.&n;*/
DECL|function|gs_module_init
r_static
r_int
id|__init
id|gs_module_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|usb_gadget_register_driver
c_func
(paren
op_amp
id|gs_gadget_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_module_init: cannot register gadget driver, ret=%d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|gs_tty_driver
op_assign
id|alloc_tty_driver
c_func
(paren
id|GS_NUM_PORTS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gs_tty_driver
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|gs_tty_driver-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|gs_tty_driver-&gt;driver_name
op_assign
id|GS_SHORT_NAME
suffix:semicolon
id|gs_tty_driver-&gt;name
op_assign
l_string|&quot;ttygs&quot;
suffix:semicolon
id|gs_tty_driver-&gt;devfs_name
op_assign
l_string|&quot;usb/ttygs/&quot;
suffix:semicolon
id|gs_tty_driver-&gt;major
op_assign
id|GS_MAJOR
suffix:semicolon
id|gs_tty_driver-&gt;minor_start
op_assign
id|GS_MINOR_START
suffix:semicolon
id|gs_tty_driver-&gt;type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|gs_tty_driver-&gt;subtype
op_assign
id|SERIAL_TYPE_NORMAL
suffix:semicolon
id|gs_tty_driver-&gt;flags
op_assign
id|TTY_DRIVER_REAL_RAW
op_or
id|TTY_DRIVER_NO_DEVFS
suffix:semicolon
id|gs_tty_driver-&gt;init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|gs_tty_driver-&gt;init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
id|tty_set_operations
c_func
(paren
id|gs_tty_driver
comma
op_amp
id|gs_tty_ops
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|GS_NUM_PORTS
suffix:semicolon
id|i
op_increment
)paren
id|sema_init
c_func
(paren
op_amp
id|gs_open_close_sem
(braket
id|i
)braket
comma
l_int|1
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|gs_tmp_buf_sem
comma
l_int|1
)paren
suffix:semicolon
id|retval
op_assign
id|tty_register_driver
c_func
(paren
id|gs_tty_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|usb_gadget_unregister_driver
c_func
(paren
op_amp
id|gs_gadget_driver
)paren
suffix:semicolon
id|put_tty_driver
c_func
(paren
id|gs_tty_driver
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_module_init: cannot register tty driver, ret=%d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;gs_module_init: %s %s loaded&bslash;n&quot;
comma
id|GS_LONG_NAME
comma
id|GS_VERSION_STR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;* gs_module_exit&n;*&n;* Unregister as a tty driver and a USB gadget driver.&n;*/
DECL|function|gs_module_exit
r_static
r_void
id|__exit
id|gs_module_exit
c_func
(paren
r_void
)paren
(brace
id|tty_unregister_driver
c_func
(paren
id|gs_tty_driver
)paren
suffix:semicolon
id|put_tty_driver
c_func
(paren
id|gs_tty_driver
)paren
suffix:semicolon
id|usb_gadget_unregister_driver
c_func
(paren
op_amp
id|gs_gadget_driver
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;gs_module_exit: %s %s unloaded&bslash;n&quot;
comma
id|GS_LONG_NAME
comma
id|GS_VERSION_STR
)paren
suffix:semicolon
)brace
multiline_comment|/* TTY Driver */
multiline_comment|/*&n; * gs_open&n; */
DECL|function|gs_open
r_static
r_int
id|gs_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|port_num
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
r_struct
id|gs_dev
op_star
id|dev
suffix:semicolon
r_struct
id|gs_buf
op_star
id|buf
suffix:semicolon
r_struct
id|semaphore
op_star
id|sem
suffix:semicolon
id|port_num
op_assign
id|tty-&gt;index
suffix:semicolon
id|gs_debug
c_func
(paren
l_string|&quot;gs_open: (%d,%p,%p)&bslash;n&quot;
comma
id|port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
id|tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|port_num
OL
l_int|0
op_logical_or
id|port_num
op_ge
id|GS_NUM_PORTS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_open: (%d,%p,%p) invalid port number&bslash;n&quot;
comma
id|port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dev
op_assign
id|gs_device
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_open: (%d,%p,%p) NULL device pointer&bslash;n&quot;
comma
id|port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|sem
op_assign
op_amp
id|gs_open_close_sem
(braket
id|port_num
)braket
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
id|sem
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_open: (%d,%p,%p) interrupted waiting for semaphore&bslash;n&quot;
comma
id|port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dev-&gt;dev_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dev_config
op_eq
id|GS_NO_CONFIG_ID
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_open: (%d,%p,%p) device is not connected&bslash;n&quot;
comma
id|port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dev-&gt;dev_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|port
op_assign
id|dev-&gt;dev_port
(braket
id|port_num
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_open: (%d,%p,%p) NULL port pointer&bslash;n&quot;
comma
id|port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dev-&gt;dev_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|port-&gt;port_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;dev_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;port_dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_open: (%d,%p,%p) port disconnected (1)&bslash;n&quot;
comma
id|port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;port_open_count
OG
l_int|0
)paren
(brace
op_increment
id|port-&gt;port_open_count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|gs_debug
c_func
(paren
l_string|&quot;gs_open: (%d,%p,%p) already open&bslash;n&quot;
comma
id|port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* mark port as in use, we can drop port lock and sleep if necessary */
id|port-&gt;port_in_use
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* allocate write buffer on first open */
r_if
c_cond
(paren
id|port-&gt;port_write_buf
op_eq
l_int|NULL
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|buf
op_assign
id|gs_buf_alloc
c_func
(paren
id|write_buf_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* might have been disconnected while asleep, check */
r_if
c_cond
(paren
id|port-&gt;port_dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_open: (%d,%p,%p) port disconnected (2)&bslash;n&quot;
comma
id|port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
id|port-&gt;port_in_use
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|port-&gt;port_write_buf
op_assign
id|buf
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_open: (%d,%p,%p) cannot allocate port write buffer&bslash;n&quot;
comma
id|port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
id|port-&gt;port_in_use
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
multiline_comment|/* wait for carrier detect (not implemented) */
multiline_comment|/* might have been disconnected while asleep, check */
r_if
c_cond
(paren
id|port-&gt;port_dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_open: (%d,%p,%p) port disconnected (3)&bslash;n&quot;
comma
id|port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
id|port-&gt;port_in_use
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|tty-&gt;driver_data
op_assign
id|port
suffix:semicolon
id|port-&gt;port_tty
op_assign
id|tty
suffix:semicolon
id|port-&gt;port_open_count
op_assign
l_int|1
suffix:semicolon
id|port-&gt;port_in_use
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
id|gs_debug
c_func
(paren
l_string|&quot;gs_open: (%d,%p,%p) completed&bslash;n&quot;
comma
id|port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_close&n; */
DECL|function|gs_close
r_static
r_void
id|gs_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|gs_port
op_star
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|semaphore
op_star
id|sem
suffix:semicolon
r_if
c_cond
(paren
id|port
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_close: NULL port pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|gs_debug
c_func
(paren
l_string|&quot;gs_close: (%d,%p,%p)&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
id|sem
op_assign
op_amp
id|gs_open_close_sem
(braket
id|port-&gt;port_num
)braket
suffix:semicolon
id|down
c_func
(paren
id|sem
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;port_open_count
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_close: (%d,%p,%p) port is already closed&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;port_open_count
OG
l_int|0
)paren
(brace
op_decrement
id|port-&gt;port_open_count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* free disconnected port on final close */
r_if
c_cond
(paren
id|port-&gt;port_dev
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|port
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* mark port as closed but in use, we can drop port lock */
multiline_comment|/* and sleep if necessary */
id|port-&gt;port_in_use
op_assign
l_int|1
suffix:semicolon
id|port-&gt;port_open_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* wait for write buffer to drain, or */
multiline_comment|/* at most GS_CLOSE_TIMEOUT seconds */
r_if
c_cond
(paren
id|gs_buf_data_avail
c_func
(paren
id|port-&gt;port_write_buf
)paren
OG
l_int|0
)paren
(brace
id|wait_cond_interruptible_timeout
c_func
(paren
id|port-&gt;port_write_wait
comma
id|port-&gt;port_dev
op_eq
l_int|NULL
op_logical_or
id|gs_buf_data_avail
c_func
(paren
id|port-&gt;port_write_buf
)paren
op_eq
l_int|0
comma
op_amp
id|port-&gt;port_lock
comma
id|flags
comma
id|GS_CLOSE_TIMEOUT
op_star
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/* free disconnected port on final close */
multiline_comment|/* (might have happened during the above sleep) */
r_if
c_cond
(paren
id|port-&gt;port_dev
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|port
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|gs_buf_clear
c_func
(paren
id|port-&gt;port_write_buf
)paren
suffix:semicolon
id|tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
id|port-&gt;port_tty
op_assign
l_int|NULL
suffix:semicolon
id|port-&gt;port_in_use
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
id|gs_debug
c_func
(paren
l_string|&quot;gs_close: (%d,%p,%p) completed&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
comma
id|file
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_write&n; */
DECL|function|gs_write
r_static
r_int
id|gs_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|gs_port
op_star
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|port
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_write: NULL port pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|gs_debug
c_func
(paren
l_string|&quot;gs_write: (%d,%p) writing %d bytes&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* copy from user into tmp buffer, get tmp_buf semaphore */
r_if
c_cond
(paren
id|from_user
)paren
(brace
r_if
c_cond
(paren
id|count
OG
id|GS_TMP_BUF_SIZE
)paren
id|count
op_assign
id|GS_TMP_BUF_SIZE
suffix:semicolon
id|down
c_func
(paren
op_amp
id|gs_tmp_buf_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|gs_tmp_buf
comma
id|buf
comma
id|count
)paren
op_ne
l_int|0
)paren
(brace
id|up
c_func
(paren
op_amp
id|gs_tmp_buf_sem
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_write: (%d,%p) cannot copy from user space&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|buf
op_assign
id|gs_tmp_buf
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;port_dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_write: (%d,%p) port is not connected&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
id|up
c_func
(paren
op_amp
id|gs_tmp_buf_sem
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;port_open_count
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_write: (%d,%p) port is closed&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
id|up
c_func
(paren
op_amp
id|gs_tmp_buf_sem
)paren
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
id|count
op_assign
id|gs_buf_put
c_func
(paren
id|port-&gt;port_write_buf
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
id|up
c_func
(paren
op_amp
id|gs_tmp_buf_sem
)paren
suffix:semicolon
id|gs_send
c_func
(paren
id|gs_device
)paren
suffix:semicolon
id|gs_debug
c_func
(paren
l_string|&quot;gs_write: (%d,%p) wrote %d bytes&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
comma
id|count
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_put_char&n; */
DECL|function|gs_put_char
r_static
r_void
id|gs_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|gs_port
op_star
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|port
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_put_char: NULL port pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|gs_debug
c_func
(paren
l_string|&quot;gs_put_char: (%d,%p) char=0x%x, called from %p, %p, %p&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
comma
id|ch
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
comma
id|__builtin_return_address
c_func
(paren
l_int|1
)paren
comma
id|__builtin_return_address
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;port_dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_put_char: (%d,%p) port is not connected&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;port_open_count
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_put_char: (%d,%p) port is closed&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|gs_buf_put
c_func
(paren
id|port-&gt;port_write_buf
comma
op_amp
id|ch
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_flush_chars&n; */
DECL|function|gs_flush_chars
r_static
r_void
id|gs_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|gs_port
op_star
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|port
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_flush_chars: NULL port pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|gs_debug
c_func
(paren
l_string|&quot;gs_flush_chars: (%d,%p)&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;port_dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_flush_chars: (%d,%p) port is not connected&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;port_open_count
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_flush_chars: (%d,%p) port is closed&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|gs_send
c_func
(paren
id|gs_device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_write_room&n; */
DECL|function|gs_write_room
r_static
r_int
id|gs_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|room
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|gs_port
op_star
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|port
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;port_dev
op_ne
l_int|NULL
op_logical_and
id|port-&gt;port_open_count
OG
l_int|0
op_logical_and
id|port-&gt;port_write_buf
op_ne
l_int|NULL
)paren
id|room
op_assign
id|gs_buf_space_avail
c_func
(paren
id|port-&gt;port_write_buf
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|gs_debug
c_func
(paren
l_string|&quot;gs_write_room: (%d,%p) room=%d&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
comma
id|room
)paren
suffix:semicolon
r_return
id|room
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_chars_in_buffer&n; */
DECL|function|gs_chars_in_buffer
r_static
r_int
id|gs_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|chars
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|gs_port
op_star
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|port
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;port_dev
op_ne
l_int|NULL
op_logical_and
id|port-&gt;port_open_count
OG
l_int|0
op_logical_and
id|port-&gt;port_write_buf
op_ne
l_int|NULL
)paren
id|chars
op_assign
id|gs_buf_data_avail
c_func
(paren
id|port-&gt;port_write_buf
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
id|gs_debug
c_func
(paren
l_string|&quot;gs_chars_in_buffer: (%d,%p) chars=%d&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
comma
id|chars
)paren
suffix:semicolon
r_return
id|chars
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_throttle&n; */
DECL|function|gs_throttle
r_static
r_void
id|gs_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
)brace
multiline_comment|/*&n; * gs_unthrottle&n; */
DECL|function|gs_unthrottle
r_static
r_void
id|gs_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
)brace
multiline_comment|/*&n; * gs_break&n; */
DECL|function|gs_break
r_static
r_void
id|gs_break
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|break_state
)paren
(brace
)brace
multiline_comment|/*&n; * gs_ioctl&n; */
DECL|function|gs_ioctl
r_static
r_int
id|gs_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|gs_port
op_star
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|port
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_ioctl: NULL port pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|gs_debug
c_func
(paren
l_string|&quot;gs_ioctl: (%d,%p,%p) cmd=0x%4.4x, arg=%lu&bslash;n&quot;
comma
id|port-&gt;port_num
comma
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
multiline_comment|/* handle ioctls */
multiline_comment|/* could not handle ioctl */
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_set_termios&n; */
DECL|function|gs_set_termios
r_static
r_void
id|gs_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
)brace
multiline_comment|/*&n;* gs_send&n;*&n;* This function finds available write requests, calls&n;* gs_send_packet to fill these packets with data, and&n;* continues until either there are no more write requests&n;* available or no more data to send.  This function is&n;* run whenever data arrives or write requests are available.&n;*/
DECL|function|gs_send
r_static
r_int
id|gs_send
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
)paren
(brace
r_int
id|ret
comma
id|len
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
r_struct
id|gs_req_entry
op_star
id|req_entry
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_send: NULL device pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dev-&gt;dev_lock
comma
id|flags
)paren
suffix:semicolon
id|ep
op_assign
id|dev-&gt;dev_in_ep
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dev-&gt;dev_req_list
)paren
)paren
(brace
id|req_entry
op_assign
id|list_entry
c_func
(paren
id|dev-&gt;dev_req_list.next
comma
r_struct
id|gs_req_entry
comma
id|re_entry
)paren
suffix:semicolon
id|req
op_assign
id|req_entry-&gt;re_req
suffix:semicolon
id|len
op_assign
id|gs_send_packet
c_func
(paren
id|dev
comma
id|req-&gt;buf
comma
id|ep-&gt;maxpacket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|gs_debug_level
c_func
(paren
l_int|3
comma
l_string|&quot;gs_send: len=%d, 0x%2.2x 0x%2.2x 0x%2.2x ...&bslash;n&quot;
comma
id|len
comma
op_star
(paren
(paren
r_int
r_char
op_star
)paren
id|req-&gt;buf
)paren
comma
op_star
(paren
(paren
r_int
r_char
op_star
)paren
id|req-&gt;buf
op_plus
l_int|1
)paren
comma
op_star
(paren
(paren
r_int
r_char
op_star
)paren
id|req-&gt;buf
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|req_entry-&gt;re_entry
)paren
suffix:semicolon
id|req-&gt;length
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_ep_queue
c_func
(paren
id|ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_send: cannot queue read request, ret=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dev-&gt;dev_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_send_packet&n; *&n; * If there is data to send, a packet is built in the given&n; * buffer and the size is returned.  If there is no data to&n; * send, 0 is returned.  If there is any error a negative&n; * error number is returned.&n; *&n; * Called during USB completion routine, on interrupt time.&n; *&n; * We assume that disconnect will not happen until all completion&n; * routines have completed, so we can assume that the dev_port&n; * array does not change during the lifetime of this function.&n; */
DECL|function|gs_send_packet
r_static
r_int
id|gs_send_packet
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
comma
r_char
op_star
id|packet
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|len
suffix:semicolon
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
multiline_comment|/* TEMPORARY -- only port 0 is supported right now */
id|port
op_assign
id|dev-&gt;dev_port
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_send_packet: port=%d, NULL port pointer&bslash;n&quot;
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|port-&gt;port_lock
)paren
suffix:semicolon
id|len
op_assign
id|gs_buf_data_avail
c_func
(paren
id|port-&gt;port_write_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|size
)paren
id|size
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|port-&gt;port_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|size
op_assign
id|gs_buf_get
c_func
(paren
id|port-&gt;port_write_buf
comma
id|packet
comma
id|size
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;port_tty-&gt;write_wait
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|port-&gt;port_lock
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_recv_packet&n; *&n; * Called for each USB packet received.  Reads the packet&n; * header and stuffs the data in the appropriate tty buffer.&n; * Returns 0 if successful, or a negative error number.&n; *&n; * Called during USB completion routine, on interrupt time.&n; *&n; * We assume that disconnect will not happen until all completion&n; * routines have completed, so we can assume that the dev_port&n; * array does not change during the lifetime of this function.&n; */
DECL|function|gs_recv_packet
r_static
r_int
id|gs_recv_packet
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
comma
r_char
op_star
id|packet
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|len
suffix:semicolon
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
multiline_comment|/* TEMPORARY -- only port 0 is supported right now */
id|port
op_assign
id|dev-&gt;dev_port
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_recv_packet: port=%d, NULL port pointer&bslash;n&quot;
comma
id|port-&gt;port_num
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|port-&gt;port_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;port_tty
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_recv_packet: port=%d, NULL tty pointer&bslash;n&quot;
comma
id|port-&gt;port_num
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|port-&gt;port_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;port_tty-&gt;magic
op_ne
id|TTY_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_recv_packet: port=%d, bad tty magic&bslash;n&quot;
comma
id|port-&gt;port_num
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|port-&gt;port_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|len
op_assign
(paren
r_int
r_int
)paren
(paren
id|TTY_FLIPBUF_SIZE
op_minus
id|port-&gt;port_tty-&gt;flip.count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|size
)paren
id|size
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|port-&gt;port_tty-&gt;flip.char_buf_ptr
comma
id|packet
comma
id|size
)paren
suffix:semicolon
id|port-&gt;port_tty-&gt;flip.char_buf_ptr
op_add_assign
id|size
suffix:semicolon
id|port-&gt;port_tty-&gt;flip.count
op_add_assign
id|size
suffix:semicolon
id|tty_flip_buffer_push
c_func
(paren
id|port-&gt;port_tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;port_tty-&gt;read_wait
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|port-&gt;port_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;* gs_read_complete&n;*/
DECL|function|gs_read_complete
r_static
r_void
id|gs_read_complete
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|gs_dev
op_star
id|dev
op_assign
id|ep-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_read_complete: NULL device pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|req-&gt;status
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* normal completion */
id|gs_recv_packet
c_func
(paren
id|dev
comma
id|req-&gt;buf
comma
id|req-&gt;actual
)paren
suffix:semicolon
id|requeue
suffix:colon
id|req-&gt;length
op_assign
id|ep-&gt;maxpacket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_ep_queue
c_func
(paren
id|ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_read_complete: cannot queue read request, ret=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
op_minus
id|ESHUTDOWN
suffix:colon
multiline_comment|/* disconnect */
id|gs_debug
c_func
(paren
l_string|&quot;gs_read_complete: shutdown&bslash;n&quot;
)paren
suffix:semicolon
id|gs_free_req
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* unexpected */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_read_complete: unexpected status error, status=%d&bslash;n&quot;
comma
id|req-&gt;status
)paren
suffix:semicolon
r_goto
id|requeue
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;* gs_write_complete&n;*/
DECL|function|gs_write_complete
r_static
r_void
id|gs_write_complete
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|gs_dev
op_star
id|dev
op_assign
id|ep-&gt;driver_data
suffix:semicolon
r_struct
id|gs_req_entry
op_star
id|gs_req
op_assign
id|req-&gt;context
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_write_complete: NULL device pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|req-&gt;status
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* normal completion */
id|requeue
suffix:colon
r_if
c_cond
(paren
id|gs_req
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_write_complete: NULL request pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|dev-&gt;dev_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|gs_req-&gt;re_entry
comma
op_amp
id|dev-&gt;dev_req_list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;dev_lock
)paren
suffix:semicolon
id|gs_send
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ESHUTDOWN
suffix:colon
multiline_comment|/* disconnect */
id|gs_debug
c_func
(paren
l_string|&quot;gs_write_complete: shutdown&bslash;n&quot;
)paren
suffix:semicolon
id|gs_free_req
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_write_complete: unexpected status error, status=%d&bslash;n&quot;
comma
id|req-&gt;status
)paren
suffix:semicolon
r_goto
id|requeue
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Gadget Driver */
multiline_comment|/*&n; * gs_bind&n; *&n; * Called on module load.  Allocates and initializes the device&n; * structure and a control request.&n; */
DECL|function|gs_bind
r_static
r_int
id|gs_bind
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|gs_dev
op_star
id|dev
suffix:semicolon
id|gs_device
op_assign
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|gs_dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|set_gadget_data
c_func
(paren
id|gadget
comma
id|dev
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|gs_dev
)paren
)paren
suffix:semicolon
id|dev-&gt;dev_gadget
op_assign
id|gadget
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|dev-&gt;dev_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dev-&gt;dev_req_list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|gs_alloc_ports
c_func
(paren
id|dev
comma
id|GFP_KERNEL
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_bind: cannot allocate ports&bslash;n&quot;
)paren
suffix:semicolon
id|gs_unbind
c_func
(paren
id|gadget
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* preallocate control response and buffer */
id|dev-&gt;dev_ctrl_req
op_assign
id|gs_alloc_req
c_func
(paren
id|gadget-&gt;ep0
comma
id|GS_MAX_DESC_LEN
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dev_ctrl_req
op_eq
l_int|NULL
)paren
(brace
id|gs_unbind
c_func
(paren
id|gadget
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|dev-&gt;dev_ctrl_req-&gt;complete
op_assign
id|gs_setup_complete
suffix:semicolon
id|gadget-&gt;ep0-&gt;driver_data
op_assign
id|dev
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;gs_bind: %s %s bound&bslash;n&quot;
comma
id|GS_LONG_NAME
comma
id|GS_VERSION_STR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_unbind&n; *&n; * Called on module unload.  Frees the control request and device&n; * structure.&n; */
DECL|function|gs_unbind
r_static
r_void
id|gs_unbind
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|gs_dev
op_star
id|dev
op_assign
id|get_gadget_data
c_func
(paren
id|gadget
)paren
suffix:semicolon
id|gs_device
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* read/write requests already freed, only control request remains */
r_if
c_cond
(paren
id|dev
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;dev_ctrl_req
op_ne
l_int|NULL
)paren
id|gs_free_req
c_func
(paren
id|gadget-&gt;ep0
comma
id|dev-&gt;dev_ctrl_req
)paren
suffix:semicolon
id|gs_free_ports
c_func
(paren
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
id|set_gadget_data
c_func
(paren
id|gadget
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;gs_unbind: %s %s unbound&bslash;n&quot;
comma
id|GS_LONG_NAME
comma
id|GS_VERSION_STR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_setup&n; *&n; * Implements all the control endpoint functionality that&squot;s not&n; * handled in hardware or the hardware driver.&n; *&n; * Returns the size of the data sent to the host, or a negative&n; * error number.&n; */
DECL|function|gs_setup
r_static
r_int
id|gs_setup
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
r_const
r_struct
id|usb_ctrlrequest
op_star
id|ctrl
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_int
r_int
id|sv_config
suffix:semicolon
r_struct
id|gs_dev
op_star
id|dev
op_assign
id|get_gadget_data
c_func
(paren
id|gadget
)paren
suffix:semicolon
r_struct
id|usb_request
op_star
id|req
op_assign
id|dev-&gt;dev_ctrl_req
suffix:semicolon
r_switch
c_cond
(paren
id|ctrl-&gt;bRequest
)paren
(brace
r_case
id|USB_REQ_GET_DESCRIPTOR
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
id|USB_DIR_IN
)paren
r_break
suffix:semicolon
r_switch
c_cond
(paren
id|ctrl-&gt;wValue
op_rshift
l_int|8
)paren
(brace
r_case
id|USB_DT_DEVICE
suffix:colon
id|ret
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
r_sizeof
(paren
r_struct
id|usb_device_descriptor
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|req-&gt;buf
comma
op_amp
id|gs_device_desc
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef HIGHSPEED
r_case
id|USB_DT_DEVICE_QUALIFIER
suffix:colon
id|ret
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
r_sizeof
(paren
r_struct
id|usb_qualifier_descriptor
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|req-&gt;buf
comma
op_amp
id|gs_qualifier_desc
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_OTHER_SPEED_CONFIG
suffix:colon
macro_line|#endif /* HIGHSPEED */
r_case
id|USB_DT_CONFIG
suffix:colon
id|ret
op_assign
id|gs_build_config_desc
c_func
(paren
id|req-&gt;buf
comma
id|gadget-&gt;speed
comma
id|ctrl-&gt;wValue
op_rshift
l_int|8
comma
id|ctrl-&gt;wValue
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
id|ret
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_STRING
suffix:colon
multiline_comment|/* wIndex == language code. */
id|ret
op_assign
id|usb_gadget_get_string
c_func
(paren
op_amp
id|gs_string_table
comma
id|ctrl-&gt;wValue
op_amp
l_int|0xff
comma
id|req-&gt;buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
id|ret
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|USB_REQ_SET_CONFIGURATION
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dev-&gt;dev_lock
)paren
suffix:semicolon
id|ret
op_assign
id|gs_set_config
c_func
(paren
id|dev
comma
id|ctrl-&gt;wValue
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;dev_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_REQ_GET_CONFIGURATION
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
id|USB_DIR_IN
)paren
r_break
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|req-&gt;buf
op_assign
id|dev-&gt;dev_config
suffix:semicolon
id|ret
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_REQ_SET_INTERFACE
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
id|USB_RECIP_INTERFACE
)paren
r_break
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dev-&gt;dev_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dev_config
op_eq
id|GS_BULK_CONFIG_ID
op_logical_and
id|ctrl-&gt;wIndex
op_eq
id|GS_INTERFACE_ID
op_logical_and
id|ctrl-&gt;wValue
op_eq
id|GS_ALT_INTERFACE_ID
)paren
(brace
id|sv_config
op_assign
id|dev-&gt;dev_config
suffix:semicolon
multiline_comment|/* since there is only one interface, setting the */
multiline_comment|/* interface is equivalent to setting the config */
id|gs_reset_config
c_func
(paren
id|dev
)paren
suffix:semicolon
id|gs_set_config
c_func
(paren
id|dev
comma
id|sv_config
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;dev_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_REQ_GET_INTERFACE
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_IN
op_or
id|USB_RECIP_INTERFACE
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dev_config
op_eq
id|GS_NO_CONFIG_ID
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;wIndex
op_ne
id|GS_INTERFACE_ID
)paren
(brace
id|ret
op_assign
op_minus
id|EDOM
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
(paren
id|u8
op_star
)paren
id|req-&gt;buf
op_assign
id|GS_ALT_INTERFACE_ID
suffix:semicolon
id|ret
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_setup: unknown request, type=%02x, request=%02x, value=%04x, index=%04x, length=%d&bslash;n&quot;
comma
id|ctrl-&gt;bRequestType
comma
id|ctrl-&gt;bRequest
comma
id|ctrl-&gt;wValue
comma
id|ctrl-&gt;wIndex
comma
id|ctrl-&gt;wLength
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* respond with data transfer before status phase? */
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
id|req-&gt;length
op_assign
id|ret
suffix:semicolon
id|ret
op_assign
id|usb_ep_queue
c_func
(paren
id|gadget-&gt;ep0
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_setup: cannot queue response, ret=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
id|req-&gt;status
op_assign
l_int|0
suffix:semicolon
id|gs_setup_complete
c_func
(paren
id|gadget-&gt;ep0
comma
id|req
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* device either stalls (ret &lt; 0) or reports success */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_setup_complete&n; */
DECL|function|gs_setup_complete
r_static
r_void
id|gs_setup_complete
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;status
op_logical_or
id|req-&gt;actual
op_ne
id|req-&gt;length
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_setup_complete: status error, status=%d, actual=%d, length=%d&bslash;n&quot;
comma
id|req-&gt;status
comma
id|req-&gt;actual
comma
id|req-&gt;length
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * gs_disconnect&n; *&n; * Called when the device is disconnected.  Frees the closed&n; * ports and disconnects open ports.  Open ports will be freed&n; * on close.  Then reallocates the ports for the next connection.&n; */
DECL|function|gs_disconnect
r_static
r_void
id|gs_disconnect
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|gs_dev
op_star
id|dev
op_assign
id|get_gadget_data
c_func
(paren
id|gadget
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dev-&gt;dev_lock
comma
id|flags
)paren
suffix:semicolon
id|gs_reset_config
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* free closed ports and disconnect open ports */
multiline_comment|/* (open ports will be freed when closed) */
id|gs_free_ports
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* re-allocate ports for the next connection */
r_if
c_cond
(paren
id|gs_alloc_ports
c_func
(paren
id|dev
comma
id|GFP_ATOMIC
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_disconnect: cannot re-allocate ports&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dev-&gt;dev_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;gs_disconnect: %s disconnected&bslash;n&quot;
comma
id|GS_LONG_NAME
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_set_config&n; *&n; * Configures the device by enabling device specific&n; * optimizations, setting up the endpoints, allocating&n; * read and write requests and queuing read requests.&n; *&n; * The device lock must be held when calling this function.&n; */
DECL|function|gs_set_config
r_static
r_int
id|gs_set_config
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
comma
r_int
id|config
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|usb_gadget
op_star
id|gadget
op_assign
id|dev-&gt;dev_gadget
suffix:semicolon
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
r_struct
id|gs_req_entry
op_star
id|req_entry
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_set_config: NULL device pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|config
op_eq
id|dev-&gt;dev_config
)paren
r_return
l_int|0
suffix:semicolon
id|gs_reset_config
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config
op_eq
id|GS_NO_CONFIG_ID
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|config
op_ne
id|GS_BULK_CONFIG_ID
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|hw_optimize
c_func
(paren
id|gadget
)paren
suffix:semicolon
id|gadget_for_each_ep
c_func
(paren
id|ep
comma
id|gadget
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ep-&gt;name
comma
id|EP_IN_NAME
)paren
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|usb_ep_enable
c_func
(paren
id|ep
comma
id|gadget-&gt;speed
op_eq
id|USB_SPEED_HIGH
ques
c_cond
op_amp
id|gs_highspeed_in_desc
suffix:colon
op_amp
id|gs_fullspeed_in_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ep-&gt;driver_data
op_assign
id|dev
suffix:semicolon
id|dev-&gt;dev_in_ep
op_assign
id|ep
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_set_config: cannot enable in endpoint %s, ret=%d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|ret
)paren
suffix:semicolon
id|gs_reset_config
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ep-&gt;name
comma
id|EP_OUT_NAME
)paren
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|usb_ep_enable
c_func
(paren
id|ep
comma
id|gadget-&gt;speed
op_eq
id|USB_SPEED_HIGH
ques
c_cond
op_amp
id|gs_highspeed_out_desc
suffix:colon
op_amp
id|gs_fullspeed_out_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ep-&gt;driver_data
op_assign
id|dev
suffix:semicolon
id|dev-&gt;dev_out_ep
op_assign
id|ep
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_set_config: cannot enable out endpoint %s, ret=%d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|ret
)paren
suffix:semicolon
id|gs_reset_config
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|dev-&gt;dev_in_ep
op_eq
l_int|NULL
op_logical_or
id|dev-&gt;dev_out_ep
op_eq
l_int|NULL
)paren
(brace
id|gs_reset_config
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_set_config: cannot find endpoints&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* allocate and queue read requests */
id|ep
op_assign
id|dev-&gt;dev_out_ep
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|read_q_size
op_logical_and
id|ret
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|req
op_assign
id|gs_alloc_req
c_func
(paren
id|ep
comma
id|ep-&gt;maxpacket
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|req-&gt;complete
op_assign
id|gs_read_complete
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_ep_queue
c_func
(paren
id|ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_set_config: cannot queue read request, ret=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|gs_reset_config
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_set_config: cannot allocate read requests&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
multiline_comment|/* allocate write requests, and put on free list */
id|ep
op_assign
id|dev-&gt;dev_in_ep
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|write_q_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|req_entry
op_assign
id|gs_alloc_req_entry
c_func
(paren
id|ep
comma
id|ep-&gt;maxpacket
comma
id|GFP_ATOMIC
)paren
)paren
)paren
(brace
id|req_entry-&gt;re_req-&gt;complete
op_assign
id|gs_write_complete
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|req_entry-&gt;re_entry
comma
op_amp
id|dev-&gt;dev_req_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|gs_reset_config
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_set_config: cannot allocate write requests&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|dev-&gt;dev_config
op_assign
id|config
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;gs_set_config: %s configured for %s speed&bslash;n&quot;
comma
id|GS_LONG_NAME
comma
id|gadget-&gt;speed
op_eq
id|USB_SPEED_HIGH
ques
c_cond
l_string|&quot;high&quot;
suffix:colon
l_string|&quot;full&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_reset_config&n; *&n; * Mark the device as not configured, disable all endpoints,&n; * which forces completion of pending I/O and frees queued&n; * requests, and free the remaining write requests on the&n; * free list.&n; *&n; * The device lock must be held when calling this function.&n; */
DECL|function|gs_reset_config
r_static
r_void
id|gs_reset_config
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
)paren
(brace
r_struct
id|gs_req_entry
op_star
id|req_entry
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs_reset_config: NULL device pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;dev_config
op_eq
id|GS_NO_CONFIG_ID
)paren
r_return
suffix:semicolon
id|dev-&gt;dev_config
op_assign
id|GS_NO_CONFIG_ID
suffix:semicolon
multiline_comment|/* free write requests on the free list */
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dev-&gt;dev_req_list
)paren
)paren
(brace
id|req_entry
op_assign
id|list_entry
c_func
(paren
id|dev-&gt;dev_req_list.next
comma
r_struct
id|gs_req_entry
comma
id|re_entry
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|req_entry-&gt;re_entry
)paren
suffix:semicolon
id|gs_free_req_entry
c_func
(paren
id|dev-&gt;dev_in_ep
comma
id|req_entry
)paren
suffix:semicolon
)brace
multiline_comment|/* disable endpoints, forcing completion of pending i/o; */
multiline_comment|/* completion handlers free their requests in this case */
r_if
c_cond
(paren
id|dev-&gt;dev_in_ep
)paren
(brace
id|usb_ep_disable
c_func
(paren
id|dev-&gt;dev_in_ep
)paren
suffix:semicolon
id|dev-&gt;dev_in_ep
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;dev_out_ep
)paren
(brace
id|usb_ep_disable
c_func
(paren
id|dev-&gt;dev_out_ep
)paren
suffix:semicolon
id|dev-&gt;dev_out_ep
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * gs_build_config_desc&n; *&n; * Builds a config descriptor in the given buffer and returns the&n; * length, or a negative error number.&n; */
DECL|function|gs_build_config_desc
r_static
r_int
id|gs_build_config_desc
c_func
(paren
id|u8
op_star
id|buf
comma
r_enum
id|usb_device_speed
id|speed
comma
id|u8
id|type
comma
r_int
r_int
id|index
)paren
(brace
r_int
id|high_speed
suffix:semicolon
r_int
id|len
op_assign
id|USB_DT_CONFIG_SIZE
op_plus
id|USB_DT_INTERFACE_SIZE
op_plus
id|GS_NUM_ENDPOINTS
op_star
id|USB_DT_ENDPOINT_SIZE
suffix:semicolon
multiline_comment|/* only one config */
r_if
c_cond
(paren
id|index
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
op_amp
id|gs_config_desc
comma
id|USB_DT_CONFIG_SIZE
)paren
suffix:semicolon
(paren
(paren
r_struct
id|usb_config_descriptor
op_star
)paren
id|buf
)paren
op_member_access_from_pointer
id|bDescriptorType
op_assign
id|type
suffix:semicolon
(paren
(paren
r_struct
id|usb_config_descriptor
op_star
)paren
id|buf
)paren
op_member_access_from_pointer
id|wTotalLength
op_assign
id|__constant_cpu_to_le16
c_func
(paren
id|len
)paren
suffix:semicolon
id|buf
op_add_assign
id|USB_DT_CONFIG_SIZE
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
op_amp
id|gs_interface_desc
comma
id|USB_DT_INTERFACE_SIZE
)paren
suffix:semicolon
id|buf
op_add_assign
id|USB_DT_INTERFACE_SIZE
suffix:semicolon
multiline_comment|/* other speed switches high and full speed */
id|high_speed
op_assign
(paren
id|speed
op_eq
id|USB_SPEED_HIGH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|USB_DT_OTHER_SPEED_CONFIG
)paren
id|high_speed
op_assign
op_logical_neg
id|high_speed
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|high_speed
ques
c_cond
op_amp
id|gs_highspeed_in_desc
suffix:colon
op_amp
id|gs_fullspeed_in_desc
comma
id|USB_DT_ENDPOINT_SIZE
)paren
suffix:semicolon
id|buf
op_add_assign
id|USB_DT_ENDPOINT_SIZE
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|high_speed
ques
c_cond
op_amp
id|gs_highspeed_out_desc
suffix:colon
op_amp
id|gs_fullspeed_out_desc
comma
id|USB_DT_ENDPOINT_SIZE
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_alloc_req&n; *&n; * Allocate a usb_request and its buffer.  Returns a pointer to the&n; * usb_request or NULL if there is an error.&n; */
DECL|function|gs_alloc_req
r_static
r_struct
id|usb_request
op_star
id|gs_alloc_req
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_int
r_int
id|len
comma
r_int
id|kmalloc_flags
)paren
(brace
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|req
op_assign
id|usb_ep_alloc_request
c_func
(paren
id|ep
comma
id|kmalloc_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
op_ne
l_int|NULL
)paren
(brace
id|req-&gt;length
op_assign
id|len
suffix:semicolon
id|req-&gt;buf
op_assign
id|usb_ep_alloc_buffer
c_func
(paren
id|ep
comma
id|len
comma
op_amp
id|req-&gt;dma
comma
id|kmalloc_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;buf
op_eq
l_int|NULL
)paren
(brace
id|usb_ep_free_request
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|req
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_free_req&n; *&n; * Free a usb_request and its buffer.&n; */
DECL|function|gs_free_req
r_static
r_void
id|gs_free_req
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|ep
op_ne
l_int|NULL
op_logical_and
id|req
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;buf
op_ne
l_int|NULL
)paren
id|usb_ep_free_buffer
c_func
(paren
id|ep
comma
id|req-&gt;buf
comma
id|req-&gt;dma
comma
id|req-&gt;length
)paren
suffix:semicolon
id|usb_ep_free_request
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * gs_alloc_req_entry&n; *&n; * Allocates a request and its buffer, using the given&n; * endpoint, buffer len, and kmalloc flags.&n; */
DECL|function|gs_alloc_req_entry
r_static
r_struct
id|gs_req_entry
op_star
id|gs_alloc_req_entry
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_int
id|len
comma
r_int
id|kmalloc_flags
)paren
(brace
r_struct
id|gs_req_entry
op_star
id|req
suffix:semicolon
id|req
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|gs_req_entry
)paren
comma
id|kmalloc_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|req-&gt;re_req
op_assign
id|gs_alloc_req
c_func
(paren
id|ep
comma
id|len
comma
id|kmalloc_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;re_req
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|req
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|req-&gt;re_req-&gt;context
op_assign
id|req
suffix:semicolon
r_return
id|req
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_free_req_entry&n; *&n; * Frees a request and its buffer.&n; */
DECL|function|gs_free_req_entry
r_static
r_void
id|gs_free_req_entry
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|gs_req_entry
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|ep
op_ne
l_int|NULL
op_logical_and
id|req
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;re_req
op_ne
l_int|NULL
)paren
id|gs_free_req
c_func
(paren
id|ep
comma
id|req-&gt;re_req
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * gs_alloc_ports&n; *&n; * Allocate all ports and set the gs_dev struct to point to them.&n; * Return 0 if successful, or a negative error number.&n; *&n; * The device lock is normally held when calling this function.&n; */
DECL|function|gs_alloc_ports
r_static
r_int
id|gs_alloc_ports
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
comma
r_int
id|kmalloc_flags
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|GS_NUM_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|port
op_assign
(paren
r_struct
id|gs_port
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|gs_port
)paren
comma
id|kmalloc_flags
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|port
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|gs_port
)paren
)paren
suffix:semicolon
id|port-&gt;port_dev
op_assign
id|dev
suffix:semicolon
id|port-&gt;port_num
op_assign
id|i
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|port-&gt;port_lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|port-&gt;port_write_wait
)paren
suffix:semicolon
id|dev-&gt;dev_port
(braket
id|i
)braket
op_assign
id|port
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_free_ports&n; *&n; * Free all closed ports.  Open ports are disconnected by&n; * freeing their write buffers, setting their device pointers&n; * and the pointers to them in the device to NULL.  These&n; * ports will be freed when closed.&n; *&n; * The device lock is normally held when calling this function.&n; */
DECL|function|gs_free_ports
r_static
r_void
id|gs_free_ports
c_func
(paren
r_struct
id|gs_dev
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|GS_NUM_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|port
op_assign
id|dev-&gt;dev_port
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|dev-&gt;dev_port
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;port_write_buf
op_ne
l_int|NULL
)paren
(brace
id|gs_buf_free
c_func
(paren
id|port-&gt;port_write_buf
)paren
suffix:semicolon
id|port-&gt;port_write_buf
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;port_open_count
OG
l_int|0
op_logical_or
id|port-&gt;port_in_use
)paren
(brace
id|port-&gt;port_dev
op_assign
l_int|NULL
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;port_write_wait
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;port_tty-&gt;read_wait
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;port_tty-&gt;write_wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|kfree
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|port-&gt;port_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Circular Buffer */
multiline_comment|/*&n; * gs_buf_alloc&n; *&n; * Allocate a circular buffer and all associated memory.&n; */
DECL|function|gs_buf_alloc
r_static
r_struct
id|gs_buf
op_star
id|gs_buf_alloc
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|kmalloc_flags
)paren
(brace
r_struct
id|gs_buf
op_star
id|gb
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|gb
op_assign
(paren
r_struct
id|gs_buf
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|gs_buf
)paren
comma
id|kmalloc_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gb
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|gb-&gt;buf_buf
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|kmalloc_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gb-&gt;buf_buf
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|gb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|gb-&gt;buf_size
op_assign
id|size
suffix:semicolon
id|gb-&gt;buf_get
op_assign
id|gb-&gt;buf_put
op_assign
id|gb-&gt;buf_buf
suffix:semicolon
r_return
id|gb
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_buf_free&n; *&n; * Free the buffer and all associated memory.&n; */
DECL|function|gs_buf_free
r_void
id|gs_buf_free
c_func
(paren
r_struct
id|gs_buf
op_star
id|gb
)paren
(brace
r_if
c_cond
(paren
id|gb
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|gb-&gt;buf_buf
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|gb-&gt;buf_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|gb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * gs_buf_clear&n; *&n; * Clear out all data in the circular buffer.&n; */
DECL|function|gs_buf_clear
r_void
id|gs_buf_clear
c_func
(paren
r_struct
id|gs_buf
op_star
id|gb
)paren
(brace
r_if
c_cond
(paren
id|gb
op_ne
l_int|NULL
)paren
id|gb-&gt;buf_get
op_assign
id|gb-&gt;buf_put
suffix:semicolon
multiline_comment|/* equivalent to a get of all data available */
)brace
multiline_comment|/*&n; * gs_buf_data_avail&n; *&n; * Return the number of bytes of data available in the circular&n; * buffer.&n; */
DECL|function|gs_buf_data_avail
r_int
r_int
id|gs_buf_data_avail
c_func
(paren
r_struct
id|gs_buf
op_star
id|gb
)paren
(brace
r_if
c_cond
(paren
id|gb
op_ne
l_int|NULL
)paren
r_return
(paren
id|gb-&gt;buf_size
op_plus
id|gb-&gt;buf_put
op_minus
id|gb-&gt;buf_get
)paren
op_mod
id|gb-&gt;buf_size
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_buf_space_avail&n; *&n; * Return the number of bytes of space available in the circular&n; * buffer.&n; */
DECL|function|gs_buf_space_avail
r_int
r_int
id|gs_buf_space_avail
c_func
(paren
r_struct
id|gs_buf
op_star
id|gb
)paren
(brace
r_if
c_cond
(paren
id|gb
op_ne
l_int|NULL
)paren
r_return
(paren
id|gb-&gt;buf_size
op_plus
id|gb-&gt;buf_get
op_minus
id|gb-&gt;buf_put
op_minus
l_int|1
)paren
op_mod
id|gb-&gt;buf_size
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_buf_put&n; *&n; * Copy data data from a user buffer and put it into the circular buffer.&n; * Restrict to the amount of space available.&n; *&n; * Return the number of bytes copied.&n; */
DECL|function|gs_buf_put
r_int
r_int
id|gs_buf_put
c_func
(paren
r_struct
id|gs_buf
op_star
id|gb
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|gb
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_assign
id|gs_buf_space_avail
c_func
(paren
id|gb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|len
)paren
id|count
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_assign
id|gb-&gt;buf_buf
op_plus
id|gb-&gt;buf_size
op_minus
id|gb-&gt;buf_put
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|len
)paren
(brace
id|memcpy
c_func
(paren
id|gb-&gt;buf_put
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|gb-&gt;buf_buf
comma
id|buf
op_plus
id|len
comma
id|count
op_minus
id|len
)paren
suffix:semicolon
id|gb-&gt;buf_put
op_assign
id|gb-&gt;buf_buf
op_plus
id|count
op_minus
id|len
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|gb-&gt;buf_put
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
id|len
)paren
id|gb-&gt;buf_put
op_add_assign
id|count
suffix:semicolon
r_else
multiline_comment|/* count == len */
id|gb-&gt;buf_put
op_assign
id|gb-&gt;buf_buf
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * gs_buf_get&n; *&n; * Get data from the circular buffer and copy to the given buffer.&n; * Restrict to the amount of data available.&n; *&n; * Return the number of bytes copied.&n; */
DECL|function|gs_buf_get
r_int
r_int
id|gs_buf_get
c_func
(paren
r_struct
id|gs_buf
op_star
id|gb
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|gb
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_assign
id|gs_buf_data_avail
c_func
(paren
id|gb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|len
)paren
id|count
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|len
op_assign
id|gb-&gt;buf_buf
op_plus
id|gb-&gt;buf_size
op_minus
id|gb-&gt;buf_get
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|len
)paren
(brace
id|memcpy
c_func
(paren
id|buf
comma
id|gb-&gt;buf_get
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
op_plus
id|len
comma
id|gb-&gt;buf_buf
comma
id|count
op_minus
id|len
)paren
suffix:semicolon
id|gb-&gt;buf_get
op_assign
id|gb-&gt;buf_buf
op_plus
id|count
op_minus
id|len
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|buf
comma
id|gb-&gt;buf_get
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
id|len
)paren
id|gb-&gt;buf_get
op_add_assign
id|count
suffix:semicolon
r_else
multiline_comment|/* count == len */
id|gb-&gt;buf_get
op_assign
id|gb-&gt;buf_buf
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
eof
