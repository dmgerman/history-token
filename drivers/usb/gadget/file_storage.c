multiline_comment|/*&n; * file_storage.c -- File-backed USB Storage Gadget, for USB development&n; *&n; * Copyright (C) 2003, 2004 Alan Stern&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. The names of the above-listed copyright holders may not be used&n; *    to endorse or promote products derived from this software without&n; *    specific prior written permission.&n; *&n; * ALTERNATIVELY, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;) as published by the Free Software&n; * Foundation, either version 2 of that License or (at your option) any&n; * later version.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS&n; * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,&n; * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR&n; * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR&n; * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,&n; * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,&n; * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR&n; * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF&n; * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING&n; * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS&n; * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; */
multiline_comment|/*&n; * The File-backed Storage Gadget acts as a USB Mass Storage device,&n; * appearing to the host as a disk drive.  In addition to providing an&n; * example of a genuinely useful gadget driver for a USB device, it also&n; * illustrates a technique of double-buffering for increased throughput.&n; * Last but not least, it gives an easy way to probe the behavior of the&n; * Mass Storage drivers in a USB host.&n; *&n; * Backing storage is provided by a regular file or a block device, specified&n; * by the &quot;file&quot; module parameter.  Access can be limited to read-only by&n; * setting the optional &quot;ro&quot; module parameter.  The gadget will indicate that&n; * it has removable media if the optional &quot;removable&quot; module parameter is set.&n; *&n; * The gadget supports the Control-Bulk (CB), Control-Bulk-Interrupt (CBI),&n; * and Bulk-Only (also known as Bulk-Bulk-Bulk or BBB) transports, selected&n; * by the optional &quot;transport&quot; module parameter.  It also supports the&n; * following protocols: RBC (0x01), ATAPI or SFF-8020i (0x02), QIC-157 (0c03),&n; * UFI (0x04), SFF-8070i (0x05), and transparent SCSI (0x06), selected by&n; * the optional &quot;protocol&quot; module parameter.  In addition, the default&n; * Vendor ID, Product ID, and release number can be overridden.&n; *&n; * There is support for multiple logical units (LUNs), each of which has&n; * its own backing file.  The number of LUNs can be set using the optional&n; * &quot;luns&quot; module parameter (anywhere from 1 to 8), and the corresponding&n; * files are specified using comma-separated lists for &quot;file&quot; and &quot;ro&quot;.&n; * The default number of LUNs is taken from the number of &quot;file&quot; elements;&n; * it is 1 if &quot;file&quot; is not given.  If &quot;removable&quot; is not set then a backing&n; * file must be specified for each LUN.  If it is set, then an unspecified&n; * or empty backing filename means the LUN&squot;s medium is not loaded.&n; *&n; * Requirements are modest; only a bulk-in and a bulk-out endpoint are&n; * needed (an interrupt-out endpoint is also needed for CBI).  The memory&n; * requirement amounts to two 16K buffers, size configurable by a parameter.&n; * Support is included for both full-speed and high-speed operation.&n; *&n; * Module options:&n; *&n; *&t;file=filename[,filename...]&n; *&t;&t;&t;&t;Required if &quot;removable&quot; is not set, names of&n; *&t;&t;&t;&t;&t;the files or block devices used for&n; *&t;&t;&t;&t;&t;backing storage&n; *&t;ro=b[,b...]&t;&t;Default false, booleans for read-only access&n; *&t;removable&t;&t;Default false, boolean for removable media&n; *&t;luns=N&t;&t;&t;Default N = number of filenames, number of&n; *&t;&t;&t;&t;&t;LUNs to support&n; *&t;transport=XXX&t;&t;Default BBB, transport name (CB, CBI, or BBB)&n; *&t;protocol=YYY&t;&t;Default SCSI, protocol name (RBC, 8020 or&n; *&t;&t;&t;&t;&t;ATAPI, QIC, UFI, 8070, or SCSI;&n; *&t;&t;&t;&t;&t;also 1 - 6)&n; *&t;vendor=0xVVVV&t;&t;Default 0x0525 (NetChip), USB Vendor ID&n; *&t;product=0xPPPP&t;&t;Default 0xa4a5 (FSG), USB Product ID&n; *&t;release=0xRRRR&t;&t;Override the USB release number (bcdDevice)&n; *&t;buflen=N&t;&t;Default N=16384, buffer size used (will be&n; *&t;&t;&t;&t;&t;rounded down to a multiple of&n; *&t;&t;&t;&t;&t;PAGE_CACHE_SIZE)&n; *&t;stall&t;&t;&t;Default determined according to the type of&n; *&t;&t;&t;&t;&t;USB device controller (usually true),&n; *&t;&t;&t;&t;&t;boolean to permit the driver to halt&n; *&t;&t;&t;&t;&t;bulk endpoints&n; *&n; * If CONFIG_USB_FILE_STORAGE_TEST is not set, only the &quot;file&quot;, &quot;ro&quot;,&n; * &quot;removable&quot;, and &quot;luns&quot; options are available; default values are used&n; * for everything else.&n; *&n; * The pathnames of the backing files and the ro settings are available in&n; * the attribute files &quot;file&quot; and &quot;ro&quot; in the lun&lt;n&gt; subdirectory of the&n; * gadget&squot;s sysfs directory.  If the &quot;removable&quot; option is set, writing to&n; * these files will simulate ejecting/loading the medium (writing an empty&n; * line means eject) and adjusting a write-enable tab.  Changes to the ro&n; * setting are not allowed when the medium is loaded.&n; *&n; * This gadget driver is heavily based on &quot;Gadget Zero&quot; by David Brownell.&n; */
multiline_comment|/*&n; *&t;&t;&t;&t;Driver Design&n; *&n; * The FSG driver is fairly straightforward.  There is a main kernel&n; * thread that handles most of the work.  Interrupt routines field&n; * callbacks from the controller driver: bulk- and interrupt-request&n; * completion notifications, endpoint-0 events, and disconnect events.&n; * Completion events are passed to the main thread by wakeup calls.  Many&n; * ep0 requests are handled at interrupt time, but SetInterface,&n; * SetConfiguration, and device reset requests are forwarded to the&n; * thread in the form of &quot;exceptions&quot; using SIGUSR1 signals (since they&n; * should interrupt any ongoing file I/O operations).&n; *&n; * The thread&squot;s main routine implements the standard command/data/status&n; * parts of a SCSI interaction.  It and its subroutines are full of tests&n; * for pending signals/exceptions -- all this polling is necessary since&n; * the kernel has no setjmp/longjmp equivalents.  (Maybe this is an&n; * indication that the driver really wants to be running in userspace.)&n; * An important point is that so long as the thread is alive it keeps an&n; * open reference to the backing file.  This will prevent unmounting&n; * the backing file&squot;s underlying filesystem and could cause problems&n; * during system shutdown, for example.  To prevent such problems, the&n; * thread catches INT, TERM, and KILL signals and converts them into&n; * an EXIT exception.&n; *&n; * In normal operation the main thread is started during the gadget&squot;s&n; * fsg_bind() callback and stopped during fsg_unbind().  But it can also&n; * exit when it receives a signal, and there&squot;s no point leaving the&n; * gadget running when the thread is dead.  So just before the thread&n; * exits, it deregisters the gadget driver.  This makes things a little&n; * tricky: The driver is deregistered at two places, and the exiting&n; * thread can indirectly call fsg_unbind() which in turn can tell the&n; * thread to exit.  The first problem is resolved through the use of the&n; * REGISTERED atomic bitflag; the driver will only be deregistered once.&n; * The second problem is resolved by having fsg_unbind() check&n; * fsg-&gt;state; it won&squot;t try to stop the thread if the state is already&n; * FSG_STATE_TERMINATED.&n; *&n; * To provide maximum throughput, the driver uses a circular pipeline of&n; * buffer heads (struct fsg_buffhd).  In principle the pipeline can be&n; * arbitrarily long; in practice the benefits don&squot;t justify having more&n; * than 2 stages (i.e., double buffering).  But it helps to think of the&n; * pipeline as being a long one.  Each buffer head contains a bulk-in and&n; * a bulk-out request pointer (since the buffer can be used for both&n; * output and input -- directions always are given from the host&squot;s&n; * point of view) as well as a pointer to the buffer and various state&n; * variables.&n; *&n; * Use of the pipeline follows a simple protocol.  There is a variable&n; * (fsg-&gt;next_buffhd_to_fill) that points to the next buffer head to use.&n; * At any time that buffer head may still be in use from an earlier&n; * request, so each buffer head has a state variable indicating whether&n; * it is EMPTY, FULL, or BUSY.  Typical use involves waiting for the&n; * buffer head to be EMPTY, filling the buffer either by file I/O or by&n; * USB I/O (during which the buffer head is BUSY), and marking the buffer&n; * head FULL when the I/O is complete.  Then the buffer will be emptied&n; * (again possibly by USB I/O, during which it is marked BUSY) and&n; * finally marked EMPTY again (possibly by a completion routine).&n; *&n; * A module parameter tells the driver to avoid stalling the bulk&n; * endpoints wherever the transport specification allows.  This is&n; * necessary for some UDCs like the SuperH, which cannot reliably clear a&n; * halt on a bulk endpoint.  However, under certain circumstances the&n; * Bulk-only specification requires a stall.  In such cases the driver&n; * will halt the endpoint and set a flag indicating that it should clear&n; * the halt in software during the next device reset.  Hopefully this&n; * will permit everything to work correctly.  Furthermore, although the&n; * specification allows the bulk-out endpoint to halt when the host sends&n; * too much data, implementing this would cause an unavoidable race.&n; * The driver will always use the &quot;no-stall&quot; approach for OUT transfers.&n; *&n; * One subtle point concerns sending status-stage responses for ep0&n; * requests.  Some of these requests, such as device reset, can involve&n; * interrupting an ongoing file I/O operation, which might take an&n; * arbitrarily long time.  During that delay the host might give up on&n; * the original ep0 request and issue a new one.  When that happens the&n; * driver should not notify the host about completion of the original&n; * request, as the host will no longer be waiting for it.  So the driver&n; * assigns to each ep0 request a unique tag, and it keeps track of the&n; * tag value of the request associated with a long-running exception&n; * (device-reset, interface-change, or configuration-change).  When the&n; * exception handler is finished, the status-stage response is submitted&n; * only if the current ep0 request tag is equal to the exception request&n; * tag.  Thus only the most recently received ep0 request will get a&n; * status-stage response.&n; *&n; * Warning: This driver source file is too long.  It ought to be split up&n; * into a header file plus about 3 separate .c files, to handle the details&n; * of the Gadget, USB Mass Storage, and SCSI protocols.&n; */
DECL|macro|DEBUG
macro_line|#undef DEBUG
DECL|macro|VERBOSE
macro_line|#undef VERBOSE
DECL|macro|DUMP_MSGS
macro_line|#undef DUMP_MSGS
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/dcache.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/limits.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/uts.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/usb_ch9.h&gt;
macro_line|#include &lt;linux/usb_gadget.h&gt;
macro_line|#include &quot;gadget_chips.h&quot;
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|DRIVER_DESC
mdefine_line|#define DRIVER_DESC&t;&t;&quot;File-backed Storage Gadget&quot;
DECL|macro|DRIVER_NAME
mdefine_line|#define DRIVER_NAME&t;&t;&quot;g_file_storage&quot;
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION&t;&t;&quot;20 October 2004&quot;
DECL|variable|longname
r_static
r_const
r_char
id|longname
(braket
)braket
op_assign
id|DRIVER_DESC
suffix:semicolon
DECL|variable|shortname
r_static
r_const
r_char
id|shortname
(braket
)braket
op_assign
id|DRIVER_NAME
suffix:semicolon
DECL|variable|DRIVER_DESC
id|MODULE_DESCRIPTION
c_func
(paren
id|DRIVER_DESC
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Alan Stern&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;Dual BSD/GPL&quot;
)paren
suffix:semicolon
multiline_comment|/* Thanks to NetChip Technologies for donating this product ID.&n; *&n; * DO NOT REUSE THESE IDs with any other driver!!  Ever!!&n; * Instead:  allocate your own, using normal USB-IF procedures. */
DECL|macro|DRIVER_VENDOR_ID
mdefine_line|#define DRIVER_VENDOR_ID&t;0x0525&t;
singleline_comment|// NetChip
DECL|macro|DRIVER_PRODUCT_ID
mdefine_line|#define DRIVER_PRODUCT_ID&t;0xa4a5&t;
singleline_comment|// Linux-USB File-backed Storage Gadget
multiline_comment|/*&n; * This driver assumes self-powered hardware and has no way for users to&n; * trigger remote wakeup.  It uses autoconfiguration to select endpoints&n; * and endpoint addresses.&n; */
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|xprintk
mdefine_line|#define xprintk(f,level,fmt,args...) &bslash;&n;&t;dev_printk(level , &amp;(f)-&gt;gadget-&gt;dev , fmt , ## args)
DECL|macro|yprintk
mdefine_line|#define yprintk(l,level,fmt,args...) &bslash;&n;&t;dev_printk(level , &amp;(l)-&gt;dev , fmt , ## args)
macro_line|#ifdef DEBUG
DECL|macro|DBG
mdefine_line|#define DBG(fsg,fmt,args...) &bslash;&n;&t;xprintk(fsg , KERN_DEBUG , fmt , ## args)
DECL|macro|LDBG
mdefine_line|#define LDBG(lun,fmt,args...) &bslash;&n;&t;yprintk(lun , KERN_DEBUG , fmt , ## args)
DECL|macro|MDBG
mdefine_line|#define MDBG(fmt,args...) &bslash;&n;&t;printk(KERN_DEBUG DRIVER_NAME &quot;: &quot; fmt , ## args)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(fsg,fmt,args...) &bslash;&n;&t;do { } while (0)
DECL|macro|LDBG
mdefine_line|#define LDBG(lun,fmt,args...) &bslash;&n;&t;do { } while (0)
DECL|macro|MDBG
mdefine_line|#define MDBG(fmt,args...) &bslash;&n;&t;do { } while (0)
DECL|macro|VERBOSE
macro_line|#undef VERBOSE
DECL|macro|DUMP_MSGS
macro_line|#undef DUMP_MSGS
macro_line|#endif /* DEBUG */
macro_line|#ifdef VERBOSE
DECL|macro|VDBG
mdefine_line|#define VDBG&t;DBG
DECL|macro|VLDBG
mdefine_line|#define VLDBG&t;LDBG
macro_line|#else
DECL|macro|VDBG
mdefine_line|#define VDBG(fsg,fmt,args...) &bslash;&n;&t;do { } while (0)
DECL|macro|VLDBG
mdefine_line|#define VLDBG(lun,fmt,args...) &bslash;&n;&t;do { } while (0)
macro_line|#endif /* VERBOSE */
DECL|macro|ERROR
mdefine_line|#define ERROR(fsg,fmt,args...) &bslash;&n;&t;xprintk(fsg , KERN_ERR , fmt , ## args)
DECL|macro|LERROR
mdefine_line|#define LERROR(lun,fmt,args...) &bslash;&n;&t;yprintk(lun , KERN_ERR , fmt , ## args)
DECL|macro|WARN
mdefine_line|#define WARN(fsg,fmt,args...) &bslash;&n;&t;xprintk(fsg , KERN_WARNING , fmt , ## args)
DECL|macro|LWARN
mdefine_line|#define LWARN(lun,fmt,args...) &bslash;&n;&t;yprintk(lun , KERN_WARNING , fmt , ## args)
DECL|macro|INFO
mdefine_line|#define INFO(fsg,fmt,args...) &bslash;&n;&t;xprintk(fsg , KERN_INFO , fmt , ## args)
DECL|macro|LINFO
mdefine_line|#define LINFO(lun,fmt,args...) &bslash;&n;&t;yprintk(lun , KERN_INFO , fmt , ## args)
DECL|macro|MINFO
mdefine_line|#define MINFO(fmt,args...) &bslash;&n;&t;printk(KERN_INFO DRIVER_NAME &quot;: &quot; fmt , ## args)
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Encapsulate the module parameter settings */
DECL|macro|MAX_LUNS
mdefine_line|#define MAX_LUNS&t;8
multiline_comment|/* Arggh!  There should be a module_param_array_named macro! */
DECL|variable|file
r_static
r_char
op_star
id|file
(braket
id|MAX_LUNS
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|ro
r_static
r_int
id|ro
(braket
id|MAX_LUNS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_static
r_struct
(brace
DECL|member|num_filenames
r_int
id|num_filenames
suffix:semicolon
DECL|member|num_ros
r_int
id|num_ros
suffix:semicolon
DECL|member|nluns
r_int
r_int
id|nluns
suffix:semicolon
DECL|member|transport_parm
r_char
op_star
id|transport_parm
suffix:semicolon
DECL|member|protocol_parm
r_char
op_star
id|protocol_parm
suffix:semicolon
DECL|member|removable
r_int
id|removable
suffix:semicolon
DECL|member|vendor
r_int
r_int
id|vendor
suffix:semicolon
DECL|member|product
r_int
r_int
id|product
suffix:semicolon
DECL|member|release
r_int
r_int
id|release
suffix:semicolon
DECL|member|buflen
r_int
r_int
id|buflen
suffix:semicolon
DECL|member|can_stall
r_int
id|can_stall
suffix:semicolon
DECL|member|transport_type
r_int
id|transport_type
suffix:semicolon
DECL|member|transport_name
r_char
op_star
id|transport_name
suffix:semicolon
DECL|member|protocol_type
r_int
id|protocol_type
suffix:semicolon
DECL|member|protocol_name
r_char
op_star
id|protocol_name
suffix:semicolon
DECL|variable|mod_data
)brace
id|mod_data
op_assign
(brace
singleline_comment|// Default values
dot
id|transport_parm
op_assign
l_string|&quot;BBB&quot;
comma
dot
id|protocol_parm
op_assign
l_string|&quot;SCSI&quot;
comma
dot
id|removable
op_assign
l_int|0
comma
dot
id|vendor
op_assign
id|DRIVER_VENDOR_ID
comma
dot
id|product
op_assign
id|DRIVER_PRODUCT_ID
comma
dot
id|release
op_assign
l_int|0xffff
comma
singleline_comment|// Use controller chip type
dot
id|buflen
op_assign
l_int|16384
comma
dot
id|can_stall
op_assign
l_int|1
comma
)brace
suffix:semicolon
id|module_param_array
c_func
(paren
id|file
comma
id|charp
comma
op_amp
id|mod_data.num_filenames
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|file
comma
l_string|&quot;names of backing files or devices&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|ro
comma
r_bool
comma
op_amp
id|mod_data.num_ros
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ro
comma
l_string|&quot;true to force read-only&quot;
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|luns
comma
id|mod_data.nluns
comma
id|uint
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|luns
comma
l_string|&quot;number of LUNs&quot;
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|removable
comma
id|mod_data.removable
comma
r_bool
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|removable
comma
l_string|&quot;true to simulate removable media&quot;
)paren
suffix:semicolon
multiline_comment|/* In the non-TEST version, only the module parameters listed above&n; * are available. */
macro_line|#ifdef CONFIG_USB_FILE_STORAGE_TEST
id|module_param_named
c_func
(paren
id|transport
comma
id|mod_data.transport_parm
comma
id|charp
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|transport
comma
l_string|&quot;type of transport (BBB, CBI, or CB)&quot;
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|protocol
comma
id|mod_data.protocol_parm
comma
id|charp
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|protocol
comma
l_string|&quot;type of protocol (RBC, 8020, QIC, UFI, &quot;
l_string|&quot;8070, or SCSI)&quot;
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|vendor
comma
id|mod_data.vendor
comma
id|ushort
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|vendor
comma
l_string|&quot;USB Vendor ID&quot;
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|product
comma
id|mod_data.product
comma
id|ushort
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|product
comma
l_string|&quot;USB Product ID&quot;
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|release
comma
id|mod_data.release
comma
id|ushort
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|release
comma
l_string|&quot;USB release number&quot;
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|buflen
comma
id|mod_data.buflen
comma
id|uint
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|buflen
comma
l_string|&quot;I/O buffer size&quot;
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|stall
comma
id|mod_data.can_stall
comma
r_bool
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|stall
comma
l_string|&quot;false to prevent bulk stalls&quot;
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_USB_FILE_STORAGE_TEST */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* USB protocol value = the transport method */
DECL|macro|USB_PR_CBI
mdefine_line|#define USB_PR_CBI&t;0x00&t;&t;
singleline_comment|// Control/Bulk/Interrupt
DECL|macro|USB_PR_CB
mdefine_line|#define USB_PR_CB&t;0x01&t;&t;
singleline_comment|// Control/Bulk w/o interrupt
DECL|macro|USB_PR_BULK
mdefine_line|#define USB_PR_BULK&t;0x50&t;&t;
singleline_comment|// Bulk-only
multiline_comment|/* USB subclass value = the protocol encapsulation */
DECL|macro|USB_SC_RBC
mdefine_line|#define USB_SC_RBC&t;0x01&t;&t;
singleline_comment|// Reduced Block Commands (flash)
DECL|macro|USB_SC_8020
mdefine_line|#define USB_SC_8020&t;0x02&t;&t;
singleline_comment|// SFF-8020i, MMC-2, ATAPI (CD-ROM)
DECL|macro|USB_SC_QIC
mdefine_line|#define USB_SC_QIC&t;0x03&t;&t;
singleline_comment|// QIC-157 (tape)
DECL|macro|USB_SC_UFI
mdefine_line|#define USB_SC_UFI&t;0x04&t;&t;
singleline_comment|// UFI (floppy)
DECL|macro|USB_SC_8070
mdefine_line|#define USB_SC_8070&t;0x05&t;&t;
singleline_comment|// SFF-8070i (removable)
DECL|macro|USB_SC_SCSI
mdefine_line|#define USB_SC_SCSI&t;0x06&t;&t;
singleline_comment|// Transparent SCSI
multiline_comment|/* Bulk-only data structures */
multiline_comment|/* Command Block Wrapper */
DECL|struct|bulk_cb_wrap
r_struct
id|bulk_cb_wrap
(brace
DECL|member|Signature
id|__le32
id|Signature
suffix:semicolon
singleline_comment|// Contains &squot;USBC&squot;
DECL|member|Tag
id|u32
id|Tag
suffix:semicolon
singleline_comment|// Unique per command id
DECL|member|DataTransferLength
id|__le32
id|DataTransferLength
suffix:semicolon
singleline_comment|// Size of the data
DECL|member|Flags
id|u8
id|Flags
suffix:semicolon
singleline_comment|// Direction in bit 7
DECL|member|Lun
id|u8
id|Lun
suffix:semicolon
singleline_comment|// LUN (normally 0)
DECL|member|Length
id|u8
id|Length
suffix:semicolon
singleline_comment|// Of the CDB, &lt;= MAX_COMMAND_SIZE
DECL|member|CDB
id|u8
id|CDB
(braket
l_int|16
)braket
suffix:semicolon
singleline_comment|// Command Data Block
)brace
suffix:semicolon
DECL|macro|USB_BULK_CB_WRAP_LEN
mdefine_line|#define USB_BULK_CB_WRAP_LEN&t;31
DECL|macro|USB_BULK_CB_SIG
mdefine_line|#define USB_BULK_CB_SIG&t;&t;0x43425355&t;
singleline_comment|// Spells out USBC
DECL|macro|USB_BULK_IN_FLAG
mdefine_line|#define USB_BULK_IN_FLAG&t;0x80
multiline_comment|/* Command Status Wrapper */
DECL|struct|bulk_cs_wrap
r_struct
id|bulk_cs_wrap
(brace
DECL|member|Signature
id|__le32
id|Signature
suffix:semicolon
singleline_comment|// Should = &squot;USBS&squot;
DECL|member|Tag
id|u32
id|Tag
suffix:semicolon
singleline_comment|// Same as original command
DECL|member|Residue
id|__le32
id|Residue
suffix:semicolon
singleline_comment|// Amount not transferred
DECL|member|Status
id|u8
id|Status
suffix:semicolon
singleline_comment|// See below
)brace
suffix:semicolon
DECL|macro|USB_BULK_CS_WRAP_LEN
mdefine_line|#define USB_BULK_CS_WRAP_LEN&t;13
DECL|macro|USB_BULK_CS_SIG
mdefine_line|#define USB_BULK_CS_SIG&t;&t;0x53425355&t;
singleline_comment|// Spells out &squot;USBS&squot;
DECL|macro|USB_STATUS_PASS
mdefine_line|#define USB_STATUS_PASS&t;&t;0
DECL|macro|USB_STATUS_FAIL
mdefine_line|#define USB_STATUS_FAIL&t;&t;1
DECL|macro|USB_STATUS_PHASE_ERROR
mdefine_line|#define USB_STATUS_PHASE_ERROR&t;2
multiline_comment|/* Bulk-only class specific requests */
DECL|macro|USB_BULK_RESET_REQUEST
mdefine_line|#define USB_BULK_RESET_REQUEST&t;&t;0xff
DECL|macro|USB_BULK_GET_MAX_LUN_REQUEST
mdefine_line|#define USB_BULK_GET_MAX_LUN_REQUEST&t;0xfe
multiline_comment|/* CBI Interrupt data structure */
DECL|struct|interrupt_data
r_struct
id|interrupt_data
(brace
DECL|member|bType
id|u8
id|bType
suffix:semicolon
DECL|member|bValue
id|u8
id|bValue
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|CBI_INTERRUPT_DATA_LEN
mdefine_line|#define CBI_INTERRUPT_DATA_LEN&t;&t;2
multiline_comment|/* CBI Accept Device-Specific Command request */
DECL|macro|USB_CBI_ADSC_REQUEST
mdefine_line|#define USB_CBI_ADSC_REQUEST&t;&t;0x00
DECL|macro|MAX_COMMAND_SIZE
mdefine_line|#define MAX_COMMAND_SIZE&t;16&t;
singleline_comment|// Length of a SCSI Command Data Block
multiline_comment|/* SCSI commands that we recognize */
DECL|macro|SC_FORMAT_UNIT
mdefine_line|#define SC_FORMAT_UNIT&t;&t;&t;0x04
DECL|macro|SC_INQUIRY
mdefine_line|#define SC_INQUIRY&t;&t;&t;0x12
DECL|macro|SC_MODE_SELECT_6
mdefine_line|#define SC_MODE_SELECT_6&t;&t;0x15
DECL|macro|SC_MODE_SELECT_10
mdefine_line|#define SC_MODE_SELECT_10&t;&t;0x55
DECL|macro|SC_MODE_SENSE_6
mdefine_line|#define SC_MODE_SENSE_6&t;&t;&t;0x1a
DECL|macro|SC_MODE_SENSE_10
mdefine_line|#define SC_MODE_SENSE_10&t;&t;0x5a
DECL|macro|SC_PREVENT_ALLOW_MEDIUM_REMOVAL
mdefine_line|#define SC_PREVENT_ALLOW_MEDIUM_REMOVAL&t;0x1e
DECL|macro|SC_READ_6
mdefine_line|#define SC_READ_6&t;&t;&t;0x08
DECL|macro|SC_READ_10
mdefine_line|#define SC_READ_10&t;&t;&t;0x28
DECL|macro|SC_READ_12
mdefine_line|#define SC_READ_12&t;&t;&t;0xa8
DECL|macro|SC_READ_CAPACITY
mdefine_line|#define SC_READ_CAPACITY&t;&t;0x25
DECL|macro|SC_READ_FORMAT_CAPACITIES
mdefine_line|#define SC_READ_FORMAT_CAPACITIES&t;0x23
DECL|macro|SC_RELEASE
mdefine_line|#define SC_RELEASE&t;&t;&t;0x17
DECL|macro|SC_REQUEST_SENSE
mdefine_line|#define SC_REQUEST_SENSE&t;&t;0x03
DECL|macro|SC_RESERVE
mdefine_line|#define SC_RESERVE&t;&t;&t;0x16
DECL|macro|SC_SEND_DIAGNOSTIC
mdefine_line|#define SC_SEND_DIAGNOSTIC&t;&t;0x1d
DECL|macro|SC_START_STOP_UNIT
mdefine_line|#define SC_START_STOP_UNIT&t;&t;0x1b
DECL|macro|SC_SYNCHRONIZE_CACHE
mdefine_line|#define SC_SYNCHRONIZE_CACHE&t;&t;0x35
DECL|macro|SC_TEST_UNIT_READY
mdefine_line|#define SC_TEST_UNIT_READY&t;&t;0x00
DECL|macro|SC_VERIFY
mdefine_line|#define SC_VERIFY&t;&t;&t;0x2f
DECL|macro|SC_WRITE_6
mdefine_line|#define SC_WRITE_6&t;&t;&t;0x0a
DECL|macro|SC_WRITE_10
mdefine_line|#define SC_WRITE_10&t;&t;&t;0x2a
DECL|macro|SC_WRITE_12
mdefine_line|#define SC_WRITE_12&t;&t;&t;0xaa
multiline_comment|/* SCSI Sense Key/Additional Sense Code/ASC Qualifier values */
DECL|macro|SS_NO_SENSE
mdefine_line|#define SS_NO_SENSE&t;&t;&t;&t;0
DECL|macro|SS_COMMUNICATION_FAILURE
mdefine_line|#define SS_COMMUNICATION_FAILURE&t;&t;0x040800
DECL|macro|SS_INVALID_COMMAND
mdefine_line|#define SS_INVALID_COMMAND&t;&t;&t;0x052000
DECL|macro|SS_INVALID_FIELD_IN_CDB
mdefine_line|#define SS_INVALID_FIELD_IN_CDB&t;&t;&t;0x052400
DECL|macro|SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE
mdefine_line|#define SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE&t;0x052100
DECL|macro|SS_LOGICAL_UNIT_NOT_SUPPORTED
mdefine_line|#define SS_LOGICAL_UNIT_NOT_SUPPORTED&t;&t;0x052500
DECL|macro|SS_MEDIUM_NOT_PRESENT
mdefine_line|#define SS_MEDIUM_NOT_PRESENT&t;&t;&t;0x023a00
DECL|macro|SS_MEDIUM_REMOVAL_PREVENTED
mdefine_line|#define SS_MEDIUM_REMOVAL_PREVENTED&t;&t;0x055302
DECL|macro|SS_NOT_READY_TO_READY_TRANSITION
mdefine_line|#define SS_NOT_READY_TO_READY_TRANSITION&t;0x062800
DECL|macro|SS_RESET_OCCURRED
mdefine_line|#define SS_RESET_OCCURRED&t;&t;&t;0x062900
DECL|macro|SS_SAVING_PARAMETERS_NOT_SUPPORTED
mdefine_line|#define SS_SAVING_PARAMETERS_NOT_SUPPORTED&t;0x053900
DECL|macro|SS_UNRECOVERED_READ_ERROR
mdefine_line|#define SS_UNRECOVERED_READ_ERROR&t;&t;0x031100
DECL|macro|SS_WRITE_ERROR
mdefine_line|#define SS_WRITE_ERROR&t;&t;&t;&t;0x030c02
DECL|macro|SS_WRITE_PROTECTED
mdefine_line|#define SS_WRITE_PROTECTED&t;&t;&t;0x072700
DECL|macro|SK
mdefine_line|#define SK(x)&t;&t;((u8) ((x) &gt;&gt; 16))&t;
singleline_comment|// Sense Key byte, etc.
DECL|macro|ASC
mdefine_line|#define ASC(x)&t;&t;((u8) ((x) &gt;&gt; 8))
DECL|macro|ASCQ
mdefine_line|#define ASCQ(x)&t;&t;((u8) (x))
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * These definitions will permit the compiler to avoid generating code for&n; * parts of the driver that aren&squot;t used in the non-TEST version.  Even gcc&n; * can recognize when a test of a constant expression yields a dead code&n; * path.&n; */
macro_line|#ifdef CONFIG_USB_FILE_STORAGE_TEST
DECL|macro|transport_is_bbb
mdefine_line|#define transport_is_bbb()&t;(mod_data.transport_type == USB_PR_BULK)
DECL|macro|transport_is_cbi
mdefine_line|#define transport_is_cbi()&t;(mod_data.transport_type == USB_PR_CBI)
DECL|macro|protocol_is_scsi
mdefine_line|#define protocol_is_scsi()&t;(mod_data.protocol_type == USB_SC_SCSI)
macro_line|#else
DECL|macro|transport_is_bbb
mdefine_line|#define transport_is_bbb()&t;1
DECL|macro|transport_is_cbi
mdefine_line|#define transport_is_cbi()&t;0
DECL|macro|protocol_is_scsi
mdefine_line|#define protocol_is_scsi()&t;1
macro_line|#endif /* CONFIG_USB_FILE_STORAGE_TEST */
DECL|struct|lun
r_struct
id|lun
(brace
DECL|member|filp
r_struct
id|file
op_star
id|filp
suffix:semicolon
DECL|member|file_length
id|loff_t
id|file_length
suffix:semicolon
DECL|member|num_sectors
id|loff_t
id|num_sectors
suffix:semicolon
DECL|member|ro
r_int
r_int
id|ro
suffix:colon
l_int|1
suffix:semicolon
DECL|member|prevent_medium_removal
r_int
r_int
id|prevent_medium_removal
suffix:colon
l_int|1
suffix:semicolon
DECL|member|registered
r_int
r_int
id|registered
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sense_data
id|u32
id|sense_data
suffix:semicolon
DECL|member|sense_data_info
id|u32
id|sense_data_info
suffix:semicolon
DECL|member|unit_attention_data
id|u32
id|unit_attention_data
suffix:semicolon
DECL|member|dev
r_struct
id|device
id|dev
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|backing_file_is_open
mdefine_line|#define backing_file_is_open(curlun)&t;((curlun)-&gt;filp != NULL)
DECL|function|dev_to_lun
r_static
r_inline
r_struct
id|lun
op_star
id|dev_to_lun
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_return
id|container_of
c_func
(paren
id|dev
comma
r_struct
id|lun
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Big enough to hold our biggest descriptor */
DECL|macro|EP0_BUFSIZE
mdefine_line|#define EP0_BUFSIZE&t;256
DECL|macro|DELAYED_STATUS
mdefine_line|#define DELAYED_STATUS&t;(EP0_BUFSIZE + 999)&t;
singleline_comment|// An impossibly large value
multiline_comment|/* Number of buffers we will use.  2 is enough for double-buffering */
DECL|macro|NUM_BUFFERS
mdefine_line|#define NUM_BUFFERS&t;2
DECL|enum|fsg_buffer_state
r_enum
id|fsg_buffer_state
(brace
DECL|enumerator|BUF_STATE_EMPTY
id|BUF_STATE_EMPTY
op_assign
l_int|0
comma
DECL|enumerator|BUF_STATE_FULL
id|BUF_STATE_FULL
comma
DECL|enumerator|BUF_STATE_BUSY
id|BUF_STATE_BUSY
)brace
suffix:semicolon
DECL|struct|fsg_buffhd
r_struct
id|fsg_buffhd
(brace
DECL|member|buf
r_void
op_star
id|buf
suffix:semicolon
DECL|member|dma
id|dma_addr_t
id|dma
suffix:semicolon
DECL|member|state
r_volatile
r_enum
id|fsg_buffer_state
id|state
suffix:semicolon
DECL|member|next
r_struct
id|fsg_buffhd
op_star
id|next
suffix:semicolon
multiline_comment|/* The NetChip 2280 is faster, and handles some protocol faults&n;&t; * better, if we don&squot;t submit any short bulk-out read requests.&n;&t; * So we will record the intended request length here. */
DECL|member|bulk_out_intended_length
r_int
r_int
id|bulk_out_intended_length
suffix:semicolon
DECL|member|inreq
r_struct
id|usb_request
op_star
id|inreq
suffix:semicolon
DECL|member|inreq_busy
r_volatile
r_int
id|inreq_busy
suffix:semicolon
DECL|member|outreq
r_struct
id|usb_request
op_star
id|outreq
suffix:semicolon
DECL|member|outreq_busy
r_volatile
r_int
id|outreq_busy
suffix:semicolon
)brace
suffix:semicolon
DECL|enum|fsg_state
r_enum
id|fsg_state
(brace
DECL|enumerator|FSG_STATE_COMMAND_PHASE
id|FSG_STATE_COMMAND_PHASE
op_assign
op_minus
l_int|10
comma
singleline_comment|// This one isn&squot;t used anywhere
DECL|enumerator|FSG_STATE_DATA_PHASE
id|FSG_STATE_DATA_PHASE
comma
DECL|enumerator|FSG_STATE_STATUS_PHASE
id|FSG_STATE_STATUS_PHASE
comma
DECL|enumerator|FSG_STATE_IDLE
id|FSG_STATE_IDLE
op_assign
l_int|0
comma
DECL|enumerator|FSG_STATE_ABORT_BULK_OUT
id|FSG_STATE_ABORT_BULK_OUT
comma
DECL|enumerator|FSG_STATE_RESET
id|FSG_STATE_RESET
comma
DECL|enumerator|FSG_STATE_INTERFACE_CHANGE
id|FSG_STATE_INTERFACE_CHANGE
comma
DECL|enumerator|FSG_STATE_CONFIG_CHANGE
id|FSG_STATE_CONFIG_CHANGE
comma
DECL|enumerator|FSG_STATE_DISCONNECT
id|FSG_STATE_DISCONNECT
comma
DECL|enumerator|FSG_STATE_EXIT
id|FSG_STATE_EXIT
comma
DECL|enumerator|FSG_STATE_TERMINATED
id|FSG_STATE_TERMINATED
)brace
suffix:semicolon
DECL|enum|data_direction
r_enum
id|data_direction
(brace
DECL|enumerator|DATA_DIR_UNKNOWN
id|DATA_DIR_UNKNOWN
op_assign
l_int|0
comma
DECL|enumerator|DATA_DIR_FROM_HOST
id|DATA_DIR_FROM_HOST
comma
DECL|enumerator|DATA_DIR_TO_HOST
id|DATA_DIR_TO_HOST
comma
DECL|enumerator|DATA_DIR_NONE
id|DATA_DIR_NONE
)brace
suffix:semicolon
DECL|struct|fsg_dev
r_struct
id|fsg_dev
(brace
multiline_comment|/* lock protects: state, all the req_busy&squot;s, and cbbuf_cmnd */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|gadget
r_struct
id|usb_gadget
op_star
id|gadget
suffix:semicolon
multiline_comment|/* filesem protects: backing files in use */
DECL|member|filesem
r_struct
id|rw_semaphore
id|filesem
suffix:semicolon
DECL|member|ep0
r_struct
id|usb_ep
op_star
id|ep0
suffix:semicolon
singleline_comment|// Handy copy of gadget-&gt;ep0
DECL|member|ep0req
r_struct
id|usb_request
op_star
id|ep0req
suffix:semicolon
singleline_comment|// For control responses
DECL|member|ep0_req_tag
r_volatile
r_int
r_int
id|ep0_req_tag
suffix:semicolon
DECL|member|ep0req_name
r_const
r_char
op_star
id|ep0req_name
suffix:semicolon
DECL|member|intreq
r_struct
id|usb_request
op_star
id|intreq
suffix:semicolon
singleline_comment|// For interrupt responses
DECL|member|intreq_busy
r_volatile
r_int
id|intreq_busy
suffix:semicolon
DECL|member|intr_buffhd
r_struct
id|fsg_buffhd
op_star
id|intr_buffhd
suffix:semicolon
DECL|member|bulk_out_maxpacket
r_int
r_int
id|bulk_out_maxpacket
suffix:semicolon
DECL|member|state
r_enum
id|fsg_state
id|state
suffix:semicolon
singleline_comment|// For exception handling
DECL|member|exception_req_tag
r_int
r_int
id|exception_req_tag
suffix:semicolon
DECL|member|config
DECL|member|new_config
id|u8
id|config
comma
id|new_config
suffix:semicolon
DECL|member|running
r_int
r_int
id|running
suffix:colon
l_int|1
suffix:semicolon
DECL|member|bulk_in_enabled
r_int
r_int
id|bulk_in_enabled
suffix:colon
l_int|1
suffix:semicolon
DECL|member|bulk_out_enabled
r_int
r_int
id|bulk_out_enabled
suffix:colon
l_int|1
suffix:semicolon
DECL|member|intr_in_enabled
r_int
r_int
id|intr_in_enabled
suffix:colon
l_int|1
suffix:semicolon
DECL|member|phase_error
r_int
r_int
id|phase_error
suffix:colon
l_int|1
suffix:semicolon
DECL|member|short_packet_received
r_int
r_int
id|short_packet_received
suffix:colon
l_int|1
suffix:semicolon
DECL|member|bad_lun_okay
r_int
r_int
id|bad_lun_okay
suffix:colon
l_int|1
suffix:semicolon
DECL|member|atomic_bitflags
r_int
r_int
id|atomic_bitflags
suffix:semicolon
DECL|macro|REGISTERED
mdefine_line|#define REGISTERED&t;&t;0
DECL|macro|CLEAR_BULK_HALTS
mdefine_line|#define CLEAR_BULK_HALTS&t;1
DECL|macro|SUSPENDED
mdefine_line|#define SUSPENDED&t;&t;2
DECL|member|bulk_in
r_struct
id|usb_ep
op_star
id|bulk_in
suffix:semicolon
DECL|member|bulk_out
r_struct
id|usb_ep
op_star
id|bulk_out
suffix:semicolon
DECL|member|intr_in
r_struct
id|usb_ep
op_star
id|intr_in
suffix:semicolon
DECL|member|next_buffhd_to_fill
r_struct
id|fsg_buffhd
op_star
id|next_buffhd_to_fill
suffix:semicolon
DECL|member|next_buffhd_to_drain
r_struct
id|fsg_buffhd
op_star
id|next_buffhd_to_drain
suffix:semicolon
DECL|member|buffhds
r_struct
id|fsg_buffhd
id|buffhds
(braket
id|NUM_BUFFERS
)braket
suffix:semicolon
DECL|member|thread_wqh
id|wait_queue_head_t
id|thread_wqh
suffix:semicolon
DECL|member|thread_wakeup_needed
r_int
id|thread_wakeup_needed
suffix:semicolon
DECL|member|thread_notifier
r_struct
id|completion
id|thread_notifier
suffix:semicolon
DECL|member|thread_pid
r_int
id|thread_pid
suffix:semicolon
DECL|member|thread_task
r_struct
id|task_struct
op_star
id|thread_task
suffix:semicolon
DECL|member|thread_signal_mask
id|sigset_t
id|thread_signal_mask
suffix:semicolon
DECL|member|cmnd_size
r_int
id|cmnd_size
suffix:semicolon
DECL|member|cmnd
id|u8
id|cmnd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
DECL|member|data_dir
r_enum
id|data_direction
id|data_dir
suffix:semicolon
DECL|member|data_size
id|u32
id|data_size
suffix:semicolon
DECL|member|data_size_from_cmnd
id|u32
id|data_size_from_cmnd
suffix:semicolon
DECL|member|tag
id|u32
id|tag
suffix:semicolon
DECL|member|lun
r_int
r_int
id|lun
suffix:semicolon
DECL|member|residue
id|u32
id|residue
suffix:semicolon
DECL|member|usb_amount_left
id|u32
id|usb_amount_left
suffix:semicolon
multiline_comment|/* The CB protocol offers no way for a host to know when a command&n;&t; * has completed.  As a result the next command may arrive early,&n;&t; * and we will still have to handle it.  For that reason we need&n;&t; * a buffer to store new commands when using CB (or CBI, which&n;&t; * does not oblige a host to wait for command completion either). */
DECL|member|cbbuf_cmnd_size
r_int
id|cbbuf_cmnd_size
suffix:semicolon
DECL|member|cbbuf_cmnd
id|u8
id|cbbuf_cmnd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
DECL|member|nluns
r_int
r_int
id|nluns
suffix:semicolon
DECL|member|luns
r_struct
id|lun
op_star
id|luns
suffix:semicolon
DECL|member|curlun
r_struct
id|lun
op_star
id|curlun
suffix:semicolon
DECL|member|lun_released
r_struct
id|completion
id|lun_released
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|fsg_routine_t
r_typedef
r_void
(paren
op_star
id|fsg_routine_t
)paren
(paren
r_struct
id|fsg_dev
op_star
)paren
suffix:semicolon
DECL|function|exception_in_progress
r_static
r_int
r_inline
id|exception_in_progress
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_return
(paren
id|fsg-&gt;state
OG
id|FSG_STATE_IDLE
)paren
suffix:semicolon
)brace
multiline_comment|/* Make bulk-out requests be divisible by the maxpacket size */
DECL|function|set_bulk_out_req_length
r_static
r_void
r_inline
id|set_bulk_out_req_length
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|fsg_buffhd
op_star
id|bh
comma
r_int
r_int
id|length
)paren
(brace
r_int
r_int
id|rem
suffix:semicolon
id|bh-&gt;bulk_out_intended_length
op_assign
id|length
suffix:semicolon
id|rem
op_assign
id|length
op_mod
id|fsg-&gt;bulk_out_maxpacket
suffix:semicolon
r_if
c_cond
(paren
id|rem
OG
l_int|0
)paren
id|length
op_add_assign
id|fsg-&gt;bulk_out_maxpacket
op_minus
id|rem
suffix:semicolon
id|bh-&gt;outreq-&gt;length
op_assign
id|length
suffix:semicolon
)brace
DECL|variable|the_fsg
r_static
r_struct
id|fsg_dev
op_star
id|the_fsg
suffix:semicolon
DECL|variable|fsg_driver
r_static
r_struct
id|usb_gadget_driver
id|fsg_driver
suffix:semicolon
r_static
r_void
id|close_backing_file
c_func
(paren
r_struct
id|lun
op_star
id|curlun
)paren
suffix:semicolon
r_static
r_void
id|close_all_backing_files
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#ifdef DUMP_MSGS
DECL|function|dump_msg
r_static
r_void
id|dump_msg
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_const
r_char
op_star
id|label
comma
r_const
id|u8
op_star
id|buf
comma
r_int
r_int
id|length
)paren
(brace
r_int
r_int
id|start
comma
id|num
comma
id|i
suffix:semicolon
r_char
id|line
(braket
l_int|52
)braket
comma
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|length
op_ge
l_int|512
)paren
r_return
suffix:semicolon
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;%s, length %u:&bslash;n&quot;
comma
id|label
comma
id|length
)paren
suffix:semicolon
id|start
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
id|num
op_assign
id|min
c_func
(paren
id|length
comma
l_int|16u
)paren
suffix:semicolon
id|p
op_assign
id|line
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
l_int|8
)paren
op_star
id|p
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; %02x&quot;
comma
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|p
op_add_assign
l_int|3
suffix:semicolon
)brace
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%6x: %s&bslash;n&quot;
comma
id|start
comma
id|line
)paren
suffix:semicolon
id|buf
op_add_assign
id|num
suffix:semicolon
id|start
op_add_assign
id|num
suffix:semicolon
id|length
op_sub_assign
id|num
suffix:semicolon
)brace
)brace
DECL|function|dump_cdb
r_static
r_void
r_inline
id|dump_cdb
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
)brace
macro_line|#else
DECL|function|dump_msg
r_static
r_void
r_inline
id|dump_msg
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_const
r_char
op_star
id|label
comma
r_const
id|u8
op_star
id|buf
comma
r_int
r_int
id|length
)paren
(brace
)brace
DECL|function|dump_cdb
r_static
r_void
r_inline
id|dump_cdb
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|cmdbuf
(braket
l_int|3
op_star
id|MAX_COMMAND_SIZE
op_plus
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fsg-&gt;cmnd_size
suffix:semicolon
op_increment
id|i
)paren
id|sprintf
c_func
(paren
id|cmdbuf
op_plus
id|i
op_star
l_int|3
comma
l_string|&quot; %02x&quot;
comma
id|fsg-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;SCSI CDB: %s&bslash;n&quot;
comma
id|cmdbuf
)paren
suffix:semicolon
)brace
macro_line|#endif /* DUMP_MSGS */
DECL|function|fsg_set_halt
r_static
r_int
id|fsg_set_halt
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|usb_ep
op_star
id|ep
)paren
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_eq
id|fsg-&gt;bulk_in
)paren
id|name
op_assign
l_string|&quot;bulk-in&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ep
op_eq
id|fsg-&gt;bulk_out
)paren
id|name
op_assign
l_string|&quot;bulk-out&quot;
suffix:semicolon
r_else
id|name
op_assign
id|ep-&gt;name
suffix:semicolon
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;%s set halt&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
id|usb_ep_set_halt
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Routines for unaligned data access */
DECL|function|get_be16
r_static
id|u16
r_inline
id|get_be16
c_func
(paren
id|u8
op_star
id|buf
)paren
(brace
r_return
(paren
(paren
id|u16
)paren
id|buf
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u16
)paren
id|buf
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
DECL|function|get_be32
r_static
id|u32
r_inline
id|get_be32
c_func
(paren
id|u8
op_star
id|buf
)paren
(brace
r_return
(paren
(paren
id|u32
)paren
id|buf
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
id|buf
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
id|buf
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
id|buf
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
DECL|function|put_be16
r_static
r_void
r_inline
id|put_be16
c_func
(paren
id|u8
op_star
id|buf
comma
id|u16
id|val
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
id|val
op_rshift
l_int|8
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|val
suffix:semicolon
)brace
DECL|function|put_be32
r_static
r_void
r_inline
id|put_be32
c_func
(paren
id|u8
op_star
id|buf
comma
id|u32
id|val
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
id|val
op_rshift
l_int|24
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|val
op_rshift
l_int|16
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|val
op_rshift
l_int|8
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
id|val
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * DESCRIPTORS ... most are static, but strings and (full) configuration&n; * descriptors are built on demand.  Also the (static) config and interface&n; * descriptors are adjusted during fsg_bind().&n; */
DECL|macro|STRING_MANUFACTURER
mdefine_line|#define STRING_MANUFACTURER&t;1
DECL|macro|STRING_PRODUCT
mdefine_line|#define STRING_PRODUCT&t;&t;2
DECL|macro|STRING_SERIAL
mdefine_line|#define STRING_SERIAL&t;&t;3
multiline_comment|/* There is only one configuration. */
DECL|macro|CONFIG_VALUE
mdefine_line|#define&t;CONFIG_VALUE&t;&t;1
r_static
r_struct
id|usb_device_descriptor
DECL|variable|device_desc
id|device_desc
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|device_desc
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_DEVICE
comma
dot
id|bcdUSB
op_assign
id|__constant_cpu_to_le16
c_func
(paren
l_int|0x0200
)paren
comma
dot
id|bDeviceClass
op_assign
id|USB_CLASS_PER_INTERFACE
comma
multiline_comment|/* The next three values can be overridden by module parameters */
dot
id|idVendor
op_assign
id|__constant_cpu_to_le16
c_func
(paren
id|DRIVER_VENDOR_ID
)paren
comma
dot
id|idProduct
op_assign
id|__constant_cpu_to_le16
c_func
(paren
id|DRIVER_PRODUCT_ID
)paren
comma
dot
id|bcdDevice
op_assign
id|__constant_cpu_to_le16
c_func
(paren
l_int|0xffff
)paren
comma
dot
id|iManufacturer
op_assign
id|STRING_MANUFACTURER
comma
dot
id|iProduct
op_assign
id|STRING_PRODUCT
comma
dot
id|iSerialNumber
op_assign
id|STRING_SERIAL
comma
dot
id|bNumConfigurations
op_assign
l_int|1
comma
)brace
suffix:semicolon
r_static
r_struct
id|usb_config_descriptor
DECL|variable|config_desc
id|config_desc
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|config_desc
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_CONFIG
comma
multiline_comment|/* wTotalLength computed by usb_gadget_config_buf() */
dot
id|bNumInterfaces
op_assign
l_int|1
comma
dot
id|bConfigurationValue
op_assign
id|CONFIG_VALUE
comma
dot
id|bmAttributes
op_assign
id|USB_CONFIG_ATT_ONE
op_or
id|USB_CONFIG_ATT_SELFPOWER
comma
dot
id|bMaxPower
op_assign
l_int|1
comma
singleline_comment|// self-powered
)brace
suffix:semicolon
r_static
r_struct
id|usb_otg_descriptor
DECL|variable|otg_desc
id|otg_desc
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
(paren
id|otg_desc
)paren
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_OTG
comma
dot
id|bmAttributes
op_assign
id|USB_OTG_SRP
comma
)brace
suffix:semicolon
multiline_comment|/* There is only one interface. */
r_static
r_struct
id|usb_interface_descriptor
DECL|variable|intf_desc
id|intf_desc
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|intf_desc
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_INTERFACE
comma
dot
id|bNumEndpoints
op_assign
l_int|2
comma
singleline_comment|// Adjusted during fsg_bind()
dot
id|bInterfaceClass
op_assign
id|USB_CLASS_MASS_STORAGE
comma
dot
id|bInterfaceSubClass
op_assign
id|USB_SC_SCSI
comma
singleline_comment|// Adjusted during fsg_bind()
dot
id|bInterfaceProtocol
op_assign
id|USB_PR_BULK
comma
singleline_comment|// Adjusted during fsg_bind()
)brace
suffix:semicolon
multiline_comment|/* Three full-speed endpoint descriptors: bulk-in, bulk-out,&n; * and interrupt-in. */
r_static
r_struct
id|usb_endpoint_descriptor
DECL|variable|fs_bulk_in_desc
id|fs_bulk_in_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_IN
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
multiline_comment|/* wMaxPacketSize set by autoconfiguration */
)brace
suffix:semicolon
r_static
r_struct
id|usb_endpoint_descriptor
DECL|variable|fs_bulk_out_desc
id|fs_bulk_out_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_OUT
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
multiline_comment|/* wMaxPacketSize set by autoconfiguration */
)brace
suffix:semicolon
r_static
r_struct
id|usb_endpoint_descriptor
DECL|variable|fs_intr_in_desc
id|fs_intr_in_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_IN
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_INT
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
c_func
(paren
l_int|2
)paren
comma
dot
id|bInterval
op_assign
l_int|32
comma
singleline_comment|// frames -&gt; 32 ms
)brace
suffix:semicolon
DECL|variable|fs_function
r_static
r_const
r_struct
id|usb_descriptor_header
op_star
id|fs_function
(braket
)braket
op_assign
(brace
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|otg_desc
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|intf_desc
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|fs_bulk_in_desc
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|fs_bulk_out_desc
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|fs_intr_in_desc
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|macro|FS_FUNCTION_PRE_EP_ENTRIES
mdefine_line|#define FS_FUNCTION_PRE_EP_ENTRIES&t;2
macro_line|#ifdef&t;CONFIG_USB_GADGET_DUALSPEED
multiline_comment|/*&n; * USB 2.0 devices need to expose both high speed and full speed&n; * descriptors, unless they only run at full speed.&n; *&n; * That means alternate endpoint descriptors (bigger packets)&n; * and a &quot;device qualifier&quot; ... plus more construction options&n; * for the config descriptor.&n; */
r_static
r_struct
id|usb_qualifier_descriptor
DECL|variable|dev_qualifier
id|dev_qualifier
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|dev_qualifier
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_DEVICE_QUALIFIER
comma
dot
id|bcdUSB
op_assign
id|__constant_cpu_to_le16
c_func
(paren
l_int|0x0200
)paren
comma
dot
id|bDeviceClass
op_assign
id|USB_CLASS_PER_INTERFACE
comma
dot
id|bNumConfigurations
op_assign
l_int|1
comma
)brace
suffix:semicolon
r_static
r_struct
id|usb_endpoint_descriptor
DECL|variable|hs_bulk_in_desc
id|hs_bulk_in_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
multiline_comment|/* bEndpointAddress copied from fs_bulk_in_desc during fsg_bind() */
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
c_func
(paren
l_int|512
)paren
comma
)brace
suffix:semicolon
r_static
r_struct
id|usb_endpoint_descriptor
DECL|variable|hs_bulk_out_desc
id|hs_bulk_out_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
multiline_comment|/* bEndpointAddress copied from fs_bulk_out_desc during fsg_bind() */
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
c_func
(paren
l_int|512
)paren
comma
dot
id|bInterval
op_assign
l_int|1
comma
singleline_comment|// NAK every 1 uframe
)brace
suffix:semicolon
r_static
r_struct
id|usb_endpoint_descriptor
DECL|variable|hs_intr_in_desc
id|hs_intr_in_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
multiline_comment|/* bEndpointAddress copied from fs_intr_in_desc during fsg_bind() */
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_INT
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
c_func
(paren
l_int|2
)paren
comma
dot
id|bInterval
op_assign
l_int|9
comma
singleline_comment|// 2**(9-1) = 256 uframes -&gt; 32 ms
)brace
suffix:semicolon
DECL|variable|hs_function
r_static
r_const
r_struct
id|usb_descriptor_header
op_star
id|hs_function
(braket
)braket
op_assign
(brace
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|otg_desc
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|intf_desc
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|hs_bulk_in_desc
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|hs_bulk_out_desc
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|hs_intr_in_desc
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|macro|HS_FUNCTION_PRE_EP_ENTRIES
mdefine_line|#define HS_FUNCTION_PRE_EP_ENTRIES&t;2
multiline_comment|/* Maxpacket and other transfer characteristics vary by speed. */
DECL|macro|ep_desc
mdefine_line|#define ep_desc(g,fs,hs)&t;(((g)-&gt;speed==USB_SPEED_HIGH) ? (hs) : (fs))
macro_line|#else
multiline_comment|/* If there&squot;s no high speed support, always use the full-speed descriptor. */
DECL|macro|ep_desc
mdefine_line|#define ep_desc(g,fs,hs)&t;fs
macro_line|#endif&t;/* !CONFIG_USB_GADGET_DUALSPEED */
multiline_comment|/* The CBI specification limits the serial string to 12 uppercase hexadecimal&n; * characters. */
DECL|variable|manufacturer
r_static
r_char
id|manufacturer
(braket
l_int|50
)braket
suffix:semicolon
DECL|variable|serial
r_static
r_char
id|serial
(braket
l_int|13
)braket
suffix:semicolon
multiline_comment|/* Static strings, in UTF-8 (for simplicity we use only ASCII characters) */
DECL|variable|strings
r_static
r_struct
id|usb_string
id|strings
(braket
)braket
op_assign
(brace
(brace
id|STRING_MANUFACTURER
comma
id|manufacturer
)brace
comma
(brace
id|STRING_PRODUCT
comma
id|longname
)brace
comma
(brace
id|STRING_SERIAL
comma
id|serial
)brace
comma
(brace
)brace
)brace
suffix:semicolon
DECL|variable|stringtab
r_static
r_struct
id|usb_gadget_strings
id|stringtab
op_assign
(brace
dot
id|language
op_assign
l_int|0x0409
comma
singleline_comment|// en-us
dot
id|strings
op_assign
id|strings
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Config descriptors must agree with the code that sets configurations&n; * and with code managing interfaces and their altsettings.  They must&n; * also handle different speeds and other-speed requests.&n; */
DECL|function|populate_config_buf
r_static
r_int
id|populate_config_buf
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
id|u8
op_star
id|buf
comma
id|u8
id|type
comma
r_int
id|index
)paren
(brace
macro_line|#ifdef CONFIG_USB_GADGET_DUALSPEED
r_enum
id|usb_device_speed
id|speed
op_assign
id|gadget-&gt;speed
suffix:semicolon
macro_line|#endif
r_int
id|len
suffix:semicolon
r_const
r_struct
id|usb_descriptor_header
op_star
op_star
id|function
suffix:semicolon
r_if
c_cond
(paren
id|index
OG
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef CONFIG_USB_GADGET_DUALSPEED
r_if
c_cond
(paren
id|type
op_eq
id|USB_DT_OTHER_SPEED_CONFIG
)paren
id|speed
op_assign
(paren
id|USB_SPEED_FULL
op_plus
id|USB_SPEED_HIGH
)paren
op_minus
id|speed
suffix:semicolon
r_if
c_cond
(paren
id|speed
op_eq
id|USB_SPEED_HIGH
)paren
id|function
op_assign
id|hs_function
suffix:semicolon
r_else
macro_line|#endif
id|function
op_assign
id|fs_function
suffix:semicolon
multiline_comment|/* for now, don&squot;t advertise srp-only devices */
r_if
c_cond
(paren
op_logical_neg
id|gadget-&gt;is_otg
)paren
id|function
op_increment
suffix:semicolon
id|len
op_assign
id|usb_gadget_config_buf
c_func
(paren
op_amp
id|config_desc
comma
id|buf
comma
id|EP0_BUFSIZE
comma
id|function
)paren
suffix:semicolon
(paren
(paren
r_struct
id|usb_config_descriptor
op_star
)paren
id|buf
)paren
op_member_access_from_pointer
id|bDescriptorType
op_assign
id|type
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* These routines may be called in process context or in_irq */
DECL|function|wakeup_thread
r_static
r_void
id|wakeup_thread
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
multiline_comment|/* Tell the main thread that something has happened */
id|fsg-&gt;thread_wakeup_needed
op_assign
l_int|1
suffix:semicolon
id|wake_up_all
c_func
(paren
op_amp
id|fsg-&gt;thread_wqh
)paren
suffix:semicolon
)brace
DECL|function|raise_exception
r_static
r_void
id|raise_exception
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_enum
id|fsg_state
id|new_state
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|task_struct
op_star
id|thread_task
suffix:semicolon
multiline_comment|/* Do nothing if a higher-priority exception is already in progress.&n;&t; * If a lower-or-equal priority exception is in progress, preempt it&n;&t; * and notify the main thread by sending it a signal. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|fsg-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;state
op_le
id|new_state
)paren
(brace
id|fsg-&gt;exception_req_tag
op_assign
id|fsg-&gt;ep0_req_tag
suffix:semicolon
id|fsg-&gt;state
op_assign
id|new_state
suffix:semicolon
id|thread_task
op_assign
id|fsg-&gt;thread_task
suffix:semicolon
r_if
c_cond
(paren
id|thread_task
)paren
id|send_sig_info
c_func
(paren
id|SIGUSR1
comma
id|SEND_SIG_FORCED
comma
id|thread_task
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|fsg-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* The disconnect callback and ep0 routines.  These always run in_irq,&n; * except that ep0_queue() is called in the main thread to acknowledge&n; * completion of various requests: set config, set interface, and&n; * Bulk-only device reset. */
DECL|function|fsg_disconnect
r_static
r_void
id|fsg_disconnect
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
id|get_gadget_data
c_func
(paren
id|gadget
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;disconnect or port reset&bslash;n&quot;
)paren
suffix:semicolon
id|raise_exception
c_func
(paren
id|fsg
comma
id|FSG_STATE_DISCONNECT
)paren
suffix:semicolon
)brace
DECL|function|ep0_queue
r_static
r_int
id|ep0_queue
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|usb_ep_queue
c_func
(paren
id|fsg-&gt;ep0
comma
id|fsg-&gt;ep0req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
op_logical_and
id|rc
op_ne
op_minus
id|ESHUTDOWN
)paren
(brace
multiline_comment|/* We can&squot;t do much more than wait for a reset */
id|WARN
c_func
(paren
id|fsg
comma
l_string|&quot;error in submission: %s --&gt; %d&bslash;n&quot;
comma
id|fsg-&gt;ep0-&gt;name
comma
id|rc
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|ep0_complete
r_static
r_void
id|ep0_complete
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
(paren
r_struct
id|fsg_dev
op_star
)paren
id|ep-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;actual
OG
l_int|0
)paren
id|dump_msg
c_func
(paren
id|fsg
comma
id|fsg-&gt;ep0req_name
comma
id|req-&gt;buf
comma
id|req-&gt;actual
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;status
op_logical_or
id|req-&gt;actual
op_ne
id|req-&gt;length
)paren
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;%s --&gt; %d, %u/%u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|req-&gt;status
comma
id|req-&gt;actual
comma
id|req-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;status
op_eq
op_minus
id|ECONNRESET
)paren
singleline_comment|// Request was cancelled
id|usb_ep_fifo_flush
c_func
(paren
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;status
op_eq
l_int|0
op_logical_and
id|req-&gt;context
)paren
(paren
(paren
id|fsg_routine_t
)paren
(paren
id|req-&gt;context
)paren
)paren
(paren
id|fsg
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Bulk and interrupt endpoint completion handlers.&n; * These always run in_irq. */
DECL|function|bulk_in_complete
r_static
r_void
id|bulk_in_complete
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
(paren
r_struct
id|fsg_dev
op_star
)paren
id|ep-&gt;driver_data
suffix:semicolon
r_struct
id|fsg_buffhd
op_star
id|bh
op_assign
(paren
r_struct
id|fsg_buffhd
op_star
)paren
id|req-&gt;context
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;status
op_logical_or
id|req-&gt;actual
op_ne
id|req-&gt;length
)paren
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;%s --&gt; %d, %u/%u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|req-&gt;status
comma
id|req-&gt;actual
comma
id|req-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;status
op_eq
op_minus
id|ECONNRESET
)paren
singleline_comment|// Request was cancelled
id|usb_ep_fifo_flush
c_func
(paren
id|ep
)paren
suffix:semicolon
multiline_comment|/* Hold the lock while we update the request and buffer states */
id|spin_lock
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
id|bh-&gt;inreq_busy
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;state
op_assign
id|BUF_STATE_EMPTY
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
id|wakeup_thread
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
DECL|function|bulk_out_complete
r_static
r_void
id|bulk_out_complete
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
(paren
r_struct
id|fsg_dev
op_star
)paren
id|ep-&gt;driver_data
suffix:semicolon
r_struct
id|fsg_buffhd
op_star
id|bh
op_assign
(paren
r_struct
id|fsg_buffhd
op_star
)paren
id|req-&gt;context
suffix:semicolon
id|dump_msg
c_func
(paren
id|fsg
comma
l_string|&quot;bulk-out&quot;
comma
id|req-&gt;buf
comma
id|req-&gt;actual
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;status
op_logical_or
id|req-&gt;actual
op_ne
id|bh-&gt;bulk_out_intended_length
)paren
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;%s --&gt; %d, %u/%u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|req-&gt;status
comma
id|req-&gt;actual
comma
id|bh-&gt;bulk_out_intended_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;status
op_eq
op_minus
id|ECONNRESET
)paren
singleline_comment|// Request was cancelled
id|usb_ep_fifo_flush
c_func
(paren
id|ep
)paren
suffix:semicolon
multiline_comment|/* Hold the lock while we update the request and buffer states */
id|spin_lock
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
id|bh-&gt;outreq_busy
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;state
op_assign
id|BUF_STATE_FULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
id|wakeup_thread
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_USB_FILE_STORAGE_TEST
DECL|function|intr_in_complete
r_static
r_void
id|intr_in_complete
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
(paren
r_struct
id|fsg_dev
op_star
)paren
id|ep-&gt;driver_data
suffix:semicolon
r_struct
id|fsg_buffhd
op_star
id|bh
op_assign
(paren
r_struct
id|fsg_buffhd
op_star
)paren
id|req-&gt;context
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;status
op_logical_or
id|req-&gt;actual
op_ne
id|req-&gt;length
)paren
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;%s --&gt; %d, %u/%u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|req-&gt;status
comma
id|req-&gt;actual
comma
id|req-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;status
op_eq
op_minus
id|ECONNRESET
)paren
singleline_comment|// Request was cancelled
id|usb_ep_fifo_flush
c_func
(paren
id|ep
)paren
suffix:semicolon
multiline_comment|/* Hold the lock while we update the request and buffer states */
id|spin_lock
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
id|fsg-&gt;intreq_busy
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;state
op_assign
id|BUF_STATE_EMPTY
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
id|wakeup_thread
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|intr_in_complete
r_static
r_void
id|intr_in_complete
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
)brace
macro_line|#endif /* CONFIG_USB_FILE_STORAGE_TEST */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Ep0 class-specific handlers.  These always run in_irq. */
macro_line|#ifdef CONFIG_USB_FILE_STORAGE_TEST
DECL|function|received_cbi_adsc
r_static
r_void
id|received_cbi_adsc
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|fsg_buffhd
op_star
id|bh
)paren
(brace
r_struct
id|usb_request
op_star
id|req
op_assign
id|fsg-&gt;ep0req
suffix:semicolon
r_static
id|u8
id|cbi_reset_cmnd
(braket
l_int|6
)braket
op_assign
(brace
id|SC_SEND_DIAGNOSTIC
comma
l_int|4
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
multiline_comment|/* Error in command transfer? */
r_if
c_cond
(paren
id|req-&gt;status
op_logical_or
id|req-&gt;length
op_ne
id|req-&gt;actual
op_logical_or
id|req-&gt;actual
template_param
id|MAX_COMMAND_SIZE
)paren
(brace
multiline_comment|/* Not all controllers allow a protocol stall after&n;&t;&t; * receiving control-out data, but we&squot;ll try anyway. */
id|fsg_set_halt
c_func
(paren
id|fsg
comma
id|fsg-&gt;ep0
)paren
suffix:semicolon
r_return
suffix:semicolon
singleline_comment|// Wait for reset
)brace
multiline_comment|/* Is it the special reset command? */
r_if
c_cond
(paren
id|req-&gt;actual
op_ge
r_sizeof
id|cbi_reset_cmnd
op_logical_and
id|memcmp
c_func
(paren
id|req-&gt;buf
comma
id|cbi_reset_cmnd
comma
r_sizeof
id|cbi_reset_cmnd
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Raise an exception to stop the current operation&n;&t;&t; * and reinitialize our state. */
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;cbi reset request&bslash;n&quot;
)paren
suffix:semicolon
id|raise_exception
c_func
(paren
id|fsg
comma
id|FSG_STATE_RESET
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;CB[I] accept device-specific command&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Save the command for later */
r_if
c_cond
(paren
id|fsg-&gt;cbbuf_cmnd_size
)paren
id|WARN
c_func
(paren
id|fsg
comma
l_string|&quot;CB[I] overwriting previous command&bslash;n&quot;
)paren
suffix:semicolon
id|fsg-&gt;cbbuf_cmnd_size
op_assign
id|req-&gt;actual
suffix:semicolon
id|memcpy
c_func
(paren
id|fsg-&gt;cbbuf_cmnd
comma
id|req-&gt;buf
comma
id|fsg-&gt;cbbuf_cmnd_size
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
id|wakeup_thread
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|received_cbi_adsc
r_static
r_void
id|received_cbi_adsc
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|fsg_buffhd
op_star
id|bh
)paren
(brace
)brace
macro_line|#endif /* CONFIG_USB_FILE_STORAGE_TEST */
DECL|function|class_setup_req
r_static
r_int
id|class_setup_req
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_const
r_struct
id|usb_ctrlrequest
op_star
id|ctrl
)paren
(brace
r_struct
id|usb_request
op_star
id|req
op_assign
id|fsg-&gt;ep0req
suffix:semicolon
r_int
id|value
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fsg-&gt;config
)paren
r_return
id|value
suffix:semicolon
multiline_comment|/* Handle Bulk-only class-specific requests */
r_if
c_cond
(paren
id|transport_is_bbb
c_func
(paren
)paren
)paren
(brace
r_switch
c_cond
(paren
id|ctrl-&gt;bRequest
)paren
(brace
r_case
id|USB_BULK_RESET_REQUEST
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_OUT
op_or
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;wIndex
op_ne
l_int|0
)paren
(brace
id|value
op_assign
op_minus
id|EDOM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Raise an exception to stop the current operation&n;&t;&t;&t; * and reinitialize our state. */
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;bulk reset request&bslash;n&quot;
)paren
suffix:semicolon
id|raise_exception
c_func
(paren
id|fsg
comma
id|FSG_STATE_RESET
)paren
suffix:semicolon
id|value
op_assign
id|DELAYED_STATUS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_BULK_GET_MAX_LUN_REQUEST
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_IN
op_or
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;wIndex
op_ne
l_int|0
)paren
(brace
id|value
op_assign
op_minus
id|EDOM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;get max LUN&bslash;n&quot;
)paren
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|req-&gt;buf
op_assign
id|fsg-&gt;nluns
op_minus
l_int|1
suffix:semicolon
id|value
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Handle CBI class-specific requests */
r_else
(brace
r_switch
c_cond
(paren
id|ctrl-&gt;bRequest
)paren
(brace
r_case
id|USB_CBI_ADSC_REQUEST
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_OUT
op_or
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;wIndex
op_ne
l_int|0
)paren
(brace
id|value
op_assign
op_minus
id|EDOM
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctrl-&gt;wLength
OG
id|MAX_COMMAND_SIZE
)paren
(brace
id|value
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_break
suffix:semicolon
)brace
id|value
op_assign
id|ctrl-&gt;wLength
suffix:semicolon
id|fsg-&gt;ep0req-&gt;context
op_assign
id|received_cbi_adsc
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|value
op_eq
op_minus
id|EOPNOTSUPP
)paren
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;unknown class-specific control req &quot;
l_string|&quot;%02x.%02x v%04x i%04x l%u&bslash;n&quot;
comma
id|ctrl-&gt;bRequestType
comma
id|ctrl-&gt;bRequest
comma
id|ctrl-&gt;wValue
comma
id|ctrl-&gt;wIndex
comma
id|ctrl-&gt;wLength
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Ep0 standard request handlers.  These always run in_irq. */
DECL|function|standard_setup_req
r_static
r_int
id|standard_setup_req
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_const
r_struct
id|usb_ctrlrequest
op_star
id|ctrl
)paren
(brace
r_struct
id|usb_request
op_star
id|req
op_assign
id|fsg-&gt;ep0req
suffix:semicolon
r_int
id|value
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* Usually this just stores reply data in the pre-allocated ep0 buffer,&n;&t; * but config change events will also reconfigure hardware. */
r_switch
c_cond
(paren
id|ctrl-&gt;bRequest
)paren
(brace
r_case
id|USB_REQ_GET_DESCRIPTOR
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_IN
op_or
id|USB_TYPE_STANDARD
op_or
id|USB_RECIP_DEVICE
)paren
)paren
r_break
suffix:semicolon
r_switch
c_cond
(paren
id|ctrl-&gt;wValue
op_rshift
l_int|8
)paren
(brace
r_case
id|USB_DT_DEVICE
suffix:colon
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;get device descriptor&bslash;n&quot;
)paren
suffix:semicolon
id|value
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
r_sizeof
id|device_desc
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|req-&gt;buf
comma
op_amp
id|device_desc
comma
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_USB_GADGET_DUALSPEED
r_case
id|USB_DT_DEVICE_QUALIFIER
suffix:colon
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;get device qualifier&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fsg-&gt;gadget-&gt;is_dualspeed
)paren
r_break
suffix:semicolon
id|value
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
r_sizeof
id|dev_qualifier
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|req-&gt;buf
comma
op_amp
id|dev_qualifier
comma
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_OTHER_SPEED_CONFIG
suffix:colon
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;get other-speed config descriptor&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fsg-&gt;gadget-&gt;is_dualspeed
)paren
r_break
suffix:semicolon
r_goto
id|get_config
suffix:semicolon
macro_line|#endif
r_case
id|USB_DT_CONFIG
suffix:colon
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;get configuration descriptor&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_GADGET_DUALSPEED
id|get_config
suffix:colon
macro_line|#endif
id|value
op_assign
id|populate_config_buf
c_func
(paren
id|fsg-&gt;gadget
comma
id|req-&gt;buf
comma
id|ctrl-&gt;wValue
op_rshift
l_int|8
comma
id|ctrl-&gt;wValue
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
l_int|0
)paren
id|value
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_STRING
suffix:colon
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;get string descriptor&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* wIndex == language code */
id|value
op_assign
id|usb_gadget_get_string
c_func
(paren
op_amp
id|stringtab
comma
id|ctrl-&gt;wValue
op_amp
l_int|0xff
comma
id|req-&gt;buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
l_int|0
)paren
id|value
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* One config, two speeds */
r_case
id|USB_REQ_SET_CONFIGURATION
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_OUT
op_or
id|USB_TYPE_STANDARD
op_or
id|USB_RECIP_DEVICE
)paren
)paren
r_break
suffix:semicolon
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;set configuration&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;wValue
op_eq
id|CONFIG_VALUE
op_logical_or
id|ctrl-&gt;wValue
op_eq
l_int|0
)paren
(brace
id|fsg-&gt;new_config
op_assign
id|ctrl-&gt;wValue
suffix:semicolon
multiline_comment|/* Raise an exception to wipe out previous transaction&n;&t;&t;&t; * state (queued bufs, etc) and set the new config. */
id|raise_exception
c_func
(paren
id|fsg
comma
id|FSG_STATE_CONFIG_CHANGE
)paren
suffix:semicolon
id|value
op_assign
id|DELAYED_STATUS
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|USB_REQ_GET_CONFIGURATION
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_IN
op_or
id|USB_TYPE_STANDARD
op_or
id|USB_RECIP_DEVICE
)paren
)paren
r_break
suffix:semicolon
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;get configuration&bslash;n&quot;
)paren
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|req-&gt;buf
op_assign
id|fsg-&gt;config
suffix:semicolon
id|value
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_REQ_SET_INTERFACE
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_OUT
op_or
id|USB_TYPE_STANDARD
op_or
id|USB_RECIP_INTERFACE
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;config
op_logical_and
id|ctrl-&gt;wIndex
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Raise an exception to wipe out previous transaction&n;&t;&t;&t; * state (queued bufs, etc) and install the new&n;&t;&t;&t; * interface altsetting. */
id|raise_exception
c_func
(paren
id|fsg
comma
id|FSG_STATE_INTERFACE_CHANGE
)paren
suffix:semicolon
id|value
op_assign
id|DELAYED_STATUS
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|USB_REQ_GET_INTERFACE
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_IN
op_or
id|USB_TYPE_STANDARD
op_or
id|USB_RECIP_INTERFACE
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fsg-&gt;config
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;wIndex
op_ne
l_int|0
)paren
(brace
id|value
op_assign
op_minus
id|EDOM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;get interface&bslash;n&quot;
)paren
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|req-&gt;buf
op_assign
l_int|0
suffix:semicolon
id|value
op_assign
id|min
c_func
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;unknown control req %02x.%02x v%04x i%04x l%u&bslash;n&quot;
comma
id|ctrl-&gt;bRequestType
comma
id|ctrl-&gt;bRequest
comma
id|ctrl-&gt;wValue
comma
id|ctrl-&gt;wIndex
comma
id|ctrl-&gt;wLength
)paren
suffix:semicolon
)brace
r_return
id|value
suffix:semicolon
)brace
DECL|function|fsg_setup
r_static
r_int
id|fsg_setup
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
r_const
r_struct
id|usb_ctrlrequest
op_star
id|ctrl
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
id|get_gadget_data
c_func
(paren
id|gadget
)paren
suffix:semicolon
r_int
id|rc
suffix:semicolon
op_increment
id|fsg-&gt;ep0_req_tag
suffix:semicolon
singleline_comment|// Record arrival of a new request
id|fsg-&gt;ep0req-&gt;context
op_assign
l_int|NULL
suffix:semicolon
id|fsg-&gt;ep0req-&gt;length
op_assign
l_int|0
suffix:semicolon
id|dump_msg
c_func
(paren
id|fsg
comma
l_string|&quot;ep0-setup&quot;
comma
(paren
id|u8
op_star
)paren
id|ctrl
comma
r_sizeof
(paren
op_star
id|ctrl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ctrl-&gt;bRequestType
op_amp
id|USB_TYPE_MASK
)paren
op_eq
id|USB_TYPE_CLASS
)paren
id|rc
op_assign
id|class_setup_req
c_func
(paren
id|fsg
comma
id|ctrl
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|standard_setup_req
c_func
(paren
id|fsg
comma
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Respond with data/status or defer until later? */
r_if
c_cond
(paren
id|rc
op_ge
l_int|0
op_logical_and
id|rc
op_ne
id|DELAYED_STATUS
)paren
(brace
id|fsg-&gt;ep0req-&gt;length
op_assign
id|rc
suffix:semicolon
id|fsg-&gt;ep0req-&gt;zero
op_assign
(paren
id|rc
OL
id|ctrl-&gt;wLength
op_logical_and
(paren
id|rc
op_mod
id|gadget-&gt;ep0-&gt;maxpacket
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|fsg-&gt;ep0req_name
op_assign
(paren
id|ctrl-&gt;bRequestType
op_amp
id|USB_DIR_IN
ques
c_cond
l_string|&quot;ep0-in&quot;
suffix:colon
l_string|&quot;ep0-out&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|ep0_queue
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
multiline_comment|/* Device either stalls (rc &lt; 0) or reports success */
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* All the following routines run in process context */
multiline_comment|/* Use this for bulk or interrupt transfers, not ep0 */
DECL|function|start_transfer
r_static
r_void
id|start_transfer
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
comma
r_volatile
r_int
op_star
id|pbusy
comma
r_volatile
r_enum
id|fsg_buffer_state
op_star
id|state
)paren
(brace
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_eq
id|fsg-&gt;bulk_in
)paren
id|dump_msg
c_func
(paren
id|fsg
comma
l_string|&quot;bulk-in&quot;
comma
id|req-&gt;buf
comma
id|req-&gt;length
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ep
op_eq
id|fsg-&gt;intr_in
)paren
id|dump_msg
c_func
(paren
id|fsg
comma
l_string|&quot;intr-in&quot;
comma
id|req-&gt;buf
comma
id|req-&gt;length
)paren
suffix:semicolon
op_star
id|pbusy
op_assign
l_int|1
suffix:semicolon
op_star
id|state
op_assign
id|BUF_STATE_BUSY
suffix:semicolon
id|rc
op_assign
id|usb_ep_queue
c_func
(paren
id|ep
comma
id|req
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
op_star
id|pbusy
op_assign
l_int|0
suffix:semicolon
op_star
id|state
op_assign
id|BUF_STATE_EMPTY
suffix:semicolon
multiline_comment|/* We can&squot;t do much more than wait for a reset */
multiline_comment|/* Note: currently the net2280 driver fails zero-length&n;&t;&t; * submissions if DMA is enabled. */
r_if
c_cond
(paren
id|rc
op_ne
op_minus
id|ESHUTDOWN
op_logical_and
op_logical_neg
(paren
id|rc
op_eq
op_minus
id|EOPNOTSUPP
op_logical_and
id|req-&gt;length
op_eq
l_int|0
)paren
)paren
id|WARN
c_func
(paren
id|fsg
comma
l_string|&quot;error in submission: %s --&gt; %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|rc
)paren
suffix:semicolon
)brace
)brace
DECL|function|sleep_thread
r_static
r_int
id|sleep_thread
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* Wait until a signal arrives or we are woken up */
id|rc
op_assign
id|wait_event_interruptible
c_func
(paren
id|fsg-&gt;thread_wqh
comma
id|fsg-&gt;thread_wakeup_needed
)paren
suffix:semicolon
id|fsg-&gt;thread_wakeup_needed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
id|refrigerator
c_func
(paren
id|PF_FREEZE
)paren
suffix:semicolon
r_return
(paren
id|rc
ques
c_cond
op_minus
id|EINTR
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|do_read
r_static
r_int
id|do_read
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|fsg-&gt;curlun
suffix:semicolon
id|u32
id|lba
suffix:semicolon
r_struct
id|fsg_buffhd
op_star
id|bh
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|u32
id|amount_left
suffix:semicolon
id|loff_t
id|file_offset
comma
id|file_offset_tmp
suffix:semicolon
r_int
r_int
id|amount
suffix:semicolon
r_int
r_int
id|partial_page
suffix:semicolon
id|ssize_t
id|nread
suffix:semicolon
multiline_comment|/* Get the starting Logical Block Address and check that it&squot;s&n;&t; * not too big */
r_if
c_cond
(paren
id|fsg-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|SC_READ_6
)paren
id|lba
op_assign
(paren
id|fsg-&gt;cmnd
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
id|get_be16
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_else
(brace
id|lba
op_assign
id|get_be32
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/* We allow DPO (Disable Page Out = don&squot;t save data in the&n;&t;&t; * cache) and FUA (Force Unit Access = don&squot;t read from the&n;&t;&t; * cache), but we don&squot;t implement them. */
r_if
c_cond
(paren
(paren
id|fsg-&gt;cmnd
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x18
)paren
op_ne
l_int|0
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_INVALID_FIELD_IN_CDB
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lba
op_ge
id|curlun-&gt;num_sectors
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|file_offset
op_assign
(paren
(paren
id|loff_t
)paren
id|lba
)paren
op_lshift
l_int|9
suffix:semicolon
multiline_comment|/* Carry out the file reads */
id|amount_left
op_assign
id|fsg-&gt;data_size_from_cmnd
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|amount_left
op_eq
l_int|0
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
singleline_comment|// No default reply
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Figure out how much we need to read:&n;&t;&t; * Try to read the remaining amount.&n;&t;&t; * But don&squot;t read more than the buffer size.&n;&t;&t; * And don&squot;t try to read past the end of the file.&n;&t;&t; * Finally, if we&squot;re not at a page boundary, don&squot;t read past&n;&t;&t; *&t;the next page.&n;&t;&t; * If this means reading 0 then we were asked to read past&n;&t;&t; *&t;the end of file. */
id|amount
op_assign
id|min
c_func
(paren
(paren
r_int
r_int
)paren
id|amount_left
comma
id|mod_data.buflen
)paren
suffix:semicolon
id|amount
op_assign
id|min
c_func
(paren
(paren
id|loff_t
)paren
id|amount
comma
id|curlun-&gt;file_length
op_minus
id|file_offset
)paren
suffix:semicolon
id|partial_page
op_assign
id|file_offset
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_page
OG
l_int|0
)paren
id|amount
op_assign
id|min
c_func
(paren
id|amount
comma
(paren
r_int
r_int
)paren
id|PAGE_CACHE_SIZE
op_minus
id|partial_page
)paren
suffix:semicolon
multiline_comment|/* Wait for the next buffer to become available */
id|bh
op_assign
id|fsg-&gt;next_buffhd_to_fill
suffix:semicolon
r_while
c_loop
(paren
id|bh-&gt;state
op_ne
id|BUF_STATE_EMPTY
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|sleep_thread
c_func
(paren
id|fsg
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* If we were asked to read past the end of file,&n;&t;&t; * end with an empty buffer. */
r_if
c_cond
(paren
id|amount
op_eq
l_int|0
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE
suffix:semicolon
id|curlun-&gt;sense_data_info
op_assign
id|file_offset
op_rshift
l_int|9
suffix:semicolon
id|bh-&gt;inreq-&gt;length
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;state
op_assign
id|BUF_STATE_FULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Perform the read */
id|file_offset_tmp
op_assign
id|file_offset
suffix:semicolon
id|nread
op_assign
id|vfs_read
c_func
(paren
id|curlun-&gt;filp
comma
(paren
r_char
id|__user
op_star
)paren
id|bh-&gt;buf
comma
id|amount
comma
op_amp
id|file_offset_tmp
)paren
suffix:semicolon
id|VLDBG
c_func
(paren
id|curlun
comma
l_string|&quot;file read %u @ %llu -&gt; %d&bslash;n&quot;
comma
id|amount
comma
(paren
r_int
r_int
r_int
)paren
id|file_offset
comma
(paren
r_int
)paren
id|nread
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
r_if
c_cond
(paren
id|nread
OL
l_int|0
)paren
(brace
id|LDBG
c_func
(paren
id|curlun
comma
l_string|&quot;error in file read: %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|nread
)paren
suffix:semicolon
id|nread
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nread
OL
id|amount
)paren
(brace
id|LDBG
c_func
(paren
id|curlun
comma
l_string|&quot;partial file read: %d/%u&bslash;n&quot;
comma
(paren
r_int
)paren
id|nread
comma
id|amount
)paren
suffix:semicolon
id|nread
op_sub_assign
(paren
id|nread
op_amp
l_int|511
)paren
suffix:semicolon
singleline_comment|// Round down to a block
)brace
id|file_offset
op_add_assign
id|nread
suffix:semicolon
id|amount_left
op_sub_assign
id|nread
suffix:semicolon
id|fsg-&gt;residue
op_sub_assign
id|nread
suffix:semicolon
id|bh-&gt;inreq-&gt;length
op_assign
id|nread
suffix:semicolon
id|bh-&gt;state
op_assign
id|BUF_STATE_FULL
suffix:semicolon
multiline_comment|/* If an error occurred, report it and its position */
r_if
c_cond
(paren
id|nread
OL
id|amount
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_UNRECOVERED_READ_ERROR
suffix:semicolon
id|curlun-&gt;sense_data_info
op_assign
id|file_offset
op_rshift
l_int|9
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|amount_left
op_eq
l_int|0
)paren
r_break
suffix:semicolon
singleline_comment|// No more left to read
multiline_comment|/* Send this buffer and go read some more */
id|bh-&gt;inreq-&gt;zero
op_assign
l_int|0
suffix:semicolon
id|start_transfer
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_in
comma
id|bh-&gt;inreq
comma
op_amp
id|bh-&gt;inreq_busy
comma
op_amp
id|bh-&gt;state
)paren
suffix:semicolon
id|fsg-&gt;next_buffhd_to_fill
op_assign
id|bh-&gt;next
suffix:semicolon
)brace
r_return
op_minus
id|EIO
suffix:semicolon
singleline_comment|// No default reply
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|do_write
r_static
r_int
id|do_write
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|fsg-&gt;curlun
suffix:semicolon
id|u32
id|lba
suffix:semicolon
r_struct
id|fsg_buffhd
op_star
id|bh
suffix:semicolon
r_int
id|get_some_more
suffix:semicolon
id|u32
id|amount_left_to_req
comma
id|amount_left_to_write
suffix:semicolon
id|loff_t
id|usb_offset
comma
id|file_offset
comma
id|file_offset_tmp
suffix:semicolon
r_int
r_int
id|amount
suffix:semicolon
r_int
r_int
id|partial_page
suffix:semicolon
id|ssize_t
id|nwritten
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|curlun-&gt;ro
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_WRITE_PROTECTED
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|curlun-&gt;filp-&gt;f_flags
op_and_assign
op_complement
id|O_SYNC
suffix:semicolon
singleline_comment|// Default is not to wait
multiline_comment|/* Get the starting Logical Block Address and check that it&squot;s&n;&t; * not too big */
r_if
c_cond
(paren
id|fsg-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|SC_WRITE_6
)paren
id|lba
op_assign
(paren
id|fsg-&gt;cmnd
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
id|get_be16
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_else
(brace
id|lba
op_assign
id|get_be32
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/* We allow DPO (Disable Page Out = don&squot;t save data in the&n;&t;&t; * cache) and FUA (Force Unit Access = write directly to the&n;&t;&t; * medium).  We don&squot;t implement DPO; we implement FUA by&n;&t;&t; * performing synchronous output. */
r_if
c_cond
(paren
(paren
id|fsg-&gt;cmnd
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x18
)paren
op_ne
l_int|0
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_INVALID_FIELD_IN_CDB
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fsg-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|0x08
)paren
singleline_comment|// FUA
id|curlun-&gt;filp-&gt;f_flags
op_or_assign
id|O_SYNC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lba
op_ge
id|curlun-&gt;num_sectors
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Carry out the file writes */
id|get_some_more
op_assign
l_int|1
suffix:semicolon
id|file_offset
op_assign
id|usb_offset
op_assign
(paren
(paren
id|loff_t
)paren
id|lba
)paren
op_lshift
l_int|9
suffix:semicolon
id|amount_left_to_req
op_assign
id|amount_left_to_write
op_assign
id|fsg-&gt;data_size_from_cmnd
suffix:semicolon
r_while
c_loop
(paren
id|amount_left_to_write
OG
l_int|0
)paren
(brace
multiline_comment|/* Queue a request for more data from the host */
id|bh
op_assign
id|fsg-&gt;next_buffhd_to_fill
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;state
op_eq
id|BUF_STATE_EMPTY
op_logical_and
id|get_some_more
)paren
(brace
multiline_comment|/* Figure out how much we want to get:&n;&t;&t;&t; * Try to get the remaining amount.&n;&t;&t;&t; * But don&squot;t get more than the buffer size.&n;&t;&t;&t; * And don&squot;t try to go past the end of the file.&n;&t;&t;&t; * If we&squot;re not at a page boundary,&n;&t;&t;&t; *&t;don&squot;t go past the next page.&n;&t;&t;&t; * If this means getting 0, then we were asked&n;&t;&t;&t; *&t;to write past the end of file.&n;&t;&t;&t; * Finally, round down to a block boundary. */
id|amount
op_assign
id|min
c_func
(paren
id|amount_left_to_req
comma
id|mod_data.buflen
)paren
suffix:semicolon
id|amount
op_assign
id|min
c_func
(paren
(paren
id|loff_t
)paren
id|amount
comma
id|curlun-&gt;file_length
op_minus
id|usb_offset
)paren
suffix:semicolon
id|partial_page
op_assign
id|usb_offset
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_page
OG
l_int|0
)paren
id|amount
op_assign
id|min
c_func
(paren
id|amount
comma
(paren
r_int
r_int
)paren
id|PAGE_CACHE_SIZE
op_minus
id|partial_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amount
op_eq
l_int|0
)paren
(brace
id|get_some_more
op_assign
l_int|0
suffix:semicolon
id|curlun-&gt;sense_data
op_assign
id|SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE
suffix:semicolon
id|curlun-&gt;sense_data_info
op_assign
id|usb_offset
op_rshift
l_int|9
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|amount
op_sub_assign
(paren
id|amount
op_amp
l_int|511
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amount
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Why were we were asked to transfer a&n;&t;&t;&t;&t; * partial block? */
id|get_some_more
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Get the next buffer */
id|usb_offset
op_add_assign
id|amount
suffix:semicolon
id|fsg-&gt;usb_amount_left
op_sub_assign
id|amount
suffix:semicolon
id|amount_left_to_req
op_sub_assign
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|amount_left_to_req
op_eq
l_int|0
)paren
id|get_some_more
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* amount is always divisible by 512, hence by&n;&t;&t;&t; * the bulk-out maxpacket size */
id|bh-&gt;outreq-&gt;length
op_assign
id|bh-&gt;bulk_out_intended_length
op_assign
id|amount
suffix:semicolon
id|start_transfer
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_out
comma
id|bh-&gt;outreq
comma
op_amp
id|bh-&gt;outreq_busy
comma
op_amp
id|bh-&gt;state
)paren
suffix:semicolon
id|fsg-&gt;next_buffhd_to_fill
op_assign
id|bh-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Write the received data to the backing file */
id|bh
op_assign
id|fsg-&gt;next_buffhd_to_drain
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;state
op_eq
id|BUF_STATE_EMPTY
op_logical_and
op_logical_neg
id|get_some_more
)paren
r_break
suffix:semicolon
singleline_comment|// We stopped early
r_if
c_cond
(paren
id|bh-&gt;state
op_eq
id|BUF_STATE_FULL
)paren
(brace
id|fsg-&gt;next_buffhd_to_drain
op_assign
id|bh-&gt;next
suffix:semicolon
id|bh-&gt;state
op_assign
id|BUF_STATE_EMPTY
suffix:semicolon
multiline_comment|/* Did something go wrong with the transfer? */
r_if
c_cond
(paren
id|bh-&gt;outreq-&gt;status
op_ne
l_int|0
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_COMMUNICATION_FAILURE
suffix:semicolon
id|curlun-&gt;sense_data_info
op_assign
id|file_offset
op_rshift
l_int|9
suffix:semicolon
r_break
suffix:semicolon
)brace
id|amount
op_assign
id|bh-&gt;outreq-&gt;actual
suffix:semicolon
r_if
c_cond
(paren
id|curlun-&gt;file_length
op_minus
id|file_offset
OL
id|amount
)paren
(brace
id|LERROR
c_func
(paren
id|curlun
comma
l_string|&quot;write %u @ %llu beyond end %llu&bslash;n&quot;
comma
id|amount
comma
(paren
r_int
r_int
r_int
)paren
id|file_offset
comma
(paren
r_int
r_int
r_int
)paren
id|curlun-&gt;file_length
)paren
suffix:semicolon
id|amount
op_assign
id|curlun-&gt;file_length
op_minus
id|file_offset
suffix:semicolon
)brace
multiline_comment|/* Perform the write */
id|file_offset_tmp
op_assign
id|file_offset
suffix:semicolon
id|nwritten
op_assign
id|vfs_write
c_func
(paren
id|curlun-&gt;filp
comma
(paren
r_char
id|__user
op_star
)paren
id|bh-&gt;buf
comma
id|amount
comma
op_amp
id|file_offset_tmp
)paren
suffix:semicolon
id|VLDBG
c_func
(paren
id|curlun
comma
l_string|&quot;file write %u @ %llu -&gt; %d&bslash;n&quot;
comma
id|amount
comma
(paren
r_int
r_int
r_int
)paren
id|file_offset
comma
(paren
r_int
)paren
id|nwritten
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
singleline_comment|// Interrupted!
r_if
c_cond
(paren
id|nwritten
OL
l_int|0
)paren
(brace
id|LDBG
c_func
(paren
id|curlun
comma
l_string|&quot;error in file write: %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|nwritten
)paren
suffix:semicolon
id|nwritten
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nwritten
OL
id|amount
)paren
(brace
id|LDBG
c_func
(paren
id|curlun
comma
l_string|&quot;partial file write: %d/%u&bslash;n&quot;
comma
(paren
r_int
)paren
id|nwritten
comma
id|amount
)paren
suffix:semicolon
id|nwritten
op_sub_assign
(paren
id|nwritten
op_amp
l_int|511
)paren
suffix:semicolon
singleline_comment|// Round down to a block
)brace
id|file_offset
op_add_assign
id|nwritten
suffix:semicolon
id|amount_left_to_write
op_sub_assign
id|nwritten
suffix:semicolon
id|fsg-&gt;residue
op_sub_assign
id|nwritten
suffix:semicolon
multiline_comment|/* If an error occurred, report it and its position */
r_if
c_cond
(paren
id|nwritten
OL
id|amount
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_WRITE_ERROR
suffix:semicolon
id|curlun-&gt;sense_data_info
op_assign
id|file_offset
op_rshift
l_int|9
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Did the host decide to stop early? */
r_if
c_cond
(paren
id|bh-&gt;outreq-&gt;actual
op_ne
id|bh-&gt;outreq-&gt;length
)paren
(brace
id|fsg-&gt;short_packet_received
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* Wait for something to happen */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|sleep_thread
c_func
(paren
id|fsg
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
r_return
op_minus
id|EIO
suffix:semicolon
singleline_comment|// No default reply
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Sync the file data, don&squot;t bother with the metadata.&n; * This code was copied from fs/buffer.c:sys_fdatasync(). */
DECL|function|fsync_sub
r_static
r_int
id|fsync_sub
c_func
(paren
r_struct
id|lun
op_star
id|curlun
)paren
(brace
r_struct
id|file
op_star
id|filp
op_assign
id|curlun-&gt;filp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|rc
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|curlun-&gt;ro
op_logical_or
op_logical_neg
id|filp
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_op-&gt;fsync
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_SYNCWRITE
suffix:semicolon
id|rc
op_assign
id|filemap_fdatawrite
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
id|err
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|fsync
c_func
(paren
id|filp
comma
id|filp-&gt;f_dentry
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
id|rc
op_assign
id|err
suffix:semicolon
id|err
op_assign
id|filemap_fdatawait
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
id|rc
op_assign
id|err
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_SYNCWRITE
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|VLDBG
c_func
(paren
id|curlun
comma
l_string|&quot;fdatasync -&gt; %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|fsync_all
r_static
r_void
id|fsync_all
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fsg-&gt;nluns
suffix:semicolon
op_increment
id|i
)paren
id|fsync_sub
c_func
(paren
op_amp
id|fsg-&gt;luns
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|do_synchronize_cache
r_static
r_int
id|do_synchronize_cache
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|fsg-&gt;curlun
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* We ignore the requested LBA and write out all file&squot;s&n;&t; * dirty data buffers. */
id|rc
op_assign
id|fsync_sub
c_func
(paren
id|curlun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|curlun-&gt;sense_data
op_assign
id|SS_WRITE_ERROR
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|invalidate_sub
r_static
r_void
id|invalidate_sub
c_func
(paren
r_struct
id|lun
op_star
id|curlun
)paren
(brace
r_struct
id|file
op_star
id|filp
op_assign
id|curlun-&gt;filp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|invalidate_inode_pages
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
id|VLDBG
c_func
(paren
id|curlun
comma
l_string|&quot;invalidate_inode_pages -&gt; %ld&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
)brace
DECL|function|do_verify
r_static
r_int
id|do_verify
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|fsg-&gt;curlun
suffix:semicolon
id|u32
id|lba
suffix:semicolon
id|u32
id|verification_length
suffix:semicolon
r_struct
id|fsg_buffhd
op_star
id|bh
op_assign
id|fsg-&gt;next_buffhd_to_fill
suffix:semicolon
id|loff_t
id|file_offset
comma
id|file_offset_tmp
suffix:semicolon
id|u32
id|amount_left
suffix:semicolon
r_int
r_int
id|amount
suffix:semicolon
id|ssize_t
id|nread
suffix:semicolon
multiline_comment|/* Get the starting Logical Block Address and check that it&squot;s&n;&t; * not too big */
id|lba
op_assign
id|get_be32
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lba
op_ge
id|curlun-&gt;num_sectors
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* We allow DPO (Disable Page Out = don&squot;t save data in the&n;&t; * cache) but we don&squot;t implement it. */
r_if
c_cond
(paren
(paren
id|fsg-&gt;cmnd
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x10
)paren
op_ne
l_int|0
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_INVALID_FIELD_IN_CDB
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|verification_length
op_assign
id|get_be16
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|7
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|verification_length
op_eq
l_int|0
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
singleline_comment|// No default reply
multiline_comment|/* Prepare to carry out the file verify */
id|amount_left
op_assign
id|verification_length
op_lshift
l_int|9
suffix:semicolon
id|file_offset
op_assign
(paren
(paren
id|loff_t
)paren
id|lba
)paren
op_lshift
l_int|9
suffix:semicolon
multiline_comment|/* Write out all the dirty buffers before invalidating them */
id|fsync_sub
c_func
(paren
id|curlun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|invalidate_sub
c_func
(paren
id|curlun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
multiline_comment|/* Just try to read the requested blocks */
r_while
c_loop
(paren
id|amount_left
OG
l_int|0
)paren
(brace
multiline_comment|/* Figure out how much we need to read:&n;&t;&t; * Try to read the remaining amount, but not more than&n;&t;&t; * the buffer size.&n;&t;&t; * And don&squot;t try to read past the end of the file.&n;&t;&t; * If this means reading 0 then we were asked to read&n;&t;&t; * past the end of file. */
id|amount
op_assign
id|min
c_func
(paren
(paren
r_int
r_int
)paren
id|amount_left
comma
id|mod_data.buflen
)paren
suffix:semicolon
id|amount
op_assign
id|min
c_func
(paren
(paren
id|loff_t
)paren
id|amount
comma
id|curlun-&gt;file_length
op_minus
id|file_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amount
op_eq
l_int|0
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE
suffix:semicolon
id|curlun-&gt;sense_data_info
op_assign
id|file_offset
op_rshift
l_int|9
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Perform the read */
id|file_offset_tmp
op_assign
id|file_offset
suffix:semicolon
id|nread
op_assign
id|vfs_read
c_func
(paren
id|curlun-&gt;filp
comma
(paren
r_char
id|__user
op_star
)paren
id|bh-&gt;buf
comma
id|amount
comma
op_amp
id|file_offset_tmp
)paren
suffix:semicolon
id|VLDBG
c_func
(paren
id|curlun
comma
l_string|&quot;file read %u @ %llu -&gt; %d&bslash;n&quot;
comma
id|amount
comma
(paren
r_int
r_int
r_int
)paren
id|file_offset
comma
(paren
r_int
)paren
id|nread
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
r_if
c_cond
(paren
id|nread
OL
l_int|0
)paren
(brace
id|LDBG
c_func
(paren
id|curlun
comma
l_string|&quot;error in file verify: %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|nread
)paren
suffix:semicolon
id|nread
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nread
OL
id|amount
)paren
(brace
id|LDBG
c_func
(paren
id|curlun
comma
l_string|&quot;partial file verify: %d/%u&bslash;n&quot;
comma
(paren
r_int
)paren
id|nread
comma
id|amount
)paren
suffix:semicolon
id|nread
op_sub_assign
(paren
id|nread
op_amp
l_int|511
)paren
suffix:semicolon
singleline_comment|// Round down to a sector
)brace
r_if
c_cond
(paren
id|nread
op_eq
l_int|0
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_UNRECOVERED_READ_ERROR
suffix:semicolon
id|curlun-&gt;sense_data_info
op_assign
id|file_offset
op_rshift
l_int|9
suffix:semicolon
r_break
suffix:semicolon
)brace
id|file_offset
op_add_assign
id|nread
suffix:semicolon
id|amount_left
op_sub_assign
id|nread
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|do_inquiry
r_static
r_int
id|do_inquiry
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|fsg_buffhd
op_star
id|bh
)paren
(brace
id|u8
op_star
id|buf
op_assign
(paren
id|u8
op_star
)paren
id|bh-&gt;buf
suffix:semicolon
r_static
r_char
id|vendor_id
(braket
)braket
op_assign
l_string|&quot;Linux   &quot;
suffix:semicolon
r_static
r_char
id|product_id
(braket
)braket
op_assign
l_string|&quot;File-Stor Gadget&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fsg-&gt;curlun
)paren
(brace
singleline_comment|// Unsupported LUNs are okay
id|fsg-&gt;bad_lun_okay
op_assign
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
l_int|36
)paren
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0x7f
suffix:semicolon
singleline_comment|// Unsupported, no device-type
r_return
l_int|36
suffix:semicolon
)brace
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
singleline_comment|// Non-removable, direct-access device
r_if
c_cond
(paren
id|mod_data.removable
)paren
id|buf
(braket
l_int|1
)braket
op_assign
l_int|0x80
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
l_int|2
suffix:semicolon
singleline_comment|// ANSI SCSI level 2
id|buf
(braket
l_int|3
)braket
op_assign
l_int|2
suffix:semicolon
singleline_comment|// SCSI-2 INQUIRY data format
id|buf
(braket
l_int|4
)braket
op_assign
l_int|31
suffix:semicolon
singleline_comment|// Additional length
singleline_comment|// No special options
id|sprintf
c_func
(paren
id|buf
op_plus
l_int|8
comma
l_string|&quot;%-8s%-16s%04x&quot;
comma
id|vendor_id
comma
id|product_id
comma
id|mod_data.release
)paren
suffix:semicolon
r_return
l_int|36
suffix:semicolon
)brace
DECL|function|do_request_sense
r_static
r_int
id|do_request_sense
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|fsg_buffhd
op_star
id|bh
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|fsg-&gt;curlun
suffix:semicolon
id|u8
op_star
id|buf
op_assign
(paren
id|u8
op_star
)paren
id|bh-&gt;buf
suffix:semicolon
id|u32
id|sd
comma
id|sdinfo
suffix:semicolon
multiline_comment|/*&n;&t; * From the SCSI-2 spec., section 7.9 (Unit attention condition):&n;&t; *&n;&t; * If a REQUEST SENSE command is received from an initiator&n;&t; * with a pending unit attention condition (before the target&n;&t; * generates the contingent allegiance condition), then the&n;&t; * target shall either:&n;&t; *   a) report any pending sense data and preserve the unit&n;&t; *&t;attention condition on the logical unit, or,&n;&t; *   b) report the unit attention condition, may discard any&n;&t; *&t;pending sense data, and clear the unit attention&n;&t; *&t;condition on the logical unit for that initiator.&n;&t; *&n;&t; * FSG normally uses option a); enable this code to use option b).&n;&t; */
macro_line|#if 0
r_if
c_cond
(paren
id|curlun
op_logical_and
id|curlun-&gt;unit_attention_data
op_ne
id|SS_NO_SENSE
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|curlun-&gt;unit_attention_data
suffix:semicolon
id|curlun-&gt;unit_attention_data
op_assign
id|SS_NO_SENSE
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|curlun
)paren
(brace
singleline_comment|// Unsupported LUNs are okay
id|fsg-&gt;bad_lun_okay
op_assign
l_int|1
suffix:semicolon
id|sd
op_assign
id|SS_LOGICAL_UNIT_NOT_SUPPORTED
suffix:semicolon
id|sdinfo
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sd
op_assign
id|curlun-&gt;sense_data
suffix:semicolon
id|sdinfo
op_assign
id|curlun-&gt;sense_data_info
suffix:semicolon
id|curlun-&gt;sense_data
op_assign
id|SS_NO_SENSE
suffix:semicolon
id|curlun-&gt;sense_data_info
op_assign
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
l_int|18
)paren
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0x80
op_or
l_int|0x70
suffix:semicolon
singleline_comment|// Valid, current error
id|buf
(braket
l_int|2
)braket
op_assign
id|SK
c_func
(paren
id|sd
)paren
suffix:semicolon
id|put_be32
c_func
(paren
op_amp
id|buf
(braket
l_int|3
)braket
comma
id|sdinfo
)paren
suffix:semicolon
singleline_comment|// Sense information
id|buf
(braket
l_int|7
)braket
op_assign
l_int|18
op_minus
l_int|8
suffix:semicolon
singleline_comment|// Additional sense length
id|buf
(braket
l_int|12
)braket
op_assign
id|ASC
c_func
(paren
id|sd
)paren
suffix:semicolon
id|buf
(braket
l_int|13
)braket
op_assign
id|ASCQ
c_func
(paren
id|sd
)paren
suffix:semicolon
r_return
l_int|18
suffix:semicolon
)brace
DECL|function|do_read_capacity
r_static
r_int
id|do_read_capacity
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|fsg_buffhd
op_star
id|bh
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|fsg-&gt;curlun
suffix:semicolon
id|u32
id|lba
op_assign
id|get_be32
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_int
id|pmi
op_assign
id|fsg-&gt;cmnd
(braket
l_int|8
)braket
suffix:semicolon
id|u8
op_star
id|buf
op_assign
(paren
id|u8
op_star
)paren
id|bh-&gt;buf
suffix:semicolon
multiline_comment|/* Check the PMI and LBA fields */
r_if
c_cond
(paren
id|pmi
OG
l_int|1
op_logical_or
(paren
id|pmi
op_eq
l_int|0
op_logical_and
id|lba
op_ne
l_int|0
)paren
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_INVALID_FIELD_IN_CDB
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|put_be32
c_func
(paren
op_amp
id|buf
(braket
l_int|0
)braket
comma
id|curlun-&gt;num_sectors
op_minus
l_int|1
)paren
suffix:semicolon
singleline_comment|// Max logical block
id|put_be32
c_func
(paren
op_amp
id|buf
(braket
l_int|4
)braket
comma
l_int|512
)paren
suffix:semicolon
singleline_comment|// Block length
r_return
l_int|8
suffix:semicolon
)brace
DECL|function|do_mode_sense
r_static
r_int
id|do_mode_sense
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|fsg_buffhd
op_star
id|bh
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|fsg-&gt;curlun
suffix:semicolon
r_int
id|mscmnd
op_assign
id|fsg-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
id|u8
op_star
id|buf
op_assign
(paren
id|u8
op_star
)paren
id|bh-&gt;buf
suffix:semicolon
id|u8
op_star
id|buf0
op_assign
id|buf
suffix:semicolon
r_int
id|pc
comma
id|page_code
suffix:semicolon
r_int
id|changeable_values
comma
id|all_pages
suffix:semicolon
r_int
id|valid_page
op_assign
l_int|0
suffix:semicolon
r_int
id|len
comma
id|limit
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fsg-&gt;cmnd
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x08
)paren
op_ne
l_int|0
)paren
(brace
singleline_comment|// Mask away DBD
id|curlun-&gt;sense_data
op_assign
id|SS_INVALID_FIELD_IN_CDB
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|pc
op_assign
id|fsg-&gt;cmnd
(braket
l_int|2
)braket
op_rshift
l_int|6
suffix:semicolon
id|page_code
op_assign
id|fsg-&gt;cmnd
(braket
l_int|2
)braket
op_amp
l_int|0x3f
suffix:semicolon
r_if
c_cond
(paren
id|pc
op_eq
l_int|3
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_SAVING_PARAMETERS_NOT_SUPPORTED
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|changeable_values
op_assign
(paren
id|pc
op_eq
l_int|1
)paren
suffix:semicolon
id|all_pages
op_assign
(paren
id|page_code
op_eq
l_int|0x3f
)paren
suffix:semicolon
multiline_comment|/* Write the mode parameter header.  Fixed values are: default&n;&t; * medium type, no cache control (DPOFUA), and no block descriptors.&n;&t; * The only variable value is the WriteProtect bit.  We will fill in&n;&t; * the mode data length later. */
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mscmnd
op_eq
id|SC_MODE_SENSE_6
)paren
(brace
id|buf
(braket
l_int|2
)braket
op_assign
(paren
id|curlun-&gt;ro
ques
c_cond
l_int|0x80
suffix:colon
l_int|0x00
)paren
suffix:semicolon
singleline_comment|// WP, DPOFUA
id|buf
op_add_assign
l_int|4
suffix:semicolon
id|limit
op_assign
l_int|255
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// SC_MODE_SENSE_10
id|buf
(braket
l_int|3
)braket
op_assign
(paren
id|curlun-&gt;ro
ques
c_cond
l_int|0x80
suffix:colon
l_int|0x00
)paren
suffix:semicolon
singleline_comment|// WP, DPOFUA
id|buf
op_add_assign
l_int|8
suffix:semicolon
id|limit
op_assign
l_int|65535
suffix:semicolon
singleline_comment|// Should really be mod_data.buflen
)brace
multiline_comment|/* No block descriptors */
multiline_comment|/* The mode pages, in numerical order.  The only page we support&n;&t; * is the Caching page. */
r_if
c_cond
(paren
id|page_code
op_eq
l_int|0x08
op_logical_or
id|all_pages
)paren
(brace
id|valid_page
op_assign
l_int|1
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0x08
suffix:semicolon
singleline_comment|// Page code
id|buf
(braket
l_int|1
)braket
op_assign
l_int|10
suffix:semicolon
singleline_comment|// Page length
id|memset
c_func
(paren
id|buf
op_plus
l_int|2
comma
l_int|0
comma
l_int|10
)paren
suffix:semicolon
singleline_comment|// None of the fields are changeable
r_if
c_cond
(paren
op_logical_neg
id|changeable_values
)paren
(brace
id|buf
(braket
l_int|2
)braket
op_assign
l_int|0x04
suffix:semicolon
singleline_comment|// Write cache enable,
singleline_comment|// Read cache not disabled
singleline_comment|// No cache retention priorities
id|put_be16
c_func
(paren
op_amp
id|buf
(braket
l_int|4
)braket
comma
l_int|0xffff
)paren
suffix:semicolon
singleline_comment|// Don&squot;t disable prefetch
singleline_comment|// Minimum prefetch = 0
id|put_be16
c_func
(paren
op_amp
id|buf
(braket
l_int|8
)braket
comma
l_int|0xffff
)paren
suffix:semicolon
singleline_comment|// Maximum prefetch
id|put_be16
c_func
(paren
op_amp
id|buf
(braket
l_int|10
)braket
comma
l_int|0xffff
)paren
suffix:semicolon
singleline_comment|// Maximum prefetch ceiling
)brace
id|buf
op_add_assign
l_int|12
suffix:semicolon
)brace
multiline_comment|/* Check that a valid page was requested and the mode data length&n;&t; * isn&squot;t too long. */
id|len
op_assign
id|buf
op_minus
id|buf0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|valid_page
op_logical_or
id|len
OG
id|limit
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_INVALID_FIELD_IN_CDB
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  Store the mode data length */
r_if
c_cond
(paren
id|mscmnd
op_eq
id|SC_MODE_SENSE_6
)paren
id|buf0
(braket
l_int|0
)braket
op_assign
id|len
op_minus
l_int|1
suffix:semicolon
r_else
id|put_be16
c_func
(paren
id|buf0
comma
id|len
op_minus
l_int|2
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|do_start_stop
r_static
r_int
id|do_start_stop
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|fsg-&gt;curlun
suffix:semicolon
r_int
id|loej
comma
id|start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod_data.removable
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_INVALID_COMMAND
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
singleline_comment|// int immed = fsg-&gt;cmnd[1] &amp; 0x01;
id|loej
op_assign
id|fsg-&gt;cmnd
(braket
l_int|4
)braket
op_amp
l_int|0x02
suffix:semicolon
id|start
op_assign
id|fsg-&gt;cmnd
(braket
l_int|4
)braket
op_amp
l_int|0x01
suffix:semicolon
macro_line|#ifdef CONFIG_USB_FILE_STORAGE_TEST
r_if
c_cond
(paren
(paren
id|fsg-&gt;cmnd
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x01
)paren
op_ne
l_int|0
op_logical_or
singleline_comment|// Mask away Immed
(paren
id|fsg-&gt;cmnd
(braket
l_int|4
)braket
op_amp
op_complement
l_int|0x03
)paren
op_ne
l_int|0
)paren
(brace
singleline_comment|// Mask LoEj, Start
id|curlun-&gt;sense_data
op_assign
id|SS_INVALID_FIELD_IN_CDB
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|start
)paren
(brace
multiline_comment|/* Are we allowed to unload the media? */
r_if
c_cond
(paren
id|curlun-&gt;prevent_medium_removal
)paren
(brace
id|LDBG
c_func
(paren
id|curlun
comma
l_string|&quot;unload attempt prevented&bslash;n&quot;
)paren
suffix:semicolon
id|curlun-&gt;sense_data
op_assign
id|SS_MEDIUM_REMOVAL_PREVENTED
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|loej
)paren
(brace
singleline_comment|// Simulate an unload/eject
id|up_read
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
id|close_backing_file
c_func
(paren
id|curlun
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Our emulation doesn&squot;t support mounting; the medium is&n;&t;&t; * available for use as soon as it is loaded. */
r_if
c_cond
(paren
op_logical_neg
id|backing_file_is_open
c_func
(paren
id|curlun
)paren
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_MEDIUM_NOT_PRESENT
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|do_prevent_allow
r_static
r_int
id|do_prevent_allow
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|fsg-&gt;curlun
suffix:semicolon
r_int
id|prevent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod_data.removable
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_INVALID_COMMAND
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|prevent
op_assign
id|fsg-&gt;cmnd
(braket
l_int|4
)braket
op_amp
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fsg-&gt;cmnd
(braket
l_int|4
)braket
op_amp
op_complement
l_int|0x01
)paren
op_ne
l_int|0
)paren
(brace
singleline_comment|// Mask away Prevent
id|curlun-&gt;sense_data
op_assign
id|SS_INVALID_FIELD_IN_CDB
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curlun-&gt;prevent_medium_removal
op_logical_and
op_logical_neg
id|prevent
)paren
id|fsync_sub
c_func
(paren
id|curlun
)paren
suffix:semicolon
id|curlun-&gt;prevent_medium_removal
op_assign
id|prevent
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|do_read_format_capacities
r_static
r_int
id|do_read_format_capacities
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|fsg_buffhd
op_star
id|bh
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|fsg-&gt;curlun
suffix:semicolon
id|u8
op_star
id|buf
op_assign
(paren
id|u8
op_star
)paren
id|bh-&gt;buf
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
id|buf
(braket
l_int|1
)braket
op_assign
id|buf
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
l_int|8
suffix:semicolon
singleline_comment|// Only the Current/Maximum Capacity Descriptor
id|buf
op_add_assign
l_int|4
suffix:semicolon
id|put_be32
c_func
(paren
op_amp
id|buf
(braket
l_int|0
)braket
comma
id|curlun-&gt;num_sectors
)paren
suffix:semicolon
singleline_comment|// Number of blocks
id|put_be32
c_func
(paren
op_amp
id|buf
(braket
l_int|4
)braket
comma
l_int|512
)paren
suffix:semicolon
singleline_comment|// Block length
id|buf
(braket
l_int|4
)braket
op_assign
l_int|0x02
suffix:semicolon
singleline_comment|// Current capacity
r_return
l_int|12
suffix:semicolon
)brace
DECL|function|do_mode_select
r_static
r_int
id|do_mode_select
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|fsg_buffhd
op_star
id|bh
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|fsg-&gt;curlun
suffix:semicolon
multiline_comment|/* We don&squot;t support MODE SELECT */
id|curlun-&gt;sense_data
op_assign
id|SS_INVALID_COMMAND
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|halt_bulk_in_endpoint
r_static
r_int
id|halt_bulk_in_endpoint
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|fsg_set_halt
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EAGAIN
)paren
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;delayed bulk-in endpoint halt&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|rc
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|rc
op_ne
op_minus
id|EAGAIN
)paren
(brace
id|WARN
c_func
(paren
id|fsg
comma
l_string|&quot;usb_ep_set_halt -&gt; %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Wait for a short time and then try again */
r_if
c_cond
(paren
id|msleep_interruptible
c_func
(paren
l_int|100
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|rc
op_assign
id|usb_ep_set_halt
c_func
(paren
id|fsg-&gt;bulk_in
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|pad_with_zeros
r_static
r_int
id|pad_with_zeros
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_struct
id|fsg_buffhd
op_star
id|bh
op_assign
id|fsg-&gt;next_buffhd_to_fill
suffix:semicolon
id|u32
id|nkeep
op_assign
id|bh-&gt;inreq-&gt;length
suffix:semicolon
id|u32
id|nsend
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|bh-&gt;state
op_assign
id|BUF_STATE_EMPTY
suffix:semicolon
singleline_comment|// For the first iteration
id|fsg-&gt;usb_amount_left
op_assign
id|nkeep
op_plus
id|fsg-&gt;residue
suffix:semicolon
r_while
c_loop
(paren
id|fsg-&gt;usb_amount_left
OG
l_int|0
)paren
(brace
multiline_comment|/* Wait for the next buffer to be free */
r_while
c_loop
(paren
id|bh-&gt;state
op_ne
id|BUF_STATE_EMPTY
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|sleep_thread
c_func
(paren
id|fsg
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
id|nsend
op_assign
id|min
c_func
(paren
id|fsg-&gt;usb_amount_left
comma
(paren
id|u32
)paren
id|mod_data.buflen
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bh-&gt;buf
op_plus
id|nkeep
comma
l_int|0
comma
id|nsend
op_minus
id|nkeep
)paren
suffix:semicolon
id|bh-&gt;inreq-&gt;length
op_assign
id|nsend
suffix:semicolon
id|bh-&gt;inreq-&gt;zero
op_assign
l_int|0
suffix:semicolon
id|start_transfer
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_in
comma
id|bh-&gt;inreq
comma
op_amp
id|bh-&gt;inreq_busy
comma
op_amp
id|bh-&gt;state
)paren
suffix:semicolon
id|bh
op_assign
id|fsg-&gt;next_buffhd_to_fill
op_assign
id|bh-&gt;next
suffix:semicolon
id|fsg-&gt;usb_amount_left
op_sub_assign
id|nsend
suffix:semicolon
id|nkeep
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|throw_away_data
r_static
r_int
id|throw_away_data
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_struct
id|fsg_buffhd
op_star
id|bh
suffix:semicolon
id|u32
id|amount
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|fsg-&gt;next_buffhd_to_drain
)paren
op_member_access_from_pointer
id|state
op_ne
id|BUF_STATE_EMPTY
op_logical_or
id|fsg-&gt;usb_amount_left
OG
l_int|0
)paren
(brace
multiline_comment|/* Throw away the data in a filled buffer */
r_if
c_cond
(paren
id|bh-&gt;state
op_eq
id|BUF_STATE_FULL
)paren
(brace
id|bh-&gt;state
op_assign
id|BUF_STATE_EMPTY
suffix:semicolon
id|fsg-&gt;next_buffhd_to_drain
op_assign
id|bh-&gt;next
suffix:semicolon
multiline_comment|/* A short packet or an error ends everything */
r_if
c_cond
(paren
id|bh-&gt;outreq-&gt;actual
op_ne
id|bh-&gt;outreq-&gt;length
op_logical_or
id|bh-&gt;outreq-&gt;status
op_ne
l_int|0
)paren
(brace
id|raise_exception
c_func
(paren
id|fsg
comma
id|FSG_STATE_ABORT_BULK_OUT
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* Try to submit another request if we need one */
id|bh
op_assign
id|fsg-&gt;next_buffhd_to_fill
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;state
op_eq
id|BUF_STATE_EMPTY
op_logical_and
id|fsg-&gt;usb_amount_left
OG
l_int|0
)paren
(brace
id|amount
op_assign
id|min
c_func
(paren
id|fsg-&gt;usb_amount_left
comma
(paren
id|u32
)paren
id|mod_data.buflen
)paren
suffix:semicolon
multiline_comment|/* amount is always divisible by 512, hence by&n;&t;&t;&t; * the bulk-out maxpacket size */
id|bh-&gt;outreq-&gt;length
op_assign
id|bh-&gt;bulk_out_intended_length
op_assign
id|amount
suffix:semicolon
id|start_transfer
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_out
comma
id|bh-&gt;outreq
comma
op_amp
id|bh-&gt;outreq_busy
comma
op_amp
id|bh-&gt;state
)paren
suffix:semicolon
id|fsg-&gt;next_buffhd_to_fill
op_assign
id|bh-&gt;next
suffix:semicolon
id|fsg-&gt;usb_amount_left
op_sub_assign
id|amount
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Otherwise wait for something to happen */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|sleep_thread
c_func
(paren
id|fsg
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|finish_reply
r_static
r_int
id|finish_reply
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_struct
id|fsg_buffhd
op_star
id|bh
op_assign
id|fsg-&gt;next_buffhd_to_fill
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|fsg-&gt;data_dir
)paren
(brace
r_case
id|DATA_DIR_NONE
suffix:colon
r_break
suffix:semicolon
singleline_comment|// Nothing to send
multiline_comment|/* If we don&squot;t know whether the host wants to read or write,&n;&t; * this must be CB or CBI with an unknown command.  We mustn&squot;t&n;&t; * try to send or receive any data.  So stall both bulk pipes&n;&t; * if we can and wait for a reset. */
r_case
id|DATA_DIR_UNKNOWN
suffix:colon
r_if
c_cond
(paren
id|mod_data.can_stall
)paren
(brace
id|fsg_set_halt
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_out
)paren
suffix:semicolon
id|rc
op_assign
id|halt_bulk_in_endpoint
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* All but the last buffer of data must have already been sent */
r_case
id|DATA_DIR_TO_HOST
suffix:colon
r_if
c_cond
(paren
id|fsg-&gt;data_size
op_eq
l_int|0
)paren
suffix:semicolon
singleline_comment|// Nothing to send
multiline_comment|/* If there&squot;s no residue, simply send the last buffer */
r_else
r_if
c_cond
(paren
id|fsg-&gt;residue
op_eq
l_int|0
)paren
(brace
id|bh-&gt;inreq-&gt;zero
op_assign
l_int|0
suffix:semicolon
id|start_transfer
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_in
comma
id|bh-&gt;inreq
comma
op_amp
id|bh-&gt;inreq_busy
comma
op_amp
id|bh-&gt;state
)paren
suffix:semicolon
id|fsg-&gt;next_buffhd_to_fill
op_assign
id|bh-&gt;next
suffix:semicolon
)brace
multiline_comment|/* There is a residue.  For CB and CBI, simply mark the end&n;&t;&t; * of the data with a short packet.  However, if we are&n;&t;&t; * allowed to stall, there was no data at all (residue ==&n;&t;&t; * data_size), and the command failed (invalid LUN or&n;&t;&t; * sense data is set), then halt the bulk-in endpoint&n;&t;&t; * instead. */
r_else
r_if
c_cond
(paren
op_logical_neg
id|transport_is_bbb
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|mod_data.can_stall
op_logical_and
id|fsg-&gt;residue
op_eq
id|fsg-&gt;data_size
op_logical_and
(paren
op_logical_neg
id|fsg-&gt;curlun
op_logical_or
id|fsg-&gt;curlun-&gt;sense_data
op_ne
id|SS_NO_SENSE
)paren
)paren
(brace
id|bh-&gt;state
op_assign
id|BUF_STATE_EMPTY
suffix:semicolon
id|rc
op_assign
id|halt_bulk_in_endpoint
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
r_else
(brace
id|bh-&gt;inreq-&gt;zero
op_assign
l_int|1
suffix:semicolon
id|start_transfer
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_in
comma
id|bh-&gt;inreq
comma
op_amp
id|bh-&gt;inreq_busy
comma
op_amp
id|bh-&gt;state
)paren
suffix:semicolon
id|fsg-&gt;next_buffhd_to_fill
op_assign
id|bh-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* For Bulk-only, if we&squot;re allowed to stall then send the&n;&t;&t; * short packet and halt the bulk-in endpoint.  If we can&squot;t&n;&t;&t; * stall, pad out the remaining data with 0&squot;s. */
r_else
(brace
r_if
c_cond
(paren
id|mod_data.can_stall
)paren
(brace
id|bh-&gt;inreq-&gt;zero
op_assign
l_int|1
suffix:semicolon
id|start_transfer
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_in
comma
id|bh-&gt;inreq
comma
op_amp
id|bh-&gt;inreq_busy
comma
op_amp
id|bh-&gt;state
)paren
suffix:semicolon
id|fsg-&gt;next_buffhd_to_fill
op_assign
id|bh-&gt;next
suffix:semicolon
id|rc
op_assign
id|halt_bulk_in_endpoint
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
r_else
id|rc
op_assign
id|pad_with_zeros
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* We have processed all we want from the data the host has sent.&n;&t; * There may still be outstanding bulk-out requests. */
r_case
id|DATA_DIR_FROM_HOST
suffix:colon
r_if
c_cond
(paren
id|fsg-&gt;residue
op_eq
l_int|0
)paren
suffix:semicolon
singleline_comment|// Nothing to receive
multiline_comment|/* Did the host stop sending unexpectedly early? */
r_else
r_if
c_cond
(paren
id|fsg-&gt;short_packet_received
)paren
(brace
id|raise_exception
c_func
(paren
id|fsg
comma
id|FSG_STATE_ABORT_BULK_OUT
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINTR
suffix:semicolon
)brace
multiline_comment|/* We haven&squot;t processed all the incoming data.  Even though&n;&t;&t; * we may be allowed to stall, doing so would cause a race.&n;&t;&t; * The controller may already have ACK&squot;ed all the remaining&n;&t;&t; * bulk-out packets, in which case the host wouldn&squot;t see a&n;&t;&t; * STALL.  Not realizing the endpoint was halted, it wouldn&squot;t&n;&t;&t; * clear the halt -- leading to problems later on. */
macro_line|#if 0
r_else
r_if
c_cond
(paren
id|mod_data.can_stall
)paren
(brace
id|fsg_set_halt
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_out
)paren
suffix:semicolon
id|raise_exception
c_func
(paren
id|fsg
comma
id|FSG_STATE_ABORT_BULK_OUT
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINTR
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* We can&squot;t stall.  Read in the excess data and throw it&n;&t;&t; * all away. */
r_else
id|rc
op_assign
id|throw_away_data
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|send_status
r_static
r_int
id|send_status
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|fsg-&gt;curlun
suffix:semicolon
r_struct
id|fsg_buffhd
op_star
id|bh
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|u8
id|status
op_assign
id|USB_STATUS_PASS
suffix:semicolon
id|u32
id|sd
comma
id|sdinfo
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wait for the next buffer to become available */
id|bh
op_assign
id|fsg-&gt;next_buffhd_to_fill
suffix:semicolon
r_while
c_loop
(paren
id|bh-&gt;state
op_ne
id|BUF_STATE_EMPTY
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|sleep_thread
c_func
(paren
id|fsg
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curlun
)paren
(brace
id|sd
op_assign
id|curlun-&gt;sense_data
suffix:semicolon
id|sdinfo
op_assign
id|curlun-&gt;sense_data_info
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fsg-&gt;bad_lun_okay
)paren
id|sd
op_assign
id|SS_NO_SENSE
suffix:semicolon
r_else
id|sd
op_assign
id|SS_LOGICAL_UNIT_NOT_SUPPORTED
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;phase_error
)paren
(brace
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;sending phase-error status&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
id|USB_STATUS_PHASE_ERROR
suffix:semicolon
id|sd
op_assign
id|SS_INVALID_COMMAND
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sd
op_ne
id|SS_NO_SENSE
)paren
(brace
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;sending command-failure status&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
id|USB_STATUS_FAIL
suffix:semicolon
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;  sense data: SK x%02x, ASC x%02x, ASCQ x%02x;&quot;
l_string|&quot;  info x%x&bslash;n&quot;
comma
id|SK
c_func
(paren
id|sd
)paren
comma
id|ASC
c_func
(paren
id|sd
)paren
comma
id|ASCQ
c_func
(paren
id|sd
)paren
comma
id|sdinfo
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|transport_is_bbb
c_func
(paren
)paren
)paren
(brace
r_struct
id|bulk_cs_wrap
op_star
id|csw
op_assign
(paren
r_struct
id|bulk_cs_wrap
op_star
)paren
id|bh-&gt;buf
suffix:semicolon
multiline_comment|/* Store and send the Bulk-only CSW */
id|csw-&gt;Signature
op_assign
id|__constant_cpu_to_le32
c_func
(paren
id|USB_BULK_CS_SIG
)paren
suffix:semicolon
id|csw-&gt;Tag
op_assign
id|fsg-&gt;tag
suffix:semicolon
id|csw-&gt;Residue
op_assign
id|cpu_to_le32
c_func
(paren
id|fsg-&gt;residue
)paren
suffix:semicolon
id|csw-&gt;Status
op_assign
id|status
suffix:semicolon
id|bh-&gt;inreq-&gt;length
op_assign
id|USB_BULK_CS_WRAP_LEN
suffix:semicolon
id|bh-&gt;inreq-&gt;zero
op_assign
l_int|0
suffix:semicolon
id|start_transfer
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_in
comma
id|bh-&gt;inreq
comma
op_amp
id|bh-&gt;inreq_busy
comma
op_amp
id|bh-&gt;state
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mod_data.transport_type
op_eq
id|USB_PR_CB
)paren
(brace
multiline_comment|/* Control-Bulk transport has no status phase! */
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// USB_PR_CBI
r_struct
id|interrupt_data
op_star
id|buf
op_assign
(paren
r_struct
id|interrupt_data
op_star
)paren
id|bh-&gt;buf
suffix:semicolon
multiline_comment|/* Store and send the Interrupt data.  UFI sends the ASC&n;&t;&t; * and ASCQ bytes.  Everything else sends a Type (which&n;&t;&t; * is always 0) and the status Value. */
r_if
c_cond
(paren
id|mod_data.protocol_type
op_eq
id|USB_SC_UFI
)paren
(brace
id|buf-&gt;bType
op_assign
id|ASC
c_func
(paren
id|sd
)paren
suffix:semicolon
id|buf-&gt;bValue
op_assign
id|ASCQ
c_func
(paren
id|sd
)paren
suffix:semicolon
)brace
r_else
(brace
id|buf-&gt;bType
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;bValue
op_assign
id|status
suffix:semicolon
)brace
id|fsg-&gt;intreq-&gt;length
op_assign
id|CBI_INTERRUPT_DATA_LEN
suffix:semicolon
id|fsg-&gt;intr_buffhd
op_assign
id|bh
suffix:semicolon
singleline_comment|// Point to the right buffhd
id|fsg-&gt;intreq-&gt;buf
op_assign
id|bh-&gt;inreq-&gt;buf
suffix:semicolon
id|fsg-&gt;intreq-&gt;dma
op_assign
id|bh-&gt;inreq-&gt;dma
suffix:semicolon
id|fsg-&gt;intreq-&gt;context
op_assign
id|bh
suffix:semicolon
id|start_transfer
c_func
(paren
id|fsg
comma
id|fsg-&gt;intr_in
comma
id|fsg-&gt;intreq
comma
op_amp
id|fsg-&gt;intreq_busy
comma
op_amp
id|bh-&gt;state
)paren
suffix:semicolon
)brace
id|fsg-&gt;next_buffhd_to_fill
op_assign
id|bh-&gt;next
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Check whether the command is properly formed and whether its data size&n; * and direction agree with the values we already have. */
DECL|function|check_command
r_static
r_int
id|check_command
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_int
id|cmnd_size
comma
r_enum
id|data_direction
id|data_dir
comma
r_int
r_int
id|mask
comma
r_int
id|needs_medium
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|lun
op_assign
id|fsg-&gt;cmnd
(braket
l_int|1
)braket
op_rshift
l_int|5
suffix:semicolon
r_static
r_const
r_char
id|dirletter
(braket
l_int|4
)braket
op_assign
(brace
l_char|&squot;u&squot;
comma
l_char|&squot;o&squot;
comma
l_char|&squot;i&squot;
comma
l_char|&squot;n&squot;
)brace
suffix:semicolon
r_char
id|hdlen
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|lun
op_star
id|curlun
suffix:semicolon
multiline_comment|/* Adjust the expected cmnd_size for protocol encapsulation padding.&n;&t; * Transparent SCSI doesn&squot;t pad. */
r_if
c_cond
(paren
id|protocol_is_scsi
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* There&squot;s some disagreement as to whether RBC pads commands or not.&n;&t; * We&squot;ll play it safe and accept either form. */
r_else
r_if
c_cond
(paren
id|mod_data.protocol_type
op_eq
id|USB_SC_RBC
)paren
(brace
r_if
c_cond
(paren
id|fsg-&gt;cmnd_size
op_eq
l_int|12
)paren
id|cmnd_size
op_assign
l_int|12
suffix:semicolon
multiline_comment|/* All the other protocols pad to 12 bytes */
)brace
r_else
id|cmnd_size
op_assign
l_int|12
suffix:semicolon
id|hdlen
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;data_dir
op_ne
id|DATA_DIR_UNKNOWN
)paren
id|sprintf
c_func
(paren
id|hdlen
comma
l_string|&quot;, H%c=%u&quot;
comma
id|dirletter
(braket
(paren
r_int
)paren
id|fsg-&gt;data_dir
)braket
comma
id|fsg-&gt;data_size
)paren
suffix:semicolon
id|VDBG
c_func
(paren
id|fsg
comma
l_string|&quot;SCSI command: %s;  Dc=%d, D%c=%u;  Hc=%d%s&bslash;n&quot;
comma
id|name
comma
id|cmnd_size
comma
id|dirletter
(braket
(paren
r_int
)paren
id|data_dir
)braket
comma
id|fsg-&gt;data_size_from_cmnd
comma
id|fsg-&gt;cmnd_size
comma
id|hdlen
)paren
suffix:semicolon
multiline_comment|/* We can&squot;t reply at all until we know the correct data direction&n;&t; * and size. */
r_if
c_cond
(paren
id|fsg-&gt;data_size_from_cmnd
op_eq
l_int|0
)paren
id|data_dir
op_assign
id|DATA_DIR_NONE
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;data_dir
op_eq
id|DATA_DIR_UNKNOWN
)paren
(brace
singleline_comment|// CB or CBI
id|fsg-&gt;data_dir
op_assign
id|data_dir
suffix:semicolon
id|fsg-&gt;data_size
op_assign
id|fsg-&gt;data_size_from_cmnd
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// Bulk-only
r_if
c_cond
(paren
id|fsg-&gt;data_size
OL
id|fsg-&gt;data_size_from_cmnd
)paren
(brace
multiline_comment|/* Host data size &lt; Device data size is a phase error.&n;&t;&t;&t; * Carry out the command, but only transfer as much&n;&t;&t;&t; * as we are allowed. */
id|fsg-&gt;data_size_from_cmnd
op_assign
id|fsg-&gt;data_size
suffix:semicolon
id|fsg-&gt;phase_error
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|fsg-&gt;residue
op_assign
id|fsg-&gt;usb_amount_left
op_assign
id|fsg-&gt;data_size
suffix:semicolon
multiline_comment|/* Conflicting data directions is a phase error */
r_if
c_cond
(paren
id|fsg-&gt;data_dir
op_ne
id|data_dir
op_logical_and
id|fsg-&gt;data_size_from_cmnd
OG
l_int|0
)paren
(brace
id|fsg-&gt;phase_error
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Verify the length of the command itself */
r_if
c_cond
(paren
id|cmnd_size
op_ne
id|fsg-&gt;cmnd_size
)paren
(brace
multiline_comment|/* Special case workaround: MS-Windows issues REQUEST SENSE&n;&t;&t; * with cbw-&gt;Length == 12 (it should be 6). */
r_if
c_cond
(paren
id|fsg-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|SC_REQUEST_SENSE
op_logical_and
id|fsg-&gt;cmnd_size
op_eq
l_int|12
)paren
id|cmnd_size
op_assign
id|fsg-&gt;cmnd_size
suffix:semicolon
r_else
(brace
id|fsg-&gt;phase_error
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* Check that the LUN values are oonsistent */
r_if
c_cond
(paren
id|transport_is_bbb
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|fsg-&gt;lun
op_ne
id|lun
)paren
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;using LUN %d from CBW, &quot;
l_string|&quot;not LUN %d from CDB&bslash;n&quot;
comma
id|fsg-&gt;lun
comma
id|lun
)paren
suffix:semicolon
)brace
r_else
id|fsg-&gt;lun
op_assign
id|lun
suffix:semicolon
singleline_comment|// Use LUN from the command
multiline_comment|/* Check the LUN */
r_if
c_cond
(paren
id|fsg-&gt;lun
op_ge
l_int|0
op_logical_and
id|fsg-&gt;lun
OL
id|fsg-&gt;nluns
)paren
(brace
id|fsg-&gt;curlun
op_assign
id|curlun
op_assign
op_amp
id|fsg-&gt;luns
(braket
id|fsg-&gt;lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|SC_REQUEST_SENSE
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_NO_SENSE
suffix:semicolon
id|curlun-&gt;sense_data_info
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|fsg-&gt;curlun
op_assign
id|curlun
op_assign
l_int|NULL
suffix:semicolon
id|fsg-&gt;bad_lun_okay
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* INQUIRY and REQUEST SENSE commands are explicitly allowed&n;&t;&t; * to use unsupported LUNs; all others may not. */
r_if
c_cond
(paren
id|fsg-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|SC_INQUIRY
op_logical_and
id|fsg-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|SC_REQUEST_SENSE
)paren
(brace
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;unsupported LUN %d&bslash;n&quot;
comma
id|fsg-&gt;lun
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* If a unit attention condition exists, only INQUIRY and&n;&t; * REQUEST SENSE commands are allowed; anything else must fail. */
r_if
c_cond
(paren
id|curlun
op_logical_and
id|curlun-&gt;unit_attention_data
op_ne
id|SS_NO_SENSE
op_logical_and
id|fsg-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|SC_INQUIRY
op_logical_and
id|fsg-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|SC_REQUEST_SENSE
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|curlun-&gt;unit_attention_data
suffix:semicolon
id|curlun-&gt;unit_attention_data
op_assign
id|SS_NO_SENSE
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Check that only command bytes listed in the mask are non-zero */
id|fsg-&gt;cmnd
(braket
l_int|1
)braket
op_and_assign
l_int|0x1f
suffix:semicolon
singleline_comment|// Mask away the LUN
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|cmnd_size
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|fsg-&gt;cmnd
(braket
id|i
)braket
op_logical_and
op_logical_neg
(paren
id|mask
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|curlun
)paren
id|curlun-&gt;sense_data
op_assign
id|SS_INVALID_FIELD_IN_CDB
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* If the medium isn&squot;t mounted and the command needs to access&n;&t; * it, return an error. */
r_if
c_cond
(paren
id|curlun
op_logical_and
op_logical_neg
id|backing_file_is_open
c_func
(paren
id|curlun
)paren
op_logical_and
id|needs_medium
)paren
(brace
id|curlun-&gt;sense_data
op_assign
id|SS_MEDIUM_NOT_PRESENT
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|do_scsi_command
r_static
r_int
id|do_scsi_command
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_struct
id|fsg_buffhd
op_star
id|bh
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|reply
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_static
r_char
id|unknown
(braket
l_int|16
)braket
suffix:semicolon
id|dump_cdb
c_func
(paren
id|fsg
)paren
suffix:semicolon
multiline_comment|/* Wait for the next buffer to become available for data or status */
id|bh
op_assign
id|fsg-&gt;next_buffhd_to_drain
op_assign
id|fsg-&gt;next_buffhd_to_fill
suffix:semicolon
r_while
c_loop
(paren
id|bh-&gt;state
op_ne
id|BUF_STATE_EMPTY
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|sleep_thread
c_func
(paren
id|fsg
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
id|fsg-&gt;phase_error
op_assign
l_int|0
suffix:semicolon
id|fsg-&gt;short_packet_received
op_assign
l_int|0
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
singleline_comment|// We&squot;re using the backing file
r_switch
c_cond
(paren
id|fsg-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|SC_INQUIRY
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
id|fsg-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|6
comma
id|DATA_DIR_TO_HOST
comma
(paren
l_int|1
op_lshift
l_int|4
)paren
comma
l_int|0
comma
l_string|&quot;INQUIRY&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_inquiry
c_func
(paren
id|fsg
comma
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_MODE_SELECT_6
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
id|fsg-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|6
comma
id|DATA_DIR_FROM_HOST
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
op_or
(paren
l_int|1
op_lshift
l_int|4
)paren
comma
l_int|0
comma
l_string|&quot;MODE SELECT(6)&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_mode_select
c_func
(paren
id|fsg
comma
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_MODE_SELECT_10
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
id|get_be16
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|7
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|10
comma
id|DATA_DIR_FROM_HOST
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
op_or
(paren
l_int|3
op_lshift
l_int|7
)paren
comma
l_int|0
comma
l_string|&quot;MODE SELECT(10)&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_mode_select
c_func
(paren
id|fsg
comma
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_MODE_SENSE_6
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
id|fsg-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|6
comma
id|DATA_DIR_TO_HOST
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
op_or
(paren
l_int|1
op_lshift
l_int|4
)paren
comma
l_int|0
comma
l_string|&quot;MODE SENSE(6)&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_mode_sense
c_func
(paren
id|fsg
comma
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_MODE_SENSE_10
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
id|get_be16
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|7
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|10
comma
id|DATA_DIR_TO_HOST
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
op_or
(paren
l_int|3
op_lshift
l_int|7
)paren
comma
l_int|0
comma
l_string|&quot;MODE SENSE(10)&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_mode_sense
c_func
(paren
id|fsg
comma
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_PREVENT_ALLOW_MEDIUM_REMOVAL
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|6
comma
id|DATA_DIR_NONE
comma
(paren
l_int|1
op_lshift
l_int|4
)paren
comma
l_int|0
comma
l_string|&quot;PREVENT-ALLOW MEDIUM REMOVAL&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_prevent_allow
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_READ_6
suffix:colon
id|i
op_assign
id|fsg-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
id|fsg-&gt;data_size_from_cmnd
op_assign
(paren
id|i
op_eq
l_int|0
ques
c_cond
l_int|256
suffix:colon
id|i
)paren
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|6
comma
id|DATA_DIR_TO_HOST
comma
(paren
l_int|7
op_lshift
l_int|1
)paren
op_or
(paren
l_int|1
op_lshift
l_int|4
)paren
comma
l_int|1
comma
l_string|&quot;READ(6)&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_read
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_READ_10
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
id|get_be16
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|10
comma
id|DATA_DIR_TO_HOST
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
op_or
(paren
l_int|0xf
op_lshift
l_int|2
)paren
op_or
(paren
l_int|3
op_lshift
l_int|7
)paren
comma
l_int|1
comma
l_string|&quot;READ(10)&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_read
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_READ_12
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
id|get_be32
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|12
comma
id|DATA_DIR_TO_HOST
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
op_or
(paren
l_int|0xf
op_lshift
l_int|2
)paren
op_or
(paren
l_int|0xf
op_lshift
l_int|6
)paren
comma
l_int|1
comma
l_string|&quot;READ(12)&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_read
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_READ_CAPACITY
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|10
comma
id|DATA_DIR_TO_HOST
comma
(paren
l_int|0xf
op_lshift
l_int|2
)paren
op_or
(paren
l_int|1
op_lshift
l_int|8
)paren
comma
l_int|1
comma
l_string|&quot;READ CAPACITY&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_read_capacity
c_func
(paren
id|fsg
comma
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_READ_FORMAT_CAPACITIES
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
id|get_be16
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|7
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|10
comma
id|DATA_DIR_TO_HOST
comma
(paren
l_int|3
op_lshift
l_int|7
)paren
comma
l_int|1
comma
l_string|&quot;READ FORMAT CAPACITIES&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_read_format_capacities
c_func
(paren
id|fsg
comma
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_REQUEST_SENSE
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
id|fsg-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|6
comma
id|DATA_DIR_TO_HOST
comma
(paren
l_int|1
op_lshift
l_int|4
)paren
comma
l_int|0
comma
l_string|&quot;REQUEST SENSE&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_request_sense
c_func
(paren
id|fsg
comma
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_START_STOP_UNIT
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|6
comma
id|DATA_DIR_NONE
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
op_or
(paren
l_int|1
op_lshift
l_int|4
)paren
comma
l_int|0
comma
l_string|&quot;START-STOP UNIT&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_start_stop
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_SYNCHRONIZE_CACHE
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|10
comma
id|DATA_DIR_NONE
comma
(paren
l_int|0xf
op_lshift
l_int|2
)paren
op_or
(paren
l_int|3
op_lshift
l_int|7
)paren
comma
l_int|1
comma
l_string|&quot;SYNCHRONIZE CACHE&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_synchronize_cache
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_TEST_UNIT_READY
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
l_int|0
suffix:semicolon
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|6
comma
id|DATA_DIR_NONE
comma
l_int|0
comma
l_int|1
comma
l_string|&quot;TEST UNIT READY&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Although optional, this command is used by MS-Windows.  We&n;&t; * support a minimal version: BytChk must be 0. */
r_case
id|SC_VERIFY
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|10
comma
id|DATA_DIR_NONE
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
op_or
(paren
l_int|0xf
op_lshift
l_int|2
)paren
op_or
(paren
l_int|3
op_lshift
l_int|7
)paren
comma
l_int|1
comma
l_string|&quot;VERIFY&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_verify
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_WRITE_6
suffix:colon
id|i
op_assign
id|fsg-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
id|fsg-&gt;data_size_from_cmnd
op_assign
(paren
id|i
op_eq
l_int|0
ques
c_cond
l_int|256
suffix:colon
id|i
)paren
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|6
comma
id|DATA_DIR_FROM_HOST
comma
(paren
l_int|7
op_lshift
l_int|1
)paren
op_or
(paren
l_int|1
op_lshift
l_int|4
)paren
comma
l_int|1
comma
l_string|&quot;WRITE(6)&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_write
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_WRITE_10
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
id|get_be16
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|10
comma
id|DATA_DIR_FROM_HOST
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
op_or
(paren
l_int|0xf
op_lshift
l_int|2
)paren
op_or
(paren
l_int|3
op_lshift
l_int|7
)paren
comma
l_int|1
comma
l_string|&quot;WRITE(10)&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_write
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SC_WRITE_12
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
id|get_be32
c_func
(paren
op_amp
id|fsg-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
l_int|12
comma
id|DATA_DIR_FROM_HOST
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
op_or
(paren
l_int|0xf
op_lshift
l_int|2
)paren
op_or
(paren
l_int|0xf
op_lshift
l_int|6
)paren
comma
l_int|1
comma
l_string|&quot;WRITE(12)&quot;
)paren
)paren
op_eq
l_int|0
)paren
id|reply
op_assign
id|do_write
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Some mandatory commands that we recognize but don&squot;t implement.&n;&t; * They don&squot;t mean much in this setting.  It&squot;s left as an exercise&n;&t; * for anyone interested to implement RESERVE and RELEASE in terms&n;&t; * of Posix locks. */
r_case
id|SC_FORMAT_UNIT
suffix:colon
r_case
id|SC_RELEASE
suffix:colon
r_case
id|SC_RESERVE
suffix:colon
r_case
id|SC_SEND_DIAGNOSTIC
suffix:colon
singleline_comment|// Fall through
r_default
suffix:colon
id|fsg-&gt;data_size_from_cmnd
op_assign
l_int|0
suffix:semicolon
id|sprintf
c_func
(paren
id|unknown
comma
l_string|&quot;Unknown x%02x&quot;
comma
id|fsg-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reply
op_assign
id|check_command
c_func
(paren
id|fsg
comma
id|fsg-&gt;cmnd_size
comma
id|DATA_DIR_UNKNOWN
comma
l_int|0xff
comma
l_int|0
comma
id|unknown
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|fsg-&gt;curlun-&gt;sense_data
op_assign
id|SS_INVALID_COMMAND
suffix:semicolon
id|reply
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reply
op_eq
op_minus
id|EINTR
op_logical_or
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
multiline_comment|/* Set up the single reply buffer for finish_reply() */
r_if
c_cond
(paren
id|reply
op_eq
op_minus
id|EINVAL
)paren
id|reply
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Error reply length
r_if
c_cond
(paren
id|reply
op_ge
l_int|0
op_logical_and
id|fsg-&gt;data_dir
op_eq
id|DATA_DIR_TO_HOST
)paren
(brace
id|reply
op_assign
id|min
c_func
(paren
(paren
id|u32
)paren
id|reply
comma
id|fsg-&gt;data_size_from_cmnd
)paren
suffix:semicolon
id|bh-&gt;inreq-&gt;length
op_assign
id|reply
suffix:semicolon
id|bh-&gt;state
op_assign
id|BUF_STATE_FULL
suffix:semicolon
id|fsg-&gt;residue
op_sub_assign
id|reply
suffix:semicolon
)brace
singleline_comment|// Otherwise it&squot;s already set
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|received_cbw
r_static
r_int
id|received_cbw
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|fsg_buffhd
op_star
id|bh
)paren
(brace
r_struct
id|usb_request
op_star
id|req
op_assign
id|bh-&gt;outreq
suffix:semicolon
r_struct
id|bulk_cb_wrap
op_star
id|cbw
op_assign
(paren
r_struct
id|bulk_cb_wrap
op_star
)paren
id|req-&gt;buf
suffix:semicolon
multiline_comment|/* Was this a real packet? */
r_if
c_cond
(paren
id|req-&gt;status
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Is the CBW valid? */
r_if
c_cond
(paren
id|req-&gt;actual
op_ne
id|USB_BULK_CB_WRAP_LEN
op_logical_or
id|cbw-&gt;Signature
op_ne
id|__constant_cpu_to_le32
c_func
(paren
id|USB_BULK_CB_SIG
)paren
)paren
(brace
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;invalid CBW: len %u sig 0x%x&bslash;n&quot;
comma
id|req-&gt;actual
comma
id|le32_to_cpu
c_func
(paren
id|cbw-&gt;Signature
)paren
)paren
suffix:semicolon
multiline_comment|/* The Bulk-only spec says we MUST stall the bulk pipes!&n;&t;&t; * If we want to avoid stalls, set a flag so that we will&n;&t;&t; * clear the endpoint halts at the next reset. */
r_if
c_cond
(paren
op_logical_neg
id|mod_data.can_stall
)paren
id|set_bit
c_func
(paren
id|CLEAR_BULK_HALTS
comma
op_amp
id|fsg-&gt;atomic_bitflags
)paren
suffix:semicolon
id|fsg_set_halt
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_out
)paren
suffix:semicolon
id|halt_bulk_in_endpoint
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Is the CBW meaningful? */
r_if
c_cond
(paren
id|cbw-&gt;Lun
op_ge
id|MAX_LUNS
op_logical_or
id|cbw-&gt;Flags
op_amp
op_complement
id|USB_BULK_IN_FLAG
op_logical_or
id|cbw-&gt;Length
template_param
id|MAX_COMMAND_SIZE
)paren
(brace
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;non-meaningful CBW: lun = %u, flags = 0x%x, &quot;
l_string|&quot;cmdlen %u&bslash;n&quot;
comma
id|cbw-&gt;Lun
comma
id|cbw-&gt;Flags
comma
id|cbw-&gt;Length
)paren
suffix:semicolon
multiline_comment|/* We can do anything we want here, so let&squot;s stall the&n;&t;&t; * bulk pipes if we are allowed to. */
r_if
c_cond
(paren
id|mod_data.can_stall
)paren
(brace
id|fsg_set_halt
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_out
)paren
suffix:semicolon
id|halt_bulk_in_endpoint
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Save the command for later */
id|fsg-&gt;cmnd_size
op_assign
id|cbw-&gt;Length
suffix:semicolon
id|memcpy
c_func
(paren
id|fsg-&gt;cmnd
comma
id|cbw-&gt;CDB
comma
id|fsg-&gt;cmnd_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cbw-&gt;Flags
op_amp
id|USB_BULK_IN_FLAG
)paren
id|fsg-&gt;data_dir
op_assign
id|DATA_DIR_TO_HOST
suffix:semicolon
r_else
id|fsg-&gt;data_dir
op_assign
id|DATA_DIR_FROM_HOST
suffix:semicolon
id|fsg-&gt;data_size
op_assign
id|le32_to_cpu
c_func
(paren
id|cbw-&gt;DataTransferLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;data_size
op_eq
l_int|0
)paren
id|fsg-&gt;data_dir
op_assign
id|DATA_DIR_NONE
suffix:semicolon
id|fsg-&gt;lun
op_assign
id|cbw-&gt;Lun
suffix:semicolon
id|fsg-&gt;tag
op_assign
id|cbw-&gt;Tag
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_next_command
r_static
r_int
id|get_next_command
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_struct
id|fsg_buffhd
op_star
id|bh
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|transport_is_bbb
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* Wait for the next buffer to become available */
id|bh
op_assign
id|fsg-&gt;next_buffhd_to_fill
suffix:semicolon
r_while
c_loop
(paren
id|bh-&gt;state
op_ne
id|BUF_STATE_EMPTY
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|sleep_thread
c_func
(paren
id|fsg
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Queue a request to read a Bulk-only CBW */
id|set_bulk_out_req_length
c_func
(paren
id|fsg
comma
id|bh
comma
id|USB_BULK_CB_WRAP_LEN
)paren
suffix:semicolon
id|start_transfer
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_out
comma
id|bh-&gt;outreq
comma
op_amp
id|bh-&gt;outreq_busy
comma
op_amp
id|bh-&gt;state
)paren
suffix:semicolon
multiline_comment|/* We will drain the buffer in software, which means we&n;&t;&t; * can reuse it for the next filling.  No need to advance&n;&t;&t; * next_buffhd_to_fill. */
multiline_comment|/* Wait for the CBW to arrive */
r_while
c_loop
(paren
id|bh-&gt;state
op_ne
id|BUF_STATE_FULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|sleep_thread
c_func
(paren
id|fsg
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
id|rc
op_assign
id|received_cbw
c_func
(paren
id|fsg
comma
id|bh
)paren
suffix:semicolon
id|bh-&gt;state
op_assign
id|BUF_STATE_EMPTY
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// USB_PR_CB or USB_PR_CBI
multiline_comment|/* Wait for the next command to arrive */
r_while
c_loop
(paren
id|fsg-&gt;cbbuf_cmnd_size
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|sleep_thread
c_func
(paren
id|fsg
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Is the previous status interrupt request still busy?&n;&t;&t; * The host is allowed to skip reading the status,&n;&t;&t; * so we must cancel it. */
r_if
c_cond
(paren
id|fsg-&gt;intreq_busy
)paren
id|usb_ep_dequeue
c_func
(paren
id|fsg-&gt;intr_in
comma
id|fsg-&gt;intreq
)paren
suffix:semicolon
multiline_comment|/* Copy the command and mark the buffer empty */
id|fsg-&gt;data_dir
op_assign
id|DATA_DIR_UNKNOWN
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
id|fsg-&gt;cmnd_size
op_assign
id|fsg-&gt;cbbuf_cmnd_size
suffix:semicolon
id|memcpy
c_func
(paren
id|fsg-&gt;cmnd
comma
id|fsg-&gt;cbbuf_cmnd
comma
id|fsg-&gt;cmnd_size
)paren
suffix:semicolon
id|fsg-&gt;cbbuf_cmnd_size
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|enable_endpoint
r_static
r_int
id|enable_endpoint
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|usb_ep
op_star
id|ep
comma
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|d
)paren
(brace
r_int
id|rc
suffix:semicolon
id|ep-&gt;driver_data
op_assign
id|fsg
suffix:semicolon
id|rc
op_assign
id|usb_ep_enable
c_func
(paren
id|ep
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|ERROR
c_func
(paren
id|fsg
comma
l_string|&quot;can&squot;t enable %s, result %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|alloc_request
r_static
r_int
id|alloc_request
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
op_star
id|preq
)paren
(brace
op_star
id|preq
op_assign
id|usb_ep_alloc_request
c_func
(paren
id|ep
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|preq
)paren
r_return
l_int|0
suffix:semicolon
id|ERROR
c_func
(paren
id|fsg
comma
l_string|&quot;can&squot;t allocate request for %s&bslash;n&quot;
comma
id|ep-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset interface setting and re-init endpoint state (toggle etc).&n; * Call with altsetting &lt; 0 to disable the interface.  The only other&n; * available altsetting is 0, which enables the interface.&n; */
DECL|function|do_set_interface
r_static
r_int
id|do_set_interface
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
r_int
id|altsetting
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|d
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;running
)paren
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;reset interface&bslash;n&quot;
)paren
suffix:semicolon
id|reset
suffix:colon
multiline_comment|/* Deallocate the requests */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_BUFFERS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|fsg_buffhd
op_star
id|bh
op_assign
op_amp
id|fsg-&gt;buffhds
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;inreq
)paren
(brace
id|usb_ep_free_request
c_func
(paren
id|fsg-&gt;bulk_in
comma
id|bh-&gt;inreq
)paren
suffix:semicolon
id|bh-&gt;inreq
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh-&gt;outreq
)paren
(brace
id|usb_ep_free_request
c_func
(paren
id|fsg-&gt;bulk_out
comma
id|bh-&gt;outreq
)paren
suffix:semicolon
id|bh-&gt;outreq
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|fsg-&gt;intreq
)paren
(brace
id|usb_ep_free_request
c_func
(paren
id|fsg-&gt;intr_in
comma
id|fsg-&gt;intreq
)paren
suffix:semicolon
id|fsg-&gt;intreq
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Disable the endpoints */
r_if
c_cond
(paren
id|fsg-&gt;bulk_in_enabled
)paren
(brace
id|usb_ep_disable
c_func
(paren
id|fsg-&gt;bulk_in
)paren
suffix:semicolon
id|fsg-&gt;bulk_in_enabled
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fsg-&gt;bulk_out_enabled
)paren
(brace
id|usb_ep_disable
c_func
(paren
id|fsg-&gt;bulk_out
)paren
suffix:semicolon
id|fsg-&gt;bulk_out_enabled
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fsg-&gt;intr_in_enabled
)paren
(brace
id|usb_ep_disable
c_func
(paren
id|fsg-&gt;intr_in
)paren
suffix:semicolon
id|fsg-&gt;intr_in_enabled
op_assign
l_int|0
suffix:semicolon
)brace
id|fsg-&gt;running
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|altsetting
OL
l_int|0
op_logical_or
id|rc
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;set interface %d&bslash;n&quot;
comma
id|altsetting
)paren
suffix:semicolon
multiline_comment|/* Enable the endpoints */
id|d
op_assign
id|ep_desc
c_func
(paren
id|fsg-&gt;gadget
comma
op_amp
id|fs_bulk_in_desc
comma
op_amp
id|hs_bulk_in_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|enable_endpoint
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_in
comma
id|d
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|reset
suffix:semicolon
id|fsg-&gt;bulk_in_enabled
op_assign
l_int|1
suffix:semicolon
id|d
op_assign
id|ep_desc
c_func
(paren
id|fsg-&gt;gadget
comma
op_amp
id|fs_bulk_out_desc
comma
op_amp
id|hs_bulk_out_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|enable_endpoint
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_out
comma
id|d
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|reset
suffix:semicolon
id|fsg-&gt;bulk_out_enabled
op_assign
l_int|1
suffix:semicolon
id|fsg-&gt;bulk_out_maxpacket
op_assign
id|le16_to_cpu
c_func
(paren
id|d-&gt;wMaxPacketSize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transport_is_cbi
c_func
(paren
)paren
)paren
(brace
id|d
op_assign
id|ep_desc
c_func
(paren
id|fsg-&gt;gadget
comma
op_amp
id|fs_intr_in_desc
comma
op_amp
id|hs_intr_in_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|enable_endpoint
c_func
(paren
id|fsg
comma
id|fsg-&gt;intr_in
comma
id|d
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|reset
suffix:semicolon
id|fsg-&gt;intr_in_enabled
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Allocate the requests */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_BUFFERS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|fsg_buffhd
op_star
id|bh
op_assign
op_amp
id|fsg-&gt;buffhds
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|alloc_request
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_in
comma
op_amp
id|bh-&gt;inreq
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|reset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|alloc_request
c_func
(paren
id|fsg
comma
id|fsg-&gt;bulk_out
comma
op_amp
id|bh-&gt;outreq
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|reset
suffix:semicolon
id|bh-&gt;inreq-&gt;buf
op_assign
id|bh-&gt;outreq-&gt;buf
op_assign
id|bh-&gt;buf
suffix:semicolon
id|bh-&gt;inreq-&gt;dma
op_assign
id|bh-&gt;outreq-&gt;dma
op_assign
id|bh-&gt;dma
suffix:semicolon
id|bh-&gt;inreq-&gt;context
op_assign
id|bh-&gt;outreq-&gt;context
op_assign
id|bh
suffix:semicolon
id|bh-&gt;inreq-&gt;complete
op_assign
id|bulk_in_complete
suffix:semicolon
id|bh-&gt;outreq-&gt;complete
op_assign
id|bulk_out_complete
suffix:semicolon
)brace
r_if
c_cond
(paren
id|transport_is_cbi
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|alloc_request
c_func
(paren
id|fsg
comma
id|fsg-&gt;intr_in
comma
op_amp
id|fsg-&gt;intreq
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|reset
suffix:semicolon
id|fsg-&gt;intreq-&gt;complete
op_assign
id|intr_in_complete
suffix:semicolon
)brace
id|fsg-&gt;running
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fsg-&gt;nluns
suffix:semicolon
op_increment
id|i
)paren
id|fsg-&gt;luns
(braket
id|i
)braket
dot
id|unit_attention_data
op_assign
id|SS_RESET_OCCURRED
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Change our operational configuration.  This code must agree with the code&n; * that returns config descriptors, and with interface altsetting code.&n; *&n; * It&squot;s also responsible for power management interactions.  Some&n; * configurations might not work with our current power sources.&n; * For now we just assume the gadget is always self-powered.&n; */
DECL|function|do_set_config
r_static
r_int
id|do_set_config
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
comma
id|u8
id|new_config
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Disable the single interface */
r_if
c_cond
(paren
id|fsg-&gt;config
op_ne
l_int|0
)paren
(brace
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;reset config&bslash;n&quot;
)paren
suffix:semicolon
id|fsg-&gt;config
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|do_set_interface
c_func
(paren
id|fsg
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Enable the interface */
r_if
c_cond
(paren
id|new_config
op_ne
l_int|0
)paren
(brace
id|fsg-&gt;config
op_assign
id|new_config
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|do_set_interface
c_func
(paren
id|fsg
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
id|fsg-&gt;config
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Reset on errors
r_else
(brace
r_char
op_star
id|speed
suffix:semicolon
r_switch
c_cond
(paren
id|fsg-&gt;gadget-&gt;speed
)paren
(brace
r_case
id|USB_SPEED_LOW
suffix:colon
id|speed
op_assign
l_string|&quot;low&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_FULL
suffix:colon
id|speed
op_assign
l_string|&quot;full&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_HIGH
suffix:colon
id|speed
op_assign
l_string|&quot;high&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|speed
op_assign
l_string|&quot;?&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|INFO
c_func
(paren
id|fsg
comma
l_string|&quot;%s speed config #%d&bslash;n&quot;
comma
id|speed
comma
id|fsg-&gt;config
)paren
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|handle_exception
r_static
r_void
id|handle_exception
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
id|siginfo_t
id|info
suffix:semicolon
r_int
id|sig
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|num_active
suffix:semicolon
r_struct
id|fsg_buffhd
op_star
id|bh
suffix:semicolon
r_enum
id|fsg_state
id|old_state
suffix:semicolon
id|u8
id|new_config
suffix:semicolon
r_struct
id|lun
op_star
id|curlun
suffix:semicolon
r_int
r_int
id|exception_req_tag
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* Clear the existing signals.  Anything but SIGUSR1 is converted&n;&t; * into a high-priority EXIT exception. */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|sig
op_assign
id|dequeue_signal_lock
c_func
(paren
id|current
comma
op_amp
id|fsg-&gt;thread_signal_mask
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sig
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sig
op_ne
id|SIGUSR1
)paren
(brace
r_if
c_cond
(paren
id|fsg-&gt;state
OL
id|FSG_STATE_EXIT
)paren
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;Main thread exiting on signal&bslash;n&quot;
)paren
suffix:semicolon
id|raise_exception
c_func
(paren
id|fsg
comma
id|FSG_STATE_EXIT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Cancel all the pending transfers */
r_if
c_cond
(paren
id|fsg-&gt;intreq_busy
)paren
id|usb_ep_dequeue
c_func
(paren
id|fsg-&gt;intr_in
comma
id|fsg-&gt;intreq
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_BUFFERS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|bh
op_assign
op_amp
id|fsg-&gt;buffhds
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;inreq_busy
)paren
id|usb_ep_dequeue
c_func
(paren
id|fsg-&gt;bulk_in
comma
id|bh-&gt;inreq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;outreq_busy
)paren
id|usb_ep_dequeue
c_func
(paren
id|fsg-&gt;bulk_out
comma
id|bh-&gt;outreq
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait until everything is idle */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|num_active
op_assign
id|fsg-&gt;intreq_busy
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_BUFFERS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|bh
op_assign
op_amp
id|fsg-&gt;buffhds
(braket
id|i
)braket
suffix:semicolon
id|num_active
op_add_assign
id|bh-&gt;inreq_busy
op_plus
id|bh-&gt;outreq_busy
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num_active
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|sleep_thread
c_func
(paren
id|fsg
)paren
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/* Clear out the controller&squot;s fifos */
r_if
c_cond
(paren
id|fsg-&gt;bulk_in_enabled
)paren
id|usb_ep_fifo_flush
c_func
(paren
id|fsg-&gt;bulk_in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;bulk_out_enabled
)paren
id|usb_ep_fifo_flush
c_func
(paren
id|fsg-&gt;bulk_out
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;intr_in_enabled
)paren
id|usb_ep_fifo_flush
c_func
(paren
id|fsg-&gt;intr_in
)paren
suffix:semicolon
multiline_comment|/* Reset the I/O buffer states and pointers, the SCSI&n;&t; * state, and the exception.  Then invoke the handler. */
id|spin_lock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_BUFFERS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|bh
op_assign
op_amp
id|fsg-&gt;buffhds
(braket
id|i
)braket
suffix:semicolon
id|bh-&gt;state
op_assign
id|BUF_STATE_EMPTY
suffix:semicolon
)brace
id|fsg-&gt;next_buffhd_to_fill
op_assign
id|fsg-&gt;next_buffhd_to_drain
op_assign
op_amp
id|fsg-&gt;buffhds
(braket
l_int|0
)braket
suffix:semicolon
id|exception_req_tag
op_assign
id|fsg-&gt;exception_req_tag
suffix:semicolon
id|new_config
op_assign
id|fsg-&gt;new_config
suffix:semicolon
id|old_state
op_assign
id|fsg-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|old_state
op_eq
id|FSG_STATE_ABORT_BULK_OUT
)paren
id|fsg-&gt;state
op_assign
id|FSG_STATE_STATUS_PHASE
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fsg-&gt;nluns
suffix:semicolon
op_increment
id|i
)paren
(brace
id|curlun
op_assign
op_amp
id|fsg-&gt;luns
(braket
id|i
)braket
suffix:semicolon
id|curlun-&gt;prevent_medium_removal
op_assign
l_int|0
suffix:semicolon
id|curlun-&gt;sense_data
op_assign
id|curlun-&gt;unit_attention_data
op_assign
id|SS_NO_SENSE
suffix:semicolon
id|curlun-&gt;sense_data_info
op_assign
l_int|0
suffix:semicolon
)brace
id|fsg-&gt;state
op_assign
id|FSG_STATE_IDLE
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Carry out any extra actions required for the exception */
r_switch
c_cond
(paren
id|old_state
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|FSG_STATE_ABORT_BULK_OUT
suffix:colon
id|send_status
c_func
(paren
id|fsg
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;state
op_eq
id|FSG_STATE_STATUS_PHASE
)paren
id|fsg-&gt;state
op_assign
id|FSG_STATE_IDLE
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSG_STATE_RESET
suffix:colon
multiline_comment|/* In case we were forced against our will to halt a&n;&t;&t; * bulk endpoint, clear the halt now.  (The SuperH UDC&n;&t;&t; * requires this.) */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|CLEAR_BULK_HALTS
comma
op_amp
id|fsg-&gt;atomic_bitflags
)paren
)paren
(brace
id|usb_ep_clear_halt
c_func
(paren
id|fsg-&gt;bulk_in
)paren
suffix:semicolon
id|usb_ep_clear_halt
c_func
(paren
id|fsg-&gt;bulk_out
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|transport_is_bbb
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|fsg-&gt;ep0_req_tag
op_eq
id|exception_req_tag
)paren
id|ep0_queue
c_func
(paren
id|fsg
)paren
suffix:semicolon
singleline_comment|// Complete the status stage
)brace
r_else
r_if
c_cond
(paren
id|transport_is_cbi
c_func
(paren
)paren
)paren
id|send_status
c_func
(paren
id|fsg
)paren
suffix:semicolon
singleline_comment|// Status by interrupt pipe
multiline_comment|/* Technically this should go here, but it would only be&n;&t;&t; * a waste of time.  Ditto for the INTERFACE_CHANGE and&n;&t;&t; * CONFIG_CHANGE cases. */
singleline_comment|// for (i = 0; i &lt; fsg-&gt;nluns; ++i)
singleline_comment|//&t;fsg-&gt;luns[i].unit_attention_data = SS_RESET_OCCURRED;
r_break
suffix:semicolon
r_case
id|FSG_STATE_INTERFACE_CHANGE
suffix:colon
id|rc
op_assign
id|do_set_interface
c_func
(paren
id|fsg
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;ep0_req_tag
op_ne
id|exception_req_tag
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
singleline_comment|// STALL on errors
id|fsg_set_halt
c_func
(paren
id|fsg
comma
id|fsg-&gt;ep0
)paren
suffix:semicolon
r_else
singleline_comment|// Complete the status stage
id|ep0_queue
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSG_STATE_CONFIG_CHANGE
suffix:colon
id|rc
op_assign
id|do_set_config
c_func
(paren
id|fsg
comma
id|new_config
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fsg-&gt;ep0_req_tag
op_ne
id|exception_req_tag
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
singleline_comment|// STALL on errors
id|fsg_set_halt
c_func
(paren
id|fsg
comma
id|fsg-&gt;ep0
)paren
suffix:semicolon
r_else
singleline_comment|// Complete the status stage
id|ep0_queue
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSG_STATE_DISCONNECT
suffix:colon
id|fsync_all
c_func
(paren
id|fsg
)paren
suffix:semicolon
id|do_set_config
c_func
(paren
id|fsg
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|// Unconfigured state
r_break
suffix:semicolon
r_case
id|FSG_STATE_EXIT
suffix:colon
r_case
id|FSG_STATE_TERMINATED
suffix:colon
id|do_set_config
c_func
(paren
id|fsg
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|// Free resources
id|spin_lock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
id|fsg-&gt;state
op_assign
id|FSG_STATE_TERMINATED
suffix:semicolon
singleline_comment|// Stop the thread
id|spin_unlock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|fsg_main_thread
r_static
r_int
id|fsg_main_thread
c_func
(paren
r_void
op_star
id|fsg_
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
(paren
r_struct
id|fsg_dev
op_star
)paren
id|fsg_
suffix:semicolon
id|fsg-&gt;thread_task
op_assign
id|current
suffix:semicolon
multiline_comment|/* Release all our userspace resources */
id|daemonize
c_func
(paren
l_string|&quot;file-storage-gadget&quot;
)paren
suffix:semicolon
multiline_comment|/* Allow the thread to be killed by a signal, but set the signal mask&n;&t; * to block everything but INT, TERM, KILL, and USR1. */
id|siginitsetinv
c_func
(paren
op_amp
id|fsg-&gt;thread_signal_mask
comma
id|sigmask
c_func
(paren
id|SIGINT
)paren
op_or
id|sigmask
c_func
(paren
id|SIGTERM
)paren
op_or
id|sigmask
c_func
(paren
id|SIGKILL
)paren
op_or
id|sigmask
c_func
(paren
id|SIGUSR1
)paren
)paren
suffix:semicolon
id|sigprocmask
c_func
(paren
id|SIG_SETMASK
comma
op_amp
id|fsg-&gt;thread_signal_mask
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Arrange for userspace references to be interpreted as kernel&n;&t; * pointers.  That way we can pass a kernel pointer to a routine&n;&t; * that expects a __user pointer and it will work okay. */
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Wait for the gadget registration to finish up */
id|wait_for_completion
c_func
(paren
op_amp
id|fsg-&gt;thread_notifier
)paren
suffix:semicolon
multiline_comment|/* The main loop */
r_while
c_loop
(paren
id|fsg-&gt;state
op_ne
id|FSG_STATE_TERMINATED
)paren
(brace
r_if
c_cond
(paren
id|exception_in_progress
c_func
(paren
id|fsg
)paren
op_logical_or
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|handle_exception
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|fsg-&gt;running
)paren
(brace
id|sleep_thread
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_next_command
c_func
(paren
id|fsg
)paren
)paren
r_continue
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|exception_in_progress
c_func
(paren
id|fsg
)paren
)paren
id|fsg-&gt;state
op_assign
id|FSG_STATE_DATA_PHASE
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_scsi_command
c_func
(paren
id|fsg
)paren
op_logical_or
id|finish_reply
c_func
(paren
id|fsg
)paren
)paren
r_continue
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|exception_in_progress
c_func
(paren
id|fsg
)paren
)paren
id|fsg-&gt;state
op_assign
id|FSG_STATE_STATUS_PHASE
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_status
c_func
(paren
id|fsg
)paren
)paren
r_continue
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|exception_in_progress
c_func
(paren
id|fsg
)paren
)paren
id|fsg-&gt;state
op_assign
id|FSG_STATE_IDLE
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
)brace
id|fsg-&gt;thread_task
op_assign
l_int|NULL
suffix:semicolon
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* In case we are exiting because of a signal, unregister the&n;&t; * gadget driver and close the backing file. */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|REGISTERED
comma
op_amp
id|fsg-&gt;atomic_bitflags
)paren
)paren
(brace
id|usb_gadget_unregister_driver
c_func
(paren
op_amp
id|fsg_driver
)paren
suffix:semicolon
id|close_all_backing_files
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
multiline_comment|/* Let the unbind and cleanup routines know the thread has exited */
id|complete_and_exit
c_func
(paren
op_amp
id|fsg-&gt;thread_notifier
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* If the next two routines are called while the gadget is registered,&n; * the caller must own fsg-&gt;filesem for writing. */
DECL|function|open_backing_file
r_static
r_int
id|open_backing_file
c_func
(paren
r_struct
id|lun
op_star
id|curlun
comma
r_const
r_char
op_star
id|filename
)paren
(brace
r_int
id|ro
suffix:semicolon
r_struct
id|file
op_star
id|filp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
id|loff_t
id|size
suffix:semicolon
id|loff_t
id|num_sectors
suffix:semicolon
multiline_comment|/* R/W if we can, R/O if we must */
id|ro
op_assign
id|curlun-&gt;ro
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ro
)paren
(brace
id|filp
op_assign
id|filp_open
c_func
(paren
id|filename
comma
id|O_RDWR
op_or
id|O_LARGEFILE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
id|EROFS
op_eq
id|PTR_ERR
c_func
(paren
id|filp
)paren
)paren
id|ro
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ro
)paren
id|filp
op_assign
id|filp_open
c_func
(paren
id|filename
comma
id|O_RDONLY
op_or
id|O_LARGEFILE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|filp
)paren
)paren
(brace
id|LINFO
c_func
(paren
id|curlun
comma
l_string|&quot;unable to open backing file: %s&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|filp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
id|ro
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_dentry
)paren
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|bdev_read_only
c_func
(paren
id|inode-&gt;i_bdev
)paren
)paren
id|ro
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|LINFO
c_func
(paren
id|curlun
comma
l_string|&quot;invalid file type: %s&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* If we can&squot;t read the file, it&squot;s no good.&n;&t; * If we can&squot;t write the file, use it read-only. */
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_op
op_logical_or
op_logical_neg
(paren
id|filp-&gt;f_op-&gt;read
op_logical_or
id|filp-&gt;f_op-&gt;aio_read
)paren
)paren
(brace
id|LINFO
c_func
(paren
id|curlun
comma
l_string|&quot;file not readable: %s&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_op-&gt;write
op_logical_or
id|filp-&gt;f_op-&gt;aio_write
)paren
)paren
id|ro
op_assign
l_int|1
suffix:semicolon
id|size
op_assign
id|i_size_read
c_func
(paren
id|inode-&gt;i_mapping-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|0
)paren
(brace
id|LINFO
c_func
(paren
id|curlun
comma
l_string|&quot;unable to find file size: %s&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
id|rc
op_assign
(paren
r_int
)paren
id|size
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|num_sectors
op_assign
id|size
op_rshift
l_int|9
suffix:semicolon
singleline_comment|// File size in 512-byte sectors
r_if
c_cond
(paren
id|num_sectors
op_eq
l_int|0
)paren
(brace
id|LINFO
c_func
(paren
id|curlun
comma
l_string|&quot;file too small: %s&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ETOOSMALL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|get_file
c_func
(paren
id|filp
)paren
suffix:semicolon
id|curlun-&gt;ro
op_assign
id|ro
suffix:semicolon
id|curlun-&gt;filp
op_assign
id|filp
suffix:semicolon
id|curlun-&gt;file_length
op_assign
id|size
suffix:semicolon
id|curlun-&gt;num_sectors
op_assign
id|num_sectors
suffix:semicolon
id|LDBG
c_func
(paren
id|curlun
comma
l_string|&quot;open backing file: %s&bslash;n&quot;
comma
id|filename
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|filp_close
c_func
(paren
id|filp
comma
id|current-&gt;files
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|close_backing_file
r_static
r_void
id|close_backing_file
c_func
(paren
r_struct
id|lun
op_star
id|curlun
)paren
(brace
r_if
c_cond
(paren
id|curlun-&gt;filp
)paren
(brace
id|LDBG
c_func
(paren
id|curlun
comma
l_string|&quot;close backing file&bslash;n&quot;
)paren
suffix:semicolon
id|fput
c_func
(paren
id|curlun-&gt;filp
)paren
suffix:semicolon
id|curlun-&gt;filp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|close_all_backing_files
r_static
r_void
id|close_all_backing_files
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fsg-&gt;nluns
suffix:semicolon
op_increment
id|i
)paren
id|close_backing_file
c_func
(paren
op_amp
id|fsg-&gt;luns
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|show_ro
r_static
id|ssize_t
id|show_ro
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|dev_to_lun
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|curlun-&gt;ro
)paren
suffix:semicolon
)brace
DECL|function|show_file
r_static
id|ssize_t
id|show_file
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|dev_to_lun
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
(paren
r_struct
id|fsg_dev
op_star
)paren
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
id|ssize_t
id|rc
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|backing_file_is_open
c_func
(paren
id|curlun
)paren
)paren
(brace
singleline_comment|// Get the complete pathname
id|p
op_assign
id|d_path
c_func
(paren
id|curlun-&gt;filp-&gt;f_dentry
comma
id|curlun-&gt;filp-&gt;f_vfsmnt
comma
id|buf
comma
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|p
)paren
)paren
id|rc
op_assign
id|PTR_ERR
c_func
(paren
id|p
)paren
suffix:semicolon
r_else
(brace
id|rc
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|buf
comma
id|p
comma
id|rc
)paren
suffix:semicolon
id|buf
(braket
id|rc
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
singleline_comment|// Add a newline
id|buf
(braket
op_increment
id|rc
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// No file, return 0 bytes
op_star
id|buf
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|store_ro
r_static
id|ssize_t
id|store_ro
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|ssize_t
id|rc
op_assign
id|count
suffix:semicolon
r_struct
id|lun
op_star
id|curlun
op_assign
id|dev_to_lun
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
(paren
r_struct
id|fsg_dev
op_star
)paren
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sscanf
c_func
(paren
id|buf
comma
l_string|&quot;%d&quot;
comma
op_amp
id|i
)paren
op_ne
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Allow the write-enable status to change only while the backing file&n;&t; * is closed. */
id|down_read
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|backing_file_is_open
c_func
(paren
id|curlun
)paren
)paren
(brace
id|LDBG
c_func
(paren
id|curlun
comma
l_string|&quot;read-only status change prevented&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
id|curlun-&gt;ro
op_assign
op_logical_neg
op_logical_neg
id|i
suffix:semicolon
id|LDBG
c_func
(paren
id|curlun
comma
l_string|&quot;read-only status set to %d&bslash;n&quot;
comma
id|curlun-&gt;ro
)paren
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|store_file
r_static
id|ssize_t
id|store_file
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|lun
op_star
id|curlun
op_assign
id|dev_to_lun
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
(paren
r_struct
id|fsg_dev
op_star
)paren
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|curlun-&gt;prevent_medium_removal
op_logical_and
id|backing_file_is_open
c_func
(paren
id|curlun
)paren
)paren
(brace
id|LDBG
c_func
(paren
id|curlun
comma
l_string|&quot;eject attempt prevented&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
singleline_comment|// &quot;Door is locked&quot;
)brace
multiline_comment|/* Remove a trailing newline */
r_if
c_cond
(paren
id|count
OG
l_int|0
op_logical_and
id|buf
(braket
id|count
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
(braket
id|count
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Ugh!
multiline_comment|/* Eject current medium */
id|down_write
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|backing_file_is_open
c_func
(paren
id|curlun
)paren
)paren
(brace
id|close_backing_file
c_func
(paren
id|curlun
)paren
suffix:semicolon
id|curlun-&gt;unit_attention_data
op_assign
id|SS_MEDIUM_NOT_PRESENT
suffix:semicolon
)brace
multiline_comment|/* Load new medium */
r_if
c_cond
(paren
id|count
OG
l_int|0
op_logical_and
id|buf
(braket
l_int|0
)braket
)paren
(brace
id|rc
op_assign
id|open_backing_file
c_func
(paren
id|curlun
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|curlun-&gt;unit_attention_data
op_assign
id|SS_NOT_READY_TO_READY_TRANSITION
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
r_return
(paren
id|rc
OL
l_int|0
ques
c_cond
id|rc
suffix:colon
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* The write permissions and store_xxx pointers are set in fsg_bind() */
r_static
id|DEVICE_ATTR
c_func
(paren
id|ro
comma
l_int|0444
comma
id|show_ro
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|file
comma
l_int|0444
comma
id|show_file
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|lun_release
r_static
r_void
id|lun_release
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
(paren
r_struct
id|fsg_dev
op_star
)paren
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
id|complete
c_func
(paren
op_amp
id|fsg-&gt;lun_released
)paren
suffix:semicolon
)brace
DECL|function|fsg_unbind
r_static
r_void
id|fsg_unbind
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
id|get_gadget_data
c_func
(paren
id|gadget
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|lun
op_star
id|curlun
suffix:semicolon
r_struct
id|usb_request
op_star
id|req
op_assign
id|fsg-&gt;ep0req
suffix:semicolon
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;unbind&bslash;n&quot;
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|REGISTERED
comma
op_amp
id|fsg-&gt;atomic_bitflags
)paren
suffix:semicolon
multiline_comment|/* Unregister the sysfs attribute files and the LUNs */
id|init_completion
c_func
(paren
op_amp
id|fsg-&gt;lun_released
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fsg-&gt;nluns
suffix:semicolon
op_increment
id|i
)paren
(brace
id|curlun
op_assign
op_amp
id|fsg-&gt;luns
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|curlun-&gt;registered
)paren
(brace
id|device_remove_file
c_func
(paren
op_amp
id|curlun-&gt;dev
comma
op_amp
id|dev_attr_ro
)paren
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|curlun-&gt;dev
comma
op_amp
id|dev_attr_file
)paren
suffix:semicolon
id|device_unregister
c_func
(paren
op_amp
id|curlun-&gt;dev
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|fsg-&gt;lun_released
)paren
suffix:semicolon
id|curlun-&gt;registered
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* If the thread isn&squot;t already dead, tell it to exit now */
r_if
c_cond
(paren
id|fsg-&gt;state
op_ne
id|FSG_STATE_TERMINATED
)paren
(brace
id|raise_exception
c_func
(paren
id|fsg
comma
id|FSG_STATE_EXIT
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|fsg-&gt;thread_notifier
)paren
suffix:semicolon
multiline_comment|/* The cleanup routine waits for this completion also */
id|complete
c_func
(paren
op_amp
id|fsg-&gt;thread_notifier
)paren
suffix:semicolon
)brace
multiline_comment|/* Free the data buffers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_BUFFERS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|fsg_buffhd
op_star
id|bh
op_assign
op_amp
id|fsg-&gt;buffhds
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;buf
)paren
id|usb_ep_free_buffer
c_func
(paren
id|fsg-&gt;bulk_in
comma
id|bh-&gt;buf
comma
id|bh-&gt;dma
comma
id|mod_data.buflen
)paren
suffix:semicolon
)brace
multiline_comment|/* Free the request and buffer for endpoint 0 */
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;buf
)paren
id|usb_ep_free_buffer
c_func
(paren
id|fsg-&gt;ep0
comma
id|req-&gt;buf
comma
id|req-&gt;dma
comma
id|EP0_BUFSIZE
)paren
suffix:semicolon
id|usb_ep_free_request
c_func
(paren
id|fsg-&gt;ep0
comma
id|req
)paren
suffix:semicolon
)brace
id|set_gadget_data
c_func
(paren
id|gadget
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|check_parameters
r_static
r_int
id|__init
id|check_parameters
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
r_int
id|prot
suffix:semicolon
multiline_comment|/* Store the default values */
id|mod_data.transport_type
op_assign
id|USB_PR_BULK
suffix:semicolon
id|mod_data.transport_name
op_assign
l_string|&quot;Bulk-only&quot;
suffix:semicolon
id|mod_data.protocol_type
op_assign
id|USB_SC_SCSI
suffix:semicolon
id|mod_data.protocol_name
op_assign
l_string|&quot;Transparent SCSI&quot;
suffix:semicolon
r_if
c_cond
(paren
id|gadget_is_sh
c_func
(paren
id|fsg-&gt;gadget
)paren
)paren
id|mod_data.can_stall
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mod_data.release
op_eq
l_int|0xffff
)paren
(brace
singleline_comment|// Parameter wasn&squot;t set
r_if
c_cond
(paren
id|gadget_is_net2280
c_func
(paren
id|fsg-&gt;gadget
)paren
)paren
id|mod_data.release
op_assign
l_int|0x0301
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gadget_is_dummy
c_func
(paren
id|fsg-&gt;gadget
)paren
)paren
id|mod_data.release
op_assign
l_int|0x0302
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gadget_is_pxa
c_func
(paren
id|fsg-&gt;gadget
)paren
)paren
id|mod_data.release
op_assign
l_int|0x0303
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gadget_is_sh
c_func
(paren
id|fsg-&gt;gadget
)paren
)paren
id|mod_data.release
op_assign
l_int|0x0304
suffix:semicolon
multiline_comment|/* The sa1100 controller is not supported */
r_else
r_if
c_cond
(paren
id|gadget_is_goku
c_func
(paren
id|fsg-&gt;gadget
)paren
)paren
id|mod_data.release
op_assign
l_int|0x0306
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gadget_is_mq11xx
c_func
(paren
id|fsg-&gt;gadget
)paren
)paren
id|mod_data.release
op_assign
l_int|0x0307
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gadget_is_omap
c_func
(paren
id|fsg-&gt;gadget
)paren
)paren
id|mod_data.release
op_assign
l_int|0x0308
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gadget_is_lh7a40x
c_func
(paren
id|fsg-&gt;gadget
)paren
)paren
id|mod_data.release
op_assign
l_int|0x0309
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gadget_is_n9604
c_func
(paren
id|fsg-&gt;gadget
)paren
)paren
id|mod_data.release
op_assign
l_int|0x0310
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gadget_is_pxa27x
c_func
(paren
id|fsg-&gt;gadget
)paren
)paren
id|mod_data.release
op_assign
l_int|0x0311
suffix:semicolon
r_else
(brace
id|WARN
c_func
(paren
id|fsg
comma
l_string|&quot;controller &squot;%s&squot; not recognized&bslash;n&quot;
comma
id|fsg-&gt;gadget-&gt;name
)paren
suffix:semicolon
id|mod_data.release
op_assign
l_int|0x0399
suffix:semicolon
)brace
)brace
id|prot
op_assign
id|simple_strtol
c_func
(paren
id|mod_data.protocol_parm
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_FILE_STORAGE_TEST
r_if
c_cond
(paren
id|strnicmp
c_func
(paren
id|mod_data.transport_parm
comma
l_string|&quot;BBB&quot;
comma
l_int|10
)paren
op_eq
l_int|0
)paren
(brace
suffix:semicolon
singleline_comment|// Use default setting
)brace
r_else
r_if
c_cond
(paren
id|strnicmp
c_func
(paren
id|mod_data.transport_parm
comma
l_string|&quot;CB&quot;
comma
l_int|10
)paren
op_eq
l_int|0
)paren
(brace
id|mod_data.transport_type
op_assign
id|USB_PR_CB
suffix:semicolon
id|mod_data.transport_name
op_assign
l_string|&quot;Control-Bulk&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strnicmp
c_func
(paren
id|mod_data.transport_parm
comma
l_string|&quot;CBI&quot;
comma
l_int|10
)paren
op_eq
l_int|0
)paren
(brace
id|mod_data.transport_type
op_assign
id|USB_PR_CBI
suffix:semicolon
id|mod_data.transport_name
op_assign
l_string|&quot;Control-Bulk-Interrupt&quot;
suffix:semicolon
)brace
r_else
(brace
id|ERROR
c_func
(paren
id|fsg
comma
l_string|&quot;invalid transport: %s&bslash;n&quot;
comma
id|mod_data.transport_parm
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strnicmp
c_func
(paren
id|mod_data.protocol_parm
comma
l_string|&quot;SCSI&quot;
comma
l_int|10
)paren
op_eq
l_int|0
op_logical_or
id|prot
op_eq
id|USB_SC_SCSI
)paren
(brace
suffix:semicolon
singleline_comment|// Use default setting
)brace
r_else
r_if
c_cond
(paren
id|strnicmp
c_func
(paren
id|mod_data.protocol_parm
comma
l_string|&quot;RBC&quot;
comma
l_int|10
)paren
op_eq
l_int|0
op_logical_or
id|prot
op_eq
id|USB_SC_RBC
)paren
(brace
id|mod_data.protocol_type
op_assign
id|USB_SC_RBC
suffix:semicolon
id|mod_data.protocol_name
op_assign
l_string|&quot;RBC&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strnicmp
c_func
(paren
id|mod_data.protocol_parm
comma
l_string|&quot;8020&quot;
comma
l_int|4
)paren
op_eq
l_int|0
op_logical_or
id|strnicmp
c_func
(paren
id|mod_data.protocol_parm
comma
l_string|&quot;ATAPI&quot;
comma
l_int|10
)paren
op_eq
l_int|0
op_logical_or
id|prot
op_eq
id|USB_SC_8020
)paren
(brace
id|mod_data.protocol_type
op_assign
id|USB_SC_8020
suffix:semicolon
id|mod_data.protocol_name
op_assign
l_string|&quot;8020i (ATAPI)&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strnicmp
c_func
(paren
id|mod_data.protocol_parm
comma
l_string|&quot;QIC&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|prot
op_eq
id|USB_SC_QIC
)paren
(brace
id|mod_data.protocol_type
op_assign
id|USB_SC_QIC
suffix:semicolon
id|mod_data.protocol_name
op_assign
l_string|&quot;QIC-157&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strnicmp
c_func
(paren
id|mod_data.protocol_parm
comma
l_string|&quot;UFI&quot;
comma
l_int|10
)paren
op_eq
l_int|0
op_logical_or
id|prot
op_eq
id|USB_SC_UFI
)paren
(brace
id|mod_data.protocol_type
op_assign
id|USB_SC_UFI
suffix:semicolon
id|mod_data.protocol_name
op_assign
l_string|&quot;UFI&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strnicmp
c_func
(paren
id|mod_data.protocol_parm
comma
l_string|&quot;8070&quot;
comma
l_int|4
)paren
op_eq
l_int|0
op_logical_or
id|prot
op_eq
id|USB_SC_8070
)paren
(brace
id|mod_data.protocol_type
op_assign
id|USB_SC_8070
suffix:semicolon
id|mod_data.protocol_name
op_assign
l_string|&quot;8070i&quot;
suffix:semicolon
)brace
r_else
(brace
id|ERROR
c_func
(paren
id|fsg
comma
l_string|&quot;invalid protocol: %s&bslash;n&quot;
comma
id|mod_data.protocol_parm
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mod_data.buflen
op_and_assign
id|PAGE_CACHE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|mod_data.buflen
op_le
l_int|0
)paren
(brace
id|ERROR
c_func
(paren
id|fsg
comma
l_string|&quot;invalid buflen&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ETOOSMALL
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_USB_FILE_STORAGE_TEST */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fsg_bind
r_static
r_int
id|__init
id|fsg_bind
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
id|the_fsg
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|lun
op_star
id|curlun
suffix:semicolon
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
r_char
op_star
id|pathbuf
comma
op_star
id|p
suffix:semicolon
id|fsg-&gt;gadget
op_assign
id|gadget
suffix:semicolon
id|set_gadget_data
c_func
(paren
id|gadget
comma
id|fsg
)paren
suffix:semicolon
id|fsg-&gt;ep0
op_assign
id|gadget-&gt;ep0
suffix:semicolon
id|fsg-&gt;ep0-&gt;driver_data
op_assign
id|fsg
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|check_parameters
c_func
(paren
id|fsg
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|mod_data.removable
)paren
(brace
singleline_comment|// Enable the store_xxx attributes
id|dev_attr_ro.attr.mode
op_assign
id|dev_attr_file.attr.mode
op_assign
l_int|0644
suffix:semicolon
id|dev_attr_ro.store
op_assign
id|store_ro
suffix:semicolon
id|dev_attr_file.store
op_assign
id|store_file
suffix:semicolon
)brace
multiline_comment|/* Find out how many LUNs there should be */
id|i
op_assign
id|mod_data.nluns
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|i
op_assign
id|max
c_func
(paren
id|mod_data.num_filenames
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
id|MAX_LUNS
)paren
(brace
id|ERROR
c_func
(paren
id|fsg
comma
l_string|&quot;invalid number of LUNs: %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Create the LUNs, open their backing files, and register the&n;&t; * LUN devices in sysfs. */
id|fsg-&gt;luns
op_assign
id|kmalloc
c_func
(paren
id|i
op_star
r_sizeof
(paren
r_struct
id|lun
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fsg-&gt;luns
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|fsg-&gt;luns
comma
l_int|0
comma
id|i
op_star
r_sizeof
(paren
r_struct
id|lun
)paren
)paren
suffix:semicolon
id|fsg-&gt;nluns
op_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fsg-&gt;nluns
suffix:semicolon
op_increment
id|i
)paren
(brace
id|curlun
op_assign
op_amp
id|fsg-&gt;luns
(braket
id|i
)braket
suffix:semicolon
id|curlun-&gt;ro
op_assign
id|ro
(braket
id|i
)braket
suffix:semicolon
id|curlun-&gt;dev.parent
op_assign
op_amp
id|gadget-&gt;dev
suffix:semicolon
id|curlun-&gt;dev.driver
op_assign
op_amp
id|fsg_driver.driver
suffix:semicolon
id|dev_set_drvdata
c_func
(paren
op_amp
id|curlun-&gt;dev
comma
id|fsg
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|curlun-&gt;dev.bus_id
comma
id|BUS_ID_SIZE
comma
l_string|&quot;%s-lun%d&quot;
comma
id|gadget-&gt;dev.bus_id
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|device_register
c_func
(paren
op_amp
id|curlun-&gt;dev
)paren
)paren
op_ne
l_int|0
)paren
id|INFO
c_func
(paren
id|fsg
comma
l_string|&quot;failed to register LUN%d: %d&bslash;n&quot;
comma
id|i
comma
id|rc
)paren
suffix:semicolon
r_else
(brace
id|curlun-&gt;registered
op_assign
l_int|1
suffix:semicolon
id|curlun-&gt;dev.release
op_assign
id|lun_release
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|curlun-&gt;dev
comma
op_amp
id|dev_attr_ro
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|curlun-&gt;dev
comma
op_amp
id|dev_attr_file
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file
(braket
id|i
)braket
op_logical_and
op_star
id|file
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|open_backing_file
c_func
(paren
id|curlun
comma
id|file
(braket
id|i
)braket
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|mod_data.removable
)paren
(brace
id|ERROR
c_func
(paren
id|fsg
comma
l_string|&quot;no file given for LUN%d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* Find all the endpoints we will use */
id|usb_ep_autoconfig_reset
c_func
(paren
id|gadget
)paren
suffix:semicolon
id|ep
op_assign
id|usb_ep_autoconfig
c_func
(paren
id|gadget
comma
op_amp
id|fs_bulk_in_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_goto
id|autoconf_fail
suffix:semicolon
id|ep-&gt;driver_data
op_assign
id|fsg
suffix:semicolon
singleline_comment|// claim the endpoint
id|fsg-&gt;bulk_in
op_assign
id|ep
suffix:semicolon
id|ep
op_assign
id|usb_ep_autoconfig
c_func
(paren
id|gadget
comma
op_amp
id|fs_bulk_out_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_goto
id|autoconf_fail
suffix:semicolon
id|ep-&gt;driver_data
op_assign
id|fsg
suffix:semicolon
singleline_comment|// claim the endpoint
id|fsg-&gt;bulk_out
op_assign
id|ep
suffix:semicolon
r_if
c_cond
(paren
id|transport_is_cbi
c_func
(paren
)paren
)paren
(brace
id|ep
op_assign
id|usb_ep_autoconfig
c_func
(paren
id|gadget
comma
op_amp
id|fs_intr_in_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_goto
id|autoconf_fail
suffix:semicolon
id|ep-&gt;driver_data
op_assign
id|fsg
suffix:semicolon
singleline_comment|// claim the endpoint
id|fsg-&gt;intr_in
op_assign
id|ep
suffix:semicolon
)brace
multiline_comment|/* Fix up the descriptors */
id|device_desc.bMaxPacketSize0
op_assign
id|fsg-&gt;ep0-&gt;maxpacket
suffix:semicolon
id|device_desc.idVendor
op_assign
id|cpu_to_le16
c_func
(paren
id|mod_data.vendor
)paren
suffix:semicolon
id|device_desc.idProduct
op_assign
id|cpu_to_le16
c_func
(paren
id|mod_data.product
)paren
suffix:semicolon
id|device_desc.bcdDevice
op_assign
id|cpu_to_le16
c_func
(paren
id|mod_data.release
)paren
suffix:semicolon
id|i
op_assign
(paren
id|transport_is_cbi
c_func
(paren
)paren
ques
c_cond
l_int|3
suffix:colon
l_int|2
)paren
suffix:semicolon
singleline_comment|// Number of endpoints
id|intf_desc.bNumEndpoints
op_assign
id|i
suffix:semicolon
id|intf_desc.bInterfaceSubClass
op_assign
id|mod_data.protocol_type
suffix:semicolon
id|intf_desc.bInterfaceProtocol
op_assign
id|mod_data.transport_type
suffix:semicolon
id|fs_function
(braket
id|i
op_plus
id|FS_FUNCTION_PRE_EP_ENTRIES
)braket
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_USB_GADGET_DUALSPEED
id|hs_function
(braket
id|i
op_plus
id|HS_FUNCTION_PRE_EP_ENTRIES
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Assume ep0 uses the same maxpacket value for both speeds */
id|dev_qualifier.bMaxPacketSize0
op_assign
id|fsg-&gt;ep0-&gt;maxpacket
suffix:semicolon
multiline_comment|/* Assume that all endpoint addresses are the same for both speeds */
id|hs_bulk_in_desc.bEndpointAddress
op_assign
id|fs_bulk_in_desc.bEndpointAddress
suffix:semicolon
id|hs_bulk_out_desc.bEndpointAddress
op_assign
id|fs_bulk_out_desc.bEndpointAddress
suffix:semicolon
id|hs_intr_in_desc.bEndpointAddress
op_assign
id|fs_intr_in_desc.bEndpointAddress
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|gadget-&gt;is_otg
)paren
(brace
id|otg_desc.bmAttributes
op_or_assign
id|USB_OTG_HNP
comma
id|config_desc.bmAttributes
op_or_assign
id|USB_CONFIG_ATT_WAKEUP
suffix:semicolon
)brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Allocate the request and buffer for endpoint 0 */
id|fsg-&gt;ep0req
op_assign
id|req
op_assign
id|usb_ep_alloc_request
c_func
(paren
id|fsg-&gt;ep0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_goto
id|out
suffix:semicolon
id|req-&gt;buf
op_assign
id|usb_ep_alloc_buffer
c_func
(paren
id|fsg-&gt;ep0
comma
id|EP0_BUFSIZE
comma
op_amp
id|req-&gt;dma
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;buf
)paren
r_goto
id|out
suffix:semicolon
id|req-&gt;complete
op_assign
id|ep0_complete
suffix:semicolon
multiline_comment|/* Allocate the data buffers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_BUFFERS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|fsg_buffhd
op_star
id|bh
op_assign
op_amp
id|fsg-&gt;buffhds
(braket
id|i
)braket
suffix:semicolon
id|bh-&gt;buf
op_assign
id|usb_ep_alloc_buffer
c_func
(paren
id|fsg-&gt;bulk_in
comma
id|mod_data.buflen
comma
op_amp
id|bh-&gt;dma
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;buf
)paren
r_goto
id|out
suffix:semicolon
id|bh-&gt;next
op_assign
id|bh
op_plus
l_int|1
suffix:semicolon
)brace
id|fsg-&gt;buffhds
(braket
id|NUM_BUFFERS
op_minus
l_int|1
)braket
dot
id|next
op_assign
op_amp
id|fsg-&gt;buffhds
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* This should reflect the actual gadget power source */
id|usb_gadget_set_selfpowered
c_func
(paren
id|gadget
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|manufacturer
comma
r_sizeof
id|manufacturer
comma
id|UTS_SYSNAME
l_string|&quot; &quot;
id|UTS_RELEASE
l_string|&quot; with %s&quot;
comma
id|gadget-&gt;name
)paren
suffix:semicolon
multiline_comment|/* On a real device, serial[] would be loaded from permanent&n;&t; * storage.  We just encode it from the driver version string. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|serial
)paren
op_minus
l_int|2
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
r_int
r_char
id|c
op_assign
id|DRIVER_VERSION
(braket
id|i
op_div
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
id|sprintf
c_func
(paren
op_amp
id|serial
(braket
id|i
)braket
comma
l_string|&quot;%02X&quot;
comma
id|c
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|kernel_thread
c_func
(paren
id|fsg_main_thread
comma
id|fsg
comma
(paren
id|CLONE_VM
op_or
id|CLONE_FS
op_or
id|CLONE_FILES
)paren
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|fsg-&gt;thread_pid
op_assign
id|rc
suffix:semicolon
id|INFO
c_func
(paren
id|fsg
comma
id|DRIVER_DESC
l_string|&quot;, version: &quot;
id|DRIVER_VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|INFO
c_func
(paren
id|fsg
comma
l_string|&quot;Number of LUNs=%d&bslash;n&quot;
comma
id|fsg-&gt;nluns
)paren
suffix:semicolon
id|pathbuf
op_assign
id|kmalloc
c_func
(paren
id|PATH_MAX
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fsg-&gt;nluns
suffix:semicolon
op_increment
id|i
)paren
(brace
id|curlun
op_assign
op_amp
id|fsg-&gt;luns
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|backing_file_is_open
c_func
(paren
id|curlun
)paren
)paren
(brace
id|p
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|pathbuf
)paren
(brace
id|p
op_assign
id|d_path
c_func
(paren
id|curlun-&gt;filp-&gt;f_dentry
comma
id|curlun-&gt;filp-&gt;f_vfsmnt
comma
id|pathbuf
comma
id|PATH_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|p
)paren
)paren
id|p
op_assign
l_int|NULL
suffix:semicolon
)brace
id|LINFO
c_func
(paren
id|curlun
comma
l_string|&quot;ro=%d, file: %s&bslash;n&quot;
comma
id|curlun-&gt;ro
comma
(paren
id|p
ques
c_cond
id|p
suffix:colon
l_string|&quot;(error)&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|pathbuf
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;transport=%s (x%02x)&bslash;n&quot;
comma
id|mod_data.transport_name
comma
id|mod_data.transport_type
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;protocol=%s (x%02x)&bslash;n&quot;
comma
id|mod_data.protocol_name
comma
id|mod_data.protocol_type
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;VendorID=x%04x, ProductID=x%04x, Release=x%04x&bslash;n&quot;
comma
id|mod_data.vendor
comma
id|mod_data.product
comma
id|mod_data.release
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;removable=%d, stall=%d, buflen=%u&bslash;n&quot;
comma
id|mod_data.removable
comma
id|mod_data.can_stall
comma
id|mod_data.buflen
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;I/O thread pid: %d&bslash;n&quot;
comma
id|fsg-&gt;thread_pid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|autoconf_fail
suffix:colon
id|ERROR
c_func
(paren
id|fsg
comma
l_string|&quot;unable to autoconfigure all endpoints&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOTSUPP
suffix:semicolon
id|out
suffix:colon
id|fsg-&gt;state
op_assign
id|FSG_STATE_TERMINATED
suffix:semicolon
singleline_comment|// The thread is dead
id|fsg_unbind
c_func
(paren
id|gadget
)paren
suffix:semicolon
id|close_all_backing_files
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|fsg_suspend
r_static
r_void
id|fsg_suspend
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
id|get_gadget_data
c_func
(paren
id|gadget
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;suspend&bslash;n&quot;
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SUSPENDED
comma
op_amp
id|fsg-&gt;atomic_bitflags
)paren
suffix:semicolon
)brace
DECL|function|fsg_resume
r_static
r_void
id|fsg_resume
c_func
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
id|get_gadget_data
c_func
(paren
id|gadget
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|fsg
comma
l_string|&quot;resume&bslash;n&quot;
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|SUSPENDED
comma
op_amp
id|fsg-&gt;atomic_bitflags
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|variable|fsg_driver
r_static
r_struct
id|usb_gadget_driver
id|fsg_driver
op_assign
(brace
macro_line|#ifdef CONFIG_USB_GADGET_DUALSPEED
dot
id|speed
op_assign
id|USB_SPEED_HIGH
comma
macro_line|#else
dot
id|speed
op_assign
id|USB_SPEED_FULL
comma
macro_line|#endif
dot
id|function
op_assign
(paren
r_char
op_star
)paren
id|longname
comma
dot
id|bind
op_assign
id|fsg_bind
comma
dot
id|unbind
op_assign
id|fsg_unbind
comma
dot
id|disconnect
op_assign
id|fsg_disconnect
comma
dot
id|setup
op_assign
id|fsg_setup
comma
dot
id|suspend
op_assign
id|fsg_suspend
comma
dot
id|resume
op_assign
id|fsg_resume
comma
dot
id|driver
op_assign
(brace
dot
id|name
op_assign
(paren
r_char
op_star
)paren
id|shortname
comma
singleline_comment|// .release = ...
singleline_comment|// .suspend = ...
singleline_comment|// .resume = ...
)brace
comma
)brace
suffix:semicolon
DECL|function|fsg_alloc
r_static
r_int
id|__init
id|fsg_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
suffix:semicolon
id|fsg
op_assign
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|fsg
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fsg
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|fsg
comma
l_int|0
comma
r_sizeof
op_star
id|fsg
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|fsg-&gt;lock
)paren
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|fsg-&gt;filesem
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|fsg-&gt;thread_wqh
)paren
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|fsg-&gt;thread_notifier
)paren
suffix:semicolon
id|the_fsg
op_assign
id|fsg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fsg_free
r_static
r_void
id|fsg_free
c_func
(paren
r_struct
id|fsg_dev
op_star
id|fsg
)paren
(brace
id|kfree
c_func
(paren
id|fsg-&gt;luns
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
DECL|function|fsg_init
r_static
r_int
id|__init
id|fsg_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|fsg_dev
op_star
id|fsg
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|fsg_alloc
c_func
(paren
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|fsg
op_assign
id|the_fsg
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|usb_gadget_register_driver
c_func
(paren
op_amp
id|fsg_driver
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|fsg_free
c_func
(paren
id|fsg
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|REGISTERED
comma
op_amp
id|fsg-&gt;atomic_bitflags
)paren
suffix:semicolon
multiline_comment|/* Tell the thread to start working */
id|complete
c_func
(paren
op_amp
id|fsg-&gt;thread_notifier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|fsg_init
id|module_init
c_func
(paren
id|fsg_init
)paren
suffix:semicolon
DECL|function|fsg_cleanup
r_static
r_void
id|__exit
id|fsg_cleanup
c_func
(paren
r_void
)paren
(brace
r_struct
id|fsg_dev
op_star
id|fsg
op_assign
id|the_fsg
suffix:semicolon
multiline_comment|/* Unregister the driver iff the thread hasn&squot;t already done so */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|REGISTERED
comma
op_amp
id|fsg-&gt;atomic_bitflags
)paren
)paren
id|usb_gadget_unregister_driver
c_func
(paren
op_amp
id|fsg_driver
)paren
suffix:semicolon
multiline_comment|/* Wait for the thread to finish up */
id|wait_for_completion
c_func
(paren
op_amp
id|fsg-&gt;thread_notifier
)paren
suffix:semicolon
id|close_all_backing_files
c_func
(paren
id|fsg
)paren
suffix:semicolon
id|fsg_free
c_func
(paren
id|fsg
)paren
suffix:semicolon
)brace
DECL|variable|fsg_cleanup
id|module_exit
c_func
(paren
id|fsg_cleanup
)paren
suffix:semicolon
eof
