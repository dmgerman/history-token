multiline_comment|/*&n; * epautoconf.c -- endpoint autoconfiguration for usb gadget drivers&n; *&n; * Copyright (C) 2004 David Brownell&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/usb_ch9.h&gt;
macro_line|#include &lt;linux/usb_gadget.h&gt;
macro_line|#include &quot;gadget_chips.h&quot;
multiline_comment|/* we must assign addresses for configurable endpoints (like net2280) */
DECL|variable|epnum
r_static
id|__initdata
r_int
id|epnum
suffix:semicolon
singleline_comment|// #define MANY_ENDPOINTS
macro_line|#ifdef MANY_ENDPOINTS
multiline_comment|/* more than 15 configurable endpoints */
DECL|variable|in_epnum
r_static
id|__initdata
r_int
id|in_epnum
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * This should work with endpoints from controller drivers sharing the&n; * same endpoint naming convention.  By example:&n; *&n; *&t;- ep1, ep2, ... address is fixed, not direction or type&n; *&t;- ep1in, ep2out, ... address and direction are fixed, not type&n; *&t;- ep1-bulk, ep2-bulk, ... address and type are fixed, not direction&n; *&t;- ep1in-bulk, ep2out-iso, ... all three are fixed&n; *&t;- ep-* ... no functionality restrictions&n; *&n; * Type suffixes are &quot;-bulk&quot;, &quot;-iso&quot;, or &quot;-int&quot;.  Numbers are decimal.&n; * Less common restrictions are implied by gadget_is_*().&n; *&n; * NOTE:  each endpoint is unidirectional, as specified by its USB&n; * descriptor; and isn&squot;t specific to a configuration or altsetting.&n; */
r_static
r_int
id|__init
DECL|function|ep_matches
id|ep_matches
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_endpoint_descriptor
op_star
id|desc
)paren
(brace
id|u8
id|type
suffix:semicolon
r_const
r_char
op_star
id|tmp
suffix:semicolon
id|u16
id|max
suffix:semicolon
multiline_comment|/* endpoint already claimed? */
r_if
c_cond
(paren
l_int|0
op_ne
id|ep-&gt;driver_data
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* only support ep0 for portable CONTROL traffic */
id|type
op_assign
id|desc-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|USB_ENDPOINT_XFER_CONTROL
op_eq
id|type
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* some other naming convention */
r_if
c_cond
(paren
l_char|&squot;e&squot;
op_ne
id|ep-&gt;name
(braket
l_int|0
)braket
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* type-restriction:  &quot;-iso&quot;, &quot;-bulk&quot;, or &quot;-int&quot;.&n;&t; * direction-restriction:  &quot;in&quot;, &quot;out&quot;.&n;&t; */
r_if
c_cond
(paren
l_char|&squot;-&squot;
op_ne
id|ep-&gt;name
(braket
l_int|2
)braket
)paren
(brace
id|tmp
op_assign
id|strrchr
(paren
id|ep-&gt;name
comma
l_char|&squot;-&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|USB_ENDPOINT_XFER_INT
suffix:colon
multiline_comment|/* bulk endpoints handle interrupt transfers,&n;&t;&t;&t;&t; * except the toggle-quirky iso-synch kind&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
l_char|&squot;s&squot;
op_eq
id|tmp
(braket
l_int|2
)braket
)paren
singleline_comment|// == &quot;-iso&quot;
r_return
l_int|0
suffix:semicolon
multiline_comment|/* for now, avoid PXA &quot;interrupt-in&quot;;&n;&t;&t;&t;&t; * it&squot;s documented as never using DATA1.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|gadget_is_pxa
(paren
id|gadget
)paren
op_logical_and
l_char|&squot;i&squot;
op_eq
id|tmp
(braket
l_int|1
)braket
)paren
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_ENDPOINT_XFER_BULK
suffix:colon
r_if
c_cond
(paren
l_char|&squot;b&squot;
op_ne
id|tmp
(braket
l_int|1
)braket
)paren
singleline_comment|// != &quot;-bulk&quot;
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_ENDPOINT_XFER_ISOC
suffix:colon
r_if
c_cond
(paren
l_char|&squot;s&squot;
op_ne
id|tmp
(braket
l_int|2
)braket
)paren
singleline_comment|// != &quot;-iso&quot;
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|tmp
op_assign
id|ep-&gt;name
op_plus
id|strlen
(paren
id|ep-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* direction-restriction:  &quot;..in-..&quot;, &quot;out-..&quot; */
id|tmp
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isdigit
(paren
op_star
id|tmp
)paren
)paren
(brace
r_if
c_cond
(paren
id|desc-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
(brace
r_if
c_cond
(paren
l_char|&squot;n&squot;
op_ne
op_star
id|tmp
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
l_char|&squot;t&squot;
op_ne
op_star
id|tmp
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* endpoint maxpacket size is an input parameter, except for bulk&n;&t; * where it&squot;s an output parameter representing the full speed limit.&n;&t; * the usb spec fixes high speed bulk maxpacket at 512 bytes.&n;&t; */
id|max
op_assign
l_int|0x7ff
op_amp
id|le16_to_cpup
(paren
op_amp
id|desc-&gt;wMaxPacketSize
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|USB_ENDPOINT_XFER_INT
suffix:colon
multiline_comment|/* INT:  limit 64 bytes full speed, 1024 high speed */
r_if
c_cond
(paren
op_logical_neg
id|gadget-&gt;is_dualspeed
op_logical_and
id|max
OG
l_int|64
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|USB_ENDPOINT_XFER_ISOC
suffix:colon
multiline_comment|/* ISO:  limit 1023 bytes full speed, 1024 high speed */
r_if
c_cond
(paren
id|ep-&gt;maxpacket
OL
id|max
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gadget-&gt;is_dualspeed
op_logical_and
id|max
OG
l_int|1023
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* BOTH:  &quot;high bandwidth&quot; works only at high speed */
r_if
c_cond
(paren
(paren
id|desc-&gt;wMaxPacketSize
op_amp
id|__constant_cpu_to_le16
c_func
(paren
l_int|3
op_lshift
l_int|11
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|gadget-&gt;is_dualspeed
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* configure your hardware with enough buffering!! */
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* MATCH!! */
multiline_comment|/* report address */
r_if
c_cond
(paren
id|isdigit
(paren
id|ep-&gt;name
(braket
l_int|2
)braket
)paren
)paren
(brace
id|u8
id|num
op_assign
id|simple_strtol
(paren
op_amp
id|ep-&gt;name
(braket
l_int|2
)braket
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
id|desc-&gt;bEndpointAddress
op_or_assign
id|num
suffix:semicolon
macro_line|#ifdef&t;MANY_ENDPOINTS
)brace
r_else
r_if
c_cond
(paren
id|desc-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
(brace
r_if
c_cond
(paren
op_increment
id|in_epnum
OG
l_int|15
)paren
r_return
l_int|0
suffix:semicolon
id|desc-&gt;bEndpointAddress
op_assign
id|USB_DIR_IN
op_or
id|in_epnum
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
op_increment
id|epnum
OG
l_int|15
)paren
r_return
l_int|0
suffix:semicolon
id|desc-&gt;bEndpointAddress
op_or_assign
id|epnum
suffix:semicolon
)brace
multiline_comment|/* report (variable) full speed bulk maxpacket */
r_if
c_cond
(paren
id|USB_ENDPOINT_XFER_BULK
op_eq
id|type
)paren
(brace
r_int
id|size
op_assign
id|ep-&gt;maxpacket
suffix:semicolon
multiline_comment|/* min() doesn&squot;t work on bitfields with gcc-3.5 */
r_if
c_cond
(paren
id|size
OG
l_int|64
)paren
id|size
op_assign
l_int|64
suffix:semicolon
id|desc-&gt;wMaxPacketSize
op_assign
id|cpu_to_le16
c_func
(paren
id|size
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_struct
id|usb_ep
op_star
id|__init
DECL|function|find_ep
id|find_ep
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
id|list_for_each_entry
(paren
id|ep
comma
op_amp
id|gadget-&gt;ep_list
comma
id|ep_list
)paren
(brace
r_if
c_cond
(paren
l_int|0
op_eq
id|strcmp
(paren
id|ep-&gt;name
comma
id|name
)paren
)paren
r_return
id|ep
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_ep_autoconfig - choose an endpoint matching the descriptor&n; * @gadget: The device to which the endpoint must belong.&n; * @desc: Endpoint descriptor, with endpoint direction and transfer mode&n; *&t;initialized.  For periodic transfers, the maximum packet&n; *&t;size must also be initialized.  This is modified on success.&n; *&n; * By choosing an endpoint to use with the specified descriptor, this&n; * routine simplifies writing gadget drivers that work with multiple&n; * USB device controllers.  The endpoint would be passed later to&n; * usb_ep_enable(), along with some descriptor.&n; *&n; * That second descriptor won&squot;t always be the same as the first one.&n; * For example, isochronous endpoints can be autoconfigured for high&n; * bandwidth, and then used in several lower bandwidth altsettings.&n; * Also, high and full speed descriptors will be different.&n; *&n; * Be sure to examine and test the results of autoconfiguration on your&n; * hardware.  This code may not make the best choices about how to use the&n; * USB controller, and it can&squot;t know all the restrictions that may apply.&n; * Some combinations of driver and hardware won&squot;t be able to autoconfigure.&n; *&n; * On success, this returns an un-claimed usb_ep, and modifies the endpoint&n; * descriptor bEndpointAddress.  For bulk endpoints, the wMaxPacket value&n; * is initialized as if the endpoint were used at full speed.  To prevent&n; * the endpoint from being returned by a later autoconfig call, claim it&n; * by assigning ep-&gt;driver_data to some non-null value.&n; *&n; * On failure, this returns a null endpoint descriptor.&n; */
DECL|function|usb_ep_autoconfig
r_struct
id|usb_ep
op_star
id|__init
id|usb_ep_autoconfig
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
r_struct
id|usb_endpoint_descriptor
op_star
id|desc
)paren
(brace
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
id|u8
id|type
suffix:semicolon
id|type
op_assign
id|desc-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
suffix:semicolon
multiline_comment|/* First, apply chip-specific &quot;best usage&quot; knowledge.&n;&t; * This might make a good usb_gadget_ops hook ...&n;&t; */
r_if
c_cond
(paren
id|gadget_is_net2280
(paren
id|gadget
)paren
op_logical_and
id|type
op_eq
id|USB_ENDPOINT_XFER_INT
)paren
(brace
multiline_comment|/* ep-e, ep-f are PIO with only 64 byte fifos */
id|ep
op_assign
id|find_ep
(paren
id|gadget
comma
l_string|&quot;ep-e&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_logical_and
id|ep_matches
(paren
id|gadget
comma
id|ep
comma
id|desc
)paren
)paren
r_return
id|ep
suffix:semicolon
id|ep
op_assign
id|find_ep
(paren
id|gadget
comma
l_string|&quot;ep-f&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_logical_and
id|ep_matches
(paren
id|gadget
comma
id|ep
comma
id|desc
)paren
)paren
r_return
id|ep
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|gadget_is_goku
(paren
id|gadget
)paren
)paren
(brace
r_if
c_cond
(paren
id|USB_ENDPOINT_XFER_INT
op_eq
id|type
)paren
(brace
multiline_comment|/* single buffering is enough */
id|ep
op_assign
id|find_ep
(paren
id|gadget
comma
l_string|&quot;ep3-bulk&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_logical_and
id|ep_matches
(paren
id|gadget
comma
id|ep
comma
id|desc
)paren
)paren
r_return
id|ep
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|USB_ENDPOINT_XFER_BULK
op_eq
id|type
op_logical_and
(paren
id|USB_DIR_IN
op_amp
id|desc-&gt;bEndpointAddress
)paren
)paren
(brace
multiline_comment|/* DMA may be available */
id|ep
op_assign
id|find_ep
(paren
id|gadget
comma
l_string|&quot;ep2-bulk&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_logical_and
id|ep_matches
(paren
id|gadget
comma
id|ep
comma
id|desc
)paren
)paren
r_return
id|ep
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|gadget_is_sh
(paren
id|gadget
)paren
op_logical_and
id|USB_ENDPOINT_XFER_INT
op_eq
id|type
)paren
(brace
multiline_comment|/* single buffering is enough; maybe 8 byte fifo is too */
id|ep
op_assign
id|find_ep
(paren
id|gadget
comma
l_string|&quot;ep3in-bulk&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_logical_and
id|ep_matches
(paren
id|gadget
comma
id|ep
comma
id|desc
)paren
)paren
r_return
id|ep
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|gadget_is_mq11xx
(paren
id|gadget
)paren
op_logical_and
id|USB_ENDPOINT_XFER_INT
op_eq
id|type
)paren
(brace
id|ep
op_assign
id|find_ep
(paren
id|gadget
comma
l_string|&quot;ep1-bulk&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_logical_and
id|ep_matches
(paren
id|gadget
comma
id|ep
comma
id|desc
)paren
)paren
r_return
id|ep
suffix:semicolon
)brace
multiline_comment|/* Second, look at endpoints until an unclaimed one looks usable */
id|list_for_each_entry
(paren
id|ep
comma
op_amp
id|gadget-&gt;ep_list
comma
id|ep_list
)paren
(brace
r_if
c_cond
(paren
id|ep_matches
(paren
id|gadget
comma
id|ep
comma
id|desc
)paren
)paren
r_return
id|ep
suffix:semicolon
)brace
multiline_comment|/* Fail */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_ep_autoconfig_reset - reset endpoint autoconfig state&n; * @gadget: device for which autoconfig state will be reset&n; *&n; * Use this for devices where one configuration may need to assign&n; * endpoint resources very differently from the next one.  It clears&n; * state such as ep-&gt;driver_data and the record of assigned endpoints&n; * used by usb_ep_autoconfig().&n; */
DECL|function|usb_ep_autoconfig_reset
r_void
id|__init
id|usb_ep_autoconfig_reset
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
id|list_for_each_entry
(paren
id|ep
comma
op_amp
id|gadget-&gt;ep_list
comma
id|ep_list
)paren
(brace
id|ep-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef&t;MANY_ENDPOINTS
id|in_epnum
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|epnum
op_assign
l_int|0
suffix:semicolon
)brace
eof
