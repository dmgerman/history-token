multiline_comment|/*&n; * zero.c -- Gadget Zero, for USB development&n; *&n; * Copyright (C) 2003 David Brownell&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. The names of the above-listed copyright holders may not be used&n; *    to endorse or promote products derived from this software without&n; *    specific prior written permission.&n; *&n; * ALTERNATIVELY, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;) as published by the Free Software&n; * Foundation, either version 2 of that License or (at your option) any&n; * later version.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS&n; * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,&n; * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR&n; * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR&n; * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,&n; * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,&n; * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR&n; * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF&n; * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING&n; * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS&n; * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; */
multiline_comment|/*&n; * Gadget Zero only needs two bulk endpoints, and is an example of how you&n; * can write a hardware-agnostic gadget driver running inside a USB device.&n; *&n; * Hardware details are visible (see CONFIG_USB_ZERO_* below) but don&squot;t&n; * affect most of the driver.&n; *&n; * Use it with the Linux host/master side &quot;usbtest&quot; driver to get a basic&n; * functional test of your device-side usb stack, or with &quot;usb-skeleton&quot;.&n; *&n; * It supports two similar configurations.  One sinks whatever the usb host&n; * writes, and in return sources zeroes.  The other loops whatever the host&n; * writes back, so the host can read it.  Module options include:&n; *&n; *   buflen=N&t;&t;default N=4096, buffer size used&n; *   qlen=N&t;&t;default N=32, how many buffers in the loopback queue&n; *   loopdefault&t;default false, list loopback config first&n; *&n; * Many drivers will only have one configuration, letting them be much&n; * simpler if they also don&squot;t support high speed operation (like this&n; * driver does).&n; */
DECL|macro|DEBUG
mdefine_line|#define DEBUG 1
singleline_comment|// #define VERBOSE
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/uts.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;linux/usb_ch9.h&gt;
macro_line|#include &lt;linux/usb_gadget.h&gt;
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION&t;&t;&quot;19 Feb 2003&quot;
DECL|variable|shortname
r_static
r_const
r_char
id|shortname
(braket
)braket
op_assign
l_string|&quot;zero&quot;
suffix:semicolon
DECL|variable|longname
r_static
r_const
r_char
id|longname
(braket
)braket
op_assign
l_string|&quot;Gadget Zero&quot;
suffix:semicolon
DECL|variable|source_sink
r_static
r_const
r_char
id|source_sink
(braket
)braket
op_assign
l_string|&quot;source and sink data&quot;
suffix:semicolon
DECL|variable|loopback
r_static
r_const
r_char
id|loopback
(braket
)braket
op_assign
l_string|&quot;loop input to output&quot;
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * hardware-specific configuration, controlled by which device&n; * controller driver was configured.&n; *&n; * CHIP ... hardware identifier&n; * DRIVER_VERSION_NUM ... alerts the host side driver to differences&n; * EP0_MAXPACKET ... controls packetization of control requests&n; * EP_*_NAME ... which endpoints do we use for which purpose?&n; * EP_*_NUM ... numbers for them (often limited by hardware)&n; * HIGHSPEED ... define if ep0 and descriptors need high speed support&n; * MAX_USB_POWER ... define if we use other than 100 mA bus current&n; * SELFPOWER ... unless we can run on bus power, USB_CONFIG_ATT_SELFPOWER&n; * WAKEUP ... if hardware supports remote wakeup AND we will issue the&n; * &t;usb_gadget_wakeup() call to initiate it, USB_CONFIG_ATT_WAKEUP&n; *&n; * hw_optimize(gadget) ... for any hardware tweaks we want to kick in&n; * &t;before we enable our endpoints&n; *&n; * add other defines for other portability issues, like hardware that&n; * for some reason doesn&squot;t handle full speed bulk maxpacket of 64.&n; */
multiline_comment|/*&n; * DRIVER_VERSION_NUM 0x0000 (?):  Martin Diehl&squot;s ezusb an21/fx code&n; */
multiline_comment|/*&n; * NetChip 2280, PCI based.&n; *&n; * This has half a dozen configurable endpoints, four with dedicated&n; * DMA channels to manage their FIFOs.  It supports high speed.&n; * Those endpoints can be arranged in any desired configuration.&n; */
macro_line|#ifdef&t;CONFIG_USB_ZERO_NET2280
DECL|macro|CHIP
mdefine_line|#define CHIP&t;&t;&t;&quot;net2280&quot;
DECL|macro|DRIVER_VERSION_NUM
mdefine_line|#define DRIVER_VERSION_NUM&t;0x0101
DECL|macro|EP0_MAXPACKET
mdefine_line|#define EP0_MAXPACKET&t;&t;64
DECL|variable|EP_OUT_NAME
r_static
r_const
r_char
id|EP_OUT_NAME
(braket
)braket
op_assign
l_string|&quot;ep-a&quot;
suffix:semicolon
DECL|macro|EP_OUT_NUM
mdefine_line|#define EP_OUT_NUM&t;2
DECL|variable|EP_IN_NAME
r_static
r_const
r_char
id|EP_IN_NAME
(braket
)braket
op_assign
l_string|&quot;ep-b&quot;
suffix:semicolon
DECL|macro|EP_IN_NUM
mdefine_line|#define EP_IN_NUM&t;2
DECL|macro|HIGHSPEED
mdefine_line|#define HIGHSPEED
multiline_comment|/* specific hardware configs could be bus-powered */
DECL|macro|SELFPOWER
mdefine_line|#define SELFPOWER USB_CONFIG_ATT_SELFPOWER
multiline_comment|/* supports remote wakeup, but this driver doesn&squot;t */
r_extern
r_int
id|net2280_set_fifo_mode
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
r_int
id|mode
)paren
suffix:semicolon
DECL|function|hw_optimize
r_static
r_inline
r_void
id|hw_optimize
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
multiline_comment|/* we can have bigger ep-a/ep-b fifos (2KB each, 4 packets&n;&t; * for highspeed bulk) because we&squot;re not using ep-c/ep-d.&n;&t; */
id|net2280_set_fifo_mode
(paren
id|gadget
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * PXA-250 UDC:  widely used in second gen Linux-capable PDAs.&n; *&n; * This has fifteen fixed-function full speed endpoints, and it&n; * can support all USB transfer types.&n; *&n; * It only supports three configurations (numbered 1, 2, or 3)&n; * with two interfaces each ... there&squot;s partial hardware support&n; * for set_configuration and set_interface, preventing some more&n; * interesting config/interface/endpoint arrangements.&n; */
macro_line|#ifdef&t;CONFIG_USB_ZERO_PXA250
DECL|macro|CHIP
mdefine_line|#define CHIP&t;&t;&t;&quot;pxa250&quot;
DECL|macro|DRIVER_VERSION_NUM
mdefine_line|#define DRIVER_VERSION_NUM&t;0x0103
DECL|macro|EP0_MAXPACKET
mdefine_line|#define EP0_MAXPACKET&t;&t;16
DECL|variable|EP_OUT_NAME
r_static
r_const
r_char
id|EP_OUT_NAME
(braket
)braket
op_assign
l_string|&quot;ep12out-bulk&quot;
suffix:semicolon
DECL|macro|EP_OUT_NUM
mdefine_line|#define EP_OUT_NUM&t;12
DECL|variable|EP_IN_NAME
r_static
r_const
r_char
id|EP_IN_NAME
(braket
)braket
op_assign
l_string|&quot;ep11in-bulk&quot;
suffix:semicolon
DECL|macro|EP_IN_NUM
mdefine_line|#define EP_IN_NUM&t;11
multiline_comment|/* doesn&squot;t support bus-powered operation */
DECL|macro|SELFPOWER
mdefine_line|#define SELFPOWER USB_CONFIG_ATT_SELFPOWER
multiline_comment|/* supports remote wakeup, but this driver doesn&squot;t */
multiline_comment|/* no hw optimizations to apply */
DECL|macro|hw_optimize
mdefine_line|#define hw_optimize(g) do {} while (0);
macro_line|#endif
multiline_comment|/*&n; * SA-1100 UDC:  widely used in first gen Linux-capable PDAs.&n; *&n; * This has only two fixed function endpoints, which can only&n; * be used for bulk (or interrupt) transfers.  (Plus control.)&n; *&n; * Since it can&squot;t flush its TX fifos without disabling the UDC,&n; * the current configuration or altsettings can&squot;t change except&n; * in special situations.  So this is a case of &quot;choose it right&n; * during enumeration&quot; ...&n; */
macro_line|#ifdef&t;CONFIG_USB_ZERO_SA1100
DECL|macro|CHIP
mdefine_line|#define CHIP&t;&t;&t;&quot;sa1100&quot;
DECL|macro|DRIVER_VERSION_NUM
mdefine_line|#define DRIVER_VERSION_NUM&t;0x0105
DECL|macro|EP0_MAXPACKET
mdefine_line|#define EP0_MAXPACKET&t;&t;8
DECL|variable|EP_OUT_NAME
r_static
r_const
r_char
id|EP_OUT_NAME
(braket
)braket
op_assign
l_string|&quot;ep1out-bulk&quot;
suffix:semicolon
DECL|macro|EP_OUT_NUM
mdefine_line|#define EP_OUT_NUM&t;1
DECL|variable|EP_IN_NAME
r_static
r_const
r_char
id|EP_IN_NAME
(braket
)braket
op_assign
l_string|&quot;ep2in-bulk&quot;
suffix:semicolon
DECL|macro|EP_IN_NUM
mdefine_line|#define EP_IN_NUM&t;2
multiline_comment|/* doesn&squot;t support bus-powered operation */
DECL|macro|SELFPOWER
mdefine_line|#define SELFPOWER USB_CONFIG_ATT_SELFPOWER
multiline_comment|/* doesn&squot;t support remote wakeup? */
multiline_comment|/* no hw optimizations to apply */
DECL|macro|hw_optimize
mdefine_line|#define hw_optimize(g) do {} while (0);
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#ifndef EP0_MAXPACKET
macro_line|#&t;error Configure some USB peripheral controller driver!
macro_line|#endif
multiline_comment|/* power usage is config specific.&n; * hardware that supports remote wakeup defaults to disabling it.&n; */
macro_line|#ifndef&t;SELFPOWER
multiline_comment|/* default: say we rely on bus power */
DECL|macro|SELFPOWER
mdefine_line|#define SELFPOWER&t;0
multiline_comment|/* else:&n; * - SELFPOWER value must be USB_CONFIG_ATT_SELFPOWER&n; * - MAX_USB_POWER may be nonzero.&n; */
macro_line|#endif
macro_line|#ifndef&t;MAX_USB_POWER
multiline_comment|/* any hub supports this steady state bus power consumption */
DECL|macro|MAX_USB_POWER
mdefine_line|#define MAX_USB_POWER&t;100&t;/* mA */
macro_line|#endif
macro_line|#ifndef&t;WAKEUP
multiline_comment|/* default: this driver won&squot;t do remote wakeup */
DECL|macro|WAKEUP
mdefine_line|#define WAKEUP&t;&t;0
multiline_comment|/* else value must be USB_CONFIG_ATT_WAKEUP */
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* big enough to hold our biggest descriptor */
DECL|macro|USB_BUFSIZ
mdefine_line|#define USB_BUFSIZ&t;256
DECL|struct|zero_dev
r_struct
id|zero_dev
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|gadget
r_struct
id|usb_gadget
op_star
id|gadget
suffix:semicolon
DECL|member|req
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
multiline_comment|/* for control responses */
multiline_comment|/* when configured, we have one of two configs:&n;&t; * - source data (in to host) and sink it (out from host)&n;&t; * - or loop it back (out from host back in to host)&n;&t; */
DECL|member|config
id|u8
id|config
suffix:semicolon
DECL|member|in_ep
DECL|member|out_ep
r_struct
id|usb_ep
op_star
id|in_ep
comma
op_star
id|out_ep
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|xprintk
mdefine_line|#define xprintk(d,level,fmt,args...) &bslash;&n;&t;dev_printk(level , &amp;(d)-&gt;gadget-&gt;dev , fmt , ## args)
macro_line|#ifdef DEBUG
DECL|macro|DEBUG
macro_line|#undef DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_DEBUG , fmt , ## args)
macro_line|#else
DECL|macro|DEBUG
mdefine_line|#define DEBUG(dev,fmt,args...) &bslash;&n;&t;do { } while (0)
macro_line|#endif /* DEBUG */
macro_line|#ifdef VERBOSE
DECL|macro|VDEBUG
mdefine_line|#define VDEBUG&t;DEBUG
macro_line|#else
DECL|macro|VDEBUG
mdefine_line|#define VDEBUG(dev,fmt,args...) &bslash;&n;&t;do { } while (0)
macro_line|#endif /* DEBUG */
DECL|macro|ERROR
mdefine_line|#define ERROR(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_ERR , fmt , ## args)
DECL|macro|WARN
mdefine_line|#define WARN(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_WARNING , fmt , ## args)
DECL|macro|INFO
mdefine_line|#define INFO(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_INFO , fmt , ## args)
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|variable|buflen
r_static
r_int
id|buflen
op_assign
l_int|4096
suffix:semicolon
DECL|variable|qlen
r_static
r_int
id|qlen
op_assign
l_int|32
suffix:semicolon
id|module_param
(paren
id|buflen
comma
id|uint
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
id|module_param
(paren
id|qlen
comma
id|uint
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
multiline_comment|/*&n; * Normally the &quot;loopback&quot; configuration is second (index 1) so&n; * it&squot;s not the default.  Here&squot;s where to change that order, to&n; * work better with hosts (like Linux ... for now!) where config&n; * changes are problematic.&n; */
DECL|variable|loopdefault
r_static
r_int
id|loopdefault
op_assign
l_int|0
suffix:semicolon
id|module_param
(paren
id|loopdefault
comma
r_bool
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Thanks to NetChip Technologies for donating this product ID.&n; *&n; * DO NOT REUSE THESE IDs with any other driver!!  Ever!!&n; * Instead:  allocate your own, using normal USB-IF procedures.&n; */
DECL|macro|DRIVER_VENDOR_NUM
mdefine_line|#define DRIVER_VENDOR_NUM&t;0x0525&t;&t;/* NetChip */
DECL|macro|DRIVER_PRODUCT_NUM
mdefine_line|#define DRIVER_PRODUCT_NUM&t;0xa4a0&t;&t;/* Linux-USB &quot;Gadget Zero&quot; */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * DESCRIPTORS ... most are static, but strings and (full)&n; * configuration descriptors are built on demand.&n; */
DECL|macro|STRING_MANUFACTURER
mdefine_line|#define STRING_MANUFACTURER&t;&t;25
DECL|macro|STRING_PRODUCT
mdefine_line|#define STRING_PRODUCT&t;&t;&t;42
DECL|macro|STRING_SERIAL
mdefine_line|#define STRING_SERIAL&t;&t;&t;101
DECL|macro|STRING_SOURCE_SINK
mdefine_line|#define STRING_SOURCE_SINK&t;&t;250
DECL|macro|STRING_LOOPBACK
mdefine_line|#define STRING_LOOPBACK&t;&t;&t;251
multiline_comment|/*&n; * This device advertises two configurations; these numbers work&n; * on a pxa250 as well as more flexible hardware.&n; */
DECL|macro|CONFIG_SOURCE_SINK
mdefine_line|#define&t;CONFIG_SOURCE_SINK&t;3
DECL|macro|CONFIG_LOOPBACK
mdefine_line|#define&t;CONFIG_LOOPBACK&t;&t;2
r_static
r_const
r_struct
id|usb_device_descriptor
DECL|variable|device_desc
id|device_desc
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|device_desc
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_DEVICE
comma
dot
id|bcdUSB
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0200
)paren
comma
dot
id|bDeviceClass
op_assign
id|USB_CLASS_VENDOR_SPEC
comma
dot
id|bMaxPacketSize0
op_assign
id|EP0_MAXPACKET
comma
dot
id|idVendor
op_assign
id|__constant_cpu_to_le16
(paren
id|DRIVER_VENDOR_NUM
)paren
comma
dot
id|idProduct
op_assign
id|__constant_cpu_to_le16
(paren
id|DRIVER_PRODUCT_NUM
)paren
comma
dot
id|bcdDevice
op_assign
id|__constant_cpu_to_le16
(paren
id|DRIVER_VERSION_NUM
)paren
comma
dot
id|iManufacturer
op_assign
id|STRING_MANUFACTURER
comma
dot
id|iProduct
op_assign
id|STRING_PRODUCT
comma
dot
id|iSerialNumber
op_assign
id|STRING_SERIAL
comma
dot
id|bNumConfigurations
op_assign
l_int|2
comma
)brace
suffix:semicolon
r_static
r_const
r_struct
id|usb_config_descriptor
DECL|variable|source_sink_config
id|source_sink_config
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|source_sink_config
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_CONFIG
comma
multiline_comment|/* compute wTotalLength on the fly */
dot
id|bNumInterfaces
op_assign
l_int|1
comma
dot
id|bConfigurationValue
op_assign
id|CONFIG_SOURCE_SINK
comma
dot
id|iConfiguration
op_assign
id|STRING_SOURCE_SINK
comma
dot
id|bmAttributes
op_assign
id|USB_CONFIG_ATT_ONE
op_or
id|SELFPOWER
op_or
id|WAKEUP
comma
dot
id|bMaxPower
op_assign
(paren
id|MAX_USB_POWER
op_plus
l_int|1
)paren
op_div
l_int|2
comma
)brace
suffix:semicolon
r_static
r_const
r_struct
id|usb_config_descriptor
DECL|variable|loopback_config
id|loopback_config
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|loopback_config
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_CONFIG
comma
multiline_comment|/* compute wTotalLength on the fly */
dot
id|bNumInterfaces
op_assign
l_int|1
comma
dot
id|bConfigurationValue
op_assign
id|CONFIG_LOOPBACK
comma
dot
id|iConfiguration
op_assign
id|STRING_LOOPBACK
comma
dot
id|bmAttributes
op_assign
id|USB_CONFIG_ATT_ONE
op_or
id|SELFPOWER
op_or
id|WAKEUP
comma
dot
id|bMaxPower
op_assign
(paren
id|MAX_USB_POWER
op_plus
l_int|1
)paren
op_div
l_int|2
comma
)brace
suffix:semicolon
multiline_comment|/* one interface in each configuration */
r_static
r_const
r_struct
id|usb_interface_descriptor
DECL|variable|source_sink_intf
id|source_sink_intf
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|source_sink_intf
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_INTERFACE
comma
dot
id|bNumEndpoints
op_assign
l_int|2
comma
dot
id|bInterfaceClass
op_assign
id|USB_CLASS_VENDOR_SPEC
comma
dot
id|iInterface
op_assign
id|STRING_SOURCE_SINK
comma
)brace
suffix:semicolon
r_static
r_const
r_struct
id|usb_interface_descriptor
DECL|variable|loopback_intf
id|loopback_intf
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|loopback_intf
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_INTERFACE
comma
dot
id|bNumEndpoints
op_assign
l_int|2
comma
dot
id|bInterfaceClass
op_assign
id|USB_CLASS_VENDOR_SPEC
comma
dot
id|iInterface
op_assign
id|STRING_LOOPBACK
comma
)brace
suffix:semicolon
multiline_comment|/* two full speed bulk endpoints; their use is config-dependent */
r_static
r_const
r_struct
id|usb_endpoint_descriptor
DECL|variable|fs_source_desc
id|fs_source_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|EP_IN_NUM
op_or
id|USB_DIR_IN
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
(paren
l_int|64
)paren
comma
)brace
suffix:semicolon
r_static
r_const
r_struct
id|usb_endpoint_descriptor
DECL|variable|fs_sink_desc
id|fs_sink_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|EP_OUT_NUM
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
(paren
l_int|64
)paren
comma
)brace
suffix:semicolon
macro_line|#ifdef&t;HIGHSPEED
multiline_comment|/*&n; * usb 2.0 devices need to expose both high speed and full speed&n; * descriptors, unless they only run at full speed.&n; *&n; * that means alternate endpoint descriptors (bigger packets)&n; * and a &quot;device qualifier&quot; ... plus more construction options&n; * for the config descriptor.&n; */
r_static
r_const
r_struct
id|usb_endpoint_descriptor
DECL|variable|hs_source_desc
id|hs_source_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|EP_IN_NUM
op_or
id|USB_DIR_IN
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
(paren
l_int|512
)paren
comma
)brace
suffix:semicolon
r_static
r_const
r_struct
id|usb_endpoint_descriptor
DECL|variable|hs_sink_desc
id|hs_sink_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|EP_OUT_NUM
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
(paren
l_int|512
)paren
comma
)brace
suffix:semicolon
r_static
r_const
r_struct
id|usb_qualifier_descriptor
DECL|variable|dev_qualifier
id|dev_qualifier
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|dev_qualifier
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_DEVICE_QUALIFIER
comma
dot
id|bcdUSB
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0200
)paren
comma
dot
id|bDeviceClass
op_assign
id|USB_CLASS_VENDOR_SPEC
comma
multiline_comment|/* assumes ep0 uses the same value for both speeds ... */
dot
id|bMaxPacketSize0
op_assign
id|EP0_MAXPACKET
comma
dot
id|bNumConfigurations
op_assign
l_int|2
comma
)brace
suffix:semicolon
multiline_comment|/* maxpacket and other transfer characteristics vary by speed. */
DECL|macro|ep_desc
mdefine_line|#define ep_desc(g,hs,fs) (((g)-&gt;speed==USB_SPEED_HIGH)?(hs):(fs))
macro_line|#else
multiline_comment|/* if there&squot;s no high speed support, maxpacket doesn&squot;t change. */
DECL|macro|ep_desc
mdefine_line|#define ep_desc(g,hs,fs) fs
macro_line|#endif&t;/* !HIGHSPEED */
DECL|variable|serial
r_static
r_char
id|serial
(braket
l_int|40
)braket
suffix:semicolon
multiline_comment|/* static strings, in iso 8859/1 */
DECL|variable|strings
r_static
r_struct
id|usb_string
id|strings
(braket
)braket
op_assign
(brace
(brace
id|STRING_MANUFACTURER
comma
id|UTS_SYSNAME
l_string|&quot; &quot;
id|UTS_RELEASE
l_string|&quot; with &quot;
id|CHIP
comma
)brace
comma
(brace
id|STRING_PRODUCT
comma
id|longname
comma
)brace
comma
(brace
id|STRING_SERIAL
comma
id|serial
comma
)brace
comma
(brace
id|STRING_LOOPBACK
comma
id|loopback
comma
)brace
comma
(brace
id|STRING_SOURCE_SINK
comma
id|source_sink
comma
)brace
comma
(brace
)brace
multiline_comment|/* end of list */
)brace
suffix:semicolon
DECL|variable|stringtab
r_static
r_struct
id|usb_gadget_strings
id|stringtab
op_assign
(brace
dot
id|language
op_assign
l_int|0x0409
comma
multiline_comment|/* en-us */
dot
id|strings
op_assign
id|strings
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * config descriptors are also handcrafted.  these must agree with code&n; * that sets configurations, and with code managing interface altsettings.&n; * other complexity may come from:&n; *&n; *  - high speed support, including &quot;other speed config&quot; rules&n; *  - multiple configurations&n; *  - interfaces with alternate settings&n; *  - embedded class or vendor-specific descriptors&n; *&n; * this handles high speed, and has a second config that could as easily&n; * have been an alternate interface setting.&n; *&n; * NOTE:  to demonstrate (and test) more USB capabilities, this driver&n; * should include an altsetting to test interrupt transfers, including&n; * high bandwidth modes at high speed.  (Maybe work like Intel&squot;s test&n; * device?)&n; */
r_static
r_int
DECL|function|config_buf
id|config_buf
(paren
r_enum
id|usb_device_speed
id|speed
comma
id|u8
op_star
id|buf
comma
id|u8
id|type
comma
r_int
id|index
)paren
(brace
r_int
id|is_source_sink
suffix:semicolon
r_const
r_int
id|config_len
op_assign
id|USB_DT_CONFIG_SIZE
op_plus
id|USB_DT_INTERFACE_SIZE
op_plus
l_int|2
op_star
id|USB_DT_ENDPOINT_SIZE
suffix:semicolon
macro_line|#ifdef HIGHSPEED
r_int
id|hs
suffix:semicolon
macro_line|#endif
multiline_comment|/* two configurations will always be index 0 and index 1 */
r_if
c_cond
(paren
id|index
OG
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|config_len
OG
id|USB_BUFSIZ
)paren
r_return
op_minus
id|EDOM
suffix:semicolon
id|is_source_sink
op_assign
id|loopdefault
ques
c_cond
(paren
id|index
op_eq
l_int|1
)paren
suffix:colon
(paren
id|index
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* config (or other speed config) */
r_if
c_cond
(paren
id|is_source_sink
)paren
id|memcpy
(paren
id|buf
comma
op_amp
id|source_sink_config
comma
id|USB_DT_CONFIG_SIZE
)paren
suffix:semicolon
r_else
id|memcpy
(paren
id|buf
comma
op_amp
id|loopback_config
comma
id|USB_DT_CONFIG_SIZE
)paren
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|type
suffix:semicolon
(paren
(paren
r_struct
id|usb_config_descriptor
op_star
)paren
id|buf
)paren
op_member_access_from_pointer
id|wTotalLength
op_assign
id|__constant_cpu_to_le16
(paren
id|config_len
)paren
suffix:semicolon
id|buf
op_add_assign
id|USB_DT_CONFIG_SIZE
suffix:semicolon
multiline_comment|/* one interface */
r_if
c_cond
(paren
id|is_source_sink
)paren
id|memcpy
(paren
id|buf
comma
op_amp
id|source_sink_intf
comma
id|USB_DT_INTERFACE_SIZE
)paren
suffix:semicolon
r_else
id|memcpy
(paren
id|buf
comma
op_amp
id|loopback_intf
comma
id|USB_DT_INTERFACE_SIZE
)paren
suffix:semicolon
id|buf
op_add_assign
id|USB_DT_INTERFACE_SIZE
suffix:semicolon
multiline_comment|/* the endpoints in that interface (at that speed) */
macro_line|#ifdef HIGHSPEED
id|hs
op_assign
(paren
id|speed
op_eq
id|USB_SPEED_HIGH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|USB_DT_OTHER_SPEED_CONFIG
)paren
id|hs
op_assign
op_logical_neg
id|hs
suffix:semicolon
r_if
c_cond
(paren
id|hs
)paren
(brace
id|memcpy
(paren
id|buf
comma
op_amp
id|hs_source_desc
comma
id|USB_DT_ENDPOINT_SIZE
)paren
suffix:semicolon
id|buf
op_add_assign
id|USB_DT_ENDPOINT_SIZE
suffix:semicolon
id|memcpy
(paren
id|buf
comma
op_amp
id|hs_sink_desc
comma
id|USB_DT_ENDPOINT_SIZE
)paren
suffix:semicolon
id|buf
op_add_assign
id|USB_DT_ENDPOINT_SIZE
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|memcpy
(paren
id|buf
comma
op_amp
id|fs_source_desc
comma
id|USB_DT_ENDPOINT_SIZE
)paren
suffix:semicolon
id|buf
op_add_assign
id|USB_DT_ENDPOINT_SIZE
suffix:semicolon
id|memcpy
(paren
id|buf
comma
op_amp
id|fs_sink_desc
comma
id|USB_DT_ENDPOINT_SIZE
)paren
suffix:semicolon
id|buf
op_add_assign
id|USB_DT_ENDPOINT_SIZE
suffix:semicolon
)brace
r_return
id|config_len
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_struct
id|usb_request
op_star
DECL|function|alloc_ep_req
id|alloc_ep_req
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_int
id|length
)paren
(brace
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
id|req
op_assign
id|usb_ep_alloc_request
(paren
id|ep
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|req-&gt;length
op_assign
id|length
suffix:semicolon
id|req-&gt;buf
op_assign
id|usb_ep_alloc_buffer
(paren
id|ep
comma
id|length
comma
op_amp
id|req-&gt;dma
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;buf
)paren
(brace
id|usb_ep_free_request
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
id|req
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|req
suffix:semicolon
)brace
DECL|function|free_ep_req
r_static
r_void
id|free_ep_req
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;buf
)paren
id|usb_ep_free_buffer
(paren
id|ep
comma
id|req-&gt;buf
comma
id|req-&gt;dma
comma
id|req-&gt;length
)paren
suffix:semicolon
id|usb_ep_free_request
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* optionally require specific source/sink data patterns  */
r_static
r_inline
r_int
DECL|function|check_read_data
id|check_read_data
(paren
r_struct
id|zero_dev
op_star
id|dev
comma
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|req-&gt;actual
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|u8
op_star
)paren
id|req-&gt;buf
)paren
(braket
id|i
)braket
op_ne
l_int|0
)paren
(brace
id|ERROR
(paren
id|dev
comma
l_string|&quot;nonzero OUT byte from host, &quot;
l_string|&quot;buf [%d] = %d&bslash;n&quot;
comma
id|i
comma
(paren
(paren
id|u8
op_star
)paren
id|req-&gt;buf
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|usb_ep_set_halt
(paren
id|ep
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|reinit_write_data
id|reinit_write_data
(paren
r_struct
id|zero_dev
op_star
id|dev
comma
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
id|memset
(paren
id|req-&gt;buf
comma
l_int|0
comma
id|req-&gt;length
)paren
suffix:semicolon
)brace
multiline_comment|/* if there is only one request in the queue, there&squot;ll always be an&n; * irq delay between end of one request and start of the next.&n; * that prevents using hardware dma queues.&n; */
DECL|function|source_sink_complete
r_static
r_void
id|source_sink_complete
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|ep-&gt;driver_data
suffix:semicolon
r_int
id|status
op_assign
id|req-&gt;status
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* normal completion? */
r_if
c_cond
(paren
id|ep
op_eq
id|dev-&gt;out_ep
)paren
id|check_read_data
(paren
id|dev
comma
id|ep
comma
id|req
)paren
suffix:semicolon
r_else
id|reinit_write_data
(paren
id|dev
comma
id|ep
comma
id|req
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* this endpoint is normally active while we&squot;re configured */
r_case
op_minus
id|ECONNRESET
suffix:colon
multiline_comment|/* request dequeued */
r_case
op_minus
id|ESHUTDOWN
suffix:colon
multiline_comment|/* disconnect from host */
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;%s gone (%d), %d/%d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|status
comma
id|req-&gt;actual
comma
id|req-&gt;length
)paren
suffix:semicolon
id|free_ep_req
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
op_minus
id|EOVERFLOW
suffix:colon
multiline_comment|/* buffer overrun on read means that&n;&t;&t;&t;&t;&t; * we didn&squot;t provide a big enough&n;&t;&t;&t;&t;&t; * buffer.&n;&t;&t;&t;&t;&t; */
r_default
suffix:colon
macro_line|#if 1
id|DEBUG
(paren
id|dev
comma
l_string|&quot;%s complete --&gt; %d, %d/%d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|status
comma
id|req-&gt;actual
comma
id|req-&gt;length
)paren
suffix:semicolon
macro_line|#endif
r_case
op_minus
id|EREMOTEIO
suffix:colon
multiline_comment|/* short read */
r_break
suffix:semicolon
)brace
id|status
op_assign
id|usb_ep_queue
(paren
id|ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|ERROR
(paren
id|dev
comma
l_string|&quot;kill %s:  resubmit %d bytes --&gt; %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|req-&gt;length
comma
id|status
)paren
suffix:semicolon
id|usb_ep_set_halt
(paren
id|ep
)paren
suffix:semicolon
multiline_comment|/* FIXME recover later ... somehow */
)brace
)brace
r_static
r_struct
id|usb_request
op_star
DECL|function|source_sink_start_ep
id|source_sink_start_ep
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_int
id|gfp_flags
)paren
(brace
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
r_int
id|status
suffix:semicolon
id|req
op_assign
id|alloc_ep_req
(paren
id|ep
comma
id|buflen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_return
l_int|0
suffix:semicolon
id|memset
(paren
id|req-&gt;buf
comma
l_int|0
comma
id|req-&gt;length
)paren
suffix:semicolon
id|req-&gt;complete
op_assign
id|source_sink_complete
suffix:semicolon
id|status
op_assign
id|usb_ep_queue
(paren
id|ep
comma
id|req
comma
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|ep-&gt;driver_data
suffix:semicolon
id|ERROR
(paren
id|dev
comma
l_string|&quot;start %s --&gt; %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|status
)paren
suffix:semicolon
id|free_ep_req
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
id|req
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|req
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_source_sink_config
id|set_source_sink_config
(paren
r_struct
id|zero_dev
op_star
id|dev
comma
r_int
id|gfp_flags
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
r_struct
id|usb_gadget
op_star
id|gadget
op_assign
id|dev-&gt;gadget
suffix:semicolon
id|gadget_for_each_ep
(paren
id|ep
comma
id|gadget
)paren
(brace
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|d
suffix:semicolon
multiline_comment|/* one endpoint writes (sources) zeroes in (to the host) */
r_if
c_cond
(paren
id|strcmp
(paren
id|ep-&gt;name
comma
id|EP_IN_NAME
)paren
op_eq
l_int|0
)paren
(brace
id|d
op_assign
id|ep_desc
(paren
id|gadget
comma
op_amp
id|hs_source_desc
comma
op_amp
id|fs_source_desc
)paren
suffix:semicolon
id|result
op_assign
id|usb_ep_enable
(paren
id|ep
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|ep-&gt;driver_data
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|source_sink_start_ep
(paren
id|ep
comma
id|gfp_flags
)paren
op_ne
l_int|0
)paren
(brace
id|dev-&gt;in_ep
op_assign
id|ep
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|usb_ep_disable
(paren
id|ep
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* one endpoint reads (sinks) anything out (from the host) */
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|ep-&gt;name
comma
id|EP_OUT_NAME
)paren
op_eq
l_int|0
)paren
(brace
id|d
op_assign
id|ep_desc
(paren
id|gadget
comma
op_amp
id|hs_sink_desc
comma
op_amp
id|fs_sink_desc
)paren
suffix:semicolon
id|result
op_assign
id|usb_ep_enable
(paren
id|ep
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|ep-&gt;driver_data
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|source_sink_start_ep
(paren
id|ep
comma
id|gfp_flags
)paren
op_ne
l_int|0
)paren
(brace
id|dev-&gt;out_ep
op_assign
id|ep
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|usb_ep_disable
(paren
id|ep
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* ignore any other endpoints */
)brace
r_else
r_continue
suffix:semicolon
multiline_comment|/* stop on error */
id|ERROR
(paren
id|dev
comma
l_string|&quot;can&squot;t start %s, result %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|result
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
id|DEBUG
(paren
id|dev
comma
l_string|&quot;buflen %d&bslash;n&quot;
comma
id|buflen
)paren
suffix:semicolon
multiline_comment|/* caller is responsible for cleanup on error */
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|loopback_complete
r_static
r_void
id|loopback_complete
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|ep-&gt;driver_data
suffix:semicolon
r_int
id|status
op_assign
id|req-&gt;status
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* normal completion? */
r_if
c_cond
(paren
id|ep
op_eq
id|dev-&gt;out_ep
)paren
(brace
multiline_comment|/* loop this OUT packet back IN to the host */
id|req-&gt;zero
op_assign
(paren
id|req-&gt;actual
OL
id|req-&gt;length
)paren
suffix:semicolon
id|req-&gt;length
op_assign
id|req-&gt;actual
suffix:semicolon
id|status
op_assign
id|usb_ep_queue
(paren
id|dev-&gt;in_ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* &quot;should never get here&quot; */
id|ERROR
(paren
id|dev
comma
l_string|&quot;can&squot;t loop %s to %s: %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|dev-&gt;in_ep-&gt;name
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* queue the buffer for some later OUT packet */
id|req-&gt;length
op_assign
id|buflen
suffix:semicolon
id|status
op_assign
id|usb_ep_queue
(paren
id|dev-&gt;out_ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* &quot;should never get here&quot; */
multiline_comment|/* FALLTHROUGH */
r_default
suffix:colon
id|ERROR
(paren
id|dev
comma
l_string|&quot;%s loop complete --&gt; %d, %d/%d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|status
comma
id|req-&gt;actual
comma
id|req-&gt;length
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
multiline_comment|/* NOTE:  since this driver doesn&squot;t maintain an explicit record&n;&t; * of requests it submitted (just maintains qlen count), we&n;&t; * rely on the hardware driver to clean up on disconnect or&n;&t; * endpoint disable.&n;&t; */
r_case
op_minus
id|ESHUTDOWN
suffix:colon
multiline_comment|/* disconnect from host */
id|free_ep_req
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|set_loopback_config
id|set_loopback_config
(paren
r_struct
id|zero_dev
op_star
id|dev
comma
r_int
id|gfp_flags
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
r_struct
id|usb_gadget
op_star
id|gadget
op_assign
id|dev-&gt;gadget
suffix:semicolon
id|gadget_for_each_ep
(paren
id|ep
comma
id|gadget
)paren
(brace
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|d
suffix:semicolon
multiline_comment|/* one endpoint writes data back IN to the host */
r_if
c_cond
(paren
id|strcmp
(paren
id|ep-&gt;name
comma
id|EP_IN_NAME
)paren
op_eq
l_int|0
)paren
(brace
id|d
op_assign
id|ep_desc
(paren
id|gadget
comma
op_amp
id|hs_source_desc
comma
op_amp
id|fs_source_desc
)paren
suffix:semicolon
id|result
op_assign
id|usb_ep_enable
(paren
id|ep
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|ep-&gt;driver_data
op_assign
id|dev
suffix:semicolon
id|dev-&gt;in_ep
op_assign
id|ep
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* one endpoint just reads OUT packets */
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|ep-&gt;name
comma
id|EP_OUT_NAME
)paren
op_eq
l_int|0
)paren
(brace
id|d
op_assign
id|ep_desc
(paren
id|gadget
comma
op_amp
id|hs_sink_desc
comma
op_amp
id|fs_sink_desc
)paren
suffix:semicolon
id|result
op_assign
id|usb_ep_enable
(paren
id|ep
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|ep-&gt;driver_data
op_assign
id|dev
suffix:semicolon
id|dev-&gt;out_ep
op_assign
id|ep
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* ignore any other endpoints */
)brace
r_else
r_continue
suffix:semicolon
multiline_comment|/* stop on error */
id|ERROR
(paren
id|dev
comma
l_string|&quot;can&squot;t enable %s, result %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|result
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* allocate a bunch of read buffers and queue them all at once.&n;&t; * we buffer at most &squot;qlen&squot; transfers; fewer if any need more&n;&t; * than &squot;buflen&squot; bytes each.&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ep
op_assign
id|dev-&gt;out_ep
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|qlen
op_logical_and
id|result
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|req
op_assign
id|alloc_ep_req
(paren
id|ep
comma
id|buflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|req-&gt;complete
op_assign
id|loopback_complete
suffix:semicolon
id|result
op_assign
id|usb_ep_queue
(paren
id|ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|DEBUG
(paren
id|dev
comma
l_string|&quot;%s queue req --&gt; %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|result
)paren
suffix:semicolon
)brace
r_else
id|result
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
id|DEBUG
(paren
id|dev
comma
l_string|&quot;qlen %d, buflen %d&bslash;n&quot;
comma
id|qlen
comma
id|buflen
)paren
suffix:semicolon
multiline_comment|/* caller is responsible for cleanup on error */
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|zero_reset_config
r_static
r_void
id|zero_reset_config
(paren
r_struct
id|zero_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;config
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|DEBUG
(paren
id|dev
comma
l_string|&quot;reset config&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* just disable endpoints, forcing completion of pending i/o.&n;&t; * all our completion handlers free their requests in this case.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;in_ep
)paren
(brace
id|usb_ep_disable
(paren
id|dev-&gt;in_ep
)paren
suffix:semicolon
id|dev-&gt;in_ep
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;out_ep
)paren
(brace
id|usb_ep_disable
(paren
id|dev-&gt;out_ep
)paren
suffix:semicolon
id|dev-&gt;out_ep
op_assign
l_int|0
suffix:semicolon
)brace
id|dev-&gt;config
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* change our operational config.  this code must agree with the code&n; * that returns config descriptors, and altsetting code.&n; *&n; * it&squot;s also responsible for power management interactions. some&n; * configurations might not work with our current power sources.&n; *&n; * note that some device controller hardware will constrain what this&n; * code can do, perhaps by disallowing more than one configuration or&n; * by limiting configuration choices (like the pxa250).&n; */
r_static
r_int
DECL|function|zero_set_config
id|zero_set_config
(paren
r_struct
id|zero_dev
op_star
id|dev
comma
r_int
id|number
comma
r_int
id|gfp_flags
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_struct
id|usb_gadget
op_star
id|gadget
op_assign
id|dev-&gt;gadget
suffix:semicolon
r_if
c_cond
(paren
id|number
op_eq
id|dev-&gt;config
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_USB_ZERO_SA1100
r_if
c_cond
(paren
id|dev-&gt;config
)paren
(brace
multiline_comment|/* tx fifo is full, but we can&squot;t clear it...*/
id|INFO
(paren
id|dev
comma
l_string|&quot;can&squot;t change configurations&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
macro_line|#endif
id|zero_reset_config
(paren
id|dev
)paren
suffix:semicolon
id|hw_optimize
(paren
id|gadget
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|number
)paren
(brace
r_case
id|CONFIG_SOURCE_SINK
suffix:colon
id|result
op_assign
id|set_source_sink_config
(paren
id|dev
comma
id|gfp_flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONFIG_LOOPBACK
suffix:colon
id|result
op_assign
id|set_loopback_config
(paren
id|dev
comma
id|gfp_flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* FALL THROUGH */
r_case
l_int|0
suffix:colon
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|result
op_logical_and
(paren
op_logical_neg
id|dev-&gt;in_ep
op_logical_or
op_logical_neg
id|dev-&gt;out_ep
)paren
)paren
id|result
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|zero_reset_config
(paren
id|dev
)paren
suffix:semicolon
r_else
(brace
r_char
op_star
id|speed
suffix:semicolon
r_switch
c_cond
(paren
id|gadget-&gt;speed
)paren
(brace
r_case
id|USB_SPEED_LOW
suffix:colon
id|speed
op_assign
l_string|&quot;low&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_FULL
suffix:colon
id|speed
op_assign
l_string|&quot;full&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_HIGH
suffix:colon
id|speed
op_assign
l_string|&quot;high&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|speed
op_assign
l_string|&quot;?&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dev-&gt;config
op_assign
id|number
suffix:semicolon
id|INFO
(paren
id|dev
comma
l_string|&quot;%s speed config #%d: %s&bslash;n&quot;
comma
id|speed
comma
id|number
comma
(paren
id|number
op_eq
id|CONFIG_SOURCE_SINK
)paren
ques
c_cond
id|source_sink
suffix:colon
id|loopback
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|zero_setup_complete
r_static
r_void
id|zero_setup_complete
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;status
op_logical_or
id|req-&gt;actual
op_ne
id|req-&gt;length
)paren
id|DEBUG
(paren
(paren
r_struct
id|zero_dev
op_star
)paren
id|ep-&gt;driver_data
comma
l_string|&quot;setup complete --&gt; %d, %d/%d&bslash;n&quot;
comma
id|req-&gt;status
comma
id|req-&gt;actual
comma
id|req-&gt;length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The setup() callback implements all the ep0 functionality that&squot;s&n; * not handled lower down, in hardware or the hardware driver (like&n; * device and endpoint feature flags, and their status).  It&squot;s all&n; * housekeeping for the gadget function we&squot;re implementing.  Most of&n; * the work is in config-specific setup.&n; */
r_static
r_int
DECL|function|zero_setup
id|zero_setup
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
r_const
r_struct
id|usb_ctrlrequest
op_star
id|ctrl
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|get_gadget_data
(paren
id|gadget
)paren
suffix:semicolon
r_struct
id|usb_request
op_star
id|req
op_assign
id|dev-&gt;req
suffix:semicolon
r_int
id|value
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* usually this stores reply data in the pre-allocated ep0 buffer,&n;&t; * but config change events will reconfigure hardware.&n;&t; */
r_switch
c_cond
(paren
id|ctrl-&gt;bRequest
)paren
(brace
r_case
id|USB_REQ_GET_DESCRIPTOR
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
id|USB_DIR_IN
)paren
r_break
suffix:semicolon
r_switch
c_cond
(paren
id|ctrl-&gt;wValue
op_rshift
l_int|8
)paren
(brace
r_case
id|USB_DT_DEVICE
suffix:colon
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
r_sizeof
id|device_desc
)paren
suffix:semicolon
id|memcpy
(paren
id|req-&gt;buf
comma
op_amp
id|device_desc
comma
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef HIGHSPEED
r_case
id|USB_DT_DEVICE_QUALIFIER
suffix:colon
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
r_sizeof
id|dev_qualifier
)paren
suffix:semicolon
id|memcpy
(paren
id|req-&gt;buf
comma
op_amp
id|dev_qualifier
comma
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_OTHER_SPEED_CONFIG
suffix:colon
singleline_comment|// FALLTHROUGH
macro_line|#endif /* HIGHSPEED */
r_case
id|USB_DT_CONFIG
suffix:colon
id|value
op_assign
id|config_buf
(paren
id|gadget-&gt;speed
comma
id|req-&gt;buf
comma
id|ctrl-&gt;wValue
op_rshift
l_int|8
comma
id|ctrl-&gt;wValue
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
l_int|0
)paren
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_STRING
suffix:colon
multiline_comment|/* wIndex == language code.&n;&t;&t;&t; * this driver only handles one language, you can&n;&t;&t;&t; * add others even if they don&squot;t use iso8859/1&n;&t;&t;&t; */
id|value
op_assign
id|usb_gadget_get_string
(paren
op_amp
id|stringtab
comma
id|ctrl-&gt;wValue
op_amp
l_int|0xff
comma
id|req-&gt;buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
l_int|0
)paren
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* currently two configs, two speeds */
r_case
id|USB_REQ_SET_CONFIGURATION
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|value
op_assign
id|zero_set_config
(paren
id|dev
comma
id|ctrl-&gt;wValue
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_REQ_GET_CONFIGURATION
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
id|USB_DIR_IN
)paren
r_break
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|req-&gt;buf
op_assign
id|dev-&gt;config
suffix:semicolon
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* until we add altsetting support, or other interfaces,&n;&t; * only 0/0 are possible.&n;&t; */
r_case
id|USB_REQ_SET_INTERFACE
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
id|USB_RECIP_INTERFACE
)paren
r_break
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;config
op_logical_and
id|ctrl-&gt;wIndex
op_eq
l_int|0
op_logical_and
id|ctrl-&gt;wValue
op_eq
l_int|0
)paren
(brace
id|u8
id|config
op_assign
id|dev-&gt;config
suffix:semicolon
multiline_comment|/* resets interface configuration, forgets about&n;&t;&t;&t; * previous transaction state (queued bufs, etc)&n;&t;&t;&t; * and re-inits endpoint state (toggle etc)&n;&t;&t;&t; * no response queued, just zero status == success.&n;&t;&t;&t; * if we had more than one interface we couldn&squot;t&n;&t;&t;&t; * use this &quot;reset the config&quot; shortcut.&n;&t;&t;&t; */
id|zero_reset_config
(paren
id|dev
)paren
suffix:semicolon
id|zero_set_config
(paren
id|dev
comma
id|config
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|value
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_REQ_GET_INTERFACE
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_IN
op_or
id|USB_RECIP_INTERFACE
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;config
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;wIndex
op_ne
l_int|0
)paren
(brace
id|value
op_assign
op_minus
id|EDOM
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
(paren
id|u8
op_star
)paren
id|req-&gt;buf
op_assign
l_int|0
suffix:semicolon
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;unknown control req%02x.%02x v%04x i%04x l%d&bslash;n&quot;
comma
id|ctrl-&gt;bRequestType
comma
id|ctrl-&gt;bRequest
comma
id|ctrl-&gt;wValue
comma
id|ctrl-&gt;wIndex
comma
id|ctrl-&gt;wLength
)paren
suffix:semicolon
)brace
multiline_comment|/* respond with data transfer before status phase? */
r_if
c_cond
(paren
id|value
op_ge
l_int|0
)paren
(brace
id|req-&gt;length
op_assign
id|value
suffix:semicolon
id|value
op_assign
id|usb_ep_queue
(paren
id|gadget-&gt;ep0
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|0
)paren
(brace
id|DEBUG
(paren
id|dev
comma
l_string|&quot;ep_queue --&gt; %d&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
id|req-&gt;status
op_assign
l_int|0
suffix:semicolon
id|zero_setup_complete
(paren
id|gadget-&gt;ep0
comma
id|req
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* device either stalls (value &lt; 0) or reports success */
r_return
id|value
suffix:semicolon
)brace
r_static
r_void
DECL|function|zero_disconnect
id|zero_disconnect
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|get_gadget_data
(paren
id|gadget
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|zero_reset_config
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* a more significant application might have some non-usb&n;&t; * activities to quiesce here, saving resources like power&n;&t; * or pushing the notification up a network stack.&n;&t; */
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* next we may get setup() calls to enumerate new connections;&n;&t; * or an unbind() during shutdown (including removing module).&n;&t; */
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_void
DECL|function|zero_unbind
id|zero_unbind
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|get_gadget_data
(paren
id|gadget
)paren
suffix:semicolon
id|DEBUG
(paren
id|dev
comma
l_string|&quot;unbind&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* we&squot;ve already been disconnected ... no i/o is active */
r_if
c_cond
(paren
id|dev-&gt;req
)paren
id|free_ep_req
(paren
id|gadget-&gt;ep0
comma
id|dev-&gt;req
)paren
suffix:semicolon
id|kfree
(paren
id|dev
)paren
suffix:semicolon
id|set_gadget_data
(paren
id|gadget
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|zero_bind
id|zero_bind
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
suffix:semicolon
id|dev
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|dev
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
op_star
id|dev
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|dev-&gt;gadget
op_assign
id|gadget
suffix:semicolon
id|set_gadget_data
(paren
id|gadget
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* preallocate control response and buffer */
id|dev-&gt;req
op_assign
id|usb_ep_alloc_request
(paren
id|gadget-&gt;ep0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;req
)paren
r_goto
id|enomem
suffix:semicolon
id|dev-&gt;req-&gt;buf
op_assign
id|usb_ep_alloc_buffer
(paren
id|gadget-&gt;ep0
comma
id|USB_BUFSIZ
comma
op_amp
id|dev-&gt;req-&gt;dma
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;req-&gt;buf
)paren
r_goto
id|enomem
suffix:semicolon
id|dev-&gt;req-&gt;complete
op_assign
id|zero_setup_complete
suffix:semicolon
id|gadget-&gt;ep0-&gt;driver_data
op_assign
id|dev
suffix:semicolon
id|INFO
(paren
id|dev
comma
l_string|&quot;%s, version: &quot;
id|DRIVER_VERSION
l_string|&quot;&bslash;n&quot;
comma
id|longname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|enomem
suffix:colon
id|zero_unbind
(paren
id|gadget
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|variable|zero_driver
r_static
r_struct
id|usb_gadget_driver
id|zero_driver
op_assign
(brace
macro_line|#ifdef HIGHSPEED
dot
id|speed
op_assign
id|USB_SPEED_HIGH
comma
macro_line|#else
dot
id|speed
op_assign
id|USB_SPEED_FULL
comma
macro_line|#endif
dot
id|function
op_assign
(paren
r_char
op_star
)paren
id|longname
comma
dot
id|bind
op_assign
id|zero_bind
comma
dot
id|unbind
op_assign
id|zero_unbind
comma
dot
id|setup
op_assign
id|zero_setup
comma
dot
id|disconnect
op_assign
id|zero_disconnect
comma
dot
id|driver
op_assign
(brace
dot
id|name
op_assign
(paren
r_char
op_star
)paren
id|shortname
comma
singleline_comment|// .shutdown = ...
singleline_comment|// .suspend = ...
singleline_comment|// .resume = ...
)brace
comma
)brace
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;David Brownell&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;Dual BSD/GPL&quot;
)paren
suffix:semicolon
DECL|function|init
r_static
r_int
id|__init
id|init
(paren
r_void
)paren
(brace
multiline_comment|/* a real value would likely come through some id prom&n;&t; * or module option.  this one takes at least two packets.&n;&t; */
id|strlcpy
(paren
id|serial
comma
l_string|&quot;0123456789.0123456789.0123456789&quot;
comma
r_sizeof
id|serial
)paren
suffix:semicolon
r_return
id|usb_gadget_register_driver
(paren
op_amp
id|zero_driver
)paren
suffix:semicolon
)brace
DECL|variable|init
id|module_init
(paren
id|init
)paren
suffix:semicolon
DECL|function|cleanup
r_static
r_void
id|__exit
id|cleanup
(paren
r_void
)paren
(brace
id|usb_gadget_unregister_driver
(paren
op_amp
id|zero_driver
)paren
suffix:semicolon
)brace
DECL|variable|cleanup
id|module_exit
(paren
id|cleanup
)paren
suffix:semicolon
eof
