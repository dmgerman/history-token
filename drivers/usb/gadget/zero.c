multiline_comment|/*&n; * zero.c -- Gadget Zero, for USB development&n; *&n; * Copyright (C) 2003-2004 David Brownell&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. The names of the above-listed copyright holders may not be used&n; *    to endorse or promote products derived from this software without&n; *    specific prior written permission.&n; *&n; * ALTERNATIVELY, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;) as published by the Free Software&n; * Foundation, either version 2 of that License or (at your option) any&n; * later version.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS&n; * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,&n; * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR&n; * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR&n; * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,&n; * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,&n; * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR&n; * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF&n; * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING&n; * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS&n; * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; */
multiline_comment|/*&n; * Gadget Zero only needs two bulk endpoints, and is an example of how you&n; * can write a hardware-agnostic gadget driver running inside a USB device.&n; *&n; * Hardware details are visible (see CONFIG_USB_ZERO_* below) but don&squot;t&n; * affect most of the driver.&n; *&n; * Use it with the Linux host/master side &quot;usbtest&quot; driver to get a basic&n; * functional test of your device-side usb stack, or with &quot;usb-skeleton&quot;.&n; *&n; * It supports two similar configurations.  One sinks whatever the usb host&n; * writes, and in return sources zeroes.  The other loops whatever the host&n; * writes back, so the host can read it.  Module options include:&n; *&n; *   buflen=N&t;&t;default N=4096, buffer size used&n; *   qlen=N&t;&t;default N=32, how many buffers in the loopback queue&n; *   loopdefault&t;default false, list loopback config first&n; *&n; * Many drivers will only have one configuration, letting them be much&n; * simpler if they also don&squot;t support high speed operation (like this&n; * driver does).&n; */
DECL|macro|DEBUG
mdefine_line|#define DEBUG 1
singleline_comment|// #define VERBOSE
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/uts.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;linux/usb_ch9.h&gt;
macro_line|#include &lt;linux/usb_gadget.h&gt;
macro_line|#include &quot;gadget_chips.h&quot;
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION&t;&t;&quot;St Patrick&squot;s Day 2004&quot;
DECL|variable|shortname
r_static
r_const
r_char
id|shortname
(braket
)braket
op_assign
l_string|&quot;zero&quot;
suffix:semicolon
DECL|variable|longname
r_static
r_const
r_char
id|longname
(braket
)braket
op_assign
l_string|&quot;Gadget Zero&quot;
suffix:semicolon
DECL|variable|source_sink
r_static
r_const
r_char
id|source_sink
(braket
)braket
op_assign
l_string|&quot;source and sink data&quot;
suffix:semicolon
DECL|variable|loopback
r_static
r_const
r_char
id|loopback
(braket
)braket
op_assign
l_string|&quot;loop input to output&quot;
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * driver assumes self-powered hardware, and&n; * has no way for users to trigger remote wakeup.&n; *&n; * this version autoconfigures as much as possible,&n; * which is reasonable for most &quot;bulk-only&quot; drivers.&n; */
DECL|variable|EP_IN_NAME
r_static
r_const
r_char
op_star
id|EP_IN_NAME
suffix:semicolon
multiline_comment|/* source */
DECL|variable|EP_OUT_NAME
r_static
r_const
r_char
op_star
id|EP_OUT_NAME
suffix:semicolon
multiline_comment|/* sink */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* big enough to hold our biggest descriptor */
DECL|macro|USB_BUFSIZ
mdefine_line|#define USB_BUFSIZ&t;256
DECL|struct|zero_dev
r_struct
id|zero_dev
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|gadget
r_struct
id|usb_gadget
op_star
id|gadget
suffix:semicolon
DECL|member|req
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
multiline_comment|/* for control responses */
multiline_comment|/* when configured, we have one of two configs:&n;&t; * - source data (in to host) and sink it (out from host)&n;&t; * - or loop it back (out from host back in to host)&n;&t; */
DECL|member|config
id|u8
id|config
suffix:semicolon
DECL|member|in_ep
DECL|member|out_ep
r_struct
id|usb_ep
op_star
id|in_ep
comma
op_star
id|out_ep
suffix:semicolon
multiline_comment|/* autoresume timer */
DECL|member|resume
r_struct
id|timer_list
id|resume
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|xprintk
mdefine_line|#define xprintk(d,level,fmt,args...) &bslash;&n;&t;dev_printk(level , &amp;(d)-&gt;gadget-&gt;dev , fmt , ## args)
macro_line|#ifdef DEBUG
DECL|macro|DBG
mdefine_line|#define DBG(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_DEBUG , fmt , ## args)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(dev,fmt,args...) &bslash;&n;&t;do { } while (0)
macro_line|#endif /* DEBUG */
macro_line|#ifdef VERBOSE
DECL|macro|VDBG
mdefine_line|#define VDBG&t;DBG
macro_line|#else
DECL|macro|VDBG
mdefine_line|#define VDBG(dev,fmt,args...) &bslash;&n;&t;do { } while (0)
macro_line|#endif /* VERBOSE */
DECL|macro|ERROR
mdefine_line|#define ERROR(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_ERR , fmt , ## args)
DECL|macro|WARN
mdefine_line|#define WARN(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_WARNING , fmt , ## args)
DECL|macro|INFO
mdefine_line|#define INFO(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_INFO , fmt , ## args)
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|variable|buflen
r_static
r_int
id|buflen
op_assign
l_int|4096
suffix:semicolon
DECL|variable|qlen
r_static
r_int
id|qlen
op_assign
l_int|32
suffix:semicolon
DECL|variable|pattern
r_static
r_int
id|pattern
op_assign
l_int|0
suffix:semicolon
id|module_param
(paren
id|buflen
comma
id|uint
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
id|module_param
(paren
id|qlen
comma
id|uint
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
id|module_param
(paren
id|pattern
comma
id|uint
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
multiline_comment|/*&n; * if it&squot;s nonzero, autoresume says how many seconds to wait&n; * before trying to wake up the host after suspend.&n; */
DECL|variable|autoresume
r_static
r_int
id|autoresume
op_assign
l_int|0
suffix:semicolon
id|module_param
(paren
id|autoresume
comma
id|uint
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; * Normally the &quot;loopback&quot; configuration is second (index 1) so&n; * it&squot;s not the default.  Here&squot;s where to change that order, to&n; * work better with hosts where config changes are problematic.&n; * Or controllers (like superh) that only support one config.&n; */
DECL|variable|loopdefault
r_static
r_int
id|loopdefault
op_assign
l_int|0
suffix:semicolon
id|module_param
(paren
id|loopdefault
comma
r_bool
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Thanks to NetChip Technologies for donating this product ID.&n; *&n; * DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!&n; * Instead:  allocate your own, using normal USB-IF procedures.&n; */
macro_line|#ifndef&t;CONFIG_USB_ZERO_HNPTEST
DECL|macro|DRIVER_VENDOR_NUM
mdefine_line|#define DRIVER_VENDOR_NUM&t;0x0525&t;&t;/* NetChip */
DECL|macro|DRIVER_PRODUCT_NUM
mdefine_line|#define DRIVER_PRODUCT_NUM&t;0xa4a0&t;&t;/* Linux-USB &quot;Gadget Zero&quot; */
macro_line|#else
DECL|macro|DRIVER_VENDOR_NUM
mdefine_line|#define DRIVER_VENDOR_NUM&t;0x1a0a&t;&t;/* OTG test device IDs */
DECL|macro|DRIVER_PRODUCT_NUM
mdefine_line|#define DRIVER_PRODUCT_NUM&t;0xbadd
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * DESCRIPTORS ... most are static, but strings and (full)&n; * configuration descriptors are built on demand.&n; */
DECL|macro|STRING_MANUFACTURER
mdefine_line|#define STRING_MANUFACTURER&t;&t;25
DECL|macro|STRING_PRODUCT
mdefine_line|#define STRING_PRODUCT&t;&t;&t;42
DECL|macro|STRING_SERIAL
mdefine_line|#define STRING_SERIAL&t;&t;&t;101
DECL|macro|STRING_SOURCE_SINK
mdefine_line|#define STRING_SOURCE_SINK&t;&t;250
DECL|macro|STRING_LOOPBACK
mdefine_line|#define STRING_LOOPBACK&t;&t;&t;251
multiline_comment|/*&n; * This device advertises two configurations; these numbers work&n; * on a pxa250 as well as more flexible hardware.&n; */
DECL|macro|CONFIG_SOURCE_SINK
mdefine_line|#define&t;CONFIG_SOURCE_SINK&t;3
DECL|macro|CONFIG_LOOPBACK
mdefine_line|#define&t;CONFIG_LOOPBACK&t;&t;2
r_static
r_struct
id|usb_device_descriptor
DECL|variable|device_desc
id|device_desc
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|device_desc
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_DEVICE
comma
dot
id|bcdUSB
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0200
)paren
comma
dot
id|bDeviceClass
op_assign
id|USB_CLASS_VENDOR_SPEC
comma
dot
id|idVendor
op_assign
id|__constant_cpu_to_le16
(paren
id|DRIVER_VENDOR_NUM
)paren
comma
dot
id|idProduct
op_assign
id|__constant_cpu_to_le16
(paren
id|DRIVER_PRODUCT_NUM
)paren
comma
dot
id|iManufacturer
op_assign
id|STRING_MANUFACTURER
comma
dot
id|iProduct
op_assign
id|STRING_PRODUCT
comma
dot
id|iSerialNumber
op_assign
id|STRING_SERIAL
comma
dot
id|bNumConfigurations
op_assign
l_int|2
comma
)brace
suffix:semicolon
r_static
r_struct
id|usb_config_descriptor
DECL|variable|source_sink_config
id|source_sink_config
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|source_sink_config
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_CONFIG
comma
multiline_comment|/* compute wTotalLength on the fly */
dot
id|bNumInterfaces
op_assign
l_int|1
comma
dot
id|bConfigurationValue
op_assign
id|CONFIG_SOURCE_SINK
comma
dot
id|iConfiguration
op_assign
id|STRING_SOURCE_SINK
comma
dot
id|bmAttributes
op_assign
id|USB_CONFIG_ATT_ONE
op_or
id|USB_CONFIG_ATT_SELFPOWER
comma
dot
id|bMaxPower
op_assign
l_int|1
comma
multiline_comment|/* self-powered */
)brace
suffix:semicolon
r_static
r_struct
id|usb_config_descriptor
DECL|variable|loopback_config
id|loopback_config
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|loopback_config
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_CONFIG
comma
multiline_comment|/* compute wTotalLength on the fly */
dot
id|bNumInterfaces
op_assign
l_int|1
comma
dot
id|bConfigurationValue
op_assign
id|CONFIG_LOOPBACK
comma
dot
id|iConfiguration
op_assign
id|STRING_LOOPBACK
comma
dot
id|bmAttributes
op_assign
id|USB_CONFIG_ATT_ONE
op_or
id|USB_CONFIG_ATT_SELFPOWER
comma
dot
id|bMaxPower
op_assign
l_int|1
comma
multiline_comment|/* self-powered */
)brace
suffix:semicolon
r_static
r_struct
id|usb_otg_descriptor
DECL|variable|otg_descriptor
id|otg_descriptor
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|otg_descriptor
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_OTG
comma
dot
id|bmAttributes
op_assign
id|USB_OTG_SRP
comma
)brace
suffix:semicolon
multiline_comment|/* one interface in each configuration */
r_static
r_const
r_struct
id|usb_interface_descriptor
DECL|variable|source_sink_intf
id|source_sink_intf
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|source_sink_intf
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_INTERFACE
comma
dot
id|bNumEndpoints
op_assign
l_int|2
comma
dot
id|bInterfaceClass
op_assign
id|USB_CLASS_VENDOR_SPEC
comma
dot
id|iInterface
op_assign
id|STRING_SOURCE_SINK
comma
)brace
suffix:semicolon
r_static
r_const
r_struct
id|usb_interface_descriptor
DECL|variable|loopback_intf
id|loopback_intf
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|loopback_intf
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_INTERFACE
comma
dot
id|bNumEndpoints
op_assign
l_int|2
comma
dot
id|bInterfaceClass
op_assign
id|USB_CLASS_VENDOR_SPEC
comma
dot
id|iInterface
op_assign
id|STRING_LOOPBACK
comma
)brace
suffix:semicolon
multiline_comment|/* two full speed bulk endpoints; their use is config-dependent */
r_static
r_struct
id|usb_endpoint_descriptor
DECL|variable|fs_source_desc
id|fs_source_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_IN
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
)brace
suffix:semicolon
r_static
r_struct
id|usb_endpoint_descriptor
DECL|variable|fs_sink_desc
id|fs_sink_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_OUT
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
)brace
suffix:semicolon
DECL|variable|fs_source_sink_function
r_static
r_const
r_struct
id|usb_descriptor_header
op_star
id|fs_source_sink_function
(braket
)braket
op_assign
(brace
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|otg_descriptor
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|source_sink_intf
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|fs_sink_desc
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|fs_source_desc
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|fs_loopback_function
r_static
r_const
r_struct
id|usb_descriptor_header
op_star
id|fs_loopback_function
(braket
)braket
op_assign
(brace
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|otg_descriptor
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|loopback_intf
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|fs_sink_desc
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|fs_source_desc
comma
l_int|NULL
comma
)brace
suffix:semicolon
macro_line|#ifdef&t;CONFIG_USB_GADGET_DUALSPEED
multiline_comment|/*&n; * usb 2.0 devices need to expose both high speed and full speed&n; * descriptors, unless they only run at full speed.&n; *&n; * that means alternate endpoint descriptors (bigger packets)&n; * and a &quot;device qualifier&quot; ... plus more construction options&n; * for the config descriptor.&n; */
r_static
r_struct
id|usb_endpoint_descriptor
DECL|variable|hs_source_desc
id|hs_source_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
(paren
l_int|512
)paren
comma
)brace
suffix:semicolon
r_static
r_struct
id|usb_endpoint_descriptor
DECL|variable|hs_sink_desc
id|hs_sink_desc
op_assign
(brace
dot
id|bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_ENDPOINT
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|wMaxPacketSize
op_assign
id|__constant_cpu_to_le16
(paren
l_int|512
)paren
comma
)brace
suffix:semicolon
r_static
r_struct
id|usb_qualifier_descriptor
DECL|variable|dev_qualifier
id|dev_qualifier
op_assign
(brace
dot
id|bLength
op_assign
r_sizeof
id|dev_qualifier
comma
dot
id|bDescriptorType
op_assign
id|USB_DT_DEVICE_QUALIFIER
comma
dot
id|bcdUSB
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0200
)paren
comma
dot
id|bDeviceClass
op_assign
id|USB_CLASS_VENDOR_SPEC
comma
dot
id|bNumConfigurations
op_assign
l_int|2
comma
)brace
suffix:semicolon
DECL|variable|hs_source_sink_function
r_static
r_const
r_struct
id|usb_descriptor_header
op_star
id|hs_source_sink_function
(braket
)braket
op_assign
(brace
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|otg_descriptor
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|source_sink_intf
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|hs_source_desc
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|hs_sink_desc
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|hs_loopback_function
r_static
r_const
r_struct
id|usb_descriptor_header
op_star
id|hs_loopback_function
(braket
)braket
op_assign
(brace
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|otg_descriptor
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|loopback_intf
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|hs_source_desc
comma
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
op_amp
id|hs_sink_desc
comma
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/* maxpacket and other transfer characteristics vary by speed. */
DECL|macro|ep_desc
mdefine_line|#define ep_desc(g,hs,fs) (((g)-&gt;speed==USB_SPEED_HIGH)?(hs):(fs))
macro_line|#else
multiline_comment|/* if there&squot;s no high speed support, maxpacket doesn&squot;t change. */
DECL|macro|ep_desc
mdefine_line|#define ep_desc(g,hs,fs) fs
macro_line|#endif&t;/* !CONFIG_USB_GADGET_DUALSPEED */
DECL|variable|manufacturer
r_static
r_char
id|manufacturer
(braket
l_int|50
)braket
suffix:semicolon
DECL|variable|serial
r_static
r_char
id|serial
(braket
l_int|40
)braket
suffix:semicolon
multiline_comment|/* static strings, in UTF-8 */
DECL|variable|strings
r_static
r_struct
id|usb_string
id|strings
(braket
)braket
op_assign
(brace
(brace
id|STRING_MANUFACTURER
comma
id|manufacturer
comma
)brace
comma
(brace
id|STRING_PRODUCT
comma
id|longname
comma
)brace
comma
(brace
id|STRING_SERIAL
comma
id|serial
comma
)brace
comma
(brace
id|STRING_LOOPBACK
comma
id|loopback
comma
)brace
comma
(brace
id|STRING_SOURCE_SINK
comma
id|source_sink
comma
)brace
comma
(brace
)brace
multiline_comment|/* end of list */
)brace
suffix:semicolon
DECL|variable|stringtab
r_static
r_struct
id|usb_gadget_strings
id|stringtab
op_assign
(brace
dot
id|language
op_assign
l_int|0x0409
comma
multiline_comment|/* en-us */
dot
id|strings
op_assign
id|strings
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * config descriptors are also handcrafted.  these must agree with code&n; * that sets configurations, and with code managing interfaces and their&n; * altsettings.  other complexity may come from:&n; *&n; *  - high speed support, including &quot;other speed config&quot; rules&n; *  - multiple configurations&n; *  - interfaces with alternate settings&n; *  - embedded class or vendor-specific descriptors&n; *&n; * this handles high speed, and has a second config that could as easily&n; * have been an alternate interface setting (on most hardware).&n; *&n; * NOTE:  to demonstrate (and test) more USB capabilities, this driver&n; * should include an altsetting to test interrupt transfers, including&n; * high bandwidth modes at high speed.  (Maybe work like Intel&squot;s test&n; * device?)&n; */
r_static
r_int
DECL|function|config_buf
id|config_buf
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
id|u8
op_star
id|buf
comma
id|u8
id|type
comma
r_int
id|index
)paren
(brace
r_int
id|is_source_sink
suffix:semicolon
r_int
id|len
suffix:semicolon
r_const
r_struct
id|usb_descriptor_header
op_star
op_star
id|function
suffix:semicolon
macro_line|#ifdef CONFIG_USB_GADGET_DUALSPEED
r_int
id|hs
op_assign
(paren
id|gadget-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* two configurations will always be index 0 and index 1 */
r_if
c_cond
(paren
id|index
OG
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|is_source_sink
op_assign
id|loopdefault
ques
c_cond
(paren
id|index
op_eq
l_int|1
)paren
suffix:colon
(paren
id|index
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_GADGET_DUALSPEED
r_if
c_cond
(paren
id|type
op_eq
id|USB_DT_OTHER_SPEED_CONFIG
)paren
id|hs
op_assign
op_logical_neg
id|hs
suffix:semicolon
r_if
c_cond
(paren
id|hs
)paren
id|function
op_assign
id|is_source_sink
ques
c_cond
id|hs_source_sink_function
suffix:colon
id|hs_loopback_function
suffix:semicolon
r_else
macro_line|#endif
id|function
op_assign
id|is_source_sink
ques
c_cond
id|fs_source_sink_function
suffix:colon
id|fs_loopback_function
suffix:semicolon
multiline_comment|/* for now, don&squot;t advertise srp-only devices */
r_if
c_cond
(paren
op_logical_neg
id|gadget-&gt;is_otg
)paren
id|function
op_increment
suffix:semicolon
id|len
op_assign
id|usb_gadget_config_buf
(paren
id|is_source_sink
ques
c_cond
op_amp
id|source_sink_config
suffix:colon
op_amp
id|loopback_config
comma
id|buf
comma
id|USB_BUFSIZ
comma
id|function
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|len
suffix:semicolon
(paren
(paren
r_struct
id|usb_config_descriptor
op_star
)paren
id|buf
)paren
op_member_access_from_pointer
id|bDescriptorType
op_assign
id|type
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_struct
id|usb_request
op_star
DECL|function|alloc_ep_req
id|alloc_ep_req
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_int
id|length
)paren
(brace
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
id|req
op_assign
id|usb_ep_alloc_request
(paren
id|ep
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|req-&gt;length
op_assign
id|length
suffix:semicolon
id|req-&gt;buf
op_assign
id|usb_ep_alloc_buffer
(paren
id|ep
comma
id|length
comma
op_amp
id|req-&gt;dma
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;buf
)paren
(brace
id|usb_ep_free_request
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
id|req
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|req
suffix:semicolon
)brace
DECL|function|free_ep_req
r_static
r_void
id|free_ep_req
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;buf
)paren
id|usb_ep_free_buffer
(paren
id|ep
comma
id|req-&gt;buf
comma
id|req-&gt;dma
comma
id|req-&gt;length
)paren
suffix:semicolon
id|usb_ep_free_request
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* optionally require specific source/sink data patterns  */
r_static
r_int
DECL|function|check_read_data
id|check_read_data
(paren
r_struct
id|zero_dev
op_star
id|dev
comma
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_int
id|i
suffix:semicolon
id|u8
op_star
id|buf
op_assign
id|req-&gt;buf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|req-&gt;actual
suffix:semicolon
id|i
op_increment
comma
id|buf
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|pattern
)paren
(brace
multiline_comment|/* all-zeroes has no synchronization issues */
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_star
id|buf
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* mod63 stays in sync with short-terminated transfers,&n;&t;&t; * or otherwise when host and gadget agree on how large&n;&t;&t; * each usb transfer request should be.  resync is done&n;&t;&t; * with set_interface or set_config.&n;&t;&t; */
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
op_star
id|buf
op_eq
(paren
id|u8
)paren
(paren
id|i
op_mod
l_int|63
)paren
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ERROR
(paren
id|dev
comma
l_string|&quot;bad OUT byte, buf [%d] = %d&bslash;n&quot;
comma
id|i
comma
op_star
id|buf
)paren
suffix:semicolon
id|usb_ep_set_halt
(paren
id|ep
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|reinit_write_data
id|reinit_write_data
(paren
r_struct
id|zero_dev
op_star
id|dev
comma
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_int
id|i
suffix:semicolon
id|u8
op_star
id|buf
op_assign
id|req-&gt;buf
suffix:semicolon
r_switch
c_cond
(paren
id|pattern
)paren
(brace
r_case
l_int|0
suffix:colon
id|memset
(paren
id|req-&gt;buf
comma
l_int|0
comma
id|req-&gt;length
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|req-&gt;length
suffix:semicolon
id|i
op_increment
)paren
op_star
id|buf
op_increment
op_assign
(paren
id|u8
)paren
(paren
id|i
op_mod
l_int|63
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* if there is only one request in the queue, there&squot;ll always be an&n; * irq delay between end of one request and start of the next.&n; * that prevents using hardware dma queues.&n; */
DECL|function|source_sink_complete
r_static
r_void
id|source_sink_complete
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|ep-&gt;driver_data
suffix:semicolon
r_int
id|status
op_assign
id|req-&gt;status
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* normal completion? */
r_if
c_cond
(paren
id|ep
op_eq
id|dev-&gt;out_ep
)paren
id|check_read_data
(paren
id|dev
comma
id|ep
comma
id|req
)paren
suffix:semicolon
r_else
id|reinit_write_data
(paren
id|dev
comma
id|ep
comma
id|req
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* this endpoint is normally active while we&squot;re configured */
r_case
op_minus
id|ECONNABORTED
suffix:colon
multiline_comment|/* hardware forced ep reset */
r_case
op_minus
id|ECONNRESET
suffix:colon
multiline_comment|/* request dequeued */
r_case
op_minus
id|ESHUTDOWN
suffix:colon
multiline_comment|/* disconnect from host */
id|VDBG
(paren
id|dev
comma
l_string|&quot;%s gone (%d), %d/%d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|status
comma
id|req-&gt;actual
comma
id|req-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_eq
id|dev-&gt;out_ep
)paren
id|check_read_data
(paren
id|dev
comma
id|ep
comma
id|req
)paren
suffix:semicolon
id|free_ep_req
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
op_minus
id|EOVERFLOW
suffix:colon
multiline_comment|/* buffer overrun on read means that&n;&t;&t;&t;&t;&t; * we didn&squot;t provide a big enough&n;&t;&t;&t;&t;&t; * buffer.&n;&t;&t;&t;&t;&t; */
r_default
suffix:colon
macro_line|#if 1
id|DBG
(paren
id|dev
comma
l_string|&quot;%s complete --&gt; %d, %d/%d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|status
comma
id|req-&gt;actual
comma
id|req-&gt;length
)paren
suffix:semicolon
macro_line|#endif
r_case
op_minus
id|EREMOTEIO
suffix:colon
multiline_comment|/* short read */
r_break
suffix:semicolon
)brace
id|status
op_assign
id|usb_ep_queue
(paren
id|ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|ERROR
(paren
id|dev
comma
l_string|&quot;kill %s:  resubmit %d bytes --&gt; %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|req-&gt;length
comma
id|status
)paren
suffix:semicolon
id|usb_ep_set_halt
(paren
id|ep
)paren
suffix:semicolon
multiline_comment|/* FIXME recover later ... somehow */
)brace
)brace
r_static
r_struct
id|usb_request
op_star
DECL|function|source_sink_start_ep
id|source_sink_start_ep
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_int
id|gfp_flags
)paren
(brace
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
r_int
id|status
suffix:semicolon
id|req
op_assign
id|alloc_ep_req
(paren
id|ep
comma
id|buflen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
(paren
id|req-&gt;buf
comma
l_int|0
comma
id|req-&gt;length
)paren
suffix:semicolon
id|req-&gt;complete
op_assign
id|source_sink_complete
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
(paren
id|ep-&gt;name
comma
id|EP_IN_NAME
)paren
op_eq
l_int|0
)paren
id|reinit_write_data
(paren
id|ep-&gt;driver_data
comma
id|ep
comma
id|req
)paren
suffix:semicolon
id|status
op_assign
id|usb_ep_queue
(paren
id|ep
comma
id|req
comma
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|ep-&gt;driver_data
suffix:semicolon
id|ERROR
(paren
id|dev
comma
l_string|&quot;start %s --&gt; %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|status
)paren
suffix:semicolon
id|free_ep_req
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
id|req
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|req
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_source_sink_config
id|set_source_sink_config
(paren
r_struct
id|zero_dev
op_star
id|dev
comma
r_int
id|gfp_flags
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
r_struct
id|usb_gadget
op_star
id|gadget
op_assign
id|dev-&gt;gadget
suffix:semicolon
id|gadget_for_each_ep
(paren
id|ep
comma
id|gadget
)paren
(brace
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|d
suffix:semicolon
multiline_comment|/* one endpoint writes (sources) zeroes in (to the host) */
r_if
c_cond
(paren
id|strcmp
(paren
id|ep-&gt;name
comma
id|EP_IN_NAME
)paren
op_eq
l_int|0
)paren
(brace
id|d
op_assign
id|ep_desc
(paren
id|gadget
comma
op_amp
id|hs_source_desc
comma
op_amp
id|fs_source_desc
)paren
suffix:semicolon
id|result
op_assign
id|usb_ep_enable
(paren
id|ep
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|ep-&gt;driver_data
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|source_sink_start_ep
(paren
id|ep
comma
id|gfp_flags
)paren
op_ne
l_int|0
)paren
(brace
id|dev-&gt;in_ep
op_assign
id|ep
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|usb_ep_disable
(paren
id|ep
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* one endpoint reads (sinks) anything out (from the host) */
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|ep-&gt;name
comma
id|EP_OUT_NAME
)paren
op_eq
l_int|0
)paren
(brace
id|d
op_assign
id|ep_desc
(paren
id|gadget
comma
op_amp
id|hs_sink_desc
comma
op_amp
id|fs_sink_desc
)paren
suffix:semicolon
id|result
op_assign
id|usb_ep_enable
(paren
id|ep
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|ep-&gt;driver_data
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|source_sink_start_ep
(paren
id|ep
comma
id|gfp_flags
)paren
op_ne
l_int|0
)paren
(brace
id|dev-&gt;out_ep
op_assign
id|ep
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|usb_ep_disable
(paren
id|ep
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* ignore any other endpoints */
)brace
r_else
r_continue
suffix:semicolon
multiline_comment|/* stop on error */
id|ERROR
(paren
id|dev
comma
l_string|&quot;can&squot;t start %s, result %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|result
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
id|DBG
(paren
id|dev
comma
l_string|&quot;buflen %d&bslash;n&quot;
comma
id|buflen
)paren
suffix:semicolon
multiline_comment|/* caller is responsible for cleanup on error */
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|loopback_complete
r_static
r_void
id|loopback_complete
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|ep-&gt;driver_data
suffix:semicolon
r_int
id|status
op_assign
id|req-&gt;status
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* normal completion? */
r_if
c_cond
(paren
id|ep
op_eq
id|dev-&gt;out_ep
)paren
(brace
multiline_comment|/* loop this OUT packet back IN to the host */
id|req-&gt;zero
op_assign
(paren
id|req-&gt;actual
OL
id|req-&gt;length
)paren
suffix:semicolon
id|req-&gt;length
op_assign
id|req-&gt;actual
suffix:semicolon
id|status
op_assign
id|usb_ep_queue
(paren
id|dev-&gt;in_ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* &quot;should never get here&quot; */
id|ERROR
(paren
id|dev
comma
l_string|&quot;can&squot;t loop %s to %s: %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|dev-&gt;in_ep-&gt;name
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* queue the buffer for some later OUT packet */
id|req-&gt;length
op_assign
id|buflen
suffix:semicolon
id|status
op_assign
id|usb_ep_queue
(paren
id|dev-&gt;out_ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* &quot;should never get here&quot; */
multiline_comment|/* FALLTHROUGH */
r_default
suffix:colon
id|ERROR
(paren
id|dev
comma
l_string|&quot;%s loop complete --&gt; %d, %d/%d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|status
comma
id|req-&gt;actual
comma
id|req-&gt;length
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
multiline_comment|/* NOTE:  since this driver doesn&squot;t maintain an explicit record&n;&t; * of requests it submitted (just maintains qlen count), we&n;&t; * rely on the hardware driver to clean up on disconnect or&n;&t; * endpoint disable.&n;&t; */
r_case
op_minus
id|ECONNABORTED
suffix:colon
multiline_comment|/* hardware forced ep reset */
r_case
op_minus
id|ECONNRESET
suffix:colon
multiline_comment|/* request dequeued */
r_case
op_minus
id|ESHUTDOWN
suffix:colon
multiline_comment|/* disconnect from host */
id|free_ep_req
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|set_loopback_config
id|set_loopback_config
(paren
r_struct
id|zero_dev
op_star
id|dev
comma
r_int
id|gfp_flags
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
r_struct
id|usb_gadget
op_star
id|gadget
op_assign
id|dev-&gt;gadget
suffix:semicolon
id|gadget_for_each_ep
(paren
id|ep
comma
id|gadget
)paren
(brace
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|d
suffix:semicolon
multiline_comment|/* one endpoint writes data back IN to the host */
r_if
c_cond
(paren
id|strcmp
(paren
id|ep-&gt;name
comma
id|EP_IN_NAME
)paren
op_eq
l_int|0
)paren
(brace
id|d
op_assign
id|ep_desc
(paren
id|gadget
comma
op_amp
id|hs_source_desc
comma
op_amp
id|fs_source_desc
)paren
suffix:semicolon
id|result
op_assign
id|usb_ep_enable
(paren
id|ep
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|ep-&gt;driver_data
op_assign
id|dev
suffix:semicolon
id|dev-&gt;in_ep
op_assign
id|ep
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* one endpoint just reads OUT packets */
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|ep-&gt;name
comma
id|EP_OUT_NAME
)paren
op_eq
l_int|0
)paren
(brace
id|d
op_assign
id|ep_desc
(paren
id|gadget
comma
op_amp
id|hs_sink_desc
comma
op_amp
id|fs_sink_desc
)paren
suffix:semicolon
id|result
op_assign
id|usb_ep_enable
(paren
id|ep
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|ep-&gt;driver_data
op_assign
id|dev
suffix:semicolon
id|dev-&gt;out_ep
op_assign
id|ep
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* ignore any other endpoints */
)brace
r_else
r_continue
suffix:semicolon
multiline_comment|/* stop on error */
id|ERROR
(paren
id|dev
comma
l_string|&quot;can&squot;t enable %s, result %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|result
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* allocate a bunch of read buffers and queue them all at once.&n;&t; * we buffer at most &squot;qlen&squot; transfers; fewer if any need more&n;&t; * than &squot;buflen&squot; bytes each.&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ep
op_assign
id|dev-&gt;out_ep
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|qlen
op_logical_and
id|result
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|req
op_assign
id|alloc_ep_req
(paren
id|ep
comma
id|buflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|req-&gt;complete
op_assign
id|loopback_complete
suffix:semicolon
id|result
op_assign
id|usb_ep_queue
(paren
id|ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|DBG
(paren
id|dev
comma
l_string|&quot;%s queue req --&gt; %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|result
)paren
suffix:semicolon
)brace
r_else
id|result
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
id|DBG
(paren
id|dev
comma
l_string|&quot;qlen %d, buflen %d&bslash;n&quot;
comma
id|qlen
comma
id|buflen
)paren
suffix:semicolon
multiline_comment|/* caller is responsible for cleanup on error */
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|zero_reset_config
r_static
r_void
id|zero_reset_config
(paren
r_struct
id|zero_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;config
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|DBG
(paren
id|dev
comma
l_string|&quot;reset config&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* just disable endpoints, forcing completion of pending i/o.&n;&t; * all our completion handlers free their requests in this case.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;in_ep
)paren
(brace
id|usb_ep_disable
(paren
id|dev-&gt;in_ep
)paren
suffix:semicolon
id|dev-&gt;in_ep
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;out_ep
)paren
(brace
id|usb_ep_disable
(paren
id|dev-&gt;out_ep
)paren
suffix:semicolon
id|dev-&gt;out_ep
op_assign
l_int|NULL
suffix:semicolon
)brace
id|dev-&gt;config
op_assign
l_int|0
suffix:semicolon
id|del_timer
(paren
op_amp
id|dev-&gt;resume
)paren
suffix:semicolon
)brace
multiline_comment|/* change our operational config.  this code must agree with the code&n; * that returns config descriptors, and altsetting code.&n; *&n; * it&squot;s also responsible for power management interactions. some&n; * configurations might not work with our current power sources.&n; *&n; * note that some device controller hardware will constrain what this&n; * code can do, perhaps by disallowing more than one configuration or&n; * by limiting configuration choices (like the pxa2xx).&n; */
r_static
r_int
DECL|function|zero_set_config
id|zero_set_config
(paren
r_struct
id|zero_dev
op_star
id|dev
comma
r_int
id|number
comma
r_int
id|gfp_flags
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_struct
id|usb_gadget
op_star
id|gadget
op_assign
id|dev-&gt;gadget
suffix:semicolon
r_if
c_cond
(paren
id|number
op_eq
id|dev-&gt;config
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|gadget_is_sa1100
(paren
id|gadget
)paren
op_logical_and
id|dev-&gt;config
)paren
(brace
multiline_comment|/* tx fifo is full, but we can&squot;t clear it...*/
id|INFO
(paren
id|dev
comma
l_string|&quot;can&squot;t change configurations&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
id|zero_reset_config
(paren
id|dev
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|number
)paren
(brace
r_case
id|CONFIG_SOURCE_SINK
suffix:colon
id|result
op_assign
id|set_source_sink_config
(paren
id|dev
comma
id|gfp_flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONFIG_LOOPBACK
suffix:colon
id|result
op_assign
id|set_loopback_config
(paren
id|dev
comma
id|gfp_flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* FALL THROUGH */
r_case
l_int|0
suffix:colon
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|result
op_logical_and
(paren
op_logical_neg
id|dev-&gt;in_ep
op_logical_or
op_logical_neg
id|dev-&gt;out_ep
)paren
)paren
id|result
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|zero_reset_config
(paren
id|dev
)paren
suffix:semicolon
r_else
(brace
r_char
op_star
id|speed
suffix:semicolon
r_switch
c_cond
(paren
id|gadget-&gt;speed
)paren
(brace
r_case
id|USB_SPEED_LOW
suffix:colon
id|speed
op_assign
l_string|&quot;low&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_FULL
suffix:colon
id|speed
op_assign
l_string|&quot;full&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_HIGH
suffix:colon
id|speed
op_assign
l_string|&quot;high&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|speed
op_assign
l_string|&quot;?&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dev-&gt;config
op_assign
id|number
suffix:semicolon
id|INFO
(paren
id|dev
comma
l_string|&quot;%s speed config #%d: %s&bslash;n&quot;
comma
id|speed
comma
id|number
comma
(paren
id|number
op_eq
id|CONFIG_SOURCE_SINK
)paren
ques
c_cond
id|source_sink
suffix:colon
id|loopback
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|zero_setup_complete
r_static
r_void
id|zero_setup_complete
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;status
op_logical_or
id|req-&gt;actual
op_ne
id|req-&gt;length
)paren
id|DBG
(paren
(paren
r_struct
id|zero_dev
op_star
)paren
id|ep-&gt;driver_data
comma
l_string|&quot;setup complete --&gt; %d, %d/%d&bslash;n&quot;
comma
id|req-&gt;status
comma
id|req-&gt;actual
comma
id|req-&gt;length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The setup() callback implements all the ep0 functionality that&squot;s&n; * not handled lower down, in hardware or the hardware driver (like&n; * device and endpoint feature flags, and their status).  It&squot;s all&n; * housekeeping for the gadget function we&squot;re implementing.  Most of&n; * the work is in config-specific setup.&n; */
r_static
r_int
DECL|function|zero_setup
id|zero_setup
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
r_const
r_struct
id|usb_ctrlrequest
op_star
id|ctrl
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|get_gadget_data
(paren
id|gadget
)paren
suffix:semicolon
r_struct
id|usb_request
op_star
id|req
op_assign
id|dev-&gt;req
suffix:semicolon
r_int
id|value
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* usually this stores reply data in the pre-allocated ep0 buffer,&n;&t; * but config change events will reconfigure hardware.&n;&t; */
id|req-&gt;zero
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|ctrl-&gt;bRequest
)paren
(brace
r_case
id|USB_REQ_GET_DESCRIPTOR
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
id|USB_DIR_IN
)paren
r_goto
id|unknown
suffix:semicolon
r_switch
c_cond
(paren
id|ctrl-&gt;wValue
op_rshift
l_int|8
)paren
(brace
r_case
id|USB_DT_DEVICE
suffix:colon
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
r_sizeof
id|device_desc
)paren
suffix:semicolon
id|memcpy
(paren
id|req-&gt;buf
comma
op_amp
id|device_desc
comma
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_USB_GADGET_DUALSPEED
r_case
id|USB_DT_DEVICE_QUALIFIER
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|gadget-&gt;is_dualspeed
)paren
r_break
suffix:semicolon
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
r_sizeof
id|dev_qualifier
)paren
suffix:semicolon
id|memcpy
(paren
id|req-&gt;buf
comma
op_amp
id|dev_qualifier
comma
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_OTHER_SPEED_CONFIG
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|gadget-&gt;is_dualspeed
)paren
r_break
suffix:semicolon
singleline_comment|// FALLTHROUGH
macro_line|#endif /* CONFIG_USB_GADGET_DUALSPEED */
r_case
id|USB_DT_CONFIG
suffix:colon
id|value
op_assign
id|config_buf
(paren
id|gadget
comma
id|req-&gt;buf
comma
id|ctrl-&gt;wValue
op_rshift
l_int|8
comma
id|ctrl-&gt;wValue
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
l_int|0
)paren
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_STRING
suffix:colon
multiline_comment|/* wIndex == language code.&n;&t;&t;&t; * this driver only handles one language, you can&n;&t;&t;&t; * add string tables for other languages, using&n;&t;&t;&t; * any UTF-8 characters&n;&t;&t;&t; */
id|value
op_assign
id|usb_gadget_get_string
(paren
op_amp
id|stringtab
comma
id|ctrl-&gt;wValue
op_amp
l_int|0xff
comma
id|req-&gt;buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
l_int|0
)paren
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* currently two configs, two speeds */
r_case
id|USB_REQ_SET_CONFIGURATION
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
l_int|0
)paren
r_goto
id|unknown
suffix:semicolon
r_if
c_cond
(paren
id|gadget-&gt;a_hnp_support
)paren
id|DBG
(paren
id|dev
comma
l_string|&quot;HNP available&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gadget-&gt;a_alt_hnp_support
)paren
id|DBG
(paren
id|dev
comma
l_string|&quot;HNP needs a different root port&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|VDBG
(paren
id|dev
comma
l_string|&quot;HNP inactive&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|value
op_assign
id|zero_set_config
(paren
id|dev
comma
id|ctrl-&gt;wValue
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_REQ_GET_CONFIGURATION
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
id|USB_DIR_IN
)paren
r_goto
id|unknown
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|req-&gt;buf
op_assign
id|dev-&gt;config
suffix:semicolon
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* until we add altsetting support, or other interfaces,&n;&t; * only 0/0 are possible.  pxa2xx only supports 0/0 (poorly)&n;&t; * and already killed pending endpoint I/O.&n;&t; */
r_case
id|USB_REQ_SET_INTERFACE
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
id|USB_RECIP_INTERFACE
)paren
r_goto
id|unknown
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;config
op_logical_and
id|ctrl-&gt;wIndex
op_eq
l_int|0
op_logical_and
id|ctrl-&gt;wValue
op_eq
l_int|0
)paren
(brace
id|u8
id|config
op_assign
id|dev-&gt;config
suffix:semicolon
multiline_comment|/* resets interface configuration, forgets about&n;&t;&t;&t; * previous transaction state (queued bufs, etc)&n;&t;&t;&t; * and re-inits endpoint state (toggle etc)&n;&t;&t;&t; * no response queued, just zero status == success.&n;&t;&t;&t; * if we had more than one interface we couldn&squot;t&n;&t;&t;&t; * use this &quot;reset the config&quot; shortcut.&n;&t;&t;&t; */
id|zero_reset_config
(paren
id|dev
)paren
suffix:semicolon
id|zero_set_config
(paren
id|dev
comma
id|config
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|value
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_REQ_GET_INTERFACE
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_IN
op_or
id|USB_RECIP_INTERFACE
)paren
)paren
r_goto
id|unknown
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;config
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;wIndex
op_ne
l_int|0
)paren
(brace
id|value
op_assign
op_minus
id|EDOM
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
(paren
id|u8
op_star
)paren
id|req-&gt;buf
op_assign
l_int|0
suffix:semicolon
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * These are the same vendor-specific requests supported by&n;&t; * Intel&squot;s USB 2.0 compliance test devices.  We exceed that&n;&t; * device spec by allowing multiple-packet requests.&n;&t; */
r_case
l_int|0x5b
suffix:colon
multiline_comment|/* control WRITE test -- fill the buffer */
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_OUT
op_or
id|USB_TYPE_VENDOR
)paren
)paren
r_goto
id|unknown
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;wValue
op_logical_or
id|ctrl-&gt;wIndex
)paren
r_break
suffix:semicolon
multiline_comment|/* just read that many bytes into the buffer */
r_if
c_cond
(paren
id|ctrl-&gt;wLength
OG
id|USB_BUFSIZ
)paren
r_break
suffix:semicolon
id|value
op_assign
id|ctrl-&gt;wLength
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x5c
suffix:colon
multiline_comment|/* control READ test -- return the buffer */
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
(paren
id|USB_DIR_IN
op_or
id|USB_TYPE_VENDOR
)paren
)paren
r_goto
id|unknown
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;wValue
op_logical_or
id|ctrl-&gt;wIndex
)paren
r_break
suffix:semicolon
multiline_comment|/* expect those bytes are still in the buffer; send back */
r_if
c_cond
(paren
id|ctrl-&gt;wLength
OG
id|USB_BUFSIZ
op_logical_or
id|ctrl-&gt;wLength
op_ne
id|req-&gt;length
)paren
r_break
suffix:semicolon
id|value
op_assign
id|ctrl-&gt;wLength
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|unknown
suffix:colon
id|VDBG
(paren
id|dev
comma
l_string|&quot;unknown control req%02x.%02x v%04x i%04x l%d&bslash;n&quot;
comma
id|ctrl-&gt;bRequestType
comma
id|ctrl-&gt;bRequest
comma
id|ctrl-&gt;wValue
comma
id|ctrl-&gt;wIndex
comma
id|ctrl-&gt;wLength
)paren
suffix:semicolon
)brace
multiline_comment|/* respond with data transfer before status phase? */
r_if
c_cond
(paren
id|value
op_ge
l_int|0
)paren
(brace
id|req-&gt;length
op_assign
id|value
suffix:semicolon
id|req-&gt;zero
op_assign
id|value
OL
id|ctrl-&gt;wLength
op_logical_and
(paren
id|value
op_mod
id|gadget-&gt;ep0-&gt;maxpacket
)paren
op_eq
l_int|0
suffix:semicolon
id|value
op_assign
id|usb_ep_queue
(paren
id|gadget-&gt;ep0
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|0
)paren
(brace
id|DBG
(paren
id|dev
comma
l_string|&quot;ep_queue --&gt; %d&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
id|req-&gt;status
op_assign
l_int|0
suffix:semicolon
id|zero_setup_complete
(paren
id|gadget-&gt;ep0
comma
id|req
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* device either stalls (value &lt; 0) or reports success */
r_return
id|value
suffix:semicolon
)brace
r_static
r_void
DECL|function|zero_disconnect
id|zero_disconnect
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|get_gadget_data
(paren
id|gadget
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|zero_reset_config
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* a more significant application might have some non-usb&n;&t; * activities to quiesce here, saving resources like power&n;&t; * or pushing the notification up a network stack.&n;&t; */
id|spin_unlock_irqrestore
(paren
op_amp
id|dev-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* next we may get setup() calls to enumerate new connections;&n;&t; * or an unbind() during shutdown (including removing module).&n;&t; */
)brace
r_static
r_void
DECL|function|zero_autoresume
id|zero_autoresume
(paren
r_int
r_int
id|_dev
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
(paren
r_struct
id|zero_dev
op_star
)paren
id|_dev
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* normally the host would be woken up for something&n;&t; * more significant than just a timer firing...&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;gadget-&gt;speed
op_ne
id|USB_SPEED_UNKNOWN
)paren
(brace
id|status
op_assign
id|usb_gadget_wakeup
(paren
id|dev-&gt;gadget
)paren
suffix:semicolon
id|DBG
(paren
id|dev
comma
l_string|&quot;wakeup --&gt; %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_void
DECL|function|zero_unbind
id|zero_unbind
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|get_gadget_data
(paren
id|gadget
)paren
suffix:semicolon
id|DBG
(paren
id|dev
comma
l_string|&quot;unbind&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* we&squot;ve already been disconnected ... no i/o is active */
r_if
c_cond
(paren
id|dev-&gt;req
)paren
id|free_ep_req
(paren
id|gadget-&gt;ep0
comma
id|dev-&gt;req
)paren
suffix:semicolon
id|del_timer_sync
(paren
op_amp
id|dev-&gt;resume
)paren
suffix:semicolon
id|kfree
(paren
id|dev
)paren
suffix:semicolon
id|set_gadget_data
(paren
id|gadget
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|zero_bind
id|zero_bind
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
suffix:semicolon
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
multiline_comment|/* Bulk-only drivers like this one SHOULD be able to&n;&t; * autoconfigure on any sane usb controller driver,&n;&t; * but there may also be important quirks to address.&n;&t; */
id|usb_ep_autoconfig_reset
(paren
id|gadget
)paren
suffix:semicolon
id|ep
op_assign
id|usb_ep_autoconfig
(paren
id|gadget
comma
op_amp
id|fs_source_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
(brace
id|autoconf_fail
suffix:colon
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: can&squot;t autoconfigure on %s&bslash;n&quot;
comma
id|shortname
comma
id|gadget-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|EP_IN_NAME
op_assign
id|ep-&gt;name
suffix:semicolon
id|ep-&gt;driver_data
op_assign
id|ep
suffix:semicolon
multiline_comment|/* claim */
id|ep
op_assign
id|usb_ep_autoconfig
(paren
id|gadget
comma
op_amp
id|fs_sink_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_goto
id|autoconf_fail
suffix:semicolon
id|EP_OUT_NAME
op_assign
id|ep-&gt;name
suffix:semicolon
id|ep-&gt;driver_data
op_assign
id|ep
suffix:semicolon
multiline_comment|/* claim */
multiline_comment|/*&n;&t; * DRIVER POLICY CHOICE:  you may want to do this differently.&n;&t; * One thing to avoid is reusing a bcdDevice revision code&n;&t; * with different host-visible configurations or behavior&n;&t; * restrictions -- using ep1in/ep2out vs ep1out/ep3in, etc&n;&t; */
r_if
c_cond
(paren
id|gadget_is_net2280
(paren
id|gadget
)paren
)paren
(brace
id|device_desc.bcdDevice
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0201
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|gadget_is_pxa
(paren
id|gadget
)paren
)paren
(brace
id|device_desc.bcdDevice
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0203
)paren
suffix:semicolon
macro_line|#if 0
)brace
r_else
r_if
c_cond
(paren
id|gadget_is_sh
c_func
(paren
id|gadget
)paren
)paren
(brace
id|device_desc.bcdDevice
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0204
)paren
suffix:semicolon
multiline_comment|/* SH has only one configuration; see &quot;loopdefault&quot; */
id|device_desc.bNumConfigurations
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* FIXME make 1 == default.bConfigurationValue */
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|gadget_is_sa1100
(paren
id|gadget
)paren
)paren
(brace
id|device_desc.bcdDevice
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0205
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|gadget_is_goku
(paren
id|gadget
)paren
)paren
(brace
id|device_desc.bcdDevice
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0206
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|gadget_is_mq11xx
(paren
id|gadget
)paren
)paren
(brace
id|device_desc.bcdDevice
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0207
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|gadget_is_omap
(paren
id|gadget
)paren
)paren
(brace
id|device_desc.bcdDevice
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0208
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|gadget_is_lh7a40x
c_func
(paren
id|gadget
)paren
)paren
(brace
id|device_desc.bcdDevice
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0209
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|gadget_is_n9604
c_func
(paren
id|gadget
)paren
)paren
(brace
id|device_desc.bcdDevice
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0210
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* gadget zero is so simple (for now, no altsettings) that&n;&t;&t; * it SHOULD NOT have problems with bulk-capable hardware.&n;&t;&t; * so warn about unrcognized controllers, don&squot;t panic.&n;&t;&t; *&n;&t;&t; * things like configuration and altsetting numbering&n;&t;&t; * can need hardware-specific attention though.&n;&t;&t; */
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: controller &squot;%s&squot; not recognized&bslash;n&quot;
comma
id|shortname
comma
id|gadget-&gt;name
)paren
suffix:semicolon
id|device_desc.bcdDevice
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x9999
)paren
suffix:semicolon
)brace
multiline_comment|/* ok, we made sense of the hardware ... */
id|dev
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|dev
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
op_star
id|dev
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|dev-&gt;gadget
op_assign
id|gadget
suffix:semicolon
id|set_gadget_data
(paren
id|gadget
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* preallocate control response and buffer */
id|dev-&gt;req
op_assign
id|usb_ep_alloc_request
(paren
id|gadget-&gt;ep0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;req
)paren
r_goto
id|enomem
suffix:semicolon
id|dev-&gt;req-&gt;buf
op_assign
id|usb_ep_alloc_buffer
(paren
id|gadget-&gt;ep0
comma
id|USB_BUFSIZ
comma
op_amp
id|dev-&gt;req-&gt;dma
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;req-&gt;buf
)paren
r_goto
id|enomem
suffix:semicolon
id|dev-&gt;req-&gt;complete
op_assign
id|zero_setup_complete
suffix:semicolon
id|device_desc.bMaxPacketSize0
op_assign
id|gadget-&gt;ep0-&gt;maxpacket
suffix:semicolon
macro_line|#ifdef CONFIG_USB_GADGET_DUALSPEED
multiline_comment|/* assume ep0 uses the same value for both speeds ... */
id|dev_qualifier.bMaxPacketSize0
op_assign
id|device_desc.bMaxPacketSize0
suffix:semicolon
multiline_comment|/* and that all endpoints are dual-speed */
id|hs_source_desc.bEndpointAddress
op_assign
id|fs_source_desc.bEndpointAddress
suffix:semicolon
id|hs_sink_desc.bEndpointAddress
op_assign
id|fs_sink_desc.bEndpointAddress
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|gadget-&gt;is_otg
)paren
(brace
id|otg_descriptor.bmAttributes
op_or_assign
id|USB_OTG_HNP
comma
id|source_sink_config.bmAttributes
op_or_assign
id|USB_CONFIG_ATT_WAKEUP
suffix:semicolon
id|loopback_config.bmAttributes
op_or_assign
id|USB_CONFIG_ATT_WAKEUP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gadget-&gt;is_otg
)paren
(brace
id|otg_descriptor.bmAttributes
op_or_assign
id|USB_OTG_HNP
comma
id|source_sink_config.bmAttributes
op_or_assign
id|USB_CONFIG_ATT_WAKEUP
suffix:semicolon
id|loopback_config.bmAttributes
op_or_assign
id|USB_CONFIG_ATT_WAKEUP
suffix:semicolon
)brace
id|usb_gadget_set_selfpowered
(paren
id|gadget
)paren
suffix:semicolon
id|init_timer
(paren
op_amp
id|dev-&gt;resume
)paren
suffix:semicolon
id|dev-&gt;resume.function
op_assign
id|zero_autoresume
suffix:semicolon
id|dev-&gt;resume.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|autoresume
)paren
(brace
id|source_sink_config.bmAttributes
op_or_assign
id|USB_CONFIG_ATT_WAKEUP
suffix:semicolon
id|loopback_config.bmAttributes
op_or_assign
id|USB_CONFIG_ATT_WAKEUP
suffix:semicolon
)brace
id|gadget-&gt;ep0-&gt;driver_data
op_assign
id|dev
suffix:semicolon
id|INFO
(paren
id|dev
comma
l_string|&quot;%s, version: &quot;
id|DRIVER_VERSION
l_string|&quot;&bslash;n&quot;
comma
id|longname
)paren
suffix:semicolon
id|INFO
(paren
id|dev
comma
l_string|&quot;using %s, OUT %s IN %s&bslash;n&quot;
comma
id|gadget-&gt;name
comma
id|EP_OUT_NAME
comma
id|EP_IN_NAME
)paren
suffix:semicolon
id|snprintf
(paren
id|manufacturer
comma
r_sizeof
id|manufacturer
comma
id|UTS_SYSNAME
l_string|&quot; &quot;
id|UTS_RELEASE
l_string|&quot; with %s&quot;
comma
id|gadget-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|enomem
suffix:colon
id|zero_unbind
(paren
id|gadget
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_void
DECL|function|zero_suspend
id|zero_suspend
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|get_gadget_data
(paren
id|gadget
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gadget-&gt;speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|autoresume
)paren
(brace
id|mod_timer
(paren
op_amp
id|dev-&gt;resume
comma
id|jiffies
op_plus
(paren
id|HZ
op_star
id|autoresume
)paren
)paren
suffix:semicolon
id|DBG
(paren
id|dev
comma
l_string|&quot;suspend, wakeup in %d seconds&bslash;n&quot;
comma
id|autoresume
)paren
suffix:semicolon
)brace
r_else
id|DBG
(paren
id|dev
comma
l_string|&quot;suspend&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|zero_resume
id|zero_resume
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|zero_dev
op_star
id|dev
op_assign
id|get_gadget_data
(paren
id|gadget
)paren
suffix:semicolon
id|DBG
(paren
id|dev
comma
l_string|&quot;resume&bslash;n&quot;
)paren
suffix:semicolon
id|del_timer
(paren
op_amp
id|dev-&gt;resume
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|variable|zero_driver
r_static
r_struct
id|usb_gadget_driver
id|zero_driver
op_assign
(brace
macro_line|#ifdef CONFIG_USB_GADGET_DUALSPEED
dot
id|speed
op_assign
id|USB_SPEED_HIGH
comma
macro_line|#else
dot
id|speed
op_assign
id|USB_SPEED_FULL
comma
macro_line|#endif
dot
id|function
op_assign
(paren
r_char
op_star
)paren
id|longname
comma
dot
id|bind
op_assign
id|zero_bind
comma
dot
id|unbind
op_assign
id|zero_unbind
comma
dot
id|setup
op_assign
id|zero_setup
comma
dot
id|disconnect
op_assign
id|zero_disconnect
comma
dot
id|suspend
op_assign
id|zero_suspend
comma
dot
id|resume
op_assign
id|zero_resume
comma
dot
id|driver
op_assign
(brace
dot
id|name
op_assign
(paren
r_char
op_star
)paren
id|shortname
comma
singleline_comment|// .shutdown = ...
singleline_comment|// .suspend = ...
singleline_comment|// .resume = ...
)brace
comma
)brace
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;David Brownell&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;Dual BSD/GPL&quot;
)paren
suffix:semicolon
DECL|function|init
r_static
r_int
id|__init
id|init
(paren
r_void
)paren
(brace
multiline_comment|/* a real value would likely come through some id prom&n;&t; * or module option.  this one takes at least two packets.&n;&t; */
id|strlcpy
(paren
id|serial
comma
l_string|&quot;0123456789.0123456789.0123456789&quot;
comma
r_sizeof
id|serial
)paren
suffix:semicolon
r_return
id|usb_gadget_register_driver
(paren
op_amp
id|zero_driver
)paren
suffix:semicolon
)brace
DECL|variable|init
id|module_init
(paren
id|init
)paren
suffix:semicolon
DECL|function|cleanup
r_static
r_void
id|__exit
id|cleanup
(paren
r_void
)paren
(brace
id|usb_gadget_unregister_driver
(paren
op_amp
id|zero_driver
)paren
suffix:semicolon
)brace
DECL|variable|cleanup
id|module_exit
(paren
id|cleanup
)paren
suffix:semicolon
eof
