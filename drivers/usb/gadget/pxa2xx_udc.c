multiline_comment|/*&n; * linux/drivers/usb/gadget/pxa2xx_udc.c&n; * Intel PXA2xx and IXP4xx on-chip full speed USB device controllers&n; *&n; * Copyright (C) 2002 Intrinsyc, Inc. (Frank Becker)&n; * Copyright (C) 2003 Robert Schwebel, Pengutronix&n; * Copyright (C) 2003 Benedikt Spranger, Pengutronix&n; * Copyright (C) 2003 David Brownell&n; * Copyright (C) 2003 Joshua Wise&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; */
DECL|macro|DEBUG
macro_line|#undef&t;DEBUG
singleline_comment|// #define&t;VERBOSE&t;DBG_VERBOSE
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/dma-mapping.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/mach-types.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/arch/pxa-regs.h&gt;
macro_line|#include &lt;linux/usb_ch9.h&gt;
macro_line|#include &lt;linux/usb_gadget.h&gt;
macro_line|#include &lt;asm/arch/udc.h&gt;
multiline_comment|/*&n; * This driver handles the USB Device Controller (UDC) in Intel&squot;s PXA 2xx&n; * series processors.  The UDC for the IXP 4xx series is very similar.&n; * There are fifteen endpoints, in addition to ep0.&n; *&n; * Such controller drivers work with a gadget driver.  The gadget driver&n; * returns descriptors, implements configuration and data protocols used&n; * by the host to interact with this device, and allocates endpoints to&n; * the different protocol interfaces.  The controller driver virtualizes&n; * usb hardware so that the gadget drivers will be more portable.&n; * &n; * This UDC hardware wants to implement a bit too much USB protocol, so&n; * it constrains the sorts of USB configuration change events that work.&n; * The errata for these chips are misleading; some &quot;fixed&quot; bugs from&n; * pxa250 a0/a1 b0/b1/b2 sure act like they&squot;re still there.&n; */
DECL|macro|DRIVER_VERSION
mdefine_line|#define&t;DRIVER_VERSION&t;&quot;14-Dec-2003&quot;
DECL|macro|DRIVER_DESC
mdefine_line|#define&t;DRIVER_DESC&t;&quot;PXA 2xx USB Device Controller driver&quot;
DECL|variable|driver_name
r_static
r_const
r_char
id|driver_name
(braket
)braket
op_assign
l_string|&quot;pxa2xx_udc&quot;
suffix:semicolon
DECL|variable|ep0name
r_static
r_const
r_char
id|ep0name
(braket
)braket
op_assign
l_string|&quot;ep0&quot;
suffix:semicolon
singleline_comment|// #define&t;USE_DMA
singleline_comment|// #define&t;USE_OUT_DMA
singleline_comment|// #define&t;DISABLE_TEST_MODE
macro_line|#ifdef CONFIG_PROC_FS
DECL|macro|UDC_PROC_FILE
mdefine_line|#define&t;UDC_PROC_FILE
macro_line|#endif
macro_line|#ifdef CONFIG_ARCH_IXP4XX
DECL|macro|USE_DMA
macro_line|#undef USE_DMA
multiline_comment|/* cpu-specific register addresses are compiled in to this code */
macro_line|#ifdef CONFIG_ARCH_PXA
macro_line|#error &quot;Can&squot;t configure both IXP and PXA&quot;
macro_line|#endif
macro_line|#endif
macro_line|#include &quot;pxa2xx_udc.h&quot;
macro_line|#ifdef CONFIG_EMBEDDED
multiline_comment|/* few strings, and little code to use them */
DECL|macro|DEBUG
macro_line|#undef&t;DEBUG
DECL|macro|UDC_PROC_FILE
macro_line|#undef&t;UDC_PROC_FILE
macro_line|#endif
macro_line|#ifdef&t;USE_DMA
DECL|variable|use_dma
r_static
r_int
id|use_dma
op_assign
l_int|1
suffix:semicolon
id|module_param
c_func
(paren
id|use_dma
comma
r_bool
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|use_dma
comma
l_string|&quot;true to use dma&quot;
)paren
suffix:semicolon
r_static
r_void
id|dma_nodesc_handler
(paren
r_int
id|dmach
comma
r_void
op_star
id|_ep
comma
r_struct
id|pt_regs
op_star
id|r
)paren
suffix:semicolon
r_static
r_void
id|kick_dma
c_func
(paren
r_struct
id|pxa2xx_ep
op_star
id|ep
comma
r_struct
id|pxa2xx_request
op_star
id|req
)paren
suffix:semicolon
macro_line|#ifdef USE_OUT_DMA
DECL|macro|DMASTR
mdefine_line|#define&t;DMASTR &quot; (dma support)&quot;
macro_line|#else
DECL|macro|DMASTR
mdefine_line|#define&t;DMASTR &quot; (dma in)&quot;
macro_line|#endif
macro_line|#else&t;/* !USE_DMA */
DECL|macro|DMASTR
mdefine_line|#define&t;DMASTR &quot; (pio only)&quot;
DECL|macro|USE_OUT_DMA
macro_line|#undef&t;USE_OUT_DMA
macro_line|#endif
macro_line|#ifdef&t;CONFIG_USB_PXA2XX_SMALL
DECL|macro|SIZE_STR
mdefine_line|#define SIZE_STR&t;&quot; (small)&quot;
macro_line|#else
DECL|macro|SIZE_STR
mdefine_line|#define SIZE_STR&t;&quot;&quot;
macro_line|#endif
macro_line|#ifdef DISABLE_TEST_MODE
multiline_comment|/* (mode == 0) == no undocumented chip tweaks&n; * (mode &amp; 1)  == double buffer bulk IN&n; * (mode &amp; 2)  == double buffer bulk OUT&n; * ... so mode = 3 (or 7, 15, etc) does it for both&n; */
DECL|variable|fifo_mode
r_static
id|ushort
id|fifo_mode
op_assign
l_int|0
suffix:semicolon
id|module_param
c_func
(paren
id|fifo_mode
comma
id|ushort
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|fifo_mode
comma
l_string|&quot;pxa2xx udc fifo mode&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* ---------------------------------------------------------------------------&n; * &t;endpoint related parts of the api to the usb controller hardware,&n; *&t;used by gadget driver; and the inner talker-to-hardware core.&n; * ---------------------------------------------------------------------------&n; */
r_static
r_void
id|pxa2xx_ep_fifo_flush
(paren
r_struct
id|usb_ep
op_star
id|ep
)paren
suffix:semicolon
r_static
r_void
id|nuke
(paren
r_struct
id|pxa2xx_ep
op_star
comma
r_int
id|status
)paren
suffix:semicolon
DECL|function|pio_irq_enable
r_static
r_void
id|pio_irq_enable
c_func
(paren
r_int
id|bEndpointAddress
)paren
(brace
id|bEndpointAddress
op_and_assign
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|bEndpointAddress
OL
l_int|8
)paren
id|UICR0
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|bEndpointAddress
)paren
suffix:semicolon
r_else
(brace
id|bEndpointAddress
op_sub_assign
l_int|8
suffix:semicolon
id|UICR1
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|bEndpointAddress
)paren
suffix:semicolon
)brace
)brace
DECL|function|pio_irq_disable
r_static
r_void
id|pio_irq_disable
c_func
(paren
r_int
id|bEndpointAddress
)paren
(brace
id|bEndpointAddress
op_and_assign
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|bEndpointAddress
OL
l_int|8
)paren
id|UICR0
op_or_assign
l_int|1
op_lshift
id|bEndpointAddress
suffix:semicolon
r_else
(brace
id|bEndpointAddress
op_sub_assign
l_int|8
suffix:semicolon
id|UICR1
op_or_assign
l_int|1
op_lshift
id|bEndpointAddress
suffix:semicolon
)brace
)brace
multiline_comment|/* The UDCCR reg contains mask and interrupt status bits,&n; * so using &squot;|=&squot; isn&squot;t safe as it may ack an interrupt.&n; */
DECL|macro|UDCCR_MASK_BITS
mdefine_line|#define UDCCR_MASK_BITS         (UDCCR_REM | UDCCR_SRM | UDCCR_UDE)
DECL|function|udc_set_mask_UDCCR
r_static
r_inline
r_void
id|udc_set_mask_UDCCR
c_func
(paren
r_int
id|mask
)paren
(brace
id|UDCCR
op_assign
(paren
id|UDCCR
op_amp
id|UDCCR_MASK_BITS
)paren
op_or
(paren
id|mask
op_amp
id|UDCCR_MASK_BITS
)paren
suffix:semicolon
)brace
DECL|function|udc_clear_mask_UDCCR
r_static
r_inline
r_void
id|udc_clear_mask_UDCCR
c_func
(paren
r_int
id|mask
)paren
(brace
id|UDCCR
op_assign
(paren
id|UDCCR
op_amp
id|UDCCR_MASK_BITS
)paren
op_amp
op_complement
(paren
id|mask
op_amp
id|UDCCR_MASK_BITS
)paren
suffix:semicolon
)brace
DECL|function|udc_ack_int_UDCCR
r_static
r_inline
r_void
id|udc_ack_int_UDCCR
c_func
(paren
r_int
id|mask
)paren
(brace
multiline_comment|/* udccr contains the bits we dont want to change */
id|__u32
id|udccr
op_assign
id|UDCCR
op_amp
id|UDCCR_MASK_BITS
suffix:semicolon
id|UDCCR
op_assign
id|udccr
op_or
(paren
id|mask
op_amp
op_complement
id|UDCCR_MASK_BITS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * endpoint enable/disable&n; *&n; * we need to verify the descriptors used to enable endpoints.  since pxa2xx&n; * endpoint configurations are fixed, and are pretty much always enabled,&n; * there&squot;s not a lot to manage here.&n; *&n; * because pxa2xx can&squot;t selectively initialize bulk (or interrupt) endpoints,&n; * (resetting endpoint halt and toggle), SET_INTERFACE is unusable except&n; * for a single interface (with only the default altsetting) and for gadget&n; * drivers that don&squot;t halt endpoints (not reset by set_interface).  that also&n; * means that if you use ISO, you must violate the USB spec rule that all&n; * iso endpoints must be in non-default altsettings.&n; */
DECL|function|pxa2xx_ep_enable
r_static
r_int
id|pxa2xx_ep_enable
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|desc
)paren
(brace
r_struct
id|pxa2xx_ep
op_star
id|ep
suffix:semicolon
r_struct
id|pxa2xx_udc
op_star
id|dev
suffix:semicolon
id|ep
op_assign
id|container_of
(paren
id|_ep
comma
r_struct
id|pxa2xx_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
op_logical_neg
id|desc
op_logical_or
id|ep-&gt;desc
op_logical_or
id|_ep-&gt;name
op_eq
id|ep0name
op_logical_or
id|desc-&gt;bDescriptorType
op_ne
id|USB_DT_ENDPOINT
op_logical_or
id|ep-&gt;bEndpointAddress
op_ne
id|desc-&gt;bEndpointAddress
op_logical_or
id|ep-&gt;fifo_size
OL
id|le16_to_cpu
(paren
id|desc-&gt;wMaxPacketSize
)paren
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s, bad ep or descriptor&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* xfer types must match, except that interrupt ~= bulk */
r_if
c_cond
(paren
id|ep-&gt;bmAttributes
op_ne
id|desc-&gt;bmAttributes
op_logical_and
id|ep-&gt;bmAttributes
op_ne
id|USB_ENDPOINT_XFER_BULK
op_logical_and
id|desc-&gt;bmAttributes
op_ne
id|USB_ENDPOINT_XFER_INT
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s, %s type mismatch&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|_ep-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* hardware _could_ do smaller, but driver doesn&squot;t */
r_if
c_cond
(paren
(paren
id|desc-&gt;bmAttributes
op_eq
id|USB_ENDPOINT_XFER_BULK
op_logical_and
id|le16_to_cpu
(paren
id|desc-&gt;wMaxPacketSize
)paren
op_ne
id|BULK_FIFO_SIZE
)paren
op_logical_or
op_logical_neg
id|desc-&gt;wMaxPacketSize
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s, bad %s maxpacket&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|_ep-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ERANGE
suffix:semicolon
)brace
id|dev
op_assign
id|ep-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;driver
op_logical_or
id|dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s, bogus device state&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|ESHUTDOWN
suffix:semicolon
)brace
id|ep-&gt;desc
op_assign
id|desc
suffix:semicolon
id|ep-&gt;dma
op_assign
op_minus
l_int|1
suffix:semicolon
id|ep-&gt;stopped
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;pio_irqs
op_assign
id|ep-&gt;dma_irqs
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;ep.maxpacket
op_assign
id|le16_to_cpu
(paren
id|desc-&gt;wMaxPacketSize
)paren
suffix:semicolon
multiline_comment|/* flush fifo (mostly for OUT buffers) */
id|pxa2xx_ep_fifo_flush
(paren
id|_ep
)paren
suffix:semicolon
multiline_comment|/* ... reset halt state too, if we could ... */
macro_line|#ifdef&t;USE_DMA
multiline_comment|/* for (some) bulk and ISO endpoints, try to get a DMA channel and&n;&t; * bind it to the endpoint.  otherwise use PIO. &n;&t; */
r_switch
c_cond
(paren
id|ep-&gt;bmAttributes
)paren
(brace
r_case
id|USB_ENDPOINT_XFER_ISOC
suffix:colon
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|desc-&gt;wMaxPacketSize
)paren
op_mod
l_int|32
)paren
r_break
suffix:semicolon
singleline_comment|// fall through
r_case
id|USB_ENDPOINT_XFER_BULK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|use_dma
op_logical_or
op_logical_neg
id|ep-&gt;reg_drcmr
)paren
r_break
suffix:semicolon
id|ep-&gt;dma
op_assign
id|pxa_request_dma
(paren
(paren
r_char
op_star
)paren
id|_ep-&gt;name
comma
(paren
id|le16_to_cpu
(paren
id|desc-&gt;wMaxPacketSize
)paren
OG
l_int|64
)paren
ques
c_cond
id|DMA_PRIO_MEDIUM
multiline_comment|/* some iso */
suffix:colon
id|DMA_PRIO_LOW
comma
id|dma_nodesc_handler
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;dma
op_ge
l_int|0
)paren
(brace
op_star
id|ep-&gt;reg_drcmr
op_assign
id|DRCMR_MAPVLD
op_or
id|ep-&gt;dma
suffix:semicolon
id|DMSG
c_func
(paren
l_string|&quot;%s using dma%d&bslash;n&quot;
comma
id|_ep-&gt;name
comma
id|ep-&gt;dma
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;enabled %s&bslash;n&quot;
comma
id|_ep-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pxa2xx_ep_disable
r_static
r_int
id|pxa2xx_ep_disable
(paren
r_struct
id|usb_ep
op_star
id|_ep
)paren
(brace
r_struct
id|pxa2xx_ep
op_star
id|ep
suffix:semicolon
id|ep
op_assign
id|container_of
(paren
id|_ep
comma
r_struct
id|pxa2xx_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
op_logical_neg
id|ep-&gt;desc
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s, %s not enabled&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|_ep
ques
c_cond
id|ep-&gt;ep.name
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|nuke
(paren
id|ep
comma
op_minus
id|ESHUTDOWN
)paren
suffix:semicolon
macro_line|#ifdef&t;USE_DMA
r_if
c_cond
(paren
id|ep-&gt;dma
op_ge
l_int|0
)paren
(brace
op_star
id|ep-&gt;reg_drcmr
op_assign
l_int|0
suffix:semicolon
id|pxa_free_dma
(paren
id|ep-&gt;dma
)paren
suffix:semicolon
id|ep-&gt;dma
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* flush fifo (mostly for IN buffers) */
id|pxa2xx_ep_fifo_flush
(paren
id|_ep
)paren
suffix:semicolon
id|ep-&gt;desc
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;stopped
op_assign
l_int|1
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;%s disabled&bslash;n&quot;
comma
id|_ep-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* for the pxa2xx, these can just wrap kmalloc/kfree.  gadget drivers&n; * must still pass correctly initialized endpoints, since other controller&n; * drivers may care about how it&squot;s currently set up (dma issues etc).&n; */
multiline_comment|/*&n; * &t;pxa2xx_ep_alloc_request - allocate a request data structure&n; */
r_static
r_struct
id|usb_request
op_star
DECL|function|pxa2xx_ep_alloc_request
id|pxa2xx_ep_alloc_request
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_int
id|gfp_flags
)paren
(brace
r_struct
id|pxa2xx_request
op_star
id|req
suffix:semicolon
id|req
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|req
comma
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_return
l_int|0
suffix:semicolon
id|memset
(paren
id|req
comma
l_int|0
comma
r_sizeof
op_star
id|req
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|req-&gt;queue
)paren
suffix:semicolon
r_return
op_amp
id|req-&gt;req
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;pxa2xx_ep_free_request - deallocate a request data structure&n; */
r_static
r_void
DECL|function|pxa2xx_ep_free_request
id|pxa2xx_ep_free_request
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_struct
id|usb_request
op_star
id|_req
)paren
(brace
r_struct
id|pxa2xx_request
op_star
id|req
suffix:semicolon
id|req
op_assign
id|container_of
(paren
id|_req
comma
r_struct
id|pxa2xx_request
comma
id|req
)paren
suffix:semicolon
id|WARN_ON
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|req-&gt;queue
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/* PXA cache needs flushing with DMA I/O (it&squot;s dma-incoherent), but there&squot;s&n; * no device-affinity and the heap works perfectly well for i/o buffers.&n; * It wastes much less memory than dma_alloc_coherent() would, and even&n; * prevents cacheline (32 bytes wide) sharing problems.&n; */
r_static
r_void
op_star
DECL|function|pxa2xx_ep_alloc_buffer
id|pxa2xx_ep_alloc_buffer
c_func
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_int
id|bytes
comma
id|dma_addr_t
op_star
id|dma
comma
r_int
id|gfp_flags
)paren
(brace
r_char
op_star
id|retval
suffix:semicolon
id|retval
op_assign
id|kmalloc
(paren
id|bytes
comma
id|gfp_flags
op_amp
op_complement
(paren
id|__GFP_DMA
op_or
id|__GFP_HIGHMEM
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
op_star
id|dma
op_assign
id|virt_to_bus
(paren
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_void
DECL|function|pxa2xx_ep_free_buffer
id|pxa2xx_ep_free_buffer
c_func
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_void
op_star
id|buf
comma
id|dma_addr_t
id|dma
comma
r_int
id|bytes
)paren
(brace
id|kfree
(paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; *&t;done - retire a request; caller blocked irqs&n; */
DECL|function|done
r_static
r_void
id|done
c_func
(paren
r_struct
id|pxa2xx_ep
op_star
id|ep
comma
r_struct
id|pxa2xx_request
op_star
id|req
comma
r_int
id|status
)paren
(brace
r_int
id|stopped
op_assign
id|ep-&gt;stopped
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|req-&gt;queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|req-&gt;req.status
op_eq
op_minus
id|EINPROGRESS
)paren
)paren
id|req-&gt;req.status
op_assign
id|status
suffix:semicolon
r_else
id|status
op_assign
id|req-&gt;req.status
suffix:semicolon
r_if
c_cond
(paren
id|status
op_logical_and
id|status
op_ne
op_minus
id|ESHUTDOWN
)paren
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;complete %s req %p stat %d len %u/%u&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
op_amp
id|req-&gt;req
comma
id|status
comma
id|req-&gt;req.actual
comma
id|req-&gt;req.length
)paren
suffix:semicolon
multiline_comment|/* don&squot;t modify queue heads during completion callback */
id|ep-&gt;stopped
op_assign
l_int|1
suffix:semicolon
id|req-&gt;req
dot
id|complete
c_func
(paren
op_amp
id|ep-&gt;ep
comma
op_amp
id|req-&gt;req
)paren
suffix:semicolon
id|ep-&gt;stopped
op_assign
id|stopped
suffix:semicolon
)brace
DECL|function|ep0_idle
r_static
r_inline
r_void
id|ep0_idle
(paren
r_struct
id|pxa2xx_udc
op_star
id|dev
)paren
(brace
id|dev-&gt;ep0state
op_assign
id|EP0_IDLE
suffix:semicolon
id|LED_EP0_OFF
suffix:semicolon
)brace
r_static
r_int
DECL|function|write_packet
id|write_packet
c_func
(paren
r_volatile
id|u32
op_star
id|uddr
comma
r_struct
id|pxa2xx_request
op_star
id|req
comma
r_int
id|max
)paren
(brace
id|u8
op_star
id|buf
suffix:semicolon
r_int
id|length
comma
id|count
suffix:semicolon
id|buf
op_assign
id|req-&gt;req.buf
op_plus
id|req-&gt;req.actual
suffix:semicolon
id|prefetch
c_func
(paren
id|buf
)paren
suffix:semicolon
multiline_comment|/* how big will this packet be? */
id|length
op_assign
id|min
c_func
(paren
id|req-&gt;req.length
op_minus
id|req-&gt;req.actual
comma
id|max
)paren
suffix:semicolon
id|req-&gt;req.actual
op_add_assign
id|length
suffix:semicolon
id|count
op_assign
id|length
suffix:semicolon
r_while
c_loop
(paren
id|likely
c_func
(paren
id|count
op_decrement
)paren
)paren
op_star
id|uddr
op_assign
op_star
id|buf
op_increment
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
multiline_comment|/*&n; * write to an IN endpoint fifo, as many packets as possible.&n; * irqs will use this to write the rest later.&n; * caller guarantees at least one packet buffer is ready (or a zlp).&n; */
r_static
r_int
DECL|function|write_fifo
id|write_fifo
(paren
r_struct
id|pxa2xx_ep
op_star
id|ep
comma
r_struct
id|pxa2xx_request
op_star
id|req
)paren
(brace
r_int
id|max
suffix:semicolon
id|max
op_assign
id|le16_to_cpu
c_func
(paren
id|ep-&gt;desc-&gt;wMaxPacketSize
)paren
suffix:semicolon
r_do
(brace
r_int
id|count
suffix:semicolon
r_int
id|is_last
comma
id|is_short
suffix:semicolon
id|count
op_assign
id|write_packet
c_func
(paren
id|ep-&gt;reg_uddr
comma
id|req
comma
id|max
)paren
suffix:semicolon
multiline_comment|/* last packet is usually short (or a zlp) */
r_if
c_cond
(paren
id|unlikely
(paren
id|count
op_ne
id|max
)paren
)paren
id|is_last
op_assign
id|is_short
op_assign
l_int|1
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|req-&gt;req.length
op_ne
id|req-&gt;req.actual
)paren
op_logical_or
id|req-&gt;req.zero
)paren
id|is_last
op_assign
l_int|0
suffix:semicolon
r_else
id|is_last
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* interrupt/iso maxpacket may not fill the fifo */
id|is_short
op_assign
id|unlikely
(paren
id|max
OL
id|ep-&gt;fifo_size
)paren
suffix:semicolon
)brace
id|DBG
c_func
(paren
id|DBG_VERY_NOISY
comma
l_string|&quot;wrote %s %d bytes%s%s %d left %p&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|count
comma
id|is_last
ques
c_cond
l_string|&quot;/L&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|is_short
ques
c_cond
l_string|&quot;/S&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|req-&gt;req.length
op_minus
id|req-&gt;req.actual
comma
id|req
)paren
suffix:semicolon
multiline_comment|/* let loose that packet. maybe try writing another one,&n;&t;&t; * double buffering might work.  TSP, TPC, and TFS&n;&t;&t; * bit values are the same for all normal IN endpoints.&n;&t;&t; */
op_star
id|ep-&gt;reg_udccs
op_assign
id|UDCCS_BI_TPC
suffix:semicolon
r_if
c_cond
(paren
id|is_short
)paren
op_star
id|ep-&gt;reg_udccs
op_assign
id|UDCCS_BI_TSP
suffix:semicolon
multiline_comment|/* requests complete when all IN data is in the FIFO */
r_if
c_cond
(paren
id|is_last
)paren
(brace
id|done
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
op_logical_or
id|unlikely
c_func
(paren
id|ep-&gt;dma
op_ge
l_int|0
)paren
)paren
(brace
id|pio_irq_disable
(paren
id|ep-&gt;bEndpointAddress
)paren
suffix:semicolon
macro_line|#ifdef USE_DMA
multiline_comment|/* unaligned data and zlps couldn&squot;t use dma */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
)paren
(brace
id|req
op_assign
id|list_entry
c_func
(paren
id|ep-&gt;queue.next
comma
r_struct
id|pxa2xx_request
comma
id|queue
)paren
suffix:semicolon
id|kick_dma
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
)brace
r_return
l_int|1
suffix:semicolon
)brace
singleline_comment|// TODO experiment: how robust can fifo mode tweaking be?
singleline_comment|// double buffering is off in the default fifo mode, which
singleline_comment|// prevents TFS from being set here.
)brace
r_while
c_loop
(paren
op_star
id|ep-&gt;reg_udccs
op_amp
id|UDCCS_BI_TFS
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* caller asserts req-&gt;pending (ep0 irq status nyet cleared); starts&n; * ep0 data stage.  these chips want very simple state transitions.&n; */
r_static
r_inline
DECL|function|ep0start
r_void
id|ep0start
c_func
(paren
r_struct
id|pxa2xx_udc
op_star
id|dev
comma
id|u32
id|flags
comma
r_const
r_char
op_star
id|tag
)paren
(brace
id|UDCCS0
op_assign
id|flags
op_or
id|UDCCS0_SA
op_or
id|UDCCS0_OPR
suffix:semicolon
id|USIR0
op_assign
id|USIR0_IR0
suffix:semicolon
id|dev-&gt;req_pending
op_assign
l_int|0
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_VERY_NOISY
comma
l_string|&quot;%s %s, %02x/%02x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|tag
comma
id|UDCCS0
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|write_ep0_fifo
id|write_ep0_fifo
(paren
r_struct
id|pxa2xx_ep
op_star
id|ep
comma
r_struct
id|pxa2xx_request
op_star
id|req
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
id|is_short
suffix:semicolon
id|count
op_assign
id|write_packet
c_func
(paren
op_amp
id|UDDR0
comma
id|req
comma
id|EP0_FIFO_SIZE
)paren
suffix:semicolon
id|ep-&gt;dev-&gt;stats.write.bytes
op_add_assign
id|count
suffix:semicolon
multiline_comment|/* last packet &quot;must be&quot; short (or a zlp) */
id|is_short
op_assign
(paren
id|count
op_ne
id|EP0_FIFO_SIZE
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_VERY_NOISY
comma
l_string|&quot;ep0in %d bytes %d left %p&bslash;n&quot;
comma
id|count
comma
id|req-&gt;req.length
op_minus
id|req-&gt;req.actual
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|is_short
)paren
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;dev-&gt;req_pending
)paren
id|ep0start
c_func
(paren
id|ep-&gt;dev
comma
id|UDCCS0_IPR
comma
l_string|&quot;short IN&quot;
)paren
suffix:semicolon
r_else
id|UDCCS0
op_assign
id|UDCCS0_IPR
suffix:semicolon
id|count
op_assign
id|req-&gt;req.length
suffix:semicolon
id|done
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
id|ep0_idle
c_func
(paren
id|ep-&gt;dev
)paren
suffix:semicolon
macro_line|#if 1
multiline_comment|/* This seems to get rid of lost status irqs in some cases:&n;&t;&t; * host responds quickly, or next request involves config&n;&t;&t; * change automagic, or should have been hidden, or ...&n;&t;&t; *&n;&t;&t; * FIXME get rid of all udelays possible...&n;&t;&t; */
r_if
c_cond
(paren
id|count
op_ge
id|EP0_FIFO_SIZE
)paren
(brace
id|count
op_assign
l_int|100
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|UDCCS0
op_amp
id|UDCCS0_OPR
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* clear OPR, generate ack */
id|UDCCS0
op_assign
id|UDCCS0_OPR
suffix:semicolon
r_break
suffix:semicolon
)brace
id|count
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|ep-&gt;dev-&gt;req_pending
)paren
id|ep0start
c_func
(paren
id|ep-&gt;dev
comma
l_int|0
comma
l_string|&quot;IN&quot;
)paren
suffix:semicolon
r_return
id|is_short
suffix:semicolon
)brace
multiline_comment|/*&n; * read_fifo -  unload packet(s) from the fifo we use for usb OUT&n; * transfers and put them into the request.  caller should have made&n; * sure there&squot;s at least one packet ready.&n; *&n; * returns true if the request completed because of short packet or the&n; * request buffer having filled (and maybe overran till end-of-packet).&n; */
r_static
r_int
DECL|function|read_fifo
id|read_fifo
(paren
r_struct
id|pxa2xx_ep
op_star
id|ep
comma
r_struct
id|pxa2xx_request
op_star
id|req
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|u32
id|udccs
suffix:semicolon
id|u8
op_star
id|buf
suffix:semicolon
r_int
id|bufferspace
comma
id|count
comma
id|is_short
suffix:semicolon
multiline_comment|/* make sure there&squot;s a packet in the FIFO.&n;&t;&t; * UDCCS_{BO,IO}_RPC are all the same bit value.&n;&t;&t; * UDCCS_{BO,IO}_RNE are all the same bit value.&n;&t;&t; */
id|udccs
op_assign
op_star
id|ep-&gt;reg_udccs
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
(paren
id|udccs
op_amp
id|UDCCS_BO_RPC
)paren
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|buf
op_assign
id|req-&gt;req.buf
op_plus
id|req-&gt;req.actual
suffix:semicolon
id|prefetchw
c_func
(paren
id|buf
)paren
suffix:semicolon
id|bufferspace
op_assign
id|req-&gt;req.length
op_minus
id|req-&gt;req.actual
suffix:semicolon
multiline_comment|/* read all bytes from this packet */
r_if
c_cond
(paren
id|likely
(paren
id|udccs
op_amp
id|UDCCS_BO_RNE
)paren
)paren
(brace
id|count
op_assign
l_int|1
op_plus
(paren
l_int|0x0ff
op_amp
op_star
id|ep-&gt;reg_ubcr
)paren
suffix:semicolon
id|req-&gt;req.actual
op_add_assign
id|min
(paren
id|count
comma
id|bufferspace
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* zlp */
id|count
op_assign
l_int|0
suffix:semicolon
id|is_short
op_assign
(paren
id|count
OL
id|ep-&gt;ep.maxpacket
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_VERY_NOISY
comma
l_string|&quot;read %s %02x, %d bytes%s req %p %d/%d&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|udccs
comma
id|count
comma
id|is_short
ques
c_cond
l_string|&quot;/S&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|req
comma
id|req-&gt;req.actual
comma
id|req-&gt;req.length
)paren
suffix:semicolon
r_while
c_loop
(paren
id|likely
(paren
id|count
op_decrement
op_ne
l_int|0
)paren
)paren
(brace
id|u8
id|byte
op_assign
(paren
id|u8
)paren
op_star
id|ep-&gt;reg_uddr
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|bufferspace
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* this happens when the driver&squot;s buffer&n;&t;&t;&t;&t; * is smaller than what the host sent.&n;&t;&t;&t;&t; * discard the extra data.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|req-&gt;req.status
op_ne
op_minus
id|EOVERFLOW
)paren
id|DMSG
c_func
(paren
l_string|&quot;%s overflow %d&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|count
)paren
suffix:semicolon
id|req-&gt;req.status
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
)brace
r_else
(brace
op_star
id|buf
op_increment
op_assign
id|byte
suffix:semicolon
id|bufferspace
op_decrement
suffix:semicolon
)brace
)brace
op_star
id|ep-&gt;reg_udccs
op_assign
id|UDCCS_BO_RPC
suffix:semicolon
multiline_comment|/* RPC/RSP/RNE could now reflect the other packet buffer */
multiline_comment|/* iso is one request per packet */
r_if
c_cond
(paren
id|ep-&gt;bmAttributes
op_eq
id|USB_ENDPOINT_XFER_ISOC
)paren
(brace
r_if
c_cond
(paren
id|udccs
op_amp
id|UDCCS_IO_ROF
)paren
id|req-&gt;req.status
op_assign
op_minus
id|EHOSTUNREACH
suffix:semicolon
multiline_comment|/* more like &quot;is_done&quot; */
id|is_short
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* completion */
r_if
c_cond
(paren
id|is_short
op_logical_or
id|req-&gt;req.actual
op_eq
id|req-&gt;req.length
)paren
(brace
id|done
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
id|pio_irq_disable
(paren
id|ep-&gt;bEndpointAddress
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* finished that packet.  the next one may be waiting... */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * special ep0 version of the above.  no UBCR0 or double buffering; status&n; * handshaking is magic.  most device protocols don&squot;t need control-OUT.&n; * CDC vendor commands (and RNDIS), mass storage CB/CBI, and some other&n; * protocols do use them.&n; */
r_static
r_int
DECL|function|read_ep0_fifo
id|read_ep0_fifo
(paren
r_struct
id|pxa2xx_ep
op_star
id|ep
comma
r_struct
id|pxa2xx_request
op_star
id|req
)paren
(brace
id|u8
op_star
id|buf
comma
id|byte
suffix:semicolon
r_int
id|bufferspace
suffix:semicolon
id|buf
op_assign
id|req-&gt;req.buf
op_plus
id|req-&gt;req.actual
suffix:semicolon
id|bufferspace
op_assign
id|req-&gt;req.length
op_minus
id|req-&gt;req.actual
suffix:semicolon
r_while
c_loop
(paren
id|UDCCS0
op_amp
id|UDCCS0_RNE
)paren
(brace
id|byte
op_assign
(paren
id|u8
)paren
id|UDDR0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|bufferspace
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* this happens when the driver&squot;s buffer&n;&t;&t;&t; * is smaller than what the host sent.&n;&t;&t;&t; * discard the extra data.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|req-&gt;req.status
op_ne
op_minus
id|EOVERFLOW
)paren
id|DMSG
c_func
(paren
l_string|&quot;%s overflow&bslash;n&quot;
comma
id|ep-&gt;ep.name
)paren
suffix:semicolon
id|req-&gt;req.status
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
)brace
r_else
(brace
op_star
id|buf
op_increment
op_assign
id|byte
suffix:semicolon
id|req-&gt;req.actual
op_increment
suffix:semicolon
id|bufferspace
op_decrement
suffix:semicolon
)brace
)brace
id|UDCCS0
op_assign
id|UDCCS0_OPR
op_or
id|UDCCS0_IPR
suffix:semicolon
multiline_comment|/* completion */
r_if
c_cond
(paren
id|req-&gt;req.actual
op_ge
id|req-&gt;req.length
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* finished that packet.  the next one may be waiting... */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef&t;USE_DMA
DECL|macro|MAX_IN_DMA
mdefine_line|#define&t;MAX_IN_DMA&t;((DCMD_LENGTH + 1) - BULK_FIFO_SIZE)
r_static
r_void
DECL|function|start_dma_nodesc
id|start_dma_nodesc
c_func
(paren
r_struct
id|pxa2xx_ep
op_star
id|ep
comma
r_struct
id|pxa2xx_request
op_star
id|req
comma
r_int
id|is_in
)paren
(brace
id|u32
id|dcmd
op_assign
id|req-&gt;req.length
suffix:semicolon
id|u32
id|buf
op_assign
id|req-&gt;req.dma
suffix:semicolon
id|u32
id|fifo
op_assign
id|io_v2p
(paren
(paren
id|u32
)paren
id|ep-&gt;reg_uddr
)paren
suffix:semicolon
multiline_comment|/* caller guarantees there&squot;s a packet or more remaining&n;&t; *  - IN may end with a short packet (TSP set separately),&n;&t; *  - OUT is always full length&n;&t; */
id|buf
op_add_assign
id|req-&gt;req.actual
suffix:semicolon
id|dcmd
op_sub_assign
id|req-&gt;req.actual
suffix:semicolon
id|ep-&gt;dma_fixup
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no-descriptor mode can be simple for bulk-in, iso-in, iso-out */
id|DCSR
c_func
(paren
id|ep-&gt;dma
)paren
op_assign
id|DCSR_NODESC
suffix:semicolon
r_if
c_cond
(paren
id|is_in
)paren
(brace
id|DSADR
c_func
(paren
id|ep-&gt;dma
)paren
op_assign
id|buf
suffix:semicolon
id|DTADR
c_func
(paren
id|ep-&gt;dma
)paren
op_assign
id|fifo
suffix:semicolon
r_if
c_cond
(paren
id|dcmd
OG
id|MAX_IN_DMA
)paren
id|dcmd
op_assign
id|MAX_IN_DMA
suffix:semicolon
r_else
id|ep-&gt;dma_fixup
op_assign
(paren
id|dcmd
op_mod
id|ep-&gt;ep.maxpacket
)paren
op_ne
l_int|0
suffix:semicolon
id|dcmd
op_or_assign
id|DCMD_BURST32
op_or
id|DCMD_WIDTH1
op_or
id|DCMD_FLOWTRG
op_or
id|DCMD_INCSRCADDR
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef USE_OUT_DMA
id|DSADR
c_func
(paren
id|ep-&gt;dma
)paren
op_assign
id|fifo
suffix:semicolon
id|DTADR
c_func
(paren
id|ep-&gt;dma
)paren
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;bmAttributes
op_ne
id|USB_ENDPOINT_XFER_ISOC
)paren
id|dcmd
op_assign
id|ep-&gt;ep.maxpacket
suffix:semicolon
id|dcmd
op_or_assign
id|DCMD_BURST32
op_or
id|DCMD_WIDTH1
op_or
id|DCMD_FLOWSRC
op_or
id|DCMD_INCTRGADDR
suffix:semicolon
macro_line|#endif
)brace
id|DCMD
c_func
(paren
id|ep-&gt;dma
)paren
op_assign
id|dcmd
suffix:semicolon
id|DCSR
c_func
(paren
id|ep-&gt;dma
)paren
op_assign
id|DCSR_RUN
op_or
id|DCSR_NODESC
op_or
(paren
id|unlikely
c_func
(paren
id|is_in
)paren
ques
c_cond
id|DCSR_STOPIRQEN
multiline_comment|/* use dma_nodesc_handler() */
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* use handle_ep() */
)brace
DECL|function|kick_dma
r_static
r_void
id|kick_dma
c_func
(paren
r_struct
id|pxa2xx_ep
op_star
id|ep
comma
r_struct
id|pxa2xx_request
op_star
id|req
)paren
(brace
r_int
id|is_in
op_assign
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
suffix:semicolon
r_if
c_cond
(paren
id|is_in
)paren
(brace
multiline_comment|/* unaligned tx buffers and zlps only work with PIO */
r_if
c_cond
(paren
(paren
id|req-&gt;req.dma
op_amp
l_int|0x0f
)paren
op_ne
l_int|0
op_logical_or
id|unlikely
c_func
(paren
(paren
id|req-&gt;req.length
op_minus
id|req-&gt;req.actual
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|pio_irq_enable
c_func
(paren
id|ep-&gt;bEndpointAddress
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|ep-&gt;reg_udccs
op_amp
id|UDCCS_BI_TFS
)paren
op_ne
l_int|0
)paren
(paren
r_void
)paren
id|write_fifo
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
)brace
r_else
(brace
id|start_dma_nodesc
c_func
(paren
id|ep
comma
id|req
comma
id|USB_DIR_IN
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|req-&gt;req.length
op_minus
id|req-&gt;req.actual
)paren
OL
id|ep-&gt;ep.maxpacket
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s short dma read...&bslash;n&quot;
comma
id|ep-&gt;ep.name
)paren
suffix:semicolon
multiline_comment|/* we&squot;re always set up for pio out */
id|read_fifo
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|ep-&gt;reg_udccs
op_assign
id|UDCCS_BO_DME
op_or
(paren
op_star
id|ep-&gt;reg_udccs
op_amp
id|UDCCS_BO_FST
)paren
suffix:semicolon
id|start_dma_nodesc
c_func
(paren
id|ep
comma
id|req
comma
id|USB_DIR_OUT
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|cancel_dma
r_static
r_void
id|cancel_dma
c_func
(paren
r_struct
id|pxa2xx_ep
op_star
id|ep
)paren
(brace
r_struct
id|pxa2xx_request
op_star
id|req
suffix:semicolon
id|u32
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|DCSR
c_func
(paren
id|ep-&gt;dma
)paren
op_eq
l_int|0
op_logical_or
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
r_return
suffix:semicolon
id|DCSR
c_func
(paren
id|ep-&gt;dma
)paren
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|DCSR
c_func
(paren
id|ep-&gt;dma
)paren
op_amp
id|DCSR_STOPSTATE
)paren
op_eq
l_int|0
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
id|req
op_assign
id|list_entry
c_func
(paren
id|ep-&gt;queue.next
comma
r_struct
id|pxa2xx_request
comma
id|queue
)paren
suffix:semicolon
id|tmp
op_assign
id|DCMD
c_func
(paren
id|ep-&gt;dma
)paren
op_amp
id|DCMD_LENGTH
suffix:semicolon
id|req-&gt;req.actual
op_assign
id|req-&gt;req.length
op_minus
(paren
id|tmp
op_amp
id|DCMD_LENGTH
)paren
suffix:semicolon
multiline_comment|/* the last tx packet may be incomplete, so flush the fifo.&n;&t; * FIXME correct req.actual if we can&n;&t; */
r_if
c_cond
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
op_star
id|ep-&gt;reg_udccs
op_assign
id|UDCCS_BI_FTF
suffix:semicolon
)brace
multiline_comment|/* dma channel stopped ... normal tx end (IN), or on error (IN/OUT) */
DECL|function|dma_nodesc_handler
r_static
r_void
id|dma_nodesc_handler
c_func
(paren
r_int
id|dmach
comma
r_void
op_star
id|_ep
comma
r_struct
id|pt_regs
op_star
id|r
)paren
(brace
r_struct
id|pxa2xx_ep
op_star
id|ep
op_assign
id|_ep
suffix:semicolon
r_struct
id|pxa2xx_request
op_star
id|req
suffix:semicolon
id|u32
id|tmp
comma
id|completed
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|req
op_assign
id|list_entry
c_func
(paren
id|ep-&gt;queue.next
comma
r_struct
id|pxa2xx_request
comma
id|queue
)paren
suffix:semicolon
id|ep-&gt;dma_irqs
op_increment
suffix:semicolon
id|ep-&gt;dev-&gt;stats.irqs
op_increment
suffix:semicolon
id|HEX_DISPLAY
c_func
(paren
id|ep-&gt;dev-&gt;stats.irqs
)paren
suffix:semicolon
multiline_comment|/* ack/clear */
id|tmp
op_assign
id|DCSR
c_func
(paren
id|ep-&gt;dma
)paren
suffix:semicolon
id|DCSR
c_func
(paren
id|ep-&gt;dma
)paren
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|DCSR_STOPSTATE
)paren
op_eq
l_int|0
op_logical_or
(paren
id|DDADR
c_func
(paren
id|ep-&gt;dma
)paren
op_amp
id|DDADR_STOP
)paren
op_ne
l_int|0
)paren
(brace
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;%s, dcsr %08x ddadr %08x&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|DCSR
c_func
(paren
id|ep-&gt;dma
)paren
comma
id|DDADR
c_func
(paren
id|ep-&gt;dma
)paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|DCSR
c_func
(paren
id|ep-&gt;dma
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear DCSR_STOPSTATE */
multiline_comment|/* update transfer status */
id|completed
op_assign
id|tmp
op_amp
id|DCSR_BUSERR
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
id|tmp
op_assign
id|DSADR
c_func
(paren
id|ep-&gt;dma
)paren
suffix:semicolon
r_else
id|tmp
op_assign
id|DTADR
c_func
(paren
id|ep-&gt;dma
)paren
suffix:semicolon
id|req-&gt;req.actual
op_assign
id|tmp
op_minus
id|req-&gt;req.dma
suffix:semicolon
multiline_comment|/* FIXME seems we sometimes see partial transfers... */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|completed
op_ne
l_int|0
)paren
)paren
id|req-&gt;req.status
op_assign
op_minus
id|EIO
suffix:semicolon
r_else
r_if
c_cond
(paren
id|req-&gt;req.actual
)paren
(brace
multiline_comment|/* these registers have zeroes in low bits; they miscount&n;&t;&t; * some (end-of-transfer) short packets:  tx 14 as tx 12&n;&t;&t; */
r_if
c_cond
(paren
id|ep-&gt;dma_fixup
)paren
id|req-&gt;req.actual
op_assign
id|min
c_func
(paren
id|req-&gt;req.actual
op_plus
l_int|3
comma
id|req-&gt;req.length
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|req-&gt;req.length
op_minus
id|req-&gt;req.actual
)paren
suffix:semicolon
id|completed
op_assign
(paren
id|tmp
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|completed
op_logical_and
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
)paren
(brace
multiline_comment|/* maybe validate final short packet ... */
r_if
c_cond
(paren
(paren
id|req-&gt;req.actual
op_mod
id|ep-&gt;ep.maxpacket
)paren
op_ne
l_int|0
)paren
op_star
id|ep-&gt;reg_udccs
op_assign
id|UDCCS_BI_TSP
multiline_comment|/*|UDCCS_BI_TPC*/
suffix:semicolon
multiline_comment|/* ... or zlp, using pio fallback */
r_else
r_if
c_cond
(paren
id|ep-&gt;bmAttributes
op_eq
id|USB_ENDPOINT_XFER_BULK
op_logical_and
id|req-&gt;req.zero
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s zlp terminate ...&bslash;n&quot;
comma
id|ep-&gt;ep.name
)paren
suffix:semicolon
id|completed
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|completed
)paren
)paren
(brace
id|done
c_func
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* maybe re-activate after completion */
r_if
c_cond
(paren
id|ep-&gt;stopped
op_logical_or
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
r_goto
id|done
suffix:semicolon
id|req
op_assign
id|list_entry
c_func
(paren
id|ep-&gt;queue.next
comma
r_struct
id|pxa2xx_request
comma
id|queue
)paren
suffix:semicolon
)brace
id|kick_dma
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
id|done
suffix:colon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_int
DECL|function|pxa2xx_ep_queue
id|pxa2xx_ep_queue
c_func
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_struct
id|usb_request
op_star
id|_req
comma
r_int
id|gfp_flags
)paren
(brace
r_struct
id|pxa2xx_request
op_star
id|req
suffix:semicolon
r_struct
id|pxa2xx_ep
op_star
id|ep
suffix:semicolon
r_struct
id|pxa2xx_udc
op_star
id|dev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|req
op_assign
id|container_of
c_func
(paren
id|_req
comma
r_struct
id|pxa2xx_request
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|_req
op_logical_or
op_logical_neg
id|_req-&gt;complete
op_logical_or
op_logical_neg
id|_req-&gt;buf
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|req-&gt;queue
)paren
)paren
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s, bad params&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ep
op_assign
id|container_of
c_func
(paren
id|_ep
comma
r_struct
id|pxa2xx_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|_ep
op_logical_or
(paren
op_logical_neg
id|ep-&gt;desc
op_logical_and
id|ep-&gt;ep.name
op_ne
id|ep0name
)paren
)paren
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s, bad ep&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev
op_assign
id|ep-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|dev-&gt;driver
op_logical_or
id|dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s, bogus device state&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|ESHUTDOWN
suffix:semicolon
)brace
multiline_comment|/* iso is always one packet per request, that&squot;s the only way&n;&t; * we can report per-packet status.  that also helps with dma.&n;&t; */
r_if
c_cond
(paren
id|unlikely
(paren
id|ep-&gt;bmAttributes
op_eq
id|USB_ENDPOINT_XFER_ISOC
op_logical_and
id|req-&gt;req.length
OG
id|le16_to_cpu
(paren
id|ep-&gt;desc-&gt;wMaxPacketSize
)paren
)paren
)paren
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
macro_line|#ifdef&t;USE_DMA
singleline_comment|// FIXME caller may already have done the dma mapping
r_if
c_cond
(paren
id|ep-&gt;dma
op_ge
l_int|0
)paren
(brace
id|_req-&gt;dma
op_assign
id|dma_map_single
c_func
(paren
id|dev-&gt;dev
comma
id|_req-&gt;buf
comma
id|_req-&gt;length
comma
(paren
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
op_ne
l_int|0
)paren
ques
c_cond
id|DMA_TO_DEVICE
suffix:colon
id|DMA_FROM_DEVICE
)paren
suffix:semicolon
)brace
macro_line|#endif
id|DBG
c_func
(paren
id|DBG_NOISY
comma
l_string|&quot;%s queue req %p, len %d buf %p&bslash;n&quot;
comma
id|_ep-&gt;name
comma
id|_req
comma
id|_req-&gt;length
comma
id|_req-&gt;buf
)paren
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|_req-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
id|_req-&gt;actual
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* kickstart this i/o queue? */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
op_logical_and
op_logical_neg
id|ep-&gt;stopped
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;desc
op_eq
l_int|0
multiline_comment|/* ep0 */
)paren
(brace
r_int
id|length
op_assign
id|_req-&gt;length
suffix:semicolon
r_switch
c_cond
(paren
id|dev-&gt;ep0state
)paren
(brace
r_case
id|EP0_IN_DATA_PHASE
suffix:colon
id|dev-&gt;stats.write.ops
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|write_ep0_fifo
c_func
(paren
id|ep
comma
id|req
)paren
)paren
id|req
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EP0_OUT_DATA_PHASE
suffix:colon
id|dev-&gt;stats.read.ops
op_increment
suffix:semicolon
multiline_comment|/* messy ... */
r_if
c_cond
(paren
id|dev-&gt;req_config
)paren
(brace
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;ep0 config ack%s&bslash;n&quot;
comma
id|dev-&gt;has_cfr
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; raced&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;has_cfr
)paren
id|UDCCFR
op_assign
id|UDCCFR_AREN
op_or
id|UDCCFR_ACM
suffix:semicolon
id|done
c_func
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;ep0state
op_assign
id|EP0_END_XFER
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;req_pending
)paren
id|ep0start
c_func
(paren
id|dev
comma
id|UDCCS0_IPR
comma
l_string|&quot;OUT&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
op_eq
l_int|0
op_logical_or
(paren
(paren
id|UDCCS0
op_amp
id|UDCCS0_RNE
)paren
op_ne
l_int|0
op_logical_and
id|read_ep0_fifo
c_func
(paren
id|ep
comma
id|req
)paren
)paren
)paren
(brace
id|ep0_idle
c_func
(paren
id|dev
)paren
suffix:semicolon
id|done
c_func
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
id|req
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|DMSG
c_func
(paren
l_string|&quot;ep0 i/o, odd state %d&bslash;n&quot;
comma
id|dev-&gt;ep0state
)paren
suffix:semicolon
id|local_irq_restore
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EL2HLT
suffix:semicolon
)brace
macro_line|#ifdef&t;USE_DMA
multiline_comment|/* either start dma or prime pio pump */
)brace
r_else
r_if
c_cond
(paren
id|ep-&gt;dma
op_ge
l_int|0
)paren
(brace
id|kick_dma
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* can the FIFO can satisfy the request immediately? */
)brace
r_else
r_if
c_cond
(paren
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
op_ne
l_int|0
op_logical_and
(paren
op_star
id|ep-&gt;reg_udccs
op_amp
id|UDCCS_BI_TFS
)paren
op_ne
l_int|0
op_logical_and
id|write_fifo
c_func
(paren
id|ep
comma
id|req
)paren
)paren
(brace
id|req
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
id|ep-&gt;reg_udccs
op_amp
id|UDCCS_BO_RFS
)paren
op_ne
l_int|0
op_logical_and
id|read_fifo
c_func
(paren
id|ep
comma
id|req
)paren
)paren
(brace
id|req
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
(paren
id|req
op_logical_and
id|ep-&gt;desc
)paren
op_logical_and
id|ep-&gt;dma
OL
l_int|0
)paren
id|pio_irq_enable
c_func
(paren
id|ep-&gt;bEndpointAddress
)paren
suffix:semicolon
)brace
multiline_comment|/* pio or dma irq handler advances the queue. */
r_if
c_cond
(paren
id|likely
(paren
id|req
op_ne
l_int|0
)paren
)paren
id|list_add_tail
c_func
(paren
op_amp
id|req-&gt;queue
comma
op_amp
id|ep-&gt;queue
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;nuke - dequeue ALL requests&n; */
DECL|function|nuke
r_static
r_void
id|nuke
c_func
(paren
r_struct
id|pxa2xx_ep
op_star
id|ep
comma
r_int
id|status
)paren
(brace
r_struct
id|pxa2xx_request
op_star
id|req
suffix:semicolon
multiline_comment|/* called with irqs blocked */
macro_line|#ifdef&t;USE_DMA
r_if
c_cond
(paren
id|ep-&gt;dma
op_ge
l_int|0
op_logical_and
op_logical_neg
id|ep-&gt;stopped
)paren
id|cancel_dma
c_func
(paren
id|ep
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
(brace
id|req
op_assign
id|list_entry
c_func
(paren
id|ep-&gt;queue.next
comma
r_struct
id|pxa2xx_request
comma
id|queue
)paren
suffix:semicolon
id|done
c_func
(paren
id|ep
comma
id|req
comma
id|status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ep-&gt;desc
)paren
id|pio_irq_disable
(paren
id|ep-&gt;bEndpointAddress
)paren
suffix:semicolon
)brace
multiline_comment|/* dequeue JUST ONE request */
DECL|function|pxa2xx_ep_dequeue
r_static
r_int
id|pxa2xx_ep_dequeue
c_func
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_struct
id|usb_request
op_star
id|_req
)paren
(brace
r_struct
id|pxa2xx_ep
op_star
id|ep
suffix:semicolon
r_struct
id|pxa2xx_request
op_star
id|req
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ep
op_assign
id|container_of
c_func
(paren
id|_ep
comma
r_struct
id|pxa2xx_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
id|ep-&gt;ep.name
op_eq
id|ep0name
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* make sure it&squot;s actually queued on this endpoint */
id|list_for_each_entry
(paren
id|req
comma
op_amp
id|ep-&gt;queue
comma
id|queue
)paren
(brace
r_if
c_cond
(paren
op_amp
id|req-&gt;req
op_eq
id|_req
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_amp
id|req-&gt;req
op_ne
id|_req
)paren
(brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef&t;USE_DMA
r_if
c_cond
(paren
id|ep-&gt;dma
op_ge
l_int|0
op_logical_and
id|ep-&gt;queue.next
op_eq
op_amp
id|req-&gt;queue
op_logical_and
op_logical_neg
id|ep-&gt;stopped
)paren
(brace
id|cancel_dma
c_func
(paren
id|ep
)paren
suffix:semicolon
id|done
c_func
(paren
id|ep
comma
id|req
comma
op_minus
id|ECONNRESET
)paren
suffix:semicolon
multiline_comment|/* restart i/o */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
(brace
id|req
op_assign
id|list_entry
c_func
(paren
id|ep-&gt;queue.next
comma
r_struct
id|pxa2xx_request
comma
id|queue
)paren
suffix:semicolon
id|kick_dma
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif
id|done
c_func
(paren
id|ep
comma
id|req
comma
op_minus
id|ECONNRESET
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|pxa2xx_ep_set_halt
r_static
r_int
id|pxa2xx_ep_set_halt
c_func
(paren
r_struct
id|usb_ep
op_star
id|_ep
comma
r_int
id|value
)paren
(brace
r_struct
id|pxa2xx_ep
op_star
id|ep
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ep
op_assign
id|container_of
c_func
(paren
id|_ep
comma
r_struct
id|pxa2xx_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|_ep
op_logical_or
(paren
op_logical_neg
id|ep-&gt;desc
op_logical_and
id|ep-&gt;ep.name
op_ne
id|ep0name
)paren
)paren
op_logical_or
id|ep-&gt;bmAttributes
op_eq
id|USB_ENDPOINT_XFER_ISOC
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s, bad ep&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|value
op_eq
l_int|0
)paren
(brace
multiline_comment|/* this path (reset toggle+halt) is needed to implement&n;&t;&t; * SET_INTERFACE on normal hardware.  but it can&squot;t be&n;&t;&t; * done from software on the PXA UDC, and the hardware&n;&t;&t; * forgets to do it as part of SET_INTERFACE automagic.&n;&t;&t; */
id|DMSG
c_func
(paren
l_string|&quot;only host can clear %s halt&bslash;n&quot;
comma
id|_ep-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
op_ne
l_int|0
op_logical_and
(paren
(paren
op_star
id|ep-&gt;reg_udccs
op_amp
id|UDCCS_BI_TFS
)paren
op_eq
l_int|0
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
)paren
(brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* FST bit is the same for control, bulk in, bulk out, interrupt in */
op_star
id|ep-&gt;reg_udccs
op_assign
id|UDCCS_BI_FST
op_or
id|UDCCS_BI_FTF
suffix:semicolon
multiline_comment|/* ep0 needs special care */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;desc
)paren
(brace
id|start_watchdog
c_func
(paren
id|ep-&gt;dev
)paren
suffix:semicolon
id|ep-&gt;dev-&gt;req_pending
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;dev-&gt;ep0state
op_assign
id|EP0_STALL
suffix:semicolon
id|LED_EP0_OFF
suffix:semicolon
multiline_comment|/* and bulk/intr endpoints like dropping stalls too */
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_add_assign
l_int|20
)paren
(brace
r_if
c_cond
(paren
op_star
id|ep-&gt;reg_udccs
op_amp
id|UDCCS_BI_SST
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
)brace
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;%s halt&bslash;n&quot;
comma
id|_ep-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pxa2xx_ep_fifo_status
r_static
r_int
id|pxa2xx_ep_fifo_status
c_func
(paren
r_struct
id|usb_ep
op_star
id|_ep
)paren
(brace
r_struct
id|pxa2xx_ep
op_star
id|ep
suffix:semicolon
id|ep
op_assign
id|container_of
c_func
(paren
id|_ep
comma
r_struct
id|pxa2xx_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s, bad ep&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* pxa can&squot;t report unclaimed bytes from IN fifos */
r_if
c_cond
(paren
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
op_logical_or
(paren
op_star
id|ep-&gt;reg_udccs
op_amp
id|UDCCS_BO_RFS
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
(paren
op_star
id|ep-&gt;reg_ubcr
op_amp
l_int|0xfff
)paren
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|pxa2xx_ep_fifo_flush
r_static
r_void
id|pxa2xx_ep_fifo_flush
c_func
(paren
r_struct
id|usb_ep
op_star
id|_ep
)paren
(brace
r_struct
id|pxa2xx_ep
op_star
id|ep
suffix:semicolon
id|ep
op_assign
id|container_of
c_func
(paren
id|_ep
comma
r_struct
id|pxa2xx_ep
comma
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_ep
op_logical_or
id|ep-&gt;ep.name
op_eq
id|ep0name
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s, bad ep&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* toggle and halt bits stay unchanged */
multiline_comment|/* for OUT, just read and discard the FIFO contents. */
r_if
c_cond
(paren
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
op_eq
l_int|0
)paren
(brace
r_while
c_loop
(paren
(paren
(paren
op_star
id|ep-&gt;reg_udccs
)paren
op_amp
id|UDCCS_BO_RNE
)paren
op_ne
l_int|0
)paren
(paren
r_void
)paren
op_star
id|ep-&gt;reg_uddr
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* most IN status is the same, but ISO can&squot;t stall */
op_star
id|ep-&gt;reg_udccs
op_assign
id|UDCCS_BI_TPC
op_or
id|UDCCS_BI_FTF
op_or
id|UDCCS_BI_TUR
op_or
(paren
id|ep-&gt;bmAttributes
op_eq
id|USB_ENDPOINT_XFER_ISOC
)paren
ques
c_cond
l_int|0
suffix:colon
id|UDCCS_BI_SST
suffix:semicolon
)brace
DECL|variable|pxa2xx_ep_ops
r_static
r_struct
id|usb_ep_ops
id|pxa2xx_ep_ops
op_assign
(brace
dot
id|enable
op_assign
id|pxa2xx_ep_enable
comma
dot
id|disable
op_assign
id|pxa2xx_ep_disable
comma
dot
id|alloc_request
op_assign
id|pxa2xx_ep_alloc_request
comma
dot
id|free_request
op_assign
id|pxa2xx_ep_free_request
comma
dot
id|alloc_buffer
op_assign
id|pxa2xx_ep_alloc_buffer
comma
dot
id|free_buffer
op_assign
id|pxa2xx_ep_free_buffer
comma
dot
id|queue
op_assign
id|pxa2xx_ep_queue
comma
dot
id|dequeue
op_assign
id|pxa2xx_ep_dequeue
comma
dot
id|set_halt
op_assign
id|pxa2xx_ep_set_halt
comma
dot
id|fifo_status
op_assign
id|pxa2xx_ep_fifo_status
comma
dot
id|fifo_flush
op_assign
id|pxa2xx_ep_fifo_flush
comma
)brace
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------------------------&n; * &t;device-scoped parts of the api to the usb controller hardware&n; * ---------------------------------------------------------------------------&n; */
DECL|function|pxa2xx_udc_get_frame
r_static
r_int
id|pxa2xx_udc_get_frame
c_func
(paren
r_struct
id|usb_gadget
op_star
id|_gadget
)paren
(brace
r_return
(paren
(paren
id|UFNRH
op_amp
l_int|0x07
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|UFNRL
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
DECL|function|pxa2xx_udc_wakeup
r_static
r_int
id|pxa2xx_udc_wakeup
c_func
(paren
r_struct
id|usb_gadget
op_star
id|_gadget
)paren
(brace
multiline_comment|/* host may not have enabled remote wakeup */
r_if
c_cond
(paren
(paren
id|UDCCS0
op_amp
id|UDCCS0_DRWF
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
id|udc_set_mask_UDCCR
c_func
(paren
id|UDCCR_RSM
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pxa2xx_udc_ops
r_static
r_const
r_struct
id|usb_gadget_ops
id|pxa2xx_udc_ops
op_assign
(brace
dot
id|get_frame
op_assign
id|pxa2xx_udc_get_frame
comma
dot
id|wakeup
op_assign
id|pxa2xx_udc_wakeup
comma
singleline_comment|// current versions must always be self-powered
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#ifdef UDC_PROC_FILE
DECL|variable|proc_node_name
r_static
r_const
r_char
id|proc_node_name
(braket
)braket
op_assign
l_string|&quot;driver/udc&quot;
suffix:semicolon
r_static
r_int
DECL|function|udc_proc_read
id|udc_proc_read
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|_dev
)paren
(brace
r_char
op_star
id|buf
op_assign
id|page
suffix:semicolon
r_struct
id|pxa2xx_udc
op_star
id|dev
op_assign
id|_dev
suffix:semicolon
r_char
op_star
id|next
op_assign
id|buf
suffix:semicolon
r_int
id|size
op_assign
id|count
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
comma
id|t
suffix:semicolon
id|u32
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* basic device status */
id|t
op_assign
id|scnprintf
c_func
(paren
id|next
comma
id|size
comma
id|DRIVER_DESC
l_string|&quot;&bslash;n&quot;
l_string|&quot;%s version: %s&bslash;nGadget driver: %s&bslash;nHost %s&bslash;n&bslash;n&quot;
comma
id|driver_name
comma
id|DRIVER_VERSION
id|SIZE_STR
id|DMASTR
comma
id|dev-&gt;driver
ques
c_cond
id|dev-&gt;driver-&gt;driver.name
suffix:colon
l_string|&quot;(none)&quot;
comma
id|is_usb_connected
c_func
(paren
)paren
ques
c_cond
l_string|&quot;full speed&quot;
suffix:colon
l_string|&quot;disconnected&quot;
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
multiline_comment|/* registers for device and ep0 */
id|t
op_assign
id|scnprintf
c_func
(paren
id|next
comma
id|size
comma
l_string|&quot;uicr %02X.%02X, usir %02X.%02x, ufnr %02X.%02X&bslash;n&quot;
comma
id|UICR1
comma
id|UICR0
comma
id|USIR1
comma
id|USIR0
comma
id|UFNRH
comma
id|UFNRL
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
id|tmp
op_assign
id|UDCCR
suffix:semicolon
id|t
op_assign
id|scnprintf
c_func
(paren
id|next
comma
id|size
comma
l_string|&quot;udccr %02X =%s%s%s%s%s%s%s%s&bslash;n&quot;
comma
id|tmp
comma
(paren
id|tmp
op_amp
id|UDCCR_REM
)paren
ques
c_cond
l_string|&quot; rem&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCR_RSTIR
)paren
ques
c_cond
l_string|&quot; rstir&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCR_SRM
)paren
ques
c_cond
l_string|&quot; srm&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCR_SUSIR
)paren
ques
c_cond
l_string|&quot; susir&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCR_RESIR
)paren
ques
c_cond
l_string|&quot; resir&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCR_RSM
)paren
ques
c_cond
l_string|&quot; rsm&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCR_UDA
)paren
ques
c_cond
l_string|&quot; uda&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCR_UDE
)paren
ques
c_cond
l_string|&quot; ude&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
id|tmp
op_assign
id|UDCCS0
suffix:semicolon
id|t
op_assign
id|scnprintf
c_func
(paren
id|next
comma
id|size
comma
l_string|&quot;udccs0 %02X =%s%s%s%s%s%s%s%s&bslash;n&quot;
comma
id|tmp
comma
(paren
id|tmp
op_amp
id|UDCCS0_SA
)paren
ques
c_cond
l_string|&quot; sa&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCS0_RNE
)paren
ques
c_cond
l_string|&quot; rne&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCS0_FST
)paren
ques
c_cond
l_string|&quot; fst&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCS0_SST
)paren
ques
c_cond
l_string|&quot; sst&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCS0_DRWF
)paren
ques
c_cond
l_string|&quot; dwrf&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCS0_FTF
)paren
ques
c_cond
l_string|&quot; ftf&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCS0_IPR
)paren
ques
c_cond
l_string|&quot; ipr&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCS0_OPR
)paren
ques
c_cond
l_string|&quot; opr&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;has_cfr
)paren
(brace
id|tmp
op_assign
id|UDCCFR
suffix:semicolon
id|t
op_assign
id|scnprintf
c_func
(paren
id|next
comma
id|size
comma
l_string|&quot;udccfr %02X =%s%s&bslash;n&quot;
comma
id|tmp
comma
(paren
id|tmp
op_amp
id|UDCCFR_AREN
)paren
ques
c_cond
l_string|&quot; aren&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tmp
op_amp
id|UDCCFR_ACM
)paren
ques
c_cond
l_string|&quot; acm&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_usb_connected
c_func
(paren
)paren
op_logical_or
op_logical_neg
id|dev-&gt;driver
)paren
r_goto
id|done
suffix:semicolon
id|t
op_assign
id|scnprintf
c_func
(paren
id|next
comma
id|size
comma
l_string|&quot;ep0 IN %lu/%lu, OUT %lu/%lu&bslash;nirqs %lu&bslash;n&bslash;n&quot;
comma
id|dev-&gt;stats.write.bytes
comma
id|dev-&gt;stats.write.ops
comma
id|dev-&gt;stats.read.bytes
comma
id|dev-&gt;stats.read.ops
comma
id|dev-&gt;stats.irqs
)paren
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
multiline_comment|/* dump endpoint queues */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PXA_UDC_NUM_ENDPOINTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|pxa2xx_ep
op_star
id|ep
op_assign
op_amp
id|dev-&gt;ep
(braket
id|i
)braket
suffix:semicolon
r_struct
id|pxa2xx_request
op_star
id|req
suffix:semicolon
r_int
id|t
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
l_int|0
)paren
(brace
r_const
r_struct
id|usb_endpoint_descriptor
op_star
id|d
suffix:semicolon
id|d
op_assign
id|ep-&gt;desc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d
)paren
r_continue
suffix:semicolon
id|tmp
op_assign
op_star
id|dev-&gt;ep
(braket
id|i
)braket
dot
id|reg_udccs
suffix:semicolon
id|t
op_assign
id|scnprintf
c_func
(paren
id|next
comma
id|size
comma
l_string|&quot;%s max %d %s udccs %02x irqs %lu/%lu&bslash;n&quot;
comma
id|ep-&gt;ep.name
comma
id|le16_to_cpu
(paren
id|d-&gt;wMaxPacketSize
)paren
comma
(paren
id|ep-&gt;dma
op_ge
l_int|0
)paren
ques
c_cond
l_string|&quot;dma&quot;
suffix:colon
l_string|&quot;pio&quot;
comma
id|tmp
comma
id|ep-&gt;pio_irqs
comma
id|ep-&gt;dma_irqs
)paren
suffix:semicolon
multiline_comment|/* TODO translate all five groups of udccs bits! */
)brace
r_else
multiline_comment|/* ep0 should only have one transfer queued */
id|t
op_assign
id|scnprintf
c_func
(paren
id|next
comma
id|size
comma
l_string|&quot;ep0 max 16 pio irqs %lu&bslash;n&quot;
comma
id|ep-&gt;pio_irqs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_le
l_int|0
op_logical_or
id|t
OG
id|size
)paren
r_goto
id|done
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
(brace
id|t
op_assign
id|scnprintf
c_func
(paren
id|next
comma
id|size
comma
l_string|&quot;&bslash;t(nothing queued)&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_le
l_int|0
op_logical_or
id|t
OG
id|size
)paren
r_goto
id|done
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|list_for_each_entry
c_func
(paren
id|req
comma
op_amp
id|ep-&gt;queue
comma
id|queue
)paren
(brace
macro_line|#ifdef&t;USE_DMA
r_if
c_cond
(paren
id|ep-&gt;dma
op_ge
l_int|0
op_logical_and
id|req-&gt;queue.prev
op_eq
op_amp
id|ep-&gt;queue
)paren
id|t
op_assign
id|scnprintf
c_func
(paren
id|next
comma
id|size
comma
l_string|&quot;&bslash;treq %p len %d/%d &quot;
l_string|&quot;buf %p (dma%d dcmd %08x)&bslash;n&quot;
comma
op_amp
id|req-&gt;req
comma
id|req-&gt;req.actual
comma
id|req-&gt;req.length
comma
id|req-&gt;req.buf
comma
id|ep-&gt;dma
comma
id|DCMD
c_func
(paren
id|ep-&gt;dma
)paren
singleline_comment|// low 13 bits == bytes-to-go
)paren
suffix:semicolon
r_else
macro_line|#endif
id|t
op_assign
id|scnprintf
c_func
(paren
id|next
comma
id|size
comma
l_string|&quot;&bslash;treq %p len %d/%d buf %p&bslash;n&quot;
comma
op_amp
id|req-&gt;req
comma
id|req-&gt;req.actual
comma
id|req-&gt;req.length
comma
id|req-&gt;req.buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_le
l_int|0
op_logical_or
id|t
OG
id|size
)paren
r_goto
id|done
suffix:semicolon
id|size
op_sub_assign
id|t
suffix:semicolon
id|next
op_add_assign
id|t
suffix:semicolon
)brace
)brace
id|done
suffix:colon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|count
op_minus
id|size
suffix:semicolon
)brace
DECL|macro|create_proc_files
mdefine_line|#define create_proc_files() &bslash;&n;&t;create_proc_read_entry(proc_node_name, 0, NULL, udc_proc_read, dev)
DECL|macro|remove_proc_files
mdefine_line|#define remove_proc_files() &bslash;&n;&t;remove_proc_entry(proc_node_name, NULL)
macro_line|#else&t;/* !UDC_PROC_FILE */
DECL|macro|create_proc_files
mdefine_line|#define create_proc_files() do {} while (0)
DECL|macro|remove_proc_files
mdefine_line|#define remove_proc_files() do {} while (0)
macro_line|#endif&t;/* UDC_PROC_FILE */
multiline_comment|/* &quot;function&quot; sysfs attribute */
r_static
id|ssize_t
DECL|function|show_function
id|show_function
(paren
r_struct
id|device
op_star
id|_dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|pxa2xx_udc
op_star
id|dev
op_assign
id|dev_get_drvdata
(paren
id|_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;driver
op_logical_or
op_logical_neg
id|dev-&gt;driver-&gt;function
op_logical_or
id|strlen
(paren
id|dev-&gt;driver-&gt;function
)paren
OG
id|PAGE_SIZE
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|scnprintf
(paren
id|buf
comma
id|PAGE_SIZE
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|dev-&gt;driver-&gt;function
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
(paren
id|function
comma
id|S_IRUGO
comma
id|show_function
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * &t;udc_disable - disable USB device controller&n; */
DECL|function|udc_disable
r_static
r_void
id|udc_disable
c_func
(paren
r_struct
id|pxa2xx_udc
op_star
id|dev
)paren
(brace
multiline_comment|/* block all irqs */
id|udc_set_mask_UDCCR
c_func
(paren
id|UDCCR_SRM
op_or
id|UDCCR_REM
)paren
suffix:semicolon
id|UICR0
op_assign
id|UICR1
op_assign
l_int|0xff
suffix:semicolon
id|UFNRH
op_assign
id|UFNRH_SIM
suffix:semicolon
multiline_comment|/* if hardware supports it, disconnect from usb */
id|make_usb_disappear
c_func
(paren
)paren
suffix:semicolon
id|udc_clear_mask_UDCCR
c_func
(paren
id|UDCCR_UDE
)paren
suffix:semicolon
macro_line|#ifdef&t;CONFIG_ARCH_PXA
multiline_comment|/* Disable clock for USB device */
id|pxa_set_cken
c_func
(paren
id|CKEN11_USB
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|ep0_idle
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;gadget.speed
op_assign
id|USB_SPEED_UNKNOWN
suffix:semicolon
id|LED_CONNECTED_OFF
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;udc_reinit - initialize software state&n; */
DECL|function|udc_reinit
r_static
r_void
id|udc_reinit
c_func
(paren
r_struct
id|pxa2xx_udc
op_star
id|dev
)paren
(brace
id|u32
id|i
suffix:semicolon
multiline_comment|/* device/ep0 records init */
id|INIT_LIST_HEAD
(paren
op_amp
id|dev-&gt;gadget.ep_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|dev-&gt;gadget.ep0-&gt;ep_list
)paren
suffix:semicolon
id|dev-&gt;ep0state
op_assign
id|EP0_IDLE
suffix:semicolon
multiline_comment|/* basic endpoint records init */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PXA_UDC_NUM_ENDPOINTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|pxa2xx_ep
op_star
id|ep
op_assign
op_amp
id|dev-&gt;ep
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
l_int|0
)paren
id|list_add_tail
(paren
op_amp
id|ep-&gt;ep.ep_list
comma
op_amp
id|dev-&gt;gadget.ep_list
)paren
suffix:semicolon
id|ep-&gt;desc
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;stopped
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|ep-&gt;queue
)paren
suffix:semicolon
id|ep-&gt;pio_irqs
op_assign
id|ep-&gt;dma_irqs
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* the rest was statically initialized, and is read-only */
)brace
multiline_comment|/* until it&squot;s enabled, this UDC should be completely invisible&n; * to any USB host.&n; */
DECL|function|udc_enable
r_static
r_void
id|udc_enable
(paren
r_struct
id|pxa2xx_udc
op_star
id|dev
)paren
(brace
id|udc_clear_mask_UDCCR
c_func
(paren
id|UDCCR_UDE
)paren
suffix:semicolon
macro_line|#ifdef&t;CONFIG_ARCH_PXA
multiline_comment|/* Enable clock for USB device */
id|pxa_set_cken
c_func
(paren
id|CKEN11_USB
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* try to clear these bits before we enable the udc */
id|udc_ack_int_UDCCR
c_func
(paren
id|UDCCR_SUSIR
op_or
multiline_comment|/*UDCCR_RSTIR|*/
id|UDCCR_RESIR
)paren
suffix:semicolon
id|ep0_idle
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;gadget.speed
op_assign
id|USB_SPEED_UNKNOWN
suffix:semicolon
id|dev-&gt;stats.irqs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * sequence taken from chapter 12.5.10, PXA250 AppProcDevManual:&n;&t; * - enable UDC&n;&t; * - if RESET is already in progress, ack interrupt&n;&t; * - unmask reset interrupt&n;&t; */
id|udc_set_mask_UDCCR
c_func
(paren
id|UDCCR_UDE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|UDCCR
op_amp
id|UDCCR_UDA
)paren
)paren
id|udc_ack_int_UDCCR
c_func
(paren
id|UDCCR_RSTIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;has_cfr
multiline_comment|/* UDC_RES2 is defined */
)paren
(brace
multiline_comment|/* pxa255 (a0+) can avoid a set_config race that could&n;&t;&t; * prevent gadget drivers from configuring correctly&n;&t;&t; */
id|UDCCFR
op_assign
id|UDCCFR_ACM
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &quot;USB test mode&quot; for pxa250 errata 40-42 (stepping a0, a1)&n;&t;&t; * which could result in missing packets and interrupts.&n;&t;&t; * supposedly one bit per endpoint, controlling whether it&n;&t;&t; * double buffers or not; ACM/AREN bits fit into the holes.&n;&t;&t; * zero bits (like USIR0_IRx) disable double buffering.&n;&t;&t; */
id|UDC_RES1
op_assign
l_int|0x00
suffix:semicolon
id|UDC_RES2
op_assign
l_int|0x00
suffix:semicolon
)brace
macro_line|#ifdef&t;DISABLE_TEST_MODE
multiline_comment|/* &quot;test mode&quot; seems to have become the default in later chip&n;&t; * revs, preventing double buffering (and invalidating docs).&n;&t; * this EXPERIMENT enables it for bulk endpoints by tweaking&n;&t; * undefined/reserved register bits (that other drivers clear).&n;&t; * Belcarra code comments noted this usage.&n;&t; */
r_if
c_cond
(paren
id|fifo_mode
op_amp
l_int|1
)paren
(brace
multiline_comment|/* IN endpoints */
id|UDC_RES1
op_or_assign
id|USIR0_IR1
op_or
id|USIR0_IR6
suffix:semicolon
id|UDC_RES2
op_or_assign
id|USIR1_IR11
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fifo_mode
op_amp
l_int|2
)paren
(brace
multiline_comment|/* OUT endpoints */
id|UDC_RES1
op_or_assign
id|USIR0_IR2
op_or
id|USIR0_IR7
suffix:semicolon
id|UDC_RES2
op_or_assign
id|USIR1_IR12
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* caller must be able to sleep in order to cope&n;&t; * with startup transients.&n;&t; */
id|msleep
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* enable suspend/resume and reset irqs */
id|udc_clear_mask_UDCCR
c_func
(paren
id|UDCCR_SRM
op_or
id|UDCCR_REM
)paren
suffix:semicolon
multiline_comment|/* enable ep0 irqs */
id|UICR0
op_and_assign
op_complement
id|UICR0_IM0
suffix:semicolon
multiline_comment|/* if hardware supports it, connect to usb and wait for host */
id|let_usb_appear
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* when a driver is successfully registered, it will receive&n; * control requests including set_configuration(), which enables&n; * non-control requests.  then usb traffic follows until a&n; * disconnect is reported.  then a host may connect again, or&n; * the driver might get unbound.&n; */
DECL|function|usb_gadget_register_driver
r_int
id|usb_gadget_register_driver
c_func
(paren
r_struct
id|usb_gadget_driver
op_star
id|driver
)paren
(brace
r_struct
id|pxa2xx_udc
op_star
id|dev
op_assign
id|the_controller
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver
op_logical_or
id|driver-&gt;speed
op_ne
id|USB_SPEED_FULL
op_logical_or
op_logical_neg
id|driver-&gt;bind
op_logical_or
op_logical_neg
id|driver-&gt;unbind
op_logical_or
op_logical_neg
id|driver-&gt;disconnect
op_logical_or
op_logical_neg
id|driver-&gt;setup
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;driver
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* first hook up the driver ... */
id|dev-&gt;driver
op_assign
id|driver
suffix:semicolon
id|dev-&gt;gadget.dev.driver
op_assign
op_amp
id|driver-&gt;driver
suffix:semicolon
id|device_add
(paren
op_amp
id|dev-&gt;gadget.dev
)paren
suffix:semicolon
id|retval
op_assign
id|driver
op_member_access_from_pointer
id|bind
c_func
(paren
op_amp
id|dev-&gt;gadget
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;bind to driver %s --&gt; error %d&bslash;n&quot;
comma
id|driver-&gt;driver.name
comma
id|retval
)paren
suffix:semicolon
id|device_del
(paren
op_amp
id|dev-&gt;gadget.dev
)paren
suffix:semicolon
id|dev-&gt;driver
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;gadget.dev.driver
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|device_create_file
c_func
(paren
id|dev-&gt;dev
comma
op_amp
id|dev_attr_function
)paren
suffix:semicolon
multiline_comment|/* ... then enable host detection and ep0; and we&squot;re ready&n;&t; * for set_configuration as well as eventual disconnect.&n;&t; * NOTE:  this shouldn&squot;t power up until later.&n;&t; */
id|DMSG
c_func
(paren
l_string|&quot;registered gadget driver &squot;%s&squot;&bslash;n&quot;
comma
id|driver-&gt;driver.name
)paren
suffix:semicolon
id|udc_enable
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dump_state
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_gadget_register_driver
id|EXPORT_SYMBOL
c_func
(paren
id|usb_gadget_register_driver
)paren
suffix:semicolon
r_static
r_void
DECL|function|stop_activity
id|stop_activity
c_func
(paren
r_struct
id|pxa2xx_udc
op_star
id|dev
comma
r_struct
id|usb_gadget_driver
op_star
id|driver
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* don&squot;t disconnect drivers more than once */
r_if
c_cond
(paren
id|dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
id|driver
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;gadget.speed
op_assign
id|USB_SPEED_UNKNOWN
suffix:semicolon
multiline_comment|/* prevent new request submissions, kill any outstanding requests  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PXA_UDC_NUM_ENDPOINTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|pxa2xx_ep
op_star
id|ep
op_assign
op_amp
id|dev-&gt;ep
(braket
id|i
)braket
suffix:semicolon
id|ep-&gt;stopped
op_assign
l_int|1
suffix:semicolon
id|nuke
c_func
(paren
id|ep
comma
op_minus
id|ESHUTDOWN
)paren
suffix:semicolon
)brace
id|del_timer_sync
c_func
(paren
op_amp
id|dev-&gt;timer
)paren
suffix:semicolon
multiline_comment|/* report disconnect; the driver is already quiesced */
id|LED_CONNECTED_OFF
suffix:semicolon
r_if
c_cond
(paren
id|driver
)paren
id|driver
op_member_access_from_pointer
id|disconnect
c_func
(paren
op_amp
id|dev-&gt;gadget
)paren
suffix:semicolon
multiline_comment|/* re-init driver-visible data structures */
id|udc_reinit
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|usb_gadget_unregister_driver
r_int
id|usb_gadget_unregister_driver
c_func
(paren
r_struct
id|usb_gadget_driver
op_star
id|driver
)paren
(brace
r_struct
id|pxa2xx_udc
op_star
id|dev
op_assign
id|the_controller
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver
op_logical_or
id|driver
op_ne
id|dev-&gt;driver
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|udc_disable
c_func
(paren
id|dev
)paren
suffix:semicolon
id|stop_activity
c_func
(paren
id|dev
comma
id|driver
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|driver
op_member_access_from_pointer
id|unbind
c_func
(paren
op_amp
id|dev-&gt;gadget
)paren
suffix:semicolon
id|dev-&gt;driver
op_assign
l_int|0
suffix:semicolon
id|device_del
(paren
op_amp
id|dev-&gt;gadget.dev
)paren
suffix:semicolon
id|device_remove_file
c_func
(paren
id|dev-&gt;dev
comma
op_amp
id|dev_attr_function
)paren
suffix:semicolon
id|DMSG
c_func
(paren
l_string|&quot;unregistered gadget driver &squot;%s&squot;&bslash;n&quot;
comma
id|driver-&gt;driver.name
)paren
suffix:semicolon
id|dump_state
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_gadget_unregister_driver
id|EXPORT_SYMBOL
c_func
(paren
id|usb_gadget_unregister_driver
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#ifdef CONFIG_ARCH_LUBBOCK
multiline_comment|/* Lubbock can report connect or disconnect irqs.  Likely more hardware&n; * could support it as a timer callback.&n; *&n; * FIXME for better power management, keep the hardware powered down&n; * until a host is powering the link.  means scheduling work later&n; * in some task that can udc_enable().&n; */
DECL|macro|enable_disconnect_irq
mdefine_line|#define&t;enable_disconnect_irq() &bslash;&n;&t;if (machine_is_lubbock()) { enable_irq(LUBBOCK_USB_DISC_IRQ); }
DECL|macro|disable_disconnect_irq
mdefine_line|#define&t;disable_disconnect_irq() &bslash;&n;&t;if (machine_is_lubbock()) { disable_irq(LUBBOCK_USB_DISC_IRQ); }
r_static
id|irqreturn_t
DECL|function|usb_connection_irq
id|usb_connection_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|_dev
comma
r_struct
id|pt_regs
op_star
id|r
)paren
(brace
r_struct
id|pxa2xx_udc
op_star
id|dev
op_assign
id|_dev
suffix:semicolon
id|dev-&gt;stats.irqs
op_increment
suffix:semicolon
id|HEX_DISPLAY
c_func
(paren
id|dev-&gt;stats.irqs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_usb_connected
c_func
(paren
)paren
)paren
(brace
id|LED_CONNECTED_OFF
suffix:semicolon
id|disable_disconnect_irq
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* report disconnect just once */
r_if
c_cond
(paren
id|dev-&gt;gadget.speed
op_ne
id|USB_SPEED_UNKNOWN
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;disconnect %s&bslash;n&quot;
comma
id|dev-&gt;driver
ques
c_cond
id|dev-&gt;driver-&gt;driver.name
suffix:colon
l_int|0
)paren
suffix:semicolon
id|stop_activity
c_func
(paren
id|dev
comma
id|dev-&gt;driver
)paren
suffix:semicolon
singleline_comment|// udc_disable (dev);
singleline_comment|// no more udc irqs
singleline_comment|// maybe &quot;ACTION=disconnect /sbin/hotplug gadget&quot;.
)brace
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;gadget.speed
op_eq
id|USB_SPEED_UNKNOWN
)paren
(brace
id|LED_CONNECTED_ON
suffix:semicolon
id|DMSG
c_func
(paren
l_string|&quot;?? connect irq ??&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// if there&squot;s no driver bound, ignore; else
singleline_comment|// udc_enable (dev);
singleline_comment|// UDC irqs drive the rest.
singleline_comment|// maybe &quot;ACTION=connect /sbin/hotplug gadget&quot;.
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef&t;enable_disconnect_irq
macro_line|#warning USB disconnect() is not yet reported.
DECL|macro|enable_disconnect_irq
mdefine_line|#define&t;enable_disconnect_irq()&t;&t;do {} while (0)
DECL|macro|disable_disconnect_irq
mdefine_line|#define&t;disable_disconnect_irq()&t;do {} while (0)
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|clear_ep_state
r_static
r_inline
r_void
id|clear_ep_state
(paren
r_struct
id|pxa2xx_udc
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* hardware SET_{CONFIGURATION,INTERFACE} automagic resets endpoint&n;&t; * fifos, and pending transactions mustn&squot;t be continued in any case.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|PXA_UDC_NUM_ENDPOINTS
suffix:semicolon
id|i
op_increment
)paren
id|nuke
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
id|i
)braket
comma
op_minus
id|ECONNABORTED
)paren
suffix:semicolon
)brace
DECL|function|udc_watchdog
r_static
r_void
id|udc_watchdog
c_func
(paren
r_int
r_int
id|_dev
)paren
(brace
r_struct
id|pxa2xx_udc
op_star
id|dev
op_assign
(paren
r_void
op_star
)paren
id|_dev
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;ep0state
op_eq
id|EP0_STALL
op_logical_and
(paren
id|UDCCS0
op_amp
id|UDCCS0_FST
)paren
op_eq
l_int|0
op_logical_and
(paren
id|UDCCS0
op_amp
id|UDCCS0_SST
)paren
op_eq
l_int|0
)paren
(brace
id|UDCCS0
op_assign
id|UDCCS0_FST
op_or
id|UDCCS0_FTF
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;ep0 re-stall&bslash;n&quot;
)paren
suffix:semicolon
id|start_watchdog
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|handle_ep0
r_static
r_void
id|handle_ep0
(paren
r_struct
id|pxa2xx_udc
op_star
id|dev
)paren
(brace
id|u32
id|udccs0
op_assign
id|UDCCS0
suffix:semicolon
r_struct
id|pxa2xx_ep
op_star
id|ep
op_assign
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
suffix:semicolon
r_struct
id|pxa2xx_request
op_star
id|req
suffix:semicolon
r_union
(brace
r_struct
id|usb_ctrlrequest
id|r
suffix:semicolon
id|u8
id|raw
(braket
l_int|8
)braket
suffix:semicolon
id|u32
id|word
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|u
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
id|req
op_assign
l_int|0
suffix:semicolon
r_else
id|req
op_assign
id|list_entry
c_func
(paren
id|ep-&gt;queue.next
comma
r_struct
id|pxa2xx_request
comma
id|queue
)paren
suffix:semicolon
multiline_comment|/* clear stall status */
r_if
c_cond
(paren
id|udccs0
op_amp
id|UDCCS0_SST
)paren
(brace
id|nuke
c_func
(paren
id|ep
comma
op_minus
id|EPIPE
)paren
suffix:semicolon
id|UDCCS0
op_assign
id|UDCCS0_SST
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|dev-&gt;timer
)paren
suffix:semicolon
id|ep0_idle
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* previous request unfinished?  non-error iff back-to-back ... */
r_if
c_cond
(paren
(paren
id|udccs0
op_amp
id|UDCCS0_SA
)paren
op_ne
l_int|0
op_logical_and
id|dev-&gt;ep0state
op_ne
id|EP0_IDLE
)paren
(brace
id|nuke
c_func
(paren
id|ep
comma
l_int|0
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|dev-&gt;timer
)paren
suffix:semicolon
id|ep0_idle
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dev-&gt;ep0state
)paren
(brace
r_case
id|EP0_IDLE
suffix:colon
multiline_comment|/* late-breaking status? */
id|udccs0
op_assign
id|UDCCS0
suffix:semicolon
multiline_comment|/* start control request? */
r_if
c_cond
(paren
id|likely
c_func
(paren
(paren
id|udccs0
op_amp
(paren
id|UDCCS0_OPR
op_or
id|UDCCS0_SA
op_or
id|UDCCS0_RNE
)paren
)paren
op_eq
(paren
id|UDCCS0_OPR
op_or
id|UDCCS0_SA
op_or
id|UDCCS0_RNE
)paren
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|nuke
(paren
id|ep
comma
op_minus
id|EPROTO
)paren
suffix:semicolon
multiline_comment|/* read SETUP packet */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
(paren
id|UDCCS0
op_amp
id|UDCCS0_RNE
)paren
)paren
)paren
(brace
id|bad_setup
suffix:colon
id|DMSG
c_func
(paren
l_string|&quot;SETUP %d!&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_goto
id|stall
suffix:semicolon
)brace
id|u.raw
(braket
id|i
)braket
op_assign
(paren
id|u8
)paren
id|UDDR0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|UDCCS0
op_amp
id|UDCCS0_RNE
)paren
op_ne
l_int|0
)paren
)paren
r_goto
id|bad_setup
suffix:semicolon
id|got_setup
suffix:colon
id|le16_to_cpus
(paren
op_amp
id|u.r.wValue
)paren
suffix:semicolon
id|le16_to_cpus
(paren
op_amp
id|u.r.wIndex
)paren
suffix:semicolon
id|le16_to_cpus
(paren
op_amp
id|u.r.wLength
)paren
suffix:semicolon
id|LED_EP0_ON
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;SETUP %02x.%02x v%04x i%04x l%04x&bslash;n&quot;
comma
id|u.r.bRequestType
comma
id|u.r.bRequest
comma
id|u.r.wValue
comma
id|u.r.wIndex
comma
id|u.r.wLength
)paren
suffix:semicolon
multiline_comment|/* cope with automagic for some standard requests. */
id|dev-&gt;req_std
op_assign
(paren
id|u.r.bRequestType
op_amp
id|USB_TYPE_MASK
)paren
op_eq
id|USB_TYPE_STANDARD
suffix:semicolon
id|dev-&gt;req_config
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;req_pending
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|u.r.bRequest
)paren
(brace
multiline_comment|/* hardware restricts gadget drivers here! */
r_case
id|USB_REQ_SET_CONFIGURATION
suffix:colon
r_if
c_cond
(paren
id|u.r.bRequestType
op_eq
id|USB_RECIP_DEVICE
)paren
(brace
multiline_comment|/* reflect hardware&squot;s automagic&n;&t;&t;&t;&t;&t; * up to the gadget driver.&n;&t;&t;&t;&t;&t; */
id|config_change
suffix:colon
id|dev-&gt;req_config
op_assign
l_int|1
suffix:semicolon
id|clear_ep_state
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* if !has_cfr, there&squot;s no synch&n;&t;&t;&t;&t;&t; * else use AREN (later) not SA|OPR&n;&t;&t;&t;&t;&t; * USIR0_IR0 acts edge sensitive&n;&t;&t;&t;&t;&t; */
)brace
r_break
suffix:semicolon
multiline_comment|/* ... and here, even more ... */
r_case
id|USB_REQ_SET_INTERFACE
suffix:colon
r_if
c_cond
(paren
id|u.r.bRequestType
op_eq
id|USB_RECIP_INTERFACE
)paren
(brace
multiline_comment|/* udc hardware is broken by design:&n;&t;&t;&t;&t;&t; *  - altsetting may only be zero;&n;&t;&t;&t;&t;&t; *  - hw resets all interfaces&squot; eps;&n;&t;&t;&t;&t;&t; *  - ep reset doesn&squot;t include halt(?).&n;&t;&t;&t;&t;&t; */
id|DMSG
c_func
(paren
l_string|&quot;broken set_interface (%d/%d)&bslash;n&quot;
comma
id|u.r.wIndex
comma
id|u.r.wValue
)paren
suffix:semicolon
r_goto
id|config_change
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* hardware was supposed to hide this */
r_case
id|USB_REQ_SET_ADDRESS
suffix:colon
r_if
c_cond
(paren
id|u.r.bRequestType
op_eq
id|USB_RECIP_DEVICE
)paren
(brace
id|ep0start
c_func
(paren
id|dev
comma
l_int|0
comma
l_string|&quot;address&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|u.r.bRequestType
op_amp
id|USB_DIR_IN
)paren
id|dev-&gt;ep0state
op_assign
id|EP0_IN_DATA_PHASE
suffix:semicolon
r_else
id|dev-&gt;ep0state
op_assign
id|EP0_OUT_DATA_PHASE
suffix:semicolon
id|i
op_assign
id|dev-&gt;driver
op_member_access_from_pointer
id|setup
c_func
(paren
op_amp
id|dev-&gt;gadget
comma
op_amp
id|u.r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
multiline_comment|/* hardware automagic preventing STALL... */
r_if
c_cond
(paren
id|dev-&gt;req_config
)paren
(brace
multiline_comment|/* hardware sometimes neglects to tell&n;&t;&t;&t;&t;&t; * tell us about config change events,&n;&t;&t;&t;&t;&t; * so later ones may fail...&n;&t;&t;&t;&t;&t; */
id|WARN
c_func
(paren
l_string|&quot;config change %02x fail %d?&bslash;n&quot;
comma
id|u.r.bRequest
comma
id|i
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* TODO experiment:  if has_cfr,&n;&t;&t;&t;&t;&t; * hardware didn&squot;t ACK; maybe we&n;&t;&t;&t;&t;&t; * could actually STALL!&n;&t;&t;&t;&t;&t; */
)brace
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;protocol STALL, &quot;
l_string|&quot;%02x err %d&bslash;n&quot;
comma
id|UDCCS0
comma
id|i
)paren
suffix:semicolon
id|stall
suffix:colon
multiline_comment|/* the watchdog timer helps deal with cases&n;&t;&t;&t;&t; * where udc seems to clear FST wrongly, and&n;&t;&t;&t;&t; * then NAKs instead of STALLing.&n;&t;&t;&t;&t; */
id|ep0start
c_func
(paren
id|dev
comma
id|UDCCS0_FST
op_or
id|UDCCS0_FTF
comma
l_string|&quot;stall&quot;
)paren
suffix:semicolon
id|start_watchdog
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;ep0state
op_assign
id|EP0_STALL
suffix:semicolon
id|LED_EP0_OFF
suffix:semicolon
multiline_comment|/* deferred i/o == no response yet */
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;req_pending
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|dev-&gt;ep0state
op_eq
id|EP0_IN_DATA_PHASE
op_logical_or
id|dev-&gt;req_std
op_logical_or
id|u.r.wLength
)paren
)paren
id|ep0start
c_func
(paren
id|dev
comma
l_int|0
comma
l_string|&quot;defer&quot;
)paren
suffix:semicolon
r_else
id|ep0start
c_func
(paren
id|dev
comma
id|UDCCS0_IPR
comma
l_string|&quot;defer/IPR&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* expect at least one data or status stage irq */
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|likely
c_func
(paren
(paren
id|udccs0
op_amp
(paren
id|UDCCS0_OPR
op_or
id|UDCCS0_SA
)paren
)paren
op_eq
(paren
id|UDCCS0_OPR
op_or
id|UDCCS0_SA
)paren
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* pxa210/250 erratum 131 for B0/B1 says RNE lies.&n;&t;&t;&t; * still observed on a pxa255 a0.&n;&t;&t;&t; */
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;e131&bslash;n&quot;
)paren
suffix:semicolon
id|nuke
c_func
(paren
id|ep
comma
op_minus
id|EPROTO
)paren
suffix:semicolon
multiline_comment|/* read SETUP data, but don&squot;t trust it too much */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|u.raw
(braket
id|i
)braket
op_assign
(paren
id|u8
)paren
id|UDDR0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u.r.bRequestType
op_amp
id|USB_RECIP_MASK
)paren
OG
id|USB_RECIP_OTHER
)paren
r_goto
id|stall
suffix:semicolon
r_if
c_cond
(paren
id|u.word
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
id|u.word
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
r_goto
id|stall
suffix:semicolon
r_goto
id|got_setup
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* some random early IRQ:&n;&t;&t;&t; * - we acked FST&n;&t;&t;&t; * - IPR cleared&n;&t;&t;&t; * - OPR got set, without SA (likely status stage)&n;&t;&t;&t; */
id|UDCCS0
op_assign
id|udccs0
op_amp
(paren
id|UDCCS0_SA
op_or
id|UDCCS0_OPR
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EP0_IN_DATA_PHASE
suffix:colon
multiline_comment|/* GET_DESCRIPTOR etc */
r_if
c_cond
(paren
id|udccs0
op_amp
id|UDCCS0_OPR
)paren
(brace
id|UDCCS0
op_assign
id|UDCCS0_OPR
op_or
id|UDCCS0_FTF
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;ep0in premature status&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
id|done
c_func
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
id|ep0_idle
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* irq was IPR clearing */
(brace
r_if
c_cond
(paren
id|req
)paren
(brace
multiline_comment|/* this IN packet might finish the request */
(paren
r_void
)paren
id|write_ep0_fifo
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/* else IN token before response was written */
)brace
r_break
suffix:semicolon
r_case
id|EP0_OUT_DATA_PHASE
suffix:colon
multiline_comment|/* SET_DESCRIPTOR etc */
r_if
c_cond
(paren
id|udccs0
op_amp
id|UDCCS0_OPR
)paren
(brace
r_if
c_cond
(paren
id|req
)paren
(brace
multiline_comment|/* this OUT packet might finish the request */
r_if
c_cond
(paren
id|read_ep0_fifo
c_func
(paren
id|ep
comma
id|req
)paren
)paren
id|done
c_func
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* else more OUT packets expected */
)brace
multiline_comment|/* else OUT token before read was issued */
)brace
r_else
multiline_comment|/* irq was IPR clearing */
(brace
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;ep0out premature status&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
id|done
c_func
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
id|ep0_idle
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EP0_END_XFER
suffix:colon
r_if
c_cond
(paren
id|req
)paren
id|done
c_func
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* ack control-IN status (maybe in-zlp was skipped)&n;&t;&t; * also appears after some config change events.&n;&t;&t; */
r_if
c_cond
(paren
id|udccs0
op_amp
id|UDCCS0_OPR
)paren
id|UDCCS0
op_assign
id|UDCCS0_OPR
suffix:semicolon
id|ep0_idle
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EP0_STALL
suffix:colon
id|UDCCS0
op_assign
id|UDCCS0_FST
suffix:semicolon
r_break
suffix:semicolon
)brace
id|USIR0
op_assign
id|USIR0_IR0
suffix:semicolon
)brace
DECL|function|handle_ep
r_static
r_void
id|handle_ep
c_func
(paren
r_struct
id|pxa2xx_ep
op_star
id|ep
)paren
(brace
r_struct
id|pxa2xx_request
op_star
id|req
suffix:semicolon
r_int
id|is_in
op_assign
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
suffix:semicolon
r_int
id|completed
suffix:semicolon
id|u32
id|udccs
comma
id|tmp
suffix:semicolon
r_do
(brace
id|completed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;queue
)paren
)paren
)paren
id|req
op_assign
id|list_entry
c_func
(paren
id|ep-&gt;queue.next
comma
r_struct
id|pxa2xx_request
comma
id|queue
)paren
suffix:semicolon
r_else
id|req
op_assign
l_int|0
suffix:semicolon
singleline_comment|// TODO check FST handling
id|udccs
op_assign
op_star
id|ep-&gt;reg_udccs
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|is_in
)paren
)paren
(brace
multiline_comment|/* irq from TPC, SST, or (ISO) TUR */
id|tmp
op_assign
id|UDCCS_BI_TUR
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ep-&gt;bmAttributes
op_eq
id|USB_ENDPOINT_XFER_BULK
)paren
)paren
id|tmp
op_or_assign
id|UDCCS_BI_SST
suffix:semicolon
id|tmp
op_and_assign
id|udccs
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|tmp
)paren
)paren
op_star
id|ep-&gt;reg_udccs
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|req
op_logical_and
id|likely
(paren
(paren
id|udccs
op_amp
id|UDCCS_BI_TFS
)paren
op_ne
l_int|0
)paren
)paren
id|completed
op_assign
id|write_fifo
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* irq from RPC (or for ISO, ROF) */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ep-&gt;bmAttributes
op_eq
id|USB_ENDPOINT_XFER_BULK
)paren
)paren
id|tmp
op_assign
id|UDCCS_BO_SST
op_or
id|UDCCS_BO_DME
suffix:semicolon
r_else
id|tmp
op_assign
id|UDCCS_IO_ROF
op_or
id|UDCCS_IO_DME
suffix:semicolon
id|tmp
op_and_assign
id|udccs
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|tmp
)paren
)paren
op_star
id|ep-&gt;reg_udccs
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* fifos can hold packets, ready for reading... */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|req
)paren
)paren
(brace
macro_line|#ifdef USE_OUT_DMA
singleline_comment|// TODO didn&squot;t yet debug out-dma.  this approach assumes
singleline_comment|// the worst about short packets and RPC; it might be better.
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ep-&gt;dma
op_ge
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|udccs
op_amp
id|UDCCS_BO_RSP
)paren
)paren
(brace
op_star
id|ep-&gt;reg_udccs
op_assign
id|UDCCS_BO_RPC
suffix:semicolon
id|ep-&gt;dma_irqs
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
id|completed
op_assign
id|read_fifo
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
)brace
r_else
id|pio_irq_disable
(paren
id|ep-&gt;bEndpointAddress
)paren
suffix:semicolon
)brace
id|ep-&gt;pio_irqs
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|completed
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pxa2xx_udc_irq - interrupt handler&n; *&n; * avoid delays in ep0 processing. the control handshaking isn&squot;t always&n; * under software control (pxa250c0 and the pxa255 are better), and delays&n; * could cause usb protocol errors.&n; */
r_static
id|irqreturn_t
DECL|function|pxa2xx_udc_irq
id|pxa2xx_udc_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|_dev
comma
r_struct
id|pt_regs
op_star
id|r
)paren
(brace
r_struct
id|pxa2xx_udc
op_star
id|dev
op_assign
id|_dev
suffix:semicolon
r_int
id|handled
suffix:semicolon
id|dev-&gt;stats.irqs
op_increment
suffix:semicolon
id|HEX_DISPLAY
c_func
(paren
id|dev-&gt;stats.irqs
)paren
suffix:semicolon
r_do
(brace
id|u32
id|udccr
op_assign
id|UDCCR
suffix:semicolon
id|handled
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* SUSpend Interrupt Request */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|udccr
op_amp
id|UDCCR_SUSIR
)paren
)paren
(brace
id|udc_ack_int_UDCCR
c_func
(paren
id|UDCCR_SUSIR
)paren
suffix:semicolon
id|handled
op_assign
l_int|1
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;USB suspend%s&bslash;n&quot;
comma
id|is_usb_connected
c_func
(paren
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;+disconnect&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_usb_connected
c_func
(paren
)paren
)paren
id|stop_activity
c_func
(paren
id|dev
comma
id|dev-&gt;driver
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dev-&gt;gadget.speed
op_ne
id|USB_SPEED_UNKNOWN
op_logical_and
id|dev-&gt;driver
op_logical_and
id|dev-&gt;driver-&gt;suspend
)paren
id|dev-&gt;driver
op_member_access_from_pointer
id|suspend
c_func
(paren
op_amp
id|dev-&gt;gadget
)paren
suffix:semicolon
id|ep0_idle
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* RESume Interrupt Request */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|udccr
op_amp
id|UDCCR_RESIR
)paren
)paren
(brace
id|udc_ack_int_UDCCR
c_func
(paren
id|UDCCR_RESIR
)paren
suffix:semicolon
id|handled
op_assign
l_int|1
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;USB resume&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;gadget.speed
op_ne
id|USB_SPEED_UNKNOWN
op_logical_and
id|dev-&gt;driver
op_logical_and
id|dev-&gt;driver-&gt;resume
op_logical_and
id|is_usb_connected
c_func
(paren
)paren
)paren
id|dev-&gt;driver
op_member_access_from_pointer
id|resume
c_func
(paren
op_amp
id|dev-&gt;gadget
)paren
suffix:semicolon
)brace
multiline_comment|/* ReSeT Interrupt Request - USB reset */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|udccr
op_amp
id|UDCCR_RSTIR
)paren
)paren
(brace
id|udc_ack_int_UDCCR
c_func
(paren
id|UDCCR_RSTIR
)paren
suffix:semicolon
id|handled
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|UDCCR
op_amp
id|UDCCR_UDA
)paren
op_eq
l_int|0
)paren
(brace
id|DBG
c_func
(paren
id|DBG_VERBOSE
comma
l_string|&quot;USB reset start&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;gadget.speed
op_ne
id|USB_SPEED_UNKNOWN
)paren
id|disable_disconnect_irq
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* reset driver and endpoints,&n;&t;&t;&t;&t; * in case that&squot;s not yet done&n;&t;&t;&t;&t; */
id|stop_activity
(paren
id|dev
comma
id|dev-&gt;driver
)paren
suffix:semicolon
)brace
r_else
(brace
id|INFO
c_func
(paren
l_string|&quot;USB reset&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;gadget.speed
op_assign
id|USB_SPEED_FULL
suffix:semicolon
id|LED_CONNECTED_ON
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dev-&gt;stats
comma
l_int|0
comma
r_sizeof
id|dev-&gt;stats
)paren
suffix:semicolon
multiline_comment|/* driver and endpoints are still reset */
id|enable_disconnect_irq
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|u32
id|usir0
op_assign
id|USIR0
op_amp
op_complement
id|UICR0
suffix:semicolon
id|u32
id|usir1
op_assign
id|USIR1
op_amp
op_complement
id|UICR1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|usir0
op_logical_and
op_logical_neg
id|usir1
)paren
)paren
r_continue
suffix:semicolon
id|DBG
c_func
(paren
id|DBG_VERY_NOISY
comma
l_string|&quot;irq %02x.%02x&bslash;n&quot;
comma
id|usir1
comma
id|usir0
)paren
suffix:semicolon
multiline_comment|/* control traffic */
r_if
c_cond
(paren
id|usir0
op_amp
id|USIR0_IR0
)paren
(brace
id|dev-&gt;ep
(braket
l_int|0
)braket
dot
id|pio_irqs
op_increment
suffix:semicolon
id|handle_ep0
c_func
(paren
id|dev
)paren
suffix:semicolon
id|handled
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endpoint data transfers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u32
id|tmp
op_assign
l_int|1
op_lshift
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
id|usir0
op_amp
id|tmp
)paren
)paren
(brace
id|handle_ep
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
id|i
)braket
)paren
suffix:semicolon
id|USIR0
op_or_assign
id|tmp
suffix:semicolon
id|handled
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usir1
op_amp
id|tmp
)paren
(brace
id|handle_ep
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
id|i
op_plus
l_int|8
)braket
)paren
suffix:semicolon
id|USIR1
op_or_assign
id|tmp
suffix:semicolon
id|handled
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* we could also ask for 1 msec SOF (SIR) interrupts */
)brace
r_while
c_loop
(paren
id|handled
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|nop_release
r_static
r_void
id|nop_release
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;%s %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|dev-&gt;bus_id
)paren
suffix:semicolon
)brace
multiline_comment|/* this uses load-time allocation and initialization (instead of&n; * doing it at run-time) to save code, eliminate fault paths, and&n; * be more obviously correct.&n; */
DECL|variable|memory
r_static
r_struct
id|pxa2xx_udc
id|memory
op_assign
(brace
dot
id|gadget
op_assign
(brace
dot
id|ops
op_assign
op_amp
id|pxa2xx_udc_ops
comma
dot
id|ep0
op_assign
op_amp
id|memory.ep
(braket
l_int|0
)braket
dot
id|ep
comma
dot
id|name
op_assign
id|driver_name
comma
dot
id|dev
op_assign
(brace
dot
id|bus_id
op_assign
l_string|&quot;gadget&quot;
comma
dot
id|release
op_assign
id|nop_release
comma
)brace
comma
)brace
comma
multiline_comment|/* control endpoint */
dot
id|ep
(braket
l_int|0
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
id|ep0name
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|EP0_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS0
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR0
comma
)brace
comma
multiline_comment|/* first group of endpoints */
dot
id|ep
(braket
l_int|1
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep1in-bulk&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|BULK_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|BULK_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_IN
op_or
l_int|1
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS1
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR1
comma
id|drcmr
(paren
l_int|25
)paren
)brace
comma
dot
id|ep
(braket
l_int|2
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep2out-bulk&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|BULK_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|BULK_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
l_int|2
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS2
comma
dot
id|reg_ubcr
op_assign
op_amp
id|UBCR2
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR2
comma
id|drcmr
(paren
l_int|26
)paren
)brace
comma
macro_line|#ifndef CONFIG_USB_PXA2XX_SMALL
dot
id|ep
(braket
l_int|3
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep3in-iso&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|ISO_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|ISO_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_IN
op_or
l_int|3
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_ISOC
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS3
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR3
comma
id|drcmr
(paren
l_int|27
)paren
)brace
comma
dot
id|ep
(braket
l_int|4
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep4out-iso&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|ISO_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|ISO_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
l_int|4
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_ISOC
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS4
comma
dot
id|reg_ubcr
op_assign
op_amp
id|UBCR4
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR4
comma
id|drcmr
(paren
l_int|28
)paren
)brace
comma
dot
id|ep
(braket
l_int|5
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep5in-int&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|INT_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|INT_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_IN
op_or
l_int|5
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_INT
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS5
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR5
comma
)brace
comma
multiline_comment|/* second group of endpoints */
dot
id|ep
(braket
l_int|6
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep6in-bulk&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|BULK_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|BULK_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_IN
op_or
l_int|6
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS6
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR6
comma
id|drcmr
(paren
l_int|30
)paren
)brace
comma
dot
id|ep
(braket
l_int|7
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep7out-bulk&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|BULK_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|BULK_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
l_int|7
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS7
comma
dot
id|reg_ubcr
op_assign
op_amp
id|UBCR7
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR7
comma
id|drcmr
(paren
l_int|31
)paren
)brace
comma
dot
id|ep
(braket
l_int|8
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep8in-iso&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|ISO_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|ISO_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_IN
op_or
l_int|8
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_ISOC
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS8
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR8
comma
id|drcmr
(paren
l_int|32
)paren
)brace
comma
dot
id|ep
(braket
l_int|9
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep9out-iso&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|ISO_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|ISO_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
l_int|9
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_ISOC
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS9
comma
dot
id|reg_ubcr
op_assign
op_amp
id|UBCR9
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR9
comma
id|drcmr
(paren
l_int|33
)paren
)brace
comma
dot
id|ep
(braket
l_int|10
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep10in-int&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|INT_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|INT_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_IN
op_or
l_int|10
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_INT
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS10
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR10
comma
)brace
comma
multiline_comment|/* third group of endpoints */
dot
id|ep
(braket
l_int|11
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep11in-bulk&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|BULK_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|BULK_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_IN
op_or
l_int|11
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS11
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR11
comma
id|drcmr
(paren
l_int|35
)paren
)brace
comma
dot
id|ep
(braket
l_int|12
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep12out-bulk&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|BULK_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|BULK_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
l_int|12
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_BULK
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS12
comma
dot
id|reg_ubcr
op_assign
op_amp
id|UBCR12
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR12
comma
id|drcmr
(paren
l_int|36
)paren
)brace
comma
dot
id|ep
(braket
l_int|13
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep13in-iso&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|ISO_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|ISO_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_IN
op_or
l_int|13
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_ISOC
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS13
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR13
comma
id|drcmr
(paren
l_int|37
)paren
)brace
comma
dot
id|ep
(braket
l_int|14
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep14out-iso&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|ISO_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|ISO_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
l_int|14
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_ISOC
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS14
comma
dot
id|reg_ubcr
op_assign
op_amp
id|UBCR14
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR14
comma
id|drcmr
(paren
l_int|38
)paren
)brace
comma
dot
id|ep
(braket
l_int|15
)braket
op_assign
(brace
dot
id|ep
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ep15in-int&quot;
comma
dot
id|ops
op_assign
op_amp
id|pxa2xx_ep_ops
comma
dot
id|maxpacket
op_assign
id|INT_FIFO_SIZE
comma
)brace
comma
dot
id|dev
op_assign
op_amp
id|memory
comma
dot
id|fifo_size
op_assign
id|INT_FIFO_SIZE
comma
dot
id|bEndpointAddress
op_assign
id|USB_DIR_IN
op_or
l_int|15
comma
dot
id|bmAttributes
op_assign
id|USB_ENDPOINT_XFER_INT
comma
dot
id|reg_udccs
op_assign
op_amp
id|UDCCS15
comma
dot
id|reg_uddr
op_assign
op_amp
id|UDDR15
comma
)brace
comma
macro_line|#endif /* !CONFIG_USB_PXA2XX_SMALL */
)brace
suffix:semicolon
DECL|macro|CP15R0_VENDOR_MASK
mdefine_line|#define CP15R0_VENDOR_MASK&t;0xffffe000
macro_line|#if&t;defined(CONFIG_ARCH_PXA)
DECL|macro|CP15R0_XSCALE_VALUE
mdefine_line|#define CP15R0_XSCALE_VALUE&t;0x69052000&t;/* intel/arm/xscale */
macro_line|#elif&t;defined(CONFIG_ARCH_IXP4XX)
DECL|macro|CP15R0_XSCALE_VALUE
mdefine_line|#define CP15R0_XSCALE_VALUE&t;0x69054000&t;/* intel/arm/ixp4xx */
macro_line|#endif
DECL|macro|CP15R0_PROD_MASK
mdefine_line|#define CP15R0_PROD_MASK&t;0x000003f0
DECL|macro|PXA25x
mdefine_line|#define PXA25x&t;&t;&t;0x00000100&t;/* and PXA26x */
DECL|macro|PXA210
mdefine_line|#define PXA210&t;&t;&t;0x00000120
DECL|macro|CP15R0_REV_MASK
mdefine_line|#define CP15R0_REV_MASK&t;&t;0x0000000f
DECL|macro|CP15R0_PRODREV_MASK
mdefine_line|#define CP15R0_PRODREV_MASK&t;(CP15R0_PROD_MASK | CP15R0_REV_MASK)
DECL|macro|PXA255_A0
mdefine_line|#define PXA255_A0&t;&t;0x00000106&t;/* or PXA260_B1 */
DECL|macro|PXA250_C0
mdefine_line|#define PXA250_C0&t;&t;0x00000105&t;/* or PXA26x_B0 */
DECL|macro|PXA250_B2
mdefine_line|#define PXA250_B2&t;&t;0x00000104
DECL|macro|PXA250_B1
mdefine_line|#define PXA250_B1&t;&t;0x00000103&t;/* or PXA260_A0 */
DECL|macro|PXA250_B0
mdefine_line|#define PXA250_B0&t;&t;0x00000102
DECL|macro|PXA250_A1
mdefine_line|#define PXA250_A1&t;&t;0x00000101
DECL|macro|PXA250_A0
mdefine_line|#define PXA250_A0&t;&t;0x00000100
DECL|macro|PXA210_C0
mdefine_line|#define PXA210_C0&t;&t;0x00000125
DECL|macro|PXA210_B2
mdefine_line|#define PXA210_B2&t;&t;0x00000124
DECL|macro|PXA210_B1
mdefine_line|#define PXA210_B1&t;&t;0x00000123
DECL|macro|PXA210_B0
mdefine_line|#define PXA210_B0&t;&t;0x00000122
DECL|macro|IXP425_A0
mdefine_line|#define IXP425_A0&t;&t;0x000001c1
multiline_comment|/*&n; * &t;probe - binds to the platform device&n; */
DECL|function|pxa2xx_udc_probe
r_static
r_int
id|__init
id|pxa2xx_udc_probe
c_func
(paren
r_struct
id|device
op_star
id|_dev
)paren
(brace
r_struct
id|pxa2xx_udc
op_star
id|dev
op_assign
op_amp
id|memory
suffix:semicolon
r_int
id|retval
comma
id|out_dma
op_assign
l_int|1
suffix:semicolon
id|u32
id|chiprev
suffix:semicolon
multiline_comment|/* insist on Intel/ARM/XScale */
id|asm
c_func
(paren
l_string|&quot;mrc%? p15, 0, %0, c0, c0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|chiprev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chiprev
op_amp
id|CP15R0_VENDOR_MASK
)paren
op_ne
id|CP15R0_XSCALE_VALUE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: not XScale!&bslash;n&quot;
comma
id|driver_name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* trigger chiprev-specific logic */
r_switch
c_cond
(paren
id|chiprev
op_amp
id|CP15R0_PRODREV_MASK
)paren
(brace
macro_line|#if&t;defined(CONFIG_ARCH_PXA)
r_case
id|PXA255_A0
suffix:colon
id|dev-&gt;has_cfr
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PXA250_A0
suffix:colon
r_case
id|PXA250_A1
suffix:colon
multiline_comment|/* A0/A1 &quot;not released&quot;; ep 13, 15 unusable */
multiline_comment|/* fall through */
r_case
id|PXA250_B2
suffix:colon
r_case
id|PXA210_B2
suffix:colon
r_case
id|PXA250_B1
suffix:colon
r_case
id|PXA210_B1
suffix:colon
r_case
id|PXA250_B0
suffix:colon
r_case
id|PXA210_B0
suffix:colon
id|out_dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|PXA250_C0
suffix:colon
r_case
id|PXA210_C0
suffix:colon
r_break
suffix:semicolon
macro_line|#elif&t;defined(CONFIG_ARCH_IXP4XX)
r_case
id|IXP425_A0
suffix:colon
id|out_dma
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|out_dma
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unrecognized processor: %08x&bslash;n&quot;
comma
id|driver_name
comma
id|chiprev
)paren
suffix:semicolon
multiline_comment|/* iop3xx, ixp4xx, ... */
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|pr_debug
c_func
(paren
l_string|&quot;%s: IRQ %d%s%s%s&bslash;n&quot;
comma
id|driver_name
comma
id|IRQ_USB
comma
id|dev-&gt;has_cfr
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; (!cfr)&quot;
comma
id|out_dma
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; (broken dma-out)&quot;
comma
id|SIZE_STR
id|DMASTR
)paren
suffix:semicolon
macro_line|#ifdef&t;USE_DMA
macro_line|#ifndef&t;USE_OUT_DMA
id|out_dma
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* pxa 250 erratum 130 prevents using OUT dma (fixed C0) */
r_if
c_cond
(paren
op_logical_neg
id|out_dma
)paren
(brace
id|DMSG
c_func
(paren
l_string|&quot;disabled OUT dma&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;ep
(braket
l_int|2
)braket
dot
id|reg_drcmr
op_assign
id|dev-&gt;ep
(braket
l_int|4
)braket
dot
id|reg_drcmr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;ep
(braket
l_int|7
)braket
dot
id|reg_drcmr
op_assign
id|dev-&gt;ep
(braket
l_int|9
)braket
dot
id|reg_drcmr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;ep
(braket
l_int|12
)braket
dot
id|reg_drcmr
op_assign
id|dev-&gt;ep
(braket
l_int|14
)braket
dot
id|reg_drcmr
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* other non-static parts of init */
id|dev-&gt;dev
op_assign
id|_dev
suffix:semicolon
id|dev-&gt;mach
op_assign
id|_dev-&gt;platform_data
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|dev-&gt;timer
)paren
suffix:semicolon
id|dev-&gt;timer.function
op_assign
id|udc_watchdog
suffix:semicolon
id|dev-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|device_initialize
c_func
(paren
op_amp
id|dev-&gt;gadget.dev
)paren
suffix:semicolon
id|dev-&gt;gadget.dev.parent
op_assign
id|_dev
suffix:semicolon
id|dev-&gt;gadget.dev.dma_mask
op_assign
id|_dev-&gt;dma_mask
suffix:semicolon
id|the_controller
op_assign
id|dev
suffix:semicolon
id|dev_set_drvdata
c_func
(paren
id|_dev
comma
id|dev
)paren
suffix:semicolon
id|udc_disable
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udc_reinit
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* irq setup after old hardware state is cleaned up */
id|retval
op_assign
id|request_irq
c_func
(paren
id|IRQ_USB
comma
id|pxa2xx_udc_irq
comma
id|SA_INTERRUPT
comma
id|driver_name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: can&squot;t get irq %i, err %d&bslash;n&quot;
comma
id|driver_name
comma
id|IRQ_USB
comma
id|retval
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|dev-&gt;got_irq
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_ARCH_LUBBOCK
r_if
c_cond
(paren
id|machine_is_lubbock
c_func
(paren
)paren
)paren
(brace
id|disable_irq
c_func
(paren
id|LUBBOCK_USB_DISC_IRQ
)paren
suffix:semicolon
id|retval
op_assign
id|request_irq
c_func
(paren
id|LUBBOCK_USB_DISC_IRQ
comma
id|usb_connection_irq
comma
id|SA_INTERRUPT
multiline_comment|/* OOPSING | SA_SAMPLE_RANDOM */
comma
id|driver_name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
(brace
id|enable_irq
c_func
(paren
id|LUBBOCK_USB_DISC_IRQ
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: can&squot;t get irq %i, err %d&bslash;n&quot;
comma
id|driver_name
comma
id|LUBBOCK_USB_DISC_IRQ
comma
id|retval
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|dev-&gt;got_disc
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
id|create_proc_files
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pxa2xx_udc_remove
r_static
r_int
id|__exit
id|pxa2xx_udc_remove
c_func
(paren
r_struct
id|device
op_star
id|_dev
)paren
(brace
r_struct
id|pxa2xx_udc
op_star
id|dev
op_assign
id|_dev-&gt;driver_data
suffix:semicolon
id|udc_disable
c_func
(paren
id|dev
)paren
suffix:semicolon
id|remove_proc_files
c_func
(paren
)paren
suffix:semicolon
id|usb_gadget_unregister_driver
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;got_irq
)paren
(brace
id|free_irq
c_func
(paren
id|IRQ_USB
comma
id|dev
)paren
suffix:semicolon
id|dev-&gt;got_irq
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|machine_is_lubbock
c_func
(paren
)paren
op_logical_and
id|dev-&gt;got_disc
)paren
(brace
id|free_irq
c_func
(paren
id|LUBBOCK_USB_DISC_IRQ
comma
id|dev
)paren
suffix:semicolon
id|dev-&gt;got_disc
op_assign
l_int|0
suffix:semicolon
)brace
id|dev_set_drvdata
c_func
(paren
id|_dev
comma
l_int|0
)paren
suffix:semicolon
id|the_controller
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|variable|udc_driver
r_static
r_struct
id|device_driver
id|udc_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;pxa2xx-udc&quot;
comma
dot
id|bus
op_assign
op_amp
id|platform_bus_type
comma
dot
id|probe
op_assign
id|pxa2xx_udc_probe
comma
dot
id|remove
op_assign
id|__exit_p
c_func
(paren
id|pxa2xx_udc_remove
)paren
comma
singleline_comment|// FIXME power management support
singleline_comment|// .suspend = ... disable UDC
singleline_comment|// .resume = ... re-enable UDC
)brace
suffix:semicolon
DECL|function|udc_init
r_static
r_int
id|__init
id|udc_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: version %s&bslash;n&quot;
comma
id|driver_name
comma
id|DRIVER_VERSION
)paren
suffix:semicolon
r_return
id|driver_register
c_func
(paren
op_amp
id|udc_driver
)paren
suffix:semicolon
)brace
DECL|variable|udc_init
id|module_init
c_func
(paren
id|udc_init
)paren
suffix:semicolon
DECL|function|udc_exit
r_static
r_void
id|__exit
id|udc_exit
c_func
(paren
r_void
)paren
(brace
id|driver_unregister
c_func
(paren
op_amp
id|udc_driver
)paren
suffix:semicolon
)brace
DECL|variable|udc_exit
id|module_exit
c_func
(paren
id|udc_exit
)paren
suffix:semicolon
DECL|variable|DRIVER_DESC
id|MODULE_DESCRIPTION
c_func
(paren
id|DRIVER_DESC
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Frank Becker, Robert Schwebel, David Brownell&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
