multiline_comment|/*&n; * inode.c -- user mode filesystem api for usb gadget controllers&n; *&n; * Copyright (C) 2003-2004 David Brownell&n; * Copyright (C) 2003 Agilent Technologies&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
singleline_comment|// #define&t;DEBUG &t;&t;&t;/* data to help fault diagnosis */
singleline_comment|// #define&t;VERBOSE&t;&t;/* extra debug messages (success too) */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/uts.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/usb_gadgetfs.h&gt;
macro_line|#include &lt;linux/usb_gadget.h&gt;
multiline_comment|/*&n; * The gadgetfs API maps each endpoint to a file descriptor so that you&n; * can use standard synchronous read/write calls for I/O.  There&squot;s some&n; * O_NONBLOCK and O_ASYNC/FASYNC style i/o support.  Example usermode&n; * drivers show how this works in practice.  You can also use AIO to&n; * eliminate I/O gaps between requests, to help when streaming data.&n; *&n; * Key parts that must be USB-specific are protocols defining how the&n; * read/write operations relate to the hardware state machines.  There&n; * are two types of files.  One type is for the device, implementing ep0.&n; * The other type is for each IN or OUT endpoint.  In both cases, the&n; * user mode driver must configure the hardware before using it.&n; *&n; * - First, dev_config() is called when /dev/gadget/$CHIP is configured&n; *   (by writing configuration and device descriptors).  Afterwards it&n; *   may serve as a source of device events, used to handle all control&n; *   requests other than basic enumeration.&n; *&n; * - Then either immediately, or after a SET_CONFIGURATION control request,&n; *   ep_config() is called when each /dev/gadget/ep* file is configured&n; *   (by writing endpoint descriptors).  Afterwards these files are used&n; *   to write() IN data or to read() OUT data.  To halt the endpoint, a&n; *   &quot;wrong direction&quot; request is issued (like reading an IN endpoint).&n; *&n; * Unlike &quot;usbfs&quot; the only ioctl()s are for things that are rare, and maybe&n; * not possible on all hardware.  For example, precise fault handling with&n; * respect to data left in endpoint fifos after aborted operations; or&n; * selective clearing of endpoint halts, to implement SET_INTERFACE.&n; */
DECL|macro|DRIVER_DESC
mdefine_line|#define&t;DRIVER_DESC&t;&quot;USB Gadget filesystem&quot;
DECL|macro|DRIVER_VERSION
mdefine_line|#define&t;DRIVER_VERSION&t;&quot;24 Aug 2004&quot;
DECL|variable|driver_desc
r_static
r_const
r_char
id|driver_desc
(braket
)braket
op_assign
id|DRIVER_DESC
suffix:semicolon
DECL|variable|shortname
r_static
r_const
r_char
id|shortname
(braket
)braket
op_assign
l_string|&quot;gadgetfs&quot;
suffix:semicolon
DECL|variable|DRIVER_DESC
id|MODULE_DESCRIPTION
(paren
id|DRIVER_DESC
)paren
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;David Brownell&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------------*/
DECL|macro|GADGETFS_MAGIC
mdefine_line|#define GADGETFS_MAGIC&t;&t;0xaee71ee7
DECL|macro|DMA_ADDR_INVALID
mdefine_line|#define DMA_ADDR_INVALID&t;(~(dma_addr_t)0)
multiline_comment|/* /dev/gadget/$CHIP represents ep0 and the whole device */
DECL|enum|ep0_state
r_enum
id|ep0_state
(brace
multiline_comment|/* DISBLED is the initial state.&n;&t; */
DECL|enumerator|STATE_DEV_DISABLED
id|STATE_DEV_DISABLED
op_assign
l_int|0
comma
multiline_comment|/* Only one open() of /dev/gadget/$CHIP; only one file tracks&n;&t; * ep0/device i/o modes and binding to the controller.  Driver&n;&t; * must always write descriptors to initialize the device, then&n;&t; * the device becomes UNCONNECTED until enumeration.&n;&t; */
DECL|enumerator|STATE_OPENED
id|STATE_OPENED
comma
multiline_comment|/* From then on, ep0 fd is in either of two basic modes:&n;&t; * - (UN)CONNECTED: read usb_gadgetfs_event(s) from it&n;&t; * - SETUP: read/write will transfer control data and succeed;&n;&t; *   or if &quot;wrong direction&quot;, performs protocol stall&n;&t; */
DECL|enumerator|STATE_UNCONNECTED
id|STATE_UNCONNECTED
comma
DECL|enumerator|STATE_CONNECTED
id|STATE_CONNECTED
comma
DECL|enumerator|STATE_SETUP
id|STATE_SETUP
comma
multiline_comment|/* UNBOUND means the driver closed ep0, so the device won&squot;t be&n;&t; * accessible again (DEV_DISABLED) until all fds are closed.&n;&t; */
DECL|enumerator|STATE_DEV_UNBOUND
id|STATE_DEV_UNBOUND
comma
)brace
suffix:semicolon
multiline_comment|/* enough for the whole queue: most events invalidate others */
DECL|macro|N_EVENT
mdefine_line|#define&t;N_EVENT&t;&t;&t;5
DECL|struct|dev_data
r_struct
id|dev_data
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|state
r_enum
id|ep0_state
id|state
suffix:semicolon
DECL|member|event
r_struct
id|usb_gadgetfs_event
id|event
(braket
id|N_EVENT
)braket
suffix:semicolon
DECL|member|ev_next
r_int
id|ev_next
suffix:semicolon
DECL|member|fasync
r_struct
id|fasync_struct
op_star
id|fasync
suffix:semicolon
DECL|member|current_config
id|u8
id|current_config
suffix:semicolon
multiline_comment|/* drivers reading ep0 MUST handle control requests (SETUP)&n;&t; * reported that way; else the host will time out.&n;&t; */
DECL|member|usermode_setup
r_int
id|usermode_setup
suffix:colon
l_int|1
comma
DECL|member|setup_in
id|setup_in
suffix:colon
l_int|1
comma
DECL|member|setup_can_stall
id|setup_can_stall
suffix:colon
l_int|1
comma
DECL|member|setup_out_ready
id|setup_out_ready
suffix:colon
l_int|1
comma
DECL|member|setup_out_error
id|setup_out_error
suffix:colon
l_int|1
comma
DECL|member|setup_abort
id|setup_abort
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* the rest is basically write-once */
DECL|member|config
DECL|member|hs_config
r_struct
id|usb_config_descriptor
op_star
id|config
comma
op_star
id|hs_config
suffix:semicolon
DECL|member|dev
r_struct
id|usb_device_descriptor
op_star
id|dev
suffix:semicolon
DECL|member|req
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
DECL|member|gadget
r_struct
id|usb_gadget
op_star
id|gadget
suffix:semicolon
DECL|member|epfiles
r_struct
id|list_head
id|epfiles
suffix:semicolon
DECL|member|buf
r_void
op_star
id|buf
suffix:semicolon
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
DECL|member|sb
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
DECL|member|dentry
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
multiline_comment|/* except this scratch i/o buffer for ep0 */
DECL|member|rbuf
id|u8
id|rbuf
(braket
l_int|256
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|get_dev
r_static
r_inline
r_void
id|get_dev
(paren
r_struct
id|dev_data
op_star
id|data
)paren
(brace
id|atomic_inc
(paren
op_amp
id|data-&gt;count
)paren
suffix:semicolon
)brace
DECL|function|put_dev
r_static
r_void
id|put_dev
(paren
r_struct
id|dev_data
op_star
id|data
)paren
(brace
r_if
c_cond
(paren
id|likely
(paren
op_logical_neg
id|atomic_dec_and_test
(paren
op_amp
id|data-&gt;count
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* needs no more cleanup */
id|BUG_ON
(paren
id|waitqueue_active
(paren
op_amp
id|data-&gt;wait
)paren
)paren
suffix:semicolon
id|kfree
(paren
id|data
)paren
suffix:semicolon
)brace
DECL|function|dev_new
r_static
r_struct
id|dev_data
op_star
id|dev_new
(paren
r_void
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
suffix:semicolon
id|dev
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|dev
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
op_star
id|dev
)paren
suffix:semicolon
id|dev-&gt;state
op_assign
id|STATE_DEV_DISABLED
suffix:semicolon
id|atomic_set
(paren
op_amp
id|dev-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|dev-&gt;epfiles
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|dev-&gt;wait
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------------*/
multiline_comment|/* other /dev/gadget/$ENDPOINT files represent endpoints */
DECL|enum|ep_state
r_enum
id|ep_state
(brace
DECL|enumerator|STATE_EP_DISABLED
id|STATE_EP_DISABLED
op_assign
l_int|0
comma
DECL|enumerator|STATE_EP_READY
id|STATE_EP_READY
comma
DECL|enumerator|STATE_EP_DEFER_ENABLE
id|STATE_EP_DEFER_ENABLE
comma
DECL|enumerator|STATE_EP_ENABLED
id|STATE_EP_ENABLED
comma
DECL|enumerator|STATE_EP_UNBOUND
id|STATE_EP_UNBOUND
comma
)brace
suffix:semicolon
DECL|struct|ep_data
r_struct
id|ep_data
(brace
DECL|member|lock
r_struct
id|semaphore
id|lock
suffix:semicolon
DECL|member|state
r_enum
id|ep_state
id|state
suffix:semicolon
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|dev
r_struct
id|dev_data
op_star
id|dev
suffix:semicolon
multiline_comment|/* must hold dev-&gt;lock before accessing ep or req */
DECL|member|ep
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
DECL|member|req
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
DECL|member|status
id|ssize_t
id|status
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|desc
DECL|member|hs_desc
r_struct
id|usb_endpoint_descriptor
id|desc
comma
id|hs_desc
suffix:semicolon
DECL|member|epfiles
r_struct
id|list_head
id|epfiles
suffix:semicolon
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
DECL|member|dentry
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
DECL|member|inode
r_struct
id|inode
op_star
id|inode
suffix:semicolon
)brace
suffix:semicolon
DECL|function|get_ep
r_static
r_inline
r_void
id|get_ep
(paren
r_struct
id|ep_data
op_star
id|data
)paren
(brace
id|atomic_inc
(paren
op_amp
id|data-&gt;count
)paren
suffix:semicolon
)brace
DECL|function|put_ep
r_static
r_void
id|put_ep
(paren
r_struct
id|ep_data
op_star
id|data
)paren
(brace
r_if
c_cond
(paren
id|likely
(paren
op_logical_neg
id|atomic_dec_and_test
(paren
op_amp
id|data-&gt;count
)paren
)paren
)paren
r_return
suffix:semicolon
id|put_dev
(paren
id|data-&gt;dev
)paren
suffix:semicolon
multiline_comment|/* needs no more cleanup */
id|BUG_ON
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|data-&gt;epfiles
)paren
)paren
suffix:semicolon
id|BUG_ON
(paren
id|waitqueue_active
(paren
op_amp
id|data-&gt;wait
)paren
)paren
suffix:semicolon
id|BUG_ON
(paren
id|down_trylock
(paren
op_amp
id|data-&gt;lock
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|kfree
(paren
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------------*/
multiline_comment|/* most &quot;how to use the hardware&quot; policy choices are in userspace:&n; * mapping endpoint roles (which the driver needs) to the capabilities&n; * which the usb controller has.  most of those capabilities are exposed&n; * implicitly, starting with the driver name and then endpoint names.&n; */
DECL|variable|CHIP
r_static
r_const
r_char
op_star
id|CHIP
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------------*/
multiline_comment|/* NOTE:  don&squot;t use dev_printk calls before binding to the gadget&n; * at the end of ep0 configuration, or after unbind.&n; */
multiline_comment|/* too wordy: dev_printk(level , &amp;(d)-&gt;gadget-&gt;dev , fmt , ## args) */
DECL|macro|xprintk
mdefine_line|#define xprintk(d,level,fmt,args...) &bslash;&n;&t;printk(level &quot;%s: &quot; fmt , shortname , ## args)
macro_line|#ifdef DEBUG
DECL|macro|DBG
mdefine_line|#define DBG(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_DEBUG , fmt , ## args)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(dev,fmt,args...) &bslash;&n;&t;do { } while (0)
macro_line|#endif /* DEBUG */
macro_line|#ifdef VERBOSE
DECL|macro|VDEBUG
mdefine_line|#define VDEBUG&t;DBG
macro_line|#else
DECL|macro|VDEBUG
mdefine_line|#define VDEBUG(dev,fmt,args...) &bslash;&n;&t;do { } while (0)
macro_line|#endif /* DEBUG */
DECL|macro|ERROR
mdefine_line|#define ERROR(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_ERR , fmt , ## args)
DECL|macro|WARN
mdefine_line|#define WARN(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_WARNING , fmt , ## args)
DECL|macro|INFO
mdefine_line|#define INFO(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_INFO , fmt , ## args)
multiline_comment|/*----------------------------------------------------------------------*/
multiline_comment|/* SYNCHRONOUS ENDPOINT OPERATIONS (bulk/intr/iso)&n; *&n; * After opening, configure non-control endpoints.  Then use normal&n; * stream read() and write() requests; and maybe ioctl() to get more&n; * precise FIFO status when recovering from cancelation.&n; */
DECL|function|epio_complete
r_static
r_void
id|epio_complete
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|ep_data
op_star
id|epdata
op_assign
id|ep-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;context
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;status
)paren
id|epdata-&gt;status
op_assign
id|req-&gt;status
suffix:semicolon
r_else
id|epdata-&gt;status
op_assign
id|req-&gt;actual
suffix:semicolon
id|complete
(paren
(paren
r_struct
id|completion
op_star
)paren
id|req-&gt;context
)paren
suffix:semicolon
)brace
multiline_comment|/* tasklock endpoint, returning when it&squot;s connected.&n; * still need dev-&gt;lock to use epdata-&gt;ep.&n; */
r_static
r_int
DECL|function|get_ready_ep
id|get_ready_ep
(paren
r_int
id|f_flags
comma
r_struct
id|ep_data
op_star
id|epdata
)paren
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
id|down_trylock
(paren
op_amp
id|epdata-&gt;lock
)paren
op_ne
l_int|0
)paren
r_goto
id|nonblock
suffix:semicolon
r_if
c_cond
(paren
id|epdata-&gt;state
op_ne
id|STATE_EP_ENABLED
)paren
(brace
id|up
(paren
op_amp
id|epdata-&gt;lock
)paren
suffix:semicolon
id|nonblock
suffix:colon
id|val
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
id|val
op_assign
l_int|0
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|down_interruptible
(paren
op_amp
id|epdata-&gt;lock
)paren
)paren
OL
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|newstate
suffix:colon
r_switch
c_cond
(paren
id|epdata-&gt;state
)paren
(brace
r_case
id|STATE_EP_ENABLED
suffix:colon
r_break
suffix:semicolon
r_case
id|STATE_EP_DEFER_ENABLE
suffix:colon
id|DBG
(paren
id|epdata-&gt;dev
comma
l_string|&quot;%s wait for host&bslash;n&quot;
comma
id|epdata-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_assign
id|wait_event_interruptible
(paren
id|epdata-&gt;wait
comma
id|epdata-&gt;state
op_ne
id|STATE_EP_DEFER_ENABLE
op_logical_or
id|epdata-&gt;dev-&gt;state
op_eq
id|STATE_DEV_UNBOUND
)paren
)paren
OL
l_int|0
)paren
r_goto
id|fail
suffix:semicolon
r_goto
id|newstate
suffix:semicolon
singleline_comment|// case STATE_EP_DISABLED:&t;&t;/* &quot;can&squot;t happen&quot; */
singleline_comment|// case STATE_EP_READY:&t;&t;&t;/* &quot;can&squot;t happen&quot; */
r_default
suffix:colon
multiline_comment|/* error! */
id|pr_debug
(paren
l_string|&quot;%s: ep %p not available, state %d&bslash;n&quot;
comma
id|shortname
comma
id|epdata
comma
id|epdata-&gt;state
)paren
suffix:semicolon
singleline_comment|// FALLTHROUGH
r_case
id|STATE_EP_UNBOUND
suffix:colon
multiline_comment|/* clean disconnect */
id|val
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|fail
suffix:colon
id|up
(paren
op_amp
id|epdata-&gt;lock
)paren
suffix:semicolon
)brace
r_return
id|val
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|ep_io
id|ep_io
(paren
r_struct
id|ep_data
op_star
id|epdata
comma
r_void
op_star
id|buf
comma
r_int
id|len
)paren
(brace
id|DECLARE_COMPLETION
(paren
id|done
)paren
suffix:semicolon
r_int
id|value
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|epdata-&gt;dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|epdata-&gt;ep
op_ne
l_int|NULL
)paren
)paren
(brace
r_struct
id|usb_request
op_star
id|req
op_assign
id|epdata-&gt;req
suffix:semicolon
id|req-&gt;context
op_assign
op_amp
id|done
suffix:semicolon
id|req-&gt;complete
op_assign
id|epio_complete
suffix:semicolon
id|req-&gt;buf
op_assign
id|buf
suffix:semicolon
id|req-&gt;length
op_assign
id|len
suffix:semicolon
id|value
op_assign
id|usb_ep_queue
(paren
id|epdata-&gt;ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_else
id|value
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|epdata-&gt;dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|value
op_eq
l_int|0
)paren
)paren
(brace
id|value
op_assign
id|wait_event_interruptible
(paren
id|done.wait
comma
id|done.done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
(brace
id|spin_lock_irq
(paren
op_amp
id|epdata-&gt;dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|epdata-&gt;ep
op_ne
l_int|NULL
)paren
)paren
(brace
id|DBG
(paren
id|epdata-&gt;dev
comma
l_string|&quot;%s i/o interrupted&bslash;n&quot;
comma
id|epdata-&gt;name
)paren
suffix:semicolon
id|usb_ep_dequeue
(paren
id|epdata-&gt;ep
comma
id|epdata-&gt;req
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|epdata-&gt;dev-&gt;lock
)paren
suffix:semicolon
id|wait_event
(paren
id|done.wait
comma
id|done.done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|epdata-&gt;status
op_eq
op_minus
id|ECONNRESET
)paren
id|epdata-&gt;status
op_assign
op_minus
id|EINTR
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock_irq
(paren
op_amp
id|epdata-&gt;dev-&gt;lock
)paren
suffix:semicolon
id|DBG
(paren
id|epdata-&gt;dev
comma
l_string|&quot;endpoint gone&bslash;n&quot;
)paren
suffix:semicolon
id|epdata-&gt;status
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_return
id|epdata-&gt;status
suffix:semicolon
)brace
r_return
id|value
suffix:semicolon
)brace
multiline_comment|/* handle a synchronous OUT bulk/intr/iso transfer */
r_static
id|ssize_t
DECL|function|ep_read
id|ep_read
(paren
r_struct
id|file
op_star
id|fd
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ptr
)paren
(brace
r_struct
id|ep_data
op_star
id|data
op_assign
id|fd-&gt;private_data
suffix:semicolon
r_void
op_star
id|kbuf
suffix:semicolon
id|ssize_t
id|value
suffix:semicolon
r_if
c_cond
(paren
(paren
id|value
op_assign
id|get_ready_ep
(paren
id|fd-&gt;f_flags
comma
id|data
)paren
)paren
OL
l_int|0
)paren
r_return
id|value
suffix:semicolon
multiline_comment|/* halt any endpoint by doing a &quot;wrong direction&quot; i/o call */
r_if
c_cond
(paren
id|data-&gt;desc.bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
(brace
r_if
c_cond
(paren
(paren
id|data-&gt;desc.bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_ISOC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|DBG
(paren
id|data-&gt;dev
comma
l_string|&quot;%s halt&bslash;n&quot;
comma
id|data-&gt;name
)paren
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|data-&gt;dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|data-&gt;ep
op_ne
l_int|NULL
)paren
)paren
id|usb_ep_set_halt
(paren
id|data-&gt;ep
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|data-&gt;dev-&gt;lock
)paren
suffix:semicolon
id|up
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
r_return
op_minus
id|EBADMSG
suffix:semicolon
)brace
multiline_comment|/* FIXME readahead for O_NONBLOCK and poll(); careful with ZLPs */
id|value
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|kbuf
op_assign
id|kmalloc
(paren
id|len
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|kbuf
)paren
)paren
r_goto
id|free1
suffix:semicolon
id|value
op_assign
id|ep_io
(paren
id|data
comma
id|kbuf
comma
id|len
)paren
suffix:semicolon
id|VDEBUG
(paren
id|data-&gt;dev
comma
l_string|&quot;%s read %d OUT, status %d&bslash;n&quot;
comma
id|data-&gt;name
comma
id|len
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
l_int|0
op_logical_and
id|copy_to_user
(paren
id|buf
comma
id|kbuf
comma
id|value
)paren
)paren
id|value
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|free1
suffix:colon
id|up
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
id|kfree
(paren
id|kbuf
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
multiline_comment|/* handle a synchronous IN bulk/intr/iso transfer */
r_static
id|ssize_t
DECL|function|ep_write
id|ep_write
(paren
r_struct
id|file
op_star
id|fd
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ptr
)paren
(brace
r_struct
id|ep_data
op_star
id|data
op_assign
id|fd-&gt;private_data
suffix:semicolon
r_void
op_star
id|kbuf
suffix:semicolon
id|ssize_t
id|value
suffix:semicolon
r_if
c_cond
(paren
(paren
id|value
op_assign
id|get_ready_ep
(paren
id|fd-&gt;f_flags
comma
id|data
)paren
)paren
OL
l_int|0
)paren
r_return
id|value
suffix:semicolon
multiline_comment|/* halt any endpoint by doing a &quot;wrong direction&quot; i/o call */
r_if
c_cond
(paren
op_logical_neg
(paren
id|data-&gt;desc.bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|data-&gt;desc.bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_ISOC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|DBG
(paren
id|data-&gt;dev
comma
l_string|&quot;%s halt&bslash;n&quot;
comma
id|data-&gt;name
)paren
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|data-&gt;dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|data-&gt;ep
op_ne
l_int|NULL
)paren
)paren
id|usb_ep_set_halt
(paren
id|data-&gt;ep
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|data-&gt;dev-&gt;lock
)paren
suffix:semicolon
id|up
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
r_return
op_minus
id|EBADMSG
suffix:semicolon
)brace
multiline_comment|/* FIXME writebehind for O_NONBLOCK and poll(), qlen = 1 */
id|value
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|kbuf
op_assign
id|kmalloc
(paren
id|len
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kbuf
)paren
r_goto
id|free1
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
id|kbuf
comma
id|buf
comma
id|len
)paren
)paren
(brace
id|value
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free1
suffix:semicolon
)brace
id|value
op_assign
id|ep_io
(paren
id|data
comma
id|kbuf
comma
id|len
)paren
suffix:semicolon
id|VDEBUG
(paren
id|data-&gt;dev
comma
l_string|&quot;%s write %d IN, status %d&bslash;n&quot;
comma
id|data-&gt;name
comma
id|len
comma
id|value
)paren
suffix:semicolon
id|free1
suffix:colon
id|up
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
id|kfree
(paren
id|kbuf
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
r_static
r_int
DECL|function|ep_release
id|ep_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|fd
)paren
(brace
r_struct
id|ep_data
op_star
id|data
op_assign
id|fd-&gt;private_data
suffix:semicolon
multiline_comment|/* clean up if this can be reopened */
r_if
c_cond
(paren
id|data-&gt;state
op_ne
id|STATE_EP_UNBOUND
)paren
(brace
id|data-&gt;state
op_assign
id|STATE_EP_DISABLED
suffix:semicolon
id|data-&gt;desc.bDescriptorType
op_assign
l_int|0
suffix:semicolon
id|data-&gt;hs_desc.bDescriptorType
op_assign
l_int|0
suffix:semicolon
)brace
id|put_ep
(paren
id|data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ep_ioctl
r_static
r_int
id|ep_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|fd
comma
r_int
id|code
comma
r_int
r_int
id|value
)paren
(brace
r_struct
id|ep_data
op_star
id|data
op_assign
id|fd-&gt;private_data
suffix:semicolon
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|get_ready_ep
(paren
id|fd-&gt;f_flags
comma
id|data
)paren
)paren
OL
l_int|0
)paren
r_return
id|status
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|data-&gt;dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|data-&gt;ep
op_ne
l_int|NULL
)paren
)paren
(brace
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|GADGETFS_FIFO_STATUS
suffix:colon
id|status
op_assign
id|usb_ep_fifo_status
(paren
id|data-&gt;ep
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GADGETFS_FIFO_FLUSH
suffix:colon
id|usb_ep_fifo_flush
(paren
id|data-&gt;ep
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GADGETFS_CLEAR_HALT
suffix:colon
id|status
op_assign
id|usb_ep_clear_halt
(paren
id|data-&gt;ep
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
op_minus
id|ENOTTY
suffix:semicolon
)brace
)brace
r_else
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|data-&gt;dev-&gt;lock
)paren
suffix:semicolon
id|up
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------------*/
multiline_comment|/* ASYNCHRONOUS ENDPOINT I/O OPERATIONS (bulk/intr/iso) */
DECL|struct|kiocb_priv
r_struct
id|kiocb_priv
(brace
DECL|member|req
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
DECL|member|epdata
r_struct
id|ep_data
op_star
id|epdata
suffix:semicolon
DECL|member|buf
r_void
op_star
id|buf
suffix:semicolon
DECL|member|ubuf
r_char
id|__user
op_star
id|ubuf
suffix:semicolon
DECL|member|actual
r_int
id|actual
suffix:semicolon
)brace
suffix:semicolon
DECL|function|ep_aio_cancel
r_static
r_int
id|ep_aio_cancel
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|io_event
op_star
id|e
)paren
(brace
r_struct
id|kiocb_priv
op_star
id|priv
op_assign
id|iocb
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|ep_data
op_star
id|epdata
suffix:semicolon
r_int
id|value
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|epdata
op_assign
id|priv-&gt;epdata
suffix:semicolon
singleline_comment|// spin_lock(&amp;epdata-&gt;dev-&gt;lock);
id|kiocbSetCancelled
c_func
(paren
id|iocb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|epdata
op_logical_and
id|epdata-&gt;ep
op_logical_and
id|priv-&gt;req
)paren
)paren
id|value
op_assign
id|usb_ep_dequeue
(paren
id|epdata-&gt;ep
comma
id|priv-&gt;req
)paren
suffix:semicolon
r_else
id|value
op_assign
op_minus
id|EINVAL
suffix:semicolon
singleline_comment|// spin_unlock(&amp;epdata-&gt;dev-&gt;lock);
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|aio_put_req
c_func
(paren
id|iocb
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
DECL|function|ep_aio_read_retry
r_static
id|ssize_t
id|ep_aio_read_retry
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
r_struct
id|kiocb_priv
op_star
id|priv
op_assign
id|iocb
op_member_access_from_pointer
r_private
suffix:semicolon
id|ssize_t
id|status
op_assign
id|priv-&gt;actual
suffix:semicolon
multiline_comment|/* we &quot;retry&quot; to get the right mm context for this: */
id|status
op_assign
id|copy_to_user
c_func
(paren
id|priv-&gt;ubuf
comma
id|priv-&gt;buf
comma
id|priv-&gt;actual
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
l_int|0
op_ne
id|status
)paren
)paren
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|status
op_assign
id|priv-&gt;actual
suffix:semicolon
id|kfree
c_func
(paren
id|priv-&gt;buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|priv
)paren
suffix:semicolon
id|aio_put_req
c_func
(paren
id|iocb
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|ep_aio_complete
r_static
r_void
id|ep_aio_complete
c_func
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|kiocb
op_star
id|iocb
op_assign
id|req-&gt;context
suffix:semicolon
r_struct
id|kiocb_priv
op_star
id|priv
op_assign
id|iocb
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|ep_data
op_star
id|epdata
op_assign
id|priv-&gt;epdata
suffix:semicolon
multiline_comment|/* lock against disconnect (and ideally, cancel) */
id|spin_lock
c_func
(paren
op_amp
id|epdata-&gt;dev-&gt;lock
)paren
suffix:semicolon
id|priv-&gt;req
op_assign
l_int|NULL
suffix:semicolon
id|priv-&gt;epdata
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|iocb-&gt;ki_retry
op_logical_or
id|unlikely
c_func
(paren
l_int|0
op_eq
id|req-&gt;actual
)paren
op_logical_or
id|unlikely
c_func
(paren
id|kiocbIsCancelled
c_func
(paren
id|iocb
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|req-&gt;buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|priv
)paren
suffix:semicolon
id|iocb
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* aio_complete() reports bytes-transferred _and_ faults */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|kiocbIsCancelled
c_func
(paren
id|iocb
)paren
)paren
)paren
id|aio_put_req
c_func
(paren
id|iocb
)paren
suffix:semicolon
r_else
id|aio_complete
c_func
(paren
id|iocb
comma
id|req-&gt;actual
ques
c_cond
id|req-&gt;actual
suffix:colon
id|req-&gt;status
comma
id|req-&gt;status
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* retry() won&squot;t report both; so we hide some faults */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
l_int|0
op_ne
id|req-&gt;status
)paren
)paren
id|DBG
c_func
(paren
id|epdata-&gt;dev
comma
l_string|&quot;%s fault %d len %d&bslash;n&quot;
comma
id|ep-&gt;name
comma
id|req-&gt;status
comma
id|req-&gt;actual
)paren
suffix:semicolon
id|priv-&gt;buf
op_assign
id|req-&gt;buf
suffix:semicolon
id|priv-&gt;actual
op_assign
id|req-&gt;actual
suffix:semicolon
id|kick_iocb
c_func
(paren
id|iocb
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|epdata-&gt;dev-&gt;lock
)paren
suffix:semicolon
id|usb_ep_free_request
c_func
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
id|put_ep
c_func
(paren
id|epdata
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|ep_aio_rwtail
id|ep_aio_rwtail
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_char
op_star
id|buf
comma
r_int
id|len
comma
r_struct
id|ep_data
op_star
id|epdata
comma
r_char
id|__user
op_star
id|ubuf
)paren
(brace
r_struct
id|kiocb_priv
op_star
id|priv
op_assign
(paren
r_void
op_star
)paren
op_amp
id|iocb
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|usb_request
op_star
id|req
suffix:semicolon
id|ssize_t
id|value
suffix:semicolon
id|priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|priv
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv
)paren
(brace
id|value
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|fail
suffix:colon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
id|iocb
op_member_access_from_pointer
r_private
op_assign
id|priv
suffix:semicolon
id|priv-&gt;ubuf
op_assign
id|ubuf
suffix:semicolon
id|value
op_assign
id|get_ready_ep
c_func
(paren
id|iocb-&gt;ki_filp-&gt;f_flags
comma
id|epdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|value
OL
l_int|0
)paren
)paren
(brace
id|kfree
c_func
(paren
id|priv
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|iocb-&gt;ki_cancel
op_assign
id|ep_aio_cancel
suffix:semicolon
id|get_ep
c_func
(paren
id|epdata
)paren
suffix:semicolon
id|priv-&gt;epdata
op_assign
id|epdata
suffix:semicolon
id|priv-&gt;actual
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* each kiocb is coupled to one usb_request, but we can&squot;t&n;&t; * allocate or submit those if the host disconnected.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|epdata-&gt;dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|epdata-&gt;ep
)paren
)paren
(brace
id|req
op_assign
id|usb_ep_alloc_request
c_func
(paren
id|epdata-&gt;ep
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|req
)paren
)paren
(brace
id|priv-&gt;req
op_assign
id|req
suffix:semicolon
id|req-&gt;buf
op_assign
id|buf
suffix:semicolon
id|req-&gt;length
op_assign
id|len
suffix:semicolon
id|req-&gt;complete
op_assign
id|ep_aio_complete
suffix:semicolon
id|req-&gt;context
op_assign
id|iocb
suffix:semicolon
id|value
op_assign
id|usb_ep_queue
c_func
(paren
id|epdata-&gt;ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
l_int|0
op_ne
id|value
)paren
)paren
id|usb_ep_free_request
c_func
(paren
id|epdata-&gt;ep
comma
id|req
)paren
suffix:semicolon
)brace
r_else
id|value
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
id|value
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|epdata-&gt;dev-&gt;lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|epdata-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|value
)paren
)paren
(brace
id|kfree
c_func
(paren
id|priv
)paren
suffix:semicolon
id|put_ep
c_func
(paren
id|epdata
)paren
suffix:semicolon
)brace
r_else
id|value
op_assign
op_minus
id|EIOCBQUEUED
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|ep_aio_read
id|ep_aio_read
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_char
id|__user
op_star
id|ubuf
comma
r_int
id|len
comma
id|loff_t
id|o
)paren
(brace
r_struct
id|ep_data
op_star
id|epdata
op_assign
id|iocb-&gt;ki_filp-&gt;private_data
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|epdata-&gt;desc.bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buf
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|iocb-&gt;ki_retry
op_assign
id|ep_aio_read_retry
suffix:semicolon
r_return
id|ep_aio_rwtail
c_func
(paren
id|iocb
comma
id|buf
comma
id|len
comma
id|epdata
comma
id|ubuf
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|ep_aio_write
id|ep_aio_write
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_const
r_char
id|__user
op_star
id|ubuf
comma
r_int
id|len
comma
id|loff_t
id|o
)paren
(brace
r_struct
id|ep_data
op_star
id|epdata
op_assign
id|iocb-&gt;ki_filp-&gt;private_data
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
(paren
id|epdata-&gt;desc.bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buf
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
id|ubuf
comma
id|len
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|ep_aio_rwtail
c_func
(paren
id|iocb
comma
id|buf
comma
id|len
comma
id|epdata
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------------*/
multiline_comment|/* used after endpoint configuration */
DECL|variable|ep_io_operations
r_static
r_struct
id|file_operations
id|ep_io_operations
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|read
op_assign
id|ep_read
comma
dot
id|write
op_assign
id|ep_write
comma
dot
id|ioctl
op_assign
id|ep_ioctl
comma
dot
id|release
op_assign
id|ep_release
comma
dot
id|aio_read
op_assign
id|ep_aio_read
comma
dot
id|aio_write
op_assign
id|ep_aio_write
comma
)brace
suffix:semicolon
multiline_comment|/* ENDPOINT INITIALIZATION&n; *&n; *     fd = open (&quot;/dev/gadget/$ENDPOINT&quot;, O_RDWR)&n; *     status = write (fd, descriptors, sizeof descriptors)&n; *&n; * That write establishes the endpoint configuration, configuring&n; * the controller to process bulk, interrupt, or isochronous transfers&n; * at the right maxpacket size, and so on.&n; *&n; * The descriptors are message type 1, identified by a host order u32&n; * at the beginning of what&squot;s written.  Descriptor order is: full/low&n; * speed descriptor, then optional high speed descriptor.&n; */
r_static
id|ssize_t
DECL|function|ep_config
id|ep_config
(paren
r_struct
id|file
op_star
id|fd
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ptr
)paren
(brace
r_struct
id|ep_data
op_star
id|data
op_assign
id|fd-&gt;private_data
suffix:semicolon
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
id|u32
id|tag
suffix:semicolon
r_int
id|value
suffix:semicolon
r_if
c_cond
(paren
(paren
id|value
op_assign
id|down_interruptible
(paren
op_amp
id|data-&gt;lock
)paren
)paren
OL
l_int|0
)paren
r_return
id|value
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;state
op_ne
id|STATE_EP_READY
)paren
(brace
id|value
op_assign
op_minus
id|EL2HLT
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|value
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|USB_DT_ENDPOINT_SIZE
op_plus
l_int|4
)paren
r_goto
id|fail0
suffix:semicolon
multiline_comment|/* we might need to change message format someday */
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|tag
comma
id|buf
comma
l_int|4
)paren
)paren
(brace
r_goto
id|fail1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tag
op_ne
l_int|1
)paren
(brace
id|DBG
c_func
(paren
id|data-&gt;dev
comma
l_string|&quot;config %s, bad tag %d&bslash;n&quot;
comma
id|data-&gt;name
comma
id|tag
)paren
suffix:semicolon
r_goto
id|fail0
suffix:semicolon
)brace
id|buf
op_add_assign
l_int|4
suffix:semicolon
id|len
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* NOTE:  audio endpoint extensions not accepted here;&n;&t; * just don&squot;t include the extra bytes.&n;&t; */
multiline_comment|/* full/low speed descriptor, then high speed */
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|data-&gt;desc
comma
id|buf
comma
id|USB_DT_ENDPOINT_SIZE
)paren
)paren
(brace
r_goto
id|fail1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data-&gt;desc.bLength
op_ne
id|USB_DT_ENDPOINT_SIZE
op_logical_or
id|data-&gt;desc.bDescriptorType
op_ne
id|USB_DT_ENDPOINT
)paren
r_goto
id|fail0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|USB_DT_ENDPOINT_SIZE
)paren
(brace
r_if
c_cond
(paren
id|len
op_ne
l_int|2
op_star
id|USB_DT_ENDPOINT_SIZE
)paren
r_goto
id|fail0
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|data-&gt;hs_desc
comma
id|buf
op_plus
id|USB_DT_ENDPOINT_SIZE
comma
id|USB_DT_ENDPOINT_SIZE
)paren
)paren
(brace
r_goto
id|fail1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data-&gt;hs_desc.bLength
op_ne
id|USB_DT_ENDPOINT_SIZE
op_logical_or
id|data-&gt;hs_desc.bDescriptorType
op_ne
id|USB_DT_ENDPOINT
)paren
(brace
id|DBG
c_func
(paren
id|data-&gt;dev
comma
l_string|&quot;config %s, bad hs length or type&bslash;n&quot;
comma
id|data-&gt;name
)paren
suffix:semicolon
r_goto
id|fail0
suffix:semicolon
)brace
)brace
id|value
op_assign
id|len
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|data-&gt;dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;dev-&gt;state
op_eq
id|STATE_DEV_UNBOUND
)paren
(brace
id|value
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|gone
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ep
op_assign
id|data-&gt;ep
)paren
op_eq
l_int|NULL
)paren
(brace
id|value
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|gone
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|data-&gt;dev-&gt;gadget-&gt;speed
)paren
(brace
r_case
id|USB_SPEED_LOW
suffix:colon
r_case
id|USB_SPEED_FULL
suffix:colon
id|value
op_assign
id|usb_ep_enable
(paren
id|ep
comma
op_amp
id|data-&gt;desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
l_int|0
)paren
id|data-&gt;state
op_assign
id|STATE_EP_ENABLED
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef&t;HIGHSPEED
r_case
id|USB_SPEED_HIGH
suffix:colon
multiline_comment|/* fails if caller didn&squot;t provide that descriptor... */
id|value
op_assign
id|usb_ep_enable
(paren
id|ep
comma
op_amp
id|data-&gt;hs_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
l_int|0
)paren
id|data-&gt;state
op_assign
id|STATE_EP_ENABLED
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|DBG
(paren
id|data-&gt;dev
comma
l_string|&quot;unconnected, %s init deferred&bslash;n&quot;
comma
id|data-&gt;name
)paren
suffix:semicolon
id|data-&gt;state
op_assign
id|STATE_EP_DEFER_ENABLE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|value
op_eq
l_int|0
)paren
id|fd-&gt;f_op
op_assign
op_amp
id|ep_io_operations
suffix:semicolon
id|gone
suffix:colon
id|spin_unlock_irq
(paren
op_amp
id|data-&gt;dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|0
)paren
(brace
id|fail
suffix:colon
id|data-&gt;desc.bDescriptorType
op_assign
l_int|0
suffix:semicolon
id|data-&gt;hs_desc.bDescriptorType
op_assign
l_int|0
suffix:semicolon
)brace
id|up
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
id|fail0
suffix:colon
id|value
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|fail
suffix:semicolon
id|fail1
suffix:colon
id|value
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
r_static
r_int
DECL|function|ep_open
id|ep_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|fd
)paren
(brace
r_struct
id|ep_data
op_star
id|data
op_assign
id|inode-&gt;u.generic_ip
suffix:semicolon
r_int
id|value
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|data-&gt;lock
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|data-&gt;dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;dev-&gt;state
op_eq
id|STATE_DEV_UNBOUND
)paren
id|value
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|data-&gt;state
op_eq
id|STATE_EP_DISABLED
)paren
(brace
id|value
op_assign
l_int|0
suffix:semicolon
id|data-&gt;state
op_assign
id|STATE_EP_READY
suffix:semicolon
id|get_ep
(paren
id|data
)paren
suffix:semicolon
id|fd-&gt;private_data
op_assign
id|data
suffix:semicolon
id|VDEBUG
(paren
id|data-&gt;dev
comma
l_string|&quot;%s ready&bslash;n&quot;
comma
id|data-&gt;name
)paren
suffix:semicolon
)brace
r_else
id|DBG
(paren
id|data-&gt;dev
comma
l_string|&quot;%s state %d&bslash;n&quot;
comma
id|data-&gt;name
comma
id|data-&gt;state
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|data-&gt;dev-&gt;lock
)paren
suffix:semicolon
id|up
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
multiline_comment|/* used before endpoint configuration */
DECL|variable|ep_config_operations
r_static
r_struct
id|file_operations
id|ep_config_operations
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|open
op_assign
id|ep_open
comma
dot
id|write
op_assign
id|ep_config
comma
dot
id|release
op_assign
id|ep_release
comma
)brace
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------------*/
multiline_comment|/* EP0 IMPLEMENTATION can be partly in userspace.&n; *&n; * Drivers that use this facility receive various events, including&n; * control requests the kernel doesn&squot;t handle.  Drivers that don&squot;t&n; * use this facility may be too simple-minded for real applications.&n; */
DECL|function|ep0_readable
r_static
r_inline
r_void
id|ep0_readable
(paren
r_struct
id|dev_data
op_star
id|dev
)paren
(brace
id|wake_up
(paren
op_amp
id|dev-&gt;wait
)paren
suffix:semicolon
id|kill_fasync
(paren
op_amp
id|dev-&gt;fasync
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
)brace
DECL|function|clean_req
r_static
r_void
id|clean_req
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|ep-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;buf
op_ne
id|dev-&gt;rbuf
)paren
(brace
id|usb_ep_free_buffer
(paren
id|ep
comma
id|req-&gt;buf
comma
id|req-&gt;dma
comma
id|req-&gt;length
)paren
suffix:semicolon
id|req-&gt;buf
op_assign
id|dev-&gt;rbuf
suffix:semicolon
id|req-&gt;dma
op_assign
id|DMA_ADDR_INVALID
suffix:semicolon
)brace
id|req-&gt;complete
op_assign
id|epio_complete
suffix:semicolon
id|dev-&gt;setup_out_ready
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|ep0_complete
r_static
r_void
id|ep0_complete
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|ep-&gt;driver_data
suffix:semicolon
r_int
id|free
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* for control OUT, data must still get to userspace */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;setup_in
)paren
(brace
id|dev-&gt;setup_out_error
op_assign
(paren
id|req-&gt;status
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;setup_out_error
)paren
id|free
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;setup_out_ready
op_assign
l_int|1
suffix:semicolon
id|ep0_readable
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|STATE_SETUP
)paren
id|dev-&gt;state
op_assign
id|STATE_CONNECTED
suffix:semicolon
multiline_comment|/* clean up as appropriate */
r_if
c_cond
(paren
id|free
op_logical_and
id|req-&gt;buf
op_ne
op_amp
id|dev-&gt;rbuf
)paren
id|clean_req
(paren
id|ep
comma
id|req
)paren
suffix:semicolon
id|req-&gt;complete
op_assign
id|epio_complete
suffix:semicolon
)brace
DECL|function|setup_req
r_static
r_int
id|setup_req
(paren
r_struct
id|usb_ep
op_star
id|ep
comma
r_struct
id|usb_request
op_star
id|req
comma
id|u16
id|len
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|ep-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;setup_out_ready
)paren
(brace
id|DBG
(paren
id|dev
comma
l_string|&quot;ep0 request busy!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
r_sizeof
(paren
id|dev-&gt;rbuf
)paren
)paren
id|req-&gt;buf
op_assign
id|usb_ep_alloc_buffer
(paren
id|ep
comma
id|len
comma
op_amp
id|req-&gt;dma
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;buf
op_eq
l_int|0
)paren
(brace
id|req-&gt;buf
op_assign
id|dev-&gt;rbuf
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|req-&gt;complete
op_assign
id|ep0_complete
suffix:semicolon
id|req-&gt;length
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|ep0_read
id|ep0_read
(paren
r_struct
id|file
op_star
id|fd
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ptr
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|fd-&gt;private_data
suffix:semicolon
id|ssize_t
id|retval
suffix:semicolon
r_enum
id|ep0_state
id|state
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* report fd mode change before acting on it */
r_if
c_cond
(paren
id|dev-&gt;setup_abort
)paren
(brace
id|dev-&gt;setup_abort
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
op_minus
id|EIDRM
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* control DATA stage */
r_if
c_cond
(paren
(paren
id|state
op_assign
id|dev-&gt;state
)paren
op_eq
id|STATE_SETUP
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;setup_in
)paren
(brace
multiline_comment|/* stall IN */
id|VDEBUG
c_func
(paren
id|dev
comma
l_string|&quot;ep0in stall&bslash;n&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|usb_ep_set_halt
(paren
id|dev-&gt;gadget-&gt;ep0
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EL2HLT
suffix:semicolon
id|dev-&gt;state
op_assign
id|STATE_CONNECTED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
(brace
multiline_comment|/* ack SET_CONFIGURATION etc */
r_struct
id|usb_ep
op_star
id|ep
op_assign
id|dev-&gt;gadget-&gt;ep0
suffix:semicolon
r_struct
id|usb_request
op_star
id|req
op_assign
id|dev-&gt;req
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|setup_req
(paren
id|ep
comma
id|req
comma
l_int|0
)paren
)paren
op_eq
l_int|0
)paren
id|retval
op_assign
id|usb_ep_queue
(paren
id|ep
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|dev-&gt;state
op_assign
id|STATE_CONNECTED
suffix:semicolon
multiline_comment|/* assume that was SET_CONFIGURATION */
r_if
c_cond
(paren
id|dev-&gt;current_config
)paren
(brace
r_int
id|power
suffix:semicolon
macro_line|#ifdef&t;HIGHSPEED
r_if
c_cond
(paren
id|dev-&gt;gadget-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
id|power
op_assign
id|dev-&gt;hs_config-&gt;bMaxPower
suffix:semicolon
r_else
macro_line|#endif
id|power
op_assign
id|dev-&gt;config-&gt;bMaxPower
suffix:semicolon
id|usb_gadget_vbus_draw
c_func
(paren
id|dev-&gt;gadget
comma
l_int|2
op_star
id|power
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* collect OUT data */
r_if
c_cond
(paren
(paren
id|fd-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
op_ne
l_int|0
op_logical_and
op_logical_neg
id|dev-&gt;setup_out_ready
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|retval
op_assign
id|wait_event_interruptible
(paren
id|dev-&gt;wait
comma
id|dev-&gt;setup_out_ready
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* FIXME state could change from under us */
id|spin_lock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;setup_out_error
)paren
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_else
(brace
id|len
op_assign
id|min
(paren
id|len
comma
(paren
r_int
)paren
id|dev-&gt;req-&gt;actual
)paren
suffix:semicolon
singleline_comment|// FIXME don&squot;t call this with the spinlock held ...
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buf
comma
op_amp
id|dev-&gt;req-&gt;buf
comma
id|len
)paren
)paren
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|clean_req
(paren
id|dev-&gt;gadget-&gt;ep0
comma
id|dev-&gt;req
)paren
suffix:semicolon
multiline_comment|/* NOTE userspace can&squot;t yet choose to stall */
)brace
)brace
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* else normal: return event data */
r_if
c_cond
(paren
id|len
OL
r_sizeof
id|dev-&gt;event
(braket
l_int|0
)braket
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|len
op_sub_assign
id|len
op_mod
r_sizeof
(paren
r_struct
id|usb_gadgetfs_event
)paren
suffix:semicolon
id|dev-&gt;usermode_setup
op_assign
l_int|1
suffix:semicolon
id|scan
suffix:colon
multiline_comment|/* return queued events right away */
r_if
c_cond
(paren
id|dev-&gt;ev_next
op_ne
l_int|0
)paren
(brace
r_int
id|i
comma
id|n
suffix:semicolon
r_int
id|tmp
op_assign
id|dev-&gt;ev_next
suffix:semicolon
id|len
op_assign
id|min
(paren
id|len
comma
id|tmp
op_star
r_sizeof
(paren
r_struct
id|usb_gadgetfs_event
)paren
)paren
suffix:semicolon
id|n
op_assign
id|len
op_div
r_sizeof
(paren
r_struct
id|usb_gadgetfs_event
)paren
suffix:semicolon
multiline_comment|/* ep0 can&squot;t deliver events when STATE_SETUP */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;event
(braket
id|i
)braket
dot
id|type
op_eq
id|GADGETFS_SETUP
)paren
(brace
id|len
op_assign
id|n
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|len
op_mul_assign
r_sizeof
(paren
r_struct
id|usb_gadgetfs_event
)paren
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buf
comma
op_amp
id|dev-&gt;event
comma
id|len
)paren
)paren
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|retval
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|len
op_div_assign
r_sizeof
(paren
r_struct
id|usb_gadgetfs_event
)paren
suffix:semicolon
multiline_comment|/* NOTE this doesn&squot;t guard against broken drivers;&n;&t;&t;&t; * concurrent ep0 readers may lose events.&n;&t;&t;&t; */
id|spin_lock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|dev-&gt;ev_next
op_sub_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;ev_next
op_ne
l_int|0
)paren
id|memmove
(paren
op_amp
id|dev-&gt;event
comma
op_amp
id|dev-&gt;event
(braket
id|len
)braket
comma
r_sizeof
(paren
r_struct
id|usb_gadgetfs_event
)paren
op_star
(paren
id|tmp
op_minus
id|len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
id|dev-&gt;state
op_assign
id|STATE_SETUP
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fd-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|state
)paren
(brace
r_default
suffix:colon
id|DBG
(paren
id|dev
comma
l_string|&quot;fail %s, state %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|state
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATE_UNCONNECTED
suffix:colon
r_case
id|STATE_CONNECTED
suffix:colon
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|DBG
(paren
id|dev
comma
l_string|&quot;%s wait&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* wait for events */
id|retval
op_assign
id|wait_event_interruptible
(paren
id|dev-&gt;wait
comma
id|dev-&gt;ev_next
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_goto
id|scan
suffix:semicolon
)brace
id|done
suffix:colon
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_struct
id|usb_gadgetfs_event
op_star
DECL|function|next_event
id|next_event
(paren
r_struct
id|dev_data
op_star
id|dev
comma
r_enum
id|usb_gadgetfs_event_type
id|type
)paren
(brace
r_struct
id|usb_gadgetfs_event
op_star
id|event
suffix:semicolon
r_int
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
multiline_comment|/* these events purge the queue */
r_case
id|GADGETFS_DISCONNECT
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|STATE_SETUP
)paren
id|dev-&gt;setup_abort
op_assign
l_int|1
suffix:semicolon
singleline_comment|// FALL THROUGH
r_case
id|GADGETFS_CONNECT
suffix:colon
id|dev-&gt;ev_next
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GADGETFS_SETUP
suffix:colon
multiline_comment|/* previous request timed out */
r_case
id|GADGETFS_SUSPEND
suffix:colon
multiline_comment|/* same effect */
multiline_comment|/* these events can&squot;t be repeated */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_ne
id|dev-&gt;ev_next
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;event
(braket
id|i
)braket
dot
id|type
op_ne
id|type
)paren
r_continue
suffix:semicolon
id|DBG
(paren
id|dev
comma
l_string|&quot;discard old event %d&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
id|dev-&gt;ev_next
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|dev-&gt;ev_next
)paren
r_break
suffix:semicolon
multiline_comment|/* indices start at zero, for simplicity */
id|memmove
(paren
op_amp
id|dev-&gt;event
(braket
id|i
)braket
comma
op_amp
id|dev-&gt;event
(braket
id|i
op_plus
l_int|1
)braket
comma
r_sizeof
(paren
r_struct
id|usb_gadgetfs_event
)paren
op_star
(paren
id|dev-&gt;ev_next
op_minus
id|i
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
(paren
)paren
suffix:semicolon
)brace
id|event
op_assign
op_amp
id|dev-&gt;event
(braket
id|dev-&gt;ev_next
op_increment
)braket
suffix:semicolon
id|BUG_ON
(paren
id|dev-&gt;ev_next
OG
id|N_EVENT
)paren
suffix:semicolon
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;ev %d, next %d&bslash;n&quot;
comma
id|type
comma
id|dev-&gt;ev_next
)paren
suffix:semicolon
id|memset
(paren
id|event
comma
l_int|0
comma
r_sizeof
op_star
id|event
)paren
suffix:semicolon
id|event-&gt;type
op_assign
id|type
suffix:semicolon
r_return
id|event
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|ep0_write
id|ep0_write
(paren
r_struct
id|file
op_star
id|fd
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ptr
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|fd-&gt;private_data
suffix:semicolon
id|ssize_t
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* report fd mode change before acting on it */
r_if
c_cond
(paren
id|dev-&gt;setup_abort
)paren
(brace
id|dev-&gt;setup_abort
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
op_minus
id|EIDRM
suffix:semicolon
multiline_comment|/* data and/or status stage for control request */
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|STATE_SETUP
)paren
(brace
multiline_comment|/* IN DATA+STATUS caller makes len &lt;= wLength */
r_if
c_cond
(paren
id|dev-&gt;setup_in
)paren
(brace
id|retval
op_assign
id|setup_req
(paren
id|dev-&gt;gadget-&gt;ep0
comma
id|dev-&gt;req
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
id|dev-&gt;req-&gt;buf
comma
id|buf
comma
id|len
)paren
)paren
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|retval
op_assign
id|usb_ep_queue
(paren
id|dev-&gt;gadget-&gt;ep0
comma
id|dev-&gt;req
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|spin_lock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|clean_req
(paren
id|dev-&gt;gadget-&gt;ep0
comma
id|dev-&gt;req
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
)brace
r_else
id|retval
op_assign
id|len
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* can stall some OUT transfers */
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;setup_can_stall
)paren
(brace
id|VDEBUG
c_func
(paren
id|dev
comma
l_string|&quot;ep0out stall&bslash;n&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|usb_ep_set_halt
(paren
id|dev-&gt;gadget-&gt;ep0
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EL2HLT
suffix:semicolon
id|dev-&gt;state
op_assign
id|STATE_CONNECTED
suffix:semicolon
)brace
r_else
(brace
id|DBG
c_func
(paren
id|dev
comma
l_string|&quot;bogus ep0out stall!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
id|DBG
(paren
id|dev
comma
l_string|&quot;fail %s, state %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|dev-&gt;state
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_int
DECL|function|ep0_fasync
id|ep0_fasync
(paren
r_int
id|f
comma
r_struct
id|file
op_star
id|fd
comma
r_int
id|on
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|fd-&gt;private_data
suffix:semicolon
singleline_comment|// caller must F_SETOWN before signal delivery happens
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;%s %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|on
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
r_return
id|fasync_helper
(paren
id|f
comma
id|fd
comma
id|on
comma
op_amp
id|dev-&gt;fasync
)paren
suffix:semicolon
)brace
DECL|variable|gadgetfs_driver
r_static
r_struct
id|usb_gadget_driver
id|gadgetfs_driver
suffix:semicolon
r_static
r_int
DECL|function|dev_release
id|dev_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|fd
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|fd-&gt;private_data
suffix:semicolon
multiline_comment|/* closing ep0 === shutdown all */
id|usb_gadget_unregister_driver
(paren
op_amp
id|gadgetfs_driver
)paren
suffix:semicolon
multiline_comment|/* at this point &quot;good&quot; hardware has disconnected the&n;&t; * device from USB; the host won&squot;t see it any more.&n;&t; * alternatively, all host requests will time out.&n;&t; */
id|fasync_helper
(paren
op_minus
l_int|1
comma
id|fd
comma
l_int|0
comma
op_amp
id|dev-&gt;fasync
)paren
suffix:semicolon
id|kfree
(paren
id|dev-&gt;buf
)paren
suffix:semicolon
id|dev-&gt;buf
op_assign
l_int|NULL
suffix:semicolon
id|put_dev
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* other endpoints were all decoupled from this device */
id|dev-&gt;state
op_assign
id|STATE_DEV_DISABLED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dev_ioctl
r_static
r_int
id|dev_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|fd
comma
r_int
id|code
comma
r_int
r_int
id|value
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|fd-&gt;private_data
suffix:semicolon
r_struct
id|usb_gadget
op_star
id|gadget
op_assign
id|dev-&gt;gadget
suffix:semicolon
r_if
c_cond
(paren
id|gadget-&gt;ops-&gt;ioctl
)paren
r_return
id|gadget-&gt;ops-&gt;ioctl
(paren
id|gadget
comma
id|code
comma
id|value
)paren
suffix:semicolon
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
multiline_comment|/* used after device configuration */
DECL|variable|ep0_io_operations
r_static
r_struct
id|file_operations
id|ep0_io_operations
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|read
op_assign
id|ep0_read
comma
dot
id|write
op_assign
id|ep0_write
comma
dot
id|fasync
op_assign
id|ep0_fasync
comma
singleline_comment|// .poll =&t;ep0_poll,
dot
id|ioctl
op_assign
id|dev_ioctl
comma
dot
id|release
op_assign
id|dev_release
comma
)brace
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------------*/
multiline_comment|/* The in-kernel gadget driver handles most ep0 issues, in particular&n; * enumerating the single configuration (as provided from user space).&n; *&n; * Unrecognized ep0 requests may be handled in user space.&n; */
macro_line|#ifdef&t;HIGHSPEED
DECL|function|make_qualifier
r_static
r_void
id|make_qualifier
(paren
r_struct
id|dev_data
op_star
id|dev
)paren
(brace
r_struct
id|usb_qualifier_descriptor
id|qual
suffix:semicolon
r_struct
id|usb_device_descriptor
op_star
id|desc
suffix:semicolon
id|qual.bLength
op_assign
r_sizeof
id|qual
suffix:semicolon
id|qual.bDescriptorType
op_assign
id|USB_DT_DEVICE_QUALIFIER
suffix:semicolon
id|qual.bcdUSB
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0200
)paren
suffix:semicolon
id|desc
op_assign
id|dev-&gt;dev
suffix:semicolon
id|qual.bDeviceClass
op_assign
id|desc-&gt;bDeviceClass
suffix:semicolon
id|qual.bDeviceSubClass
op_assign
id|desc-&gt;bDeviceSubClass
suffix:semicolon
id|qual.bDeviceProtocol
op_assign
id|desc-&gt;bDeviceProtocol
suffix:semicolon
multiline_comment|/* assumes ep0 uses the same value for both speeds ... */
id|qual.bMaxPacketSize0
op_assign
id|desc-&gt;bMaxPacketSize0
suffix:semicolon
id|qual.bNumConfigurations
op_assign
l_int|1
suffix:semicolon
id|qual.bRESERVED
op_assign
l_int|0
suffix:semicolon
id|memcpy
(paren
id|dev-&gt;rbuf
comma
op_amp
id|qual
comma
r_sizeof
id|qual
)paren
suffix:semicolon
)brace
macro_line|#endif
r_static
r_int
DECL|function|config_buf
id|config_buf
(paren
r_struct
id|dev_data
op_star
id|dev
comma
id|u8
id|type
comma
r_int
id|index
)paren
(brace
r_int
id|len
suffix:semicolon
macro_line|#ifdef HIGHSPEED
r_int
id|hs
suffix:semicolon
macro_line|#endif
multiline_comment|/* only one configuration */
r_if
c_cond
(paren
id|index
OG
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef HIGHSPEED
id|hs
op_assign
(paren
id|dev-&gt;gadget-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|USB_DT_OTHER_SPEED_CONFIG
)paren
id|hs
op_assign
op_logical_neg
id|hs
suffix:semicolon
r_if
c_cond
(paren
id|hs
)paren
(brace
id|dev-&gt;req-&gt;buf
op_assign
id|dev-&gt;hs_config
suffix:semicolon
id|len
op_assign
id|le16_to_cpup
(paren
op_amp
id|dev-&gt;hs_config-&gt;wTotalLength
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|dev-&gt;req-&gt;buf
op_assign
id|dev-&gt;config
suffix:semicolon
id|len
op_assign
id|le16_to_cpup
(paren
op_amp
id|dev-&gt;config-&gt;wTotalLength
)paren
suffix:semicolon
)brace
(paren
(paren
id|u8
op_star
)paren
id|dev-&gt;req-&gt;buf
)paren
(braket
l_int|1
)braket
op_assign
id|type
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_static
r_int
DECL|function|gadgetfs_setup
id|gadgetfs_setup
(paren
r_struct
id|usb_gadget
op_star
id|gadget
comma
r_const
r_struct
id|usb_ctrlrequest
op_star
id|ctrl
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|get_gadget_data
(paren
id|gadget
)paren
suffix:semicolon
r_struct
id|usb_request
op_star
id|req
op_assign
id|dev-&gt;req
suffix:semicolon
r_int
id|value
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_struct
id|usb_gadgetfs_event
op_star
id|event
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|dev-&gt;setup_abort
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|STATE_UNCONNECTED
)paren
(brace
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
r_struct
id|ep_data
op_star
id|data
suffix:semicolon
id|dev-&gt;state
op_assign
id|STATE_CONNECTED
suffix:semicolon
id|dev-&gt;dev-&gt;bMaxPacketSize0
op_assign
id|gadget-&gt;ep0-&gt;maxpacket
suffix:semicolon
macro_line|#ifdef&t;HIGHSPEED
r_if
c_cond
(paren
id|gadget-&gt;speed
op_eq
id|USB_SPEED_HIGH
op_logical_and
id|dev-&gt;hs_config
op_eq
l_int|0
)paren
(brace
id|ERROR
(paren
id|dev
comma
l_string|&quot;no high speed config??&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif&t;/* HIGHSPEED */
id|INFO
(paren
id|dev
comma
l_string|&quot;connected&bslash;n&quot;
)paren
suffix:semicolon
id|event
op_assign
id|next_event
(paren
id|dev
comma
id|GADGETFS_CONNECT
)paren
suffix:semicolon
id|event-&gt;u.speed
op_assign
id|gadget-&gt;speed
suffix:semicolon
id|ep0_readable
(paren
id|dev
)paren
suffix:semicolon
id|list_for_each_entry
(paren
id|ep
comma
op_amp
id|gadget-&gt;ep_list
comma
id|ep_list
)paren
(brace
id|data
op_assign
id|ep-&gt;driver_data
suffix:semicolon
multiline_comment|/* ... down_trylock (&amp;data-&gt;lock) ... */
r_if
c_cond
(paren
id|data-&gt;state
op_ne
id|STATE_EP_DEFER_ENABLE
)paren
r_continue
suffix:semicolon
macro_line|#ifdef&t;HIGHSPEED
r_if
c_cond
(paren
id|gadget-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
id|value
op_assign
id|usb_ep_enable
(paren
id|ep
comma
op_amp
id|data-&gt;hs_desc
)paren
suffix:semicolon
r_else
macro_line|#endif&t;/* HIGHSPEED */
id|value
op_assign
id|usb_ep_enable
(paren
id|ep
comma
op_amp
id|data-&gt;desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
)paren
(brace
id|ERROR
(paren
id|dev
comma
l_string|&quot;deferred %s enable --&gt; %d&bslash;n&quot;
comma
id|data-&gt;name
comma
id|value
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|data-&gt;state
op_assign
id|STATE_EP_ENABLED
suffix:semicolon
id|wake_up
(paren
op_amp
id|data-&gt;wait
)paren
suffix:semicolon
id|DBG
(paren
id|dev
comma
l_string|&quot;woke up %s waiters&bslash;n&quot;
comma
id|data-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* host may have given up waiting for response.  we can miss control&n;&t; * requests handled lower down (device/endpoint status and features);&n;&t; * then ep0_{read,write} will report the wrong status. controller&n;&t; * driver will have aborted pending i/o.&n;&t; */
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|STATE_SETUP
)paren
id|dev-&gt;setup_abort
op_assign
l_int|1
suffix:semicolon
id|req-&gt;buf
op_assign
id|dev-&gt;rbuf
suffix:semicolon
id|req-&gt;dma
op_assign
id|DMA_ADDR_INVALID
suffix:semicolon
id|req-&gt;context
op_assign
l_int|NULL
suffix:semicolon
id|value
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_switch
c_cond
(paren
id|ctrl-&gt;bRequest
)paren
(brace
r_case
id|USB_REQ_GET_DESCRIPTOR
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
id|USB_DIR_IN
)paren
r_goto
id|unrecognized
suffix:semicolon
r_switch
c_cond
(paren
id|ctrl-&gt;wValue
op_rshift
l_int|8
)paren
(brace
r_case
id|USB_DT_DEVICE
suffix:colon
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
r_sizeof
op_star
id|dev-&gt;dev
)paren
suffix:semicolon
id|req-&gt;buf
op_assign
id|dev-&gt;dev
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef&t;HIGHSPEED
r_case
id|USB_DT_DEVICE_QUALIFIER
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;hs_config
)paren
r_break
suffix:semicolon
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
r_sizeof
(paren
r_struct
id|usb_qualifier_descriptor
)paren
)paren
suffix:semicolon
id|make_qualifier
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_OTHER_SPEED_CONFIG
suffix:colon
singleline_comment|// FALLTHROUGH
macro_line|#endif
r_case
id|USB_DT_CONFIG
suffix:colon
id|value
op_assign
id|config_buf
(paren
id|dev
comma
id|ctrl-&gt;wValue
op_rshift
l_int|8
comma
id|ctrl-&gt;wValue
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
l_int|0
)paren
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_STRING
suffix:colon
r_goto
id|unrecognized
suffix:semicolon
r_default
suffix:colon
singleline_comment|// all others are errors
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* currently one config, two speeds */
r_case
id|USB_REQ_SET_CONFIGURATION
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
(paren
id|u8
)paren
id|ctrl-&gt;wValue
)paren
(brace
id|value
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;current_config
op_assign
l_int|0
suffix:semicolon
id|usb_gadget_vbus_draw
c_func
(paren
id|gadget
comma
l_int|8
multiline_comment|/* mA */
)paren
suffix:semicolon
singleline_comment|// user mode expected to disable endpoints
)brace
r_else
(brace
id|u8
id|config
comma
id|power
suffix:semicolon
macro_line|#ifdef&t;HIGHSPEED
r_if
c_cond
(paren
id|gadget-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
(brace
id|config
op_assign
id|dev-&gt;hs_config-&gt;bConfigurationValue
suffix:semicolon
id|power
op_assign
id|dev-&gt;hs_config-&gt;bMaxPower
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|config
op_assign
id|dev-&gt;config-&gt;bConfigurationValue
suffix:semicolon
id|power
op_assign
id|dev-&gt;config-&gt;bMaxPower
suffix:semicolon
)brace
r_if
c_cond
(paren
id|config
op_eq
(paren
id|u8
)paren
id|ctrl-&gt;wValue
)paren
(brace
id|value
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;current_config
op_assign
id|config
suffix:semicolon
id|usb_gadget_vbus_draw
c_func
(paren
id|gadget
comma
l_int|2
op_star
id|power
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* report SET_CONFIGURATION like any other control request,&n;&t;&t; * except that usermode may not stall this.  the next&n;&t;&t; * request mustn&squot;t be allowed start until this finishes:&n;&t;&t; * endpoints and threads set up, etc.&n;&t;&t; *&n;&t;&t; * NOTE:  older PXA hardware (before PXA 255: without UDCCFR)&n;&t;&t; * has bad/racey automagic that prevents synchronizing here.&n;&t;&t; * even kernel mode drivers often miss them.&n;&t;&t; */
r_if
c_cond
(paren
id|value
op_eq
l_int|0
)paren
(brace
id|INFO
(paren
id|dev
comma
l_string|&quot;configuration #%d&bslash;n&quot;
comma
id|dev-&gt;current_config
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;usermode_setup
)paren
(brace
id|dev-&gt;setup_can_stall
op_assign
l_int|0
suffix:semicolon
r_goto
id|delegate
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
macro_line|#ifndef&t;CONFIG_USB_GADGETFS_PXA2XX
multiline_comment|/* PXA automagically handles this request too */
r_case
id|USB_REQ_GET_CONFIGURATION
suffix:colon
r_if
c_cond
(paren
id|ctrl-&gt;bRequestType
op_ne
l_int|0x80
)paren
r_break
suffix:semicolon
op_star
(paren
id|u8
op_star
)paren
id|req-&gt;buf
op_assign
id|dev-&gt;current_config
suffix:semicolon
id|value
op_assign
id|min
(paren
id|ctrl-&gt;wLength
comma
(paren
id|u16
)paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|unrecognized
suffix:colon
id|VDEBUG
(paren
id|dev
comma
l_string|&quot;%s req%02x.%02x v%04x i%04x l%d&bslash;n&quot;
comma
id|dev-&gt;usermode_setup
ques
c_cond
l_string|&quot;delegate&quot;
suffix:colon
l_string|&quot;fail&quot;
comma
id|ctrl-&gt;bRequestType
comma
id|ctrl-&gt;bRequest
comma
id|ctrl-&gt;wValue
comma
id|ctrl-&gt;wIndex
comma
id|ctrl-&gt;wLength
)paren
suffix:semicolon
multiline_comment|/* if there&squot;s an ep0 reader, don&squot;t stall */
r_if
c_cond
(paren
id|dev-&gt;usermode_setup
)paren
(brace
id|dev-&gt;setup_can_stall
op_assign
l_int|1
suffix:semicolon
id|delegate
suffix:colon
id|dev-&gt;setup_in
op_assign
(paren
id|ctrl-&gt;bRequestType
op_amp
id|USB_DIR_IN
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|dev-&gt;setup_out_ready
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;setup_out_error
op_assign
l_int|0
suffix:semicolon
id|value
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* read DATA stage for OUT right away */
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|dev-&gt;setup_in
op_logical_and
id|ctrl-&gt;wLength
)paren
)paren
(brace
id|value
op_assign
id|setup_req
(paren
id|gadget-&gt;ep0
comma
id|dev-&gt;req
comma
id|ctrl-&gt;wLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|0
)paren
r_break
suffix:semicolon
id|value
op_assign
id|usb_ep_queue
(paren
id|gadget-&gt;ep0
comma
id|dev-&gt;req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|0
)paren
(brace
id|clean_req
(paren
id|gadget-&gt;ep0
comma
id|dev-&gt;req
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* we can&squot;t currently stall these */
id|dev-&gt;setup_can_stall
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* state changes when reader collects event */
id|event
op_assign
id|next_event
(paren
id|dev
comma
id|GADGETFS_SETUP
)paren
suffix:semicolon
id|event-&gt;u.setup
op_assign
op_star
id|ctrl
suffix:semicolon
id|ep0_readable
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* proceed with data transfer and status phases? */
r_if
c_cond
(paren
id|value
op_ge
l_int|0
op_logical_and
id|dev-&gt;state
op_ne
id|STATE_SETUP
)paren
(brace
id|req-&gt;length
op_assign
id|value
suffix:semicolon
id|req-&gt;zero
op_assign
id|value
OL
id|ctrl-&gt;wLength
op_logical_and
(paren
id|value
op_mod
id|gadget-&gt;ep0-&gt;maxpacket
)paren
op_eq
l_int|0
suffix:semicolon
id|value
op_assign
id|usb_ep_queue
(paren
id|gadget-&gt;ep0
comma
id|req
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|0
)paren
(brace
id|DBG
(paren
id|dev
comma
l_string|&quot;ep_queue --&gt; %d&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
id|req-&gt;status
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* device stalls when value &lt; 0 */
id|spin_unlock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
DECL|function|destroy_ep_files
r_static
r_void
id|destroy_ep_files
(paren
r_struct
id|dev_data
op_star
id|dev
)paren
(brace
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|tmp
suffix:semicolon
id|DBG
(paren
id|dev
comma
l_string|&quot;%s %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|dev-&gt;state
)paren
suffix:semicolon
multiline_comment|/* dev-&gt;state must prevent interference */
id|restart
suffix:colon
id|spin_lock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|list_for_each_safe
(paren
id|entry
comma
id|tmp
comma
op_amp
id|dev-&gt;epfiles
)paren
(brace
r_struct
id|ep_data
op_star
id|ep
suffix:semicolon
r_struct
id|inode
op_star
id|parent
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
multiline_comment|/* break link to FS */
id|ep
op_assign
id|list_entry
(paren
id|entry
comma
r_struct
id|ep_data
comma
id|epfiles
)paren
suffix:semicolon
id|list_del_init
(paren
op_amp
id|ep-&gt;epfiles
)paren
suffix:semicolon
id|dentry
op_assign
id|ep-&gt;dentry
suffix:semicolon
id|ep-&gt;dentry
op_assign
l_int|NULL
suffix:semicolon
id|parent
op_assign
id|dentry-&gt;d_parent-&gt;d_inode
suffix:semicolon
multiline_comment|/* break link to controller */
r_if
c_cond
(paren
id|ep-&gt;state
op_eq
id|STATE_EP_ENABLED
)paren
(paren
r_void
)paren
id|usb_ep_disable
(paren
id|ep-&gt;ep
)paren
suffix:semicolon
id|ep-&gt;state
op_assign
id|STATE_EP_UNBOUND
suffix:semicolon
id|usb_ep_free_request
(paren
id|ep-&gt;ep
comma
id|ep-&gt;req
)paren
suffix:semicolon
id|ep-&gt;ep
op_assign
l_int|NULL
suffix:semicolon
id|wake_up
(paren
op_amp
id|ep-&gt;wait
)paren
suffix:semicolon
id|put_ep
(paren
id|ep
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* break link to dcache */
id|down
(paren
op_amp
id|parent-&gt;i_sem
)paren
suffix:semicolon
id|d_delete
(paren
id|dentry
)paren
suffix:semicolon
id|dput
(paren
id|dentry
)paren
suffix:semicolon
id|up
(paren
op_amp
id|parent-&gt;i_sem
)paren
suffix:semicolon
multiline_comment|/* fds may still be open */
r_goto
id|restart
suffix:semicolon
)brace
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
)brace
r_static
r_struct
id|inode
op_star
id|gadgetfs_create_file
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_char
r_const
op_star
id|name
comma
r_void
op_star
id|data
comma
r_struct
id|file_operations
op_star
id|fops
comma
r_struct
id|dentry
op_star
op_star
id|dentry_p
)paren
suffix:semicolon
DECL|function|activate_ep_files
r_static
r_int
id|activate_ep_files
(paren
r_struct
id|dev_data
op_star
id|dev
)paren
(brace
r_struct
id|usb_ep
op_star
id|ep
suffix:semicolon
id|gadget_for_each_ep
(paren
id|ep
comma
id|dev-&gt;gadget
)paren
(brace
r_struct
id|ep_data
op_star
id|data
suffix:semicolon
id|data
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|data
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_goto
id|enomem
suffix:semicolon
id|memset
(paren
id|data
comma
l_int|0
comma
r_sizeof
id|data
)paren
suffix:semicolon
id|data-&gt;state
op_assign
id|STATE_EP_DISABLED
suffix:semicolon
id|init_MUTEX
(paren
op_amp
id|data-&gt;lock
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|data-&gt;wait
)paren
suffix:semicolon
id|strncpy
(paren
id|data-&gt;name
comma
id|ep-&gt;name
comma
r_sizeof
(paren
id|data-&gt;name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|atomic_set
(paren
op_amp
id|data-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|data-&gt;dev
op_assign
id|dev
suffix:semicolon
id|get_dev
(paren
id|dev
)paren
suffix:semicolon
id|data-&gt;ep
op_assign
id|ep
suffix:semicolon
id|ep-&gt;driver_data
op_assign
id|data
suffix:semicolon
id|data-&gt;req
op_assign
id|usb_ep_alloc_request
(paren
id|ep
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data-&gt;req
)paren
r_goto
id|enomem
suffix:semicolon
id|data-&gt;inode
op_assign
id|gadgetfs_create_file
(paren
id|dev-&gt;sb
comma
id|data-&gt;name
comma
id|data
comma
op_amp
id|ep_config_operations
comma
op_amp
id|data-&gt;dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data-&gt;inode
)paren
(brace
id|kfree
(paren
id|data
)paren
suffix:semicolon
r_goto
id|enomem
suffix:semicolon
)brace
id|list_add_tail
(paren
op_amp
id|data-&gt;epfiles
comma
op_amp
id|dev-&gt;epfiles
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|enomem
suffix:colon
id|DBG
(paren
id|dev
comma
l_string|&quot;%s enomem&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|destroy_ep_files
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_static
r_void
DECL|function|gadgetfs_unbind
id|gadgetfs_unbind
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|get_gadget_data
(paren
id|gadget
)paren
suffix:semicolon
id|DBG
(paren
id|dev
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|dev-&gt;state
op_assign
id|STATE_DEV_UNBOUND
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|destroy_ep_files
(paren
id|dev
)paren
suffix:semicolon
id|gadget-&gt;ep0-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
id|set_gadget_data
(paren
id|gadget
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* we&squot;ve already been disconnected ... no i/o is active */
r_if
c_cond
(paren
id|dev-&gt;req
)paren
id|usb_ep_free_request
(paren
id|gadget-&gt;ep0
comma
id|dev-&gt;req
)paren
suffix:semicolon
id|DBG
(paren
id|dev
comma
l_string|&quot;%s done&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|put_dev
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|variable|the_device
r_static
r_struct
id|dev_data
op_star
id|the_device
suffix:semicolon
r_static
r_int
DECL|function|gadgetfs_bind
id|gadgetfs_bind
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|the_device
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|strcmp
(paren
id|CHIP
comma
id|gadget-&gt;name
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s expected %s controller not %s&bslash;n&quot;
comma
id|shortname
comma
id|CHIP
comma
id|gadget-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|set_gadget_data
(paren
id|gadget
comma
id|dev
)paren
suffix:semicolon
id|dev-&gt;gadget
op_assign
id|gadget
suffix:semicolon
id|gadget-&gt;ep0-&gt;driver_data
op_assign
id|dev
suffix:semicolon
id|dev-&gt;dev-&gt;bMaxPacketSize0
op_assign
id|gadget-&gt;ep0-&gt;maxpacket
suffix:semicolon
multiline_comment|/* preallocate control response and buffer */
id|dev-&gt;req
op_assign
id|usb_ep_alloc_request
(paren
id|gadget-&gt;ep0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;req
)paren
r_goto
id|enomem
suffix:semicolon
id|dev-&gt;req-&gt;context
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;req-&gt;complete
op_assign
id|epio_complete
suffix:semicolon
r_if
c_cond
(paren
id|activate_ep_files
(paren
id|dev
)paren
OL
l_int|0
)paren
r_goto
id|enomem
suffix:semicolon
id|INFO
(paren
id|dev
comma
l_string|&quot;bound to %s driver&bslash;n&quot;
comma
id|gadget-&gt;name
)paren
suffix:semicolon
id|dev-&gt;state
op_assign
id|STATE_UNCONNECTED
suffix:semicolon
id|get_dev
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|enomem
suffix:colon
id|gadgetfs_unbind
(paren
id|gadget
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_static
r_void
DECL|function|gadgetfs_disconnect
id|gadgetfs_disconnect
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|get_gadget_data
(paren
id|gadget
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|STATE_UNCONNECTED
)paren
(brace
id|DBG
(paren
id|dev
comma
l_string|&quot;already unconnected&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev-&gt;state
op_assign
id|STATE_UNCONNECTED
suffix:semicolon
id|INFO
(paren
id|dev
comma
l_string|&quot;disconnected&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|next_event
(paren
id|dev
comma
id|GADGETFS_DISCONNECT
)paren
suffix:semicolon
id|ep0_readable
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gadgetfs_suspend
id|gadgetfs_suspend
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|get_gadget_data
(paren
id|gadget
)paren
suffix:semicolon
id|INFO
(paren
id|dev
comma
l_string|&quot;suspended from state %d&bslash;n&quot;
comma
id|dev-&gt;state
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|dev-&gt;state
)paren
(brace
r_case
id|STATE_SETUP
suffix:colon
singleline_comment|// VERY odd... host died??
r_case
id|STATE_CONNECTED
suffix:colon
r_case
id|STATE_UNCONNECTED
suffix:colon
id|next_event
(paren
id|dev
comma
id|GADGETFS_SUSPEND
)paren
suffix:semicolon
id|ep0_readable
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
)brace
DECL|variable|gadgetfs_driver
r_static
r_struct
id|usb_gadget_driver
id|gadgetfs_driver
op_assign
(brace
macro_line|#ifdef&t;HIGHSPEED
dot
id|speed
op_assign
id|USB_SPEED_HIGH
comma
macro_line|#else
dot
id|speed
op_assign
id|USB_SPEED_FULL
comma
macro_line|#endif
dot
id|function
op_assign
(paren
r_char
op_star
)paren
id|driver_desc
comma
dot
id|bind
op_assign
id|gadgetfs_bind
comma
dot
id|unbind
op_assign
id|gadgetfs_unbind
comma
dot
id|setup
op_assign
id|gadgetfs_setup
comma
dot
id|disconnect
op_assign
id|gadgetfs_disconnect
comma
dot
id|suspend
op_assign
id|gadgetfs_suspend
comma
dot
id|driver
op_assign
(brace
dot
id|name
op_assign
(paren
r_char
op_star
)paren
id|shortname
comma
singleline_comment|// .shutdown = ...
singleline_comment|// .suspend = ...
singleline_comment|// .resume = ...
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------------*/
DECL|function|gadgetfs_nop
r_static
r_void
id|gadgetfs_nop
c_func
(paren
r_struct
id|usb_gadget
op_star
id|arg
)paren
(brace
)brace
DECL|function|gadgetfs_probe
r_static
r_int
id|gadgetfs_probe
(paren
r_struct
id|usb_gadget
op_star
id|gadget
)paren
(brace
id|CHIP
op_assign
id|gadget-&gt;name
suffix:semicolon
r_return
op_minus
id|EISNAM
suffix:semicolon
)brace
DECL|variable|probe_driver
r_static
r_struct
id|usb_gadget_driver
id|probe_driver
op_assign
(brace
dot
id|speed
op_assign
id|USB_SPEED_HIGH
comma
dot
id|bind
op_assign
id|gadgetfs_probe
comma
dot
id|unbind
op_assign
id|gadgetfs_nop
comma
dot
id|setup
op_assign
(paren
r_void
op_star
)paren
id|gadgetfs_nop
comma
dot
id|disconnect
op_assign
id|gadgetfs_nop
comma
dot
id|driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;nop&quot;
comma
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* DEVICE INITIALIZATION&n; *&n; *     fd = open (&quot;/dev/gadget/$CHIP&quot;, O_RDWR)&n; *     status = write (fd, descriptors, sizeof descriptors)&n; *&n; * That write establishes the device configuration, so the kernel can&n; * bind to the controller ... guaranteeing it can handle enumeration&n; * at all necessary speeds.  Descriptor order is:&n; *&n; * . message tag (u32, host order) ... for now, must be zero; it&n; *&t;would change to support features like multi-config devices&n; * . full/low speed config ... all wTotalLength bytes (with interface,&n; *&t;class, altsetting, endpoint, and other descriptors)&n; * . high speed config ... all descriptors, for high speed operation;&n; * &t;this one&squot;s optional except for high-speed hardware&n; * . device descriptor&n; *&n; * Endpoints are not yet enabled. Drivers may want to immediately&n; * initialize them, using the /dev/gadget/ep* files that are available&n; * as soon as the kernel sees the configuration, or they can wait&n; * until device configuration and interface altsetting changes create&n; * the need to configure (or unconfigure) them.&n; *&n; * After initialization, the device stays active for as long as that&n; * $CHIP file is open.  Events may then be read from that descriptor,&n; * such configuration notifications.  More complex drivers will handle&n; * some control requests in user space.&n; */
DECL|function|is_valid_config
r_static
r_int
id|is_valid_config
(paren
r_struct
id|usb_config_descriptor
op_star
id|config
)paren
(brace
r_return
id|config-&gt;bDescriptorType
op_eq
id|USB_DT_CONFIG
op_logical_and
id|config-&gt;bLength
op_eq
id|USB_DT_CONFIG_SIZE
op_logical_and
id|config-&gt;bConfigurationValue
op_ne
l_int|0
op_logical_and
(paren
id|config-&gt;bmAttributes
op_amp
id|USB_CONFIG_ATT_ONE
)paren
op_ne
l_int|0
op_logical_and
(paren
id|config-&gt;bmAttributes
op_amp
id|USB_CONFIG_ATT_WAKEUP
)paren
op_eq
l_int|0
suffix:semicolon
multiline_comment|/* FIXME if gadget-&gt;is_otg, _must_ include an otg descriptor */
multiline_comment|/* FIXME check lengths: walk to end */
)brace
r_static
id|ssize_t
DECL|function|dev_config
id|dev_config
(paren
r_struct
id|file
op_star
id|fd
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ptr
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|fd-&gt;private_data
suffix:semicolon
id|ssize_t
id|value
op_assign
id|len
comma
id|length
op_assign
id|len
suffix:semicolon
r_int
id|total
suffix:semicolon
id|u32
id|tag
suffix:semicolon
r_char
op_star
id|kbuf
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;state
op_ne
id|STATE_OPENED
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
(paren
id|USB_DT_CONFIG_SIZE
op_plus
id|USB_DT_DEVICE_SIZE
op_plus
l_int|4
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* we might need to change message format someday */
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|tag
comma
id|buf
comma
l_int|4
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|buf
op_add_assign
l_int|4
suffix:semicolon
id|length
op_sub_assign
l_int|4
suffix:semicolon
id|kbuf
op_assign
id|kmalloc
(paren
id|length
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
id|kbuf
comma
id|buf
comma
id|length
)paren
)paren
(brace
id|kfree
(paren
id|kbuf
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|spin_lock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|value
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;buf
)paren
r_goto
id|fail
suffix:semicolon
id|dev-&gt;buf
op_assign
id|kbuf
suffix:semicolon
multiline_comment|/* full or low speed config */
id|dev-&gt;config
op_assign
(paren
r_void
op_star
)paren
id|kbuf
suffix:semicolon
id|total
op_assign
id|le16_to_cpup
(paren
op_amp
id|dev-&gt;config-&gt;wTotalLength
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_valid_config
(paren
id|dev-&gt;config
)paren
op_logical_or
id|total
op_ge
id|length
)paren
r_goto
id|fail
suffix:semicolon
id|kbuf
op_add_assign
id|total
suffix:semicolon
id|length
op_sub_assign
id|total
suffix:semicolon
multiline_comment|/* optional high speed config */
r_if
c_cond
(paren
id|kbuf
(braket
l_int|1
)braket
op_eq
id|USB_DT_CONFIG
)paren
(brace
id|dev-&gt;hs_config
op_assign
(paren
r_void
op_star
)paren
id|kbuf
suffix:semicolon
id|total
op_assign
id|le16_to_cpup
(paren
op_amp
id|dev-&gt;hs_config-&gt;wTotalLength
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_valid_config
(paren
id|dev-&gt;hs_config
)paren
op_logical_or
id|total
op_ge
id|length
)paren
r_goto
id|fail
suffix:semicolon
id|kbuf
op_add_assign
id|total
suffix:semicolon
id|length
op_sub_assign
id|total
suffix:semicolon
)brace
multiline_comment|/* could support multiple configs, using another encoding! */
multiline_comment|/* device descriptor (tweaked for paranoia) */
r_if
c_cond
(paren
id|length
op_ne
id|USB_DT_DEVICE_SIZE
)paren
r_goto
id|fail
suffix:semicolon
id|dev-&gt;dev
op_assign
(paren
r_void
op_star
)paren
id|kbuf
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dev-&gt;bLength
op_ne
id|USB_DT_DEVICE_SIZE
op_logical_or
id|dev-&gt;dev-&gt;bDescriptorType
op_ne
id|USB_DT_DEVICE
op_logical_or
id|dev-&gt;dev-&gt;bNumConfigurations
op_ne
l_int|1
)paren
r_goto
id|fail
suffix:semicolon
id|dev-&gt;dev-&gt;bNumConfigurations
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;dev-&gt;bcdUSB
op_assign
id|__constant_cpu_to_le16
(paren
l_int|0x0200
)paren
suffix:semicolon
multiline_comment|/* triggers gadgetfs_bind(); then we can enumerate. */
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|value
op_assign
id|usb_gadget_register_driver
(paren
op_amp
id|gadgetfs_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
(brace
id|kfree
(paren
id|dev-&gt;buf
)paren
suffix:semicolon
id|dev-&gt;buf
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* at this point &quot;good&quot; hardware has for the first time&n;&t;&t; * let the USB the host see us.  alternatively, if users&n;&t;&t; * unplug/replug that will clear all the error state.&n;&t;&t; *&n;&t;&t; * note:  everything running before here was guaranteed&n;&t;&t; * to choke driver model style diagnostics.  from here&n;&t;&t; * on, they can work ... except in cleanup paths that&n;&t;&t; * kick in after the ep0 descriptor is closed.&n;&t;&t; */
id|fd-&gt;f_op
op_assign
op_amp
id|ep0_io_operations
suffix:semicolon
id|value
op_assign
id|len
suffix:semicolon
)brace
r_return
id|value
suffix:semicolon
id|fail
suffix:colon
id|spin_unlock_irq
(paren
op_amp
id|dev-&gt;lock
)paren
suffix:semicolon
id|pr_debug
(paren
l_string|&quot;%s: %s fail %Zd, %p&bslash;n&quot;
comma
id|shortname
comma
id|__FUNCTION__
comma
id|value
comma
id|dev
)paren
suffix:semicolon
id|kfree
(paren
id|dev-&gt;buf
)paren
suffix:semicolon
id|dev-&gt;buf
op_assign
l_int|NULL
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
r_static
r_int
DECL|function|dev_open
id|dev_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|fd
)paren
(brace
r_struct
id|dev_data
op_star
id|dev
op_assign
id|inode-&gt;u.generic_ip
suffix:semicolon
r_int
id|value
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|STATE_DEV_DISABLED
)paren
(brace
id|dev-&gt;ev_next
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;state
op_assign
id|STATE_OPENED
suffix:semicolon
id|fd-&gt;private_data
op_assign
id|dev
suffix:semicolon
id|get_dev
(paren
id|dev
)paren
suffix:semicolon
id|value
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|value
suffix:semicolon
)brace
DECL|variable|dev_init_operations
r_static
r_struct
id|file_operations
id|dev_init_operations
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|open
op_assign
id|dev_open
comma
dot
id|write
op_assign
id|dev_config
comma
dot
id|fasync
op_assign
id|ep0_fasync
comma
dot
id|ioctl
op_assign
id|dev_ioctl
comma
dot
id|release
op_assign
id|dev_release
comma
)brace
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------------*/
multiline_comment|/* FILESYSTEM AND SUPERBLOCK OPERATIONS&n; *&n; * Mounting the filesystem creates a controller file, used first for&n; * device configuration then later for event monitoring.&n; */
multiline_comment|/* FIXME PAM etc could set this security policy without mount options&n; * if epfiles inherited ownership and permissons from ep0 ...&n; */
DECL|variable|default_uid
r_static
r_int
id|default_uid
suffix:semicolon
DECL|variable|default_gid
r_static
r_int
id|default_gid
suffix:semicolon
DECL|variable|default_perm
r_static
r_int
id|default_perm
op_assign
id|S_IRUSR
op_or
id|S_IWUSR
suffix:semicolon
id|module_param
(paren
id|default_uid
comma
id|uint
comma
l_int|0644
)paren
suffix:semicolon
id|module_param
(paren
id|default_gid
comma
id|uint
comma
l_int|0644
)paren
suffix:semicolon
id|module_param
(paren
id|default_perm
comma
id|uint
comma
l_int|0644
)paren
suffix:semicolon
r_static
r_struct
id|inode
op_star
DECL|function|gadgetfs_make_inode
id|gadgetfs_make_inode
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_struct
id|file_operations
op_star
id|fops
comma
r_int
id|mode
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|new_inode
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|inode-&gt;i_mode
op_assign
id|mode
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|default_uid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|default_gid
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;u.generic_ip
op_assign
id|data
suffix:semicolon
id|inode-&gt;i_fop
op_assign
id|fops
suffix:semicolon
)brace
r_return
id|inode
suffix:semicolon
)brace
multiline_comment|/* creates in fs root directory, so non-renamable and non-linkable.&n; * so inode and dentry are paired, until device reconfig.&n; */
r_static
r_struct
id|inode
op_star
DECL|function|gadgetfs_create_file
id|gadgetfs_create_file
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_char
r_const
op_star
id|name
comma
r_void
op_star
id|data
comma
r_struct
id|file_operations
op_star
id|fops
comma
r_struct
id|dentry
op_star
op_star
id|dentry_p
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|dentry
op_assign
id|d_alloc_name
c_func
(paren
id|sb-&gt;s_root
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_return
l_int|NULL
suffix:semicolon
id|inode
op_assign
id|gadgetfs_make_inode
(paren
id|sb
comma
id|data
comma
id|fops
comma
id|S_IFREG
op_or
(paren
id|default_perm
op_amp
id|S_IRWXUGO
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|d_add
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
op_star
id|dentry_p
op_assign
id|dentry
suffix:semicolon
r_return
id|inode
suffix:semicolon
)brace
DECL|variable|gadget_fs_operations
r_static
r_struct
id|super_operations
id|gadget_fs_operations
op_assign
(brace
dot
id|statfs
op_assign
id|simple_statfs
comma
dot
id|drop_inode
op_assign
id|generic_delete_inode
comma
)brace
suffix:semicolon
r_static
r_int
DECL|function|gadgetfs_fill_super
id|gadgetfs_fill_super
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|opts
comma
r_int
id|silent
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dentry
op_star
id|d
suffix:semicolon
r_struct
id|dev_data
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|the_device
)paren
r_return
op_minus
id|ESRCH
suffix:semicolon
multiline_comment|/* fake probe to determine $CHIP */
(paren
r_void
)paren
id|usb_gadget_register_driver
(paren
op_amp
id|probe_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CHIP
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* superblock */
id|sb-&gt;s_blocksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|sb-&gt;s_blocksize_bits
op_assign
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|sb-&gt;s_magic
op_assign
id|GADGETFS_MAGIC
suffix:semicolon
id|sb-&gt;s_op
op_assign
op_amp
id|gadget_fs_operations
suffix:semicolon
id|sb-&gt;s_time_gran
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* root inode */
id|inode
op_assign
id|gadgetfs_make_inode
(paren
id|sb
comma
l_int|NULL
comma
op_amp
id|simple_dir_operations
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|simple_dir_inode_operations
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|d
op_assign
id|d_alloc_root
(paren
id|inode
)paren
)paren
)paren
(brace
id|iput
(paren
id|inode
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|sb-&gt;s_root
op_assign
id|d
suffix:semicolon
multiline_comment|/* the ep0 file is named after the controller we expect;&n;&t; * user mode code can use it for sanity checks, like we do.&n;&t; */
id|dev
op_assign
id|dev_new
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|dev-&gt;sb
op_assign
id|sb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode
op_assign
id|gadgetfs_create_file
(paren
id|sb
comma
id|CHIP
comma
id|dev
comma
op_amp
id|dev_init_operations
comma
op_amp
id|dev-&gt;dentry
)paren
)paren
)paren
(brace
id|put_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* other endpoint files are available after hardware setup,&n;&t; * from binding to a controller.&n;&t; */
id|the_device
op_assign
id|dev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &quot;mount -t gadgetfs path /dev/gadget&quot; ends up here */
r_static
r_struct
id|super_block
op_star
DECL|function|gadgetfs_get_sb
id|gadgetfs_get_sb
(paren
r_struct
id|file_system_type
op_star
id|t
comma
r_int
id|flags
comma
r_const
r_char
op_star
id|path
comma
r_void
op_star
id|opts
)paren
(brace
r_return
id|get_sb_single
(paren
id|t
comma
id|flags
comma
id|opts
comma
id|gadgetfs_fill_super
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|gadgetfs_kill_sb
id|gadgetfs_kill_sb
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|kill_litter_super
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|the_device
)paren
(brace
id|put_dev
(paren
id|the_device
)paren
suffix:semicolon
id|the_device
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*----------------------------------------------------------------------*/
DECL|variable|gadgetfs_type
r_static
r_struct
id|file_system_type
id|gadgetfs_type
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
id|shortname
comma
dot
id|get_sb
op_assign
id|gadgetfs_get_sb
comma
dot
id|kill_sb
op_assign
id|gadgetfs_kill_sb
comma
)brace
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------------*/
DECL|function|init
r_static
r_int
id|__init
id|init
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|register_filesystem
(paren
op_amp
id|gadgetfs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
id|pr_info
(paren
l_string|&quot;%s: %s, version &quot;
id|DRIVER_VERSION
l_string|&quot;&bslash;n&quot;
comma
id|shortname
comma
id|driver_desc
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|variable|init
id|module_init
(paren
id|init
)paren
suffix:semicolon
DECL|function|cleanup
r_static
r_void
id|__exit
id|cleanup
(paren
r_void
)paren
(brace
id|pr_debug
(paren
l_string|&quot;unregister %s&bslash;n&quot;
comma
id|shortname
)paren
suffix:semicolon
id|unregister_filesystem
(paren
op_amp
id|gadgetfs_type
)paren
suffix:semicolon
)brace
DECL|variable|cleanup
id|module_exit
(paren
id|cleanup
)paren
suffix:semicolon
eof
