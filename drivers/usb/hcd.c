multiline_comment|/*&n; * Copyright (c) 2001 by David Brownell&n; * &n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY&n; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; * for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/uts.h&gt;&t;&t;&t;/* for UTS_SYSNAME */
macro_line|#ifndef CONFIG_USB_DEBUG
DECL|macro|CONFIG_USB_DEBUG
mdefine_line|#define CONFIG_USB_DEBUG&t;/* this is experimental! */
macro_line|#endif
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &quot;hcd.h&quot;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * USB Host Controller Driver framework&n; *&n; * Plugs into usbcore (usb_bus) and lets HCDs share code, minimizing&n; * HCD-specific behaviors/bugs.&n; *&n; * This does error checks, tracks devices and urbs, and delegates to a&n; * &quot;hc_driver&quot; only for code (and data) that really needs to know about&n; * hardware differences.  That includes root hub registers, i/o queues,&n; * and so on ... but as little else as possible.&n; *&n; * Shared code includes most of the &quot;root hub&quot; code (these are emulated,&n; * though each HC&squot;s hardware works differently) and PCI glue, plus request&n; * tracking overhead.  The HCD code should only block on spinlocks or on&n; * hardware handshaking; blocking on software events (such as other kernel&n; * threads releasing resources, or completing actions) is all generic.&n; *&n; * Happens the USB 2.0 spec says this would be invisible inside the &quot;USBD&quot;,&n; * and includes mostly a &quot;HCDI&quot; (HCD Interface) along with some APIs used&n; * only by the hub driver ... and that neither should be seen or used by&n; * usb client device drivers.&n; *&n; * Contributors of ideas or unattributed patches include: David Brownell,&n; * Roman Weissgaerber, Rory Bolt, ...&n; *&n; * HISTORY:&n; * 2001-12-12&t;Initial patch version for Linux 2.5.1 kernel.&n; */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* host controllers we manage */
r_static
id|LIST_HEAD
(paren
id|hcd_list
)paren
suffix:semicolon
multiline_comment|/* used when updating list of hcds */
r_static
id|DECLARE_MUTEX
(paren
id|hcd_list_lock
)paren
suffix:semicolon
multiline_comment|/* used when updating hcd data */
DECL|variable|hcd_data_lock
r_static
id|spinlock_t
id|hcd_data_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|hcd_operations
r_static
r_struct
id|usb_operations
id|hcd_operations
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * Sharable chunks of root hub code.&n; */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* usb 2.0 root hub device descriptor */
DECL|variable|usb2_rh_dev_descriptor
r_static
r_const
id|u8
id|usb2_rh_dev_descriptor
(braket
l_int|18
)braket
op_assign
(brace
l_int|0x12
comma
multiline_comment|/*  __u8  bLength; */
l_int|0x01
comma
multiline_comment|/*  __u8  bDescriptorType; Device */
l_int|0x00
comma
l_int|0x02
comma
multiline_comment|/*  __u16 bcdUSB; v2.0 */
l_int|0x09
comma
multiline_comment|/*  __u8  bDeviceClass; HUB_CLASSCODE */
l_int|0x00
comma
multiline_comment|/*  __u8  bDeviceSubClass; */
l_int|0x01
comma
multiline_comment|/*  __u8  bDeviceProtocol; [ usb 2.0 single TT ]*/
l_int|0x08
comma
multiline_comment|/*  __u8  bMaxPacketSize0; 8 Bytes */
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*  __u16 idVendor; */
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*  __u16 idProduct; */
l_int|0x40
comma
l_int|0x02
comma
multiline_comment|/*  __u16 bcdDevice; (v2.4) */
l_int|0x03
comma
multiline_comment|/*  __u8  iManufacturer; */
l_int|0x02
comma
multiline_comment|/*  __u8  iProduct; */
l_int|0x01
comma
multiline_comment|/*  __u8  iSerialNumber; */
l_int|0x01
multiline_comment|/*  __u8  bNumConfigurations; */
)brace
suffix:semicolon
multiline_comment|/* no usb 2.0 root hub &quot;device qualifier&quot; descriptor: one speed only */
multiline_comment|/* usb 1.1 root hub device descriptor */
DECL|variable|usb11_rh_dev_descriptor
r_static
r_const
id|u8
id|usb11_rh_dev_descriptor
(braket
l_int|18
)braket
op_assign
(brace
l_int|0x12
comma
multiline_comment|/*  __u8  bLength; */
l_int|0x01
comma
multiline_comment|/*  __u8  bDescriptorType; Device */
l_int|0x10
comma
l_int|0x01
comma
multiline_comment|/*  __u16 bcdUSB; v1.1 */
l_int|0x09
comma
multiline_comment|/*  __u8  bDeviceClass; HUB_CLASSCODE */
l_int|0x00
comma
multiline_comment|/*  __u8  bDeviceSubClass; */
l_int|0x00
comma
multiline_comment|/*  __u8  bDeviceProtocol; [ low/full speeds only ] */
l_int|0x08
comma
multiline_comment|/*  __u8  bMaxPacketSize0; 8 Bytes */
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*  __u16 idVendor; */
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*  __u16 idProduct; */
l_int|0x40
comma
l_int|0x02
comma
multiline_comment|/*  __u16 bcdDevice; (v2.4) */
l_int|0x03
comma
multiline_comment|/*  __u8  iManufacturer; */
l_int|0x02
comma
multiline_comment|/*  __u8  iProduct; */
l_int|0x01
comma
multiline_comment|/*  __u8  iSerialNumber; */
l_int|0x01
multiline_comment|/*  __u8  bNumConfigurations; */
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Configuration descriptor for all our root hubs */
DECL|variable|rh_config_descriptor
r_static
r_const
id|u8
id|rh_config_descriptor
(braket
)braket
op_assign
(brace
multiline_comment|/* one configuration */
l_int|0x09
comma
multiline_comment|/*  __u8  bLength; */
l_int|0x02
comma
multiline_comment|/*  __u8  bDescriptorType; Configuration */
l_int|0x19
comma
l_int|0x00
comma
multiline_comment|/*  __u16 wTotalLength; */
l_int|0x01
comma
multiline_comment|/*  __u8  bNumInterfaces; (1) */
l_int|0x01
comma
multiline_comment|/*  __u8  bConfigurationValue; */
l_int|0x00
comma
multiline_comment|/*  __u8  iConfiguration; */
l_int|0x40
comma
multiline_comment|/*  __u8  bmAttributes; &n;&t;&t;&t;&t; Bit 7: Bus-powered,&n;&t;&t;&t;&t;     6: Self-powered,&n;&t;&t;&t;&t;     5 Remote-wakwup,&n;&t;&t;&t;&t;     4..0: resvd */
l_int|0x00
comma
multiline_comment|/*  __u8  MaxPower; */
multiline_comment|/* USB 1.1:&n;&t; * USB 2.0, single TT organization (mandatory):&n;&t; *&t;one interface, protocol 0&n;&t; *&n;&t; * USB 2.0, multiple TT organization (optional):&n;&t; *&t;two interfaces, protocols 1 (like single TT)&n;&t; *&t;and 2 (multiple TT mode) ... config is&n;&t; *&t;sometimes settable&n;&t; *&t;NOT IMPLEMENTED&n;&t; */
multiline_comment|/* one interface */
l_int|0x09
comma
multiline_comment|/*  __u8  if_bLength; */
l_int|0x04
comma
multiline_comment|/*  __u8  if_bDescriptorType; Interface */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bInterfaceNumber; */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bAlternateSetting; */
l_int|0x01
comma
multiline_comment|/*  __u8  if_bNumEndpoints; */
l_int|0x09
comma
multiline_comment|/*  __u8  if_bInterfaceClass; HUB_CLASSCODE */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bInterfaceSubClass; */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bInterfaceProtocol; [usb1.1 or single tt] */
l_int|0x00
comma
multiline_comment|/*  __u8  if_iInterface; */
multiline_comment|/* one endpoint (status change endpoint) */
l_int|0x07
comma
multiline_comment|/*  __u8  ep_bLength; */
l_int|0x05
comma
multiline_comment|/*  __u8  ep_bDescriptorType; Endpoint */
l_int|0x81
comma
multiline_comment|/*  __u8  ep_bEndpointAddress; IN Endpoint 1 */
l_int|0x03
comma
multiline_comment|/*  __u8  ep_bmAttributes; Interrupt */
l_int|0x02
comma
l_int|0x00
comma
multiline_comment|/*  __u16 ep_wMaxPacketSize; 1 + (MAX_ROOT_PORTS / 8) */
l_int|0x0c
multiline_comment|/*  __u8  ep_bInterval; (12ms -- usb 2.0 spec) */
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * helper routine for returning string descriptors in UTF-16LE&n; * input can actually be ISO-8859-1; ASCII is its 7-bit subset&n; */
DECL|function|ascii2utf
r_static
r_int
id|ascii2utf
(paren
r_char
op_star
id|ascii
comma
id|u8
op_star
id|utf
comma
r_int
id|utfmax
)paren
(brace
r_int
id|retval
suffix:semicolon
r_for
c_loop
(paren
id|retval
op_assign
l_int|0
suffix:semicolon
op_star
id|ascii
op_logical_and
id|utfmax
OG
l_int|1
suffix:semicolon
id|utfmax
op_sub_assign
l_int|2
comma
id|retval
op_add_assign
l_int|2
)paren
(brace
op_star
id|utf
op_increment
op_assign
op_star
id|ascii
op_increment
op_amp
l_int|0x7f
suffix:semicolon
op_star
id|utf
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * rh_string - provides manufacturer, product and serial strings for root hub&n; * @id: the string ID number (1: serial number, 2: product, 3: vendor)&n; * @pci_desc: PCI device descriptor for the relevant HC&n; * @type: string describing our driver &n; * @data: return packet in UTF-16 LE&n; * @len: length of the return packet&n; *&n; * Produces either a manufacturer, product or serial number string for the&n; * virtual root hub device.&n; */
DECL|function|rh_string
r_static
r_int
id|rh_string
(paren
r_int
id|id
comma
r_struct
id|pci_dev
op_star
id|pci_desc
comma
r_char
op_star
id|type
comma
id|u8
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_char
id|buf
(braket
l_int|100
)braket
suffix:semicolon
singleline_comment|// language ids
r_if
c_cond
(paren
id|id
op_eq
l_int|0
)paren
(brace
op_star
id|data
op_increment
op_assign
l_int|4
suffix:semicolon
op_star
id|data
op_increment
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 4 bytes string data */
op_star
id|data
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|data
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* some language id */
r_return
l_int|4
suffix:semicolon
singleline_comment|// serial number
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|1
)paren
(brace
id|strcpy
(paren
id|buf
comma
id|pci_desc-&gt;slot_name
)paren
suffix:semicolon
singleline_comment|// product description
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|2
)paren
(brace
id|strcpy
(paren
id|buf
comma
id|pci_desc-&gt;name
)paren
suffix:semicolon
singleline_comment|// id 3 == vendor description
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|3
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;%s %s %s&quot;
comma
id|UTS_SYSNAME
comma
id|UTS_RELEASE
comma
id|type
)paren
suffix:semicolon
singleline_comment|// unsupported IDs --&gt; &quot;protocol stall&quot;
)brace
r_else
r_return
l_int|0
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
l_int|2
op_plus
id|ascii2utf
(paren
id|buf
comma
id|data
op_plus
l_int|2
comma
id|len
op_minus
l_int|2
)paren
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* type == string */
r_return
id|data
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/* Root hub control transfers execute synchronously */
DECL|function|rh_call_control
r_static
r_int
id|rh_call_control
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_ctrlrequest
op_star
id|cmd
op_assign
(paren
r_struct
id|usb_ctrlrequest
op_star
)paren
id|urb-&gt;setup_packet
suffix:semicolon
id|u16
id|typeReq
comma
id|wValue
comma
id|wIndex
comma
id|wLength
suffix:semicolon
r_const
id|u8
op_star
id|bufp
op_assign
l_int|0
suffix:semicolon
id|u8
op_star
id|ubuf
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|typeReq
op_assign
(paren
id|cmd-&gt;bRequestType
op_lshift
l_int|8
)paren
op_or
id|cmd-&gt;bRequest
suffix:semicolon
id|wValue
op_assign
id|le16_to_cpu
(paren
id|cmd-&gt;wValue
)paren
suffix:semicolon
id|wIndex
op_assign
id|le16_to_cpu
(paren
id|cmd-&gt;wIndex
)paren
suffix:semicolon
id|wLength
op_assign
id|le16_to_cpu
(paren
id|cmd-&gt;wLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wLength
OG
id|urb-&gt;transfer_buffer_length
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* set up for success */
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;actual_length
op_assign
id|wLength
suffix:semicolon
r_switch
c_cond
(paren
id|typeReq
)paren
(brace
multiline_comment|/* DEVICE REQUESTS */
r_case
id|DeviceRequest
op_or
id|USB_REQ_GET_STATUS
suffix:colon
singleline_comment|// DEVICE_REMOTE_WAKEUP
id|ubuf
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
singleline_comment|// selfpowered
id|ubuf
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|DeviceOutRequest
op_or
id|USB_REQ_CLEAR_FEATURE
suffix:colon
r_case
id|DeviceOutRequest
op_or
id|USB_REQ_SET_FEATURE
suffix:colon
id|dbg
(paren
l_string|&quot;no device features yet yet&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DeviceRequest
op_or
id|USB_REQ_GET_CONFIGURATION
suffix:colon
id|ubuf
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|DeviceOutRequest
op_or
id|USB_REQ_SET_CONFIGURATION
suffix:colon
r_break
suffix:semicolon
r_case
id|DeviceRequest
op_or
id|USB_REQ_GET_DESCRIPTOR
suffix:colon
r_switch
c_cond
(paren
id|wValue
op_amp
l_int|0xff00
)paren
(brace
r_case
id|USB_DT_DEVICE
op_lshift
l_int|8
suffix:colon
r_if
c_cond
(paren
id|hcd-&gt;driver-&gt;flags
op_amp
id|HCD_USB2
)paren
id|bufp
op_assign
id|usb2_rh_dev_descriptor
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hcd-&gt;driver-&gt;flags
op_amp
id|HCD_USB11
)paren
id|bufp
op_assign
id|usb11_rh_dev_descriptor
suffix:semicolon
r_else
r_goto
id|error
suffix:semicolon
id|len
op_assign
l_int|18
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_CONFIG
op_lshift
l_int|8
suffix:colon
id|bufp
op_assign
id|rh_config_descriptor
suffix:semicolon
id|len
op_assign
r_sizeof
id|rh_config_descriptor
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_STRING
op_lshift
l_int|8
suffix:colon
id|urb-&gt;actual_length
op_assign
id|rh_string
(paren
id|wValue
op_amp
l_int|0xff
comma
id|hcd-&gt;pdev
comma
(paren
r_char
op_star
)paren
id|hcd-&gt;description
comma
id|ubuf
comma
id|wLength
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|error
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DeviceRequest
op_or
id|USB_REQ_GET_INTERFACE
suffix:colon
id|ubuf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|DeviceOutRequest
op_or
id|USB_REQ_SET_INTERFACE
suffix:colon
r_break
suffix:semicolon
r_case
id|DeviceOutRequest
op_or
id|USB_REQ_SET_ADDRESS
suffix:colon
singleline_comment|// wValue == urb-&gt;dev-&gt;devaddr
id|dbg
(paren
l_string|&quot;%s root hub device address %d&quot;
comma
id|hcd-&gt;bus_name
comma
id|wValue
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* INTERFACE REQUESTS (no defined feature/status flags) */
multiline_comment|/* ENDPOINT REQUESTS */
r_case
id|EndpointRequest
op_or
id|USB_REQ_GET_STATUS
suffix:colon
singleline_comment|// ENDPOINT_HALT flag
id|ubuf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|ubuf
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|EndpointOutRequest
op_or
id|USB_REQ_CLEAR_FEATURE
suffix:colon
r_case
id|EndpointOutRequest
op_or
id|USB_REQ_SET_FEATURE
suffix:colon
id|dbg
(paren
l_string|&quot;no endpoint features yet&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* CLASS REQUESTS (and errors) */
r_default
suffix:colon
multiline_comment|/* non-generic request */
id|urb-&gt;status
op_assign
id|hcd-&gt;driver-&gt;hub_control
(paren
id|hcd
comma
id|typeReq
comma
id|wValue
comma
id|wIndex
comma
id|ubuf
comma
id|wLength
)paren
suffix:semicolon
r_break
suffix:semicolon
id|error
suffix:colon
multiline_comment|/* &quot;protocol stall&quot; on error */
id|urb-&gt;status
op_assign
op_minus
id|EPIPE
suffix:semicolon
id|dbg
(paren
l_string|&quot;unsupported hub control message (maxchild %d)&quot;
comma
id|urb-&gt;dev-&gt;maxchild
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|dbg
(paren
l_string|&quot;CTRL: TypeReq=0x%x val=0x%x idx=0x%x len=%d ==&gt; %d&quot;
comma
id|typeReq
comma
id|wValue
comma
id|wIndex
comma
id|wLength
comma
id|urb-&gt;status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bufp
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;transfer_buffer_length
OL
id|len
)paren
id|len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
id|urb-&gt;actual_length
op_assign
id|len
suffix:semicolon
singleline_comment|// always USB_DIR_IN, toward host
id|memcpy
(paren
id|ubuf
comma
id|bufp
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/* any errors get returned through the urb completion */
id|usb_hcd_giveback_urb
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * Root Hub interrupt transfers are synthesized with a timer.&n; * Completions are called in_interrupt() but not in_irq().&n; */
r_static
r_void
id|rh_report_status
(paren
r_int
r_int
id|ptr
)paren
suffix:semicolon
DECL|function|rh_status_urb
r_static
r_int
id|rh_status_urb
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|len
op_assign
l_int|1
op_plus
(paren
id|urb-&gt;dev-&gt;maxchild
op_div
l_int|8
)paren
suffix:semicolon
multiline_comment|/* rh_timer protected by hcd_data_lock */
r_if
c_cond
(paren
id|timer_pending
(paren
op_amp
id|hcd-&gt;rh_timer
)paren
op_logical_or
id|urb-&gt;status
op_ne
op_minus
id|EINPROGRESS
op_logical_or
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|hcd-&gt;state
)paren
op_logical_or
id|urb-&gt;transfer_buffer_length
OL
id|len
)paren
(brace
id|dbg
(paren
l_string|&quot;not queuing status urb, stat %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|urb-&gt;hcpriv
op_assign
id|hcd
suffix:semicolon
multiline_comment|/* nonzero to indicate it&squot;s queued */
id|init_timer
(paren
op_amp
id|hcd-&gt;rh_timer
)paren
suffix:semicolon
id|hcd-&gt;rh_timer.function
op_assign
id|rh_report_status
suffix:semicolon
id|hcd-&gt;rh_timer.data
op_assign
(paren
r_int
r_int
)paren
id|urb
suffix:semicolon
id|hcd-&gt;rh_timer.expires
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_star
(paren
id|urb-&gt;interval
OL
l_int|30
ques
c_cond
l_int|30
suffix:colon
id|urb-&gt;interval
)paren
)paren
op_div
l_int|1000
suffix:semicolon
id|add_timer
(paren
op_amp
id|hcd-&gt;rh_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* timer callback */
DECL|function|rh_report_status
r_static
r_void
id|rh_report_status
(paren
r_int
r_int
id|ptr
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_struct
id|usb_hcd
op_star
id|hcd
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|urb
op_assign
(paren
r_struct
id|urb
op_star
)paren
id|ptr
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;dev
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hcd
op_assign
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|hcd-&gt;state
)paren
)paren
(brace
id|length
op_assign
id|hcd-&gt;driver-&gt;hub_status_data
(paren
id|hcd
comma
id|urb-&gt;transfer_buffer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
l_int|0
)paren
(brace
id|urb-&gt;actual_length
op_assign
id|length
suffix:semicolon
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|hcd-&gt;state
)paren
op_logical_and
id|rh_status_urb
(paren
id|hcd
comma
id|urb
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* another driver snuck in? */
id|dbg
(paren
l_string|&quot;%s, can&squot;t resubmit roothub status urb?&quot;
comma
id|hcd-&gt;bus_name
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* this urb&squot;s been unlinked */
id|urb-&gt;hcpriv
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|usb_hcd_giveback_urb
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|rh_urb_enqueue
r_static
r_int
id|rh_urb_enqueue
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|usb_pipeint
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|rh_status_urb
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
r_return
id|rh_call_control
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|rh_status_dequeue
r_static
r_void
id|rh_status_dequeue
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|del_timer_sync
(paren
op_amp
id|hcd-&gt;rh_timer
)paren
suffix:semicolon
id|hcd-&gt;rh_timer.data
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* we rely on RH callback code not unlinking its URB! */
id|usb_hcd_giveback_urb
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#ifdef CONFIG_PCI
multiline_comment|/* PCI-based HCs are normal, but custom bus glue should be ok */
r_static
r_void
id|hcd_irq
(paren
r_int
id|irq
comma
r_void
op_star
id|__hcd
comma
r_struct
id|pt_regs
op_star
id|r
)paren
suffix:semicolon
r_static
r_void
id|hc_died
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* configure so an HC device and id are always provided */
multiline_comment|/* always called with process context; sleeping is OK */
multiline_comment|/**&n; * usb_hcd_pci_probe - initialize PCI-based HCDs&n; * @dev: USB Host Controller being probed&n; * @id: pci hotplug id connecting controller to HCD framework&n; *&n; * Allocates basic PCI resources for this USB host controller, and&n; * then invokes the start() method for the HCD associated with it&n; * through the hotplug entry&squot;s driver_data.&n; *&n; * Store this function in the HCD&squot;s struct pci_driver as probe().&n; */
DECL|function|usb_hcd_pci_probe
r_int
id|usb_hcd_pci_probe
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_const
r_struct
id|pci_device_id
op_star
id|id
)paren
(brace
r_struct
id|hc_driver
op_star
id|driver
suffix:semicolon
r_int
r_int
id|resource
comma
id|len
suffix:semicolon
r_void
op_star
id|base
suffix:semicolon
id|u8
id|latency
comma
id|limit
suffix:semicolon
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
r_struct
id|usb_hcd
op_star
id|hcd
suffix:semicolon
r_int
id|retval
comma
id|region
suffix:semicolon
r_char
id|buf
(braket
l_int|8
)braket
comma
op_star
id|bufp
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|id
op_logical_or
op_logical_neg
(paren
id|driver
op_assign
(paren
r_struct
id|hc_driver
op_star
)paren
id|id-&gt;driver_data
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
(paren
id|dev
)paren
OL
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq
)paren
(brace
id|err
(paren
l_string|&quot;Found HC with no IRQ.  Check BIOS/PCI %s setup!&quot;
comma
id|dev-&gt;slot_name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|HCD_MEMORY
)paren
(brace
singleline_comment|// EHCI, OHCI
id|region
op_assign
l_int|0
suffix:semicolon
id|resource
op_assign
id|pci_resource_start
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|len
op_assign
id|pci_resource_len
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
(paren
id|resource
comma
id|len
comma
id|driver-&gt;description
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;controller already in use&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|base
op_assign
id|ioremap_nocache
(paren
id|resource
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|NULL
)paren
(brace
id|dbg
(paren
l_string|&quot;error mapping memory&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|clean_1
suffix:colon
id|release_mem_region
(paren
id|resource
comma
id|len
)paren
suffix:semicolon
id|err
(paren
l_string|&quot;init %s fail, %d&quot;
comma
id|dev-&gt;slot_name
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// UHCI
id|resource
op_assign
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|region
op_assign
l_int|0
suffix:semicolon
id|region
OL
id|PCI_ROM_RESOURCE
suffix:semicolon
id|region
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pci_resource_flags
(paren
id|dev
comma
id|region
)paren
op_amp
id|IORESOURCE_IO
)paren
)paren
r_continue
suffix:semicolon
id|resource
op_assign
id|pci_resource_start
(paren
id|dev
comma
id|region
)paren
suffix:semicolon
id|len
op_assign
id|pci_resource_len
(paren
id|dev
comma
id|region
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_region
(paren
id|resource
comma
id|len
comma
id|driver-&gt;description
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|region
op_eq
id|PCI_ROM_RESOURCE
)paren
(brace
id|dbg
(paren
l_string|&quot;no i/o regions available&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|base
op_assign
(paren
r_void
op_star
)paren
id|resource
suffix:semicolon
)brace
singleline_comment|// driver-&gt;start(), later on, will transfer device from
singleline_comment|// control by SMM/BIOS to control by Linux (if needed)
id|pci_set_master
(paren
id|dev
)paren
suffix:semicolon
id|hcd
op_assign
id|driver-&gt;hcd_alloc
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hcd
op_eq
l_int|NULL
)paren
(brace
id|dbg
(paren
l_string|&quot;hcd alloc fail&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|clean_2
suffix:colon
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|HCD_MEMORY
)paren
(brace
id|iounmap
(paren
id|base
)paren
suffix:semicolon
r_goto
id|clean_1
suffix:semicolon
)brace
r_else
(brace
id|release_region
(paren
id|resource
comma
id|len
)paren
suffix:semicolon
id|err
(paren
l_string|&quot;init %s fail, %d&quot;
comma
id|dev-&gt;slot_name
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
id|pci_set_drvdata
c_func
(paren
id|dev
comma
id|hcd
)paren
suffix:semicolon
id|hcd-&gt;driver
op_assign
id|driver
suffix:semicolon
id|hcd-&gt;description
op_assign
id|driver-&gt;description
suffix:semicolon
id|hcd-&gt;pdev
op_assign
id|dev
suffix:semicolon
id|info
(paren
l_string|&quot;%s @ %s, %s&quot;
comma
id|hcd-&gt;description
comma
id|dev-&gt;slot_name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|pci_read_config_byte
(paren
id|dev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|latency
)paren
suffix:semicolon
r_if
c_cond
(paren
id|latency
)paren
(brace
id|pci_read_config_byte
(paren
id|dev
comma
id|PCI_MAX_LAT
comma
op_amp
id|limit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_logical_and
id|limit
OL
id|latency
)paren
(brace
id|dbg
(paren
l_string|&quot;PCI latency reduced to max %d&quot;
comma
id|limit
)paren
suffix:semicolon
id|pci_write_config_byte
(paren
id|dev
comma
id|PCI_LATENCY_TIMER
comma
id|limit
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifndef __sparc__
id|sprintf
(paren
id|buf
comma
l_string|&quot;%d&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#else
id|bufp
op_assign
id|__irq_itoa
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|request_irq
(paren
id|dev-&gt;irq
comma
id|hcd_irq
comma
id|SA_SHIRQ
comma
id|hcd-&gt;description
comma
id|hcd
)paren
op_ne
l_int|0
)paren
(brace
id|err
(paren
l_string|&quot;request interrupt %s failed&quot;
comma
id|bufp
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|clean_3
suffix:colon
id|driver-&gt;hcd_free
(paren
id|hcd
)paren
suffix:semicolon
r_goto
id|clean_2
suffix:semicolon
)brace
id|hcd-&gt;irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|hcd-&gt;regs
op_assign
id|base
suffix:semicolon
id|hcd-&gt;region
op_assign
id|region
suffix:semicolon
id|info
(paren
l_string|&quot;irq %s, %s %p&quot;
comma
id|bufp
comma
(paren
id|driver-&gt;flags
op_amp
id|HCD_MEMORY
)paren
ques
c_cond
l_string|&quot;pci mem&quot;
suffix:colon
l_string|&quot;io base&quot;
comma
id|base
)paren
suffix:semicolon
singleline_comment|// FIXME simpler: make &quot;bus&quot; be that data, not pointer to it.
id|bus
op_assign
id|usb_alloc_bus
(paren
op_amp
id|hcd_operations
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|NULL
)paren
(brace
id|dbg
(paren
l_string|&quot;usb_alloc_bus fail&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|free_irq
(paren
id|dev-&gt;irq
comma
id|hcd
)paren
suffix:semicolon
r_goto
id|clean_3
suffix:semicolon
)brace
id|hcd-&gt;bus
op_assign
id|bus
suffix:semicolon
id|hcd-&gt;bus_name
op_assign
id|dev-&gt;slot_name
suffix:semicolon
id|bus-&gt;hcpriv
op_assign
(paren
r_void
op_star
)paren
id|hcd
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|hcd-&gt;dev_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|hcd-&gt;hcd_list
)paren
suffix:semicolon
id|down
(paren
op_amp
id|hcd_list_lock
)paren
suffix:semicolon
id|list_add
(paren
op_amp
id|hcd-&gt;hcd_list
comma
op_amp
id|hcd_list
)paren
suffix:semicolon
id|up
(paren
op_amp
id|hcd_list_lock
)paren
suffix:semicolon
id|usb_register_bus
(paren
id|bus
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|driver-&gt;start
(paren
id|hcd
)paren
)paren
OL
l_int|0
)paren
id|usb_hcd_pci_remove
(paren
id|dev
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|usb_hcd_pci_probe
id|EXPORT_SYMBOL
(paren
id|usb_hcd_pci_probe
)paren
suffix:semicolon
multiline_comment|/* may be called without controller electrically present */
multiline_comment|/* may be called with controller, bus, and devices active */
multiline_comment|/**&n; * usb_hcd_pci_remove - shutdown processing for PCI-based HCDs&n; * @dev: USB Host Controller being removed&n; *&n; * Reverses the effect of usb_hcd_pci_probe(), first invoking&n; * the HCD&squot;s stop() method.  It is always called from a thread&n; * context, normally &quot;rmmod&quot;, &quot;apmd&quot;, or something similar.&n; *&n; * Store this function in the HCD&squot;s struct pci_driver as remove().&n; */
DECL|function|usb_hcd_pci_remove
r_void
id|usb_hcd_pci_remove
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|usb_hcd
op_star
id|hcd
suffix:semicolon
r_struct
id|usb_device
op_star
id|hub
suffix:semicolon
id|hcd
op_assign
id|pci_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hcd
)paren
r_return
suffix:semicolon
id|info
(paren
l_string|&quot;remove: %s, state %x&quot;
comma
id|hcd-&gt;bus_name
comma
id|hcd-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
(paren
)paren
)paren
id|BUG
(paren
)paren
suffix:semicolon
id|hub
op_assign
id|hcd-&gt;bus-&gt;root_hub
suffix:semicolon
id|hcd-&gt;state
op_assign
id|USB_STATE_QUIESCING
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: roothub graceful disconnect&quot;
comma
id|hcd-&gt;bus_name
)paren
suffix:semicolon
id|usb_disconnect
(paren
op_amp
id|hub
)paren
suffix:semicolon
singleline_comment|// usb_disconnect (&amp;hcd-&gt;bus-&gt;root_hub);
id|hcd-&gt;driver-&gt;stop
(paren
id|hcd
)paren
suffix:semicolon
id|hcd-&gt;state
op_assign
id|USB_STATE_HALT
suffix:semicolon
id|free_irq
(paren
id|hcd-&gt;irq
comma
id|hcd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hcd-&gt;driver-&gt;flags
op_amp
id|HCD_MEMORY
)paren
(brace
id|iounmap
(paren
id|hcd-&gt;regs
)paren
suffix:semicolon
id|release_mem_region
(paren
id|pci_resource_start
(paren
id|dev
comma
l_int|0
)paren
comma
id|pci_resource_len
(paren
id|dev
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|release_region
(paren
id|pci_resource_start
(paren
id|dev
comma
id|hcd-&gt;region
)paren
comma
id|pci_resource_len
(paren
id|dev
comma
id|hcd-&gt;region
)paren
)paren
suffix:semicolon
)brace
id|down
(paren
op_amp
id|hcd_list_lock
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|hcd-&gt;hcd_list
)paren
suffix:semicolon
id|up
(paren
op_amp
id|hcd_list_lock
)paren
suffix:semicolon
id|usb_deregister_bus
(paren
id|hcd-&gt;bus
)paren
suffix:semicolon
id|usb_free_bus
(paren
id|hcd-&gt;bus
)paren
suffix:semicolon
id|hcd-&gt;bus
op_assign
l_int|NULL
suffix:semicolon
id|hcd-&gt;driver-&gt;hcd_free
(paren
id|hcd
)paren
suffix:semicolon
)brace
DECL|variable|usb_hcd_pci_remove
id|EXPORT_SYMBOL
(paren
id|usb_hcd_pci_remove
)paren
suffix:semicolon
macro_line|#ifdef&t;CONFIG_PM
multiline_comment|/*&n; * Some &quot;sleep&quot; power levels imply updating struct usb_driver&n; * to include a callback asking hcds to do their bit by checking&n; * if all the drivers can suspend.  Gets involved with remote wakeup.&n; *&n; * If there are pending urbs, then HCs will need to access memory,&n; * causing extra power drain.  New sleep()/wakeup() PM calls might&n; * be needed, beyond PCI suspend()/resume().  The root hub timer&n; * still be accessing memory though ...&n; *&n; * FIXME:  USB should have some power budgeting support working with&n; * all kinds of hubs.&n; *&n; * FIXME:  This assumes only D0-&gt;D3 suspend and D3-&gt;D0 resume.&n; * D1 and D2 states should do something, yes?&n; *&n; * FIXME:  Should provide generic enable_wake(), calling pci_enable_wake()&n; * for all supported states, so that USB remote wakeup can work for any&n; * devices that support it (and are connected via powered hubs).&n; *&n; * FIXME:  resume doesn&squot;t seem to work right any more...&n; */
singleline_comment|// 2.4 kernels have issued concurrent resumes (w/APM)
singleline_comment|// we defend against that error; PCI doesn&squot;t yet.
multiline_comment|/**&n; * usb_hcd_pci_suspend - power management suspend of a PCI-based HCD&n; * @dev: USB Host Controller being suspended&n; *&n; * Store this function in the HCD&squot;s struct pci_driver as suspend().&n; */
DECL|function|usb_hcd_pci_suspend
r_int
id|usb_hcd_pci_suspend
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|u32
id|state
)paren
(brace
r_struct
id|usb_hcd
op_star
id|hcd
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|hcd
op_assign
id|pci_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
id|info
(paren
l_string|&quot;suspend %s to state %d&quot;
comma
id|hcd-&gt;bus_name
comma
id|state
)paren
suffix:semicolon
id|pci_save_state
(paren
id|dev
comma
id|hcd-&gt;pci_state
)paren
suffix:semicolon
singleline_comment|// FIXME for all connected devices, leaf-to-root:
singleline_comment|// driver-&gt;suspend()
singleline_comment|// proposed &quot;new 2.5 driver model&quot; will automate that
multiline_comment|/* driver may want to disable DMA etc */
id|retval
op_assign
id|hcd-&gt;driver-&gt;suspend
(paren
id|hcd
comma
id|state
)paren
suffix:semicolon
id|hcd-&gt;state
op_assign
id|USB_STATE_SUSPENDED
suffix:semicolon
id|pci_set_power_state
(paren
id|dev
comma
id|state
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|usb_hcd_pci_suspend
id|EXPORT_SYMBOL
(paren
id|usb_hcd_pci_suspend
)paren
suffix:semicolon
multiline_comment|/**&n; * usb_hcd_pci_resume - power management resume of a PCI-based HCD&n; * @dev: USB Host Controller being resumed&n; *&n; * Store this function in the HCD&squot;s struct pci_driver as resume().&n; */
DECL|function|usb_hcd_pci_resume
r_int
id|usb_hcd_pci_resume
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|usb_hcd
op_star
id|hcd
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|hcd
op_assign
id|pci_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
id|info
(paren
l_string|&quot;resume %s&quot;
comma
id|hcd-&gt;bus_name
)paren
suffix:semicolon
multiline_comment|/* guard against multiple resumes (APM bug?) */
id|atomic_inc
(paren
op_amp
id|hcd-&gt;resume_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
(paren
op_amp
id|hcd-&gt;resume_count
)paren
op_ne
l_int|1
)paren
(brace
id|err
(paren
l_string|&quot;concurrent PCI resumes for %s&quot;
comma
id|hcd-&gt;bus_name
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|hcd-&gt;state
op_ne
id|USB_STATE_SUSPENDED
)paren
(brace
id|dbg
(paren
l_string|&quot;can&squot;t resume, not suspended!&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|hcd-&gt;state
op_assign
id|USB_STATE_RESUMING
suffix:semicolon
id|pci_set_power_state
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|pci_restore_state
(paren
id|dev
comma
id|hcd-&gt;pci_state
)paren
suffix:semicolon
id|retval
op_assign
id|hcd-&gt;driver-&gt;resume
(paren
id|hcd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|hcd-&gt;state
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;resume %s failure, retval %d&quot;
comma
id|hcd-&gt;bus_name
comma
id|retval
)paren
suffix:semicolon
id|hc_died
(paren
id|hcd
)paren
suffix:semicolon
singleline_comment|// FIXME:  recover, reset etc.
)brace
r_else
(brace
singleline_comment|// FIXME for all connected devices, root-to-leaf:
singleline_comment|// driver-&gt;resume ();
singleline_comment|// proposed &quot;new 2.5 driver model&quot; will automate that
)brace
id|done
suffix:colon
id|atomic_dec
(paren
op_amp
id|hcd-&gt;resume_count
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|usb_hcd_pci_resume
id|EXPORT_SYMBOL
(paren
id|usb_hcd_pci_resume
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_PM */
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * Generic HC operations.&n; */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* called from khubd, or root hub init threads for hcd-private init */
DECL|function|hcd_alloc_dev
r_static
r_int
id|hcd_alloc_dev
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_struct
id|usb_hcd
op_star
id|hcd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
op_logical_or
id|udev-&gt;hcpriv
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev-&gt;bus
op_logical_or
op_logical_neg
id|udev-&gt;bus-&gt;hcpriv
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|hcd
op_assign
id|udev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
id|hcd-&gt;state
op_eq
id|USB_STATE_QUIESCING
)paren
r_return
op_minus
id|ENOLINK
suffix:semicolon
id|dev
op_assign
(paren
r_struct
id|hcd_dev
op_star
)paren
id|kmalloc
(paren
r_sizeof
op_star
id|dev
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
op_star
id|dev
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|dev-&gt;dev_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|dev-&gt;urb_list
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add
(paren
op_amp
id|dev-&gt;dev_list
comma
op_amp
id|hcd-&gt;dev_list
)paren
suffix:semicolon
singleline_comment|// refcount is implicit
id|udev-&gt;hcpriv
op_assign
id|dev
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|hc_died
r_static
r_void
id|hc_died
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|list_head
op_star
id|devlist
comma
op_star
id|urblist
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* flag every pending urb as done */
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each
(paren
id|devlist
comma
op_amp
id|hcd-&gt;dev_list
)paren
(brace
id|dev
op_assign
id|list_entry
(paren
id|devlist
comma
r_struct
id|hcd_dev
comma
id|dev_list
)paren
suffix:semicolon
id|list_for_each
(paren
id|urblist
comma
op_amp
id|dev-&gt;urb_list
)paren
(brace
id|urb
op_assign
id|list_entry
(paren
id|urblist
comma
r_struct
id|urb
comma
id|urb_list
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;shutdown %s urb %p pipe %x, current status %d&quot;
comma
id|hcd-&gt;bus_name
comma
id|urb
comma
id|urb-&gt;pipe
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|urb-&gt;status
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
)brace
)brace
id|urb
op_assign
(paren
r_struct
id|urb
op_star
)paren
id|hcd-&gt;rh_timer.data
suffix:semicolon
r_if
c_cond
(paren
id|urb
)paren
id|urb-&gt;status
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
)paren
id|rh_status_dequeue
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
id|hcd-&gt;driver-&gt;stop
(paren
id|hcd
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* may be called in any context with a valid urb-&gt;dev usecount */
multiline_comment|/* caller surrenders &quot;ownership&quot; of urb (and chain at urb-&gt;next).  */
DECL|function|hcd_submit_urb
r_static
r_int
id|hcd_submit_urb
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|usb_hcd
op_star
id|hcd
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
op_logical_or
id|urb-&gt;hcpriv
op_logical_or
op_logical_neg
id|urb-&gt;complete
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|urb-&gt;urb_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;dev
op_logical_or
op_logical_neg
id|urb-&gt;dev-&gt;bus
op_logical_or
id|urb-&gt;dev-&gt;devnum
op_le
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|hcd
op_assign
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
id|dev
op_assign
id|urb-&gt;dev-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hcd
op_logical_or
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* can&squot;t submit new urbs when quiescing, halted, ... */
r_if
c_cond
(paren
id|hcd-&gt;state
op_eq
id|USB_STATE_QUIESCING
op_logical_or
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|hcd-&gt;state
)paren
)paren
r_return
op_minus
id|ESHUTDOWN
suffix:semicolon
id|pipe
op_assign
id|urb-&gt;pipe
suffix:semicolon
r_if
c_cond
(paren
id|usb_endpoint_halted
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|pipe
)paren
comma
id|usb_pipeout
(paren
id|pipe
)paren
)paren
)paren
r_return
op_minus
id|EPIPE
suffix:semicolon
macro_line|#ifdef DEBUG
(brace
r_int
r_int
id|orig_flags
op_assign
id|urb-&gt;transfer_flags
suffix:semicolon
r_int
r_int
id|allowed
suffix:semicolon
multiline_comment|/* enforce simple/standard policy */
id|allowed
op_assign
id|USB_ASYNC_UNLINK
suffix:semicolon
singleline_comment|// affects later unlinks
id|allowed
op_or_assign
id|USB_NO_FSBR
suffix:semicolon
singleline_comment|// only affects UHCI
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|pipe
)paren
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
id|allowed
op_or_assign
id|USB_DISABLE_SPD
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
id|allowed
op_or_assign
id|USB_DISABLE_SPD
op_or
id|USB_QUEUE_BULK
op_or
id|USB_ZERO_PACKET
op_or
id|URB_NO_INTERRUPT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|allowed
op_or_assign
id|USB_DISABLE_SPD
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|allowed
op_or_assign
id|USB_ISO_ASAP
suffix:semicolon
r_break
suffix:semicolon
)brace
id|urb-&gt;transfer_flags
op_and_assign
id|allowed
suffix:semicolon
multiline_comment|/* warn if submitter gave bogus flags */
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_ne
id|orig_flags
)paren
id|warn
(paren
l_string|&quot;BOGUS urb flags, %x --&gt; %x&quot;
comma
id|orig_flags
comma
id|urb-&gt;transfer_flags
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * FIXME:  alloc periodic bandwidth here, for interrupt and iso?&n;&t; * Need to look at the ring submit mechanism for iso tds ... they&n;&t; * aren&squot;t actually &quot;periodic&quot; in 2.4 kernels.&n;&t; *&n;&t; * FIXME:  make urb timeouts be generic, keeping the HCD cores&n;&t; * as simple as possible.&n;&t; */
singleline_comment|// NOTE:  a generic device/urb monitoring hook would go here.
singleline_comment|// hcd_monitor_hook(MONITOR_URB_SUBMIT, urb)
singleline_comment|// It would catch submission paths for all urbs.
multiline_comment|/* increment the reference count of the urb, as we now also control it. */
id|urb
op_assign
id|usb_get_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Atomically queue the urb,  first to our records, then to the HCD.&n;&t; * Access to urb-&gt;status is controlled by urb-&gt;lock ... changes on&n;&t; * i/o completion (normal or fault) or unlinking.&n;&t; */
singleline_comment|// FIXME:  verify that quiescing hc works right (RH cleans up)
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|hcd-&gt;state
)paren
op_logical_and
id|hcd-&gt;state
op_ne
id|USB_STATE_QUIESCING
)paren
(brace
id|usb_inc_dev_use
(paren
id|urb-&gt;dev
)paren
suffix:semicolon
id|list_add
(paren
op_amp
id|urb-&gt;urb_list
comma
op_amp
id|dev-&gt;urb_list
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|INIT_LIST_HEAD
(paren
op_amp
id|urb-&gt;urb_list
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;dev
op_eq
id|hcd-&gt;bus-&gt;root_hub
)paren
id|status
op_assign
id|rh_urb_enqueue
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
r_else
id|status
op_assign
id|hcd-&gt;driver-&gt;urb_enqueue
(paren
id|hcd
comma
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;dev
)paren
(brace
id|urb-&gt;status
op_assign
id|status
suffix:semicolon
id|usb_hcd_giveback_urb
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* called in any context */
DECL|function|hcd_get_frame_number
r_static
r_int
id|hcd_get_frame_number
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_struct
id|usb_hcd
op_star
id|hcd
op_assign
(paren
r_struct
id|usb_hcd
op_star
)paren
id|udev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_return
id|hcd-&gt;driver-&gt;get_frame_number
(paren
id|hcd
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|struct|completion_splice
r_struct
id|completion_splice
(brace
singleline_comment|// modified urb context:
multiline_comment|/* did we complete? */
DECL|member|done
r_int
id|done
suffix:semicolon
multiline_comment|/* original urb data */
DECL|member|complete
r_void
(paren
op_star
id|complete
)paren
(paren
r_struct
id|urb
op_star
)paren
suffix:semicolon
DECL|member|context
r_void
op_star
id|context
suffix:semicolon
)brace
suffix:semicolon
DECL|function|unlink_complete
r_static
r_void
id|unlink_complete
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|completion_splice
op_star
id|splice
suffix:semicolon
id|splice
op_assign
(paren
r_struct
id|completion_splice
op_star
)paren
id|urb-&gt;context
suffix:semicolon
multiline_comment|/* issue original completion call */
id|urb-&gt;complete
op_assign
id|splice-&gt;complete
suffix:semicolon
id|urb-&gt;context
op_assign
id|splice-&gt;context
suffix:semicolon
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
id|splice-&gt;done
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * called in any context; note ASYNC_UNLINK restrictions&n; *&n; * caller guarantees urb won&squot;t be recycled till both unlink()&n; * and the urb&squot;s completion function return&n; */
DECL|function|hcd_unlink_urb
r_static
r_int
id|hcd_unlink_urb
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_struct
id|usb_hcd
op_star
id|hcd
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|completion_splice
id|splice
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * we contend for urb-&gt;status with the hcd core,&n;&t; * which changes it while returning the urb.&n;&t; *&n;&t; * Caller guaranteed that the urb pointer hasn&squot;t been freed, and&n;&t; * that it was submitted.  But as a rule it can&squot;t know whether or&n;&t; * not it&squot;s already been unlinked ... so we respect the reversed&n;&t; * lock sequence needed for the usb_hcd_giveback_urb() code paths&n;&t; * (urb lock, then hcd_data_lock) in case some other CPU is now&n;&t; * unlinking it.&n;&t; */
id|spin_lock_irqsave
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|hcd_data_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;hcpriv
op_logical_or
id|urb-&gt;transfer_flags
op_amp
id|USB_TIMEOUT_KILLED
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;dev
op_logical_or
op_logical_neg
id|urb-&gt;dev-&gt;bus
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* giveback clears dev; non-null means it&squot;s linked at this level */
id|dev
op_assign
id|urb-&gt;dev-&gt;hcpriv
suffix:semicolon
id|hcd
op_assign
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|hcd
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* For non-periodic transfers, any status except -EINPROGRESS means&n;&t; * the HCD has already started to unlink this URB from the hardware.&n;&t; * In that case, there&squot;s no more work to do.&n;&t; *&n;&t; * For periodic transfers, this is the only way to trigger unlinking&n;&t; * from the hardware.  Since we (currently) overload urb-&gt;status to&n;&t; * tell the driver to unlink, error status might get clobbered ...&n;&t; * unless that transfer hasn&squot;t yet restarted.  One such case is when&n;&t; * the URB gets unlinked from its completion handler.&n;&t; *&n;&t; * FIXME use an URB_UNLINKED flag to match URB_TIMEOUT_KILLED&n;&t; */
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
r_case
id|PIPE_BULK
suffix:colon
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
op_minus
id|EINPROGRESS
)paren
(brace
id|retval
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
multiline_comment|/* maybe set up to block on completion notification */
r_if
c_cond
(paren
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_TIMEOUT_KILLED
)paren
)paren
id|urb-&gt;status
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ASYNC_UNLINK
)paren
)paren
(brace
r_if
c_cond
(paren
id|in_interrupt
(paren
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;non-async unlink in_interrupt&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EWOULDBLOCK
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* synchronous unlink: block till we see the completion */
id|splice.done
op_assign
l_int|0
suffix:semicolon
id|splice.complete
op_assign
id|urb-&gt;complete
suffix:semicolon
id|splice.context
op_assign
id|urb-&gt;context
suffix:semicolon
id|urb-&gt;complete
op_assign
id|unlink_complete
suffix:semicolon
id|urb-&gt;context
op_assign
op_amp
id|splice
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* asynchronous unlink */
id|urb-&gt;status
op_assign
op_minus
id|ECONNRESET
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|hcd_data_lock
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
op_eq
(paren
r_struct
id|urb
op_star
)paren
id|hcd-&gt;rh_timer.data
)paren
(brace
id|rh_status_dequeue
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|hcd-&gt;driver-&gt;urb_dequeue
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
singleline_comment|// FIXME:  if retval and we tried to splice, whoa!!
r_if
c_cond
(paren
id|retval
op_logical_and
id|urb-&gt;status
op_eq
op_minus
id|ENOENT
)paren
id|err
(paren
l_string|&quot;whoa! retval %d&quot;
comma
id|retval
)paren
suffix:semicolon
)brace
multiline_comment|/* block till giveback, if needed */
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
(paren
id|USB_ASYNC_UNLINK
op_or
id|USB_TIMEOUT_KILLED
)paren
)paren
op_logical_and
id|HCD_IS_RUNNING
(paren
id|hcd-&gt;state
)paren
op_logical_and
op_logical_neg
id|retval
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|splice.done
)paren
(brace
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
(paren
(paren
l_int|2
multiline_comment|/*msec*/
op_star
id|HZ
)paren
op_div
l_int|1000
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: wait for giveback urb %p&quot;
comma
id|hcd-&gt;bus_name
comma
id|urb
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ASYNC_UNLINK
)paren
op_logical_and
id|retval
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
)brace
r_goto
id|bye
suffix:semicolon
id|done
suffix:colon
id|spin_unlock
(paren
op_amp
id|hcd_data_lock
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|bye
suffix:colon
r_if
c_cond
(paren
id|retval
)paren
id|dbg
(paren
l_string|&quot;%s: hcd_unlink_urb fail %d&quot;
comma
id|hcd
ques
c_cond
id|hcd-&gt;bus_name
suffix:colon
l_string|&quot;(no bus?)&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* called by khubd, rmmod, apmd, or other thread for hcd-private cleanup */
singleline_comment|// FIXME:  likely best to have explicit per-setting (config+alt)
singleline_comment|// setup primitives in the usbcore-to-hcd driver API, so nothing
singleline_comment|// is implicit.  kernel 2.5 needs a bunch of config cleanup...
DECL|function|hcd_free_dev
r_static
r_int
id|hcd_free_dev
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_struct
id|usb_hcd
op_star
id|hcd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
op_logical_or
op_logical_neg
id|udev-&gt;hcpriv
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev-&gt;bus
op_logical_or
op_logical_neg
id|udev-&gt;bus-&gt;hcpriv
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
singleline_comment|// should udev-&gt;devnum == -1 ??
id|dev
op_assign
id|udev-&gt;hcpriv
suffix:semicolon
id|hcd
op_assign
id|udev-&gt;bus-&gt;hcpriv
suffix:semicolon
multiline_comment|/* device driver problem with refcounts? */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|dev-&gt;urb_list
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;free busy dev, %s devnum %d (bug!)&quot;
comma
id|hcd-&gt;bus_name
comma
id|udev-&gt;devnum
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|hcd-&gt;driver-&gt;free_config
(paren
id|hcd
comma
id|udev
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|dev-&gt;dev_list
)paren
suffix:semicolon
id|udev-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|hcd_operations
r_static
r_struct
id|usb_operations
id|hcd_operations
op_assign
(brace
id|allocate
suffix:colon
id|hcd_alloc_dev
comma
id|get_frame_number
suffix:colon
id|hcd_get_frame_number
comma
id|submit_urb
suffix:colon
id|hcd_submit_urb
comma
id|unlink_urb
suffix:colon
id|hcd_unlink_urb
comma
id|deallocate
suffix:colon
id|hcd_free_dev
comma
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|hcd_irq
r_static
r_void
id|hcd_irq
(paren
r_int
id|irq
comma
r_void
op_star
id|__hcd
comma
r_struct
id|pt_regs
op_star
id|r
)paren
(brace
r_struct
id|usb_hcd
op_star
id|hcd
op_assign
id|__hcd
suffix:semicolon
r_int
id|start
op_assign
id|hcd-&gt;state
suffix:semicolon
id|hcd-&gt;driver-&gt;irq
(paren
id|hcd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hcd-&gt;state
op_ne
id|start
op_logical_and
id|hcd-&gt;state
op_eq
id|USB_STATE_HALT
)paren
id|hc_died
(paren
id|hcd
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/**&n; * usb_hcd_giveback_urb - return URB from HCD to device driver&n; * @hcd: host controller returning the URB&n; * @urb: urb being returned to the USB device driver.&n; *&n; * This hands the URB from HCD to its USB device driver, using its&n; * completion function.  The HCD has freed all per-urb resources&n; * (and is done using urb-&gt;hcpriv).  It also released all HCD locks;&n; * the device driver won&squot;t cause deadlocks if it resubmits this URB,&n; * and won&squot;t confuse things by modifying and resubmitting this one.&n; * Bandwidth and other resources will be deallocated.&n; *&n; * HCDs must not use this for periodic URBs that are still scheduled&n; * and will be reissued.  They should just call their completion handlers&n; * until the urb is returned to the device driver by unlinking.&n; *&n; * In common cases, urb-&gt;next will be submitted before the completion&n; * function gets called.  That&squot;s not done if the URB includes error&n; * status (including unlinking).&n; */
DECL|function|usb_hcd_giveback_urb
r_void
id|usb_hcd_giveback_urb
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* Release periodic transfer bandwidth */
r_if
c_cond
(paren
id|urb-&gt;bandwidth
)paren
(brace
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_INTERRUPT
suffix:colon
id|usb_release_bandwidth
(paren
id|urb-&gt;dev
comma
id|urb
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|usb_release_bandwidth
(paren
id|urb-&gt;dev
comma
id|urb
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* clear all state linking urb to this dev (and hcd) */
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del_init
(paren
op_amp
id|urb-&gt;urb_list
)paren
suffix:semicolon
id|dev
op_assign
id|urb-&gt;dev
suffix:semicolon
id|urb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// NOTE:  a generic device/urb monitoring hook would go here.
singleline_comment|// hcd_monitor_hook(MONITOR_URB_FINISH, urb, dev)
singleline_comment|// It would catch exit/unlink paths for all urbs, but non-exit
singleline_comment|// completions for periodic urbs need hooks inside the HCD.
singleline_comment|// hcd_monitor_hook(MONITOR_URB_UPDATE, urb, dev)
r_if
c_cond
(paren
id|urb-&gt;status
)paren
id|dbg
(paren
l_string|&quot;giveback urb %p status %d&quot;
comma
id|urb
comma
id|urb-&gt;status
)paren
suffix:semicolon
multiline_comment|/* if no error, make sure urb-&gt;next progresses */
r_else
r_if
c_cond
(paren
id|urb-&gt;next
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|usb_submit_urb
(paren
id|urb-&gt;next
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|dbg
(paren
l_string|&quot;urb %p chain fail, %d&quot;
comma
id|urb-&gt;next
comma
id|status
)paren
suffix:semicolon
id|urb-&gt;next-&gt;status
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
)brace
multiline_comment|/* HCDs never modify the urb-&gt;next chain, and only use it here,&n;&t;&t; * so that if urb-&gt;complete sees an URB there with -ENOTCONN,&n;&t;&t; * it knows the driver chained it but it couldn&squot;t be submitted.&n;&t;&t; */
)brace
multiline_comment|/* pass ownership to the completion handler */
id|usb_dec_dev_use
(paren
id|dev
)paren
suffix:semicolon
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
id|usb_put_urb
(paren
id|urb
)paren
suffix:semicolon
)brace
DECL|variable|usb_hcd_giveback_urb
id|EXPORT_SYMBOL
(paren
id|usb_hcd_giveback_urb
)paren
suffix:semicolon
eof
