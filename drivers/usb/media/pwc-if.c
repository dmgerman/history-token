multiline_comment|/* Linux driver for Philips webcam &n;   USB and Video4Linux interface part.&n;   (C) 1999-2001 Nemosoft Unv.&n;&n;   This program is free software; you can redistribute it and/or modify&n;   it under the terms of the GNU General Public License as published by&n;   the Free Software Foundation; either version 2 of the License, or&n;   (at your option) any later version.&n;&n;   This program is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;   GNU General Public License for more details.&n;&n;   You should have received a copy of the GNU General Public License&n;   along with this program; if not, write to the Free Software&n;   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n;&n;*/
multiline_comment|/*  &n;   This code forms the interface between the USB layers and the Philips&n;   specific stuff. Some adanved stuff of the driver falls under an&n;   NDA, signed between me and Philips B.V., Eindhoven, the Netherlands, and&n;   is thus not distributed in source form. The binary pwcx.o module &n;   contains the code that falls under the NDA.&n;   &n;   In case you&squot;re wondering: &squot;pwc&squot; stands for &quot;Philips WebCam&quot;, but &n;   I really didn&squot;t want to type &squot;philips_web_cam&squot; every time (I&squot;m lazy as&n;   any Linux kernel hacker, but I don&squot;t like uncomprehensible abbreviations&n;   without explanation).&n;   &n;   Oh yes, convention: to disctinguish between all the various pointers to&n;   device-structures, I use these names for the pointer variables:&n;   udev: struct usb_device *&n;   vdev: struct video_device *&n;   pdev: struct pwc_devive *&n;*/
multiline_comment|/* Contributors:&n;   - Alvarado: adding whitebalance code&n;   - Alistar Moire: QuickCam 3000 Pro device/product ID&n;   - Tony Hoyle: Creative Labs Webcam 5 device/product ID&n;   - Mark Burazin: solving hang in VIDIOCSYNC when camera gets unplugged&n;   - Jk Fang: SOTEC device/product ID&n;*/
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;pwc.h&quot;
macro_line|#include &quot;pwc-ioctl.h&quot;
macro_line|#include &quot;pwc-uncompress.h&quot;
macro_line|#if !defined(MAP_NR)
DECL|macro|MAP_NR
mdefine_line|#define MAP_NR(a) virt_to_page(a)
macro_line|#endif
multiline_comment|/* Function prototypes and driver templates */
multiline_comment|/* hotplug device table support */
DECL|variable|pwc_device_table
r_static
r_struct
id|usb_device_id
id|pwc_device_table
(braket
)braket
op_assign
(brace
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0471
comma
l_int|0x0302
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0471
comma
l_int|0x0303
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0471
comma
l_int|0x0304
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0471
comma
l_int|0x0307
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0471
comma
l_int|0x0308
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0471
comma
l_int|0x030C
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0471
comma
l_int|0x0310
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0471
comma
l_int|0x0311
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0471
comma
l_int|0x0312
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x069A
comma
l_int|0x0001
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x046D
comma
l_int|0x08b0
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x055D
comma
l_int|0x9000
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x055D
comma
l_int|0x9001
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x041E
comma
l_int|0x400C
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x04CC
comma
l_int|0x8116
)paren
)brace
comma
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|usb
comma
id|pwc_device_table
)paren
suffix:semicolon
r_static
r_void
op_star
id|usb_pwc_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
suffix:semicolon
r_static
r_void
id|usb_pwc_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_void
op_star
id|ptr
)paren
suffix:semicolon
DECL|variable|pwc_driver
r_static
r_struct
id|usb_driver
id|pwc_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;Philips webcam&quot;
comma
multiline_comment|/* name */
id|id_table
suffix:colon
id|pwc_device_table
comma
id|probe
suffix:colon
id|usb_pwc_probe
comma
multiline_comment|/* probe() */
id|disconnect
suffix:colon
id|usb_pwc_disconnect
comma
multiline_comment|/* disconnect() */
)brace
suffix:semicolon
DECL|macro|MAX_DEV_HINTS
mdefine_line|#define MAX_DEV_HINTS 10
DECL|variable|default_size
r_static
r_int
id|default_size
op_assign
id|PSZ_QCIF
suffix:semicolon
DECL|variable|default_fps
r_static
r_int
id|default_fps
op_assign
l_int|10
suffix:semicolon
DECL|variable|default_palette
r_static
r_int
id|default_palette
op_assign
id|VIDEO_PALETTE_YUV420P
suffix:semicolon
multiline_comment|/* This format is understood by most tools */
DECL|variable|default_fbufs
r_static
r_int
id|default_fbufs
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* Default number of frame buffers */
DECL|variable|default_mbufs
r_static
r_int
id|default_mbufs
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Default number of mmap() buffers */
DECL|variable|pwc_trace
r_int
id|pwc_trace
op_assign
id|TRACE_MODULE
op_or
id|TRACE_FLOW
op_or
id|TRACE_PWCX
suffix:semicolon
DECL|variable|power_save
r_static
r_int
id|power_save
op_assign
l_int|0
suffix:semicolon
DECL|variable|led_on
DECL|variable|led_off
r_static
r_int
id|led_on
op_assign
l_int|1
comma
id|led_off
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* defaults to LED that is on while in use */
DECL|variable|pwc_preferred_compression
r_int
id|pwc_preferred_compression
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* 0..3 = uncompressed..high */
r_static
r_struct
(brace
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|member|serial_number
r_char
id|serial_number
(braket
l_int|30
)braket
suffix:semicolon
DECL|member|device_node
r_int
id|device_node
suffix:semicolon
DECL|member|pdev
r_struct
id|pwc_device
op_star
id|pdev
suffix:semicolon
DECL|variable|device_hint
)brace
id|device_hint
(braket
id|MAX_DEV_HINTS
)braket
suffix:semicolon
DECL|variable|mem_lock
r_static
r_struct
id|semaphore
id|mem_lock
suffix:semicolon
DECL|variable|mem_leak
r_static
r_void
op_star
id|mem_leak
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* For delayed kfree()s. See below */
multiline_comment|/***/
r_static
r_int
id|pwc_video_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|pwc_video_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|pwc_video_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
r_int
r_int
id|pwc_video_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
suffix:semicolon
r_static
r_int
id|pwc_video_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|ioctlnr
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|pwc_video_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
DECL|variable|pwc_fops
r_static
r_struct
id|file_operations
id|pwc_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|open
suffix:colon
id|pwc_video_open
comma
id|release
suffix:colon
id|pwc_video_close
comma
id|read
suffix:colon
id|pwc_video_read
comma
id|poll
suffix:colon
id|pwc_video_poll
comma
id|mmap
suffix:colon
id|pwc_video_mmap
comma
id|ioctl
suffix:colon
id|pwc_video_ioctl
comma
id|llseek
suffix:colon
id|no_llseek
comma
)brace
suffix:semicolon
DECL|variable|pwc_template
r_static
r_struct
id|video_device
id|pwc_template
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|name
suffix:colon
l_string|&quot;Philips Webcam&quot;
comma
multiline_comment|/* Filled in later */
id|type
suffix:colon
id|VID_TYPE_CAPTURE
comma
id|hardware
suffix:colon
id|VID_HARDWARE_PWC
comma
id|fops
suffix:colon
op_amp
id|pwc_fops
comma
)brace
suffix:semicolon
multiline_comment|/***************************************************************************/
multiline_comment|/* Okay, this is some magic that I worked out and the reasoning behind it...&n;&n;   The biggest problem with any USB device is of course: &quot;what to do &n;   when the user unplugs the device while it is in use by an application?&quot;&n;   We have several options:&n;   1) Curse them with the 7 plagues when they do (requires divine intervention)&n;   2) Tell them not to (won&squot;t work: they&squot;ll do it anyway)&n;   3) Oops the kernel (this will have a negative effect on a user&squot;s uptime)&n;   4) Do something sensible.&n;   &n;   Of course, we go for option 4.&n;&n;   It happens that this device will be linked to two times, once from&n;   usb_device and once from the video_device in their respective &squot;private&squot;&n;   pointers. This is done when the device is probed() and all initialization&n;   succeeded. The pwc_device struct links back to both structures.&n;&n;   When a device is unplugged while in use it will be removed from the &n;   list of known USB devices; I also de-register as a V4L device, but &n;   unfortunately I can&squot;t free the memory since the struct is still in use&n;   by the file descriptor. This free-ing is then deferend until the first&n;   opportunity. Crude, but it works.&n;   &n;   A small &squot;advantage&squot; is that if a user unplugs the cam and plugs it back&n;   in, it should get assigned the same video device minor, but unfortunately&n;   it&squot;s non-trivial to re-link the cam back to the video device... (that &n;   would surely be magic! :))&n;*/
multiline_comment|/***************************************************************************/
multiline_comment|/* Private functions */
multiline_comment|/* Here we want the physical address of the memory.&n; * This is used when initializing the contents of the area.&n; */
DECL|function|kvirt_to_pa
r_static
r_inline
r_int
r_int
id|kvirt_to_pa
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|kva
comma
id|ret
suffix:semicolon
id|kva
op_assign
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|vmalloc_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|adr
)paren
)paren
suffix:semicolon
id|kva
op_or_assign
id|adr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* restore the offset */
id|ret
op_assign
id|__pa
c_func
(paren
id|kva
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|rvmalloc
r_static
r_void
op_star
id|rvmalloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_void
op_star
id|mem
suffix:semicolon
r_int
r_int
id|adr
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|mem
op_assign
id|vmalloc_32
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
id|memset
c_func
(paren
id|mem
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Clear the ram out, no junk to the user */
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|mem_map_reserve
c_func
(paren
id|vmalloc_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|adr
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_return
id|mem
suffix:semicolon
)brace
DECL|function|rvfree
r_static
r_void
id|rvfree
c_func
(paren
r_void
op_star
id|mem
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|adr
suffix:semicolon
r_if
c_cond
(paren
id|mem
)paren
(brace
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
)paren
id|size
OG
l_int|0
)paren
(brace
id|mem_map_unreserve
c_func
(paren
id|vmalloc_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|adr
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
)brace
DECL|function|pwc_allocate_buffers
r_static
r_int
id|pwc_allocate_buffers
c_func
(paren
r_struct
id|pwc_device
op_star
id|pdev
)paren
(brace
r_int
id|i
suffix:semicolon
r_void
op_star
id|kbuf
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Entering allocate_buffers(%p).&bslash;n&quot;
comma
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
macro_line|#ifdef PWC_MAGIC
r_if
c_cond
(paren
id|pdev-&gt;magic
op_ne
id|PWC_MAGIC
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;allocate_buffers(): magic failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
macro_line|#endif&t;
multiline_comment|/* Allocate Isochronuous pipe buffers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ISO_BUFS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_eq
l_int|NULL
)paren
(brace
id|kbuf
op_assign
id|kmalloc
c_func
(paren
id|ISO_BUFFER_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbuf
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Failed to allocate iso buffer %d.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Allocated iso buffer at %p.&bslash;n&quot;
comma
id|kbuf
)paren
suffix:semicolon
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_assign
id|kbuf
suffix:semicolon
id|memset
c_func
(paren
id|kbuf
comma
l_int|0
comma
id|ISO_BUFFER_SIZE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Allocate frame buffer structure */
r_if
c_cond
(paren
id|pdev-&gt;fbuf
op_eq
l_int|NULL
)paren
(brace
id|kbuf
op_assign
id|kmalloc
c_func
(paren
id|default_fbufs
op_star
r_sizeof
(paren
r_struct
id|pwc_frame_buf
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbuf
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Failed to allocate frame buffer structure.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Allocated frame buffer structure at %p.&bslash;n&quot;
comma
id|kbuf
)paren
suffix:semicolon
id|pdev-&gt;fbuf
op_assign
id|kbuf
suffix:semicolon
id|memset
c_func
(paren
id|kbuf
comma
l_int|0
comma
id|default_fbufs
op_star
r_sizeof
(paren
r_struct
id|pwc_frame_buf
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* create frame buffers, and make circular ring */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|default_fbufs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pdev-&gt;fbuf
(braket
id|i
)braket
dot
id|data
op_eq
l_int|NULL
)paren
(brace
id|kbuf
op_assign
id|vmalloc
c_func
(paren
id|PWC_FRAME_SIZE
)paren
suffix:semicolon
multiline_comment|/* need vmalloc since frame buffer &gt; 128K */
r_if
c_cond
(paren
id|kbuf
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Failed to allocate frame buffer %d.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Allocated frame buffer %d at %p.&bslash;n&quot;
comma
id|i
comma
id|kbuf
)paren
suffix:semicolon
id|pdev-&gt;fbuf
(braket
id|i
)braket
dot
id|data
op_assign
id|kbuf
suffix:semicolon
id|memset
c_func
(paren
id|kbuf
comma
l_int|128
comma
id|PWC_FRAME_SIZE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Allocate decompressor table space */
id|kbuf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;decompressor
op_ne
l_int|NULL
)paren
(brace
id|kbuf
op_assign
id|kmalloc
c_func
(paren
id|pdev-&gt;decompressor-&gt;table_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbuf
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Failed to allocate decompress table.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Allocated decompress table %p.&bslash;n&quot;
comma
id|kbuf
)paren
suffix:semicolon
)brace
id|pdev-&gt;decompress_data
op_assign
id|kbuf
suffix:semicolon
multiline_comment|/* Allocate image buffer; double buffer for mmap() */
id|kbuf
op_assign
id|rvmalloc
c_func
(paren
id|default_mbufs
op_star
id|pdev-&gt;len_per_image
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbuf
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Failed to allocate image buffer(s).&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Allocated image buffer at %p.&bslash;n&quot;
comma
id|kbuf
)paren
suffix:semicolon
id|pdev-&gt;image_data
op_assign
id|kbuf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|default_mbufs
suffix:semicolon
id|i
op_increment
)paren
id|pdev-&gt;image_ptr
(braket
id|i
)braket
op_assign
id|kbuf
op_plus
id|i
op_star
id|pdev-&gt;len_per_image
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|MAX_IMAGES
suffix:semicolon
id|i
op_increment
)paren
id|pdev-&gt;image_ptr
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Leaving pwc_allocate_buffers().&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pwc_free_buffers
r_static
r_void
id|pwc_free_buffers
c_func
(paren
r_struct
id|pwc_device
op_star
id|pdev
)paren
(brace
r_int
id|i
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Entering free_buffers(%p).&bslash;n&quot;
comma
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
macro_line|#ifdef PWC_MAGIC
r_if
c_cond
(paren
id|pdev-&gt;magic
op_ne
id|PWC_MAGIC
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;free_buffers(): magic failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif&t;
multiline_comment|/* Release Iso-pipe buffers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ISO_BUFS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_ne
l_int|NULL
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Freeing ISO buffer at %p.&bslash;n&quot;
comma
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* The same for frame buffers */
r_if
c_cond
(paren
id|pdev-&gt;fbuf
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|default_fbufs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pdev-&gt;fbuf
(braket
id|i
)braket
dot
id|data
op_ne
l_int|NULL
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Freeing frame buffer %d at %p.&bslash;n&quot;
comma
id|i
comma
id|pdev-&gt;fbuf
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|pdev-&gt;fbuf
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
id|pdev-&gt;fbuf
(braket
id|i
)braket
dot
id|data
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|pdev-&gt;fbuf
)paren
suffix:semicolon
id|pdev-&gt;fbuf
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Intermediate decompression buffer &amp; tables */
r_if
c_cond
(paren
id|pdev-&gt;decompress_data
op_ne
l_int|NULL
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Freeing decompression buffer at %p.&bslash;n&quot;
comma
id|pdev-&gt;decompress_data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pdev-&gt;decompress_data
)paren
suffix:semicolon
id|pdev-&gt;decompress_data
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pdev-&gt;decompressor
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Release image buffers */
r_if
c_cond
(paren
id|pdev-&gt;image_data
op_ne
l_int|NULL
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Freeing image buffer at %p.&bslash;n&quot;
comma
id|pdev-&gt;image_data
)paren
suffix:semicolon
id|rvfree
c_func
(paren
id|pdev-&gt;image_data
comma
id|default_mbufs
op_star
id|pdev-&gt;len_per_image
)paren
suffix:semicolon
)brace
id|pdev-&gt;image_data
op_assign
l_int|NULL
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Leaving free_buffers().&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* The frame &amp; image buffer mess. &n;&n;   Yes, this is a mess. Well, it used to be simple, but alas...  In this&n;   module, 3 buffers schemes are used to get the data from the USB bus to&n;   the user program. The first scheme involves the ISO buffers (called thus&n;   since they transport ISO data from the USB controller), and not really&n;   interesting. Suffices to say the data from this buffer is quickly &n;   gathered in an interrupt handler (pwc_isoc_handler) and placed into the &n;   frame buffer.&n;   &n;   The frame buffer is the second scheme, and is the central element here.&n;   It collects the data from a single frame from the camera (hence, the&n;   name). Frames are delimited by the USB camera with a short USB packet,&n;   so that&squot;s easy to detect. The frame buffers form a list that is filled&n;   by the camera+USB controller and drained by the user process through &n;   either read() or mmap().&n;   &n;   The image buffer is the third scheme, in which frames are decompressed&n;   and possibly converted into planar format. For mmap() there is more than&n;   one image buffer available.&n;&n;   The frame buffers provide the image buffering, in case the user process&n;   is a bit slow. This introduces lag and some undesired side-effects.&n;   The problem arises when the frame buffer is full. I used to drop the last &n;   frame, which makes the data in the queue stale very quickly. But dropping &n;   the frame at the head of the queue proved to be a litte bit more difficult.&n;   I tried a circular linked scheme, but this introduced more problems than&n;   it solved.&n;&n;   Because filling and draining are completely asynchronous processes, this&n;   requires some fiddling with pointers and mutexes.&n;   &n;   Eventually, I came up with a system with 2 lists: an &squot;empty&squot; frame list&n;   and a &squot;full&squot; frame list:&n;     * Initially, all frame buffers but one are on the &squot;empty&squot; list; the one&n;       remaining buffer is our initial fill frame.&n;     * If a frame is needed for filling, we take it from the &squot;empty&squot; list, &n;       unless that list is empty, in which case we take the buffer at the &n;       head of the &squot;full&squot; list.&n;     * When our fill buffer has been filled, it is appended to the &squot;full&squot; &n;       list.&n;     * If a frame is needed by read() or mmap(), it is taken from the head of &n;       the &squot;full&squot; list, handled, and then appended to the &squot;empty&squot; list. If no&n;       buffer is present on the &squot;full&squot; list, we wait.&n;   The advantage is that the buffer that is currently being decompressed/&n;   converted, is on neither list, and thus not in our way (any other scheme &n;   I tried had the problem of old data lingering in the queue).&n;&n;   Whatever strategy you choose, it always remains a tradeoff: with more&n;   frame buffers the chances of a missed frame are reduced. On the other&n;   hand, on slower machines it introduces lag because the queue will &n;   always be full.&n; */
multiline_comment|/**&n;  &bslash;brief Find next frame buffer to fill. Take from empty or full list, whichever comes first.&n; */
DECL|function|pwc_next_fill_frame
r_static
r_inline
r_int
id|pwc_next_fill_frame
c_func
(paren
r_struct
id|pwc_device
op_star
id|pdev
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pdev-&gt;ptrlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;fill_frame
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* append to &squot;full&squot; list */
r_if
c_cond
(paren
id|pdev-&gt;full_frames
op_eq
l_int|NULL
)paren
(brace
id|pdev-&gt;full_frames
op_assign
id|pdev-&gt;fill_frame
suffix:semicolon
id|pdev-&gt;full_frames_tail
op_assign
id|pdev-&gt;full_frames
suffix:semicolon
)brace
r_else
(brace
id|pdev-&gt;full_frames_tail-&gt;next
op_assign
id|pdev-&gt;fill_frame
suffix:semicolon
id|pdev-&gt;full_frames_tail
op_assign
id|pdev-&gt;fill_frame
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pdev-&gt;empty_frames
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* We have empty frames available. That&squot;s easy */
id|pdev-&gt;fill_frame
op_assign
id|pdev-&gt;empty_frames
suffix:semicolon
id|pdev-&gt;empty_frames
op_assign
id|pdev-&gt;empty_frames-&gt;next
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Hmm. Take it from the full list */
macro_line|#if PWC_DEBUG&t;&t;
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|pdev-&gt;full_frames
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Neither empty or full frames available!&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pdev-&gt;ptrlock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif
id|pdev-&gt;fill_frame
op_assign
id|pdev-&gt;full_frames
suffix:semicolon
id|pdev-&gt;full_frames
op_assign
id|pdev-&gt;full_frames-&gt;next
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|pdev-&gt;fill_frame-&gt;next
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if PWC_DEBUG
id|Trace
c_func
(paren
id|TRACE_SEQUENCE
comma
l_string|&quot;Assigning sequence number %d.&bslash;n&quot;
comma
id|pdev-&gt;sequence
)paren
suffix:semicolon
id|pdev-&gt;fill_frame-&gt;sequence
op_assign
id|pdev-&gt;sequence
op_increment
suffix:semicolon
macro_line|#endif
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pdev-&gt;ptrlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n;  &bslash;brief Reset all buffers, pointers and lists, except for the image_used[] buffer. &n;  &n;  If the image_used[] buffer is cleared too, mmap()/VIDIOCSYNC will run into trouble.&n; */
DECL|function|pwc_reset_buffers
r_static
r_void
id|pwc_reset_buffers
c_func
(paren
r_struct
id|pwc_device
op_star
id|pdev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pdev-&gt;ptrlock
comma
id|flags
)paren
suffix:semicolon
id|pdev-&gt;full_frames
op_assign
l_int|NULL
suffix:semicolon
id|pdev-&gt;full_frames_tail
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|default_fbufs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pdev-&gt;fbuf
(braket
id|i
)braket
dot
id|filled
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|pdev-&gt;fbuf
(braket
id|i
)braket
dot
id|next
op_assign
op_amp
id|pdev-&gt;fbuf
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
r_else
id|pdev-&gt;fbuf-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pdev-&gt;empty_frames
op_assign
op_amp
id|pdev-&gt;fbuf
(braket
id|default_fbufs
op_minus
l_int|1
)braket
suffix:semicolon
id|pdev-&gt;empty_frames_tail
op_assign
id|pdev-&gt;fbuf
suffix:semicolon
id|pdev-&gt;read_frame
op_assign
l_int|NULL
suffix:semicolon
id|pdev-&gt;fill_frame
op_assign
id|pdev-&gt;empty_frames
suffix:semicolon
id|pdev-&gt;empty_frames
op_assign
id|pdev-&gt;empty_frames-&gt;next
suffix:semicolon
id|pdev-&gt;image_read_pos
op_assign
l_int|0
suffix:semicolon
id|pdev-&gt;fill_image
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pdev-&gt;ptrlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n;  &bslash;brief Do all the handling for getting one frame: get pointer, decompress, advance pointers.&n; */
DECL|function|pwc_handle_frame
r_static
r_int
id|pwc_handle_frame
c_func
(paren
r_struct
id|pwc_device
op_star
id|pdev
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pdev-&gt;ptrlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* First grab our read_frame; this is removed from all lists, so&n;&t;   we can release the lock after this without problems */
r_if
c_cond
(paren
id|pdev-&gt;read_frame
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* This can&squot;t theoretically happen */
id|Err
c_func
(paren
l_string|&quot;Huh? Read frame still in use?&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pdev-&gt;full_frames
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Woops. No frames ready.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|pdev-&gt;read_frame
op_assign
id|pdev-&gt;full_frames
suffix:semicolon
id|pdev-&gt;full_frames
op_assign
id|pdev-&gt;full_frames-&gt;next
suffix:semicolon
id|pdev-&gt;read_frame-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pdev-&gt;read_frame
op_ne
l_int|NULL
)paren
(brace
macro_line|#if PWC_DEBUG
id|Trace
c_func
(paren
id|TRACE_SEQUENCE
comma
l_string|&quot;Decompressing frame %d&bslash;n&quot;
comma
id|pdev-&gt;read_frame-&gt;sequence
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Decompression is a lenghty process, so it&squot;s outside of the lock.&n;&t;&t;&t;   This gives the isoc_handler the opportunity to fill more frames &n;&t;&t;&t;   in the mean time.&n;&t;&t;&t;*/
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pdev-&gt;ptrlock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|pwc_decompress
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pdev-&gt;ptrlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* We&squot;re done with read_buffer, tack it to the end of the empty buffer list */
r_if
c_cond
(paren
id|pdev-&gt;empty_frames
op_eq
l_int|NULL
)paren
(brace
id|pdev-&gt;empty_frames
op_assign
id|pdev-&gt;read_frame
suffix:semicolon
id|pdev-&gt;empty_frames_tail
op_assign
id|pdev-&gt;empty_frames
suffix:semicolon
)brace
r_else
(brace
id|pdev-&gt;empty_frames_tail-&gt;next
op_assign
id|pdev-&gt;read_frame
suffix:semicolon
id|pdev-&gt;empty_frames_tail
op_assign
id|pdev-&gt;read_frame
suffix:semicolon
)brace
id|pdev-&gt;read_frame
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pdev-&gt;ptrlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n;  &bslash;brief Advance pointers of image buffer (after each user request) &n;*/
DECL|function|pwc_next_image
r_static
r_inline
r_void
id|pwc_next_image
c_func
(paren
r_struct
id|pwc_device
op_star
id|pdev
)paren
(brace
id|pdev-&gt;image_used
(braket
id|pdev-&gt;fill_image
)braket
op_assign
l_int|0
suffix:semicolon
id|pdev-&gt;fill_image
op_assign
(paren
id|pdev-&gt;fill_image
op_plus
l_int|1
)paren
op_mod
id|default_mbufs
suffix:semicolon
)brace
multiline_comment|/* 2001-10-14: The YUV420 is still there, but you can only set it from within &n;   a program (YUV420P being the default) */
DECL|function|pwc_set_palette
r_static
r_int
id|pwc_set_palette
c_func
(paren
r_struct
id|pwc_device
op_star
id|pdev
comma
r_int
id|pal
)paren
(brace
r_if
c_cond
(paren
id|pal
op_eq
id|VIDEO_PALETTE_YUV420
op_logical_or
id|pal
op_eq
id|VIDEO_PALETTE_YUV420P
macro_line|#if PWC_DEBUG
op_logical_or
id|pal
op_eq
id|VIDEO_PALETTE_RAW
macro_line|#endif
)paren
(brace
id|pdev-&gt;vpalette
op_assign
id|pal
suffix:semicolon
id|pwc_set_image_buffer_size
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|Trace
c_func
(paren
id|TRACE_READ
comma
l_string|&quot;Palette %d not supported.&bslash;n&quot;
comma
id|pal
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This gets called for the Isochronous pipe (video). This is done in&n; * interrupt time, so it has to be fast, not crash, and not stall. Neat.&n; */
DECL|function|pwc_isoc_handler
r_static
r_void
id|pwc_isoc_handler
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|pwc_device
op_star
id|pdev
suffix:semicolon
r_int
id|i
comma
id|fst
comma
id|flen
suffix:semicolon
r_int
id|awake
suffix:semicolon
r_struct
id|pwc_frame_buf
op_star
id|fbuf
suffix:semicolon
r_int
r_char
op_star
id|fillptr
comma
op_star
id|iso_buf
suffix:semicolon
id|pdev
op_assign
(paren
r_struct
id|pwc_device
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;isoc_handler() called with NULL device?!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PWC_MAGIC&t;
r_if
c_cond
(paren
id|pdev-&gt;magic
op_ne
id|PWC_MAGIC
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;isoc_handler() called with bad magic!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|ENOENT
op_logical_or
id|urb-&gt;status
op_eq
op_minus
id|ECONNRESET
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;pwc_isoc_handler(): URB unlinked.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
op_minus
id|EINPROGRESS
op_logical_and
id|urb-&gt;status
op_ne
l_int|0
)paren
(brace
r_char
op_star
id|errmsg
suffix:semicolon
id|errmsg
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
r_switch
c_cond
(paren
id|urb-&gt;status
)paren
(brace
r_case
op_minus
id|ENOSR
suffix:colon
id|errmsg
op_assign
l_string|&quot;Buffer error (overrun)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EPIPE
suffix:colon
id|errmsg
op_assign
l_string|&quot;Stalled (device not responding)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EOVERFLOW
suffix:colon
id|errmsg
op_assign
l_string|&quot;Babble (bad cable?)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EPROTO
suffix:colon
id|errmsg
op_assign
l_string|&quot;Bit-stuff error (bad cable?)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EILSEQ
suffix:colon
id|errmsg
op_assign
l_string|&quot;CRC/Timeout&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ETIMEDOUT
suffix:colon
id|errmsg
op_assign
l_string|&quot;NAK (device does not respond)&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|Trace
c_func
(paren
id|TRACE_FLOW
comma
l_string|&quot;pwc_isoc_handler() called with status %d [%s].&bslash;n&quot;
comma
id|urb-&gt;status
comma
id|errmsg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|fbuf
op_assign
id|pdev-&gt;fill_frame
suffix:semicolon
r_if
c_cond
(paren
id|fbuf
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;pwc_isoc_handler without valid fill frame.&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|pdev-&gt;frameq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|fillptr
op_assign
id|fbuf-&gt;data
op_plus
id|fbuf-&gt;filled
suffix:semicolon
id|awake
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* vsync: 0 = don&squot;t copy data&n;&t;          1 = sync-hunt&n;&t;          2 = synched &n;&t; */
multiline_comment|/* Compact data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
id|fst
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
suffix:semicolon
id|flen
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
suffix:semicolon
id|iso_buf
op_assign
id|urb-&gt;transfer_buffer
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|fst
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|flen
OG
l_int|0
)paren
(brace
multiline_comment|/* if valid data... */
r_if
c_cond
(paren
id|pdev-&gt;vsync
OG
l_int|0
)paren
(brace
multiline_comment|/* ...and we are not sync-hunting... */
id|pdev-&gt;vsync
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* ...copy data to frame buffer, if possible */
r_if
c_cond
(paren
id|flen
op_plus
id|fbuf-&gt;filled
OG
id|pdev-&gt;frame_size
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_FLOW
comma
l_string|&quot;Frame buffer overflow (flen = %d, frame_size = %d).&bslash;n&quot;
comma
id|flen
comma
id|pdev-&gt;frame_size
)paren
suffix:semicolon
id|pdev-&gt;vsync
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Hmm, let&squot;s wait for an EOF (end-of-frame) */
id|pdev-&gt;vframes_error
op_increment
suffix:semicolon
)brace
r_else
(brace
id|memmove
c_func
(paren
id|fillptr
comma
id|iso_buf
comma
id|flen
)paren
suffix:semicolon
id|fillptr
op_add_assign
id|flen
suffix:semicolon
)brace
)brace
id|fbuf-&gt;filled
op_add_assign
id|flen
suffix:semicolon
)brace
multiline_comment|/* ..flen &gt; 0 */
r_if
c_cond
(paren
id|flen
OL
id|pdev-&gt;vlast_packet_size
)paren
(brace
multiline_comment|/* Shorter packet... We probably have the end of an image-frame; &n;&t;&t;&t;&t;   wake up read() process and let select()/poll() do something.&n;&t;&t;&t;&t;   Decompression is done in user time over there. &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pdev-&gt;vsync
op_eq
l_int|2
)paren
(brace
multiline_comment|/* The ToUCam Fun CMOS sensor causes the firmware to send 2 or 3 bogus &n;&t;&t;&t;&t;&t;   frames on the USB wire after an exposure change. This conditition is &n;&t;&t;&t;&t;&t;   however detected  in the cam and a bit is set in the header.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pdev-&gt;type
op_eq
l_int|730
)paren
(brace
r_int
r_char
op_star
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|fbuf-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|ptr
(braket
l_int|1
)braket
op_eq
l_int|1
op_logical_and
id|ptr
(braket
l_int|0
)braket
op_amp
l_int|0x10
)paren
(brace
macro_line|#if PWC_DEBUG
id|Debug
c_func
(paren
l_string|&quot;Hyundai CMOS sensor bug. Dropping frame %d.&bslash;n&quot;
comma
id|fbuf-&gt;sequence
)paren
suffix:semicolon
macro_line|#endif
id|pdev-&gt;drop_frames
op_assign
l_int|2
suffix:semicolon
id|pdev-&gt;vframes_error
op_increment
suffix:semicolon
)brace
multiline_comment|/* Sometimes the trailer of the 730 is still sent as a 4 byte packet &n;&t;&t;&t;&t;&t;&t;   after a short frame; this condition is filtered out specifically. A 4 byte&n;&t;&t;&t;&t;&t;&t;   frame doesn&squot;t make sense anyway.&n;&t;&t;&t;&t;&t;&t;   So we get either this sequence: &n;&t;&t;&t;&t;&t;&t;   &t;drop_bit set -&gt; 4 byte frame -&gt; short frame -&gt; good frame&n;&t;&t;&t;&t;&t;&t;   Or this one:&n;&t;&t;&t;&t;&t;&t;   &t;drop_bit set -&gt; short frame -&gt; good frame&n;&t;&t;&t;&t;&t;&t;   So we drop either 3 or 2 frames in all!&n;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|fbuf-&gt;filled
op_eq
l_int|4
)paren
id|pdev-&gt;drop_frames
op_increment
suffix:semicolon
)brace
multiline_comment|/* In case we were instructed to drop the frame, do so silently.&n;&t;&t;&t;&t;&t;   The buffer pointers are not updated either (but the counters are reset below).&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pdev-&gt;drop_frames
)paren
id|pdev-&gt;drop_frames
op_decrement
suffix:semicolon
r_else
(brace
multiline_comment|/* Check for underflow first */
r_if
c_cond
(paren
id|fbuf-&gt;filled
OL
id|pdev-&gt;frame_size
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_FLOW
comma
l_string|&quot;Frame buffer underflow (%d bytes); discarded.&bslash;n&quot;
comma
id|fbuf-&gt;filled
)paren
suffix:semicolon
id|pdev-&gt;vframes_error
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Send only once per EOF */
id|awake
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* delay wake_ups */
multiline_comment|/* Find our next frame to fill. This will always succeed, since we&n;&t;&t;&t;&t;&t;&t;&t; * nick a frame from either empty or full list, but if we had to&n;&t;&t;&t;&t;&t;&t;&t; * take it from the full list, it means a frame got dropped.&n;&t;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pwc_next_fill_frame
c_func
(paren
id|pdev
)paren
)paren
(brace
id|pdev-&gt;vframes_dumped
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pdev-&gt;vframe_count
OG
id|FRAME_LOWMARK
)paren
op_logical_and
(paren
id|pwc_trace
op_amp
id|TRACE_FLOW
)paren
)paren
(brace
r_if
c_cond
(paren
id|pdev-&gt;vframes_dumped
OL
l_int|20
)paren
id|Trace
c_func
(paren
id|TRACE_FLOW
comma
l_string|&quot;Dumping frame %d.&bslash;n&quot;
comma
id|pdev-&gt;vframe_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;vframes_dumped
op_eq
l_int|20
)paren
id|Trace
c_func
(paren
id|TRACE_FLOW
comma
l_string|&quot;Dumping frame %d (last message).&bslash;n&quot;
comma
id|pdev-&gt;vframe_count
)paren
suffix:semicolon
)brace
)brace
id|fbuf
op_assign
id|pdev-&gt;fill_frame
suffix:semicolon
)brace
)brace
multiline_comment|/* !drop_frames */
id|pdev-&gt;vframe_count
op_increment
suffix:semicolon
)brace
id|fbuf-&gt;filled
op_assign
l_int|0
suffix:semicolon
id|fillptr
op_assign
id|fbuf-&gt;data
suffix:semicolon
id|pdev-&gt;vsync
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* .. flen &lt; last_packet_size */
id|pdev-&gt;vlast_packet_size
op_assign
id|flen
suffix:semicolon
)brace
multiline_comment|/* ..status == 0 */
macro_line|#ifdef PWC_DEBUG
multiline_comment|/* This is normally not interesting to the user, unless you are really debugging something */
r_else
id|Trace
c_func
(paren
id|TRACE_FLOW
comma
l_string|&quot;Iso frame %d of USB has error %d&bslash;n&quot;
comma
id|i
comma
id|fst
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;
)brace
r_if
c_cond
(paren
id|awake
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|pdev-&gt;frameq
)paren
suffix:semicolon
id|urb-&gt;dev
op_assign
id|pdev-&gt;udev
suffix:semicolon
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
DECL|function|pwc_isoc_init
r_static
r_int
id|pwc_isoc_init
c_func
(paren
r_struct
id|pwc_device
op_star
id|pdev
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|ret
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|idesc
suffix:semicolon
r_int
id|cur_alt
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;iso_init
)paren
r_return
l_int|0
suffix:semicolon
id|pdev-&gt;vsync
op_assign
l_int|0
suffix:semicolon
id|udev
op_assign
id|pdev-&gt;udev
suffix:semicolon
multiline_comment|/* Get the current alternate interface, adjust packet size */
r_if
c_cond
(paren
op_logical_neg
id|udev-&gt;actconfig
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cur_alt
op_assign
id|udev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
dot
id|act_altsetting
suffix:semicolon
id|idesc
op_assign
op_amp
id|udev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
dot
id|altsetting
(braket
id|cur_alt
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idesc
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Search video endpoint */
id|pdev-&gt;vmax_packet_size
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|idesc-&gt;bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|idesc-&gt;endpoint
(braket
id|i
)braket
dot
id|bEndpointAddress
op_amp
l_int|0xF
)paren
op_eq
id|pdev-&gt;vendpoint
)paren
(brace
id|pdev-&gt;vmax_packet_size
op_assign
id|idesc-&gt;endpoint
(braket
id|i
)braket
dot
id|wMaxPacketSize
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pdev-&gt;vmax_packet_size
template_param
id|ISO_MAX_FRAME_SIZE
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Failed to find packet size for video endpoint in current alternate setting.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENFILE
suffix:semicolon
multiline_comment|/* Odd error, that should be noticable */
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ISO_BUFS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|urb
op_assign
id|usb_alloc_urb
c_func
(paren
id|ISO_FRAMES_PER_DESC
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Failed to allocate urb %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
op_assign
id|urb
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* De-allocate in reverse order */
r_while
c_loop
(paren
id|i
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
op_ne
l_int|NULL
)paren
id|usb_free_urb
c_func
(paren
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
)paren
suffix:semicolon
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
op_assign
l_int|NULL
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* init URB structure */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ISO_BUFS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|urb
op_assign
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
suffix:semicolon
id|urb-&gt;interval
op_assign
l_int|1
suffix:semicolon
singleline_comment|// devik
id|urb-&gt;dev
op_assign
id|udev
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|usb_rcvisocpipe
c_func
(paren
id|udev
comma
id|pdev-&gt;vendpoint
)paren
suffix:semicolon
id|urb-&gt;transfer_flags
op_assign
id|USB_ISO_ASAP
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|data
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|ISO_BUFFER_SIZE
suffix:semicolon
id|urb-&gt;complete
op_assign
id|pwc_isoc_handler
suffix:semicolon
id|urb-&gt;context
op_assign
id|pdev
suffix:semicolon
id|urb-&gt;start_frame
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;number_of_packets
op_assign
id|ISO_FRAMES_PER_DESC
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ISO_FRAMES_PER_DESC
suffix:semicolon
id|j
op_increment
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|j
)braket
dot
id|offset
op_assign
id|j
op_star
id|pdev-&gt;vmax_packet_size
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|j
)braket
dot
id|length
op_assign
id|pdev-&gt;vmax_packet_size
suffix:semicolon
)brace
)brace
multiline_comment|/* link */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ISO_BUFS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|Err
c_func
(paren
l_string|&quot;isoc_init() submit_urb %d failed with error %d&bslash;n&quot;
comma
id|i
comma
id|ret
)paren
suffix:semicolon
r_else
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;pwc_isoc_init(): URB submitted.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* data should stream in now */
id|pdev-&gt;iso_init
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pwc_isoc_cleanup
r_static
r_void
id|pwc_isoc_cleanup
c_func
(paren
r_struct
id|pwc_device
op_star
id|pdev
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pdev-&gt;iso_init
)paren
r_return
suffix:semicolon
multiline_comment|/* Stop camera, but only if we are sure the camera is still there */
r_if
c_cond
(paren
op_logical_neg
id|pdev-&gt;unplugged
)paren
id|usb_set_interface
c_func
(paren
id|pdev-&gt;udev
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Unlinking ISOC buffers one by one */
r_for
c_loop
(paren
id|i
op_assign
id|MAX_ISO_BUFS
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
singleline_comment|//pdev-&gt;sbuf[i].urb-&gt;next = NULL;
id|usb_unlink_urb
c_func
(paren
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
)paren
suffix:semicolon
id|pdev-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pdev-&gt;iso_init
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|pwc_try_video_mode
r_int
id|pwc_try_video_mode
c_func
(paren
r_struct
id|pwc_device
op_star
id|pdev
comma
r_int
id|width
comma
r_int
id|height
comma
r_int
id|new_fps
comma
r_int
id|new_compression
comma
r_int
id|new_snapshot
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* Stop isoc stuff */
id|pwc_isoc_cleanup
c_func
(paren
id|pdev
)paren
suffix:semicolon
multiline_comment|/* Reset parameters */
id|pwc_reset_buffers
c_func
(paren
id|pdev
)paren
suffix:semicolon
multiline_comment|/* Try to set video mode... */
id|ret
op_assign
id|pwc_set_video_mode
c_func
(paren
id|pdev
comma
id|width
comma
id|height
comma
id|new_fps
comma
id|new_compression
comma
id|new_snapshot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
multiline_comment|/* That failed... restore old mode (we know that worked) */
id|ret
op_assign
id|pwc_set_video_mode
c_func
(paren
id|pdev
comma
id|pdev-&gt;view.x
comma
id|pdev-&gt;view.y
comma
id|pdev-&gt;vframes
comma
id|pdev-&gt;vcompression
comma
id|pdev-&gt;vsnapshot
)paren
suffix:semicolon
r_else
multiline_comment|/* Set (new) alternate interface */
id|ret
op_assign
id|usb_set_interface
c_func
(paren
id|pdev-&gt;udev
comma
l_int|0
comma
id|pdev-&gt;valternate
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|pwc_isoc_init
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|pdev-&gt;drop_frames
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* try to avoid garbage during switch */
r_return
id|ret
suffix:semicolon
)brace
DECL|function|set_mem_leak
r_static
r_inline
r_void
id|set_mem_leak
c_func
(paren
r_void
op_star
id|ptr
)paren
(brace
id|down
c_func
(paren
op_amp
id|mem_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem_leak
op_ne
l_int|NULL
)paren
id|Err
c_func
(paren
l_string|&quot;Memleak: overwriting mem_leak pointer!&bslash;n&quot;
)paren
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Setting mem_leak to 0x%p.&bslash;n&quot;
comma
id|ptr
)paren
suffix:semicolon
id|mem_leak
op_assign
id|ptr
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mem_lock
)paren
suffix:semicolon
)brace
DECL|function|free_mem_leak
r_static
r_inline
r_void
id|free_mem_leak
c_func
(paren
r_void
)paren
(brace
id|down
c_func
(paren
op_amp
id|mem_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem_leak
op_ne
l_int|NULL
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;Freeing mem_leak ptr 0x%p.&bslash;n&quot;
comma
id|mem_leak
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mem_leak
)paren
suffix:semicolon
id|mem_leak
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|mem_lock
)paren
suffix:semicolon
)brace
multiline_comment|/***************************************************************************/
multiline_comment|/* Video4Linux functions */
DECL|function|pwc_video_open
r_static
r_int
id|pwc_video_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|video_device
op_star
id|vdev
op_assign
id|video_devdata
c_func
(paren
id|file
)paren
suffix:semicolon
r_struct
id|pwc_device
op_star
id|pdev
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;video_open called(0x%p).&bslash;n&quot;
comma
id|vdev
)paren
suffix:semicolon
id|pdev
op_assign
(paren
r_struct
id|pwc_device
op_star
)paren
id|vdev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;vopen
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|down
c_func
(paren
op_amp
id|pdev-&gt;modlock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pdev-&gt;usb_init
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;Doing first time initialization.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Reset camera */
r_if
c_cond
(paren
id|usb_set_interface
c_func
(paren
id|pdev-&gt;udev
comma
l_int|0
comma
l_int|0
)paren
)paren
id|Info
c_func
(paren
l_string|&quot;Failed to set alternate interface to 0.&bslash;n&quot;
)paren
suffix:semicolon
id|pdev-&gt;usb_init
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Turn on camera */
r_if
c_cond
(paren
id|power_save
)paren
(brace
id|i
op_assign
id|pwc_camera_power
c_func
(paren
id|pdev
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
id|Info
c_func
(paren
l_string|&quot;Failed to restore power to the camera! (%d)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* Set LED on/off time */
r_if
c_cond
(paren
id|pwc_set_leds
c_func
(paren
id|pdev
comma
id|led_on
comma
id|led_off
)paren
OL
l_int|0
)paren
id|Info
c_func
(paren
l_string|&quot;Failed to set LED on/off time.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Find our decompressor, if any */
id|pdev-&gt;decompressor
op_assign
id|pwc_find_decompressor
c_func
(paren
id|pdev-&gt;type
)paren
suffix:semicolon
macro_line|#if PWC_DEBUG&t;
id|Debug
c_func
(paren
l_string|&quot;Found decompressor for %d at 0x%p&bslash;n&quot;
comma
id|pdev-&gt;type
comma
id|pdev-&gt;decompressor
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* So far, so good. Allocate memory. */
id|i
op_assign
id|pwc_allocate_buffers
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;Failed to allocate buffer memory.&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|pdev-&gt;modlock
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* Reset buffers &amp; parameters */
id|pwc_reset_buffers
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|default_mbufs
suffix:semicolon
id|i
op_increment
)paren
id|pdev-&gt;image_used
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|pdev-&gt;vframe_count
op_assign
l_int|0
suffix:semicolon
id|pdev-&gt;vframes_dumped
op_assign
l_int|0
suffix:semicolon
id|pdev-&gt;vframes_error
op_assign
l_int|0
suffix:semicolon
id|pdev-&gt;vpalette
op_assign
id|default_palette
suffix:semicolon
macro_line|#if PWC_DEBUG&t;
id|pdev-&gt;sequence
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set some defaults */
id|pdev-&gt;vsnapshot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;type
op_eq
l_int|730
op_logical_or
id|pdev-&gt;type
op_eq
l_int|740
op_logical_or
id|pdev-&gt;type
op_eq
l_int|750
)paren
id|pdev-&gt;vsize
op_assign
id|PSZ_QSIF
suffix:semicolon
r_else
id|pdev-&gt;vsize
op_assign
id|PSZ_QCIF
suffix:semicolon
id|pdev-&gt;vframes
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* Start iso pipe for video; first try user-supplied size/fps, if&n;&t;   that fails try QCIF/10 or QSIF/10 (a reasonable default), &n;&t;   then give up &n;&t; */
id|i
op_assign
id|pwc_set_video_mode
c_func
(paren
id|pdev
comma
id|pwc_image_sizes
(braket
id|default_size
)braket
dot
id|x
comma
id|pwc_image_sizes
(braket
id|default_size
)braket
dot
id|y
comma
id|default_fps
comma
id|pdev-&gt;vcompression
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;First attempt at set_video_mode failed.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;type
op_eq
l_int|730
op_logical_or
id|pdev-&gt;type
op_eq
l_int|740
op_logical_or
id|pdev-&gt;type
op_eq
l_int|750
)paren
id|i
op_assign
id|pwc_set_video_mode
c_func
(paren
id|pdev
comma
id|pwc_image_sizes
(braket
id|PSZ_QSIF
)braket
dot
id|x
comma
id|pwc_image_sizes
(braket
id|PSZ_QSIF
)braket
dot
id|y
comma
l_int|10
comma
id|pdev-&gt;vcompression
comma
l_int|0
)paren
suffix:semicolon
r_else
id|i
op_assign
id|pwc_set_video_mode
c_func
(paren
id|pdev
comma
id|pwc_image_sizes
(braket
id|PSZ_QCIF
)braket
dot
id|x
comma
id|pwc_image_sizes
(braket
id|PSZ_QCIF
)braket
dot
id|y
comma
l_int|10
comma
id|pdev-&gt;vcompression
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;Second attempt at set_video_mode failed.&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|pdev-&gt;modlock
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
id|i
op_assign
id|usb_set_interface
c_func
(paren
id|pdev-&gt;udev
comma
l_int|0
comma
id|pdev-&gt;valternate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;Failed to set alternate interface = %d.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|pdev-&gt;modlock
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|i
op_assign
id|pwc_isoc_init
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;Failed to init ISOC stuff = %d.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|up
c_func
(paren
op_amp
id|pdev-&gt;modlock
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
id|pdev-&gt;vopen
op_increment
suffix:semicolon
id|file-&gt;private_data
op_assign
id|vdev
suffix:semicolon
multiline_comment|/* lock decompressor; this has a small race condition, since we &n;&t;   could in theory unload pwcx.o between pwc_find_decompressor()&n;&t;   above and this call. I doubt it&squot;s ever going to be a problem.&n;&t; */
r_if
c_cond
(paren
id|pdev-&gt;decompressor
op_ne
l_int|NULL
)paren
id|pdev-&gt;decompressor
op_member_access_from_pointer
id|lock
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|pdev-&gt;modlock
)paren
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;video_open() returning 0.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Note that all cleanup is done in the reverse order as in _open */
DECL|function|pwc_video_close
r_static
r_int
id|pwc_video_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|video_device
op_star
id|vdev
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|pwc_device
op_star
id|pdev
suffix:semicolon
r_int
id|i
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;video_close called(0x%p).&bslash;n&quot;
comma
id|vdev
)paren
suffix:semicolon
id|pdev
op_assign
(paren
r_struct
id|pwc_device
op_star
)paren
id|vdev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;vopen
op_eq
l_int|0
)paren
id|Info
c_func
(paren
l_string|&quot;video_close() called on closed device?&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Free isoc URBs */
id|pwc_isoc_cleanup
c_func
(paren
id|pdev
)paren
suffix:semicolon
multiline_comment|/* Dump statistics, but only if a reasonable amount of frames were&n;&t;   processed (to prevent endless log-entries in case of snap-shot&n;&t;   programs) &n;&t; */
r_if
c_cond
(paren
id|pdev-&gt;vframe_count
OG
l_int|20
)paren
id|Info
c_func
(paren
l_string|&quot;Closing video device: %d frames received, dumped %d frames, %d frames with errors.&bslash;n&quot;
comma
id|pdev-&gt;vframe_count
comma
id|pdev-&gt;vframes_dumped
comma
id|pdev-&gt;vframes_error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pdev-&gt;unplugged
)paren
(brace
multiline_comment|/* Normal close: stop isochronuous and interrupt endpoint */
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;Normal close(): setting interface to 0.&bslash;n&quot;
)paren
suffix:semicolon
id|usb_set_interface
c_func
(paren
id|pdev-&gt;udev
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Turn LEDs off */
r_if
c_cond
(paren
id|pwc_set_leds
c_func
(paren
id|pdev
comma
l_int|0
comma
l_int|0
)paren
OL
l_int|0
)paren
id|Info
c_func
(paren
l_string|&quot;Failed to set LED on/off time..&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Power down camere to save energy */
r_if
c_cond
(paren
id|power_save
)paren
(brace
id|i
op_assign
id|pwc_camera_power
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
id|Err
c_func
(paren
l_string|&quot;Failed to power down camera (%d)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
id|pdev-&gt;vopen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;decompressor
op_ne
l_int|NULL
)paren
(brace
id|pdev-&gt;decompressor
op_member_access_from_pointer
m_exit
(paren
)paren
suffix:semicolon
id|pdev-&gt;decompressor
op_member_access_from_pointer
id|unlock
c_func
(paren
)paren
suffix:semicolon
)brace
id|pwc_free_buffers
c_func
(paren
id|pdev
)paren
suffix:semicolon
multiline_comment|/* wake up _disconnect() routine */
r_if
c_cond
(paren
id|pdev-&gt;unplugged
)paren
id|wake_up
c_func
(paren
op_amp
id|pdev-&gt;remove_ok
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;FIXME: what about two parallel reads ????&n; *      ANSWER: Not supported. You can&squot;t open the device more than once,&n;                despite what the V4L1 interface says. First, I don&squot;t see &n;                the need, second there&squot;s no mechanism of alerting the &n;                2nd/3rd/... process of events like changing image size.&n;                And I don&squot;t see the point of blocking that for the &n;                2nd/3rd/... process.&n;                In multi-threaded environments reading parallel from any&n;                device is tricky anyhow.&n; */
DECL|function|pwc_video_read
r_static
r_int
id|pwc_video_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|video_device
op_star
id|vdev
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|pwc_device
op_star
id|pdev
suffix:semicolon
r_int
id|noblock
op_assign
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_READ
comma
l_string|&quot;video_read(0x%p, %p, %d) called.&bslash;n&quot;
comma
id|vdev
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|pdev
op_assign
id|vdev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;unplugged
)paren
(brace
id|Info
c_func
(paren
l_string|&quot;pwc_video_read: Device got unplugged (1).&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
multiline_comment|/* unplugged device! */
)brace
multiline_comment|/* In case we&squot;re doing partial reads, we don&squot;t have to wait for a frame */
r_if
c_cond
(paren
id|pdev-&gt;image_read_pos
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Do wait queueing according to the (doc)book */
id|add_wait_queue
c_func
(paren
op_amp
id|pdev-&gt;frameq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pdev-&gt;full_frames
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|noblock
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|pdev-&gt;frameq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|pdev-&gt;frameq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|pdev-&gt;frameq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
multiline_comment|/* Decompress [, convert] and release frame */
r_if
c_cond
(paren
id|pwc_handle_frame
c_func
(paren
id|pdev
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|Trace
c_func
(paren
id|TRACE_READ
comma
l_string|&quot;Copying data to user space.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* copy bytes to user space; we allow for partial reads */
r_if
c_cond
(paren
id|count
op_plus
id|pdev-&gt;image_read_pos
OG
id|pdev-&gt;view.size
)paren
id|count
op_assign
id|pdev-&gt;view.size
op_minus
id|pdev-&gt;image_read_pos
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|pdev-&gt;image_ptr
(braket
id|pdev-&gt;fill_image
)braket
op_plus
id|pdev-&gt;image_read_pos
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|pdev-&gt;image_read_pos
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;image_read_pos
op_ge
id|pdev-&gt;view.size
)paren
(brace
multiline_comment|/* All data has been read */
id|pdev-&gt;image_read_pos
op_assign
l_int|0
suffix:semicolon
id|pwc_next_image
c_func
(paren
id|pdev
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|pwc_video_poll
r_static
r_int
r_int
id|pwc_video_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|video_device
op_star
id|vdev
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|pwc_device
op_star
id|pdev
suffix:semicolon
r_if
c_cond
(paren
id|vdev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|pdev
op_assign
id|vdev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|pdev-&gt;frameq
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;unplugged
)paren
(brace
id|Info
c_func
(paren
l_string|&quot;pwc_video_poll: Device got unplugged.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|POLLERR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pdev-&gt;full_frames
op_ne
l_int|NULL
)paren
multiline_comment|/* we have frames waiting */
r_return
(paren
id|POLLIN
op_or
id|POLLRDNORM
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pwc_video_do_ioctl
r_static
r_int
id|pwc_video_do_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|video_device
op_star
id|vdev
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|pwc_device
op_star
id|pdev
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|pdev
op_assign
id|vdev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* Query cabapilities */
r_case
id|VIDIOCGCAP
suffix:colon
(brace
r_struct
id|video_capability
op_star
id|caps
op_assign
id|arg
suffix:semicolon
id|strcpy
c_func
(paren
id|caps-&gt;name
comma
id|vdev-&gt;name
)paren
suffix:semicolon
id|caps-&gt;type
op_assign
id|VID_TYPE_CAPTURE
suffix:semicolon
id|caps-&gt;channels
op_assign
l_int|1
suffix:semicolon
id|caps-&gt;audios
op_assign
l_int|1
suffix:semicolon
id|caps-&gt;minwidth
op_assign
id|pdev-&gt;view_min.x
suffix:semicolon
id|caps-&gt;minheight
op_assign
id|pdev-&gt;view_min.y
suffix:semicolon
id|caps-&gt;maxwidth
op_assign
id|pdev-&gt;view_max.x
suffix:semicolon
id|caps-&gt;maxheight
op_assign
id|pdev-&gt;view_max.y
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Channel functions (simulate 1 channel) */
r_case
id|VIDIOCGCHAN
suffix:colon
(brace
r_struct
id|video_channel
op_star
id|v
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|v-&gt;channel
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|v-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|v-&gt;tuners
op_assign
l_int|0
suffix:semicolon
id|v-&gt;type
op_assign
id|VIDEO_TYPE_CAMERA
suffix:semicolon
id|strcpy
c_func
(paren
id|v-&gt;name
comma
l_string|&quot;Webcam&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSCHAN
suffix:colon
(brace
multiline_comment|/* The spec says the argument is an integer, but&n;&t;&t;&t;   the bttv driver uses a video_channel arg, which&n;&t;&t;&t;   makes sense becasue it also has the norm flag.&n;&t;&t;&t; */
r_struct
id|video_channel
op_star
id|v
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|v-&gt;channel
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Picture functions; contrast etc. */
r_case
id|VIDIOCGPICT
suffix:colon
(brace
r_struct
id|video_picture
op_star
id|p
op_assign
id|arg
suffix:semicolon
r_int
id|val
suffix:semicolon
id|p-&gt;colour
op_assign
l_int|0x8000
suffix:semicolon
id|p-&gt;hue
op_assign
l_int|0x8000
suffix:semicolon
id|val
op_assign
id|pwc_get_brightness
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
id|p-&gt;brightness
op_assign
id|val
suffix:semicolon
r_else
id|p-&gt;brightness
op_assign
l_int|0xffff
suffix:semicolon
id|val
op_assign
id|pwc_get_contrast
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
id|p-&gt;contrast
op_assign
id|val
suffix:semicolon
r_else
id|p-&gt;contrast
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Gamma, Whiteness, what&squot;s the difference? :) */
id|val
op_assign
id|pwc_get_gamma
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
id|p-&gt;whiteness
op_assign
id|val
suffix:semicolon
r_else
id|p-&gt;whiteness
op_assign
l_int|0xffff
suffix:semicolon
id|val
op_assign
id|pwc_get_saturation
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
id|p-&gt;colour
op_assign
id|val
suffix:semicolon
r_else
id|p-&gt;colour
op_assign
l_int|0xffff
suffix:semicolon
id|p-&gt;depth
op_assign
l_int|24
suffix:semicolon
id|p-&gt;palette
op_assign
id|pdev-&gt;vpalette
suffix:semicolon
id|p-&gt;hue
op_assign
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* N/A */
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCSPICT
suffix:colon
(brace
r_struct
id|video_picture
op_star
id|p
op_assign
id|arg
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;FIXME:&t;Suppose we are mid read&n;&t;&t;&t;        ANSWER: No problem: the firmware of the camera&n;&t;&t;&t;                can handle brightness/contrast/etc&n;&t;&t;&t;                changes at _any_ time, and the palette&n;&t;&t;&t;                is used exactly once in the uncompress&n;&t;&t;&t;                routine.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;palette
op_logical_and
id|p-&gt;palette
op_ne
id|pdev-&gt;vpalette
)paren
(brace
r_if
c_cond
(paren
id|pwc_set_palette
c_func
(paren
id|pdev
comma
id|p-&gt;palette
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|pwc_set_brightness
c_func
(paren
id|pdev
comma
id|p-&gt;brightness
)paren
suffix:semicolon
id|pwc_set_contrast
c_func
(paren
id|pdev
comma
id|p-&gt;contrast
)paren
suffix:semicolon
id|pwc_set_gamma
c_func
(paren
id|pdev
comma
id|p-&gt;whiteness
)paren
suffix:semicolon
id|pwc_set_saturation
c_func
(paren
id|pdev
comma
id|p-&gt;colour
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Window/size parameters */
r_case
id|VIDIOCGWIN
suffix:colon
(brace
r_struct
id|video_window
op_star
id|vw
op_assign
id|arg
suffix:semicolon
id|vw-&gt;x
op_assign
l_int|0
suffix:semicolon
id|vw-&gt;y
op_assign
l_int|0
suffix:semicolon
id|vw-&gt;width
op_assign
id|pdev-&gt;view.x
suffix:semicolon
id|vw-&gt;height
op_assign
id|pdev-&gt;view.y
suffix:semicolon
id|vw-&gt;chromakey
op_assign
l_int|0
suffix:semicolon
id|vw-&gt;flags
op_assign
(paren
id|pdev-&gt;vframes
op_lshift
id|PWC_FPS_SHIFT
)paren
op_or
(paren
id|pdev-&gt;vsnapshot
ques
c_cond
id|PWC_FPS_SNAPSHOT
suffix:colon
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCSWIN
suffix:colon
(brace
r_struct
id|video_window
op_star
id|vw
op_assign
id|arg
suffix:semicolon
r_int
id|fps
comma
id|snapshot
comma
id|ret
suffix:semicolon
id|fps
op_assign
(paren
id|vw-&gt;flags
op_amp
id|PWC_FPS_FRMASK
)paren
op_rshift
id|PWC_FPS_SHIFT
suffix:semicolon
id|snapshot
op_assign
id|vw-&gt;flags
op_amp
id|PWC_FPS_SNAPSHOT
suffix:semicolon
r_if
c_cond
(paren
id|fps
op_eq
l_int|0
)paren
id|fps
op_assign
id|pdev-&gt;vframes
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;view.x
op_eq
id|vw-&gt;width
op_logical_and
id|pdev-&gt;view.y
op_logical_and
id|fps
op_eq
id|pdev-&gt;vframes
op_logical_and
id|snapshot
op_eq
id|pdev-&gt;vsnapshot
)paren
r_return
l_int|0
suffix:semicolon
id|ret
op_assign
id|pwc_try_video_mode
c_func
(paren
id|pdev
comma
id|vw-&gt;width
comma
id|vw-&gt;height
comma
id|fps
comma
id|pdev-&gt;vcompression
comma
id|snapshot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* We don&squot;t have overlay support (yet) */
r_case
id|VIDIOCGFBUF
suffix:colon
(brace
r_struct
id|video_buffer
op_star
id|vb
op_assign
id|arg
suffix:semicolon
id|memset
c_func
(paren
id|vb
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|vb
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* mmap() functions */
r_case
id|VIDIOCGMBUF
suffix:colon
(brace
multiline_comment|/* Tell the user program how much memory is needed for a mmap() */
r_struct
id|video_mbuf
op_star
id|vm
op_assign
id|arg
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
id|vm
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|vm
)paren
)paren
suffix:semicolon
id|vm-&gt;size
op_assign
id|default_mbufs
op_star
id|pdev-&gt;len_per_image
suffix:semicolon
id|vm-&gt;frames
op_assign
id|default_mbufs
suffix:semicolon
multiline_comment|/* double buffering should be enough for most applications */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|default_mbufs
suffix:semicolon
id|i
op_increment
)paren
id|vm-&gt;offsets
(braket
id|i
)braket
op_assign
id|i
op_star
id|pdev-&gt;len_per_image
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCMCAPTURE
suffix:colon
(brace
multiline_comment|/* Start capture into a given image buffer (called &squot;frame&squot; in video_mmap structure) */
r_struct
id|video_mmap
op_star
id|vm
op_assign
id|arg
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_READ
comma
l_string|&quot;VIDIOCMCAPTURE: %dx%d, frame %d, format %d&bslash;n&quot;
comma
id|vm-&gt;width
comma
id|vm-&gt;height
comma
id|vm-&gt;frame
comma
id|vm-&gt;format
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vm-&gt;frame
OL
l_int|0
op_logical_or
id|vm-&gt;frame
op_ge
id|default_mbufs
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* xawtv is nasty. It probes the available palettes&n;&t;&t;&t;   by setting a very small image size and trying&n;&t;&t;&t;   various palettes... The driver doesn&squot;t support&n;&t;&t;&t;   such small images, so I&squot;m working around it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vm-&gt;format
op_logical_and
id|vm-&gt;format
op_ne
id|pdev-&gt;vpalette
)paren
r_if
c_cond
(paren
id|pwc_set_palette
c_func
(paren
id|pdev
comma
id|vm-&gt;format
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vm-&gt;width
op_ne
id|pdev-&gt;view.x
op_logical_or
id|vm-&gt;height
op_ne
id|pdev-&gt;view.y
)paren
op_logical_and
(paren
id|vm-&gt;width
op_ge
id|pdev-&gt;view_min.x
op_logical_and
id|vm-&gt;height
op_ge
id|pdev-&gt;view_min.y
)paren
)paren
(brace
r_int
id|ret
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_OPEN
comma
l_string|&quot;VIDIOCMCAPTURE: changing size to please xawtv :-(.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|pwc_try_video_mode
c_func
(paren
id|pdev
comma
id|vm-&gt;width
comma
id|vm-&gt;height
comma
id|pdev-&gt;vframes
comma
id|pdev-&gt;vcompression
comma
id|pdev-&gt;vsnapshot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* ... size mismatch */
multiline_comment|/* FIXME: should we lock here? */
r_if
c_cond
(paren
id|pdev-&gt;image_used
(braket
id|vm-&gt;frame
)braket
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* buffer wasn&squot;t available. Bummer */
id|pdev-&gt;image_used
(braket
id|vm-&gt;frame
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Okay, we&squot;re done here. In the SYNC call we wait until a &n;&t;&t;&t;   frame comes available, then expand image into the given &n;&t;&t;&t;   buffer.&n;&t;&t;&t;   In contrast to the CPiA cam the Philips cams deliver a &n;&t;&t;&t;   constant stream, almost like a grabber card. Also,&n;&t;&t;&t;   we have separate buffers for the rawdata and the image,&n;&t;&t;&t;   meaning we can nearly always expand into the requested buffer.&n;&t;&t;&t; */
id|Trace
c_func
(paren
id|TRACE_READ
comma
l_string|&quot;VIDIOCMCAPTURE done.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCSYNC
suffix:colon
(brace
multiline_comment|/* The doc says: &quot;Whenever a buffer is used it should&n;&t;&t;&t;   call VIDIOCSYNC to free this frame up and continue.&quot;&n;&t;&t;&t;   &n;&t;&t;&t;   The only odd thing about this whole procedure is &n;&t;&t;&t;   that MCAPTURE flags the buffer as &quot;in use&quot;, and&n;&t;&t;&t;   SYNC immediately unmarks it, while it isn&squot;t &n;&t;&t;&t;   after SYNC that you know that the buffer actually&n;&t;&t;&t;   got filled! So you better not start a CAPTURE in&n;&t;&t;&t;   the same frame immediately (use double buffering). &n;&t;&t;&t;   This is not a problem for this cam, since it has &n;&t;&t;&t;   extra intermediate buffers, but a hardware &n;&t;&t;&t;   grabber card will then overwrite the buffer &n;&t;&t;&t;   you&squot;re working on.&n;&t;&t;&t; */
r_int
op_star
id|mbuf
op_assign
id|arg
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_READ
comma
l_string|&quot;VIDIOCSYNC called (%d).&bslash;n&quot;
comma
op_star
id|mbuf
)paren
suffix:semicolon
multiline_comment|/* bounds check */
r_if
c_cond
(paren
op_star
id|mbuf
OL
l_int|0
op_logical_or
op_star
id|mbuf
op_ge
id|default_mbufs
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* check if this buffer was requested anyway */
r_if
c_cond
(paren
id|pdev-&gt;image_used
(braket
op_star
id|mbuf
)braket
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Add ourselves to the frame wait-queue.&n;&t;&t;&t;   &n;&t;&t;&t;   FIXME: needs auditing for safety.&n;&t;&t;&t;   QUSTION: In what respect? I think that using the&n;&t;&t;&t;            frameq is safe now.&n;&t;&t;&t; */
id|add_wait_queue
c_func
(paren
op_amp
id|pdev-&gt;frameq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pdev-&gt;full_frames
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pdev-&gt;unplugged
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|pdev-&gt;frameq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|pdev-&gt;frameq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|pdev-&gt;frameq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
multiline_comment|/* The frame is ready. Expand in the image buffer &n;&t;&t;&t;   requested by the user. I don&squot;t care if you &n;&t;&t;&t;   mmap() 5 buffers and request data in this order: &n;&t;&t;&t;   buffer 4 2 3 0 1 2 3 0 4 3 1 . . .&n;&t;&t;&t;   Grabber hardware may not be so forgiving.&n;&t;&t;&t; */
id|Trace
c_func
(paren
id|TRACE_READ
comma
l_string|&quot;VIDIOCSYNC: frame ready.&bslash;n&quot;
)paren
suffix:semicolon
id|pdev-&gt;fill_image
op_assign
op_star
id|mbuf
suffix:semicolon
multiline_comment|/* tell in which buffer we want the image to be expanded */
multiline_comment|/* Decompress, etc */
id|ret
op_assign
id|pwc_handle_frame
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|pdev-&gt;image_used
(braket
op_star
id|mbuf
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCGAUDIO
suffix:colon
(brace
r_struct
id|video_audio
op_star
id|v
op_assign
id|arg
suffix:semicolon
id|strcpy
c_func
(paren
id|v-&gt;name
comma
l_string|&quot;Microphone&quot;
)paren
suffix:semicolon
id|v-&gt;audio
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* unknown audio minor */
id|v-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|v-&gt;mode
op_assign
id|VIDEO_SOUND_MONO
suffix:semicolon
id|v-&gt;volume
op_assign
l_int|0
suffix:semicolon
id|v-&gt;bass
op_assign
l_int|0
suffix:semicolon
id|v-&gt;treble
op_assign
l_int|0
suffix:semicolon
id|v-&gt;balance
op_assign
l_int|0x8000
suffix:semicolon
id|v-&gt;step
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCSAUDIO
suffix:colon
(brace
multiline_comment|/* Dummy: nothing can be set */
r_break
suffix:semicolon
)brace
r_case
id|VIDIOCGUNIT
suffix:colon
(brace
r_struct
id|video_unit
op_star
id|vu
op_assign
id|arg
suffix:semicolon
id|vu-&gt;video
op_assign
id|pdev-&gt;vdev-&gt;minor
op_amp
l_int|0x3F
suffix:semicolon
id|vu-&gt;audio
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* not known yet */
id|vu-&gt;vbi
op_assign
op_minus
l_int|1
suffix:semicolon
id|vu-&gt;radio
op_assign
op_minus
l_int|1
suffix:semicolon
id|vu-&gt;teletext
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
r_return
id|pwc_ioctl
c_func
(paren
id|pdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/* ..switch */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pwc_video_ioctl
r_static
r_int
id|pwc_video_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_return
id|video_usercopy
c_func
(paren
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
comma
id|pwc_video_do_ioctl
)paren
suffix:semicolon
)brace
DECL|function|pwc_video_mmap
r_static
r_int
id|pwc_video_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|video_device
op_star
id|vdev
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|pwc_device
op_star
id|pdev
suffix:semicolon
r_int
r_int
id|start
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_int
r_int
id|size
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
r_int
r_int
id|page
comma
id|pos
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_MEMORY
comma
l_string|&quot;mmap(0x%p, 0x%lx, %lu) called.&bslash;n&quot;
comma
id|vdev
comma
id|start
comma
id|size
)paren
suffix:semicolon
id|pdev
op_assign
id|vdev-&gt;priv
suffix:semicolon
multiline_comment|/* FIXME - audit mmap during a read */
id|pos
op_assign
(paren
r_int
r_int
)paren
id|pdev-&gt;image_data
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|kvirt_to_pa
c_func
(paren
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|vma
comma
id|start
comma
id|page
comma
id|PAGE_SIZE
comma
id|PAGE_SHARED
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pos
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_else
id|size
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***************************************************************************/
multiline_comment|/* USB functions */
multiline_comment|/* This function gets called when a new device is plugged in or the usb core&n; * is loaded.&n; */
DECL|function|usb_pwc_probe
r_static
r_void
op_star
id|usb_pwc_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|pwc_device
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|video_device
op_star
id|vdev
suffix:semicolon
r_int
id|vendor_id
comma
id|product_id
comma
id|type_id
suffix:semicolon
r_int
id|i
comma
id|hint
suffix:semicolon
r_int
id|video_nr
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* default: use next available device */
r_char
id|serial_number
(braket
l_int|30
)braket
suffix:semicolon
id|free_mem_leak
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Check if we can handle this device */
id|Trace
c_func
(paren
id|TRACE_PROBE
comma
l_string|&quot;probe() called [%04X %04X], if %d&bslash;n&quot;
comma
id|udev-&gt;descriptor.idVendor
comma
id|udev-&gt;descriptor.idProduct
comma
id|ifnum
)paren
suffix:semicolon
multiline_comment|/* the interfaces are probed one by one. We are only interested in the&n;&t;   video interface (0) now.&n;&t;   Interface 1 is the Audio Control, and interface 2 Audio itself.&n;&t; */
r_if
c_cond
(paren
id|ifnum
OG
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|vendor_id
op_assign
id|udev-&gt;descriptor.idVendor
suffix:semicolon
id|product_id
op_assign
id|udev-&gt;descriptor.idProduct
suffix:semicolon
r_if
c_cond
(paren
id|vendor_id
op_eq
l_int|0x0471
)paren
(brace
r_switch
c_cond
(paren
id|product_id
)paren
(brace
r_case
l_int|0x0302
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Philips PCA645VC USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|645
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0303
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Philips PCA646VC USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|646
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0304
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Askey VC010 type 2 USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|646
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0307
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Philips PCVC675K (Vesta) USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|675
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0308
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Philips PCVC680K (Vesta Pro) USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|680
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x030C
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Philips PCVC690K (Vesta Pro Scan) USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|690
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0310
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Philips PCVC730K (ToUCam Fun) USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|730
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0311
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Philips PCVC740K (ToUCam Pro) USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|740
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0312
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Philips PCVC750K (ToUCam Pro Scan) USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|750
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|vendor_id
op_eq
l_int|0x069A
)paren
(brace
r_switch
c_cond
(paren
id|product_id
)paren
(brace
r_case
l_int|0x0001
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Askey VC010 type 1 USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|645
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|vendor_id
op_eq
l_int|0x046d
)paren
(brace
r_switch
c_cond
(paren
id|product_id
)paren
(brace
r_case
l_int|0x08b0
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Logitech QuickCam 3000 Pro detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|730
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|vendor_id
op_eq
l_int|0x055d
)paren
(brace
multiline_comment|/* I don&squot;t know the difference between the C10 and the C30;&n;&t;&t;   I suppose the difference is the sensor, but both cameras&n;&t;&t;   work equally well with a type_id of 675&n;&t;&t; */
r_switch
c_cond
(paren
id|product_id
)paren
(brace
r_case
l_int|0x9000
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Samsung MPC-C10 USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|675
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x9001
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Samsung MPC-C30 USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|675
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|vendor_id
op_eq
l_int|0x041e
)paren
(brace
r_switch
c_cond
(paren
id|product_id
)paren
(brace
r_case
l_int|0x400c
suffix:colon
id|Info
c_func
(paren
l_string|&quot;Creative Labs Webcam 5 detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|730
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|vendor_id
op_eq
l_int|0x04cc
)paren
(brace
r_switch
c_cond
(paren
id|product_id
)paren
(brace
r_case
l_int|0x8116
suffix:colon
id|Info
c_func
(paren
l_string|&quot;SOTEC CMS-001 USB webcam detected.&bslash;n&quot;
)paren
suffix:semicolon
id|type_id
op_assign
l_int|730
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Not Philips, Askey, Logitech, Samsung, Creative or SOTEC, for sure. */
id|memset
c_func
(paren
id|serial_number
comma
l_int|0
comma
l_int|30
)paren
suffix:semicolon
id|usb_string
c_func
(paren
id|udev
comma
id|udev-&gt;descriptor.iSerialNumber
comma
id|serial_number
comma
l_int|29
)paren
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_PROBE
comma
l_string|&quot;Device serial number is %s&bslash;n&quot;
comma
id|serial_number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;descriptor.bNumConfigurations
OG
l_int|1
)paren
id|Info
c_func
(paren
l_string|&quot;Warning: more than 1 configuration available.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Allocate structure, initialize pointers, mutexes, etc. and link it to the usb_device */
id|pdev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pwc_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Oops, could not allocate memory for pwc_device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pdev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pwc_device
)paren
)paren
suffix:semicolon
id|pdev-&gt;type
op_assign
id|type_id
suffix:semicolon
id|pwc_construct
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|pdev-&gt;modlock
)paren
suffix:semicolon
id|pdev-&gt;ptrlock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|pdev-&gt;udev
op_assign
id|udev
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pdev-&gt;frameq
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pdev-&gt;remove_ok
)paren
suffix:semicolon
id|pdev-&gt;vcompression
op_assign
id|pwc_preferred_compression
suffix:semicolon
multiline_comment|/* Now hook it up to the video subsystem */
id|vdev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|video_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vdev
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Oops, could not allocate memory for video_device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|vdev
comma
op_amp
id|pwc_template
comma
r_sizeof
(paren
id|pwc_template
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|vdev-&gt;name
comma
l_string|&quot;Philips %d webcam&quot;
comma
id|pdev-&gt;type
)paren
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|vdev
)paren
suffix:semicolon
id|pdev-&gt;vdev
op_assign
id|vdev
suffix:semicolon
id|vdev-&gt;priv
op_assign
id|pdev
suffix:semicolon
id|pdev-&gt;release
op_assign
id|udev-&gt;descriptor.bcdDevice
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_PROBE
comma
l_string|&quot;Release: %04x&bslash;n&quot;
comma
id|pdev-&gt;release
)paren
suffix:semicolon
multiline_comment|/* Now search device_hint[] table for a match, so we can hint a node number. */
r_for
c_loop
(paren
id|hint
op_assign
l_int|0
suffix:semicolon
id|hint
OL
id|MAX_DEV_HINTS
suffix:semicolon
id|hint
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|device_hint
(braket
id|hint
)braket
dot
id|type
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|device_hint
(braket
id|hint
)braket
dot
id|type
op_eq
id|pdev-&gt;type
)paren
)paren
op_logical_and
(paren
id|device_hint
(braket
id|hint
)braket
dot
id|pdev
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* so far, so good... try serial number */
r_if
c_cond
(paren
(paren
id|device_hint
(braket
id|hint
)braket
dot
id|serial_number
(braket
l_int|0
)braket
op_eq
l_char|&squot;*&squot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|device_hint
(braket
id|hint
)braket
dot
id|serial_number
comma
id|serial_number
)paren
)paren
(brace
multiline_comment|/* match! */
id|video_nr
op_assign
id|device_hint
(braket
id|hint
)braket
dot
id|device_node
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_PROBE
comma
l_string|&quot;Found hint, will try to register as /dev/video%d&bslash;n&quot;
comma
id|video_nr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|i
op_assign
id|video_register_device
c_func
(paren
id|vdev
comma
id|VFL_TYPE_GRABBER
comma
id|video_nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Failed to register as video device (%d).&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|Trace
c_func
(paren
id|TRACE_PROBE
comma
l_string|&quot;Registered video struct at 0x%p.&bslash;n&quot;
comma
id|vdev
)paren
suffix:semicolon
id|Info
c_func
(paren
l_string|&quot;Registered as /dev/video%d.&bslash;n&quot;
comma
id|vdev-&gt;minor
op_amp
l_int|0x3F
)paren
suffix:semicolon
)brace
multiline_comment|/* occupy slot */
r_if
c_cond
(paren
id|hint
OL
id|MAX_DEV_HINTS
)paren
id|device_hint
(braket
id|hint
)braket
dot
id|pdev
op_assign
id|pdev
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_PROBE
comma
l_string|&quot;probe() function returning struct at 0x%p.&bslash;n&quot;
comma
id|pdev
)paren
suffix:semicolon
r_return
id|pdev
suffix:semicolon
)brace
multiline_comment|/* The user janked out the cable... */
DECL|function|usb_pwc_disconnect
r_static
r_void
id|usb_pwc_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|pwc_device
op_star
id|pdev
suffix:semicolon
r_int
id|hint
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|free_mem_leak
c_func
(paren
)paren
suffix:semicolon
id|pdev
op_assign
(paren
r_struct
id|pwc_device
op_star
)paren
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|pdev
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;pwc_disconnect() Called without private pointer.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pdev-&gt;udev
op_eq
l_int|NULL
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;pwc_disconnect() already called for %p&bslash;n&quot;
comma
id|pdev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pdev-&gt;udev
op_ne
id|udev
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;pwc_disconnect() Woops: pointer mismatch udev/pdev.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PWC_MAGIC&t;
r_if
c_cond
(paren
id|pdev-&gt;magic
op_ne
id|PWC_MAGIC
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;pwc_disconnect() Magic number failed. Consult your scrolls and try again.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif&t;
id|pdev-&gt;unplugged
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;vdev
op_ne
l_int|NULL
)paren
(brace
id|video_unregister_device
c_func
(paren
id|pdev-&gt;vdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;vopen
)paren
(brace
id|Info
c_func
(paren
l_string|&quot;Disconnected while device/video is open!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Wake up any processes that might be waiting for&n;&t;&t;&t;   a frame, let them return an error condition&n;&t;&t;&t; */
id|wake_up
c_func
(paren
op_amp
id|pdev-&gt;frameq
)paren
suffix:semicolon
multiline_comment|/* Wait until we get a &squot;go&squot; from _close(). This used&n;&t;&t;&t;   to have a gigantic race condition, since we kfree()&n;&t;&t;&t;   stuff here, but we have to wait until close() &n;&t;&t;&t;   is finished. &n;&t;&t;&t; */
id|Trace
c_func
(paren
id|TRACE_PROBE
comma
l_string|&quot;Sleeping on remove_ok.&bslash;n&quot;
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|pdev-&gt;remove_ok
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/* ... wait ... */
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|pdev-&gt;remove_ok
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_PROBE
comma
l_string|&quot;Done sleeping.&bslash;n&quot;
)paren
suffix:semicolon
id|set_mem_leak
c_func
(paren
id|pdev-&gt;vdev
)paren
suffix:semicolon
id|pdev-&gt;vdev
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Normal disconnect; remove from available devices */
id|Trace
c_func
(paren
id|TRACE_PROBE
comma
l_string|&quot;Unregistering video device normally.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pdev-&gt;vdev
)paren
suffix:semicolon
id|pdev-&gt;vdev
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* search device_hint[] table if we occupy a slot, by any chance */
r_for
c_loop
(paren
id|hint
op_assign
l_int|0
suffix:semicolon
id|hint
OL
id|MAX_DEV_HINTS
suffix:semicolon
id|hint
op_increment
)paren
r_if
c_cond
(paren
id|device_hint
(braket
id|hint
)braket
dot
id|pdev
op_eq
id|pdev
)paren
id|device_hint
(braket
id|hint
)braket
dot
id|pdev
op_assign
l_int|NULL
suffix:semicolon
id|pdev-&gt;udev
op_assign
l_int|NULL
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pdev
)paren
suffix:semicolon
)brace
multiline_comment|/* *grunt* We have to do atoi ourselves :-( */
DECL|function|pwc_atoi
r_static
r_int
id|pwc_atoi
c_func
(paren
r_char
op_star
id|s
)paren
(brace
r_int
id|k
op_assign
l_int|0
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|s
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_star
id|s
op_ge
l_char|&squot;0&squot;
op_logical_and
op_star
id|s
op_le
l_char|&squot;9&squot;
)paren
(brace
id|k
op_assign
l_int|10
op_star
id|k
op_plus
(paren
op_star
id|s
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
id|s
op_increment
suffix:semicolon
)brace
r_return
id|k
suffix:semicolon
)brace
multiline_comment|/* &n; * Initialization code &amp; module stuff &n; */
DECL|variable|size
r_static
r_char
op_star
id|size
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|fps
r_static
r_int
id|fps
op_assign
l_int|0
suffix:semicolon
DECL|variable|fbufs
r_static
r_int
id|fbufs
op_assign
l_int|0
suffix:semicolon
DECL|variable|mbufs
r_static
r_int
id|mbufs
op_assign
l_int|0
suffix:semicolon
DECL|variable|trace
r_static
r_int
id|trace
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|compression
r_static
r_int
id|compression
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|leds
r_static
r_int
id|leds
(braket
l_int|2
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|dev_hint
r_static
r_char
op_star
id|dev_hint
(braket
l_int|10
)braket
op_assign
(brace
)brace
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|size
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|size
comma
l_string|&quot;Initial image size. One of sqcif, qsif, qcif, sif, cif, vga&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|fps
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|fps
comma
l_string|&quot;Initial frames per second. Varies with model, useful range 5-30&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|fbufs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|fbufs
comma
l_string|&quot;Number of internal frame buffers to reserve&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|mbufs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|mbufs
comma
l_string|&quot;Number of external (mmap()ed) image buffers&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|trace
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|trace
comma
l_string|&quot;For debugging purposes&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|power_save
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|power_save
comma
l_string|&quot;Turn power save feature in camera on or off&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|compression
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|compression
comma
l_string|&quot;Preferred compression quality. Range 0 (uncompressed) to 3 (high compression)&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|leds
comma
l_string|&quot;2i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|leds
comma
l_string|&quot;LED on,off time in milliseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dev_hint
comma
l_string|&quot;0-10s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|dev_hint
comma
l_string|&quot;Device node hints&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Philips USB webcam driver&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Nemosoft Unv. &lt;nemosoft@smcc.demon.nl&gt;&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|function|usb_pwc_init
r_static
r_int
id|__init
id|usb_pwc_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|sz
suffix:semicolon
r_char
op_star
id|sizenames
(braket
id|PSZ_MAX
)braket
op_assign
(brace
l_string|&quot;sqcif&quot;
comma
l_string|&quot;qsif&quot;
comma
l_string|&quot;qcif&quot;
comma
l_string|&quot;sif&quot;
comma
l_string|&quot;cif&quot;
comma
l_string|&quot;vga&quot;
)brace
suffix:semicolon
id|Info
c_func
(paren
l_string|&quot;Philips PCA645/646 + PCVC675/680/690 + PCVC730/740/750 webcam module version &quot;
id|PWC_VERSION
l_string|&quot; loaded.&bslash;n&quot;
)paren
suffix:semicolon
id|Info
c_func
(paren
l_string|&quot;Also supports the Askey VC010, Logitech Quickcam 3000 Pro, Samsung MPC-C10 and MPC-C30, the Creative WebCam 5 and the SOTEC CMS-001.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fps
)paren
(brace
r_if
c_cond
(paren
id|fps
template_param
l_int|30
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Framerate out of bounds (5-30).&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|default_fps
op_assign
id|fps
suffix:semicolon
id|Info
c_func
(paren
l_string|&quot;Default framerate set to %d.&bslash;n&quot;
comma
id|default_fps
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
)paren
(brace
multiline_comment|/* string; try matching with array */
r_for
c_loop
(paren
id|sz
op_assign
l_int|0
suffix:semicolon
id|sz
OL
id|PSZ_MAX
suffix:semicolon
id|sz
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|sizenames
(braket
id|sz
)braket
comma
id|size
)paren
)paren
(brace
multiline_comment|/* Found! */
id|default_size
op_assign
id|sz
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sz
op_eq
id|PSZ_MAX
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Size not recognized; try size=[sqcif | qsif | qcif | sif | cif | vga].&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|Info
c_func
(paren
l_string|&quot;Default image size set to %s [%dx%d].&bslash;n&quot;
comma
id|sizenames
(braket
id|default_size
)braket
comma
id|pwc_image_sizes
(braket
id|default_size
)braket
dot
id|x
comma
id|pwc_image_sizes
(braket
id|default_size
)braket
dot
id|y
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mbufs
)paren
(brace
r_if
c_cond
(paren
id|mbufs
template_param
id|MAX_IMAGES
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Illegal number of mmap() buffers; use a number between 1 and %d.&bslash;n&quot;
comma
id|MAX_IMAGES
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|default_mbufs
op_assign
id|mbufs
suffix:semicolon
id|Info
c_func
(paren
l_string|&quot;Number of image buffers set to %d.&bslash;n&quot;
comma
id|default_mbufs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fbufs
)paren
(brace
r_if
c_cond
(paren
id|fbufs
template_param
id|MAX_FRAMES
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Illegal number of frame buffers; use a number between 2 and %d.&bslash;n&quot;
comma
id|MAX_FRAMES
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|default_fbufs
op_assign
id|fbufs
suffix:semicolon
id|Info
c_func
(paren
l_string|&quot;Number of frame buffers set to %d.&bslash;n&quot;
comma
id|default_fbufs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|trace
op_ge
l_int|0
)paren
(brace
id|Info
c_func
(paren
l_string|&quot;Trace options: 0x%04x&bslash;n&quot;
comma
id|trace
)paren
suffix:semicolon
id|pwc_trace
op_assign
id|trace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|compression
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|compression
OG
l_int|3
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Invalid compression setting; use a number between 0 (uncompressed) and 3 (high).&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|pwc_preferred_compression
op_assign
id|compression
suffix:semicolon
id|Info
c_func
(paren
l_string|&quot;Preferred compression set to %d.&bslash;n&quot;
comma
id|pwc_preferred_compression
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|power_save
)paren
id|Info
c_func
(paren
l_string|&quot;Enabling power save on open/close.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|leds
(braket
l_int|0
)braket
op_ge
l_int|0
)paren
id|led_on
op_assign
id|leds
(braket
l_int|0
)braket
op_div
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|leds
(braket
l_int|1
)braket
op_ge
l_int|0
)paren
id|led_off
op_assign
id|leds
(braket
l_int|1
)braket
op_div
l_int|100
suffix:semicolon
multiline_comment|/* Big device node whoopla. Basicly, it allows you to assign a &n;&t;   device node (/dev/videoX) to a camera, based on its type &n;&t;   &amp; serial number. The format is [type[.serialnumber]:]node.&n;&n;           Any camera that isn&squot;t matched by these rules gets the next &n;           available free device node.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DEV_HINTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
op_star
id|s
comma
op_star
id|colon
comma
op_star
id|dot
suffix:semicolon
multiline_comment|/* This loop also initializes the array */
id|device_hint
(braket
id|i
)braket
dot
id|pdev
op_assign
l_int|NULL
suffix:semicolon
id|s
op_assign
id|dev_hint
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|s
op_ne
l_int|NULL
op_logical_and
op_star
id|s
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|device_hint
(braket
id|i
)braket
dot
id|type
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* wildcard */
id|strcpy
c_func
(paren
id|device_hint
(braket
id|i
)braket
dot
id|serial_number
comma
l_string|&quot;*&quot;
)paren
suffix:semicolon
multiline_comment|/* parse string: chop at &squot;:&squot; &amp; &squot;/&squot; */
id|colon
op_assign
id|dot
op_assign
id|s
suffix:semicolon
r_while
c_loop
(paren
op_star
id|colon
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_star
id|colon
op_ne
l_char|&squot;:&squot;
)paren
id|colon
op_increment
suffix:semicolon
r_while
c_loop
(paren
op_star
id|dot
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_star
id|dot
op_ne
l_char|&squot;.&squot;
)paren
id|dot
op_increment
suffix:semicolon
multiline_comment|/* Few sanity checks */
r_if
c_cond
(paren
op_star
id|dot
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
id|dot
OG
id|colon
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Malformed camera hint: the colon must be after the dot.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|colon
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
multiline_comment|/* No colon */
r_if
c_cond
(paren
op_star
id|dot
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|Err
c_func
(paren
l_string|&quot;Malformed camera hint: no colon + device node given.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No type or serial number specified, just a number. */
id|device_hint
(braket
id|i
)braket
dot
id|device_node
op_assign
id|pwc_atoi
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* There&squot;s a colon, so we have at least a type and a device node */
id|device_hint
(braket
id|i
)braket
dot
id|type
op_assign
id|pwc_atoi
c_func
(paren
id|s
)paren
suffix:semicolon
id|device_hint
(braket
id|i
)braket
dot
id|device_node
op_assign
id|pwc_atoi
c_func
(paren
id|colon
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dot
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
multiline_comment|/* There&squot;s a serial number as well */
r_int
id|k
suffix:semicolon
id|dot
op_increment
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|dot
op_ne
l_char|&squot;:&squot;
op_logical_and
id|k
OL
l_int|29
)paren
(brace
id|device_hint
(braket
id|i
)braket
dot
id|serial_number
(braket
id|k
op_increment
)braket
op_assign
op_star
id|dot
suffix:semicolon
id|dot
op_increment
suffix:semicolon
)brace
id|device_hint
(braket
id|i
)braket
dot
id|serial_number
(braket
id|k
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
macro_line|#ifdef PWC_DEBUG&t;&t;
id|Debug
c_func
(paren
l_string|&quot;device_hint[%d]:&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|Debug
c_func
(paren
l_string|&quot;  type    : %d&bslash;n&quot;
comma
id|device_hint
(braket
id|i
)braket
dot
id|type
)paren
suffix:semicolon
id|Debug
c_func
(paren
l_string|&quot;  serial# : %s&bslash;n&quot;
comma
id|device_hint
(braket
id|i
)braket
dot
id|serial_number
)paren
suffix:semicolon
id|Debug
c_func
(paren
l_string|&quot;  node    : %d&bslash;n&quot;
comma
id|device_hint
(braket
id|i
)braket
dot
id|device_node
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;
)brace
r_else
id|device_hint
(braket
id|i
)braket
dot
id|type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not filled */
)brace
multiline_comment|/* ..for MAX_DEV_HINTS */
id|init_MUTEX
c_func
(paren
op_amp
id|mem_lock
)paren
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_PROBE
comma
l_string|&quot;Registering driver at address 0x%p.&bslash;n&quot;
comma
op_amp
id|pwc_driver
)paren
suffix:semicolon
r_return
id|usb_register
c_func
(paren
op_amp
id|pwc_driver
)paren
suffix:semicolon
)brace
DECL|function|usb_pwc_exit
r_static
r_void
id|__exit
id|usb_pwc_exit
c_func
(paren
r_void
)paren
(brace
id|free_mem_leak
c_func
(paren
)paren
suffix:semicolon
id|Trace
c_func
(paren
id|TRACE_MODULE
comma
l_string|&quot;Deregistering driver.&bslash;n&quot;
)paren
suffix:semicolon
id|usb_deregister
c_func
(paren
op_amp
id|pwc_driver
)paren
suffix:semicolon
id|Info
c_func
(paren
l_string|&quot;Philips webcam module removed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|usb_pwc_init
id|module_init
c_func
(paren
id|usb_pwc_init
)paren
suffix:semicolon
DECL|variable|usb_pwc_exit
id|module_exit
c_func
(paren
id|usb_pwc_exit
)paren
suffix:semicolon
eof
