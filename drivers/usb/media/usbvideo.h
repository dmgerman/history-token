multiline_comment|/*&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#ifndef usbvideo_h
DECL|macro|usbvideo_h
mdefine_line|#define&t;usbvideo_h
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/videodev.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
multiline_comment|/* Most helpful debugging aid */
DECL|macro|assert
mdefine_line|#define assert(expr) ((void) ((expr) ? 0 : (err(&quot;assert failed at line %d&quot;,__LINE__))))
DECL|macro|USBVIDEO_REPORT_STATS
mdefine_line|#define USBVIDEO_REPORT_STATS&t;1&t;/* Set to 0 to block statistics on close */
multiline_comment|/* Bit flags (options) */
DECL|macro|FLAGS_RETRY_VIDIOCSYNC
mdefine_line|#define FLAGS_RETRY_VIDIOCSYNC&t;&t;(1 &lt;&lt; 0)
DECL|macro|FLAGS_MONOCHROME
mdefine_line|#define&t;FLAGS_MONOCHROME&t;&t;(1 &lt;&lt; 1)
DECL|macro|FLAGS_DISPLAY_HINTS
mdefine_line|#define FLAGS_DISPLAY_HINTS&t;&t;(1 &lt;&lt; 2)
DECL|macro|FLAGS_OVERLAY_STATS
mdefine_line|#define FLAGS_OVERLAY_STATS&t;&t;(1 &lt;&lt; 3)
DECL|macro|FLAGS_FORCE_TESTPATTERN
mdefine_line|#define FLAGS_FORCE_TESTPATTERN&t;&t;(1 &lt;&lt; 4)
DECL|macro|FLAGS_SEPARATE_FRAMES
mdefine_line|#define FLAGS_SEPARATE_FRAMES&t;&t;(1 &lt;&lt; 5)
DECL|macro|FLAGS_CLEAN_FRAMES
mdefine_line|#define FLAGS_CLEAN_FRAMES&t;&t;(1 &lt;&lt; 6)
DECL|macro|FLAGS_NO_DECODING
mdefine_line|#define&t;FLAGS_NO_DECODING&t;&t;(1 &lt;&lt; 7)
multiline_comment|/* Bit flags for frames (apply to the frame where they are specified) */
DECL|macro|USBVIDEO_FRAME_FLAG_SOFTWARE_CONTRAST
mdefine_line|#define USBVIDEO_FRAME_FLAG_SOFTWARE_CONTRAST&t;(1 &lt;&lt; 0)
multiline_comment|/* Camera capabilities (maximum) */
DECL|macro|CAMERA_URB_FRAMES
mdefine_line|#define CAMERA_URB_FRAMES       32
DECL|macro|CAMERA_MAX_ISO_PACKET
mdefine_line|#define CAMERA_MAX_ISO_PACKET   1023 /* 1022 actually sent by camera */
DECL|macro|FRAMES_PER_DESC
mdefine_line|#define FRAMES_PER_DESC&t;&t;(CAMERA_URB_FRAMES)
DECL|macro|FRAME_SIZE_PER_DESC
mdefine_line|#define FRAME_SIZE_PER_DESC&t;(CAMERA_MAX_ISO_PACKET)
multiline_comment|/* This macro restricts an int variable to an inclusive range */
DECL|macro|RESTRICT_TO_RANGE
mdefine_line|#define RESTRICT_TO_RANGE(v,mi,ma) { if ((v) &lt; (mi)) (v) = (mi); else if ((v) &gt; (ma)) (v) = (ma); }
DECL|macro|V4L_BYTES_PER_PIXEL
mdefine_line|#define V4L_BYTES_PER_PIXEL     3&t;/* Because we produce RGB24 */
multiline_comment|/*&n; * Use this macro to construct constants for different video sizes.&n; * We have to deal with different video sizes that have to be&n; * configured in the device or compared against when we receive&n; * a data. Normally one would define a bunch of VIDEOSIZE_x_by_y&n; * #defines and that&squot;s the end of story. However this solution&n; * does not allow to convert between real pixel sizes and the&n; * constant (integer) value that may be used to tag a frame or&n; * whatever. The set of macros below constructs videosize constants&n; * from the pixel size and allows to reconstruct the pixel size&n; * from the combined value later.&n; */
DECL|macro|VIDEOSIZE
mdefine_line|#define&t;VIDEOSIZE(x,y)&t;(((x) &amp; 0xFFFFL) | (((y) &amp; 0xFFFFL) &lt;&lt; 16))
DECL|macro|VIDEOSIZE_X
mdefine_line|#define&t;VIDEOSIZE_X(vs)&t;((vs) &amp; 0xFFFFL)
DECL|macro|VIDEOSIZE_Y
mdefine_line|#define&t;VIDEOSIZE_Y(vs)&t;(((vs) &gt;&gt; 16) &amp; 0xFFFFL)
DECL|typedef|videosize_t
r_typedef
r_int
r_int
id|videosize_t
suffix:semicolon
multiline_comment|/*&n; * This macro checks if the camera is still operational. The &squot;uvd&squot;&n; * pointer must be valid, uvd-&gt;dev must be valid, we are not&n; * removing the device and the device has not erred on us.&n; */
DECL|macro|CAMERA_IS_OPERATIONAL
mdefine_line|#define CAMERA_IS_OPERATIONAL(uvd) (&bslash;&n;&t;(uvd != NULL) &amp;&amp; &bslash;&n;&t;((uvd)-&gt;dev != NULL) &amp;&amp; &bslash;&n;&t;((uvd)-&gt;last_error == 0) &amp;&amp; &bslash;&n;&t;(!(uvd)-&gt;remove_pending))
multiline_comment|/*&n; * We use macros to do YUV -&gt; RGB conversion because this is&n; * very important for speed and totally unimportant for size.&n; *&n; * YUV -&gt; RGB Conversion&n; * ---------------------&n; *&n; * B = 1.164*(Y-16)&t;&t;    + 2.018*(V-128)&n; * G = 1.164*(Y-16) - 0.813*(U-128) - 0.391*(V-128)&n; * R = 1.164*(Y-16) + 1.596*(U-128)&n; *&n; * If you fancy integer arithmetics (as you should), hear this:&n; *&n; * 65536*B = 76284*(Y-16)&t;&t;  + 132252*(V-128)&n; * 65536*G = 76284*(Y-16) -  53281*(U-128) -  25625*(V-128)&n; * 65536*R = 76284*(Y-16) + 104595*(U-128)&n; *&n; * Make sure the output values are within [0..255] range.&n; */
DECL|macro|LIMIT_RGB
mdefine_line|#define LIMIT_RGB(x) (((x) &lt; 0) ? 0 : (((x) &gt; 255) ? 255 : (x)))
DECL|macro|YUV_TO_RGB_BY_THE_BOOK
mdefine_line|#define YUV_TO_RGB_BY_THE_BOOK(my,mu,mv,mr,mg,mb) { &bslash;&n;    int mm_y, mm_yc, mm_u, mm_v, mm_r, mm_g, mm_b; &bslash;&n;    mm_y = (my) - 16;  &bslash;&n;    mm_u = (mu) - 128; &bslash;&n;    mm_v = (mv) - 128; &bslash;&n;    mm_yc= mm_y * 76284; &bslash;&n;    mm_b = (mm_yc&t;&t;+ 132252*mm_v&t;) &gt;&gt; 16; &bslash;&n;    mm_g = (mm_yc -  53281*mm_u -  25625*mm_v&t;) &gt;&gt; 16; &bslash;&n;    mm_r = (mm_yc + 104595*mm_u&t;&t;&t;) &gt;&gt; 16; &bslash;&n;    mb = LIMIT_RGB(mm_b); &bslash;&n;    mg = LIMIT_RGB(mm_g); &bslash;&n;    mr = LIMIT_RGB(mm_r); &bslash;&n;}
DECL|macro|RING_QUEUE_SIZE
mdefine_line|#define&t;RING_QUEUE_SIZE&t;&t;(128*1024)&t;/* Must be a power of 2 */
DECL|macro|RING_QUEUE_ADVANCE_INDEX
mdefine_line|#define&t;RING_QUEUE_ADVANCE_INDEX(rq,ind,n) (rq)-&gt;ind = ((rq)-&gt;ind + (n)) &amp; ((rq)-&gt;length-1)
DECL|macro|RING_QUEUE_DEQUEUE_BYTES
mdefine_line|#define&t;RING_QUEUE_DEQUEUE_BYTES(rq,n) RING_QUEUE_ADVANCE_INDEX(rq,ri,n)
DECL|macro|RING_QUEUE_PEEK
mdefine_line|#define&t;RING_QUEUE_PEEK(rq,ofs) ((rq)-&gt;queue[((ofs) + (rq)-&gt;ri) &amp; ((rq)-&gt;length-1)])
DECL|struct|RingQueue
r_struct
id|RingQueue
(brace
DECL|member|queue
r_int
r_char
op_star
id|queue
suffix:semicolon
multiline_comment|/* Data from the Isoc data pump */
DECL|member|length
r_int
id|length
suffix:semicolon
multiline_comment|/* How many bytes allocated for the queue */
DECL|member|wi
r_int
id|wi
suffix:semicolon
multiline_comment|/* That&squot;s where we write */
DECL|member|ri
r_int
id|ri
suffix:semicolon
multiline_comment|/* Read from here until you hit write index */
DECL|member|wqh
id|wait_queue_head_t
id|wqh
suffix:semicolon
multiline_comment|/* Processes waiting */
)brace
suffix:semicolon
DECL|enum|ScanState
r_enum
id|ScanState
(brace
DECL|enumerator|ScanState_Scanning
id|ScanState_Scanning
comma
multiline_comment|/* Scanning for header */
DECL|enumerator|ScanState_Lines
id|ScanState_Lines
multiline_comment|/* Parsing lines */
)brace
suffix:semicolon
multiline_comment|/* Completion states of the data parser */
DECL|enum|ParseState
r_enum
id|ParseState
(brace
DECL|enumerator|scan_Continue
id|scan_Continue
comma
multiline_comment|/* Just parse next item */
DECL|enumerator|scan_NextFrame
id|scan_NextFrame
comma
multiline_comment|/* Frame done, send it to V4L */
DECL|enumerator|scan_Out
id|scan_Out
comma
multiline_comment|/* Not enough data for frame */
DECL|enumerator|scan_EndParse
id|scan_EndParse
multiline_comment|/* End parsing */
)brace
suffix:semicolon
DECL|enum|FrameState
r_enum
id|FrameState
(brace
DECL|enumerator|FrameState_Unused
id|FrameState_Unused
comma
multiline_comment|/* Unused (no MCAPTURE) */
DECL|enumerator|FrameState_Ready
id|FrameState_Ready
comma
multiline_comment|/* Ready to start grabbing */
DECL|enumerator|FrameState_Grabbing
id|FrameState_Grabbing
comma
multiline_comment|/* In the process of being grabbed into */
DECL|enumerator|FrameState_Done
id|FrameState_Done
comma
multiline_comment|/* Finished grabbing, but not been synced yet */
DECL|enumerator|FrameState_Done_Hold
id|FrameState_Done_Hold
comma
multiline_comment|/* Are syncing or reading */
DECL|enumerator|FrameState_Error
id|FrameState_Error
comma
multiline_comment|/* Something bad happened while processing */
)brace
suffix:semicolon
multiline_comment|/*&n; * Some frames may contain only even or odd lines. This type&n; * specifies what type of deinterlacing is required.&n; */
DECL|enum|Deinterlace
r_enum
id|Deinterlace
(brace
DECL|enumerator|Deinterlace_None
id|Deinterlace_None
op_assign
l_int|0
comma
DECL|enumerator|Deinterlace_FillOddLines
id|Deinterlace_FillOddLines
comma
DECL|enumerator|Deinterlace_FillEvenLines
id|Deinterlace_FillEvenLines
)brace
suffix:semicolon
DECL|macro|USBVIDEO_NUMFRAMES
mdefine_line|#define USBVIDEO_NUMFRAMES&t;2&t;/* How many frames we work with */
DECL|macro|USBVIDEO_NUMSBUF
mdefine_line|#define USBVIDEO_NUMSBUF&t;2&t;/* How many URBs linked in a ring */
multiline_comment|/* This structure represents one Isoc request - URB and buffer */
DECL|struct|usbvideo_sbuf
r_struct
id|usbvideo_sbuf
(brace
DECL|member|data
r_char
op_star
id|data
suffix:semicolon
DECL|member|urb
r_struct
id|urb
op_star
id|urb
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|usbvideo_frame
r_struct
id|usbvideo_frame
(brace
DECL|member|data
r_char
op_star
id|data
suffix:semicolon
multiline_comment|/* Frame buffer */
DECL|member|header
r_int
r_int
id|header
suffix:semicolon
multiline_comment|/* Significant bits from the header */
DECL|member|canvas
id|videosize_t
id|canvas
suffix:semicolon
multiline_comment|/* The canvas (max. image) allocated */
DECL|member|request
id|videosize_t
id|request
suffix:semicolon
multiline_comment|/* That&squot;s what the application asked for */
DECL|member|palette
r_int
r_int
id|palette
suffix:semicolon
multiline_comment|/* The desired format */
DECL|member|frameState
r_enum
id|FrameState
id|frameState
suffix:semicolon
multiline_comment|/* State of grabbing */
DECL|member|scanstate
r_enum
id|ScanState
id|scanstate
suffix:semicolon
multiline_comment|/* State of scanning */
DECL|member|deinterlace
r_enum
id|Deinterlace
id|deinterlace
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* USBVIDEO_FRAME_FLAG_xxx bit flags */
DECL|member|curline
r_int
id|curline
suffix:semicolon
multiline_comment|/* Line of frame we&squot;re working on */
DECL|member|seqRead_Length
r_int
id|seqRead_Length
suffix:semicolon
multiline_comment|/* Raw data length of frame */
DECL|member|seqRead_Index
r_int
id|seqRead_Index
suffix:semicolon
multiline_comment|/* Amount of data that has been already read */
DECL|member|user
r_void
op_star
id|user
suffix:semicolon
multiline_comment|/* Additional data that user may need */
)brace
suffix:semicolon
multiline_comment|/* Statistics that can be overlaid on screen */
DECL|struct|usbvideo_statistics
r_struct
id|usbvideo_statistics
(brace
DECL|member|frame_num
r_int
r_int
id|frame_num
suffix:semicolon
multiline_comment|/* Sequential number of the frame */
DECL|member|urb_count
r_int
r_int
id|urb_count
suffix:semicolon
multiline_comment|/* How many URBs we received so far */
DECL|member|urb_length
r_int
r_int
id|urb_length
suffix:semicolon
multiline_comment|/* Length of last URB */
DECL|member|data_count
r_int
r_int
id|data_count
suffix:semicolon
multiline_comment|/* How many bytes we received */
DECL|member|header_count
r_int
r_int
id|header_count
suffix:semicolon
multiline_comment|/* How many frame headers we found */
DECL|member|iso_skip_count
r_int
r_int
id|iso_skip_count
suffix:semicolon
multiline_comment|/* How many empty ISO packets received */
DECL|member|iso_err_count
r_int
r_int
id|iso_err_count
suffix:semicolon
multiline_comment|/* How many bad ISO packets received */
)brace
suffix:semicolon
r_struct
id|usbvideo
suffix:semicolon
DECL|struct|uvd
r_struct
id|uvd
(brace
DECL|member|vdev
r_struct
id|video_device
id|vdev
suffix:semicolon
multiline_comment|/* Must be the first field! */
DECL|member|dev
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
DECL|member|handle
r_struct
id|usbvideo
op_star
id|handle
suffix:semicolon
multiline_comment|/* Points back to the struct usbvideo */
DECL|member|user_data
r_void
op_star
id|user_data
suffix:semicolon
multiline_comment|/* Camera-dependent data */
DECL|member|user_size
r_int
id|user_size
suffix:semicolon
multiline_comment|/* Size of that camera-dependent data */
DECL|member|debug
r_int
id|debug
suffix:semicolon
multiline_comment|/* Debug level for usbvideo */
DECL|member|iface
r_int
r_char
id|iface
suffix:semicolon
multiline_comment|/* Video interface number */
DECL|member|video_endp
r_int
r_char
id|video_endp
suffix:semicolon
DECL|member|ifaceAltActive
r_int
r_char
id|ifaceAltActive
suffix:semicolon
DECL|member|ifaceAltInactive
r_int
r_char
id|ifaceAltInactive
suffix:semicolon
multiline_comment|/* Alt settings */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* FLAGS_USBVIDEO_xxx */
DECL|member|paletteBits
r_int
r_int
id|paletteBits
suffix:semicolon
multiline_comment|/* Which palettes we accept? */
DECL|member|defaultPalette
r_int
r_int
id|defaultPalette
suffix:semicolon
multiline_comment|/* What palette to use for read() */
DECL|member|lock
r_struct
id|semaphore
id|lock
suffix:semicolon
DECL|member|user
r_int
id|user
suffix:semicolon
multiline_comment|/* user count for exclusive use */
DECL|member|videosize
id|videosize_t
id|videosize
suffix:semicolon
multiline_comment|/* Current setting */
DECL|member|canvas
id|videosize_t
id|canvas
suffix:semicolon
multiline_comment|/* This is the width,height of the V4L canvas */
DECL|member|max_frame_size
r_int
id|max_frame_size
suffix:semicolon
multiline_comment|/* Bytes in one video frame */
DECL|member|uvd_used
r_int
id|uvd_used
suffix:semicolon
multiline_comment|/* Is this structure in use? */
DECL|member|streaming
r_int
id|streaming
suffix:semicolon
multiline_comment|/* Are we streaming Isochronous? */
DECL|member|grabbing
r_int
id|grabbing
suffix:semicolon
multiline_comment|/* Are we grabbing? */
DECL|member|settingsAdjusted
r_int
id|settingsAdjusted
suffix:semicolon
multiline_comment|/* Have we adjusted contrast etc.? */
DECL|member|last_error
r_int
id|last_error
suffix:semicolon
multiline_comment|/* What calamity struck us? */
DECL|member|fbuf
r_char
op_star
id|fbuf
suffix:semicolon
multiline_comment|/* Videodev buffer area */
DECL|member|fbuf_size
r_int
id|fbuf_size
suffix:semicolon
multiline_comment|/* Videodev buffer size */
DECL|member|curframe
r_int
id|curframe
suffix:semicolon
DECL|member|iso_packet_len
r_int
id|iso_packet_len
suffix:semicolon
multiline_comment|/* Videomode-dependent, saves bus bandwidth */
DECL|member|dp
r_struct
id|RingQueue
id|dp
suffix:semicolon
multiline_comment|/* Isoc data pump */
DECL|member|frame
r_struct
id|usbvideo_frame
id|frame
(braket
id|USBVIDEO_NUMFRAMES
)braket
suffix:semicolon
DECL|member|sbuf
r_struct
id|usbvideo_sbuf
id|sbuf
(braket
id|USBVIDEO_NUMSBUF
)braket
suffix:semicolon
DECL|member|remove_pending
r_volatile
r_int
id|remove_pending
suffix:semicolon
multiline_comment|/* If set then about to exit */
DECL|member|vpic
DECL|member|vpic_old
r_struct
id|video_picture
id|vpic
comma
id|vpic_old
suffix:semicolon
multiline_comment|/* Picture settings */
DECL|member|vcap
r_struct
id|video_capability
id|vcap
suffix:semicolon
multiline_comment|/* Video capabilities */
DECL|member|vchan
r_struct
id|video_channel
id|vchan
suffix:semicolon
multiline_comment|/* May be used for tuner support */
DECL|member|stats
r_struct
id|usbvideo_statistics
id|stats
suffix:semicolon
DECL|member|videoName
r_char
id|videoName
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* Holds name like &quot;video7&quot; */
)brace
suffix:semicolon
multiline_comment|/*&n; * usbvideo callbacks (virtual methods). They are set when usbvideo&n; * services are registered. All of these default to NULL, except those&n; * that default to usbvideo-provided methods.&n; */
DECL|struct|usbvideo_cb
r_struct
id|usbvideo_cb
(brace
DECL|member|probe
r_int
(paren
op_star
id|probe
)paren
(paren
r_struct
id|usb_interface
op_star
comma
r_const
r_struct
id|usb_device_id
op_star
)paren
suffix:semicolon
DECL|member|userFree
r_void
(paren
op_star
id|userFree
)paren
(paren
r_struct
id|uvd
op_star
)paren
suffix:semicolon
DECL|member|disconnect
r_void
(paren
op_star
id|disconnect
)paren
(paren
r_struct
id|usb_interface
op_star
)paren
suffix:semicolon
DECL|member|setupOnOpen
r_int
(paren
op_star
id|setupOnOpen
)paren
(paren
r_struct
id|uvd
op_star
)paren
suffix:semicolon
DECL|member|videoStart
r_void
(paren
op_star
id|videoStart
)paren
(paren
r_struct
id|uvd
op_star
)paren
suffix:semicolon
DECL|member|videoStop
r_void
(paren
op_star
id|videoStop
)paren
(paren
r_struct
id|uvd
op_star
)paren
suffix:semicolon
DECL|member|processData
r_void
(paren
op_star
id|processData
)paren
(paren
r_struct
id|uvd
op_star
comma
r_struct
id|usbvideo_frame
op_star
)paren
suffix:semicolon
DECL|member|postProcess
r_void
(paren
op_star
id|postProcess
)paren
(paren
r_struct
id|uvd
op_star
comma
r_struct
id|usbvideo_frame
op_star
)paren
suffix:semicolon
DECL|member|adjustPicture
r_void
(paren
op_star
id|adjustPicture
)paren
(paren
r_struct
id|uvd
op_star
)paren
suffix:semicolon
DECL|member|getFPS
r_int
(paren
op_star
id|getFPS
)paren
(paren
r_struct
id|uvd
op_star
)paren
suffix:semicolon
DECL|member|overlayHook
r_int
(paren
op_star
id|overlayHook
)paren
(paren
r_struct
id|uvd
op_star
comma
r_struct
id|usbvideo_frame
op_star
)paren
suffix:semicolon
DECL|member|getFrame
r_int
(paren
op_star
id|getFrame
)paren
(paren
r_struct
id|uvd
op_star
comma
r_int
)paren
suffix:semicolon
DECL|member|startDataPump
r_int
(paren
op_star
id|startDataPump
)paren
(paren
r_struct
id|uvd
op_star
id|uvd
)paren
suffix:semicolon
DECL|member|stopDataPump
r_void
(paren
op_star
id|stopDataPump
)paren
(paren
r_struct
id|uvd
op_star
id|uvd
)paren
suffix:semicolon
DECL|member|setVideoMode
r_int
(paren
op_star
id|setVideoMode
)paren
(paren
r_struct
id|uvd
op_star
id|uvd
comma
r_struct
id|video_window
op_star
id|vw
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|usbvideo
r_struct
id|usbvideo
(brace
DECL|member|num_cameras
r_int
id|num_cameras
suffix:semicolon
multiline_comment|/* As allocated */
DECL|member|usbdrv
r_struct
id|usb_driver
id|usbdrv
suffix:semicolon
multiline_comment|/* Interface to the USB stack */
DECL|member|drvName
r_char
id|drvName
(braket
l_int|80
)braket
suffix:semicolon
multiline_comment|/* Driver name */
DECL|member|lock
r_struct
id|semaphore
id|lock
suffix:semicolon
multiline_comment|/* Mutex protecting camera structures */
DECL|member|cb
r_struct
id|usbvideo_cb
id|cb
suffix:semicolon
multiline_comment|/* Table of callbacks (virtual methods) */
DECL|member|vdt
r_struct
id|video_device
id|vdt
suffix:semicolon
multiline_comment|/* Video device template */
DECL|member|cam
r_struct
id|uvd
op_star
id|cam
suffix:semicolon
multiline_comment|/* Array of camera structures */
DECL|member|md_module
r_struct
id|module
op_star
id|md_module
suffix:semicolon
multiline_comment|/* Minidriver module */
)brace
suffix:semicolon
multiline_comment|/*&n; * This macro retrieves callback address from the struct uvd object.&n; * No validity checks are done here, so be sure to check the&n; * callback beforehand with VALID_CALLBACK.&n; */
DECL|macro|GET_CALLBACK
mdefine_line|#define&t;GET_CALLBACK(uvd,cbName) ((uvd)-&gt;handle-&gt;cb.cbName)
multiline_comment|/*&n; * This macro returns either callback pointer or NULL. This is safe&n; * macro, meaning that most of components of data structures involved&n; * may be NULL - this only results in NULL being returned. You may&n; * wish to use this macro to make sure that the callback is callable.&n; * However keep in mind that those checks take time.&n; */
DECL|macro|VALID_CALLBACK
mdefine_line|#define&t;VALID_CALLBACK(uvd,cbName) ((((uvd) != NULL) &amp;&amp; &bslash;&n;&t;&t;((uvd)-&gt;handle != NULL)) ? GET_CALLBACK(uvd,cbName) : NULL)
r_int
id|RingQueue_Dequeue
c_func
(paren
r_struct
id|RingQueue
op_star
id|rq
comma
r_int
r_char
op_star
id|dst
comma
r_int
id|len
)paren
suffix:semicolon
r_int
id|RingQueue_Enqueue
c_func
(paren
r_struct
id|RingQueue
op_star
id|rq
comma
r_const
r_int
r_char
op_star
id|cdata
comma
r_int
id|n
)paren
suffix:semicolon
r_void
id|RingQueue_WakeUpInterruptible
c_func
(paren
r_struct
id|RingQueue
op_star
id|rq
)paren
suffix:semicolon
r_void
id|RingQueue_Flush
c_func
(paren
r_struct
id|RingQueue
op_star
id|rq
)paren
suffix:semicolon
DECL|function|RingQueue_GetLength
r_static
r_inline
r_int
id|RingQueue_GetLength
c_func
(paren
r_const
r_struct
id|RingQueue
op_star
id|rq
)paren
(brace
r_return
(paren
id|rq-&gt;wi
op_minus
id|rq-&gt;ri
op_plus
id|rq-&gt;length
)paren
op_amp
(paren
id|rq-&gt;length
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|RingQueue_GetFreeSpace
r_static
r_inline
r_int
id|RingQueue_GetFreeSpace
c_func
(paren
r_const
r_struct
id|RingQueue
op_star
id|rq
)paren
(brace
r_return
id|rq-&gt;length
op_minus
id|RingQueue_GetLength
c_func
(paren
id|rq
)paren
suffix:semicolon
)brace
r_void
id|usbvideo_DrawLine
c_func
(paren
r_struct
id|usbvideo_frame
op_star
id|frame
comma
r_int
id|x1
comma
r_int
id|y1
comma
r_int
id|x2
comma
r_int
id|y2
comma
r_int
r_char
id|cr
comma
r_int
r_char
id|cg
comma
r_int
r_char
id|cb
)paren
suffix:semicolon
r_void
id|usbvideo_HexDump
c_func
(paren
r_const
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
suffix:semicolon
r_void
id|usbvideo_SayAndWait
c_func
(paren
r_const
r_char
op_star
id|what
)paren
suffix:semicolon
r_void
id|usbvideo_TestPattern
c_func
(paren
r_struct
id|uvd
op_star
id|uvd
comma
r_int
id|fullframe
comma
r_int
id|pmode
)paren
suffix:semicolon
multiline_comment|/* Memory allocation routines */
r_int
r_int
id|usbvideo_kvirt_to_pa
c_func
(paren
r_int
r_int
id|adr
)paren
suffix:semicolon
r_int
id|usbvideo_register
c_func
(paren
r_struct
id|usbvideo
op_star
op_star
id|pCams
comma
r_const
r_int
id|num_cams
comma
r_const
r_int
id|num_extra
comma
r_const
r_char
op_star
id|driverName
comma
r_const
r_struct
id|usbvideo_cb
op_star
id|cbTable
comma
r_struct
id|module
op_star
id|md
comma
r_const
r_struct
id|usb_device_id
op_star
id|id_table
)paren
suffix:semicolon
r_struct
id|uvd
op_star
id|usbvideo_AllocateDevice
c_func
(paren
r_struct
id|usbvideo
op_star
id|cams
)paren
suffix:semicolon
r_int
id|usbvideo_RegisterVideoDevice
c_func
(paren
r_struct
id|uvd
op_star
id|uvd
)paren
suffix:semicolon
r_void
id|usbvideo_Deregister
c_func
(paren
r_struct
id|usbvideo
op_star
op_star
id|uvt
)paren
suffix:semicolon
r_int
id|usbvideo_v4l_initialize
c_func
(paren
r_struct
id|video_device
op_star
id|dev
)paren
suffix:semicolon
r_void
id|usbvideo_DeinterlaceFrame
c_func
(paren
r_struct
id|uvd
op_star
id|uvd
comma
r_struct
id|usbvideo_frame
op_star
id|frame
)paren
suffix:semicolon
multiline_comment|/*&n; * This code performs bounds checking - use it when working with&n; * new formats, or else you may get oopses all over the place.&n; * If pixel falls out of bounds then it gets shoved back (as close&n; * to place of offence as possible) and is painted bright red.&n; *&n; * There are two important concepts: frame width, height and&n; * V4L canvas width, height. The former is the area requested by&n; * the application -for this very frame-. The latter is the largest&n; * possible frame that we can serve (we advertise that via V4L ioctl).&n; * The frame data is expected to be formatted as lines of length&n; * VIDEOSIZE_X(fr-&gt;request), total VIDEOSIZE_Y(frame-&gt;request) lines.&n; */
DECL|function|RGB24_PUTPIXEL
r_static
r_inline
r_void
id|RGB24_PUTPIXEL
c_func
(paren
r_struct
id|usbvideo_frame
op_star
id|fr
comma
r_int
id|ix
comma
r_int
id|iy
comma
r_int
r_char
id|vr
comma
r_int
r_char
id|vg
comma
r_int
r_char
id|vb
)paren
(brace
r_register
r_int
r_char
op_star
id|pf
suffix:semicolon
r_int
id|limiter
op_assign
l_int|0
comma
id|mx
comma
id|my
suffix:semicolon
id|mx
op_assign
id|ix
suffix:semicolon
id|my
op_assign
id|iy
suffix:semicolon
r_if
c_cond
(paren
id|mx
OL
l_int|0
)paren
(brace
id|mx
op_assign
l_int|0
suffix:semicolon
id|limiter
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mx
op_ge
id|VIDEOSIZE_X
c_func
(paren
(paren
id|fr
)paren
op_member_access_from_pointer
id|request
)paren
)paren
(brace
id|mx
op_assign
id|VIDEOSIZE_X
c_func
(paren
(paren
id|fr
)paren
op_member_access_from_pointer
id|request
)paren
op_minus
l_int|1
suffix:semicolon
id|limiter
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|my
OL
l_int|0
)paren
(brace
id|my
op_assign
l_int|0
suffix:semicolon
id|limiter
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|my
op_ge
id|VIDEOSIZE_Y
c_func
(paren
(paren
id|fr
)paren
op_member_access_from_pointer
id|request
)paren
)paren
(brace
id|my
op_assign
id|VIDEOSIZE_Y
c_func
(paren
(paren
id|fr
)paren
op_member_access_from_pointer
id|request
)paren
op_minus
l_int|1
suffix:semicolon
id|limiter
op_increment
suffix:semicolon
)brace
id|pf
op_assign
(paren
id|fr
)paren
op_member_access_from_pointer
id|data
op_plus
id|V4L_BYTES_PER_PIXEL
op_star
(paren
(paren
id|iy
)paren
op_star
id|VIDEOSIZE_X
c_func
(paren
(paren
id|fr
)paren
op_member_access_from_pointer
id|request
)paren
op_plus
(paren
id|ix
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|limiter
)paren
(brace
op_star
id|pf
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|pf
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|pf
op_increment
op_assign
l_int|0xFF
suffix:semicolon
)brace
r_else
(brace
op_star
id|pf
op_increment
op_assign
(paren
id|vb
)paren
suffix:semicolon
op_star
id|pf
op_increment
op_assign
(paren
id|vg
)paren
suffix:semicolon
op_star
id|pf
op_increment
op_assign
(paren
id|vr
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* usbvideo_h */
eof
