multiline_comment|/*&n;   Colour conversion routines (RGB &lt;-&gt; YUV) in plain C, with viewport &n;   extension.&n;   (C) 2001 Nemosoft Unv.    nemosoft@smcc.demon.nl&n;   &n;   This program is free software; you can redistribute it and/or modify&n;   it under the terms of the GNU General Public License as published by&n;   the Free Software Foundation; either version 2 of the License, or&n;   (at your option) any later version.&n;&n;   This program is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;   GNU General Public License for more details.&n;&n;   You should have received a copy of the GNU General Public License&n;   along with this program; if not, write to the Free Software&n;   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n;*/
multiline_comment|/* Colour conversion routines that use a viewport. See the assembly code/.h&n;   files for more information.&n;&n;   If you are always converting images where the image- and viewport size&n;   is the same, you can hack out the &squot;plus&squot; variable and delete the &n;   offset calculation at the bottom of every for(line) {} loop. Otherwise,&n;   just call the functions with plus = width.&n;   &n;   NB: for these function, the YUV420 format is defined as:&n;   even lines:  YYYY UU YYYY UU YYYY ..&n;   odd lines:   YYYY VV YYYY VV YYYY ..&n;*/
macro_line|#include &quot;vcvt.h&quot;
DECL|macro|PUSH_RGB24
mdefine_line|#define PUSH_RGB24&t;1
DECL|macro|PUSH_BGR24
mdefine_line|#define PUSH_BGR24&t;2
DECL|macro|PUSH_RGB32
mdefine_line|#define PUSH_RGB32&t;3
DECL|macro|PUSH_BGR32
mdefine_line|#define PUSH_BGR32&t;4
multiline_comment|/**&n;  &bslash;brief convert YUV 4:2:0 data into RGB, BGR, RGBa or BGRa&n;  &bslash;param width Width of yuv data, in pixels&n;  &bslash;param height Height of yuv data, in pixels&n;  &bslash;param plus Width of viewport, in pixels&n;  &bslash;param src beginning of YUV data&n;  &bslash;param dst beginning of RGB data, &bslash;b including the initial offset into the viewport&n;  &bslash;param push The requested RGB format &n;&n;  &bslash;e push can be any of PUSH_RGB24, PUSH_BGR24, PUSH_RGB32 or PUSH_BGR32&n;  &n; This is a really simplistic approach. Speedups are welcomed. &n;*/
DECL|function|vcvt_420i
r_static
r_void
id|vcvt_420i
c_func
(paren
r_int
id|width
comma
r_int
id|height
comma
r_int
id|plus
comma
r_int
r_char
op_star
id|src
comma
r_int
r_char
op_star
id|dst
comma
r_int
id|push
)paren
(brace
r_int
id|line
comma
id|col
comma
id|linewidth
suffix:semicolon
r_int
id|y
comma
id|u
comma
id|v
comma
id|yy
comma
id|vr
op_assign
l_int|0
comma
id|ug
op_assign
l_int|0
comma
id|vg
op_assign
l_int|0
comma
id|ub
op_assign
l_int|0
suffix:semicolon
r_int
id|r
comma
id|g
comma
id|b
suffix:semicolon
r_int
r_char
op_star
id|sy
comma
op_star
id|su
comma
op_star
id|sv
suffix:semicolon
id|linewidth
op_assign
id|width
op_plus
(paren
id|width
op_rshift
l_int|1
)paren
suffix:semicolon
id|sy
op_assign
id|src
suffix:semicolon
id|su
op_assign
id|sy
op_plus
l_int|4
suffix:semicolon
id|sv
op_assign
id|su
op_plus
id|linewidth
suffix:semicolon
multiline_comment|/* The biggest problem is the interlaced data, and the fact that odd&n;&t;   add even lines have V and U data, resp. &n;&t; */
r_for
c_loop
(paren
id|line
op_assign
l_int|0
suffix:semicolon
id|line
OL
id|height
suffix:semicolon
id|line
op_increment
)paren
(brace
r_for
c_loop
(paren
id|col
op_assign
l_int|0
suffix:semicolon
id|col
OL
id|width
suffix:semicolon
id|col
op_increment
)paren
(brace
id|y
op_assign
op_star
id|sy
op_increment
suffix:semicolon
id|yy
op_assign
id|y
op_lshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|col
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* only at even colums we update the u/v data */
id|u
op_assign
op_star
id|su
op_minus
l_int|128
suffix:semicolon
id|ug
op_assign
l_int|88
op_star
id|u
suffix:semicolon
id|ub
op_assign
l_int|454
op_star
id|u
suffix:semicolon
id|v
op_assign
op_star
id|sv
op_minus
l_int|128
suffix:semicolon
id|vg
op_assign
l_int|183
op_star
id|v
suffix:semicolon
id|vr
op_assign
l_int|359
op_star
id|v
suffix:semicolon
id|su
op_increment
suffix:semicolon
id|sv
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|col
op_amp
l_int|3
)paren
op_eq
l_int|3
)paren
(brace
id|sy
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* skip u/v */
id|su
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* skip y */
id|sv
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* skip y */
)brace
id|r
op_assign
(paren
id|yy
op_plus
id|vr
)paren
op_rshift
l_int|8
suffix:semicolon
id|g
op_assign
(paren
id|yy
op_minus
id|ug
op_minus
id|vg
)paren
op_rshift
l_int|8
suffix:semicolon
id|b
op_assign
(paren
id|yy
op_plus
id|ub
)paren
op_rshift
l_int|8
suffix:semicolon
multiline_comment|/* At moments like this, you crave for MMX instructions with saturation */
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
id|r
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|255
)paren
id|r
op_assign
l_int|255
suffix:semicolon
r_if
c_cond
(paren
id|g
OL
l_int|0
)paren
id|g
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|g
OG
l_int|255
)paren
id|g
op_assign
l_int|255
suffix:semicolon
r_if
c_cond
(paren
id|b
OL
l_int|0
)paren
id|b
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|b
OG
l_int|255
)paren
id|b
op_assign
l_int|255
suffix:semicolon
r_switch
c_cond
(paren
id|push
)paren
(brace
r_case
id|PUSH_RGB24
suffix:colon
op_star
id|dst
op_increment
op_assign
id|r
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|g
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|b
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PUSH_BGR24
suffix:colon
op_star
id|dst
op_increment
op_assign
id|b
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|g
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|r
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PUSH_RGB32
suffix:colon
op_star
id|dst
op_increment
op_assign
id|r
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|g
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|b
suffix:semicolon
op_star
id|dst
op_increment
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PUSH_BGR32
suffix:colon
op_star
id|dst
op_increment
op_assign
id|b
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|g
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|r
suffix:semicolon
op_star
id|dst
op_increment
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* ..for col */
r_if
c_cond
(paren
id|line
op_amp
l_int|1
)paren
(brace
singleline_comment|// odd line: go to next band
id|su
op_add_assign
id|linewidth
suffix:semicolon
id|sv
op_add_assign
id|linewidth
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// rewind u/v pointers
id|su
op_sub_assign
id|linewidth
suffix:semicolon
id|sv
op_sub_assign
id|linewidth
suffix:semicolon
)brace
multiline_comment|/* Adjust destination pointer, using viewport. We have just&n;&t;&t;   filled one line worth of data, so only skip the difference&n;&t;&t;   between the view width and the image width.&n;&t;&t; */
r_if
c_cond
(paren
id|push
op_eq
id|PUSH_RGB24
op_logical_or
id|push
op_eq
id|PUSH_BGR24
)paren
id|dst
op_add_assign
(paren
(paren
id|plus
op_minus
id|width
)paren
op_star
l_int|3
)paren
suffix:semicolon
r_else
id|dst
op_add_assign
(paren
(paren
id|plus
op_minus
id|width
)paren
op_star
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* ..for line */
)brace
DECL|function|vcvt_420i_rgb24
r_void
id|vcvt_420i_rgb24
c_func
(paren
r_int
id|width
comma
r_int
id|height
comma
r_int
id|plus
comma
r_void
op_star
id|src
comma
r_void
op_star
id|dst
)paren
(brace
id|vcvt_420i
c_func
(paren
id|width
comma
id|height
comma
id|plus
comma
(paren
r_int
r_char
op_star
)paren
id|src
comma
(paren
r_int
r_char
op_star
)paren
id|dst
comma
id|PUSH_RGB24
)paren
suffix:semicolon
)brace
DECL|function|vcvt_420i_bgr24
r_void
id|vcvt_420i_bgr24
c_func
(paren
r_int
id|width
comma
r_int
id|height
comma
r_int
id|plus
comma
r_void
op_star
id|src
comma
r_void
op_star
id|dst
)paren
(brace
id|vcvt_420i
c_func
(paren
id|width
comma
id|height
comma
id|plus
comma
(paren
r_int
r_char
op_star
)paren
id|src
comma
(paren
r_int
r_char
op_star
)paren
id|dst
comma
id|PUSH_BGR24
)paren
suffix:semicolon
)brace
DECL|function|vcvt_420i_rgb32
r_void
id|vcvt_420i_rgb32
c_func
(paren
r_int
id|width
comma
r_int
id|height
comma
r_int
id|plus
comma
r_void
op_star
id|src
comma
r_void
op_star
id|dst
)paren
(brace
id|vcvt_420i
c_func
(paren
id|width
comma
id|height
comma
id|plus
comma
(paren
r_int
r_char
op_star
)paren
id|src
comma
(paren
r_int
r_char
op_star
)paren
id|dst
comma
id|PUSH_RGB32
)paren
suffix:semicolon
)brace
DECL|function|vcvt_420i_bgr32
r_void
id|vcvt_420i_bgr32
c_func
(paren
r_int
id|width
comma
r_int
id|height
comma
r_int
id|plus
comma
r_void
op_star
id|src
comma
r_void
op_star
id|dst
)paren
(brace
id|vcvt_420i
c_func
(paren
id|width
comma
id|height
comma
id|plus
comma
(paren
r_int
r_char
op_star
)paren
id|src
comma
(paren
r_int
r_char
op_star
)paren
id|dst
comma
id|PUSH_BGR32
)paren
suffix:semicolon
)brace
multiline_comment|/** &bslash;brief Convert from interlaces YUV 420 to planar format &n;*/
DECL|function|vcvt_420i_420p
r_void
id|vcvt_420i_420p
c_func
(paren
r_int
id|width
comma
r_int
id|height
comma
r_int
id|plus
comma
r_void
op_star
id|src
comma
r_void
op_star
id|dsty
comma
r_void
op_star
id|dstu
comma
r_void
op_star
id|dstv
)paren
(brace
r_int
op_star
id|s
comma
op_star
id|dy
comma
op_star
id|du
comma
op_star
id|dv
suffix:semicolon
r_int
id|line
comma
id|col
suffix:semicolon
id|s
op_assign
(paren
r_int
op_star
)paren
id|src
suffix:semicolon
id|dy
op_assign
(paren
r_int
op_star
)paren
id|dsty
suffix:semicolon
id|du
op_assign
(paren
r_int
op_star
)paren
id|dstu
suffix:semicolon
id|dv
op_assign
(paren
r_int
op_star
)paren
id|dstv
suffix:semicolon
r_for
c_loop
(paren
id|line
op_assign
l_int|0
suffix:semicolon
id|line
OL
id|height
suffix:semicolon
id|line
op_increment
)paren
(brace
r_for
c_loop
(paren
id|col
op_assign
l_int|0
suffix:semicolon
id|col
OL
id|width
suffix:semicolon
id|col
op_add_assign
l_int|4
)paren
(brace
op_star
id|dy
op_increment
op_assign
op_star
id|s
op_increment
suffix:semicolon
op_star
id|dy
op_increment
op_assign
op_star
id|s
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|line
op_amp
l_int|1
)paren
op_star
id|dv
op_increment
op_assign
op_star
id|s
op_increment
suffix:semicolon
r_else
op_star
id|du
op_increment
op_assign
op_star
id|s
op_increment
suffix:semicolon
)brace
multiline_comment|/* ..for col */
id|dy
op_add_assign
(paren
id|plus
op_minus
id|width
)paren
suffix:semicolon
id|dv
op_add_assign
(paren
(paren
id|plus
op_minus
id|width
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|du
op_add_assign
(paren
(paren
id|plus
op_minus
id|width
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* ..for line */
)brace
DECL|function|vcvt_420i_yuyv
r_void
id|vcvt_420i_yuyv
c_func
(paren
r_int
id|width
comma
r_int
id|height
comma
r_int
id|plus
comma
r_void
op_star
id|src
comma
r_void
op_star
id|dst
)paren
(brace
r_int
id|line
comma
id|col
comma
id|linewidth
suffix:semicolon
r_int
r_char
op_star
id|sy
comma
op_star
id|su
comma
op_star
id|sv
comma
op_star
id|d
suffix:semicolon
id|linewidth
op_assign
id|width
op_plus
(paren
id|width
op_rshift
l_int|1
)paren
suffix:semicolon
id|sy
op_assign
(paren
r_int
r_char
op_star
)paren
id|src
suffix:semicolon
id|su
op_assign
id|sy
op_plus
l_int|4
suffix:semicolon
id|sv
op_assign
id|su
op_plus
id|linewidth
suffix:semicolon
id|d
op_assign
(paren
r_int
r_char
op_star
)paren
id|dst
suffix:semicolon
r_for
c_loop
(paren
id|line
op_assign
l_int|0
suffix:semicolon
id|line
OL
id|height
suffix:semicolon
id|line
op_increment
)paren
(brace
r_for
c_loop
(paren
id|col
op_assign
l_int|0
suffix:semicolon
id|col
OL
id|width
suffix:semicolon
id|col
op_add_assign
l_int|4
)paren
(brace
multiline_comment|/* four pixels in one go */
op_star
id|d
op_increment
op_assign
op_star
id|sy
op_increment
suffix:semicolon
op_star
id|d
op_increment
op_assign
op_star
id|su
suffix:semicolon
op_star
id|d
op_increment
op_assign
op_star
id|sy
op_increment
suffix:semicolon
op_star
id|d
op_increment
op_assign
op_star
id|sv
suffix:semicolon
op_star
id|d
op_increment
op_assign
op_star
id|sy
op_increment
suffix:semicolon
op_star
id|d
op_increment
op_assign
op_star
id|su
op_increment
suffix:semicolon
op_star
id|d
op_increment
op_assign
op_star
id|sy
op_increment
suffix:semicolon
op_star
id|d
op_increment
op_assign
op_star
id|sv
op_increment
suffix:semicolon
id|sy
op_add_assign
l_int|2
suffix:semicolon
id|su
op_add_assign
l_int|4
suffix:semicolon
id|sv
op_add_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* ..for col */
r_if
c_cond
(paren
id|line
op_amp
l_int|1
)paren
(brace
singleline_comment|// odd line: go to next band
id|su
op_add_assign
id|linewidth
suffix:semicolon
id|sv
op_add_assign
id|linewidth
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// rewind u/v pointers
id|su
op_sub_assign
id|linewidth
suffix:semicolon
id|sv
op_sub_assign
id|linewidth
suffix:semicolon
)brace
multiline_comment|/* Adjust for viewport width */
id|d
op_add_assign
(paren
(paren
id|plus
op_minus
id|width
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* ..for line */
)brace
eof
